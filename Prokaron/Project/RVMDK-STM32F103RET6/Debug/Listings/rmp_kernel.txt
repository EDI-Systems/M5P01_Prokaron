; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\rmp_kernel.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\rmp_kernel.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F1_V1.6.0\Drivers\STM32F1xx_HAL_Driver\Inc -I..\..\..\M0P0_Library\STM32Cube_FW_F1_V1.6.0\Drivers\CMSIS\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F1_V1.6.0\Drivers\CMSIS\Device\ST\STM32F1xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F1_V1.6.0\Drivers\STM32F1xx_HAL_Driver\Inc\Conf -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F103RET6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F10X_HD -DUSE_HAL_DRIVER -DSTM32F103xE -W --enum_is_int --signed_chars --omf_browse=.\debug\output\rmp_kernel.crf ..\..\MProkaron\Kernel\rmp_kernel.c]
                          THUMB

                          AREA ||i.RMP_CRC16||, CODE, READONLY, ALIGN=2

                  RMP_CRC16 PROC
;;;279    #ifdef __RMP_U16_T__
;;;280    rmp_ptr_t RMP_CRC16(const rmp_u8_t* Data, rmp_ptr_t Length)
000000  b530              PUSH     {r4,r5,lr}
;;;281    {
000002  b0c1              SUB      sp,sp,#0x104
000004  460d              MOV      r5,r1
000006  4604              MOV      r4,r0
;;;282        rmp_ptr_t Data_Cnt;
;;;283        rmp_u8_t Index;
;;;284        rmp_u8_t Temp_High;
;;;285        rmp_u8_t Temp_Low;
;;;286        
;;;287        /* CRC16 constants with X^16+X^15+X^2+1 */
;;;288        static const rmp_u8_t CRC16_High[256]=
;;;289        {
;;;290            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;291            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;292            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;293            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;294            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;295            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;296            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;297            0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;298            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;299            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;300            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;301            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;302            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;303            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;304            0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;305            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;306            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;307            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;308            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;309            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;310            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;311            0x00, 0xC1, 0x81, 0x40
;;;312        };
;;;313    
;;;314        const rmp_u8_t CRC16_Low[256]=
000008  f44f7280          MOV      r2,#0x100
00000c  490c              LDR      r1,|L1.64|
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       __aeabi_memcpy4
;;;315        {
;;;316            0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7,
;;;317            0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E,
;;;318            0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9,
;;;319            0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC,
;;;320            0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
;;;321            0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32,
;;;322            0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D,
;;;323            0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38,
;;;324            0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF,
;;;325            0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
;;;326            0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1,
;;;327            0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4,
;;;328            0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB,
;;;329            0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA,
;;;330            0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
;;;331            0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0,
;;;332            0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97,
;;;333            0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E,
;;;334            0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89,
;;;335            0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
;;;336            0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83,
;;;337            0x41, 0x81, 0x80, 0x40
;;;338        };
;;;339    
;;;340        Temp_High=0xFF;
000014  23ff              MOVS     r3,#0xff
;;;341        Temp_Low=0xFF;
000016  461a              MOV      r2,r3
;;;342        for(Data_Cnt=0;Data_Cnt<Length;Data_Cnt++)
000018  2d00              CMP      r5,#0
00001a  bf1c              ITT      NE                    ;314
00001c  46ec              MOVNE    r12,sp                ;314
;;;343        {
;;;344            Index=Temp_Low^Data[Data_Cnt];
;;;345            Temp_Low=(rmp_u8_t)(Temp_High^CRC16_High[Index]);
00001e  4909              LDRNE    r1,|L1.68|
000020  d009              BEQ      |L1.54|
000022  bf00              NOP                            ;344
                  |L1.36|
000024  f8140b01          LDRB     r0,[r4],#1            ;344
000028  4050              EORS     r0,r0,r2              ;344
00002a  5c0a              LDRB     r2,[r1,r0]
00002c  405a              EORS     r2,r2,r3
;;;346            Temp_High=CRC16_Low[Index];
00002e  f81c3000          LDRB     r3,[r12,r0]
000032  1e6d              SUBS     r5,r5,#1
000034  d1f6              BNE      |L1.36|
                  |L1.54|
;;;347        }
;;;348    
;;;349        return (rmp_u16_t)(((rmp_u16_t)Temp_High)<<8|Temp_Low);
;;;350    }
000036  b041              ADD      sp,sp,#0x104
000038  ea422003          ORR      r0,r2,r3,LSL #8       ;349
00003c  bd30              POP      {r4,r5,pc}
;;;351    #endif
                          ENDP

00003e  0000              DCW      0x0000
                  |L1.64|
                          DCD      ||.constdata||+0x200
                  |L1.68|
                          DCD      ||.constdata||+0x100

                          AREA ||i.RMP_Clear||, CODE, READONLY, ALIGN=1

                  RMP_Clear PROC
;;;66     ******************************************************************************/
;;;67     void RMP_Clear(volatile void* Addr, rmp_ptr_t Size)
000000  2900              CMP      r1,#0
;;;68     {
;;;69         rmp_u8_t* Ptr;
;;;70         rmp_cnt_t Count;
;;;71        
;;;72         Ptr=(rmp_u8_t*)Addr;
;;;73         for(Count=0;Count<(rmp_cnt_t)Size;Count++)
;;;74             Ptr[Count]=0;
;;;75     }
000002  bfd8              IT       LE
000004  4770              BXLE     lr
000006  f0110f01          TST      r1,#1
00000a  f04f0200          MOV      r2,#0
00000e  f1a00001          SUB      r0,r0,#1
000012  bf18              IT       NE                    ;74
000014  f8002f01          STRBNE   r2,[r0,#1]!           ;74
000018  1049              ASRS     r1,r1,#1              ;73
00001a  bf08              IT       EQ
00001c  4770              BXEQ     lr
                  |L2.30|
00001e  7042              STRB     r2,[r0,#1]            ;74
000020  f8002f02          STRB     r2,[r0,#2]!           ;74
000024  1e49              SUBS     r1,r1,#1              ;74
000026  d1fa              BNE      |L2.30|
000028  4770              BX       lr
;;;76     /* End Function:RMP_Clear ****************************************************/
                          ENDP


                          AREA ||i.RMP_Free||, CODE, READONLY, ALIGN=1

                  RMP_Free PROC
;;;2517   ******************************************************************************/
;;;2518   void RMP_Free(volatile void* Pool, void* Mem_Ptr)
000000  2800              CMP      r0,#0
;;;2519   {
;;;2520       volatile struct RMP_Mem* Mem;
;;;2521       volatile struct RMP_Mem_Head* Mem_Head;
;;;2522       volatile struct RMP_Mem_Head* Left_Head;
;;;2523       volatile struct RMP_Mem_Head* Right_Head;
;;;2524       rmp_cnt_t Merge_Left;
;;;2525   
;;;2526       /* Check if pointer is null */
;;;2527       if((Pool==0)||(Mem_Ptr==0))
000002  bf1c              ITT      NE
000004  2900              CMPNE    r1,#0
;;;2528       {
;;;2529           RMP_COVERAGE_MARKER();
;;;2530           return;
;;;2531       }
;;;2532       else
;;;2533           RMP_COVERAGE_MARKER();
;;;2534       
;;;2535       /* See if the address is within the allocatable address range. If not, abort directly. */
;;;2536       Mem=(volatile struct RMP_Mem*)Pool;
;;;2537       if((((rmp_ptr_t)Mem_Ptr)<=((rmp_ptr_t)Mem))||(((rmp_ptr_t)Mem_Ptr)>=(((rmp_ptr_t)Mem)+Mem->Size)))
000006  4281              CMPNE    r1,r0
;;;2538       {
;;;2539           RMP_COVERAGE_MARKER();
;;;2540           return;
;;;2541       }
;;;2542       else
;;;2543           RMP_COVERAGE_MARKER();
;;;2544   
;;;2545       Mem_Head=(struct RMP_Mem_Head*)(((rmp_ptr_t)Mem_Ptr)-sizeof(struct RMP_Mem_Head));
;;;2546       /* See if the block can really be freed */
;;;2547       if(Mem_Head->State==RMP_MEM_FREE)
;;;2548       {
;;;2549           RMP_COVERAGE_MARKER();
;;;2550           return;
;;;2551       }
;;;2552       else
;;;2553           RMP_COVERAGE_MARKER();
;;;2554   
;;;2555       /* Mark it as free */
;;;2556       Mem_Head->State=RMP_MEM_FREE;
;;;2557       
;;;2558       /* Now check if we can merge it with the higher blocks */
;;;2559       Right_Head=(struct RMP_Mem_Head*)(((rmp_ptr_t)(Mem_Head->Tail))+sizeof(struct RMP_Mem_Tail));
;;;2560       if(((rmp_ptr_t)Right_Head)!=(((rmp_ptr_t)Mem)+Mem->Size))
;;;2561       {
;;;2562           RMP_COVERAGE_MARKER();
;;;2563           /* If this one is unoccupied */
;;;2564           if((Right_Head->State)==RMP_MEM_FREE)
;;;2565           {
;;;2566               RMP_COVERAGE_MARKER();
;;;2567               /* Delete, merge */
;;;2568               _RMP_Mem_Del(Pool,Right_Head);
;;;2569               _RMP_Mem_Block(Mem_Head,
;;;2570                              ((rmp_ptr_t)(Right_Head->Tail))+sizeof(struct RMP_Mem_Tail)-(rmp_ptr_t)Mem_Head);
;;;2571           }
;;;2572           else
;;;2573               RMP_COVERAGE_MARKER();
;;;2574       }
;;;2575       else
;;;2576           RMP_COVERAGE_MARKER();
;;;2577   
;;;2578       /* Now check if we can merge it with the lower blocks */
;;;2579       Merge_Left=0;
;;;2580       if((rmp_ptr_t)Mem_Head!=Mem->Start)
;;;2581       {
;;;2582           RMP_COVERAGE_MARKER();
;;;2583           Left_Head=((struct RMP_Mem_Tail*)(((rmp_ptr_t)Mem_Head)-sizeof(struct RMP_Mem_Tail)))->Head;
;;;2584   
;;;2585           /* If this one is unoccupied */
;;;2586           if(Left_Head->State==RMP_MEM_FREE)
;;;2587           {
;;;2588               RMP_COVERAGE_MARKER();
;;;2589               /* Delete, merge */
;;;2590               _RMP_Mem_Del(Pool, Left_Head);
;;;2591               _RMP_Mem_Block(Left_Head,
;;;2592                              (rmp_ptr_t)((rmp_ptr_t)(Mem_Head->Tail)+sizeof(struct RMP_Mem_Tail)-(rmp_ptr_t)Left_Head));
;;;2593   
;;;2594               /* We have completed the merge here and the original block has destroyed.
;;;2595                * Thus there's no need to insert it into the list again */
;;;2596               Merge_Left=1;
;;;2597           }
;;;2598           else
;;;2599               RMP_COVERAGE_MARKER();
;;;2600       }
;;;2601       else
;;;2602           RMP_COVERAGE_MARKER();
;;;2603   
;;;2604       /* If we did not merge it with the left-side blocks, insert the original pointer's block 
;;;2605        * into the TLSF table(Merging with the right-side one won't disturb this) */
;;;2606       if(Merge_Left==0)
;;;2607       {
;;;2608           RMP_COVERAGE_MARKER();
;;;2609           _RMP_Mem_Ins(Pool, Mem_Head);
;;;2610       }
;;;2611       else
;;;2612       {
;;;2613           RMP_COVERAGE_MARKER();
;;;2614           _RMP_Mem_Ins(Pool, Left_Head);
;;;2615       }
;;;2616   }
000008  bf98              IT       LS
00000a  4770              BXLS     lr
00000c  e92d41f0          PUSH     {r4-r8,lr}            ;2519
000010  6882              LDR      r2,[r0,#8]            ;2537
000012  4606              MOV      r6,r0                 ;2519
000014  1990              ADDS     r0,r2,r6              ;2537
000016  4288              CMP      r0,r1                 ;2537
000018  bf98              IT       LS
00001a  e8bd81f0          POPLS    {r4-r8,pc}
00001e  f1a10410          SUB      r4,r1,#0x10           ;2545
000022  f8510c08          LDR      r0,[r1,#-8]           ;2547
000026  2800              CMP      r0,#0                 ;2547
000028  bf08              IT       EQ
00002a  e8bd81f0          POPEQ    {r4-r8,pc}
00002e  2700              MOVS     r7,#0                 ;2556
000030  60a7              STR      r7,[r4,#8]            ;2556
000032  68e0              LDR      r0,[r4,#0xc]          ;2559
000034  68b1              LDR      r1,[r6,#8]            ;2560
000036  1d05              ADDS     r5,r0,#4              ;2559
000038  1988              ADDS     r0,r1,r6              ;2560
00003a  42a8              CMP      r0,r5                 ;2560
00003c  d00e              BEQ      |L3.92|
00003e  68a8              LDR      r0,[r5,#8]            ;2564
000040  b960              CBNZ     r0,|L3.92|
000042  4629              MOV      r1,r5                 ;2568
000044  4630              MOV      r0,r6                 ;2568
000046  f7fffffe          BL       _RMP_Mem_Del
00004a  68e8              LDR      r0,[r5,#0xc]          ;2569
00004c  60a7              STR      r7,[r4,#8]            ;2569
00004e  1b00              SUBS     r0,r0,r4              ;2569
000050  1d00              ADDS     r0,r0,#4              ;2569
000052  4420              ADD      r0,r0,r4              ;2569
000054  1f00              SUBS     r0,r0,#4              ;2569
000056  60e0              STR      r0,[r4,#0xc]          ;2569
000058  68e0              LDR      r0,[r4,#0xc]          ;2569
00005a  6004              STR      r4,[r0,#0]            ;2569
                  |L3.92|
00005c  6870              LDR      r0,[r6,#4]            ;2580
00005e  42a0              CMP      r0,r4                 ;2580
000060  d003              BEQ      |L3.106|
000062  f8545c04          LDR      r5,[r4,#-4]           ;2583
000066  68a8              LDR      r0,[r5,#8]            ;2586
000068  b128              CBZ      r0,|L3.118|
                  |L3.106|
00006a  4621              MOV      r1,r4                 ;2609
00006c  4630              MOV      r0,r6                 ;2609
00006e  e8bd41f0          POP      {r4-r8,lr}            ;2609
000072  f7ffbffe          B.W      _RMP_Mem_Ins
                  |L3.118|
000076  4629              MOV      r1,r5                 ;2590
000078  4630              MOV      r0,r6                 ;2590
00007a  f7fffffe          BL       _RMP_Mem_Del
00007e  68e0              LDR      r0,[r4,#0xc]          ;2591
000080  60af              STR      r7,[r5,#8]            ;2591
000082  1b40              SUBS     r0,r0,r5              ;2591
000084  1d00              ADDS     r0,r0,#4              ;2591
000086  4428              ADD      r0,r0,r5              ;2591
000088  1f00              SUBS     r0,r0,#4              ;2591
00008a  60e8              STR      r0,[r5,#0xc]          ;2591
00008c  68e8              LDR      r0,[r5,#0xc]          ;2591
00008e  6005              STR      r5,[r0,#0]            ;2591
000090  4629              MOV      r1,r5                 ;2614
000092  4630              MOV      r0,r6                 ;2614
000094  e8bd41f0          POP      {r4-r8,lr}            ;2614
000098  f7ffbffe          B.W      _RMP_Mem_Ins
;;;2617   /* End Function:RMP_Free *****************************************************/
                          ENDP


                          AREA ||i.RMP_Init||, CODE, READONLY, ALIGN=2

                  RMP_Init PROC
;;;1970   ******************************************************************************/
;;;1971   void RMP_Init(void)
000000  20ff              MOVS     r0,#0xff
000002  f7fffffe          BL       RMP_Mask_Int
000006  4808              LDR      r0,|L4.40|
000008  2101              MOVS     r1,#1
00000a  6081              STR      r1,[r0,#8]  ; RMP_Sched_Locked
00000c  6841              LDR      r1,[r0,#4]  ; RMP_Sched_Lock_Cnt
00000e  1c49              ADDS     r1,r1,#1
000010  6041              STR      r1,[r0,#4]  ; RMP_Sched_Lock_Cnt
;;;1972   {
;;;1973       RMP_Lock_Sched();
;;;1974       
;;;1975       /* Platform will use this hook to do something */
;;;1976       _RMP_Plat_Hook();
000012  f7fffffe          BL       _RMP_Plat_Hook
;;;1977       /* Start the second thread here */
;;;1978       RMP_Init_Hook();
000016  f7fffffe          BL       RMP_Init_Hook
;;;1979       
;;;1980       RMP_Unlock_Sched();
00001a  f7fffffe          BL       RMP_Unlock_Sched
;;;1981       
;;;1982       while(1)
;;;1983           RMP_Init_Idle();
00001e  bf00              NOP      
                  |L4.32|
000020  f7fffffe          BL       RMP_Init_Idle
000024  e7fc              B        |L4.32|
;;;1984   }
;;;1985   /* End Function:RMP_Init *****************************************************/
                          ENDP

000026  0000              DCW      0x0000
                  |L4.40|
                          DCD      ||.data||

                          AREA ||i.RMP_LSB_Get||, CODE, READONLY, ALIGN=2

                  RMP_LSB_Get PROC
;;;2118   ******************************************************************************/
;;;2119   rmp_ptr_t RMP_LSB_Get(rmp_ptr_t Val)
000000  4a0c              LDR      r2,|L5.52|
;;;2120   {
000002  b510              PUSH     {r4,lr}
000004  0e03              LSRS     r3,r0,#24
000006  4601              MOV      r1,r0
000008  5cd3              LDRB     r3,[r2,r3]
00000a  f3630007          BFI      r0,r3,#0,#8
00000e  f3c14307          UBFX     r3,r1,#16,#8
000012  5cd3              LDRB     r3,[r2,r3]
000014  f363200f          BFI      r0,r3,#8,#8
000018  f3c12307          UBFX     r3,r1,#8,#8
00001c  b2c9              UXTB     r1,r1
00001e  5cd3              LDRB     r3,[r2,r3]
000020  5c51              LDRB     r1,[r2,r1]
000022  f3634017          BFI      r0,r3,#16,#8
000026  f361601f          BFI      r0,r1,#24,#8
;;;2121       return RMP_WORD_SIZE-1-RMP_MSB_Get(RMP_RBIT_Get(Val));
00002a  f7fffffe          BL       RMP_MSB_Get
00002e  f1c0001f          RSB      r0,r0,#0x1f
;;;2122   }
000032  bd10              POP      {r4,pc}
;;;2123   /* End Function:RMP_LSB_Get **************************************************/
                          ENDP

                  |L5.52|
                          DCD      ||.constdata||

                          AREA ||i.RMP_List_Crt||, CODE, READONLY, ALIGN=1

                  RMP_List_Crt PROC
;;;230    ******************************************************************************/
;;;231    void RMP_List_Crt(volatile struct RMP_List* Head)
000000  6000              STR      r0,[r0,#0]
;;;232    {
;;;233        Head->Prev=(struct RMP_List*)Head;
;;;234        Head->Next=(struct RMP_List*)Head;
000002  6040              STR      r0,[r0,#4]
;;;235    }
000004  4770              BX       lr
;;;236    /* End Function:RMP_List_Crt *************************************************/
                          ENDP


                          AREA ||i.RMP_List_Del||, CODE, READONLY, ALIGN=1

                  RMP_List_Del PROC
;;;244    ******************************************************************************/
;;;245    void RMP_List_Del(volatile struct RMP_List* Prev,volatile struct RMP_List* Next)
000000  6008              STR      r0,[r1,#0]
;;;246    {
;;;247        Next->Prev=(struct RMP_List*)Prev;
;;;248        Prev->Next=(struct RMP_List*)Next;
000002  6041              STR      r1,[r0,#4]
;;;249    }
000004  4770              BX       lr
;;;250    /* End Function:RMP_List_Del *************************************************/
                          ENDP


                          AREA ||i.RMP_List_Ins||, CODE, READONLY, ALIGN=1

                  RMP_List_Ins PROC
;;;259    ******************************************************************************/
;;;260    void RMP_List_Ins(volatile struct RMP_List* New,
000000  6010              STR      r0,[r2,#0]
;;;261                      volatile struct RMP_List* Prev,
;;;262                      volatile struct RMP_List* Next)
;;;263    {
;;;264        Next->Prev=(struct RMP_List*)New;
;;;265        New->Next=(struct RMP_List*)Next;
000002  6042              STR      r2,[r0,#4]
;;;266        New->Prev=(struct RMP_List*)Prev;
000004  6001              STR      r1,[r0,#0]
;;;267        Prev->Next=(struct RMP_List*)New;
000006  6048              STR      r0,[r1,#4]
;;;268    }
000008  4770              BX       lr
;;;269    /* End Function:RMP_List_Ins *************************************************/
                          ENDP


                          AREA ||i.RMP_Load_Ctx||, CODE, READONLY, ALIGN=1

                  RMP_Load_Ctx PROC
;;;1955   #if(RMP_USE_HOOKS==RMP_FALSE)
;;;1956   void RMP_Load_Ctx(void)
000000  4770              BX       lr
;;;1957   {
;;;1958       return;
;;;1959   }
;;;1960   #endif
                          ENDP


                          AREA ||i.RMP_Lock_Sched||, CODE, READONLY, ALIGN=2

                  RMP_Lock_Sched PROC
;;;360    ******************************************************************************/
;;;361    void RMP_Lock_Sched(void)
000000  b510              PUSH     {r4,lr}
;;;362    {
;;;363        RMP_MASK_INT();
000002  20ff              MOVS     r0,#0xff
000004  f7fffffe          BL       RMP_Mask_Int
;;;364        RMP_Sched_Locked=1;
000008  4803              LDR      r0,|L10.24|
00000a  2101              MOVS     r1,#1
00000c  6081              STR      r1,[r0,#8]  ; RMP_Sched_Locked
;;;365        RMP_Sched_Lock_Cnt++;
00000e  6841              LDR      r1,[r0,#4]  ; RMP_Sched_Lock_Cnt
000010  1c49              ADDS     r1,r1,#1
000012  6041              STR      r1,[r0,#4]  ; RMP_Sched_Lock_Cnt
;;;366    }
000014  bd10              POP      {r4,pc}
;;;367    /* End Function:RMP_Lock_Sched ***********************************************/
                          ENDP

000016  0000              DCW      0x0000
                  |L10.24|
                          DCD      ||.data||

                          AREA ||i.RMP_Malloc||, CODE, READONLY, ALIGN=2

                  RMP_Malloc PROC
;;;2444   ******************************************************************************/
;;;2445   void* RMP_Malloc(volatile void* Pool, rmp_ptr_t Size)
000000  2800              CMP      r0,#0
;;;2446   {    
;;;2447       rmp_cnt_t FLI_Level;
;;;2448       rmp_cnt_t SLI_Level;
;;;2449       volatile struct RMP_Mem* Mem;
;;;2450       rmp_ptr_t Old_Size;
;;;2451       volatile struct RMP_Mem_Head* Mem_Head;
;;;2452       rmp_ptr_t Rounded_Size;
;;;2453       volatile struct RMP_Mem_Head* New_Mem;
;;;2454       rmp_ptr_t New_Size;
;;;2455       
;;;2456       if((Pool==0)||(Size==0))
000002  bf12              ITEE     NE
000004  2900              CMPNE    r1,#0
;;;2457       {
;;;2458           RMP_COVERAGE_MARKER();
;;;2459           return (void*)(0);
000006  2000              MOVEQ    r0,#0
;;;2460       }
;;;2461       else
;;;2462           RMP_COVERAGE_MARKER();
;;;2463       
;;;2464       /* Round up the size:a multiple of 8 and bigger than 64B */
;;;2465       Rounded_Size=RMP_ROUND_UP(Size,3);
;;;2466       /* See if it is smaller than the smallest block */
;;;2467       Rounded_Size=(Rounded_Size>64)?Rounded_Size:64;
;;;2468   
;;;2469       /* See if such block exists, if not, abort */
;;;2470       if(_RMP_Mem_Search(Pool,Rounded_Size,&FLI_Level,&SLI_Level)!=0)
;;;2471       {
;;;2472           RMP_COVERAGE_MARKER();
;;;2473           return (void*)(0);
;;;2474       }
;;;2475       else
;;;2476           RMP_COVERAGE_MARKER();
;;;2477       
;;;2478       Mem=(volatile struct RMP_Mem*)Pool;
;;;2479       
;;;2480       /* There is such block. Get it and delete it from the TLSF list. */
;;;2481       Mem_Head=(struct RMP_Mem_Head*)(Mem->Table[RMP_MEM_POS(FLI_Level,SLI_Level)].Next);
;;;2482       _RMP_Mem_Del(Pool, Mem_Head);
;;;2483   
;;;2484       /* Allocate and calculate if the space left could be big enough to be a new 
;;;2485        * block. If so, we will put the block back into the TLSF table */
;;;2486       New_Size=((rmp_ptr_t)(Mem_Head->Tail))-((rmp_ptr_t)Mem_Head)-sizeof(struct RMP_Mem_Head)-Rounded_Size;
;;;2487       if(New_Size>=(sizeof(struct RMP_Mem_Head)+64+sizeof(struct RMP_Mem_Tail)))
;;;2488       {
;;;2489           RMP_COVERAGE_MARKER();
;;;2490           Old_Size=sizeof(struct RMP_Mem_Head)+Rounded_Size+sizeof(struct RMP_Mem_Tail);
;;;2491           New_Mem=(volatile struct RMP_Mem_Head*)(((rmp_ptr_t)Mem_Head)+Old_Size);
;;;2492   
;;;2493           _RMP_Mem_Block(Mem_Head, Old_Size);
;;;2494           _RMP_Mem_Block(New_Mem, New_Size);
;;;2495   
;;;2496           /* Put the extra block back */
;;;2497           _RMP_Mem_Ins(Pool, New_Mem);
;;;2498       }
;;;2499       else
;;;2500           RMP_COVERAGE_MARKER();
;;;2501   
;;;2502       /* Mark the block as in use */
;;;2503       Mem_Head->State=RMP_MEM_USED;
;;;2504   
;;;2505       /* Finally, return the start address */
;;;2506       return (void*)(((rmp_ptr_t)Mem_Head)+sizeof(struct RMP_Mem_Head));
;;;2507   }
000008  4770              BXEQ     lr
00000a  e92d5ff0          PUSH     {r4-r12,lr}           ;2446
00000e  4607              MOV      r7,r0                 ;2446
000010  1dc8              ADDS     r0,r1,#7              ;2465
000012  f0200607          BIC      r6,r0,#7              ;2465
000016  2e40              CMP      r6,#0x40              ;2467
000018  bf98              IT       LS                    ;2467
00001a  2640              MOVLS    r6,#0x40              ;2467
00001c  463d              MOV      r5,r7                 ;2470
00001e  4630              MOV      r0,r6                 ;2470
000020  f7fffffe          BL       RMP_MSB_Get
000024  1f81              SUBS     r1,r0,#6              ;2470
000026  1ec2              SUBS     r2,r0,#3              ;2470
000028  fa26f002          LSR      r0,r6,r2              ;2470
00002c  f0000007          AND      r0,r0,#7              ;2470
000030  f1000308          ADD      r3,r0,#8              ;2470
000034  fa03f202          LSL      r2,r3,r2              ;2470
000038  42b2              CMP      r2,r6                 ;2470
00003a  d004              BEQ      |L11.70|
00003c  1c40              ADDS     r0,r0,#1              ;2470
00003e  2808              CMP      r0,#8                 ;2470
000040  bf04              ITT      EQ                    ;2470
000042  2000              MOVEQ    r0,#0                 ;2470
000044  1c49              ADDEQ    r1,r1,#1              ;2470
                  |L11.70|
000046  682a              LDR      r2,[r5,#0]            ;2470
000048  4291              CMP      r1,r2                 ;2470
00004a  d27c              BCS      |L11.326|
00004c  eb0004c1          ADD      r4,r0,r1,LSL #3       ;2470
000050  1160              ASRS     r0,r4,#5              ;2470
000052  eb050080          ADD      r0,r5,r0,LSL #2       ;2470
000056  6900              LDR      r0,[r0,#0x10]         ;2470
000058  f0040b1f          AND      r11,r4,#0x1f          ;2470
00005c  fa20f10b          LSR      r1,r0,r11             ;2470
000060  f8df8110          LDR      r8,|L11.372|
000064  0e0a              LSRS     r2,r1,#24             ;2470
000066  f8182002          LDRB     r2,[r8,r2]            ;2470
00006a  f3620007          BFI      r0,r2,#0,#8           ;2470
00006e  f3c14207          UBFX     r2,r1,#16,#8          ;2470
000072  f8182002          LDRB     r2,[r8,r2]            ;2470
000076  f362200f          BFI      r0,r2,#8,#8           ;2470
00007a  f3c12207          UBFX     r2,r1,#8,#8           ;2470
00007e  b2c9              UXTB     r1,r1                 ;2470
000080  f8182002          LDRB     r2,[r8,r2]            ;2470
000084  f8181001          LDRB     r1,[r8,r1]            ;2470
000088  f3624017          BFI      r0,r2,#16,#8          ;2470
00008c  f361601f          BFI      r0,r1,#24,#8          ;2470
000090  f7fffffe          BL       RMP_MSB_Get
000094  f1c0001f          RSB      r0,r0,#0x1f           ;2470
000098  f04f0a01          MOV      r10,#1                ;2470
00009c  f04f0900          MOV      r9,#0                 ;2470
0000a0  2820              CMP      r0,#0x20              ;2470
0000a2  d206              BCS      |L11.178|
0000a4  f024011f          BIC      r1,r4,#0x1f           ;2470
0000a8  4408              ADD      r0,r0,r1              ;2470
0000aa  eb00010b          ADD      r1,r0,r11             ;2470
0000ae  10c8              ASRS     r0,r1,#3              ;2470
0000b0  e02c              B        |L11.268|
                  |L11.178|
0000b2  6828              LDR      r0,[r5,#0]            ;2470
0000b4  eb0a1464          ADD      r4,r10,r4,ASR #5      ;2470
0000b8  1cc0              ADDS     r0,r0,#3              ;2470
0000ba  0881              LSRS     r1,r0,#2              ;2470
0000bc  428c              CMP      r4,r1                 ;2470
0000be  da56              BGE      |L11.366|
                  |L11.192|
0000c0  eb050084          ADD      r0,r5,r4,LSL #2       ;2470
0000c4  6900              LDR      r0,[r0,#0x10]         ;2470
0000c6  2800              CMP      r0,#0                 ;2470
0000c8  d04e              BEQ      |L11.360|
0000ca  eb050084          ADD      r0,r5,r4,LSL #2       ;2470
0000ce  6900              LDR      r0,[r0,#0x10]         ;2470
0000d0  0e02              LSRS     r2,r0,#24             ;2470
0000d2  f8182002          LDRB     r2,[r8,r2]            ;2470
0000d6  f3620107          BFI      r1,r2,#0,#8           ;2470
0000da  f3c04207          UBFX     r2,r0,#16,#8          ;2470
0000de  f8182002          LDRB     r2,[r8,r2]            ;2470
0000e2  f362210f          BFI      r1,r2,#8,#8           ;2470
0000e6  f3c02207          UBFX     r2,r0,#8,#8           ;2470
0000ea  b2c0              UXTB     r0,r0                 ;2470
0000ec  f8182002          LDRB     r2,[r8,r2]            ;2470
0000f0  f8180000          LDRB     r0,[r8,r0]            ;2470
0000f4  f3624117          BFI      r1,r2,#16,#8          ;2470
0000f8  f360611f          BFI      r1,r0,#24,#8          ;2470
0000fc  4608              MOV      r0,r1                 ;2470
0000fe  f7fffffe          BL       RMP_MSB_Get
000102  f1c0011f          RSB      r1,r0,#0x1f           ;2470
000106  eb011044          ADD      r0,r1,r4,LSL #5       ;2470
00010a  08c0              LSRS     r0,r0,#3              ;2470
                  |L11.268|
00010c  68fa              LDR      r2,[r7,#0xc]          ;2481
00010e  f0010107          AND      r1,r1,#7              ;2481
000112  eb0100c0          ADD      r0,r1,r0,LSL #3       ;2481
000116  2104              MOVS     r1,#4                 ;2481
000118  eb0100c0          ADD      r0,r1,r0,LSL #3       ;2481
00011c  5814              LDR      r4,[r2,r0]            ;2481
00011e  4638              MOV      r0,r7                 ;2482
000120  4621              MOV      r1,r4                 ;2482
000122  f7fffffe          BL       _RMP_Mem_Del
000126  68e0              LDR      r0,[r4,#0xc]          ;2486
000128  1b00              SUBS     r0,r0,r4              ;2486
00012a  1b80              SUBS     r0,r0,r6              ;2486
00012c  3810              SUBS     r0,r0,#0x10           ;2486
00012e  2854              CMP      r0,#0x54              ;2487
000130  d314              BCC      |L11.348|
000132  f1060114          ADD      r1,r6,#0x14           ;2490
000136  4421              ADD      r1,r1,r4              ;2491
000138  f8c49008          STR      r9,[r4,#8]            ;2491
00013c  1f0a              SUBS     r2,r1,#4              ;2491
00013e  60e2              STR      r2,[r4,#0xc]          ;2491
000140  68e2              LDR      r2,[r4,#0xc]          ;2491
000142  6014              STR      r4,[r2,#0]            ;2491
000144  e000              B        |L11.328|
                  |L11.326|
000146  e012              B        |L11.366|
                  |L11.328|
000148  f8c19008          STR      r9,[r1,#8]            ;2491
00014c  4408              ADD      r0,r0,r1              ;2491
00014e  1f00              SUBS     r0,r0,#4              ;2491
000150  60c8              STR      r0,[r1,#0xc]          ;2491
000152  68c8              LDR      r0,[r1,#0xc]          ;2491
000154  6001              STR      r1,[r0,#0]            ;2491
000156  4638              MOV      r0,r7                 ;2497
000158  f7fffffe          BL       _RMP_Mem_Ins
                  |L11.348|
00015c  f8c4a008          STR      r10,[r4,#8]           ;2503
000160  f1040010          ADD      r0,r4,#0x10           ;2506
000164  e8bd9ff0          POP      {r4-r12,pc}
                  |L11.360|
000168  1c64              ADDS     r4,r4,#1
00016a  428c              CMP      r4,r1
00016c  dba8              BLT      |L11.192|
                  |L11.366|
00016e  2000              MOVS     r0,#0                 ;2473
000170  e8bd9ff0          POP      {r4-r12,pc}
;;;2508   /* End Function:RMP_Malloc ***************************************************/
                          ENDP

                  |L11.372|
                          DCD      ||.constdata||

                          AREA ||i.RMP_Mem_Init||, CODE, READONLY, ALIGN=2

                  RMP_Mem_Init PROC
;;;2160   ******************************************************************************/
;;;2161   rmp_ret_t RMP_Mem_Init(volatile void* Pool, rmp_ptr_t Size)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;2162   {
000004  460d              MOV      r5,r1
000006  0004              MOVS     r4,r0
000008  d009              BEQ      |L12.30|
;;;2163       rmp_cnt_t FLI_Cnt;
;;;2164       rmp_ptr_t Offset;
;;;2165       rmp_ptr_t Bitmap_Size;
;;;2166       volatile struct RMP_Mem* Mem;
;;;2167       
;;;2168       /* See if the memory pool is large enough to enable dynamic allocation - at
;;;2169        * least 1024 machine words or pool initialization will be refused */
;;;2170       if((Pool==0)||(Size<(1024*sizeof(rmp_ptr_t)))||((((rmp_ptr_t)Pool)+Size)<Size))
00000a  f5b55f80          CMP      r5,#0x1000
00000e  bf21              ITTTT    CS
000010  1960              ADDCS    r0,r4,r5
000012  42a8              CMPCS    r0,r5
;;;2171       {
;;;2172           RMP_COVERAGE_MARKER();
;;;2173           return RMP_ERR_MEM;
;;;2174       }
;;;2175       else
;;;2176           RMP_COVERAGE_MARKER();
;;;2177       
;;;2178       /* See if the address and size is word-aligned */
;;;2179       if(((((rmp_ptr_t)Pool)&RMP_ALIGN_MASK)!=0)||((Size&RMP_ALIGN_MASK)!=0))
000014  ea440005          ORRCS    r0,r4,r5
000018  f0100f03          TSTCS    r0,#3
00001c  d003              BEQ      |L12.38|
                  |L12.30|
;;;2180       {
;;;2181           RMP_COVERAGE_MARKER();
;;;2182           return RMP_ERR_MEM;
00001e  f06f0006          MVN      r0,#6
;;;2183       }
;;;2184       else
;;;2185           RMP_COVERAGE_MARKER();
;;;2186   
;;;2187       Mem=(volatile struct RMP_Mem*)Pool;
;;;2188       Mem->Size=Size;
;;;2189       /* Calculate the FLI value needed for this - we always align to 64 byte */
;;;2190       Mem->FLI_Num=RMP_MSB_Get(Size-sizeof(struct RMP_Mem))-6+1;
;;;2191       
;;;2192       /* Decide the location of the bitmap */
;;;2193       Offset=sizeof(struct RMP_Mem);
;;;2194       Bitmap_Size=RMP_ROUND_UP(Mem->FLI_Num,RMP_ALIGN_ORDER);
;;;2195       /* Initialize the bitmap */
;;;2196       for(FLI_Cnt=0;FLI_Cnt<(rmp_cnt_t)(Bitmap_Size>>RMP_ALIGN_ORDER);FLI_Cnt++)
;;;2197           Mem->Bitmap[FLI_Cnt]=0;
;;;2198       
;;;2199       /* Decide the location of the allocation table - "-sizeof(rmp_ptr_t)" is
;;;2200        * because we defined the length=1 in our struct already */
;;;2201       Offset+=Bitmap_Size-sizeof(rmp_ptr_t);
;;;2202       Mem->Table=(struct RMP_List*)(((rmp_ptr_t)Mem)+Offset);
;;;2203       /* Initialize the allocation table */
;;;2204       for(FLI_Cnt=0;FLI_Cnt<(rmp_cnt_t)(Mem->FLI_Num);FLI_Cnt++)
;;;2205       {
;;;2206           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,0)]));
;;;2207           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,1)]));
;;;2208           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,2)]));
;;;2209           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,3)]));
;;;2210           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,4)]));
;;;2211           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,5)]));
;;;2212           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,6)]));
;;;2213           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,7)]));
;;;2214       }
;;;2215       
;;;2216       /* Calculate the offset of the actual allocatable memory - each FLI have
;;;2217        * 8 SLIs, and each SLI has a corresponding table header */
;;;2218       Offset+=sizeof(struct RMP_List)*8*Mem->FLI_Num;
;;;2219       Mem->Start=((rmp_ptr_t)Mem)+Offset;
;;;2220       
;;;2221       /* Initialize the first big block */
;;;2222       _RMP_Mem_Block((struct RMP_Mem_Head*)(Mem->Start),Size-Offset);
;;;2223       /* Insert the memory into the corresponding level */
;;;2224       _RMP_Mem_Ins(Pool,(struct RMP_Mem_Head*)(Mem->Start));
;;;2225       
;;;2226       return 0;
;;;2227   }
000022  e8bd9ff0          POP      {r4-r12,pc}
                  |L12.38|
000026  60a5              STR      r5,[r4,#8]            ;2188
000028  f1a50014          SUB      r0,r5,#0x14           ;2190
00002c  f7fffffe          BL       RMP_MSB_Get
000030  1f40              SUBS     r0,r0,#5              ;2190
000032  6020              STR      r0,[r4,#0]            ;2190
000034  6820              LDR      r0,[r4,#0]            ;2194
000036  f04f0e00          MOV      lr,#0                 ;2197
00003a  1cc0              ADDS     r0,r0,#3              ;2194
00003c  f0200103          BIC      r1,r0,#3              ;2194
000040  0888              LSRS     r0,r1,#2              ;2197
000042  bf1f              ITTTT    NE                    ;2197
000044  f3c10080          UBFXNE   r0,r1,#2,#1           ;2197
000048  2800              CMPNE    r0,#0                 ;2196
00004a  4622              MOVNE    r2,r4                 ;2197
00004c  f8c4e010          STRNE    lr,[r4,#0x10]         ;2197
000050  ebb00f91          CMP      r0,r1,LSR #2          ;2196
000054  da0a              BGE      |L12.108|
000056  bf00              NOP                            ;2197
                  |L12.88|
000058  eb040280          ADD      r2,r4,r0,LSL #2       ;2197
00005c  f8c2e010          STR      lr,[r2,#0x10]         ;2197
000060  f8c2e014          STR      lr,[r2,#0x14]         ;2197
000064  1c80              ADDS     r0,r0,#2              ;2197
000066  ebb00f91          CMP      r0,r1,LSR #2          ;2197
00006a  dbf5              BLT      |L12.88|
                  |L12.108|
00006c  f1010310          ADD      r3,r1,#0x10           ;2201
000070  18e1              ADDS     r1,r4,r3              ;2202
000072  60e1              STR      r1,[r4,#0xc]          ;2202
000074  6820              LDR      r0,[r4,#0]            ;2204
000076  2200              MOVS     r2,#0                 ;2204
000078  4290              CMP      r0,r2                 ;2204
00007a  dd3d              BLE      |L12.248|
00007c  2008              MOVS     r0,#8                 ;2207
00007e  2618              MOVS     r6,#0x18              ;2209
000080  f04f0c10          MOV      r12,#0x10             ;2208
000084  2720              MOVS     r7,#0x20              ;2210
000086  f04f0828          MOV      r8,#0x28              ;2211
00008a  f04f0930          MOV      r9,#0x30              ;2212
00008e  f04f0a38          MOV      r10,#0x38             ;2213
                  |L12.146|
000092  68e1              LDR      r1,[r4,#0xc]          ;2206
000094  eb011182          ADD      r1,r1,r2,LSL #6       ;2206
000098  6009              STR      r1,[r1,#0]            ;2206
00009a  6049              STR      r1,[r1,#4]            ;2206
00009c  68e1              LDR      r1,[r4,#0xc]          ;2207
00009e  eb001b82          ADD      r11,r0,r2,LSL #6      ;2207
0000a2  4459              ADD      r1,r1,r11             ;2207
0000a4  6009              STR      r1,[r1,#0]            ;2207
0000a6  6049              STR      r1,[r1,#4]            ;2207
0000a8  68e1              LDR      r1,[r4,#0xc]          ;2208
0000aa  eb0c1b82          ADD      r11,r12,r2,LSL #6     ;2208
0000ae  4459              ADD      r1,r1,r11             ;2208
0000b0  6009              STR      r1,[r1,#0]            ;2208
0000b2  6049              STR      r1,[r1,#4]            ;2208
0000b4  68e1              LDR      r1,[r4,#0xc]          ;2209
0000b6  eb061b82          ADD      r11,r6,r2,LSL #6      ;2209
0000ba  4459              ADD      r1,r1,r11             ;2209
0000bc  6009              STR      r1,[r1,#0]            ;2209
0000be  6049              STR      r1,[r1,#4]            ;2209
0000c0  68e1              LDR      r1,[r4,#0xc]          ;2210
0000c2  eb071b82          ADD      r11,r7,r2,LSL #6      ;2210
0000c6  4459              ADD      r1,r1,r11             ;2210
0000c8  6009              STR      r1,[r1,#0]            ;2210
0000ca  6049              STR      r1,[r1,#4]            ;2210
0000cc  68e1              LDR      r1,[r4,#0xc]          ;2211
0000ce  eb081b82          ADD      r11,r8,r2,LSL #6      ;2211
0000d2  4459              ADD      r1,r1,r11             ;2211
0000d4  6009              STR      r1,[r1,#0]            ;2211
0000d6  6049              STR      r1,[r1,#4]            ;2211
0000d8  68e1              LDR      r1,[r4,#0xc]          ;2212
0000da  eb091b82          ADD      r11,r9,r2,LSL #6      ;2212
0000de  4459              ADD      r1,r1,r11             ;2212
0000e0  6009              STR      r1,[r1,#0]            ;2212
0000e2  6049              STR      r1,[r1,#4]            ;2212
0000e4  68e1              LDR      r1,[r4,#0xc]          ;2213
0000e6  eb0a1b82          ADD      r11,r10,r2,LSL #6     ;2213
0000ea  4459              ADD      r1,r1,r11             ;2213
0000ec  6009              STR      r1,[r1,#0]            ;2213
0000ee  6049              STR      r1,[r1,#4]            ;2213
0000f0  6821              LDR      r1,[r4,#0]            ;2213
0000f2  1c52              ADDS     r2,r2,#1              ;2213
0000f4  4291              CMP      r1,r2                 ;2213
0000f6  dccc              BGT      |L12.146|
                  |L12.248|
0000f8  6820              LDR      r0,[r4,#0]            ;2218
0000fa  eb031180          ADD      r1,r3,r0,LSL #6       ;2218
0000fe  1862              ADDS     r2,r4,r1              ;2219
000100  6062              STR      r2,[r4,#4]            ;2219
000102  6860              LDR      r0,[r4,#4]            ;2222
000104  1a69              SUBS     r1,r5,r1              ;2222
000106  f8c0e008          STR      lr,[r0,#8]            ;2222
00010a  4401              ADD      r1,r1,r0              ;2222
00010c  1f09              SUBS     r1,r1,#4              ;2222
00010e  60c1              STR      r1,[r0,#0xc]          ;2222
000110  68c1              LDR      r1,[r0,#0xc]          ;2222
000112  6008              STR      r0,[r1,#0]            ;2222
000114  4620              MOV      r0,r4                 ;2224
000116  6861              LDR      r1,[r4,#4]            ;2224
000118  f7fffffe          BL       _RMP_Mem_Ins
00011c  2000              MOVS     r0,#0                 ;2226
00011e  e8bd9ff0          POP      {r4-r12,pc}
;;;2228   /* End Function:RMP_Mem_Init *************************************************/
                          ENDP


                          AREA ||i.RMP_Print_Int||, CODE, READONLY, ALIGN=2

                  RMP_Print_Int PROC
;;;84     ******************************************************************************/
;;;85     rmp_cnt_t RMP_Print_Int(rmp_cnt_t Int)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;86     {
;;;87         rmp_ptr_t Iter;
;;;88         rmp_cnt_t Count;
;;;89         rmp_cnt_t Num;
;;;90         rmp_ptr_t Div;
;;;91         
;;;92         /* how many digits are there? */
;;;93         if(Int==0)
;;;94         {
;;;95             RMP_Putchar('0');
;;;96             return 1;
;;;97         }
;;;98         else if(Int<0)
;;;99         {
;;;100            /* How many digits are there? */
;;;101            Count=0;
;;;102            Div=1;
;;;103            Iter=(rmp_ptr_t)(-Int);
;;;104            while(Iter!=0)
;;;105            {
;;;106                Iter/=10;
000004  f8df80b8          LDR      r8,|L13.192|
000008  1e05              SUBS     r5,r0,#0              ;86
;;;107                Count++;
;;;108                Div*=10;
;;;109            }
;;;110            Div/=10;
;;;111            
;;;112            RMP_Putchar('-');
;;;113            Iter=-Int;
;;;114            Num=Count+1;
;;;115            
;;;116            while(Count>0)
;;;117            {
;;;118                Count--;
;;;119                RMP_Putchar(Iter/Div+'0');
;;;120                Iter=Iter%Div;
;;;121                Div/=10;
;;;122            }
;;;123        }
;;;124        else
;;;125        {
;;;126            /* How many digits are there? */
;;;127            Count=0;
00000a  bfc4              ITT      GT
00000c  2400              MOVGT    r4,#0
;;;128            Div=1;
00000e  2101              MOVGT    r1,#1
000010  d02b              BEQ      |L13.106|
000012  da30              BGE      |L13.118|
000014  2600              MOVS     r6,#0                 ;101
000016  2101              MOVS     r1,#1                 ;102
000018  4244              RSBS     r4,r0,#0              ;103
00001a  4625              MOV      r5,r4                 ;103
00001c  d00a              BEQ      |L13.52|
00001e  bf00              NOP                            ;106
                  |L13.32|
000020  fba82004          UMULL    r2,r0,r8,r4           ;106
000024  08c4              LSRS     r4,r0,#3              ;106
000026  eb010081          ADD      r0,r1,r1,LSL #2       ;108
00002a  ea4f0140          LSL      r1,r0,#1              ;108
00002e  f1060601          ADD      r6,r6,#1              ;108
000032  d1f5              BNE      |L13.32|
                  |L13.52|
000034  fba81001          UMULL    r1,r0,r8,r1           ;110
000038  08c7              LSRS     r7,r0,#3              ;110
00003a  202d              MOVS     r0,#0x2d              ;112
00003c  f7fffffe          BL       RMP_Putchar
000040  f1060901          ADD      r9,r6,#1              ;114
000044  2e00              CMP      r6,#0                 ;116
000046  dd37              BLE      |L13.184|
                  |L13.72|
000048  fbb5f0f7          UDIV     r0,r5,r7              ;119
00004c  3030              ADDS     r0,r0,#0x30           ;119
00004e  b240              SXTB     r0,r0                 ;119
000050  1e76              SUBS     r6,r6,#1              ;119
000052  f7fffffe          BL       RMP_Putchar
000056  fbb5f0f7          UDIV     r0,r5,r7              ;120
00005a  fb075510          MLS      r5,r7,r0,r5           ;120
00005e  fba81007          UMULL    r1,r0,r8,r7           ;121
000062  08c7              LSRS     r7,r0,#3              ;121
000064  2e00              CMP      r6,#0                 ;116
000066  dcef              BGT      |L13.72|
000068  e026              B        |L13.184|
                  |L13.106|
00006a  2030              MOVS     r0,#0x30              ;95
00006c  f7fffffe          BL       RMP_Putchar
000070  2001              MOVS     r0,#1                 ;96
;;;129            Iter=Int;
;;;130            while(Iter!=0)
;;;131            {
;;;132                Iter/=10;
;;;133                Count++;
;;;134                Div*=10;
;;;135            }
;;;136            Div/=10;
;;;137            
;;;138            Iter=Int;
;;;139            Num=Count;
;;;140            
;;;141            while(Count>0)
;;;142            {
;;;143                Count--;
;;;144                RMP_Putchar(Iter/Div+'0');
;;;145                Iter=Iter%Div;
;;;146                Div/=10;
;;;147            }
;;;148        }
;;;149        
;;;150        return Num;
;;;151    }
000072  e8bd87f0          POP      {r4-r10,pc}
                  |L13.118|
000076  fba82000          UMULL    r2,r0,r8,r0           ;132
00007a  eb010181          ADD      r1,r1,r1,LSL #2       ;134
00007e  08c0              LSRS     r0,r0,#3              ;132
000080  ea4f0141          LSL      r1,r1,#1              ;134
000084  f1040401          ADD      r4,r4,#1              ;134
000088  d1f5              BNE      |L13.118|
00008a  fba81001          UMULL    r1,r0,r8,r1           ;136
00008e  08c6              LSRS     r6,r0,#3              ;136
000090  f1b40900          SUBS     r9,r4,#0              ;139
000094  dd10              BLE      |L13.184|
000096  bf00              NOP                            ;144
                  |L13.152|
000098  fbb5f0f6          UDIV     r0,r5,r6              ;144
00009c  3030              ADDS     r0,r0,#0x30           ;144
00009e  b240              SXTB     r0,r0                 ;144
0000a0  1e64              SUBS     r4,r4,#1              ;144
0000a2  f7fffffe          BL       RMP_Putchar
0000a6  fbb5f0f6          UDIV     r0,r5,r6              ;145
0000aa  fb065510          MLS      r5,r6,r0,r5           ;145
0000ae  fba81006          UMULL    r1,r0,r8,r6           ;146
0000b2  08c6              LSRS     r6,r0,#3              ;146
0000b4  2c00              CMP      r4,#0                 ;141
0000b6  dcef              BGT      |L13.152|
                  |L13.184|
0000b8  4648              MOV      r0,r9                 ;150
0000ba  e8bd87f0          POP      {r4-r10,pc}
;;;152    /* End Function:RMP_Print_Int ************************************************/
                          ENDP

0000be  0000              DCW      0x0000
                  |L13.192|
                          DCD      0xcccccccd

                          AREA ||i.RMP_Print_String||, CODE, READONLY, ALIGN=1

                  RMP_Print_String PROC
;;;207    ******************************************************************************/
;;;208    rmp_cnt_t RMP_Print_String(rmp_s8_t* String)
000000  b570              PUSH     {r4-r6,lr}
;;;209    {
000002  4605              MOV      r5,r0
;;;210        rmp_cnt_t Count;
;;;211        
;;;212        Count=0;
000004  2400              MOVS     r4,#0
                  |L14.6|
;;;213        while(Count<RMP_KERNEL_DEBUG_MAX_STR)
;;;214        {
;;;215            if(String[Count]=='\0')
000006  5728              LDRSB    r0,[r5,r4]
000008  b120              CBZ      r0,|L14.20|
00000a  1c64              ADDS     r4,r4,#1
;;;216                break;
;;;217            
;;;218            RMP_Putchar(String[Count++]);
00000c  f7fffffe          BL       RMP_Putchar
000010  2cff              CMP      r4,#0xff              ;213
000012  dbf8              BLT      |L14.6|
                  |L14.20|
;;;219        }
;;;220        
;;;221        return Count;
000014  4620              MOV      r0,r4
;;;222    }
000016  bd70              POP      {r4-r6,pc}
;;;223    /* End Function:RMP_Print_String *********************************************/
                          ENDP


                          AREA ||i.RMP_Print_Uint||, CODE, READONLY, ALIGN=1

                  RMP_Print_Uint PROC
;;;160    ******************************************************************************/
;;;161    rmp_cnt_t RMP_Print_Uint(rmp_ptr_t Uint)
000000  b570              PUSH     {r4-r6,lr}
;;;162    {
000002  0005              MOVS     r5,r0
000004  d003              BEQ      |L15.14|
;;;163        rmp_ptr_t Iter;
;;;164        rmp_cnt_t Count;
;;;165        rmp_cnt_t Num;
;;;166        
;;;167        /* how many digits are there? */
;;;168        if(Uint==0)
;;;169        {
;;;170            RMP_Putchar('0');
;;;171            return 1;
;;;172        }
;;;173        else
;;;174        {
;;;175            /* Filter out all the zeroes */
;;;176            Count=0;
000006  2100              MOVS     r1,#0
;;;177            Iter=Uint;
;;;178            while((Iter>>((sizeof(rmp_ptr_t)*8)-4))==0)
000008  0f02              LSRS     r2,r0,#28
00000a  d005              BEQ      |L15.24|
00000c  e008              B        |L15.32|
                  |L15.14|
00000e  2030              MOVS     r0,#0x30              ;170
000010  f7fffffe          BL       RMP_Putchar
000014  2001              MOVS     r0,#1                 ;171
;;;179            {
;;;180                Iter<<=4;
;;;181                Count++;
;;;182            }
;;;183            /* Count is the number of pts to print */
;;;184            Count=sizeof(rmp_ptr_t)*2-Count;
;;;185            Num=Count;
;;;186            while(Count>0)
;;;187            {
;;;188                Count--;
;;;189                Iter=(Uint>>(Count*4))&0x0F;
;;;190                if(Iter<10)
;;;191                    RMP_Putchar('0'+Iter);
;;;192                else
;;;193                    RMP_Putchar('A'+Iter-10);
;;;194            }
;;;195        }
;;;196        
;;;197        return Num;
;;;198    }
000016  bd70              POP      {r4-r6,pc}
                  |L15.24|
000018  0100              LSLS     r0,r0,#4              ;180
00001a  1c49              ADDS     r1,r1,#1              ;180
00001c  0f02              LSRS     r2,r0,#28             ;178
00001e  d0fb              BEQ      |L15.24|
                  |L15.32|
000020  f1c10408          RSB      r4,r1,#8              ;184
000024  1e26              SUBS     r6,r4,#0              ;185
000026  dd0f              BLE      |L15.72|
                  |L15.40|
000028  4620              MOV      r0,r4                 ;188
00002a  1e64              SUBS     r4,r4,#1              ;188
00002c  0080              LSLS     r0,r0,#2
00002e  1f00              SUBS     r0,r0,#4
000030  fa25f000          LSR      r0,r5,r0              ;189
000034  f000000f          AND      r0,r0,#0xf            ;189
000038  280a              CMP      r0,#0xa               ;190
00003a  bf34              ITE      CC                    ;190
00003c  3030              ADDCC    r0,r0,#0x30           ;190
00003e  3037              ADDCS    r0,r0,#0x37           ;190
000040  f7fffffe          BL       RMP_Putchar
000044  2c00              CMP      r4,#0                 ;186
000046  dcef              BGT      |L15.40|
                  |L15.72|
000048  4630              MOV      r0,r6                 ;197
00004a  bd70              POP      {r4-r6,pc}
;;;199    /* End Function:RMP_Print_Uint ***********************************************/
                          ENDP


                          AREA ||i.RMP_RBIT_Get||, CODE, READONLY, ALIGN=2

                  RMP_RBIT_Get PROC
;;;2077   
;;;2078   rmp_ptr_t RMP_RBIT_Get(rmp_ptr_t Val)
000000  4a0a              LDR      r2,|L16.44|
;;;2079   {
000002  0e03              LSRS     r3,r0,#24
000004  4601              MOV      r1,r0
;;;2080       rmp_ptr_t Ret;
;;;2081       rmp_ptr_t Src;
;;;2082       rmp_u8_t* To;
;;;2083       rmp_u8_t* From;
;;;2084       
;;;2085       Src=Val;
;;;2086       To=(rmp_u8_t*)(&Ret);
;;;2087       From=(rmp_u8_t*)(&Src);
;;;2088       
;;;2089   #if(RMP_WORD_ORDER==4)
;;;2090       To[0]=RMP_RBIT_Table[From[1]];
;;;2091       To[1]=RMP_RBIT_Table[From[0]];
;;;2092   #elif(RMP_WORD_ORDER==5)
;;;2093       To[0]=RMP_RBIT_Table[From[3]];
000006  5cd3              LDRB     r3,[r2,r3]
000008  f3630007          BFI      r0,r3,#0,#8
00000c  f3c14307          UBFX     r3,r1,#16,#8
;;;2094       To[1]=RMP_RBIT_Table[From[2]];
000010  5cd3              LDRB     r3,[r2,r3]
000012  f363200f          BFI      r0,r3,#8,#8
000016  f3c12307          UBFX     r3,r1,#8,#8
;;;2095       To[2]=RMP_RBIT_Table[From[1]];
00001a  b2c9              UXTB     r1,r1
00001c  5cd3              LDRB     r3,[r2,r3]
;;;2096       To[3]=RMP_RBIT_Table[From[0]];
00001e  5c51              LDRB     r1,[r2,r1]
000020  f3634017          BFI      r0,r3,#16,#8          ;2095
000024  f361601f          BFI      r0,r1,#24,#8
;;;2097   #else
;;;2098       To[0]=RMP_RBIT_Table[From[7]];
;;;2099       To[1]=RMP_RBIT_Table[From[6]];
;;;2100       To[2]=RMP_RBIT_Table[From[5]];
;;;2101       To[3]=RMP_RBIT_Table[From[4]];
;;;2102       To[4]=RMP_RBIT_Table[From[3]];
;;;2103       To[5]=RMP_RBIT_Table[From[2]];
;;;2104       To[6]=RMP_RBIT_Table[From[1]];
;;;2105       To[7]=RMP_RBIT_Table[From[0]];
;;;2106   #endif
;;;2107   
;;;2108       return Ret;
;;;2109   }
000028  4770              BX       lr
;;;2110   /* End Function:RMP_RBIT_Get *************************************************/
                          ENDP

00002a  0000              DCW      0x0000
                  |L16.44|
                          DCD      ||.constdata||

                          AREA ||i.RMP_Realloc||, CODE, READONLY, ALIGN=1

                  RMP_Realloc PROC
;;;2629   ******************************************************************************/
;;;2630   void* RMP_Realloc(volatile void* Pool, void* Mem_Ptr, rmp_ptr_t Size)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;2631   {
000004  460d              MOV      r5,r1
000006  ea5f0900          MOVS     r9,r0
00000a  d008              BEQ      |L17.30|
;;;2632       /* The size of the original memory block */
;;;2633       rmp_ptr_t Mem_Size;
;;;2634       /* The rounded size of the new memory request */
;;;2635       rmp_ptr_t Rounded_Size;
;;;2636       rmp_ptr_t Count;
;;;2637       /* The pointer to the pool */
;;;2638       volatile struct RMP_Mem* Mem;
;;;2639       /* The head of the old memory */
;;;2640       volatile struct RMP_Mem_Head* Mem_Head;
;;;2641       /* The right-side block head */
;;;2642       volatile struct RMP_Mem_Head* Right_Head;
;;;2643       /* The pointer to the residue memory head */
;;;2644       volatile struct RMP_Mem_Head* Res_Mem;
;;;2645       /* The new memory block */
;;;2646       void* New_Mem;
;;;2647       /* The size of the memory block including the header sizes */
;;;2648       rmp_ptr_t Old_Size;
;;;2649       /* The size of the residue memory block including the header sizes */
;;;2650       rmp_ptr_t Res_Size;
;;;2651       
;;;2652       /* Check if no pool present */
;;;2653       if(Pool==0)
;;;2654       {
;;;2655           RMP_COVERAGE_MARKER();
;;;2656           return 0;
;;;2657       }
;;;2658       else
;;;2659           RMP_COVERAGE_MARKER();
;;;2660       
;;;2661       /* Are we passing in a NULL pointer? */
;;;2662       if(Mem_Ptr==0)
00000c  b155              CBZ      r5,|L17.36|
;;;2663       {
;;;2664           RMP_COVERAGE_MARKER();
;;;2665           return RMP_Malloc(Pool,Size);
;;;2666       }
;;;2667       else
;;;2668           RMP_COVERAGE_MARKER();
;;;2669       
;;;2670       /* Is the size passed in zero? If yes, we free directly */
;;;2671       if(Size==0)
00000e  b172              CBZ      r2,|L17.46|
;;;2672       {
;;;2673           RMP_COVERAGE_MARKER();
;;;2674           RMP_Free(Pool,Mem_Ptr);
;;;2675           return 0;
;;;2676       }
;;;2677       else
;;;2678           RMP_COVERAGE_MARKER();
;;;2679       
;;;2680       /* See if the address is within the allocatable address range. If not, abort directly. */
;;;2681       Mem=(volatile struct RMP_Mem*)Pool;
;;;2682       if((((rmp_ptr_t)Mem_Ptr)<=((rmp_ptr_t)Mem))||(((rmp_ptr_t)Mem_Ptr)>=(((rmp_ptr_t)Mem)+Mem->Size)))
000010  454d              CMP      r5,r9
000012  d904              BLS      |L17.30|
000014  6881              LDR      r1,[r0,#8]
000016  eb010009          ADD      r0,r1,r9
00001a  42a8              CMP      r0,r5
00001c  d80c              BHI      |L17.56|
                  |L17.30|
;;;2683       {
;;;2684           RMP_COVERAGE_MARKER();
;;;2685           return 0;
00001e  2000              MOVS     r0,#0
;;;2686       }
;;;2687       else
;;;2688           RMP_COVERAGE_MARKER();
;;;2689   
;;;2690       /* Yes, get the location of the header of the memory */
;;;2691       Mem_Head=(struct RMP_Mem_Head*)(((rmp_ptr_t)Mem_Ptr)-sizeof(struct RMP_Mem_Head));
;;;2692       /* See if the block can really be realloced */
;;;2693       if(Mem_Head->State==RMP_MEM_FREE)
;;;2694       {
;;;2695           RMP_COVERAGE_MARKER();
;;;2696           return 0;
;;;2697       }
;;;2698       else
;;;2699           RMP_COVERAGE_MARKER();
;;;2700       
;;;2701       /* Round up the size:a multiple of 8 and bigger than 64B */
;;;2702       Rounded_Size=RMP_ROUND_UP(Size,3);
;;;2703       /* See if it is smaller than the smallest block */
;;;2704       Rounded_Size=(Rounded_Size>64)?Rounded_Size:64;
;;;2705       
;;;2706       Mem_Size=((rmp_ptr_t)Mem_Head->Tail)-((rmp_ptr_t)Mem_Ptr);
;;;2707       /* Does the right-side head exist at all? */
;;;2708       Right_Head=(struct RMP_Mem_Head*)(((rmp_ptr_t)(Mem_Head->Tail))+sizeof(struct RMP_Mem_Tail));
;;;2709       if(((rmp_ptr_t)Right_Head)==(((rmp_ptr_t)Mem)+Mem->Size))
;;;2710       {
;;;2711           RMP_COVERAGE_MARKER();
;;;2712           Right_Head=0;
;;;2713       }
;;;2714       else
;;;2715           RMP_COVERAGE_MARKER();
;;;2716       
;;;2717       /* Are we gonna expand it? */
;;;2718       if(Mem_Size<Rounded_Size)
;;;2719       {
;;;2720           /* Expanding */
;;;2721           RMP_COVERAGE_MARKER();
;;;2722           /* Does the right side exist at all? */
;;;2723           if(Right_Head!=0)
;;;2724           {
;;;2725               RMP_COVERAGE_MARKER();
;;;2726               /* Is it allocated? */
;;;2727               if(Right_Head->State==RMP_MEM_FREE)
;;;2728               {
;;;2729                   RMP_COVERAGE_MARKER();
;;;2730                   /* Right-side exists and is free. How big is its usable size? Is it sufficient for our realloc? */
;;;2731                   if((((rmp_ptr_t)Right_Head->Tail)-((rmp_ptr_t)Mem_Ptr))>=Rounded_Size)
;;;2732                   {
;;;2733                       RMP_COVERAGE_MARKER();
;;;2734                       /* Remove the right-side from the free list so we can operate on it */
;;;2735                       _RMP_Mem_Del(Pool, Right_Head);   
;;;2736                       /* Allocate and calculate if the space left could be big enough to be a new 
;;;2737                        * block. If so, we will put the block back into the TLSF table */
;;;2738                       Res_Size=((rmp_ptr_t)(Right_Head->Tail))-((rmp_ptr_t)Mem_Ptr)-Rounded_Size;
;;;2739                       /* Is the residue big enough to be a block? */
;;;2740                       if(Res_Size>=(sizeof(struct RMP_Mem_Head)+64+sizeof(struct RMP_Mem_Tail)))
;;;2741                       {
;;;2742                           RMP_COVERAGE_MARKER();
;;;2743                           Old_Size=sizeof(struct RMP_Mem_Head)+Rounded_Size+sizeof(struct RMP_Mem_Tail);
;;;2744                           Res_Mem=(volatile struct RMP_Mem_Head*)(((rmp_ptr_t)Mem_Head)+Old_Size);
;;;2745   
;;;2746                           _RMP_Mem_Block(Mem_Head, Old_Size);
;;;2747                           _RMP_Mem_Block(Res_Mem, Res_Size);
;;;2748   
;;;2749                           /* Put the extra block back */
;;;2750                           _RMP_Mem_Ins(Pool, Res_Mem);
;;;2751                       }
;;;2752                       else
;;;2753                       {
;;;2754                           /* Residue too small. Merging the whole thing in is the only option */
;;;2755                           RMP_COVERAGE_MARKER();
;;;2756                           Old_Size=((rmp_ptr_t)(Right_Head->Tail))-((rmp_ptr_t)Mem_Head)+sizeof(struct RMP_Mem_Tail);
;;;2757                           _RMP_Mem_Block(Mem_Head, Old_Size);
;;;2758                       }
;;;2759                       
;;;2760                       /* Mark the block as in use (making new block clears this flag) */
;;;2761                       Mem_Head->State=RMP_MEM_USED;
;;;2762                       /* Return the old pointer because we expanded it */
;;;2763                       return Mem_Ptr;
;;;2764                   }
;;;2765                   /* Right-side not large enough, have to go malloc then memcpy */
;;;2766                   else
;;;2767                       RMP_COVERAGE_MARKER();
;;;2768               }
;;;2769               /* It is allocated, have to go malloc then memcpy */
;;;2770               else
;;;2771                   RMP_COVERAGE_MARKER();
;;;2772           }
;;;2773           /* Right-side doesn't exist, have to go malloc then memcpy */
;;;2774           else
;;;2775               RMP_COVERAGE_MARKER();
;;;2776           
;;;2777           New_Mem=RMP_Malloc(Pool,Rounded_Size);
;;;2778           /* See if we can allocate this much, if we can't at all, exit */
;;;2779           if(New_Mem==0)
;;;2780           {
;;;2781               RMP_COVERAGE_MARKER();
;;;2782               return 0;
;;;2783           }
;;;2784           else
;;;2785               RMP_COVERAGE_MARKER();
;;;2786           
;;;2787           /* Copy old memory to new memory - we know that this is always aligned, so this is fine */
;;;2788           for(Count=0;Count<(Mem_Size>>RMP_ALIGN_ORDER);Count++)
;;;2789               ((rmp_ptr_t*)New_Mem)[Count]=((rmp_ptr_t*)Mem_Ptr)[Count];
;;;2790           
;;;2791           /* Free old memory then return */
;;;2792           RMP_Free(Pool,Mem_Ptr);
;;;2793           return New_Mem;
;;;2794       }
;;;2795       /* Shrinking or keeping */
;;;2796       else
;;;2797           RMP_COVERAGE_MARKER();
;;;2798       
;;;2799       /* Are we keeping the size? */
;;;2800       if(Mem_Size==Rounded_Size)
;;;2801       {
;;;2802           RMP_COVERAGE_MARKER();
;;;2803           return Mem_Ptr;
;;;2804       }
;;;2805       else
;;;2806           RMP_COVERAGE_MARKER();
;;;2807       
;;;2808       /* Does the right side exist at all? */
;;;2809       if(Right_Head!=0)
;;;2810       {
;;;2811           RMP_COVERAGE_MARKER();
;;;2812           /* Is it allocated? */
;;;2813           if(Right_Head->State==RMP_MEM_FREE)
;;;2814           {
;;;2815               /* Right-side not allocated. Need to merge the block */
;;;2816               RMP_COVERAGE_MARKER();
;;;2817               /* Remove the right-side from the allocation list so we can operate on it */
;;;2818               _RMP_Mem_Del(Pool, Right_Head);
;;;2819               Res_Size=((rmp_ptr_t)(Right_Head->Tail))-((rmp_ptr_t)Mem_Ptr)-Rounded_Size;
;;;2820               Old_Size=sizeof(struct RMP_Mem_Head)+Rounded_Size+sizeof(struct RMP_Mem_Tail);
;;;2821               Res_Mem=(volatile struct RMP_Mem_Head*)(((rmp_ptr_t)Mem_Head)+Old_Size);
;;;2822   
;;;2823               _RMP_Mem_Block(Mem_Head, Old_Size);
;;;2824               _RMP_Mem_Block(Res_Mem, Res_Size);
;;;2825   
;;;2826               /* Put the extra block back */
;;;2827               _RMP_Mem_Ins(Pool, Res_Mem);
;;;2828               
;;;2829               /* Mark the block as in use (making new block clears this flag) */
;;;2830               Mem_Head->State=RMP_MEM_USED;
;;;2831               /* Return the old pointer because we shrinked it */
;;;2832               return Mem_Ptr;
;;;2833           }
;;;2834           /* Allocated. Need to see if the residue block itself is large enough to be inserted back */
;;;2835           else
;;;2836               RMP_COVERAGE_MARKER();
;;;2837       }
;;;2838       else
;;;2839           RMP_COVERAGE_MARKER();
;;;2840       
;;;2841       /* The right-side head either does not exist or is allocated. Calculate the resulting residue size */
;;;2842       Res_Size=Mem_Size-Rounded_Size;
;;;2843       if(Res_Size<(sizeof(struct RMP_Mem_Head)+64+sizeof(struct RMP_Mem_Tail)))
;;;2844       {
;;;2845           RMP_COVERAGE_MARKER();
;;;2846           /* The residue block wouldn't even count as a small one. Do nothing and quit */
;;;2847           return Mem_Ptr;
;;;2848       }
;;;2849       else
;;;2850           RMP_COVERAGE_MARKER();
;;;2851       
;;;2852       /* The residue will be big enough to become a standalone block. We need to place it back */ 
;;;2853       Old_Size=sizeof(struct RMP_Mem_Head)+Rounded_Size+sizeof(struct RMP_Mem_Tail);
;;;2854       Res_Mem=(volatile struct RMP_Mem_Head*)(((rmp_ptr_t)Mem_Head)+Old_Size);
;;;2855   
;;;2856       _RMP_Mem_Block(Mem_Head, Old_Size);
;;;2857       _RMP_Mem_Block(Res_Mem, Res_Size);
;;;2858   
;;;2859       /* Put the extra block back */
;;;2860       _RMP_Mem_Ins(Pool, Res_Mem);
;;;2861               
;;;2862       /* Mark the block as in use (making new block clears this flag) */
;;;2863       Mem_Head->State=RMP_MEM_USED;
;;;2864       /* Return the old pointer because we shrinked it */
;;;2865       return Mem_Ptr;
;;;2866   }
000020  e8bd9ff0          POP      {r4-r12,pc}
                  |L17.36|
000024  e8bd5ff0          POP      {r4-r12,lr}           ;2665
000028  4611              MOV      r1,r2                 ;2665
00002a  f7ffbffe          B.W      RMP_Malloc
                  |L17.46|
00002e  f7fffffe          BL       RMP_Free
000032  2000              MOVS     r0,#0                 ;2675
000034  e8bd9ff0          POP      {r4-r12,pc}
                  |L17.56|
000038  f8550c08          LDR      r0,[r5,#-8]           ;2693
00003c  f1a50410          SUB      r4,r5,#0x10           ;2691
000040  2800              CMP      r0,#0                 ;2693
000042  bf08              IT       EQ
000044  e8bd9ff0          POPEQ    {r4-r12,pc}
000048  1dd0              ADDS     r0,r2,#7              ;2702
00004a  f0200707          BIC      r7,r0,#7              ;2702
00004e  2f40              CMP      r7,#0x40              ;2704
000050  bf98              IT       LS                    ;2704
000052  2740              MOVLS    r7,#0x40              ;2704
000054  68e0              LDR      r0,[r4,#0xc]          ;2706
000056  eba00b05          SUB      r11,r0,r5             ;2706
00005a  68e0              LDR      r0,[r4,#0xc]          ;2708
00005c  f8d91008          LDR      r1,[r9,#8]            ;2709
000060  1d06              ADDS     r6,r0,#4              ;2708
000062  eb010009          ADD      r0,r1,r9              ;2709
000066  42b0              CMP      r0,r6                 ;2709
000068  bf08              IT       EQ                    ;2712
00006a  2600              MOVEQ    r6,#0                 ;2712
00006c  f04f0800          MOV      r8,#0                 ;2712
000070  f04f0a01          MOV      r10,#1                ;2761
000074  45bb              CMP      r11,r7                ;2718
000076  d25a              BCS      |L17.302|
000078  b396              CBZ      r6,|L17.224|
00007a  68b0              LDR      r0,[r6,#8]            ;2727
00007c  bb80              CBNZ     r0,|L17.224|
00007e  68f0              LDR      r0,[r6,#0xc]          ;2731
000080  eba00005          SUB      r0,r0,r5              ;2731
000084  4287              CMP      r7,r0                 ;2731
000086  d82c              BHI      |L17.226|
000088  4631              MOV      r1,r6                 ;2735
00008a  4648              MOV      r0,r9                 ;2735
00008c  f7fffffe          BL       _RMP_Mem_Del
000090  68f0              LDR      r0,[r6,#0xc]          ;2738
000092  1b40              SUBS     r0,r0,r5              ;2738
000094  1bc0              SUBS     r0,r0,r7              ;2738
000096  2854              CMP      r0,#0x54              ;2740
000098  d313              BCC      |L17.194|
00009a  f1070114          ADD      r1,r7,#0x14           ;2743
00009e  4421              ADD      r1,r1,r4              ;2744
0000a0  f8c48008          STR      r8,[r4,#8]            ;2744
0000a4  1f0a              SUBS     r2,r1,#4              ;2744
0000a6  60e2              STR      r2,[r4,#0xc]          ;2744
0000a8  68e2              LDR      r2,[r4,#0xc]          ;2744
0000aa  6014              STR      r4,[r2,#0]            ;2744
0000ac  f8c18008          STR      r8,[r1,#8]            ;2744
0000b0  4408              ADD      r0,r0,r1              ;2744
0000b2  1f00              SUBS     r0,r0,#4              ;2744
0000b4  60c8              STR      r0,[r1,#0xc]          ;2744
0000b6  68c8              LDR      r0,[r1,#0xc]          ;2744
0000b8  6001              STR      r1,[r0,#0]            ;2744
0000ba  4648              MOV      r0,r9                 ;2750
0000bc  f7fffffe          BL       _RMP_Mem_Ins
0000c0  e009              B        |L17.214|
                  |L17.194|
0000c2  68f0              LDR      r0,[r6,#0xc]          ;2756
0000c4  f8c48008          STR      r8,[r4,#8]            ;2756
0000c8  1b00              SUBS     r0,r0,r4              ;2756
0000ca  1d00              ADDS     r0,r0,#4              ;2756
0000cc  4420              ADD      r0,r0,r4              ;2756
0000ce  1f00              SUBS     r0,r0,#4              ;2756
0000d0  60e0              STR      r0,[r4,#0xc]          ;2756
0000d2  68e0              LDR      r0,[r4,#0xc]          ;2756
0000d4  6004              STR      r4,[r0,#0]            ;2756
                  |L17.214|
0000d6  f8c4a008          STR      r10,[r4,#8]           ;2761
0000da  4628              MOV      r0,r5                 ;2763
0000dc  e8bd9ff0          POP      {r4-r12,pc}
                  |L17.224|
0000e0  e7ff              B        |L17.226|
                  |L17.226|
0000e2  4639              MOV      r1,r7                 ;2777
0000e4  4648              MOV      r0,r9                 ;2777
0000e6  f7fffffe          BL       RMP_Malloc
0000ea  1e04              SUBS     r4,r0,#0              ;2777
0000ec  bf08              IT       EQ
0000ee  e8bd9ff0          POPEQ    {r4-r12,pc}
0000f2  ea5f009b          LSRS     r0,r11,#2             ;2788
0000f6  d013              BEQ      |L17.288|
0000f8  1f29              SUBS     r1,r5,#4              ;2788
0000fa  1f20              SUBS     r0,r4,#4              ;2788
0000fc  f01b0f04          TST      r11,#4
000100  d003              BEQ      |L17.266|
000102  f8512f04          LDR      r2,[r1,#4]!           ;2789
000106  f8402f04          STR      r2,[r0,#4]!           ;2789
                  |L17.266|
00010a  ea5f02db          LSRS     r2,r11,#3             ;2788
00010e  d007              BEQ      |L17.288|
                  |L17.272|
000110  684b              LDR      r3,[r1,#4]            ;2789
000112  6043              STR      r3,[r0,#4]            ;2789
000114  f8513f08          LDR      r3,[r1,#8]!           ;2789
000118  f8403f08          STR      r3,[r0,#8]!           ;2789
00011c  1e52              SUBS     r2,r2,#1              ;2789
00011e  d1f7              BNE      |L17.272|
                  |L17.288|
000120  4629              MOV      r1,r5                 ;2792
000122  4648              MOV      r0,r9                 ;2792
000124  f7fffffe          BL       RMP_Free
000128  4620              MOV      r0,r4                 ;2793
00012a  e8bd9ff0          POP      {r4-r12,pc}
                  |L17.302|
00012e  d006              BEQ      |L17.318|
000130  b10e              CBZ      r6,|L17.310|
000132  68b0              LDR      r0,[r6,#8]            ;2813
000134  b130              CBZ      r0,|L17.324|
                  |L17.310|
000136  ebab0007          SUB      r0,r11,r7             ;2842
00013a  2854              CMP      r0,#0x54              ;2843
00013c  d209              BCS      |L17.338|
                  |L17.318|
00013e  4628              MOV      r0,r5                 ;2847
000140  e8bd9ff0          POP      {r4-r12,pc}
                  |L17.324|
000144  4631              MOV      r1,r6                 ;2818
000146  4648              MOV      r0,r9                 ;2818
000148  f7fffffe          BL       _RMP_Mem_Del
00014c  68f0              LDR      r0,[r6,#0xc]          ;2819
00014e  1b40              SUBS     r0,r0,r5              ;2819
000150  1bc0              SUBS     r0,r0,r7              ;2819
                  |L17.338|
000152  f1070114          ADD      r1,r7,#0x14           ;2853
000156  4421              ADD      r1,r1,r4              ;2854
000158  f8c48008          STR      r8,[r4,#8]            ;2854
00015c  1f0a              SUBS     r2,r1,#4              ;2854
00015e  60e2              STR      r2,[r4,#0xc]          ;2854
000160  68e2              LDR      r2,[r4,#0xc]          ;2854
000162  6014              STR      r4,[r2,#0]            ;2854
000164  f8c18008          STR      r8,[r1,#8]            ;2854
000168  4408              ADD      r0,r0,r1              ;2854
00016a  1f00              SUBS     r0,r0,#4              ;2854
00016c  60c8              STR      r0,[r1,#0xc]          ;2854
00016e  68c8              LDR      r0,[r1,#0xc]          ;2854
000170  6001              STR      r1,[r0,#0]            ;2854
000172  4648              MOV      r0,r9                 ;2860
000174  f7fffffe          BL       _RMP_Mem_Ins
000178  f8c4a008          STR      r10,[r4,#8]           ;2863
00017c  4628              MOV      r0,r5                 ;2865
00017e  e8bd9ff0          POP      {r4-r12,pc}
;;;2867   /* End Function:RMP_Realloc **************************************************/
                          ENDP


                          AREA ||i.RMP_Save_Ctx||, CODE, READONLY, ALIGN=1

                  RMP_Save_Ctx PROC
;;;1941   #if(RMP_USE_HOOKS==RMP_FALSE)
;;;1942   void RMP_Save_Ctx(void)
000000  4770              BX       lr
;;;1943   {
;;;1944       return;
;;;1945   }
;;;1946   #endif
                          ENDP


                          AREA ||i.RMP_Sem_Abort||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Abort PROC
;;;1736   ******************************************************************************/
;;;1737   rmp_ret_t RMP_Sem_Abort(volatile struct RMP_Thd* Thread)
000000  2800              CMP      r0,#0
;;;1738   {
;;;1739       /* Check if this thread structure could possibly be in use */
;;;1740       if(Thread==0)
;;;1741       {
;;;1742           RMP_COVERAGE_MARKER();
;;;1743           return RMP_ERR_THD;
000002  bf04              ITT      EQ
000004  f04f30ff          MOVEQ    r0,#0xffffffff
;;;1744       }
;;;1745       else
;;;1746           RMP_COVERAGE_MARKER();
;;;1747   
;;;1748       RMP_Lock_Sched();
;;;1749       
;;;1750       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;1751       {
;;;1752           RMP_COVERAGE_MARKER();
;;;1753           RMP_Unlock_Sched();
;;;1754           return RMP_ERR_THD;
;;;1755       }
;;;1756       else
;;;1757           RMP_COVERAGE_MARKER();
;;;1758       
;;;1759       /* Is it waiting on a semaphore? If no, we abort and return an error code */
;;;1760       if((RMP_THD_STATE(Thread->State)!=RMP_THD_SEMBLK)&&
;;;1761          (RMP_THD_STATE(Thread->State)!=RMP_THD_SEMDLY))
;;;1762       {
;;;1763           RMP_COVERAGE_MARKER();
;;;1764           RMP_Unlock_Sched();
;;;1765           return RMP_ERR_STATE;
;;;1766       }
;;;1767       else
;;;1768           RMP_COVERAGE_MARKER();
;;;1769   
;;;1770       /* Waiting for a semaphore. We abort it and return */
;;;1771       RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1772       if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1773       {
;;;1774           RMP_COVERAGE_MARKER();
;;;1775           RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1776       }
;;;1777       else
;;;1778           RMP_COVERAGE_MARKER();
;;;1779       
;;;1780       RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1781       /* Set to running if not suspended */
;;;1782       _RMP_Set_Rdy(Thread);
;;;1783       
;;;1784       Thread->Retval=RMP_ERR_OPER;
;;;1785       RMP_Unlock_Sched();
;;;1786       return 0;
;;;1787   }
000008  4770              BXEQ     lr
00000a  b510              PUSH     {r4,lr}               ;1738
00000c  4604              MOV      r4,r0                 ;1738
00000e  20ff              MOVS     r0,#0xff              ;1738
000010  f7fffffe          BL       RMP_Mask_Int
000014  481b              LDR      r0,|L19.132|
000016  2101              MOVS     r1,#1                 ;1738
000018  6081              STR      r1,[r0,#8]            ;1738  ; RMP_Sched_Locked
00001a  6841              LDR      r1,[r0,#4]            ;1738  ; RMP_Sched_Lock_Cnt
00001c  1c49              ADDS     r1,r1,#1              ;1738
00001e  6041              STR      r1,[r0,#4]            ;1738  ; RMP_Sched_Lock_Cnt
000020  69a0              LDR      r0,[r4,#0x18]         ;1750
000022  f0100fff          TST      r0,#0xff              ;1750
000026  d00c              BEQ      |L19.66|
000028  69a0              LDR      r0,[r4,#0x18]         ;1760
00002a  b2c0              UXTB     r0,r0                 ;1760
00002c  2807              CMP      r0,#7                 ;1760
00002e  d00d              BEQ      |L19.76|
000030  69a0              LDR      r0,[r4,#0x18]         ;1760
000032  b2c0              UXTB     r0,r0                 ;1760
000034  2808              CMP      r0,#8                 ;1760
000036  d009              BEQ      |L19.76|
000038  f7fffffe          BL       RMP_Unlock_Sched
00003c  f06f0003          MVN      r0,#3                 ;1765
000040  bd10              POP      {r4,pc}
                  |L19.66|
000042  f7fffffe          BL       RMP_Unlock_Sched
000046  f04f30ff          MOV      r0,#0xffffffff        ;1754
00004a  bd10              POP      {r4,pc}
                  |L19.76|
00004c  6820              LDR      r0,[r4,#0]            ;1771
00004e  6861              LDR      r1,[r4,#4]            ;1771
000050  6008              STR      r0,[r1,#0]            ;1771
000052  6041              STR      r1,[r0,#4]            ;1771
000054  69a0              LDR      r0,[r4,#0x18]         ;1772
000056  b2c0              UXTB     r0,r0                 ;1772
000058  2808              CMP      r0,#8                 ;1772
00005a  d103              BNE      |L19.100|
00005c  68a1              LDR      r1,[r4,#8]            ;1775
00005e  68e0              LDR      r0,[r4,#0xc]          ;1775
000060  6001              STR      r1,[r0,#0]            ;1775
000062  6048              STR      r0,[r1,#4]            ;1775
                  |L19.100|
000064  69a0              LDR      r0,[r4,#0x18]         ;1780
000066  f02000ff          BIC      r0,r0,#0xff           ;1780
00006a  f0400001          ORR      r0,r0,#1              ;1780
00006e  61a0              STR      r0,[r4,#0x18]         ;1780
000070  4620              MOV      r0,r4                 ;1782
000072  f7fffffe          BL       _RMP_Set_Rdy
000076  f06f0004          MVN      r0,#4                 ;1784
00007a  63a0              STR      r0,[r4,#0x38]         ;1784
00007c  f7fffffe          BL       RMP_Unlock_Sched
000080  2000              MOVS     r0,#0                 ;1786
000082  bd10              POP      {r4,pc}
;;;1788   /* End Function:RMP_Sem_Abort ************************************************/
                          ENDP

                  |L19.132|
                          DCD      ||.data||

                          AREA ||i.RMP_Sem_Crt||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Crt PROC
;;;1555   ******************************************************************************/
;;;1556   rmp_ret_t RMP_Sem_Crt(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Number)
000000  2800              CMP      r0,#0
;;;1557   {
;;;1558       /* Check if this semaphore structure could possibly be in use */
;;;1559       if(Semaphore==0)
;;;1560       {
;;;1561           RMP_COVERAGE_MARKER();
;;;1562           return RMP_ERR_SEM;
000002  bf04              ITT      EQ
000004  f06f0005          MVNEQ    r0,#5
;;;1563       }
;;;1564       else
;;;1565           RMP_COVERAGE_MARKER();
;;;1566       
;;;1567       RMP_Lock_Sched();
;;;1568       
;;;1569       if(Semaphore->State!=RMP_SEM_FREE)
;;;1570       {
;;;1571           RMP_COVERAGE_MARKER();
;;;1572           RMP_Unlock_Sched();
;;;1573           return RMP_ERR_SEM;
;;;1574       }
;;;1575       else
;;;1576           RMP_COVERAGE_MARKER();
;;;1577       
;;;1578       /* Is the number too great to initialize? */
;;;1579       if(Number>=RMP_SEM_MAX_NUM)
;;;1580       {
;;;1581           RMP_COVERAGE_MARKER();
;;;1582           RMP_Unlock_Sched();
;;;1583           return RMP_ERR_OPER;
;;;1584       }
;;;1585       else
;;;1586           RMP_COVERAGE_MARKER();
;;;1587   
;;;1588       /* Initialize contents */
;;;1589       Semaphore->Cur_Num=Number;
;;;1590       Semaphore->State=RMP_SEM_USED;
;;;1591       RMP_List_Crt(&(Semaphore->Wait_List));
;;;1592       
;;;1593       RMP_Unlock_Sched();
;;;1594       
;;;1595       return 0;
;;;1596   }
000008  4770              BXEQ     lr
00000a  b570              PUSH     {r4-r6,lr}            ;1557
00000c  4604              MOV      r4,r0                 ;1557
00000e  460d              MOV      r5,r1                 ;1557
000010  20ff              MOVS     r0,#0xff              ;1557
000012  f7fffffe          BL       RMP_Mask_Int
000016  480e              LDR      r0,|L20.80|
000018  2101              MOVS     r1,#1                 ;1557
00001a  6081              STR      r1,[r0,#8]            ;1557  ; RMP_Sched_Locked
00001c  6842              LDR      r2,[r0,#4]            ;1557  ; RMP_Sched_Lock_Cnt
00001e  1c52              ADDS     r2,r2,#1              ;1557
000020  6042              STR      r2,[r0,#4]            ;1557  ; RMP_Sched_Lock_Cnt
000022  68a0              LDR      r0,[r4,#8]            ;1569
000024  b120              CBZ      r0,|L20.48|
000026  f7fffffe          BL       RMP_Unlock_Sched
00002a  f06f0005          MVN      r0,#5                 ;1573
00002e  bd70              POP      {r4-r6,pc}
                  |L20.48|
000030  f5b57f7a          CMP      r5,#0x3e8             ;1579
000034  d304              BCC      |L20.64|
000036  f7fffffe          BL       RMP_Unlock_Sched
00003a  f06f0004          MVN      r0,#4                 ;1583
00003e  bd70              POP      {r4-r6,pc}
                  |L20.64|
000040  60e5              STR      r5,[r4,#0xc]          ;1589
000042  60a1              STR      r1,[r4,#8]            ;1590
000044  6024              STR      r4,[r4,#0]            ;1590
000046  6064              STR      r4,[r4,#4]            ;1590
000048  f7fffffe          BL       RMP_Unlock_Sched
00004c  2000              MOVS     r0,#0                 ;1595
00004e  bd70              POP      {r4-r6,pc}
;;;1597   /* End Function:RMP_Sem_Crt **************************************************/
                          ENDP

                  |L20.80|
                          DCD      ||.data||

                          AREA ||i.RMP_Sem_Del||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Del PROC
;;;1604   ******************************************************************************/
;;;1605   rmp_ret_t RMP_Sem_Del(volatile struct RMP_Sem* Semaphore)
000000  2800              CMP      r0,#0
;;;1606   {
;;;1607       struct RMP_Thd* Thread;
;;;1608       
;;;1609       /* Check if this semaphore structure could possibly be in use */
;;;1610       if(Semaphore==0)
;;;1611       {
;;;1612           RMP_COVERAGE_MARKER();
;;;1613           return RMP_ERR_SEM;
000002  bf04              ITT      EQ
000004  f06f0005          MVNEQ    r0,#5
;;;1614       }
;;;1615       else
;;;1616           RMP_COVERAGE_MARKER();
;;;1617       
;;;1618       RMP_Lock_Sched();
;;;1619       
;;;1620       if(Semaphore->State!=RMP_SEM_USED)
;;;1621       {
;;;1622           RMP_COVERAGE_MARKER();
;;;1623           RMP_Unlock_Sched();
;;;1624           return RMP_ERR_SEM;
;;;1625       }
;;;1626       else
;;;1627           RMP_COVERAGE_MARKER();
;;;1628   
;;;1629       /* Get rid of all guys waiting on it */
;;;1630       while(&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)
;;;1631       {
;;;1632           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
;;;1633           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1634           
;;;1635           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1636           {
;;;1637               RMP_COVERAGE_MARKER();
;;;1638               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1639           }
;;;1640           else
;;;1641               RMP_COVERAGE_MARKER();
;;;1642   
;;;1643           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1644           /* Set to running if not suspended */
;;;1645           _RMP_Set_Rdy(Thread);
;;;1646           Thread->Retval=RMP_ERR_OPER;
;;;1647       }
;;;1648       Semaphore->State=RMP_SEM_FREE;
;;;1649       
;;;1650       RMP_Unlock_Sched();
;;;1651   
;;;1652       return 0;
;;;1653   }
000008  4770              BXEQ     lr
00000a  b570              PUSH     {r4-r6,lr}            ;1606
00000c  4605              MOV      r5,r0                 ;1606
00000e  20ff              MOVS     r0,#0xff              ;1606
000010  f7fffffe          BL       RMP_Mask_Int
000014  4819              LDR      r0,|L21.124|
000016  2101              MOVS     r1,#1                 ;1606
000018  6081              STR      r1,[r0,#8]            ;1606  ; RMP_Sched_Locked
00001a  6841              LDR      r1,[r0,#4]            ;1606  ; RMP_Sched_Lock_Cnt
00001c  1c49              ADDS     r1,r1,#1              ;1606
00001e  6041              STR      r1,[r0,#4]            ;1606  ; RMP_Sched_Lock_Cnt
000020  68a8              LDR      r0,[r5,#8]            ;1620
000022  2801              CMP      r0,#1                 ;1620
000024  d004              BEQ      |L21.48|
000026  f7fffffe          BL       RMP_Unlock_Sched
00002a  f06f0005          MVN      r0,#5                 ;1624
00002e  bd70              POP      {r4-r6,pc}
                  |L21.48|
000030  6868              LDR      r0,[r5,#4]            ;1630
000032  42a8              CMP      r0,r5                 ;1630
000034  bf18              IT       NE                    ;1646
000036  f06f0604          MVNNE    r6,#4                 ;1646
00003a  d018              BEQ      |L21.110|
                  |L21.60|
00003c  686c              LDR      r4,[r5,#4]            ;1632
00003e  e9d40100          LDRD     r0,r1,[r4,#0]         ;1632
000042  6008              STR      r0,[r1,#0]            ;1632
000044  6041              STR      r1,[r0,#4]            ;1632
000046  7e20              LDRB     r0,[r4,#0x18]         ;1635
000048  2808              CMP      r0,#8                 ;1635
00004a  d103              BNE      |L21.84|
00004c  e9d40102          LDRD     r0,r1,[r4,#8]         ;1635
000050  6008              STR      r0,[r1,#0]            ;1635
000052  6041              STR      r1,[r0,#4]            ;1635
                  |L21.84|
000054  69a0              LDR      r0,[r4,#0x18]         ;1643
000056  f02000ff          BIC      r0,r0,#0xff           ;1643
00005a  f0400001          ORR      r0,r0,#1              ;1643
00005e  61a0              STR      r0,[r4,#0x18]         ;1645
000060  4620              MOV      r0,r4                 ;1645
000062  f7fffffe          BL       _RMP_Set_Rdy
000066  63a6              STR      r6,[r4,#0x38]         ;1646
000068  6868              LDR      r0,[r5,#4]            ;1646
00006a  42a8              CMP      r0,r5                 ;1646
00006c  d1e6              BNE      |L21.60|
                  |L21.110|
00006e  2000              MOVS     r0,#0                 ;1648
000070  60a8              STR      r0,[r5,#8]            ;1648
000072  f7fffffe          BL       RMP_Unlock_Sched
000076  2000              MOVS     r0,#0                 ;1652
000078  bd70              POP      {r4-r6,pc}
;;;1654   /* End Function:RMP_Sem_Del **************************************************/
                          ENDP

00007a  0000              DCW      0x0000
                  |L21.124|
                          DCD      ||.data||

                          AREA ||i.RMP_Sem_Pend||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Pend PROC
;;;1662   ******************************************************************************/
;;;1663   rmp_ret_t RMP_Sem_Pend(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Slices)
000000  2800              CMP      r0,#0
;;;1664   {
;;;1665       /* Check if this semaphore structure could possibly be in use */
;;;1666       if(Semaphore==0)
;;;1667       {
;;;1668           RMP_COVERAGE_MARKER();
;;;1669           return RMP_ERR_SEM;
000002  bf04              ITT      EQ
000004  f06f0005          MVNEQ    r0,#5
;;;1670       }
;;;1671       else
;;;1672           RMP_COVERAGE_MARKER();
;;;1673       
;;;1674       RMP_Lock_Sched();
;;;1675       
;;;1676       if(Semaphore->State!=RMP_SEM_USED)
;;;1677       {
;;;1678           RMP_COVERAGE_MARKER();
;;;1679           RMP_Unlock_Sched();
;;;1680           return RMP_ERR_SEM;
;;;1681       }
;;;1682       else
;;;1683           RMP_COVERAGE_MARKER();
;;;1684       
;;;1685       /* Check if we can get one immediately */
;;;1686       if(Semaphore->Cur_Num!=0)
;;;1687       {
;;;1688           RMP_COVERAGE_MARKER();
;;;1689           Semaphore->Cur_Num--;
;;;1690           RMP_Unlock_Sched();
;;;1691           return Semaphore->Cur_Num;
;;;1692       }
;;;1693       else
;;;1694       {
;;;1695           RMP_COVERAGE_MARKER();
;;;1696           /* Cannot get one, we need to block */
;;;1697           if(Slices==0)
;;;1698           {
;;;1699               RMP_COVERAGE_MARKER();
;;;1700               RMP_Unlock_Sched();
;;;1701               return RMP_ERR_OPER;
;;;1702           }
;;;1703           else
;;;1704               RMP_COVERAGE_MARKER();
;;;1705   
;;;1706           /* We must be running - place into waitlist now */
;;;1707           _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1708           RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),Semaphore->Wait_List.Prev,&(Semaphore->Wait_List));
;;;1709           
;;;1710           if(Slices<RMP_MAX_SLICES)
;;;1711           {
;;;1712               RMP_COVERAGE_MARKER();
;;;1713               _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1714               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SEMDLY);
;;;1715           }
;;;1716           else
;;;1717           {
;;;1718               RMP_COVERAGE_MARKER();
;;;1719               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SEMBLK);
;;;1720           }
;;;1721           
;;;1722           RMP_Cur_Thd->Retval=0;
;;;1723       }
;;;1724       
;;;1725       RMP_Unlock_Sched();
;;;1726   
;;;1727       return RMP_Cur_Thd->Retval;
;;;1728   }
000008  4770              BXEQ     lr
00000a  b570              PUSH     {r4-r6,lr}            ;1664
00000c  4605              MOV      r5,r0                 ;1664
00000e  460e              MOV      r6,r1                 ;1664
000010  20ff              MOVS     r0,#0xff              ;1664
000012  f7fffffe          BL       RMP_Mask_Int
000016  4c2d              LDR      r4,|L22.204|
000018  2001              MOVS     r0,#1                 ;1664
00001a  60a0              STR      r0,[r4,#8]            ;1664  ; RMP_Sched_Locked
00001c  6860              LDR      r0,[r4,#4]            ;1664  ; RMP_Sched_Lock_Cnt
00001e  1c40              ADDS     r0,r0,#1              ;1664
000020  6060              STR      r0,[r4,#4]            ;1664  ; RMP_Sched_Lock_Cnt
000022  68a8              LDR      r0,[r5,#8]            ;1676
000024  2801              CMP      r0,#1                 ;1676
000026  d004              BEQ      |L22.50|
000028  f7fffffe          BL       RMP_Unlock_Sched
00002c  f06f0005          MVN      r0,#5                 ;1680
000030  bd70              POP      {r4-r6,pc}
                  |L22.50|
000032  68e8              LDR      r0,[r5,#0xc]          ;1686
000034  b130              CBZ      r0,|L22.68|
000036  68e8              LDR      r0,[r5,#0xc]          ;1689
000038  1e40              SUBS     r0,r0,#1              ;1689
00003a  60e8              STR      r0,[r5,#0xc]          ;1689
00003c  f7fffffe          BL       RMP_Unlock_Sched
000040  68e8              LDR      r0,[r5,#0xc]          ;1691
000042  bd70              POP      {r4-r6,pc}
                  |L22.68|
000044  b36e              CBZ      r6,|L22.162|
000046  69a0              LDR      r0,[r4,#0x18]         ;1707  ; RMP_Cur_Thd
000048  f7fffffe          BL       _RMP_Clr_Rdy
00004c  69a0              LDR      r0,[r4,#0x18]         ;1708  ; RMP_Cur_Thd
00004e  682a              LDR      r2,[r5,#0]            ;1708
000050  6028              STR      r0,[r5,#0]            ;1708
000052  6045              STR      r5,[r0,#4]            ;1708
000054  6002              STR      r2,[r0,#0]            ;1708
000056  6050              STR      r0,[r2,#4]            ;1708
000058  481d              LDR      r0,|L22.208|
00005a  4286              CMP      r6,r0                 ;1710
00005c  d226              BCS      |L22.172|
00005e  69a2              LDR      r2,[r4,#0x18]         ;1713  ; RMP_Cur_Thd
000060  4b1c              LDR      r3,|L22.212|
000062  6858              LDR      r0,[r3,#4]            ;1713  ; RMP_Delay
000064  4298              CMP      r0,r3                 ;1713
000066  d009              BEQ      |L22.124|
                  |L22.104|
000068  6a01              LDR      r1,[r0,#0x20]         ;1713
00006a  f8d4c014          LDR      r12,[r4,#0x14]        ;1713  ; RMP_Tick
00006e  eba1010c          SUB      r1,r1,r12             ;1713
000072  42b1              CMP      r1,r6                 ;1713
000074  d802              BHI      |L22.124|
000076  6840              LDR      r0,[r0,#4]            ;1713
000078  4298              CMP      r0,r3                 ;1713
00007a  d1f5              BNE      |L22.104|
                  |L22.124|
00007c  6961              LDR      r1,[r4,#0x14]         ;1713  ; RMP_Tick
00007e  4431              ADD      r1,r1,r6              ;1713
000080  6291              STR      r1,[r2,#0x28]         ;1713
000082  f1020108          ADD      r1,r2,#8              ;1713
000086  6802              LDR      r2,[r0,#0]            ;1713
000088  6001              STR      r1,[r0,#0]            ;1713
00008a  6048              STR      r0,[r1,#4]            ;1713
00008c  600a              STR      r2,[r1,#0]            ;1713
00008e  6051              STR      r1,[r2,#4]            ;1713
000090  69a0              LDR      r0,[r4,#0x18]         ;1714  ; RMP_Cur_Thd
000092  69a1              LDR      r1,[r4,#0x18]         ;1714  ; RMP_Cur_Thd
000094  6980              LDR      r0,[r0,#0x18]         ;1714
000096  f02000ff          BIC      r0,r0,#0xff           ;1714
00009a  f0400008          ORR      r0,r0,#8              ;1714
00009e  6188              STR      r0,[r1,#0x18]         ;1714
0000a0  e00c              B        |L22.188|
                  |L22.162|
0000a2  f7fffffe          BL       RMP_Unlock_Sched
0000a6  f06f0004          MVN      r0,#4                 ;1701
0000aa  bd70              POP      {r4-r6,pc}
                  |L22.172|
0000ac  69a0              LDR      r0,[r4,#0x18]         ;1719  ; RMP_Cur_Thd
0000ae  69a1              LDR      r1,[r4,#0x18]         ;1719  ; RMP_Cur_Thd
0000b0  6980              LDR      r0,[r0,#0x18]         ;1719
0000b2  f02000ff          BIC      r0,r0,#0xff           ;1719
0000b6  f0400007          ORR      r0,r0,#7              ;1719
0000ba  6188              STR      r0,[r1,#0x18]         ;1719
                  |L22.188|
0000bc  69a1              LDR      r1,[r4,#0x18]         ;1722  ; RMP_Cur_Thd
0000be  2000              MOVS     r0,#0                 ;1722
0000c0  6388              STR      r0,[r1,#0x38]         ;1725
0000c2  f7fffffe          BL       RMP_Unlock_Sched
0000c6  69a0              LDR      r0,[r4,#0x18]         ;1727  ; RMP_Cur_Thd
0000c8  6b80              LDR      r0,[r0,#0x38]         ;1727
0000ca  bd70              POP      {r4-r6,pc}
;;;1729   /* End Function:RMP_Sem_Pend *************************************************/
                          ENDP

                  |L22.204|
                          DCD      ||.data||
                  |L22.208|
                          DCD      0x000186a0
                  |L22.212|
                          DCD      ||.data||+0x20

                          AREA ||i.RMP_Sem_Post||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Post PROC
;;;1796   ******************************************************************************/
;;;1797   rmp_ret_t RMP_Sem_Post(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Number)
000000  2800              CMP      r0,#0
;;;1798   {
;;;1799       struct RMP_Thd* Thread;
;;;1800       
;;;1801       /* Check if this semaphore structure could possibly be in use */
;;;1802       if((Semaphore==0)||(Number==0))
000002  bf12              ITEE     NE
000004  2900              CMPNE    r1,#0
;;;1803       {
;;;1804           RMP_COVERAGE_MARKER();
;;;1805           return RMP_ERR_SEM;
000006  f06f0005          MVNEQ    r0,#5
;;;1806       }
;;;1807       else
;;;1808           RMP_COVERAGE_MARKER();
;;;1809       
;;;1810       RMP_Lock_Sched();
;;;1811       
;;;1812       if(Semaphore->State!=RMP_SEM_USED)
;;;1813       {
;;;1814           RMP_COVERAGE_MARKER();
;;;1815           RMP_Unlock_Sched();
;;;1816           return RMP_ERR_SEM;
;;;1817       }
;;;1818       else
;;;1819           RMP_COVERAGE_MARKER();
;;;1820       
;;;1821       /* Would the maximum value be exceeded if this is posted? */
;;;1822       if((Semaphore->Cur_Num+Number)>=RMP_SEM_MAX_NUM)
;;;1823       {
;;;1824           RMP_COVERAGE_MARKER();
;;;1825           RMP_Unlock_Sched();
;;;1826           return RMP_ERR_OPER;
;;;1827       }
;;;1828       else
;;;1829           RMP_COVERAGE_MARKER();
;;;1830       
;;;1831       Semaphore->Cur_Num+=Number;
;;;1832       /* Is there any thread waiting on it? If there are, clean them up*/
;;;1833       while((&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)&&(Semaphore->Cur_Num!=0))
;;;1834       {
;;;1835           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
;;;1836           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1837           
;;;1838           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1839           {
;;;1840               RMP_COVERAGE_MARKER();
;;;1841               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1842           }
;;;1843           else
;;;1844               RMP_COVERAGE_MARKER();
;;;1845           
;;;1846           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1847           /* Set to running if not suspended */
;;;1848           _RMP_Set_Rdy(Thread);
;;;1849   
;;;1850           /* Finally, return success */
;;;1851           Thread->Retval=0;
;;;1852           Semaphore->Cur_Num--;
;;;1853       }
;;;1854   
;;;1855       RMP_Unlock_Sched();
;;;1856       return 0;
;;;1857   }
00000a  4770              BXEQ     lr
00000c  b570              PUSH     {r4-r6,lr}            ;1798
00000e  4604              MOV      r4,r0                 ;1798
000010  460d              MOV      r5,r1                 ;1798
000012  20ff              MOVS     r0,#0xff              ;1798
000014  f7fffffe          BL       RMP_Mask_Int
000018  481f              LDR      r0,|L23.152|
00001a  2101              MOVS     r1,#1                 ;1798
00001c  6081              STR      r1,[r0,#8]            ;1798  ; RMP_Sched_Locked
00001e  6841              LDR      r1,[r0,#4]            ;1798  ; RMP_Sched_Lock_Cnt
000020  1c49              ADDS     r1,r1,#1              ;1798
000022  6041              STR      r1,[r0,#4]            ;1798  ; RMP_Sched_Lock_Cnt
000024  68a0              LDR      r0,[r4,#8]            ;1812
000026  2801              CMP      r0,#1                 ;1812
000028  d004              BEQ      |L23.52|
00002a  f7fffffe          BL       RMP_Unlock_Sched
00002e  f06f0005          MVN      r0,#5                 ;1816
000032  bd70              POP      {r4-r6,pc}
                  |L23.52|
000034  68e0              LDR      r0,[r4,#0xc]          ;1822
000036  4428              ADD      r0,r0,r5              ;1822
000038  f5b07f7a          CMP      r0,#0x3e8             ;1822
00003c  d304              BCC      |L23.72|
00003e  f7fffffe          BL       RMP_Unlock_Sched
000042  f06f0004          MVN      r0,#4                 ;1826
000046  bd70              POP      {r4-r6,pc}
                  |L23.72|
000048  68e0              LDR      r0,[r4,#0xc]          ;1831
00004a  4428              ADD      r0,r0,r5              ;1831
00004c  60e0              STR      r0,[r4,#0xc]          ;1831
00004e  2600              MOVS     r6,#0                 ;1831
000050  e018              B        |L23.132|
                  |L23.82|
000052  6865              LDR      r5,[r4,#4]            ;1835
000054  e9d50100          LDRD     r0,r1,[r5,#0]         ;1835
000058  6008              STR      r0,[r1,#0]            ;1835
00005a  6041              STR      r1,[r0,#4]            ;1835
00005c  7e28              LDRB     r0,[r5,#0x18]         ;1838
00005e  2808              CMP      r0,#8                 ;1838
000060  d103              BNE      |L23.106|
000062  e9d50102          LDRD     r0,r1,[r5,#8]         ;1838
000066  6008              STR      r0,[r1,#0]            ;1838
000068  6041              STR      r1,[r0,#4]            ;1838
                  |L23.106|
00006a  69a8              LDR      r0,[r5,#0x18]         ;1846
00006c  f02000ff          BIC      r0,r0,#0xff           ;1846
000070  f0400001          ORR      r0,r0,#1              ;1846
000074  61a8              STR      r0,[r5,#0x18]         ;1848
000076  4628              MOV      r0,r5                 ;1848
000078  f7fffffe          BL       _RMP_Set_Rdy
00007c  63ae              STR      r6,[r5,#0x38]         ;1852
00007e  68e0              LDR      r0,[r4,#0xc]          ;1852
000080  1e40              SUBS     r0,r0,#1              ;1852
000082  60e0              STR      r0,[r4,#0xc]          ;1852
                  |L23.132|
000084  6860              LDR      r0,[r4,#4]            ;1852
000086  42a0              CMP      r0,r4                 ;1852
000088  bf1c              ITT      NE                    ;1852
00008a  68e0              LDRNE    r0,[r4,#0xc]          ;1852
00008c  2800              CMPNE    r0,#0                 ;1852
00008e  d1e0              BNE      |L23.82|
000090  f7fffffe          BL       RMP_Unlock_Sched
000094  2000              MOVS     r0,#0                 ;1856
000096  bd70              POP      {r4-r6,pc}
;;;1858   /* End Function:RMP_Sem_Post *************************************************/
                          ENDP

                  |L23.152|
                          DCD      ||.data||

                          AREA ||i.RMP_Sem_Post_ISR||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Post_ISR PROC
;;;1868   ******************************************************************************/
;;;1869   rmp_ret_t RMP_Sem_Post_ISR(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Number)
000000  2800              CMP      r0,#0
;;;1870   {
;;;1871       struct RMP_Thd* Thread;
;;;1872       /* Check if this semaphore structure could possibly be in use */
;;;1873       if((Semaphore==0)||(Number==0))
000002  bf12              ITEE     NE
000004  2900              CMPNE    r1,#0
;;;1874       {
;;;1875           RMP_COVERAGE_MARKER();
;;;1876           return RMP_ERR_SEM;
000006  f06f0005          MVNEQ    r0,#5
;;;1877       }
;;;1878       else
;;;1879           RMP_COVERAGE_MARKER();
;;;1880       
;;;1881       if(Semaphore->State!=RMP_SEM_USED)
;;;1882       {
;;;1883           RMP_COVERAGE_MARKER();
;;;1884           return RMP_ERR_SEM;
;;;1885       }
;;;1886       else
;;;1887           RMP_COVERAGE_MARKER();
;;;1888   
;;;1889       /* Would the maximum value be exceeded if this is posted? */
;;;1890       if((Semaphore->Cur_Num+Number)>=RMP_SEM_MAX_NUM)
;;;1891       {
;;;1892           RMP_COVERAGE_MARKER();
;;;1893           return RMP_ERR_OPER;
;;;1894       }
;;;1895       else
;;;1896           RMP_COVERAGE_MARKER();
;;;1897       
;;;1898       Semaphore->Cur_Num+=Number;
;;;1899       /* Is there any thread waiting on it? If there are, clean them up*/
;;;1900       while((&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)&&(Semaphore->Cur_Num!=0))
;;;1901       {
;;;1902           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
;;;1903           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1904           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1905           {
;;;1906               RMP_COVERAGE_MARKER();
;;;1907               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1908           }
;;;1909           else
;;;1910               RMP_COVERAGE_MARKER();
;;;1911           
;;;1912           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1913           /* Set to running if not suspended */
;;;1914           _RMP_Set_Rdy(Thread);
;;;1915           
;;;1916           /* If schedule pending, trigger it now because we are in ISR */
;;;1917           if(RMP_Sched_Pend!=0)
;;;1918           {
;;;1919               RMP_COVERAGE_MARKER();
;;;1920               RMP_Sched_Pend=0;
;;;1921               _RMP_Yield();   
;;;1922           }
;;;1923           else
;;;1924               RMP_COVERAGE_MARKER();
;;;1925   
;;;1926           /* Finally, return success */
;;;1927           Thread->Retval=0;
;;;1928           Semaphore->Cur_Num--;
;;;1929       }
;;;1930   
;;;1931       return 0;
;;;1932   }
00000a  4770              BXEQ     lr
00000c  e92d41f0          PUSH     {r4-r8,lr}            ;1870
000010  4604              MOV      r4,r0                 ;1870
000012  6880              LDR      r0,[r0,#8]            ;1881
000014  2801              CMP      r0,#1                 ;1881
000016  bf1c              ITT      NE                    ;1884
000018  f06f0005          MVNNE    r0,#5                 ;1884
00001c  e8bd81f0          POPNE    {r4-r8,pc}
000020  68e0              LDR      r0,[r4,#0xc]          ;1890
000022  4408              ADD      r0,r0,r1              ;1890
000024  f5b07f7a          CMP      r0,#0x3e8             ;1890
000028  bf24              ITT      CS                    ;1893
00002a  f06f0004          MVNCS    r0,#4                 ;1893
00002e  e8bd81f0          POPCS    {r4-r8,pc}
000032  68e0              LDR      r0,[r4,#0xc]          ;1898
000034  4408              ADD      r0,r0,r1              ;1898
000036  60e0              STR      r0,[r4,#0xc]          ;1898
000038  4f15              LDR      r7,|L24.144|
00003a  2600              MOVS     r6,#0                 ;1917
00003c  e01e              B        |L24.124|
                  |L24.62|
00003e  6865              LDR      r5,[r4,#4]            ;1902
000040  e9d50100          LDRD     r0,r1,[r5,#0]         ;1902
000044  6008              STR      r0,[r1,#0]            ;1902
000046  6041              STR      r1,[r0,#4]            ;1902
000048  7e28              LDRB     r0,[r5,#0x18]         ;1904
00004a  2808              CMP      r0,#8                 ;1904
00004c  d103              BNE      |L24.86|
00004e  e9d50102          LDRD     r0,r1,[r5,#8]         ;1904
000052  6008              STR      r0,[r1,#0]            ;1904
000054  6041              STR      r1,[r0,#4]            ;1904
                  |L24.86|
000056  69a8              LDR      r0,[r5,#0x18]         ;1912
000058  f02000ff          BIC      r0,r0,#0xff           ;1912
00005c  f0400001          ORR      r0,r0,#1              ;1912
000060  61a8              STR      r0,[r5,#0x18]         ;1914
000062  4628              MOV      r0,r5                 ;1914
000064  f7fffffe          BL       _RMP_Set_Rdy
000068  68f8              LDR      r0,[r7,#0xc]          ;1917  ; RMP_Sched_Pend
00006a  2800              CMP      r0,#0                 ;1917
00006c  bf1c              ITT      NE                    ;1920
00006e  60fe              STRNE    r6,[r7,#0xc]          ;1920  ; RMP_Sched_Pend
000070  f7fffffe          BLNE     _RMP_Yield
000074  63ae              STR      r6,[r5,#0x38]         ;1928
000076  68e0              LDR      r0,[r4,#0xc]          ;1928
000078  1e40              SUBS     r0,r0,#1              ;1928
00007a  60e0              STR      r0,[r4,#0xc]          ;1928
                  |L24.124|
00007c  6860              LDR      r0,[r4,#4]            ;1928
00007e  42a0              CMP      r0,r4                 ;1928
000080  bf1c              ITT      NE                    ;1928
000082  68e0              LDRNE    r0,[r4,#0xc]          ;1928
000084  2800              CMPNE    r0,#0                 ;1928
000086  d1da              BNE      |L24.62|
000088  2000              MOVS     r0,#0                 ;1931
00008a  e8bd81f0          POP      {r4-r8,pc}
;;;1933   /* End Function:RMP_Sem_Post_ISR *********************************************/
                          ENDP

00008e  0000              DCW      0x0000
                  |L24.144|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Cancel||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Cancel PROC
;;;1513   ******************************************************************************/
;;;1514   rmp_ret_t RMP_Thd_Cancel(volatile struct RMP_Thd* Thread)
000000  2800              CMP      r0,#0
;;;1515   {
;;;1516       /* Check if this thread structure could possibly be in use */
;;;1517       if(Thread==0)
;;;1518       {
;;;1519           RMP_COVERAGE_MARKER();
;;;1520           return RMP_ERR_THD;
000002  bf04              ITT      EQ
000004  f04f30ff          MOVEQ    r0,#0xffffffff
;;;1521       }
;;;1522       else
;;;1523           RMP_COVERAGE_MARKER();
;;;1524       
;;;1525       RMP_Lock_Sched();
;;;1526       
;;;1527       /* Is it delayed? */
;;;1528       if(RMP_THD_STATE(Thread->State)!=RMP_THD_DELAYED)
;;;1529       {
;;;1530           RMP_COVERAGE_MARKER();
;;;1531           RMP_Unlock_Sched();
;;;1532           return RMP_ERR_STATE;
;;;1533       }
;;;1534       else
;;;1535           RMP_COVERAGE_MARKER();
;;;1536   
;;;1537       /* Delete it from the delay list */
;;;1538       RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1539       RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1540       /* Set to running if not suspended */
;;;1541       _RMP_Set_Rdy(Thread);
;;;1542       
;;;1543       Thread->Retval=RMP_ERR_OPER;
;;;1544       RMP_Unlock_Sched();
;;;1545       return 0;
;;;1546   }
000008  4770              BXEQ     lr
00000a  b510              PUSH     {r4,lr}               ;1515
00000c  4604              MOV      r4,r0                 ;1515
00000e  20ff              MOVS     r0,#0xff              ;1515
000010  f7fffffe          BL       RMP_Mask_Int
000014  4811              LDR      r0,|L25.92|
000016  2101              MOVS     r1,#1                 ;1515
000018  6081              STR      r1,[r0,#8]            ;1515  ; RMP_Sched_Locked
00001a  6841              LDR      r1,[r0,#4]            ;1515  ; RMP_Sched_Lock_Cnt
00001c  1c49              ADDS     r1,r1,#1              ;1515
00001e  6041              STR      r1,[r0,#4]            ;1515  ; RMP_Sched_Lock_Cnt
000020  69a0              LDR      r0,[r4,#0x18]         ;1528
000022  b2c0              UXTB     r0,r0                 ;1528
000024  2806              CMP      r0,#6                 ;1528
000026  d004              BEQ      |L25.50|
000028  f7fffffe          BL       RMP_Unlock_Sched
00002c  f06f0003          MVN      r0,#3                 ;1532
000030  bd10              POP      {r4,pc}
                  |L25.50|
000032  68a0              LDR      r0,[r4,#8]            ;1538
000034  68e1              LDR      r1,[r4,#0xc]          ;1538
000036  6008              STR      r0,[r1,#0]            ;1538
000038  6041              STR      r1,[r0,#4]            ;1538
00003a  69a0              LDR      r0,[r4,#0x18]         ;1539
00003c  f02000ff          BIC      r0,r0,#0xff           ;1539
000040  f0400001          ORR      r0,r0,#1              ;1539
000044  61a0              STR      r0,[r4,#0x18]         ;1539
000046  4620              MOV      r0,r4                 ;1541
000048  f7fffffe          BL       _RMP_Set_Rdy
00004c  f06f0004          MVN      r0,#4                 ;1543
000050  63a0              STR      r0,[r4,#0x38]         ;1543
000052  f7fffffe          BL       RMP_Unlock_Sched
000056  2000              MOVS     r0,#0                 ;1545
000058  bd10              POP      {r4,pc}
;;;1547   /* End Function:RMP_Thd_Cancel ***********************************************/
                          ENDP

00005a  0000              DCW      0x0000
                  |L25.92|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Crt||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Crt PROC
;;;765    ******************************************************************************/
;;;766    rmp_ret_t RMP_Thd_Crt(volatile struct RMP_Thd* Thread, void* Entry, void* Stack, void* Arg, rmp_ptr_t Prio, rmp_ptr_t Slices)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;767    {
000004  4699              MOV      r9,r3
000006  e9dd8508          LDRD     r8,r5,[sp,#0x20]
00000a  4616              MOV      r6,r2
00000c  468a              MOV      r10,r1
00000e  4604              MOV      r4,r0
;;;768        /* Check if the priority and timeslice range is correct */
;;;769        if(Prio>=RMP_MAX_PREEMPT_PRIO)
000010  f1b80f20          CMP      r8,#0x20
;;;770        {
;;;771            RMP_COVERAGE_MARKER();
;;;772            return RMP_ERR_PRIO;
000014  bf24              ITT      CS
000016  f06f0001          MVNCS    r0,#1
;;;773        }
;;;774        else
;;;775            RMP_COVERAGE_MARKER();
;;;776        
;;;777        if((Slices==0)||(Slices>=RMP_MAX_SLICES))
;;;778        {
;;;779            RMP_COVERAGE_MARKER();
;;;780            return RMP_ERR_SLICE;
;;;781        }
;;;782        else
;;;783            RMP_COVERAGE_MARKER();
;;;784        
;;;785        /* Check if this thread structure could possibly be in use */
;;;786        if(Thread==0)
;;;787        {
;;;788            RMP_COVERAGE_MARKER();
;;;789            return RMP_ERR_THD;
;;;790        }
;;;791        else
;;;792            RMP_COVERAGE_MARKER();
;;;793        
;;;794        RMP_Lock_Sched();
;;;795        
;;;796        if(RMP_THD_STATE(Thread->State)!=RMP_THD_FREE)
;;;797        {
;;;798            RMP_COVERAGE_MARKER();
;;;799            RMP_Unlock_Sched();
;;;800            return RMP_ERR_THD;
;;;801        }
;;;802        else
;;;803            RMP_COVERAGE_MARKER();
;;;804        
;;;805        /* Create the thread and insert it into the list */
;;;806        Thread->Prio=Prio;
;;;807        Thread->Slices=Slices;
;;;808        Thread->Slices_Left=Slices;
;;;809        Thread->Stack=(rmp_ptr_t)Stack;
;;;810        
;;;811        /* Initialize its stack and sending list */
;;;812        _RMP_Stack_Init((rmp_ptr_t)Entry, (rmp_ptr_t)Stack, (rmp_ptr_t)Arg);
;;;813        RMP_List_Crt(&(Thread->Snd_List));
;;;814        
;;;815        /* Notify the scheduler that we have created something new, also check locks */
;;;816        Thread->State=RMP_THD_RUNNING;
;;;817        _RMP_Set_Rdy(Thread);
;;;818        
;;;819        RMP_Unlock_Sched();
;;;820    
;;;821        return 0;
;;;822    }
00001a  e8bd87f0          POPCS    {r4-r10,pc}
00001e  2d00              CMP      r5,#0                 ;777
000020  bf1c              ITT      NE                    ;777
000022  481b              LDRNE    r0,|L26.144|
000024  4285              CMPNE    r5,r0                 ;777
000026  bf24              ITT      CS                    ;780
000028  f06f0002          MVNCS    r0,#2                 ;780
00002c  e8bd87f0          POPCS    {r4-r10,pc}
000030  2c00              CMP      r4,#0                 ;786
000032  bf04              ITT      EQ                    ;789
000034  f04f30ff          MOVEQ    r0,#0xffffffff        ;789
000038  e8bd87f0          POPEQ    {r4-r10,pc}
00003c  20ff              MOVS     r0,#0xff
00003e  f7fffffe          BL       RMP_Mask_Int
000042  4814              LDR      r0,|L26.148|
000044  2701              MOVS     r7,#1
000046  6087              STR      r7,[r0,#8]  ; RMP_Sched_Locked
000048  6841              LDR      r1,[r0,#4]  ; RMP_Sched_Lock_Cnt
00004a  1c49              ADDS     r1,r1,#1
00004c  6041              STR      r1,[r0,#4]  ; RMP_Sched_Lock_Cnt
00004e  69a0              LDR      r0,[r4,#0x18]         ;796
000050  f0100fff          TST      r0,#0xff              ;796
000054  d004              BEQ      |L26.96|
000056  f7fffffe          BL       RMP_Unlock_Sched
00005a  1eb8              SUBS     r0,r7,#2              ;800
00005c  e8bd87f0          POP      {r4-r10,pc}
                  |L26.96|
000060  f8c48024          STR      r8,[r4,#0x24]         ;806
000064  61e5              STR      r5,[r4,#0x1c]         ;807
000066  6225              STR      r5,[r4,#0x20]         ;808
000068  6366              STR      r6,[r4,#0x34]         ;809
00006a  464a              MOV      r2,r9                 ;812
00006c  4631              MOV      r1,r6                 ;812
00006e  4650              MOV      r0,r10                ;812
000070  f7fffffe          BL       _RMP_Stack_Init
000074  f1040010          ADD      r0,r4,#0x10           ;813
000078  6120              STR      r0,[r4,#0x10]         ;813
00007a  6160              STR      r0,[r4,#0x14]         ;813
00007c  61a7              STR      r7,[r4,#0x18]         ;816
00007e  4620              MOV      r0,r4                 ;817
000080  f7fffffe          BL       _RMP_Set_Rdy
000084  f7fffffe          BL       RMP_Unlock_Sched
000088  2000              MOVS     r0,#0                 ;821
00008a  e8bd87f0          POP      {r4-r10,pc}
;;;823    /* End Function:RMP_Thd_Crt **************************************************/
                          ENDP

00008e  0000              DCW      0x0000
                  |L26.144|
                          DCD      0x000186a0
                  |L26.148|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Del||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Del PROC
;;;830    ******************************************************************************/
;;;831    rmp_ret_t RMP_Thd_Del(volatile struct RMP_Thd* Thread)
000000  2800              CMP      r0,#0
;;;832    {
;;;833        struct RMP_Thd* Release;
;;;834        
;;;835        /* Check if this thread structure could possibly be in use */
;;;836        if(Thread==0)
;;;837        {
;;;838            RMP_COVERAGE_MARKER();
;;;839            return RMP_ERR_THD;
000002  bf04              ITT      EQ
000004  f04f30ff          MOVEQ    r0,#0xffffffff
;;;840        }
;;;841        else
;;;842            RMP_COVERAGE_MARKER();
;;;843        
;;;844        RMP_Lock_Sched();
;;;845        
;;;846        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;847        {
;;;848            RMP_COVERAGE_MARKER();
;;;849            RMP_Unlock_Sched();
;;;850            return RMP_ERR_THD;
;;;851        }
;;;852        else
;;;853            RMP_COVERAGE_MARKER();
;;;854        
;;;855        /* See if anyone waiting to send to this thread. If there is, release all these threads */
;;;856        while(&(Thread->Snd_List)!=Thread->Snd_List.Next)
;;;857        {
;;;858            Release=(struct RMP_Thd*)(Thread->Snd_List.Next);
;;;859            RMP_List_Del(Release->Run_Head.Prev,Release->Run_Head.Next);
;;;860            if(RMP_THD_STATE(Release->State)==RMP_THD_SNDDLY)
;;;861            {
;;;862                RMP_COVERAGE_MARKER();
;;;863                RMP_List_Del(Release->Dly_Head.Prev,Release->Dly_Head.Next);
;;;864            }
;;;865            else
;;;866                RMP_COVERAGE_MARKER();
;;;867            
;;;868            RMP_THD_STATE_SET(Release->State,RMP_THD_RUNNING);
;;;869            /* Set ready if not suspended */
;;;870            _RMP_Set_Rdy(Release);
;;;871            Release->Retval=RMP_ERR_OPER;
;;;872        }
;;;873        
;;;874        /* See what is its state */
;;;875        switch(RMP_THD_STATE(Thread->State))
;;;876        {
;;;877            case RMP_THD_RUNNING:
;;;878            {
;;;879                RMP_COVERAGE_MARKER();
;;;880                /* Clear ready if not suspended */
;;;881                _RMP_Clr_Rdy(Thread);
;;;882                break;
;;;883            }
;;;884            
;;;885            /* Do nothing if it is blocked on receive */
;;;886            case RMP_THD_RCVBLK:
;;;887            {
;;;888                RMP_COVERAGE_MARKER();
;;;889                break;
;;;890            }
;;;891            
;;;892            case RMP_THD_SNDBLK:RMP_COVERAGE_MARKER();
;;;893            case RMP_THD_SEMBLK:
;;;894            {
;;;895                RMP_COVERAGE_MARKER();
;;;896                RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;897                break;
;;;898            }
;;;899            
;;;900            case RMP_THD_SNDDLY:RMP_COVERAGE_MARKER();
;;;901            case RMP_THD_SEMDLY:
;;;902            {
;;;903                RMP_COVERAGE_MARKER();
;;;904                RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;905                /* Fall-through case */
;;;906            }
;;;907            case RMP_THD_RCVDLY:RMP_COVERAGE_MARKER();
;;;908            case RMP_THD_DELAYED:
;;;909            {
;;;910                RMP_COVERAGE_MARKER();
;;;911                RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;912                break;
;;;913            }
;;;914            /* Should not get here */
;;;915            default:while(1);
;;;916        }
;;;917        /* Set return value to failure anyway */
;;;918        Thread->Retval=RMP_ERR_OPER;
;;;919        Thread->State=RMP_THD_FREE;
;;;920        /* If we are deleting ourself, pend a yield */
;;;921        if(Thread==RMP_Cur_Thd)
;;;922        {
;;;923            RMP_COVERAGE_MARKER();
;;;924            RMP_Sched_Pend=1;
;;;925        }
;;;926        else
;;;927            RMP_COVERAGE_MARKER();
;;;928        
;;;929        RMP_Unlock_Sched();
;;;930        
;;;931        /* If we are deleting ourself, just stop the execution here */
;;;932        if(Thread==RMP_Cur_Thd)
;;;933            while(1);
;;;934        else
;;;935            RMP_COVERAGE_MARKER();
;;;936    
;;;937        return 0;
;;;938    }
000008  4770              BXEQ     lr
00000a  e92d47f0          PUSH     {r4-r10,lr}           ;832
00000e  4604              MOV      r4,r0                 ;832
000010  20ff              MOVS     r0,#0xff              ;832
000012  f7fffffe          BL       RMP_Mask_Int
000016  4e30              LDR      r6,|L27.216|
000018  f04f0901          MOV      r9,#1                 ;832
00001c  f8c69008          STR      r9,[r6,#8]            ;832  ; RMP_Sched_Locked
000020  6870              LDR      r0,[r6,#4]            ;832  ; RMP_Sched_Lock_Cnt
000022  1c40              ADDS     r0,r0,#1              ;832
000024  6070              STR      r0,[r6,#4]            ;832  ; RMP_Sched_Lock_Cnt
000026  69a0              LDR      r0,[r4,#0x18]         ;846
000028  f0100fff          TST      r0,#0xff              ;846
00002c  d00f              BEQ      |L27.78|
00002e  6960              LDR      r0,[r4,#0x14]         ;856
000030  f1040810          ADD      r8,r4,#0x10           ;856
000034  f06f0704          MVN      r7,#4                 ;871
000038  4540              CMP      r0,r8                 ;856
00003a  d01f              BEQ      |L27.124|
                  |L27.60|
00003c  6965              LDR      r5,[r4,#0x14]         ;858
00003e  e9d50100          LDRD     r0,r1,[r5,#0]         ;858
000042  6008              STR      r0,[r1,#0]            ;858
000044  6041              STR      r1,[r0,#4]            ;858
000046  7e28              LDRB     r0,[r5,#0x18]         ;860
000048  2803              CMP      r0,#3                 ;860
00004a  d10a              BNE      |L27.98|
00004c  e005              B        |L27.90|
                  |L27.78|
00004e  f7fffffe          BL       RMP_Unlock_Sched
000052  f04f30ff          MOV      r0,#0xffffffff        ;850
000056  e8bd87f0          POP      {r4-r10,pc}
                  |L27.90|
00005a  e9d50102          LDRD     r0,r1,[r5,#8]
00005e  6008              STR      r0,[r1,#0]
000060  6041              STR      r1,[r0,#4]
                  |L27.98|
000062  69a8              LDR      r0,[r5,#0x18]         ;868
000064  f02000ff          BIC      r0,r0,#0xff           ;868
000068  f0400001          ORR      r0,r0,#1              ;868
00006c  61a8              STR      r0,[r5,#0x18]         ;870
00006e  4628              MOV      r0,r5                 ;870
000070  f7fffffe          BL       _RMP_Set_Rdy
000074  63af              STR      r7,[r5,#0x38]         ;871
000076  6960              LDR      r0,[r4,#0x14]         ;871
000078  4540              CMP      r0,r8                 ;871
00007a  d1df              BNE      |L27.60|
                  |L27.124|
00007c  69a0              LDR      r0,[r4,#0x18]         ;875
00007e  b2c0              UXTB     r0,r0                 ;875
000080  2809              CMP      r0,#9                 ;875
000082  d228              BCS      |L27.214|
000084  e8dff000          TBB      [pc,r0]               ;875
000088  2705090e          DCB      0x27,0x05,0x09,0x0e
00008c  16121209          DCB      0x16,0x12,0x12,0x09
000090  0e00              DCB      0x0e,0x00
000092  4620              MOV      r0,r4                 ;881
000094  f7fffffe          BL       _RMP_Clr_Rdy
000098  e00c              B        |L27.180|
00009a  6821              LDR      r1,[r4,#0]            ;896
00009c  6860              LDR      r0,[r4,#4]            ;896
00009e  6001              STR      r1,[r0,#0]            ;896
0000a0  6048              STR      r0,[r1,#4]            ;896
0000a2  e007              B        |L27.180|
0000a4  6820              LDR      r0,[r4,#0]            ;904
0000a6  6861              LDR      r1,[r4,#4]            ;904
0000a8  6008              STR      r0,[r1,#0]            ;904
0000aa  6041              STR      r1,[r0,#4]            ;904
0000ac  68a1              LDR      r1,[r4,#8]            ;911
0000ae  68e0              LDR      r0,[r4,#0xc]          ;911
0000b0  6001              STR      r1,[r0,#0]            ;911
0000b2  6048              STR      r0,[r1,#4]            ;911
                  |L27.180|
0000b4  63a7              STR      r7,[r4,#0x38]         ;918
0000b6  2000              MOVS     r0,#0                 ;919
0000b8  61a0              STR      r0,[r4,#0x18]         ;919
0000ba  69b0              LDR      r0,[r6,#0x18]         ;921  ; RMP_Cur_Thd
0000bc  4284              CMP      r4,r0                 ;921
0000be  bf08              IT       EQ                    ;924
0000c0  f8c6900c          STREQ    r9,[r6,#0xc]          ;924  ; RMP_Sched_Pend
0000c4  f7fffffe          BL       RMP_Unlock_Sched
0000c8  69b0              LDR      r0,[r6,#0x18]         ;932  ; RMP_Cur_Thd
0000ca  4284              CMP      r4,r0                 ;932
0000cc  bf1c              ITT      NE                    ;937
0000ce  2000              MOVNE    r0,#0                 ;937
0000d0  e8bd87f0          POPNE    {r4-r10,pc}
                  |L27.212|
0000d4  e7fe              B        |L27.212|
                  |L27.214|
0000d6  e7fe              B        |L27.214|
;;;939    /* End Function:RMP_Thd_Del **************************************************/
                          ENDP

                  |L27.216|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Delay||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Delay PROC
;;;1483   ******************************************************************************/
;;;1484   rmp_ret_t RMP_Thd_Delay(rmp_ptr_t Slices)
000000  b570              PUSH     {r4-r6,lr}
;;;1485   {
000002  0005              MOVS     r5,r0
;;;1486       if((Slices==0)||(Slices>=RMP_MAX_SLICES))
000004  bf1c              ITT      NE
000006  481f              LDRNE    r0,|L28.132|
000008  42a8              CMPNE    r0,r5
;;;1487       {
;;;1488           RMP_COVERAGE_MARKER();
;;;1489           return RMP_ERR_SLICE;
00000a  bf9c              ITT      LS
00000c  f06f0002          MVNLS    r0,#2
;;;1490       }
;;;1491       else
;;;1492           RMP_COVERAGE_MARKER();
;;;1493       
;;;1494       RMP_Lock_Sched();
;;;1495   
;;;1496       /* We must be running and not suspended so we will be out of running queue */
;;;1497       _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1498       RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_DELAYED);
;;;1499       _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1500   
;;;1501       RMP_Cur_Thd->Retval=0;
;;;1502       RMP_Unlock_Sched();
;;;1503       /* Need to return if successful or not */
;;;1504       return RMP_Cur_Thd->Retval;
;;;1505   }
000010  bd70              POPLS    {r4-r6,pc}
000012  20ff              MOVS     r0,#0xff
000014  f7fffffe          BL       RMP_Mask_Int
000018  4c1b              LDR      r4,|L28.136|
00001a  2001              MOVS     r0,#1
00001c  60a0              STR      r0,[r4,#8]  ; RMP_Sched_Locked
00001e  6860              LDR      r0,[r4,#4]  ; RMP_Sched_Lock_Cnt
000020  1c40              ADDS     r0,r0,#1
000022  6060              STR      r0,[r4,#4]  ; RMP_Sched_Lock_Cnt
000024  69a0              LDR      r0,[r4,#0x18]         ;1497  ; RMP_Cur_Thd
000026  f7fffffe          BL       _RMP_Clr_Rdy
00002a  69a0              LDR      r0,[r4,#0x18]         ;1498  ; RMP_Cur_Thd
00002c  69a1              LDR      r1,[r4,#0x18]         ;1498  ; RMP_Cur_Thd
00002e  6980              LDR      r0,[r0,#0x18]         ;1498
000030  f02000ff          BIC      r0,r0,#0xff           ;1498
000034  f0400006          ORR      r0,r0,#6              ;1498
000038  6188              STR      r0,[r1,#0x18]         ;1499
00003a  f8d4c018          LDR      r12,[r4,#0x18]        ;1499  ; RMP_Cur_Thd
00003e  f1040320          ADD      r3,r4,#0x20           ;1499
000042  6859              LDR      r1,[r3,#4]            ;1499  ; RMP_Delay
000044  4299              CMP      r1,r3                 ;1499
000046  d007              BEQ      |L28.88|
                  |L28.72|
000048  6a08              LDR      r0,[r1,#0x20]         ;1499
00004a  6962              LDR      r2,[r4,#0x14]         ;1499  ; RMP_Tick
00004c  1a80              SUBS     r0,r0,r2              ;1499
00004e  42a8              CMP      r0,r5                 ;1499
000050  d802              BHI      |L28.88|
000052  6849              LDR      r1,[r1,#4]            ;1499
000054  4299              CMP      r1,r3                 ;1499
000056  d1f7              BNE      |L28.72|
                  |L28.88|
000058  6960              LDR      r0,[r4,#0x14]         ;1499  ; RMP_Tick
00005a  4428              ADD      r0,r0,r5              ;1499
00005c  f8cc0028          STR      r0,[r12,#0x28]        ;1499
000060  f10c0008          ADD      r0,r12,#8             ;1499
000064  680a              LDR      r2,[r1,#0]            ;1499
000066  6008              STR      r0,[r1,#0]            ;1499
000068  f8cc100c          STR      r1,[r12,#0xc]         ;1499
00006c  f8cc2008          STR      r2,[r12,#8]           ;1499
000070  6050              STR      r0,[r2,#4]            ;1499
000072  69a1              LDR      r1,[r4,#0x18]         ;1501  ; RMP_Cur_Thd
000074  2000              MOVS     r0,#0                 ;1501
000076  6388              STR      r0,[r1,#0x38]         ;1502
000078  f7fffffe          BL       RMP_Unlock_Sched
00007c  69a0              LDR      r0,[r4,#0x18]         ;1504  ; RMP_Cur_Thd
00007e  6b80              LDR      r0,[r0,#0x38]         ;1504
000080  bd70              POP      {r4-r6,pc}
;;;1506   /* End Function:RMP_Thd_Delay ************************************************/
                          ENDP

000082  0000              DCW      0x0000
                  |L28.132|
                          DCD      0x000186a0
                  |L28.136|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Rcv||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Rcv PROC
;;;1366   ******************************************************************************/
;;;1367   rmp_ret_t RMP_Thd_Rcv(rmp_ptr_t* Data, rmp_ptr_t Slices)
000000  2800              CMP      r0,#0
;;;1368   {
;;;1369       struct RMP_Thd* Sender;
;;;1370       
;;;1371       if(Data==0)
;;;1372       {
;;;1373           RMP_COVERAGE_MARKER();
;;;1374           return RMP_ERR_OPER;
000002  bf04              ITT      EQ
000004  f06f0004          MVNEQ    r0,#4
;;;1375       }
;;;1376       else
;;;1377           RMP_COVERAGE_MARKER();
;;;1378       
;;;1379       RMP_Lock_Sched();
;;;1380       
;;;1381       /* Is there any other guy waiting on us? If there is, unblock it and set it running */
;;;1382       Sender=0;
;;;1383       if(&(RMP_Cur_Thd->Snd_List)!=RMP_Cur_Thd->Snd_List.Next)
;;;1384       {
;;;1385           RMP_COVERAGE_MARKER();
;;;1386           /* Read the data */
;;;1387           Sender=(struct RMP_Thd*)(RMP_Cur_Thd->Snd_List.Next);
;;;1388           RMP_List_Del(Sender->Run_Head.Prev,Sender->Run_Head.Next);
;;;1389           *Data=Sender->Data;
;;;1390           /* Now we unblock it - what state is it in? */
;;;1391           if((RMP_THD_STATE(Sender->State)==RMP_THD_SNDDLY))
;;;1392           {
;;;1393               RMP_COVERAGE_MARKER();
;;;1394               RMP_List_Del(Sender->Dly_Head.Prev,Sender->Dly_Head.Next);
;;;1395           }
;;;1396           else
;;;1397               RMP_COVERAGE_MARKER();
;;;1398           
;;;1399           RMP_THD_STATE_SET(Sender->State,RMP_THD_RUNNING);
;;;1400           /* Set to running if not suspended */
;;;1401           _RMP_Set_Rdy(Sender);
;;;1402       }
;;;1403   
;;;1404       /* Check if there is a value in our mailbox. If yes, we return with that value */
;;;1405       if((RMP_Cur_Thd->State&RMP_THD_MBOXFUL)!=0)
;;;1406       {
;;;1407           RMP_COVERAGE_MARKER();
;;;1408           /* Get the value from mailbox */
;;;1409           *Data=RMP_Cur_Thd->Mailbox;
;;;1410           /* See if we unblocked a sender. If yes, we place the new value into 
;;;1411            * our mailbox and it is still full */
;;;1412           if(Sender!=0)
;;;1413               RMP_Cur_Thd->Mailbox=Sender->Data;
;;;1414           else
;;;1415               RMP_Cur_Thd->State&=~RMP_THD_MBOXFUL;
;;;1416           
;;;1417           RMP_Unlock_Sched();
;;;1418           return 0;
;;;1419       }
;;;1420       else
;;;1421       {
;;;1422           RMP_COVERAGE_MARKER();
;;;1423           
;;;1424           /* Box empty. Do we have somebody waiting? */
;;;1425           if(Sender!=0)
;;;1426           {
;;;1427               RMP_COVERAGE_MARKER();
;;;1428               RMP_Cur_Thd->Mailbox=Sender->Data;
;;;1429               RMP_Unlock_Sched();
;;;1430               return 0;
;;;1431           }
;;;1432           /* No sender waiting on us and box empty, we need to block */
;;;1433           else
;;;1434           {
;;;1435               RMP_COVERAGE_MARKER();
;;;1436               
;;;1437               if(Slices==0)
;;;1438               {
;;;1439                   RMP_COVERAGE_MARKER();
;;;1440                   RMP_Unlock_Sched();
;;;1441                   return RMP_ERR_OPER;
;;;1442               }
;;;1443               else
;;;1444                   RMP_COVERAGE_MARKER();
;;;1445   
;;;1446               /* We must be running and not suspended so we will surely be deleted from queue */
;;;1447               _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1448   
;;;1449               if(Slices<RMP_MAX_SLICES)
;;;1450               {
;;;1451                   RMP_COVERAGE_MARKER();
;;;1452                   _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1453                   RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_RCVDLY);
;;;1454               }
;;;1455               else
;;;1456               {
;;;1457                   RMP_COVERAGE_MARKER();
;;;1458                   RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_RCVBLK);
;;;1459               }
;;;1460               RMP_Unlock_Sched();
;;;1461               
;;;1462               /* Dummy read - to separate the lock & unlock. If the compiler optimizes these two
;;;1463                * functions(inline them) on some architectures sometimes we never block. */
;;;1464               *Data=RMP_Cur_Thd->Mailbox;
;;;1465               
;;;1466               /* We've been unblocked. There must be something in our mbox, or we should have failed */
;;;1467               RMP_Lock_Sched();
;;;1468               *Data=RMP_Cur_Thd->Mailbox;
;;;1469               RMP_Cur_Thd->State&=~RMP_THD_MBOXFUL;
;;;1470           }
;;;1471       }
;;;1472       
;;;1473       RMP_Unlock_Sched();
;;;1474       return RMP_Cur_Thd->Retval;
;;;1475   }
000008  4770              BXEQ     lr
00000a  e92d41f0          PUSH     {r4-r8,lr}            ;1368
00000e  4607              MOV      r7,r0                 ;1368
000010  460e              MOV      r6,r1                 ;1368
000012  20ff              MOVS     r0,#0xff              ;1368
000014  f7fffffe          BL       RMP_Mask_Int
000018  4c4c              LDR      r4,|L29.332|
00001a  f04f0801          MOV      r8,#1                 ;1368
00001e  f8c48008          STR      r8,[r4,#8]            ;1368  ; RMP_Sched_Locked
000022  6860              LDR      r0,[r4,#4]            ;1368  ; RMP_Sched_Lock_Cnt
000024  1c40              ADDS     r0,r0,#1              ;1368
000026  6060              STR      r0,[r4,#4]            ;1368  ; RMP_Sched_Lock_Cnt
000028  69a0              LDR      r0,[r4,#0x18]         ;1383  ; RMP_Cur_Thd
00002a  2500              MOVS     r5,#0                 ;1382
00002c  69a1              LDR      r1,[r4,#0x18]         ;1383  ; RMP_Cur_Thd
00002e  6940              LDR      r0,[r0,#0x14]         ;1383
000030  3110              ADDS     r1,r1,#0x10           ;1383
000032  4288              CMP      r0,r1                 ;1383
000034  d017              BEQ      |L29.102|
000036  69a0              LDR      r0,[r4,#0x18]         ;1387  ; RMP_Cur_Thd
000038  6945              LDR      r5,[r0,#0x14]         ;1387
00003a  e9d50100          LDRD     r0,r1,[r5,#0]         ;1387
00003e  6008              STR      r0,[r1,#0]            ;1387
000040  6041              STR      r1,[r0,#4]            ;1387
000042  6b28              LDR      r0,[r5,#0x30]         ;1389
000044  6038              STR      r0,[r7,#0]            ;1391
000046  7e28              LDRB     r0,[r5,#0x18]         ;1391
000048  2803              CMP      r0,#3                 ;1391
00004a  d103              BNE      |L29.84|
00004c  e9d50102          LDRD     r0,r1,[r5,#8]         ;1391
000050  6008              STR      r0,[r1,#0]            ;1391
000052  6041              STR      r1,[r0,#4]            ;1391
                  |L29.84|
000054  69a8              LDR      r0,[r5,#0x18]         ;1399
000056  f02000ff          BIC      r0,r0,#0xff           ;1399
00005a  f0400001          ORR      r0,r0,#1              ;1399
00005e  61a8              STR      r0,[r5,#0x18]         ;1401
000060  4628              MOV      r0,r5                 ;1401
000062  f7fffffe          BL       _RMP_Set_Rdy
                  |L29.102|
000066  69a0              LDR      r0,[r4,#0x18]         ;1405  ; RMP_Cur_Thd
000068  8b00              LDRH     r0,[r0,#0x18]         ;1405
00006a  f4107f00          TST      r0,#0x200             ;1405
00006e  d012              BEQ      |L29.150|
000070  69a0              LDR      r0,[r4,#0x18]         ;1409  ; RMP_Cur_Thd
000072  2d00              CMP      r5,#0                 ;1412
000074  6ac0              LDR      r0,[r0,#0x2c]         ;1409
000076  6038              STR      r0,[r7,#0]            ;1412
000078  bf01              ITTTT    EQ                    ;1415
00007a  69a0              LDREQ    r0,[r4,#0x18]         ;1415  ; RMP_Cur_Thd
00007c  6981              LDREQ    r1,[r0,#0x18]         ;1415
00007e  f4217100          BICEQ    r1,r1,#0x200          ;1415
000082  6181              STREQ    r1,[r0,#0x18]         ;1415
000084  bf1e              ITTT     NE                    ;1413
000086  6b28              LDRNE    r0,[r5,#0x30]         ;1413
000088  69a1              LDRNE    r1,[r4,#0x18]         ;1413  ; RMP_Cur_Thd
00008a  62c8              STRNE    r0,[r1,#0x2c]         ;1413
00008c  f7fffffe          BL       RMP_Unlock_Sched
000090  2000              MOVS     r0,#0                 ;1418
000092  e8bd81f0          POP      {r4-r8,pc}
                  |L29.150|
000096  b13d              CBZ      r5,|L29.168|
000098  6b28              LDR      r0,[r5,#0x30]         ;1428
00009a  69a1              LDR      r1,[r4,#0x18]         ;1428  ; RMP_Cur_Thd
00009c  62c8              STR      r0,[r1,#0x2c]         ;1429
00009e  f7fffffe          BL       RMP_Unlock_Sched
0000a2  2000              MOVS     r0,#0                 ;1430
0000a4  e8bd81f0          POP      {r4-r8,pc}
                  |L29.168|
0000a8  b33e              CBZ      r6,|L29.250|
0000aa  69a0              LDR      r0,[r4,#0x18]         ;1447  ; RMP_Cur_Thd
0000ac  f7fffffe          BL       _RMP_Clr_Rdy
0000b0  4827              LDR      r0,|L29.336|
0000b2  4286              CMP      r6,r0                 ;1449
0000b4  d227              BCS      |L29.262|
0000b6  69a2              LDR      r2,[r4,#0x18]         ;1452  ; RMP_Cur_Thd
0000b8  4b26              LDR      r3,|L29.340|
0000ba  6858              LDR      r0,[r3,#4]            ;1452  ; RMP_Delay
0000bc  4298              CMP      r0,r3                 ;1452
0000be  d009              BEQ      |L29.212|
                  |L29.192|
0000c0  6a01              LDR      r1,[r0,#0x20]         ;1452
0000c2  f8d4c014          LDR      r12,[r4,#0x14]        ;1452  ; RMP_Tick
0000c6  eba1010c          SUB      r1,r1,r12             ;1452
0000ca  42b1              CMP      r1,r6                 ;1452
0000cc  d802              BHI      |L29.212|
0000ce  6840              LDR      r0,[r0,#4]            ;1452
0000d0  4298              CMP      r0,r3                 ;1452
0000d2  d1f5              BNE      |L29.192|
                  |L29.212|
0000d4  6961              LDR      r1,[r4,#0x14]         ;1452  ; RMP_Tick
0000d6  4431              ADD      r1,r1,r6              ;1452
0000d8  6291              STR      r1,[r2,#0x28]         ;1452
0000da  f1020108          ADD      r1,r2,#8              ;1452
0000de  6802              LDR      r2,[r0,#0]            ;1452
0000e0  6001              STR      r1,[r0,#0]            ;1452
0000e2  6048              STR      r0,[r1,#4]            ;1452
0000e4  600a              STR      r2,[r1,#0]            ;1452
0000e6  6051              STR      r1,[r2,#4]            ;1452
0000e8  69a0              LDR      r0,[r4,#0x18]         ;1453  ; RMP_Cur_Thd
0000ea  69a1              LDR      r1,[r4,#0x18]         ;1453  ; RMP_Cur_Thd
0000ec  6980              LDR      r0,[r0,#0x18]         ;1453
0000ee  f02000ff          BIC      r0,r0,#0xff           ;1453
0000f2  f0400005          ORR      r0,r0,#5              ;1453
0000f6  6188              STR      r0,[r1,#0x18]         ;1453
0000f8  e00d              B        |L29.278|
                  |L29.250|
0000fa  f7fffffe          BL       RMP_Unlock_Sched
0000fe  f06f0004          MVN      r0,#4                 ;1441
000102  e8bd81f0          POP      {r4-r8,pc}
                  |L29.262|
000106  69a0              LDR      r0,[r4,#0x18]         ;1458  ; RMP_Cur_Thd
000108  69a1              LDR      r1,[r4,#0x18]         ;1458  ; RMP_Cur_Thd
00010a  6980              LDR      r0,[r0,#0x18]         ;1458
00010c  f02000ff          BIC      r0,r0,#0xff           ;1458
000110  f0400004          ORR      r0,r0,#4              ;1458
000114  6188              STR      r0,[r1,#0x18]         ;1458
                  |L29.278|
000116  f7fffffe          BL       RMP_Unlock_Sched
00011a  69a0              LDR      r0,[r4,#0x18]         ;1464  ; RMP_Cur_Thd
00011c  6ac0              LDR      r0,[r0,#0x2c]         ;1464
00011e  6038              STR      r0,[r7,#0]            ;1464
000120  20ff              MOVS     r0,#0xff              ;1464
000122  f7fffffe          BL       RMP_Mask_Int
000126  f8c48008          STR      r8,[r4,#8]            ;1464  ; RMP_Sched_Locked
00012a  6860              LDR      r0,[r4,#4]            ;1464  ; RMP_Sched_Lock_Cnt
00012c  1c40              ADDS     r0,r0,#1              ;1464
00012e  6060              STR      r0,[r4,#4]            ;1464  ; RMP_Sched_Lock_Cnt
000130  69a0              LDR      r0,[r4,#0x18]         ;1468  ; RMP_Cur_Thd
000132  6ac0              LDR      r0,[r0,#0x2c]         ;1468
000134  6038              STR      r0,[r7,#0]            ;1469
000136  69a0              LDR      r0,[r4,#0x18]         ;1469  ; RMP_Cur_Thd
000138  6981              LDR      r1,[r0,#0x18]         ;1469
00013a  f4217100          BIC      r1,r1,#0x200          ;1469
00013e  6181              STR      r1,[r0,#0x18]         ;1473
000140  f7fffffe          BL       RMP_Unlock_Sched
000144  69a0              LDR      r0,[r4,#0x18]         ;1474  ; RMP_Cur_Thd
000146  6b80              LDR      r0,[r0,#0x38]         ;1474
000148  e8bd81f0          POP      {r4-r8,pc}
;;;1476   /* End Function:RMP_Thd_Rcv **************************************************/
                          ENDP

                  |L29.332|
                          DCD      ||.data||
                  |L29.336|
                          DCD      0x000186a0
                  |L29.340|
                          DCD      ||.data||+0x20

                          AREA ||i.RMP_Thd_Resume||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Resume PROC
;;;1110   ******************************************************************************/
;;;1111   rmp_ret_t RMP_Thd_Resume(volatile struct RMP_Thd* Thread)
000000  2800              CMP      r0,#0
;;;1112   {
;;;1113       rmp_ret_t Retval;
;;;1114       
;;;1115       /* Check if this thread structure could possibly be in use */
;;;1116       if(Thread==0)
;;;1117       {
;;;1118           RMP_COVERAGE_MARKER();
;;;1119           return RMP_ERR_THD;
000002  bf04              ITT      EQ
000004  f04f30ff          MOVEQ    r0,#0xffffffff
;;;1120       }
;;;1121       else
;;;1122           RMP_COVERAGE_MARKER();
;;;1123   
;;;1124       RMP_Lock_Sched();
;;;1125       
;;;1126       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;1127       {
;;;1128           RMP_COVERAGE_MARKER();
;;;1129           RMP_Unlock_Sched();
;;;1130           return RMP_ERR_THD;
;;;1131       }
;;;1132       else
;;;1133           RMP_COVERAGE_MARKER();
;;;1134       
;;;1135       /* Check if the thread is suspended, if not, then throw an error */
;;;1136       if((Thread->State&RMP_THD_SUSPENDED)!=0)
;;;1137       {
;;;1138           RMP_COVERAGE_MARKER();
;;;1139           
;;;1140           /* Suspended */
;;;1141           Thread->State&=~RMP_THD_SUSPENDED;
;;;1142           /* Only when it is running will we put it back. It can't be suspended here, 
;;;1143            * so the set ready operation will surely put it back */
;;;1144           if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
;;;1145           {
;;;1146               RMP_COVERAGE_MARKER();
;;;1147               _RMP_Set_Rdy(Thread);
;;;1148           }
;;;1149           else
;;;1150               RMP_COVERAGE_MARKER();
;;;1151           
;;;1152           Retval=0;
;;;1153       }
;;;1154       else
;;;1155       {
;;;1156           RMP_COVERAGE_MARKER();
;;;1157           Retval=RMP_ERR_STATE;
;;;1158       }
;;;1159       
;;;1160       RMP_Unlock_Sched();
;;;1161   
;;;1162       return Retval;
;;;1163   }
000008  4770              BXEQ     lr
00000a  b510              PUSH     {r4,lr}               ;1112
00000c  4604              MOV      r4,r0                 ;1112
00000e  20ff              MOVS     r0,#0xff              ;1112
000010  f7fffffe          BL       RMP_Mask_Int
000014  4812              LDR      r0,|L30.96|
000016  2101              MOVS     r1,#1                 ;1112
000018  6081              STR      r1,[r0,#8]            ;1112  ; RMP_Sched_Locked
00001a  6841              LDR      r1,[r0,#4]            ;1112  ; RMP_Sched_Lock_Cnt
00001c  1c49              ADDS     r1,r1,#1              ;1112
00001e  6041              STR      r1,[r0,#4]            ;1112  ; RMP_Sched_Lock_Cnt
000020  69a0              LDR      r0,[r4,#0x18]         ;1126
000022  f0100fff          TST      r0,#0xff              ;1126
000026  d016              BEQ      |L30.86|
000028  69a0              LDR      r0,[r4,#0x18]         ;1136
00002a  f4107f80          TST      r0,#0x100             ;1136
00002e  bf08              IT       EQ                    ;1157
000030  f06f0403          MVNEQ    r4,#3                 ;1157
000034  d00b              BEQ      |L30.78|
000036  69a0              LDR      r0,[r4,#0x18]         ;1141
000038  f4207080          BIC      r0,r0,#0x100          ;1141
00003c  61a0              STR      r0,[r4,#0x18]         ;1141
00003e  69a0              LDR      r0,[r4,#0x18]         ;1144
000040  b2c0              UXTB     r0,r0                 ;1144
000042  2801              CMP      r0,#1                 ;1144
000044  bf04              ITT      EQ                    ;1147
000046  4620              MOVEQ    r0,r4                 ;1147
000048  f7fffffe          BLEQ     _RMP_Set_Rdy
00004c  2400              MOVS     r4,#0                 ;1152
                  |L30.78|
00004e  f7fffffe          BL       RMP_Unlock_Sched
000052  4620              MOV      r0,r4                 ;1162
000054  bd10              POP      {r4,pc}
                  |L30.86|
000056  f7fffffe          BL       RMP_Unlock_Sched
00005a  f04f30ff          MOV      r0,#0xffffffff        ;1130
00005e  bd10              POP      {r4,pc}
;;;1164   /* End Function:RMP_Thd_Resume ***********************************************/
                          ENDP

                  |L30.96|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Set||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Set PROC
;;;950    ******************************************************************************/
;;;951    rmp_ret_t RMP_Thd_Set(volatile struct RMP_Thd* Thread, rmp_ptr_t Prio, rmp_ptr_t Slices)
000000  2a00              CMP      r2,#0
;;;952    {
;;;953        /* Check if the priority and timeslice range is correct */
;;;954        if(Slices==0)
;;;955        {
;;;956            RMP_COVERAGE_MARKER();
;;;957            return RMP_ERR_SLICE;
000002  bf04              ITT      EQ
000004  f06f0002          MVNEQ    r0,#2
;;;958        }
;;;959        else
;;;960            RMP_COVERAGE_MARKER();
;;;961        
;;;962        /* Check if this thread structure could possibly be in use */
;;;963        if(Thread==0)
;;;964        {
;;;965            RMP_COVERAGE_MARKER();
;;;966            return RMP_ERR_THD;
;;;967        }
;;;968        else
;;;969            RMP_COVERAGE_MARKER();
;;;970        
;;;971        RMP_Lock_Sched();
;;;972        
;;;973        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;974        {
;;;975            RMP_COVERAGE_MARKER();
;;;976            RMP_Unlock_Sched();
;;;977            return RMP_ERR_THD;
;;;978        }
;;;979        else
;;;980            RMP_COVERAGE_MARKER();
;;;981        
;;;982        /* See if the thread is in running state */
;;;983        if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
;;;984        {
;;;985            RMP_COVERAGE_MARKER();
;;;986            
;;;987            /* See if we are gonna change one of it or both */
;;;988            if(Prio<RMP_MAX_PREEMPT_PRIO)
;;;989            {
;;;990                RMP_COVERAGE_MARKER();
;;;991                if(Thread->Prio!=Prio)
;;;992                {
;;;993                    RMP_COVERAGE_MARKER();
;;;994                    /* It doesn't matter whether this is suspended or not. 
;;;995                     * If suspended, the operations will not be conducted. */
;;;996                    _RMP_Clr_Rdy(Thread);
;;;997                    Thread->Prio=Prio;
;;;998                    _RMP_Set_Rdy(Thread);
;;;999                }
;;;1000               else
;;;1001                   RMP_COVERAGE_MARKER();
;;;1002           }
;;;1003           else
;;;1004               RMP_COVERAGE_MARKER();
;;;1005           
;;;1006           if(Slices<RMP_MAX_SLICES)
;;;1007           {
;;;1008               RMP_COVERAGE_MARKER();
;;;1009               Thread->Slices=Slices;
;;;1010           }
;;;1011           else
;;;1012               RMP_COVERAGE_MARKER();
;;;1013       }
;;;1014       else
;;;1015       {
;;;1016           RMP_COVERAGE_MARKER();
;;;1017           
;;;1018           if(Prio<RMP_MAX_PREEMPT_PRIO)
;;;1019           {
;;;1020               RMP_COVERAGE_MARKER();
;;;1021               Thread->Prio=Prio;
;;;1022           }
;;;1023           else
;;;1024               RMP_COVERAGE_MARKER();
;;;1025           
;;;1026           if(Slices<RMP_MAX_SLICES)
;;;1027           {
;;;1028               RMP_COVERAGE_MARKER();
;;;1029               Thread->Slices=Slices;
;;;1030           }
;;;1031           else
;;;1032               RMP_COVERAGE_MARKER();
;;;1033       }
;;;1034       
;;;1035       RMP_Unlock_Sched();
;;;1036       return 0;
;;;1037   }
000008  4770              BXEQ     lr
00000a  2800              CMP      r0,#0                 ;963
00000c  bf04              ITT      EQ                    ;966
00000e  f04f30ff          MOVEQ    r0,#0xffffffff        ;966
000012  4770              BXEQ     lr
000014  e92d41f0          PUSH     {r4-r8,lr}            ;952
000018  4604              MOV      r4,r0                 ;952
00001a  4615              MOV      r5,r2                 ;952
00001c  460e              MOV      r6,r1                 ;952
00001e  20ff              MOVS     r0,#0xff              ;952
000020  f7fffffe          BL       RMP_Mask_Int
000024  4817              LDR      r0,|L31.132|
000026  2101              MOVS     r1,#1                 ;952
000028  6081              STR      r1,[r0,#8]            ;952  ; RMP_Sched_Locked
00002a  6841              LDR      r1,[r0,#4]            ;952  ; RMP_Sched_Lock_Cnt
00002c  1c49              ADDS     r1,r1,#1              ;952
00002e  6041              STR      r1,[r0,#4]            ;952  ; RMP_Sched_Lock_Cnt
000030  69a0              LDR      r0,[r4,#0x18]         ;973
000032  f0100fff          TST      r0,#0xff              ;973
000036  d00f              BEQ      |L31.88|
000038  69a0              LDR      r0,[r4,#0x18]         ;983
00003a  4f13              LDR      r7,|L31.136|
00003c  b2c0              UXTB     r0,r0                 ;983
00003e  2801              CMP      r0,#1                 ;983
000040  d010              BEQ      |L31.100|
000042  2e20              CMP      r6,#0x20              ;1018
000044  bf38              IT       CC                    ;1021
000046  6266              STRCC    r6,[r4,#0x24]         ;1021
000048  42bd              CMP      r5,r7                 ;1026
00004a  d200              BCS      |L31.78|
                  |L31.76|
00004c  61e5              STR      r5,[r4,#0x1c]         ;1029
                  |L31.78|
00004e  f7fffffe          BL       RMP_Unlock_Sched
000052  2000              MOVS     r0,#0                 ;1036
000054  e8bd81f0          POP      {r4-r8,pc}
                  |L31.88|
000058  f7fffffe          BL       RMP_Unlock_Sched
00005c  f04f30ff          MOV      r0,#0xffffffff        ;977
000060  e8bd81f0          POP      {r4-r8,pc}
                  |L31.100|
000064  2e20              CMP      r6,#0x20              ;988
000066  d209              BCS      |L31.124|
000068  6a60              LDR      r0,[r4,#0x24]         ;991
00006a  42b0              CMP      r0,r6                 ;991
00006c  d006              BEQ      |L31.124|
00006e  4620              MOV      r0,r4                 ;996
000070  f7fffffe          BL       _RMP_Clr_Rdy
000074  6266              STR      r6,[r4,#0x24]         ;997
000076  4620              MOV      r0,r4                 ;998
000078  f7fffffe          BL       _RMP_Set_Rdy
                  |L31.124|
00007c  42bd              CMP      r5,r7                 ;1006
00007e  d2e6              BCS      |L31.78|
000080  e7e4              B        |L31.76|
;;;1038   /* End Function:RMP_Thd_Set **************************************************/
                          ENDP

000082  0000              DCW      0x0000
                  |L31.132|
                          DCD      ||.data||
                  |L31.136|
                          DCD      0x000186a0

                          AREA ||i.RMP_Thd_Snd||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Snd PROC
;;;1174   ******************************************************************************/
;;;1175   rmp_ret_t RMP_Thd_Snd(volatile struct RMP_Thd* Thread, rmp_ptr_t Data, rmp_ptr_t Slices)
000000  2800              CMP      r0,#0
;;;1176   {
;;;1177       /* Check if this thread structure could possibly be in use */
;;;1178       if(Thread==0)
;;;1179       {
;;;1180           RMP_COVERAGE_MARKER();
;;;1181           return RMP_ERR_THD;
000002  bf04              ITT      EQ
000004  f04f30ff          MOVEQ    r0,#0xffffffff
;;;1182       }
;;;1183       else
;;;1184           RMP_COVERAGE_MARKER();
;;;1185       
;;;1186       RMP_Lock_Sched();
;;;1187       
;;;1188       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;1189       {
;;;1190           RMP_COVERAGE_MARKER();
;;;1191           RMP_Unlock_Sched();
;;;1192           return RMP_ERR_THD;
;;;1193       }
;;;1194       else
;;;1195           RMP_COVERAGE_MARKER();
;;;1196       
;;;1197       /* Are we sending to ourself? This is not allowed */
;;;1198       if(RMP_Cur_Thd==Thread)
;;;1199       {
;;;1200           RMP_COVERAGE_MARKER();
;;;1201           RMP_Unlock_Sched();
;;;1202           return RMP_ERR_OPER;
;;;1203       }
;;;1204       else
;;;1205           RMP_COVERAGE_MARKER();
;;;1206       
;;;1207       RMP_Cur_Thd->Retval=0;
;;;1208   
;;;1209       /* See if there is already a value in the mailbox, if yes, we block */
;;;1210       if((Thread->State&RMP_THD_MBOXFUL)!=0)
;;;1211       {
;;;1212           RMP_COVERAGE_MARKER();
;;;1213           
;;;1214           /* Mailbox full, we block, and put ourself into the queue */
;;;1215           if(Slices==0)
;;;1216           {
;;;1217               RMP_COVERAGE_MARKER();
;;;1218               RMP_Unlock_Sched();
;;;1219               return RMP_ERR_OPER;
;;;1220           }
;;;1221           else
;;;1222               RMP_COVERAGE_MARKER();
;;;1223   
;;;1224           /* We must be running */
;;;1225           _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1226           RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),Thread->Snd_List.Prev,&(Thread->Snd_List));
;;;1227   
;;;1228           if(Slices<RMP_MAX_SLICES)
;;;1229           {
;;;1230               RMP_COVERAGE_MARKER();
;;;1231               _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1232               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SNDDLY);
;;;1233           }
;;;1234           else
;;;1235           {
;;;1236               RMP_COVERAGE_MARKER();
;;;1237               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SNDBLK);
;;;1238           }
;;;1239   
;;;1240           RMP_Cur_Thd->Data=Data;
;;;1241       }
;;;1242       else
;;;1243       {
;;;1244           RMP_COVERAGE_MARKER();
;;;1245           
;;;1246           /* Mailbox not full. We need to check if the receiver is waiting for us */
;;;1247           if((RMP_THD_STATE(Thread->State)==RMP_THD_RCVBLK)||
;;;1248              (RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY))
;;;1249           {
;;;1250               RMP_COVERAGE_MARKER();
;;;1251               
;;;1252               /* The receiver is blocked, wake it up and return the value */
;;;1253               if(RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY)
;;;1254               {
;;;1255                   RMP_COVERAGE_MARKER();
;;;1256                   RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1257               }
;;;1258               else
;;;1259                   RMP_COVERAGE_MARKER();
;;;1260               
;;;1261               RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1262               /* Set to running if not suspended */
;;;1263               _RMP_Set_Rdy(Thread);
;;;1264           }
;;;1265           else
;;;1266               RMP_COVERAGE_MARKER();
;;;1267           
;;;1268           /* Set the mailbox */
;;;1269           Thread->Mailbox=Data;
;;;1270           Thread->State|=RMP_THD_MBOXFUL;
;;;1271       }
;;;1272       
;;;1273       RMP_Unlock_Sched();
;;;1274   
;;;1275       return RMP_Cur_Thd->Retval;
;;;1276   }
000008  4770              BXEQ     lr
00000a  e92d41f0          PUSH     {r4-r8,lr}            ;1176
00000e  4605              MOV      r5,r0                 ;1176
000010  4616              MOV      r6,r2                 ;1176
000012  460f              MOV      r7,r1                 ;1176
000014  20ff              MOVS     r0,#0xff              ;1176
000016  f7fffffe          BL       RMP_Mask_Int
00001a  4c40              LDR      r4,|L32.284|
00001c  2001              MOVS     r0,#1                 ;1176
00001e  60a0              STR      r0,[r4,#8]            ;1176  ; RMP_Sched_Locked
000020  6860              LDR      r0,[r4,#4]            ;1176  ; RMP_Sched_Lock_Cnt
000022  1c40              ADDS     r0,r0,#1              ;1176
000024  6060              STR      r0,[r4,#4]            ;1176  ; RMP_Sched_Lock_Cnt
000026  69a8              LDR      r0,[r5,#0x18]         ;1188
000028  f0100fff          TST      r0,#0xff              ;1188
00002c  d03b              BEQ      |L32.166|
00002e  69a0              LDR      r0,[r4,#0x18]         ;1198  ; RMP_Cur_Thd
000030  42a8              CMP      r0,r5                 ;1198
000032  d03e              BEQ      |L32.178|
000034  69a1              LDR      r1,[r4,#0x18]         ;1207  ; RMP_Cur_Thd
000036  2000              MOVS     r0,#0                 ;1207
000038  6388              STR      r0,[r1,#0x38]         ;1210
00003a  69a8              LDR      r0,[r5,#0x18]         ;1210
00003c  f4107f00          TST      r0,#0x200             ;1210
000040  d048              BEQ      |L32.212|
000042  2e00              CMP      r6,#0                 ;1215
000044  d035              BEQ      |L32.178|
000046  69a0              LDR      r0,[r4,#0x18]         ;1225  ; RMP_Cur_Thd
000048  f7fffffe          BL       _RMP_Clr_Rdy
00004c  69a0              LDR      r0,[r4,#0x18]         ;1226  ; RMP_Cur_Thd
00004e  f8551f10          LDR      r1,[r5,#0x10]!        ;1226
000052  6028              STR      r0,[r5,#0]            ;1226
000054  6045              STR      r5,[r0,#4]            ;1226
000056  6001              STR      r1,[r0,#0]            ;1226
000058  6048              STR      r0,[r1,#4]            ;1226
00005a  4831              LDR      r0,|L32.288|
00005c  4286              CMP      r6,r0                 ;1228
00005e  d22e              BCS      |L32.190|
000060  69a3              LDR      r3,[r4,#0x18]         ;1231  ; RMP_Cur_Thd
000062  f1040220          ADD      r2,r4,#0x20           ;1231
000066  6850              LDR      r0,[r2,#4]            ;1231  ; RMP_Delay
000068  4290              CMP      r0,r2                 ;1231
00006a  d009              BEQ      |L32.128|
                  |L32.108|
00006c  6a01              LDR      r1,[r0,#0x20]         ;1231
00006e  f8d4c014          LDR      r12,[r4,#0x14]        ;1231  ; RMP_Tick
000072  eba1010c          SUB      r1,r1,r12             ;1231
000076  42b1              CMP      r1,r6                 ;1231
000078  d802              BHI      |L32.128|
00007a  6840              LDR      r0,[r0,#4]            ;1231
00007c  4290              CMP      r0,r2                 ;1231
00007e  d1f5              BNE      |L32.108|
                  |L32.128|
000080  6961              LDR      r1,[r4,#0x14]         ;1231  ; RMP_Tick
000082  4431              ADD      r1,r1,r6              ;1231
000084  6299              STR      r1,[r3,#0x28]         ;1231
000086  f1030208          ADD      r2,r3,#8              ;1231
00008a  6801              LDR      r1,[r0,#0]            ;1231
00008c  6002              STR      r2,[r0,#0]            ;1231
00008e  60d8              STR      r0,[r3,#0xc]          ;1231
000090  6099              STR      r1,[r3,#8]            ;1231
000092  604a              STR      r2,[r1,#4]            ;1231
000094  69a0              LDR      r0,[r4,#0x18]         ;1232  ; RMP_Cur_Thd
000096  69a1              LDR      r1,[r4,#0x18]         ;1232  ; RMP_Cur_Thd
000098  6980              LDR      r0,[r0,#0x18]         ;1232
00009a  f02000ff          BIC      r0,r0,#0xff           ;1232
00009e  f0400003          ORR      r0,r0,#3              ;1232
0000a2  6188              STR      r0,[r1,#0x18]         ;1232
0000a4  e013              B        |L32.206|
                  |L32.166|
0000a6  f7fffffe          BL       RMP_Unlock_Sched
0000aa  f04f30ff          MOV      r0,#0xffffffff        ;1192
0000ae  e8bd81f0          POP      {r4-r8,pc}
                  |L32.178|
0000b2  f7fffffe          BL       RMP_Unlock_Sched
0000b6  f06f0004          MVN      r0,#4                 ;1219
0000ba  e8bd81f0          POP      {r4-r8,pc}
                  |L32.190|
0000be  69a0              LDR      r0,[r4,#0x18]         ;1237  ; RMP_Cur_Thd
0000c0  69a1              LDR      r1,[r4,#0x18]         ;1237  ; RMP_Cur_Thd
0000c2  6980              LDR      r0,[r0,#0x18]         ;1237
0000c4  f02000ff          BIC      r0,r0,#0xff           ;1237
0000c8  f0400002          ORR      r0,r0,#2              ;1237
0000cc  6188              STR      r0,[r1,#0x18]         ;1237
                  |L32.206|
0000ce  69a0              LDR      r0,[r4,#0x18]         ;1240  ; RMP_Cur_Thd
0000d0  6307              STR      r7,[r0,#0x30]         ;1240
0000d2  e01d              B        |L32.272|
                  |L32.212|
0000d4  69a8              LDR      r0,[r5,#0x18]         ;1247
0000d6  b2c0              UXTB     r0,r0                 ;1247
0000d8  2804              CMP      r0,#4                 ;1247
0000da  d003              BEQ      |L32.228|
0000dc  69a8              LDR      r0,[r5,#0x18]         ;1247
0000de  b2c0              UXTB     r0,r0                 ;1247
0000e0  2805              CMP      r0,#5                 ;1247
0000e2  d110              BNE      |L32.262|
                  |L32.228|
0000e4  69a8              LDR      r0,[r5,#0x18]         ;1253
0000e6  b2c0              UXTB     r0,r0                 ;1253
0000e8  2805              CMP      r0,#5                 ;1253
0000ea  d103              BNE      |L32.244|
0000ec  68a8              LDR      r0,[r5,#8]            ;1256
0000ee  68e9              LDR      r1,[r5,#0xc]          ;1256
0000f0  6008              STR      r0,[r1,#0]            ;1256
0000f2  6041              STR      r1,[r0,#4]            ;1256
                  |L32.244|
0000f4  69a8              LDR      r0,[r5,#0x18]         ;1261
0000f6  f02000ff          BIC      r0,r0,#0xff           ;1261
0000fa  f0400001          ORR      r0,r0,#1              ;1261
0000fe  61a8              STR      r0,[r5,#0x18]         ;1261
000100  4628              MOV      r0,r5                 ;1263
000102  f7fffffe          BL       _RMP_Set_Rdy
                  |L32.262|
000106  62ef              STR      r7,[r5,#0x2c]         ;1269
000108  69a8              LDR      r0,[r5,#0x18]         ;1270
00010a  f4407000          ORR      r0,r0,#0x200          ;1270
00010e  61a8              STR      r0,[r5,#0x18]         ;1270
                  |L32.272|
000110  f7fffffe          BL       RMP_Unlock_Sched
000114  69a0              LDR      r0,[r4,#0x18]         ;1275  ; RMP_Cur_Thd
000116  6b80              LDR      r0,[r0,#0x38]         ;1275
000118  e8bd81f0          POP      {r4-r8,pc}
;;;1277   /* End Function:RMP_Thd_Snd **************************************************/
                          ENDP

                  |L32.284|
                          DCD      ||.data||
                  |L32.288|
                          DCD      0x000186a0

                          AREA ||i.RMP_Thd_Snd_ISR||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Snd_ISR PROC
;;;1289   ******************************************************************************/
;;;1290   rmp_ret_t RMP_Thd_Snd_ISR(volatile struct RMP_Thd* Thread, rmp_ptr_t Data)
000000  2800              CMP      r0,#0
;;;1291   {
;;;1292       /* Check if this thread structure could possibly be in use */
;;;1293       if(Thread==0)
;;;1294       {
;;;1295           RMP_COVERAGE_MARKER();
;;;1296           return RMP_ERR_THD;
000002  bf04              ITT      EQ
000004  f04f30ff          MOVEQ    r0,#0xffffffff
;;;1297       }
;;;1298       else
;;;1299           RMP_COVERAGE_MARKER();
;;;1300       
;;;1301       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;1302       {
;;;1303           RMP_COVERAGE_MARKER();
;;;1304           return RMP_ERR_THD;
;;;1305       }
;;;1306       else
;;;1307           RMP_COVERAGE_MARKER();
;;;1308   
;;;1309       /* See if there is already a value in the mailbox, if yes, we abort */
;;;1310       if((Thread->State&RMP_THD_MBOXFUL)!=0)
;;;1311       {
;;;1312           RMP_COVERAGE_MARKER();
;;;1313           return RMP_ERR_OPER;
;;;1314       }
;;;1315       else
;;;1316       {
;;;1317           RMP_COVERAGE_MARKER();
;;;1318           
;;;1319           /* Mailbox not full. We need to check if the receiver is waiting for us */
;;;1320           if((RMP_THD_STATE(Thread->State)==RMP_THD_RCVBLK)||
;;;1321              (RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY))
;;;1322           {
;;;1323               RMP_COVERAGE_MARKER();
;;;1324   
;;;1325               /* The receiver is blocked, wake it up and return the value */
;;;1326               if(RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY)
;;;1327               {
;;;1328                   RMP_COVERAGE_MARKER();
;;;1329                   RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1330               }
;;;1331               else
;;;1332                   RMP_COVERAGE_MARKER();
;;;1333               
;;;1334               RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1335   
;;;1336               /* Set to running if not suspended */
;;;1337               _RMP_Set_Rdy(Thread);
;;;1338   
;;;1339               /* If schedule pending, trigger it now because we are in ISR */
;;;1340               if(RMP_Sched_Pend!=0)
;;;1341               {
;;;1342                   RMP_COVERAGE_MARKER();
;;;1343                   RMP_Sched_Pend=0;
;;;1344                   _RMP_Yield();
;;;1345               }
;;;1346               else
;;;1347                   RMP_COVERAGE_MARKER();
;;;1348           }
;;;1349           else
;;;1350               RMP_COVERAGE_MARKER();
;;;1351           
;;;1352           /* Set the mailbox */
;;;1353           Thread->Mailbox=Data;
;;;1354           Thread->State|=RMP_THD_MBOXFUL;
;;;1355       }
;;;1356   
;;;1357       return 0;
;;;1358   }
000008  4770              BXEQ     lr
00000a  b570              PUSH     {r4-r6,lr}            ;1291
00000c  4604              MOV      r4,r0                 ;1291
00000e  6980              LDR      r0,[r0,#0x18]         ;1301
000010  460d              MOV      r5,r1                 ;1291
000012  f0100fff          TST      r0,#0xff              ;1301
000016  bf04              ITT      EQ                    ;1304
000018  f04f30ff          MOVEQ    r0,#0xffffffff        ;1304
00001c  bd70              POPEQ    {r4-r6,pc}
00001e  69a0              LDR      r0,[r4,#0x18]         ;1310
000020  f4107f00          TST      r0,#0x200             ;1310
000024  bf1c              ITT      NE                    ;1313
000026  f06f0004          MVNNE    r0,#4                 ;1313
00002a  bd70              POPNE    {r4-r6,pc}
00002c  69a0              LDR      r0,[r4,#0x18]         ;1320
00002e  b2c0              UXTB     r0,r0                 ;1320
000030  2804              CMP      r0,#4                 ;1320
000032  d003              BEQ      |L33.60|
000034  69a0              LDR      r0,[r4,#0x18]         ;1320
000036  b2c0              UXTB     r0,r0                 ;1320
000038  2805              CMP      r0,#5                 ;1320
00003a  d117              BNE      |L33.108|
                  |L33.60|
00003c  69a0              LDR      r0,[r4,#0x18]         ;1326
00003e  b2c0              UXTB     r0,r0                 ;1326
000040  2805              CMP      r0,#5                 ;1326
000042  d103              BNE      |L33.76|
000044  68a0              LDR      r0,[r4,#8]            ;1329
000046  68e2              LDR      r2,[r4,#0xc]          ;1329
000048  6010              STR      r0,[r2,#0]            ;1329
00004a  6042              STR      r2,[r0,#4]            ;1329
                  |L33.76|
00004c  69a0              LDR      r0,[r4,#0x18]         ;1334
00004e  f02000ff          BIC      r0,r0,#0xff           ;1334
000052  f0400001          ORR      r0,r0,#1              ;1334
000056  61a0              STR      r0,[r4,#0x18]         ;1334
000058  4620              MOV      r0,r4                 ;1337
00005a  f7fffffe          BL       _RMP_Set_Rdy
00005e  4807              LDR      r0,|L33.124|
000060  68c1              LDR      r1,[r0,#0xc]          ;1340  ; RMP_Sched_Pend
000062  b119              CBZ      r1,|L33.108|
000064  2100              MOVS     r1,#0                 ;1343
000066  60c1              STR      r1,[r0,#0xc]          ;1343  ; RMP_Sched_Pend
000068  f7fffffe          BL       _RMP_Yield
                  |L33.108|
00006c  62e5              STR      r5,[r4,#0x2c]         ;1353
00006e  69a0              LDR      r0,[r4,#0x18]         ;1354
000070  f4407000          ORR      r0,r0,#0x200          ;1354
000074  61a0              STR      r0,[r4,#0x18]         ;1354
000076  2000              MOVS     r0,#0                 ;1357
000078  bd70              POP      {r4-r6,pc}
;;;1359   /* End Function:RMP_Thd_Snd_ISR **********************************************/
                          ENDP

00007a  0000              DCW      0x0000
                  |L33.124|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Suspend||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Suspend PROC
;;;1045   ******************************************************************************/
;;;1046   rmp_ret_t RMP_Thd_Suspend(volatile struct RMP_Thd* Thread)
000000  2800              CMP      r0,#0
;;;1047   {
;;;1048       /* Check if this thread structure could possibly be in use */
;;;1049       if(Thread==0)
;;;1050       {
;;;1051           RMP_COVERAGE_MARKER();
;;;1052           return RMP_ERR_THD;
000002  bf04              ITT      EQ
000004  f04f30ff          MOVEQ    r0,#0xffffffff
;;;1053       }
;;;1054       else
;;;1055           RMP_COVERAGE_MARKER();
;;;1056       
;;;1057       RMP_Lock_Sched();
;;;1058       
;;;1059       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;1060       {
;;;1061           RMP_COVERAGE_MARKER();
;;;1062           RMP_Unlock_Sched();
;;;1063           return RMP_ERR_THD;
;;;1064       }
;;;1065       else
;;;1066           RMP_COVERAGE_MARKER();
;;;1067       
;;;1068       /* Suspend it */
;;;1069       if((Thread->State&RMP_THD_SUSPENDED)!=0)
;;;1070       {
;;;1071           RMP_COVERAGE_MARKER();
;;;1072           RMP_Unlock_Sched();
;;;1073           return RMP_ERR_STATE;
;;;1074       }
;;;1075       else
;;;1076           RMP_COVERAGE_MARKER();
;;;1077       
;;;1078       /* Only when it is running do we clear this. If we are clearing this, it is not
;;;1079        * suspended, so the running queue removal is guaranteed to succceed */
;;;1080       if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
;;;1081       {
;;;1082           RMP_COVERAGE_MARKER();
;;;1083           _RMP_Clr_Rdy(Thread);
;;;1084       }
;;;1085       else
;;;1086           RMP_COVERAGE_MARKER();
;;;1087       
;;;1088       /* Mark this as suspended */
;;;1089       Thread->State|=RMP_THD_SUSPENDED;
;;;1090       
;;;1091       /* If we are suspending ourself, pend a yield */
;;;1092       if(Thread==RMP_Cur_Thd)
;;;1093       {
;;;1094           RMP_COVERAGE_MARKER();
;;;1095           RMP_Sched_Pend=1;
;;;1096       }
;;;1097       else
;;;1098           RMP_COVERAGE_MARKER();
;;;1099       
;;;1100       RMP_Unlock_Sched();
;;;1101       return 0;
;;;1102   }
000008  4770              BXEQ     lr
00000a  b570              PUSH     {r4-r6,lr}            ;1047
00000c  4604              MOV      r4,r0                 ;1047
00000e  20ff              MOVS     r0,#0xff              ;1047
000010  f7fffffe          BL       RMP_Mask_Int
000014  4d14              LDR      r5,|L34.104|
000016  2601              MOVS     r6,#1                 ;1047
000018  60ae              STR      r6,[r5,#8]            ;1047  ; RMP_Sched_Locked
00001a  6868              LDR      r0,[r5,#4]            ;1047  ; RMP_Sched_Lock_Cnt
00001c  1c40              ADDS     r0,r0,#1              ;1047
00001e  6068              STR      r0,[r5,#4]            ;1047  ; RMP_Sched_Lock_Cnt
000020  69a0              LDR      r0,[r4,#0x18]         ;1059
000022  f0100fff          TST      r0,#0xff              ;1059
000026  d007              BEQ      |L34.56|
000028  69a0              LDR      r0,[r4,#0x18]         ;1069
00002a  f4107f80          TST      r0,#0x100             ;1069
00002e  d008              BEQ      |L34.66|
000030  f7fffffe          BL       RMP_Unlock_Sched
000034  1f70              SUBS     r0,r6,#5              ;1073
000036  bd70              POP      {r4-r6,pc}
                  |L34.56|
000038  f7fffffe          BL       RMP_Unlock_Sched
00003c  f04f30ff          MOV      r0,#0xffffffff        ;1063
000040  bd70              POP      {r4-r6,pc}
                  |L34.66|
000042  69a0              LDR      r0,[r4,#0x18]         ;1080
000044  b2c0              UXTB     r0,r0                 ;1080
000046  2801              CMP      r0,#1                 ;1080
000048  bf04              ITT      EQ                    ;1083
00004a  4620              MOVEQ    r0,r4                 ;1083
00004c  f7fffffe          BLEQ     _RMP_Clr_Rdy
000050  69a0              LDR      r0,[r4,#0x18]         ;1089
000052  f4407080          ORR      r0,r0,#0x100          ;1089
000056  61a0              STR      r0,[r4,#0x18]         ;1089
000058  69a8              LDR      r0,[r5,#0x18]         ;1092  ; RMP_Cur_Thd
00005a  4284              CMP      r4,r0                 ;1092
00005c  bf08              IT       EQ                    ;1095
00005e  60ee              STREQ    r6,[r5,#0xc]          ;1095  ; RMP_Sched_Pend
000060  f7fffffe          BL       RMP_Unlock_Sched
000064  2000              MOVS     r0,#0                 ;1101
000066  bd70              POP      {r4-r6,pc}
;;;1103   /* End Function:RMP_Thd_Suspend **********************************************/
                          ENDP

                  |L34.104|
                          DCD      ||.data||

                          AREA ||i.RMP_Unlock_Sched||, CODE, READONLY, ALIGN=2

                  RMP_Unlock_Sched PROC
;;;374    ******************************************************************************/
;;;375    void RMP_Unlock_Sched(void)
000000  480d              LDR      r0,|L35.56|
;;;376    {
000002  b510              PUSH     {r4,lr}
;;;377        if(RMP_Sched_Lock_Cnt==1)
000004  6841              LDR      r1,[r0,#4]  ; RMP_Sched_Lock_Cnt
000006  2901              CMP      r1,#1
000008  d006              BEQ      |L35.24|
;;;378        {
;;;379            RMP_COVERAGE_MARKER();
;;;380            /* Clear the count before enabling */
;;;381            RMP_Sched_Lock_Cnt=0;
;;;382            RMP_Sched_Locked=0;
;;;383            /* Now see if the scheduler scheduling action is pended in the lock-unlock 
;;;384             * period. If yes, perform a schedule now */
;;;385            if(RMP_Sched_Pend!=0)
;;;386            {
;;;387                RMP_COVERAGE_MARKER();
;;;388                /* Reset the count and trigger the context switch */
;;;389                RMP_Sched_Pend=0;
;;;390                _RMP_Yield();
;;;391            }
;;;392            else
;;;393                RMP_COVERAGE_MARKER();
;;;394            
;;;395            RMP_UNMASK_INT();
;;;396        }
;;;397        else if(RMP_Sched_Lock_Cnt>1)
00000a  6841              LDR      r1,[r0,#4]  ; RMP_Sched_Lock_Cnt
00000c  2901              CMP      r1,#1
00000e  d911              BLS      |L35.52|
;;;398        {
;;;399            RMP_COVERAGE_MARKER();
;;;400            RMP_Sched_Lock_Cnt--;
000010  6841              LDR      r1,[r0,#4]  ; RMP_Sched_Lock_Cnt
000012  1e49              SUBS     r1,r1,#1
000014  6041              STR      r1,[r0,#4]  ; RMP_Sched_Lock_Cnt
;;;401        }
;;;402        /* Trying to unlock a scheduler that is not locked - should never happen */
;;;403        else
;;;404            while(1);
;;;405    }
000016  bd10              POP      {r4,pc}
                  |L35.24|
000018  2100              MOVS     r1,#0                 ;381
00001a  6041              STR      r1,[r0,#4]            ;381  ; RMP_Sched_Lock_Cnt
00001c  6081              STR      r1,[r0,#8]            ;382  ; RMP_Sched_Locked
00001e  68c2              LDR      r2,[r0,#0xc]          ;385  ; RMP_Sched_Pend
000020  2a00              CMP      r2,#0                 ;385
000022  bf1c              ITT      NE                    ;389
000024  60c1              STRNE    r1,[r0,#0xc]          ;389  ; RMP_Sched_Pend
000026  f7fffffe          BLNE     _RMP_Yield
00002a  2000              MOVS     r0,#0                 ;395
00002c  e8bd4010          POP      {r4,lr}               ;395
000030  f7ffbffe          B.W      RMP_Mask_Int
                  |L35.52|
000034  e7fe              B        |L35.52|
;;;406    /* End Function:RMP_Unlock_Sched *********************************************/
                          ENDP

000036  0000              DCW      0x0000
                  |L35.56|
                          DCD      ||.data||

                          AREA ||i.RMP_Yield||, CODE, READONLY, ALIGN=2

                  RMP_Yield PROC
;;;413    ******************************************************************************/
;;;414    void RMP_Yield(void)
000000  4804              LDR      r0,|L36.20|
;;;415    {
;;;416        if(RMP_Sched_Locked==0)
000002  6881              LDR      r1,[r0,#8]  ; RMP_Sched_Locked
000004  2900              CMP      r1,#0
;;;417        {
;;;418            RMP_COVERAGE_MARKER();
;;;419            /* Now see if the scheduler scheduling action is pended in the lock-unlock 
;;;420             * period. If yes, perform a schedule now */
;;;421            _RMP_Yield();
;;;422        }
;;;423        else
;;;424        {
;;;425            RMP_COVERAGE_MARKER();
;;;426            RMP_Sched_Pend=1;
000006  bf1e              ITTT     NE
000008  2101              MOVNE    r1,#1
00000a  60c1              STRNE    r1,[r0,#0xc]  ; RMP_Sched_Pend
;;;427        }
;;;428    }
00000c  4770              BXNE     lr
00000e  f7ffbffe          B.W      _RMP_Yield
;;;429    /* End Function:RMP_Yield ****************************************************/
                          ENDP

000012  0000              DCW      0x0000
                  |L36.20|
                          DCD      ||.data||

                          AREA ||i._RMP_Clr_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Clr_Rdy PROC
;;;685    ******************************************************************************/
;;;686    void _RMP_Clr_Rdy(volatile struct RMP_Thd* Thread)
000000  6981              LDR      r1,[r0,#0x18]
;;;687    {
;;;688        /* Is it suspended? If yes, no need to delete again */
;;;689        if((Thread->State&RMP_THD_SUSPENDED)==0)
000002  f4117f80          TST      r1,#0x100
;;;690        {
;;;691            RMP_COVERAGE_MARKER();
;;;692            /* See if it is the last thread on the priority level */
;;;693            if(Thread->Run_Head.Prev==Thread->Run_Head.Next)
;;;694            {
;;;695                RMP_COVERAGE_MARKER();
;;;696                RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]&=~(((rmp_ptr_t)1)<<(Thread->Prio&RMP_WORD_MASK));
;;;697            }
;;;698            else
;;;699                RMP_COVERAGE_MARKER();
;;;700            
;;;701            /* Delete this from the corresponding runqueue */
;;;702            RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;703            
;;;704            /* If it is the current thread, request a context switch */
;;;705            if(Thread==RMP_Cur_Thd)
;;;706            {
;;;707                RMP_COVERAGE_MARKER();
;;;708                RMP_Sched_Pend=1;
;;;709            }
;;;710            else
;;;711                RMP_COVERAGE_MARKER();
;;;712        }
;;;713        else
;;;714            RMP_COVERAGE_MARKER();
;;;715    }
000006  bf18              IT       NE
000008  4770              BXNE     lr
00000a  6801              LDR      r1,[r0,#0]            ;693
00000c  6842              LDR      r2,[r0,#4]            ;693
00000e  2301              MOVS     r3,#1                 ;696
000010  4291              CMP      r1,r2                 ;693
000012  d10e              BNE      |L37.50|
000014  6a41              LDR      r1,[r0,#0x24]         ;696
000016  4a0c              LDR      r2,|L37.72|
000018  0949              LSRS     r1,r1,#5              ;696
00001a  eb020181          ADD      r1,r2,r1,LSL #2       ;696
00001e  680a              LDR      r2,[r1,#0]            ;696
000020  f8d0c024          LDR      r12,[r0,#0x24]        ;696
000024  f00c0c1f          AND      r12,r12,#0x1f         ;696
000028  fa03fc0c          LSL      r12,r3,r12            ;696
00002c  ea22020c          BIC      r2,r2,r12             ;696
000030  600a              STR      r2,[r1,#0]            ;696
                  |L37.50|
000032  6801              LDR      r1,[r0,#0]            ;702
000034  6842              LDR      r2,[r0,#4]            ;702
000036  6011              STR      r1,[r2,#0]            ;702
000038  604a              STR      r2,[r1,#4]            ;702
00003a  4903              LDR      r1,|L37.72|
00003c  698a              LDR      r2,[r1,#0x18]         ;705  ; RMP_Cur_Thd
00003e  4290              CMP      r0,r2                 ;705
000040  bf08              IT       EQ                    ;708
000042  60cb              STREQ    r3,[r1,#0xc]          ;708  ; RMP_Sched_Pend
000044  4770              BX       lr
;;;716    /* End Function:_RMP_Clr_Rdy *************************************************/
                          ENDP

000046  0000              DCW      0x0000
                  |L37.72|
                          DCD      ||.data||

                          AREA ||i._RMP_Get_High_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Get_High_Rdy PROC
;;;493    ******************************************************************************/
;;;494    void _RMP_Get_High_Rdy(void)
000000  b510              PUSH     {r4,lr}
;;;495    {
;;;496        rmp_cnt_t Count;
;;;497        
;;;498        /* Write the SP value to thread structure */
;;;499        RMP_Cur_Thd->Stack=RMP_Cur_SP;
000002  4c19              LDR      r4,|L38.104|
000004  69e0              LDR      r0,[r4,#0x1c]  ; RMP_Cur_SP
000006  69a1              LDR      r1,[r4,#0x18]  ; RMP_Cur_Thd
;;;500        
;;;501        /* No need to detect scheduler locks - if this interrupt can be entered, the scheduler is not locked */
;;;502        RMP_Sched_Pend=0;
000008  6348              STR      r0,[r1,#0x34]
00000a  2000              MOVS     r0,#0
00000c  60e0              STR      r0,[r4,#0xc]  ; RMP_Sched_Pend
;;;503        /* See which one is ready, and pick it */
;;;504        for(Count=RMP_BITMAP_SIZE-1;Count>=0;Count--)
;;;505        {
;;;506            if(RMP_Bitmap[Count]==0)
00000e  4620              MOV      r0,r4
000010  6801              LDR      r1,[r0,#0]
000012  b321              CBZ      r1,|L38.94|
;;;507            {
;;;508                RMP_COVERAGE_MARKER();
;;;509                continue;
;;;510            }
;;;511            else
;;;512                RMP_COVERAGE_MARKER();
;;;513            
;;;514            Count=RMP_MSB_Get(RMP_Bitmap[Count])+(Count<<RMP_WORD_ORDER);
000014  6800              LDR      r0,[r0,#0]
000016  f7fffffe          BL       RMP_MSB_Get
;;;515            
;;;516            /* See if the current thread and the next thread are the same. If yes, place the current at the end of the queue */
;;;517            if(RMP_Cur_Thd==(struct RMP_Thd*)(RMP_Run[Count].Next))
00001a  4914              LDR      r1,|L38.108|
00001c  eb0103c0          ADD      r3,r1,r0,LSL #3
000020  6858              LDR      r0,[r3,#4]
000022  69a2              LDR      r2,[r4,#0x18]  ; RMP_Cur_Thd
000024  4290              CMP      r0,r2
000026  d114              BNE      |L38.82|
;;;518            {
;;;519                RMP_COVERAGE_MARKER();
;;;520                RMP_List_Del(RMP_Cur_Thd->Run_Head.Prev, RMP_Cur_Thd->Run_Head.Next);
000028  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
00002a  69a2              LDR      r2,[r4,#0x18]  ; RMP_Cur_Thd
00002c  6800              LDR      r0,[r0,#0]
00002e  6852              LDR      r2,[r2,#4]
000030  6010              STR      r0,[r2,#0]
000032  6042              STR      r2,[r0,#4]
;;;521                RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),
000034  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
000036  69a2              LDR      r2,[r4,#0x18]  ; RMP_Cur_Thd
000038  6a52              LDR      r2,[r2,#0x24]
00003a  f8512032          LDR      r2,[r1,r2,LSL #3]
00003e  f8d4c018          LDR      r12,[r4,#0x18]  ; RMP_Cur_Thd
000042  f8dcc024          LDR      r12,[r12,#0x24]
000046  eb0101cc          ADD      r1,r1,r12,LSL #3
00004a  6008              STR      r0,[r1,#0]
00004c  6041              STR      r1,[r0,#4]
00004e  6002              STR      r2,[r0,#0]
000050  6050              STR      r0,[r2,#4]
                  |L38.82|
;;;522                             RMP_Run[RMP_Cur_Thd->Prio].Prev,
;;;523                             &(RMP_Run[RMP_Cur_Thd->Prio]));
;;;524            }
;;;525            else
;;;526                RMP_COVERAGE_MARKER();
;;;527            
;;;528            /* Replenish timeslices */
;;;529            RMP_Cur_Thd->Slices_Left=RMP_Cur_Thd->Slices;
000052  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
000054  69a1              LDR      r1,[r4,#0x18]  ; RMP_Cur_Thd
000056  69c0              LDR      r0,[r0,#0x1c]
;;;530            RMP_Cur_Thd=(struct RMP_Thd*)(RMP_Run[Count].Next);
000058  6208              STR      r0,[r1,#0x20]
00005a  6858              LDR      r0,[r3,#4]
00005c  61a0              STR      r0,[r4,#0x18]  ; RMP_Cur_Thd
                  |L38.94|
;;;531            break;
;;;532        }
;;;533        
;;;534        /* Load the SP value from thread structure */
;;;535        RMP_Cur_SP=RMP_Cur_Thd->Stack;
00005e  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
000060  6b40              LDR      r0,[r0,#0x34]
000062  61e0              STR      r0,[r4,#0x1c]  ; RMP_Cur_SP
;;;536        
;;;537    #if(RMP_USE_HOOKS==RMP_TRUE)
;;;538        RMP_Sched_Hook();
;;;539    #endif
;;;540    }
000064  bd10              POP      {r4,pc}
;;;541    /* End Function:_RMP_Get_High_Rdy ********************************************/
                          ENDP

000066  0000              DCW      0x0000
                  |L38.104|
                          DCD      ||.data||
                  |L38.108|
                          DCD      ||.bss||

                          AREA ||i._RMP_Get_Near_Ticks||, CODE, READONLY, ALIGN=2

                  _RMP_Get_Near_Ticks PROC
;;;611    ******************************************************************************/
;;;612    rmp_ptr_t _RMP_Get_Near_Ticks(void)
000000  4a08              LDR      r2,|L39.36|
;;;613    {
;;;614        rmp_ptr_t Value;
;;;615        struct RMP_Thd* Thread;
;;;616        
;;;617        /* What is the current thread's timeout value? */
;;;618        Value=RMP_Cur_Thd->Slices_Left;
000002  6990              LDR      r0,[r2,#0x18]  ; RMP_Cur_Thd
;;;619        
;;;620        /* What is the nearest timer timeout value? */
;;;621        if((&RMP_Delay)!=RMP_Delay.Next)
000004  f1020120          ADD      r1,r2,#0x20
000008  6a00              LDR      r0,[r0,#0x20]         ;618
00000a  684b              LDR      r3,[r1,#4]  ; RMP_Delay
00000c  428b              CMP      r3,r1
;;;622        {
;;;623            RMP_COVERAGE_MARKER();
;;;624            Thread=RMP_DLY2THD(RMP_Delay.Next);
;;;625            /* See if it is nearer - don't worry about the situation that the timer
;;;626             * have overflown, because if that is to happen, it would have been 
;;;627             * already processed by the timeout processing routine just before. */
;;;628            if((Thread->Timeout-RMP_Tick)<Value)
;;;629            {
;;;630                RMP_COVERAGE_MARKER();
;;;631                Value=Thread->Timeout-RMP_Tick;
;;;632            }
;;;633            else
;;;634                RMP_COVERAGE_MARKER();
;;;635        }
;;;636        else
;;;637            RMP_COVERAGE_MARKER();
;;;638        
;;;639        return Value;
;;;640    }
00000e  bf08              IT       EQ
000010  4770              BXEQ     lr
000012  6849              LDR      r1,[r1,#4]            ;624  ; RMP_Delay
000014  6953              LDR      r3,[r2,#0x14]         ;628  ; RMP_Tick
000016  6a09              LDR      r1,[r1,#0x20]         ;628
000018  1acb              SUBS     r3,r1,r3              ;628
00001a  4283              CMP      r3,r0                 ;628
00001c  bf3c              ITT      CC                    ;631
00001e  6950              LDRCC    r0,[r2,#0x14]         ;631  ; RMP_Tick
000020  1a08              SUBCC    r0,r1,r0              ;631
000022  4770              BX       lr
;;;641    /* End Function:_RMP_Get_Near_Ticks ******************************************/
                          ENDP

                  |L39.36|
                          DCD      ||.data||

                          AREA ||i._RMP_Mem_Del||, CODE, READONLY, ALIGN=1

                  _RMP_Mem_Del PROC
;;;2305   ******************************************************************************/
;;;2306   void _RMP_Mem_Del(volatile void* Pool, volatile struct RMP_Mem_Head* Mem_Head)
000000  b570              PUSH     {r4-r6,lr}
;;;2307   {
;;;2308       rmp_ptr_t FLI_Level;
;;;2309       rmp_ptr_t SLI_Level;
;;;2310       rmp_ptr_t Level;
;;;2311       rmp_ptr_t Size;
;;;2312       volatile struct RMP_Mem* Mem;
;;;2313       volatile struct RMP_List* Slot;    
;;;2314       
;;;2315       /* Get the memory pool and block size */
;;;2316       Mem=(volatile struct RMP_Mem*)Pool;
000002  4605              MOV      r5,r0
;;;2317       Size=(rmp_ptr_t)(Mem_Head->Tail)-((rmp_ptr_t)Mem_Head)-sizeof(struct RMP_Mem_Head);
000004  68c8              LDR      r0,[r1,#0xc]
000006  460c              MOV      r4,r1                 ;2307
000008  1b00              SUBS     r0,r0,r4
00000a  f1a00610          SUB      r6,r0,#0x10
;;;2318       
;;;2319       /* Guarantee the Mem_Size is bigger than 64 or a failure will surely occur here */
;;;2320       FLI_Level=RMP_MSB_Get(Size)-6;
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       RMP_MSB_Get
;;;2321       /* Decide the SLI level directly from the FLI level */
;;;2322       SLI_Level=(Size>>(FLI_Level+3))&0x07;
000014  1ec1              SUBS     r1,r0,#3
000016  fa26f101          LSR      r1,r6,r1
00001a  f0010107          AND      r1,r1,#7
00001e  1f80              SUBS     r0,r0,#6
;;;2323       /* Calculate the bit position */
;;;2324       Level=RMP_MEM_POS(FLI_Level,SLI_Level);
000020  eb0101c0          ADD      r1,r1,r0,LSL #3
;;;2325       /* Get the slot */
;;;2326       Slot=&(Mem->Table[Level]);
000024  68e8              LDR      r0,[r5,#0xc]
;;;2327   
;;;2328       /* Delete the node now */
;;;2329       RMP_List_Del(Mem_Head->Head.Prev,Mem_Head->Head.Next);
000026  6822              LDR      r2,[r4,#0]
000028  eb0000c1          ADD      r0,r0,r1,LSL #3       ;2326
00002c  6863              LDR      r3,[r4,#4]
00002e  601a              STR      r2,[r3,#0]
000030  6053              STR      r3,[r2,#4]
;;;2330   
;;;2331       /* See if there are any blocks in the level, equal means no. So
;;;2332        * what we deleted is the last blockm need to clear the flag */
;;;2333       if(Slot==Slot->Next)
000032  6842              LDR      r2,[r0,#4]
000034  4282              CMP      r2,r0
;;;2334       {
;;;2335           RMP_COVERAGE_MARKER();
;;;2336           /* Clear the corresponding bit in the TLSF bitmap */
;;;2337           Mem->Bitmap[Level>>RMP_WORD_ORDER]&=~RMP_POW2(Level&RMP_WORD_MASK);
;;;2338       }
;;;2339       else
;;;2340           RMP_COVERAGE_MARKER();
;;;2341   }
000036  bf18              IT       NE
000038  bd70              POPNE    {r4-r6,pc}
00003a  0948              LSRS     r0,r1,#5              ;2337
00003c  eb050080          ADD      r0,r5,r0,LSL #2       ;2337
000040  6902              LDR      r2,[r0,#0x10]         ;2337
000042  f001011f          AND      r1,r1,#0x1f           ;2337
000046  2301              MOVS     r3,#1                 ;2337
000048  fa03f101          LSL      r1,r3,r1              ;2337
00004c  ea220101          BIC      r1,r2,r1              ;2337
000050  6101              STR      r1,[r0,#0x10]         ;2337
000052  bd70              POP      {r4-r6,pc}
;;;2342   /* End Function:_RMP_Mem_Del *************************************************/
                          ENDP


                          AREA ||i._RMP_Mem_Ins||, CODE, READONLY, ALIGN=1

                  _RMP_Mem_Ins PROC
;;;2260   ******************************************************************************/
;;;2261   void _RMP_Mem_Ins(volatile void* Pool, volatile struct RMP_Mem_Head* Mem_Head)
000000  b570              PUSH     {r4-r6,lr}
;;;2262   {
;;;2263       rmp_ptr_t FLI_Level;
;;;2264       rmp_ptr_t SLI_Level;
;;;2265       rmp_ptr_t Level;
;;;2266       rmp_ptr_t Size;
;;;2267       volatile struct RMP_Mem* Mem;
;;;2268       volatile struct RMP_List* Slot;
;;;2269       
;;;2270       /* Get the memory pool and block size */
;;;2271       Mem=(volatile struct RMP_Mem*)Pool;
000002  4605              MOV      r5,r0
;;;2272       Size=(rmp_ptr_t)(Mem_Head->Tail)-((rmp_ptr_t)Mem_Head)-sizeof(struct RMP_Mem_Head);
000004  68c8              LDR      r0,[r1,#0xc]
000006  460c              MOV      r4,r1                 ;2262
000008  1b00              SUBS     r0,r0,r4
00000a  f1a00610          SUB      r6,r0,#0x10
;;;2273   
;;;2274       /* Guarantee the Mem_Size is bigger than 64 or a failure will surely occur here */
;;;2275       FLI_Level=RMP_MSB_Get(Size)-6;
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       RMP_MSB_Get
;;;2276       /* Decide the SLI level directly from the FLI level */
;;;2277       SLI_Level=(Size>>(FLI_Level+3))&0x07;
000014  1ec1              SUBS     r1,r0,#3
000016  fa26f101          LSR      r1,r6,r1
00001a  f0010107          AND      r1,r1,#7
00001e  1f80              SUBS     r0,r0,#6
;;;2278       /* Calculate the bit position */
;;;2279       Level=RMP_MEM_POS(FLI_Level,SLI_Level);
000020  eb0102c0          ADD      r2,r1,r0,LSL #3
;;;2280       /* Get the slot */
;;;2281       Slot=&(Mem->Table[Level]);
000024  68e8              LDR      r0,[r5,#0xc]
000026  eb0001c2          ADD      r1,r0,r2,LSL #3
;;;2282   
;;;2283       /* See if there are any blocks in the level, equal means no. So what we inserted is the first block */
;;;2284       if(Slot==Slot->Next)
00002a  6848              LDR      r0,[r1,#4]
00002c  4288              CMP      r0,r1
00002e  d10b              BNE      |L41.72|
;;;2285       {
;;;2286           RMP_COVERAGE_MARKER();
;;;2287           /* Set the corresponding bit in the TLSF bitmap */
;;;2288           Mem->Bitmap[Level>>RMP_WORD_ORDER]|=RMP_POW2(Level&RMP_WORD_MASK);
000030  0950              LSRS     r0,r2,#5
000032  eb050080          ADD      r0,r5,r0,LSL #2
000036  6903              LDR      r3,[r0,#0x10]
000038  f002021f          AND      r2,r2,#0x1f
00003c  f04f0c01          MOV      r12,#1
000040  fa0cf202          LSL      r2,r12,r2
000044  431a              ORRS     r2,r2,r3
000046  6102              STR      r2,[r0,#0x10]
                  |L41.72|
;;;2289       }
;;;2290       else
;;;2291           RMP_COVERAGE_MARKER();
;;;2292   
;;;2293       /* Insert the node now */
;;;2294       RMP_List_Ins(&(Mem_Head->Head), Slot, Slot->Next);
000048  6848              LDR      r0,[r1,#4]
00004a  6004              STR      r4,[r0,#0]
00004c  6060              STR      r0,[r4,#4]
00004e  6021              STR      r1,[r4,#0]
000050  604c              STR      r4,[r1,#4]
;;;2295   }
000052  bd70              POP      {r4-r6,pc}
;;;2296   /* End Function:_RMP_Mem_Ins *************************************************/
                          ENDP


                          AREA ||i._RMP_Set_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Set_Rdy PROC
;;;652    ******************************************************************************/
;;;653    void _RMP_Set_Rdy(volatile struct RMP_Thd* Thread)
000000  6981              LDR      r1,[r0,#0x18]
;;;654    {        
;;;655        /* Is it suspended? If yes, we can't directly set it running */
;;;656        if((Thread->State&RMP_THD_SUSPENDED)==0)
000002  f4117f80          TST      r1,#0x100
;;;657        {
;;;658            RMP_COVERAGE_MARKER();
;;;659            /* Insert this into the corresponding runqueue */
;;;660            RMP_List_Ins(&(Thread->Run_Head),RMP_Run[Thread->Prio].Prev,&(RMP_Run[Thread->Prio]));
;;;661            /* Set this runlevel as active */
;;;662            RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]|=((rmp_ptr_t)1)<<(Thread->Prio&RMP_WORD_MASK);
;;;663            
;;;664            /* Compare this with the current one to see if we need a context switch */
;;;665            if(Thread->Prio>RMP_Cur_Thd->Prio)
;;;666            {
;;;667                RMP_COVERAGE_MARKER();
;;;668                RMP_Sched_Pend=1;
;;;669            }
;;;670            else
;;;671                RMP_COVERAGE_MARKER();
;;;672        }
;;;673        else
;;;674            RMP_COVERAGE_MARKER();
;;;675    }
000006  bf18              IT       NE
000008  4770              BXNE     lr
00000a  6a41              LDR      r1,[r0,#0x24]         ;660
00000c  4a10              LDR      r2,|L42.80|
00000e  f8521031          LDR      r1,[r2,r1,LSL #3]     ;660
000012  6a43              LDR      r3,[r0,#0x24]         ;660
000014  eb0202c3          ADD      r2,r2,r3,LSL #3       ;660
000018  6010              STR      r0,[r2,#0]            ;660
00001a  6042              STR      r2,[r0,#4]            ;660
00001c  6001              STR      r1,[r0,#0]            ;660
00001e  6048              STR      r0,[r1,#4]            ;660
000020  6a41              LDR      r1,[r0,#0x24]         ;662
000022  4a0c              LDR      r2,|L42.84|
000024  0949              LSRS     r1,r1,#5              ;662
000026  eb020181          ADD      r1,r2,r1,LSL #2       ;662
00002a  680b              LDR      r3,[r1,#0]            ;662
00002c  6a42              LDR      r2,[r0,#0x24]         ;662
00002e  f0020c1f          AND      r12,r2,#0x1f          ;662
000032  2201              MOVS     r2,#1                 ;662
000034  fa02fc0c          LSL      r12,r2,r12            ;662
000038  ea43030c          ORR      r3,r3,r12             ;662
00003c  600b              STR      r3,[r1,#0]            ;662
00003e  6a41              LDR      r1,[r0,#0x24]         ;665
000040  4804              LDR      r0,|L42.84|
000042  6983              LDR      r3,[r0,#0x18]         ;665  ; RMP_Cur_Thd
000044  6a5b              LDR      r3,[r3,#0x24]         ;665
000046  4299              CMP      r1,r3                 ;665
000048  bf88              IT       HI                    ;668
00004a  60c2              STRHI    r2,[r0,#0xc]          ;668  ; RMP_Sched_Pend
00004c  4770              BX       lr
;;;676    /* End Function:_RMP_Set_Rdy *************************************************/
                          ENDP

00004e  0000              DCW      0x0000
                  |L42.80|
                          DCD      ||.bss||
                  |L42.84|
                          DCD      ||.data||

                          AREA ||i._RMP_Tick_Handler||, CODE, READONLY, ALIGN=2

                  _RMP_Tick_Handler PROC
;;;548    ******************************************************************************/
;;;549    void _RMP_Tick_Handler(rmp_ptr_t Ticks)
000000  b570              PUSH     {r4-r6,lr}
;;;550    {
;;;551        struct RMP_Thd* Thread;
;;;552        /* Increase the timestamp as always */
;;;553        RMP_Tick+=Ticks;
000002  4d28              LDR      r5,|L43.164|
000004  6969              LDR      r1,[r5,#0x14]  ; RMP_Tick
000006  4401              ADD      r1,r1,r0
000008  6169              STR      r1,[r5,#0x14]  ; RMP_Tick
;;;554        
;;;555        /* See if the current thread expired. If yes, trigger a scheduler event */
;;;556        if(Ticks>RMP_Cur_Thd->Slices_Left)
00000a  69a9              LDR      r1,[r5,#0x18]  ; RMP_Cur_Thd
00000c  6a09              LDR      r1,[r1,#0x20]
00000e  4281              CMP      r1,r0
;;;557        {
;;;558            RMP_COVERAGE_MARKER();
;;;559            RMP_Sched_Pend=1;
000010  bf3c              ITT      CC
000012  2001              MOVCC    r0,#1
000014  60e8              STRCC    r0,[r5,#0xc]  ; RMP_Sched_Pend
000016  d303              BCC      |L43.32|
;;;560        }
;;;561        else
;;;562        {
;;;563            RMP_COVERAGE_MARKER();
;;;564            RMP_Cur_Thd->Slices_Left-=Ticks;
000018  69a9              LDR      r1,[r5,#0x18]  ; RMP_Cur_Thd
00001a  6a0a              LDR      r2,[r1,#0x20]
00001c  1a10              SUBS     r0,r2,r0
00001e  6208              STR      r0,[r1,#0x20]
                  |L43.32|
;;;565        }
;;;566        
;;;567        /* Check if there are any timer events */
;;;568        if((&RMP_Delay)!=RMP_Delay.Next)
000020  4c21              LDR      r4,|L43.168|
000022  6860              LDR      r0,[r4,#4]  ; RMP_Delay
000024  42a0              CMP      r0,r4
000026  d033              BEQ      |L43.144|
;;;569        {
;;;570            RMP_COVERAGE_MARKER();
;;;571            Thread=RMP_DLY2THD(RMP_Delay.Next);
000028  6860              LDR      r0,[r4,#4]  ; RMP_Delay
;;;572            /* If the value is less than this, then it means that the time have
;;;573             * already passed and we have to process this */
;;;574            if((RMP_Tick-Thread->Timeout)<=(RMP_ALLBITS>>1))
00002a  6969              LDR      r1,[r5,#0x14]  ; RMP_Tick
00002c  6a00              LDR      r0,[r0,#0x20]
00002e  1a08              SUBS     r0,r1,r0
000030  f1b04f00          CMP      r0,#0x80000000
000034  d22c              BCS      |L43.144|
000036  6860              LDR      r0,[r4,#4]  ; RMP_Delay
000038  42a0              CMP      r0,r4
00003a  bf18              IT       NE
00003c  f06f0604          MVNNE    r6,#4
000040  d026              BEQ      |L43.144|
                  |L43.66|
000042  6860              LDR      r0,[r4,#4]  ; RMP_Delay
000044  6969              LDR      r1,[r5,#0x14]  ; RMP_Tick
000046  6a02              LDR      r2,[r0,#0x20]
000048  3808              SUBS     r0,r0,#8
00004a  1a89              SUBS     r1,r1,r2
00004c  f1b14f00          CMP      r1,#0x80000000
000050  d21e              BCS      |L43.144|
000052  e9d01202          LDRD     r1,r2,[r0,#8]
000056  6011              STR      r1,[r2,#0]
000058  604a              STR      r2,[r1,#4]
00005a  7e01              LDRB     r1,[r0,#0x18]
00005c  2903              CMP      r1,#3
00005e  d007              BEQ      |L43.112|
000060  2905              CMP      r1,#5
000062  bf0c              ITE      EQ
000064  6386              STREQ    r6,[r0,#0x38]
000066  2906              CMPNE    r1,#6
000068  d007              BEQ      |L43.122|
00006a  2908              CMP      r1,#8
00006c  d000              BEQ      |L43.112|
                  |L43.110|
00006e  e7fe              B        |L43.110|
                  |L43.112|
000070  e9d01200          LDRD     r1,r2,[r0,#0]
000074  6011              STR      r1,[r2,#0]
000076  604a              STR      r2,[r1,#4]
000078  6386              STR      r6,[r0,#0x38]
                  |L43.122|
00007a  6981              LDR      r1,[r0,#0x18]
00007c  f02101ff          BIC      r1,r1,#0xff
000080  f0410101          ORR      r1,r1,#1
000084  6181              STR      r1,[r0,#0x18]
000086  f7fffffe          BL       _RMP_Set_Rdy
00008a  6860              LDR      r0,[r4,#4]  ; RMP_Delay
00008c  42a0              CMP      r0,r4
00008e  d1d8              BNE      |L43.66|
                  |L43.144|
;;;575            {
;;;576                RMP_COVERAGE_MARKER();
;;;577                /* No need to care about scheduler locks if this interrupt can be entered
;;;578                 * - we have disabled timer and scheduler interrupts in scheduler lock */
;;;579                _RMP_Timer_Proc();
;;;580            }
;;;581            else
;;;582                RMP_COVERAGE_MARKER();
;;;583        }
;;;584        else
;;;585            RMP_COVERAGE_MARKER();
;;;586        
;;;587        if(RMP_Sched_Pend!=0)
000090  68e8              LDR      r0,[r5,#0xc]  ; RMP_Sched_Pend
000092  2800              CMP      r0,#0
;;;588        {
;;;589            RMP_COVERAGE_MARKER();
;;;590            RMP_Sched_Pend=0;
;;;591            _RMP_Yield();
;;;592        }
;;;593        else
;;;594            RMP_COVERAGE_MARKER();
;;;595        
;;;596    #if(RMP_USE_HOOKS==RMP_TRUE)
;;;597        RMP_Tick_Hook(Ticks);
;;;598    #endif
;;;599    }
000094  bf08              IT       EQ
000096  bd70              POPEQ    {r4-r6,pc}
000098  2000              MOVS     r0,#0                 ;590
00009a  60e8              STR      r0,[r5,#0xc]          ;590  ; RMP_Sched_Pend
00009c  e8bd4070          POP      {r4-r6,lr}            ;591
0000a0  f7ffbffe          B.W      _RMP_Yield
;;;600    /* End Function:_RMP_Tick_Handler ********************************************/
                          ENDP

                  |L43.164|
                          DCD      ||.data||
                  |L43.168|
                          DCD      ||.data||+0x20

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;1993   ******************************************************************************/
;;;1994   int main(void)
000000  b510              PUSH     {r4,lr}
;;;1995   {
;;;1996       rmp_ptr_t Count;
;;;1997       
;;;1998   #ifdef RMP_COVERAGE
;;;1999       /* Initialize coverage markers if coverage enabled */
;;;2000       for(Count=0;Count<RMP_COVERAGE_LINES;Count++)
;;;2001           RMP_Coverage[Count]=0;
;;;2002   #endif
;;;2003       
;;;2004       /* Initialize the kernel data structures first */
;;;2005       _RMP_Low_Level_Init();
000002  f7fffffe          BL       _RMP_Low_Level_Init
;;;2006       
;;;2007   #if(RMP_USE_HOOKS==RMP_TRUE)
;;;2008       RMP_Start_Hook();
;;;2009   #endif
;;;2010       
;;;2011       RMP_Tick=0;
000006  4b22              LDR      r3,|L44.144|
000008  2000              MOVS     r0,#0
00000a  6158              STR      r0,[r3,#0x14]  ; RMP_Tick
;;;2012       /* Now initialize the kernel data structures */
;;;2013       RMP_Sched_Lock_Cnt=0;
00000c  6058              STR      r0,[r3,#4]  ; RMP_Sched_Lock_Cnt
;;;2014       RMP_Sched_Locked=0;
00000e  6098              STR      r0,[r3,#8]  ; RMP_Sched_Locked
;;;2015       RMP_Sched_Pend=0;
000010  60d8              STR      r0,[r3,#0xc]  ; RMP_Sched_Pend
;;;2016       RMP_Timer_Pend=0;
000012  6118              STR      r0,[r3,#0x10]  ; RMP_Timer_Pend
;;;2017       
;;;2018       /* Linked lists */
;;;2019       RMP_List_Crt(&RMP_Delay);
000014  f1030120          ADD      r1,r3,#0x20
000018  6009              STR      r1,[r1,#0]
00001a  6049              STR      r1,[r1,#4]
;;;2020       for(Count=0;Count<RMP_MAX_PREEMPT_PRIO;Count++)
;;;2021           RMP_List_Crt(&RMP_Run[Count]);
00001c  f8dfc074          LDR      r12,|L44.148|
000020  4601              MOV      r1,r0                 ;2020
000022  bf00              NOP      
                  |L44.36|
000024  eb0c02c1          ADD      r2,r12,r1,LSL #3
000028  6012              STR      r2,[r2,#0]
00002a  6052              STR      r2,[r2,#4]
00002c  1c49              ADDS     r1,r1,#1
00002e  2920              CMP      r1,#0x20
000030  d3f8              BCC      |L44.36|
;;;2022       for(Count=0;Count<RMP_BITMAP_SIZE;Count++)
;;;2023           RMP_Bitmap[Count]=0;
000032  4c17              LDR      r4,|L44.144|
000034  6020              STR      r0,[r4,#0]  ; RMP_Bitmap
;;;2024           
;;;2025       /* Now boot into the first thread */
;;;2026       RMP_Clear(&RMP_Init_Thd,sizeof(struct RMP_Thd));
000036  4a18              LDR      r2,|L44.152|
000038  211e              MOVS     r1,#0x1e
                  |L44.58|
00003a  1e49              SUBS     r1,r1,#1
00003c  7050              STRB     r0,[r2,#1]
00003e  f8020f02          STRB     r0,[r2,#2]!
000042  d1fa              BNE      |L44.58|
;;;2027       RMP_Init_Thd.Prio=0;
000044  4915              LDR      r1,|L44.156|
000046  6248              STR      r0,[r1,#0x24]  ; RMP_Init_Thd
;;;2028       RMP_Init_Thd.Slices=10;
000048  200a              MOVS     r0,#0xa
00004a  61c8              STR      r0,[r1,#0x1c]  ; RMP_Init_Thd
;;;2029       RMP_Init_Thd.Slices_Left=10;
00004c  6208              STR      r0,[r1,#0x20]  ; RMP_Init_Thd
;;;2030       RMP_Init_Thd.State=RMP_THD_RUNNING;
00004e  2001              MOVS     r0,#1
000050  6188              STR      r0,[r1,#0x18]  ; RMP_Init_Thd
;;;2031       RMP_Init_Thd.Stack=RMP_INIT_STACK;
000052  f1a10044          SUB      r0,r1,#0x44
000056  6348              STR      r0,[r1,#0x34]  ; RMP_Init_Thd
;;;2032       
;;;2033       /* Initialize sending list */
;;;2034       RMP_List_Crt(&(RMP_Init_Thd.Snd_List));
000058  f1010010          ADD      r0,r1,#0x10
00005c  6108              STR      r0,[r1,#0x10]
00005e  6148              STR      r0,[r1,#0x14]
;;;2035       
;;;2036       /* Insert this into the corresponding runqueue */
;;;2037       RMP_List_Ins(&(RMP_Init_Thd.Run_Head),RMP_Run[0].Prev,&(RMP_Run[0]));
000060  f8dc2000          LDR      r2,[r12,#0]  ; RMP_Run
000064  4608              MOV      r0,r1
000066  f5a07c00          SUB      r12,r0,#0x200
00006a  f8cc0000          STR      r0,[r12,#0]
00006e  f8c0c004          STR      r12,[r0,#4]
000072  6002              STR      r2,[r0,#0]
000074  6050              STR      r0,[r2,#4]
;;;2038       /* Set this runlevel as active - in fact it is always active */
;;;2039       RMP_Bitmap[0]|=1;
000076  6820              LDR      r0,[r4,#0]  ; RMP_Bitmap
000078  f0400001          ORR      r0,r0,#1
00007c  6020              STR      r0,[r4,#0]  ; RMP_Bitmap
;;;2040       
;;;2041       /* Set current thread and stack */
;;;2042       RMP_Cur_Thd=(struct RMP_Thd*)(&RMP_Init_Thd);
00007e  6199              STR      r1,[r3,#0x18]  ; RMP_Cur_Thd
;;;2043       RMP_Cur_SP=RMP_Init_Thd.Stack;
000080  6b48              LDR      r0,[r1,#0x34]  ; RMP_Init_Thd
000082  61d8              STR      r0,[r3,#0x1c]  ; RMP_Cur_SP
;;;2044       
;;;2045       /* Now jump to the user function and will never return. Initialization of stack is not needed */
;;;2046       _RMP_Start((rmp_ptr_t)RMP_Init, (rmp_ptr_t)RMP_Init_Thd.Stack);
000084  6b49              LDR      r1,[r1,#0x34]  ; RMP_Init_Thd
000086  4806              LDR      r0,|L44.160|
000088  f7fffffe          BL       _RMP_Start
;;;2047       
;;;2048       return 0;
00008c  2000              MOVS     r0,#0
;;;2049   }
00008e  bd10              POP      {r4,pc}
;;;2050   /* End Function:main *********************************************************/
                          ENDP

                  |L44.144|
                          DCD      ||.data||
                  |L44.148|
                          DCD      ||.bss||
                  |L44.152|
                          DCD      ||.bss||+0x1ff
                  |L44.156|
                          DCD      ||.bss||+0x200
                  |L44.160|
                          DCD      RMP_Init

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  RMP_Run
                          %        256
                  RMP_Init_Stack
                          %        256
                  RMP_Init_Thd
                          %        60

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  RMP_RBIT_Table
000000  008040c0          DCB      0x00,0x80,0x40,0xc0
000004  20a060e0          DCB      0x20,0xa0,0x60,0xe0
000008  109050d0          DCB      0x10,0x90,0x50,0xd0
00000c  30b070f0          DCB      0x30,0xb0,0x70,0xf0
000010  088848c8          DCB      0x08,0x88,0x48,0xc8
000014  28a868e8          DCB      0x28,0xa8,0x68,0xe8
000018  189858d8          DCB      0x18,0x98,0x58,0xd8
00001c  38b878f8          DCB      0x38,0xb8,0x78,0xf8
000020  048444c4          DCB      0x04,0x84,0x44,0xc4
000024  24a464e4          DCB      0x24,0xa4,0x64,0xe4
000028  149454d4          DCB      0x14,0x94,0x54,0xd4
00002c  34b474f4          DCB      0x34,0xb4,0x74,0xf4
000030  0c8c4ccc          DCB      0x0c,0x8c,0x4c,0xcc
000034  2cac6cec          DCB      0x2c,0xac,0x6c,0xec
000038  1c9c5cdc          DCB      0x1c,0x9c,0x5c,0xdc
00003c  3cbc7cfc          DCB      0x3c,0xbc,0x7c,0xfc
000040  028242c2          DCB      0x02,0x82,0x42,0xc2
000044  22a262e2          DCB      0x22,0xa2,0x62,0xe2
000048  129252d2          DCB      0x12,0x92,0x52,0xd2
00004c  32b272f2          DCB      0x32,0xb2,0x72,0xf2
000050  0a8a4aca          DCB      0x0a,0x8a,0x4a,0xca
000054  2aaa6aea          DCB      0x2a,0xaa,0x6a,0xea
000058  1a9a5ada          DCB      0x1a,0x9a,0x5a,0xda
00005c  3aba7afa          DCB      0x3a,0xba,0x7a,0xfa
000060  068646c6          DCB      0x06,0x86,0x46,0xc6
000064  26a666e6          DCB      0x26,0xa6,0x66,0xe6
000068  169656d6          DCB      0x16,0x96,0x56,0xd6
00006c  36b676f6          DCB      0x36,0xb6,0x76,0xf6
000070  0e8e4ece          DCB      0x0e,0x8e,0x4e,0xce
000074  2eae6eee          DCB      0x2e,0xae,0x6e,0xee
000078  1e9e5ede          DCB      0x1e,0x9e,0x5e,0xde
00007c  3ebe7efe          DCB      0x3e,0xbe,0x7e,0xfe
000080  018141c1          DCB      0x01,0x81,0x41,0xc1
000084  21a161e1          DCB      0x21,0xa1,0x61,0xe1
000088  119151d1          DCB      0x11,0x91,0x51,0xd1
00008c  31b171f1          DCB      0x31,0xb1,0x71,0xf1
000090  098949c9          DCB      0x09,0x89,0x49,0xc9
000094  29a969e9          DCB      0x29,0xa9,0x69,0xe9
000098  199959d9          DCB      0x19,0x99,0x59,0xd9
00009c  39b979f9          DCB      0x39,0xb9,0x79,0xf9
0000a0  058545c5          DCB      0x05,0x85,0x45,0xc5
0000a4  25a565e5          DCB      0x25,0xa5,0x65,0xe5
0000a8  159555d5          DCB      0x15,0x95,0x55,0xd5
0000ac  35b575f5          DCB      0x35,0xb5,0x75,0xf5
0000b0  0d8d4dcd          DCB      0x0d,0x8d,0x4d,0xcd
0000b4  2dad6ded          DCB      0x2d,0xad,0x6d,0xed
0000b8  1d9d5ddd          DCB      0x1d,0x9d,0x5d,0xdd
0000bc  3dbd7dfd          DCB      0x3d,0xbd,0x7d,0xfd
0000c0  038343c3          DCB      0x03,0x83,0x43,0xc3
0000c4  23a363e3          DCB      0x23,0xa3,0x63,0xe3
0000c8  139353d3          DCB      0x13,0x93,0x53,0xd3
0000cc  33b373f3          DCB      0x33,0xb3,0x73,0xf3
0000d0  0b8b4bcb          DCB      0x0b,0x8b,0x4b,0xcb
0000d4  2bab6beb          DCB      0x2b,0xab,0x6b,0xeb
0000d8  1b9b5bdb          DCB      0x1b,0x9b,0x5b,0xdb
0000dc  3bbb7bfb          DCB      0x3b,0xbb,0x7b,0xfb
0000e0  078747c7          DCB      0x07,0x87,0x47,0xc7
0000e4  27a767e7          DCB      0x27,0xa7,0x67,0xe7
0000e8  179757d7          DCB      0x17,0x97,0x57,0xd7
0000ec  37b777f7          DCB      0x37,0xb7,0x77,0xf7
0000f0  0f8f4fcf          DCB      0x0f,0x8f,0x4f,0xcf
0000f4  2faf6fef          DCB      0x2f,0xaf,0x6f,0xef
0000f8  1f9f5fdf          DCB      0x1f,0x9f,0x5f,0xdf
0000fc  3fbf7fff          DCB      0x3f,0xbf,0x7f,0xff
                  CRC16_High
000100  00c18140          DCB      0x00,0xc1,0x81,0x40
000104  01c08041          DCB      0x01,0xc0,0x80,0x41
000108  01c08041          DCB      0x01,0xc0,0x80,0x41
00010c  00c18140          DCB      0x00,0xc1,0x81,0x40
000110  01c08041          DCB      0x01,0xc0,0x80,0x41
000114  00c18140          DCB      0x00,0xc1,0x81,0x40
000118  00c18140          DCB      0x00,0xc1,0x81,0x40
00011c  01c08041          DCB      0x01,0xc0,0x80,0x41
000120  01c08041          DCB      0x01,0xc0,0x80,0x41
000124  00c18140          DCB      0x00,0xc1,0x81,0x40
000128  00c18140          DCB      0x00,0xc1,0x81,0x40
00012c  01c08041          DCB      0x01,0xc0,0x80,0x41
000130  00c18140          DCB      0x00,0xc1,0x81,0x40
000134  01c08041          DCB      0x01,0xc0,0x80,0x41
000138  01c08041          DCB      0x01,0xc0,0x80,0x41
00013c  00c18140          DCB      0x00,0xc1,0x81,0x40
000140  01c08041          DCB      0x01,0xc0,0x80,0x41
000144  00c18140          DCB      0x00,0xc1,0x81,0x40
000148  00c18140          DCB      0x00,0xc1,0x81,0x40
00014c  01c08041          DCB      0x01,0xc0,0x80,0x41
000150  00c18140          DCB      0x00,0xc1,0x81,0x40
000154  01c08041          DCB      0x01,0xc0,0x80,0x41
000158  01c08041          DCB      0x01,0xc0,0x80,0x41
00015c  00c18140          DCB      0x00,0xc1,0x81,0x40
000160  00c18140          DCB      0x00,0xc1,0x81,0x40
000164  01c08041          DCB      0x01,0xc0,0x80,0x41
000168  01c08041          DCB      0x01,0xc0,0x80,0x41
00016c  00c18140          DCB      0x00,0xc1,0x81,0x40
000170  01c08041          DCB      0x01,0xc0,0x80,0x41
000174  00c18140          DCB      0x00,0xc1,0x81,0x40
000178  00c18140          DCB      0x00,0xc1,0x81,0x40
00017c  01c08041          DCB      0x01,0xc0,0x80,0x41
000180  01c08041          DCB      0x01,0xc0,0x80,0x41
000184  00c18140          DCB      0x00,0xc1,0x81,0x40
000188  00c18140          DCB      0x00,0xc1,0x81,0x40
00018c  01c08041          DCB      0x01,0xc0,0x80,0x41
000190  00c18140          DCB      0x00,0xc1,0x81,0x40
000194  01c08041          DCB      0x01,0xc0,0x80,0x41
000198  01c08041          DCB      0x01,0xc0,0x80,0x41
00019c  00c18140          DCB      0x00,0xc1,0x81,0x40
0001a0  00c18140          DCB      0x00,0xc1,0x81,0x40
0001a4  01c08041          DCB      0x01,0xc0,0x80,0x41
0001a8  01c08041          DCB      0x01,0xc0,0x80,0x41
0001ac  00c18140          DCB      0x00,0xc1,0x81,0x40
0001b0  01c08041          DCB      0x01,0xc0,0x80,0x41
0001b4  00c18140          DCB      0x00,0xc1,0x81,0x40
0001b8  00c18140          DCB      0x00,0xc1,0x81,0x40
0001bc  01c08041          DCB      0x01,0xc0,0x80,0x41
0001c0  00c18140          DCB      0x00,0xc1,0x81,0x40
0001c4  01c08041          DCB      0x01,0xc0,0x80,0x41
0001c8  01c08041          DCB      0x01,0xc0,0x80,0x41
0001cc  00c18140          DCB      0x00,0xc1,0x81,0x40
0001d0  01c08041          DCB      0x01,0xc0,0x80,0x41
0001d4  00c18140          DCB      0x00,0xc1,0x81,0x40
0001d8  00c18140          DCB      0x00,0xc1,0x81,0x40
0001dc  01c08041          DCB      0x01,0xc0,0x80,0x41
0001e0  01c08041          DCB      0x01,0xc0,0x80,0x41
0001e4  00c18140          DCB      0x00,0xc1,0x81,0x40
0001e8  00c18140          DCB      0x00,0xc1,0x81,0x40
0001ec  01c08041          DCB      0x01,0xc0,0x80,0x41
0001f0  00c18140          DCB      0x00,0xc1,0x81,0x40
0001f4  01c08041          DCB      0x01,0xc0,0x80,0x41
0001f8  01c08041          DCB      0x01,0xc0,0x80,0x41
0001fc  00c18140          DCB      0x00,0xc1,0x81,0x40
000200  00c0c101          DCB      0x00,0xc0,0xc1,0x01
000204  c30302c2          DCB      0xc3,0x03,0x02,0xc2
000208  c60607c7          DCB      0xc6,0x06,0x07,0xc7
00020c  05c5c404          DCB      0x05,0xc5,0xc4,0x04
000210  cc0c0dcd          DCB      0xcc,0x0c,0x0d,0xcd
000214  0fcfce0e          DCB      0x0f,0xcf,0xce,0x0e
000218  0acacb0b          DCB      0x0a,0xca,0xcb,0x0b
00021c  c90908c8          DCB      0xc9,0x09,0x08,0xc8
000220  d81819d9          DCB      0xd8,0x18,0x19,0xd9
000224  1bdbda1a          DCB      0x1b,0xdb,0xda,0x1a
000228  1ededf1f          DCB      0x1e,0xde,0xdf,0x1f
00022c  dd1d1cdc          DCB      0xdd,0x1d,0x1c,0xdc
000230  14d4d515          DCB      0x14,0xd4,0xd5,0x15
000234  d71716d6          DCB      0xd7,0x17,0x16,0xd6
000238  d21213d3          DCB      0xd2,0x12,0x13,0xd3
00023c  11d1d010          DCB      0x11,0xd1,0xd0,0x10
000240  f03031f1          DCB      0xf0,0x30,0x31,0xf1
000244  33f3f232          DCB      0x33,0xf3,0xf2,0x32
000248  36f6f737          DCB      0x36,0xf6,0xf7,0x37
00024c  f53534f4          DCB      0xf5,0x35,0x34,0xf4
000250  3cfcfd3d          DCB      0x3c,0xfc,0xfd,0x3d
000254  ff3f3efe          DCB      0xff,0x3f,0x3e,0xfe
000258  fa3a3bfb          DCB      0xfa,0x3a,0x3b,0xfb
00025c  39f9f838          DCB      0x39,0xf9,0xf8,0x38
000260  28e8e929          DCB      0x28,0xe8,0xe9,0x29
000264  eb2b2aea          DCB      0xeb,0x2b,0x2a,0xea
000268  ee2e2fef          DCB      0xee,0x2e,0x2f,0xef
00026c  2dedec2c          DCB      0x2d,0xed,0xec,0x2c
000270  e42425e5          DCB      0xe4,0x24,0x25,0xe5
000274  27e7e626          DCB      0x27,0xe7,0xe6,0x26
000278  22e2e323          DCB      0x22,0xe2,0xe3,0x23
00027c  e12120e0          DCB      0xe1,0x21,0x20,0xe0
000280  a06061a1          DCB      0xa0,0x60,0x61,0xa1
000284  63a3a262          DCB      0x63,0xa3,0xa2,0x62
000288  66a6a767          DCB      0x66,0xa6,0xa7,0x67
00028c  a56564a4          DCB      0xa5,0x65,0x64,0xa4
000290  6cacad6d          DCB      0x6c,0xac,0xad,0x6d
000294  af6f6eae          DCB      0xaf,0x6f,0x6e,0xae
000298  aa6a6bab          DCB      0xaa,0x6a,0x6b,0xab
00029c  69a9a868          DCB      0x69,0xa9,0xa8,0x68
0002a0  78b8b979          DCB      0x78,0xb8,0xb9,0x79
0002a4  bb7b7aba          DCB      0xbb,0x7b,0x7a,0xba
0002a8  be7e7fbf          DCB      0xbe,0x7e,0x7f,0xbf
0002ac  7dbdbc7c          DCB      0x7d,0xbd,0xbc,0x7c
0002b0  b47475b5          DCB      0xb4,0x74,0x75,0xb5
0002b4  77b7b676          DCB      0x77,0xb7,0xb6,0x76
0002b8  72b2b373          DCB      0x72,0xb2,0xb3,0x73
0002bc  b17170b0          DCB      0xb1,0x71,0x70,0xb0
0002c0  50909151          DCB      0x50,0x90,0x91,0x51
0002c4  93535292          DCB      0x93,0x53,0x52,0x92
0002c8  96565797          DCB      0x96,0x56,0x57,0x97
0002cc  55959454          DCB      0x55,0x95,0x94,0x54
0002d0  9c5c5d9d          DCB      0x9c,0x5c,0x5d,0x9d
0002d4  5f9f9e5e          DCB      0x5f,0x9f,0x9e,0x5e
0002d8  5a9a9b5b          DCB      0x5a,0x9a,0x9b,0x5b
0002dc  99595898          DCB      0x99,0x59,0x58,0x98
0002e0  88484989          DCB      0x88,0x48,0x49,0x89
0002e4  4b8b8a4a          DCB      0x4b,0x8b,0x8a,0x4a
0002e8  4e8e8f4f          DCB      0x4e,0x8e,0x8f,0x4f
0002ec  8d4d4c8c          DCB      0x8d,0x4d,0x4c,0x8c
0002f0  44848545          DCB      0x44,0x84,0x85,0x45
0002f4  87474686          DCB      0x87,0x47,0x46,0x86
0002f8  82424383          DCB      0x82,0x42,0x43,0x83
0002fc  41818040          DCB      0x41,0x81,0x80,0x40

                          AREA ||.data||, DATA, ALIGN=2

                  RMP_Bitmap
                          DCD      0x00000000
                  RMP_Sched_Lock_Cnt
                          DCD      0x00000000
                  RMP_Sched_Locked
                          DCD      0x00000000
                  RMP_Sched_Pend
                          DCD      0x00000000
                  RMP_Timer_Pend
                          DCD      0x00000000
                  RMP_Tick
                          DCD      0x00000000
                  RMP_Cur_Thd
                          DCD      0x00000000
                  RMP_Cur_SP
                          DCD      0x00000000
                  RMP_Delay
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\..\\MProkaron\\Kernel\\rmp_kernel.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_rmp_kernel_c_346ad0e8____REV16|
#line 388 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F1_V1.6.0\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___12_rmp_kernel_c_346ad0e8____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_rmp_kernel_c_346ad0e8____REVSH|
#line 402
|__asm___12_rmp_kernel_c_346ad0e8____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___12_rmp_kernel_c_346ad0e8____RRX|
#line 587
|__asm___12_rmp_kernel_c_346ad0e8____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
