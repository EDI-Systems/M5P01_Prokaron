; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f4xx_rcc.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f4xx_rcc.d --cpu=Cortex-M4.fp --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32F4xx_StdPeriph_Driver\inc -I..\..\..\M0P0_Library\STM32F4xx_StdPeriph_Driver\CMSIS\ST\STM32F4xx\Include -I..\..\..\M0P0_Library\STM32F4xx_StdPeriph_Driver\CMSIS\Include -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F405RGT6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.11.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F405xx -DSTM32F4XX -DUSE_STDPERIPH_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f4xx_rcc.crf ..\..\..\M0P0_Library\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_rcc.c]
                          THUMB

                          AREA ||i.RCC_AHB1PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB1PeriphClockCmd PROC
;;;1084     */
;;;1085   void RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L1.20|
;;;1086   {
;;;1087     /* Check the parameters */
;;;1088     assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));
;;;1089   
;;;1090     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1091     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1092     {
;;;1093       RCC->AHB1ENR |= RCC_AHB1Periph;
;;;1094     }
;;;1095     else
;;;1096     {
;;;1097       RCC->AHB1ENR &= ~RCC_AHB1Periph;
000004  6811              LDR      r1,[r2,#0]
000006  bf14              ITE      NE                    ;1093
000008  4308              ORRNE    r0,r0,r1              ;1093
00000a  ea210000          BICEQ    r0,r1,r0
00000e  6010              STR      r0,[r2,#0]            ;1093
;;;1098     }
;;;1099   }
000010  4770              BX       lr
;;;1100   
                          ENDP

000012  0000              DCW      0x0000
                  |L1.20|
                          DCD      0x40023830

                          AREA ||i.RCC_AHB1PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB1PeriphClockLPModeCmd PROC
;;;1454     */
;;;1455   void RCC_AHB1PeriphClockLPModeCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L2.20|
;;;1456   {
;;;1457     /* Check the parameters */
;;;1458     assert_param(IS_RCC_AHB1_LPMODE_PERIPH(RCC_AHB1Periph));
;;;1459     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1460     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1461     {
;;;1462       RCC->AHB1LPENR |= RCC_AHB1Periph;
;;;1463     }
;;;1464     else
;;;1465     {
;;;1466       RCC->AHB1LPENR &= ~RCC_AHB1Periph;
000004  6811              LDR      r1,[r2,#0]
000006  bf14              ITE      NE                    ;1462
000008  4308              ORRNE    r0,r0,r1              ;1462
00000a  ea210000          BICEQ    r0,r1,r0
00000e  6010              STR      r0,[r2,#0]            ;1462
;;;1467     }
;;;1468   }
000010  4770              BX       lr
;;;1469   
                          ENDP

000012  0000              DCW      0x0000
                  |L2.20|
                          DCD      0x40023850

                          AREA ||i.RCC_AHB1PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB1PeriphResetCmd PROC
;;;1272     */
;;;1273   void RCC_AHB1PeriphResetCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L3.20|
;;;1274   {
;;;1275     /* Check the parameters */
;;;1276     assert_param(IS_RCC_AHB1_RESET_PERIPH(RCC_AHB1Periph));
;;;1277     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1278   
;;;1279     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1280     {
;;;1281       RCC->AHB1RSTR |= RCC_AHB1Periph;
;;;1282     }
;;;1283     else
;;;1284     {
;;;1285       RCC->AHB1RSTR &= ~RCC_AHB1Periph;
000004  6811              LDR      r1,[r2,#0]
000006  bf14              ITE      NE                    ;1281
000008  4308              ORRNE    r0,r0,r1              ;1281
00000a  ea210000          BICEQ    r0,r1,r0
00000e  6010              STR      r0,[r2,#0]            ;1281
;;;1286     }
;;;1287   }
000010  4770              BX       lr
;;;1288   
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      0x40023810

                          AREA ||i.RCC_AHB2PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB2PeriphClockCmd PROC
;;;1116     */
;;;1117   void RCC_AHB2PeriphClockCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L4.20|
;;;1118   {
;;;1119     /* Check the parameters */
;;;1120     assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
;;;1121     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1122   
;;;1123     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1124     {
;;;1125       RCC->AHB2ENR |= RCC_AHB2Periph;
;;;1126     }
;;;1127     else
;;;1128     {
;;;1129       RCC->AHB2ENR &= ~RCC_AHB2Periph;
000004  6811              LDR      r1,[r2,#0]
000006  bf14              ITE      NE                    ;1125
000008  4308              ORRNE    r0,r0,r1              ;1125
00000a  ea210000          BICEQ    r0,r1,r0
00000e  6010              STR      r0,[r2,#0]            ;1125
;;;1130     }
;;;1131   }
000010  4770              BX       lr
;;;1132   
                          ENDP

000012  0000              DCW      0x0000
                  |L4.20|
                          DCD      0x40023834

                          AREA ||i.RCC_AHB2PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB2PeriphClockLPModeCmd PROC
;;;1486     */
;;;1487   void RCC_AHB2PeriphClockLPModeCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L5.20|
;;;1488   {
;;;1489     /* Check the parameters */
;;;1490     assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
;;;1491     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1492     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1493     {
;;;1494       RCC->AHB2LPENR |= RCC_AHB2Periph;
;;;1495     }
;;;1496     else
;;;1497     {
;;;1498       RCC->AHB2LPENR &= ~RCC_AHB2Periph;
000004  6811              LDR      r1,[r2,#0]
000006  bf14              ITE      NE                    ;1494
000008  4308              ORRNE    r0,r0,r1              ;1494
00000a  ea210000          BICEQ    r0,r1,r0
00000e  6010              STR      r0,[r2,#0]            ;1494
;;;1499     }
;;;1500   }
000010  4770              BX       lr
;;;1501   
                          ENDP

000012  0000              DCW      0x0000
                  |L5.20|
                          DCD      0x40023854

                          AREA ||i.RCC_AHB2PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB2PeriphResetCmd PROC
;;;1301     */
;;;1302   void RCC_AHB2PeriphResetCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L6.20|
;;;1303   {
;;;1304     /* Check the parameters */
;;;1305     assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
;;;1306     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1307   
;;;1308     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1309     {
;;;1310       RCC->AHB2RSTR |= RCC_AHB2Periph;
;;;1311     }
;;;1312     else
;;;1313     {
;;;1314       RCC->AHB2RSTR &= ~RCC_AHB2Periph;
000004  6811              LDR      r1,[r2,#0]
000006  bf14              ITE      NE                    ;1310
000008  4308              ORRNE    r0,r0,r1              ;1310
00000a  ea210000          BICEQ    r0,r1,r0
00000e  6010              STR      r0,[r2,#0]            ;1310
;;;1315     }
;;;1316   }
000010  4770              BX       lr
;;;1317   
                          ENDP

000012  0000              DCW      0x0000
                  |L6.20|
                          DCD      0x40023814

                          AREA ||i.RCC_AHB3PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB3PeriphClockCmd PROC
;;;1143     */
;;;1144   void RCC_AHB3PeriphClockCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L7.20|
;;;1145   {
;;;1146     /* Check the parameters */
;;;1147     assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));  
;;;1148     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1149   
;;;1150     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1151     {
;;;1152       RCC->AHB3ENR |= RCC_AHB3Periph;
;;;1153     }
;;;1154     else
;;;1155     {
;;;1156       RCC->AHB3ENR &= ~RCC_AHB3Periph;
000004  6811              LDR      r1,[r2,#0]
000006  bf14              ITE      NE                    ;1152
000008  4308              ORRNE    r0,r0,r1              ;1152
00000a  ea210000          BICEQ    r0,r1,r0
00000e  6010              STR      r0,[r2,#0]            ;1152
;;;1157     }
;;;1158   }
000010  4770              BX       lr
;;;1159   
                          ENDP

000012  0000              DCW      0x0000
                  |L7.20|
                          DCD      0x40023838

                          AREA ||i.RCC_AHB3PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB3PeriphClockLPModeCmd PROC
;;;1513     */
;;;1514   void RCC_AHB3PeriphClockLPModeCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L8.20|
;;;1515   {
;;;1516     /* Check the parameters */
;;;1517     assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
;;;1518     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1519     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1520     {
;;;1521       RCC->AHB3LPENR |= RCC_AHB3Periph;
;;;1522     }
;;;1523     else
;;;1524     {
;;;1525       RCC->AHB3LPENR &= ~RCC_AHB3Periph;
000004  6811              LDR      r1,[r2,#0]
000006  bf14              ITE      NE                    ;1521
000008  4308              ORRNE    r0,r0,r1              ;1521
00000a  ea210000          BICEQ    r0,r1,r0
00000e  6010              STR      r0,[r2,#0]            ;1521
;;;1526     }
;;;1527   }
000010  4770              BX       lr
;;;1528   
                          ENDP

000012  0000              DCW      0x0000
                  |L8.20|
                          DCD      0x40023858

                          AREA ||i.RCC_AHB3PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB3PeriphResetCmd PROC
;;;1325     */
;;;1326   void RCC_AHB3PeriphResetCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L9.20|
;;;1327   {
;;;1328     /* Check the parameters */
;;;1329     assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
;;;1330     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1331   
;;;1332     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1333     {
;;;1334       RCC->AHB3RSTR |= RCC_AHB3Periph;
;;;1335     }
;;;1336     else
;;;1337     {
;;;1338       RCC->AHB3RSTR &= ~RCC_AHB3Periph;
000004  6811              LDR      r1,[r2,#0]
000006  bf14              ITE      NE                    ;1334
000008  4308              ORRNE    r0,r0,r1              ;1334
00000a  ea210000          BICEQ    r0,r1,r0
00000e  6010              STR      r0,[r2,#0]            ;1334
;;;1339     }
;;;1340   }
000010  4770              BX       lr
;;;1341   
                          ENDP

000012  0000              DCW      0x0000
                  |L9.20|
                          DCD      0x40023818

                          AREA ||i.RCC_APB1PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphClockCmd PROC
;;;1193     */
;;;1194   void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L10.20|
;;;1195   {
;;;1196     /* Check the parameters */
;;;1197     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
;;;1198     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1199   
;;;1200     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1201     {
;;;1202       RCC->APB1ENR |= RCC_APB1Periph;
;;;1203     }
;;;1204     else
;;;1205     {
;;;1206       RCC->APB1ENR &= ~RCC_APB1Periph;
000004  6811              LDR      r1,[r2,#0]
000006  bf14              ITE      NE                    ;1202
000008  4308              ORRNE    r0,r0,r1              ;1202
00000a  ea210000          BICEQ    r0,r1,r0
00000e  6010              STR      r0,[r2,#0]            ;1202
;;;1207     }
;;;1208   }
000010  4770              BX       lr
;;;1209   
                          ENDP

000012  0000              DCW      0x0000
                  |L10.20|
                          DCD      0x40023840

                          AREA ||i.RCC_APB1PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphClockLPModeCmd PROC
;;;1563     */
;;;1564   void RCC_APB1PeriphClockLPModeCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L11.20|
;;;1565   {
;;;1566     /* Check the parameters */
;;;1567     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;1568     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1569     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1570     {
;;;1571       RCC->APB1LPENR |= RCC_APB1Periph;
;;;1572     }
;;;1573     else
;;;1574     {
;;;1575       RCC->APB1LPENR &= ~RCC_APB1Periph;
000004  6811              LDR      r1,[r2,#0]
000006  bf14              ITE      NE                    ;1571
000008  4308              ORRNE    r0,r0,r1              ;1571
00000a  ea210000          BICEQ    r0,r1,r0
00000e  6010              STR      r0,[r2,#0]            ;1571
;;;1576     }
;;;1577   }
000010  4770              BX       lr
;;;1578   
                          ENDP

000012  0000              DCW      0x0000
                  |L11.20|
                          DCD      0x40023860

                          AREA ||i.RCC_APB1PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphResetCmd PROC
;;;1372     */
;;;1373   void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L12.20|
;;;1374   {
;;;1375     /* Check the parameters */
;;;1376     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;1377     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1378     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1379     {
;;;1380       RCC->APB1RSTR |= RCC_APB1Periph;
;;;1381     }
;;;1382     else
;;;1383     {
;;;1384       RCC->APB1RSTR &= ~RCC_APB1Periph;
000004  6811              LDR      r1,[r2,#0]
000006  bf14              ITE      NE                    ;1380
000008  4308              ORRNE    r0,r0,r1              ;1380
00000a  ea210000          BICEQ    r0,r1,r0
00000e  6010              STR      r0,[r2,#0]            ;1380
;;;1385     }
;;;1386   }
000010  4770              BX       lr
;;;1387   
                          ENDP

000012  0000              DCW      0x0000
                  |L12.20|
                          DCD      0x40023820

                          AREA ||i.RCC_APB2PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphClockCmd PROC
;;;1233     */
;;;1234   void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L13.20|
;;;1235   {
;;;1236     /* Check the parameters */
;;;1237     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;1238     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1239   
;;;1240     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1241     {
;;;1242       RCC->APB2ENR |= RCC_APB2Periph;
;;;1243     }
;;;1244     else
;;;1245     {
;;;1246       RCC->APB2ENR &= ~RCC_APB2Periph;
000004  6811              LDR      r1,[r2,#0]
000006  bf14              ITE      NE                    ;1242
000008  4308              ORRNE    r0,r0,r1              ;1242
00000a  ea210000          BICEQ    r0,r1,r0
00000e  6010              STR      r0,[r2,#0]            ;1242
;;;1247     }
;;;1248   }
000010  4770              BX       lr
;;;1249   
                          ENDP

000012  0000              DCW      0x0000
                  |L13.20|
                          DCD      0x40023844

                          AREA ||i.RCC_APB2PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphClockLPModeCmd PROC
;;;1603     */
;;;1604   void RCC_APB2PeriphClockLPModeCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L14.20|
;;;1605   {
;;;1606     /* Check the parameters */
;;;1607     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;1608     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1609     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1610     {
;;;1611       RCC->APB2LPENR |= RCC_APB2Periph;
;;;1612     }
;;;1613     else
;;;1614     {
;;;1615       RCC->APB2LPENR &= ~RCC_APB2Periph;
000004  6811              LDR      r1,[r2,#0]
000006  bf14              ITE      NE                    ;1611
000008  4308              ORRNE    r0,r0,r1              ;1611
00000a  ea210000          BICEQ    r0,r1,r0
00000e  6010              STR      r0,[r2,#0]            ;1611
;;;1616     }
;;;1617   }
000010  4770              BX       lr
;;;1618   
                          ENDP

000012  0000              DCW      0x0000
                  |L14.20|
                          DCD      0x40023864

                          AREA ||i.RCC_APB2PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphResetCmd PROC
;;;1408     */
;;;1409   void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L15.20|
;;;1410   {
;;;1411     /* Check the parameters */
;;;1412     assert_param(IS_RCC_APB2_RESET_PERIPH(RCC_APB2Periph));
;;;1413     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1414     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1415     {
;;;1416       RCC->APB2RSTR |= RCC_APB2Periph;
;;;1417     }
;;;1418     else
;;;1419     {
;;;1420       RCC->APB2RSTR &= ~RCC_APB2Periph;
000004  6811              LDR      r1,[r2,#0]
000006  bf14              ITE      NE                    ;1416
000008  4308              ORRNE    r0,r0,r1              ;1416
00000a  ea210000          BICEQ    r0,r1,r0
00000e  6010              STR      r0,[r2,#0]            ;1416
;;;1421     }
;;;1422   }
000010  4770              BX       lr
;;;1423   
                          ENDP

000012  0000              DCW      0x0000
                  |L15.20|
                          DCD      0x40023824

                          AREA ||i.RCC_AdjustHSICalibrationValue||, CODE, READONLY, ALIGN=2

                  RCC_AdjustHSICalibrationValue PROC
;;;291      */
;;;292    void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
000000  4903              LDR      r1,|L16.16|
;;;293    {
;;;294      uint32_t tmpreg = 0;
;;;295      /* Check the parameters */
;;;296      assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
;;;297    
;;;298      tmpreg = RCC->CR;
000002  680a              LDR      r2,[r1,#0]
;;;299    
;;;300      /* Clear HSITRIM[4:0] bits */
;;;301      tmpreg &= ~RCC_CR_HSITRIM;
000004  f02202f8          BIC      r2,r2,#0xf8
;;;302    
;;;303      /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
;;;304      tmpreg |= (uint32_t)HSICalibrationValue << 3;
000008  ea4200c0          ORR      r0,r2,r0,LSL #3
;;;305    
;;;306      /* Store the new value */
;;;307      RCC->CR = tmpreg;
00000c  6008              STR      r0,[r1,#0]
;;;308    }
00000e  4770              BX       lr
;;;309    
                          ENDP

                  |L16.16|
                          DCD      0x40023800

                          AREA ||i.RCC_BackupResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_BackupResetCmd PROC
;;;1028     */
;;;1029   void RCC_BackupResetCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L17.8|
;;;1030   {
;;;1031     /* Check the parameters */
;;;1032     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1033     *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;1034   }
000004  4770              BX       lr
;;;1035   
                          ENDP

000006  0000              DCW      0x0000
                  |L17.8|
                          DCD      0x42470e40

                          AREA ||i.RCC_ClearFlag||, CODE, READONLY, ALIGN=2

                  RCC_ClearFlag PROC
;;;1729     */
;;;1730   void RCC_ClearFlag(void)
000000  4802              LDR      r0,|L18.12|
;;;1731   {
;;;1732     /* Set RMVF bit to clear the reset flags */
;;;1733     RCC->CSR |= RCC_CSR_RMVF;
000002  6801              LDR      r1,[r0,#0]
000004  f0417180          ORR      r1,r1,#0x1000000
000008  6001              STR      r1,[r0,#0]
;;;1734   }
00000a  4770              BX       lr
;;;1735   
                          ENDP

                  |L18.12|
                          DCD      0x40023874

                          AREA ||i.RCC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  RCC_ClearITPendingBit PROC
;;;1781     */
;;;1782   void RCC_ClearITPendingBit(uint8_t RCC_IT)
000000  4901              LDR      r1,|L19.8|
;;;1783   {
;;;1784     /* Check the parameters */
;;;1785     assert_param(IS_RCC_CLEAR_IT(RCC_IT));
;;;1786   
;;;1787     /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
;;;1788        pending bits */
;;;1789     *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
000002  7008              STRB     r0,[r1,#0]
;;;1790   }
000004  4770              BX       lr
;;;1791   
                          ENDP

000006  0000              DCW      0x0000
                  |L19.8|
                          DCD      0x4002380e

                          AREA ||i.RCC_ClockSecuritySystemCmd||, CODE, READONLY, ALIGN=2

                  RCC_ClockSecuritySystemCmd PROC
;;;517      */
;;;518    void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L20.8|
;;;519    {
;;;520      /* Check the parameters */
;;;521      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;522      *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
000002  64c8              STR      r0,[r1,#0x4c]
;;;523    }
000004  4770              BX       lr
;;;524    
                          ENDP

000006  0000              DCW      0x0000
                  |L20.8|
                          DCD      0x42470000

                          AREA ||i.RCC_DeInit||, CODE, READONLY, ALIGN=2

                  RCC_DeInit PROC
;;;195      */
;;;196    void RCC_DeInit(void)
000000  480b              LDR      r0,|L21.48|
;;;197    {
;;;198      /* Set HSION bit */
;;;199      RCC->CR |= (uint32_t)0x00000001;
000002  6801              LDR      r1,[r0,#0]
000004  f0410101          ORR      r1,r1,#1
000008  6001              STR      r1,[r0,#0]
;;;200    
;;;201      /* Reset CFGR register */
;;;202      RCC->CFGR = 0x00000000;
00000a  4a0a              LDR      r2,|L21.52|
00000c  2100              MOVS     r1,#0
00000e  6011              STR      r1,[r2,#0]
;;;203    
;;;204      /* Reset HSEON, CSSON and PLLON bits */
;;;205      RCC->CR &= (uint32_t)0xFEF6FFFF;
000010  6802              LDR      r2,[r0,#0]
000012  f4222210          BIC      r2,r2,#0x90000
000016  f0227280          BIC      r2,r2,#0x1000000
00001a  6002              STR      r2,[r0,#0]
;;;206    
;;;207      /* Reset PLLCFGR register */
;;;208      RCC->PLLCFGR = 0x24003010;
00001c  1d03              ADDS     r3,r0,#4
00001e  4a06              LDR      r2,|L21.56|
000020  601a              STR      r2,[r3,#0]
;;;209    
;;;210      /* Reset HSEBYP bit */
;;;211      RCC->CR &= (uint32_t)0xFFFBFFFF;
000022  6802              LDR      r2,[r0,#0]
000024  f4222280          BIC      r2,r2,#0x40000
000028  6002              STR      r2,[r0,#0]
;;;212    
;;;213      /* Disable all interrupts */
;;;214      RCC->CIR = 0x00000000;
00002a  4804              LDR      r0,|L21.60|
00002c  6001              STR      r1,[r0,#0]
;;;215    }
00002e  4770              BX       lr
;;;216    
                          ENDP

                  |L21.48|
                          DCD      0x40023800
                  |L21.52|
                          DCD      0x40023808
                  |L21.56|
                          DCD      0x24003010
                  |L21.60|
                          DCD      0x4002380c

                          AREA ||i.RCC_GetClocksFreq||, CODE, READONLY, ALIGN=2

                  RCC_GetClocksFreq PROC
;;;854      */
;;;855    void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
000000  4a25              LDR      r2,|L22.152|
;;;856    {
000002  b430              PUSH     {r4,r5}
;;;857      uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
;;;858    
;;;859      /* Get SYSCLK source -------------------------------------------------------*/
;;;860      tmp = RCC->CFGR & RCC_CFGR_SWS;
000004  6811              LDR      r1,[r2,#0]
;;;861    
;;;862      switch (tmp)
;;;863      {
;;;864        case 0x00:  /* HSI used as system clock source */
;;;865          RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
000006  4b25              LDR      r3,|L22.156|
000008  f011010c          ANDS     r1,r1,#0xc            ;860
00000c  d006              BEQ      |L22.28|
;;;866          break;
;;;867        case 0x04:  /* HSE used as system clock  source */
;;;868          RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
00000e  4c24              LDR      r4,|L22.160|
000010  2904              CMP      r1,#4                 ;862
000012  bf08              IT       EQ
000014  6004              STREQ    r4,[r0,#0]
000016  d002              BEQ      |L22.30|
000018  2908              CMP      r1,#8                 ;862
00001a  d01e              BEQ      |L22.90|
                  |L22.28|
00001c  6003              STR      r3,[r0,#0]            ;865
                  |L22.30|
;;;869          break;
;;;870        case 0x08:  /* PLL used as system clock  source */
;;;871    
;;;872          /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
;;;873             SYSCLK = PLL_VCO / PLLP
;;;874             */    
;;;875          pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
;;;876          pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
;;;877          
;;;878          if (pllsource != 0)
;;;879          {
;;;880            /* HSE used as PLL clock source */
;;;881            pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
;;;882          }
;;;883          else
;;;884          {
;;;885            /* HSI used as PLL clock source */
;;;886            pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
;;;887          }
;;;888    
;;;889          pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
;;;890          RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
;;;891          break;
;;;892        default:
;;;893          RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
;;;894          break;
;;;895      }
;;;896      /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/
;;;897    
;;;898      /* Get HCLK prescaler */
;;;899      tmp = RCC->CFGR & RCC_CFGR_HPRE;
00001e  6811              LDR      r1,[r2,#0]
;;;900      tmp = tmp >> 4;
;;;901      presc = APBAHBPrescTable[tmp];
;;;902      /* HCLK clock frequency */
;;;903      RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
;;;904    
;;;905      /* Get PCLK1 prescaler */
;;;906      tmp = RCC->CFGR & RCC_CFGR_PPRE1;
;;;907      tmp = tmp >> 10;
;;;908      presc = APBAHBPrescTable[tmp];
;;;909      /* PCLK1 clock frequency */
;;;910      RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
;;;911    
;;;912      /* Get PCLK2 prescaler */
;;;913      tmp = RCC->CFGR & RCC_CFGR_PPRE2;
;;;914      tmp = tmp >> 13;
;;;915      presc = APBAHBPrescTable[tmp];
;;;916      /* PCLK2 clock frequency */
;;;917      RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
;;;918    }
000020  230f              MOVS     r3,#0xf
000022  ea031111          AND      r1,r3,r1,LSR #4
000026  4b1f              LDR      r3,|L22.164|
000028  5c59              LDRB     r1,[r3,r1]            ;901
00002a  f8d0c000          LDR      r12,[r0,#0]           ;903
00002e  fa2cf101          LSR      r1,r12,r1             ;903
000032  6041              STR      r1,[r0,#4]            ;906
000034  f8d2c000          LDR      r12,[r2,#0]           ;906
000038  2407              MOVS     r4,#7
00003a  ea042c9c          AND      r12,r4,r12,LSR #10
00003e  f813c00c          LDRB     r12,[r3,r12]          ;908
000042  fa21fc0c          LSR      r12,r1,r12            ;910
000046  f8c0c008          STR      r12,[r0,#8]           ;913
00004a  6812              LDR      r2,[r2,#0]            ;913
00004c  ea043252          AND      r2,r4,r2,LSR #13
000050  5c9a              LDRB     r2,[r3,r2]            ;915
000052  40d1              LSRS     r1,r1,r2              ;917
000054  60c1              STR      r1,[r0,#0xc]
000056  bc30              POP      {r4,r5}
000058  4770              BX       lr
                  |L22.90|
00005a  4913              LDR      r1,|L22.168|
00005c  f8d1c000          LDR      r12,[r1,#0]           ;875
000060  f3cc5580          UBFX     r5,r12,#22,#1         ;875
000064  f8d1c000          LDR      r12,[r1,#0]           ;876
000068  2d00              CMP      r5,#0                 ;878
00006a  f00c0c3f          AND      r12,r12,#0x3f         ;876
00006e  bf14              ITE      NE                    ;881
000070  fbb4f3fc          UDIVNE   r3,r4,r12             ;881
000074  fbb3f3fc          UDIVEQ   r3,r3,r12             ;886
000078  f8d1c000          LDR      r12,[r1,#0]           ;886
00007c  6809              LDR      r1,[r1,#0]            ;889
00007e  f3cc1c88          UBFX     r12,r12,#6,#9         ;886
000082  fb03f30c          MUL      r3,r3,r12             ;886
000086  f3c14101          UBFX     r1,r1,#16,#2          ;889
00008a  1c49              ADDS     r1,r1,#1              ;889
00008c  0049              LSLS     r1,r1,#1              ;889
00008e  fbb3f1f1          UDIV     r1,r3,r1              ;890
000092  6001              STR      r1,[r0,#0]            ;878
000094  e7c3              B        |L22.30|
;;;919    
                          ENDP

000096  0000              DCW      0x0000
                  |L22.152|
                          DCD      0x40023808
                  |L22.156|
                          DCD      0x00f42400
                  |L22.160|
                          DCD      0x017d7840
                  |L22.164|
                          DCD      ||.data||
                  |L22.168|
                          DCD      0x40023804

                          AREA ||i.RCC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetFlagStatus PROC
;;;1684     */
;;;1685   FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
000000  2200              MOVS     r2,#0
;;;1686   {
;;;1687     uint32_t tmp = 0;
;;;1688     uint32_t statusreg = 0;
;;;1689     FlagStatus bitstatus = RESET;
;;;1690   
;;;1691     /* Check the parameters */
;;;1692     assert_param(IS_RCC_FLAG(RCC_FLAG));
;;;1693   
;;;1694     /* Get the RCC register index */
;;;1695     tmp = RCC_FLAG >> 5;
000002  0941              LSRS     r1,r0,#5
;;;1696     if (tmp == 1)               /* The flag to check is in CR register */
000004  2901              CMP      r1,#1
;;;1697     {
;;;1698       statusreg = RCC->CR;
000006  bf04              ITT      EQ
000008  4908              LDREQ    r1,|L23.44|
00000a  6809              LDREQ    r1,[r1,#0]
00000c  d004              BEQ      |L23.24|
;;;1699     }
;;;1700     else if (tmp == 2)          /* The flag to check is in BDCR register */
00000e  2902              CMP      r1,#2
;;;1701     {
;;;1702       statusreg = RCC->BDCR;
000010  bf0c              ITE      EQ
000012  4907              LDREQ    r1,|L23.48|
;;;1703     }
;;;1704     else                       /* The flag to check is in CSR register */
;;;1705     {
;;;1706       statusreg = RCC->CSR;
000014  4907              LDRNE    r1,|L23.52|
000016  6809              LDR      r1,[r1,#0]
                  |L23.24|
;;;1707     }
;;;1708   
;;;1709     /* Get the flag position */
;;;1710     tmp = RCC_FLAG & FLAG_MASK;
000018  f000001f          AND      r0,r0,#0x1f
;;;1711     if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
00001c  2301              MOVS     r3,#1
00001e  fa03f000          LSL      r0,r3,r0
000022  4208              TST      r0,r1
;;;1712     {
;;;1713       bitstatus = SET;
000024  bf18              IT       NE
000026  2201              MOVNE    r2,#1
;;;1714     }
;;;1715     else
;;;1716     {
;;;1717       bitstatus = RESET;
;;;1718     }
;;;1719     /* Return the flag status */
;;;1720     return bitstatus;
000028  4610              MOV      r0,r2
;;;1721   }
00002a  4770              BX       lr
;;;1722   
                          ENDP

                  |L23.44|
                          DCD      0x40023800
                  |L23.48|
                          DCD      0x40023870
                  |L23.52|
                          DCD      0x40023874

                          AREA ||i.RCC_GetITStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetITStatus PROC
;;;1748     */
;;;1749   ITStatus RCC_GetITStatus(uint8_t RCC_IT)
000000  4a03              LDR      r2,|L24.16|
;;;1750   {
000002  4601              MOV      r1,r0
;;;1751     ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1752   
;;;1753     /* Check the parameters */
;;;1754     assert_param(IS_RCC_GET_IT(RCC_IT));
;;;1755   
;;;1756     /* Check the status of the specified RCC interrupt */
;;;1757     if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
000006  6812              LDR      r2,[r2,#0]
000008  420a              TST      r2,r1
;;;1758     {
;;;1759       bitstatus = SET;
00000a  bf18              IT       NE
00000c  2001              MOVNE    r0,#1
;;;1760     }
;;;1761     else
;;;1762     {
;;;1763       bitstatus = RESET;
;;;1764     }
;;;1765     /* Return the RCC_IT status */
;;;1766     return  bitstatus;
;;;1767   }
00000e  4770              BX       lr
;;;1768   
                          ENDP

                  |L24.16|
                          DCD      0x4002380c

                          AREA ||i.RCC_GetSYSCLKSource||, CODE, READONLY, ALIGN=2

                  RCC_GetSYSCLKSource PROC
;;;714      */
;;;715    uint8_t RCC_GetSYSCLKSource(void)
000000  4802              LDR      r0,|L25.12|
;;;716    {
;;;717      return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
000002  6800              LDR      r0,[r0,#0]
000004  f000000c          AND      r0,r0,#0xc
;;;718    }
000008  4770              BX       lr
;;;719    
                          ENDP

00000a  0000              DCW      0x0000
                  |L25.12|
                          DCD      0x40023808

                          AREA ||i.RCC_HCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_HCLKConfig PROC
;;;739      */
;;;740    void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
000000  4903              LDR      r1,|L26.16|
;;;741    {
;;;742      uint32_t tmpreg = 0;
;;;743      
;;;744      /* Check the parameters */
;;;745      assert_param(IS_RCC_HCLK(RCC_SYSCLK));
;;;746    
;;;747      tmpreg = RCC->CFGR;
000002  680a              LDR      r2,[r1,#0]
;;;748    
;;;749      /* Clear HPRE[3:0] bits */
;;;750      tmpreg &= ~RCC_CFGR_HPRE;
000004  f02202f0          BIC      r2,r2,#0xf0
;;;751    
;;;752      /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
;;;753      tmpreg |= RCC_SYSCLK;
000008  4310              ORRS     r0,r0,r2
;;;754    
;;;755      /* Store the new value */
;;;756      RCC->CFGR = tmpreg;
00000a  6008              STR      r0,[r1,#0]
;;;757    }
00000c  4770              BX       lr
;;;758    
                          ENDP

00000e  0000              DCW      0x0000
                  |L26.16|
                          DCD      0x40023808

                          AREA ||i.RCC_HSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_HSEConfig PROC
;;;236      */
;;;237    void RCC_HSEConfig(uint8_t RCC_HSE)
000000  4902              LDR      r1,|L27.12|
;;;238    {
;;;239      /* Check the parameters */
;;;240      assert_param(IS_RCC_HSE(RCC_HSE));
;;;241    
;;;242      /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
;;;243      *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE_OFF;
000002  2200              MOVS     r2,#0
000004  700a              STRB     r2,[r1,#0]
;;;244    
;;;245      /* Set the new HSE configuration -------------------------------------------*/
;;;246      *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE;
000006  7008              STRB     r0,[r1,#0]
;;;247    }
000008  4770              BX       lr
;;;248    
                          ENDP

00000a  0000              DCW      0x0000
                  |L27.12|
                          DCD      0x40023802

                          AREA ||i.RCC_HSICmd||, CODE, READONLY, ALIGN=2

                  RCC_HSICmd PROC
;;;327      */
;;;328    void RCC_HSICmd(FunctionalState NewState)
000000  4901              LDR      r1,|L28.8|
;;;329    {
;;;330      /* Check the parameters */
;;;331      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;332    
;;;333      *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;334    }
000004  4770              BX       lr
;;;335    
                          ENDP

000006  0000              DCW      0x0000
                  |L28.8|
                          DCD      0x42470000

                          AREA ||i.RCC_I2SCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_I2SCLKConfig PROC
;;;1045     */
;;;1046   void RCC_I2SCLKConfig(uint32_t RCC_I2SCLKSource)
000000  4901              LDR      r1,|L29.8|
;;;1047   {
;;;1048     /* Check the parameters */
;;;1049     assert_param(IS_RCC_I2SCLK_SOURCE(RCC_I2SCLKSource));
;;;1050   
;;;1051     *(__IO uint32_t *) CFGR_I2SSRC_BB = RCC_I2SCLKSource;
000002  f8c1015c          STR      r0,[r1,#0x15c]
;;;1052   }
000006  4770              BX       lr
;;;1053   
                          ENDP

                  |L29.8|
                          DCD      0x42470000

                          AREA ||i.RCC_ITConfig||, CODE, READONLY, ALIGN=2

                  RCC_ITConfig PROC
;;;1648     */
;;;1649   void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
000000  4a04              LDR      r2,|L30.20|
;;;1650   {
;;;1651     /* Check the parameters */
;;;1652     assert_param(IS_RCC_IT(RCC_IT));
;;;1653     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1654     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1655     {
;;;1656       /* Perform Byte access to RCC_CIR[14:8] bits to enable the selected interrupts */
;;;1657       *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
;;;1658     }
;;;1659     else
;;;1660     {
;;;1661       /* Perform Byte access to RCC_CIR[14:8] bits to disable the selected interrupts */
;;;1662       *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
000004  7811              LDRB     r1,[r2,#0]
000006  bf14              ITE      NE                    ;1657
000008  4308              ORRNE    r0,r0,r1              ;1657
00000a  ea210000          BICEQ    r0,r1,r0
00000e  7010              STRB     r0,[r2,#0]            ;1657
;;;1663     }
;;;1664   }
000010  4770              BX       lr
;;;1665   
                          ENDP

000012  0000              DCW      0x0000
                  |L30.20|
                          DCD      0x4002380d

                          AREA ||i.RCC_LSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_LSEConfig PROC
;;;352      */
;;;353    void RCC_LSEConfig(uint8_t RCC_LSE)
000000  4905              LDR      r1,|L31.24|
;;;354    {
;;;355      /* Check the parameters */
;;;356      assert_param(IS_RCC_LSE(RCC_LSE));
;;;357    
;;;358      /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
;;;359      /* Reset LSEON bit */
;;;360      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
000002  2200              MOVS     r2,#0
000004  700a              STRB     r2,[r1,#0]
;;;361    
;;;362      /* Reset LSEBYP bit */
;;;363      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
000006  700a              STRB     r2,[r1,#0]
;;;364    
;;;365      /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
;;;366      switch (RCC_LSE)
000008  2801              CMP      r0,#1
00000a  d003              BEQ      |L31.20|
00000c  2804              CMP      r0,#4
;;;367      {
;;;368        case RCC_LSE_ON:
;;;369          /* Set LSEON bit */
;;;370          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
;;;371          break;
;;;372        case RCC_LSE_Bypass:
;;;373          /* Set LSEBYP and LSEON bits */
;;;374          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
00000e  bf0c              ITE      EQ
000010  2005              MOVEQ    r0,#5
;;;375          break;
;;;376        default:
;;;377          break;
;;;378      }
;;;379    }
000012  4770              BXNE     lr
                  |L31.20|
000014  7008              STRB     r0,[r1,#0]            ;374
000016  4770              BX       lr
;;;380    
                          ENDP

                  |L31.24|
                          DCD      0x40023870

                          AREA ||i.RCC_LSICmd||, CODE, READONLY, ALIGN=2

                  RCC_LSICmd PROC
;;;392      */
;;;393    void RCC_LSICmd(FunctionalState NewState)
000000  4901              LDR      r1,|L32.8|
;;;394    {
;;;395      /* Check the parameters */
;;;396      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;397    
;;;398      *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;399    }
000004  4770              BX       lr
;;;400    
                          ENDP

000006  0000              DCW      0x0000
                  |L32.8|
                          DCD      0x42470e80

                          AREA ||i.RCC_MCO1Config||, CODE, READONLY, ALIGN=2

                  RCC_MCO1Config PROC
;;;542      */
;;;543    void RCC_MCO1Config(uint32_t RCC_MCO1Source, uint32_t RCC_MCO1Div)
000000  4a03              LDR      r2,|L33.16|
;;;544    {
;;;545      uint32_t tmpreg = 0;
;;;546      
;;;547      /* Check the parameters */
;;;548      assert_param(IS_RCC_MCO1SOURCE(RCC_MCO1Source));
;;;549      assert_param(IS_RCC_MCO1DIV(RCC_MCO1Div));  
;;;550    
;;;551      tmpreg = RCC->CFGR;
000002  6813              LDR      r3,[r2,#0]
;;;552    
;;;553      /* Clear MCO1[1:0] and MCO1PRE[2:0] bits */
;;;554      tmpreg &= CFGR_MCO1_RESET_MASK;
;;;555    
;;;556      /* Select MCO1 clock source and prescaler */
;;;557      tmpreg |= RCC_MCO1Source | RCC_MCO1Div;
000004  4308              ORRS     r0,r0,r1
000006  f02363ec          BIC      r3,r3,#0x7600000      ;554
00000a  4318              ORRS     r0,r0,r3
;;;558    
;;;559      /* Store the new value */
;;;560      RCC->CFGR = tmpreg;  
00000c  6010              STR      r0,[r2,#0]
;;;561    }
00000e  4770              BX       lr
;;;562    
                          ENDP

                  |L33.16|
                          DCD      0x40023808

                          AREA ||i.RCC_MCO2Config||, CODE, READONLY, ALIGN=2

                  RCC_MCO2Config PROC
;;;580      */
;;;581    void RCC_MCO2Config(uint32_t RCC_MCO2Source, uint32_t RCC_MCO2Div)
000000  4a03              LDR      r2,|L34.16|
;;;582    {
;;;583      uint32_t tmpreg = 0;
;;;584      
;;;585      /* Check the parameters */
;;;586      assert_param(IS_RCC_MCO2SOURCE(RCC_MCO2Source));
;;;587      assert_param(IS_RCC_MCO2DIV(RCC_MCO2Div));
;;;588      
;;;589      tmpreg = RCC->CFGR;
000002  6813              LDR      r3,[r2,#0]
;;;590      
;;;591      /* Clear MCO2 and MCO2PRE[2:0] bits */
;;;592      tmpreg &= CFGR_MCO2_RESET_MASK;
;;;593    
;;;594      /* Select MCO2 clock source and prescaler */
;;;595      tmpreg |= RCC_MCO2Source | RCC_MCO2Div;
000004  4308              ORRS     r0,r0,r1
000006  f0234378          BIC      r3,r3,#0xf8000000     ;592
00000a  4318              ORRS     r0,r0,r3
;;;596    
;;;597      /* Store the new value */
;;;598      RCC->CFGR = tmpreg;  
00000c  6010              STR      r0,[r2,#0]
;;;599    }
00000e  4770              BX       lr
;;;600    
                          ENDP

                  |L34.16|
                          DCD      0x40023808

                          AREA ||i.RCC_PCLK1Config||, CODE, READONLY, ALIGN=2

                  RCC_PCLK1Config PROC
;;;771      */
;;;772    void RCC_PCLK1Config(uint32_t RCC_HCLK)
000000  4903              LDR      r1,|L35.16|
;;;773    {
;;;774      uint32_t tmpreg = 0;
;;;775    
;;;776      /* Check the parameters */
;;;777      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;778    
;;;779      tmpreg = RCC->CFGR;
000002  680a              LDR      r2,[r1,#0]
;;;780    
;;;781      /* Clear PPRE1[2:0] bits */
;;;782      tmpreg &= ~RCC_CFGR_PPRE1;
000004  f42252e0          BIC      r2,r2,#0x1c00
;;;783    
;;;784      /* Set PPRE1[2:0] bits according to RCC_HCLK value */
;;;785      tmpreg |= RCC_HCLK;
000008  4310              ORRS     r0,r0,r2
;;;786    
;;;787      /* Store the new value */
;;;788      RCC->CFGR = tmpreg;
00000a  6008              STR      r0,[r1,#0]
;;;789    }
00000c  4770              BX       lr
;;;790    
                          ENDP

00000e  0000              DCW      0x0000
                  |L35.16|
                          DCD      0x40023808

                          AREA ||i.RCC_PCLK2Config||, CODE, READONLY, ALIGN=2

                  RCC_PCLK2Config PROC
;;;802      */
;;;803    void RCC_PCLK2Config(uint32_t RCC_HCLK)
000000  4903              LDR      r1,|L36.16|
;;;804    {
;;;805      uint32_t tmpreg = 0;
;;;806    
;;;807      /* Check the parameters */
;;;808      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;809    
;;;810      tmpreg = RCC->CFGR;
000002  680a              LDR      r2,[r1,#0]
;;;811    
;;;812      /* Clear PPRE2[2:0] bits */
;;;813      tmpreg &= ~RCC_CFGR_PPRE2;
000004  f4224260          BIC      r2,r2,#0xe000
;;;814    
;;;815      /* Set PPRE2[2:0] bits according to RCC_HCLK value */
;;;816      tmpreg |= RCC_HCLK << 3;
000008  ea4200c0          ORR      r0,r2,r0,LSL #3
;;;817    
;;;818      /* Store the new value */
;;;819      RCC->CFGR = tmpreg;
00000c  6008              STR      r0,[r1,#0]
;;;820    }
00000e  4770              BX       lr
;;;821    
                          ENDP

                  |L36.16|
                          DCD      0x40023808

                          AREA ||i.RCC_PLLCmd||, CODE, READONLY, ALIGN=2

                  RCC_PLLCmd PROC
;;;458      */
;;;459    void RCC_PLLCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L37.8|
;;;460    {
;;;461      /* Check the parameters */
;;;462      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;463      *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
000002  6608              STR      r0,[r1,#0x60]
;;;464    }
000004  4770              BX       lr
;;;465    
                          ENDP

000006  0000              DCW      0x0000
                  |L37.8|
                          DCD      0x42470000

                          AREA ||i.RCC_PLLConfig||, CODE, READONLY, ALIGN=2

                  RCC_PLLConfig PROC
;;;435      */
;;;436    void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t PLLM, uint32_t PLLN, uint32_t PLLP, uint32_t PLLQ)
000000  ea411182          ORR      r1,r1,r2,LSL #6
;;;437    {
;;;438      /* Check the parameters */
;;;439      assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
;;;440      assert_param(IS_RCC_PLLM_VALUE(PLLM));
;;;441      assert_param(IS_RCC_PLLN_VALUE(PLLN));
;;;442      assert_param(IS_RCC_PLLP_VALUE(PLLP));
;;;443      assert_param(IS_RCC_PLLQ_VALUE(PLLQ));
;;;444    
;;;445      RCC->PLLCFGR = PLLM | (PLLN << 6) | (((PLLP >> 1) -1) << 16) | (RCC_PLLSource) |
000004  085a              LSRS     r2,r3,#1
000006  4b06              LDR      r3,|L38.32|
000008  f8ddc000          LDR      r12,[sp,#0]
00000c  eb034202          ADD      r2,r3,r2,LSL #16
000010  4311              ORRS     r1,r1,r2
000012  4308              ORRS     r0,r0,r1
000014  4903              LDR      r1,|L38.36|
000016  ea40600c          ORR      r0,r0,r12,LSL #24
00001a  6008              STR      r0,[r1,#0]
;;;446                     (PLLQ << 24);
;;;447    }
00001c  4770              BX       lr
;;;448    
                          ENDP

00001e  0000              DCW      0x0000
                  |L38.32|
                          DCD      0xffff0000
                  |L38.36|
                          DCD      0x40023804

                          AREA ||i.RCC_PLLI2SCmd||, CODE, READONLY, ALIGN=2

                  RCC_PLLI2SCmd PROC
;;;499      */
;;;500    void RCC_PLLI2SCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L39.8|
;;;501    {
;;;502      /* Check the parameters */
;;;503      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;504      *(__IO uint32_t *) CR_PLLI2SON_BB = (uint32_t)NewState;
000002  6688              STR      r0,[r1,#0x68]
;;;505    }
000004  4770              BX       lr
;;;506    
                          ENDP

000006  0000              DCW      0x0000
                  |L39.8|
                          DCD      0x42470000

                          AREA ||i.RCC_PLLI2SConfig||, CODE, READONLY, ALIGN=2

                  RCC_PLLI2SConfig PROC
;;;484      */
;;;485    void RCC_PLLI2SConfig(uint32_t PLLI2SN, uint32_t PLLI2SR)
000000  0180              LSLS     r0,r0,#6
;;;486    {
;;;487      /* Check the parameters */
;;;488      assert_param(IS_RCC_PLLI2SN_VALUE(PLLI2SN));
;;;489      assert_param(IS_RCC_PLLI2SR_VALUE(PLLI2SR));
;;;490    
;;;491      RCC->PLLI2SCFGR = (PLLI2SN << 6) | (PLLI2SR << 28);
000002  ea407001          ORR      r0,r0,r1,LSL #28
000006  4901              LDR      r1,|L40.12|
000008  6008              STR      r0,[r1,#0]
;;;492    }
00000a  4770              BX       lr
;;;493    
                          ENDP

                  |L40.12|
                          DCD      0x40023884

                          AREA ||i.RCC_RTCCLKCmd||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKCmd PROC
;;;1011     */
;;;1012   void RCC_RTCCLKCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L41.8|
;;;1013   {
;;;1014     /* Check the parameters */
;;;1015     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1016   
;;;1017     *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;1018   }
000004  4770              BX       lr
;;;1019   
                          ENDP

000006  0000              DCW      0x0000
                  |L41.8|
                          DCD      0x42470e3c

                          AREA ||i.RCC_RTCCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKConfig PROC
;;;979      */
;;;980    void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
000000  f44f7140          MOV      r1,#0x300
;;;981    {
;;;982      uint32_t tmpreg = 0;
;;;983    
;;;984      /* Check the parameters */
;;;985      assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
;;;986    
;;;987      if ((RCC_RTCCLKSource & 0x00000300) == 0x00000300)
000004  4381              BICS     r1,r1,r0
000006  d109              BNE      |L42.28|
;;;988      { /* If HSE is selected as RTC clock source, configure HSE division factor for RTC clock */
;;;989        tmpreg = RCC->CFGR;
000008  4908              LDR      r1,|L42.44|
00000a  680a              LDR      r2,[r1,#0]
;;;990    
;;;991        /* Clear RTCPRE[4:0] bits */
;;;992        tmpreg &= ~RCC_CFGR_RTCPRE;
;;;993    
;;;994        /* Configure HSE division factor for RTC clock */
;;;995        tmpreg |= (RCC_RTCCLKSource & 0xFFFFCFF);
00000c  f4207340          BIC      r3,r0,#0x300
000010  f42212f8          BIC      r2,r2,#0x1f0000       ;992
000014  f0234370          BIC      r3,r3,#0xf0000000
000018  431a              ORRS     r2,r2,r3
;;;996    
;;;997        /* Store the new value */
;;;998        RCC->CFGR = tmpreg;
00001a  600a              STR      r2,[r1,#0]
                  |L42.28|
;;;999      }
;;;1000       
;;;1001     /* Select the RTC clock source */
;;;1002     RCC->BDCR |= (RCC_RTCCLKSource & 0x00000FFF);
00001c  4904              LDR      r1,|L42.48|
00001e  680a              LDR      r2,[r1,#0]
000020  f3c0000b          UBFX     r0,r0,#0,#12
000024  4310              ORRS     r0,r0,r2
000026  6008              STR      r0,[r1,#0]
;;;1003   }
000028  4770              BX       lr
;;;1004   
                          ENDP

00002a  0000              DCW      0x0000
                  |L42.44|
                          DCD      0x40023808
                  |L42.48|
                          DCD      0x40023870

                          AREA ||i.RCC_SYSCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_SYSCLKConfig PROC
;;;686      */
;;;687    void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
000000  4903              LDR      r1,|L43.16|
;;;688    {
;;;689      uint32_t tmpreg = 0;
;;;690    
;;;691      /* Check the parameters */
;;;692      assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
;;;693    
;;;694      tmpreg = RCC->CFGR;
000002  680a              LDR      r2,[r1,#0]
;;;695    
;;;696      /* Clear SW[1:0] bits */
;;;697      tmpreg &= ~RCC_CFGR_SW;
000004  f0220203          BIC      r2,r2,#3
;;;698    
;;;699      /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
;;;700      tmpreg |= RCC_SYSCLKSource;
000008  4310              ORRS     r0,r0,r2
;;;701    
;;;702      /* Store the new value */
;;;703      RCC->CFGR = tmpreg;
00000a  6008              STR      r0,[r1,#0]
;;;704    }
00000c  4770              BX       lr
;;;705    
                          ENDP

00000e  0000              DCW      0x0000
                  |L43.16|
                          DCD      0x40023808

                          AREA ||i.RCC_WaitForHSEStartUp||, CODE, READONLY, ALIGN=2

                  RCC_WaitForHSEStartUp PROC
;;;260      */
;;;261    ErrorStatus RCC_WaitForHSEStartUp(void)
000000  b081              SUB      sp,sp,#4
;;;262    {
;;;263      __IO uint32_t startupcounter = 0;
000002  2000              MOVS     r0,#0
000004  490b              LDR      r1,|L44.52|
000006  9000              STR      r0,[sp,#0]
                  |L44.8|
000008  2000              MOVS     r0,#0
00000a  680a              LDR      r2,[r1,#0]
00000c  f4123f00          TST      r2,#0x20000
000010  bf18              IT       NE
000012  2001              MOVNE    r0,#1
;;;264      ErrorStatus status = ERROR;
;;;265      FlagStatus hsestatus = RESET;
;;;266      /* Wait till HSE is ready and if Time out is reached exit */
;;;267      do
;;;268      {
;;;269        hsestatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
;;;270        startupcounter++;
000014  9a00              LDR      r2,[sp,#0]
000016  1c52              ADDS     r2,r2,#1
;;;271      } while((startupcounter != HSE_STARTUP_TIMEOUT) && (hsestatus == RESET));
000018  9200              STR      r2,[sp,#0]
00001a  f5b26fa0          CMP      r2,#0x500
00001e  d001              BEQ      |L44.36|
000020  2800              CMP      r0,#0
000022  d0f1              BEQ      |L44.8|
                  |L44.36|
000024  6808              LDR      r0,[r1,#0]
000026  f4103000          ANDS     r0,r0,#0x20000
;;;272    
;;;273      if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
;;;274      {
;;;275        status = SUCCESS;
00002a  bf18              IT       NE
00002c  2001              MOVNE    r0,#1
;;;276      }
;;;277      else
;;;278      {
;;;279        status = ERROR;
;;;280      }
;;;281      return (status);
;;;282    }
00002e  b001              ADD      sp,sp,#4
000030  4770              BX       lr
;;;283    
                          ENDP

000032  0000              DCW      0x0000
                  |L44.52|
                          DCD      0x40023800

                          AREA ||.data||, DATA, ALIGN=0

                  APBAHBPrescTable
000000  00000000          DCB      0x00,0x00,0x00,0x00
000004  01020304          DCB      0x01,0x02,0x03,0x04
000008  01020304          DCB      0x01,0x02,0x03,0x04
00000c  06070809          DCB      0x06,0x07,0x08,0x09

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32F4xx_StdPeriph_Driver\\src\\stm32f4xx_rcc.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_rcc_c_49e27980____REV16|
#line 114 "..\\..\\..\\M0P0_Library\\STM32F4xx_StdPeriph_Driver\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f4xx_rcc_c_49e27980____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_rcc_c_49e27980____REVSH|
#line 128
|__asm___15_stm32f4xx_rcc_c_49e27980____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
