; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f10x_usart.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f10x_usart.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32F10x_StdPeriph_Lib_V3.3.0\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\M0P0_Library\STM32F10x_StdPeriph_Lib_V3.3.0\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\..\M0P0_Library\STM32F10x_StdPeriph_Lib_V3.3.0\Libraries\CMSIS -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F103RET6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f10x_usart.crf ..\..\..\M0P0_Library\STM32F10x_StdPeriph_Lib_V3.3.0\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_usart.c]
                          THUMB

                          AREA ||i.USART_ClearFlag||, CODE, READONLY, ALIGN=1

                  USART_ClearFlag PROC
;;;918      */
;;;919    void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG)
000000  43c9              MVNS     r1,r1
;;;920    {
;;;921      /* Check the parameters */
;;;922      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;923      assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
;;;924      /* The CTS flag is not available for UART4 and UART5 */
;;;925      if ((USART_FLAG & USART_FLAG_CTS) == USART_FLAG_CTS)
;;;926      {
;;;927        assert_param(IS_USART_123_PERIPH(USARTx));
;;;928      } 
;;;929       
;;;930      USARTx->SR = (uint16_t)~USART_FLAG;
000002  8001              STRH     r1,[r0,#0]
;;;931    }
000004  4770              BX       lr
;;;932    
                          ENDP


                          AREA ||i.USART_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  USART_ClearITPendingBit PROC
;;;1025     */
;;;1026   void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT)
000000  0a09              LSRS     r1,r1,#8
;;;1027   {
;;;1028     uint16_t bitpos = 0x00, itmask = 0x00;
;;;1029     /* Check the parameters */
;;;1030     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1031     assert_param(IS_USART_CLEAR_IT(USART_IT));
;;;1032     /* The CTS interrupt is not available for UART4 and UART5 */
;;;1033     if (USART_IT == USART_IT_CTS)
;;;1034     {
;;;1035       assert_param(IS_USART_123_PERIPH(USARTx));
;;;1036     }   
;;;1037     
;;;1038     bitpos = USART_IT >> 0x08;
;;;1039     itmask = ((uint16_t)0x01 << (uint16_t)bitpos);
000002  2201              MOVS     r2,#1
000004  fa02f101          LSL      r1,r2,r1
;;;1040     USARTx->SR = (uint16_t)~itmask;
000008  43c9              MVNS     r1,r1
00000a  8001              STRH     r1,[r0,#0]
;;;1041   }
00000c  4770              BX       lr
;;;1042   /**
                          ENDP


                          AREA ||i.USART_ClockInit||, CODE, READONLY, ALIGN=1

                  USART_ClockInit PROC
;;;298      */
;;;299    void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
000000  8a02              LDRH     r2,[r0,#0x10]
;;;300    {
;;;301      uint32_t tmpreg = 0x00;
;;;302      /* Check the parameters */
;;;303      assert_param(IS_USART_123_PERIPH(USARTx));
;;;304      assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
;;;305      assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
;;;306      assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
;;;307      assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
;;;308      
;;;309    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;310      tmpreg = USARTx->CR2;
;;;311      /* Clear CLKEN, CPOL, CPHA and LBCL bits */
;;;312      tmpreg &= CR2_CLOCK_CLEAR_Mask;
000002  f24f03ff          MOV      r3,#0xf0ff
000006  401a              ANDS     r2,r2,r3
;;;313      /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
;;;314      /* Set CLKEN bit according to USART_Clock value */
;;;315      /* Set CPOL bit according to USART_CPOL value */
;;;316      /* Set CPHA bit according to USART_CPHA value */
;;;317      /* Set LBCL bit according to USART_LastBit value */
;;;318      tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
000008  880b              LDRH     r3,[r1,#0]
00000a  f8b1c002          LDRH     r12,[r1,#2]
00000e  ea43030c          ORR      r3,r3,r12
000012  f8b1c004          LDRH     r12,[r1,#4]
000016  88c9              LDRH     r1,[r1,#6]
000018  ea4c0101          ORR      r1,r12,r1
00001c  4319              ORRS     r1,r1,r3
00001e  4311              ORRS     r1,r1,r2
;;;319                     USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
;;;320      /* Write to USART CR2 */
;;;321      USARTx->CR2 = (uint16_t)tmpreg;
000020  8201              STRH     r1,[r0,#0x10]
;;;322    }
000022  4770              BX       lr
;;;323    
                          ENDP


                          AREA ||i.USART_ClockStructInit||, CODE, READONLY, ALIGN=1

                  USART_ClockStructInit PROC
;;;329      */
;;;330    void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
000000  2100              MOVS     r1,#0
;;;331    {
;;;332      /* USART_ClockInitStruct members default value */
;;;333      USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
000002  8001              STRH     r1,[r0,#0]
;;;334      USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
000004  8041              STRH     r1,[r0,#2]
;;;335      USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
000006  8081              STRH     r1,[r0,#4]
;;;336      USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
000008  80c1              STRH     r1,[r0,#6]
;;;337    }
00000a  4770              BX       lr
;;;338    
                          ENDP


                          AREA ||i.USART_Cmd||, CODE, READONLY, ALIGN=1

                  USART_Cmd PROC
;;;347      */
;;;348    void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;349    {
;;;350      /* Check the parameters */
;;;351      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;352      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;353      
;;;354      if (NewState != DISABLE)
;;;355      {
;;;356        /* Enable the selected USART by setting the UE bit in the CR1 register */
;;;357        USARTx->CR1 |= CR1_UE_Set;
;;;358      }
;;;359      else
;;;360      {
;;;361        /* Disable the selected USART by clearing the UE bit in the CR1 register */
;;;362        USARTx->CR1 &= CR1_UE_Reset;
000002  8981              LDRH     r1,[r0,#0xc]
000004  bf14              ITE      NE                    ;357
000006  f4415100          ORRNE    r1,r1,#0x2000         ;357
00000a  f4215100          BICEQ    r1,r1,#0x2000
00000e  8181              STRH     r1,[r0,#0xc]          ;357
;;;363      }
;;;364    }
000010  4770              BX       lr
;;;365    
                          ENDP


                          AREA ||i.USART_DMACmd||, CODE, READONLY, ALIGN=1

                  USART_DMACmd PROC
;;;443      */
;;;444    void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;445    {
;;;446      /* Check the parameters */
;;;447      assert_param(IS_USART_1234_PERIPH(USARTx));
;;;448      assert_param(IS_USART_DMAREQ(USART_DMAReq));  
;;;449      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;450      if (NewState != DISABLE)
;;;451      {
;;;452        /* Enable the DMA transfer for selected requests by setting the DMAT and/or
;;;453           DMAR bits in the USART CR3 register */
;;;454        USARTx->CR3 |= USART_DMAReq;
;;;455      }
;;;456      else
;;;457      {
;;;458        /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
;;;459           DMAR bits in the USART CR3 register */
;;;460        USARTx->CR3 &= (uint16_t)~USART_DMAReq;
000002  8a82              LDRH     r2,[r0,#0x14]
000004  bf14              ITE      NE                    ;454
000006  4311              ORRNE    r1,r1,r2              ;454
000008  ea220101          BICEQ    r1,r2,r1
00000c  8281              STRH     r1,[r0,#0x14]         ;454
;;;461      }
;;;462    }
00000e  4770              BX       lr
;;;463    
                          ENDP


                          AREA ||i.USART_DeInit||, CODE, READONLY, ALIGN=1

                  USART_DeInit PROC
;;;127      */
;;;128    void USART_DeInit(USART_TypeDef* USARTx)
000000  b510              PUSH     {r4,lr}
;;;129    {
;;;130      /* Check the parameters */
;;;131      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;132    
;;;133      if (USARTx == USART1)
000002  f1a04180          SUB      r1,r0,#0x40000000
000006  f5b1319c          SUBS     r1,r1,#0x13800
00000a  d017              BEQ      |L7.60|
;;;134      {
;;;135        RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
;;;136        RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
;;;137      }
;;;138      else if (USARTx == USART2)
00000c  f5114174          ADDS     r1,r1,#0xf400
000010  d01f              BEQ      |L7.82|
;;;139      {
;;;140        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
;;;141        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
;;;142      }
;;;143      else if (USARTx == USART3)
000012  f5b16180          SUBS     r1,r1,#0x400
000016  d027              BEQ      |L7.104|
;;;144      {
;;;145        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
;;;146        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
;;;147      }    
;;;148      else if (USARTx == UART4)
000018  f5b16180          SUBS     r1,r1,#0x400
00001c  d02f              BEQ      |L7.126|
;;;149      {
;;;150        RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
;;;151        RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
;;;152      }    
;;;153      else
;;;154      {
;;;155        if (USARTx == UART5)
00001e  f5b16180          SUBS     r1,r1,#0x400
;;;156        { 
;;;157          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
;;;158          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
;;;159        }
;;;160      }
;;;161    }
000022  bf18              IT       NE
000024  bd10              POPNE    {r4,pc}
000026  2101              MOVS     r1,#1                 ;157
000028  0508              LSLS     r0,r1,#20             ;157
00002a  f7fffffe          BL       RCC_APB1PeriphResetCmd
00002e  e8bd4010          POP      {r4,lr}               ;158
000032  2100              MOVS     r1,#0                 ;158
000034  f44f1080          MOV      r0,#0x100000          ;158
000038  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L7.60|
00003c  2101              MOVS     r1,#1                 ;135
00003e  0388              LSLS     r0,r1,#14             ;135
000040  f7fffffe          BL       RCC_APB2PeriphResetCmd
000044  e8bd4010          POP      {r4,lr}               ;136
000048  2100              MOVS     r1,#0                 ;136
00004a  f44f4080          MOV      r0,#0x4000            ;136
00004e  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L7.82|
000052  2101              MOVS     r1,#1                 ;140
000054  0448              LSLS     r0,r1,#17             ;140
000056  f7fffffe          BL       RCC_APB1PeriphResetCmd
00005a  e8bd4010          POP      {r4,lr}               ;141
00005e  2100              MOVS     r1,#0                 ;141
000060  f44f3000          MOV      r0,#0x20000           ;141
000064  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L7.104|
000068  2101              MOVS     r1,#1                 ;145
00006a  0488              LSLS     r0,r1,#18             ;145
00006c  f7fffffe          BL       RCC_APB1PeriphResetCmd
000070  e8bd4010          POP      {r4,lr}               ;146
000074  2100              MOVS     r1,#0                 ;146
000076  f44f2080          MOV      r0,#0x40000           ;146
00007a  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L7.126|
00007e  2101              MOVS     r1,#1                 ;150
000080  04c8              LSLS     r0,r1,#19             ;150
000082  f7fffffe          BL       RCC_APB1PeriphResetCmd
000086  e8bd4010          POP      {r4,lr}               ;151
00008a  2100              MOVS     r1,#0                 ;151
00008c  f44f2000          MOV      r0,#0x80000           ;151
000090  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
;;;162    
                          ENDP


                          AREA ||i.USART_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  USART_GetFlagStatus PROC
;;;869      */
;;;870    FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)
000000  4602              MOV      r2,r0
;;;871    {
;;;872      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;873      /* Check the parameters */
;;;874      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;875      assert_param(IS_USART_FLAG(USART_FLAG));
;;;876      /* The CTS flag is not available for UART4 and UART5 */
;;;877      if (USART_FLAG == USART_FLAG_CTS)
;;;878      {
;;;879        assert_param(IS_USART_123_PERIPH(USARTx));
;;;880      }  
;;;881      
;;;882      if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
000004  8812              LDRH     r2,[r2,#0]
000006  420a              TST      r2,r1
;;;883      {
;;;884        bitstatus = SET;
000008  bf18              IT       NE
00000a  2001              MOVNE    r0,#1
;;;885      }
;;;886      else
;;;887      {
;;;888        bitstatus = RESET;
;;;889      }
;;;890      return bitstatus;
;;;891    }
00000c  4770              BX       lr
;;;892    
                          ENDP


                          AREA ||i.USART_GetITStatus||, CODE, READONLY, ALIGN=1

                  USART_GetITStatus PROC
;;;951      */
;;;952    ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
000000  b410              PUSH     {r4}
;;;953    {
;;;954      uint32_t bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
;;;955      ITStatus bitstatus = RESET;
;;;956      /* Check the parameters */
;;;957      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;958      assert_param(IS_USART_GET_IT(USART_IT));
;;;959      /* The CTS interrupt is not available for UART4 and UART5 */ 
;;;960      if (USART_IT == USART_IT_CTS)
;;;961      {
;;;962        assert_param(IS_USART_123_PERIPH(USARTx));
;;;963      }   
;;;964      
;;;965      /* Get the USART register index */
;;;966      usartreg = (((uint8_t)USART_IT) >> 0x05);
;;;967      /* Get the interrupt position */
;;;968      itmask = USART_IT & IT_Mask;
000002  f001021f          AND      r2,r1,#0x1f
;;;969      itmask = (uint32_t)0x01 << itmask;
000006  2401              MOVS     r4,#1
000008  2300              MOVS     r3,#0                 ;955
00000a  f3c11c42          UBFX     r12,r1,#5,#3          ;966
00000e  fa04f202          LSL      r2,r4,r2
;;;970      
;;;971      if (usartreg == 0x01) /* The IT  is in CR1 register */
000012  f1bc0f01          CMP      r12,#1
;;;972      {
;;;973        itmask &= USARTx->CR1;
000016  bf04              ITT      EQ
000018  f8b0c00c          LDRHEQ   r12,[r0,#0xc]
00001c  ea0c0202          ANDEQ    r2,r12,r2
000020  d008              BEQ      |L9.52|
;;;974      }
;;;975      else if (usartreg == 0x02) /* The IT  is in CR2 register */
000022  f1bc0f02          CMP      r12,#2
;;;976      {
;;;977        itmask &= USARTx->CR2;
000026  bf0c              ITE      EQ
000028  f8b0c010          LDRHEQ   r12,[r0,#0x10]
;;;978      }
;;;979      else /* The IT  is in CR3 register */
;;;980      {
;;;981        itmask &= USARTx->CR3;
00002c  f8b0c014          LDRHNE   r12,[r0,#0x14]
000030  ea0c0202          AND      r2,r12,r2             ;977
                  |L9.52|
;;;982      }
;;;983      
;;;984      bitpos = USART_IT >> 0x08;
000034  0a09              LSRS     r1,r1,#8
;;;985      bitpos = (uint32_t)0x01 << bitpos;
;;;986      bitpos &= USARTx->SR;
000036  8800              LDRH     r0,[r0,#0]
000038  fa04f101          LSL      r1,r4,r1              ;985
00003c  4008              ANDS     r0,r0,r1
;;;987      if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
00003e  2a00              CMP      r2,#0
000040  bf1c              ITT      NE
000042  2800              CMPNE    r0,#0
;;;988      {
;;;989        bitstatus = SET;
000044  2301              MOVNE    r3,#1
;;;990      }
;;;991      else
;;;992      {
;;;993        bitstatus = RESET;
;;;994      }
;;;995      
;;;996      return bitstatus;  
000046  4618              MOV      r0,r3
;;;997    }
000048  bc10              POP      {r4}
00004a  4770              BX       lr
;;;998    
                          ENDP


                          AREA ||i.USART_HalfDuplexCmd||, CODE, READONLY, ALIGN=1

                  USART_HalfDuplexCmd PROC
;;;726      */
;;;727    void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;728    {
;;;729      /* Check the parameters */
;;;730      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;731      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;732      
;;;733      if (NewState != DISABLE)
;;;734      {
;;;735        /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;736        USARTx->CR3 |= CR3_HDSEL_Set;
;;;737      }
;;;738      else
;;;739      {
;;;740        /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
;;;741        USARTx->CR3 &= CR3_HDSEL_Reset;
000002  8a81              LDRH     r1,[r0,#0x14]
000004  bf14              ITE      NE                    ;736
000006  f0410108          ORRNE    r1,r1,#8              ;736
00000a  f0210108          BICEQ    r1,r1,#8
00000e  8281              STRH     r1,[r0,#0x14]         ;736
;;;742      }
;;;743    }
000010  4770              BX       lr
;;;744    
                          ENDP


                          AREA ||i.USART_ITConfig||, CODE, READONLY, ALIGN=1

                  USART_ITConfig PROC
;;;384      */
;;;385    void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
000000  f3c11342          UBFX     r3,r1,#5,#3
;;;386    {
;;;387      uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
;;;388      uint32_t usartxbase = 0x00;
;;;389      /* Check the parameters */
;;;390      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;391      assert_param(IS_USART_CONFIG_IT(USART_IT));
;;;392      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;393      /* The CTS interrupt is not available for UART4 and UART5 */
;;;394      if (USART_IT == USART_IT_CTS)
;;;395      {
;;;396        assert_param(IS_USART_123_PERIPH(USARTx));
;;;397      }   
;;;398      
;;;399      usartxbase = (uint32_t)USARTx;
;;;400    
;;;401      /* Get the USART register index */
;;;402      usartreg = (((uint8_t)USART_IT) >> 0x05);
;;;403    
;;;404      /* Get the interrupt position */
;;;405      itpos = USART_IT & IT_Mask;
000004  f001011f          AND      r1,r1,#0x1f
;;;406      itmask = (((uint32_t)0x01) << itpos);
000008  f04f0c01          MOV      r12,#1
00000c  fa0cf101          LSL      r1,r12,r1
;;;407        
;;;408      if (usartreg == 0x01) /* The IT is in CR1 register */
000010  2b01              CMP      r3,#1
000012  bf08              IT       EQ
000014  300c              ADDEQ    r0,r0,#0xc
000016  d003              BEQ      |L11.32|
;;;409      {
;;;410        usartxbase += 0x0C;
;;;411      }
;;;412      else if (usartreg == 0x02) /* The IT is in CR2 register */
000018  2b02              CMP      r3,#2
00001a  bf0c              ITE      EQ
00001c  3010              ADDEQ    r0,r0,#0x10
00001e  3014              ADDNE    r0,r0,#0x14
                  |L11.32|
;;;413      {
;;;414        usartxbase += 0x10;
;;;415      }
;;;416      else /* The IT is in CR3 register */
;;;417      {
;;;418        usartxbase += 0x14; 
;;;419      }
;;;420      if (NewState != DISABLE)
000020  2a00              CMP      r2,#0
;;;421      {
;;;422        *(__IO uint32_t*)usartxbase  |= itmask;
;;;423      }
;;;424      else
;;;425      {
;;;426        *(__IO uint32_t*)usartxbase &= ~itmask;
000022  6802              LDR      r2,[r0,#0]
000024  bf14              ITE      NE                    ;422
000026  4311              ORRNE    r1,r1,r2              ;422
000028  ea220101          BICEQ    r1,r2,r1
00002c  6001              STR      r1,[r0,#0]            ;422
;;;427      }
;;;428    }
00002e  4770              BX       lr
;;;429    
                          ENDP


                          AREA ||i.USART_Init||, CODE, READONLY, ALIGN=2

                  USART_Init PROC
;;;172      */
;;;173    void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;174    {
000002  4604              MOV      r4,r0
;;;175      uint32_t tmpreg = 0x00, apbclock = 0x00;
;;;176      uint32_t integerdivider = 0x00;
;;;177      uint32_t fractionaldivider = 0x00;
;;;178      uint32_t usartxbase = 0;
;;;179      RCC_ClocksTypeDef RCC_ClocksStatus;
;;;180      /* Check the parameters */
;;;181      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;182      assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
;;;183      assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
;;;184      assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
;;;185      assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
;;;186      assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
;;;187      assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
;;;188      /* The hardware flow control is available only for USART1, USART2 and USART3 */
;;;189      if (USART_InitStruct->USART_HardwareFlowControl != USART_HardwareFlowControl_None)
;;;190      {
;;;191        assert_param(IS_USART_123_PERIPH(USARTx));
;;;192      }
;;;193    
;;;194      usartxbase = (uint32_t)USARTx;
;;;195    
;;;196    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;197      tmpreg = USARTx->CR2;
000004  8a00              LDRH     r0,[r0,#0x10]
000006  b085              SUB      sp,sp,#0x14           ;174
000008  460d              MOV      r5,r1                 ;174
;;;198      /* Clear STOP[13:12] bits */
;;;199      tmpreg &= CR2_STOP_CLEAR_Mask;
00000a  f64c71ff          MOV      r1,#0xcfff
00000e  4008              ANDS     r0,r0,r1
;;;200      /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
;;;201      /* Set STOP[13:12] bits according to USART_StopBits value */
;;;202      tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
000010  88e9              LDRH     r1,[r5,#6]
000012  4308              ORRS     r0,r0,r1
;;;203      
;;;204      /* Write to USART CR2 */
;;;205      USARTx->CR2 = (uint16_t)tmpreg;
000014  8220              STRH     r0,[r4,#0x10]
;;;206    
;;;207    /*---------------------------- USART CR1 Configuration -----------------------*/
;;;208      tmpreg = USARTx->CR1;
000016  89a0              LDRH     r0,[r4,#0xc]
;;;209      /* Clear M, PCE, PS, TE and RE bits */
;;;210      tmpreg &= CR1_CLEAR_Mask;
000018  f64e11f3          MOV      r1,#0xe9f3
00001c  4008              ANDS     r0,r0,r1
;;;211      /* Configure the USART Word Length, Parity and mode ----------------------- */
;;;212      /* Set the M bits according to USART_WordLength value */
;;;213      /* Set PCE and PS bits according to USART_Parity value */
;;;214      /* Set TE and RE bits according to USART_Mode value */
;;;215      tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
00001e  88a9              LDRH     r1,[r5,#4]
000020  892a              LDRH     r2,[r5,#8]
000022  4311              ORRS     r1,r1,r2
000024  896a              LDRH     r2,[r5,#0xa]
000026  4310              ORRS     r0,r0,r2
000028  4308              ORRS     r0,r0,r1
;;;216                USART_InitStruct->USART_Mode;
;;;217      /* Write to USART CR1 */
;;;218      USARTx->CR1 = (uint16_t)tmpreg;
00002a  81a0              STRH     r0,[r4,#0xc]
;;;219    
;;;220    /*---------------------------- USART CR3 Configuration -----------------------*/  
;;;221      tmpreg = USARTx->CR3;
00002c  8aa0              LDRH     r0,[r4,#0x14]
;;;222      /* Clear CTSE and RTSE bits */
;;;223      tmpreg &= CR3_CLEAR_Mask;
00002e  f64f41ff          MOV      r1,#0xfcff
000032  4008              ANDS     r0,r0,r1
;;;224      /* Configure the USART HFC -------------------------------------------------*/
;;;225      /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
;;;226      tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
000034  89a9              LDRH     r1,[r5,#0xc]
000036  4308              ORRS     r0,r0,r1
;;;227      /* Write to USART CR3 */
;;;228      USARTx->CR3 = (uint16_t)tmpreg;
000038  82a0              STRH     r0,[r4,#0x14]
;;;229    
;;;230    /*---------------------------- USART BRR Configuration -----------------------*/
;;;231      /* Configure the USART Baud Rate -------------------------------------------*/
;;;232      RCC_GetClocksFreq(&RCC_ClocksStatus);
00003a  4668              MOV      r0,sp
00003c  f7fffffe          BL       RCC_GetClocksFreq
;;;233      if (usartxbase == USART1_BASE)
000040  f1a44080          SUB      r0,r4,#0x40000000
000044  f5b0309c          SUBS     r0,r0,#0x13800
;;;234      {
;;;235        apbclock = RCC_ClocksStatus.PCLK2_Frequency;
000048  bf0c              ITE      EQ
00004a  9803              LDREQ    r0,[sp,#0xc]
;;;236      }
;;;237      else
;;;238      {
;;;239        apbclock = RCC_ClocksStatus.PCLK1_Frequency;
00004c  9802              LDRNE    r0,[sp,#8]
;;;240      }
;;;241      
;;;242      /* Determine the integer part */
;;;243      if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
00004e  89a1              LDRH     r1,[r4,#0xc]
000050  f4114f00          TST      r1,#0x8000
;;;244      {
;;;245        /* Integer part computing in case Oversampling mode is 8 Samples */
;;;246        integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
;;;247      }
;;;248      else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
;;;249      {
;;;250        /* Integer part computing in case Oversampling mode is 16 Samples */
;;;251        integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
000054  eb0001c0          ADD      r1,r0,r0,LSL #3
000058  eb011000          ADD      r0,r1,r0,LSL #4
00005c  6829              LDR      r1,[r5,#0]
00005e  bf14              ITE      NE                    ;246
000060  0049              LSLNE    r1,r1,#1              ;246
000062  0089              LSLEQ    r1,r1,#2
000064  fbb0f0f1          UDIV     r0,r0,r1
;;;252      }
;;;253      tmpreg = (integerdivider / 100) << 4;
000068  4a11              LDR      r2,|L12.176|
;;;254    
;;;255      /* Determine the fractional part */
;;;256      fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
00006a  f06f0c18          MVN      r12,#0x18
00006e  fba23100          UMULL    r3,r1,r2,r0           ;253
000072  0949              LSRS     r1,r1,#5              ;253
000074  0109              LSLS     r1,r1,#4              ;253
000076  090b              LSRS     r3,r1,#4
000078  fb03f30c          MUL      r3,r3,r12
00007c  eb000083          ADD      r0,r0,r3,LSL #2
;;;257    
;;;258      /* Implement the fractional part in the register */
;;;259      if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
000080  89a3              LDRH     r3,[r4,#0xc]
000082  f4134f00          TST      r3,#0x8000
;;;260      {
;;;261        tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
000086  f04f0332          MOV      r3,#0x32
00008a  bf14              ITE      NE
00008c  eb0300c0          ADDNE    r0,r3,r0,LSL #3
;;;262      }
;;;263      else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
;;;264      {
;;;265        tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
000090  eb031000          ADDEQ    r0,r3,r0,LSL #4
000094  fba22000          UMULL    r2,r0,r2,r0
000098  ea4f1050          LSR      r0,r0,#5
00009c  bf14              ITE      NE                    ;261
00009e  f0000007          ANDNE    r0,r0,#7              ;261
0000a2  f000000f          ANDEQ    r0,r0,#0xf
0000a6  4308              ORRS     r0,r0,r1
;;;266      }
;;;267      
;;;268      /* Write to USART BRR */
;;;269      USARTx->BRR = (uint16_t)tmpreg;
0000a8  8120              STRH     r0,[r4,#8]
;;;270    }
0000aa  b005              ADD      sp,sp,#0x14
0000ac  bd30              POP      {r4,r5,pc}
;;;271    
                          ENDP

0000ae  0000              DCW      0x0000
                  |L12.176|
                          DCD      0x51eb851f

                          AREA ||i.USART_IrDACmd||, CODE, READONLY, ALIGN=1

                  USART_IrDACmd PROC
;;;832      */
;;;833    void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;834    {
;;;835      /* Check the parameters */
;;;836      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;837      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;838        
;;;839      if (NewState != DISABLE)
;;;840      {
;;;841        /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
;;;842        USARTx->CR3 |= CR3_IREN_Set;
;;;843      }
;;;844      else
;;;845      {
;;;846        /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
;;;847        USARTx->CR3 &= CR3_IREN_Reset;
000002  8a81              LDRH     r1,[r0,#0x14]
000004  bf14              ITE      NE                    ;842
000006  f0410102          ORRNE    r1,r1,#2              ;842
00000a  f0210102          BICEQ    r1,r1,#2
00000e  8281              STRH     r1,[r0,#0x14]         ;842
;;;848      }
;;;849    }
000010  4770              BX       lr
;;;850    
                          ENDP


                          AREA ||i.USART_IrDAConfig||, CODE, READONLY, ALIGN=1

                  USART_IrDAConfig PROC
;;;813      */
;;;814    void USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode)
000000  8a82              LDRH     r2,[r0,#0x14]
;;;815    {
;;;816      /* Check the parameters */
;;;817      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;818      assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
;;;819        
;;;820      USARTx->CR3 &= CR3_IRLP_Mask;
000002  f0220204          BIC      r2,r2,#4
000006  8282              STRH     r2,[r0,#0x14]
;;;821      USARTx->CR3 |= USART_IrDAMode;
000008  8a82              LDRH     r2,[r0,#0x14]
00000a  4311              ORRS     r1,r1,r2
00000c  8281              STRH     r1,[r0,#0x14]
;;;822    }
00000e  4770              BX       lr
;;;823    
                          ENDP


                          AREA ||i.USART_LINBreakDetectLengthConfig||, CODE, READONLY, ALIGN=1

                  USART_LINBreakDetectLengthConfig PROC
;;;542      */
;;;543    void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength)
000000  8a02              LDRH     r2,[r0,#0x10]
;;;544    {
;;;545      /* Check the parameters */
;;;546      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;547      assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
;;;548      
;;;549      USARTx->CR2 &= CR2_LBDL_Mask;
000002  f0220220          BIC      r2,r2,#0x20
000006  8202              STRH     r2,[r0,#0x10]
;;;550      USARTx->CR2 |= USART_LINBreakDetectLength;  
000008  8a02              LDRH     r2,[r0,#0x10]
00000a  4311              ORRS     r1,r1,r2
00000c  8201              STRH     r1,[r0,#0x10]
;;;551    }
00000e  4770              BX       lr
;;;552    
                          ENDP


                          AREA ||i.USART_LINCmd||, CODE, READONLY, ALIGN=1

                  USART_LINCmd PROC
;;;561      */
;;;562    void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;563    {
;;;564      /* Check the parameters */
;;;565      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;566      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;567      
;;;568      if (NewState != DISABLE)
;;;569      {
;;;570        /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;571        USARTx->CR2 |= CR2_LINEN_Set;
;;;572      }
;;;573      else
;;;574      {
;;;575        /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
;;;576        USARTx->CR2 &= CR2_LINEN_Reset;
000002  8a01              LDRH     r1,[r0,#0x10]
000004  bf14              ITE      NE                    ;571
000006  f4414180          ORRNE    r1,r1,#0x4000         ;571
00000a  f4214180          BICEQ    r1,r1,#0x4000
00000e  8201              STRH     r1,[r0,#0x10]         ;571
;;;577      }
;;;578    }
000010  4770              BX       lr
;;;579    
                          ENDP


                          AREA ||i.USART_OneBitMethodCmd||, CODE, READONLY, ALIGN=1

                  USART_OneBitMethodCmd PROC
;;;784      */
;;;785    void USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;786    {
;;;787      /* Check the parameters */
;;;788      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;789      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;790      
;;;791      if (NewState != DISABLE)
;;;792      {
;;;793        /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
;;;794        USARTx->CR3 |= CR3_ONEBITE_Set;
;;;795      }
;;;796      else
;;;797      {
;;;798        /* Disable tthe one bit method by clearing the ONEBITE bit in the CR3 register */
;;;799        USARTx->CR3 &= CR3_ONEBITE_Reset;
000002  8a81              LDRH     r1,[r0,#0x14]
000004  bf14              ITE      NE                    ;794
000006  f4416100          ORRNE    r1,r1,#0x800          ;794
00000a  f4216100          BICEQ    r1,r1,#0x800
00000e  8281              STRH     r1,[r0,#0x14]         ;794
;;;800      }
;;;801    }
000010  4770              BX       lr
;;;802    
                          ENDP


                          AREA ||i.USART_OverSampling8Cmd||, CODE, READONLY, ALIGN=1

                  USART_OverSampling8Cmd PROC
;;;757      */
;;;758    void USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;759    {
;;;760      /* Check the parameters */
;;;761      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;762      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;763      
;;;764      if (NewState != DISABLE)
;;;765      {
;;;766        /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
;;;767        USARTx->CR1 |= CR1_OVER8_Set;
;;;768      }
;;;769      else
;;;770      {
;;;771        /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
;;;772        USARTx->CR1 &= CR1_OVER8_Reset;
000002  8981              LDRH     r1,[r0,#0xc]
000004  bf14              ITE      NE                    ;767
000006  f4414100          ORRNE    r1,r1,#0x8000         ;767
00000a  f3c1010e          UBFXEQ   r1,r1,#0,#15
00000e  8181              STRH     r1,[r0,#0xc]          ;767
;;;773      }
;;;774    }
000010  4770              BX       lr
;;;775    
                          ENDP


                          AREA ||i.USART_ReceiveData||, CODE, READONLY, ALIGN=1

                  USART_ReceiveData PROC
;;;604      */
;;;605    uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
000000  8880              LDRH     r0,[r0,#4]
;;;606    {
;;;607      /* Check the parameters */
;;;608      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;609      
;;;610      /* Receive Data */
;;;611      return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
000002  f3c00008          UBFX     r0,r0,#0,#9
;;;612    }
000006  4770              BX       lr
;;;613    
                          ENDP


                          AREA ||i.USART_ReceiverWakeUpCmd||, CODE, READONLY, ALIGN=1

                  USART_ReceiverWakeUpCmd PROC
;;;513      */
;;;514    void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;515    {
;;;516      /* Check the parameters */
;;;517      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;518      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;519      
;;;520      if (NewState != DISABLE)
;;;521      {
;;;522        /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
;;;523        USARTx->CR1 |= CR1_RWU_Set;
;;;524      }
;;;525      else
;;;526      {
;;;527        /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
;;;528        USARTx->CR1 &= CR1_RWU_Reset;
000002  8981              LDRH     r1,[r0,#0xc]
000004  bf14              ITE      NE                    ;523
000006  f0410102          ORRNE    r1,r1,#2              ;523
00000a  f0210102          BICEQ    r1,r1,#2
00000e  8181              STRH     r1,[r0,#0xc]          ;523
;;;529      }
;;;530    }
000010  4770              BX       lr
;;;531    
                          ENDP


                          AREA ||i.USART_SendBreak||, CODE, READONLY, ALIGN=1

                  USART_SendBreak PROC
;;;620      */
;;;621    void USART_SendBreak(USART_TypeDef* USARTx)
000000  8981              LDRH     r1,[r0,#0xc]
;;;622    {
;;;623      /* Check the parameters */
;;;624      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;625      
;;;626      /* Send break characters */
;;;627      USARTx->CR1 |= CR1_SBK_Set;
000002  f0410101          ORR      r1,r1,#1
000006  8181              STRH     r1,[r0,#0xc]
;;;628    }
000008  4770              BX       lr
;;;629    
                          ENDP


                          AREA ||i.USART_SendData||, CODE, READONLY, ALIGN=1

                  USART_SendData PROC
;;;587      */
;;;588    void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
000000  f3c10108          UBFX     r1,r1,#0,#9
;;;589    {
;;;590      /* Check the parameters */
;;;591      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;592      assert_param(IS_USART_DATA(Data)); 
;;;593        
;;;594      /* Transmit Data */
;;;595      USARTx->DR = (Data & (uint16_t)0x01FF);
000004  8081              STRH     r1,[r0,#4]
;;;596    }
000006  4770              BX       lr
;;;597    
                          ENDP


                          AREA ||i.USART_SetAddress||, CODE, READONLY, ALIGN=1

                  USART_SetAddress PROC
;;;471      */
;;;472    void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
000000  8a02              LDRH     r2,[r0,#0x10]
;;;473    {
;;;474      /* Check the parameters */
;;;475      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;476      assert_param(IS_USART_ADDRESS(USART_Address)); 
;;;477        
;;;478      /* Clear the USART address */
;;;479      USARTx->CR2 &= CR2_Address_Mask;
000002  f022020f          BIC      r2,r2,#0xf
000006  8202              STRH     r2,[r0,#0x10]
;;;480      /* Set the USART address node */
;;;481      USARTx->CR2 |= USART_Address;
000008  8a02              LDRH     r2,[r0,#0x10]
00000a  4311              ORRS     r1,r1,r2
00000c  8201              STRH     r1,[r0,#0x10]
;;;482    }
00000e  4770              BX       lr
;;;483    
                          ENDP


                          AREA ||i.USART_SetGuardTime||, CODE, READONLY, ALIGN=1

                  USART_SetGuardTime PROC
;;;636      */
;;;637    void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;638    {    
;;;639      /* Check the parameters */
;;;640      assert_param(IS_USART_123_PERIPH(USARTx));
;;;641      
;;;642      /* Clear the USART Guard time */
;;;643      USARTx->GTPR &= GTPR_LSB_Mask;
000002  b2d2              UXTB     r2,r2
000004  8302              STRH     r2,[r0,#0x18]
;;;644      /* Set the USART guard time */
;;;645      USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
000006  8b02              LDRH     r2,[r0,#0x18]
000008  ea422101          ORR      r1,r2,r1,LSL #8
00000c  8301              STRH     r1,[r0,#0x18]
;;;646    }
00000e  4770              BX       lr
;;;647    
                          ENDP


                          AREA ||i.USART_SetPrescaler||, CODE, READONLY, ALIGN=1

                  USART_SetPrescaler PROC
;;;656      */
;;;657    void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;658    { 
;;;659      /* Check the parameters */
;;;660      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;661      
;;;662      /* Clear the USART prescaler */
;;;663      USARTx->GTPR &= GTPR_MSB_Mask;
000002  f402427f          AND      r2,r2,#0xff00
000006  8302              STRH     r2,[r0,#0x18]
;;;664      /* Set the USART prescaler */
;;;665      USARTx->GTPR |= USART_Prescaler;
000008  8b02              LDRH     r2,[r0,#0x18]
00000a  4311              ORRS     r1,r1,r2
00000c  8301              STRH     r1,[r0,#0x18]
;;;666    }
00000e  4770              BX       lr
;;;667    
                          ENDP


                          AREA ||i.USART_SmartCardCmd||, CODE, READONLY, ALIGN=1

                  USART_SmartCardCmd PROC
;;;675      */
;;;676    void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;677    {
;;;678      /* Check the parameters */
;;;679      assert_param(IS_USART_123_PERIPH(USARTx));
;;;680      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;681      if (NewState != DISABLE)
;;;682      {
;;;683        /* Enable the SC mode by setting the SCEN bit in the CR3 register */
;;;684        USARTx->CR3 |= CR3_SCEN_Set;
;;;685      }
;;;686      else
;;;687      {
;;;688        /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
;;;689        USARTx->CR3 &= CR3_SCEN_Reset;
000002  8a81              LDRH     r1,[r0,#0x14]
000004  bf14              ITE      NE                    ;684
000006  f0410120          ORRNE    r1,r1,#0x20           ;684
00000a  f0210120          BICEQ    r1,r1,#0x20
00000e  8281              STRH     r1,[r0,#0x14]         ;684
;;;690      }
;;;691    }
000010  4770              BX       lr
;;;692    
                          ENDP


                          AREA ||i.USART_SmartCardNACKCmd||, CODE, READONLY, ALIGN=1

                  USART_SmartCardNACKCmd PROC
;;;700      */
;;;701    void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;702    {
;;;703      /* Check the parameters */
;;;704      assert_param(IS_USART_123_PERIPH(USARTx));  
;;;705      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;706      if (NewState != DISABLE)
;;;707      {
;;;708        /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
;;;709        USARTx->CR3 |= CR3_NACK_Set;
;;;710      }
;;;711      else
;;;712      {
;;;713        /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
;;;714        USARTx->CR3 &= CR3_NACK_Reset;
000002  8a81              LDRH     r1,[r0,#0x14]
000004  bf14              ITE      NE                    ;709
000006  f0410110          ORRNE    r1,r1,#0x10           ;709
00000a  f0210110          BICEQ    r1,r1,#0x10
00000e  8281              STRH     r1,[r0,#0x14]         ;709
;;;715      }
;;;716    }
000010  4770              BX       lr
;;;717    
                          ENDP


                          AREA ||i.USART_StructInit||, CODE, READONLY, ALIGN=1

                  USART_StructInit PROC
;;;277      */
;;;278    void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
000000  f44f5116          MOV      r1,#0x2580
;;;279    {
;;;280      /* USART_InitStruct members default value */
;;;281      USART_InitStruct->USART_BaudRate = 9600;
;;;282      USART_InitStruct->USART_WordLength = USART_WordLength_8b;
000004  6001              STR      r1,[r0,#0]
000006  2100              MOVS     r1,#0
000008  8081              STRH     r1,[r0,#4]
;;;283      USART_InitStruct->USART_StopBits = USART_StopBits_1;
00000a  80c1              STRH     r1,[r0,#6]
;;;284      USART_InitStruct->USART_Parity = USART_Parity_No ;
00000c  8101              STRH     r1,[r0,#8]
;;;285      USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00000e  220c              MOVS     r2,#0xc
000010  8142              STRH     r2,[r0,#0xa]
;;;286      USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
000012  8181              STRH     r1,[r0,#0xc]
;;;287    }
000014  4770              BX       lr
;;;288    
                          ENDP


                          AREA ||i.USART_WakeUpConfig||, CODE, READONLY, ALIGN=1

                  USART_WakeUpConfig PROC
;;;494      */
;;;495    void USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp)
000000  8982              LDRH     r2,[r0,#0xc]
;;;496    {
;;;497      /* Check the parameters */
;;;498      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;499      assert_param(IS_USART_WAKEUP(USART_WakeUp));
;;;500      
;;;501      USARTx->CR1 &= CR1_WAKE_Mask;
000002  f4226200          BIC      r2,r2,#0x800
000006  8182              STRH     r2,[r0,#0xc]
;;;502      USARTx->CR1 |= USART_WakeUp;
000008  8982              LDRH     r2,[r0,#0xc]
00000a  4311              ORRS     r1,r1,r2
00000c  8181              STRH     r1,[r0,#0xc]
;;;503    }
00000e  4770              BX       lr
;;;504    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32F10x_StdPeriph_Lib_V3.3.0\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_usart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_stm32f10x_usart_c_9565154b____REV16|
#line 464 "D:\\Program_Files_x86\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.1.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___17_stm32f10x_usart_c_9565154b____REV16| PROC
#line 465

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_stm32f10x_usart_c_9565154b____REVSH|
#line 479
|__asm___17_stm32f10x_usart_c_9565154b____REVSH| PROC
#line 480

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___17_stm32f10x_usart_c_9565154b____RRX|
#line 666
|__asm___17_stm32f10x_usart_c_9565154b____RRX| PROC
#line 667

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
