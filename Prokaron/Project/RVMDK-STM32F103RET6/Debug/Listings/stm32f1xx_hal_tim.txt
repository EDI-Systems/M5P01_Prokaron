; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f1xx_hal_tim.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f1xx_hal_tim.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F1_V1.6.0\Drivers\STM32F1xx_HAL_Driver\Inc -I..\..\..\M0P0_Library\STM32Cube_FW_F1_V1.6.0\Drivers\CMSIS\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F1_V1.6.0\Drivers\CMSIS\Device\ST\STM32F1xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F1_V1.6.0\Drivers\STM32F1xx_HAL_Driver\Inc\Conf -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F103RET6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F10X_HD -DUSE_HAL_DRIVER -DSTM32F103xE -W --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f1xx_hal_tim.crf ..\..\..\M0P0_Library\STM32Cube_FW_F1_V1.6.0\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_tim.c]
                          THUMB

                          AREA ||i.HAL_TIM_Base_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_DeInit PROC
;;;245      */
;;;246    HAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;247    {
000002  4604              MOV      r4,r0
;;;248      /* Check the parameters */
;;;249      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;250    
;;;251      htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  6420              STR      r0,[r4,#0x40]
;;;252    
;;;253      /* Disable the TIM Peripheral Clock */
;;;254      __HAL_TIM_DISABLE(htim);
000008  6820              LDR      r0,[r4,#0]
00000a  6a01              LDR      r1,[r0,#0x20]
00000c  f2411211          MOV      r2,#0x1111
000010  4211              TST      r1,r2
000012  d107              BNE      |L1.36|
000014  6a01              LDR      r1,[r0,#0x20]
000016  1092              ASRS     r2,r2,#2
000018  4211              TST      r1,r2
00001a  d103              BNE      |L1.36|
00001c  6801              LDR      r1,[r0,#0]
00001e  f0210101          BIC      r1,r1,#1
000022  6001              STR      r1,[r0,#0]
                  |L1.36|
;;;255    
;;;256      /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;257      HAL_TIM_Base_MspDeInit(htim);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       HAL_TIM_Base_MspDeInit
;;;258    
;;;259      /* Change TIM state */
;;;260      htim->State = HAL_TIM_STATE_RESET;
00002a  2000              MOVS     r0,#0
00002c  6420              STR      r0,[r4,#0x40]
;;;261    
;;;262      /* Release Lock */
;;;263      __HAL_UNLOCK(htim);
00002e  63e0              STR      r0,[r4,#0x3c]
;;;264    
;;;265      return HAL_OK;
;;;266    }
000030  bd10              POP      {r4,pc}
;;;267    
                          ENDP


                          AREA ||i.HAL_TIM_Base_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_GetState PROC
;;;4388     */
;;;4389   HAL_TIM_StateTypeDef HAL_TIM_Base_GetState(TIM_HandleTypeDef *htim)
000000  6c00              LDR      r0,[r0,#0x40]
;;;4390   {
;;;4391     return htim->State;
;;;4392   }
000002  4770              BX       lr
;;;4393   
                          ENDP


                          AREA ||i.HAL_TIM_Base_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Init PROC
;;;205      */
;;;206    HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
000000  2800              CMP      r0,#0
;;;207    {
;;;208      /* Check the TIM handle allocation */
;;;209      if(htim == NULL)
;;;210      {
;;;211        return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;212      }
;;;213    
;;;214      /* Check the parameters */
;;;215      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;216      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;217      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;218      assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;219    
;;;220      if(htim->State == HAL_TIM_STATE_RESET)
;;;221      {
;;;222        /* Allocate lock resource and initialize it */
;;;223        htim->Lock = HAL_UNLOCKED;
;;;224        
;;;225        /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;226        HAL_TIM_Base_MspInit(htim);
;;;227      }
;;;228    
;;;229      /* Set the TIM state */
;;;230      htim->State= HAL_TIM_STATE_BUSY;
;;;231    
;;;232      /* Set the Time Base configuration */
;;;233      TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;234    
;;;235      /* Initialize the TIM state*/
;;;236      htim->State= HAL_TIM_STATE_READY;
;;;237    
;;;238      return HAL_OK;
;;;239    }
000006  4770              BXEQ     lr
000008  b510              PUSH     {r4,lr}               ;207
00000a  4604              MOV      r4,r0                 ;207
00000c  6c00              LDR      r0,[r0,#0x40]         ;220
00000e  b920              CBNZ     r0,|L3.26|
000010  2000              MOVS     r0,#0                 ;223
000012  63e0              STR      r0,[r4,#0x3c]         ;226
000014  4620              MOV      r0,r4                 ;226
000016  f7fffffe          BL       HAL_TIM_Base_MspInit
                  |L3.26|
00001a  2002              MOVS     r0,#2                 ;230
00001c  6420              STR      r0,[r4,#0x40]         ;230
00001e  1d21              ADDS     r1,r4,#4              ;233
000020  6820              LDR      r0,[r4,#0]            ;233
000022  f7fffffe          BL       TIM_Base_SetConfig
000026  2001              MOVS     r0,#1                 ;236
000028  6420              STR      r0,[r4,#0x40]         ;236
00002a  2000              MOVS     r0,#0                 ;238
00002c  bd10              POP      {r4,pc}
;;;240    
                          ENDP


                          AREA ||i.HAL_TIM_Base_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_MspDeInit PROC
;;;286      */
;;;287    __weak void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;288    {
;;;289      /* Prevent unused argument(s) compilation warning */
;;;290      UNUSED(htim);
;;;291      /* NOTE : This function Should not be modified, when the callback is needed,
;;;292                the HAL_TIM_Base_MspDeInit could be implemented in the user file
;;;293       */
;;;294    }
;;;295    
                          ENDP


                          AREA ||i.HAL_TIM_Base_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_MspInit PROC
;;;272      */
;;;273    __weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;274    {
;;;275      /* Prevent unused argument(s) compilation warning */
;;;276      UNUSED(htim);
;;;277      /* NOTE : This function Should not be modified, when the callback is needed,
;;;278                the HAL_TIM_Base_MspInit could be implemented in the user file
;;;279       */
;;;280    }
;;;281    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Start PROC
;;;301    */
;;;302    HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
000000  2102              MOVS     r1,#2
;;;303    {
;;;304      /* Check the parameters */
;;;305      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;306    
;;;307      /* Set the TIM state */
;;;308      htim->State= HAL_TIM_STATE_BUSY;
000002  6401              STR      r1,[r0,#0x40]
;;;309    
;;;310      /* Enable the Peripheral */
;;;311      __HAL_TIM_ENABLE(htim);
000004  6801              LDR      r1,[r0,#0]
000006  680a              LDR      r2,[r1,#0]
000008  f0420201          ORR      r2,r2,#1
00000c  600a              STR      r2,[r1,#0]
;;;312    
;;;313      /* Change the TIM state*/
;;;314      htim->State= HAL_TIM_STATE_READY;
00000e  2101              MOVS     r1,#1
000010  6401              STR      r1,[r0,#0x40]
;;;315    
;;;316      /* Return function status */
;;;317      return HAL_OK;
000012  2000              MOVS     r0,#0
;;;318    }
000014  4770              BX       lr
;;;319    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Base_Start_DMA PROC
;;;388    */
;;;389    HAL_StatusTypeDef HAL_TIM_Base_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
000000  b510              PUSH     {r4,lr}
;;;390    {
000002  4604              MOV      r4,r0
;;;391      /* Check the parameters */
;;;392      assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
;;;393    
;;;394      if((htim->State == HAL_TIM_STATE_BUSY))
000004  6c00              LDR      r0,[r0,#0x40]
000006  2802              CMP      r0,#2
;;;395      {
;;;396         return HAL_BUSY;
;;;397      }
;;;398      else if((htim->State == HAL_TIM_STATE_READY))
;;;399      {
;;;400        if((pData == 0U) && (Length > 0U))
;;;401        {
;;;402          return HAL_ERROR;
;;;403        }
;;;404        else
;;;405        {
;;;406          htim->State = HAL_TIM_STATE_BUSY;
;;;407        }
;;;408      }
;;;409      /* Set the DMA Period elapsed callback */
;;;410      htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;411    
;;;412      /* Set the DMA error callback */
;;;413      htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
;;;414    
;;;415      /* Enable the DMA channel */
;;;416      HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)pData, (uint32_t)&htim->Instance->ARR, Length);
;;;417    
;;;418      /* Enable the TIM Update DMA request */
;;;419      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_UPDATE);
;;;420    
;;;421      /* Enable the Peripheral */
;;;422      __HAL_TIM_ENABLE(htim);
;;;423    
;;;424      /* Return function status */
;;;425      return HAL_OK;
;;;426    }
000008  bf08              IT       EQ
00000a  bd10              POPEQ    {r4,pc}
00000c  6c20              LDR      r0,[r4,#0x40]         ;398
00000e  2801              CMP      r0,#1                 ;398
000010  d106              BNE      |L7.32|
000012  b919              CBNZ     r1,|L7.28|
000014  2a00              CMP      r2,#0                 ;400
000016  bf1c              ITT      NE                    ;402
000018  2001              MOVNE    r0,#1                 ;402
00001a  bd10              POPNE    {r4,pc}
                  |L7.28|
00001c  2002              MOVS     r0,#2                 ;406
00001e  6420              STR      r0,[r4,#0x40]         ;406
                  |L7.32|
000020  6a23              LDR      r3,[r4,#0x20]         ;410
000022  480c              LDR      r0,|L7.84|
000024  62d8              STR      r0,[r3,#0x2c]         ;413
000026  6a23              LDR      r3,[r4,#0x20]         ;413
000028  480b              LDR      r0,|L7.88|
00002a  6358              STR      r0,[r3,#0x34]         ;416
00002c  6820              LDR      r0,[r4,#0]            ;416
00002e  4613              MOV      r3,r2                 ;416
000030  f1000c2c          ADD      r12,r0,#0x2c          ;416
000034  4662              MOV      r2,r12                ;416
000036  6a20              LDR      r0,[r4,#0x20]         ;416
000038  f7fffffe          BL       HAL_DMA_Start_IT
00003c  6820              LDR      r0,[r4,#0]            ;419
00003e  68c1              LDR      r1,[r0,#0xc]          ;419
000040  f4417180          ORR      r1,r1,#0x100          ;419
000044  60c1              STR      r1,[r0,#0xc]          ;419
000046  6820              LDR      r0,[r4,#0]            ;422
000048  6801              LDR      r1,[r0,#0]            ;422
00004a  f0410101          ORR      r1,r1,#1              ;422
00004e  6001              STR      r1,[r0,#0]            ;422
000050  2000              MOVS     r0,#0                 ;425
000052  bd10              POP      {r4,pc}
;;;427    
                          ENDP

                  |L7.84|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L7.88|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_Base_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Start_IT PROC
;;;347    */
;;;348    HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
000000  6801              LDR      r1,[r0,#0]
;;;349    {
;;;350      /* Check the parameters */
;;;351      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;352    
;;;353       /* Enable the TIM Update interrupt */
;;;354       __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
000002  68ca              LDR      r2,[r1,#0xc]
000004  f0420201          ORR      r2,r2,#1
000008  60ca              STR      r2,[r1,#0xc]
;;;355    
;;;356       /* Enable the Peripheral */
;;;357      __HAL_TIM_ENABLE(htim);
00000a  6800              LDR      r0,[r0,#0]
00000c  6801              LDR      r1,[r0,#0]
00000e  f0410101          ORR      r1,r1,#1
000012  6001              STR      r1,[r0,#0]
;;;358    
;;;359      /* Return function status */
;;;360      return HAL_OK;
000014  2000              MOVS     r0,#0
;;;361    }
000016  4770              BX       lr
;;;362    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Stop PROC
;;;324    */
;;;325    HAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim)
000000  2102              MOVS     r1,#2
;;;326    {
;;;327      /* Check the parameters */
;;;328      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;329    
;;;330      /* Set the TIM state */
;;;331      htim->State= HAL_TIM_STATE_BUSY;
000002  6401              STR      r1,[r0,#0x40]
;;;332    
;;;333      /* Disable the Peripheral */
;;;334      __HAL_TIM_DISABLE(htim);
000004  6801              LDR      r1,[r0,#0]
000006  6a0a              LDR      r2,[r1,#0x20]
000008  f2411311          MOV      r3,#0x1111
00000c  421a              TST      r2,r3
00000e  d107              BNE      |L9.32|
000010  6a0a              LDR      r2,[r1,#0x20]
000012  109b              ASRS     r3,r3,#2
000014  421a              TST      r2,r3
000016  d103              BNE      |L9.32|
000018  680a              LDR      r2,[r1,#0]
00001a  f0220201          BIC      r2,r2,#1
00001e  600a              STR      r2,[r1,#0]
                  |L9.32|
;;;335    
;;;336      /* Change the TIM state*/
;;;337      htim->State= HAL_TIM_STATE_READY;
000020  2101              MOVS     r1,#1
000022  6401              STR      r1,[r0,#0x40]
;;;338    
;;;339      /* Return function status */
;;;340      return HAL_OK;
000024  2000              MOVS     r0,#0
;;;341    }
000026  4770              BX       lr
;;;342    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Stop_DMA PROC
;;;432    */
;;;433    HAL_StatusTypeDef HAL_TIM_Base_Stop_DMA(TIM_HandleTypeDef *htim)
000000  6801              LDR      r1,[r0,#0]
;;;434    {
;;;435      /* Check the parameters */
;;;436      assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
;;;437    
;;;438      /* Disable the TIM Update DMA request */
;;;439      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_UPDATE);
000002  68ca              LDR      r2,[r1,#0xc]
000004  f4227280          BIC      r2,r2,#0x100
000008  60ca              STR      r2,[r1,#0xc]
;;;440    
;;;441      /* Disable the Peripheral */
;;;442      __HAL_TIM_DISABLE(htim);
00000a  6801              LDR      r1,[r0,#0]
00000c  6a0a              LDR      r2,[r1,#0x20]
00000e  f2411311          MOV      r3,#0x1111
000012  421a              TST      r2,r3
000014  d107              BNE      |L10.38|
000016  6a0a              LDR      r2,[r1,#0x20]
000018  109b              ASRS     r3,r3,#2
00001a  421a              TST      r2,r3
00001c  d103              BNE      |L10.38|
00001e  680a              LDR      r2,[r1,#0]
000020  f0220201          BIC      r2,r2,#1
000024  600a              STR      r2,[r1,#0]
                  |L10.38|
;;;443    
;;;444      /* Change the htim state */
;;;445      htim->State = HAL_TIM_STATE_READY;
000026  2101              MOVS     r1,#1
000028  6401              STR      r1,[r0,#0x40]
;;;446    
;;;447      /* Return function status */
;;;448      return HAL_OK;
00002a  2000              MOVS     r0,#0
;;;449    }
00002c  4770              BX       lr
;;;450    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Stop_IT PROC
;;;367    */
;;;368    HAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim)
000000  6801              LDR      r1,[r0,#0]
;;;369    {
;;;370      /* Check the parameters */
;;;371      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;372      /* Disable the TIM Update interrupt */
;;;373      __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
000002  68ca              LDR      r2,[r1,#0xc]
000004  f0220201          BIC      r2,r2,#1
000008  60ca              STR      r2,[r1,#0xc]
;;;374    
;;;375      /* Disable the Peripheral */
;;;376      __HAL_TIM_DISABLE(htim);
00000a  6800              LDR      r0,[r0,#0]
00000c  6a01              LDR      r1,[r0,#0x20]
00000e  f2411211          MOV      r2,#0x1111
000012  4211              TST      r1,r2
000014  d107              BNE      |L11.38|
000016  6a01              LDR      r1,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L11.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L11.38|
;;;377    
;;;378      /* Return function status */
;;;379      return HAL_OK;
000026  2000              MOVS     r0,#0
;;;380    }
000028  4770              BX       lr
;;;381    
                          ENDP


                          AREA ||i.HAL_TIM_ConfigClockSource||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ConfigClockSource PROC
;;;3920     */ 
;;;3921   HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef * sClockSourceConfig)
000000  6bc2              LDR      r2,[r0,#0x3c]
;;;3922   {
;;;3923     uint32_t tmpsmcr = 0U;
;;;3924   
;;;3925     /* Process Locked */
;;;3926     __HAL_LOCK(htim);
000002  2a01              CMP      r2,#1
000004  bf0d              ITEET    EQ
000006  2002              MOVEQ    r0,#2
000008  2301              MOVNE    r3,#1
00000a  63c3              STRNE    r3,[r0,#0x3c]
;;;3927   
;;;3928     htim->State = HAL_TIM_STATE_BUSY;
;;;3929   
;;;3930     /* Check the parameters */
;;;3931     assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
;;;3932   
;;;3933     /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
;;;3934     tmpsmcr = htim->Instance->SMCR;
;;;3935     tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
;;;3936     tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
;;;3937     htim->Instance->SMCR = tmpsmcr;
;;;3938   
;;;3939     switch (sClockSourceConfig->ClockSource)
;;;3940     {
;;;3941     case TIM_CLOCKSOURCE_INTERNAL:
;;;3942       {
;;;3943         assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;3944         /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;3945         htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;3946       }
;;;3947       break;
;;;3948   
;;;3949     case TIM_CLOCKSOURCE_ETRMODE1:
;;;3950       {
;;;3951         /* Check whether or not the timer instance supports external trigger input mode 1 (ETRF)*/
;;;3952         assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
;;;3953   
;;;3954         /* Check ETR input conditioning related parameters */
;;;3955         assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
;;;3956         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;3957         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;3958         
;;;3959         /* Configure the ETR Clock source */
;;;3960         TIM_ETR_SetConfig(htim->Instance,
;;;3961                           sClockSourceConfig->ClockPrescaler,
;;;3962                           sClockSourceConfig->ClockPolarity,
;;;3963                           sClockSourceConfig->ClockFilter);
;;;3964         /* Get the TIMx SMCR register value */
;;;3965         tmpsmcr = htim->Instance->SMCR;
;;;3966         /* Reset the SMS and TS Bits */
;;;3967         tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
;;;3968         /* Select the External clock mode1 and the ETRF trigger */
;;;3969         tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
;;;3970         /* Write to TIMx SMCR */
;;;3971         htim->Instance->SMCR = tmpsmcr;
;;;3972       }
;;;3973       break;
;;;3974   
;;;3975     case TIM_CLOCKSOURCE_ETRMODE2:
;;;3976       {
;;;3977         /* Check whether or not the timer instance supports external trigger input mode 2 (ETRF)*/
;;;3978         assert_param(IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(htim->Instance));
;;;3979   
;;;3980         /* Check ETR input conditioning related parameters */
;;;3981         assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
;;;3982         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;3983         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;3984         
;;;3985         /* Configure the ETR Clock source */
;;;3986         TIM_ETR_SetConfig(htim->Instance,
;;;3987                           sClockSourceConfig->ClockPrescaler,
;;;3988                           sClockSourceConfig->ClockPolarity,
;;;3989                           sClockSourceConfig->ClockFilter);
;;;3990         /* Enable the External clock mode2 */
;;;3991         htim->Instance->SMCR |= TIM_SMCR_ECE;
;;;3992       }
;;;3993       break;
;;;3994   
;;;3995     case TIM_CLOCKSOURCE_TI1:
;;;3996       {
;;;3997         /* Check whether or not the timer instance supports external clock mode 1 */
;;;3998         assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
;;;3999   
;;;4000         /* Check TI1 input conditioning related parameters */
;;;4001         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4002         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4003         
;;;4004         TIM_TI1_ConfigInputStage(htim->Instance,
;;;4005                                  sClockSourceConfig->ClockPolarity,
;;;4006                                  sClockSourceConfig->ClockFilter);
;;;4007         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
;;;4008       }
;;;4009       break;
;;;4010     case TIM_CLOCKSOURCE_TI2:
;;;4011       {
;;;4012         /* Check whether or not the timer instance supports external clock mode 1 (ETRF)*/
;;;4013         assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
;;;4014   
;;;4015          /* Check TI2 input conditioning related parameters */
;;;4016         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4017         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4018   
;;;4019         TIM_TI2_ConfigInputStage(htim->Instance,
;;;4020                                  sClockSourceConfig->ClockPolarity,
;;;4021                                  sClockSourceConfig->ClockFilter);
;;;4022         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
;;;4023       }
;;;4024       break;
;;;4025     case TIM_CLOCKSOURCE_TI1ED:
;;;4026       {
;;;4027         /* Check whether or not the timer instance supports external clock mode 1 */
;;;4028         assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
;;;4029   
;;;4030         /* Check TI1 input conditioning related parameters */
;;;4031         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4032         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4033   
;;;4034         TIM_TI1_ConfigInputStage(htim->Instance,
;;;4035                                  sClockSourceConfig->ClockPolarity,
;;;4036                                  sClockSourceConfig->ClockFilter);
;;;4037         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
;;;4038       }
;;;4039       break;
;;;4040     case TIM_CLOCKSOURCE_ITR0:
;;;4041       {
;;;4042         /* Check whether or not the timer instance supports external clock mode 1 */
;;;4043         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4044   
;;;4045         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR0);
;;;4046       }
;;;4047       break;
;;;4048     case TIM_CLOCKSOURCE_ITR1:
;;;4049       {
;;;4050         /* Check whether or not the timer instance supports external clock mode 1 */
;;;4051         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4052   
;;;4053         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR1);
;;;4054       }
;;;4055       break;
;;;4056     case TIM_CLOCKSOURCE_ITR2:
;;;4057       {
;;;4058         /* Check whether or not the timer instance supports external clock mode 1 */
;;;4059         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4060   
;;;4061         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR2);
;;;4062       }
;;;4063       break;
;;;4064     case TIM_CLOCKSOURCE_ITR3:
;;;4065       {
;;;4066         /* Check whether or not the timer instance supports external clock mode 1 */
;;;4067         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4068   
;;;4069         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR3);
;;;4070       }
;;;4071       break;
;;;4072   
;;;4073     default:
;;;4074       break;
;;;4075     }
;;;4076     htim->State = HAL_TIM_STATE_READY;
;;;4077   
;;;4078     __HAL_UNLOCK(htim);
;;;4079   
;;;4080     return HAL_OK;
;;;4081   }
00000c  4770              BXEQ     lr
00000e  b430              PUSH     {r4,r5}               ;3922
000010  2202              MOVS     r2,#2                 ;3928
000012  6402              STR      r2,[r0,#0x40]         ;3928
000014  6802              LDR      r2,[r0,#0]            ;3934
000016  f8d2c008          LDR      r12,[r2,#8]           ;3934
00001a  f02c0c77          BIC      r12,r12,#0x77         ;3936
00001e  f42c4c7f          BIC      r12,r12,#0xff00       ;3936
000022  f8c2c008          STR      r12,[r2,#8]           ;3937
000026  680a              LDR      r2,[r1,#0]            ;3939
000028  2a50              CMP      r2,#0x50              ;3939
00002a  d041              BEQ      |L12.176|
00002c  dc0c              BGT      |L12.72|
00002e  2a20              CMP      r2,#0x20              ;3939
000030  d077              BEQ      |L12.290|
000032  dc04              BGT      |L12.62|
000034  2a00              CMP      r2,#0                 ;3939
000036  d075              BEQ      |L12.292|
000038  2a10              CMP      r2,#0x10              ;3939
00003a  d074              BEQ      |L12.294|
00003c  e0b1              B        |L12.418|
                  |L12.62|
00003e  2a30              CMP      r2,#0x30              ;3939
000040  d072              BEQ      |L12.296|
000042  2a40              CMP      r2,#0x40              ;3939
000044  d072              BEQ      |L12.300|
000046  e0ac              B        |L12.418|
                  |L12.72|
000048  2a60              CMP      r2,#0x60              ;3939
00004a  d04e              BEQ      |L12.234|
00004c  2a70              CMP      r2,#0x70              ;3939
00004e  d00b              BEQ      |L12.104|
000050  f5b25f80          CMP      r2,#0x1000            ;3939
000054  d003              BEQ      |L12.94|
000056  f5b25f00          CMP      r2,#0x2000            ;3939
00005a  d017              BEQ      |L12.140|
00005c  e0a1              B        |L12.418|
                  |L12.94|
00005e  6801              LDR      r1,[r0,#0]            ;3945
000060  688a              LDR      r2,[r1,#8]            ;3945
000062  f0220207          BIC      r2,r2,#7              ;3945
000066  e03e              B        |L12.230|
                  |L12.104|
000068  6802              LDR      r2,[r0,#0]            ;3960
00006a  f8d1c004          LDR      r12,[r1,#4]           ;3960
00006e  688c              LDR      r4,[r1,#8]            ;3960
000070  68c9              LDR      r1,[r1,#0xc]          ;3960
000072  6895              LDR      r5,[r2,#8]            ;3960
000074  ea4c2101          ORR      r1,r12,r1,LSL #8      ;3960
000078  f425457f          BIC      r5,r5,#0xff00         ;3960
00007c  4321              ORRS     r1,r1,r4              ;3960
00007e  4329              ORRS     r1,r1,r5              ;3960
000080  6091              STR      r1,[r2,#8]            ;3960
000082  6801              LDR      r1,[r0,#0]            ;3965
000084  688a              LDR      r2,[r1,#8]            ;3965
000086  f0420277          ORR      r2,r2,#0x77           ;3969
00008a  e02c              B        |L12.230|
                  |L12.140|
00008c  6802              LDR      r2,[r0,#0]            ;3986
00008e  f8d1c004          LDR      r12,[r1,#4]           ;3986
000092  688c              LDR      r4,[r1,#8]            ;3986
000094  68c9              LDR      r1,[r1,#0xc]          ;3986
000096  6895              LDR      r5,[r2,#8]            ;3986
000098  ea4c2101          ORR      r1,r12,r1,LSL #8      ;3986
00009c  f425457f          BIC      r5,r5,#0xff00         ;3986
0000a0  4321              ORRS     r1,r1,r4              ;3986
0000a2  4329              ORRS     r1,r1,r5              ;3986
0000a4  6091              STR      r1,[r2,#8]            ;3986
0000a6  6801              LDR      r1,[r0,#0]            ;3991
0000a8  688a              LDR      r2,[r1,#8]            ;3991
0000aa  f4424280          ORR      r2,r2,#0x4000         ;3991
0000ae  e01a              B        |L12.230|
                  |L12.176|
0000b0  6802              LDR      r2,[r0,#0]            ;4004
0000b2  f8d1c004          LDR      r12,[r1,#4]           ;4004
0000b6  68c9              LDR      r1,[r1,#0xc]          ;4004
0000b8  6a14              LDR      r4,[r2,#0x20]         ;4004
0000ba  6a15              LDR      r5,[r2,#0x20]         ;4004
0000bc  f0250501          BIC      r5,r5,#1              ;4004
0000c0  6215              STR      r5,[r2,#0x20]         ;4004
0000c2  6995              LDR      r5,[r2,#0x18]         ;4004
0000c4  f024040a          BIC      r4,r4,#0xa            ;4004
0000c8  f02505f0          BIC      r5,r5,#0xf0           ;4004
0000cc  ea451101          ORR      r1,r5,r1,LSL #4       ;4004
0000d0  ea440c0c          ORR      r12,r4,r12            ;4004
0000d4  6191              STR      r1,[r2,#0x18]         ;4004
0000d6  f8c2c020          STR      r12,[r2,#0x20]        ;4004
0000da  6801              LDR      r1,[r0,#0]            ;4004
0000dc  688a              LDR      r2,[r1,#8]            ;4004
0000de  f0220270          BIC      r2,r2,#0x70           ;4004
0000e2  f0420257          ORR      r2,r2,#0x57           ;4004
                  |L12.230|
0000e6  608a              STR      r2,[r1,#8]            ;3991
0000e8  e05b              B        |L12.418|
                  |L12.234|
0000ea  6802              LDR      r2,[r0,#0]            ;4019
0000ec  f8d1c004          LDR      r12,[r1,#4]           ;4019
0000f0  68cc              LDR      r4,[r1,#0xc]          ;4019
0000f2  6a11              LDR      r1,[r2,#0x20]         ;4019
0000f4  f0210110          BIC      r1,r1,#0x10           ;4019
0000f8  6211              STR      r1,[r2,#0x20]         ;4019
0000fa  6995              LDR      r5,[r2,#0x18]         ;4019
0000fc  6a11              LDR      r1,[r2,#0x20]         ;4019
0000fe  f4254570          BIC      r5,r5,#0xf000         ;4019
000102  ea453404          ORR      r4,r5,r4,LSL #12      ;4019
000106  f02101a0          BIC      r1,r1,#0xa0           ;4019
00010a  ea41110c          ORR      r1,r1,r12,LSL #4      ;4019
00010e  6194              STR      r4,[r2,#0x18]         ;4019
000110  6211              STR      r1,[r2,#0x20]         ;4019
000112  6801              LDR      r1,[r0,#0]            ;4019
000114  688a              LDR      r2,[r1,#8]            ;4019
000116  f0220270          BIC      r2,r2,#0x70           ;4019
00011a  f0420267          ORR      r2,r2,#0x67           ;4019
00011e  608a              STR      r2,[r1,#8]            ;4019
000120  e03f              B        |L12.418|
                  |L12.290|
000122  e02f              B        |L12.388|
                  |L12.292|
000124  e01e              B        |L12.356|
                  |L12.294|
000126  e025              B        |L12.372|
                  |L12.296|
000128  e034              B        |L12.404|
00012a  e7ff              B        |L12.300|
                  |L12.300|
00012c  6802              LDR      r2,[r0,#0]            ;4034
00012e  f8d1c004          LDR      r12,[r1,#4]           ;4034
000132  68cc              LDR      r4,[r1,#0xc]          ;4034
000134  6a11              LDR      r1,[r2,#0x20]         ;4034
000136  6a15              LDR      r5,[r2,#0x20]         ;4034
000138  f0250501          BIC      r5,r5,#1              ;4034
00013c  6215              STR      r5,[r2,#0x20]         ;4034
00013e  6995              LDR      r5,[r2,#0x18]         ;4034
000140  f021010a          BIC      r1,r1,#0xa            ;4034
000144  f02505f0          BIC      r5,r5,#0xf0           ;4034
000148  ea451404          ORR      r4,r5,r4,LSL #4       ;4034
00014c  ea41010c          ORR      r1,r1,r12             ;4034
000150  6194              STR      r4,[r2,#0x18]         ;4034
000152  6211              STR      r1,[r2,#0x20]         ;4034
000154  6801              LDR      r1,[r0,#0]            ;4034
000156  688a              LDR      r2,[r1,#8]            ;4034
000158  f0220270          BIC      r2,r2,#0x70           ;4034
00015c  f0420247          ORR      r2,r2,#0x47           ;4034
000160  608a              STR      r2,[r1,#8]            ;4034
000162  e01e              B        |L12.418|
                  |L12.356|
000164  6801              LDR      r1,[r0,#0]            ;4039
000166  688a              LDR      r2,[r1,#8]            ;4039
000168  f0220270          BIC      r2,r2,#0x70           ;4039
00016c  f0420207          ORR      r2,r2,#7              ;4039
000170  608a              STR      r2,[r1,#8]            ;4039
000172  e016              B        |L12.418|
                  |L12.372|
000174  6801              LDR      r1,[r0,#0]            ;4047
000176  688a              LDR      r2,[r1,#8]            ;4047
000178  f0220270          BIC      r2,r2,#0x70           ;4047
00017c  f0420217          ORR      r2,r2,#0x17           ;4047
000180  608a              STR      r2,[r1,#8]            ;4047
000182  e00e              B        |L12.418|
                  |L12.388|
000184  6801              LDR      r1,[r0,#0]            ;4055
000186  688a              LDR      r2,[r1,#8]            ;4055
000188  f0220270          BIC      r2,r2,#0x70           ;4055
00018c  f0420227          ORR      r2,r2,#0x27           ;4055
000190  608a              STR      r2,[r1,#8]            ;4055
000192  e006              B        |L12.418|
                  |L12.404|
000194  6801              LDR      r1,[r0,#0]            ;4063
000196  688a              LDR      r2,[r1,#8]            ;4063
000198  f0220270          BIC      r2,r2,#0x70           ;4063
00019c  f0420237          ORR      r2,r2,#0x37           ;4063
0001a0  608a              STR      r2,[r1,#8]            ;4063
                  |L12.418|
0001a2  6403              STR      r3,[r0,#0x40]         ;4076
0001a4  2100              MOVS     r1,#0                 ;4078
0001a6  63c1              STR      r1,[r0,#0x3c]         ;4080
0001a8  bc30              POP      {r4,r5}
0001aa  4608              MOV      r0,r1                 ;4080
0001ac  4770              BX       lr
;;;4082   
                          ENDP


                          AREA ||i.HAL_TIM_ConfigOCrefClear||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ConfigOCrefClear PROC
;;;3799     */ 
;;;3800   HAL_StatusTypeDef HAL_TIM_ConfigOCrefClear(TIM_HandleTypeDef *htim, TIM_ClearInputConfigTypeDef * sClearInputConfig, uint32_t Channel)
000000  6bc3              LDR      r3,[r0,#0x3c]
;;;3801   {
;;;3802     uint32_t tmpsmcr = 0U;
;;;3803   
;;;3804     /* Check the parameters */
;;;3805     assert_param(IS_TIM_OCXREF_CLEAR_INSTANCE(htim->Instance));
;;;3806     assert_param(IS_TIM_CLEARINPUT_SOURCE(sClearInputConfig->ClearInputSource));
;;;3807     assert_param(IS_TIM_CLEARINPUT_POLARITY(sClearInputConfig->ClearInputPolarity));
;;;3808     assert_param(IS_TIM_CLEARINPUT_PRESCALER(sClearInputConfig->ClearInputPrescaler));
;;;3809     assert_param(IS_TIM_CLEARINPUT_FILTER(sClearInputConfig->ClearInputFilter));
;;;3810   
;;;3811     /* Process Locked */
;;;3812     __HAL_LOCK(htim);
000002  2b01              CMP      r3,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;3813   
;;;3814     htim->State = HAL_TIM_STATE_BUSY;
;;;3815   
;;;3816     switch (sClearInputConfig->ClearInputSource)
;;;3817     {
;;;3818       case TIM_CLEARINPUTSOURCE_NONE:
;;;3819       {
;;;3820   
;;;3821         /* Clear the ETR Bits */
;;;3822         tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
;;;3823   
;;;3824         /* Set TIMx_SMCR */
;;;3825         htim->Instance->SMCR = tmpsmcr;
;;;3826      }
;;;3827       break;
;;;3828   
;;;3829       case TIM_CLEARINPUTSOURCE_ETR:
;;;3830       {
;;;3831         TIM_ETR_SetConfig(htim->Instance,
;;;3832                           sClearInputConfig->ClearInputPrescaler,
;;;3833                           sClearInputConfig->ClearInputPolarity,
;;;3834                           sClearInputConfig->ClearInputFilter);
;;;3835   
;;;3836       }
;;;3837       break;
;;;3838       default:
;;;3839       break;
;;;3840     }
;;;3841   
;;;3842     switch (Channel)
;;;3843     {
;;;3844       case TIM_CHANNEL_1:
;;;3845         {
;;;3846           if(sClearInputConfig->ClearInputState != RESET)
;;;3847           {
;;;3848             /* Enable the Ocref clear feature for Channel 1 */
;;;3849             htim->Instance->CCMR1 |= TIM_CCMR1_OC1CE;
;;;3850           }
;;;3851           else
;;;3852           {
;;;3853             /* Disable the Ocref clear feature for Channel 1 */
;;;3854           htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1CE;
;;;3855           }
;;;3856         }
;;;3857         break;
;;;3858       case TIM_CHANNEL_2:
;;;3859         {
;;;3860           assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3861           if(sClearInputConfig->ClearInputState != RESET)
;;;3862           {
;;;3863             /* Enable the Ocref clear feature for Channel 2 */
;;;3864             htim->Instance->CCMR1 |= TIM_CCMR1_OC2CE;
;;;3865           }
;;;3866           else
;;;3867           {
;;;3868             /* Disable the Ocref clear feature for Channel 2 */
;;;3869             htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2CE;
;;;3870           }
;;;3871         }
;;;3872       break;
;;;3873       case TIM_CHANNEL_3:
;;;3874         {
;;;3875           assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3876           if(sClearInputConfig->ClearInputState != RESET)
;;;3877           {
;;;3878             /* Enable the Ocref clear feature for Channel 3 */
;;;3879             htim->Instance->CCMR2 |= TIM_CCMR2_OC3CE;
;;;3880           }
;;;3881           else
;;;3882           {
;;;3883             /* Disable the Ocref clear feature for Channel 3 */
;;;3884           htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3CE;
;;;3885           }
;;;3886         }
;;;3887       break;
;;;3888       case TIM_CHANNEL_4:
;;;3889         {
;;;3890           assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3891           if(sClearInputConfig->ClearInputState != RESET)
;;;3892           {
;;;3893             /* Enable the Ocref clear feature for Channel 4 */
;;;3894             htim->Instance->CCMR2 |= TIM_CCMR2_OC4CE;
;;;3895           }
;;;3896           else
;;;3897           {
;;;3898             /* Disable the Ocref clear feature for Channel 4 */
;;;3899           htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4CE;
;;;3900           }
;;;3901         }
;;;3902       break;
;;;3903       default:
;;;3904       break;
;;;3905     }
;;;3906   
;;;3907     htim->State = HAL_TIM_STATE_READY;
;;;3908   
;;;3909     __HAL_UNLOCK(htim);
;;;3910   
;;;3911     return HAL_OK;
;;;3912   }
000008  4770              BXEQ     lr
00000a  e92d01f0          PUSH     {r4-r8}               ;3801
00000e  f04f0c01          MOV      r12,#1                ;3812
000012  2302              MOVS     r3,#2                 ;3814
000014  f8c0c03c          STR      r12,[r0,#0x3c]        ;3814
000018  6403              STR      r3,[r0,#0x40]         ;3814
00001a  684b              LDR      r3,[r1,#4]            ;3816
00001c  2400              MOVS     r4,#0                 ;3816
00001e  2b00              CMP      r3,#0                 ;3816
000020  bf04              ITT      EQ                    ;3825
000022  6803              LDREQ    r3,[r0,#0]            ;3825
000024  609c              STREQ    r4,[r3,#8]            ;3825
000026  d00e              BEQ      |L13.70|
000028  2b01              CMP      r3,#1                 ;3816
00002a  d10c              BNE      |L13.70|
00002c  6803              LDR      r3,[r0,#0]            ;3831
00002e  e9d16503          LDRD     r6,r5,[r1,#0xc]       ;3831
000032  f8d18008          LDR      r8,[r1,#8]            ;3831
000036  689f              LDR      r7,[r3,#8]            ;3831
000038  ea482505          ORR      r5,r8,r5,LSL #8       ;3831
00003c  f427477f          BIC      r7,r7,#0xff00         ;3831
000040  4335              ORRS     r5,r5,r6              ;3831
000042  433d              ORRS     r5,r5,r7              ;3831
000044  609d              STR      r5,[r3,#8]            ;3831
                  |L13.70|
000046  b132              CBZ      r2,|L13.86|
000048  2a04              CMP      r2,#4                 ;3842
00004a  d00f              BEQ      |L13.108|
00004c  2a08              CMP      r2,#8                 ;3842
00004e  d017              BEQ      |L13.128|
000050  2a0c              CMP      r2,#0xc               ;3842
000052  d026              BEQ      |L13.162|
000054  e01e              B        |L13.148|
                  |L13.86|
000056  6809              LDR      r1,[r1,#0]            ;3846
000058  2900              CMP      r1,#0                 ;3846
00005a  6801              LDR      r1,[r0,#0]            ;3854
00005c  698a              LDR      r2,[r1,#0x18]         ;3854
00005e  bf14              ITE      NE                    ;3849
000060  f0420280          ORRNE    r2,r2,#0x80           ;3849
000064  f0220280          BICEQ    r2,r2,#0x80           ;3854
                  |L13.104|
000068  618a              STR      r2,[r1,#0x18]         ;3849
00006a  e013              B        |L13.148|
                  |L13.108|
00006c  6809              LDR      r1,[r1,#0]            ;3861
00006e  2900              CMP      r1,#0                 ;3861
000070  6801              LDR      r1,[r0,#0]            ;3869
000072  698a              LDR      r2,[r1,#0x18]         ;3869
000074  bf14              ITE      NE                    ;3864
000076  f4424200          ORRNE    r2,r2,#0x8000         ;3864
00007a  f4224200          BICEQ    r2,r2,#0x8000         ;3869
00007e  e7f3              B        |L13.104|
                  |L13.128|
000080  6809              LDR      r1,[r1,#0]            ;3876
000082  2900              CMP      r1,#0                 ;3876
000084  6801              LDR      r1,[r0,#0]            ;3884
000086  69ca              LDR      r2,[r1,#0x1c]         ;3884
000088  bf14              ITE      NE                    ;3879
00008a  f0420280          ORRNE    r2,r2,#0x80           ;3879
00008e  f0220280          BICEQ    r2,r2,#0x80           ;3884
                  |L13.146|
000092  61ca              STR      r2,[r1,#0x1c]         ;3879
                  |L13.148|
000094  f8c0c040          STR      r12,[r0,#0x40]        ;3907
000098  63c4              STR      r4,[r0,#0x3c]         ;3911
00009a  e8bd01f0          POP      {r4-r8}
00009e  2000              MOVS     r0,#0                 ;3911
0000a0  4770              BX       lr
                  |L13.162|
0000a2  6809              LDR      r1,[r1,#0]            ;3891
0000a4  2900              CMP      r1,#0                 ;3891
0000a6  6801              LDR      r1,[r0,#0]            ;3899
0000a8  69ca              LDR      r2,[r1,#0x1c]         ;3899
0000aa  bf14              ITE      NE                    ;3894
0000ac  f4424200          ORRNE    r2,r2,#0x8000         ;3894
0000b0  f4224200          BICEQ    r2,r2,#0x8000         ;3899
0000b4  e7ed              B        |L13.146|
;;;3913   
                          ENDP


                          AREA ||i.HAL_TIM_ConfigTI1Input||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ConfigTI1Input PROC
;;;4094     */
;;;4095   HAL_StatusTypeDef HAL_TIM_ConfigTI1Input(TIM_HandleTypeDef *htim, uint32_t TI1_Selection)
000000  6800              LDR      r0,[r0,#0]
;;;4096   {
;;;4097     uint32_t tmpcr2 = 0U;
;;;4098   
;;;4099     /* Check the parameters */
;;;4100     assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;4101     assert_param(IS_TIM_TI1SELECTION(TI1_Selection));
;;;4102   
;;;4103     /* Get the TIMx CR2 register value */
;;;4104     tmpcr2 = htim->Instance->CR2;
000002  6842              LDR      r2,[r0,#4]
;;;4105   
;;;4106     /* Reset the TI1 selection */
;;;4107     tmpcr2 &= ~TIM_CR2_TI1S;
000004  f0220280          BIC      r2,r2,#0x80
;;;4108   
;;;4109     /* Set the the TI1 selection */
;;;4110     tmpcr2 |= TI1_Selection;
000008  4311              ORRS     r1,r1,r2
;;;4111   
;;;4112     /* Write to TIMxCR2 */
;;;4113     htim->Instance->CR2 = tmpcr2;
00000a  6041              STR      r1,[r0,#4]
;;;4114   
;;;4115     return HAL_OK;
00000c  2000              MOVS     r0,#0
;;;4116   }
00000e  4770              BX       lr
;;;4117   
                          ENDP


                          AREA ||i.HAL_TIM_DMABurst_ReadStart||, CODE, READONLY, ALIGN=2

                  HAL_TIM_DMABurst_ReadStart PROC
;;;3558     */
;;;3559   HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3560                                                uint32_t  *BurstBuffer, uint32_t  BurstLength)
;;;3561   {
000004  4604              MOV      r4,r0
;;;3562     /* Check the parameters */
;;;3563     assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
;;;3564     assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
;;;3565     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3566     assert_param(IS_TIM_DMA_LENGTH(BurstLength));
;;;3567   
;;;3568     if((htim->State == HAL_TIM_STATE_BUSY))
000006  9d06              LDR      r5,[sp,#0x18]
000008  6c00              LDR      r0,[r0,#0x40]
00000a  469c              MOV      r12,r3                ;3561
00000c  4616              MOV      r6,r2                 ;3561
00000e  4688              MOV      r8,r1                 ;3561
000010  2802              CMP      r0,#2
;;;3569     {
;;;3570        return HAL_BUSY;
;;;3571     }
;;;3572     else if((htim->State == HAL_TIM_STATE_READY))
;;;3573     {
;;;3574       if((BurstBuffer == 0U) && (BurstLength > 0U))
;;;3575       {
;;;3576         return HAL_ERROR;
;;;3577       }
;;;3578       else
;;;3579       {
;;;3580         htim->State = HAL_TIM_STATE_BUSY;
;;;3581       }
;;;3582     }
;;;3583     switch(BurstRequestSrc)
;;;3584     {
;;;3585       case TIM_DMA_UPDATE:
;;;3586       {
;;;3587         /* Set the DMA Period elapsed callback */
;;;3588         htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;3589   
;;;3590         /* Set the DMA error callback */
;;;3591         htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
;;;3592   
;;;3593         /* Enable the DMA channel */
;;;3594          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);
;;;3595       }
;;;3596       break;
;;;3597       case TIM_DMA_CC1:
;;;3598       {
;;;3599         /* Set the DMA Period elapsed callback */
;;;3600         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback =  TIM_DMACaptureCplt;
;;;3601   
;;;3602         /* Set the DMA error callback */
;;;3603         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;3604   
;;;3605         /* Enable the DMA channel */
;;;3606         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);
;;;3607       }
;;;3608       break;
;;;3609       case TIM_DMA_CC2:
;;;3610       {
;;;3611         /* Set the DMA Period elapsed callback */
;;;3612         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback =  TIM_DMACaptureCplt;
;;;3613   
;;;3614         /* Set the DMA error callback */
;;;3615         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;3616   
;;;3617         /* Enable the DMA channel */
;;;3618         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);
;;;3619       }
;;;3620       break;
;;;3621       case TIM_DMA_CC3:
;;;3622       {
;;;3623         /* Set the DMA Period elapsed callback */
;;;3624         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback =  TIM_DMACaptureCplt;
;;;3625   
;;;3626         /* Set the DMA error callback */
;;;3627         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;3628   
;;;3629         /* Enable the DMA channel */
;;;3630         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);
;;;3631       }
;;;3632       break;
;;;3633       case TIM_DMA_CC4:
;;;3634       {
;;;3635         /* Set the DMA Period elapsed callback */
;;;3636         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback =  TIM_DMACaptureCplt;
;;;3637   
;;;3638         /* Set the DMA error callback */
;;;3639         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;3640   
;;;3641         /* Enable the DMA channel */
;;;3642         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);
;;;3643       }
;;;3644       break;
;;;3645       case TIM_DMA_COM:
;;;3646       {
;;;3647         /* Set the DMA Period elapsed callback */
;;;3648         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;
;;;3649   
;;;3650         /* Set the DMA error callback */
;;;3651         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
;;;3652   
;;;3653         /* Enable the DMA channel */
;;;3654         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);
;;;3655       }
;;;3656       break;
;;;3657       case TIM_DMA_TRIGGER:
;;;3658       {
;;;3659         /* Set the DMA Period elapsed callback */
;;;3660         htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
;;;3661   
;;;3662         /* Set the DMA error callback */
;;;3663         htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
;;;3664   
;;;3665         /* Enable the DMA channel */
;;;3666         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);
;;;3667       }
;;;3668       break;
;;;3669       default:
;;;3670       break;
;;;3671     }
;;;3672   
;;;3673     /* configure the DMA Burst Mode */
;;;3674     htim->Instance->DCR = BurstBaseAddress | BurstLength;
;;;3675   
;;;3676     /* Enable the TIM DMA Request */
;;;3677     __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
;;;3678   
;;;3679     htim->State = HAL_TIM_STATE_READY;
;;;3680   
;;;3681     /* Return function status */
;;;3682     return HAL_OK;
;;;3683   }
000012  bf08              IT       EQ
000014  e8bd81f0          POPEQ    {r4-r8,pc}
000018  6c20              LDR      r0,[r4,#0x40]         ;3572
00001a  2801              CMP      r0,#1                 ;3572
00001c  d109              BNE      |L15.50|
00001e  f1bc0f00          CMP      r12,#0                ;3574
000022  d104              BNE      |L15.46|
000024  2d00              CMP      r5,#0                 ;3574
000026  bf1c              ITT      NE                    ;3576
000028  2001              MOVNE    r0,#1                 ;3576
00002a  e8bd81f0          POPNE    {r4-r8,pc}
                  |L15.46|
00002e  2002              MOVS     r0,#2                 ;3580
000030  6420              STR      r0,[r4,#0x40]         ;3580
                  |L15.50|
000032  2701              MOVS     r7,#1                 ;3576
000034  483e              LDR      r0,|L15.304|
000036  4a3f              LDR      r2,|L15.308|
000038  eb072315          ADD      r3,r7,r5,LSR #8       ;3594
00003c  f5b66f00          CMP      r6,#0x800             ;3583
000040  d039              BEQ      |L15.182|
000042  dc09              BGT      |L15.88|
000044  f5b67f80          CMP      r6,#0x100             ;3583
000048  d010              BEQ      |L15.108|
00004a  f5b67f00          CMP      r6,#0x200             ;3583
00004e  d01a              BEQ      |L15.134|
000050  f5b66f80          CMP      r6,#0x400             ;3583
000054  d023              BEQ      |L15.158|
000056  e05f              B        |L15.280|
                  |L15.88|
000058  f5b65f80          CMP      r6,#0x1000            ;3583
00005c  d037              BEQ      |L15.206|
00005e  f5b65f00          CMP      r6,#0x2000            ;3583
000062  d040              BEQ      |L15.230|
000064  f5b64f80          CMP      r6,#0x4000            ;3583
000068  d04a              BEQ      |L15.256|
00006a  e055              B        |L15.280|
                  |L15.108|
00006c  6a22              LDR      r2,[r4,#0x20]         ;3588
00006e  4932              LDR      r1,|L15.312|
000070  62d1              STR      r1,[r2,#0x2c]         ;3591
000072  6a21              LDR      r1,[r4,#0x20]         ;3591
000074  4662              MOV      r2,r12                ;3594
000076  6348              STR      r0,[r1,#0x34]         ;3594
000078  6820              LDR      r0,[r4,#0]            ;3594
00007a  f100014c          ADD      r1,r0,#0x4c           ;3594
00007e  6a20              LDR      r0,[r4,#0x20]         ;3594
000080  f7fffffe          BL       HAL_DMA_Start_IT
000084  e048              B        |L15.280|
                  |L15.134|
000086  6a61              LDR      r1,[r4,#0x24]         ;3600
000088  62ca              STR      r2,[r1,#0x2c]         ;3603
00008a  6a61              LDR      r1,[r4,#0x24]         ;3603
00008c  4662              MOV      r2,r12                ;3606
00008e  6348              STR      r0,[r1,#0x34]         ;3606
000090  6820              LDR      r0,[r4,#0]            ;3606
000092  f100014c          ADD      r1,r0,#0x4c           ;3606
000096  6a60              LDR      r0,[r4,#0x24]         ;3606
000098  f7fffffe          BL       HAL_DMA_Start_IT
00009c  e03c              B        |L15.280|
                  |L15.158|
00009e  6aa1              LDR      r1,[r4,#0x28]         ;3612
0000a0  62ca              STR      r2,[r1,#0x2c]         ;3615
0000a2  6aa1              LDR      r1,[r4,#0x28]         ;3615
0000a4  4662              MOV      r2,r12                ;3618
0000a6  6348              STR      r0,[r1,#0x34]         ;3618
0000a8  6820              LDR      r0,[r4,#0]            ;3618
0000aa  f100014c          ADD      r1,r0,#0x4c           ;3618
0000ae  6aa0              LDR      r0,[r4,#0x28]         ;3618
0000b0  f7fffffe          BL       HAL_DMA_Start_IT
0000b4  e030              B        |L15.280|
                  |L15.182|
0000b6  6ae1              LDR      r1,[r4,#0x2c]         ;3624
0000b8  62ca              STR      r2,[r1,#0x2c]         ;3627
0000ba  6ae1              LDR      r1,[r4,#0x2c]         ;3627
0000bc  4662              MOV      r2,r12                ;3630
0000be  6348              STR      r0,[r1,#0x34]         ;3630
0000c0  6820              LDR      r0,[r4,#0]            ;3630
0000c2  f100014c          ADD      r1,r0,#0x4c           ;3630
0000c6  6ae0              LDR      r0,[r4,#0x2c]         ;3630
0000c8  f7fffffe          BL       HAL_DMA_Start_IT
0000cc  e024              B        |L15.280|
                  |L15.206|
0000ce  6b21              LDR      r1,[r4,#0x30]         ;3636
0000d0  62ca              STR      r2,[r1,#0x2c]         ;3639
0000d2  6b21              LDR      r1,[r4,#0x30]         ;3639
0000d4  4662              MOV      r2,r12                ;3642
0000d6  6348              STR      r0,[r1,#0x34]         ;3642
0000d8  6820              LDR      r0,[r4,#0]            ;3642
0000da  f100014c          ADD      r1,r0,#0x4c           ;3642
0000de  6b20              LDR      r0,[r4,#0x30]         ;3642
0000e0  f7fffffe          BL       HAL_DMA_Start_IT
0000e4  e018              B        |L15.280|
                  |L15.230|
0000e6  6b62              LDR      r2,[r4,#0x34]         ;3648
0000e8  4914              LDR      r1,|L15.316|
0000ea  62d1              STR      r1,[r2,#0x2c]         ;3651
0000ec  6b61              LDR      r1,[r4,#0x34]         ;3651
0000ee  4662              MOV      r2,r12                ;3654
0000f0  6348              STR      r0,[r1,#0x34]         ;3654
0000f2  6820              LDR      r0,[r4,#0]            ;3654
0000f4  f100014c          ADD      r1,r0,#0x4c           ;3654
0000f8  6b60              LDR      r0,[r4,#0x34]         ;3654
0000fa  f7fffffe          BL       HAL_DMA_Start_IT
0000fe  e00b              B        |L15.280|
                  |L15.256|
000100  6ba2              LDR      r2,[r4,#0x38]         ;3660
000102  490f              LDR      r1,|L15.320|
000104  62d1              STR      r1,[r2,#0x2c]         ;3663
000106  6ba1              LDR      r1,[r4,#0x38]         ;3663
000108  4662              MOV      r2,r12                ;3666
00010a  6348              STR      r0,[r1,#0x34]         ;3666
00010c  6820              LDR      r0,[r4,#0]            ;3666
00010e  f100014c          ADD      r1,r0,#0x4c           ;3666
000112  6ba0              LDR      r0,[r4,#0x38]         ;3666
000114  f7fffffe          BL       HAL_DMA_Start_IT
                  |L15.280|
000118  6821              LDR      r1,[r4,#0]            ;3674
00011a  ea480005          ORR      r0,r8,r5              ;3674
00011e  6488              STR      r0,[r1,#0x48]         ;3674
000120  6820              LDR      r0,[r4,#0]            ;3677
000122  68c1              LDR      r1,[r0,#0xc]          ;3677
000124  4331              ORRS     r1,r1,r6              ;3677
000126  60c1              STR      r1,[r0,#0xc]          ;3677
000128  6427              STR      r7,[r4,#0x40]         ;3679
00012a  2000              MOVS     r0,#0                 ;3682
00012c  e8bd81f0          POP      {r4-r8,pc}
;;;3684   
                          ENDP

                  |L15.304|
                          DCD      TIM_DMAError
                  |L15.308|
                          DCD      TIM_DMACaptureCplt
                  |L15.312|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L15.316|
                          DCD      TIMEx_DMACommutationCplt
                  |L15.320|
                          DCD      TIM_DMATriggerCplt

                          AREA ||i.HAL_TIM_DMABurst_ReadStop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_DMABurst_ReadStop PROC
;;;3690     */
;;;3691   HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
000000  b570              PUSH     {r4-r6,lr}
;;;3692   {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;3693     /* Check the parameters */
;;;3694     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3695   
;;;3696     /* Abort the DMA transfer (at least disable the DMA channel) */
;;;3697     switch(BurstRequestSrc)
000006  f5b16f00          CMP      r1,#0x800
;;;3698     {
;;;3699       case TIM_DMA_UPDATE:
;;;3700       {
;;;3701         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
;;;3702       }
;;;3703       break;
;;;3704       case TIM_DMA_CC1:
;;;3705       {
;;;3706         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
;;;3707       }
;;;3708       break;
;;;3709       case TIM_DMA_CC2:
;;;3710       {
;;;3711         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
;;;3712       }
;;;3713       break;
;;;3714       case TIM_DMA_CC3:
;;;3715       {
;;;3716         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
00000a  bf08              IT       EQ
00000c  6ae0              LDREQ    r0,[r4,#0x2c]
00000e  d021              BEQ      |L16.84|
000010  dc0f              BGT      |L16.50|
000012  f5b57f80          CMP      r5,#0x100             ;3697
000016  bf08              IT       EQ                    ;3701
000018  6a20              LDREQ    r0,[r4,#0x20]         ;3701
00001a  d01b              BEQ      |L16.84|
00001c  f5b57f00          CMP      r5,#0x200             ;3697
000020  bf08              IT       EQ                    ;3706
000022  6a60              LDREQ    r0,[r4,#0x24]         ;3706
000024  d016              BEQ      |L16.84|
000026  f5b56f80          CMP      r5,#0x400             ;3697
00002a  bf08              IT       EQ                    ;3711
00002c  6aa0              LDREQ    r0,[r4,#0x28]         ;3711
00002e  d011              BEQ      |L16.84|
000030  e012              B        |L16.88|
                  |L16.50|
000032  f5b55f80          CMP      r5,#0x1000            ;3697
;;;3717       }
;;;3718       break;
;;;3719       case TIM_DMA_CC4:
;;;3720       {
;;;3721         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
000036  bf08              IT       EQ
000038  6b20              LDREQ    r0,[r4,#0x30]
00003a  d00b              BEQ      |L16.84|
00003c  f5b55f00          CMP      r5,#0x2000            ;3697
;;;3722       }
;;;3723       break;
;;;3724       case TIM_DMA_COM:
;;;3725       {
;;;3726         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
000040  bf08              IT       EQ
000042  6b60              LDREQ    r0,[r4,#0x34]
000044  d006              BEQ      |L16.84|
000046  f5b54f80          CMP      r5,#0x4000            ;3697
;;;3727       }
;;;3728       break;
;;;3729       case TIM_DMA_TRIGGER:
;;;3730       {
;;;3731         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
00004a  bf04              ITT      EQ
00004c  6ba0              LDREQ    r0,[r4,#0x38]
00004e  f7fffffe          BLEQ     HAL_DMA_Abort
000052  e001              B        |L16.88|
                  |L16.84|
000054  f7fffffe          BL       HAL_DMA_Abort
                  |L16.88|
;;;3732       }
;;;3733       break;
;;;3734       default:
;;;3735       break;
;;;3736     }
;;;3737   
;;;3738     /* Disable the TIM Update DMA request */
;;;3739     __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
000058  6820              LDR      r0,[r4,#0]
00005a  68c1              LDR      r1,[r0,#0xc]
00005c  43a9              BICS     r1,r1,r5
00005e  60c1              STR      r1,[r0,#0xc]
;;;3740   
;;;3741     /* Return function status */
;;;3742     return HAL_OK;
000060  2000              MOVS     r0,#0
;;;3743   }
000062  bd70              POP      {r4-r6,pc}
;;;3744   
                          ENDP


                          AREA ||i.HAL_TIM_DMABurst_WriteStart||, CODE, READONLY, ALIGN=2

                  HAL_TIM_DMABurst_WriteStart PROC
;;;3335     */
;;;3336   HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3337                                                 uint32_t* BurstBuffer, uint32_t  BurstLength)
;;;3338   {
000004  4604              MOV      r4,r0
;;;3339     /* Check the parameters */
;;;3340     assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
;;;3341     assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
;;;3342     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3343     assert_param(IS_TIM_DMA_LENGTH(BurstLength));
;;;3344   
;;;3345     if((htim->State == HAL_TIM_STATE_BUSY))
000006  9d06              LDR      r5,[sp,#0x18]
000008  6c00              LDR      r0,[r0,#0x40]
00000a  469c              MOV      r12,r3                ;3338
00000c  4616              MOV      r6,r2                 ;3338
00000e  4688              MOV      r8,r1                 ;3338
000010  2802              CMP      r0,#2
;;;3346     {
;;;3347        return HAL_BUSY;
;;;3348     }
;;;3349     else if((htim->State == HAL_TIM_STATE_READY))
;;;3350     {
;;;3351       if((BurstBuffer == 0U) && (BurstLength > 0U))
;;;3352       {
;;;3353         return HAL_ERROR;
;;;3354       }
;;;3355       else
;;;3356       {
;;;3357         htim->State = HAL_TIM_STATE_BUSY;
;;;3358       }
;;;3359     }
;;;3360     switch(BurstRequestSrc)
;;;3361     {
;;;3362       case TIM_DMA_UPDATE:
;;;3363       {
;;;3364         /* Set the DMA Period elapsed callback */
;;;3365         htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;3366   
;;;3367         /* Set the DMA error callback */
;;;3368         htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
;;;3369   
;;;3370         /* Enable the DMA channel */
;;;3371         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);
;;;3372       }
;;;3373       break;
;;;3374       case TIM_DMA_CC1:
;;;3375       {
;;;3376         /* Set the DMA Period elapsed callback */
;;;3377         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback =  TIM_DMADelayPulseCplt;
;;;3378   
;;;3379         /* Set the DMA error callback */
;;;3380         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;3381   
;;;3382         /* Enable the DMA channel */
;;;3383         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);
;;;3384       }
;;;3385       break;
;;;3386       case TIM_DMA_CC2:
;;;3387       {
;;;3388         /* Set the DMA Period elapsed callback */
;;;3389         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback =  TIM_DMADelayPulseCplt;
;;;3390   
;;;3391         /* Set the DMA error callback */
;;;3392         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;3393   
;;;3394         /* Enable the DMA channel */
;;;3395         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);
;;;3396       }
;;;3397       break;
;;;3398       case TIM_DMA_CC3:
;;;3399       {
;;;3400         /* Set the DMA Period elapsed callback */
;;;3401         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback =  TIM_DMADelayPulseCplt;
;;;3402   
;;;3403         /* Set the DMA error callback */
;;;3404         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;3405   
;;;3406         /* Enable the DMA channel */
;;;3407         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);
;;;3408       }
;;;3409       break;
;;;3410       case TIM_DMA_CC4:
;;;3411       {
;;;3412         /* Set the DMA Period elapsed callback */
;;;3413         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback =  TIM_DMADelayPulseCplt;
;;;3414   
;;;3415         /* Set the DMA error callback */
;;;3416         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;3417   
;;;3418         /* Enable the DMA channel */
;;;3419         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);
;;;3420       }
;;;3421       break;
;;;3422       case TIM_DMA_COM:
;;;3423       {
;;;3424         /* Set the DMA Period elapsed callback */
;;;3425         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;
;;;3426   
;;;3427         /* Set the DMA error callback */
;;;3428         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
;;;3429   
;;;3430         /* Enable the DMA channel */
;;;3431         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);
;;;3432       }
;;;3433       break;
;;;3434       case TIM_DMA_TRIGGER:
;;;3435       {
;;;3436         /* Set the DMA Period elapsed callback */
;;;3437         htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
;;;3438   
;;;3439         /* Set the DMA error callback */
;;;3440         htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
;;;3441   
;;;3442         /* Enable the DMA channel */
;;;3443         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);
;;;3444       }
;;;3445       break;
;;;3446       default:
;;;3447       break;
;;;3448     }
;;;3449      /* configure the DMA Burst Mode */
;;;3450      htim->Instance->DCR = BurstBaseAddress | BurstLength;
;;;3451   
;;;3452      /* Enable the TIM DMA Request */
;;;3453      __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
;;;3454   
;;;3455      htim->State = HAL_TIM_STATE_READY;
;;;3456   
;;;3457     /* Return function status */
;;;3458     return HAL_OK;
;;;3459   }
000012  bf08              IT       EQ
000014  e8bd81f0          POPEQ    {r4-r8,pc}
000018  6c20              LDR      r0,[r4,#0x40]         ;3349
00001a  2801              CMP      r0,#1                 ;3349
00001c  d109              BNE      |L17.50|
00001e  f1bc0f00          CMP      r12,#0                ;3351
000022  d104              BNE      |L17.46|
000024  2d00              CMP      r5,#0                 ;3351
000026  bf1c              ITT      NE                    ;3353
000028  2001              MOVNE    r0,#1                 ;3353
00002a  e8bd81f0          POPNE    {r4-r8,pc}
                  |L17.46|
00002e  2002              MOVS     r0,#2                 ;3357
000030  6420              STR      r0,[r4,#0x40]         ;3357
                  |L17.50|
000032  2701              MOVS     r7,#1                 ;3353
000034  483e              LDR      r0,|L17.304|
000036  493f              LDR      r1,|L17.308|
000038  eb072315          ADD      r3,r7,r5,LSR #8       ;3371
00003c  f5b66f00          CMP      r6,#0x800             ;3360
000040  d039              BEQ      |L17.182|
000042  dc09              BGT      |L17.88|
000044  f5b67f80          CMP      r6,#0x100             ;3360
000048  d010              BEQ      |L17.108|
00004a  f5b67f00          CMP      r6,#0x200             ;3360
00004e  d01a              BEQ      |L17.134|
000050  f5b66f80          CMP      r6,#0x400             ;3360
000054  d023              BEQ      |L17.158|
000056  e05f              B        |L17.280|
                  |L17.88|
000058  f5b65f80          CMP      r6,#0x1000            ;3360
00005c  d037              BEQ      |L17.206|
00005e  f5b65f00          CMP      r6,#0x2000            ;3360
000062  d040              BEQ      |L17.230|
000064  f5b64f80          CMP      r6,#0x4000            ;3360
000068  d04a              BEQ      |L17.256|
00006a  e055              B        |L17.280|
                  |L17.108|
00006c  6a22              LDR      r2,[r4,#0x20]         ;3365
00006e  4932              LDR      r1,|L17.312|
000070  62d1              STR      r1,[r2,#0x2c]         ;3368
000072  6a21              LDR      r1,[r4,#0x20]         ;3368
000074  6348              STR      r0,[r1,#0x34]         ;3371
000076  6820              LDR      r0,[r4,#0]            ;3371
000078  4661              MOV      r1,r12                ;3371
00007a  f100024c          ADD      r2,r0,#0x4c           ;3371
00007e  6a20              LDR      r0,[r4,#0x20]         ;3371
000080  f7fffffe          BL       HAL_DMA_Start_IT
000084  e048              B        |L17.280|
                  |L17.134|
000086  6a62              LDR      r2,[r4,#0x24]         ;3377
000088  62d1              STR      r1,[r2,#0x2c]         ;3380
00008a  6a61              LDR      r1,[r4,#0x24]         ;3380
00008c  6348              STR      r0,[r1,#0x34]         ;3383
00008e  6820              LDR      r0,[r4,#0]            ;3383
000090  4661              MOV      r1,r12                ;3383
000092  f100024c          ADD      r2,r0,#0x4c           ;3383
000096  6a60              LDR      r0,[r4,#0x24]         ;3383
000098  f7fffffe          BL       HAL_DMA_Start_IT
00009c  e03c              B        |L17.280|
                  |L17.158|
00009e  6aa2              LDR      r2,[r4,#0x28]         ;3389
0000a0  62d1              STR      r1,[r2,#0x2c]         ;3392
0000a2  6aa1              LDR      r1,[r4,#0x28]         ;3392
0000a4  6348              STR      r0,[r1,#0x34]         ;3395
0000a6  6820              LDR      r0,[r4,#0]            ;3395
0000a8  4661              MOV      r1,r12                ;3395
0000aa  f100024c          ADD      r2,r0,#0x4c           ;3395
0000ae  6aa0              LDR      r0,[r4,#0x28]         ;3395
0000b0  f7fffffe          BL       HAL_DMA_Start_IT
0000b4  e030              B        |L17.280|
                  |L17.182|
0000b6  6ae2              LDR      r2,[r4,#0x2c]         ;3401
0000b8  62d1              STR      r1,[r2,#0x2c]         ;3404
0000ba  6ae1              LDR      r1,[r4,#0x2c]         ;3404
0000bc  6348              STR      r0,[r1,#0x34]         ;3407
0000be  6820              LDR      r0,[r4,#0]            ;3407
0000c0  4661              MOV      r1,r12                ;3407
0000c2  f100024c          ADD      r2,r0,#0x4c           ;3407
0000c6  6ae0              LDR      r0,[r4,#0x2c]         ;3407
0000c8  f7fffffe          BL       HAL_DMA_Start_IT
0000cc  e024              B        |L17.280|
                  |L17.206|
0000ce  6b22              LDR      r2,[r4,#0x30]         ;3413
0000d0  62d1              STR      r1,[r2,#0x2c]         ;3416
0000d2  6b21              LDR      r1,[r4,#0x30]         ;3416
0000d4  6348              STR      r0,[r1,#0x34]         ;3419
0000d6  6820              LDR      r0,[r4,#0]            ;3419
0000d8  4661              MOV      r1,r12                ;3419
0000da  f100024c          ADD      r2,r0,#0x4c           ;3419
0000de  6b20              LDR      r0,[r4,#0x30]         ;3419
0000e0  f7fffffe          BL       HAL_DMA_Start_IT
0000e4  e018              B        |L17.280|
                  |L17.230|
0000e6  6b62              LDR      r2,[r4,#0x34]         ;3425
0000e8  4914              LDR      r1,|L17.316|
0000ea  62d1              STR      r1,[r2,#0x2c]         ;3428
0000ec  6b61              LDR      r1,[r4,#0x34]         ;3428
0000ee  6348              STR      r0,[r1,#0x34]         ;3431
0000f0  6820              LDR      r0,[r4,#0]            ;3431
0000f2  4661              MOV      r1,r12                ;3431
0000f4  f100024c          ADD      r2,r0,#0x4c           ;3431
0000f8  6b60              LDR      r0,[r4,#0x34]         ;3431
0000fa  f7fffffe          BL       HAL_DMA_Start_IT
0000fe  e00b              B        |L17.280|
                  |L17.256|
000100  6ba2              LDR      r2,[r4,#0x38]         ;3437
000102  490f              LDR      r1,|L17.320|
000104  62d1              STR      r1,[r2,#0x2c]         ;3440
000106  6ba1              LDR      r1,[r4,#0x38]         ;3440
000108  6348              STR      r0,[r1,#0x34]         ;3443
00010a  6820              LDR      r0,[r4,#0]            ;3443
00010c  4661              MOV      r1,r12                ;3443
00010e  f100024c          ADD      r2,r0,#0x4c           ;3443
000112  6ba0              LDR      r0,[r4,#0x38]         ;3443
000114  f7fffffe          BL       HAL_DMA_Start_IT
                  |L17.280|
000118  6821              LDR      r1,[r4,#0]            ;3450
00011a  ea480005          ORR      r0,r8,r5              ;3450
00011e  6488              STR      r0,[r1,#0x48]         ;3450
000120  6820              LDR      r0,[r4,#0]            ;3453
000122  68c1              LDR      r1,[r0,#0xc]          ;3453
000124  4331              ORRS     r1,r1,r6              ;3453
000126  60c1              STR      r1,[r0,#0xc]          ;3453
000128  6427              STR      r7,[r4,#0x40]         ;3455
00012a  2000              MOVS     r0,#0                 ;3458
00012c  e8bd81f0          POP      {r4-r8,pc}
;;;3460   
                          ENDP

                  |L17.304|
                          DCD      TIM_DMAError
                  |L17.308|
                          DCD      TIM_DMADelayPulseCplt
                  |L17.312|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L17.316|
                          DCD      TIMEx_DMACommutationCplt
                  |L17.320|
                          DCD      TIM_DMATriggerCplt

                          AREA ||i.HAL_TIM_DMABurst_WriteStop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_DMABurst_WriteStop PROC
;;;3466     */
;;;3467   HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
000000  b570              PUSH     {r4-r6,lr}
;;;3468   {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;3469     /* Check the parameters */
;;;3470     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3471   
;;;3472     /* Abort the DMA transfer (at least disable the DMA channel) */
;;;3473     switch(BurstRequestSrc)
000006  f5b16f00          CMP      r1,#0x800
;;;3474     {
;;;3475       case TIM_DMA_UPDATE:
;;;3476       {
;;;3477         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
;;;3478       }
;;;3479       break;
;;;3480       case TIM_DMA_CC1:
;;;3481       {
;;;3482         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
;;;3483       }
;;;3484       break;
;;;3485       case TIM_DMA_CC2:
;;;3486       {
;;;3487         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
;;;3488       }
;;;3489       break;
;;;3490       case TIM_DMA_CC3:
;;;3491       {
;;;3492         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
00000a  bf08              IT       EQ
00000c  6ae0              LDREQ    r0,[r4,#0x2c]
00000e  d021              BEQ      |L18.84|
000010  dc0f              BGT      |L18.50|
000012  f5b57f80          CMP      r5,#0x100             ;3473
000016  bf08              IT       EQ                    ;3477
000018  6a20              LDREQ    r0,[r4,#0x20]         ;3477
00001a  d01b              BEQ      |L18.84|
00001c  f5b57f00          CMP      r5,#0x200             ;3473
000020  bf08              IT       EQ                    ;3482
000022  6a60              LDREQ    r0,[r4,#0x24]         ;3482
000024  d016              BEQ      |L18.84|
000026  f5b56f80          CMP      r5,#0x400             ;3473
00002a  bf08              IT       EQ                    ;3487
00002c  6aa0              LDREQ    r0,[r4,#0x28]         ;3487
00002e  d011              BEQ      |L18.84|
000030  e012              B        |L18.88|
                  |L18.50|
000032  f5b55f80          CMP      r5,#0x1000            ;3473
;;;3493       }
;;;3494       break;
;;;3495       case TIM_DMA_CC4:
;;;3496       {
;;;3497         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
000036  bf08              IT       EQ
000038  6b20              LDREQ    r0,[r4,#0x30]
00003a  d00b              BEQ      |L18.84|
00003c  f5b55f00          CMP      r5,#0x2000            ;3473
;;;3498       }
;;;3499       break;
;;;3500       case TIM_DMA_COM:
;;;3501       {
;;;3502         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
000040  bf08              IT       EQ
000042  6b60              LDREQ    r0,[r4,#0x34]
000044  d006              BEQ      |L18.84|
000046  f5b54f80          CMP      r5,#0x4000            ;3473
;;;3503       }
;;;3504       break;
;;;3505       case TIM_DMA_TRIGGER:
;;;3506       {
;;;3507         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
00004a  bf04              ITT      EQ
00004c  6ba0              LDREQ    r0,[r4,#0x38]
00004e  f7fffffe          BLEQ     HAL_DMA_Abort
000052  e001              B        |L18.88|
                  |L18.84|
000054  f7fffffe          BL       HAL_DMA_Abort
                  |L18.88|
;;;3508       }
;;;3509       break;
;;;3510       default:
;;;3511       break;
;;;3512     }
;;;3513   
;;;3514     /* Disable the TIM Update DMA request */
;;;3515     __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
000058  6820              LDR      r0,[r4,#0]
00005a  68c1              LDR      r1,[r0,#0xc]
00005c  43a9              BICS     r1,r1,r5
00005e  60c1              STR      r1,[r0,#0xc]
;;;3516   
;;;3517     /* Return function status */
;;;3518     return HAL_OK;
000060  2000              MOVS     r0,#0
;;;3519   }
000062  bd70              POP      {r4-r6,pc}
;;;3520   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_DeInit PROC
;;;2344     */
;;;2345   HAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;2346   {
000002  4604              MOV      r4,r0
;;;2347     /* Check the parameters */
;;;2348     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;2349   
;;;2350     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  6420              STR      r0,[r4,#0x40]
;;;2351   
;;;2352     /* Disable the TIM Peripheral Clock */
;;;2353     __HAL_TIM_DISABLE(htim);
000008  6820              LDR      r0,[r4,#0]
00000a  6a01              LDR      r1,[r0,#0x20]
00000c  f2411211          MOV      r2,#0x1111
000010  4211              TST      r1,r2
000012  d107              BNE      |L19.36|
000014  6a01              LDR      r1,[r0,#0x20]
000016  1092              ASRS     r2,r2,#2
000018  4211              TST      r1,r2
00001a  d103              BNE      |L19.36|
00001c  6801              LDR      r1,[r0,#0]
00001e  f0210101          BIC      r1,r1,#1
000022  6001              STR      r1,[r0,#0]
                  |L19.36|
;;;2354   
;;;2355     /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;2356     HAL_TIM_Encoder_MspDeInit(htim);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       HAL_TIM_Encoder_MspDeInit
;;;2357   
;;;2358     /* Change TIM state */
;;;2359     htim->State = HAL_TIM_STATE_RESET;
00002a  2000              MOVS     r0,#0
00002c  6420              STR      r0,[r4,#0x40]
;;;2360   
;;;2361     /* Release Lock */
;;;2362     __HAL_UNLOCK(htim);
00002e  63e0              STR      r0,[r4,#0x3c]
;;;2363   
;;;2364     return HAL_OK;
;;;2365   }
000030  bd10              POP      {r4,pc}
;;;2366   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_GetState PROC
;;;4438     */
;;;4439   HAL_TIM_StateTypeDef HAL_TIM_Encoder_GetState(TIM_HandleTypeDef *htim)
000000  6c00              LDR      r0,[r0,#0x40]
;;;4440   {
;;;4441     return htim->State;
;;;4442   }
000002  4770              BX       lr
;;;4443   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Init PROC
;;;2251     */
;;;2252   HAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim,  TIM_Encoder_InitTypeDef* sConfig)
000000  2800              CMP      r0,#0
;;;2253   {
;;;2254     uint32_t tmpsmcr = 0U;
;;;2255     uint32_t tmpccmr1 = 0U;
;;;2256     uint32_t tmpccer = 0U;
;;;2257   
;;;2258     /* Check the TIM handle allocation */
;;;2259     if(htim == NULL)
;;;2260     {
;;;2261       return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;2262     }
;;;2263   
;;;2264     /* Check the parameters */
;;;2265     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2266     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;2267     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;2268     assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;2269     assert_param(IS_TIM_ENCODER_MODE(sConfig->EncoderMode));
;;;2270     assert_param(IS_TIM_IC_SELECTION(sConfig->IC1Selection));
;;;2271     assert_param(IS_TIM_IC_SELECTION(sConfig->IC2Selection));
;;;2272     assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
;;;2273     assert_param(IS_TIM_IC_POLARITY(sConfig->IC2Polarity));
;;;2274     assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
;;;2275     assert_param(IS_TIM_IC_PRESCALER(sConfig->IC2Prescaler));
;;;2276     assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
;;;2277     assert_param(IS_TIM_IC_FILTER(sConfig->IC2Filter));
;;;2278   
;;;2279     if(htim->State == HAL_TIM_STATE_RESET)
;;;2280     {
;;;2281       /* Allocate lock resource and initialize it */
;;;2282       htim->Lock = HAL_UNLOCKED;
;;;2283       
;;;2284       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;2285       HAL_TIM_Encoder_MspInit(htim);
;;;2286     }
;;;2287   
;;;2288     /* Set the TIM state */
;;;2289     htim->State= HAL_TIM_STATE_BUSY;
;;;2290   
;;;2291     /* Reset the SMS bits */
;;;2292     htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;2293   
;;;2294     /* Configure the Time base in the Encoder Mode */
;;;2295     TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;2296   
;;;2297     /* Get the TIMx SMCR register value */
;;;2298     tmpsmcr = htim->Instance->SMCR;
;;;2299   
;;;2300     /* Get the TIMx CCMR1 register value */
;;;2301     tmpccmr1 = htim->Instance->CCMR1;
;;;2302   
;;;2303     /* Get the TIMx CCER register value */
;;;2304     tmpccer = htim->Instance->CCER;
;;;2305   
;;;2306     /* Set the encoder Mode */
;;;2307     tmpsmcr |= sConfig->EncoderMode;
;;;2308   
;;;2309     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;2310     tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
;;;2311     tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8U));
;;;2312   
;;;2313     /* Set the the Capture Compare 1 and the Capture Compare 2 prescalers and filters */
;;;2314     tmpccmr1 &= ~(TIM_CCMR1_IC1PSC | TIM_CCMR1_IC2PSC);
;;;2315     tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
;;;2316     tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8U);
;;;2317     tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
;;;2318   
;;;2319     /* Set the TI1 and the TI2 Polarities */
;;;2320     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);
;;;2321     tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
;;;2322     tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4U);
;;;2323   
;;;2324     /* Write to TIMx SMCR */
;;;2325     htim->Instance->SMCR = tmpsmcr;
;;;2326   
;;;2327     /* Write to TIMx CCMR1 */
;;;2328     htim->Instance->CCMR1 = tmpccmr1;
;;;2329   
;;;2330     /* Write to TIMx CCER */
;;;2331     htim->Instance->CCER = tmpccer;
;;;2332   
;;;2333     /* Initialize the TIM state*/
;;;2334     htim->State= HAL_TIM_STATE_READY;
;;;2335   
;;;2336     return HAL_OK;
;;;2337   }
000006  4770              BXEQ     lr
000008  b570              PUSH     {r4-r6,lr}            ;2253
00000a  4604              MOV      r4,r0                 ;2253
00000c  6c00              LDR      r0,[r0,#0x40]         ;2279
00000e  460d              MOV      r5,r1                 ;2253
000010  b920              CBNZ     r0,|L21.28|
000012  2000              MOVS     r0,#0                 ;2282
000014  63e0              STR      r0,[r4,#0x3c]         ;2285
000016  4620              MOV      r0,r4                 ;2285
000018  f7fffffe          BL       HAL_TIM_Encoder_MspInit
                  |L21.28|
00001c  2002              MOVS     r0,#2                 ;2289
00001e  6420              STR      r0,[r4,#0x40]         ;2289
000020  6820              LDR      r0,[r4,#0]            ;2292
000022  6881              LDR      r1,[r0,#8]            ;2292
000024  f0210107          BIC      r1,r1,#7              ;2292
000028  6081              STR      r1,[r0,#8]            ;2292
00002a  1d21              ADDS     r1,r4,#4              ;2295
00002c  6820              LDR      r0,[r4,#0]            ;2295
00002e  f7fffffe          BL       TIM_Base_SetConfig
000032  6820              LDR      r0,[r4,#0]            ;2298
000034  6883              LDR      r3,[r0,#8]            ;2298
000036  6982              LDR      r2,[r0,#0x18]         ;2301
000038  6a01              LDR      r1,[r0,#0x20]         ;2304
00003a  f8d5c000          LDR      r12,[r5,#0]           ;2307
00003e  f0220203          BIC      r2,r2,#3              ;2310
000042  69ae              LDR      r6,[r5,#0x18]         ;2311
000044  ea4c0303          ORR      r3,r12,r3             ;2307
000048  f4227240          BIC      r2,r2,#0x300          ;2310
00004c  ea422206          ORR      r2,r2,r6,LSL #8       ;2311
000050  f8d5c008          LDR      r12,[r5,#8]           ;2311
000054  69ee              LDR      r6,[r5,#0x1c]         ;2316
000056  ea4c0202          ORR      r2,r12,r2             ;2311
00005a  f02202fc          BIC      r2,r2,#0xfc           ;2315
00005e  f422427c          BIC      r2,r2,#0xfc00         ;2315
000062  f8d5c00c          LDR      r12,[r5,#0xc]         ;2316
000066  ea422206          ORR      r2,r2,r6,LSL #8       ;2316
00006a  ea4c0202          ORR      r2,r12,r2             ;2316
00006e  f8d5c010          LDR      r12,[r5,#0x10]        ;2317
000072  6a2e              LDR      r6,[r5,#0x20]         ;2317
000074  ea4f1c0c          LSL      r12,r12,#4            ;2317
000078  ea4c3c06          ORR      r12,r12,r6,LSL #12    ;2317
00007c  ea4c0202          ORR      r2,r12,r2             ;2317
000080  f8d5c004          LDR      r12,[r5,#4]           ;2322
000084  696d              LDR      r5,[r5,#0x14]         ;2322
000086  f02101aa          BIC      r1,r1,#0xaa           ;2321
00008a  ea411105          ORR      r1,r1,r5,LSL #4       ;2322
00008e  ea4c0101          ORR      r1,r12,r1             ;2322
000092  6083              STR      r3,[r0,#8]            ;2325
000094  6820              LDR      r0,[r4,#0]            ;2328
000096  6182              STR      r2,[r0,#0x18]         ;2328
000098  6820              LDR      r0,[r4,#0]            ;2331
00009a  6201              STR      r1,[r0,#0x20]         ;2331
00009c  2001              MOVS     r0,#1                 ;2334
00009e  6420              STR      r0,[r4,#0x40]         ;2334
0000a0  2000              MOVS     r0,#0                 ;2336
0000a2  bd70              POP      {r4-r6,pc}
;;;2338   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_MspDeInit PROC
;;;2385     */
;;;2386   __weak void HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2387   {
;;;2388     /* Prevent unused argument(s) compilation warning */
;;;2389     UNUSED(htim);
;;;2390     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2391               the HAL_TIM_Encoder_MspDeInit could be implemented in the user file
;;;2392      */
;;;2393   }
;;;2394   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_MspInit PROC
;;;2371     */
;;;2372   __weak void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2373   {
;;;2374     /* Prevent unused argument(s) compilation warning */
;;;2375     UNUSED(htim);
;;;2376     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2377               the HAL_TIM_Encoder_MspInit could be implemented in the user file
;;;2378      */
;;;2379   }
;;;2380   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Start PROC
;;;2404   */
;;;2405   HAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  6802              LDR      r2,[r0,#0]
;;;2406   {
000002  b1c9              CBZ      r1,|L24.56|
;;;2407     /* Check the parameters */
;;;2408     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2409   
;;;2410     /* Enable the encoder interface channels */
;;;2411     switch (Channel)
000004  2904              CMP      r1,#4
000006  6a11              LDR      r1,[r2,#0x20]
000008  d01e              BEQ      |L24.72|
00000a  f0210101          BIC      r1,r1,#1
00000e  6211              STR      r1,[r2,#0x20]
000010  6a11              LDR      r1,[r2,#0x20]
000012  f0410101          ORR      r1,r1,#1
000016  6211              STR      r1,[r2,#0x20]
000018  6801              LDR      r1,[r0,#0]
00001a  6a0a              LDR      r2,[r1,#0x20]
00001c  f0220210          BIC      r2,r2,#0x10
000020  620a              STR      r2,[r1,#0x20]
000022  6a0a              LDR      r2,[r1,#0x20]
000024  f0420210          ORR      r2,r2,#0x10
000028  620a              STR      r2,[r1,#0x20]
                  |L24.42|
;;;2412     {
;;;2413       case TIM_CHANNEL_1:
;;;2414     {
;;;2415       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2416         break;
;;;2417     }
;;;2418       case TIM_CHANNEL_2:
;;;2419     {
;;;2420       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2421         break;
;;;2422     }
;;;2423       default :
;;;2424     {
;;;2425        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2426        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2427        break;
;;;2428       }
;;;2429     }
;;;2430     /* Enable the Peripheral */
;;;2431     __HAL_TIM_ENABLE(htim);
00002a  6800              LDR      r0,[r0,#0]
00002c  6801              LDR      r1,[r0,#0]
00002e  f0410101          ORR      r1,r1,#1
000032  6001              STR      r1,[r0,#0]
;;;2432   
;;;2433     /* Return function status */
;;;2434     return HAL_OK;
000034  2000              MOVS     r0,#0
;;;2435   }
000036  4770              BX       lr
                  |L24.56|
000038  6a11              LDR      r1,[r2,#0x20]
00003a  f0210101          BIC      r1,r1,#1
00003e  6211              STR      r1,[r2,#0x20]
000040  6a11              LDR      r1,[r2,#0x20]
000042  f0410101          ORR      r1,r1,#1
000046  e005              B        |L24.84|
                  |L24.72|
000048  f0210110          BIC      r1,r1,#0x10           ;2416
00004c  6211              STR      r1,[r2,#0x20]         ;2416
00004e  6a11              LDR      r1,[r2,#0x20]         ;2416
000050  f0410110          ORR      r1,r1,#0x10           ;2416
                  |L24.84|
000054  6211              STR      r1,[r2,#0x20]         ;2416
000056  e7e8              B        |L24.42|
;;;2436   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Encoder_Start_DMA PROC
;;;2592   */
;;;2593   HAL_StatusTypeDef HAL_TIM_Encoder_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData1, uint32_t *pData2, uint16_t Length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2594   {
000004  4604              MOV      r4,r0
;;;2595     /* Check the parameters */
;;;2596     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;2597   
;;;2598     if((htim->State == HAL_TIM_STATE_BUSY))
000006  f8dd8018          LDR      r8,[sp,#0x18]
00000a  6c00              LDR      r0,[r0,#0x40]
00000c  461e              MOV      r6,r3                 ;2594
00000e  2802              CMP      r0,#2
;;;2599     {
;;;2600        return HAL_BUSY;
;;;2601     }
;;;2602     else if((htim->State == HAL_TIM_STATE_READY))
;;;2603     {
;;;2604       if((((pData1 == 0U) || (pData2 == 0U) )) && (Length > 0U))
;;;2605       {
;;;2606         return HAL_ERROR;
;;;2607       }
;;;2608       else
;;;2609       {
;;;2610         htim->State = HAL_TIM_STATE_BUSY;
;;;2611       }
;;;2612     }
;;;2613   
;;;2614     switch (Channel)
;;;2615     {
;;;2616       case TIM_CHANNEL_1:
;;;2617       {
;;;2618         /* Set the DMA Period elapsed callback */
;;;2619         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2620   
;;;2621         /* Set the DMA error callback */
;;;2622         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;2623   
;;;2624         /* Enable the DMA channel */
;;;2625         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t )pData1, Length);
;;;2626   
;;;2627         /* Enable the TIM Input Capture DMA request */
;;;2628         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;2629   
;;;2630         /* Enable the Peripheral */
;;;2631         __HAL_TIM_ENABLE(htim);
;;;2632   
;;;2633         /* Enable the Capture compare channel */
;;;2634         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2635       }
;;;2636       break;
;;;2637   
;;;2638       case TIM_CHANNEL_2:
;;;2639       {
;;;2640         /* Set the DMA Period elapsed callback */
;;;2641         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2642   
;;;2643         /* Set the DMA error callback */
;;;2644         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError;
;;;2645         /* Enable the DMA channel */
;;;2646         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
;;;2647   
;;;2648         /* Enable the TIM Input Capture  DMA request */
;;;2649         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;2650   
;;;2651         /* Enable the Peripheral */
;;;2652         __HAL_TIM_ENABLE(htim);
;;;2653   
;;;2654         /* Enable the Capture compare channel */
;;;2655         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2656       }
;;;2657       break;
;;;2658   
;;;2659       case TIM_CHANNEL_ALL:
;;;2660       {
;;;2661         /* Set the DMA Period elapsed callback */
;;;2662         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2663   
;;;2664         /* Set the DMA error callback */
;;;2665         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;2666   
;;;2667         /* Enable the DMA channel */
;;;2668         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length);
;;;2669   
;;;2670         /* Set the DMA Period elapsed callback */
;;;2671         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2672   
;;;2673         /* Set the DMA error callback */
;;;2674         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;2675   
;;;2676         /* Enable the DMA channel */
;;;2677         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
;;;2678   
;;;2679        /* Enable the Peripheral */
;;;2680         __HAL_TIM_ENABLE(htim);
;;;2681   
;;;2682         /* Enable the Capture compare channel */
;;;2683         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2684         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2685   
;;;2686         /* Enable the TIM Input Capture  DMA request */
;;;2687         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;2688         /* Enable the TIM Input Capture  DMA request */
;;;2689         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;2690       }
;;;2691       break;
;;;2692   
;;;2693       default:
;;;2694       break;
;;;2695     }
;;;2696     /* Return function status */
;;;2697     return HAL_OK;
;;;2698   }
000010  bf08              IT       EQ
000012  e8bd81f0          POPEQ    {r4-r8,pc}
000016  6c20              LDR      r0,[r4,#0x40]         ;2602
000018  2801              CMP      r0,#1                 ;2602
00001a  d10b              BNE      |L25.52|
00001c  2a00              CMP      r2,#0                 ;2604
00001e  bf18              IT       NE                    ;2604
000020  2e00              CMPNE    r6,#0                 ;2604
000022  d105              BNE      |L25.48|
000024  f1b80f00          CMP      r8,#0                 ;2604
000028  bf1c              ITT      NE                    ;2606
00002a  2001              MOVNE    r0,#1                 ;2606
00002c  e8bd81f0          POPNE    {r4-r8,pc}
                  |L25.48|
000030  2002              MOVS     r0,#2                 ;2610
000032  6420              STR      r0,[r4,#0x40]         ;2610
                  |L25.52|
000034  4d40              LDR      r5,|L25.312|
000036  4f41              LDR      r7,|L25.316|
000038  b121              CBZ      r1,|L25.68|
00003a  2904              CMP      r1,#4                 ;2614
00003c  d020              BEQ      |L25.128|
00003e  2918              CMP      r1,#0x18              ;2614
000040  d03e              BEQ      |L25.192|
000042  e075              B        |L25.304|
                  |L25.68|
000044  6a60              LDR      r0,[r4,#0x24]         ;2619
000046  4643              MOV      r3,r8                 ;2625
000048  62c5              STR      r5,[r0,#0x2c]         ;2622
00004a  6a60              LDR      r0,[r4,#0x24]         ;2622
00004c  6347              STR      r7,[r0,#0x34]         ;2625
00004e  6820              LDR      r0,[r4,#0]            ;2625
000050  f1000134          ADD      r1,r0,#0x34           ;2625
000054  6a60              LDR      r0,[r4,#0x24]         ;2625
000056  f7fffffe          BL       HAL_DMA_Start_IT
00005a  6820              LDR      r0,[r4,#0]            ;2628
00005c  68c1              LDR      r1,[r0,#0xc]          ;2628
00005e  f4417100          ORR      r1,r1,#0x200          ;2628
000062  60c1              STR      r1,[r0,#0xc]          ;2628
000064  6820              LDR      r0,[r4,#0]            ;2631
000066  6801              LDR      r1,[r0,#0]            ;2631
000068  f0410101          ORR      r1,r1,#1              ;2631
00006c  6001              STR      r1,[r0,#0]            ;2631
00006e  6820              LDR      r0,[r4,#0]            ;2631
000070  6a01              LDR      r1,[r0,#0x20]         ;2631
000072  f0210101          BIC      r1,r1,#1              ;2631
000076  6201              STR      r1,[r0,#0x20]         ;2631
000078  6a01              LDR      r1,[r0,#0x20]         ;2631
00007a  f0410101          ORR      r1,r1,#1              ;2631
00007e  e01d              B        |L25.188|
                  |L25.128|
000080  6aa0              LDR      r0,[r4,#0x28]         ;2641
000082  4643              MOV      r3,r8                 ;2646
000084  4632              MOV      r2,r6                 ;2646
000086  62c5              STR      r5,[r0,#0x2c]         ;2644
000088  6aa0              LDR      r0,[r4,#0x28]         ;2644
00008a  6347              STR      r7,[r0,#0x34]         ;2646
00008c  6820              LDR      r0,[r4,#0]            ;2646
00008e  f1000138          ADD      r1,r0,#0x38           ;2646
000092  6aa0              LDR      r0,[r4,#0x28]         ;2646
000094  f7fffffe          BL       HAL_DMA_Start_IT
000098  6820              LDR      r0,[r4,#0]            ;2649
00009a  68c1              LDR      r1,[r0,#0xc]          ;2649
00009c  f4416180          ORR      r1,r1,#0x400          ;2649
0000a0  60c1              STR      r1,[r0,#0xc]          ;2649
0000a2  6820              LDR      r0,[r4,#0]            ;2652
0000a4  6801              LDR      r1,[r0,#0]            ;2652
0000a6  f0410101          ORR      r1,r1,#1              ;2652
0000aa  6001              STR      r1,[r0,#0]            ;2652
0000ac  6820              LDR      r0,[r4,#0]            ;2652
0000ae  6a01              LDR      r1,[r0,#0x20]         ;2652
0000b0  f0210110          BIC      r1,r1,#0x10           ;2652
0000b4  6201              STR      r1,[r0,#0x20]         ;2652
0000b6  6a01              LDR      r1,[r0,#0x20]         ;2652
0000b8  f0410110          ORR      r1,r1,#0x10           ;2652
                  |L25.188|
0000bc  6201              STR      r1,[r0,#0x20]         ;2652
0000be  e037              B        |L25.304|
                  |L25.192|
0000c0  6a60              LDR      r0,[r4,#0x24]         ;2662
0000c2  4643              MOV      r3,r8                 ;2668
0000c4  62c5              STR      r5,[r0,#0x2c]         ;2665
0000c6  6a60              LDR      r0,[r4,#0x24]         ;2665
0000c8  6347              STR      r7,[r0,#0x34]         ;2668
0000ca  6820              LDR      r0,[r4,#0]            ;2668
0000cc  f1000134          ADD      r1,r0,#0x34           ;2668
0000d0  6a60              LDR      r0,[r4,#0x24]         ;2668
0000d2  f7fffffe          BL       HAL_DMA_Start_IT
0000d6  6aa0              LDR      r0,[r4,#0x28]         ;2671
0000d8  4643              MOV      r3,r8                 ;2677
0000da  4632              MOV      r2,r6                 ;2677
0000dc  62c5              STR      r5,[r0,#0x2c]         ;2674
0000de  6aa0              LDR      r0,[r4,#0x28]         ;2674
0000e0  6347              STR      r7,[r0,#0x34]         ;2677
0000e2  6820              LDR      r0,[r4,#0]            ;2677
0000e4  f1000138          ADD      r1,r0,#0x38           ;2677
0000e8  6aa0              LDR      r0,[r4,#0x28]         ;2677
0000ea  f7fffffe          BL       HAL_DMA_Start_IT
0000ee  6820              LDR      r0,[r4,#0]            ;2680
0000f0  6801              LDR      r1,[r0,#0]            ;2680
0000f2  f0410101          ORR      r1,r1,#1              ;2680
0000f6  6001              STR      r1,[r0,#0]            ;2680
0000f8  6820              LDR      r0,[r4,#0]            ;2680
0000fa  6a01              LDR      r1,[r0,#0x20]         ;2680
0000fc  f0210101          BIC      r1,r1,#1              ;2680
000100  6201              STR      r1,[r0,#0x20]         ;2680
000102  6a01              LDR      r1,[r0,#0x20]         ;2680
000104  f0410101          ORR      r1,r1,#1              ;2680
000108  6201              STR      r1,[r0,#0x20]         ;2680
00010a  6820              LDR      r0,[r4,#0]            ;2680
00010c  6a01              LDR      r1,[r0,#0x20]         ;2680
00010e  f0210110          BIC      r1,r1,#0x10           ;2680
000112  6201              STR      r1,[r0,#0x20]         ;2680
000114  6a01              LDR      r1,[r0,#0x20]         ;2680
000116  f0410110          ORR      r1,r1,#0x10           ;2680
00011a  6201              STR      r1,[r0,#0x20]         ;2680
00011c  6820              LDR      r0,[r4,#0]            ;2687
00011e  68c1              LDR      r1,[r0,#0xc]          ;2687
000120  f4417100          ORR      r1,r1,#0x200          ;2687
000124  60c1              STR      r1,[r0,#0xc]          ;2687
000126  6820              LDR      r0,[r4,#0]            ;2689
000128  68c1              LDR      r1,[r0,#0xc]          ;2689
00012a  f4416180          ORR      r1,r1,#0x400          ;2689
00012e  60c1              STR      r1,[r0,#0xc]          ;2689
                  |L25.304|
000130  2000              MOVS     r0,#0                 ;2697
000132  e8bd81f0          POP      {r4-r8,pc}
;;;2699   
                          ENDP

000136  0000              DCW      0x0000
                  |L25.312|
                          DCD      TIM_DMACaptureCplt
                  |L25.316|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_Encoder_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Start_IT PROC
;;;2490   */
;;;2491   HAL_StatusTypeDef HAL_TIM_Encoder_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  6802              LDR      r2,[r0,#0]
;;;2492   {
000002  b319              CBZ      r1,|L26.76|
;;;2493     /* Check the parameters */
;;;2494     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2495   
;;;2496     /* Enable the encoder interface channels */
;;;2497     /* Enable the capture compare Interrupts 1 and/or 2 */
;;;2498     switch (Channel)
000004  2904              CMP      r1,#4
000006  6a11              LDR      r1,[r2,#0x20]
000008  d02d              BEQ      |L26.102|
00000a  f0210101          BIC      r1,r1,#1
00000e  6211              STR      r1,[r2,#0x20]
000010  6a11              LDR      r1,[r2,#0x20]
000012  f0410101          ORR      r1,r1,#1
000016  6211              STR      r1,[r2,#0x20]
000018  6801              LDR      r1,[r0,#0]
00001a  6a0a              LDR      r2,[r1,#0x20]
00001c  f0220210          BIC      r2,r2,#0x10
000020  620a              STR      r2,[r1,#0x20]
000022  6a0a              LDR      r2,[r1,#0x20]
000024  f0420210          ORR      r2,r2,#0x10
000028  620a              STR      r2,[r1,#0x20]
;;;2499     {
;;;2500       case TIM_CHANNEL_1:
;;;2501     {
;;;2502       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2503       __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
;;;2504         break;
;;;2505     }
;;;2506       case TIM_CHANNEL_2:
;;;2507     {
;;;2508       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2509       __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
;;;2510         break;
;;;2511     }
;;;2512       default :
;;;2513     {
;;;2514        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2515        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2516        __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
00002a  6801              LDR      r1,[r0,#0]
00002c  68ca              LDR      r2,[r1,#0xc]
00002e  f0420202          ORR      r2,r2,#2
000032  60ca              STR      r2,[r1,#0xc]
;;;2517        __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000034  6801              LDR      r1,[r0,#0]
000036  68ca              LDR      r2,[r1,#0xc]
000038  f0420204          ORR      r2,r2,#4
00003c  60ca              STR      r2,[r1,#0xc]
                  |L26.62|
;;;2518        break;
;;;2519       }
;;;2520     }
;;;2521   
;;;2522     /* Enable the Peripheral */
;;;2523     __HAL_TIM_ENABLE(htim);
00003e  6800              LDR      r0,[r0,#0]
000040  6801              LDR      r1,[r0,#0]
000042  f0410101          ORR      r1,r1,#1
000046  6001              STR      r1,[r0,#0]
;;;2524   
;;;2525     /* Return function status */
;;;2526     return HAL_OK;
000048  2000              MOVS     r0,#0
;;;2527   }
00004a  4770              BX       lr
                  |L26.76|
00004c  6a11              LDR      r1,[r2,#0x20]
00004e  f0210101          BIC      r1,r1,#1
000052  6211              STR      r1,[r2,#0x20]
000054  6a11              LDR      r1,[r2,#0x20]
000056  f0410101          ORR      r1,r1,#1
00005a  6211              STR      r1,[r2,#0x20]
00005c  6801              LDR      r1,[r0,#0]            ;2503
00005e  68ca              LDR      r2,[r1,#0xc]          ;2503
000060  f0420202          ORR      r2,r2,#2              ;2503
000064  e00a              B        |L26.124|
                  |L26.102|
000066  f0210110          BIC      r1,r1,#0x10           ;2504
00006a  6211              STR      r1,[r2,#0x20]         ;2504
00006c  6a11              LDR      r1,[r2,#0x20]         ;2504
00006e  f0410110          ORR      r1,r1,#0x10           ;2504
000072  6211              STR      r1,[r2,#0x20]         ;2504
000074  6801              LDR      r1,[r0,#0]            ;2509
000076  68ca              LDR      r2,[r1,#0xc]          ;2509
000078  f0420204          ORR      r2,r2,#4              ;2509
                  |L26.124|
00007c  60ca              STR      r2,[r1,#0xc]          ;2503
00007e  e7de              B        |L26.62|
;;;2528   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Stop PROC
;;;2446   */
;;;2447   HAL_StatusTypeDef HAL_TIM_Encoder_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  6802              LDR      r2,[r0,#0]
;;;2448   {
000002  b1f1              CBZ      r1,|L27.66|
;;;2449     /* Check the parameters */
;;;2450       assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2451   
;;;2452      /* Disable the Input Capture channels 1 and 2
;;;2453       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
;;;2454     switch (Channel)
000004  2904              CMP      r1,#4
000006  6a11              LDR      r1,[r2,#0x20]
000008  d022              BEQ      |L27.80|
00000a  f0210101          BIC      r1,r1,#1
00000e  6211              STR      r1,[r2,#0x20]
000010  6a11              LDR      r1,[r2,#0x20]
000012  6211              STR      r1,[r2,#0x20]
000014  6801              LDR      r1,[r0,#0]
000016  6a0a              LDR      r2,[r1,#0x20]
000018  f0220210          BIC      r2,r2,#0x10
00001c  620a              STR      r2,[r1,#0x20]
00001e  6a0a              LDR      r2,[r1,#0x20]
000020  620a              STR      r2,[r1,#0x20]
                  |L27.34|
;;;2455     {
;;;2456       case TIM_CHANNEL_1:
;;;2457     {
;;;2458        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
;;;2459         break;
;;;2460     }
;;;2461       case TIM_CHANNEL_2:
;;;2462     {
;;;2463       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
;;;2464         break;
;;;2465     }
;;;2466       default :
;;;2467     {
;;;2468       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
;;;2469       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
;;;2470        break;
;;;2471       }
;;;2472     }
;;;2473   
;;;2474     /* Disable the Peripheral */
;;;2475     __HAL_TIM_DISABLE(htim);
000022  6800              LDR      r0,[r0,#0]
000024  6a01              LDR      r1,[r0,#0x20]
000026  f2411211          MOV      r2,#0x1111
00002a  4211              TST      r1,r2
00002c  d107              BNE      |L27.62|
00002e  6a01              LDR      r1,[r0,#0x20]
000030  1092              ASRS     r2,r2,#2
000032  4211              TST      r1,r2
000034  d103              BNE      |L27.62|
000036  6801              LDR      r1,[r0,#0]
000038  f0210101          BIC      r1,r1,#1
00003c  6001              STR      r1,[r0,#0]
                  |L27.62|
;;;2476   
;;;2477     /* Return function status */
;;;2478     return HAL_OK;
00003e  2000              MOVS     r0,#0
;;;2479   }
000040  4770              BX       lr
                  |L27.66|
000042  6a11              LDR      r1,[r2,#0x20]
000044  f0210101          BIC      r1,r1,#1
000048  6211              STR      r1,[r2,#0x20]
00004a  6a11              LDR      r1,[r2,#0x20]
00004c  6211              STR      r1,[r2,#0x20]
00004e  e7e8              B        |L27.34|
                  |L27.80|
000050  f0210110          BIC      r1,r1,#0x10           ;2459
000054  6211              STR      r1,[r2,#0x20]         ;2459
000056  6a11              LDR      r1,[r2,#0x20]         ;2459
000058  6211              STR      r1,[r2,#0x20]         ;2459
00005a  e7e2              B        |L27.34|
;;;2480   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Stop_DMA PROC
;;;2709   */
;;;2710   HAL_StatusTypeDef HAL_TIM_Encoder_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  6802              LDR      r2,[r0,#0]
000002  2301              MOVS     r3,#1
;;;2711   {
000004  b361              CBZ      r1,|L28.96|
;;;2712     /* Check the parameters */
;;;2713     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;2714   
;;;2715     /* Disable the Input Capture channels 1 and 2
;;;2716       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
;;;2717     if(Channel == TIM_CHANNEL_1)
;;;2718     {
;;;2719       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
;;;2720   
;;;2721       /* Disable the capture compare DMA Request 1 */
;;;2722       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
;;;2723     }
;;;2724     else if(Channel == TIM_CHANNEL_2)
000006  2904              CMP      r1,#4
000008  6a11              LDR      r1,[r2,#0x20]
00000a  d034              BEQ      |L28.118|
00000c  f0210101          BIC      r1,r1,#1
000010  6211              STR      r1,[r2,#0x20]
000012  6a11              LDR      r1,[r2,#0x20]
000014  6211              STR      r1,[r2,#0x20]
000016  6801              LDR      r1,[r0,#0]
000018  6a0a              LDR      r2,[r1,#0x20]
00001a  f0220210          BIC      r2,r2,#0x10
00001e  620a              STR      r2,[r1,#0x20]
000020  6a0a              LDR      r2,[r1,#0x20]
000022  620a              STR      r2,[r1,#0x20]
;;;2725     {
;;;2726       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
;;;2727   
;;;2728       /* Disable the capture compare DMA Request 2 */
;;;2729       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
;;;2730     }
;;;2731     else
;;;2732     {
;;;2733       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
;;;2734       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
;;;2735   
;;;2736       /* Disable the capture compare DMA Request 1 and 2 */
;;;2737       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000024  6801              LDR      r1,[r0,#0]
000026  68ca              LDR      r2,[r1,#0xc]
000028  f4227200          BIC      r2,r2,#0x200
00002c  60ca              STR      r2,[r1,#0xc]
;;;2738       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
00002e  6801              LDR      r1,[r0,#0]
000030  68ca              LDR      r2,[r1,#0xc]
000032  f4226280          BIC      r2,r2,#0x400
000036  60ca              STR      r2,[r1,#0xc]
                  |L28.56|
;;;2739     }
;;;2740   
;;;2741     /* Disable the Peripheral */
;;;2742     __HAL_TIM_DISABLE(htim);
000038  6801              LDR      r1,[r0,#0]
00003a  6a0a              LDR      r2,[r1,#0x20]
00003c  f2411c11          MOV      r12,#0x1111
000040  ea120f0c          TST      r2,r12
000044  d109              BNE      |L28.90|
000046  6a0a              LDR      r2,[r1,#0x20]
000048  f2404c44          MOV      r12,#0x444
00004c  ea120f0c          TST      r2,r12
000050  d103              BNE      |L28.90|
000052  680a              LDR      r2,[r1,#0]
000054  f0220201          BIC      r2,r2,#1
000058  600a              STR      r2,[r1,#0]
                  |L28.90|
;;;2743   
;;;2744     /* Change the htim state */
;;;2745     htim->State = HAL_TIM_STATE_READY;
00005a  6403              STR      r3,[r0,#0x40]
;;;2746   
;;;2747     /* Return function status */
;;;2748     return HAL_OK;
00005c  2000              MOVS     r0,#0
;;;2749   }
00005e  4770              BX       lr
                  |L28.96|
000060  6a11              LDR      r1,[r2,#0x20]
000062  f0210101          BIC      r1,r1,#1
000066  6211              STR      r1,[r2,#0x20]
000068  6a11              LDR      r1,[r2,#0x20]
00006a  6211              STR      r1,[r2,#0x20]
00006c  6801              LDR      r1,[r0,#0]            ;2722
00006e  68ca              LDR      r2,[r1,#0xc]          ;2722
000070  f4227200          BIC      r2,r2,#0x200          ;2722
000074  e008              B        |L28.136|
                  |L28.118|
000076  f0210110          BIC      r1,r1,#0x10           ;2722
00007a  6211              STR      r1,[r2,#0x20]         ;2722
00007c  6a11              LDR      r1,[r2,#0x20]         ;2722
00007e  6211              STR      r1,[r2,#0x20]         ;2722
000080  6801              LDR      r1,[r0,#0]            ;2729
000082  68ca              LDR      r2,[r1,#0xc]          ;2729
000084  f4226280          BIC      r2,r2,#0x400          ;2729
                  |L28.136|
000088  60ca              STR      r2,[r1,#0xc]          ;2729
00008a  e7d5              B        |L28.56|
;;;2750   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Stop_IT PROC
;;;2538   */
;;;2539   HAL_StatusTypeDef HAL_TIM_Encoder_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  6802              LDR      r2,[r0,#0]
000002  2301              MOVS     r3,#1
;;;2540   {
000004  b361              CBZ      r1,|L29.96|
;;;2541     /* Check the parameters */
;;;2542     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2543   
;;;2544     /* Disable the Input Capture channels 1 and 2
;;;2545       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
;;;2546     if(Channel == TIM_CHANNEL_1)
;;;2547     {
;;;2548       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
;;;2549   
;;;2550       /* Disable the capture compare Interrupts 1 */
;;;2551     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
;;;2552     }
;;;2553     else if(Channel == TIM_CHANNEL_2)
000006  2904              CMP      r1,#4
000008  6a11              LDR      r1,[r2,#0x20]
00000a  d034              BEQ      |L29.118|
00000c  f0210101          BIC      r1,r1,#1
000010  6211              STR      r1,[r2,#0x20]
000012  6a11              LDR      r1,[r2,#0x20]
000014  6211              STR      r1,[r2,#0x20]
000016  6801              LDR      r1,[r0,#0]
000018  6a0a              LDR      r2,[r1,#0x20]
00001a  f0220210          BIC      r2,r2,#0x10
00001e  620a              STR      r2,[r1,#0x20]
000020  6a0a              LDR      r2,[r1,#0x20]
000022  620a              STR      r2,[r1,#0x20]
;;;2554     {
;;;2555       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
;;;2556   
;;;2557       /* Disable the capture compare Interrupts 2 */
;;;2558     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
;;;2559     }
;;;2560     else
;;;2561     {
;;;2562       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
;;;2563       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
;;;2564   
;;;2565       /* Disable the capture compare Interrupts 1 and 2 */
;;;2566       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000024  6801              LDR      r1,[r0,#0]
000026  68ca              LDR      r2,[r1,#0xc]
000028  f0220202          BIC      r2,r2,#2
00002c  60ca              STR      r2,[r1,#0xc]
;;;2567       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00002e  6801              LDR      r1,[r0,#0]
000030  68ca              LDR      r2,[r1,#0xc]
000032  f0220204          BIC      r2,r2,#4
000036  60ca              STR      r2,[r1,#0xc]
                  |L29.56|
;;;2568     }
;;;2569   
;;;2570     /* Disable the Peripheral */
;;;2571     __HAL_TIM_DISABLE(htim);
000038  6801              LDR      r1,[r0,#0]
00003a  6a0a              LDR      r2,[r1,#0x20]
00003c  f2411c11          MOV      r12,#0x1111
000040  ea120f0c          TST      r2,r12
000044  d109              BNE      |L29.90|
000046  6a0a              LDR      r2,[r1,#0x20]
000048  f2404c44          MOV      r12,#0x444
00004c  ea120f0c          TST      r2,r12
000050  d103              BNE      |L29.90|
000052  680a              LDR      r2,[r1,#0]
000054  f0220201          BIC      r2,r2,#1
000058  600a              STR      r2,[r1,#0]
                  |L29.90|
;;;2572   
;;;2573     /* Change the htim state */
;;;2574     htim->State = HAL_TIM_STATE_READY;
00005a  6403              STR      r3,[r0,#0x40]
;;;2575   
;;;2576     /* Return function status */
;;;2577     return HAL_OK;
00005c  2000              MOVS     r0,#0
;;;2578   }
00005e  4770              BX       lr
                  |L29.96|
000060  6a11              LDR      r1,[r2,#0x20]
000062  f0210101          BIC      r1,r1,#1
000066  6211              STR      r1,[r2,#0x20]
000068  6a11              LDR      r1,[r2,#0x20]
00006a  6211              STR      r1,[r2,#0x20]
00006c  6801              LDR      r1,[r0,#0]            ;2551
00006e  68ca              LDR      r2,[r1,#0xc]          ;2551
000070  f0220202          BIC      r2,r2,#2              ;2551
000074  e008              B        |L29.136|
                  |L29.118|
000076  f0210110          BIC      r1,r1,#0x10           ;2551
00007a  6211              STR      r1,[r2,#0x20]         ;2551
00007c  6a11              LDR      r1,[r2,#0x20]         ;2551
00007e  6211              STR      r1,[r2,#0x20]         ;2551
000080  6801              LDR      r1,[r0,#0]            ;2558
000082  68ca              LDR      r2,[r1,#0xc]          ;2558
000084  f0220204          BIC      r2,r2,#4              ;2558
                  |L29.136|
000088  60ca              STR      r2,[r1,#0xc]          ;2558
00008a  e7d5              B        |L29.56|
;;;2579   
                          ENDP


                          AREA ||i.HAL_TIM_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ErrorCallback PROC
;;;4355     */
;;;4356   __weak void HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4357   {
;;;4358     /* Prevent unused argument(s) compilation warning */
;;;4359     UNUSED(htim);
;;;4360     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4361               the HAL_TIM_ErrorCallback could be implemented in the user file
;;;4362      */
;;;4363   }
;;;4364   
                          ENDP


                          AREA ||i.HAL_TIM_GenerateEvent||, CODE, READONLY, ALIGN=1

                  HAL_TIM_GenerateEvent PROC
;;;3762   
;;;3763   HAL_StatusTypeDef HAL_TIM_GenerateEvent(TIM_HandleTypeDef *htim, uint32_t EventSource)
000000  6bc2              LDR      r2,[r0,#0x3c]
;;;3764   {
;;;3765     /* Check the parameters */
;;;3766     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;3767     assert_param(IS_TIM_EVENT_SOURCE(EventSource));
;;;3768   
;;;3769     /* Process Locked */
;;;3770     __HAL_LOCK(htim);
000002  2a01              CMP      r2,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;3771   
;;;3772     /* Change the TIM state */
;;;3773     htim->State = HAL_TIM_STATE_BUSY;
;;;3774   
;;;3775     /* Set the event sources */
;;;3776     htim->Instance->EGR = EventSource;
;;;3777   
;;;3778     /* Change the TIM state */
;;;3779     htim->State = HAL_TIM_STATE_READY;
;;;3780   
;;;3781     __HAL_UNLOCK(htim);
;;;3782   
;;;3783     /* Return function status */
;;;3784     return HAL_OK;
;;;3785   }
000008  4770              BXEQ     lr
00000a  2201              MOVS     r2,#1                 ;3770
00000c  2302              MOVS     r3,#2                 ;3773
00000e  6403              STR      r3,[r0,#0x40]         ;3773
000010  6803              LDR      r3,[r0,#0]            ;3776
000012  6159              STR      r1,[r3,#0x14]         ;3776
000014  6402              STR      r2,[r0,#0x40]         ;3779
000016  2100              MOVS     r1,#0                 ;3781
000018  63c1              STR      r1,[r0,#0x3c]         ;3784
00001a  4608              MOV      r0,r1                 ;3784
00001c  4770              BX       lr
;;;3786   
                          ENDP


                          AREA ||i.HAL_TIM_IC_CaptureCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_CaptureCallback PROC
;;;4313     */
;;;4314   __weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4315   {
;;;4316     /* Prevent unused argument(s) compilation warning */
;;;4317     UNUSED(htim);
;;;4318     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4319               the __HAL_TIM_IC_CaptureCallback could be implemented in the user file
;;;4320      */
;;;4321   }
;;;4322   
                          ENDP


                          AREA ||i.HAL_TIM_IC_ConfigChannel||, CODE, READONLY, ALIGN=2

                  HAL_TIM_IC_ConfigChannel PROC
;;;3003     */
;;;3004   HAL_StatusTypeDef HAL_TIM_IC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_IC_InitTypeDef* sConfig, uint32_t Channel)
000000  6bc3              LDR      r3,[r0,#0x3c]
;;;3005   {
;;;3006     /* Check the parameters */
;;;3007     assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3008     assert_param(IS_TIM_IC_POLARITY(sConfig->ICPolarity));
;;;3009     assert_param(IS_TIM_IC_SELECTION(sConfig->ICSelection));
;;;3010     assert_param(IS_TIM_IC_PRESCALER(sConfig->ICPrescaler));
;;;3011     assert_param(IS_TIM_IC_FILTER(sConfig->ICFilter));
;;;3012   
;;;3013     __HAL_LOCK(htim);
000002  2b01              CMP      r3,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;3014   
;;;3015     htim->State = HAL_TIM_STATE_BUSY;
;;;3016   
;;;3017     if (Channel == TIM_CHANNEL_1)
;;;3018     {
;;;3019       /* TI1 Configuration */
;;;3020       TIM_TI1_SetConfig(htim->Instance,
;;;3021                  sConfig->ICPolarity,
;;;3022                  sConfig->ICSelection,
;;;3023                  sConfig->ICFilter);
;;;3024   
;;;3025       /* Reset the IC1PSC Bits */
;;;3026       htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
;;;3027   
;;;3028       /* Set the IC1PSC value */
;;;3029       htim->Instance->CCMR1 |= sConfig->ICPrescaler;
;;;3030     }
;;;3031     else if (Channel == TIM_CHANNEL_2)
;;;3032     {
;;;3033       /* TI2 Configuration */
;;;3034       assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3035   
;;;3036       TIM_TI2_SetConfig(htim->Instance,
;;;3037                         sConfig->ICPolarity,
;;;3038                         sConfig->ICSelection,
;;;3039                         sConfig->ICFilter);
;;;3040   
;;;3041       /* Reset the IC2PSC Bits */
;;;3042       htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
;;;3043   
;;;3044       /* Set the IC2PSC value */
;;;3045       htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8U);
;;;3046     }
;;;3047     else if (Channel == TIM_CHANNEL_3)
;;;3048     {
;;;3049       /* TI3 Configuration */
;;;3050       assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3051   
;;;3052       TIM_TI3_SetConfig(htim->Instance,
;;;3053                  sConfig->ICPolarity,
;;;3054                  sConfig->ICSelection,
;;;3055                  sConfig->ICFilter);
;;;3056   
;;;3057       /* Reset the IC3PSC Bits */
;;;3058       htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;
;;;3059   
;;;3060       /* Set the IC3PSC value */
;;;3061       htim->Instance->CCMR2 |= sConfig->ICPrescaler;
;;;3062     }
;;;3063     else
;;;3064     {
;;;3065       /* TI4 Configuration */
;;;3066       assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3067   
;;;3068       TIM_TI4_SetConfig(htim->Instance,
;;;3069                  sConfig->ICPolarity,
;;;3070                  sConfig->ICSelection,
;;;3071                  sConfig->ICFilter);
;;;3072   
;;;3073       /* Reset the IC4PSC Bits */
;;;3074       htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;
;;;3075   
;;;3076       /* Set the IC4PSC value */
;;;3077       htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8U);
;;;3078     }
;;;3079   
;;;3080     htim->State = HAL_TIM_STATE_READY;
;;;3081   
;;;3082     __HAL_UNLOCK(htim);
;;;3083   
;;;3084     return HAL_OK;
;;;3085   }
000008  4770              BXEQ     lr
00000a  e92d03f0          PUSH     {r4-r9}               ;3005
00000e  f04f0c01          MOV      r12,#1                ;3013
000012  2302              MOVS     r3,#2                 ;3015
000014  f8c0c03c          STR      r12,[r0,#0x3c]        ;3015
000018  6403              STR      r3,[r0,#0x40]         ;3015
00001a  24f0              MOVS     r4,#0xf0              ;3015
00001c  2a00              CMP      r2,#0                 ;3017
00001e  d035              BEQ      |L33.140|
000020  0223              LSLS     r3,r4,#8              ;3013
000022  2a04              CMP      r2,#4                 ;3031
000024  d076              BEQ      |L33.276|
000026  2a08              CMP      r2,#8                 ;3047
000028  6802              LDR      r2,[r0,#0]            ;3047
00002a  d072              BEQ      |L33.274|
00002c  e9d16400          LDRD     r6,r4,[r1,#0]         ;3068
000030  68cd              LDR      r5,[r1,#0xc]          ;3068
000032  6a17              LDR      r7,[r2,#0x20]         ;3068
000034  f4275780          BIC      r7,r7,#0x1000         ;3068
000038  6217              STR      r7,[r2,#0x20]         ;3068
00003a  f8d2801c          LDR      r8,[r2,#0x1c]         ;3068
00003e  6a17              LDR      r7,[r2,#0x20]         ;3068
000040  f4287840          BIC      r8,r8,#0x300          ;3068
000044  ea033305          AND      r3,r3,r5,LSL #12      ;3068
000048  ea482404          ORR      r4,r8,r4,LSL #8       ;3068
00004c  f4244470          BIC      r4,r4,#0xf000         ;3068
000050  4323              ORRS     r3,r3,r4              ;3068
000052  f44f5500          MOV      r5,#0x2000            ;3068
000056  f4275400          BIC      r4,r7,#0x2000         ;3068
00005a  ea053506          AND      r5,r5,r6,LSL #12      ;3068
00005e  432c              ORRS     r4,r4,r5              ;3068
000060  61d3              STR      r3,[r2,#0x1c]         ;3068
000062  6214              STR      r4,[r2,#0x20]         ;3068
000064  6802              LDR      r2,[r0,#0]            ;3074
000066  69d3              LDR      r3,[r2,#0x1c]         ;3074
000068  f4236340          BIC      r3,r3,#0xc00          ;3074
00006c  61d3              STR      r3,[r2,#0x1c]         ;3074
00006e  6802              LDR      r2,[r0,#0]            ;3077
000070  69d3              LDR      r3,[r2,#0x1c]         ;3077
000072  6889              LDR      r1,[r1,#8]            ;3077
000074  ea432101          ORR      r1,r3,r1,LSL #8       ;3077
                  |L33.120|
000078  f8c2101c          STR.W    r1,[r2,#0x1c]         ;3061
                  |L33.124|
00007c  f8c0c040          STR      r12,[r0,#0x40]        ;3080
000080  2100              MOVS     r1,#0                 ;3082
000082  63c1              STR      r1,[r0,#0x3c]         ;3084
000084  e8bd03f0          POP      {r4-r9}
000088  4608              MOV      r0,r1                 ;3084
00008a  4770              BX       lr
                  |L33.140|
00008c  6802              LDR      r2,[r0,#0]            ;3020
00008e  e9d16800          LDRD     r6,r8,[r1,#0]         ;3020
000092  68cd              LDR      r5,[r1,#0xc]          ;3020
000094  6a13              LDR      r3,[r2,#0x20]         ;3020
000096  f0230301          BIC      r3,r3,#1              ;3020
00009a  6213              STR      r3,[r2,#0x20]         ;3020
00009c  6993              LDR      r3,[r2,#0x18]         ;3020
00009e  6a17              LDR      r7,[r2,#0x20]         ;3020
0000a0  f1a24980          SUB      r9,r2,#0x40000000     ;3020
0000a4  f5b93996          SUBS     r9,r9,#0x12c00        ;3020
0000a8  bf1c              ITT      NE                    ;3020
0000aa  f1a24980          SUBNE    r9,r2,#0x40000000     ;3020
0000ae  f5b9399a          SUBSNE   r9,r9,#0x13400        ;3020
0000b2  d013              BEQ      |L33.220|
0000b4  f1b24f80          CMP      r2,#0x40000000        ;3020
0000b8  bf1c              ITT      NE                    ;3020
0000ba  f1a24980          SUBNE    r9,r2,#0x40000000     ;3020
0000be  f5b96980          SUBSNE   r9,r9,#0x400          ;3020
0000c2  d00b              BEQ      |L33.220|
0000c4  f1a24980          SUB      r9,r2,#0x40000000     ;3020
0000c8  f5b96900          SUBS     r9,r9,#0x800          ;3020
0000cc  bf1e              ITTT     NE                    ;3020
0000ce  f1a24980          SUBNE    r9,r2,#0x40000000     ;3020
0000d2  f5b96940          SUBSNE   r9,r9,#0xc00          ;3020
0000d6  f0430301          ORRNE    r3,r3,#1              ;3020
0000da  d103              BNE      |L33.228|
                  |L33.220|
0000dc  f0230303          BIC      r3,r3,#3              ;3020
0000e0  ea430308          ORR      r3,r3,r8              ;3020
                  |L33.228|
0000e4  ea041405          AND      r4,r4,r5,LSL #4       ;3020
0000e8  f02303f0          BIC      r3,r3,#0xf0           ;3020
0000ec  4323              ORRS     r3,r3,r4              ;3020
0000ee  f027040a          BIC      r4,r7,#0xa            ;3020
0000f2  f006050a          AND      r5,r6,#0xa            ;3020
0000f6  432c              ORRS     r4,r4,r5              ;3020
0000f8  6193              STR      r3,[r2,#0x18]         ;3020
0000fa  6214              STR      r4,[r2,#0x20]         ;3020
0000fc  6802              LDR      r2,[r0,#0]            ;3026
0000fe  6993              LDR      r3,[r2,#0x18]         ;3026
000100  f023030c          BIC      r3,r3,#0xc            ;3026
000104  6193              STR      r3,[r2,#0x18]         ;3026
000106  6802              LDR      r2,[r0,#0]            ;3029
000108  6993              LDR      r3,[r2,#0x18]         ;3029
00010a  6889              LDR      r1,[r1,#8]            ;3029
00010c  4319              ORRS     r1,r1,r3              ;3029
00010e  e027              B        |L33.352|
000110  e000              B        |L33.276|
                  |L33.274|
000112  e027              B        |L33.356|
                  |L33.276|
000114  6802              LDR      r2,[r0,#0]            ;3036
000116  e9d16500          LDRD     r6,r5,[r1,#0]         ;3036
00011a  68cc              LDR      r4,[r1,#0xc]          ;3036
00011c  6a17              LDR      r7,[r2,#0x20]         ;3036
00011e  f0270710          BIC      r7,r7,#0x10           ;3036
000122  6217              STR      r7,[r2,#0x20]         ;3036
000124  f8d28018          LDR      r8,[r2,#0x18]         ;3036
000128  6a17              LDR      r7,[r2,#0x20]         ;3036
00012a  f4287840          BIC      r8,r8,#0x300          ;3036
00012e  ea482505          ORR      r5,r8,r5,LSL #8       ;3036
000132  ea033304          AND      r3,r3,r4,LSL #12      ;3036
000136  f4254570          BIC      r5,r5,#0xf000         ;3036
00013a  432b              ORRS     r3,r3,r5              ;3036
00013c  25a0              MOVS     r5,#0xa0              ;3036
00013e  f02704a0          BIC      r4,r7,#0xa0           ;3036
000142  ea051506          AND      r5,r5,r6,LSL #4       ;3036
000146  432c              ORRS     r4,r4,r5              ;3036
000148  6193              STR      r3,[r2,#0x18]         ;3036
00014a  6214              STR      r4,[r2,#0x20]         ;3036
00014c  6802              LDR      r2,[r0,#0]            ;3042
00014e  6993              LDR      r3,[r2,#0x18]         ;3042
000150  f4236340          BIC      r3,r3,#0xc00          ;3042
000154  6193              STR      r3,[r2,#0x18]         ;3042
000156  6802              LDR      r2,[r0,#0]            ;3045
000158  6993              LDR      r3,[r2,#0x18]         ;3045
00015a  6889              LDR      r1,[r1,#8]            ;3045
00015c  ea432101          ORR      r1,r3,r1,LSL #8       ;3045
                  |L33.352|
000160  6191              STR      r1,[r2,#0x18]         ;3045
000162  e78b              B        |L33.124|
                  |L33.356|
000164  e9d13500          LDRD     r3,r5,[r1,#0]         ;3052
000168  68ce              LDR      r6,[r1,#0xc]          ;3052
00016a  6a17              LDR      r7,[r2,#0x20]         ;3052
00016c  f4277780          BIC      r7,r7,#0x100          ;3052
000170  6217              STR      r7,[r2,#0x20]         ;3052
000172  f8d2801c          LDR      r8,[r2,#0x1c]         ;3052
000176  6a17              LDR      r7,[r2,#0x20]         ;3052
000178  f0280803          BIC      r8,r8,#3              ;3052
00017c  ea041406          AND      r4,r4,r6,LSL #4       ;3052
000180  ea480505          ORR      r5,r8,r5              ;3052
000184  f02505f0          BIC      r5,r5,#0xf0           ;3052
000188  432c              ORRS     r4,r4,r5              ;3052
00018a  f44f6620          MOV      r6,#0xa00             ;3052
00018e  f4276520          BIC      r5,r7,#0xa00          ;3052
000192  ea062303          AND      r3,r6,r3,LSL #8       ;3052
000196  432b              ORRS     r3,r3,r5              ;3052
000198  61d4              STR      r4,[r2,#0x1c]         ;3052
00019a  6213              STR      r3,[r2,#0x20]         ;3052
00019c  6802              LDR      r2,[r0,#0]            ;3058
00019e  69d3              LDR      r3,[r2,#0x1c]         ;3058
0001a0  f023030c          BIC      r3,r3,#0xc            ;3058
0001a4  61d3              STR      r3,[r2,#0x1c]         ;3058
0001a6  6802              LDR      r2,[r0,#0]            ;3061
0001a8  69d3              LDR      r3,[r2,#0x1c]         ;3061
0001aa  6889              LDR      r1,[r1,#8]            ;3061
0001ac  4319              ORRS     r1,r1,r3              ;3061
0001ae  e763              B        |L33.120|
;;;3086   
                          ENDP


                          AREA ||i.HAL_TIM_IC_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_DeInit PROC
;;;1534     */
;;;1535   HAL_StatusTypeDef HAL_TIM_IC_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1536   {
000002  4604              MOV      r4,r0
;;;1537     /* Check the parameters */
;;;1538     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1539   
;;;1540     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  6420              STR      r0,[r4,#0x40]
;;;1541   
;;;1542     /* Disable the TIM Peripheral Clock */
;;;1543     __HAL_TIM_DISABLE(htim);
000008  6820              LDR      r0,[r4,#0]
00000a  6a01              LDR      r1,[r0,#0x20]
00000c  f2411211          MOV      r2,#0x1111
000010  4211              TST      r1,r2
000012  d107              BNE      |L34.36|
000014  6a01              LDR      r1,[r0,#0x20]
000016  1092              ASRS     r2,r2,#2
000018  4211              TST      r1,r2
00001a  d103              BNE      |L34.36|
00001c  6801              LDR      r1,[r0,#0]
00001e  f0210101          BIC      r1,r1,#1
000022  6001              STR      r1,[r0,#0]
                  |L34.36|
;;;1544   
;;;1545     /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;1546     HAL_TIM_IC_MspDeInit(htim);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       HAL_TIM_IC_MspDeInit
;;;1547   
;;;1548     /* Change TIM state */
;;;1549     htim->State = HAL_TIM_STATE_RESET;
00002a  2000              MOVS     r0,#0
00002c  6420              STR      r0,[r4,#0x40]
;;;1550   
;;;1551     /* Release Lock */
;;;1552     __HAL_UNLOCK(htim);
00002e  63e0              STR      r0,[r4,#0x3c]
;;;1553   
;;;1554     return HAL_OK;
;;;1555   }
000030  bd10              POP      {r4,pc}
;;;1556   
                          ENDP


                          AREA ||i.HAL_TIM_IC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_GetState PROC
;;;4418     */
;;;4419   HAL_TIM_StateTypeDef HAL_TIM_IC_GetState(TIM_HandleTypeDef *htim)
000000  6c00              LDR      r0,[r0,#0x40]
;;;4420   {
;;;4421     return htim->State;
;;;4422   }
000002  4770              BX       lr
;;;4423   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Init PROC
;;;1494     */
;;;1495   HAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim)
000000  2800              CMP      r0,#0
;;;1496   {
;;;1497     /* Check the TIM handle allocation */
;;;1498     if(htim == NULL)
;;;1499     {
;;;1500       return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;1501     }
;;;1502   
;;;1503     /* Check the parameters */
;;;1504     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1505     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;1506     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;1507     assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;1508   
;;;1509     if(htim->State == HAL_TIM_STATE_RESET)
;;;1510     {
;;;1511       /* Allocate lock resource and initialize it */
;;;1512       htim->Lock = HAL_UNLOCKED;
;;;1513       
;;;1514       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;1515       HAL_TIM_IC_MspInit(htim);
;;;1516     }
;;;1517   
;;;1518     /* Set the TIM state */
;;;1519     htim->State= HAL_TIM_STATE_BUSY;
;;;1520   
;;;1521     /* Init the base time for the input capture */
;;;1522     TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;1523   
;;;1524     /* Initialize the TIM state*/
;;;1525     htim->State= HAL_TIM_STATE_READY;
;;;1526   
;;;1527     return HAL_OK;
;;;1528   }
000006  4770              BXEQ     lr
000008  b510              PUSH     {r4,lr}               ;1496
00000a  4604              MOV      r4,r0                 ;1496
00000c  6c00              LDR      r0,[r0,#0x40]         ;1509
00000e  b920              CBNZ     r0,|L36.26|
000010  2000              MOVS     r0,#0                 ;1512
000012  63e0              STR      r0,[r4,#0x3c]         ;1515
000014  4620              MOV      r0,r4                 ;1515
000016  f7fffffe          BL       HAL_TIM_IC_MspInit
                  |L36.26|
00001a  2002              MOVS     r0,#2                 ;1519
00001c  6420              STR      r0,[r4,#0x40]         ;1519
00001e  1d21              ADDS     r1,r4,#4              ;1522
000020  6820              LDR      r0,[r4,#0]            ;1522
000022  f7fffffe          BL       TIM_Base_SetConfig
000026  2001              MOVS     r0,#1                 ;1525
000028  6420              STR      r0,[r4,#0x40]         ;1525
00002a  2000              MOVS     r0,#0                 ;1527
00002c  bd10              POP      {r4,pc}
;;;1529   
                          ENDP


                          AREA ||i.HAL_TIM_IC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_MspDeInit PROC
;;;1575     */
;;;1576   __weak void HAL_TIM_IC_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1577   {
;;;1578     /* Prevent unused argument(s) compilation warning */
;;;1579     UNUSED(htim);
;;;1580     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1581               the HAL_TIM_IC_MspDeInit could be implemented in the user file
;;;1582      */
;;;1583   }
;;;1584   
                          ENDP


                          AREA ||i.HAL_TIM_IC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_MspInit PROC
;;;1561     */
;;;1562   __weak void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1563   {
;;;1564     /* Prevent unused argument(s) compilation warning */
;;;1565     UNUSED(htim);
;;;1566     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1567               the HAL_TIM_IC_MspInit could be implemented in the user file
;;;1568      */
;;;1569   }
;;;1570   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Start PROC
;;;1595   */
;;;1596   HAL_StatusTypeDef HAL_TIM_IC_Start (TIM_HandleTypeDef *htim, uint32_t Channel)
000000  6802              LDR      r2,[r0,#0]
000002  2301              MOVS     r3,#1
000004  fa03f101          LSL      r1,r3,r1
000008  6a13              LDR      r3,[r2,#0x20]
00000a  438b              BICS     r3,r3,r1
00000c  6213              STR      r3,[r2,#0x20]
00000e  6a13              LDR      r3,[r2,#0x20]
000010  4319              ORRS     r1,r1,r3
000012  6211              STR      r1,[r2,#0x20]
;;;1597   {
;;;1598     /* Check the parameters */
;;;1599     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1600   
;;;1601     /* Enable the Input Capture channel */
;;;1602     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1603   
;;;1604     /* Enable the Peripheral */
;;;1605     __HAL_TIM_ENABLE(htim);
000014  6800              LDR      r0,[r0,#0]
000016  6801              LDR      r1,[r0,#0]
000018  f0410101          ORR      r1,r1,#1
00001c  6001              STR      r1,[r0,#0]
;;;1606   
;;;1607     /* Return function status */
;;;1608     return HAL_OK;
00001e  2000              MOVS     r0,#0
;;;1609   }
000020  4770              BX       lr
;;;1610   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_IC_Start_DMA PROC
;;;1768   */
;;;1769   HAL_StatusTypeDef HAL_TIM_IC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;1770   {
000002  4604              MOV      r4,r0
;;;1771     /* Check the parameters */
;;;1772     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1773     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;1774   
;;;1775     if((htim->State == HAL_TIM_STATE_BUSY))
000004  6c00              LDR      r0,[r0,#0x40]
000006  460d              MOV      r5,r1                 ;1770
000008  2802              CMP      r0,#2
;;;1776     {
;;;1777        return HAL_BUSY;
;;;1778     }
;;;1779     else if((htim->State == HAL_TIM_STATE_READY))
;;;1780     {
;;;1781       if((pData == 0U) && (Length > 0U))
;;;1782       {
;;;1783         return HAL_ERROR;
;;;1784       }
;;;1785       else
;;;1786       {
;;;1787         htim->State = HAL_TIM_STATE_BUSY;
;;;1788       }
;;;1789     }
;;;1790   
;;;1791     switch (Channel)
;;;1792     {
;;;1793       case TIM_CHANNEL_1:
;;;1794       {
;;;1795         /* Set the DMA Period elapsed callback */
;;;1796         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;1797   
;;;1798         /* Set the DMA error callback */
;;;1799         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;1800   
;;;1801         /* Enable the DMA channel */
;;;1802         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length);
;;;1803   
;;;1804         /* Enable the TIM Capture/Compare 1 DMA request */
;;;1805         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;1806       }
;;;1807       break;
;;;1808   
;;;1809       case TIM_CHANNEL_2:
;;;1810       {
;;;1811         /* Set the DMA Period elapsed callback */
;;;1812         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
;;;1813   
;;;1814         /* Set the DMA error callback */
;;;1815         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;1816   
;;;1817         /* Enable the DMA channel */
;;;1818         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData, Length);
;;;1819   
;;;1820         /* Enable the TIM Capture/Compare 2  DMA request */
;;;1821         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;1822       }
;;;1823       break;
;;;1824   
;;;1825       case TIM_CHANNEL_3:
;;;1826       {
;;;1827         /* Set the DMA Period elapsed callback */
;;;1828         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
;;;1829   
;;;1830         /* Set the DMA error callback */
;;;1831         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;1832   
;;;1833         /* Enable the DMA channel */
;;;1834         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->CCR3, (uint32_t)pData, Length);
;;;1835   
;;;1836         /* Enable the TIM Capture/Compare 3  DMA request */
;;;1837         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;1838       }
;;;1839       break;
;;;1840   
;;;1841       case TIM_CHANNEL_4:
;;;1842       {
;;;1843         /* Set the DMA Period elapsed callback */
;;;1844         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
;;;1845   
;;;1846         /* Set the DMA error callback */
;;;1847         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;1848   
;;;1849         /* Enable the DMA channel */
;;;1850         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->CCR4, (uint32_t)pData, Length);
;;;1851   
;;;1852         /* Enable the TIM Capture/Compare 4  DMA request */
;;;1853         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;1854       }
;;;1855       break;
;;;1856   
;;;1857       default:
;;;1858       break;
;;;1859     }
;;;1860   
;;;1861     /* Enable the Input Capture channel */
;;;1862     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1863   
;;;1864     /* Enable the Peripheral */
;;;1865     __HAL_TIM_ENABLE(htim);
;;;1866   
;;;1867     /* Return function status */
;;;1868     return HAL_OK;
;;;1869   }
00000a  bf08              IT       EQ
00000c  bd70              POPEQ    {r4-r6,pc}
00000e  6c20              LDR      r0,[r4,#0x40]         ;1779
000010  2801              CMP      r0,#1                 ;1779
000012  d106              BNE      |L40.34|
000014  b91a              CBNZ     r2,|L40.30|
000016  2b00              CMP      r3,#0                 ;1781
000018  bf1c              ITT      NE                    ;1783
00001a  2001              MOVNE    r0,#1                 ;1783
00001c  bd70              POPNE    {r4-r6,pc}
                  |L40.30|
00001e  2002              MOVS     r0,#2                 ;1787
000020  6420              STR      r0,[r4,#0x40]         ;1787
                  |L40.34|
000022  482f              LDR      r0,|L40.224|
000024  492f              LDR      r1,|L40.228|
000026  b135              CBZ      r5,|L40.54|
000028  2d04              CMP      r5,#4                 ;1791
00002a  d015              BEQ      |L40.88|
00002c  2d08              CMP      r5,#8                 ;1791
00002e  d024              BEQ      |L40.122|
000030  2d0c              CMP      r5,#0xc               ;1791
000032  d033              BEQ      |L40.156|
000034  e043              B        |L40.190|
                  |L40.54|
000036  f8d4c024          LDR      r12,[r4,#0x24]        ;1796
00003a  f8cc002c          STR      r0,[r12,#0x2c]        ;1799
00003e  6a60              LDR      r0,[r4,#0x24]         ;1799
000040  6341              STR      r1,[r0,#0x34]         ;1802
000042  6820              LDR      r0,[r4,#0]            ;1802
000044  f1000134          ADD      r1,r0,#0x34           ;1802
000048  6a60              LDR      r0,[r4,#0x24]         ;1802
00004a  f7fffffe          BL       HAL_DMA_Start_IT
00004e  6820              LDR      r0,[r4,#0]            ;1805
000050  68c1              LDR      r1,[r0,#0xc]          ;1805
000052  f4417100          ORR      r1,r1,#0x200          ;1805
000056  e031              B        |L40.188|
                  |L40.88|
000058  f8d4c028          LDR      r12,[r4,#0x28]        ;1812
00005c  f8cc002c          STR      r0,[r12,#0x2c]        ;1815
000060  6aa0              LDR      r0,[r4,#0x28]         ;1815
000062  6341              STR      r1,[r0,#0x34]         ;1818
000064  6820              LDR      r0,[r4,#0]            ;1818
000066  f1000138          ADD      r1,r0,#0x38           ;1818
00006a  6aa0              LDR      r0,[r4,#0x28]         ;1818
00006c  f7fffffe          BL       HAL_DMA_Start_IT
000070  6820              LDR      r0,[r4,#0]            ;1821
000072  68c1              LDR      r1,[r0,#0xc]          ;1821
000074  f4416180          ORR      r1,r1,#0x400          ;1821
000078  e020              B        |L40.188|
                  |L40.122|
00007a  f8d4c02c          LDR      r12,[r4,#0x2c]        ;1828
00007e  f8cc002c          STR      r0,[r12,#0x2c]        ;1831
000082  6ae0              LDR      r0,[r4,#0x2c]         ;1831
000084  6341              STR      r1,[r0,#0x34]         ;1834
000086  6820              LDR      r0,[r4,#0]            ;1834
000088  f100013c          ADD      r1,r0,#0x3c           ;1834
00008c  6ae0              LDR      r0,[r4,#0x2c]         ;1834
00008e  f7fffffe          BL       HAL_DMA_Start_IT
000092  6820              LDR      r0,[r4,#0]            ;1837
000094  68c1              LDR      r1,[r0,#0xc]          ;1837
000096  f4416100          ORR      r1,r1,#0x800          ;1837
00009a  e00f              B        |L40.188|
                  |L40.156|
00009c  f8d4c030          LDR      r12,[r4,#0x30]        ;1844
0000a0  f8cc002c          STR      r0,[r12,#0x2c]        ;1847
0000a4  6b20              LDR      r0,[r4,#0x30]         ;1847
0000a6  6341              STR      r1,[r0,#0x34]         ;1850
0000a8  6820              LDR      r0,[r4,#0]            ;1850
0000aa  f1000140          ADD      r1,r0,#0x40           ;1850
0000ae  6b20              LDR      r0,[r4,#0x30]         ;1850
0000b0  f7fffffe          BL       HAL_DMA_Start_IT
0000b4  6820              LDR      r0,[r4,#0]            ;1853
0000b6  68c1              LDR      r1,[r0,#0xc]          ;1853
0000b8  f4415180          ORR      r1,r1,#0x1000         ;1853
                  |L40.188|
0000bc  60c1              STR      r1,[r0,#0xc]          ;1837
                  |L40.190|
0000be  6820              LDR      r0,[r4,#0]            ;1837
0000c0  2101              MOVS     r1,#1                 ;1837
0000c2  40a9              LSLS     r1,r1,r5              ;1837
0000c4  6a02              LDR      r2,[r0,#0x20]         ;1837
0000c6  438a              BICS     r2,r2,r1              ;1837
0000c8  6202              STR      r2,[r0,#0x20]         ;1837
0000ca  6a02              LDR      r2,[r0,#0x20]         ;1837
0000cc  4311              ORRS     r1,r1,r2              ;1837
0000ce  6201              STR      r1,[r0,#0x20]         ;1837
0000d0  6820              LDR      r0,[r4,#0]            ;1865
0000d2  6801              LDR      r1,[r0,#0]            ;1865
0000d4  f0410101          ORR      r1,r1,#1              ;1865
0000d8  6001              STR      r1,[r0,#0]            ;1865
0000da  2000              MOVS     r0,#0                 ;1868
0000dc  bd70              POP      {r4-r6,pc}
;;;1870   
                          ENDP

0000de  0000              DCW      0x0000
                  |L40.224|
                          DCD      TIM_DMACaptureCplt
                  |L40.228|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_IC_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Start_IT PROC
;;;1647   */
;;;1648   HAL_StatusTypeDef HAL_TIM_IC_Start_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
000000  6802              LDR      r2,[r0,#0]
;;;1649   {
;;;1650     /* Check the parameters */
;;;1651     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1652   
;;;1653     switch (Channel)
000002  2900              CMP      r1,#0
;;;1654     {
;;;1655       case TIM_CHANNEL_1:
;;;1656       {
;;;1657         /* Enable the TIM Capture/Compare 1 interrupt */
;;;1658         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000004  bf04              ITT      EQ
000006  68d3              LDREQ    r3,[r2,#0xc]
000008  f0430302          ORREQ    r3,r3,#2
00000c  d011              BEQ      |L41.50|
00000e  2904              CMP      r1,#4                 ;1653
;;;1659       }
;;;1660       break;
;;;1661   
;;;1662       case TIM_CHANNEL_2:
;;;1663       {
;;;1664         /* Enable the TIM Capture/Compare 2 interrupt */
;;;1665         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000010  bf04              ITT      EQ
000012  68d3              LDREQ    r3,[r2,#0xc]
000014  f0430304          ORREQ    r3,r3,#4
000018  d00b              BEQ      |L41.50|
00001a  2908              CMP      r1,#8                 ;1653
;;;1666       }
;;;1667       break;
;;;1668   
;;;1669       case TIM_CHANNEL_3:
;;;1670       {
;;;1671         /* Enable the TIM Capture/Compare 3 interrupt */
;;;1672         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
00001c  bf04              ITT      EQ
00001e  68d3              LDREQ    r3,[r2,#0xc]
000020  f0430308          ORREQ    r3,r3,#8
000024  d005              BEQ      |L41.50|
000026  290c              CMP      r1,#0xc               ;1653
;;;1673       }
;;;1674       break;
;;;1675   
;;;1676       case TIM_CHANNEL_4:
;;;1677       {
;;;1678         /* Enable the TIM Capture/Compare 4 interrupt */
;;;1679         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
000028  bf04              ITT      EQ
00002a  68d3              LDREQ    r3,[r2,#0xc]
00002c  f0430310          ORREQ    r3,r3,#0x10
000030  d100              BNE      |L41.52|
                  |L41.50|
000032  60d3              STR      r3,[r2,#0xc]          ;1672
                  |L41.52|
000034  6802              LDR      r2,[r0,#0]            ;1672
000036  2301              MOVS     r3,#1                 ;1672
000038  fa03f101          LSL      r1,r3,r1              ;1672
00003c  6a13              LDR      r3,[r2,#0x20]         ;1672
00003e  438b              BICS     r3,r3,r1              ;1672
000040  6213              STR      r3,[r2,#0x20]         ;1672
000042  6a13              LDR      r3,[r2,#0x20]         ;1672
000044  4319              ORRS     r1,r1,r3              ;1672
000046  6211              STR      r1,[r2,#0x20]         ;1672
;;;1680       }
;;;1681       break;
;;;1682   
;;;1683       default:
;;;1684       break;
;;;1685     }
;;;1686     /* Enable the Input Capture channel */
;;;1687     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1688   
;;;1689     /* Enable the Peripheral */
;;;1690     __HAL_TIM_ENABLE(htim);
000048  6800              LDR      r0,[r0,#0]
00004a  6801              LDR      r1,[r0,#0]
00004c  f0410101          ORR      r1,r1,#1
000050  6001              STR      r1,[r0,#0]
;;;1691   
;;;1692     /* Return function status */
;;;1693     return HAL_OK;
000052  2000              MOVS     r0,#0
;;;1694   }
000054  4770              BX       lr
;;;1695   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Stop PROC
;;;1621   */
;;;1622   HAL_StatusTypeDef HAL_TIM_IC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b410              PUSH     {r4}
000002  6802              LDR      r2,[r0,#0]
000004  f04f0c01          MOV      r12,#1
;;;1623   {
;;;1624     /* Check the parameters */
;;;1625     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1626   
;;;1627     /* Disable the Input Capture channel */
;;;1628     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000008  2300              MOVS     r3,#0
00000a  6a14              LDR      r4,[r2,#0x20]
00000c  fa0cfc01          LSL      r12,r12,r1
000010  ea240c0c          BIC      r12,r4,r12
000014  f8c2c020          STR      r12,[r2,#0x20]
000018  f8d2c020          LDR      r12,[r2,#0x20]
00001c  fa03f101          LSL      r1,r3,r1
000020  ea4c0101          ORR      r1,r12,r1
000024  6211              STR      r1,[r2,#0x20]
;;;1629   
;;;1630     /* Disable the Peripheral */
;;;1631     __HAL_TIM_DISABLE(htim);
000026  6800              LDR      r0,[r0,#0]
000028  6a01              LDR      r1,[r0,#0x20]
00002a  f2411211          MOV      r2,#0x1111
00002e  4211              TST      r1,r2
000030  d107              BNE      |L42.66|
000032  6a01              LDR      r1,[r0,#0x20]
000034  1092              ASRS     r2,r2,#2
000036  4211              TST      r1,r2
000038  d103              BNE      |L42.66|
00003a  6801              LDR      r1,[r0,#0]
00003c  f0210101          BIC      r1,r1,#1
000040  6001              STR      r1,[r0,#0]
                  |L42.66|
;;;1632   
;;;1633     /* Return function status */
;;;1634     return HAL_OK;
;;;1635   }
000042  bc10              POP      {r4}
000044  2000              MOVS     r0,#0                 ;1634
000046  4770              BX       lr
;;;1636   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Stop_DMA PROC
;;;1881   */
;;;1882   HAL_StatusTypeDef HAL_TIM_IC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b430              PUSH     {r4,r5}
;;;1883   {
;;;1884     /* Check the parameters */
;;;1885     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1886     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;1887   
;;;1888     switch (Channel)
000002  6802              LDR      r2,[r0,#0]
000004  2900              CMP      r1,#0
;;;1889     {
;;;1890       case TIM_CHANNEL_1:
;;;1891       {
;;;1892         /* Disable the TIM Capture/Compare 1 DMA request */
;;;1893         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000006  bf04              ITT      EQ
000008  68d3              LDREQ    r3,[r2,#0xc]
00000a  f4237300          BICEQ    r3,r3,#0x200
00000e  d011              BEQ      |L43.52|
000010  2904              CMP      r1,#4                 ;1888
;;;1894       }
;;;1895       break;
;;;1896   
;;;1897       case TIM_CHANNEL_2:
;;;1898       {
;;;1899         /* Disable the TIM Capture/Compare 2 DMA request */
;;;1900         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000012  bf04              ITT      EQ
000014  68d3              LDREQ    r3,[r2,#0xc]
000016  f4236380          BICEQ    r3,r3,#0x400
00001a  d00b              BEQ      |L43.52|
00001c  2908              CMP      r1,#8                 ;1888
;;;1901       }
;;;1902       break;
;;;1903   
;;;1904       case TIM_CHANNEL_3:
;;;1905       {
;;;1906         /* Disable the TIM Capture/Compare 3  DMA request */
;;;1907         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
00001e  bf04              ITT      EQ
000020  68d3              LDREQ    r3,[r2,#0xc]
000022  f4236300          BICEQ    r3,r3,#0x800
000026  d005              BEQ      |L43.52|
000028  290c              CMP      r1,#0xc               ;1888
;;;1908       }
;;;1909       break;
;;;1910   
;;;1911       case TIM_CHANNEL_4:
;;;1912       {
;;;1913         /* Disable the TIM Capture/Compare 4  DMA request */
;;;1914         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
00002a  bf04              ITT      EQ
00002c  68d3              LDREQ    r3,[r2,#0xc]
00002e  f4235380          BICEQ    r3,r3,#0x1000
000032  d100              BNE      |L43.54|
                  |L43.52|
000034  60d3              STR      r3,[r2,#0xc]          ;1907
                  |L43.54|
000036  6802              LDR      r2,[r0,#0]            ;1907
000038  2301              MOVS     r3,#1                 ;1907
;;;1915       }
;;;1916       break;
;;;1917   
;;;1918       default:
;;;1919       break;
;;;1920     }
;;;1921   
;;;1922     /* Disable the Input Capture channel */
;;;1923     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
00003a  f04f0c00          MOV      r12,#0
00003e  6a15              LDR      r5,[r2,#0x20]
000040  fa03f401          LSL      r4,r3,r1
000044  ea250404          BIC      r4,r5,r4
000048  6214              STR      r4,[r2,#0x20]
00004a  6a14              LDR      r4,[r2,#0x20]
00004c  fa0cf101          LSL      r1,r12,r1
000050  4321              ORRS     r1,r1,r4
000052  6211              STR      r1,[r2,#0x20]
;;;1924   
;;;1925     /* Disable the Peripheral */
;;;1926     __HAL_TIM_DISABLE(htim);
000054  6801              LDR      r1,[r0,#0]
000056  6a0a              LDR      r2,[r1,#0x20]
000058  f2411c11          MOV      r12,#0x1111
00005c  ea120f0c          TST      r2,r12
000060  d109              BNE      |L43.118|
000062  6a0a              LDR      r2,[r1,#0x20]
000064  f2404c44          MOV      r12,#0x444
000068  ea120f0c          TST      r2,r12
00006c  d103              BNE      |L43.118|
00006e  680a              LDR      r2,[r1,#0]
000070  f0220201          BIC      r2,r2,#1
000074  600a              STR      r2,[r1,#0]
                  |L43.118|
;;;1927   
;;;1928     /* Change the htim state */
;;;1929     htim->State = HAL_TIM_STATE_READY;
000076  6403              STR      r3,[r0,#0x40]
;;;1930   
;;;1931     /* Return function status */
;;;1932     return HAL_OK;
;;;1933   }
000078  bc30              POP      {r4,r5}
00007a  2000              MOVS     r0,#0                 ;1932
00007c  4770              BX       lr
;;;1934   /**
                          ENDP


                          AREA ||i.HAL_TIM_IC_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Stop_IT PROC
;;;1706   */
;;;1707   HAL_StatusTypeDef HAL_TIM_IC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b410              PUSH     {r4}
;;;1708   {
;;;1709     /* Check the parameters */
;;;1710     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1711   
;;;1712     switch (Channel)
000002  6802              LDR      r2,[r0,#0]
000004  2900              CMP      r1,#0
;;;1713     {
;;;1714       case TIM_CHANNEL_1:
;;;1715       {
;;;1716         /* Disable the TIM Capture/Compare 1 interrupt */
;;;1717         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000006  bf04              ITT      EQ
000008  68d3              LDREQ    r3,[r2,#0xc]
00000a  f0230302          BICEQ    r3,r3,#2
00000e  d011              BEQ      |L44.52|
000010  2904              CMP      r1,#4                 ;1712
;;;1718       }
;;;1719       break;
;;;1720   
;;;1721       case TIM_CHANNEL_2:
;;;1722       {
;;;1723         /* Disable the TIM Capture/Compare 2 interrupt */
;;;1724         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000012  bf04              ITT      EQ
000014  68d3              LDREQ    r3,[r2,#0xc]
000016  f0230304          BICEQ    r3,r3,#4
00001a  d00b              BEQ      |L44.52|
00001c  2908              CMP      r1,#8                 ;1712
;;;1725       }
;;;1726       break;
;;;1727   
;;;1728       case TIM_CHANNEL_3:
;;;1729       {
;;;1730         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1731         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
00001e  bf04              ITT      EQ
000020  68d3              LDREQ    r3,[r2,#0xc]
000022  f0230308          BICEQ    r3,r3,#8
000026  d005              BEQ      |L44.52|
000028  290c              CMP      r1,#0xc               ;1712
;;;1732       }
;;;1733       break;
;;;1734   
;;;1735       case TIM_CHANNEL_4:
;;;1736       {
;;;1737         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1738         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
00002a  bf04              ITT      EQ
00002c  68d3              LDREQ    r3,[r2,#0xc]
00002e  f0230310          BICEQ    r3,r3,#0x10
000032  d100              BNE      |L44.54|
                  |L44.52|
000034  60d3              STR      r3,[r2,#0xc]          ;1731
                  |L44.54|
000036  6802              LDR      r2,[r0,#0]            ;1731
000038  f04f0c01          MOV      r12,#1                ;1731
;;;1739       }
;;;1740       break;
;;;1741   
;;;1742       default:
;;;1743       break;
;;;1744     }
;;;1745   
;;;1746     /* Disable the Input Capture channel */
;;;1747     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
00003c  2300              MOVS     r3,#0
00003e  6a14              LDR      r4,[r2,#0x20]
000040  fa0cfc01          LSL      r12,r12,r1
000044  ea240c0c          BIC      r12,r4,r12
000048  f8c2c020          STR      r12,[r2,#0x20]
00004c  f8d2c020          LDR      r12,[r2,#0x20]
000050  fa03f101          LSL      r1,r3,r1
000054  ea4c0101          ORR      r1,r12,r1
000058  6211              STR      r1,[r2,#0x20]
;;;1748   
;;;1749     /* Disable the Peripheral */
;;;1750     __HAL_TIM_DISABLE(htim);
00005a  6800              LDR      r0,[r0,#0]
00005c  6a01              LDR      r1,[r0,#0x20]
00005e  f2411211          MOV      r2,#0x1111
000062  4211              TST      r1,r2
000064  d107              BNE      |L44.118|
000066  6a01              LDR      r1,[r0,#0x20]
000068  1092              ASRS     r2,r2,#2
00006a  4211              TST      r1,r2
00006c  d103              BNE      |L44.118|
00006e  6801              LDR      r1,[r0,#0]
000070  f0210101          BIC      r1,r1,#1
000074  6001              STR      r1,[r0,#0]
                  |L44.118|
;;;1751   
;;;1752     /* Return function status */
;;;1753     return HAL_OK;
;;;1754   }
000076  bc10              POP      {r4}
000078  2000              MOVS     r0,#0                 ;1753
00007a  4770              BX       lr
;;;1755   
                          ENDP


                          AREA ||i.HAL_TIM_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IRQHandler PROC
;;;2771     */
;;;2772   void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
000000  b570              PUSH     {r4-r6,lr}
;;;2773   {
000002  4604              MOV      r4,r0
;;;2774     /* Capture compare 1 event */
;;;2775     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
000004  6800              LDR      r0,[r0,#0]
000006  6901              LDR      r1,[r0,#0x10]
000008  f04f0500          MOV      r5,#0
00000c  f0110f02          TST      r1,#2
;;;2776     {
;;;2777       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) !=RESET)
000010  bf1c              ITT      NE
000012  68c1              LDRNE    r1,[r0,#0xc]
000014  f0110f02          TSTNE    r1,#2
000018  d013              BEQ      |L45.66|
;;;2778       {
;;;2779         {
;;;2780           __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
00001a  f06f0102          MVN      r1,#2
00001e  6101              STR      r1,[r0,#0x10]
;;;2781           htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
000020  2001              MOVS     r0,#1
;;;2782   
;;;2783           /* Input capture event */
;;;2784           if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
000022  61e0              STR      r0,[r4,#0x1c]
000024  6820              LDR      r0,[r4,#0]
000026  6980              LDR      r0,[r0,#0x18]
000028  f0100f03          TST      r0,#3
;;;2785           {
;;;2786             HAL_TIM_IC_CaptureCallback(htim);
;;;2787           }
;;;2788           /* Output compare event */
;;;2789           else
;;;2790           {
;;;2791             HAL_TIM_OC_DelayElapsedCallback(htim);
00002c  4620              MOV      r0,r4
00002e  d002              BEQ      |L45.54|
000030  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
000034  e004              B        |L45.64|
                  |L45.54|
000036  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2792             HAL_TIM_PWM_PulseFinishedCallback(htim);
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L45.64|
;;;2793           }
;;;2794           htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000040  61e5              STR      r5,[r4,#0x1c]
                  |L45.66|
;;;2795         }
;;;2796       }
;;;2797     }
;;;2798     /* Capture compare 2 event */
;;;2799     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
000042  6820              LDR      r0,[r4,#0]
000044  6901              LDR      r1,[r0,#0x10]
000046  f0110f04          TST      r1,#4
;;;2800     {
;;;2801       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) !=RESET)
00004a  bf1c              ITT      NE
00004c  68c1              LDRNE    r1,[r0,#0xc]
00004e  f0110f04          TSTNE    r1,#4
000052  d013              BEQ      |L45.124|
;;;2802       {
;;;2803         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
000054  f06f0104          MVN      r1,#4
000058  6101              STR      r1,[r0,#0x10]
;;;2804         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
00005a  2002              MOVS     r0,#2
;;;2805         /* Input capture event */
;;;2806         if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
00005c  61e0              STR      r0,[r4,#0x1c]
00005e  6820              LDR      r0,[r4,#0]
000060  6980              LDR      r0,[r0,#0x18]
000062  f4107f40          TST      r0,#0x300
;;;2807         {
;;;2808           HAL_TIM_IC_CaptureCallback(htim);
;;;2809         }
;;;2810         /* Output compare event */
;;;2811         else
;;;2812         {
;;;2813           HAL_TIM_OC_DelayElapsedCallback(htim);
000066  4620              MOV      r0,r4
000068  d002              BEQ      |L45.112|
00006a  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
00006e  e004              B        |L45.122|
                  |L45.112|
000070  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2814           HAL_TIM_PWM_PulseFinishedCallback(htim);
000074  4620              MOV      r0,r4
000076  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L45.122|
;;;2815         }
;;;2816         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
00007a  61e5              STR      r5,[r4,#0x1c]
                  |L45.124|
;;;2817       }
;;;2818     }
;;;2819     /* Capture compare 3 event */
;;;2820     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
00007c  6820              LDR      r0,[r4,#0]
00007e  6901              LDR      r1,[r0,#0x10]
000080  f0110f08          TST      r1,#8
;;;2821     {
;;;2822       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) !=RESET)
000084  bf1c              ITT      NE
000086  68c1              LDRNE    r1,[r0,#0xc]
000088  f0110f08          TSTNE    r1,#8
00008c  d013              BEQ      |L45.182|
;;;2823       {
;;;2824         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
00008e  f06f0108          MVN      r1,#8
000092  6101              STR      r1,[r0,#0x10]
;;;2825         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
000094  2004              MOVS     r0,#4
;;;2826         /* Input capture event */
;;;2827         if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
000096  61e0              STR      r0,[r4,#0x1c]
000098  6820              LDR      r0,[r4,#0]
00009a  69c0              LDR      r0,[r0,#0x1c]
00009c  f0100f03          TST      r0,#3
;;;2828         {
;;;2829           HAL_TIM_IC_CaptureCallback(htim);
;;;2830         }
;;;2831         /* Output compare event */
;;;2832         else
;;;2833         {
;;;2834           HAL_TIM_OC_DelayElapsedCallback(htim);
0000a0  4620              MOV      r0,r4
0000a2  d002              BEQ      |L45.170|
0000a4  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
0000a8  e004              B        |L45.180|
                  |L45.170|
0000aa  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2835           HAL_TIM_PWM_PulseFinishedCallback(htim);
0000ae  4620              MOV      r0,r4
0000b0  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L45.180|
;;;2836         }
;;;2837         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
0000b4  61e5              STR      r5,[r4,#0x1c]
                  |L45.182|
;;;2838       }
;;;2839     }
;;;2840     /* Capture compare 4 event */
;;;2841     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
0000b6  6820              LDR      r0,[r4,#0]
0000b8  6901              LDR      r1,[r0,#0x10]
0000ba  f0110f10          TST      r1,#0x10
;;;2842     {
;;;2843       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) !=RESET)
0000be  bf1c              ITT      NE
0000c0  68c1              LDRNE    r1,[r0,#0xc]
0000c2  f0110f10          TSTNE    r1,#0x10
0000c6  d013              BEQ      |L45.240|
;;;2844       {
;;;2845         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
0000c8  f06f0110          MVN      r1,#0x10
0000cc  6101              STR      r1,[r0,#0x10]
;;;2846         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
0000ce  2008              MOVS     r0,#8
;;;2847         /* Input capture event */
;;;2848         if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
0000d0  61e0              STR      r0,[r4,#0x1c]
0000d2  6820              LDR      r0,[r4,#0]
0000d4  69c0              LDR      r0,[r0,#0x1c]
0000d6  f4107f40          TST      r0,#0x300
;;;2849         {
;;;2850           HAL_TIM_IC_CaptureCallback(htim);
;;;2851         }
;;;2852         /* Output compare event */
;;;2853         else
;;;2854         {
;;;2855           HAL_TIM_OC_DelayElapsedCallback(htim);
0000da  4620              MOV      r0,r4
0000dc  d002              BEQ      |L45.228|
0000de  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
0000e2  e004              B        |L45.238|
                  |L45.228|
0000e4  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2856           HAL_TIM_PWM_PulseFinishedCallback(htim);
0000e8  4620              MOV      r0,r4
0000ea  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L45.238|
;;;2857         }
;;;2858         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
0000ee  61e5              STR      r5,[r4,#0x1c]
                  |L45.240|
;;;2859       }
;;;2860     }
;;;2861     /* TIM Update event */
;;;2862     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
0000f0  6820              LDR      r0,[r4,#0]
0000f2  6901              LDR      r1,[r0,#0x10]
0000f4  f0110f01          TST      r1,#1
;;;2863     {
;;;2864       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) !=RESET)
0000f8  bf1c              ITT      NE
0000fa  68c1              LDRNE    r1,[r0,#0xc]
0000fc  f0110f01          TSTNE    r1,#1
000100  d005              BEQ      |L45.270|
;;;2865       {
;;;2866         __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
000102  f06f0101          MVN      r1,#1
000106  6101              STR      r1,[r0,#0x10]
;;;2867         HAL_TIM_PeriodElapsedCallback(htim);
000108  4620              MOV      r0,r4
00010a  f7fffffe          BL       HAL_TIM_PeriodElapsedCallback
                  |L45.270|
;;;2868       }
;;;2869     }
;;;2870     /* TIM Break input event */
;;;2871     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
00010e  6820              LDR      r0,[r4,#0]
000110  6901              LDR      r1,[r0,#0x10]
000112  f0110f80          TST      r1,#0x80
;;;2872     {
;;;2873       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
000116  bf1c              ITT      NE
000118  68c1              LDRNE    r1,[r0,#0xc]
00011a  f0110f80          TSTNE    r1,#0x80
00011e  d005              BEQ      |L45.300|
;;;2874       {
;;;2875         __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
000120  f06f0180          MVN      r1,#0x80
000124  6101              STR      r1,[r0,#0x10]
;;;2876         HAL_TIMEx_BreakCallback(htim);
000126  4620              MOV      r0,r4
000128  f7fffffe          BL       HAL_TIMEx_BreakCallback
                  |L45.300|
;;;2877       }
;;;2878     }
;;;2879     /* TIM Trigger detection event */
;;;2880     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
00012c  6820              LDR      r0,[r4,#0]
00012e  6901              LDR      r1,[r0,#0x10]
000130  f0110f40          TST      r1,#0x40
;;;2881     {
;;;2882       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) !=RESET)
000134  bf1c              ITT      NE
000136  68c1              LDRNE    r1,[r0,#0xc]
000138  f0110f40          TSTNE    r1,#0x40
00013c  d005              BEQ      |L45.330|
;;;2883       {
;;;2884         __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
00013e  f06f0140          MVN      r1,#0x40
000142  6101              STR      r1,[r0,#0x10]
;;;2885         HAL_TIM_TriggerCallback(htim);
000144  4620              MOV      r0,r4
000146  f7fffffe          BL       HAL_TIM_TriggerCallback
                  |L45.330|
;;;2886       }
;;;2887     }
;;;2888     /* TIM commutation event */
;;;2889     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
00014a  6820              LDR      r0,[r4,#0]
00014c  6901              LDR      r1,[r0,#0x10]
00014e  f0110f20          TST      r1,#0x20
;;;2890     {
;;;2891       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) !=RESET)
000152  bf1a              ITTE     NE
000154  68c1              LDRNE    r1,[r0,#0xc]
000156  f0110f20          TSTNE    r1,#0x20
;;;2892       {
;;;2893         __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
;;;2894         HAL_TIMEx_CommutationCallback(htim);
;;;2895       }
;;;2896     }
;;;2897   }
00015a  bd70              POPEQ    {r4-r6,pc}
00015c  f06f0120          MVN      r1,#0x20              ;2893
000160  6101              STR      r1,[r0,#0x10]         ;2893
000162  4620              MOV      r0,r4                 ;2894
000164  e8bd4070          POP      {r4-r6,lr}            ;2894
000168  f7ffbffe          B.W      HAL_TIMEx_CommutationCallback
;;;2898   
                          ENDP


                          AREA ||i.HAL_TIM_OC_ConfigChannel||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_ConfigChannel PROC
;;;2934     */
;;;2935   HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2936   {
000004  4604              MOV      r4,r0
;;;2937     /* Check the parameters */
;;;2938     assert_param(IS_TIM_CHANNELS(Channel));
;;;2939     assert_param(IS_TIM_OC_MODE(sConfig->OCMode));
;;;2940     assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
;;;2941   
;;;2942     /* Check input state */
;;;2943     __HAL_LOCK(htim);
000006  6bc0              LDR      r0,[r0,#0x3c]
000008  2801              CMP      r0,#1
00000a  bf04              ITT      EQ
00000c  2002              MOVEQ    r0,#2
;;;2944   
;;;2945     htim->State = HAL_TIM_STATE_BUSY;
;;;2946   
;;;2947     switch (Channel)
;;;2948     {
;;;2949       case TIM_CHANNEL_1:
;;;2950       {
;;;2951         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;2952         /* Configure the TIM Channel 1 in Output Compare */
;;;2953         TIM_OC1_SetConfig(htim->Instance, sConfig);
;;;2954       }
;;;2955       break;
;;;2956   
;;;2957       case TIM_CHANNEL_2:
;;;2958       {
;;;2959         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2960         /* Configure the TIM Channel 2 in Output Compare */
;;;2961         TIM_OC2_SetConfig(htim->Instance, sConfig);
;;;2962       }
;;;2963       break;
;;;2964   
;;;2965       case TIM_CHANNEL_3:
;;;2966       {
;;;2967          assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;2968         /* Configure the TIM Channel 3 in Output Compare */
;;;2969         TIM_OC3_SetConfig(htim->Instance, sConfig);
;;;2970       }
;;;2971       break;
;;;2972   
;;;2973       case TIM_CHANNEL_4:
;;;2974       {
;;;2975         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;2976          /* Configure the TIM Channel 4 in Output Compare */
;;;2977          TIM_OC4_SetConfig(htim->Instance, sConfig);
;;;2978       }
;;;2979       break;
;;;2980   
;;;2981       default:
;;;2982       break;
;;;2983     }
;;;2984     htim->State = HAL_TIM_STATE_READY;
;;;2985   
;;;2986     __HAL_UNLOCK(htim);
;;;2987   
;;;2988     return HAL_OK;
;;;2989   }
00000e  e8bd81f0          POPEQ    {r4-r8,pc}
000012  2501              MOVS     r5,#1                 ;2943
000014  2002              MOVS     r0,#2                 ;2945
000016  63e5              STR      r5,[r4,#0x3c]         ;2945
000018  6420              STR      r0,[r4,#0x40]         ;2945
00001a  4851              LDR      r0,|L46.352|
00001c  4b51              LDR      r3,|L46.356|
00001e  b132              CBZ      r2,|L46.46|
000020  2a04              CMP      r2,#4                 ;2947
000022  d037              BEQ      |L46.148|
000024  2a08              CMP      r2,#8                 ;2947
000026  d039              BEQ      |L46.156|
000028  2a0c              CMP      r2,#0xc               ;2947
00002a  d06d              BEQ      |L46.264|
00002c  e092              B        |L46.340|
                  |L46.46|
00002e  6822              LDR      r2,[r4,#0]            ;2947
000030  f8d2c020          LDR      r12,[r2,#0x20]        ;2947
000034  f02c0c01          BIC      r12,r12,#1            ;2947
000038  f8c2c020          STR      r12,[r2,#0x20]        ;2947
00003c  f8d2c020          LDR      r12,[r2,#0x20]        ;2947
000040  6856              LDR      r6,[r2,#4]            ;2947
000042  6997              LDR      r7,[r2,#0x18]         ;2947
000044  f8d18000          LDR      r8,[r1,#0]            ;2947
000048  f0270773          BIC      r7,r7,#0x73           ;2947
00004c  ea480707          ORR      r7,r8,r7              ;2947
000050  f8d18008          LDR      r8,[r1,#8]            ;2947
000054  f02c0c02          BIC      r12,r12,#2            ;2947
000058  ea480c0c          ORR      r12,r8,r12            ;2947
00005c  4282              CMP      r2,r0                 ;2947
00005e  bf18              IT       NE                    ;2947
000060  429a              CMPNE    r2,r3                 ;2947
000062  d107              BNE      |L46.116|
000064  f8d1800c          LDR      r8,[r1,#0xc]          ;2953
000068  f02c0c08          BIC      r12,r12,#8            ;2953
00006c  ea480c0c          ORR      r12,r8,r12            ;2953
000070  f02c0c04          BIC      r12,r12,#4            ;2953
                  |L46.116|
000074  4282              CMP      r2,r0                 ;2953
000076  bf18              IT       NE                    ;2953
000078  429a              CMPNE    r2,r3                 ;2953
00007a  d106              BNE      |L46.138|
00007c  694b              LDR      r3,[r1,#0x14]         ;2953
00007e  f4267040          BIC      r0,r6,#0x300          ;2953
000082  4318              ORRS     r0,r0,r3              ;2953
000084  698b              LDR      r3,[r1,#0x18]         ;2953
000086  ea430600          ORR      r6,r3,r0              ;2953
                  |L46.138|
00008a  6056              STR      r6,[r2,#4]            ;2953
00008c  6197              STR      r7,[r2,#0x18]         ;2953
00008e  6848              LDR      r0,[r1,#4]            ;2953
000090  6350              STR      r0,[r2,#0x34]         ;2953
000092  e036              B        |L46.258|
                  |L46.148|
000094  6820              LDR      r0,[r4,#0]            ;2961
000096  f7fffffe          BL       TIM_OC2_SetConfig
00009a  e05b              B        |L46.340|
                  |L46.156|
00009c  6822              LDR      r2,[r4,#0]            ;2963
00009e  f8d2c020          LDR      r12,[r2,#0x20]        ;2963
0000a2  f42c7c80          BIC      r12,r12,#0x100        ;2963
0000a6  f8c2c020          STR      r12,[r2,#0x20]        ;2963
0000aa  f8d2c020          LDR      r12,[r2,#0x20]        ;2963
0000ae  6856              LDR      r6,[r2,#4]            ;2963
0000b0  69d7              LDR      r7,[r2,#0x1c]         ;2963
0000b2  f8d18000          LDR      r8,[r1,#0]            ;2963
0000b6  f0270773          BIC      r7,r7,#0x73           ;2963
0000ba  ea480707          ORR      r7,r8,r7              ;2963
0000be  f8d18008          LDR      r8,[r1,#8]            ;2963
0000c2  f42c7c00          BIC      r12,r12,#0x200        ;2963
0000c6  ea4c2c08          ORR      r12,r12,r8,LSL #8     ;2963
0000ca  4282              CMP      r2,r0                 ;2963
0000cc  bf18              IT       NE                    ;2963
0000ce  429a              CMPNE    r2,r3                 ;2963
0000d0  d107              BNE      |L46.226|
0000d2  f8d1800c          LDR      r8,[r1,#0xc]          ;2969
0000d6  f42c6c00          BIC      r12,r12,#0x800        ;2969
0000da  ea4c2c08          ORR      r12,r12,r8,LSL #8     ;2969
0000de  f42c6c80          BIC      r12,r12,#0x400        ;2969
                  |L46.226|
0000e2  4282              CMP      r2,r0                 ;2969
0000e4  bf18              IT       NE                    ;2969
0000e6  429a              CMPNE    r2,r3                 ;2969
0000e8  d107              BNE      |L46.250|
0000ea  694b              LDR      r3,[r1,#0x14]         ;2969
0000ec  f4265040          BIC      r0,r6,#0x3000         ;2969
0000f0  ea401003          ORR      r0,r0,r3,LSL #4       ;2969
0000f4  698b              LDR      r3,[r1,#0x18]         ;2969
0000f6  ea401603          ORR      r6,r0,r3,LSL #4       ;2969
                  |L46.250|
0000fa  6056              STR      r6,[r2,#4]            ;2969
0000fc  61d7              STR      r7,[r2,#0x1c]         ;2969
0000fe  6848              LDR      r0,[r1,#4]            ;2969
000100  63d0              STR      r0,[r2,#0x3c]         ;2969
                  |L46.258|
000102  f8c2c020          STR      r12,[r2,#0x20]        ;2969
000106  e025              B        |L46.340|
                  |L46.264|
000108  6822              LDR      r2,[r4,#0]            ;2969
00010a  f8d2c020          LDR      r12,[r2,#0x20]        ;2969
00010e  f42c5c80          BIC      r12,r12,#0x1000       ;2969
000112  f8c2c020          STR      r12,[r2,#0x20]        ;2969
000116  6a17              LDR      r7,[r2,#0x20]         ;2969
000118  f8d2c004          LDR      r12,[r2,#4]           ;2969
00011c  69d6              LDR      r6,[r2,#0x1c]         ;2969
00011e  f8d18000          LDR      r8,[r1,#0]            ;2969
000122  f42646e6          BIC      r6,r6,#0x7300         ;2969
000126  ea462608          ORR      r6,r6,r8,LSL #8       ;2969
00012a  f8d18008          LDR      r8,[r1,#8]            ;2969
00012e  f4275700          BIC      r7,r7,#0x2000         ;2969
000132  ea473708          ORR      r7,r7,r8,LSL #12      ;2969
000136  4282              CMP      r2,r0                 ;2969
000138  bf18              IT       NE                    ;2969
00013a  429a              CMPNE    r2,r3                 ;2969
00013c  d104              BNE      |L46.328|
00013e  694b              LDR      r3,[r1,#0x14]         ;2977
000140  f42c4080          BIC      r0,r12,#0x4000        ;2977
000144  ea401c83          ORR      r12,r0,r3,LSL #6      ;2977
                  |L46.328|
000148  f8c2c004          STR      r12,[r2,#4]           ;2977
00014c  61d6              STR      r6,[r2,#0x1c]         ;2977
00014e  6848              LDR      r0,[r1,#4]            ;2977
000150  6410              STR      r0,[r2,#0x40]         ;2977
000152  6217              STR      r7,[r2,#0x20]         ;2977
                  |L46.340|
000154  6425              STR      r5,[r4,#0x40]         ;2984
000156  2000              MOVS     r0,#0                 ;2986
000158  63e0              STR      r0,[r4,#0x3c]         ;2986
00015a  e8bd81f0          POP      {r4-r8,pc}
;;;2990   
                          ENDP

00015e  0000              DCW      0x0000
                  |L46.352|
                          DCD      0x40012c00
                  |L46.356|
                          DCD      0x40013400

                          AREA ||i.HAL_TIM_OC_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_DeInit PROC
;;;521      */
;;;522    HAL_StatusTypeDef HAL_TIM_OC_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;523    {
000002  4604              MOV      r4,r0
;;;524      /* Check the parameters */
;;;525      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;526    
;;;527       htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  6420              STR      r0,[r4,#0x40]
;;;528    
;;;529      /* Disable the TIM Peripheral Clock */
;;;530      __HAL_TIM_DISABLE(htim);
000008  6820              LDR      r0,[r4,#0]
00000a  6a01              LDR      r1,[r0,#0x20]
00000c  f2411211          MOV      r2,#0x1111
000010  4211              TST      r1,r2
000012  d107              BNE      |L47.36|
000014  6a01              LDR      r1,[r0,#0x20]
000016  1092              ASRS     r2,r2,#2
000018  4211              TST      r1,r2
00001a  d103              BNE      |L47.36|
00001c  6801              LDR      r1,[r0,#0]
00001e  f0210101          BIC      r1,r1,#1
000022  6001              STR      r1,[r0,#0]
                  |L47.36|
;;;531    
;;;532      /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;533      HAL_TIM_OC_MspDeInit(htim);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       HAL_TIM_OC_MspDeInit
;;;534    
;;;535      /* Change TIM state */
;;;536      htim->State = HAL_TIM_STATE_RESET;
00002a  2000              MOVS     r0,#0
00002c  6420              STR      r0,[r4,#0x40]
;;;537    
;;;538      /* Release Lock */
;;;539      __HAL_UNLOCK(htim);
00002e  63e0              STR      r0,[r4,#0x3c]
;;;540    
;;;541      return HAL_OK;
;;;542    }
000030  bd10              POP      {r4,pc}
;;;543    
                          ENDP


                          AREA ||i.HAL_TIM_OC_DelayElapsedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_DelayElapsedCallback PROC
;;;4300     */
;;;4301   __weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4302   {
;;;4303     /* Prevent unused argument(s) compilation warning */
;;;4304     UNUSED(htim);
;;;4305     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4306               the __HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
;;;4307      */
;;;4308   }
;;;4309   /**
                          ENDP


                          AREA ||i.HAL_TIM_OC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_GetState PROC
;;;4398     */
;;;4399   HAL_TIM_StateTypeDef HAL_TIM_OC_GetState(TIM_HandleTypeDef *htim)
000000  6c00              LDR      r0,[r0,#0x40]
;;;4400   {
;;;4401     return htim->State;
;;;4402   }
000002  4770              BX       lr
;;;4403   
                          ENDP


                          AREA ||i.HAL_TIM_OC_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_Init PROC
;;;481      */
;;;482    HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef* htim)
000000  2800              CMP      r0,#0
;;;483    {
;;;484      /* Check the TIM handle allocation */
;;;485      if(htim == NULL)
;;;486      {
;;;487        return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;488      }
;;;489    
;;;490      /* Check the parameters */
;;;491      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;492      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;493      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;494      assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;495    
;;;496      if(htim->State == HAL_TIM_STATE_RESET)
;;;497      {
;;;498        /* Allocate lock resource and initialize it */
;;;499        htim->Lock = HAL_UNLOCKED;
;;;500        
;;;501        /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;502        HAL_TIM_OC_MspInit(htim);
;;;503      }
;;;504    
;;;505      /* Set the TIM state */
;;;506      htim->State= HAL_TIM_STATE_BUSY;
;;;507    
;;;508      /* Init the base time for the Output Compare */
;;;509      TIM_Base_SetConfig(htim->Instance,  &htim->Init);
;;;510    
;;;511      /* Initialize the TIM state*/
;;;512      htim->State= HAL_TIM_STATE_READY;
;;;513    
;;;514      return HAL_OK;
;;;515    }
000006  4770              BXEQ     lr
000008  b510              PUSH     {r4,lr}               ;483
00000a  4604              MOV      r4,r0                 ;483
00000c  6c00              LDR      r0,[r0,#0x40]         ;496
00000e  b920              CBNZ     r0,|L50.26|
000010  2000              MOVS     r0,#0                 ;499
000012  63e0              STR      r0,[r4,#0x3c]         ;502
000014  4620              MOV      r0,r4                 ;502
000016  f7fffffe          BL       HAL_TIM_OC_MspInit
                  |L50.26|
00001a  2002              MOVS     r0,#2                 ;506
00001c  6420              STR      r0,[r4,#0x40]         ;506
00001e  1d21              ADDS     r1,r4,#4              ;509
000020  6820              LDR      r0,[r4,#0]            ;509
000022  f7fffffe          BL       TIM_Base_SetConfig
000026  2001              MOVS     r0,#1                 ;512
000028  6420              STR      r0,[r4,#0x40]         ;512
00002a  2000              MOVS     r0,#0                 ;514
00002c  bd10              POP      {r4,pc}
;;;516    
                          ENDP


                          AREA ||i.HAL_TIM_OC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_MspDeInit PROC
;;;562      */
;;;563    __weak void HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;564    {
;;;565      /* Prevent unused argument(s) compilation warning */
;;;566      UNUSED(htim);
;;;567      /* NOTE : This function Should not be modified, when the callback is needed,
;;;568                the HAL_TIM_OC_MspDeInit could be implemented in the user file
;;;569       */
;;;570    }
;;;571    
                          ENDP


                          AREA ||i.HAL_TIM_OC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_MspInit PROC
;;;548      */
;;;549    __weak void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;550    {
;;;551      /* Prevent unused argument(s) compilation warning */
;;;552      UNUSED(htim);
;;;553      /* NOTE : This function Should not be modified, when the callback is needed,
;;;554                the HAL_TIM_OC_MspInit could be implemented in the user file
;;;555       */
;;;556    }
;;;557    
                          ENDP


                          AREA ||i.HAL_TIM_OC_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_Start PROC
;;;582    */
;;;583    HAL_StatusTypeDef HAL_TIM_OC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  6802              LDR      r2,[r0,#0]
000002  2301              MOVS     r3,#1
000004  fa03f101          LSL      r1,r3,r1
000008  6a13              LDR      r3,[r2,#0x20]
00000a  438b              BICS     r3,r3,r1
00000c  6213              STR      r3,[r2,#0x20]
00000e  6a13              LDR      r3,[r2,#0x20]
000010  4319              ORRS     r1,r1,r3
000012  6211              STR      r1,[r2,#0x20]
;;;584    {
;;;585      /* Check the parameters */
;;;586      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;587    
;;;588      /* Enable the Output compare channel */
;;;589      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;590    
;;;591      if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000014  6801              LDR      r1,[r0,#0]
000016  f1a14280          SUB      r2,r1,#0x40000000
00001a  f5b23296          SUBS     r2,r2,#0x12c00
00001e  bf1c              ITT      NE
000020  f1a14280          SUBNE    r2,r1,#0x40000000
000024  f5b2329a          SUBSNE   r2,r2,#0x13400
000028  d103              BNE      |L53.50|
;;;592      {
;;;593        /* Enable the main output */
;;;594        __HAL_TIM_MOE_ENABLE(htim);
00002a  6c4a              LDR      r2,[r1,#0x44]
00002c  f4424200          ORR      r2,r2,#0x8000
000030  644a              STR      r2,[r1,#0x44]
                  |L53.50|
;;;595      }
;;;596    
;;;597      /* Enable the Peripheral */
;;;598      __HAL_TIM_ENABLE(htim);
000032  6800              LDR      r0,[r0,#0]
000034  6801              LDR      r1,[r0,#0]
000036  f0410101          ORR      r1,r1,#1
00003a  6001              STR      r1,[r0,#0]
;;;599    
;;;600      /* Return function status */
;;;601      return HAL_OK;
00003c  2000              MOVS     r0,#0
;;;602    }
00003e  4770              BX       lr
;;;603    
                          ENDP


                          AREA ||i.HAL_TIM_OC_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Start_DMA PROC
;;;780    */
;;;781    HAL_StatusTypeDef HAL_TIM_OC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;782    {
000002  4604              MOV      r4,r0
;;;783      /* Check the parameters */
;;;784      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;785    
;;;786      if((htim->State == HAL_TIM_STATE_BUSY))
000004  6c00              LDR      r0,[r0,#0x40]
000006  4694              MOV      r12,r2                ;782
000008  460d              MOV      r5,r1                 ;782
00000a  2802              CMP      r0,#2
;;;787      {
;;;788         return HAL_BUSY;
;;;789      }
;;;790      else if((htim->State == HAL_TIM_STATE_READY))
;;;791      {
;;;792        if(((uint32_t)pData == 0U) && (Length > 0U))
;;;793        {
;;;794          return HAL_ERROR;
;;;795        }
;;;796        else
;;;797        {
;;;798          htim->State = HAL_TIM_STATE_BUSY;
;;;799        }
;;;800      }
;;;801      switch (Channel)
;;;802      {
;;;803        case TIM_CHANNEL_1:
;;;804        {
;;;805          /* Set the DMA Period elapsed callback */
;;;806          htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;807    
;;;808          /* Set the DMA error callback */
;;;809          htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;810    
;;;811          /* Enable the DMA channel */
;;;812          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
;;;813    
;;;814          /* Enable the TIM Capture/Compare 1 DMA request */
;;;815          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;816        }
;;;817        break;
;;;818    
;;;819        case TIM_CHANNEL_2:
;;;820        {
;;;821          /* Set the DMA Period elapsed callback */
;;;822          htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;823    
;;;824          /* Set the DMA error callback */
;;;825          htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;826    
;;;827          /* Enable the DMA channel */
;;;828          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
;;;829    
;;;830          /* Enable the TIM Capture/Compare 2 DMA request */
;;;831          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;832        }
;;;833        break;
;;;834    
;;;835        case TIM_CHANNEL_3:
;;;836        {
;;;837          /* Set the DMA Period elapsed callback */
;;;838          htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;839    
;;;840          /* Set the DMA error callback */
;;;841          htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;842    
;;;843          /* Enable the DMA channel */
;;;844          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
;;;845    
;;;846          /* Enable the TIM Capture/Compare 3 DMA request */
;;;847          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;848        }
;;;849        break;
;;;850    
;;;851        case TIM_CHANNEL_4:
;;;852        {
;;;853         /* Set the DMA Period elapsed callback */
;;;854          htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;855    
;;;856          /* Set the DMA error callback */
;;;857          htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;858    
;;;859          /* Enable the DMA channel */
;;;860          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
;;;861    
;;;862          /* Enable the TIM Capture/Compare 4 DMA request */
;;;863          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;864        }
;;;865        break;
;;;866    
;;;867        default:
;;;868        break;
;;;869      }
;;;870    
;;;871      /* Enable the Output compare channel */
;;;872      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;873    
;;;874      if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;875      {
;;;876        /* Enable the main output */
;;;877        __HAL_TIM_MOE_ENABLE(htim);
;;;878      }
;;;879    
;;;880      /* Enable the Peripheral */
;;;881      __HAL_TIM_ENABLE(htim);
;;;882    
;;;883      /* Return function status */
;;;884      return HAL_OK;
;;;885    }
00000c  bf08              IT       EQ
00000e  bd70              POPEQ    {r4-r6,pc}
000010  6c20              LDR      r0,[r4,#0x40]         ;790
000012  2801              CMP      r0,#1                 ;790
000014  d108              BNE      |L54.40|
000016  f1bc0f00          CMP      r12,#0                ;792
00001a  d103              BNE      |L54.36|
00001c  2b00              CMP      r3,#0                 ;792
00001e  bf1c              ITT      NE                    ;794
000020  2001              MOVNE    r0,#1                 ;794
000022  bd70              POPNE    {r4-r6,pc}
                  |L54.36|
000024  2002              MOVS     r0,#2                 ;798
000026  6420              STR      r0,[r4,#0x40]         ;798
                  |L54.40|
000028  4834              LDR      r0,|L54.252|
00002a  4935              LDR      r1,|L54.256|
00002c  b135              CBZ      r5,|L54.60|
00002e  2d04              CMP      r5,#4                 ;801
000030  d014              BEQ      |L54.92|
000032  2d08              CMP      r5,#8                 ;801
000034  d022              BEQ      |L54.124|
000036  2d0c              CMP      r5,#0xc               ;801
000038  d030              BEQ      |L54.156|
00003a  e03f              B        |L54.188|
                  |L54.60|
00003c  6a62              LDR      r2,[r4,#0x24]         ;806
00003e  62d0              STR      r0,[r2,#0x2c]         ;809
000040  6a60              LDR      r0,[r4,#0x24]         ;809
000042  6341              STR      r1,[r0,#0x34]         ;812
000044  6820              LDR      r0,[r4,#0]            ;812
000046  4661              MOV      r1,r12                ;812
000048  f1000234          ADD      r2,r0,#0x34           ;812
00004c  6a60              LDR      r0,[r4,#0x24]         ;812
00004e  f7fffffe          BL       HAL_DMA_Start_IT
000052  6820              LDR      r0,[r4,#0]            ;815
000054  68c1              LDR      r1,[r0,#0xc]          ;815
000056  f4417100          ORR      r1,r1,#0x200          ;815
00005a  e02e              B        |L54.186|
                  |L54.92|
00005c  6aa2              LDR      r2,[r4,#0x28]         ;822
00005e  62d0              STR      r0,[r2,#0x2c]         ;825
000060  6aa0              LDR      r0,[r4,#0x28]         ;825
000062  6341              STR      r1,[r0,#0x34]         ;828
000064  6820              LDR      r0,[r4,#0]            ;828
000066  4661              MOV      r1,r12                ;828
000068  f1000238          ADD      r2,r0,#0x38           ;828
00006c  6aa0              LDR      r0,[r4,#0x28]         ;828
00006e  f7fffffe          BL       HAL_DMA_Start_IT
000072  6820              LDR      r0,[r4,#0]            ;831
000074  68c1              LDR      r1,[r0,#0xc]          ;831
000076  f4416180          ORR      r1,r1,#0x400          ;831
00007a  e01e              B        |L54.186|
                  |L54.124|
00007c  6ae2              LDR      r2,[r4,#0x2c]         ;838
00007e  62d0              STR      r0,[r2,#0x2c]         ;841
000080  6ae0              LDR      r0,[r4,#0x2c]         ;841
000082  6341              STR      r1,[r0,#0x34]         ;844
000084  6820              LDR      r0,[r4,#0]            ;844
000086  4661              MOV      r1,r12                ;844
000088  f100023c          ADD      r2,r0,#0x3c           ;844
00008c  6ae0              LDR      r0,[r4,#0x2c]         ;844
00008e  f7fffffe          BL       HAL_DMA_Start_IT
000092  6820              LDR      r0,[r4,#0]            ;847
000094  68c1              LDR      r1,[r0,#0xc]          ;847
000096  f4416100          ORR      r1,r1,#0x800          ;847
00009a  e00e              B        |L54.186|
                  |L54.156|
00009c  6b22              LDR      r2,[r4,#0x30]         ;854
00009e  62d0              STR      r0,[r2,#0x2c]         ;857
0000a0  6b20              LDR      r0,[r4,#0x30]         ;857
0000a2  6341              STR      r1,[r0,#0x34]         ;860
0000a4  6820              LDR      r0,[r4,#0]            ;860
0000a6  4661              MOV      r1,r12                ;860
0000a8  f1000240          ADD      r2,r0,#0x40           ;860
0000ac  6b20              LDR      r0,[r4,#0x30]         ;860
0000ae  f7fffffe          BL       HAL_DMA_Start_IT
0000b2  6820              LDR      r0,[r4,#0]            ;863
0000b4  68c1              LDR      r1,[r0,#0xc]          ;863
0000b6  f4415180          ORR      r1,r1,#0x1000         ;863
                  |L54.186|
0000ba  60c1              STR      r1,[r0,#0xc]          ;847
                  |L54.188|
0000bc  6820              LDR      r0,[r4,#0]            ;847
0000be  2101              MOVS     r1,#1                 ;847
0000c0  40a9              LSLS     r1,r1,r5              ;847
0000c2  6a02              LDR      r2,[r0,#0x20]         ;847
0000c4  438a              BICS     r2,r2,r1              ;847
0000c6  6202              STR      r2,[r0,#0x20]         ;847
0000c8  6a02              LDR      r2,[r0,#0x20]         ;847
0000ca  4311              ORRS     r1,r1,r2              ;847
0000cc  6201              STR      r1,[r0,#0x20]         ;847
0000ce  6820              LDR      r0,[r4,#0]            ;874
0000d0  f1a04180          SUB      r1,r0,#0x40000000     ;874
0000d4  f5b13196          SUBS     r1,r1,#0x12c00        ;874
0000d8  bf1c              ITT      NE                    ;874
0000da  f1a04180          SUBNE    r1,r0,#0x40000000     ;874
0000de  f5b1319a          SUBSNE   r1,r1,#0x13400        ;874
0000e2  d103              BNE      |L54.236|
0000e4  6c41              LDR      r1,[r0,#0x44]         ;877
0000e6  f4414100          ORR      r1,r1,#0x8000         ;877
0000ea  6441              STR      r1,[r0,#0x44]         ;877
                  |L54.236|
0000ec  6820              LDR      r0,[r4,#0]            ;881
0000ee  6801              LDR      r1,[r0,#0]            ;881
0000f0  f0410101          ORR      r1,r1,#1              ;881
0000f4  6001              STR      r1,[r0,#0]            ;881
0000f6  2000              MOVS     r0,#0                 ;884
0000f8  bd70              POP      {r4-r6,pc}
;;;886    
                          ENDP

0000fa  0000              DCW      0x0000
                  |L54.252|
                          DCD      TIM_DMADelayPulseCplt
                  |L54.256|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_OC_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_Start_IT PROC
;;;646    */
;;;647    HAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  6802              LDR      r2,[r0,#0]
;;;648    {
;;;649      /* Check the parameters */
;;;650      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;651    
;;;652      switch (Channel)
000002  2900              CMP      r1,#0
;;;653      {
;;;654        case TIM_CHANNEL_1:
;;;655        {
;;;656          /* Enable the TIM Capture/Compare 1 interrupt */
;;;657          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000004  bf04              ITT      EQ
000006  68d3              LDREQ    r3,[r2,#0xc]
000008  f0430302          ORREQ    r3,r3,#2
00000c  d011              BEQ      |L55.50|
00000e  2904              CMP      r1,#4                 ;652
;;;658        }
;;;659        break;
;;;660    
;;;661        case TIM_CHANNEL_2:
;;;662        {
;;;663          /* Enable the TIM Capture/Compare 2 interrupt */
;;;664          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000010  bf04              ITT      EQ
000012  68d3              LDREQ    r3,[r2,#0xc]
000014  f0430304          ORREQ    r3,r3,#4
000018  d00b              BEQ      |L55.50|
00001a  2908              CMP      r1,#8                 ;652
;;;665        }
;;;666        break;
;;;667    
;;;668        case TIM_CHANNEL_3:
;;;669        {
;;;670          /* Enable the TIM Capture/Compare 3 interrupt */
;;;671          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
00001c  bf04              ITT      EQ
00001e  68d3              LDREQ    r3,[r2,#0xc]
000020  f0430308          ORREQ    r3,r3,#8
000024  d005              BEQ      |L55.50|
000026  290c              CMP      r1,#0xc               ;652
;;;672        }
;;;673        break;
;;;674    
;;;675        case TIM_CHANNEL_4:
;;;676        {
;;;677          /* Enable the TIM Capture/Compare 4 interrupt */
;;;678          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
000028  bf04              ITT      EQ
00002a  68d3              LDREQ    r3,[r2,#0xc]
00002c  f0430310          ORREQ    r3,r3,#0x10
000030  d100              BNE      |L55.52|
                  |L55.50|
000032  60d3              STR      r3,[r2,#0xc]          ;671
                  |L55.52|
000034  6802              LDR      r2,[r0,#0]            ;671
000036  2301              MOVS     r3,#1                 ;671
000038  fa03f101          LSL      r1,r3,r1              ;671
00003c  6a13              LDR      r3,[r2,#0x20]         ;671
00003e  438b              BICS     r3,r3,r1              ;671
000040  6213              STR      r3,[r2,#0x20]         ;671
000042  6a13              LDR      r3,[r2,#0x20]         ;671
000044  4319              ORRS     r1,r1,r3              ;671
000046  6211              STR      r1,[r2,#0x20]         ;671
;;;679        }
;;;680        break;
;;;681    
;;;682        default:
;;;683        break;
;;;684      }
;;;685    
;;;686      /* Enable the Output compare channel */
;;;687      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;688    
;;;689      if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000048  6801              LDR      r1,[r0,#0]
00004a  f1a14280          SUB      r2,r1,#0x40000000
00004e  f5b23296          SUBS     r2,r2,#0x12c00
000052  bf1c              ITT      NE
000054  f1a14280          SUBNE    r2,r1,#0x40000000
000058  f5b2329a          SUBSNE   r2,r2,#0x13400
00005c  d103              BNE      |L55.102|
;;;690      {
;;;691        /* Enable the main output */
;;;692        __HAL_TIM_MOE_ENABLE(htim);
00005e  6c4a              LDR      r2,[r1,#0x44]
000060  f4424200          ORR      r2,r2,#0x8000
000064  644a              STR      r2,[r1,#0x44]
                  |L55.102|
;;;693      }
;;;694    
;;;695      /* Enable the Peripheral */
;;;696      __HAL_TIM_ENABLE(htim);
000066  6800              LDR      r0,[r0,#0]
000068  6801              LDR      r1,[r0,#0]
00006a  f0410101          ORR      r1,r1,#1
00006e  6001              STR      r1,[r0,#0]
;;;697    
;;;698      /* Return function status */
;;;699      return HAL_OK;
000070  2000              MOVS     r0,#0
;;;700    }
000072  4770              BX       lr
;;;701    
                          ENDP


                          AREA ||i.HAL_TIM_OC_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_Stop PROC
;;;614    */
;;;615    HAL_StatusTypeDef HAL_TIM_OC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b410              PUSH     {r4}
000002  6802              LDR      r2,[r0,#0]
000004  f04f0c01          MOV      r12,#1
;;;616    {
;;;617      /* Check the parameters */
;;;618      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;619    
;;;620      /* Disable the Output compare channel */
;;;621      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000008  2300              MOVS     r3,#0
00000a  6a14              LDR      r4,[r2,#0x20]
00000c  fa0cfc01          LSL      r12,r12,r1
000010  ea240c0c          BIC      r12,r4,r12
000014  f8c2c020          STR      r12,[r2,#0x20]
000018  f8d2c020          LDR      r12,[r2,#0x20]
00001c  fa03f101          LSL      r1,r3,r1
000020  ea4c0101          ORR      r1,r12,r1
000024  6211              STR      r1,[r2,#0x20]
;;;622    
;;;623      if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000026  6801              LDR      r1,[r0,#0]
;;;624      {
;;;625        /* Disable the Main Ouput */
;;;626        __HAL_TIM_MOE_DISABLE(htim);
000028  f2411311          MOV      r3,#0x1111
00002c  109a              ASRS     r2,r3,#2
00002e  f1a14c80          SUB      r12,r1,#0x40000000    ;623
000032  f5bc3c96          SUBS     r12,r12,#0x12c00      ;623
000036  bf1c              ITT      NE                    ;623
000038  f1a14c80          SUBNE    r12,r1,#0x40000000    ;623
00003c  f5bc3c9a          SUBSNE   r12,r12,#0x13400      ;623
000040  d10f              BNE      |L56.98|
000042  f8d1c020          LDR      r12,[r1,#0x20]
000046  ea1c0f03          TST      r12,r3
00004a  bf04              ITT      EQ
00004c  f8d1c020          LDREQ    r12,[r1,#0x20]
000050  ea1c0f02          TSTEQ    r12,r2
000054  d105              BNE      |L56.98|
000056  f8d1c044          LDR      r12,[r1,#0x44]
00005a  f42c4c00          BIC      r12,r12,#0x8000
00005e  f8c1c044          STR      r12,[r1,#0x44]
                  |L56.98|
;;;627      }
;;;628    
;;;629      /* Disable the Peripheral */
;;;630      __HAL_TIM_DISABLE(htim);
000062  6800              LDR      r0,[r0,#0]
000064  6a01              LDR      r1,[r0,#0x20]
000066  4219              TST      r1,r3
000068  bf04              ITT      EQ
00006a  6a01              LDREQ    r1,[r0,#0x20]
00006c  4211              TSTEQ    r1,r2
00006e  d103              BNE      |L56.120|
000070  6801              LDR      r1,[r0,#0]
000072  f0210101          BIC      r1,r1,#1
000076  6001              STR      r1,[r0,#0]
                  |L56.120|
;;;631    
;;;632      /* Return function status */
;;;633      return HAL_OK;
;;;634    }
000078  bc10              POP      {r4}
00007a  2000              MOVS     r0,#0                 ;633
00007c  4770              BX       lr
;;;635    
                          ENDP


                          AREA ||i.HAL_TIM_OC_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_Stop_DMA PROC
;;;897    */
;;;898    HAL_StatusTypeDef HAL_TIM_OC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b430              PUSH     {r4,r5}
;;;899    {
;;;900      /* Check the parameters */
;;;901      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;902    
;;;903      switch (Channel)
000002  6802              LDR      r2,[r0,#0]
000004  2900              CMP      r1,#0
;;;904      {
;;;905        case TIM_CHANNEL_1:
;;;906        {
;;;907          /* Disable the TIM Capture/Compare 1 DMA request */
;;;908          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000006  bf04              ITT      EQ
000008  68d3              LDREQ    r3,[r2,#0xc]
00000a  f4237300          BICEQ    r3,r3,#0x200
00000e  d011              BEQ      |L57.52|
000010  2904              CMP      r1,#4                 ;903
;;;909        }
;;;910        break;
;;;911    
;;;912        case TIM_CHANNEL_2:
;;;913        {
;;;914          /* Disable the TIM Capture/Compare 2 DMA request */
;;;915          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000012  bf04              ITT      EQ
000014  68d3              LDREQ    r3,[r2,#0xc]
000016  f4236380          BICEQ    r3,r3,#0x400
00001a  d00b              BEQ      |L57.52|
00001c  2908              CMP      r1,#8                 ;903
;;;916        }
;;;917        break;
;;;918    
;;;919        case TIM_CHANNEL_3:
;;;920        {
;;;921          /* Disable the TIM Capture/Compare 3 DMA request */
;;;922          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
00001e  bf04              ITT      EQ
000020  68d3              LDREQ    r3,[r2,#0xc]
000022  f4236300          BICEQ    r3,r3,#0x800
000026  d005              BEQ      |L57.52|
000028  290c              CMP      r1,#0xc               ;903
;;;923        }
;;;924        break;
;;;925    
;;;926        case TIM_CHANNEL_4:
;;;927        {
;;;928          /* Disable the TIM Capture/Compare 4 interrupt */
;;;929          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
00002a  bf04              ITT      EQ
00002c  68d3              LDREQ    r3,[r2,#0xc]
00002e  f4235380          BICEQ    r3,r3,#0x1000
000032  d100              BNE      |L57.54|
                  |L57.52|
000034  60d3              STR      r3,[r2,#0xc]          ;922
                  |L57.54|
000036  6802              LDR      r2,[r0,#0]            ;922
000038  2301              MOVS     r3,#1                 ;922
;;;930        }
;;;931        break;
;;;932    
;;;933        default:
;;;934        break;
;;;935      }
;;;936    
;;;937      /* Disable the Output compare channel */
;;;938      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
00003a  f04f0c00          MOV      r12,#0
00003e  6a15              LDR      r5,[r2,#0x20]
000040  fa03f401          LSL      r4,r3,r1
000044  ea250404          BIC      r4,r5,r4
000048  6214              STR      r4,[r2,#0x20]
00004a  6a14              LDR      r4,[r2,#0x20]
00004c  fa0cf101          LSL      r1,r12,r1
000050  4321              ORRS     r1,r1,r4
000052  6211              STR      r1,[r2,#0x20]
;;;939    
;;;940      if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000054  6801              LDR      r1,[r0,#0]
;;;941      {
;;;942        /* Disable the Main Ouput */
;;;943        __HAL_TIM_MOE_DISABLE(htim);
000056  f2411c11          MOV      r12,#0x1111
00005a  f1a14480          SUB      r4,r1,#0x40000000     ;940
00005e  f2404244          MOV      r2,#0x444
000062  f5b43496          SUBS     r4,r4,#0x12c00        ;940
000066  bf1c              ITT      NE                    ;940
000068  f1a14480          SUBNE    r4,r1,#0x40000000     ;940
00006c  f5b4349a          SUBSNE   r4,r4,#0x13400        ;940
000070  d10a              BNE      |L57.136|
000072  6a0c              LDR      r4,[r1,#0x20]
000074  ea140f0c          TST      r4,r12
000078  bf04              ITT      EQ
00007a  6a0c              LDREQ    r4,[r1,#0x20]
00007c  4214              TSTEQ    r4,r2
00007e  d103              BNE      |L57.136|
000080  6c4c              LDR      r4,[r1,#0x44]
000082  f4244400          BIC      r4,r4,#0x8000
000086  644c              STR      r4,[r1,#0x44]
                  |L57.136|
;;;944      }
;;;945    
;;;946      /* Disable the Peripheral */
;;;947      __HAL_TIM_DISABLE(htim);
000088  6801              LDR      r1,[r0,#0]
00008a  6a0c              LDR      r4,[r1,#0x20]
00008c  ea140f0c          TST      r4,r12
000090  bf04              ITT      EQ
000092  f8d1c020          LDREQ    r12,[r1,#0x20]
000096  ea1c0f02          TSTEQ    r12,r2
00009a  d103              BNE      |L57.164|
00009c  680a              LDR      r2,[r1,#0]
00009e  f0220201          BIC      r2,r2,#1
0000a2  600a              STR      r2,[r1,#0]
                  |L57.164|
;;;948    
;;;949      /* Change the htim state */
;;;950      htim->State = HAL_TIM_STATE_READY;
0000a4  6403              STR      r3,[r0,#0x40]
;;;951    
;;;952      /* Return function status */
;;;953      return HAL_OK;
;;;954    }
0000a6  bc30              POP      {r4,r5}
0000a8  2000              MOVS     r0,#0                 ;953
0000aa  4770              BX       lr
;;;955    
                          ENDP


                          AREA ||i.HAL_TIM_OC_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_Stop_IT PROC
;;;712    */
;;;713    HAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b410              PUSH     {r4}
;;;714    {
;;;715      /* Check the parameters */
;;;716      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;717    
;;;718      switch (Channel)
000002  6802              LDR      r2,[r0,#0]
000004  2900              CMP      r1,#0
;;;719      {
;;;720        case TIM_CHANNEL_1:
;;;721        {
;;;722          /* Disable the TIM Capture/Compare 1 interrupt */
;;;723          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000006  bf04              ITT      EQ
000008  68d3              LDREQ    r3,[r2,#0xc]
00000a  f0230302          BICEQ    r3,r3,#2
00000e  d011              BEQ      |L58.52|
000010  2904              CMP      r1,#4                 ;718
;;;724        }
;;;725        break;
;;;726    
;;;727        case TIM_CHANNEL_2:
;;;728        {
;;;729          /* Disable the TIM Capture/Compare 2 interrupt */
;;;730          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000012  bf04              ITT      EQ
000014  68d3              LDREQ    r3,[r2,#0xc]
000016  f0230304          BICEQ    r3,r3,#4
00001a  d00b              BEQ      |L58.52|
00001c  2908              CMP      r1,#8                 ;718
;;;731        }
;;;732        break;
;;;733    
;;;734        case TIM_CHANNEL_3:
;;;735        {
;;;736          /* Disable the TIM Capture/Compare 3 interrupt */
;;;737          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
00001e  bf04              ITT      EQ
000020  68d3              LDREQ    r3,[r2,#0xc]
000022  f0230308          BICEQ    r3,r3,#8
000026  d005              BEQ      |L58.52|
000028  290c              CMP      r1,#0xc               ;718
;;;738        }
;;;739        break;
;;;740    
;;;741        case TIM_CHANNEL_4:
;;;742        {
;;;743          /* Disable the TIM Capture/Compare 4 interrupt */
;;;744          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
00002a  bf04              ITT      EQ
00002c  68d3              LDREQ    r3,[r2,#0xc]
00002e  f0230310          BICEQ    r3,r3,#0x10
000032  d100              BNE      |L58.54|
                  |L58.52|
000034  60d3              STR      r3,[r2,#0xc]          ;737
                  |L58.54|
000036  6802              LDR      r2,[r0,#0]            ;737
000038  f04f0c01          MOV      r12,#1                ;737
;;;745        }
;;;746        break;
;;;747    
;;;748        default:
;;;749        break;
;;;750      }
;;;751    
;;;752      /* Disable the Output compare channel */
;;;753      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
00003c  2300              MOVS     r3,#0
00003e  6a14              LDR      r4,[r2,#0x20]
000040  fa0cfc01          LSL      r12,r12,r1
000044  ea240c0c          BIC      r12,r4,r12
000048  f8c2c020          STR      r12,[r2,#0x20]
00004c  f8d2c020          LDR      r12,[r2,#0x20]
000050  fa03f101          LSL      r1,r3,r1
000054  ea4c0101          ORR      r1,r12,r1
000058  6211              STR      r1,[r2,#0x20]
;;;754    
;;;755      if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00005a  6801              LDR      r1,[r0,#0]
;;;756      {
;;;757        /* Disable the Main Ouput */
;;;758        __HAL_TIM_MOE_DISABLE(htim);
00005c  f2411211          MOV      r2,#0x1111
000060  1093              ASRS     r3,r2,#2
000062  f1a14c80          SUB      r12,r1,#0x40000000    ;755
000066  f5bc3c96          SUBS     r12,r12,#0x12c00      ;755
00006a  bf1c              ITT      NE                    ;755
00006c  f1a14c80          SUBNE    r12,r1,#0x40000000    ;755
000070  f5bc3c9a          SUBSNE   r12,r12,#0x13400      ;755
000074  d10f              BNE      |L58.150|
000076  f8d1c020          LDR      r12,[r1,#0x20]
00007a  ea1c0f02          TST      r12,r2
00007e  bf04              ITT      EQ
000080  f8d1c020          LDREQ    r12,[r1,#0x20]
000084  ea1c0f03          TSTEQ    r12,r3
000088  d105              BNE      |L58.150|
00008a  f8d1c044          LDR      r12,[r1,#0x44]
00008e  f42c4c00          BIC      r12,r12,#0x8000
000092  f8c1c044          STR      r12,[r1,#0x44]
                  |L58.150|
;;;759      }
;;;760    
;;;761      /* Disable the Peripheral */
;;;762      __HAL_TIM_DISABLE(htim);
000096  6800              LDR      r0,[r0,#0]
000098  6a01              LDR      r1,[r0,#0x20]
00009a  4211              TST      r1,r2
00009c  bf04              ITT      EQ
00009e  6a01              LDREQ    r1,[r0,#0x20]
0000a0  4219              TSTEQ    r1,r3
0000a2  d103              BNE      |L58.172|
0000a4  6801              LDR      r1,[r0,#0]
0000a6  f0210101          BIC      r1,r1,#1
0000aa  6001              STR      r1,[r0,#0]
                  |L58.172|
;;;763    
;;;764      /* Return function status */
;;;765      return HAL_OK;
;;;766    }
0000ac  bc10              POP      {r4}
0000ae  2000              MOVS     r0,#0                 ;765
0000b0  4770              BX       lr
;;;767    
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_ConfigChannel||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_ConfigChannel PROC
;;;3199     */
;;;3200   HAL_StatusTypeDef HAL_TIM_OnePulse_ConfigChannel(TIM_HandleTypeDef *htim,  TIM_OnePulse_InitTypeDef* sConfig, uint32_t OutputChannel,  uint32_t InputChannel)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;3201   {
000004  4699              MOV      r9,r3
000006  b087              SUB      sp,sp,#0x1c
000008  460d              MOV      r5,r1
00000a  4604              MOV      r4,r0
;;;3202     TIM_OC_InitTypeDef temp1;
;;;3203   
;;;3204     /* Check the parameters */
;;;3205     assert_param(IS_TIM_OPM_CHANNELS(OutputChannel));
;;;3206     assert_param(IS_TIM_OPM_CHANNELS(InputChannel));
;;;3207   
;;;3208     if(OutputChannel != InputChannel)
00000c  454a              CMP      r2,r9
;;;3209     {
;;;3210     __HAL_LOCK(htim);
;;;3211   
;;;3212     htim->State = HAL_TIM_STATE_BUSY;
;;;3213   
;;;3214     /* Extract the Ouput compare configuration from sConfig structure */
;;;3215     temp1.OCMode = sConfig->OCMode;
;;;3216     temp1.Pulse = sConfig->Pulse;
;;;3217     temp1.OCPolarity = sConfig->OCPolarity;
;;;3218     temp1.OCNPolarity = sConfig->OCNPolarity;
;;;3219     temp1.OCIdleState = sConfig->OCIdleState;
;;;3220     temp1.OCNIdleState = sConfig->OCNIdleState;
;;;3221   
;;;3222       switch (OutputChannel)
;;;3223     {
;;;3224       case TIM_CHANNEL_1:
;;;3225       {
;;;3226           assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3227   
;;;3228         TIM_OC1_SetConfig(htim->Instance, &temp1);
;;;3229       }
;;;3230       break;
;;;3231       case TIM_CHANNEL_2:
;;;3232       {
;;;3233           assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3234   
;;;3235         TIM_OC2_SetConfig(htim->Instance, &temp1);
;;;3236       }
;;;3237       break;
;;;3238       default:
;;;3239       break;
;;;3240     }
;;;3241     switch (InputChannel)
;;;3242     {
;;;3243       case TIM_CHANNEL_1:
;;;3244       {
;;;3245         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3246   
;;;3247         TIM_TI1_SetConfig(htim->Instance, sConfig->ICPolarity,
;;;3248                           sConfig->ICSelection, sConfig->ICFilter);
;;;3249   
;;;3250         /* Reset the IC1PSC Bits */
;;;3251       htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
;;;3252   
;;;3253         /* Select the Trigger source */
;;;3254           htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;3255         htim->Instance->SMCR |= TIM_TS_TI1FP1;
;;;3256   
;;;3257         /* Select the Slave Mode */
;;;3258           htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;3259         htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
;;;3260       }
;;;3261       break;
;;;3262       case TIM_CHANNEL_2:
;;;3263       {
;;;3264         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3265   
;;;3266         TIM_TI2_SetConfig(htim->Instance, sConfig->ICPolarity,
;;;3267                    sConfig->ICSelection, sConfig->ICFilter);
;;;3268   
;;;3269         /* Reset the IC2PSC Bits */
;;;3270           htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
;;;3271   
;;;3272         /* Select the Trigger source */
;;;3273           htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;3274         htim->Instance->SMCR |= TIM_TS_TI2FP2;
;;;3275   
;;;3276         /* Select the Slave Mode */
;;;3277           htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;3278         htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
;;;3279       }
;;;3280       break;
;;;3281   
;;;3282       default:
;;;3283       break;
;;;3284     }
;;;3285   
;;;3286     htim->State = HAL_TIM_STATE_READY;
;;;3287   
;;;3288     __HAL_UNLOCK(htim);
;;;3289   
;;;3290     return HAL_OK;
;;;3291   }
;;;3292     else
;;;3293     {
;;;3294       return HAL_ERROR;
00000e  bf02              ITTT     EQ
000010  2001              MOVEQ    r0,#1
;;;3295     }
;;;3296   }
000012  b007              ADDEQ    sp,sp,#0x1c
000014  e8bd83f0          POPEQ    {r4-r9,pc}
000018  6be0              LDR      r0,[r4,#0x3c]         ;3210
00001a  2801              CMP      r0,#1                 ;3210
00001c  bf02              ITTT     EQ                    ;3210
00001e  2002              MOVEQ    r0,#2                 ;3210
000020  b007              ADDEQ    sp,sp,#0x1c
000022  e8bd83f0          POPEQ    {r4-r9,pc}
000026  2601              MOVS     r6,#1                 ;3210
000028  2002              MOVS     r0,#2                 ;3212
00002a  63e6              STR      r6,[r4,#0x3c]         ;3212
00002c  6420              STR      r0,[r4,#0x40]         ;3212
00002e  6828              LDR      r0,[r5,#0]            ;3215
000030  9000              STR      r0,[sp,#0]            ;3216
000032  6868              LDR      r0,[r5,#4]            ;3216
000034  9001              STR      r0,[sp,#4]            ;3217
000036  68a8              LDR      r0,[r5,#8]            ;3217
000038  9002              STR      r0,[sp,#8]            ;3218
00003a  68e8              LDR      r0,[r5,#0xc]          ;3218
00003c  9003              STR      r0,[sp,#0xc]          ;3219
00003e  6928              LDR      r0,[r5,#0x10]         ;3219
000040  9005              STR      r0,[sp,#0x14]         ;3220
000042  6968              LDR      r0,[r5,#0x14]         ;3220
000044  4f68              LDR      r7,|L59.488|
000046  f8df81a4          LDR      r8,|L59.492|
00004a  9006              STR      r0,[sp,#0x18]         ;3210
00004c  b112              CBZ      r2,|L59.84|
00004e  2a04              CMP      r2,#4                 ;3222
000050  d034              BEQ      |L59.188|
000052  e037              B        |L59.196|
                  |L59.84|
000054  6820              LDR      r0,[r4,#0]            ;3222
000056  6a01              LDR      r1,[r0,#0x20]         ;3222
000058  f0210101          BIC      r1,r1,#1              ;3222
00005c  6201              STR      r1,[r0,#0x20]         ;3222
00005e  6a01              LDR      r1,[r0,#0x20]         ;3222
000060  6842              LDR      r2,[r0,#4]            ;3222
000062  6983              LDR      r3,[r0,#0x18]         ;3222
000064  f8ddc000          LDR      r12,[sp,#0]           ;3222
000068  f0230373          BIC      r3,r3,#0x73           ;3222
00006c  ea4c0303          ORR      r3,r12,r3             ;3222
000070  f8ddc008          LDR      r12,[sp,#8]           ;3222
000074  f0210102          BIC      r1,r1,#2              ;3222
000078  ea4c0101          ORR      r1,r12,r1             ;3222
00007c  42b8              CMP      r0,r7                 ;3222
00007e  bf18              IT       NE                    ;3222
000080  4540              CMPNE    r0,r8                 ;3222
000082  d107              BNE      |L59.148|
000084  f8ddc00c          LDR      r12,[sp,#0xc]         ;3228
000088  f0210108          BIC      r1,r1,#8              ;3228
00008c  ea4c0101          ORR      r1,r12,r1             ;3228
000090  f0210104          BIC      r1,r1,#4              ;3228
                  |L59.148|
000094  42b8              CMP      r0,r7                 ;3228
000096  bf18              IT       NE                    ;3228
000098  4540              CMPNE    r0,r8                 ;3228
00009a  d109              BNE      |L59.176|
00009c  f8ddc014          LDR      r12,[sp,#0x14]        ;3228
0000a0  f4227240          BIC      r2,r2,#0x300          ;3228
0000a4  ea4c0202          ORR      r2,r12,r2             ;3228
0000a8  f8ddc018          LDR      r12,[sp,#0x18]        ;3228
0000ac  ea4c0202          ORR      r2,r12,r2             ;3228
                  |L59.176|
0000b0  6042              STR      r2,[r0,#4]            ;3228
0000b2  6183              STR      r3,[r0,#0x18]         ;3228
0000b4  9a01              LDR      r2,[sp,#4]            ;3228
0000b6  6342              STR      r2,[r0,#0x34]         ;3228
0000b8  6201              STR      r1,[r0,#0x20]         ;3228
0000ba  e003              B        |L59.196|
                  |L59.188|
0000bc  4669              MOV      r1,sp                 ;3235
0000be  6820              LDR      r0,[r4,#0]            ;3235
0000c0  f7fffffe          BL       TIM_OC2_SetConfig
                  |L59.196|
0000c4  f1b90f00          CMP      r9,#0                 ;3241
0000c8  d003              BEQ      |L59.210|
0000ca  f1b90f04          CMP      r9,#4                 ;3241
0000ce  d04e              BEQ      |L59.366|
0000d0  e084              B        |L59.476|
                  |L59.210|
0000d2  6820              LDR      r0,[r4,#0]            ;3247
0000d4  e9d52c06          LDRD     r2,r12,[r5,#0x18]     ;3247
0000d8  6a2b              LDR      r3,[r5,#0x20]         ;3247
0000da  6a01              LDR      r1,[r0,#0x20]         ;3247
0000dc  f0210101          BIC      r1,r1,#1              ;3247
0000e0  6201              STR      r1,[r0,#0x20]         ;3247
0000e2  6981              LDR      r1,[r0,#0x18]         ;3247
0000e4  6a05              LDR      r5,[r0,#0x20]         ;3247
0000e6  42b8              CMP      r0,r7                 ;3247
0000e8  bf18              IT       NE                    ;3247
0000ea  4540              CMPNE    r0,r8                 ;3247
0000ec  d013              BEQ      |L59.278|
0000ee  f1b04f80          CMP      r0,#0x40000000        ;3247
0000f2  bf1c              ITT      NE                    ;3247
0000f4  f1a04780          SUBNE    r7,r0,#0x40000000     ;3247
0000f8  f5b76780          SUBSNE   r7,r7,#0x400          ;3247
0000fc  d00b              BEQ      |L59.278|
0000fe  f1a04780          SUB      r7,r0,#0x40000000     ;3247
000102  f5b76700          SUBS     r7,r7,#0x800          ;3247
000106  bf1e              ITTT     NE                    ;3247
000108  f1a04780          SUBNE    r7,r0,#0x40000000     ;3247
00010c  f5b76740          SUBSNE   r7,r7,#0xc00          ;3247
000110  f0410101          ORRNE    r1,r1,#1              ;3247
000114  d103              BNE      |L59.286|
                  |L59.278|
000116  f0210103          BIC      r1,r1,#3              ;3247
00011a  ea41010c          ORR      r1,r1,r12             ;3247
                  |L59.286|
00011e  f04f0cf0          MOV      r12,#0xf0             ;3247
000122  f02101f0          BIC      r1,r1,#0xf0           ;3247
000126  ea0c1303          AND      r3,r12,r3,LSL #4      ;3247
00012a  4319              ORRS     r1,r1,r3              ;3247
00012c  f025030a          BIC      r3,r5,#0xa            ;3247
000130  f002020a          AND      r2,r2,#0xa            ;3247
000134  431a              ORRS     r2,r2,r3              ;3247
000136  6181              STR      r1,[r0,#0x18]         ;3247
000138  6202              STR      r2,[r0,#0x20]         ;3247
00013a  6820              LDR      r0,[r4,#0]            ;3251
00013c  6981              LDR      r1,[r0,#0x18]         ;3251
00013e  f021010c          BIC      r1,r1,#0xc            ;3251
000142  6181              STR      r1,[r0,#0x18]         ;3251
000144  6820              LDR      r0,[r4,#0]            ;3254
000146  6881              LDR      r1,[r0,#8]            ;3254
000148  f0210170          BIC      r1,r1,#0x70           ;3254
00014c  6081              STR      r1,[r0,#8]            ;3254
00014e  6820              LDR      r0,[r4,#0]            ;3255
000150  6881              LDR      r1,[r0,#8]            ;3255
000152  f0410150          ORR      r1,r1,#0x50           ;3255
000156  6081              STR      r1,[r0,#8]            ;3255
000158  6820              LDR      r0,[r4,#0]            ;3258
00015a  6881              LDR      r1,[r0,#8]            ;3258
00015c  f0210107          BIC      r1,r1,#7              ;3258
000160  6081              STR      r1,[r0,#8]            ;3258
000162  6820              LDR      r0,[r4,#0]            ;3259
000164  6881              LDR      r1,[r0,#8]            ;3259
000166  f0410106          ORR      r1,r1,#6              ;3259
00016a  6081              STR      r1,[r0,#8]            ;3259
00016c  e036              B        |L59.476|
                  |L59.366|
00016e  6820              LDR      r0,[r4,#0]            ;3266
000170  e9d51307          LDRD     r1,r3,[r5,#0x1c]      ;3266
000174  69af              LDR      r7,[r5,#0x18]         ;3266
000176  6a02              LDR      r2,[r0,#0x20]         ;3266
000178  f0220210          BIC      r2,r2,#0x10           ;3266
00017c  6202              STR      r2,[r0,#0x20]         ;3266
00017e  f8d0c018          LDR      r12,[r0,#0x18]        ;3266
000182  6a02              LDR      r2,[r0,#0x20]         ;3266
000184  f42c7c40          BIC      r12,r12,#0x300        ;3266
000188  ea4c2101          ORR      r1,r12,r1,LSL #8      ;3266
00018c  f44f4c70          MOV      r12,#0xf000           ;3266
000190  f4214170          BIC      r1,r1,#0xf000         ;3266
000194  ea0c3303          AND      r3,r12,r3,LSL #12     ;3266
000198  4319              ORRS     r1,r1,r3              ;3266
00019a  23a0              MOVS     r3,#0xa0              ;3266
00019c  f02202a0          BIC      r2,r2,#0xa0           ;3266
0001a0  ea031307          AND      r3,r3,r7,LSL #4       ;3266
0001a4  431a              ORRS     r2,r2,r3              ;3266
0001a6  6181              STR      r1,[r0,#0x18]         ;3266
0001a8  6202              STR      r2,[r0,#0x20]         ;3266
0001aa  6820              LDR      r0,[r4,#0]            ;3270
0001ac  6981              LDR      r1,[r0,#0x18]         ;3270
0001ae  f4216140          BIC      r1,r1,#0xc00          ;3270
0001b2  6181              STR      r1,[r0,#0x18]         ;3270
0001b4  6820              LDR      r0,[r4,#0]            ;3273
0001b6  6881              LDR      r1,[r0,#8]            ;3273
0001b8  f0210170          BIC      r1,r1,#0x70           ;3273
0001bc  6081              STR      r1,[r0,#8]            ;3273
0001be  6820              LDR      r0,[r4,#0]            ;3274
0001c0  6881              LDR      r1,[r0,#8]            ;3274
0001c2  f0410160          ORR      r1,r1,#0x60           ;3274
0001c6  6081              STR      r1,[r0,#8]            ;3274
0001c8  6820              LDR      r0,[r4,#0]            ;3277
0001ca  6881              LDR      r1,[r0,#8]            ;3277
0001cc  f0210107          BIC      r1,r1,#7              ;3277
0001d0  6081              STR      r1,[r0,#8]            ;3277
0001d2  6820              LDR      r0,[r4,#0]            ;3278
0001d4  6881              LDR      r1,[r0,#8]            ;3278
0001d6  f0410106          ORR      r1,r1,#6              ;3278
0001da  6081              STR      r1,[r0,#8]            ;3278
                  |L59.476|
0001dc  6426              STR      r6,[r4,#0x40]         ;3286
0001de  2000              MOVS     r0,#0                 ;3288
0001e0  63e0              STR      r0,[r4,#0x3c]         ;3288
0001e2  b007              ADD      sp,sp,#0x1c
0001e4  e8bd83f0          POP      {r4-r9,pc}
;;;3297   
                          ENDP

                  |L59.488|
                          DCD      0x40012c00
                  |L59.492|
                          DCD      0x40013400

                          AREA ||i.HAL_TIM_OnePulse_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_DeInit PROC
;;;2015     */
;;;2016   HAL_StatusTypeDef HAL_TIM_OnePulse_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;2017   {
000002  4604              MOV      r4,r0
;;;2018     /* Check the parameters */
;;;2019     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;2020   
;;;2021     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  6420              STR      r0,[r4,#0x40]
;;;2022   
;;;2023     /* Disable the TIM Peripheral Clock */
;;;2024     __HAL_TIM_DISABLE(htim);
000008  6820              LDR      r0,[r4,#0]
00000a  6a01              LDR      r1,[r0,#0x20]
00000c  f2411211          MOV      r2,#0x1111
000010  4211              TST      r1,r2
000012  d107              BNE      |L60.36|
000014  6a01              LDR      r1,[r0,#0x20]
000016  1092              ASRS     r2,r2,#2
000018  4211              TST      r1,r2
00001a  d103              BNE      |L60.36|
00001c  6801              LDR      r1,[r0,#0]
00001e  f0210101          BIC      r1,r1,#1
000022  6001              STR      r1,[r0,#0]
                  |L60.36|
;;;2025   
;;;2026     /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;2027     HAL_TIM_OnePulse_MspDeInit(htim);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       HAL_TIM_OnePulse_MspDeInit
;;;2028   
;;;2029     /* Change TIM state */
;;;2030     htim->State = HAL_TIM_STATE_RESET;
00002a  2000              MOVS     r0,#0
00002c  6420              STR      r0,[r4,#0x40]
;;;2031   
;;;2032     /* Release Lock */
;;;2033     __HAL_UNLOCK(htim);
00002e  63e0              STR      r0,[r4,#0x3c]
;;;2034   
;;;2035     return HAL_OK;
;;;2036   }
000030  bd10              POP      {r4,pc}
;;;2037   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_GetState PROC
;;;4428     */
;;;4429   HAL_TIM_StateTypeDef HAL_TIM_OnePulse_GetState(TIM_HandleTypeDef *htim)
000000  6c00              LDR      r0,[r0,#0x40]
;;;4430   {
;;;4431     return htim->State;
;;;4432   }
000002  4770              BX       lr
;;;4433   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_Init PROC
;;;1968     */
;;;1969   HAL_StatusTypeDef HAL_TIM_OnePulse_Init(TIM_HandleTypeDef *htim, uint32_t OnePulseMode)
000000  2800              CMP      r0,#0
;;;1970   {
;;;1971     /* Check the TIM handle allocation */
;;;1972     if(htim == NULL)
;;;1973     {
;;;1974       return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;1975     }
;;;1976   
;;;1977     /* Check the parameters */
;;;1978     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1979     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;1980     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;1981     assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;1982     assert_param(IS_TIM_OPM_MODE(OnePulseMode));
;;;1983   
;;;1984     if(htim->State == HAL_TIM_STATE_RESET)
;;;1985     {
;;;1986       /* Allocate lock resource and initialize it */
;;;1987       htim->Lock = HAL_UNLOCKED;
;;;1988       
;;;1989       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;1990       HAL_TIM_OnePulse_MspInit(htim);
;;;1991     }
;;;1992   
;;;1993     /* Set the TIM state */
;;;1994     htim->State= HAL_TIM_STATE_BUSY;
;;;1995   
;;;1996     /* Configure the Time base in the One Pulse Mode */
;;;1997     TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;1998   
;;;1999     /* Reset the OPM Bit */
;;;2000     htim->Instance->CR1 &= ~TIM_CR1_OPM;
;;;2001   
;;;2002     /* Configure the OPM Mode */
;;;2003     htim->Instance->CR1 |= OnePulseMode;
;;;2004   
;;;2005     /* Initialize the TIM state*/
;;;2006     htim->State= HAL_TIM_STATE_READY;
;;;2007   
;;;2008     return HAL_OK;
;;;2009   }
000006  4770              BXEQ     lr
000008  b570              PUSH     {r4-r6,lr}            ;1970
00000a  4604              MOV      r4,r0                 ;1970
00000c  6c00              LDR      r0,[r0,#0x40]         ;1984
00000e  460d              MOV      r5,r1                 ;1970
000010  b920              CBNZ     r0,|L62.28|
000012  2000              MOVS     r0,#0                 ;1987
000014  63e0              STR      r0,[r4,#0x3c]         ;1990
000016  4620              MOV      r0,r4                 ;1990
000018  f7fffffe          BL       HAL_TIM_OnePulse_MspInit
                  |L62.28|
00001c  2002              MOVS     r0,#2                 ;1994
00001e  6420              STR      r0,[r4,#0x40]         ;1994
000020  1d21              ADDS     r1,r4,#4              ;1997
000022  6820              LDR      r0,[r4,#0]            ;1997
000024  f7fffffe          BL       TIM_Base_SetConfig
000028  6820              LDR      r0,[r4,#0]            ;2000
00002a  6801              LDR      r1,[r0,#0]            ;2000
00002c  f0210108          BIC      r1,r1,#8              ;2000
000030  6001              STR      r1,[r0,#0]            ;2000
000032  6820              LDR      r0,[r4,#0]            ;2003
000034  6801              LDR      r1,[r0,#0]            ;2003
000036  4329              ORRS     r1,r1,r5              ;2003
000038  6001              STR      r1,[r0,#0]            ;2003
00003a  2001              MOVS     r0,#1                 ;2006
00003c  6420              STR      r0,[r4,#0x40]         ;2006
00003e  2000              MOVS     r0,#0                 ;2008
000040  bd70              POP      {r4-r6,pc}
;;;2010   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_MspDeInit PROC
;;;2056     */
;;;2057   __weak void HAL_TIM_OnePulse_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2058   {
;;;2059     /* Prevent unused argument(s) compilation warning */
;;;2060     UNUSED(htim);
;;;2061     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2062               the HAL_TIM_OnePulse_MspDeInit could be implemented in the user file
;;;2063      */
;;;2064   }
;;;2065   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_MspInit PROC
;;;2042     */
;;;2043   __weak void HAL_TIM_OnePulse_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2044   {
;;;2045     /* Prevent unused argument(s) compilation warning */
;;;2046     UNUSED(htim);
;;;2047     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2048               the HAL_TIM_OnePulse_MspInit could be implemented in the user file
;;;2049      */
;;;2050   }
;;;2051   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_Start PROC
;;;2074   */
;;;2075   HAL_StatusTypeDef HAL_TIM_OnePulse_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  6801              LDR      r1,[r0,#0]
000002  6a0a              LDR      r2,[r1,#0x20]
000004  f0220201          BIC      r2,r2,#1
000008  620a              STR      r2,[r1,#0x20]
00000a  6a0a              LDR      r2,[r1,#0x20]
00000c  f0420201          ORR      r2,r2,#1
000010  620a              STR      r2,[r1,#0x20]
000012  6801              LDR      r1,[r0,#0]
000014  6a0a              LDR      r2,[r1,#0x20]
000016  f0220210          BIC      r2,r2,#0x10
00001a  620a              STR      r2,[r1,#0x20]
00001c  6a0a              LDR      r2,[r1,#0x20]
00001e  f0420210          ORR      r2,r2,#0x10
000022  620a              STR      r2,[r1,#0x20]
;;;2076   {
;;;2077     /* Prevent unused argument(s) compilation warning */
;;;2078     UNUSED(OutputChannel);
;;;2079   
;;;2080     /* Enable the Capture compare and the Input Capture channels 
;;;2081       (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2082       if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2083       if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2084       in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
;;;2085   
;;;2086       No need to enable the counter, it's enabled automatically by hardware 
;;;2087       (the counter starts in response to a stimulus and generate a pulse */
;;;2088   
;;;2089     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2090     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2091   
;;;2092     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000024  6800              LDR      r0,[r0,#0]
000026  f1a04180          SUB      r1,r0,#0x40000000
00002a  f5b13196          SUBS     r1,r1,#0x12c00
00002e  bf1c              ITT      NE
000030  f1a04180          SUBNE    r1,r0,#0x40000000
000034  f5b1319a          SUBSNE   r1,r1,#0x13400
000038  d103              BNE      |L65.66|
;;;2093     {
;;;2094       /* Enable the main output */
;;;2095       __HAL_TIM_MOE_ENABLE(htim);
00003a  6c41              LDR      r1,[r0,#0x44]
00003c  f4414100          ORR      r1,r1,#0x8000
000040  6441              STR      r1,[r0,#0x44]
                  |L65.66|
;;;2096     }
;;;2097   
;;;2098     /* Return function status */
;;;2099     return HAL_OK;
000042  2000              MOVS     r0,#0
;;;2100   }
000044  4770              BX       lr
;;;2101   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_Start_IT PROC
;;;2146   */
;;;2147   HAL_StatusTypeDef HAL_TIM_OnePulse_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  6801              LDR      r1,[r0,#0]
;;;2148   {
;;;2149     /* Prevent unused argument(s) compilation warning */
;;;2150     UNUSED(OutputChannel);
;;;2151   
;;;2152     /* Enable the Capture compare and the Input Capture channels 
;;;2153       (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2154       if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2155       if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2156       in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
;;;2157   
;;;2158       No need to enable the counter, it's enabled automatically by hardware 
;;;2159       (the counter starts in response to a stimulus and generate a pulse */
;;;2160   
;;;2161     /* Enable the TIM Capture/Compare 1 interrupt */
;;;2162     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000002  68ca              LDR      r2,[r1,#0xc]
000004  f0420202          ORR      r2,r2,#2
000008  60ca              STR      r2,[r1,#0xc]
;;;2163   
;;;2164     /* Enable the TIM Capture/Compare 2 interrupt */
;;;2165     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
00000a  6801              LDR      r1,[r0,#0]
00000c  68ca              LDR      r2,[r1,#0xc]
00000e  f0420204          ORR      r2,r2,#4
000012  60ca              STR      r2,[r1,#0xc]
000014  6801              LDR      r1,[r0,#0]
000016  6a0a              LDR      r2,[r1,#0x20]
000018  f0220201          BIC      r2,r2,#1
00001c  620a              STR      r2,[r1,#0x20]
00001e  6a0a              LDR      r2,[r1,#0x20]
000020  f0420201          ORR      r2,r2,#1
000024  620a              STR      r2,[r1,#0x20]
000026  6801              LDR      r1,[r0,#0]
000028  6a0a              LDR      r2,[r1,#0x20]
00002a  f0220210          BIC      r2,r2,#0x10
00002e  620a              STR      r2,[r1,#0x20]
000030  6a0a              LDR      r2,[r1,#0x20]
000032  f0420210          ORR      r2,r2,#0x10
000036  620a              STR      r2,[r1,#0x20]
;;;2166   
;;;2167     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2168     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2169   
;;;2170     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000038  6800              LDR      r0,[r0,#0]
00003a  f1a04180          SUB      r1,r0,#0x40000000
00003e  f5b13196          SUBS     r1,r1,#0x12c00
000042  bf1c              ITT      NE
000044  f1a04180          SUBNE    r1,r0,#0x40000000
000048  f5b1319a          SUBSNE   r1,r1,#0x13400
00004c  d103              BNE      |L66.86|
;;;2171     {
;;;2172       /* Enable the main output */
;;;2173       __HAL_TIM_MOE_ENABLE(htim);
00004e  6c41              LDR      r1,[r0,#0x44]
000050  f4414100          ORR      r1,r1,#0x8000
000054  6441              STR      r1,[r0,#0x44]
                  |L66.86|
;;;2174     }
;;;2175   
;;;2176     /* Return function status */
;;;2177     return HAL_OK;
000056  2000              MOVS     r0,#0
;;;2178   }
000058  4770              BX       lr
;;;2179   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_Stop PROC
;;;2110   */
;;;2111   HAL_StatusTypeDef HAL_TIM_OnePulse_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  6801              LDR      r1,[r0,#0]
000002  6a0a              LDR      r2,[r1,#0x20]
000004  f0220201          BIC      r2,r2,#1
000008  620a              STR      r2,[r1,#0x20]
00000a  6a0a              LDR      r2,[r1,#0x20]
00000c  620a              STR      r2,[r1,#0x20]
00000e  6801              LDR      r1,[r0,#0]
000010  6a0a              LDR      r2,[r1,#0x20]
000012  f0220210          BIC      r2,r2,#0x10
000016  620a              STR      r2,[r1,#0x20]
000018  6a0a              LDR      r2,[r1,#0x20]
00001a  620a              STR      r2,[r1,#0x20]
;;;2112   {
;;;2113     /* Prevent unused argument(s) compilation warning */
;;;2114     UNUSED(OutputChannel);
;;;2115   
;;;2116     /* Disable the Capture compare and the Input Capture channels
;;;2117     (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2118     if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2119     if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2120     in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
;;;2121   
;;;2122     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
;;;2123     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
;;;2124   
;;;2125     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00001c  6801              LDR      r1,[r0,#0]
;;;2126     {
;;;2127       /* Disable the Main Ouput */
;;;2128       __HAL_TIM_MOE_DISABLE(htim);
00001e  f2411211          MOV      r2,#0x1111
000022  1093              ASRS     r3,r2,#2
000024  f1a14c80          SUB      r12,r1,#0x40000000    ;2125
000028  f5bc3c96          SUBS     r12,r12,#0x12c00      ;2125
00002c  bf1c              ITT      NE                    ;2125
00002e  f1a14c80          SUBNE    r12,r1,#0x40000000    ;2125
000032  f5bc3c9a          SUBSNE   r12,r12,#0x13400      ;2125
000036  d10f              BNE      |L67.88|
000038  f8d1c020          LDR      r12,[r1,#0x20]
00003c  ea1c0f02          TST      r12,r2
000040  bf04              ITT      EQ
000042  f8d1c020          LDREQ    r12,[r1,#0x20]
000046  ea1c0f03          TSTEQ    r12,r3
00004a  d105              BNE      |L67.88|
00004c  f8d1c044          LDR      r12,[r1,#0x44]
000050  f42c4c00          BIC      r12,r12,#0x8000
000054  f8c1c044          STR      r12,[r1,#0x44]
                  |L67.88|
;;;2129     }
;;;2130   
;;;2131     /* Disable the Peripheral */
;;;2132     __HAL_TIM_DISABLE(htim);
000058  6800              LDR      r0,[r0,#0]
00005a  6a01              LDR      r1,[r0,#0x20]
00005c  4211              TST      r1,r2
00005e  bf04              ITT      EQ
000060  6a01              LDREQ    r1,[r0,#0x20]
000062  4219              TSTEQ    r1,r3
000064  d103              BNE      |L67.110|
000066  6801              LDR      r1,[r0,#0]
000068  f0210101          BIC      r1,r1,#1
00006c  6001              STR      r1,[r0,#0]
                  |L67.110|
;;;2133   
;;;2134     /* Return function status */
;;;2135     return HAL_OK;
00006e  2000              MOVS     r0,#0
;;;2136   }
000070  4770              BX       lr
;;;2137   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_Stop_IT PROC
;;;2188   */
;;;2189   HAL_StatusTypeDef HAL_TIM_OnePulse_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  6801              LDR      r1,[r0,#0]
;;;2190   {
;;;2191     /* Prevent unused argument(s) compilation warning */
;;;2192     UNUSED(OutputChannel);
;;;2193   
;;;2194     /* Disable the TIM Capture/Compare 1 interrupt */
;;;2195     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000002  68ca              LDR      r2,[r1,#0xc]
000004  f0220202          BIC      r2,r2,#2
000008  60ca              STR      r2,[r1,#0xc]
;;;2196   
;;;2197     /* Disable the TIM Capture/Compare 2 interrupt */
;;;2198     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00000a  6801              LDR      r1,[r0,#0]
00000c  68ca              LDR      r2,[r1,#0xc]
00000e  f0220204          BIC      r2,r2,#4
000012  60ca              STR      r2,[r1,#0xc]
000014  6801              LDR      r1,[r0,#0]
000016  6a0a              LDR      r2,[r1,#0x20]
000018  f0220201          BIC      r2,r2,#1
00001c  620a              STR      r2,[r1,#0x20]
00001e  6a0a              LDR      r2,[r1,#0x20]
000020  620a              STR      r2,[r1,#0x20]
000022  6801              LDR      r1,[r0,#0]
000024  6a0a              LDR      r2,[r1,#0x20]
000026  f0220210          BIC      r2,r2,#0x10
00002a  620a              STR      r2,[r1,#0x20]
00002c  6a0a              LDR      r2,[r1,#0x20]
00002e  620a              STR      r2,[r1,#0x20]
;;;2199   
;;;2200     /* Disable the Capture compare and the Input Capture channels 
;;;2201     (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2202     if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2203     if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2204     in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
;;;2205     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
;;;2206     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
;;;2207   
;;;2208     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000030  6801              LDR      r1,[r0,#0]
;;;2209     {
;;;2210       /* Disable the Main Ouput */
;;;2211       __HAL_TIM_MOE_DISABLE(htim);
000032  f2411211          MOV      r2,#0x1111
000036  1093              ASRS     r3,r2,#2
000038  f1a14c80          SUB      r12,r1,#0x40000000    ;2208
00003c  f5bc3c96          SUBS     r12,r12,#0x12c00      ;2208
000040  bf1c              ITT      NE                    ;2208
000042  f1a14c80          SUBNE    r12,r1,#0x40000000    ;2208
000046  f5bc3c9a          SUBSNE   r12,r12,#0x13400      ;2208
00004a  d10f              BNE      |L68.108|
00004c  f8d1c020          LDR      r12,[r1,#0x20]
000050  ea1c0f02          TST      r12,r2
000054  bf04              ITT      EQ
000056  f8d1c020          LDREQ    r12,[r1,#0x20]
00005a  ea1c0f03          TSTEQ    r12,r3
00005e  d105              BNE      |L68.108|
000060  f8d1c044          LDR      r12,[r1,#0x44]
000064  f42c4c00          BIC      r12,r12,#0x8000
000068  f8c1c044          STR      r12,[r1,#0x44]
                  |L68.108|
;;;2212     }
;;;2213   
;;;2214     /* Disable the Peripheral */
;;;2215      __HAL_TIM_DISABLE(htim);
00006c  6800              LDR      r0,[r0,#0]
00006e  6a01              LDR      r1,[r0,#0x20]
000070  4211              TST      r1,r2
000072  bf04              ITT      EQ
000074  6a01              LDREQ    r1,[r0,#0x20]
000076  4219              TSTEQ    r1,r3
000078  d103              BNE      |L68.130|
00007a  6801              LDR      r1,[r0,#0]
00007c  f0210101          BIC      r1,r1,#1
000080  6001              STR      r1,[r0,#0]
                  |L68.130|
;;;2216   
;;;2217     /* Return function status */
;;;2218     return HAL_OK;
000082  2000              MOVS     r0,#0
;;;2219   }
000084  4770              BX       lr
;;;2220   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_ConfigChannel||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_ConfigChannel PROC
;;;3099     */
;;;3100   HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3101   {
000004  4604              MOV      r4,r0
;;;3102     __HAL_LOCK(htim);
000006  6bc0              LDR      r0,[r0,#0x3c]
000008  460d              MOV      r5,r1                 ;3101
00000a  2801              CMP      r0,#1
00000c  bf04              ITT      EQ
00000e  2002              MOVEQ    r0,#2
;;;3103   
;;;3104     /* Check the parameters */
;;;3105     assert_param(IS_TIM_CHANNELS(Channel));
;;;3106     assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
;;;3107     assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
;;;3108     assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));
;;;3109   
;;;3110     htim->State = HAL_TIM_STATE_BUSY;
;;;3111   
;;;3112     switch (Channel)
;;;3113     {
;;;3114       case TIM_CHANNEL_1:
;;;3115       {
;;;3116         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3117         /* Configure the Channel 1 in PWM mode */
;;;3118         TIM_OC1_SetConfig(htim->Instance, sConfig);
;;;3119   
;;;3120         /* Set the Preload enable bit for channel1 */
;;;3121         htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
;;;3122   
;;;3123         /* Configure the Output Fast mode */
;;;3124         htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
;;;3125         htim->Instance->CCMR1 |= sConfig->OCFastMode;
;;;3126       }
;;;3127       break;
;;;3128   
;;;3129       case TIM_CHANNEL_2:
;;;3130       {
;;;3131         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3132         /* Configure the Channel 2 in PWM mode */
;;;3133         TIM_OC2_SetConfig(htim->Instance, sConfig);
;;;3134   
;;;3135         /* Set the Preload enable bit for channel2 */
;;;3136         htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
;;;3137   
;;;3138         /* Configure the Output Fast mode */
;;;3139         htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
;;;3140         htim->Instance->CCMR1 |= sConfig->OCFastMode << 8;
;;;3141       }
;;;3142       break;
;;;3143   
;;;3144       case TIM_CHANNEL_3:
;;;3145       {
;;;3146         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3147         /* Configure the Channel 3 in PWM mode */
;;;3148         TIM_OC3_SetConfig(htim->Instance, sConfig);
;;;3149   
;;;3150         /* Set the Preload enable bit for channel3 */
;;;3151         htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
;;;3152   
;;;3153        /* Configure the Output Fast mode */
;;;3154         htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
;;;3155         htim->Instance->CCMR2 |= sConfig->OCFastMode;
;;;3156       }
;;;3157       break;
;;;3158   
;;;3159       case TIM_CHANNEL_4:
;;;3160       {
;;;3161         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3162         /* Configure the Channel 4 in PWM mode */
;;;3163         TIM_OC4_SetConfig(htim->Instance, sConfig);
;;;3164   
;;;3165         /* Set the Preload enable bit for channel4 */
;;;3166         htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
;;;3167   
;;;3168        /* Configure the Output Fast mode */
;;;3169         htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
;;;3170         htim->Instance->CCMR2 |= sConfig->OCFastMode << 8;
;;;3171       }
;;;3172       break;
;;;3173   
;;;3174       default:
;;;3175       break;
;;;3176     }
;;;3177   
;;;3178     htim->State = HAL_TIM_STATE_READY;
;;;3179   
;;;3180     __HAL_UNLOCK(htim);
;;;3181   
;;;3182     return HAL_OK;
;;;3183   }
000010  e8bd81f0          POPEQ    {r4-r8,pc}
000014  2601              MOVS     r6,#1                 ;3102
000016  2002              MOVS     r0,#2                 ;3110
000018  63e6              STR      r6,[r4,#0x3c]         ;3110
00001a  6420              STR      r0,[r4,#0x40]         ;3110
00001c  496e              LDR      r1,|L69.472|
00001e  4b6f              LDR      r3,|L69.476|
000020  b13a              CBZ      r2,|L69.50|
000022  2a04              CMP      r2,#4                 ;3112
000024  d047              BEQ      |L69.182|
000026  2a08              CMP      r2,#8                 ;3112
000028  d059              BEQ      |L69.222|
00002a  2a0c              CMP      r2,#0xc               ;3112
00002c  d07d              BEQ      |L69.298|
00002e  f000b8ce          B.W      |L69.462|
                  |L69.50|
000032  6820              LDR      r0,[r4,#0]            ;3112
000034  6a02              LDR      r2,[r0,#0x20]         ;3112
000036  f0220201          BIC      r2,r2,#1              ;3112
00003a  6202              STR      r2,[r0,#0x20]         ;3112
00003c  6a02              LDR      r2,[r0,#0x20]         ;3112
00003e  f8d0c004          LDR      r12,[r0,#4]           ;3112
000042  6987              LDR      r7,[r0,#0x18]         ;3112
000044  f8d58000          LDR      r8,[r5,#0]            ;3112
000048  f0270773          BIC      r7,r7,#0x73           ;3112
00004c  ea480707          ORR      r7,r8,r7              ;3112
000050  f8d58008          LDR      r8,[r5,#8]            ;3112
000054  f0220202          BIC      r2,r2,#2              ;3112
000058  ea480202          ORR      r2,r8,r2              ;3112
00005c  4288              CMP      r0,r1                 ;3112
00005e  bf18              IT       NE                    ;3112
000060  4298              CMPNE    r0,r3                 ;3112
000062  d107              BNE      |L69.116|
000064  f8d5800c          LDR      r8,[r5,#0xc]          ;3118
000068  f0220208          BIC      r2,r2,#8              ;3118
00006c  ea480202          ORR      r2,r8,r2              ;3118
000070  f0220204          BIC      r2,r2,#4              ;3118
                  |L69.116|
000074  4288              CMP      r0,r1                 ;3118
000076  bf18              IT       NE                    ;3118
000078  4298              CMPNE    r0,r3                 ;3118
00007a  d106              BNE      |L69.138|
00007c  696b              LDR      r3,[r5,#0x14]         ;3118
00007e  f42c7140          BIC      r1,r12,#0x300         ;3118
000082  4319              ORRS     r1,r1,r3              ;3118
000084  69ab              LDR      r3,[r5,#0x18]         ;3118
000086  ea430c01          ORR      r12,r3,r1             ;3118
                  |L69.138|
00008a  f8c0c004          STR      r12,[r0,#4]           ;3118
00008e  6187              STR      r7,[r0,#0x18]         ;3118
000090  6869              LDR      r1,[r5,#4]            ;3118
000092  6341              STR      r1,[r0,#0x34]         ;3118
000094  6202              STR      r2,[r0,#0x20]         ;3118
000096  6820              LDR      r0,[r4,#0]            ;3121
000098  6981              LDR      r1,[r0,#0x18]         ;3121
00009a  f0410108          ORR      r1,r1,#8              ;3121
00009e  6181              STR      r1,[r0,#0x18]         ;3121
0000a0  6820              LDR      r0,[r4,#0]            ;3124
0000a2  6981              LDR      r1,[r0,#0x18]         ;3124
0000a4  f0210104          BIC      r1,r1,#4              ;3124
0000a8  6181              STR      r1,[r0,#0x18]         ;3124
0000aa  6820              LDR      r0,[r4,#0]            ;3125
0000ac  6981              LDR      r1,[r0,#0x18]         ;3125
0000ae  692a              LDR      r2,[r5,#0x10]         ;3125
0000b0  4311              ORRS     r1,r1,r2              ;3125
                  |L69.178|
0000b2  6181              STR      r1,[r0,#0x18]         ;3125
0000b4  e08b              B        |L69.462|
                  |L69.182|
0000b6  4629              MOV      r1,r5                 ;3133
0000b8  6820              LDR      r0,[r4,#0]            ;3133
0000ba  f7fffffe          BL       TIM_OC2_SetConfig
0000be  6820              LDR      r0,[r4,#0]            ;3136
0000c0  6981              LDR      r1,[r0,#0x18]         ;3136
0000c2  f4416100          ORR      r1,r1,#0x800          ;3136
0000c6  6181              STR      r1,[r0,#0x18]         ;3136
0000c8  6820              LDR      r0,[r4,#0]            ;3139
0000ca  6981              LDR      r1,[r0,#0x18]         ;3139
0000cc  f4216180          BIC      r1,r1,#0x400          ;3139
0000d0  6181              STR      r1,[r0,#0x18]         ;3139
0000d2  6820              LDR      r0,[r4,#0]            ;3140
0000d4  6981              LDR      r1,[r0,#0x18]         ;3140
0000d6  692a              LDR      r2,[r5,#0x10]         ;3140
0000d8  ea412102          ORR      r1,r1,r2,LSL #8       ;3140
0000dc  e7e9              B        |L69.178|
                  |L69.222|
0000de  6820              LDR      r0,[r4,#0]            ;3142
0000e0  6a02              LDR      r2,[r0,#0x20]         ;3142
0000e2  f4227280          BIC      r2,r2,#0x100          ;3142
0000e6  6202              STR      r2,[r0,#0x20]         ;3142
0000e8  6a02              LDR      r2,[r0,#0x20]         ;3142
0000ea  f8d0c004          LDR      r12,[r0,#4]           ;3142
0000ee  69c7              LDR      r7,[r0,#0x1c]         ;3142
0000f0  f8d58000          LDR      r8,[r5,#0]            ;3142
0000f4  f0270773          BIC      r7,r7,#0x73           ;3142
0000f8  ea480707          ORR      r7,r8,r7              ;3142
0000fc  f8d58008          LDR      r8,[r5,#8]            ;3142
000100  f4227200          BIC      r2,r2,#0x200          ;3142
000104  ea422208          ORR      r2,r2,r8,LSL #8       ;3142
000108  4288              CMP      r0,r1                 ;3142
00010a  bf18              IT       NE                    ;3142
00010c  4298              CMPNE    r0,r3                 ;3142
00010e  d107              BNE      |L69.288|
000110  f8d5800c          LDR      r8,[r5,#0xc]          ;3148
000114  f4226200          BIC      r2,r2,#0x800          ;3148
000118  ea422208          ORR      r2,r2,r8,LSL #8       ;3148
00011c  f4226280          BIC      r2,r2,#0x400          ;3148
                  |L69.288|
000120  4288              CMP      r0,r1                 ;3148
000122  bf18              IT       NE                    ;3148
000124  4298              CMPNE    r0,r3                 ;3148
000126  d109              BNE      |L69.316|
000128  e000              B        |L69.300|
                  |L69.298|
00012a  e01c              B        |L69.358|
                  |L69.300|
00012c  696b              LDR      r3,[r5,#0x14]         ;3148
00012e  f42c5140          BIC      r1,r12,#0x3000        ;3148
000132  ea411103          ORR      r1,r1,r3,LSL #4       ;3148
000136  69ab              LDR      r3,[r5,#0x18]         ;3148
000138  ea411c03          ORR      r12,r1,r3,LSL #4      ;3148
                  |L69.316|
00013c  f8c0c004          STR      r12,[r0,#4]           ;3148
000140  61c7              STR      r7,[r0,#0x1c]         ;3148
000142  6869              LDR      r1,[r5,#4]            ;3148
000144  63c1              STR      r1,[r0,#0x3c]         ;3148
000146  6202              STR      r2,[r0,#0x20]         ;3148
000148  6820              LDR      r0,[r4,#0]            ;3151
00014a  69c1              LDR      r1,[r0,#0x1c]         ;3151
00014c  f0410108          ORR      r1,r1,#8              ;3151
000150  61c1              STR      r1,[r0,#0x1c]         ;3151
000152  6820              LDR      r0,[r4,#0]            ;3154
000154  69c1              LDR      r1,[r0,#0x1c]         ;3154
000156  f0210104          BIC      r1,r1,#4              ;3154
00015a  61c1              STR      r1,[r0,#0x1c]         ;3154
00015c  6820              LDR      r0,[r4,#0]            ;3155
00015e  69c1              LDR      r1,[r0,#0x1c]         ;3155
000160  692a              LDR      r2,[r5,#0x10]         ;3155
000162  4311              ORRS     r1,r1,r2              ;3155
000164  e032              B        |L69.460|
                  |L69.358|
000166  6820              LDR      r0,[r4,#0]            ;3157
000168  6a02              LDR      r2,[r0,#0x20]         ;3157
00016a  f4225280          BIC      r2,r2,#0x1000         ;3157
00016e  6202              STR      r2,[r0,#0x20]         ;3157
000170  6a07              LDR      r7,[r0,#0x20]         ;3157
000172  6842              LDR      r2,[r0,#4]            ;3157
000174  f8d0c01c          LDR      r12,[r0,#0x1c]        ;3157
000178  f8d58000          LDR      r8,[r5,#0]            ;3157
00017c  f42c4ce6          BIC      r12,r12,#0x7300       ;3157
000180  ea4c2c08          ORR      r12,r12,r8,LSL #8     ;3157
000184  f8d58008          LDR      r8,[r5,#8]            ;3157
000188  f4275700          BIC      r7,r7,#0x2000         ;3157
00018c  ea473708          ORR      r7,r7,r8,LSL #12      ;3157
000190  4288              CMP      r0,r1                 ;3157
000192  bf18              IT       NE                    ;3157
000194  4298              CMPNE    r0,r3                 ;3157
000196  d104              BNE      |L69.418|
000198  f4224180          BIC      r1,r2,#0x4000         ;3163
00019c  696a              LDR      r2,[r5,#0x14]         ;3163
00019e  ea411282          ORR      r2,r1,r2,LSL #6       ;3163
                  |L69.418|
0001a2  6042              STR      r2,[r0,#4]            ;3163
0001a4  f8c0c01c          STR      r12,[r0,#0x1c]        ;3163
0001a8  6869              LDR      r1,[r5,#4]            ;3163
0001aa  6401              STR      r1,[r0,#0x40]         ;3163
0001ac  6207              STR      r7,[r0,#0x20]         ;3163
0001ae  6820              LDR      r0,[r4,#0]            ;3166
0001b0  69c1              LDR      r1,[r0,#0x1c]         ;3166
0001b2  f4416100          ORR      r1,r1,#0x800          ;3166
0001b6  61c1              STR      r1,[r0,#0x1c]         ;3166
0001b8  6820              LDR      r0,[r4,#0]            ;3169
0001ba  69c1              LDR      r1,[r0,#0x1c]         ;3169
0001bc  f4216180          BIC      r1,r1,#0x400          ;3169
0001c0  61c1              STR      r1,[r0,#0x1c]         ;3169
0001c2  6820              LDR      r0,[r4,#0]            ;3170
0001c4  69c1              LDR      r1,[r0,#0x1c]         ;3170
0001c6  692a              LDR      r2,[r5,#0x10]         ;3170
0001c8  ea412102          ORR      r1,r1,r2,LSL #8       ;3170
                  |L69.460|
0001cc  61c1              STR      r1,[r0,#0x1c]         ;3155
                  |L69.462|
0001ce  6426              STR      r6,[r4,#0x40]         ;3178
0001d0  2000              MOVS     r0,#0                 ;3180
0001d2  63e0              STR      r0,[r4,#0x3c]         ;3180
0001d4  e8bd81f0          POP      {r4-r8,pc}
;;;3184   
                          ENDP

                  |L69.472|
                          DCD      0x40012c00
                  |L69.476|
                          DCD      0x40013400

                          AREA ||i.HAL_TIM_PWM_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_DeInit PROC
;;;1026     */
;;;1027   HAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1028   {
000002  4604              MOV      r4,r0
;;;1029     /* Check the parameters */
;;;1030     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1031   
;;;1032     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  6420              STR      r0,[r4,#0x40]
;;;1033   
;;;1034     /* Disable the TIM Peripheral Clock */
;;;1035     __HAL_TIM_DISABLE(htim);
000008  6820              LDR      r0,[r4,#0]
00000a  6a01              LDR      r1,[r0,#0x20]
00000c  f2411211          MOV      r2,#0x1111
000010  4211              TST      r1,r2
000012  d107              BNE      |L70.36|
000014  6a01              LDR      r1,[r0,#0x20]
000016  1092              ASRS     r2,r2,#2
000018  4211              TST      r1,r2
00001a  d103              BNE      |L70.36|
00001c  6801              LDR      r1,[r0,#0]
00001e  f0210101          BIC      r1,r1,#1
000022  6001              STR      r1,[r0,#0]
                  |L70.36|
;;;1036   
;;;1037     /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;1038     HAL_TIM_PWM_MspDeInit(htim);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       HAL_TIM_PWM_MspDeInit
;;;1039   
;;;1040     /* Change TIM state */
;;;1041     htim->State = HAL_TIM_STATE_RESET;
00002a  2000              MOVS     r0,#0
00002c  6420              STR      r0,[r4,#0x40]
;;;1042   
;;;1043     /* Release Lock */
;;;1044     __HAL_UNLOCK(htim);
00002e  63e0              STR      r0,[r4,#0x3c]
;;;1045   
;;;1046     return HAL_OK;
;;;1047   }
000030  bd10              POP      {r4,pc}
;;;1048   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_GetState PROC
;;;4408     */
;;;4409   HAL_TIM_StateTypeDef HAL_TIM_PWM_GetState(TIM_HandleTypeDef *htim)
000000  6c00              LDR      r0,[r0,#0x40]
;;;4410   {
;;;4411     return htim->State;
;;;4412   }
000002  4770              BX       lr
;;;4413   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_Init PROC
;;;986      */
;;;987    HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
000000  2800              CMP      r0,#0
;;;988    {
;;;989      /* Check the TIM handle allocation */
;;;990      if(htim == NULL)
;;;991      {
;;;992        return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;993      }
;;;994    
;;;995      /* Check the parameters */
;;;996      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;997      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;998      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;999      assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;1000   
;;;1001     if(htim->State == HAL_TIM_STATE_RESET)
;;;1002     {
;;;1003       /* Allocate lock resource and initialize it */
;;;1004       htim->Lock = HAL_UNLOCKED;
;;;1005       
;;;1006       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;1007       HAL_TIM_PWM_MspInit(htim);
;;;1008     }
;;;1009   
;;;1010     /* Set the TIM state */
;;;1011     htim->State= HAL_TIM_STATE_BUSY;
;;;1012   
;;;1013     /* Init the base time for the PWM */
;;;1014     TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;1015   
;;;1016     /* Initialize the TIM state*/
;;;1017     htim->State= HAL_TIM_STATE_READY;
;;;1018   
;;;1019     return HAL_OK;
;;;1020   }
000006  4770              BXEQ     lr
000008  b510              PUSH     {r4,lr}               ;988
00000a  4604              MOV      r4,r0                 ;988
00000c  6c00              LDR      r0,[r0,#0x40]         ;1001
00000e  b920              CBNZ     r0,|L72.26|
000010  2000              MOVS     r0,#0                 ;1004
000012  63e0              STR      r0,[r4,#0x3c]         ;1007
000014  4620              MOV      r0,r4                 ;1007
000016  f7fffffe          BL       HAL_TIM_PWM_MspInit
                  |L72.26|
00001a  2002              MOVS     r0,#2                 ;1011
00001c  6420              STR      r0,[r4,#0x40]         ;1011
00001e  1d21              ADDS     r1,r4,#4              ;1014
000020  6820              LDR      r0,[r4,#0]            ;1014
000022  f7fffffe          BL       TIM_Base_SetConfig
000026  2001              MOVS     r0,#1                 ;1017
000028  6420              STR      r0,[r4,#0x40]         ;1017
00002a  2000              MOVS     r0,#0                 ;1019
00002c  bd10              POP      {r4,pc}
;;;1021   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_MspDeInit PROC
;;;1067     */
;;;1068   __weak void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1069   {
;;;1070     /* Prevent unused argument(s) compilation warning */
;;;1071     UNUSED(htim);
;;;1072     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1073               the HAL_TIM_PWM_MspDeInit could be implemented in the user file
;;;1074      */
;;;1075   }
;;;1076   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_MspInit PROC
;;;1053     */
;;;1054   __weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1055   {
;;;1056     /* Prevent unused argument(s) compilation warning */
;;;1057     UNUSED(htim);
;;;1058     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1059               the HAL_TIM_PWM_MspInit could be implemented in the user file
;;;1060      */
;;;1061   }
;;;1062   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_PulseFinishedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_PulseFinishedCallback PROC
;;;4327     */
;;;4328   __weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4329   {
;;;4330     /* Prevent unused argument(s) compilation warning */
;;;4331     UNUSED(htim);
;;;4332     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4333               the __HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
;;;4334      */
;;;4335   }
;;;4336   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_Start PROC
;;;1087   */
;;;1088   HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  6802              LDR      r2,[r0,#0]
000002  2301              MOVS     r3,#1
000004  fa03f101          LSL      r1,r3,r1
000008  6a13              LDR      r3,[r2,#0x20]
00000a  438b              BICS     r3,r3,r1
00000c  6213              STR      r3,[r2,#0x20]
00000e  6a13              LDR      r3,[r2,#0x20]
000010  4319              ORRS     r1,r1,r3
000012  6211              STR      r1,[r2,#0x20]
;;;1089   {
;;;1090     /* Check the parameters */
;;;1091     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1092   
;;;1093     /* Enable the Capture compare channel */
;;;1094     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1095   
;;;1096     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000014  6801              LDR      r1,[r0,#0]
000016  f1a14280          SUB      r2,r1,#0x40000000
00001a  f5b23296          SUBS     r2,r2,#0x12c00
00001e  bf1c              ITT      NE
000020  f1a14280          SUBNE    r2,r1,#0x40000000
000024  f5b2329a          SUBSNE   r2,r2,#0x13400
000028  d103              BNE      |L76.50|
;;;1097     {
;;;1098       /* Enable the main output */
;;;1099       __HAL_TIM_MOE_ENABLE(htim);
00002a  6c4a              LDR      r2,[r1,#0x44]
00002c  f4424200          ORR      r2,r2,#0x8000
000030  644a              STR      r2,[r1,#0x44]
                  |L76.50|
;;;1100     }
;;;1101   
;;;1102     /* Enable the Peripheral */
;;;1103     __HAL_TIM_ENABLE(htim);
000032  6800              LDR      r0,[r0,#0]
000034  6801              LDR      r1,[r0,#0]
000036  f0410101          ORR      r1,r1,#1
00003a  6001              STR      r1,[r0,#0]
;;;1104   
;;;1105     /* Return function status */
;;;1106     return HAL_OK;
00003c  2000              MOVS     r0,#0
;;;1107   }
00003e  4770              BX       lr
;;;1108   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Start_DMA PROC
;;;1288   */
;;;1289   HAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;1290   {
000002  4604              MOV      r4,r0
;;;1291     /* Check the parameters */
;;;1292     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1293   
;;;1294     if((htim->State == HAL_TIM_STATE_BUSY))
000004  6c00              LDR      r0,[r0,#0x40]
000006  4694              MOV      r12,r2                ;1290
000008  460d              MOV      r5,r1                 ;1290
00000a  2802              CMP      r0,#2
;;;1295     {
;;;1296        return HAL_BUSY;
;;;1297     }
;;;1298     else if((htim->State == HAL_TIM_STATE_READY))
;;;1299     {
;;;1300       if(((uint32_t)pData == 0U) && (Length > 0U))
;;;1301       {
;;;1302         return HAL_ERROR;
;;;1303       }
;;;1304       else
;;;1305       {
;;;1306         htim->State = HAL_TIM_STATE_BUSY;
;;;1307       }
;;;1308     }
;;;1309     switch (Channel)
;;;1310     {
;;;1311       case TIM_CHANNEL_1:
;;;1312       {
;;;1313         /* Set the DMA Period elapsed callback */
;;;1314         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1315   
;;;1316         /* Set the DMA error callback */
;;;1317         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;1318   
;;;1319         /* Enable the DMA channel */
;;;1320         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
;;;1321   
;;;1322         /* Enable the TIM Capture/Compare 1 DMA request */
;;;1323         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;1324       }
;;;1325       break;
;;;1326   
;;;1327       case TIM_CHANNEL_2:
;;;1328       {
;;;1329         /* Set the DMA Period elapsed callback */
;;;1330         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1331   
;;;1332         /* Set the DMA error callback */
;;;1333         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;1334   
;;;1335         /* Enable the DMA channel */
;;;1336         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
;;;1337   
;;;1338         /* Enable the TIM Capture/Compare 2 DMA request */
;;;1339         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;1340       }
;;;1341       break;
;;;1342   
;;;1343       case TIM_CHANNEL_3:
;;;1344       {
;;;1345         /* Set the DMA Period elapsed callback */
;;;1346         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1347   
;;;1348         /* Set the DMA error callback */
;;;1349         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;1350   
;;;1351         /* Enable the DMA channel */
;;;1352         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
;;;1353   
;;;1354         /* Enable the TIM Output Capture/Compare 3 request */
;;;1355         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;1356       }
;;;1357       break;
;;;1358   
;;;1359       case TIM_CHANNEL_4:
;;;1360       {
;;;1361        /* Set the DMA Period elapsed callback */
;;;1362         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1363   
;;;1364         /* Set the DMA error callback */
;;;1365         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;1366   
;;;1367         /* Enable the DMA channel */
;;;1368         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
;;;1369   
;;;1370         /* Enable the TIM Capture/Compare 4 DMA request */
;;;1371         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;1372       }
;;;1373       break;
;;;1374   
;;;1375       default:
;;;1376       break;
;;;1377     }
;;;1378   
;;;1379     /* Enable the Capture compare channel */
;;;1380     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1381   
;;;1382     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;1383     {
;;;1384       /* Enable the main output */
;;;1385       __HAL_TIM_MOE_ENABLE(htim);
;;;1386     }
;;;1387   
;;;1388     /* Enable the Peripheral */
;;;1389     __HAL_TIM_ENABLE(htim);
;;;1390   
;;;1391     /* Return function status */
;;;1392     return HAL_OK;
;;;1393   }
00000c  bf08              IT       EQ
00000e  bd70              POPEQ    {r4-r6,pc}
000010  6c20              LDR      r0,[r4,#0x40]         ;1298
000012  2801              CMP      r0,#1                 ;1298
000014  d108              BNE      |L77.40|
000016  f1bc0f00          CMP      r12,#0                ;1300
00001a  d103              BNE      |L77.36|
00001c  2b00              CMP      r3,#0                 ;1300
00001e  bf1c              ITT      NE                    ;1302
000020  2001              MOVNE    r0,#1                 ;1302
000022  bd70              POPNE    {r4-r6,pc}
                  |L77.36|
000024  2002              MOVS     r0,#2                 ;1306
000026  6420              STR      r0,[r4,#0x40]         ;1306
                  |L77.40|
000028  4834              LDR      r0,|L77.252|
00002a  4935              LDR      r1,|L77.256|
00002c  b135              CBZ      r5,|L77.60|
00002e  2d04              CMP      r5,#4                 ;1309
000030  d014              BEQ      |L77.92|
000032  2d08              CMP      r5,#8                 ;1309
000034  d022              BEQ      |L77.124|
000036  2d0c              CMP      r5,#0xc               ;1309
000038  d030              BEQ      |L77.156|
00003a  e03f              B        |L77.188|
                  |L77.60|
00003c  6a62              LDR      r2,[r4,#0x24]         ;1314
00003e  62d0              STR      r0,[r2,#0x2c]         ;1317
000040  6a60              LDR      r0,[r4,#0x24]         ;1317
000042  6341              STR      r1,[r0,#0x34]         ;1320
000044  6820              LDR      r0,[r4,#0]            ;1320
000046  4661              MOV      r1,r12                ;1320
000048  f1000234          ADD      r2,r0,#0x34           ;1320
00004c  6a60              LDR      r0,[r4,#0x24]         ;1320
00004e  f7fffffe          BL       HAL_DMA_Start_IT
000052  6820              LDR      r0,[r4,#0]            ;1323
000054  68c1              LDR      r1,[r0,#0xc]          ;1323
000056  f4417100          ORR      r1,r1,#0x200          ;1323
00005a  e02e              B        |L77.186|
                  |L77.92|
00005c  6aa2              LDR      r2,[r4,#0x28]         ;1330
00005e  62d0              STR      r0,[r2,#0x2c]         ;1333
000060  6aa0              LDR      r0,[r4,#0x28]         ;1333
000062  6341              STR      r1,[r0,#0x34]         ;1336
000064  6820              LDR      r0,[r4,#0]            ;1336
000066  4661              MOV      r1,r12                ;1336
000068  f1000238          ADD      r2,r0,#0x38           ;1336
00006c  6aa0              LDR      r0,[r4,#0x28]         ;1336
00006e  f7fffffe          BL       HAL_DMA_Start_IT
000072  6820              LDR      r0,[r4,#0]            ;1339
000074  68c1              LDR      r1,[r0,#0xc]          ;1339
000076  f4416180          ORR      r1,r1,#0x400          ;1339
00007a  e01e              B        |L77.186|
                  |L77.124|
00007c  6ae2              LDR      r2,[r4,#0x2c]         ;1346
00007e  62d0              STR      r0,[r2,#0x2c]         ;1349
000080  6ae0              LDR      r0,[r4,#0x2c]         ;1349
000082  6341              STR      r1,[r0,#0x34]         ;1352
000084  6820              LDR      r0,[r4,#0]            ;1352
000086  4661              MOV      r1,r12                ;1352
000088  f100023c          ADD      r2,r0,#0x3c           ;1352
00008c  6ae0              LDR      r0,[r4,#0x2c]         ;1352
00008e  f7fffffe          BL       HAL_DMA_Start_IT
000092  6820              LDR      r0,[r4,#0]            ;1355
000094  68c1              LDR      r1,[r0,#0xc]          ;1355
000096  f4416100          ORR      r1,r1,#0x800          ;1355
00009a  e00e              B        |L77.186|
                  |L77.156|
00009c  6b22              LDR      r2,[r4,#0x30]         ;1362
00009e  62d0              STR      r0,[r2,#0x2c]         ;1365
0000a0  6b20              LDR      r0,[r4,#0x30]         ;1365
0000a2  6341              STR      r1,[r0,#0x34]         ;1368
0000a4  6820              LDR      r0,[r4,#0]            ;1368
0000a6  4661              MOV      r1,r12                ;1368
0000a8  f1000240          ADD      r2,r0,#0x40           ;1368
0000ac  6b20              LDR      r0,[r4,#0x30]         ;1368
0000ae  f7fffffe          BL       HAL_DMA_Start_IT
0000b2  6820              LDR      r0,[r4,#0]            ;1371
0000b4  68c1              LDR      r1,[r0,#0xc]          ;1371
0000b6  f4415180          ORR      r1,r1,#0x1000         ;1371
                  |L77.186|
0000ba  60c1              STR      r1,[r0,#0xc]          ;1355
                  |L77.188|
0000bc  6820              LDR      r0,[r4,#0]            ;1355
0000be  2101              MOVS     r1,#1                 ;1355
0000c0  40a9              LSLS     r1,r1,r5              ;1355
0000c2  6a02              LDR      r2,[r0,#0x20]         ;1355
0000c4  438a              BICS     r2,r2,r1              ;1355
0000c6  6202              STR      r2,[r0,#0x20]         ;1355
0000c8  6a02              LDR      r2,[r0,#0x20]         ;1355
0000ca  4311              ORRS     r1,r1,r2              ;1355
0000cc  6201              STR      r1,[r0,#0x20]         ;1355
0000ce  6820              LDR      r0,[r4,#0]            ;1382
0000d0  f1a04180          SUB      r1,r0,#0x40000000     ;1382
0000d4  f5b13196          SUBS     r1,r1,#0x12c00        ;1382
0000d8  bf1c              ITT      NE                    ;1382
0000da  f1a04180          SUBNE    r1,r0,#0x40000000     ;1382
0000de  f5b1319a          SUBSNE   r1,r1,#0x13400        ;1382
0000e2  d103              BNE      |L77.236|
0000e4  6c41              LDR      r1,[r0,#0x44]         ;1385
0000e6  f4414100          ORR      r1,r1,#0x8000         ;1385
0000ea  6441              STR      r1,[r0,#0x44]         ;1385
                  |L77.236|
0000ec  6820              LDR      r0,[r4,#0]            ;1389
0000ee  6801              LDR      r1,[r0,#0]            ;1389
0000f0  f0410101          ORR      r1,r1,#1              ;1389
0000f4  6001              STR      r1,[r0,#0]            ;1389
0000f6  2000              MOVS     r0,#0                 ;1392
0000f8  bd70              POP      {r4-r6,pc}
;;;1394   
                          ENDP

0000fa  0000              DCW      0x0000
                  |L77.252|
                          DCD      TIM_DMADelayPulseCplt
                  |L77.256|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_PWM_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_Start_IT PROC
;;;1154   */
;;;1155   HAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  6802              LDR      r2,[r0,#0]
;;;1156   {
;;;1157     /* Check the parameters */
;;;1158     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1159   
;;;1160     switch (Channel)
000002  2900              CMP      r1,#0
;;;1161     {
;;;1162       case TIM_CHANNEL_1:
;;;1163       {
;;;1164         /* Enable the TIM Capture/Compare 1 interrupt */
;;;1165         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000004  bf04              ITT      EQ
000006  68d3              LDREQ    r3,[r2,#0xc]
000008  f0430302          ORREQ    r3,r3,#2
00000c  d011              BEQ      |L78.50|
00000e  2904              CMP      r1,#4                 ;1160
;;;1166       }
;;;1167       break;
;;;1168   
;;;1169       case TIM_CHANNEL_2:
;;;1170       {
;;;1171         /* Enable the TIM Capture/Compare 2 interrupt */
;;;1172         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000010  bf04              ITT      EQ
000012  68d3              LDREQ    r3,[r2,#0xc]
000014  f0430304          ORREQ    r3,r3,#4
000018  d00b              BEQ      |L78.50|
00001a  2908              CMP      r1,#8                 ;1160
;;;1173       }
;;;1174       break;
;;;1175   
;;;1176       case TIM_CHANNEL_3:
;;;1177       {
;;;1178         /* Enable the TIM Capture/Compare 3 interrupt */
;;;1179         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
00001c  bf04              ITT      EQ
00001e  68d3              LDREQ    r3,[r2,#0xc]
000020  f0430308          ORREQ    r3,r3,#8
000024  d005              BEQ      |L78.50|
000026  290c              CMP      r1,#0xc               ;1160
;;;1180       }
;;;1181       break;
;;;1182   
;;;1183       case TIM_CHANNEL_4:
;;;1184       {
;;;1185         /* Enable the TIM Capture/Compare 4 interrupt */
;;;1186         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
000028  bf04              ITT      EQ
00002a  68d3              LDREQ    r3,[r2,#0xc]
00002c  f0430310          ORREQ    r3,r3,#0x10
000030  d100              BNE      |L78.52|
                  |L78.50|
000032  60d3              STR      r3,[r2,#0xc]          ;1179
                  |L78.52|
000034  6802              LDR      r2,[r0,#0]            ;1179
000036  2301              MOVS     r3,#1                 ;1179
000038  fa03f101          LSL      r1,r3,r1              ;1179
00003c  6a13              LDR      r3,[r2,#0x20]         ;1179
00003e  438b              BICS     r3,r3,r1              ;1179
000040  6213              STR      r3,[r2,#0x20]         ;1179
000042  6a13              LDR      r3,[r2,#0x20]         ;1179
000044  4319              ORRS     r1,r1,r3              ;1179
000046  6211              STR      r1,[r2,#0x20]         ;1179
;;;1187       }
;;;1188       break;
;;;1189   
;;;1190       default:
;;;1191       break;
;;;1192     }
;;;1193   
;;;1194     /* Enable the Capture compare channel */
;;;1195     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1196   
;;;1197     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000048  6801              LDR      r1,[r0,#0]
00004a  f1a14280          SUB      r2,r1,#0x40000000
00004e  f5b23296          SUBS     r2,r2,#0x12c00
000052  bf1c              ITT      NE
000054  f1a14280          SUBNE    r2,r1,#0x40000000
000058  f5b2329a          SUBSNE   r2,r2,#0x13400
00005c  d103              BNE      |L78.102|
;;;1198     {
;;;1199       /* Enable the main output */
;;;1200       __HAL_TIM_MOE_ENABLE(htim);
00005e  6c4a              LDR      r2,[r1,#0x44]
000060  f4424200          ORR      r2,r2,#0x8000
000064  644a              STR      r2,[r1,#0x44]
                  |L78.102|
;;;1201     }
;;;1202   
;;;1203     /* Enable the Peripheral */
;;;1204     __HAL_TIM_ENABLE(htim);
000066  6800              LDR      r0,[r0,#0]
000068  6801              LDR      r1,[r0,#0]
00006a  f0410101          ORR      r1,r1,#1
00006e  6001              STR      r1,[r0,#0]
;;;1205   
;;;1206     /* Return function status */
;;;1207     return HAL_OK;
000070  2000              MOVS     r0,#0
;;;1208   }
000072  4770              BX       lr
;;;1209   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_Stop PROC
;;;1119   */
;;;1120   HAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b430              PUSH     {r4,r5}
000002  6802              LDR      r2,[r0,#0]
000004  2301              MOVS     r3,#1
;;;1121   {
;;;1122     /* Check the parameters */
;;;1123     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1124   
;;;1125     /* Disable the Capture compare channel */
;;;1126     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000006  f04f0c00          MOV      r12,#0
00000a  6a15              LDR      r5,[r2,#0x20]
00000c  fa03f401          LSL      r4,r3,r1
000010  ea250404          BIC      r4,r5,r4
000014  6214              STR      r4,[r2,#0x20]
000016  6a14              LDR      r4,[r2,#0x20]
000018  fa0cf101          LSL      r1,r12,r1
00001c  4321              ORRS     r1,r1,r4
00001e  6211              STR      r1,[r2,#0x20]
;;;1127   
;;;1128     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000020  6801              LDR      r1,[r0,#0]
;;;1129     {
;;;1130       /* Disable the Main Ouput */
;;;1131       __HAL_TIM_MOE_DISABLE(htim);
000022  f2411211          MOV      r2,#0x1111
000026  f1a14480          SUB      r4,r1,#0x40000000     ;1128
00002a  f2404c44          MOV      r12,#0x444
00002e  f5b43496          SUBS     r4,r4,#0x12c00        ;1128
000032  bf1c              ITT      NE                    ;1128
000034  f1a14480          SUBNE    r4,r1,#0x40000000     ;1128
000038  f5b4349a          SUBSNE   r4,r4,#0x13400        ;1128
00003c  d10a              BNE      |L79.84|
00003e  6a0c              LDR      r4,[r1,#0x20]
000040  4214              TST      r4,r2
000042  bf04              ITT      EQ
000044  6a0c              LDREQ    r4,[r1,#0x20]
000046  ea140f0c          TSTEQ    r4,r12
00004a  d103              BNE      |L79.84|
00004c  6c4c              LDR      r4,[r1,#0x44]
00004e  f4244400          BIC      r4,r4,#0x8000
000052  644c              STR      r4,[r1,#0x44]
                  |L79.84|
;;;1132     }
;;;1133   
;;;1134     /* Disable the Peripheral */
;;;1135     __HAL_TIM_DISABLE(htim);
000054  6801              LDR      r1,[r0,#0]
000056  6a0c              LDR      r4,[r1,#0x20]
000058  4214              TST      r4,r2
00005a  bf04              ITT      EQ
00005c  6a0a              LDREQ    r2,[r1,#0x20]
00005e  ea120f0c          TSTEQ    r2,r12
000062  d103              BNE      |L79.108|
000064  680a              LDR      r2,[r1,#0]
000066  f0220201          BIC      r2,r2,#1
00006a  600a              STR      r2,[r1,#0]
                  |L79.108|
;;;1136   
;;;1137     /* Change the htim state */
;;;1138     htim->State = HAL_TIM_STATE_READY;
00006c  6403              STR      r3,[r0,#0x40]
;;;1139   
;;;1140     /* Return function status */
;;;1141     return HAL_OK;
;;;1142   }
00006e  bc30              POP      {r4,r5}
000070  2000              MOVS     r0,#0                 ;1141
000072  4770              BX       lr
;;;1143   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_Stop_DMA PROC
;;;1405   */
;;;1406   HAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b430              PUSH     {r4,r5}
;;;1407   {
;;;1408     /* Check the parameters */
;;;1409     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1410   
;;;1411     switch (Channel)
000002  6802              LDR      r2,[r0,#0]
000004  2900              CMP      r1,#0
;;;1412     {
;;;1413       case TIM_CHANNEL_1:
;;;1414       {
;;;1415         /* Disable the TIM Capture/Compare 1 DMA request */
;;;1416         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000006  bf04              ITT      EQ
000008  68d3              LDREQ    r3,[r2,#0xc]
00000a  f4237300          BICEQ    r3,r3,#0x200
00000e  d011              BEQ      |L80.52|
000010  2904              CMP      r1,#4                 ;1411
;;;1417       }
;;;1418       break;
;;;1419   
;;;1420       case TIM_CHANNEL_2:
;;;1421       {
;;;1422         /* Disable the TIM Capture/Compare 2 DMA request */
;;;1423         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000012  bf04              ITT      EQ
000014  68d3              LDREQ    r3,[r2,#0xc]
000016  f4236380          BICEQ    r3,r3,#0x400
00001a  d00b              BEQ      |L80.52|
00001c  2908              CMP      r1,#8                 ;1411
;;;1424       }
;;;1425       break;
;;;1426   
;;;1427       case TIM_CHANNEL_3:
;;;1428       {
;;;1429         /* Disable the TIM Capture/Compare 3 DMA request */
;;;1430         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
00001e  bf04              ITT      EQ
000020  68d3              LDREQ    r3,[r2,#0xc]
000022  f4236300          BICEQ    r3,r3,#0x800
000026  d005              BEQ      |L80.52|
000028  290c              CMP      r1,#0xc               ;1411
;;;1431       }
;;;1432       break;
;;;1433   
;;;1434       case TIM_CHANNEL_4:
;;;1435       {
;;;1436         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1437         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
00002a  bf04              ITT      EQ
00002c  68d3              LDREQ    r3,[r2,#0xc]
00002e  f4235380          BICEQ    r3,r3,#0x1000
000032  d100              BNE      |L80.54|
                  |L80.52|
000034  60d3              STR      r3,[r2,#0xc]          ;1430
                  |L80.54|
000036  6802              LDR      r2,[r0,#0]            ;1430
000038  2301              MOVS     r3,#1                 ;1430
;;;1438       }
;;;1439       break;
;;;1440   
;;;1441       default:
;;;1442       break;
;;;1443     }
;;;1444   
;;;1445     /* Disable the Capture compare channel */
;;;1446     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
00003a  f04f0c00          MOV      r12,#0
00003e  6a15              LDR      r5,[r2,#0x20]
000040  fa03f401          LSL      r4,r3,r1
000044  ea250404          BIC      r4,r5,r4
000048  6214              STR      r4,[r2,#0x20]
00004a  6a14              LDR      r4,[r2,#0x20]
00004c  fa0cf101          LSL      r1,r12,r1
000050  4321              ORRS     r1,r1,r4
000052  6211              STR      r1,[r2,#0x20]
;;;1447   
;;;1448     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
000054  6801              LDR      r1,[r0,#0]
;;;1449     {
;;;1450       /* Disable the Main Ouput */
;;;1451       __HAL_TIM_MOE_DISABLE(htim);
000056  f2411c11          MOV      r12,#0x1111
00005a  f1a14480          SUB      r4,r1,#0x40000000     ;1448
00005e  f2404244          MOV      r2,#0x444
000062  f5b43496          SUBS     r4,r4,#0x12c00        ;1448
000066  bf1c              ITT      NE                    ;1448
000068  f1a14480          SUBNE    r4,r1,#0x40000000     ;1448
00006c  f5b4349a          SUBSNE   r4,r4,#0x13400        ;1448
000070  d10a              BNE      |L80.136|
000072  6a0c              LDR      r4,[r1,#0x20]
000074  ea140f0c          TST      r4,r12
000078  bf04              ITT      EQ
00007a  6a0c              LDREQ    r4,[r1,#0x20]
00007c  4214              TSTEQ    r4,r2
00007e  d103              BNE      |L80.136|
000080  6c4c              LDR      r4,[r1,#0x44]
000082  f4244400          BIC      r4,r4,#0x8000
000086  644c              STR      r4,[r1,#0x44]
                  |L80.136|
;;;1452     }
;;;1453   
;;;1454     /* Disable the Peripheral */
;;;1455     __HAL_TIM_DISABLE(htim);
000088  6801              LDR      r1,[r0,#0]
00008a  6a0c              LDR      r4,[r1,#0x20]
00008c  ea140f0c          TST      r4,r12
000090  bf04              ITT      EQ
000092  f8d1c020          LDREQ    r12,[r1,#0x20]
000096  ea1c0f02          TSTEQ    r12,r2
00009a  d103              BNE      |L80.164|
00009c  680a              LDR      r2,[r1,#0]
00009e  f0220201          BIC      r2,r2,#1
0000a2  600a              STR      r2,[r1,#0]
                  |L80.164|
;;;1456   
;;;1457     /* Change the htim state */
;;;1458     htim->State = HAL_TIM_STATE_READY;
0000a4  6403              STR      r3,[r0,#0x40]
;;;1459   
;;;1460     /* Return function status */
;;;1461     return HAL_OK;
;;;1462   }
0000a6  bc30              POP      {r4,r5}
0000a8  2000              MOVS     r0,#0                 ;1461
0000aa  4770              BX       lr
;;;1463   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_Stop_IT PROC
;;;1220   */
;;;1221   HAL_StatusTypeDef HAL_TIM_PWM_Stop_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b410              PUSH     {r4}
;;;1222   {
;;;1223     /* Check the parameters */
;;;1224     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1225   
;;;1226     switch (Channel)
000002  6802              LDR      r2,[r0,#0]
000004  2900              CMP      r1,#0
;;;1227     {
;;;1228       case TIM_CHANNEL_1:
;;;1229       {
;;;1230         /* Disable the TIM Capture/Compare 1 interrupt */
;;;1231         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000006  bf04              ITT      EQ
000008  68d3              LDREQ    r3,[r2,#0xc]
00000a  f0230302          BICEQ    r3,r3,#2
00000e  d011              BEQ      |L81.52|
000010  2904              CMP      r1,#4                 ;1226
;;;1232       }
;;;1233       break;
;;;1234   
;;;1235       case TIM_CHANNEL_2:
;;;1236       {
;;;1237         /* Disable the TIM Capture/Compare 2 interrupt */
;;;1238         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000012  bf04              ITT      EQ
000014  68d3              LDREQ    r3,[r2,#0xc]
000016  f0230304          BICEQ    r3,r3,#4
00001a  d00b              BEQ      |L81.52|
00001c  2908              CMP      r1,#8                 ;1226
;;;1239       }
;;;1240       break;
;;;1241   
;;;1242       case TIM_CHANNEL_3:
;;;1243       {
;;;1244         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1245         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
00001e  bf04              ITT      EQ
000020  68d3              LDREQ    r3,[r2,#0xc]
000022  f0230308          BICEQ    r3,r3,#8
000026  d005              BEQ      |L81.52|
000028  290c              CMP      r1,#0xc               ;1226
;;;1246       }
;;;1247       break;
;;;1248   
;;;1249       case TIM_CHANNEL_4:
;;;1250       {
;;;1251         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1252         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
00002a  bf04              ITT      EQ
00002c  68d3              LDREQ    r3,[r2,#0xc]
00002e  f0230310          BICEQ    r3,r3,#0x10
000032  d100              BNE      |L81.54|
                  |L81.52|
000034  60d3              STR      r3,[r2,#0xc]          ;1245
                  |L81.54|
000036  6802              LDR      r2,[r0,#0]            ;1245
000038  f04f0c01          MOV      r12,#1                ;1245
;;;1253       }
;;;1254       break;
;;;1255   
;;;1256       default:
;;;1257       break;
;;;1258     }
;;;1259   
;;;1260     /* Disable the Capture compare channel */
;;;1261     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
00003c  2300              MOVS     r3,#0
00003e  6a14              LDR      r4,[r2,#0x20]
000040  fa0cfc01          LSL      r12,r12,r1
000044  ea240c0c          BIC      r12,r4,r12
000048  f8c2c020          STR      r12,[r2,#0x20]
00004c  f8d2c020          LDR      r12,[r2,#0x20]
000050  fa03f101          LSL      r1,r3,r1
000054  ea4c0101          ORR      r1,r12,r1
000058  6211              STR      r1,[r2,#0x20]
;;;1262   
;;;1263     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
00005a  6801              LDR      r1,[r0,#0]
;;;1264     {
;;;1265       /* Disable the Main Ouput */
;;;1266       __HAL_TIM_MOE_DISABLE(htim);
00005c  f2411211          MOV      r2,#0x1111
000060  1093              ASRS     r3,r2,#2
000062  f1a14c80          SUB      r12,r1,#0x40000000    ;1263
000066  f5bc3c96          SUBS     r12,r12,#0x12c00      ;1263
00006a  bf1c              ITT      NE                    ;1263
00006c  f1a14c80          SUBNE    r12,r1,#0x40000000    ;1263
000070  f5bc3c9a          SUBSNE   r12,r12,#0x13400      ;1263
000074  d10f              BNE      |L81.150|
000076  f8d1c020          LDR      r12,[r1,#0x20]
00007a  ea1c0f02          TST      r12,r2
00007e  bf04              ITT      EQ
000080  f8d1c020          LDREQ    r12,[r1,#0x20]
000084  ea1c0f03          TSTEQ    r12,r3
000088  d105              BNE      |L81.150|
00008a  f8d1c044          LDR      r12,[r1,#0x44]
00008e  f42c4c00          BIC      r12,r12,#0x8000
000092  f8c1c044          STR      r12,[r1,#0x44]
                  |L81.150|
;;;1267     }
;;;1268   
;;;1269     /* Disable the Peripheral */
;;;1270     __HAL_TIM_DISABLE(htim);
000096  6800              LDR      r0,[r0,#0]
000098  6a01              LDR      r1,[r0,#0x20]
00009a  4211              TST      r1,r2
00009c  bf04              ITT      EQ
00009e  6a01              LDREQ    r1,[r0,#0x20]
0000a0  4219              TSTEQ    r1,r3
0000a2  d103              BNE      |L81.172|
0000a4  6801              LDR      r1,[r0,#0]
0000a6  f0210101          BIC      r1,r1,#1
0000aa  6001              STR      r1,[r0,#0]
                  |L81.172|
;;;1271   
;;;1272     /* Return function status */
;;;1273     return HAL_OK;
;;;1274   }
0000ac  bc10              POP      {r4}
0000ae  2000              MOVS     r0,#0                 ;1273
0000b0  4770              BX       lr
;;;1275   
                          ENDP


                          AREA ||i.HAL_TIM_PeriodElapsedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PeriodElapsedCallback PROC
;;;4286     */
;;;4287   __weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4288   {
;;;4289     /* Prevent unused argument(s) compilation warning */
;;;4290     UNUSED(htim);
;;;4291     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4292               the __HAL_TIM_PeriodElapsedCallback could be implemented in the user file
;;;4293      */
;;;4294   
;;;4295   }
;;;4296   /**
                          ENDP


                          AREA ||i.HAL_TIM_ReadCapturedValue||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ReadCapturedValue PROC
;;;4199     */
;;;4200   uint32_t HAL_TIM_ReadCapturedValue(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  6bc3              LDR      r3,[r0,#0x3c]
;;;4201   {
;;;4202     uint32_t tmpreg = 0U;
000002  2200              MOVS     r2,#0
;;;4203   
;;;4204     __HAL_LOCK(htim);
000004  2b01              CMP      r3,#1
000006  bf04              ITT      EQ
000008  2002              MOVEQ    r0,#2
;;;4205   
;;;4206     switch (Channel)
;;;4207     {
;;;4208     case TIM_CHANNEL_1:
;;;4209       {
;;;4210         /* Check the parameters */
;;;4211         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4212   
;;;4213         /* Return the capture 1 value */
;;;4214         tmpreg =  htim->Instance->CCR1;
;;;4215   
;;;4216         break;
;;;4217       }
;;;4218     case TIM_CHANNEL_2:
;;;4219       {
;;;4220         /* Check the parameters */
;;;4221         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4222   
;;;4223         /* Return the capture 2 value */
;;;4224         tmpreg =   htim->Instance->CCR2;
;;;4225   
;;;4226         break;
;;;4227       }
;;;4228   
;;;4229     case TIM_CHANNEL_3:
;;;4230       {
;;;4231         /* Check the parameters */
;;;4232         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;4233   
;;;4234         /* Return the capture 3 value */
;;;4235         tmpreg =   htim->Instance->CCR3;
;;;4236   
;;;4237         break;
;;;4238       }
;;;4239   
;;;4240     case TIM_CHANNEL_4:
;;;4241       {
;;;4242         /* Check the parameters */
;;;4243         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;4244   
;;;4245         /* Return the capture 4 value */
;;;4246         tmpreg =   htim->Instance->CCR4;
;;;4247   
;;;4248         break;
;;;4249       }
;;;4250   
;;;4251     default:
;;;4252       break;
;;;4253     }
;;;4254   
;;;4255     __HAL_UNLOCK(htim);
;;;4256     return tmpreg;
;;;4257   }
00000a  4770              BXEQ     lr
00000c  2301              MOVS     r3,#1                 ;4204
00000e  63c3              STR      r3,[r0,#0x3c]         ;4206
000010  2900              CMP      r1,#0                 ;4206
000012  bf04              ITT      EQ                    ;4214
000014  6801              LDREQ    r1,[r0,#0]            ;4214
000016  6b4a              LDREQ    r2,[r1,#0x34]         ;4214
000018  d00d              BEQ      |L83.54|
00001a  2904              CMP      r1,#4                 ;4206
00001c  bf04              ITT      EQ                    ;4224
00001e  6801              LDREQ    r1,[r0,#0]            ;4224
000020  6b8a              LDREQ    r2,[r1,#0x38]         ;4224
000022  d008              BEQ      |L83.54|
000024  2908              CMP      r1,#8                 ;4206
000026  bf04              ITT      EQ                    ;4235
000028  6801              LDREQ    r1,[r0,#0]            ;4235
00002a  6bca              LDREQ    r2,[r1,#0x3c]         ;4235
00002c  d003              BEQ      |L83.54|
00002e  290c              CMP      r1,#0xc               ;4206
000030  bf04              ITT      EQ                    ;4246
000032  6801              LDREQ    r1,[r0,#0]            ;4246
000034  6c0a              LDREQ    r2,[r1,#0x40]         ;4246
                  |L83.54|
000036  2100              MOVS     r1,#0                 ;4255
000038  63c1              STR      r1,[r0,#0x3c]         ;4256
00003a  4610              MOV      r0,r2                 ;4256
00003c  4770              BX       lr
;;;4258   
                          ENDP


                          AREA ||i.HAL_TIM_SlaveConfigSynchronization||, CODE, READONLY, ALIGN=1

                  HAL_TIM_SlaveConfigSynchronization PROC
;;;4126     */
;;;4127   HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization(TIM_HandleTypeDef *htim, TIM_SlaveConfigTypeDef * sSlaveConfig)
000000  b570              PUSH     {r4-r6,lr}
;;;4128   {
000002  4604              MOV      r4,r0
;;;4129     /* Check the parameters */
;;;4130     assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
;;;4131     assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
;;;4132     assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
;;;4133   
;;;4134     __HAL_LOCK(htim);
000004  6bc0              LDR      r0,[r0,#0x3c]
000006  2801              CMP      r0,#1
000008  bf04              ITT      EQ
00000a  2002              MOVEQ    r0,#2
;;;4135   
;;;4136     htim->State = HAL_TIM_STATE_BUSY;
;;;4137   
;;;4138     TIM_SlaveTimer_SetConfig(htim, sSlaveConfig);
;;;4139   
;;;4140     /* Disable Trigger Interrupt */
;;;4141     __HAL_TIM_DISABLE_IT(htim, TIM_IT_TRIGGER);
;;;4142   
;;;4143     /* Disable Trigger DMA request */
;;;4144     __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
;;;4145   
;;;4146     htim->State = HAL_TIM_STATE_READY;
;;;4147   
;;;4148     __HAL_UNLOCK(htim);
;;;4149   
;;;4150     return HAL_OK;
;;;4151       }
00000c  bd70              POPEQ    {r4-r6,pc}
00000e  2501              MOVS     r5,#1                 ;4134
000010  2002              MOVS     r0,#2                 ;4136
000012  63e5              STR      r5,[r4,#0x3c]         ;4136
000014  6420              STR      r0,[r4,#0x40]         ;4136
000016  4620              MOV      r0,r4                 ;4138
000018  f7fffffe          BL       TIM_SlaveTimer_SetConfig
00001c  6820              LDR      r0,[r4,#0]            ;4141
00001e  68c1              LDR      r1,[r0,#0xc]          ;4141
000020  f0210140          BIC      r1,r1,#0x40           ;4141
000024  60c1              STR      r1,[r0,#0xc]          ;4141
000026  6820              LDR      r0,[r4,#0]            ;4144
000028  68c1              LDR      r1,[r0,#0xc]          ;4144
00002a  f4214180          BIC      r1,r1,#0x4000         ;4144
00002e  60c1              STR      r1,[r0,#0xc]          ;4144
000030  6425              STR      r5,[r4,#0x40]         ;4146
000032  2000              MOVS     r0,#0                 ;4148
000034  63e0              STR      r0,[r4,#0x3c]         ;4148
000036  bd70              POP      {r4-r6,pc}
;;;4152   
                          ENDP


                          AREA ||i.HAL_TIM_SlaveConfigSynchronization_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_SlaveConfigSynchronization_IT PROC
;;;4161     */
;;;4162   HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization_IT(TIM_HandleTypeDef *htim,
000000  b570              PUSH     {r4-r6,lr}
;;;4163                                                           TIM_SlaveConfigTypeDef * sSlaveConfig)
;;;4164       {
000002  4604              MOV      r4,r0
;;;4165         /* Check the parameters */
;;;4166     assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
;;;4167     assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
;;;4168     assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
;;;4169   
;;;4170     __HAL_LOCK(htim);
000004  6bc0              LDR      r0,[r0,#0x3c]
000006  2801              CMP      r0,#1
000008  bf04              ITT      EQ
00000a  2002              MOVEQ    r0,#2
;;;4171   
;;;4172     htim->State = HAL_TIM_STATE_BUSY;
;;;4173   
;;;4174     TIM_SlaveTimer_SetConfig(htim, sSlaveConfig);
;;;4175   
;;;4176     /* Enable Trigger Interrupt */
;;;4177     __HAL_TIM_ENABLE_IT(htim, TIM_IT_TRIGGER);
;;;4178   
;;;4179     /* Disable Trigger DMA request */
;;;4180     __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
;;;4181   
;;;4182     htim->State = HAL_TIM_STATE_READY;
;;;4183   
;;;4184     __HAL_UNLOCK(htim);
;;;4185   
;;;4186     return HAL_OK;
;;;4187   }
00000c  bd70              POPEQ    {r4-r6,pc}
00000e  2501              MOVS     r5,#1                 ;4170
000010  2002              MOVS     r0,#2                 ;4172
000012  63e5              STR      r5,[r4,#0x3c]         ;4172
000014  6420              STR      r0,[r4,#0x40]         ;4172
000016  4620              MOV      r0,r4                 ;4174
000018  f7fffffe          BL       TIM_SlaveTimer_SetConfig
00001c  6820              LDR      r0,[r4,#0]            ;4177
00001e  68c1              LDR      r1,[r0,#0xc]          ;4177
000020  f0410140          ORR      r1,r1,#0x40           ;4177
000024  60c1              STR      r1,[r0,#0xc]          ;4177
000026  6820              LDR      r0,[r4,#0]            ;4180
000028  68c1              LDR      r1,[r0,#0xc]          ;4180
00002a  f4214180          BIC      r1,r1,#0x4000         ;4180
00002e  60c1              STR      r1,[r0,#0xc]          ;4180
000030  6425              STR      r5,[r4,#0x40]         ;4182
000032  2000              MOVS     r0,#0                 ;4184
000034  63e0              STR      r0,[r4,#0x3c]         ;4184
000036  bd70              POP      {r4-r6,pc}
;;;4188   
                          ENDP


                          AREA ||i.HAL_TIM_TriggerCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_TriggerCallback PROC
;;;4341     */
;;;4342   __weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4343   {
;;;4344     /* Prevent unused argument(s) compilation warning */
;;;4345     UNUSED(htim);
;;;4346     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4347               the HAL_TIM_TriggerCallback could be implemented in the user file
;;;4348      */
;;;4349   }
;;;4350   
                          ENDP


                          AREA ||i.TIM_Base_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_Base_SetConfig PROC
;;;4568     */
;;;4569   void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
000000  b4f0              PUSH     {r4-r7}
;;;4570   {
;;;4571     uint32_t tmpcr1 = 0U;
;;;4572     tmpcr1 = TIMx->CR1;
000002  6802              LDR      r2,[r0,#0]
;;;4573   
;;;4574     /* Set TIM Time Base Unit parameters ---------------------------------------*/
;;;4575     if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
000004  4b1c              LDR      r3,|L87.120|
000006  4c1d              LDR      r4,|L87.124|
000008  4d1d              LDR      r5,|L87.128|
00000a  4e1e              LDR      r6,|L87.132|
00000c  f8dfc078          LDR      r12,|L87.136|
000010  4298              CMP      r0,r3
000012  bf18              IT       NE
000014  4560              CMPNE    r0,r12
000016  d008              BEQ      |L87.42|
000018  f1b04f80          CMP      r0,#0x40000000
00001c  bf18              IT       NE
00001e  42a0              CMPNE    r0,r4
000020  d003              BEQ      |L87.42|
000022  42a8              CMP      r0,r5
000024  bf18              IT       NE
000026  42b0              CMPNE    r0,r6
000028  d103              BNE      |L87.50|
                  |L87.42|
;;;4576     {
;;;4577       /* Select the Counter Mode */
;;;4578       tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
;;;4579       tmpcr1 |= Structure->CounterMode;
00002a  684f              LDR      r7,[r1,#4]
00002c  f0220270          BIC      r2,r2,#0x70           ;4578
000030  433a              ORRS     r2,r2,r7
                  |L87.50|
;;;4580     }
;;;4581   
;;;4582     if(IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
000032  4298              CMP      r0,r3
000034  bf18              IT       NE
000036  4560              CMPNE    r0,r12
000038  d008              BEQ      |L87.76|
00003a  f1b04f80          CMP      r0,#0x40000000
00003e  bf18              IT       NE
000040  42a0              CMPNE    r0,r4
000042  d003              BEQ      |L87.76|
000044  42a8              CMP      r0,r5
000046  bf18              IT       NE
000048  42b0              CMPNE    r0,r6
00004a  d103              BNE      |L87.84|
                  |L87.76|
;;;4583     {
;;;4584       /* Set the clock division */
;;;4585       tmpcr1 &= ~TIM_CR1_CKD;
;;;4586       tmpcr1 |= (uint32_t)Structure->ClockDivision;
00004c  68cc              LDR      r4,[r1,#0xc]
00004e  f4227240          BIC      r2,r2,#0x300          ;4585
000052  4322              ORRS     r2,r2,r4
                  |L87.84|
;;;4587     }
;;;4588   
;;;4589     /* Set the auto-reload preload */
;;;4590     tmpcr1 &= ~TIM_CR1_ARPE;
;;;4591     tmpcr1 |= (uint32_t)Structure->AutoReloadPreload;
000054  694c              LDR      r4,[r1,#0x14]
000056  f0220280          BIC      r2,r2,#0x80           ;4590
00005a  4322              ORRS     r2,r2,r4
;;;4592   
;;;4593     TIMx->CR1 = tmpcr1;
00005c  6002              STR      r2,[r0,#0]
;;;4594   
;;;4595     /* Set the Autoreload value */
;;;4596     TIMx->ARR = (uint32_t)Structure->Period ;
00005e  688a              LDR      r2,[r1,#8]
000060  62c2              STR      r2,[r0,#0x2c]
;;;4597   
;;;4598     /* Set the Prescaler value */
;;;4599     TIMx->PSC = (uint32_t)Structure->Prescaler;
000062  680a              LDR      r2,[r1,#0]
000064  6282              STR      r2,[r0,#0x28]
;;;4600   
;;;4601     if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
000066  4298              CMP      r0,r3
000068  bf12              ITEE     NE
00006a  4560              CMPNE    r0,r12
;;;4602     {
;;;4603       /* Set the Repetition Counter value */
;;;4604       TIMx->RCR = Structure->RepetitionCounter;
00006c  6909              LDREQ    r1,[r1,#0x10]
00006e  6301              STREQ    r1,[r0,#0x30]
;;;4605     }
;;;4606   
;;;4607     /* Generate an update event to reload the Prescaler 
;;;4608        and the repetition counter(only for TIM1 and TIM8) value immediatly */
;;;4609     TIMx->EGR = TIM_EGR_UG;
000070  2101              MOVS     r1,#1
000072  6141              STR      r1,[r0,#0x14]
;;;4610   }
000074  bcf0              POP      {r4-r7}
000076  4770              BX       lr
;;;4611   
                          ENDP

                  |L87.120|
                          DCD      0x40012c00
                  |L87.124|
                          DCD      0x40000400
                  |L87.128|
                          DCD      0x40000800
                  |L87.132|
                          DCD      0x40000c00
                  |L87.136|
                          DCD      0x40013400

                          AREA ||i.TIM_CCxChannelCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxChannelCmd PROC
;;;5363     */
;;;5364   void TIM_CCxChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelState)
000000  2301              MOVS     r3,#1
;;;5365   {
;;;5366     uint32_t tmp = 0U;
;;;5367   
;;;5368     /* Check the parameters */
;;;5369     assert_param(IS_TIM_CC1_INSTANCE(TIMx));
;;;5370     assert_param(IS_TIM_CHANNELS(Channel));
;;;5371   
;;;5372     tmp = TIM_CCER_CC1E << Channel;
;;;5373   
;;;5374     /* Reset the CCxE Bit */
;;;5375     TIMx->CCER &= ~tmp;
000002  f8d0c020          LDR      r12,[r0,#0x20]
000006  408b              LSLS     r3,r3,r1              ;5372
000008  ea2c0303          BIC      r3,r12,r3
00000c  6203              STR      r3,[r0,#0x20]
;;;5376   
;;;5377     /* Set or reset the CCxE Bit */
;;;5378     TIMx->CCER |=  (uint32_t)(ChannelState << Channel);
00000e  6a03              LDR      r3,[r0,#0x20]
000010  fa02f101          LSL      r1,r2,r1
000014  4319              ORRS     r1,r1,r3
000016  6201              STR      r1,[r0,#0x20]
;;;5379   }
000018  4770              BX       lr
;;;5380   
                          ENDP


                          AREA ||i.TIM_DMACaptureCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMACaptureCplt PROC
;;;4506     */
;;;4507   void TIM_DMACaptureCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;4508   {
;;;4509     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
;;;4510   
;;;4511     htim->State= HAL_TIM_STATE_READY;
000002  6a84              LDR      r4,[r0,#0x28]
000004  2101              MOVS     r1,#1
000006  6421              STR      r1,[r4,#0x40]
;;;4512   
;;;4513     if (hdma == htim->hdma[TIM_DMA_ID_CC1])
000008  6a62              LDR      r2,[r4,#0x24]
00000a  4282              CMP      r2,r0
;;;4514     {
;;;4515       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
00000c  bf08              IT       EQ
00000e  61e1              STREQ    r1,[r4,#0x1c]
000010  d010              BEQ      |L89.52|
;;;4516     }
;;;4517     else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
000012  6aa1              LDR      r1,[r4,#0x28]
000014  4281              CMP      r1,r0
;;;4518     {
;;;4519       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
000016  bf04              ITT      EQ
000018  2002              MOVEQ    r0,#2
00001a  61e0              STREQ    r0,[r4,#0x1c]
00001c  d00a              BEQ      |L89.52|
;;;4520     }
;;;4521     else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
00001e  6ae1              LDR      r1,[r4,#0x2c]
000020  4281              CMP      r1,r0
;;;4522     {
;;;4523       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
000022  bf08              IT       EQ
000024  2004              MOVEQ    r0,#4
000026  d004              BEQ      |L89.50|
;;;4524     }
;;;4525     else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
000028  6b21              LDR      r1,[r4,#0x30]
00002a  4281              CMP      r1,r0
;;;4526     {
;;;4527       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
00002c  bf08              IT       EQ
00002e  2008              MOVEQ    r0,#8
000030  d100              BNE      |L89.52|
                  |L89.50|
000032  61e0              STR      r0,[r4,#0x1c]
                  |L89.52|
;;;4528     }
;;;4529   
;;;4530     HAL_TIM_IC_CaptureCallback(htim);
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
;;;4531   
;;;4532     htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
00003a  2000              MOVS     r0,#0
00003c  61e0              STR      r0,[r4,#0x1c]
;;;4533   }
00003e  bd10              POP      {r4,pc}
;;;4534   
                          ENDP


                          AREA ||i.TIM_DMADelayPulseCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMADelayPulseCplt PROC
;;;4474     */
;;;4475   void TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;4476   {
;;;4477     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
;;;4478   
;;;4479     htim->State= HAL_TIM_STATE_READY;
000002  6a84              LDR      r4,[r0,#0x28]
000004  2101              MOVS     r1,#1
000006  6421              STR      r1,[r4,#0x40]
;;;4480   
;;;4481     if (hdma == htim->hdma[TIM_DMA_ID_CC1])
000008  6a62              LDR      r2,[r4,#0x24]
00000a  4282              CMP      r2,r0
;;;4482     {
;;;4483       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
00000c  bf08              IT       EQ
00000e  61e1              STREQ    r1,[r4,#0x1c]
000010  d010              BEQ      |L90.52|
;;;4484     }
;;;4485     else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
000012  6aa1              LDR      r1,[r4,#0x28]
000014  4281              CMP      r1,r0
;;;4486     {
;;;4487       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
000016  bf04              ITT      EQ
000018  2002              MOVEQ    r0,#2
00001a  61e0              STREQ    r0,[r4,#0x1c]
00001c  d00a              BEQ      |L90.52|
;;;4488     }
;;;4489     else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
00001e  6ae1              LDR      r1,[r4,#0x2c]
000020  4281              CMP      r1,r0
;;;4490     {
;;;4491       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
000022  bf08              IT       EQ
000024  2004              MOVEQ    r0,#4
000026  d004              BEQ      |L90.50|
;;;4492     }
;;;4493     else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
000028  6b21              LDR      r1,[r4,#0x30]
00002a  4281              CMP      r1,r0
;;;4494     {
;;;4495       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
00002c  bf08              IT       EQ
00002e  2008              MOVEQ    r0,#8
000030  d100              BNE      |L90.52|
                  |L90.50|
000032  61e0              STR      r0,[r4,#0x1c]
                  |L90.52|
;;;4496     }
;;;4497   
;;;4498     HAL_TIM_PWM_PulseFinishedCallback(htim);
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
;;;4499   
;;;4500     htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
00003a  2000              MOVS     r0,#0
00003c  61e0              STR      r0,[r4,#0x1c]
;;;4501   }
00003e  bd10              POP      {r4,pc}
;;;4502   /**
                          ENDP


                          AREA ||i.TIM_DMAError||, CODE, READONLY, ALIGN=1

                  TIM_DMAError PROC
;;;4460     */
;;;4461   void TIM_DMAError(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;4462   {
;;;4463     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a80              LDR      r0,[r0,#0x28]
;;;4464   
;;;4465     htim->State= HAL_TIM_STATE_READY;
000004  2101              MOVS     r1,#1
000006  6401              STR      r1,[r0,#0x40]
;;;4466   
;;;4467     HAL_TIM_ErrorCallback(htim);
000008  f7fffffe          BL       HAL_TIM_ErrorCallback
;;;4468   }
00000c  bd10              POP      {r4,pc}
;;;4469   
                          ENDP


                          AREA ||i.TIM_DMAPeriodElapsedCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMAPeriodElapsedCplt PROC
;;;4539     */
;;;4540   static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;4541   {
;;;4542     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a80              LDR      r0,[r0,#0x28]
;;;4543   
;;;4544     htim->State= HAL_TIM_STATE_READY;
000004  2101              MOVS     r1,#1
000006  6401              STR      r1,[r0,#0x40]
;;;4545   
;;;4546     HAL_TIM_PeriodElapsedCallback(htim);
000008  f7fffffe          BL       HAL_TIM_PeriodElapsedCallback
;;;4547   }
00000c  bd10              POP      {r4,pc}
;;;4548   
                          ENDP


                          AREA ||i.TIM_DMATriggerCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMATriggerCplt PROC
;;;4553     */
;;;4554   static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;4555   {
;;;4556     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a80              LDR      r0,[r0,#0x28]
;;;4557   
;;;4558     htim->State= HAL_TIM_STATE_READY;
000004  2101              MOVS     r1,#1
000006  6401              STR      r1,[r0,#0x40]
;;;4559   
;;;4560     HAL_TIM_TriggerCallback(htim);
000008  f7fffffe          BL       HAL_TIM_TriggerCallback
;;;4561   }
00000c  bd10              POP      {r4,pc}
;;;4562   
                          ENDP


                          AREA ||i.TIM_OC2_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC2_SetConfig PROC
;;;4691     */
;;;4692   void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b470              PUSH     {r4-r6}
;;;4693   {
;;;4694     uint32_t tmpccmrx = 0U;
;;;4695     uint32_t tmpccer = 0U;
;;;4696     uint32_t tmpcr2 = 0U;
;;;4697   
;;;4698     /* Disable the Channel 2: Reset the CC2E Bit */
;;;4699     TIMx->CCER &= ~TIM_CCER_CC2E;
000002  6a02              LDR      r2,[r0,#0x20]
000004  f0220210          BIC      r2,r2,#0x10
000008  6202              STR      r2,[r0,#0x20]
;;;4700   
;;;4701     /* Get the TIMx CCER register value */
;;;4702     tmpccer = TIMx->CCER;
00000a  6a02              LDR      r2,[r0,#0x20]
;;;4703     /* Get the TIMx CR2 register value */
;;;4704     tmpcr2 =  TIMx->CR2;
00000c  6843              LDR      r3,[r0,#4]
;;;4705   
;;;4706     /* Get the TIMx CCMR1 register value */
;;;4707     tmpccmrx = TIMx->CCMR1;
00000e  f8d0c018          LDR      r12,[r0,#0x18]
;;;4708   
;;;4709     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;4710     tmpccmrx &= ~TIM_CCMR1_OC2M;
;;;4711     tmpccmrx &= ~TIM_CCMR1_CC2S;
;;;4712   
;;;4713     /* Select the Output Compare Mode */
;;;4714     tmpccmrx |= (OC_Config->OCMode << 8U);
000012  680c              LDR      r4,[r1,#0]
000014  f42c4ce6          BIC      r12,r12,#0x7300       ;4711
000018  ea4c2c04          ORR      r12,r12,r4,LSL #8
;;;4715   
;;;4716     /* Reset the Output Polarity level */
;;;4717     tmpccer &= ~TIM_CCER_CC2P;
;;;4718     /* Set the Output Compare Polarity */
;;;4719     tmpccer |= (OC_Config->OCPolarity << 4U);
00001c  688c              LDR      r4,[r1,#8]
00001e  f0220220          BIC      r2,r2,#0x20           ;4717
000022  ea421204          ORR      r2,r2,r4,LSL #4
;;;4720   
;;;4721     if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
000026  4c10              LDR      r4,|L94.104|
000028  4d10              LDR      r5,|L94.108|
00002a  42a0              CMP      r0,r4
00002c  bf18              IT       NE
00002e  42a8              CMPNE    r0,r5
000030  d106              BNE      |L94.64|
;;;4722     {
;;;4723       assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
;;;4724   
;;;4725       /* Reset the Output N Polarity level */
;;;4726       tmpccer &= ~TIM_CCER_CC2NP;
;;;4727       /* Set the Output N Polarity */
;;;4728       tmpccer |= (OC_Config->OCNPolarity << 4U);
000032  68ce              LDR      r6,[r1,#0xc]
000034  f0220280          BIC      r2,r2,#0x80           ;4726
000038  ea421206          ORR      r2,r2,r6,LSL #4
;;;4729       /* Reset the Output N State */
;;;4730       tmpccer &= ~TIM_CCER_CC2NE;
00003c  f0220240          BIC      r2,r2,#0x40
                  |L94.64|
;;;4731   
;;;4732     }
;;;4733   
;;;4734     if(IS_TIM_BREAK_INSTANCE(TIMx))
000040  42a0              CMP      r0,r4
000042  bf18              IT       NE
000044  42a8              CMPNE    r0,r5
000046  d107              BNE      |L94.88|
;;;4735     {
;;;4736       /* Check parameters */
;;;4737       assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
;;;4738       assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
;;;4739   
;;;4740       /* Reset the Output Compare and Output Compare N IDLE State */
;;;4741       tmpcr2 &= ~TIM_CR2_OIS2;
;;;4742       tmpcr2 &= ~TIM_CR2_OIS2N;
;;;4743       /* Set the Output Idle state */
;;;4744       tmpcr2 |= (OC_Config->OCIdleState << 2);
000048  694c              LDR      r4,[r1,#0x14]
00004a  f4236340          BIC      r3,r3,#0xc00          ;4742
00004e  ea430384          ORR      r3,r3,r4,LSL #2
;;;4745       /* Set the Output N Idle state */
;;;4746       tmpcr2 |= (OC_Config->OCNIdleState << 2);
000052  698c              LDR      r4,[r1,#0x18]
000054  ea430384          ORR      r3,r3,r4,LSL #2
                  |L94.88|
;;;4747     }
;;;4748   
;;;4749     /* Write to TIMx CR2 */
;;;4750     TIMx->CR2 = tmpcr2;
000058  6043              STR      r3,[r0,#4]
;;;4751   
;;;4752     /* Write to TIMx CCMR1 */
;;;4753     TIMx->CCMR1 = tmpccmrx;
00005a  f8c0c018          STR      r12,[r0,#0x18]
;;;4754   
;;;4755     /* Set the Capture Compare Register value */
;;;4756     TIMx->CCR2 = OC_Config->Pulse;
00005e  6849              LDR      r1,[r1,#4]
000060  6381              STR      r1,[r0,#0x38]
;;;4757   
;;;4758     /* Write to TIMx CCER */
;;;4759     TIMx->CCER = tmpccer;
000062  6202              STR      r2,[r0,#0x20]
;;;4760   }
000064  bc70              POP      {r4-r6}
000066  4770              BX       lr
;;;4761   
                          ENDP

                  |L94.104|
                          DCD      0x40012c00
                  |L94.108|
                          DCD      0x40013400

                          AREA ||i.TIM_SlaveTimer_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_SlaveTimer_SetConfig PROC
;;;4901     */
;;;4902   static void TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
000000  6803              LDR      r3,[r0,#0]
;;;4903                                 TIM_SlaveConfigTypeDef * sSlaveConfig)
;;;4904   {
;;;4905     uint32_t tmpsmcr = 0U;
;;;4906     uint32_t tmpccmr1 = 0U;
;;;4907     uint32_t tmpccer = 0U;
;;;4908   
;;;4909     /* Get the TIMx SMCR register value */
;;;4910     tmpsmcr = htim->Instance->SMCR;
000002  689a              LDR      r2,[r3,#8]
;;;4911   
;;;4912     /* Reset the Trigger Selection Bits */
;;;4913     tmpsmcr &= ~TIM_SMCR_TS;
;;;4914     /* Set the Input Trigger source */
;;;4915     tmpsmcr |= sSlaveConfig->InputTrigger;
000004  f8d1c004          LDR      r12,[r1,#4]
000008  f0220270          BIC      r2,r2,#0x70           ;4913
00000c  ea4c0202          ORR      r2,r12,r2
;;;4916   
;;;4917     /* Reset the slave mode Bits */
;;;4918     tmpsmcr &= ~TIM_SMCR_SMS;
;;;4919     /* Set the slave mode */
;;;4920     tmpsmcr |= sSlaveConfig->SlaveMode;
000010  f8d1c000          LDR      r12,[r1,#0]
000014  f0220207          BIC      r2,r2,#7              ;4918
000018  ea4c0202          ORR      r2,r12,r2
;;;4921   
;;;4922     /* Write to TIMx SMCR */
;;;4923     htim->Instance->SMCR = tmpsmcr;
00001c  609a              STR      r2,[r3,#8]
;;;4924   
;;;4925     /* Configure the trigger prescaler, filter, and polarity */
;;;4926     switch (sSlaveConfig->InputTrigger)
00001e  684a              LDR      r2,[r1,#4]
000020  f0120f0f          TST      r2,#0xf
;;;4927     {
;;;4928     case TIM_TS_ETRF:
;;;4929       {
;;;4930         /* Check the parameters */
;;;4931         assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
;;;4932         assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));
;;;4933         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;4934         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;4935         /* Configure the ETR Trigger source */
;;;4936         TIM_ETR_SetConfig(htim->Instance,
;;;4937                           sSlaveConfig->TriggerPrescaler,
;;;4938                           sSlaveConfig->TriggerPolarity,
;;;4939                           sSlaveConfig->TriggerFilter);
;;;4940       }
;;;4941       break;
;;;4942   
;;;4943     case TIM_TS_TI1F_ED:
;;;4944       {
;;;4945         /* Check the parameters */
;;;4946         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4947         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;4948   
;;;4949         /* Disable the Channel 1: Reset the CC1E Bit */
;;;4950         tmpccer = htim->Instance->CCER;
;;;4951         htim->Instance->CCER &= ~TIM_CCER_CC1E;
;;;4952         tmpccmr1 = htim->Instance->CCMR1;
;;;4953   
;;;4954         /* Set the filter */
;;;4955         tmpccmr1 &= ~TIM_CCMR1_IC1F;
;;;4956         tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4U);
;;;4957   
;;;4958         /* Write to TIMx CCMR1 and CCER registers */
;;;4959         htim->Instance->CCMR1 = tmpccmr1;
;;;4960         htim->Instance->CCER = tmpccer;
;;;4961   
;;;4962       }
;;;4963       break;
;;;4964   
;;;4965     case TIM_TS_TI1FP1:
;;;4966       {
;;;4967         /* Check the parameters */
;;;4968         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4969         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;4970         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;4971   
;;;4972         /* Configure TI1 Filter and Polarity */
;;;4973         TIM_TI1_ConfigInputStage(htim->Instance,
;;;4974                                  sSlaveConfig->TriggerPolarity,
;;;4975                                  sSlaveConfig->TriggerFilter);
;;;4976       }
;;;4977       break;
;;;4978   
;;;4979     case TIM_TS_TI2FP2:
;;;4980       {
;;;4981         /* Check the parameters */
;;;4982         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4983         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;4984         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;4985   
;;;4986         /* Configure TI2 Filter and Polarity */
;;;4987         TIM_TI2_ConfigInputStage(htim->Instance,
;;;4988                                   sSlaveConfig->TriggerPolarity,
;;;4989                                   sSlaveConfig->TriggerFilter);
;;;4990       }
;;;4991       break;
;;;4992   
;;;4993     case TIM_TS_ITR0:
;;;4994       {
;;;4995         /* Check the parameter */
;;;4996         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4997       }
;;;4998       break;
;;;4999   
;;;5000     case TIM_TS_ITR1:
;;;5001       {
;;;5002         /* Check the parameter */
;;;5003         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5004       }
;;;5005       break;
;;;5006   
;;;5007     case TIM_TS_ITR2:
;;;5008       {
;;;5009         /* Check the parameter */
;;;5010         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5011       }
;;;5012       break;
;;;5013   
;;;5014     case TIM_TS_ITR3:
;;;5015       {
;;;5016         /* Check the parameter */
;;;5017         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5018       }
;;;5019       break;
;;;5020   
;;;5021     default:
;;;5022       break;
;;;5023     }
;;;5024   }
000024  bf18              IT       NE
000026  4770              BXNE     lr
000028  1112              ASRS     r2,r2,#4              ;4926
00002a  2a08              CMP      r2,#8                 ;4926
00002c  bf28              IT       CS
00002e  4770              BXCS     lr
000030  e8dff002          TBB      [pc,r2]
000034  12121212          DCB      0x12,0x12,0x12,0x12
000038  13273d04          DCB      0x13,0x27,0x3d,0x04
00003c  6800              LDR      r0,[r0,#0]            ;4936
00003e  e9d12302          LDRD     r2,r3,[r1,#8]         ;4936
000042  6909              LDR      r1,[r1,#0x10]         ;4936
000044  f8d0c008          LDR      r12,[r0,#8]           ;4936
000048  ea422101          ORR      r1,r2,r1,LSL #8       ;4936
00004c  f42c4c7f          BIC      r12,r12,#0xff00       ;4936
000050  4319              ORRS     r1,r1,r3              ;4936
000052  ea41010c          ORR      r1,r1,r12             ;4936
000056  6081              STR      r1,[r0,#8]            ;4936
000058  4770              BX       lr
00005a  6802              LDR      r2,[r0,#0]            ;4950
00005c  6a13              LDR      r3,[r2,#0x20]         ;4950
00005e  f8d2c020          LDR      r12,[r2,#0x20]        ;4951
000062  f02c0c01          BIC      r12,r12,#1            ;4951
000066  f8c2c020          STR      r12,[r2,#0x20]        ;4951
00006a  6802              LDR      r2,[r0,#0]            ;4952
00006c  f8d2c018          LDR      r12,[r2,#0x18]        ;4952
000070  6909              LDR      r1,[r1,#0x10]         ;4956
000072  f02c0cf0          BIC      r12,r12,#0xf0         ;4955
000076  ea4c1101          ORR      r1,r12,r1,LSL #4      ;4956
00007a  6191              STR      r1,[r2,#0x18]         ;4959
00007c  6800              LDR      r0,[r0,#0]            ;4960
00007e  6203              STR      r3,[r0,#0x20]         ;4960
000080  4770              BX       lr
000082  6800              LDR      r0,[r0,#0]            ;4973
000084  690b              LDR      r3,[r1,#0x10]         ;4973
000086  688a              LDR      r2,[r1,#8]            ;4973
000088  6a01              LDR      r1,[r0,#0x20]         ;4973
00008a  f8d0c020          LDR      r12,[r0,#0x20]        ;4973
00008e  f02c0c01          BIC      r12,r12,#1            ;4973
000092  f8c0c020          STR      r12,[r0,#0x20]        ;4973
000096  f8d0c018          LDR      r12,[r0,#0x18]        ;4973
00009a  f021010a          BIC      r1,r1,#0xa            ;4973
00009e  f02c0cf0          BIC      r12,r12,#0xf0         ;4973
0000a2  ea4c1303          ORR      r3,r12,r3,LSL #4      ;4973
0000a6  4311              ORRS     r1,r1,r2              ;4973
0000a8  6183              STR      r3,[r0,#0x18]         ;4973
0000aa  6201              STR      r1,[r0,#0x20]         ;4973
0000ac  4770              BX       lr
0000ae  6800              LDR      r0,[r0,#0]            ;4987
0000b0  688a              LDR      r2,[r1,#8]            ;4987
0000b2  6909              LDR      r1,[r1,#0x10]         ;4987
0000b4  6a03              LDR      r3,[r0,#0x20]         ;4987
0000b6  f0230310          BIC      r3,r3,#0x10           ;4987
0000ba  6203              STR      r3,[r0,#0x20]         ;4987
0000bc  6983              LDR      r3,[r0,#0x18]         ;4987
0000be  f8d0c020          LDR      r12,[r0,#0x20]        ;4987
0000c2  f4234370          BIC      r3,r3,#0xf000         ;4987
0000c6  ea433101          ORR      r1,r3,r1,LSL #12      ;4987
0000ca  f02c03a0          BIC      r3,r12,#0xa0          ;4987
0000ce  ea431202          ORR      r2,r3,r2,LSL #4       ;4987
0000d2  6181              STR      r1,[r0,#0x18]         ;4987
0000d4  6202              STR      r2,[r0,#0x20]         ;4987
0000d6  4770              BX       lr
;;;5025   
                          ENDP


                          AREA ||i.TIM_TI1_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_TI1_SetConfig PROC
;;;5044     */
;;;5045   void TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
000000  b430              PUSH     {r4,r5}
;;;5046                          uint32_t TIM_ICFilter)
;;;5047   {
;;;5048     uint32_t tmpccmr1 = 0U;
;;;5049     uint32_t tmpccer = 0U;
;;;5050   
;;;5051     /* Disable the Channel 1: Reset the CC1E Bit */
;;;5052     TIMx->CCER &= ~TIM_CCER_CC1E;
000002  f8d0c020          LDR      r12,[r0,#0x20]
000006  f02c0c01          BIC      r12,r12,#1
00000a  f8c0c020          STR      r12,[r0,#0x20]
;;;5053     tmpccmr1 = TIMx->CCMR1;
00000e  f8d0c018          LDR      r12,[r0,#0x18]
;;;5054     tmpccer = TIMx->CCER;
000012  6a04              LDR      r4,[r0,#0x20]
;;;5055   
;;;5056     /* Select the Input */
;;;5057     if(IS_TIM_CC2_INSTANCE(TIMx) != RESET)
000014  f1a04580          SUB      r5,r0,#0x40000000
000018  f5b53596          SUBS     r5,r5,#0x12c00
00001c  bf1c              ITT      NE
00001e  f1a04580          SUBNE    r5,r0,#0x40000000
000022  f5b5359a          SUBSNE   r5,r5,#0x13400
000026  d013              BEQ      |L96.80|
000028  f1b04f80          CMP      r0,#0x40000000
00002c  bf1c              ITT      NE
00002e  f1a04580          SUBNE    r5,r0,#0x40000000
000032  f5b56580          SUBSNE   r5,r5,#0x400
000036  d00b              BEQ      |L96.80|
000038  f1a04580          SUB      r5,r0,#0x40000000
00003c  f5b56500          SUBS     r5,r5,#0x800
000040  bf1e              ITTT     NE
000042  f1a04580          SUBNE    r5,r0,#0x40000000
000046  f5b56540          SUBSNE   r5,r5,#0xc00
;;;5058     {
;;;5059       tmpccmr1 &= ~TIM_CCMR1_CC1S;
;;;5060       tmpccmr1 |= TIM_ICSelection;
;;;5061     }
;;;5062     else
;;;5063     {
;;;5064       tmpccmr1 |= TIM_CCMR1_CC1S_0;
00004a  f04c0201          ORRNE    r2,r12,#1
00004e  d103              BNE      |L96.88|
                  |L96.80|
000050  f02c0c03          BIC      r12,r12,#3            ;5059
000054  ea4c0202          ORR      r2,r12,r2             ;5060
                  |L96.88|
;;;5065     }
;;;5066   
;;;5067     /* Set the filter */
;;;5068     tmpccmr1 &= ~TIM_CCMR1_IC1F;
;;;5069     tmpccmr1 |= ((TIM_ICFilter << 4U) & TIM_CCMR1_IC1F);
000058  f04f0cf0          MOV      r12,#0xf0
00005c  f02202f0          BIC      r2,r2,#0xf0           ;5068
000060  ea0c1303          AND      r3,r12,r3,LSL #4
000064  431a              ORRS     r2,r2,r3
;;;5070   
;;;5071     /* Select the Polarity and set the CC1E Bit */
;;;5072     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
000066  f024030a          BIC      r3,r4,#0xa
;;;5073     tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));
00006a  f001010a          AND      r1,r1,#0xa
00006e  4319              ORRS     r1,r1,r3
;;;5074   
;;;5075     /* Write to TIMx CCMR1 and CCER registers */
;;;5076     TIMx->CCMR1 = tmpccmr1;
000070  6182              STR      r2,[r0,#0x18]
;;;5077     TIMx->CCER = tmpccer;
000072  6201              STR      r1,[r0,#0x20]
;;;5078   }
000074  bc30              POP      {r4,r5}
000076  4770              BX       lr
;;;5079   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F1_V1.6.0\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_tim.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_tim_c_a9d95b52____REV16|
#line 388 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F1_V1.6.0\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___19_stm32f1xx_hal_tim_c_a9d95b52____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_tim_c_a9d95b52____REVSH|
#line 402
|__asm___19_stm32f1xx_hal_tim_c_a9d95b52____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_tim_c_a9d95b52____RRX|
#line 587
|__asm___19_stm32f1xx_hal_tim_c_a9d95b52____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
