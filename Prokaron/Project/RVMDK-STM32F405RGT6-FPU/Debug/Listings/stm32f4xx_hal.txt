; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f4xx_hal.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f4xx_hal.d --cpu=Cortex-M4.fp --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F4_V1.21.0\Drivers\STM32F4xx_HAL_Driver\Inc -I..\..\..\M0P0_Library\STM32Cube_FW_F4_V1.21.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F4_V1.21.0\Drivers\CMSIS\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F4_V1.21.0\Drivers\STM32F4xx_HAL_Driver\Inc\Conf -I.\Source -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F405RGT6-FPU\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.11.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F405xx -DSTM32F405xx -DUSE_HAL_DRIVER -DHSE_VALUE=8000000 -DPLL_M=8 --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f4xx_hal.crf ..\..\..\M0P0_Library\STM32Cube_FW_F4_V1.21.0\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal.c]
                          THUMB

                          AREA ||i.HAL_DBGMCU_DisableDBGSleepMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_DisableDBGSleepMode PROC
;;;480      */
;;;481    void HAL_DBGMCU_DisableDBGSleepMode(void)
000000  4802              LDR      r0,|L1.12|
;;;482    {
;;;483      CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
000002  6841              LDR      r1,[r0,#4]
000004  f0210101          BIC      r1,r1,#1
000008  6041              STR      r1,[r0,#4]
;;;484    }
00000a  4770              BX       lr
;;;485    
                          ENDP

                  |L1.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_DisableDBGStandbyMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_DisableDBGStandbyMode PROC
;;;516      */
;;;517    void HAL_DBGMCU_DisableDBGStandbyMode(void)
000000  4802              LDR      r0,|L2.12|
;;;518    {
;;;519      CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
000002  6841              LDR      r1,[r0,#4]
000004  f0210104          BIC      r1,r1,#4
000008  6041              STR      r1,[r0,#4]
;;;520    }
00000a  4770              BX       lr
;;;521    
                          ENDP

                  |L2.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_DisableDBGStopMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_DisableDBGStopMode PROC
;;;498      */
;;;499    void HAL_DBGMCU_DisableDBGStopMode(void)
000000  4802              LDR      r0,|L3.12|
;;;500    {
;;;501      CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
000002  6841              LDR      r1,[r0,#4]
000004  f0210102          BIC      r1,r1,#2
000008  6041              STR      r1,[r0,#4]
;;;502    }
00000a  4770              BX       lr
;;;503    
                          ENDP

                  |L3.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_EnableDBGSleepMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_EnableDBGSleepMode PROC
;;;471      */
;;;472    void HAL_DBGMCU_EnableDBGSleepMode(void)
000000  4802              LDR      r0,|L4.12|
;;;473    {
;;;474      SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
000002  6841              LDR      r1,[r0,#4]
000004  f0410101          ORR      r1,r1,#1
000008  6041              STR      r1,[r0,#4]
;;;475    }
00000a  4770              BX       lr
;;;476    
                          ENDP

                  |L4.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_EnableDBGStandbyMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_EnableDBGStandbyMode PROC
;;;507      */
;;;508    void HAL_DBGMCU_EnableDBGStandbyMode(void)
000000  4802              LDR      r0,|L5.12|
;;;509    {
;;;510      SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
000002  6841              LDR      r1,[r0,#4]
000004  f0410104          ORR      r1,r1,#4
000008  6041              STR      r1,[r0,#4]
;;;511    }
00000a  4770              BX       lr
;;;512    
                          ENDP

                  |L5.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_EnableDBGStopMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_EnableDBGStopMode PROC
;;;489      */
;;;490    void HAL_DBGMCU_EnableDBGStopMode(void)
000000  4802              LDR      r0,|L6.12|
;;;491    {
;;;492      SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
000002  6841              LDR      r1,[r0,#4]
000004  f0410102          ORR      r1,r1,#2
000008  6041              STR      r1,[r0,#4]
;;;493    }
00000a  4770              BX       lr
;;;494    
                          ENDP

                  |L6.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_DeInit PROC
;;;205      */
;;;206    HAL_StatusTypeDef HAL_DeInit(void)
000000  4a0b              LDR      r2,|L7.48|
;;;207    {
000002  b510              PUSH     {r4,lr}
;;;208      /* Reset of all peripherals */
;;;209      __HAL_RCC_APB1_FORCE_RESET();
000004  f04f30ff          MOV      r0,#0xffffffff
000008  6010              STR      r0,[r2,#0]
;;;210      __HAL_RCC_APB1_RELEASE_RESET();
00000a  2100              MOVS     r1,#0
00000c  6011              STR      r1,[r2,#0]
;;;211    
;;;212      __HAL_RCC_APB2_FORCE_RESET();
00000e  1d12              ADDS     r2,r2,#4
000010  6010              STR      r0,[r2,#0]
;;;213      __HAL_RCC_APB2_RELEASE_RESET();
000012  6011              STR      r1,[r2,#0]
;;;214    
;;;215      __HAL_RCC_AHB1_FORCE_RESET();
000014  4a07              LDR      r2,|L7.52|
000016  6010              STR      r0,[r2,#0]
;;;216      __HAL_RCC_AHB1_RELEASE_RESET();
000018  6011              STR      r1,[r2,#0]
;;;217    
;;;218      __HAL_RCC_AHB2_FORCE_RESET();
00001a  1d12              ADDS     r2,r2,#4
00001c  6010              STR      r0,[r2,#0]
;;;219      __HAL_RCC_AHB2_RELEASE_RESET();
00001e  6011              STR      r1,[r2,#0]
;;;220    
;;;221      __HAL_RCC_AHB3_FORCE_RESET();
000020  1d12              ADDS     r2,r2,#4
000022  6010              STR      r0,[r2,#0]
;;;222      __HAL_RCC_AHB3_RELEASE_RESET();
000024  6011              STR      r1,[r2,#0]
;;;223    
;;;224      /* De-Init the low level hardware */
;;;225      HAL_MspDeInit();
000026  f7fffffe          BL       HAL_MspDeInit
;;;226        
;;;227      /* Return function status */
;;;228      return HAL_OK;
00002a  2000              MOVS     r0,#0
;;;229    }
00002c  bd10              POP      {r4,pc}
;;;230    
                          ENDP

00002e  0000              DCW      0x0000
                  |L7.48|
                          DCD      0x40023820
                  |L7.52|
                          DCD      0x40023810

                          AREA ||i.HAL_Delay||, CODE, READONLY, ALIGN=2

                  HAL_Delay PROC
;;;392      */
;;;393    __weak void HAL_Delay(uint32_t Delay)
000000  b570              PUSH     {r4-r6,lr}
;;;394    {
000002  4604              MOV      r4,r0
;;;395      uint32_t tickstart = HAL_GetTick();
000004  f7fffffe          BL       HAL_GetTick
000008  4605              MOV      r5,r0
;;;396      uint32_t wait = Delay;
;;;397    
;;;398      /* Add a freq to guarantee minimum wait */
;;;399      if (wait < HAL_MAX_DELAY)
00000a  f1b43fff          CMP      r4,#0xffffffff
00000e  d002              BEQ      |L8.22|
;;;400      {
;;;401        wait += (uint32_t)(uwTickFreq);
000010  4804              LDR      r0,|L8.36|
000012  6840              LDR      r0,[r0,#4]  ; uwTickFreq
000014  4404              ADD      r4,r4,r0
                  |L8.22|
;;;402      }
;;;403    
;;;404      while((HAL_GetTick() - tickstart) < wait)
000016  f7fffffe          BL       HAL_GetTick
00001a  1b40              SUBS     r0,r0,r5
00001c  42a0              CMP      r0,r4
00001e  d3fa              BCC      |L8.22|
;;;405      {
;;;406      }
;;;407    }
000020  bd70              POP      {r4-r6,pc}
;;;408    
                          ENDP

000022  0000              DCW      0x0000
                  |L8.36|
                          DCD      ||.data||

                          AREA ||i.HAL_DisableCompensationCell||, CODE, READONLY, ALIGN=2

                  HAL_DisableCompensationCell PROC
;;;538      */
;;;539    void HAL_DisableCompensationCell(void)
000000  4901              LDR      r1,|L9.8|
;;;540    {
;;;541      *(__IO uint32_t *)CMPCR_CMP_PD_BB = (uint32_t)DISABLE;
000002  2000              MOVS     r0,#0
000004  6008              STR      r0,[r1,#0]
;;;542    }
000006  4770              BX       lr
;;;543    
                          ENDP

                  |L9.8|
                          DCD      0x42270400

                          AREA ||i.HAL_EnableCompensationCell||, CODE, READONLY, ALIGN=2

                  HAL_EnableCompensationCell PROC
;;;527      */
;;;528    void HAL_EnableCompensationCell(void)
000000  4901              LDR      r1,|L10.8|
;;;529    {
;;;530      *(__IO uint32_t *)CMPCR_CMP_PD_BB = (uint32_t)ENABLE;
000002  2001              MOVS     r0,#1
000004  6008              STR      r0,[r1,#0]
;;;531    }
000006  4770              BX       lr
;;;532    
                          ENDP

                  |L10.8|
                          DCD      0x42270400

                          AREA ||i.HAL_GetDEVID||, CODE, READONLY, ALIGN=2

                  HAL_GetDEVID PROC
;;;462      */
;;;463    uint32_t HAL_GetDEVID(void)
000000  4802              LDR      r0,|L11.12|
;;;464    {
;;;465      return((DBGMCU->IDCODE) & IDCODE_DEVID_MASK);
000002  6800              LDR      r0,[r0,#0]
000004  f3c0000b          UBFX     r0,r0,#0,#12
;;;466    }
000008  4770              BX       lr
;;;467    
                          ENDP

00000a  0000              DCW      0x0000
                  |L11.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_GetHalVersion||, CODE, READONLY, ALIGN=2

                  HAL_GetHalVersion PROC
;;;444      */
;;;445    uint32_t HAL_GetHalVersion(void)
000000  4800              LDR      r0,|L12.4|
;;;446    {
;;;447      return __STM32F4xx_HAL_VERSION;
;;;448    }
000002  4770              BX       lr
;;;449    
                          ENDP

                  |L12.4|
                          DCD      0x01070400

                          AREA ||i.HAL_GetREVID||, CODE, READONLY, ALIGN=2

                  HAL_GetREVID PROC
;;;453      */
;;;454    uint32_t HAL_GetREVID(void)
000000  4801              LDR      r0,|L13.8|
;;;455    {
;;;456      return((DBGMCU->IDCODE) >> 16U);
000002  6800              LDR      r0,[r0,#0]
000004  0c00              LSRS     r0,r0,#16
;;;457    }
000006  4770              BX       lr
;;;458    
                          ENDP

                  |L13.8|
                          DCD      0xe0042000

                          AREA ||i.HAL_GetTick||, CODE, READONLY, ALIGN=2

                  HAL_GetTick PROC
;;;338      */
;;;339    __weak uint32_t HAL_GetTick(void)
000000  4801              LDR      r0,|L14.8|
;;;340    {
;;;341      return uwTick;
000002  6880              LDR      r0,[r0,#8]  ; uwTick
;;;342    }
000004  4770              BX       lr
;;;343    
                          ENDP

000006  0000              DCW      0x0000
                  |L14.8|
                          DCD      ||.data||

                          AREA ||i.HAL_GetTickFreq||, CODE, READONLY, ALIGN=2

                  HAL_GetTickFreq PROC
;;;376      */
;;;377    HAL_TickFreqTypeDef HAL_GetTickFreq(void)
000000  4801              LDR      r0,|L15.8|
;;;378    {
;;;379      return uwTickFreq;
000002  6840              LDR      r0,[r0,#4]  ; uwTickFreq
;;;380    }
000004  4770              BX       lr
;;;381    
                          ENDP

000006  0000              DCW      0x0000
                  |L15.8|
                          DCD      ||.data||

                          AREA ||i.HAL_GetTickPrio||, CODE, READONLY, ALIGN=2

                  HAL_GetTickPrio PROC
;;;347      */
;;;348    uint32_t HAL_GetTickPrio(void)
000000  4801              LDR      r0,|L16.8|
;;;349    {
;;;350      return uwTickPrio;
000002  6800              LDR      r0,[r0,#0]  ; uwTickPrio
;;;351    }
000004  4770              BX       lr
;;;352    
                          ENDP

000006  0000              DCW      0x0000
                  |L16.8|
                          DCD      ||.data||

                          AREA ||i.HAL_GetUID||, CODE, READONLY, ALIGN=2

                  HAL_GetUID PROC
;;;548      */
;;;549    void HAL_GetUID(uint32_t *UID)
000000  4904              LDR      r1,|L17.20|
;;;550    {
;;;551      UID[0] = (uint32_t)(READ_REG(*((uint32_t *)UID_BASE)));
000002  6809              LDR      r1,[r1,#0]
;;;552      UID[1] = (uint32_t)(READ_REG(*((uint32_t *)(UID_BASE + 4U))));
000004  6001              STR      r1,[r0,#0]
000006  4904              LDR      r1,|L17.24|
000008  6809              LDR      r1,[r1,#0]
;;;553      UID[2] = (uint32_t)(READ_REG(*((uint32_t *)(UID_BASE + 8U))));
00000a  6041              STR      r1,[r0,#4]
00000c  4903              LDR      r1,|L17.28|
00000e  6809              LDR      r1,[r1,#0]
000010  6081              STR      r1,[r0,#8]
;;;554    }
000012  4770              BX       lr
;;;555    
                          ENDP

                  |L17.20|
                          DCD      0x1fff7a10
                  |L17.24|
                          DCD      0x1fff7a14
                  |L17.28|
                          DCD      0x1fff7a18

                          AREA ||i.HAL_IncTick||, CODE, READONLY, ALIGN=2

                  HAL_IncTick PROC
;;;327      */
;;;328    __weak void HAL_IncTick(void)
000000  4802              LDR      r0,|L18.12|
;;;329    {
;;;330      uwTick += uwTickFreq;
000002  6881              LDR      r1,[r0,#8]  ; uwTick
000004  6842              LDR      r2,[r0,#4]  ; uwTickFreq
000006  4411              ADD      r1,r1,r2
000008  6081              STR      r1,[r0,#8]  ; uwTick
;;;331    }
00000a  4770              BX       lr
;;;332    
                          ENDP

                  |L18.12|
                          DCD      ||.data||

                          AREA ||i.HAL_Init||, CODE, READONLY, ALIGN=2

                  HAL_Init PROC
;;;172      */
;;;173    HAL_StatusTypeDef HAL_Init(void)
000000  480b              LDR      r0,|L19.48|
;;;174    {
000002  b510              PUSH     {r4,lr}
;;;175      /* Configure Flash prefetch, Instruction cache, Data cache */ 
;;;176    #if (INSTRUCTION_CACHE_ENABLE != 0U)
;;;177      __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
000004  6801              LDR      r1,[r0,#0]
000006  f4417100          ORR      r1,r1,#0x200
00000a  6001              STR      r1,[r0,#0]
;;;178    #endif /* INSTRUCTION_CACHE_ENABLE */
;;;179    
;;;180    #if (DATA_CACHE_ENABLE != 0U)
;;;181      __HAL_FLASH_DATA_CACHE_ENABLE();
00000c  6801              LDR      r1,[r0,#0]
00000e  f4416180          ORR      r1,r1,#0x400
000012  6001              STR      r1,[r0,#0]
;;;182    #endif /* DATA_CACHE_ENABLE */
;;;183    
;;;184    #if (PREFETCH_ENABLE != 0U)
;;;185      __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
000014  6801              LDR      r1,[r0,#0]
000016  f4417180          ORR      r1,r1,#0x100
00001a  6001              STR      r1,[r0,#0]
;;;186    #endif /* PREFETCH_ENABLE */
;;;187    
;;;188      /* Set Interrupt Group Priority */
;;;189      HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
00001c  2003              MOVS     r0,#3
00001e  f7fffffe          BL       HAL_NVIC_SetPriorityGrouping
;;;190    
;;;191      /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
;;;192      HAL_InitTick(TICK_INT_PRIORITY);
000022  200f              MOVS     r0,#0xf
000024  f7fffffe          BL       HAL_InitTick
;;;193    
;;;194      /* Init the low level hardware */
;;;195      HAL_MspInit();
000028  f7fffffe          BL       HAL_MspInit
;;;196    
;;;197      /* Return function status */
;;;198      return HAL_OK;
00002c  2000              MOVS     r0,#0
;;;199    }
00002e  bd10              POP      {r4,pc}
;;;200    
                          ENDP

                  |L19.48|
                          DCD      0x40023c00

                          AREA ||i.HAL_InitTick||, CODE, READONLY, ALIGN=2

                  HAL_InitTick PROC
;;;268      */
;;;269    __weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
000000  b570              PUSH     {r4-r6,lr}
;;;270    {
;;;271      /* Configure the SysTick to have interrupt in 1ms time basis*/
;;;272      if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
000002  4d0d              LDR      r5,|L20.56|
000004  4604              MOV      r4,r0                 ;270
000006  f44f717a          MOV      r1,#0x3e8
00000a  6868              LDR      r0,[r5,#4]  ; uwTickFreq
00000c  fbb1f0f0          UDIV     r0,r1,r0
000010  490a              LDR      r1,|L20.60|
000012  6809              LDR      r1,[r1,#0]  ; SystemCoreClock
000014  fbb1f0f0          UDIV     r0,r1,r0
000018  f7fffffe          BL       HAL_SYSTICK_Config
00001c  b948              CBNZ     r0,|L20.50|
;;;273      {
;;;274        return HAL_ERROR;
;;;275      }
;;;276    
;;;277      /* Configure the SysTick IRQ priority */
;;;278      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
00001e  2c10              CMP      r4,#0x10
000020  d207              BCS      |L20.50|
;;;279      {
;;;280        HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
000022  2200              MOVS     r2,#0
000024  4621              MOV      r1,r4
000026  1e50              SUBS     r0,r2,#1
000028  f7fffffe          BL       HAL_NVIC_SetPriority
;;;281        uwTickPrio = TickPriority;
;;;282      }
;;;283      else
;;;284      {
;;;285        return HAL_ERROR;
;;;286      }
;;;287    
;;;288      /* Return function status */
;;;289      return HAL_OK;
00002c  2000              MOVS     r0,#0
00002e  602c              STR      r4,[r5,#0]            ;281  ; uwTickPrio
;;;290    }
000030  bd70              POP      {r4-r6,pc}
                  |L20.50|
000032  2001              MOVS     r0,#1                 ;285
000034  bd70              POP      {r4-r6,pc}
;;;291    
                          ENDP

000036  0000              DCW      0x0000
                  |L20.56|
                          DCD      ||.data||
                  |L20.60|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_MspDeInit PROC
;;;245      */
;;;246    __weak void HAL_MspDeInit(void)
000000  4770              BX       lr
;;;247    {
;;;248      /* NOTE : This function should not be modified, when the callback is needed,
;;;249                the HAL_MspDeInit could be implemented in the user file
;;;250       */ 
;;;251    }
;;;252    
                          ENDP


                          AREA ||i.HAL_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_MspInit PROC
;;;234      */
;;;235    __weak void HAL_MspInit(void)
000000  4770              BX       lr
;;;236    {
;;;237      /* NOTE : This function should not be modified, when the callback is needed,
;;;238                the HAL_MspInit could be implemented in the user file
;;;239       */
;;;240    }
;;;241    
                          ENDP


                          AREA ||i.HAL_ResumeTick||, CODE, READONLY, ALIGN=1

                  HAL_ResumeTick PROC
;;;434      */
;;;435    __weak void HAL_ResumeTick(void)
000000  f04f20e0          MOV      r0,#0xe000e000
;;;436    {
;;;437      /* Enable SysTick Interrupt */
;;;438      SysTick->CTRL  |= SysTick_CTRL_TICKINT_Msk;
000004  6901              LDR      r1,[r0,#0x10]
000006  f0410102          ORR      r1,r1,#2
00000a  6101              STR      r1,[r0,#0x10]
;;;439    }
00000c  4770              BX       lr
;;;440    
                          ENDP


                          AREA ||i.HAL_SetTickFreq||, CODE, READONLY, ALIGN=2

                  HAL_SetTickFreq PROC
;;;356      */
;;;357    HAL_StatusTypeDef HAL_SetTickFreq(HAL_TickFreqTypeDef Freq)
000000  4a06              LDR      r2,|L24.28|
;;;358    {
000002  b510              PUSH     {r4,lr}
;;;359      HAL_StatusTypeDef status  = HAL_OK;
;;;360      assert_param(IS_TICKFREQ(Freq));
;;;361    
;;;362      if (uwTickFreq != Freq)
000004  6853              LDR      r3,[r2,#4]  ; uwTickFreq
000006  2100              MOVS     r1,#0                 ;359
000008  4283              CMP      r3,r0
00000a  d004              BEQ      |L24.22|
;;;363      {
;;;364        uwTickFreq = Freq;
;;;365    
;;;366        /* Apply the new tick Freq  */
;;;367        status = HAL_InitTick(uwTickPrio);
00000c  6050              STR      r0,[r2,#4]  ; uwTickFreq
00000e  6810              LDR      r0,[r2,#0]  ; uwTickPrio
000010  f7fffffe          BL       HAL_InitTick
000014  4601              MOV      r1,r0
                  |L24.22|
;;;368      }
;;;369    
;;;370      return status;
000016  4608              MOV      r0,r1
;;;371    }
000018  bd10              POP      {r4,pc}
;;;372    
                          ENDP

00001a  0000              DCW      0x0000
                  |L24.28|
                          DCD      ||.data||

                          AREA ||i.HAL_SuspendTick||, CODE, READONLY, ALIGN=1

                  HAL_SuspendTick PROC
;;;418      */
;;;419    __weak void HAL_SuspendTick(void)
000000  f04f20e0          MOV      r0,#0xe000e000
;;;420    {
;;;421      /* Disable SysTick Interrupt */
;;;422      SysTick->CTRL &= ~SysTick_CTRL_TICKINT_Msk;
000004  6901              LDR      r1,[r0,#0x10]
000006  f0210102          BIC      r1,r1,#2
00000a  6101              STR      r1,[r0,#0x10]
;;;423    }
00000c  4770              BX       lr
;;;424    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  uwTickPrio
                          DCD      0x00000010
                  uwTickFreq
                          DCD      0x00000001
                  uwTick
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F4_V1.21.0\\Drivers\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_hal_c_3da258af____REV16|
#line 388 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F4_V1.21.0\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___15_stm32f4xx_hal_c_3da258af____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_hal_c_3da258af____REVSH|
#line 402
|__asm___15_stm32f4xx_hal_c_3da258af____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_hal_c_3da258af____RRX|
#line 587
|__asm___15_stm32f4xx_hal_c_3da258af____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
