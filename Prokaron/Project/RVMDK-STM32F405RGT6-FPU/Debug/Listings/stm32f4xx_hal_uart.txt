; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f4xx_hal_uart.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f4xx_hal_uart.d --cpu=Cortex-M4.fp --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F4_V1.21.0\Drivers\STM32F4xx_HAL_Driver\Inc -I..\..\..\M0P0_Library\STM32Cube_FW_F4_V1.21.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F4_V1.21.0\Drivers\CMSIS\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F4_V1.21.0\Drivers\STM32F4xx_HAL_Driver\Inc\Conf -I.\Source -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F405RGT6-FPU\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.11.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F405xx -DSTM32F405xx -DUSE_HAL_DRIVER -DHSE_VALUE=8000000 -DPLL_M=8 --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f4xx_hal_uart.crf ..\..\..\M0P0_Library\STM32Cube_FW_F4_V1.21.0\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_uart.c]
                          THUMB

                          AREA ||i.HAL_HalfDuplex_EnableReceiver||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableReceiver PROC
;;;1905     */
;;;1906   HAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver(UART_HandleTypeDef *huart)
000000  6b81              LDR      r1,[r0,#0x38]
;;;1907   {
;;;1908     uint32_t tmpreg = 0x00U;
;;;1909   
;;;1910     /* Process Locked */
;;;1911     __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;1912     
;;;1913     huart->gState = HAL_UART_STATE_BUSY;
;;;1914   
;;;1915     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;1916     tmpreg = huart->Instance->CR1;
;;;1917     
;;;1918     /* Clear TE and RE bits */
;;;1919     tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_TE | USART_CR1_RE));
;;;1920     
;;;1921     /* Enable the USART's receive interface by setting the RE bit in the USART CR1 register */
;;;1922     tmpreg |= (uint32_t)USART_CR1_RE;
;;;1923     
;;;1924     /* Write to USART CR1 */
;;;1925     WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
;;;1926     
;;;1927     huart->gState = HAL_UART_STATE_READY;
;;;1928     
;;;1929     /* Process Unlocked */
;;;1930     __HAL_UNLOCK(huart);
;;;1931     
;;;1932     return HAL_OK; 
;;;1933   }
000008  4770              BXEQ     lr
00000a  2101              MOVS     r1,#1                 ;1911
00000c  6381              STR      r1,[r0,#0x38]         ;1913
00000e  2124              MOVS     r1,#0x24              ;1913
000010  63c1              STR      r1,[r0,#0x3c]         ;1913
000012  6801              LDR      r1,[r0,#0]            ;1916
000014  68ca              LDR      r2,[r1,#0xc]          ;1916
000016  f022020c          BIC      r2,r2,#0xc            ;1919
00001a  f0420204          ORR      r2,r2,#4              ;1922
00001e  60ca              STR      r2,[r1,#0xc]          ;1925
000020  2120              MOVS     r1,#0x20              ;1927
000022  63c1              STR      r1,[r0,#0x3c]         ;1927
000024  2100              MOVS     r1,#0                 ;1930
000026  6381              STR      r1,[r0,#0x38]         ;1932
000028  4608              MOV      r0,r1                 ;1932
00002a  4770              BX       lr
;;;1934   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_EnableTransmitter||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableTransmitter PROC
;;;1870     */
;;;1871   HAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(UART_HandleTypeDef *huart)
000000  6b81              LDR      r1,[r0,#0x38]
;;;1872   {
;;;1873     uint32_t tmpreg = 0x00U;
;;;1874   
;;;1875     /* Process Locked */
;;;1876     __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;1877     
;;;1878     huart->gState = HAL_UART_STATE_BUSY;
;;;1879   
;;;1880     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;1881     tmpreg = huart->Instance->CR1;
;;;1882     
;;;1883     /* Clear TE and RE bits */
;;;1884     tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_TE | USART_CR1_RE));
;;;1885     
;;;1886     /* Enable the USART's transmit interface by setting the TE bit in the USART CR1 register */
;;;1887     tmpreg |= (uint32_t)USART_CR1_TE;
;;;1888     
;;;1889     /* Write to USART CR1 */
;;;1890     WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
;;;1891    
;;;1892     huart->gState = HAL_UART_STATE_READY;
;;;1893     
;;;1894     /* Process Unlocked */
;;;1895     __HAL_UNLOCK(huart);
;;;1896     
;;;1897     return HAL_OK; 
;;;1898   }
000008  4770              BXEQ     lr
00000a  2101              MOVS     r1,#1                 ;1876
00000c  6381              STR      r1,[r0,#0x38]         ;1878
00000e  2124              MOVS     r1,#0x24              ;1878
000010  63c1              STR      r1,[r0,#0x3c]         ;1878
000012  6801              LDR      r1,[r0,#0]            ;1881
000014  68ca              LDR      r2,[r1,#0xc]          ;1881
000016  f022020c          BIC      r2,r2,#0xc            ;1884
00001a  f0420208          ORR      r2,r2,#8              ;1887
00001e  60ca              STR      r2,[r1,#0xc]          ;1890
000020  2120              MOVS     r1,#0x20              ;1892
000022  63c1              STR      r1,[r0,#0x3c]         ;1892
000024  2100              MOVS     r1,#0                 ;1895
000026  6381              STR      r1,[r0,#0x38]         ;1897
000028  4608              MOV      r0,r1                 ;1897
00002a  4770              BX       lr
;;;1899   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_Init||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_Init PROC
;;;305      */
;;;306    HAL_StatusTypeDef HAL_HalfDuplex_Init(UART_HandleTypeDef *huart)
000000  2800              CMP      r0,#0
;;;307    {
;;;308      /* Check the UART handle allocation */
;;;309      if(huart == NULL)
;;;310      {
;;;311        return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;312      }
;;;313     
;;;314      /* Check the parameters */ 
;;;315      assert_param(IS_UART_INSTANCE(huart->Instance));
;;;316      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;317      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;318    
;;;319      if(huart->gState == HAL_UART_STATE_RESET)
;;;320      { 
;;;321        /* Allocate lock resource and initialize it */
;;;322        huart->Lock = HAL_UNLOCKED;
;;;323        /* Init the low level hardware */
;;;324        HAL_UART_MspInit(huart);
;;;325      }
;;;326    
;;;327      huart->gState = HAL_UART_STATE_BUSY;
;;;328    
;;;329      /* Disable the peripheral */
;;;330      __HAL_UART_DISABLE(huart);
;;;331      
;;;332      /* Set the UART Communication parameters */
;;;333      UART_SetConfig(huart);
;;;334      
;;;335      /* In half-duplex mode, the following bits must be kept cleared: 
;;;336         - LINEN and CLKEN bits in the USART_CR2 register,
;;;337         - SCEN and IREN bits in the USART_CR3 register.*/
;;;338      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;339      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_IREN | USART_CR3_SCEN));
;;;340      
;;;341      /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;342      SET_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
;;;343     
;;;344      /* Enable the peripheral */
;;;345      __HAL_UART_ENABLE(huart);
;;;346      
;;;347      /* Initialize the UART state*/
;;;348      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;349      huart->gState= HAL_UART_STATE_READY;
;;;350      huart->RxState= HAL_UART_STATE_READY;
;;;351      
;;;352      return HAL_OK;
;;;353    }
000006  4770              BXEQ     lr
000008  b570              PUSH     {r4-r6,lr}            ;307
00000a  4604              MOV      r4,r0                 ;307
00000c  6bc0              LDR      r0,[r0,#0x3c]         ;319
00000e  2500              MOVS     r5,#0                 ;319
000010  b918              CBNZ     r0,|L3.26|
000012  4620              MOV      r0,r4                 ;324
000014  63a5              STR      r5,[r4,#0x38]         ;324
000016  f7fffffe          BL       HAL_UART_MspInit
                  |L3.26|
00001a  2024              MOVS     r0,#0x24              ;327
00001c  63e0              STR      r0,[r4,#0x3c]         ;327
00001e  6820              LDR      r0,[r4,#0]            ;330
000020  68c1              LDR      r1,[r0,#0xc]          ;330
000022  f4215100          BIC      r1,r1,#0x2000         ;330
000026  60c1              STR      r1,[r0,#0xc]          ;330
000028  4620              MOV      r0,r4                 ;333
00002a  f7fffffe          BL       UART_SetConfig
00002e  6820              LDR      r0,[r4,#0]            ;338
000030  6901              LDR      r1,[r0,#0x10]         ;338
000032  f4214190          BIC      r1,r1,#0x4800         ;338
000036  6101              STR      r1,[r0,#0x10]         ;338
000038  6820              LDR      r0,[r4,#0]            ;339
00003a  6941              LDR      r1,[r0,#0x14]         ;339
00003c  f0210122          BIC      r1,r1,#0x22           ;339
000040  6141              STR      r1,[r0,#0x14]         ;339
000042  6820              LDR      r0,[r4,#0]            ;342
000044  6941              LDR      r1,[r0,#0x14]         ;342
000046  f0410108          ORR      r1,r1,#8              ;342
00004a  6141              STR      r1,[r0,#0x14]         ;342
00004c  6820              LDR      r0,[r4,#0]            ;345
00004e  68c1              LDR      r1,[r0,#0xc]          ;345
000050  f4415100          ORR      r1,r1,#0x2000         ;345
000054  60c1              STR      r1,[r0,#0xc]          ;345
000056  6465              STR      r5,[r4,#0x44]         ;348
000058  2020              MOVS     r0,#0x20              ;349
00005a  63e0              STR      r0,[r4,#0x3c]         ;349
00005c  6420              STR      r0,[r4,#0x40]         ;350
00005e  2000              MOVS     r0,#0                 ;352
000060  bd70              POP      {r4-r6,pc}
;;;354    
                          ENDP


                          AREA ||i.HAL_LIN_Init||, CODE, READONLY, ALIGN=1

                  HAL_LIN_Init PROC
;;;365      */
;;;366    HAL_StatusTypeDef HAL_LIN_Init(UART_HandleTypeDef *huart, uint32_t BreakDetectLength)
000000  2800              CMP      r0,#0
;;;367    {
;;;368      /* Check the UART handle allocation */
;;;369      if(huart == NULL)
;;;370      {
;;;371        return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;372      }
;;;373       
;;;374      /* Check the parameters */
;;;375      assert_param(IS_UART_INSTANCE(huart->Instance));
;;;376      assert_param(IS_UART_LIN_BREAK_DETECT_LENGTH(BreakDetectLength));
;;;377      assert_param(IS_UART_LIN_WORD_LENGTH(huart->Init.WordLength));
;;;378      assert_param(IS_UART_LIN_OVERSAMPLING(huart->Init.OverSampling));
;;;379      
;;;380      if(huart->gState == HAL_UART_STATE_RESET)
;;;381      {
;;;382        /* Allocate lock resource and initialize it */
;;;383        huart->Lock = HAL_UNLOCKED;
;;;384        /* Init the low level hardware */
;;;385        HAL_UART_MspInit(huart);
;;;386      }
;;;387    
;;;388      huart->gState = HAL_UART_STATE_BUSY;
;;;389    
;;;390      /* Disable the peripheral */
;;;391      __HAL_UART_DISABLE(huart);
;;;392      
;;;393      /* Set the UART Communication parameters */
;;;394      UART_SetConfig(huart);
;;;395      
;;;396      /* In LIN mode, the following bits must be kept cleared: 
;;;397         - LINEN and CLKEN bits in the USART_CR2 register,
;;;398         - SCEN and IREN bits in the USART_CR3 register.*/
;;;399      CLEAR_BIT(huart->Instance->CR2, USART_CR2_CLKEN);
;;;400      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_HDSEL | USART_CR3_IREN | USART_CR3_SCEN));
;;;401      
;;;402      /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;403      SET_BIT(huart->Instance->CR2, USART_CR2_LINEN);
;;;404      
;;;405      /* Set the USART LIN Break detection length. */
;;;406      CLEAR_BIT(huart->Instance->CR2, USART_CR2_LBDL);
;;;407      SET_BIT(huart->Instance->CR2, BreakDetectLength);
;;;408      
;;;409      /* Enable the peripheral */
;;;410      __HAL_UART_ENABLE(huart);
;;;411      
;;;412      /* Initialize the UART state*/
;;;413      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;414      huart->gState= HAL_UART_STATE_READY;
;;;415      huart->RxState= HAL_UART_STATE_READY;
;;;416      
;;;417      return HAL_OK;
;;;418    }
000006  4770              BXEQ     lr
000008  b570              PUSH     {r4-r6,lr}            ;367
00000a  4604              MOV      r4,r0                 ;367
00000c  6bc0              LDR      r0,[r0,#0x3c]         ;380
00000e  460e              MOV      r6,r1                 ;367
000010  2500              MOVS     r5,#0                 ;380
000012  b918              CBNZ     r0,|L4.28|
000014  4620              MOV      r0,r4                 ;385
000016  63a5              STR      r5,[r4,#0x38]         ;385
000018  f7fffffe          BL       HAL_UART_MspInit
                  |L4.28|
00001c  2024              MOVS     r0,#0x24              ;388
00001e  63e0              STR      r0,[r4,#0x3c]         ;388
000020  6820              LDR      r0,[r4,#0]            ;391
000022  68c1              LDR      r1,[r0,#0xc]          ;391
000024  f4215100          BIC      r1,r1,#0x2000         ;391
000028  60c1              STR      r1,[r0,#0xc]          ;391
00002a  4620              MOV      r0,r4                 ;394
00002c  f7fffffe          BL       UART_SetConfig
000030  6820              LDR      r0,[r4,#0]            ;399
000032  6901              LDR      r1,[r0,#0x10]         ;399
000034  f4216100          BIC      r1,r1,#0x800          ;399
000038  6101              STR      r1,[r0,#0x10]         ;399
00003a  6820              LDR      r0,[r4,#0]            ;400
00003c  6941              LDR      r1,[r0,#0x14]         ;400
00003e  f021012a          BIC      r1,r1,#0x2a           ;400
000042  6141              STR      r1,[r0,#0x14]         ;400
000044  6820              LDR      r0,[r4,#0]            ;403
000046  6901              LDR      r1,[r0,#0x10]         ;403
000048  f4414180          ORR      r1,r1,#0x4000         ;403
00004c  6101              STR      r1,[r0,#0x10]         ;403
00004e  6820              LDR      r0,[r4,#0]            ;406
000050  6901              LDR      r1,[r0,#0x10]         ;406
000052  f0210120          BIC      r1,r1,#0x20           ;406
000056  6101              STR      r1,[r0,#0x10]         ;406
000058  6820              LDR      r0,[r4,#0]            ;407
00005a  6901              LDR      r1,[r0,#0x10]         ;407
00005c  4331              ORRS     r1,r1,r6              ;407
00005e  6101              STR      r1,[r0,#0x10]         ;407
000060  6820              LDR      r0,[r4,#0]            ;410
000062  68c1              LDR      r1,[r0,#0xc]          ;410
000064  f4415100          ORR      r1,r1,#0x2000         ;410
000068  60c1              STR      r1,[r0,#0xc]          ;410
00006a  6465              STR      r5,[r4,#0x44]         ;413
00006c  2020              MOVS     r0,#0x20              ;414
00006e  63e0              STR      r0,[r4,#0x3c]         ;414
000070  6420              STR      r0,[r4,#0x40]         ;415
000072  2000              MOVS     r0,#0                 ;417
000074  bd70              POP      {r4-r6,pc}
;;;419    
                          ENDP


                          AREA ||i.HAL_LIN_SendBreak||, CODE, READONLY, ALIGN=1

                  HAL_LIN_SendBreak PROC
;;;1789     */
;;;1790   HAL_StatusTypeDef HAL_LIN_SendBreak(UART_HandleTypeDef *huart)
000000  6b81              LDR      r1,[r0,#0x38]
;;;1791   {
;;;1792     /* Check the parameters */
;;;1793     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;1794     
;;;1795     /* Process Locked */
;;;1796     __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;1797     
;;;1798     huart->gState = HAL_UART_STATE_BUSY;
;;;1799     
;;;1800     /* Send break characters */
;;;1801     SET_BIT(huart->Instance->CR1, USART_CR1_SBK);
;;;1802    
;;;1803     huart->gState = HAL_UART_STATE_READY;
;;;1804     
;;;1805     /* Process Unlocked */
;;;1806     __HAL_UNLOCK(huart);
;;;1807     
;;;1808     return HAL_OK; 
;;;1809   }
000008  4770              BXEQ     lr
00000a  2101              MOVS     r1,#1                 ;1796
00000c  6381              STR      r1,[r0,#0x38]         ;1798
00000e  2124              MOVS     r1,#0x24              ;1798
000010  63c1              STR      r1,[r0,#0x3c]         ;1798
000012  6801              LDR      r1,[r0,#0]            ;1801
000014  68ca              LDR      r2,[r1,#0xc]          ;1801
000016  f0420201          ORR      r2,r2,#1              ;1801
00001a  60ca              STR      r2,[r1,#0xc]          ;1801
00001c  2120              MOVS     r1,#0x20              ;1803
00001e  63c1              STR      r1,[r0,#0x3c]         ;1803
000020  2100              MOVS     r1,#0                 ;1806
000022  6381              STR      r1,[r0,#0x38]         ;1808
000024  4608              MOV      r0,r1                 ;1808
000026  4770              BX       lr
;;;1810   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_EnterMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_EnterMuteMode PROC
;;;1816     */
;;;1817   HAL_StatusTypeDef HAL_MultiProcessor_EnterMuteMode(UART_HandleTypeDef *huart)
000000  6b81              LDR      r1,[r0,#0x38]
;;;1818   {
;;;1819     /* Check the parameters */
;;;1820     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;1821     
;;;1822     /* Process Locked */
;;;1823     __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;1824     
;;;1825     huart->gState = HAL_UART_STATE_BUSY;
;;;1826     
;;;1827     /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
;;;1828     SET_BIT(huart->Instance->CR1, USART_CR1_RWU);
;;;1829     
;;;1830     huart->gState = HAL_UART_STATE_READY;
;;;1831     
;;;1832     /* Process Unlocked */
;;;1833     __HAL_UNLOCK(huart);
;;;1834     
;;;1835     return HAL_OK; 
;;;1836   }
000008  4770              BXEQ     lr
00000a  2101              MOVS     r1,#1                 ;1823
00000c  6381              STR      r1,[r0,#0x38]         ;1825
00000e  2124              MOVS     r1,#0x24              ;1825
000010  63c1              STR      r1,[r0,#0x3c]         ;1825
000012  6801              LDR      r1,[r0,#0]            ;1828
000014  68ca              LDR      r2,[r1,#0xc]          ;1828
000016  f0420202          ORR      r2,r2,#2              ;1828
00001a  60ca              STR      r2,[r1,#0xc]          ;1828
00001c  2120              MOVS     r1,#0x20              ;1830
00001e  63c1              STR      r1,[r0,#0x3c]         ;1830
000020  2100              MOVS     r1,#0                 ;1833
000022  6381              STR      r1,[r0,#0x38]         ;1835
000024  4608              MOV      r0,r1                 ;1835
000026  4770              BX       lr
;;;1837   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_ExitMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_ExitMuteMode PROC
;;;1843     */
;;;1844   HAL_StatusTypeDef HAL_MultiProcessor_ExitMuteMode(UART_HandleTypeDef *huart)
000000  6b81              LDR      r1,[r0,#0x38]
;;;1845   {
;;;1846     /* Check the parameters */
;;;1847     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;1848     
;;;1849     /* Process Locked */
;;;1850     __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;1851     
;;;1852     huart->gState = HAL_UART_STATE_BUSY;
;;;1853     
;;;1854     /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
;;;1855     CLEAR_BIT(huart->Instance->CR1, USART_CR1_RWU);
;;;1856     
;;;1857     huart->gState = HAL_UART_STATE_READY;
;;;1858     
;;;1859     /* Process Unlocked */
;;;1860     __HAL_UNLOCK(huart);
;;;1861     
;;;1862     return HAL_OK; 
;;;1863   }
000008  4770              BXEQ     lr
00000a  2101              MOVS     r1,#1                 ;1850
00000c  6381              STR      r1,[r0,#0x38]         ;1852
00000e  2124              MOVS     r1,#0x24              ;1852
000010  63c1              STR      r1,[r0,#0x3c]         ;1852
000012  6801              LDR      r1,[r0,#0]            ;1855
000014  68ca              LDR      r2,[r1,#0xc]          ;1855
000016  f0220202          BIC      r2,r2,#2              ;1855
00001a  60ca              STR      r2,[r1,#0xc]          ;1855
00001c  2120              MOVS     r1,#0x20              ;1857
00001e  63c1              STR      r1,[r0,#0x3c]         ;1857
000020  2100              MOVS     r1,#0                 ;1860
000022  6381              STR      r1,[r0,#0x38]         ;1862
000024  4608              MOV      r0,r1                 ;1862
000026  4770              BX       lr
;;;1864   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_Init||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_Init PROC
;;;431      */
;;;432    HAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod)
000000  2800              CMP      r0,#0
;;;433    {
;;;434      /* Check the UART handle allocation */
;;;435      if(huart == NULL)
;;;436      {
;;;437        return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;438      }
;;;439    
;;;440      /* Check the parameters */
;;;441      assert_param(IS_UART_INSTANCE(huart->Instance));
;;;442      assert_param(IS_UART_WAKEUPMETHOD(WakeUpMethod));
;;;443      assert_param(IS_UART_ADDRESS(Address));
;;;444      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;445      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;446    
;;;447      if(huart->gState == HAL_UART_STATE_RESET)
;;;448      {
;;;449        /* Allocate lock resource and initialize it */
;;;450        huart->Lock = HAL_UNLOCKED;
;;;451        /* Init the low level hardware */
;;;452        HAL_UART_MspInit(huart);
;;;453      }
;;;454    
;;;455      huart->gState = HAL_UART_STATE_BUSY;
;;;456    
;;;457      /* Disable the peripheral */
;;;458      __HAL_UART_DISABLE(huart);
;;;459      
;;;460      /* Set the UART Communication parameters */
;;;461      UART_SetConfig(huart);
;;;462      
;;;463      /* In Multi-Processor mode, the following bits must be kept cleared: 
;;;464         - LINEN and CLKEN bits in the USART_CR2 register,
;;;465         - SCEN, HDSEL and IREN  bits in the USART_CR3 register */
;;;466      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;467      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;468      
;;;469      /* Clear the USART address */
;;;470      CLEAR_BIT(huart->Instance->CR2, USART_CR2_ADD);
;;;471      /* Set the USART address node */
;;;472      SET_BIT(huart->Instance->CR2, Address);
;;;473      
;;;474      /* Set the wake up method by setting the WAKE bit in the CR1 register */
;;;475      CLEAR_BIT(huart->Instance->CR1, USART_CR1_WAKE);
;;;476      SET_BIT(huart->Instance->CR1, WakeUpMethod);
;;;477      
;;;478      /* Enable the peripheral */
;;;479      __HAL_UART_ENABLE(huart);
;;;480      
;;;481      /* Initialize the UART state */
;;;482      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;483      huart->gState= HAL_UART_STATE_READY;
;;;484      huart->RxState= HAL_UART_STATE_READY;
;;;485      
;;;486      return HAL_OK;
;;;487    }
000006  4770              BXEQ     lr
000008  e92d41f0          PUSH     {r4-r8,lr}            ;433
00000c  4604              MOV      r4,r0                 ;433
00000e  6bc0              LDR      r0,[r0,#0x3c]         ;447
000010  4616              MOV      r6,r2                 ;433
000012  460f              MOV      r7,r1                 ;433
000014  2500              MOVS     r5,#0                 ;447
000016  b918              CBNZ     r0,|L8.32|
000018  4620              MOV      r0,r4                 ;452
00001a  63a5              STR      r5,[r4,#0x38]         ;452
00001c  f7fffffe          BL       HAL_UART_MspInit
                  |L8.32|
000020  2024              MOVS     r0,#0x24              ;455
000022  63e0              STR      r0,[r4,#0x3c]         ;455
000024  6820              LDR      r0,[r4,#0]            ;458
000026  68c1              LDR      r1,[r0,#0xc]          ;458
000028  f4215100          BIC      r1,r1,#0x2000         ;458
00002c  60c1              STR      r1,[r0,#0xc]          ;458
00002e  4620              MOV      r0,r4                 ;461
000030  f7fffffe          BL       UART_SetConfig
000034  6820              LDR      r0,[r4,#0]            ;466
000036  6901              LDR      r1,[r0,#0x10]         ;466
000038  f4214190          BIC      r1,r1,#0x4800         ;466
00003c  6101              STR      r1,[r0,#0x10]         ;466
00003e  6820              LDR      r0,[r4,#0]            ;467
000040  6941              LDR      r1,[r0,#0x14]         ;467
000042  f021012a          BIC      r1,r1,#0x2a           ;467
000046  6141              STR      r1,[r0,#0x14]         ;467
000048  6820              LDR      r0,[r4,#0]            ;470
00004a  6901              LDR      r1,[r0,#0x10]         ;470
00004c  f021010f          BIC      r1,r1,#0xf            ;470
000050  6101              STR      r1,[r0,#0x10]         ;470
000052  6820              LDR      r0,[r4,#0]            ;472
000054  6901              LDR      r1,[r0,#0x10]         ;472
000056  4339              ORRS     r1,r1,r7              ;472
000058  6101              STR      r1,[r0,#0x10]         ;472
00005a  6820              LDR      r0,[r4,#0]            ;475
00005c  68c1              LDR      r1,[r0,#0xc]          ;475
00005e  f4216100          BIC      r1,r1,#0x800          ;475
000062  60c1              STR      r1,[r0,#0xc]          ;475
000064  6820              LDR      r0,[r4,#0]            ;476
000066  68c1              LDR      r1,[r0,#0xc]          ;476
000068  4331              ORRS     r1,r1,r6              ;476
00006a  60c1              STR      r1,[r0,#0xc]          ;476
00006c  6820              LDR      r0,[r4,#0]            ;479
00006e  68c1              LDR      r1,[r0,#0xc]          ;479
000070  f4415100          ORR      r1,r1,#0x2000         ;479
000074  60c1              STR      r1,[r0,#0xc]          ;479
000076  6465              STR      r5,[r4,#0x44]         ;482
000078  2020              MOVS     r0,#0x20              ;483
00007a  63e0              STR      r0,[r4,#0x3c]         ;483
00007c  6420              STR      r0,[r4,#0x40]         ;484
00007e  2000              MOVS     r0,#0                 ;486
000080  e8bd81f0          POP      {r4-r8,pc}
;;;488    
                          ENDP


                          AREA ||i.HAL_UART_Abort||, CODE, READONLY, ALIGN=1

                  HAL_UART_Abort PROC
;;;1126   */
;;;1127   HAL_StatusTypeDef HAL_UART_Abort(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1128   {
000002  4604              MOV      r4,r0
;;;1129     /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1130     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6800              LDR      r0,[r0,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f42171f0          BIC      r1,r1,#0x1e0
00000c  60c1              STR      r1,[r0,#0xc]
;;;1131     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00000e  6820              LDR      r0,[r4,#0]
000010  6941              LDR      r1,[r0,#0x14]
000012  f0210101          BIC      r1,r1,#1
000016  6141              STR      r1,[r0,#0x14]
;;;1132     
;;;1133     /* Disable the UART DMA Tx request if enabled */
;;;1134     if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000018  6820              LDR      r0,[r4,#0]
00001a  6941              LDR      r1,[r0,#0x14]
00001c  f04f0500          MOV      r5,#0
000020  f0110f80          TST      r1,#0x80
000024  d009              BEQ      |L9.58|
;;;1135     {
;;;1136       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000026  6941              LDR      r1,[r0,#0x14]
000028  f0210180          BIC      r1,r1,#0x80
00002c  6141              STR      r1,[r0,#0x14]
;;;1137   
;;;1138       /* Abort the UART DMA Tx channel: use blocking DMA Abort API (no callback) */
;;;1139       if(huart->hdmatx != NULL)
00002e  6b20              LDR      r0,[r4,#0x30]
000030  b118              CBZ      r0,|L9.58|
;;;1140       {
;;;1141         /* Set the UART DMA Abort callback to Null. 
;;;1142            No call back execution at end of DMA abort procedure */
;;;1143         huart->hdmatx->XferAbortCallback = NULL;
;;;1144   
;;;1145         HAL_DMA_Abort(huart->hdmatx);
000032  6545              STR      r5,[r0,#0x54]
000034  6b20              LDR      r0,[r4,#0x30]
000036  f7fffffe          BL       HAL_DMA_Abort
                  |L9.58|
;;;1146       }
;;;1147     }
;;;1148   
;;;1149     /* Disable the UART DMA Rx request if enabled */
;;;1150     if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
00003a  6820              LDR      r0,[r4,#0]
00003c  6941              LDR      r1,[r0,#0x14]
00003e  f0110f40          TST      r1,#0x40
000042  d009              BEQ      |L9.88|
;;;1151     {
;;;1152       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000044  6941              LDR      r1,[r0,#0x14]
000046  f0210140          BIC      r1,r1,#0x40
00004a  6141              STR      r1,[r0,#0x14]
;;;1153   
;;;1154       /* Abort the UART DMA Rx channel: use blocking DMA Abort API (no callback) */
;;;1155       if(huart->hdmarx != NULL)
00004c  6b60              LDR      r0,[r4,#0x34]
00004e  b118              CBZ      r0,|L9.88|
;;;1156       {
;;;1157         /* Set the UART DMA Abort callback to Null. 
;;;1158            No call back execution at end of DMA abort procedure */
;;;1159         huart->hdmarx->XferAbortCallback = NULL;
;;;1160   
;;;1161         HAL_DMA_Abort(huart->hdmarx);
000050  6545              STR      r5,[r0,#0x54]
000052  6b60              LDR      r0,[r4,#0x34]
000054  f7fffffe          BL       HAL_DMA_Abort
                  |L9.88|
;;;1162       }
;;;1163     }
;;;1164   
;;;1165     /* Reset Tx and Rx transfer counters */
;;;1166     huart->TxXferCount = 0x00U;
000058  84e5              STRH     r5,[r4,#0x26]
;;;1167     huart->RxXferCount = 0x00U;
00005a  85e5              STRH     r5,[r4,#0x2e]
;;;1168   
;;;1169     /* Reset ErrorCode */
;;;1170     huart->ErrorCode = HAL_UART_ERROR_NONE;
00005c  6465              STR      r5,[r4,#0x44]
;;;1171   
;;;1172     /* Restore huart->RxState and huart->gState to Ready */
;;;1173     huart->RxState = HAL_UART_STATE_READY;
00005e  2020              MOVS     r0,#0x20
000060  6420              STR      r0,[r4,#0x40]
;;;1174     huart->gState = HAL_UART_STATE_READY;
000062  63e0              STR      r0,[r4,#0x3c]
;;;1175   
;;;1176     return HAL_OK;
000064  2000              MOVS     r0,#0
;;;1177   }
000066  bd70              POP      {r4-r6,pc}
;;;1178   
                          ENDP


                          AREA ||i.HAL_UART_AbortCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortCpltCallback PROC
;;;1723     */
;;;1724   __weak void HAL_UART_AbortCpltCallback (UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1725   {
;;;1726     /* Prevent unused argument(s) compilation warning */
;;;1727     UNUSED(huart);
;;;1728   
;;;1729     /* NOTE : This function should not be modified, when the callback is needed,
;;;1730               the HAL_UART_AbortCpltCallback can be implemented in the user file.
;;;1731      */
;;;1732   }
;;;1733   /**
                          ENDP


                          AREA ||i.HAL_UART_AbortReceive||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortReceive PROC
;;;1232   */
;;;1233   HAL_StatusTypeDef HAL_UART_AbortReceive(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1234   {
000002  4604              MOV      r4,r0
;;;1235     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1236     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000004  6800              LDR      r0,[r0,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f4217190          BIC      r1,r1,#0x120
00000c  60c1              STR      r1,[r0,#0xc]
;;;1237     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00000e  6820              LDR      r0,[r4,#0]
000010  6941              LDR      r1,[r0,#0x14]
000012  f0210101          BIC      r1,r1,#1
000016  6141              STR      r1,[r0,#0x14]
;;;1238   
;;;1239     /* Disable the UART DMA Rx request if enabled */
;;;1240     if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000018  6820              LDR      r0,[r4,#0]
00001a  6941              LDR      r1,[r0,#0x14]
00001c  f04f0500          MOV      r5,#0
000020  f0110f40          TST      r1,#0x40
000024  d009              BEQ      |L11.58|
;;;1241     {
;;;1242       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000026  6941              LDR      r1,[r0,#0x14]
000028  f0210140          BIC      r1,r1,#0x40
00002c  6141              STR      r1,[r0,#0x14]
;;;1243   
;;;1244       /* Abort the UART DMA Rx channel : use blocking DMA Abort API (no callback) */
;;;1245       if(huart->hdmarx != NULL)
00002e  6b60              LDR      r0,[r4,#0x34]
000030  b118              CBZ      r0,|L11.58|
;;;1246       {
;;;1247         /* Set the UART DMA Abort callback to Null. 
;;;1248            No call back execution at end of DMA abort procedure */
;;;1249         huart->hdmarx->XferAbortCallback = NULL;
;;;1250   
;;;1251         HAL_DMA_Abort(huart->hdmarx);
000032  6545              STR      r5,[r0,#0x54]
000034  6b60              LDR      r0,[r4,#0x34]
000036  f7fffffe          BL       HAL_DMA_Abort
                  |L11.58|
;;;1252       }
;;;1253     }
;;;1254   
;;;1255     /* Reset Rx transfer counter */
;;;1256     huart->RxXferCount = 0x00U;
00003a  85e5              STRH     r5,[r4,#0x2e]
;;;1257   
;;;1258     /* Restore huart->RxState to Ready */
;;;1259     huart->RxState = HAL_UART_STATE_READY;
00003c  2020              MOVS     r0,#0x20
00003e  6420              STR      r0,[r4,#0x40]
;;;1260   
;;;1261     return HAL_OK;
000040  2000              MOVS     r0,#0
;;;1262   }
000042  bd70              POP      {r4-r6,pc}
;;;1263   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceiveCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortReceiveCpltCallback PROC
;;;1752     */
;;;1753   __weak void HAL_UART_AbortReceiveCpltCallback (UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1754   {
;;;1755     /* Prevent unused argument(s) compilation warning */
;;;1756     UNUSED(huart);
;;;1757   
;;;1758     /* NOTE : This function should not be modified, when the callback is needed,
;;;1759               the HAL_UART_AbortReceiveCpltCallback can be implemented in the user file.
;;;1760      */
;;;1761   }
;;;1762   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceive_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_AbortReceive_IT PROC
;;;1464   */
;;;1465   HAL_StatusTypeDef HAL_UART_AbortReceive_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1466   {
000002  4604              MOV      r4,r0
;;;1467     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1468     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000004  6800              LDR      r0,[r0,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f4217190          BIC      r1,r1,#0x120
00000c  60c1              STR      r1,[r0,#0xc]
;;;1469     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00000e  6820              LDR      r0,[r4,#0]
000010  6941              LDR      r1,[r0,#0x14]
000012  f0210101          BIC      r1,r1,#1
000016  6141              STR      r1,[r0,#0x14]
;;;1470   
;;;1471     /* Disable the UART DMA Rx request if enabled */
;;;1472     if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000018  6820              LDR      r0,[r4,#0]
00001a  6941              LDR      r1,[r0,#0x14]
;;;1473     {
;;;1474       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1475   
;;;1476       /* Abort the UART DMA Rx channel : use blocking DMA Abort API (no callback) */
;;;1477       if(huart->hdmarx != NULL)
;;;1478       {
;;;1479         /* Set the UART DMA Abort callback : 
;;;1480            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1481         huart->hdmarx->XferAbortCallback = UART_DMARxOnlyAbortCallback;
;;;1482   
;;;1483         /* Abort DMA RX */
;;;1484         if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
;;;1485         {
;;;1486           /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */
;;;1487           huart->hdmarx->XferAbortCallback(huart->hdmarx);
;;;1488         }
;;;1489       }
;;;1490       else
;;;1491       {
;;;1492         /* Reset Rx transfer counter */
;;;1493         huart->RxXferCount = 0x00U; 
;;;1494   
;;;1495         /* Restore huart->RxState to Ready */
;;;1496         huart->RxState = HAL_UART_STATE_READY;
00001c  f04f0220          MOV      r2,#0x20
000020  f0110f40          TST      r1,#0x40              ;1472
000024  f04f0100          MOV      r1,#0                 ;1472
000028  d00f              BEQ      |L13.74|
00002a  6943              LDR      r3,[r0,#0x14]         ;1474
00002c  f0230340          BIC      r3,r3,#0x40           ;1474
000030  6143              STR      r3,[r0,#0x14]         ;1474
000032  6b60              LDR      r0,[r4,#0x34]         ;1477
000034  b148              CBZ      r0,|L13.74|
000036  4908              LDR      r1,|L13.88|
000038  6541              STR      r1,[r0,#0x54]         ;1484
00003a  6b60              LDR      r0,[r4,#0x34]         ;1484
00003c  f7fffffe          BL       HAL_DMA_Abort_IT
000040  b140              CBZ      r0,|L13.84|
000042  6b60              LDR      r0,[r4,#0x34]         ;1487
000044  6d41              LDR      r1,[r0,#0x54]         ;1487
000046  4788              BLX      r1                    ;1487
000048  e004              B        |L13.84|
                  |L13.74|
00004a  85e1              STRH     r1,[r4,#0x2e]         ;1493
00004c  6422              STR      r2,[r4,#0x40]
;;;1497   
;;;1498         /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1499         HAL_UART_AbortReceiveCpltCallback(huart);
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       HAL_UART_AbortReceiveCpltCallback
                  |L13.84|
;;;1500       }
;;;1501     }
;;;1502     else
;;;1503     {
;;;1504       /* Reset Rx transfer counter */
;;;1505       huart->RxXferCount = 0x00U; 
;;;1506   
;;;1507       /* Restore huart->RxState to Ready */
;;;1508       huart->RxState = HAL_UART_STATE_READY;
;;;1509   
;;;1510       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1511       HAL_UART_AbortReceiveCpltCallback(huart);
;;;1512     }
;;;1513   
;;;1514     return HAL_OK;
000054  2000              MOVS     r0,#0
;;;1515   }
000056  bd10              POP      {r4,pc}
;;;1516   
                          ENDP

                  |L13.88|
                          DCD      UART_DMARxOnlyAbortCallback

                          AREA ||i.HAL_UART_AbortTransmit||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortTransmit PROC
;;;1190   */
;;;1191   HAL_StatusTypeDef HAL_UART_AbortTransmit(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1192   {
000002  4604              MOV      r4,r0
;;;1193     /* Disable TXEIE and TCIE interrupts */
;;;1194     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6800              LDR      r0,[r0,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f02101c0          BIC      r1,r1,#0xc0
00000c  60c1              STR      r1,[r0,#0xc]
;;;1195   
;;;1196     /* Disable the UART DMA Tx request if enabled */
;;;1197     if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
00000e  6820              LDR      r0,[r4,#0]
000010  6941              LDR      r1,[r0,#0x14]
000012  f04f0500          MOV      r5,#0
000016  f0110f80          TST      r1,#0x80
00001a  d009              BEQ      |L14.48|
;;;1198     {
;;;1199       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
00001c  6941              LDR      r1,[r0,#0x14]
00001e  f0210180          BIC      r1,r1,#0x80
000022  6141              STR      r1,[r0,#0x14]
;;;1200   
;;;1201       /* Abort the UART DMA Tx channel : use blocking DMA Abort API (no callback) */
;;;1202       if(huart->hdmatx != NULL)
000024  6b20              LDR      r0,[r4,#0x30]
000026  b118              CBZ      r0,|L14.48|
;;;1203       {
;;;1204         /* Set the UART DMA Abort callback to Null. 
;;;1205            No call back execution at end of DMA abort procedure */
;;;1206         huart->hdmatx->XferAbortCallback = NULL;
;;;1207   
;;;1208         HAL_DMA_Abort(huart->hdmatx);
000028  6545              STR      r5,[r0,#0x54]
00002a  6b20              LDR      r0,[r4,#0x30]
00002c  f7fffffe          BL       HAL_DMA_Abort
                  |L14.48|
;;;1209       }
;;;1210     }
;;;1211   
;;;1212     /* Reset Tx transfer counter */
;;;1213     huart->TxXferCount = 0x00U;
000030  84e5              STRH     r5,[r4,#0x26]
;;;1214   
;;;1215     /* Restore huart->gState to Ready */
;;;1216     huart->gState = HAL_UART_STATE_READY;
000032  2020              MOVS     r0,#0x20
000034  63e0              STR      r0,[r4,#0x3c]
;;;1217   
;;;1218     return HAL_OK;
000036  2000              MOVS     r0,#0
;;;1219   }
000038  bd70              POP      {r4-r6,pc}
;;;1220   
                          ENDP


                          AREA ||i.HAL_UART_AbortTransmitCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortTransmitCpltCallback PROC
;;;1737     */
;;;1738   __weak void HAL_UART_AbortTransmitCpltCallback (UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1739   {
;;;1740     /* Prevent unused argument(s) compilation warning */
;;;1741     UNUSED(huart);
;;;1742   
;;;1743     /* NOTE : This function should not be modified, when the callback is needed,
;;;1744               the HAL_UART_AbortTransmitCpltCallback can be implemented in the user file.
;;;1745      */
;;;1746   }
;;;1747   
                          ENDP


                          AREA ||i.HAL_UART_AbortTransmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_AbortTransmit_IT PROC
;;;1399   */
;;;1400   HAL_StatusTypeDef HAL_UART_AbortTransmit_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1401   {
000002  4604              MOV      r4,r0
;;;1402     /* Disable TXEIE and TCIE interrupts */
;;;1403     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6800              LDR      r0,[r0,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f02101c0          BIC      r1,r1,#0xc0
00000c  60c1              STR      r1,[r0,#0xc]
;;;1404   
;;;1405     /* Disable the UART DMA Tx request if enabled */
;;;1406     if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
00000e  6820              LDR      r0,[r4,#0]
000010  6941              LDR      r1,[r0,#0x14]
;;;1407     {
;;;1408       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1409   
;;;1410       /* Abort the UART DMA Tx channel : use blocking DMA Abort API (no callback) */
;;;1411       if(huart->hdmatx != NULL)
;;;1412       {
;;;1413         /* Set the UART DMA Abort callback : 
;;;1414            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1415         huart->hdmatx->XferAbortCallback = UART_DMATxOnlyAbortCallback;
;;;1416   
;;;1417         /* Abort DMA TX */
;;;1418         if(HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
;;;1419         {
;;;1420           /* Call Directly huart->hdmatx->XferAbortCallback function in case of error */
;;;1421           huart->hdmatx->XferAbortCallback(huart->hdmatx);
;;;1422         }
;;;1423       }
;;;1424       else
;;;1425       {      
;;;1426         /* Reset Tx transfer counter */
;;;1427         huart->TxXferCount = 0x00U;
;;;1428   
;;;1429         /* Restore huart->gState to Ready */
;;;1430         huart->gState = HAL_UART_STATE_READY;
000012  f04f0220          MOV      r2,#0x20
000016  f0110f80          TST      r1,#0x80              ;1406
00001a  f04f0100          MOV      r1,#0                 ;1406
00001e  d00f              BEQ      |L16.64|
000020  6943              LDR      r3,[r0,#0x14]         ;1408
000022  f0230380          BIC      r3,r3,#0x80           ;1408
000026  6143              STR      r3,[r0,#0x14]         ;1408
000028  6b20              LDR      r0,[r4,#0x30]         ;1411
00002a  b148              CBZ      r0,|L16.64|
00002c  4908              LDR      r1,|L16.80|
00002e  6541              STR      r1,[r0,#0x54]         ;1418
000030  6b20              LDR      r0,[r4,#0x30]         ;1418
000032  f7fffffe          BL       HAL_DMA_Abort_IT
000036  b140              CBZ      r0,|L16.74|
000038  6b20              LDR      r0,[r4,#0x30]         ;1421
00003a  6d41              LDR      r1,[r0,#0x54]         ;1421
00003c  4788              BLX      r1                    ;1421
00003e  e004              B        |L16.74|
                  |L16.64|
000040  84e1              STRH     r1,[r4,#0x26]         ;1427
000042  63e2              STR      r2,[r4,#0x3c]
;;;1431   
;;;1432         /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1433         HAL_UART_AbortTransmitCpltCallback(huart);
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       HAL_UART_AbortTransmitCpltCallback
                  |L16.74|
;;;1434       }
;;;1435     }
;;;1436     else
;;;1437     {
;;;1438       /* Reset Tx transfer counter */
;;;1439       huart->TxXferCount = 0x00U;
;;;1440   
;;;1441       /* Restore huart->gState to Ready */
;;;1442       huart->gState = HAL_UART_STATE_READY;
;;;1443   
;;;1444       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1445       HAL_UART_AbortTransmitCpltCallback(huart);
;;;1446     }
;;;1447   
;;;1448     return HAL_OK;
00004a  2000              MOVS     r0,#0
;;;1449   }
00004c  bd10              POP      {r4,pc}
;;;1450   
                          ENDP

00004e  0000              DCW      0x0000
                  |L16.80|
                          DCD      UART_DMATxOnlyAbortCallback

                          AREA ||i.HAL_UART_Abort_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_Abort_IT PROC
;;;1277   */
;;;1278   HAL_StatusTypeDef HAL_UART_Abort_IT(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1279   {
000002  4604              MOV      r4,r0
;;;1280     uint32_t AbortCplt = 0x01U;
;;;1281   
;;;1282     /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1283     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6800              LDR      r0,[r0,#0]
000006  2601              MOVS     r6,#1                 ;1280
000008  68c1              LDR      r1,[r0,#0xc]
00000a  f42171f0          BIC      r1,r1,#0x1e0
00000e  60c1              STR      r1,[r0,#0xc]
;;;1284     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000010  6820              LDR      r0,[r4,#0]
000012  6941              LDR      r1,[r0,#0x14]
000014  f0210101          BIC      r1,r1,#1
000018  6141              STR      r1,[r0,#0x14]
00001a  6b20              LDR      r0,[r4,#0x30]         ;1279
;;;1285   
;;;1286     /* If DMA Tx and/or DMA Rx Handles are associated to UART Handle, DMA Abort complete callbacks should be initialised
;;;1287        before any call to DMA Abort functions */
;;;1288     /* DMA Tx Handle is valid */
;;;1289     if(huart->hdmatx != NULL)
00001c  2500              MOVS     r5,#0
00001e  b138              CBZ      r0,|L17.48|
;;;1290     {
;;;1291       /* Set DMA Abort Complete callback if UART DMA Tx request if enabled.
;;;1292          Otherwise, set it to NULL */
;;;1293       if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000020  6821              LDR      r1,[r4,#0]
000022  6949              LDR      r1,[r1,#0x14]
000024  f0110f80          TST      r1,#0x80
;;;1294       {
;;;1295         huart->hdmatx->XferAbortCallback = UART_DMATxAbortCallback;
;;;1296       }
;;;1297       else
;;;1298       {
;;;1299         huart->hdmatx->XferAbortCallback = NULL;
000028  bf0e              ITEE     EQ
00002a  6545              STREQ    r5,[r0,#0x54]
00002c  491e              LDRNE    r1,|L17.168|
00002e  6541              STRNE    r1,[r0,#0x54]         ;1295
                  |L17.48|
;;;1300       }
;;;1301     }
;;;1302     /* DMA Rx Handle is valid */
;;;1303     if(huart->hdmarx != NULL)
000030  6b60              LDR      r0,[r4,#0x34]
000032  b138              CBZ      r0,|L17.68|
;;;1304     {
;;;1305       /* Set DMA Abort Complete callback if UART DMA Rx request if enabled.
;;;1306          Otherwise, set it to NULL */
;;;1307       if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000034  6821              LDR      r1,[r4,#0]
000036  6949              LDR      r1,[r1,#0x14]
000038  f0110f40          TST      r1,#0x40
;;;1308       {
;;;1309         huart->hdmarx->XferAbortCallback = UART_DMARxAbortCallback;
;;;1310       }
;;;1311       else
;;;1312       {
;;;1313         huart->hdmarx->XferAbortCallback = NULL;
00003c  bf0e              ITEE     EQ
00003e  6545              STREQ    r5,[r0,#0x54]
000040  491a              LDRNE    r1,|L17.172|
000042  6541              STRNE    r1,[r0,#0x54]         ;1309
                  |L17.68|
;;;1314       }
;;;1315     }
;;;1316   
;;;1317     /* Disable the UART DMA Tx request if enabled */
;;;1318     if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000044  6820              LDR      r0,[r4,#0]
000046  6941              LDR      r1,[r0,#0x14]
000048  f0110f80          TST      r1,#0x80
00004c  d00c              BEQ      |L17.104|
;;;1319     {
;;;1320       /* Disable DMA Tx at UART level */
;;;1321       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
00004e  6941              LDR      r1,[r0,#0x14]
000050  f0210180          BIC      r1,r1,#0x80
000054  6141              STR      r1,[r0,#0x14]
;;;1322   
;;;1323       /* Abort the UART DMA Tx channel : use non blocking DMA Abort API (callback) */
;;;1324       if(huart->hdmatx != NULL)
000056  6b20              LDR      r0,[r4,#0x30]
000058  b130              CBZ      r0,|L17.104|
;;;1325       {
;;;1326         /* UART Tx DMA Abort callback has already been initialised : 
;;;1327            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1328   
;;;1329         /* Abort DMA TX */
;;;1330         if(HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
00005a  f7fffffe          BL       HAL_DMA_Abort_IT
00005e  2800              CMP      r0,#0
;;;1331         {
;;;1332           huart->hdmatx->XferAbortCallback = NULL;
;;;1333         }
;;;1334         else
;;;1335         {
;;;1336           AbortCplt = 0x00U;
000060  bf0e              ITEE     EQ
000062  2600              MOVEQ    r6,#0
000064  6b20              LDRNE    r0,[r4,#0x30]         ;1332
000066  6545              STRNE    r5,[r0,#0x54]         ;1332
                  |L17.104|
;;;1337         }
;;;1338       }
;;;1339     }
;;;1340   
;;;1341     /* Disable the UART DMA Rx request if enabled */
;;;1342     if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000068  6820              LDR      r0,[r4,#0]
00006a  6941              LDR      r1,[r0,#0x14]
00006c  f0110f40          TST      r1,#0x40
000070  d00d              BEQ      |L17.142|
;;;1343     {
;;;1344       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000072  6941              LDR      r1,[r0,#0x14]
000074  f0210140          BIC      r1,r1,#0x40
000078  6141              STR      r1,[r0,#0x14]
;;;1345   
;;;1346       /* Abort the UART DMA Rx channel : use non blocking DMA Abort API (callback) */
;;;1347       if(huart->hdmarx != NULL)
00007a  6b60              LDR      r0,[r4,#0x34]
00007c  b138              CBZ      r0,|L17.142|
;;;1348       {
;;;1349         /* UART Rx DMA Abort callback has already been initialised : 
;;;1350            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1351   
;;;1352         /* Abort DMA RX */
;;;1353         if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
00007e  f7fffffe          BL       HAL_DMA_Abort_IT
000082  2800              CMP      r0,#0
;;;1354         {
;;;1355           huart->hdmarx->XferAbortCallback = NULL;
000084  bf1c              ITT      NE
000086  6b60              LDRNE    r0,[r4,#0x34]
000088  6545              STRNE    r5,[r0,#0x54]
00008a  d00a              BEQ      |L17.162|
00008c  e000              B        |L17.144|
                  |L17.142|
;;;1356           AbortCplt = 0x01U;
;;;1357         }
;;;1358         else
;;;1359         {
;;;1360           AbortCplt = 0x00U;
;;;1361         }
;;;1362       }
;;;1363     }
;;;1364   
;;;1365     /* if no DMA abort complete callback execution is required => call user Abort Complete callback */
;;;1366     if(AbortCplt == 0x01U)
00008e  b146              CBZ      r6,|L17.162|
                  |L17.144|
;;;1367     {
;;;1368       /* Reset Tx and Rx transfer counters */
;;;1369       huart->TxXferCount = 0x00U; 
000090  84e5              STRH     r5,[r4,#0x26]
;;;1370       huart->RxXferCount = 0x00U;
000092  85e5              STRH     r5,[r4,#0x2e]
;;;1371   
;;;1372       /* Reset ErrorCode */
;;;1373       huart->ErrorCode = HAL_UART_ERROR_NONE;
000094  6465              STR      r5,[r4,#0x44]
;;;1374   
;;;1375       /* Restore huart->gState and huart->RxState to Ready */
;;;1376       huart->gState  = HAL_UART_STATE_READY;
000096  2020              MOVS     r0,#0x20
000098  63e0              STR      r0,[r4,#0x3c]
;;;1377       huart->RxState = HAL_UART_STATE_READY;
00009a  6420              STR      r0,[r4,#0x40]
;;;1378   
;;;1379       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1380       HAL_UART_AbortCpltCallback(huart);
00009c  4620              MOV      r0,r4
00009e  f7fffffe          BL       HAL_UART_AbortCpltCallback
                  |L17.162|
;;;1381     }
;;;1382   
;;;1383     return HAL_OK;
0000a2  2000              MOVS     r0,#0
;;;1384   }
0000a4  bd70              POP      {r4-r6,pc}
;;;1385   
                          ENDP

0000a6  0000              DCW      0x0000
                  |L17.168|
                          DCD      UART_DMATxAbortCallback
                  |L17.172|
                          DCD      UART_DMARxAbortCallback

                          AREA ||i.HAL_UART_DMAPause||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAPause PROC
;;;1004     */
;;;1005   HAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart)
000000  6b81              LDR      r1,[r0,#0x38]
;;;1006   {
;;;1007      uint32_t dmarequest = 0x00U;
;;;1008   
;;;1009     /* Process Locked */
;;;1010     __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;1011     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
;;;1012     if((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
;;;1013     {
;;;1014       /* Disable the UART DMA Tx request */
;;;1015       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1016     }
;;;1017     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
;;;1018     if((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
;;;1019     {
;;;1020       /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1021       CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1022       CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1023       
;;;1024       /* Disable the UART DMA Rx request */
;;;1025       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1026     }
;;;1027     
;;;1028     /* Process Unlocked */
;;;1029     __HAL_UNLOCK(huart);
;;;1030     
;;;1031     return HAL_OK; 
;;;1032   }
000008  4770              BXEQ     lr
00000a  2101              MOVS     r1,#1                 ;1010
00000c  6381              STR      r1,[r0,#0x38]         ;1011
00000e  6801              LDR      r1,[r0,#0]            ;1011
000010  694a              LDR      r2,[r1,#0x14]         ;1011
000012  6bc3              LDR      r3,[r0,#0x3c]         ;1012
000014  f3c212c0          UBFX     r2,r2,#7,#1           ;1011
000018  2b21              CMP      r3,#0x21              ;1012
00001a  d104              BNE      |L18.38|
00001c  b11a              CBZ      r2,|L18.38|
00001e  694a              LDR      r2,[r1,#0x14]         ;1015
000020  f0220280          BIC      r2,r2,#0x80           ;1015
000024  614a              STR      r2,[r1,#0x14]         ;1015
                  |L18.38|
000026  6801              LDR      r1,[r0,#0]            ;1017
000028  694a              LDR      r2,[r1,#0x14]         ;1017
00002a  6c03              LDR      r3,[r0,#0x40]         ;1018
00002c  f3c21280          UBFX     r2,r2,#6,#1           ;1017
000030  2b22              CMP      r3,#0x22              ;1018
000032  d10e              BNE      |L18.82|
000034  b16a              CBZ      r2,|L18.82|
000036  68ca              LDR      r2,[r1,#0xc]          ;1021
000038  f4227280          BIC      r2,r2,#0x100          ;1021
00003c  60ca              STR      r2,[r1,#0xc]          ;1021
00003e  6801              LDR      r1,[r0,#0]            ;1022
000040  694a              LDR      r2,[r1,#0x14]         ;1022
000042  f0220201          BIC      r2,r2,#1              ;1022
000046  614a              STR      r2,[r1,#0x14]         ;1022
000048  6801              LDR      r1,[r0,#0]            ;1025
00004a  694a              LDR      r2,[r1,#0x14]         ;1025
00004c  f0220240          BIC      r2,r2,#0x40           ;1025
000050  614a              STR      r2,[r1,#0x14]         ;1025
                  |L18.82|
000052  2100              MOVS     r1,#0                 ;1029
000054  6381              STR      r1,[r0,#0x38]         ;1031
000056  4608              MOV      r0,r1                 ;1031
000058  4770              BX       lr
;;;1033   
                          ENDP


                          AREA ||i.HAL_UART_DMAResume||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAResume PROC
;;;1039     */
;;;1040   HAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart)
000000  6b81              LDR      r1,[r0,#0x38]
;;;1041   {
000002  b081              SUB      sp,sp,#4
;;;1042     /* Process Locked */
;;;1043     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  bf02              ITTT     EQ
000008  2002              MOVEQ    r0,#2
;;;1044     
;;;1045     if(huart->gState == HAL_UART_STATE_BUSY_TX)
;;;1046     {
;;;1047       /* Enable the UART DMA Tx request */
;;;1048       SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1049     }
;;;1050     if(huart->RxState == HAL_UART_STATE_BUSY_RX)
;;;1051     {
;;;1052       /* Clear the Overrun flag before resuming the Rx transfer*/
;;;1053       __HAL_UART_CLEAR_OREFLAG(huart);
;;;1054       
;;;1055       /* Reenable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1056       SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1057       SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1058       
;;;1059       /* Enable the UART DMA Rx request */
;;;1060       SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1061     }
;;;1062     
;;;1063     /* Process Unlocked */
;;;1064     __HAL_UNLOCK(huart);
;;;1065     
;;;1066     return HAL_OK;
;;;1067   }
00000a  b001              ADDEQ    sp,sp,#4
00000c  4770              BXEQ     lr
00000e  2101              MOVS     r1,#1                 ;1043
000010  6381              STR      r1,[r0,#0x38]         ;1045
000012  6bc1              LDR      r1,[r0,#0x3c]         ;1045
000014  2921              CMP      r1,#0x21              ;1045
000016  d104              BNE      |L19.34|
000018  6801              LDR      r1,[r0,#0]            ;1048
00001a  694a              LDR      r2,[r1,#0x14]         ;1048
00001c  f0420280          ORR      r2,r2,#0x80           ;1048
000020  614a              STR      r2,[r1,#0x14]         ;1048
                  |L19.34|
000022  6c01              LDR      r1,[r0,#0x40]         ;1050
000024  2200              MOVS     r2,#0                 ;1050
000026  2922              CMP      r1,#0x22              ;1050
000028  d111              BNE      |L19.78|
00002a  6801              LDR      r1,[r0,#0]            ;1053
00002c  680b              LDR      r3,[r1,#0]            ;1053
00002e  684b              LDR      r3,[r1,#4]            ;1053
000030  9300              STR      r3,[sp,#0]            ;1056
000032  68cb              LDR      r3,[r1,#0xc]          ;1056
000034  f4437380          ORR      r3,r3,#0x100          ;1056
000038  60cb              STR      r3,[r1,#0xc]          ;1056
00003a  6801              LDR      r1,[r0,#0]            ;1057
00003c  694b              LDR      r3,[r1,#0x14]         ;1057
00003e  f0430301          ORR      r3,r3,#1              ;1057
000042  614b              STR      r3,[r1,#0x14]         ;1057
000044  6801              LDR      r1,[r0,#0]            ;1060
000046  694b              LDR      r3,[r1,#0x14]         ;1060
000048  f0430340          ORR      r3,r3,#0x40           ;1060
00004c  614b              STR      r3,[r1,#0x14]         ;1060
                  |L19.78|
00004e  6382              STR      r2,[r0,#0x38]         ;1066
000050  2000              MOVS     r0,#0                 ;1066
000052  b001              ADD      sp,sp,#4
000054  4770              BX       lr
;;;1068   
                          ENDP


                          AREA ||i.HAL_UART_DMAStop||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAStop PROC
;;;1074     */
;;;1075   HAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1076   {
000002  4604              MOV      r4,r0
;;;1077     uint32_t dmarequest = 0x00U;
;;;1078     /* The Lock is not implemented on this API to allow the user application
;;;1079        to call the HAL UART API under callbacks HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback():
;;;1080        when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
;;;1081        and the correspond call back is executed HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback()
;;;1082        */
;;;1083     
;;;1084     /* Stop UART DMA Tx request if ongoing */
;;;1085     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
000004  6800              LDR      r0,[r0,#0]
000006  6941              LDR      r1,[r0,#0x14]
;;;1086     if((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
000008  6be2              LDR      r2,[r4,#0x3c]
00000a  f3c111c0          UBFX     r1,r1,#7,#1           ;1085
00000e  2520              MOVS     r5,#0x20              ;1085
000010  2a21              CMP      r2,#0x21
000012  d10f              BNE      |L20.52|
000014  b171              CBZ      r1,|L20.52|
;;;1087     {
;;;1088       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000016  6941              LDR      r1,[r0,#0x14]
000018  f0210180          BIC      r1,r1,#0x80
00001c  6141              STR      r1,[r0,#0x14]
;;;1089   
;;;1090       /* Abort the UART DMA Tx channel */
;;;1091       if(huart->hdmatx != NULL)
00001e  6b20              LDR      r0,[r4,#0x30]
000020  2800              CMP      r0,#0
;;;1092       {
;;;1093         HAL_DMA_Abort(huart->hdmatx);
000022  bf18              IT       NE
000024  f7fffffe          BLNE     HAL_DMA_Abort
000028  6820              LDR      r0,[r4,#0]
00002a  68c1              LDR      r1,[r0,#0xc]
00002c  f02101c0          BIC      r1,r1,#0xc0
000030  60c1              STR      r1,[r0,#0xc]
000032  63e5              STR      r5,[r4,#0x3c]
                  |L20.52|
;;;1094       }
;;;1095       UART_EndTxTransfer(huart);
;;;1096     }
;;;1097   
;;;1098     /* Stop UART DMA Rx request if ongoing */
;;;1099     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
000034  6820              LDR      r0,[r4,#0]
000036  6941              LDR      r1,[r0,#0x14]
;;;1100     if((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
000038  6c22              LDR      r2,[r4,#0x40]
00003a  f3c11180          UBFX     r1,r1,#6,#1           ;1099
00003e  2a22              CMP      r2,#0x22
000040  d114              BNE      |L20.108|
000042  b199              CBZ      r1,|L20.108|
;;;1101     {
;;;1102       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000044  6941              LDR      r1,[r0,#0x14]
000046  f0210140          BIC      r1,r1,#0x40
00004a  6141              STR      r1,[r0,#0x14]
;;;1103   
;;;1104       /* Abort the UART DMA Rx channel */
;;;1105       if(huart->hdmarx != NULL)
00004c  6b60              LDR      r0,[r4,#0x34]
00004e  2800              CMP      r0,#0
;;;1106       {
;;;1107         HAL_DMA_Abort(huart->hdmarx);
000050  bf18              IT       NE
000052  f7fffffe          BLNE     HAL_DMA_Abort
000056  6820              LDR      r0,[r4,#0]
000058  68c1              LDR      r1,[r0,#0xc]
00005a  f4217190          BIC      r1,r1,#0x120
00005e  60c1              STR      r1,[r0,#0xc]
000060  6820              LDR      r0,[r4,#0]
000062  6941              LDR      r1,[r0,#0x14]
000064  f0210101          BIC      r1,r1,#1
000068  6141              STR      r1,[r0,#0x14]
00006a  6425              STR      r5,[r4,#0x40]
                  |L20.108|
;;;1108       }
;;;1109       UART_EndRxTransfer(huart);
;;;1110     }
;;;1111   
;;;1112     return HAL_OK;
00006c  2000              MOVS     r0,#0
;;;1113   }
00006e  bd70              POP      {r4-r6,pc}
;;;1114   
                          ENDP


                          AREA ||i.HAL_UART_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_DeInit PROC
;;;494      */
;;;495    HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
000000  2800              CMP      r0,#0
;;;496    {
;;;497      /* Check the UART handle allocation */
;;;498      if(huart == NULL)
;;;499      {
;;;500        return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;501      }
;;;502      
;;;503      /* Check the parameters */
;;;504      assert_param(IS_UART_INSTANCE(huart->Instance));
;;;505    
;;;506      huart->gState = HAL_UART_STATE_BUSY;
;;;507      
;;;508      /* DeInit the low level hardware */
;;;509      HAL_UART_MspDeInit(huart);
;;;510      
;;;511      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;512      huart->gState = HAL_UART_STATE_RESET;
;;;513      huart->RxState = HAL_UART_STATE_RESET;
;;;514    
;;;515      /* Process Lock */
;;;516      __HAL_UNLOCK(huart);
;;;517    
;;;518      return HAL_OK;
;;;519    }
000006  4770              BXEQ     lr
000008  b510              PUSH     {r4,lr}               ;496
00000a  4604              MOV      r4,r0                 ;496
00000c  2024              MOVS     r0,#0x24              ;506
00000e  63e0              STR      r0,[r4,#0x3c]         ;506
000010  4620              MOV      r0,r4                 ;509
000012  f7fffffe          BL       HAL_UART_MspDeInit
000016  2000              MOVS     r0,#0                 ;511
000018  6460              STR      r0,[r4,#0x44]         ;511
00001a  63e0              STR      r0,[r4,#0x3c]         ;512
00001c  6420              STR      r0,[r4,#0x40]         ;513
00001e  63a0              STR      r0,[r4,#0x38]         ;516
000020  bd10              POP      {r4,pc}
;;;520    
                          ENDP


                          AREA ||i.HAL_UART_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_ErrorCallback PROC
;;;1709     */
;;;1710    __weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1711   {
;;;1712     /* Prevent unused argument(s) compilation warning */
;;;1713     UNUSED(huart); 
;;;1714     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1715              the HAL_UART_ErrorCallback could be implemented in the user file
;;;1716      */ 
;;;1717   }
;;;1718   
                          ENDP


                          AREA ||i.HAL_UART_GetError||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetError PROC
;;;1977     */
;;;1978   uint32_t HAL_UART_GetError(UART_HandleTypeDef *huart)
000000  6c40              LDR      r0,[r0,#0x44]
;;;1979   {
;;;1980     return huart->ErrorCode;
;;;1981   }
000002  4770              BX       lr
;;;1982   
                          ENDP


                          AREA ||i.HAL_UART_GetState||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetState PROC
;;;1962     */
;;;1963   HAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart)
000000  6bc1              LDR      r1,[r0,#0x3c]
;;;1964   {
;;;1965     uint32_t temp1= 0x00U, temp2 = 0x00U;
;;;1966     temp1 = huart->gState;
;;;1967     temp2 = huart->RxState;
000002  6c00              LDR      r0,[r0,#0x40]
;;;1968     
;;;1969     return (HAL_UART_StateTypeDef)(temp1 | temp2);
000004  4308              ORRS     r0,r0,r1
;;;1970   }
000006  4770              BX       lr
;;;1971   
                          ENDP


                          AREA ||i.HAL_UART_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_UART_IRQHandler PROC
;;;1522     */
;;;1523   void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1524   {
;;;1525      uint32_t isrflags   = READ_REG(huart->Instance->SR);
000002  6801              LDR      r1,[r0,#0]
000004  4604              MOV      r4,r0                 ;1524
000006  6808              LDR      r0,[r1,#0]
;;;1526      uint32_t cr1its     = READ_REG(huart->Instance->CR1);
000008  68ca              LDR      r2,[r1,#0xc]
;;;1527      uint32_t cr3its     = READ_REG(huart->Instance->CR3);
00000a  694b              LDR      r3,[r1,#0x14]
;;;1528      uint32_t errorflags = 0x00U;
;;;1529      uint32_t dmarequest = 0x00U;
;;;1530   
;;;1531     /* If no error occurs */
;;;1532     errorflags = (isrflags & (uint32_t)(USART_SR_PE | USART_SR_FE | USART_SR_ORE | USART_SR_NE));
00000c  f0100f0f          TST      r0,#0xf
000010  f04f0520          MOV      r5,#0x20
000014  d044              BEQ      |L25.160|
;;;1533     if(errorflags == RESET)
;;;1534     {
;;;1535       /* UART in mode Receiver -------------------------------------------------*/
;;;1536       if(((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
;;;1537       {
;;;1538         UART_Receive_IT(huart);
;;;1539         return;
;;;1540       }
;;;1541     }  
;;;1542   
;;;1543     /* If some errors occur */
;;;1544     if((errorflags != RESET) && (((cr3its & USART_CR3_EIE) != RESET) || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)))
000016  f0030c01          AND      r12,r3,#1
00001a  f4027690          AND      r6,r2,#0x120
00001e  ea5c0c06          ORRS     r12,r12,r6
000022  f00080ed          BEQ.W    |L25.512|
;;;1545     {
;;;1546       /* UART parity error interrupt occurred ----------------------------------*/
;;;1547       if(((isrflags & USART_SR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
000026  f0100f01          TST      r0,#1
00002a  bf18              IT       NE
00002c  f4127f80          TSTNE    r2,#0x100
000030  d005              BEQ      |L25.62|
;;;1548       {
;;;1549         huart->ErrorCode |= HAL_UART_ERROR_PE;
000032  f8d4c044          LDR      r12,[r4,#0x44]
000036  f04c0c01          ORR      r12,r12,#1
00003a  f8c4c044          STR      r12,[r4,#0x44]
                  |L25.62|
;;;1550       }
;;;1551       
;;;1552       /* UART noise error interrupt occurred -----------------------------------*/
;;;1553       if(((isrflags & USART_SR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
00003e  f0100f04          TST      r0,#4
000042  bf18              IT       NE
000044  f0130f01          TSTNE    r3,#1
000048  d005              BEQ      |L25.86|
;;;1554       {
;;;1555         huart->ErrorCode |= HAL_UART_ERROR_NE;
00004a  f8d4c044          LDR      r12,[r4,#0x44]
00004e  f04c0c02          ORR      r12,r12,#2
000052  f8c4c044          STR      r12,[r4,#0x44]
                  |L25.86|
;;;1556       }
;;;1557       
;;;1558       /* UART frame error interrupt occurred -----------------------------------*/
;;;1559       if(((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
000056  f0100f02          TST      r0,#2
00005a  bf18              IT       NE
00005c  f0130f01          TSTNE    r3,#1
000060  d005              BEQ      |L25.110|
;;;1560       {
;;;1561         huart->ErrorCode |= HAL_UART_ERROR_FE;
000062  f8d4c044          LDR      r12,[r4,#0x44]
000066  f04c0c04          ORR      r12,r12,#4
00006a  f8c4c044          STR      r12,[r4,#0x44]
                  |L25.110|
;;;1562       }
;;;1563       
;;;1564       /* UART Over-Run interrupt occurred --------------------------------------*/
;;;1565       if(((isrflags & USART_SR_ORE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
00006e  f0100f08          TST      r0,#8
000072  bf18              IT       NE
000074  f0130f01          TSTNE    r3,#1
000078  d003              BEQ      |L25.130|
;;;1566       { 
;;;1567         huart->ErrorCode |= HAL_UART_ERROR_ORE;
00007a  6c63              LDR      r3,[r4,#0x44]
00007c  f0430308          ORR      r3,r3,#8
000080  6463              STR      r3,[r4,#0x44]
                  |L25.130|
;;;1568       }
;;;1569   
;;;1570       /* Call UART Error Call back function if need be --------------------------*/    
;;;1571       if(huart->ErrorCode != HAL_UART_ERROR_NONE)
000082  6c63              LDR      r3,[r4,#0x44]
000084  2b00              CMP      r3,#0
;;;1572       {
;;;1573         /* UART in mode Receiver -----------------------------------------------*/
;;;1574         if(((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
;;;1575         {
;;;1576           UART_Receive_IT(huart);
;;;1577         }
;;;1578   
;;;1579         /* If Overrun error occurs, or if any error occurs in DMA mode reception,
;;;1580            consider error as blocking */
;;;1581         dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
;;;1582         if(((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
;;;1583         {
;;;1584           /* Blocking error : transfer is aborted
;;;1585              Set the UART state ready to be able to start again the process,
;;;1586              Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
;;;1587           UART_EndRxTransfer(huart);
;;;1588           
;;;1589           /* Disable the UART DMA Rx request if enabled */
;;;1590           if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
;;;1591           {
;;;1592             CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1593             
;;;1594             /* Abort the UART DMA Rx channel */
;;;1595             if(huart->hdmarx != NULL)
;;;1596             {
;;;1597               /* Set the UART DMA Abort callback : 
;;;1598                  will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
;;;1599               huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
;;;1600               if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
;;;1601               {
;;;1602                 /* Call Directly XferAbortCallback function in case of error */
;;;1603                 huart->hdmarx->XferAbortCallback(huart->hdmarx);
;;;1604               }
;;;1605             }
;;;1606             else
;;;1607             {
;;;1608               /* Call user error callback */
;;;1609               HAL_UART_ErrorCallback(huart);
;;;1610             }
;;;1611           }
;;;1612           else
;;;1613           {
;;;1614             /* Call user error callback */
;;;1615             HAL_UART_ErrorCallback(huart);
;;;1616           }
;;;1617         }
;;;1618         else
;;;1619         {
;;;1620           /* Non Blocking error : transfer could go on. 
;;;1621              Error is notified to user through user error callback */
;;;1622           HAL_UART_ErrorCallback(huart);
;;;1623           huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1624         }
;;;1625       }
;;;1626       return;
;;;1627     } /* End if some error occurs */
;;;1628   
;;;1629     /* UART in mode Transmitter ------------------------------------------------*/
;;;1630     if(((isrflags & USART_SR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
;;;1631     {
;;;1632       UART_Transmit_IT(huart);
;;;1633       return;
;;;1634     }
;;;1635     
;;;1636     /* UART in mode Transmitter end --------------------------------------------*/
;;;1637     if(((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
;;;1638     {
;;;1639       UART_EndTransmit_IT(huart);
;;;1640       return;
;;;1641     }
;;;1642   }
000086  bf08              IT       EQ
000088  bd70              POPEQ    {r4-r6,pc}
00008a  f0100f20          TST      r0,#0x20              ;1574
00008e  bf18              IT       NE                    ;1574
000090  f0120f20          TSTNE    r2,#0x20              ;1574
000094  d07d              BEQ      |L25.402|
000096  6c22              LDR      r2,[r4,#0x40]         ;1574
000098  4620              MOV      r0,r4                 ;1576
00009a  2a22              CMP      r2,#0x22              ;1576
00009c  d042              BEQ      |L25.292|
00009e  e078              B        |L25.402|
                  |L25.160|
0000a0  f0100f20          TST      r0,#0x20              ;1536
0000a4  bf18              IT       NE                    ;1536
0000a6  f0120f20          TSTNE    r2,#0x20              ;1536
0000aa  d07d              BEQ      |L25.424|
0000ac  6c22              LDR      r2,[r4,#0x40]         ;1536
0000ae  4620              MOV      r0,r4                 ;1538
0000b0  2a22              CMP      r2,#0x22              ;1538
0000b2  bf18              IT       NE
0000b4  bd70              POPNE    {r4-r6,pc}
0000b6  6882              LDR      r2,[r0,#8]
0000b8  f5b25f80          CMP      r2,#0x1000
0000bc  d01d              BEQ      |L25.250|
0000be  6902              LDR      r2,[r0,#0x10]
0000c0  b352              CBZ      r2,|L25.280|
0000c2  6849              LDR      r1,[r1,#4]
0000c4  f001027f          AND      r2,r1,#0x7f
0000c8  6a81              LDR      r1,[r0,#0x28]
0000ca  1c4b              ADDS     r3,r1,#1
0000cc  6283              STR      r3,[r0,#0x28]
0000ce  700a              STRB     r2,[r1,#0]
                  |L25.208|
0000d0  8dc1              LDRH     r1,[r0,#0x2e]
0000d2  1e49              SUBS     r1,r1,#1
0000d4  0409              LSLS     r1,r1,#16
0000d6  0c09              LSRS     r1,r1,#16
0000d8  85c1              STRH     r1,[r0,#0x2e]
0000da  bf18              IT       NE
0000dc  bd70              POPNE    {r4-r6,pc}
0000de  6801              LDR      r1,[r0,#0]
0000e0  68ca              LDR      r2,[r1,#0xc]
0000e2  f4227290          BIC      r2,r2,#0x120
0000e6  60ca              STR      r2,[r1,#0xc]
0000e8  6801              LDR      r1,[r0,#0]
0000ea  694a              LDR      r2,[r1,#0x14]
0000ec  f0220201          BIC      r2,r2,#1
0000f0  614a              STR      r2,[r1,#0x14]
0000f2  6405              STR      r5,[r0,#0x40]
0000f4  f7fffffe          BL       HAL_UART_RxCpltCallback
0000f8  bd70              POP      {r4-r6,pc}
                  |L25.250|
0000fa  6903              LDR      r3,[r0,#0x10]
0000fc  6a82              LDR      r2,[r0,#0x28]
0000fe  6849              LDR      r1,[r1,#4]
000100  2b00              CMP      r3,#0
000102  bf14              ITE      NE
000104  b2c9              UXTBNE   r1,r1
000106  f3c10108          UBFXEQ   r1,r1,#0,#9
00010a  8011              STRH     r1,[r2,#0]
00010c  6a81              LDR      r1,[r0,#0x28]
00010e  bf14              ITE      NE
000110  1c49              ADDNE    r1,r1,#1
000112  1c89              ADDEQ    r1,r1,#2
000114  6281              STR      r1,[r0,#0x28]
000116  e7db              B        |L25.208|
                  |L25.280|
000118  684a              LDR      r2,[r1,#4]
00011a  6a81              LDR      r1,[r0,#0x28]
00011c  1c4b              ADDS     r3,r1,#1
00011e  6283              STR      r3,[r0,#0x28]
000120  700a              STRB     r2,[r1,#0]
000122  e7d5              B        |L25.208|
                  |L25.292|
000124  6882              LDR      r2,[r0,#8]
000126  f5b25f80          CMP      r2,#0x1000
00012a  d00f              BEQ      |L25.332|
00012c  6902              LDR      r2,[r0,#0x10]
00012e  b1e2              CBZ      r2,|L25.362|
000130  6849              LDR      r1,[r1,#4]
000132  f001027f          AND      r2,r1,#0x7f
000136  6a81              LDR      r1,[r0,#0x28]
000138  1c4b              ADDS     r3,r1,#1
00013a  6283              STR      r3,[r0,#0x28]
00013c  700a              STRB     r2,[r1,#0]
                  |L25.318|
00013e  8dc1              LDRH     r1,[r0,#0x2e]
000140  1e49              SUBS     r1,r1,#1
000142  0409              LSLS     r1,r1,#16
000144  0c09              LSRS     r1,r1,#16
000146  85c1              STRH     r1,[r0,#0x2e]
000148  d123              BNE      |L25.402|
00014a  e015              B        |L25.376|
                  |L25.332|
00014c  6903              LDR      r3,[r0,#0x10]
00014e  6a82              LDR      r2,[r0,#0x28]
000150  6849              LDR      r1,[r1,#4]
000152  2b00              CMP      r3,#0
000154  bf14              ITE      NE
000156  b2c9              UXTBNE   r1,r1
000158  f3c10108          UBFXEQ   r1,r1,#0,#9
00015c  8011              STRH     r1,[r2,#0]
00015e  6a81              LDR      r1,[r0,#0x28]
000160  bf14              ITE      NE
000162  1c49              ADDNE    r1,r1,#1
000164  1c89              ADDEQ    r1,r1,#2
000166  6281              STR      r1,[r0,#0x28]
000168  e7e9              B        |L25.318|
                  |L25.362|
00016a  684a              LDR      r2,[r1,#4]
00016c  6a81              LDR      r1,[r0,#0x28]
00016e  1c4b              ADDS     r3,r1,#1
000170  6283              STR      r3,[r0,#0x28]
000172  700a              STRB     r2,[r1,#0]
000174  e7e3              B        |L25.318|
000176  e00c              B        |L25.402|
                  |L25.376|
000178  6801              LDR      r1,[r0,#0]
00017a  68ca              LDR      r2,[r1,#0xc]
00017c  f4227290          BIC      r2,r2,#0x120
000180  60ca              STR      r2,[r1,#0xc]
000182  6801              LDR      r1,[r0,#0]
000184  694a              LDR      r2,[r1,#0x14]
000186  f0220201          BIC      r2,r2,#1
00018a  614a              STR      r2,[r1,#0x14]
00018c  6405              STR      r5,[r0,#0x40]
00018e  f7fffffe          BL       HAL_UART_RxCpltCallback
                  |L25.402|
000192  6820              LDR      r0,[r4,#0]            ;1581
000194  6941              LDR      r1,[r0,#0x14]         ;1581
000196  6c62              LDR      r2,[r4,#0x44]         ;1582
000198  f3c11180          UBFX     r1,r1,#6,#1           ;1581
00019c  f0020208          AND      r2,r2,#8              ;1582
0001a0  4311              ORRS     r1,r1,r2              ;1582
0001a2  d027              BEQ      |L25.500|
0001a4  68c1              LDR      r1,[r0,#0xc]          ;1582
0001a6  e000              B        |L25.426|
                  |L25.424|
0001a8  e02a              B        |L25.512|
                  |L25.426|
0001aa  f4217190          BIC      r1,r1,#0x120          ;1582
0001ae  60c1              STR      r1,[r0,#0xc]          ;1582
0001b0  6820              LDR      r0,[r4,#0]            ;1582
0001b2  6941              LDR      r1,[r0,#0x14]         ;1582
0001b4  f0210101          BIC      r1,r1,#1              ;1582
0001b8  6141              STR      r1,[r0,#0x14]         ;1582
0001ba  6425              STR      r5,[r4,#0x40]         ;1582
0001bc  6820              LDR      r0,[r4,#0]            ;1590
0001be  6941              LDR      r1,[r0,#0x14]         ;1590
0001c0  f0110f40          TST      r1,#0x40              ;1590
0001c4  d012              BEQ      |L25.492|
0001c6  6941              LDR      r1,[r0,#0x14]         ;1592
0001c8  f0210140          BIC      r1,r1,#0x40           ;1592
0001cc  6141              STR      r1,[r0,#0x14]         ;1592
0001ce  6b60              LDR      r0,[r4,#0x34]         ;1595
0001d0  b160              CBZ      r0,|L25.492|
0001d2  492c              LDR      r1,|L25.644|
0001d4  6541              STR      r1,[r0,#0x54]         ;1600
0001d6  6b60              LDR      r0,[r4,#0x34]         ;1600
0001d8  f7fffffe          BL       HAL_DMA_Abort_IT
0001dc  2800              CMP      r0,#0                 ;1600
0001de  bf08              IT       EQ
0001e0  bd70              POPEQ    {r4-r6,pc}
0001e2  6b60              LDR      r0,[r4,#0x34]         ;1603
0001e4  6d41              LDR      r1,[r0,#0x54]         ;1603
0001e6  e8bd4070          POP      {r4-r6,lr}            ;1603
0001ea  4708              BX       r1                    ;1603
                  |L25.492|
0001ec  4620              MOV      r0,r4                 ;1615
0001ee  f7fffffe          BL       HAL_UART_ErrorCallback
0001f2  bd70              POP      {r4-r6,pc}
                  |L25.500|
0001f4  4620              MOV      r0,r4                 ;1622
0001f6  f7fffffe          BL       HAL_UART_ErrorCallback
0001fa  2000              MOVS     r0,#0                 ;1623
0001fc  6460              STR      r0,[r4,#0x44]         ;1623
0001fe  bd70              POP      {r4-r6,pc}
                  |L25.512|
000200  f0100f80          TST      r0,#0x80              ;1630
000204  bf18              IT       NE                    ;1630
000206  f0120f80          TSTNE    r2,#0x80              ;1630
00020a  d02b              BEQ      |L25.612|
00020c  6be0              LDR      r0,[r4,#0x3c]         ;1630
00020e  2821              CMP      r0,#0x21              ;1630
000210  bf18              IT       NE
000212  bd70              POPNE    {r4-r6,pc}
000214  68a0              LDR      r0,[r4,#8]
000216  f5b05f80          CMP      r0,#0x1000
00021a  6a20              LDR      r0,[r4,#0x20]
00021c  d016              BEQ      |L25.588|
00021e  1c41              ADDS     r1,r0,#1
000220  6221              STR      r1,[r4,#0x20]
000222  6821              LDR      r1,[r4,#0]
000224  7800              LDRB     r0,[r0,#0]
000226  6048              STR      r0,[r1,#4]
                  |L25.552|
000228  8ce0              LDRH     r0,[r4,#0x26]
00022a  1e40              SUBS     r0,r0,#1
00022c  0400              LSLS     r0,r0,#16
00022e  0c00              LSRS     r0,r0,#16
000230  84e0              STRH     r0,[r4,#0x26]
000232  bf18              IT       NE
000234  bd70              POPNE    {r4-r6,pc}
000236  6820              LDR      r0,[r4,#0]
000238  68c1              LDR      r1,[r0,#0xc]
00023a  f0210180          BIC      r1,r1,#0x80
00023e  60c1              STR      r1,[r0,#0xc]
000240  6820              LDR      r0,[r4,#0]
000242  68c1              LDR      r1,[r0,#0xc]
000244  f0410140          ORR      r1,r1,#0x40
000248  60c1              STR      r1,[r0,#0xc]
00024a  bd70              POP      {r4-r6,pc}
                  |L25.588|
00024c  8800              LDRH     r0,[r0,#0]
00024e  f3c00008          UBFX     r0,r0,#0,#9
000252  6048              STR      r0,[r1,#4]
000254  6920              LDR      r0,[r4,#0x10]
000256  2800              CMP      r0,#0
000258  6a20              LDR      r0,[r4,#0x20]
00025a  bf14              ITE      NE
00025c  1c40              ADDNE    r0,r0,#1
00025e  1c80              ADDEQ    r0,r0,#2
000260  6220              STR      r0,[r4,#0x20]
000262  e7e1              B        |L25.552|
                  |L25.612|
000264  f0100f40          TST      r0,#0x40              ;1637
000268  bf14              ITE      NE                    ;1637
00026a  f0120f40          TSTNE    r2,#0x40              ;1637
00026e  bd70              POPEQ    {r4-r6,pc}
000270  4620              MOV      r0,r4                 ;1639
000272  68ca              LDR      r2,[r1,#0xc]          ;1639
000274  f0220240          BIC      r2,r2,#0x40           ;1639
000278  60ca              STR      r2,[r1,#0xc]          ;1639
00027a  63e5              STR      r5,[r4,#0x3c]         ;1639
00027c  f7fffffe          BL       HAL_UART_TxCpltCallback
000280  bd70              POP      {r4-r6,pc}
;;;1643   
                          ENDP

000282  0000              DCW      0x0000
                  |L25.644|
                          DCD      UART_DMAAbortOnError

                          AREA ||i.HAL_UART_Init||, CODE, READONLY, ALIGN=1

                  HAL_UART_Init PROC
;;;243      */
;;;244    HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
000000  2800              CMP      r0,#0
;;;245    {
;;;246      /* Check the UART handle allocation */
;;;247      if(huart == NULL)
;;;248      {
;;;249        return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;250      }
;;;251    
;;;252      /* Check the parameters */
;;;253      if(huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
;;;254      { 
;;;255        /* The hardware flow control is available only for USART1, USART2, USART3 and USART6 */
;;;256        assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
;;;257        assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
;;;258      }
;;;259      else
;;;260      {
;;;261        assert_param(IS_UART_INSTANCE(huart->Instance));
;;;262      }
;;;263      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;264      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;265      
;;;266      if(huart->gState == HAL_UART_STATE_RESET)
;;;267      {  
;;;268        /* Allocate lock resource and initialize it */
;;;269        huart->Lock = HAL_UNLOCKED;
;;;270        /* Init the low level hardware */
;;;271        HAL_UART_MspInit(huart);
;;;272      }
;;;273    
;;;274      huart->gState = HAL_UART_STATE_BUSY;
;;;275    
;;;276      /* Disable the peripheral */
;;;277      __HAL_UART_DISABLE(huart);
;;;278      
;;;279      /* Set the UART Communication parameters */
;;;280      UART_SetConfig(huart);
;;;281      
;;;282      /* In asynchronous mode, the following bits must be kept cleared: 
;;;283         - LINEN and CLKEN bits in the USART_CR2 register,
;;;284         - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
;;;285      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;286      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;287      
;;;288      /* Enable the peripheral */
;;;289      __HAL_UART_ENABLE(huart);
;;;290      
;;;291      /* Initialize the UART state */
;;;292      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;293      huart->gState= HAL_UART_STATE_READY;
;;;294      huart->RxState= HAL_UART_STATE_READY;
;;;295      
;;;296      return HAL_OK;
;;;297    }
000006  4770              BXEQ     lr
000008  b570              PUSH     {r4-r6,lr}            ;245
00000a  4604              MOV      r4,r0                 ;245
00000c  6bc0              LDR      r0,[r0,#0x3c]         ;266
00000e  2500              MOVS     r5,#0                 ;266
000010  b918              CBNZ     r0,|L26.26|
000012  4620              MOV      r0,r4                 ;271
000014  63a5              STR      r5,[r4,#0x38]         ;271
000016  f7fffffe          BL       HAL_UART_MspInit
                  |L26.26|
00001a  2024              MOVS     r0,#0x24              ;274
00001c  63e0              STR      r0,[r4,#0x3c]         ;274
00001e  6820              LDR      r0,[r4,#0]            ;277
000020  68c1              LDR      r1,[r0,#0xc]          ;277
000022  f4215100          BIC      r1,r1,#0x2000         ;277
000026  60c1              STR      r1,[r0,#0xc]          ;277
000028  4620              MOV      r0,r4                 ;280
00002a  f7fffffe          BL       UART_SetConfig
00002e  6820              LDR      r0,[r4,#0]            ;285
000030  6901              LDR      r1,[r0,#0x10]         ;285
000032  f4214190          BIC      r1,r1,#0x4800         ;285
000036  6101              STR      r1,[r0,#0x10]         ;285
000038  6820              LDR      r0,[r4,#0]            ;286
00003a  6941              LDR      r1,[r0,#0x14]         ;286
00003c  f021012a          BIC      r1,r1,#0x2a           ;286
000040  6141              STR      r1,[r0,#0x14]         ;286
000042  6820              LDR      r0,[r4,#0]            ;289
000044  68c1              LDR      r1,[r0,#0xc]          ;289
000046  f4415100          ORR      r1,r1,#0x2000         ;289
00004a  60c1              STR      r1,[r0,#0xc]          ;289
00004c  6465              STR      r5,[r4,#0x44]         ;292
00004e  2020              MOVS     r0,#0x20              ;293
000050  63e0              STR      r0,[r4,#0x3c]         ;293
000052  6420              STR      r0,[r4,#0x40]         ;294
000054  2000              MOVS     r0,#0                 ;296
000056  bd70              POP      {r4-r6,pc}
;;;298    
                          ENDP


                          AREA ||i.HAL_UART_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspDeInit PROC
;;;541      */
;;;542     __weak void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;543    {
;;;544      /* Prevent unused argument(s) compilation warning */
;;;545      UNUSED(huart);
;;;546      /* NOTE: This function Should not be modified, when the callback is needed,
;;;547               the HAL_UART_MspDeInit could be implemented in the user file
;;;548       */ 
;;;549    }
;;;550    
                          ENDP


                          AREA ||i.HAL_UART_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspInit PROC
;;;526      */
;;;527     __weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;528    {
;;;529       /* Prevent unused argument(s) compilation warning */
;;;530      UNUSED(huart);
;;;531      /* NOTE: This function Should not be modified, when the callback is needed,
;;;532               the HAL_UART_MspInit could be implemented in the user file
;;;533       */ 
;;;534    }
;;;535    
                          ENDP


                          AREA ||i.HAL_UART_Receive||, CODE, READONLY, ALIGN=2

                  HAL_UART_Receive PROC
;;;697      */
;;;698    HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;699    { 
000004  4604              MOV      r4,r0
;;;700      uint16_t* tmp;
;;;701      uint32_t tickstart = 0U;
;;;702      
;;;703      /* Check that a Rx process is not already ongoing */
;;;704      if(huart->RxState == HAL_UART_STATE_READY) 
000006  6c00              LDR      r0,[r0,#0x40]
000008  461d              MOV      r5,r3                 ;699
00000a  4617              MOV      r7,r2                 ;699
00000c  460e              MOV      r6,r1                 ;699
00000e  2820              CMP      r0,#0x20
000010  d17f              BNE      |L29.274|
;;;705      { 
;;;706        if((pData == NULL ) || (Size == 0)) 
000012  2e00              CMP      r6,#0
000014  bf12              ITEE     NE
000016  2f00              CMPNE    r7,#0
;;;707        {
;;;708          return  HAL_ERROR;
000018  2001              MOVEQ    r0,#1
;;;709        }
;;;710        
;;;711        /* Process Locked */
;;;712        __HAL_LOCK(huart);
;;;713        
;;;714        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;715        huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;716    	
;;;717        /* Init tickstart for timeout managment */
;;;718        tickstart = HAL_GetTick();
;;;719            
;;;720        huart->RxXferSize = Size; 
;;;721        huart->RxXferCount = Size;
;;;722        
;;;723        /* Check the remain data to be received */
;;;724        while(huart->RxXferCount > 0U)
;;;725        {
;;;726          huart->RxXferCount--;
;;;727          if(huart->Init.WordLength == UART_WORDLENGTH_9B)
;;;728          {
;;;729            if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;730            { 
;;;731              return HAL_TIMEOUT;
;;;732            }
;;;733            tmp = (uint16_t*) pData;
;;;734            if(huart->Init.Parity == UART_PARITY_NONE)
;;;735            {
;;;736              *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
;;;737              pData +=2U;
;;;738            }
;;;739            else
;;;740            {
;;;741              *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FF);
;;;742              pData +=1U;
;;;743            }
;;;744    
;;;745          } 
;;;746          else
;;;747          {
;;;748            if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;749            { 
;;;750              return HAL_TIMEOUT;
;;;751            }
;;;752            if(huart->Init.Parity == UART_PARITY_NONE)
;;;753            {
;;;754              *pData++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
;;;755            }
;;;756            else
;;;757            {
;;;758              *pData++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
;;;759            }
;;;760            
;;;761          }
;;;762        }
;;;763        
;;;764        /* At end of Rx process, restore huart->RxState to Ready */
;;;765        huart->RxState = HAL_UART_STATE_READY;
;;;766        
;;;767        /* Process Unlocked */
;;;768        __HAL_UNLOCK(huart);
;;;769        
;;;770        return HAL_OK;
;;;771      }
;;;772      else
;;;773      {
;;;774        return HAL_BUSY;   
;;;775      }
;;;776    }
00001a  e8bd87f0          POPEQ    {r4-r10,pc}
00001e  6ba0              LDR      r0,[r4,#0x38]         ;712
000020  2801              CMP      r0,#1                 ;712
000022  d076              BEQ      |L29.274|
000024  f04f0a00          MOV      r10,#0                ;714
000028  2001              MOVS     r0,#1                 ;712
00002a  f8c4a044          STR      r10,[r4,#0x44]        ;714
00002e  63a0              STR      r0,[r4,#0x38]         ;714
000030  2022              MOVS     r0,#0x22              ;715
000032  6420              STR      r0,[r4,#0x40]         ;715
000034  f7fffffe          BL       HAL_GetTick
000038  85a7              STRH     r7,[r4,#0x2c]         ;720
00003a  4680              MOV      r8,r0                 ;718
00003c  85e7              STRH     r7,[r4,#0x2e]         ;721
00003e  8de0              LDRH     r0,[r4,#0x2e]         ;724
000040  f04f0920          MOV      r9,#0x20              ;729
000044  2800              CMP      r0,#0                 ;724
000046  d04d              BEQ      |L29.228|
                  |L29.72|
000048  8de0              LDRH     r0,[r4,#0x2e]         ;726
00004a  1e40              SUBS     r0,r0,#1              ;726
00004c  85e0              STRH     r0,[r4,#0x2e]         ;726
00004e  68a0              LDR      r0,[r4,#8]            ;727
000050  f04f0720          MOV      r7,#0x20              ;748
000054  f5b05f80          CMP      r0,#0x1000            ;727
000058  6820              LDR      r0,[r4,#0]            ;727
00005a  6800              LDR      r0,[r0,#0]            ;727
00005c  ea270000          BIC      r0,r7,r0              ;727
000060  d01f              BEQ      |L29.162|
000062  2800              CMP      r0,#0                 ;727
000064  d04b              BEQ      |L29.254|
000066  bf00              NOP                            ;727
                  |L29.104|
000068  f1b53fff          CMP      r5,#0xffffffff        ;727
00006c  d042              BEQ      |L29.244|
00006e  b12d              CBZ      r5,|L29.124|
000070  f7fffffe          BL       HAL_GetTick
000074  eba00108          SUB      r1,r0,r8              ;727
000078  42a9              CMP      r1,r5                 ;727
00007a  d93b              BLS      |L29.244|
                  |L29.124|
00007c  6820              LDR      r0,[r4,#0]            ;727
00007e  68c1              LDR      r1,[r0,#0xc]          ;727
000080  f42171d0          BIC      r1,r1,#0x1a0          ;727
000084  60c1              STR      r1,[r0,#0xc]          ;727
000086  6820              LDR      r0,[r4,#0]            ;727
000088  6941              LDR      r1,[r0,#0x14]         ;727
00008a  f0210101          BIC      r1,r1,#1              ;727
00008e  6141              STR      r1,[r0,#0x14]         ;727
000090  f8c4903c          STR      r9,[r4,#0x3c]         ;727
000094  f8c49040          STR      r9,[r4,#0x40]         ;727
000098  2003              MOVS     r0,#3                 ;750
00009a  f8c4a038          STR      r10,[r4,#0x38]        ;750
00009e  e8bd87f0          POP      {r4-r10,pc}
                  |L29.162|
0000a2  b178              CBZ      r0,|L29.196|
                  |L29.164|
0000a4  f1b53fff          CMP      r5,#0xffffffff
0000a8  d007              BEQ      |L29.186|
0000aa  2d00              CMP      r5,#0
0000ac  d0e6              BEQ      |L29.124|
0000ae  f7fffffe          BL       HAL_GetTick
0000b2  eba00108          SUB      r1,r0,r8
0000b6  42a9              CMP      r1,r5
0000b8  d8e0              BHI      |L29.124|
                  |L29.186|
0000ba  6820              LDR      r0,[r4,#0]
0000bc  6800              LDR      r0,[r0,#0]
0000be  ea370000          BICS     r0,r7,r0
0000c2  d1ef              BNE      |L29.164|
                  |L29.196|
0000c4  6920              LDR      r0,[r4,#0x10]         ;734
0000c6  2800              CMP      r0,#0                 ;734
0000c8  6820              LDR      r0,[r4,#0]            ;741
0000ca  6840              LDR      r0,[r0,#4]            ;741
0000cc  bf0c              ITE      EQ                    ;736
0000ce  f3c00108          UBFXEQ   r1,r0,#0,#9           ;736
0000d2  b2c1              UXTBNE   r1,r0                 ;741
0000d4  4630              MOV      r0,r6                 ;741
0000d6  8031              STRH     r1,[r6,#0]            ;741
0000d8  bf0c              ITE      EQ                    ;737
0000da  1c86              ADDEQ    r6,r0,#2              ;737
0000dc  1c46              ADDNE    r6,r0,#1              ;742
                  |L29.222|
0000de  8de0              LDRH     r0,[r4,#0x2e]         ;758
0000e0  2800              CMP      r0,#0                 ;758
0000e2  d1b1              BNE      |L29.72|
                  |L29.228|
0000e4  f8c49040          STR      r9,[r4,#0x40]         ;765
0000e8  2000              MOVS     r0,#0                 ;770
0000ea  f8c4a038          STR      r10,[r4,#0x38]        ;770
0000ee  e8bd87f0          POP      {r4-r10,pc}
0000f2  e00e              B        |L29.274|
                  |L29.244|
0000f4  6820              LDR      r0,[r4,#0]
0000f6  6800              LDR      r0,[r0,#0]
0000f8  ea370000          BICS     r0,r7,r0
0000fc  d1b4              BNE      |L29.104|
                  |L29.254|
0000fe  6920              LDR      r0,[r4,#0x10]         ;752
000100  2800              CMP      r0,#0                 ;752
000102  6820              LDR      r0,[r4,#0]            ;758
000104  6840              LDR      r0,[r0,#4]            ;758
000106  bf18              IT       NE                    ;758
000108  f000007f          ANDNE    r0,r0,#0x7f           ;758
00010c  f8060b01          STRB     r0,[r6],#1            ;754
000110  e7e5              B        |L29.222|
                  |L29.274|
000112  2002              MOVS     r0,#2                 ;774
000114  e8bd87f0          POP      {r4-r10,pc}
;;;777    
                          ENDP


                          AREA ||i.HAL_UART_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Receive_DMA PROC
;;;937      */
;;;938    HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b538              PUSH     {r3-r5,lr}
;;;939    {  
000002  4604              MOV      r4,r0
;;;940      uint32_t *tmp;
;;;941      
;;;942      /* Check that a Rx process is not already ongoing */
;;;943      if(huart->RxState == HAL_UART_STATE_READY) 
000004  6c00              LDR      r0,[r0,#0x40]
000006  2820              CMP      r0,#0x20
000008  d139              BNE      |L30.126|
;;;944      {
;;;945        if((pData == NULL ) || (Size == 0)) 
00000a  2900              CMP      r1,#0
00000c  bf12              ITEE     NE
00000e  2a00              CMPNE    r2,#0
;;;946        {
;;;947          return HAL_ERROR;
000010  2001              MOVEQ    r0,#1
;;;948        }
;;;949        
;;;950        /* Process Locked */
;;;951        __HAL_LOCK(huart);
;;;952        
;;;953        huart->pRxBuffPtr = pData;
;;;954        huart->RxXferSize = Size;
;;;955        
;;;956        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;957        huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;958            
;;;959        /* Set the UART DMA transfer complete callback */
;;;960        huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
;;;961        
;;;962        /* Set the UART DMA Half transfer complete callback */
;;;963        huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
;;;964        
;;;965        /* Set the DMA error callback */
;;;966        huart->hdmarx->XferErrorCallback = UART_DMAError;
;;;967        
;;;968        /* Set the DMA abort callback */
;;;969        huart->hdmarx->XferAbortCallback = NULL;
;;;970    
;;;971        /* Enable the DMA Stream */
;;;972        tmp = (uint32_t*)&pData;
;;;973        HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->DR, *(uint32_t*)tmp, Size);
;;;974    
;;;975        /* Clear the Overrun flag just before enabling the DMA Rx request: can be mandatory for the second transfer */
;;;976        __HAL_UART_CLEAR_OREFLAG(huart);
;;;977    
;;;978        /* Process Unlocked */
;;;979        __HAL_UNLOCK(huart);
;;;980    
;;;981        /* Enable the UART Parity Error Interrupt */
;;;982        SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;983    
;;;984        /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;985        SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;986        
;;;987        /* Enable the DMA transfer for the receiver request by setting the DMAR bit 
;;;988        in the UART CR3 register */
;;;989        SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;990    
;;;991        return HAL_OK;
;;;992      }
;;;993      else
;;;994      {
;;;995        return HAL_BUSY; 
;;;996      }
;;;997    }
000012  bd38              POPEQ    {r3-r5,pc}
000014  6ba0              LDR      r0,[r4,#0x38]         ;951
000016  2801              CMP      r0,#1                 ;951
000018  d031              BEQ      |L30.126|
00001a  2001              MOVS     r0,#1                 ;951
00001c  62a1              STR      r1,[r4,#0x28]         ;954
00001e  63a0              STR      r0,[r4,#0x38]         ;954
000020  85a2              STRH     r2,[r4,#0x2c]         ;954
000022  2500              MOVS     r5,#0                 ;956
000024  6465              STR      r5,[r4,#0x44]         ;956
000026  2022              MOVS     r0,#0x22              ;957
000028  6420              STR      r0,[r4,#0x40]         ;957
00002a  6b63              LDR      r3,[r4,#0x34]         ;960
00002c  4815              LDR      r0,|L30.132|
00002e  6418              STR      r0,[r3,#0x40]         ;963
000030  6b63              LDR      r3,[r4,#0x34]         ;963
000032  4815              LDR      r0,|L30.136|
000034  6458              STR      r0,[r3,#0x44]         ;966
000036  6b63              LDR      r3,[r4,#0x34]         ;966
000038  4814              LDR      r0,|L30.140|
00003a  6518              STR      r0,[r3,#0x50]         ;969
00003c  6b60              LDR      r0,[r4,#0x34]         ;969
00003e  4613              MOV      r3,r2                 ;973
000040  6545              STR      r5,[r0,#0x54]         ;969
000042  4608              MOV      r0,r1                 ;969
000044  f8d4c034          LDR      r12,[r4,#0x34]        ;973
000048  6821              LDR      r1,[r4,#0]            ;973
00004a  4602              MOV      r2,r0                 ;973
00004c  4660              MOV      r0,r12                ;973
00004e  1d09              ADDS     r1,r1,#4              ;973
000050  f7fffffe          BL       HAL_DMA_Start_IT
000054  6820              LDR      r0,[r4,#0]            ;976
000056  6801              LDR      r1,[r0,#0]            ;976
000058  6841              LDR      r1,[r0,#4]            ;976
00005a  9100              STR      r1,[sp,#0]            ;979
00005c  63a5              STR      r5,[r4,#0x38]         ;982
00005e  68c1              LDR      r1,[r0,#0xc]          ;982
000060  f4417180          ORR      r1,r1,#0x100          ;982
000064  60c1              STR      r1,[r0,#0xc]          ;982
000066  6820              LDR      r0,[r4,#0]            ;985
000068  6941              LDR      r1,[r0,#0x14]         ;985
00006a  f0410101          ORR      r1,r1,#1              ;985
00006e  6141              STR      r1,[r0,#0x14]         ;985
000070  6820              LDR      r0,[r4,#0]            ;989
000072  6941              LDR      r1,[r0,#0x14]         ;989
000074  f0410140          ORR      r1,r1,#0x40           ;989
000078  6141              STR      r1,[r0,#0x14]         ;989
00007a  2000              MOVS     r0,#0                 ;991
00007c  bd38              POP      {r3-r5,pc}
                  |L30.126|
00007e  2002              MOVS     r0,#2                 ;995
000080  bd38              POP      {r3-r5,pc}
;;;998        
                          ENDP

000082  0000              DCW      0x0000
                  |L30.132|
                          DCD      UART_DMAReceiveCplt
                  |L30.136|
                          DCD      UART_DMARxHalfCplt
                  |L30.140|
                          DCD      UART_DMAError

                          AREA ||i.HAL_UART_Receive_IT||, CODE, READONLY, ALIGN=1

                  HAL_UART_Receive_IT PROC
;;;827      */
;;;828    HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  6c03              LDR      r3,[r0,#0x40]
;;;829    {
;;;830      /* Check that a Rx process is not already ongoing */ 
;;;831      if(huart->RxState == HAL_UART_STATE_READY)
000002  2b20              CMP      r3,#0x20
000004  d11b              BNE      |L31.62|
;;;832      {
;;;833        if((pData == NULL ) || (Size == 0)) 
000006  2900              CMP      r1,#0
000008  bf12              ITEE     NE
00000a  2a00              CMPNE    r2,#0
;;;834        {
;;;835          return HAL_ERROR;
00000c  2001              MOVEQ    r0,#1
;;;836        }
;;;837        
;;;838        /* Process Locked */
;;;839        __HAL_LOCK(huart);
;;;840        
;;;841        huart->pRxBuffPtr = pData;
;;;842        huart->RxXferSize = Size;
;;;843        huart->RxXferCount = Size;
;;;844        
;;;845        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;846        huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;847        
;;;848        /* Process Unlocked */
;;;849        __HAL_UNLOCK(huart);
;;;850            
;;;851        /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;852        SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;853    
;;;854        /* Enable the UART Parity Error and Data Register not empty Interrupts */
;;;855        SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE);
;;;856        
;;;857        return HAL_OK;
;;;858      }
;;;859      else
;;;860      {
;;;861        return HAL_BUSY; 
;;;862      }
;;;863    }
00000e  4770              BXEQ     lr
000010  6b83              LDR      r3,[r0,#0x38]         ;839
000012  2b01              CMP      r3,#1                 ;839
000014  d013              BEQ      |L31.62|
000016  6281              STR      r1,[r0,#0x28]         ;842
000018  8582              STRH     r2,[r0,#0x2c]         ;842
00001a  85c2              STRH     r2,[r0,#0x2e]         ;843
00001c  2100              MOVS     r1,#0                 ;845
00001e  6441              STR      r1,[r0,#0x44]         ;845
000020  2222              MOVS     r2,#0x22              ;846
000022  6402              STR      r2,[r0,#0x40]         ;846
000024  6381              STR      r1,[r0,#0x38]         ;852
000026  6801              LDR      r1,[r0,#0]            ;852
000028  694a              LDR      r2,[r1,#0x14]         ;852
00002a  f0420201          ORR      r2,r2,#1              ;852
00002e  614a              STR      r2,[r1,#0x14]         ;852
000030  6800              LDR      r0,[r0,#0]            ;855
000032  68c1              LDR      r1,[r0,#0xc]          ;855
000034  f4417190          ORR      r1,r1,#0x120          ;855
000038  60c1              STR      r1,[r0,#0xc]          ;855
00003a  2000              MOVS     r0,#0                 ;857
00003c  4770              BX       lr
                  |L31.62|
00003e  2002              MOVS     r0,#2                 ;861
000040  4770              BX       lr
;;;864    
                          ENDP


                          AREA ||i.HAL_UART_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxCpltCallback PROC
;;;1679     */
;;;1680   __weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1681   {
;;;1682     /* Prevent unused argument(s) compilation warning */
;;;1683     UNUSED(huart);
;;;1684     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1685              the HAL_UART_TxCpltCallback could be implemented in the user file
;;;1686      */
;;;1687   }
;;;1688   
                          ENDP


                          AREA ||i.HAL_UART_RxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxHalfCpltCallback PROC
;;;1694     */
;;;1695   __weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1696   {
;;;1697     /* Prevent unused argument(s) compilation warning */
;;;1698     UNUSED(huart);
;;;1699     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1700              the HAL_UART_TxCpltCallback could be implemented in the user file
;;;1701      */
;;;1702   }
;;;1703   
                          ENDP


                          AREA ||i.HAL_UART_Transmit||, CODE, READONLY, ALIGN=2

                  HAL_UART_Transmit PROC
;;;615      */
;;;616    HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;617    {
000004  4604              MOV      r4,r0
;;;618      uint16_t* tmp;
;;;619      uint32_t tickstart = 0U;
;;;620      
;;;621      /* Check that a Tx process is not already ongoing */
;;;622      if(huart->gState == HAL_UART_STATE_READY) 
000006  6bc0              LDR      r0,[r0,#0x3c]
000008  461d              MOV      r5,r3                 ;617
00000a  4617              MOV      r7,r2                 ;617
00000c  460e              MOV      r6,r1                 ;617
00000e  2820              CMP      r0,#0x20
000010  d17e              BNE      |L34.272|
;;;623      {
;;;624        if((pData == NULL ) || (Size == 0)) 
000012  2e00              CMP      r6,#0
000014  bf12              ITEE     NE
000016  2f00              CMPNE    r7,#0
;;;625        {
;;;626          return  HAL_ERROR;
000018  2001              MOVEQ    r0,#1
;;;627        }
;;;628        
;;;629        /* Process Locked */
;;;630        __HAL_LOCK(huart);
;;;631        
;;;632        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;633        huart->gState = HAL_UART_STATE_BUSY_TX;
;;;634    	
;;;635        /* Init tickstart for timeout managment */
;;;636        tickstart = HAL_GetTick();
;;;637    
;;;638        huart->TxXferSize = Size;
;;;639        huart->TxXferCount = Size;
;;;640        while(huart->TxXferCount > 0U)
;;;641        {
;;;642          huart->TxXferCount--;
;;;643          if(huart->Init.WordLength == UART_WORDLENGTH_9B)
;;;644          {
;;;645            if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;646            { 
;;;647              return HAL_TIMEOUT;
;;;648            }
;;;649            tmp = (uint16_t*) pData;
;;;650            huart->Instance->DR = (*tmp & (uint16_t)0x01FF);
;;;651            if(huart->Init.Parity == UART_PARITY_NONE)
;;;652            {
;;;653              pData +=2U;
;;;654            }
;;;655            else
;;;656            { 
;;;657              pData +=1U;
;;;658            }
;;;659          } 
;;;660          else
;;;661          {
;;;662            if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;663            {
;;;664              return HAL_TIMEOUT;
;;;665            }
;;;666            huart->Instance->DR = (*pData++ & (uint8_t)0xFF);
;;;667          } 
;;;668        }
;;;669        
;;;670        if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
;;;671        { 
;;;672          return HAL_TIMEOUT;
;;;673        }
;;;674        
;;;675        /* At end of Tx process, restore huart->gState to Ready */
;;;676          huart->gState = HAL_UART_STATE_READY;
;;;677        
;;;678        /* Process Unlocked */
;;;679        __HAL_UNLOCK(huart);
;;;680        
;;;681        return HAL_OK;
;;;682      }
;;;683      else
;;;684      {
;;;685        return HAL_BUSY;
;;;686      }
;;;687    }
00001a  e8bd8ff8          POPEQ    {r3-r11,pc}
00001e  6ba0              LDR      r0,[r4,#0x38]         ;630
000020  2801              CMP      r0,#1                 ;630
000022  d07b              BEQ      |L34.284|
000024  f04f0a00          MOV      r10,#0                ;632
000028  2001              MOVS     r0,#1                 ;630
00002a  f8c4a044          STR      r10,[r4,#0x44]        ;632
00002e  63a0              STR      r0,[r4,#0x38]         ;632
000030  2021              MOVS     r0,#0x21              ;633
000032  63e0              STR      r0,[r4,#0x3c]         ;633
000034  f7fffffe          BL       HAL_GetTick
000038  84a7              STRH     r7,[r4,#0x24]         ;638
00003a  4680              MOV      r8,r0                 ;636
00003c  84e7              STRH     r7,[r4,#0x26]         ;639
00003e  8ce0              LDRH     r0,[r4,#0x26]         ;640
000040  f04f0920          MOV      r9,#0x20              ;640
000044  2800              CMP      r0,#0                 ;640
000046  d054              BEQ      |L34.242|
                  |L34.72|
000048  8ce0              LDRH     r0,[r4,#0x26]         ;642
00004a  1e40              SUBS     r0,r0,#1              ;642
00004c  84e0              STRH     r0,[r4,#0x26]         ;642
00004e  68a0              LDR      r0,[r4,#8]            ;643
000050  f04f0780          MOV      r7,#0x80              ;662
000054  f5b05f80          CMP      r0,#0x1000            ;643
000058  6820              LDR      r0,[r4,#0]            ;643
00005a  6800              LDR      r0,[r0,#0]            ;643
00005c  ea270000          BIC      r0,r7,r0              ;643
000060  d01f              BEQ      |L34.162|
000062  2800              CMP      r0,#0                 ;643
000064  d03e              BEQ      |L34.228|
000066  bf00              NOP                            ;643
                  |L34.104|
000068  f1b53fff          CMP      r5,#0xffffffff        ;643
00006c  d035              BEQ      |L34.218|
00006e  b12d              CBZ      r5,|L34.124|
000070  f7fffffe          BL       HAL_GetTick
000074  eba00108          SUB      r1,r0,r8              ;643
000078  42a9              CMP      r1,r5                 ;643
00007a  d92e              BLS      |L34.218|
                  |L34.124|
00007c  6820              LDR      r0,[r4,#0]            ;643
00007e  68c1              LDR      r1,[r0,#0xc]          ;643
000080  f42171d0          BIC      r1,r1,#0x1a0          ;643
000084  60c1              STR      r1,[r0,#0xc]          ;643
000086  6820              LDR      r0,[r4,#0]            ;643
000088  6941              LDR      r1,[r0,#0x14]         ;643
00008a  f0210101          BIC      r1,r1,#1              ;643
00008e  6141              STR      r1,[r0,#0x14]         ;643
000090  f8c4903c          STR      r9,[r4,#0x3c]         ;643
000094  f8c49040          STR      r9,[r4,#0x40]         ;643
000098  2003              MOVS     r0,#3                 ;664
00009a  f8c4a038          STR      r10,[r4,#0x38]        ;664
00009e  e8bd8ff8          POP      {r3-r11,pc}
                  |L34.162|
0000a2  b178              CBZ      r0,|L34.196|
                  |L34.164|
0000a4  f1b53fff          CMP      r5,#0xffffffff
0000a8  d007              BEQ      |L34.186|
0000aa  2d00              CMP      r5,#0
0000ac  d0e6              BEQ      |L34.124|
0000ae  f7fffffe          BL       HAL_GetTick
0000b2  eba00108          SUB      r1,r0,r8
0000b6  42a9              CMP      r1,r5
0000b8  d8e0              BHI      |L34.124|
                  |L34.186|
0000ba  6820              LDR      r0,[r4,#0]
0000bc  6800              LDR      r0,[r0,#0]
0000be  ea370000          BICS     r0,r7,r0
0000c2  d1ef              BNE      |L34.164|
                  |L34.196|
0000c4  8830              LDRH     r0,[r6,#0]            ;650
0000c6  6821              LDR      r1,[r4,#0]            ;650
0000c8  f3c00008          UBFX     r0,r0,#0,#9           ;650
0000cc  6048              STR      r0,[r1,#4]            ;650
0000ce  6920              LDR      r0,[r4,#0x10]         ;651
0000d0  2800              CMP      r0,#0                 ;651
0000d2  bf0c              ITE      EQ                    ;651
0000d4  1cb6              ADDEQ    r6,r6,#2              ;651
0000d6  1c76              ADDNE    r6,r6,#1              ;651
0000d8  e008              B        |L34.236|
                  |L34.218|
0000da  6820              LDR      r0,[r4,#0]            ;651
0000dc  6800              LDR      r0,[r0,#0]            ;651
0000de  ea370000          BICS     r0,r7,r0              ;651
0000e2  d1c1              BNE      |L34.104|
                  |L34.228|
0000e4  6821              LDR      r1,[r4,#0]            ;666
0000e6  f8160b01          LDRB     r0,[r6],#1            ;666
0000ea  6048              STR      r0,[r1,#4]            ;666
                  |L34.236|
0000ec  8ce0              LDRH     r0,[r4,#0x26]         ;666
0000ee  2800              CMP      r0,#0                 ;666
0000f0  d1aa              BNE      |L34.72|
                  |L34.242|
0000f2  4643              MOV      r3,r8                 ;670
0000f4  2200              MOVS     r2,#0                 ;670
0000f6  2140              MOVS     r1,#0x40              ;670
0000f8  4620              MOV      r0,r4                 ;670
0000fa  9500              STR      r5,[sp,#0]            ;670
0000fc  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
000100  2800              CMP      r0,#0                 ;670
000102  bf1c              ITT      NE                    ;672
000104  2003              MOVNE    r0,#3                 ;672
000106  e8bd8ff8          POPNE    {r3-r11,pc}
00010a  f8c4903c          STR      r9,[r4,#0x3c]         ;676
00010e  e000              B        |L34.274|
                  |L34.272|
000110  e004              B        |L34.284|
                  |L34.274|
000112  2000              MOVS     r0,#0                 ;681
000114  f8c4a038          STR      r10,[r4,#0x38]        ;681
000118  e8bd8ff8          POP      {r3-r11,pc}
                  |L34.284|
00011c  2002              MOVS     r0,#2                 ;685
00011e  e8bd8ff8          POP      {r3-r11,pc}
;;;688    
                          ENDP


                          AREA ||i.HAL_UART_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Transmit_DMA PROC
;;;872      */
;;;873    HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;874    {
000002  4604              MOV      r4,r0
;;;875      uint32_t *tmp;
;;;876      
;;;877      /* Check that a Tx process is not already ongoing */
;;;878      if(huart->gState == HAL_UART_STATE_READY)
000004  6bc0              LDR      r0,[r0,#0x3c]
000006  2820              CMP      r0,#0x20
000008  d12f              BNE      |L35.106|
;;;879      {
;;;880        if((pData == NULL ) || (Size == 0))
00000a  2900              CMP      r1,#0
00000c  bf12              ITEE     NE
00000e  2a00              CMPNE    r2,#0
;;;881        {
;;;882          return HAL_ERROR;
000010  2001              MOVEQ    r0,#1
;;;883        }
;;;884    
;;;885        /* Process Locked */
;;;886        __HAL_LOCK(huart);
;;;887    
;;;888        huart->pTxBuffPtr = pData;
;;;889        huart->TxXferSize = Size;
;;;890        huart->TxXferCount = Size;
;;;891    
;;;892        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;893        huart->gState = HAL_UART_STATE_BUSY_TX;
;;;894    
;;;895        /* Set the UART DMA transfer complete callback */
;;;896        huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
;;;897    
;;;898        /* Set the UART DMA Half transfer complete callback */
;;;899        huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
;;;900    
;;;901        /* Set the DMA error callback */
;;;902        huart->hdmatx->XferErrorCallback = UART_DMAError;
;;;903    
;;;904        /* Set the DMA abort callback */
;;;905        huart->hdmatx->XferAbortCallback = NULL;
;;;906    
;;;907        /* Enable the UART transmit DMA Stream */
;;;908        tmp = (uint32_t*)&pData;
;;;909        HAL_DMA_Start_IT(huart->hdmatx, *(uint32_t*)tmp, (uint32_t)&huart->Instance->DR, Size);
;;;910        
;;;911        /* Clear the TC flag in the SR register by writing 0 to it */
;;;912        __HAL_UART_CLEAR_FLAG(huart, UART_FLAG_TC);
;;;913        
;;;914        /* Process Unlocked */
;;;915        __HAL_UNLOCK(huart);
;;;916        
;;;917        /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;918           in the UART CR3 register */
;;;919        SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;920        
;;;921        return HAL_OK;
;;;922      }
;;;923      else
;;;924      {
;;;925        return HAL_BUSY;
;;;926      }
;;;927    }
000012  bd70              POPEQ    {r4-r6,pc}
000014  6ba0              LDR      r0,[r4,#0x38]         ;886
000016  2801              CMP      r0,#1                 ;886
000018  d027              BEQ      |L35.106|
00001a  2001              MOVS     r0,#1                 ;886
00001c  6221              STR      r1,[r4,#0x20]         ;889
00001e  63a0              STR      r0,[r4,#0x38]         ;889
000020  84a2              STRH     r2,[r4,#0x24]         ;889
000022  84e2              STRH     r2,[r4,#0x26]         ;890
000024  2500              MOVS     r5,#0                 ;892
000026  6465              STR      r5,[r4,#0x44]         ;892
000028  2021              MOVS     r0,#0x21              ;893
00002a  63e0              STR      r0,[r4,#0x3c]         ;893
00002c  6b23              LDR      r3,[r4,#0x30]         ;896
00002e  4810              LDR      r0,|L35.112|
000030  6418              STR      r0,[r3,#0x40]         ;899
000032  6b23              LDR      r3,[r4,#0x30]         ;899
000034  480f              LDR      r0,|L35.116|
000036  6458              STR      r0,[r3,#0x44]         ;902
000038  6b23              LDR      r3,[r4,#0x30]         ;902
00003a  480f              LDR      r0,|L35.120|
00003c  6518              STR      r0,[r3,#0x50]         ;905
00003e  6b20              LDR      r0,[r4,#0x30]         ;905
000040  4613              MOV      r3,r2                 ;909
000042  6545              STR      r5,[r0,#0x54]         ;909
000044  6820              LDR      r0,[r4,#0]            ;909
000046  f1000c04          ADD      r12,r0,#4             ;909
00004a  4662              MOV      r2,r12                ;909
00004c  6b20              LDR      r0,[r4,#0x30]         ;909
00004e  f7fffffe          BL       HAL_DMA_Start_IT
000052  6821              LDR      r1,[r4,#0]            ;912
000054  f06f0040          MVN      r0,#0x40              ;912
000058  6008              STR      r0,[r1,#0]            ;912
00005a  63a5              STR      r5,[r4,#0x38]         ;919
00005c  6820              LDR      r0,[r4,#0]            ;919
00005e  6941              LDR      r1,[r0,#0x14]         ;919
000060  f0410180          ORR      r1,r1,#0x80           ;919
000064  6141              STR      r1,[r0,#0x14]         ;919
000066  2000              MOVS     r0,#0                 ;921
000068  bd70              POP      {r4-r6,pc}
                  |L35.106|
00006a  2002              MOVS     r0,#2                 ;925
00006c  bd70              POP      {r4-r6,pc}
;;;928    
                          ENDP

00006e  0000              DCW      0x0000
                  |L35.112|
                          DCD      UART_DMATransmitCplt
                  |L35.116|
                          DCD      UART_DMATxHalfCplt
                  |L35.120|
                          DCD      UART_DMAError

                          AREA ||i.HAL_UART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  HAL_UART_Transmit_IT PROC
;;;785      */
;;;786    HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  6bc3              LDR      r3,[r0,#0x3c]
;;;787    {
;;;788      /* Check that a Tx process is not already ongoing */
;;;789      if(huart->gState == HAL_UART_STATE_READY)
000002  2b20              CMP      r3,#0x20
000004  d116              BNE      |L36.52|
;;;790      {
;;;791        if((pData == NULL ) || (Size == 0)) 
000006  2900              CMP      r1,#0
000008  bf12              ITEE     NE
00000a  2a00              CMPNE    r2,#0
;;;792        {
;;;793          return HAL_ERROR;
00000c  2001              MOVEQ    r0,#1
;;;794        }
;;;795        
;;;796        /* Process Locked */
;;;797        __HAL_LOCK(huart);
;;;798        
;;;799        huart->pTxBuffPtr = pData;
;;;800        huart->TxXferSize = Size;
;;;801        huart->TxXferCount = Size;
;;;802    
;;;803        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;804        huart->gState = HAL_UART_STATE_BUSY_TX;
;;;805    
;;;806        /* Process Unlocked */
;;;807        __HAL_UNLOCK(huart);
;;;808    
;;;809        /* Enable the UART Transmit data register empty Interrupt */
;;;810        SET_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
;;;811        
;;;812        return HAL_OK;
;;;813      }
;;;814      else
;;;815      {
;;;816        return HAL_BUSY;   
;;;817      }
;;;818    }
00000e  4770              BXEQ     lr
000010  6b83              LDR      r3,[r0,#0x38]         ;797
000012  2b01              CMP      r3,#1                 ;797
000014  d00e              BEQ      |L36.52|
000016  6201              STR      r1,[r0,#0x20]         ;800
000018  8482              STRH     r2,[r0,#0x24]         ;800
00001a  84c2              STRH     r2,[r0,#0x26]         ;801
00001c  2100              MOVS     r1,#0                 ;803
00001e  6441              STR      r1,[r0,#0x44]         ;803
000020  2221              MOVS     r2,#0x21              ;804
000022  63c2              STR      r2,[r0,#0x3c]         ;804
000024  6381              STR      r1,[r0,#0x38]         ;810
000026  6800              LDR      r0,[r0,#0]            ;810
000028  68c1              LDR      r1,[r0,#0xc]          ;810
00002a  f0410180          ORR      r1,r1,#0x80           ;810
00002e  60c1              STR      r1,[r0,#0xc]          ;810
000030  2000              MOVS     r0,#0                 ;812
000032  4770              BX       lr
                  |L36.52|
000034  2002              MOVS     r0,#2                 ;816
000036  4770              BX       lr
;;;819    
                          ENDP


                          AREA ||i.HAL_UART_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxCpltCallback PROC
;;;1649     */
;;;1650    __weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1651   {
;;;1652     /* Prevent unused argument(s) compilation warning */
;;;1653     UNUSED(huart);
;;;1654     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1655              the HAL_UART_TxCpltCallback could be implemented in the user file
;;;1656      */ 
;;;1657   }
;;;1658   
                          ENDP


                          AREA ||i.HAL_UART_TxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxHalfCpltCallback PROC
;;;1664     */
;;;1665    __weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1666   {
;;;1667     /* Prevent unused argument(s) compilation warning */
;;;1668     UNUSED(huart);
;;;1669     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1670              the HAL_UART_TxCpltCallback could be implemented in the user file
;;;1671      */ 
;;;1672   }
;;;1673   
                          ENDP


                          AREA ||i.UART_DMAAbortOnError||, CODE, READONLY, ALIGN=1

                  UART_DMAAbortOnError PROC
;;;2170     */
;;;2171   static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2172   {
;;;2173     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6bc0              LDR      r0,[r0,#0x3c]
;;;2174     huart->RxXferCount = 0U;
000004  2100              MOVS     r1,#0
000006  85c1              STRH     r1,[r0,#0x2e]
;;;2175     huart->TxXferCount = 0U;
000008  84c1              STRH     r1,[r0,#0x26]
;;;2176   
;;;2177     HAL_UART_ErrorCallback(huart);
00000a  f7fffffe          BL       HAL_UART_ErrorCallback
;;;2178   }
00000e  bd10              POP      {r4,pc}
;;;2179   
                          ENDP


                          AREA ||i.UART_DMAError||, CODE, READONLY, ALIGN=1

                  UART_DMAError PROC
;;;2072     */
;;;2073   static void UART_DMAError(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2074   {
;;;2075     uint32_t dmarequest = 0x00U;
;;;2076     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6bc0              LDR      r0,[r0,#0x3c]
;;;2077   
;;;2078     /* Stop UART DMA Tx request if ongoing */
;;;2079     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
000004  6801              LDR      r1,[r0,#0]
000006  6949              LDR      r1,[r1,#0x14]
;;;2080     if((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
000008  f8d0c03c          LDR      r12,[r0,#0x3c]
00000c  f3c111c0          UBFX     r1,r1,#7,#1           ;2079
000010  2200              MOVS     r2,#0
000012  2320              MOVS     r3,#0x20
000014  f1bc0f21          CMP      r12,#0x21
000018  d109              BNE      |L40.46|
00001a  b141              CBZ      r1,|L40.46|
;;;2081     {
;;;2082       huart->TxXferCount = 0U;
00001c  84c2              STRH     r2,[r0,#0x26]
00001e  6801              LDR      r1,[r0,#0]
000020  f8d1c00c          LDR      r12,[r1,#0xc]
000024  f02c0cc0          BIC      r12,r12,#0xc0
000028  f8c1c00c          STR      r12,[r1,#0xc]
00002c  63c3              STR      r3,[r0,#0x3c]
                  |L40.46|
;;;2083       UART_EndTxTransfer(huart);
;;;2084     }
;;;2085   
;;;2086     /* Stop UART DMA Rx request if ongoing */
;;;2087     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR); 
00002e  6801              LDR      r1,[r0,#0]
000030  f8d1c014          LDR      r12,[r1,#0x14]
;;;2088     if((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
000034  6c04              LDR      r4,[r0,#0x40]
000036  f3cc1c80          UBFX     r12,r12,#6,#1         ;2087
00003a  2c22              CMP      r4,#0x22
00003c  d10d              BNE      |L40.90|
00003e  f1bc0f00          CMP      r12,#0
000042  d00a              BEQ      |L40.90|
;;;2089     {
;;;2090       huart->RxXferCount = 0U;
000044  85c2              STRH     r2,[r0,#0x2e]
000046  68ca              LDR      r2,[r1,#0xc]
000048  f4227290          BIC      r2,r2,#0x120
00004c  60ca              STR      r2,[r1,#0xc]
00004e  6801              LDR      r1,[r0,#0]
000050  694a              LDR      r2,[r1,#0x14]
000052  f0220201          BIC      r2,r2,#1
000056  614a              STR      r2,[r1,#0x14]
000058  6403              STR      r3,[r0,#0x40]
                  |L40.90|
;;;2091       UART_EndRxTransfer(huart);
;;;2092     }
;;;2093   
;;;2094     huart->ErrorCode |= HAL_UART_ERROR_DMA;
00005a  6c41              LDR      r1,[r0,#0x44]
00005c  f0410110          ORR      r1,r1,#0x10
000060  6441              STR      r1,[r0,#0x44]
;;;2095     HAL_UART_ErrorCallback(huart);
000062  f7fffffe          BL       HAL_UART_ErrorCallback
;;;2096   }
000066  bd10              POP      {r4,pc}
;;;2097   
                          ENDP


                          AREA ||i.UART_DMAReceiveCplt||, CODE, READONLY, ALIGN=1

                  UART_DMAReceiveCplt PROC
;;;2032     */
;;;2033   static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2034   {
000002  4601              MOV      r1,r0
;;;2035     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6bc0              LDR      r0,[r0,#0x3c]
;;;2036     /* DMA Normal mode*/
;;;2037     if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
000006  6809              LDR      r1,[r1,#0]
000008  6809              LDR      r1,[r1,#0]
00000a  f4117f80          TST      r1,#0x100
00000e  d112              BNE      |L41.54|
;;;2038     {
;;;2039       huart->RxXferCount = 0U;
000010  2100              MOVS     r1,#0
000012  85c1              STRH     r1,[r0,#0x2e]
;;;2040     
;;;2041       /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;2042       CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
000014  6801              LDR      r1,[r0,#0]
000016  68ca              LDR      r2,[r1,#0xc]
000018  f4227280          BIC      r2,r2,#0x100
00001c  60ca              STR      r2,[r1,#0xc]
;;;2043       CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00001e  6801              LDR      r1,[r0,#0]
000020  694a              LDR      r2,[r1,#0x14]
000022  f0220201          BIC      r2,r2,#1
000026  614a              STR      r2,[r1,#0x14]
;;;2044       
;;;2045       /* Disable the DMA transfer for the receiver request by setting the DMAR bit 
;;;2046          in the UART CR3 register */
;;;2047       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000028  6801              LDR      r1,[r0,#0]
00002a  694a              LDR      r2,[r1,#0x14]
00002c  f0220240          BIC      r2,r2,#0x40
000030  614a              STR      r2,[r1,#0x14]
;;;2048   	
;;;2049       /* At end of Rx process, restore huart->RxState to Ready */
;;;2050       huart->RxState = HAL_UART_STATE_READY;
000032  2120              MOVS     r1,#0x20
000034  6401              STR      r1,[r0,#0x40]
                  |L41.54|
;;;2051     }
;;;2052     HAL_UART_RxCpltCallback(huart);
000036  f7fffffe          BL       HAL_UART_RxCpltCallback
;;;2053   }
00003a  bd10              POP      {r4,pc}
;;;2054   
                          ENDP


                          AREA ||i.UART_DMARxAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMARxAbortCallback PROC
;;;2225     */
;;;2226   static void UART_DMARxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2227   {
;;;2228     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6bc0              LDR      r0,[r0,#0x3c]
;;;2229     
;;;2230     huart->hdmarx->XferAbortCallback = NULL;
000004  2100              MOVS     r1,#0
000006  6b42              LDR      r2,[r0,#0x34]
;;;2231   
;;;2232     /* Check if an Abort process is still ongoing */
;;;2233     if(huart->hdmatx != NULL)
000008  6551              STR      r1,[r2,#0x54]
00000a  6b02              LDR      r2,[r0,#0x30]
00000c  2a00              CMP      r2,#0
;;;2234     {
;;;2235       if(huart->hdmatx->XferAbortCallback != NULL)
00000e  bf1e              ITTT     NE
000010  6d52              LDRNE    r2,[r2,#0x54]
000012  2a00              CMPNE    r2,#0
;;;2236       {
;;;2237         return;
;;;2238       }
;;;2239     }
;;;2240     
;;;2241     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;2242     huart->TxXferCount = 0x00U;
;;;2243     huart->RxXferCount = 0x00U;
;;;2244   
;;;2245     /* Reset ErrorCode */
;;;2246     huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;2247   
;;;2248     /* Restore huart->gState and huart->RxState to Ready */
;;;2249     huart->gState  = HAL_UART_STATE_READY;
;;;2250     huart->RxState = HAL_UART_STATE_READY;
;;;2251   
;;;2252     /* Call user Abort complete callback */
;;;2253     HAL_UART_AbortCpltCallback(huart);
;;;2254   }
000014  bd10              POPNE    {r4,pc}
000016  84c1              STRH     r1,[r0,#0x26]         ;2242
000018  85c1              STRH     r1,[r0,#0x2e]         ;2243
00001a  6441              STR      r1,[r0,#0x44]         ;2246
00001c  2120              MOVS     r1,#0x20              ;2249
00001e  63c1              STR      r1,[r0,#0x3c]         ;2249
000020  6401              STR      r1,[r0,#0x40]         ;2250
000022  f7fffffe          BL       HAL_UART_AbortCpltCallback
000026  bd10              POP      {r4,pc}
;;;2255   
                          ENDP


                          AREA ||i.UART_DMARxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMARxHalfCplt PROC
;;;2060     */
;;;2061   static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2062   {
;;;2063     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000002  6bc0              LDR      r0,[r0,#0x3c]
;;;2064   
;;;2065     HAL_UART_RxHalfCpltCallback(huart); 
000004  f7fffffe          BL       HAL_UART_RxHalfCpltCallback
;;;2066   }
000008  bd10              POP      {r4,pc}
;;;2067   
                          ENDP


                          AREA ||i.UART_DMARxOnlyAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMARxOnlyAbortCallback PROC
;;;2284     */
;;;2285   static void UART_DMARxOnlyAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2286   {
;;;2287     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6bc0              LDR      r0,[r0,#0x3c]
;;;2288   
;;;2289     huart->RxXferCount = 0x00U;
000004  2100              MOVS     r1,#0
000006  85c1              STRH     r1,[r0,#0x2e]
;;;2290   
;;;2291     /* Restore huart->RxState to Ready */
;;;2292     huart->RxState = HAL_UART_STATE_READY;
000008  2120              MOVS     r1,#0x20
00000a  6401              STR      r1,[r0,#0x40]
;;;2293   
;;;2294     /* Call user Abort complete callback */
;;;2295     HAL_UART_AbortReceiveCpltCallback(huart);
00000c  f7fffffe          BL       HAL_UART_AbortReceiveCpltCallback
;;;2296   }
000010  bd10              POP      {r4,pc}
;;;2297   
                          ENDP


                          AREA ||i.UART_DMATransmitCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATransmitCplt PROC
;;;1991     */
;;;1992   static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1993   {
000002  4601              MOV      r1,r0
;;;1994     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6bc0              LDR      r0,[r0,#0x3c]
;;;1995     /* DMA Normal mode*/
;;;1996     if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
000006  6809              LDR      r1,[r1,#0]
000008  6809              LDR      r1,[r1,#0]
00000a  f4117f80          TST      r1,#0x100
00000e  d002              BEQ      |L45.22|
;;;1997     {
;;;1998       huart->TxXferCount = 0U;
;;;1999   
;;;2000       /* Disable the DMA transfer for transmit request by setting the DMAT bit
;;;2001          in the UART CR3 register */
;;;2002       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;2003   
;;;2004       /* Enable the UART Transmit Complete Interrupt */
;;;2005       SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
;;;2006   
;;;2007     }
;;;2008     /* DMA Circular mode */
;;;2009     else
;;;2010     {
;;;2011       HAL_UART_TxCpltCallback(huart);
000010  f7fffffe          BL       HAL_UART_TxCpltCallback
;;;2012     }
;;;2013   }
000014  bd10              POP      {r4,pc}
                  |L45.22|
000016  2100              MOVS     r1,#0                 ;1998
000018  84c1              STRH     r1,[r0,#0x26]         ;1998
00001a  6801              LDR      r1,[r0,#0]            ;2002
00001c  694a              LDR      r2,[r1,#0x14]         ;2002
00001e  f0220280          BIC      r2,r2,#0x80           ;2002
000022  614a              STR      r2,[r1,#0x14]         ;2002
000024  6800              LDR      r0,[r0,#0]            ;2005
000026  68c1              LDR      r1,[r0,#0xc]          ;2005
000028  f0410140          ORR      r1,r1,#0x40           ;2005
00002c  60c1              STR      r1,[r0,#0xc]          ;2005
00002e  bd10              POP      {r4,pc}
;;;2014   
                          ENDP


                          AREA ||i.UART_DMATxAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMATxAbortCallback PROC
;;;2187     */
;;;2188   static void UART_DMATxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2189   {
;;;2190     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6bc0              LDR      r0,[r0,#0x3c]
;;;2191     
;;;2192     huart->hdmatx->XferAbortCallback = NULL;
000004  2100              MOVS     r1,#0
000006  6b02              LDR      r2,[r0,#0x30]
;;;2193   
;;;2194     /* Check if an Abort process is still ongoing */
;;;2195     if(huart->hdmarx != NULL)
000008  6551              STR      r1,[r2,#0x54]
00000a  6b42              LDR      r2,[r0,#0x34]
00000c  2a00              CMP      r2,#0
;;;2196     {
;;;2197       if(huart->hdmarx->XferAbortCallback != NULL)
00000e  bf1e              ITTT     NE
000010  6d52              LDRNE    r2,[r2,#0x54]
000012  2a00              CMPNE    r2,#0
;;;2198       {
;;;2199         return;
;;;2200       }
;;;2201     }
;;;2202   
;;;2203     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;2204     huart->TxXferCount = 0x00U;
;;;2205     huart->RxXferCount = 0x00U;
;;;2206   
;;;2207     /* Reset ErrorCode */
;;;2208     huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;2209   
;;;2210     /* Restore huart->gState and huart->RxState to Ready */
;;;2211     huart->gState  = HAL_UART_STATE_READY;
;;;2212     huart->RxState = HAL_UART_STATE_READY;
;;;2213   
;;;2214     /* Call user Abort complete callback */
;;;2215     HAL_UART_AbortCpltCallback(huart);
;;;2216   }
000014  bd10              POPNE    {r4,pc}
000016  84c1              STRH     r1,[r0,#0x26]         ;2204
000018  85c1              STRH     r1,[r0,#0x2e]         ;2205
00001a  6441              STR      r1,[r0,#0x44]         ;2208
00001c  2120              MOVS     r1,#0x20              ;2211
00001e  63c1              STR      r1,[r0,#0x3c]         ;2211
000020  6401              STR      r1,[r0,#0x40]         ;2212
000022  f7fffffe          BL       HAL_UART_AbortCpltCallback
000026  bd10              POP      {r4,pc}
;;;2217   
                          ENDP


                          AREA ||i.UART_DMATxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATxHalfCplt PROC
;;;2020     */
;;;2021   static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2022   {
;;;2023     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000002  6bc0              LDR      r0,[r0,#0x3c]
;;;2024   
;;;2025     HAL_UART_TxHalfCpltCallback(huart);
000004  f7fffffe          BL       HAL_UART_TxHalfCpltCallback
;;;2026   }
000008  bd10              POP      {r4,pc}
;;;2027   
                          ENDP


                          AREA ||i.UART_DMATxOnlyAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMATxOnlyAbortCallback PROC
;;;2263     */
;;;2264   static void UART_DMATxOnlyAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2265   {
;;;2266     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6bc0              LDR      r0,[r0,#0x3c]
;;;2267   
;;;2268     huart->TxXferCount = 0x00U;
000004  2100              MOVS     r1,#0
000006  84c1              STRH     r1,[r0,#0x26]
;;;2269   
;;;2270     /* Restore huart->gState to Ready */
;;;2271     huart->gState = HAL_UART_STATE_READY;
000008  2120              MOVS     r1,#0x20
00000a  63c1              STR      r1,[r0,#0x3c]
;;;2272   
;;;2273     /* Call user Abort complete callback */
;;;2274     HAL_UART_AbortTransmitCpltCallback(huart);
00000c  f7fffffe          BL       HAL_UART_AbortTransmitCpltCallback
;;;2275   }
000010  bd10              POP      {r4,pc}
;;;2276   
                          ENDP


                          AREA ||i.UART_SetConfig||, CODE, READONLY, ALIGN=2

                  UART_SetConfig PROC
;;;2431     */
;;;2432   static void UART_SetConfig(UART_HandleTypeDef *huart)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2433   {
000004  4604              MOV      r4,r0
;;;2434     uint32_t tmpreg = 0x00U;
;;;2435     
;;;2436     /* Check the parameters */
;;;2437     assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
;;;2438     assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
;;;2439     assert_param(IS_UART_PARITY(huart->Init.Parity));
;;;2440     assert_param(IS_UART_MODE(huart->Init.Mode));
;;;2441   
;;;2442     /*-------------------------- USART CR2 Configuration -----------------------*/
;;;2443     tmpreg = huart->Instance->CR2;
000006  6800              LDR      r0,[r0,#0]
000008  6901              LDR      r1,[r0,#0x10]
;;;2444   
;;;2445     /* Clear STOP[13:12] bits */
;;;2446     tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
;;;2447   
;;;2448     /* Configure the UART Stop Bits: Set STOP[13:12] bits according to huart->Init.StopBits value */
;;;2449     tmpreg |= (uint32_t)huart->Init.StopBits;
00000a  68e2              LDR      r2,[r4,#0xc]
00000c  f4215140          BIC      r1,r1,#0x3000         ;2446
000010  4311              ORRS     r1,r1,r2
;;;2450     
;;;2451     /* Write to USART CR2 */
;;;2452     WRITE_REG(huart->Instance->CR2, (uint32_t)tmpreg);
000012  6101              STR      r1,[r0,#0x10]
;;;2453   
;;;2454     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;2455     tmpreg = huart->Instance->CR1;
000014  6820              LDR      r0,[r4,#0]
000016  68c1              LDR      r1,[r0,#0xc]
;;;2456   
;;;2457     /* Clear M, PCE, PS, TE and RE bits */
;;;2458     tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | \
;;;2459                                      USART_CR1_RE | USART_CR1_OVER8));
;;;2460   
;;;2461     /* Configure the UART Word Length, Parity and mode: 
;;;2462        Set the M bits according to huart->Init.WordLength value 
;;;2463        Set PCE and PS bits according to huart->Init.Parity value
;;;2464        Set TE and RE bits according to huart->Init.Mode value
;;;2465        Set OVER8 bit according to huart->Init.OverSampling value */
;;;2466     tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
000018  6923              LDR      r3,[r4,#0x10]
00001a  68a2              LDR      r2,[r4,#8]
00001c  f8d4c01c          LDR      r12,[r4,#0x1c]
000020  431a              ORRS     r2,r2,r3
000022  6963              LDR      r3,[r4,#0x14]
000024  f4217103          BIC      r1,r1,#0x20c          ;2458
000028  ea43030c          ORR      r3,r3,r12
00002c  f4214114          BIC      r1,r1,#0x9400         ;2458
000030  431a              ORRS     r2,r2,r3
000032  4311              ORRS     r1,r1,r2
;;;2467     
;;;2468     /* Write to USART CR1 */
;;;2469     WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
000034  60c1              STR      r1,[r0,#0xc]
;;;2470     
;;;2471     /*-------------------------- USART CR3 Configuration -----------------------*/  
;;;2472     tmpreg = huart->Instance->CR3;
000036  6820              LDR      r0,[r4,#0]
000038  6941              LDR      r1,[r0,#0x14]
;;;2473     
;;;2474     /* Clear CTSE and RTSE bits */
;;;2475     tmpreg &= (uint32_t)~((uint32_t)(USART_CR3_RTSE | USART_CR3_CTSE));
;;;2476     
;;;2477     /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
;;;2478     tmpreg |= huart->Init.HwFlowCtl;
00003a  69a2              LDR      r2,[r4,#0x18]
00003c  f4217140          BIC      r1,r1,#0x300          ;2475
000040  4311              ORRS     r1,r1,r2
;;;2479     
;;;2480     /* Write to USART CR3 */
;;;2481     WRITE_REG(huart->Instance->CR3, (uint32_t)tmpreg);
000042  6141              STR      r1,[r0,#0x14]
;;;2482     
;;;2483     /* Check the Over Sampling */
;;;2484     if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
000044  69e2              LDR      r2,[r4,#0x1c]
;;;2485     {
;;;2486       /*-------------------------- USART BRR Configuration ---------------------*/
;;;2487   #if defined(USART6) 
;;;2488       if((huart->Instance == USART1) || (huart->Instance == USART6))
;;;2489       {
;;;2490         huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
000046  2632              MOVS     r6,#0x32
000048  f5b24f00          CMP      r2,#0x8000            ;2484
00004c  48ba              LDR      r0,|L49.824|
00004e  49bb              LDR      r1,|L49.828|
000050  4dbb              LDR      r5,|L49.832|
000052  6822              LDR      r2,[r4,#0]            ;2433
000054  d05d              BEQ      |L49.274|
;;;2491       }
;;;2492   #else
;;;2493       if(huart->Instance == USART1)
;;;2494       {
;;;2495         huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
;;;2496       }	
;;;2497   #endif /* USART6 */
;;;2498       else
;;;2499       {
;;;2500         huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
;;;2501       }
;;;2502     }
;;;2503     else
;;;2504     {
;;;2505       /*-------------------------- USART BRR Configuration ---------------------*/
;;;2506   #if defined(USART6) 
;;;2507       if((huart->Instance == USART1) || (huart->Instance == USART6))
000056  428a              CMP      r2,r1
000058  bf18              IT       NE
00005a  4282              CMPNE    r2,r0
00005c  f0408112          BNE.W    |L49.644|
;;;2508       {
;;;2509         huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
000060  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
000064  eb0001c0          ADD      r1,r0,r0,LSL #3
000068  eb011000          ADD      r0,r1,r0,LSL #4
00006c  6861              LDR      r1,[r4,#4]
00006e  0089              LSLS     r1,r1,#2
000070  fbb0f7f1          UDIV     r7,r0,r1
000074  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
000078  eb0001c0          ADD      r1,r0,r0,LSL #3
00007c  eb011000          ADD      r0,r1,r0,LSL #4
000080  6861              LDR      r1,[r4,#4]
000082  0089              LSLS     r1,r1,#2
000084  fbb0f0f1          UDIV     r0,r0,r1
000088  fba51000          UMULL    r1,r0,r5,r0
00008c  0940              LSRS     r0,r0,#5
00008e  f06f0118          MVN      r1,#0x18
000092  4348              MULS     r0,r1,r0
000094  eb070080          ADD      r0,r7,r0,LSL #2
000098  eb061000          ADD      r0,r6,r0,LSL #4
00009c  fba51000          UMULL    r1,r0,r5,r0
0000a0  0940              LSRS     r0,r0,#5
0000a2  f00007f0          AND      r7,r0,#0xf0
0000a6  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
0000aa  eb0001c0          ADD      r1,r0,r0,LSL #3
0000ae  eb011000          ADD      r0,r1,r0,LSL #4
0000b2  6861              LDR      r1,[r4,#4]
0000b4  0089              LSLS     r1,r1,#2
0000b6  fbb0f0f1          UDIV     r0,r0,r1
0000ba  fba51000          UMULL    r1,r0,r5,r0
0000be  0940              LSRS     r0,r0,#5
0000c0  eb071700          ADD      r7,r7,r0,LSL #4
0000c4  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
0000c8  eb0001c0          ADD      r1,r0,r0,LSL #3
0000cc  eb011000          ADD      r0,r1,r0,LSL #4
0000d0  6861              LDR      r1,[r4,#4]
0000d2  0089              LSLS     r1,r1,#2
0000d4  fbb0f8f1          UDIV     r8,r0,r1
0000d8  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
0000dc  eb0001c0          ADD      r1,r0,r0,LSL #3
0000e0  eb011000          ADD      r0,r1,r0,LSL #4
0000e4  6861              LDR      r1,[r4,#4]
0000e6  0089              LSLS     r1,r1,#2
0000e8  fbb0f0f1          UDIV     r0,r0,r1
0000ec  fba51000          UMULL    r1,r0,r5,r0
0000f0  0940              LSRS     r0,r0,#5
0000f2  f06f0118          MVN      r1,#0x18
0000f6  4348              MULS     r0,r1,r0
0000f8  eb080080          ADD      r0,r8,r0,LSL #2
0000fc  eb061000          ADD      r0,r6,r0,LSL #4
000100  fba51000          UMULL    r1,r0,r5,r0
000104  6821              LDR      r1,[r4,#0]
000106  f3c01043          UBFX     r0,r0,#5,#4
00010a  4438              ADD      r0,r0,r7
00010c  6088              STR      r0,[r1,#8]
;;;2510       }
;;;2511   #else
;;;2512       if(huart->Instance == USART1)
;;;2513       {
;;;2514         huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
;;;2515       }	
;;;2516   #endif /* USART6 */
;;;2517       else
;;;2518       {
;;;2519         huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
;;;2520       }
;;;2521     }
;;;2522   }
00010e  e8bd81f0          POP      {r4-r8,pc}
                  |L49.274|
000112  428a              CMP      r2,r1                 ;2488
000114  bf18              IT       NE                    ;2488
000116  4282              CMPNE    r2,r0                 ;2488
000118  d159              BNE      |L49.462|
00011a  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
00011e  eb0001c0          ADD      r1,r0,r0,LSL #3       ;2490
000122  eb011000          ADD      r0,r1,r0,LSL #4       ;2490
000126  6861              LDR      r1,[r4,#4]            ;2490
000128  0049              LSLS     r1,r1,#1              ;2490
00012a  fbb0f0f1          UDIV     r0,r0,r1              ;2490
00012e  fba51000          UMULL    r1,r0,r5,r0           ;2490
000132  0940              LSRS     r0,r0,#5              ;2490
000134  0107              LSLS     r7,r0,#4              ;2490
000136  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
00013a  eb0001c0          ADD      r1,r0,r0,LSL #3       ;2490
00013e  eb011000          ADD      r0,r1,r0,LSL #4       ;2490
000142  6861              LDR      r1,[r4,#4]            ;2490
000144  0049              LSLS     r1,r1,#1              ;2490
000146  fbb0f8f1          UDIV     r8,r0,r1              ;2490
00014a  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
00014e  eb0001c0          ADD      r1,r0,r0,LSL #3       ;2490
000152  eb011000          ADD      r0,r1,r0,LSL #4       ;2490
000156  6861              LDR      r1,[r4,#4]            ;2490
000158  0049              LSLS     r1,r1,#1              ;2490
00015a  fbb0f0f1          UDIV     r0,r0,r1              ;2490
00015e  fba51000          UMULL    r1,r0,r5,r0           ;2490
000162  0940              LSRS     r0,r0,#5              ;2490
000164  f06f0118          MVN      r1,#0x18              ;2490
000168  4348              MULS     r0,r1,r0              ;2490
00016a  eb080080          ADD      r0,r8,r0,LSL #2       ;2490
00016e  eb0600c0          ADD      r0,r6,r0,LSL #3       ;2490
000172  fba51000          UMULL    r1,r0,r5,r0           ;2490
000176  0940              LSRS     r0,r0,#5              ;2490
000178  f00000f8          AND      r0,r0,#0xf8           ;2490
00017c  eb070740          ADD      r7,r7,r0,LSL #1       ;2490
000180  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
000184  eb0001c0          ADD      r1,r0,r0,LSL #3       ;2490
000188  eb011000          ADD      r0,r1,r0,LSL #4       ;2490
00018c  6861              LDR      r1,[r4,#4]            ;2490
00018e  0049              LSLS     r1,r1,#1              ;2490
000190  fbb0f8f1          UDIV     r8,r0,r1              ;2490
000194  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
000198  eb0001c0          ADD      r1,r0,r0,LSL #3       ;2490
00019c  eb011000          ADD      r0,r1,r0,LSL #4       ;2490
0001a0  6861              LDR      r1,[r4,#4]            ;2490
0001a2  0049              LSLS     r1,r1,#1              ;2490
0001a4  fbb0f0f1          UDIV     r0,r0,r1              ;2490
0001a8  fba51000          UMULL    r1,r0,r5,r0           ;2490
0001ac  0940              LSRS     r0,r0,#5              ;2490
0001ae  f06f0118          MVN      r1,#0x18              ;2490
0001b2  4348              MULS     r0,r1,r0              ;2490
0001b4  eb080080          ADD      r0,r8,r0,LSL #2       ;2490
0001b8  eb0600c0          ADD      r0,r6,r0,LSL #3       ;2490
0001bc  fba51000          UMULL    r1,r0,r5,r0           ;2490
0001c0  6821              LDR      r1,[r4,#0]            ;2490
0001c2  f3c01042          UBFX     r0,r0,#5,#3           ;2490
0001c6  4438              ADD      r0,r0,r7              ;2490
0001c8  6088              STR      r0,[r1,#8]            ;2490
0001ca  e8bd81f0          POP      {r4-r8,pc}
                  |L49.462|
0001ce  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
0001d2  eb0001c0          ADD      r1,r0,r0,LSL #3       ;2500
0001d6  eb011000          ADD      r0,r1,r0,LSL #4       ;2500
0001da  6861              LDR      r1,[r4,#4]            ;2500
0001dc  0049              LSLS     r1,r1,#1              ;2500
0001de  fbb0f0f1          UDIV     r0,r0,r1              ;2500
0001e2  fba51000          UMULL    r1,r0,r5,r0           ;2500
0001e6  0940              LSRS     r0,r0,#5              ;2500
0001e8  0107              LSLS     r7,r0,#4              ;2500
0001ea  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
0001ee  eb0001c0          ADD      r1,r0,r0,LSL #3       ;2500
0001f2  eb011000          ADD      r0,r1,r0,LSL #4       ;2500
0001f6  6861              LDR      r1,[r4,#4]            ;2500
0001f8  0049              LSLS     r1,r1,#1              ;2500
0001fa  fbb0f8f1          UDIV     r8,r0,r1              ;2500
0001fe  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
000202  eb0001c0          ADD      r1,r0,r0,LSL #3       ;2500
000206  eb011000          ADD      r0,r1,r0,LSL #4       ;2500
00020a  6861              LDR      r1,[r4,#4]            ;2500
00020c  0049              LSLS     r1,r1,#1              ;2500
00020e  fbb0f0f1          UDIV     r0,r0,r1              ;2500
000212  fba51000          UMULL    r1,r0,r5,r0           ;2500
000216  0940              LSRS     r0,r0,#5              ;2500
000218  f06f0118          MVN      r1,#0x18              ;2500
00021c  4348              MULS     r0,r1,r0              ;2500
00021e  eb080080          ADD      r0,r8,r0,LSL #2       ;2500
000222  eb0600c0          ADD      r0,r6,r0,LSL #3       ;2500
000226  fba51000          UMULL    r1,r0,r5,r0           ;2500
00022a  0940              LSRS     r0,r0,#5              ;2500
00022c  f00000f8          AND      r0,r0,#0xf8           ;2500
000230  eb070740          ADD      r7,r7,r0,LSL #1       ;2500
000234  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
000238  eb0001c0          ADD      r1,r0,r0,LSL #3       ;2500
00023c  eb011000          ADD      r0,r1,r0,LSL #4       ;2500
000240  6861              LDR      r1,[r4,#4]            ;2500
000242  0049              LSLS     r1,r1,#1              ;2500
000244  fbb0f8f1          UDIV     r8,r0,r1              ;2500
000248  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
00024c  eb0001c0          ADD      r1,r0,r0,LSL #3       ;2500
000250  eb011000          ADD      r0,r1,r0,LSL #4       ;2500
000254  6861              LDR      r1,[r4,#4]            ;2500
000256  0049              LSLS     r1,r1,#1              ;2500
000258  fbb0f0f1          UDIV     r0,r0,r1              ;2500
00025c  fba51000          UMULL    r1,r0,r5,r0           ;2500
000260  0940              LSRS     r0,r0,#5              ;2500
000262  f06f0118          MVN      r1,#0x18              ;2500
000266  4348              MULS     r0,r1,r0              ;2500
000268  eb080080          ADD      r0,r8,r0,LSL #2       ;2500
00026c  eb0600c0          ADD      r0,r6,r0,LSL #3       ;2500
000270  fba51000          UMULL    r1,r0,r5,r0           ;2500
000274  6821              LDR      r1,[r4,#0]            ;2500
000276  f3c01042          UBFX     r0,r0,#5,#3           ;2500
00027a  4438              ADD      r0,r0,r7              ;2500
00027c  6088              STR      r0,[r1,#8]            ;2500
00027e  e8bd81f0          POP      {r4-r8,pc}
000282  bf00              NOP                            ;2519
                  |L49.644|
000284  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
000288  eb0001c0          ADD      r1,r0,r0,LSL #3       ;2519
00028c  eb011000          ADD      r0,r1,r0,LSL #4       ;2519
000290  6861              LDR      r1,[r4,#4]            ;2519
000292  0089              LSLS     r1,r1,#2              ;2519
000294  fbb0f7f1          UDIV     r7,r0,r1              ;2519
000298  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
00029c  eb0001c0          ADD      r1,r0,r0,LSL #3       ;2519
0002a0  eb011000          ADD      r0,r1,r0,LSL #4       ;2519
0002a4  6861              LDR      r1,[r4,#4]            ;2519
0002a6  0089              LSLS     r1,r1,#2              ;2519
0002a8  fbb0f0f1          UDIV     r0,r0,r1              ;2519
0002ac  fba51000          UMULL    r1,r0,r5,r0           ;2519
0002b0  0940              LSRS     r0,r0,#5              ;2519
0002b2  f06f0118          MVN      r1,#0x18              ;2519
0002b6  4348              MULS     r0,r1,r0              ;2519
0002b8  eb070080          ADD      r0,r7,r0,LSL #2       ;2519
0002bc  eb061000          ADD      r0,r6,r0,LSL #4       ;2519
0002c0  fba51000          UMULL    r1,r0,r5,r0           ;2519
0002c4  0940              LSRS     r0,r0,#5              ;2519
0002c6  f00007f0          AND      r7,r0,#0xf0           ;2519
0002ca  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
0002ce  eb0001c0          ADD      r1,r0,r0,LSL #3       ;2519
0002d2  eb011000          ADD      r0,r1,r0,LSL #4       ;2519
0002d6  6861              LDR      r1,[r4,#4]            ;2519
0002d8  0089              LSLS     r1,r1,#2              ;2519
0002da  fbb0f0f1          UDIV     r0,r0,r1              ;2519
0002de  fba51000          UMULL    r1,r0,r5,r0           ;2519
0002e2  0940              LSRS     r0,r0,#5              ;2519
0002e4  eb071700          ADD      r7,r7,r0,LSL #4       ;2519
0002e8  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
0002ec  eb0001c0          ADD      r1,r0,r0,LSL #3       ;2519
0002f0  eb011000          ADD      r0,r1,r0,LSL #4       ;2519
0002f4  6861              LDR      r1,[r4,#4]            ;2519
0002f6  0089              LSLS     r1,r1,#2              ;2519
0002f8  fbb0f8f1          UDIV     r8,r0,r1              ;2519
0002fc  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
000300  eb0001c0          ADD      r1,r0,r0,LSL #3       ;2519
000304  eb011000          ADD      r0,r1,r0,LSL #4       ;2519
000308  6861              LDR      r1,[r4,#4]            ;2519
00030a  0089              LSLS     r1,r1,#2              ;2519
00030c  fbb0f0f1          UDIV     r0,r0,r1              ;2519
000310  fba51000          UMULL    r1,r0,r5,r0           ;2519
000314  0940              LSRS     r0,r0,#5              ;2519
000316  f06f0118          MVN      r1,#0x18              ;2519
00031a  4348              MULS     r0,r1,r0              ;2519
00031c  eb080080          ADD      r0,r8,r0,LSL #2       ;2519
000320  eb061000          ADD      r0,r6,r0,LSL #4       ;2519
000324  fba51000          UMULL    r1,r0,r5,r0           ;2519
000328  6821              LDR      r1,[r4,#0]            ;2519
00032a  f3c01043          UBFX     r0,r0,#5,#4           ;2519
00032e  4438              ADD      r0,r0,r7              ;2519
000330  6088              STR      r0,[r1,#8]            ;2519
000332  e8bd81f0          POP      {r4-r8,pc}
;;;2523   
                          ENDP

000336  0000              DCW      0x0000
                  |L49.824|
                          DCD      0x40011400
                  |L49.828|
                          DCD      0x40011000
                  |L49.832|
                          DCD      0x51eb851f

                          AREA ||i.UART_WaitOnFlagUntilTimeout||, CODE, READONLY, ALIGN=2

                  UART_WaitOnFlagUntilTimeout PROC
;;;2107     */
;;;2108   static HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2109   {
000004  4604              MOV      r4,r0
;;;2110     /* Wait until flag is set */
;;;2111     while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status) 
000006  6800              LDR      r0,[r0,#0]
000008  9e06              LDR      r6,[sp,#0x18]
00000a  461f              MOV      r7,r3                 ;2109
00000c  6800              LDR      r0,[r0,#0]
00000e  460d              MOV      r5,r1                 ;2109
000010  ea310000          BICS     r0,r1,r0
000014  d020              BEQ      |L50.88|
;;;2112     {
;;;2113       /* Check for the Timeout */
;;;2114       if(Timeout != HAL_MAX_DELAY)
000016  bf00              NOP      
                  |L50.24|
000018  f1b63fff          CMP      r6,#0xffffffff
00001c  d017              BEQ      |L50.78|
;;;2115       {
;;;2116         if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
00001e  b126              CBZ      r6,|L50.42|
000020  f7fffffe          BL       HAL_GetTick
000024  1bc0              SUBS     r0,r0,r7
000026  42b0              CMP      r0,r6
000028  d911              BLS      |L50.78|
                  |L50.42|
;;;2117         {
;;;2118           /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
;;;2119           CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
00002a  6820              LDR      r0,[r4,#0]
00002c  68c1              LDR      r1,[r0,#0xc]
00002e  f42171d0          BIC      r1,r1,#0x1a0
000032  60c1              STR      r1,[r0,#0xc]
;;;2120           CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000034  6820              LDR      r0,[r4,#0]
000036  6941              LDR      r1,[r0,#0x14]
000038  f0210101          BIC      r1,r1,#1
00003c  6141              STR      r1,[r0,#0x14]
;;;2121           
;;;2122           huart->gState  = HAL_UART_STATE_READY;
00003e  2020              MOVS     r0,#0x20
000040  63e0              STR      r0,[r4,#0x3c]
;;;2123           huart->RxState = HAL_UART_STATE_READY;
000042  6420              STR      r0,[r4,#0x40]
;;;2124           
;;;2125           /* Process Unlocked */
;;;2126           __HAL_UNLOCK(huart);
000044  2000              MOVS     r0,#0
;;;2127           
;;;2128           return HAL_TIMEOUT;
000046  63a0              STR      r0,[r4,#0x38]
000048  2003              MOVS     r0,#3
;;;2129         }
;;;2130       }
;;;2131     }
;;;2132     
;;;2133     return HAL_OK;
;;;2134   }
00004a  e8bd81f0          POP      {r4-r8,pc}
                  |L50.78|
00004e  6820              LDR      r0,[r4,#0]            ;2128
000050  6800              LDR      r0,[r0,#0]            ;2128
000052  ea350000          BICS     r0,r5,r0              ;2128
000056  d1df              BNE      |L50.24|
                  |L50.88|
000058  2000              MOVS     r0,#0                 ;2133
00005a  e8bd81f0          POP      {r4-r8,pc}
;;;2135   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F4_V1.21.0\\Drivers\\STM32F4xx_HAL_Driver\\Src\\stm32f4xx_hal_uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_hal_uart_c_d497114f____REV16|
#line 388 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F4_V1.21.0\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___20_stm32f4xx_hal_uart_c_d497114f____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_hal_uart_c_d497114f____REVSH|
#line 402
|__asm___20_stm32f4xx_hal_uart_c_d497114f____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_hal_uart_c_d497114f____RRX|
#line 587
|__asm___20_stm32f4xx_hal_uart_c_d497114f____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
