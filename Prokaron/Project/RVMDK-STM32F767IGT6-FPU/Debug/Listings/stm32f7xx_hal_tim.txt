; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f7xx_hal_tim.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f7xx_hal_tim.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Core -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Inc -I.\Source -I.\Drivers -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6-FPU\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f7xx_hal_tim.crf ..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_tim.c]
                          THUMB

                          AREA ||i.HAL_TIM_Base_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_DeInit PROC
;;;308      */
;;;309    HAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;310    {  
000002  4604              MOV      r4,r0
;;;311      /* Check the parameters */
;;;312      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;313    
;;;314      htim->State = HAL_TIM_STATE_BUSY;
;;;315       
;;;316      /* Disable the TIM Peripheral Clock */
;;;317      __HAL_TIM_DISABLE(htim);
000004  f2411211          MOV      r2,#0x1111
000008  2002              MOVS     r0,#2                 ;314
00000a  6420              STR      r0,[r4,#0x40]         ;314
00000c  6820              LDR      r0,[r4,#0]
00000e  6a01              LDR      r1,[r0,#0x20]
000010  4211              TST      r1,r2
000012  d107              BNE      |L1.36|
000014  6a01              LDR      r1,[r0,#0x20]
000016  1092              ASRS     r2,r2,#2
000018  4211              TST      r1,r2
00001a  d103              BNE      |L1.36|
00001c  6801              LDR      r1,[r0,#0]
00001e  f0210101          BIC      r1,r1,#1
000022  6001              STR      r1,[r0,#0]
                  |L1.36|
;;;318    
;;;319    #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;320      if(htim->Base_MspDeInitCallback == NULL)
;;;321      {
;;;322        htim->Base_MspDeInitCallback = HAL_TIM_Base_MspDeInit;
;;;323      }
;;;324      /* DeInit the low level hardware */
;;;325      htim->Base_MspDeInitCallback(htim);
;;;326    #else
;;;327      /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;328      HAL_TIM_Base_MspDeInit(htim);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       HAL_TIM_Base_MspDeInit
;;;329    #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;330      
;;;331      /* Change TIM state */  
;;;332      htim->State = HAL_TIM_STATE_RESET; 
00002a  2000              MOVS     r0,#0
00002c  6420              STR      r0,[r4,#0x40]
;;;333      
;;;334      /* Release Lock */
;;;335      __HAL_UNLOCK(htim);
00002e  63e0              STR      r0,[r4,#0x3c]
;;;336    
;;;337      return HAL_OK;
;;;338    }
000030  bd10              POP      {r4,pc}
;;;339    
                          ENDP


                          AREA ||i.HAL_TIM_Base_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_GetState PROC
;;;5234     */
;;;5235   HAL_TIM_StateTypeDef HAL_TIM_Base_GetState(TIM_HandleTypeDef *htim)
000000  6c00              LDR      r0,[r0,#0x40]
;;;5236   {
;;;5237     return htim->State;
;;;5238   }
000002  4770              BX       lr
;;;5239   
                          ENDP


                          AREA ||i.HAL_TIM_Base_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Init PROC
;;;256      */
;;;257    HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;258    { 
000002  0004              MOVS     r4,r0
000004  d002              BEQ      |L3.12|
;;;259      /* Check the TIM handle allocation */
;;;260      if(htim == NULL)
;;;261      {
;;;262        return HAL_ERROR;
;;;263      }
;;;264    
;;;265      /* Check the parameters */
;;;266      assert_param(IS_TIM_INSTANCE(htim->Instance)); 
;;;267      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;268      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;269      assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;270    
;;;271      if(htim->State == HAL_TIM_STATE_RESET)
000006  6c20              LDR      r0,[r4,#0x40]
000008  b110              CBZ      r0,|L3.16|
00000a  e006              B        |L3.26|
                  |L3.12|
00000c  2001              MOVS     r0,#1                 ;262
;;;272      {
;;;273        /* Allocate lock resource and initialize it */
;;;274        htim->Lock = HAL_UNLOCKED;
;;;275    
;;;276    #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;277        /* Reset interrupt callbacks to legacy week callbacks */
;;;278        TIM_ResetCallback(htim);
;;;279    
;;;280        if(htim->Base_MspInitCallback == NULL)
;;;281        {
;;;282          htim->Base_MspInitCallback = HAL_TIM_Base_MspInit;
;;;283        }
;;;284        /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;285        htim->Base_MspInitCallback(htim);
;;;286    #else
;;;287        /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;288        HAL_TIM_Base_MspInit(htim);
;;;289    #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;290      }
;;;291      /* Set the TIM state */
;;;292      htim->State= HAL_TIM_STATE_BUSY;
;;;293      
;;;294      /* Set the Time Base configuration */
;;;295      TIM_Base_SetConfig(htim->Instance, &htim->Init); 
;;;296      
;;;297      /* Initialize the TIM state*/
;;;298      htim->State= HAL_TIM_STATE_READY;
;;;299      
;;;300      return HAL_OK;
;;;301    }
00000e  bd10              POP      {r4,pc}
                  |L3.16|
000010  2000              MOVS     r0,#0                 ;274
000012  63e0              STR      r0,[r4,#0x3c]         ;288
000014  4620              MOV      r0,r4                 ;288
000016  f7fffffe          BL       HAL_TIM_Base_MspInit
                  |L3.26|
00001a  2002              MOVS     r0,#2                 ;292
00001c  6420              STR      r0,[r4,#0x40]         ;292
00001e  6820              LDR      r0,[r4,#0]            ;295
000020  1d21              ADDS     r1,r4,#4              ;295
000022  f7fffffe          BL       TIM_Base_SetConfig
000026  2001              MOVS     r0,#1                 ;298
000028  6420              STR      r0,[r4,#0x40]         ;298
00002a  2000              MOVS     r0,#0                 ;300
00002c  bd10              POP      {r4,pc}
;;;302    
                          ENDP


                          AREA ||i.HAL_TIM_Base_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_MspDeInit PROC
;;;361      */
;;;362    __weak void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;363    {
;;;364      /* Prevent unused argument(s) compilation warning */
;;;365      UNUSED(htim);
;;;366     
;;;367      /* NOTE : This function Should not be modified, when the callback is needed,
;;;368                the HAL_TIM_Base_MspDeInit could be implemented in the user file
;;;369       */
;;;370    }
;;;371    
                          ENDP


                          AREA ||i.HAL_TIM_Base_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_MspInit PROC
;;;345      */
;;;346    __weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;347    {
;;;348      /* Prevent unused argument(s) compilation warning */
;;;349      UNUSED(htim);
;;;350     
;;;351      /* NOTE : This function Should not be modified, when the callback is needed,
;;;352                the HAL_TIM_Base_MspInit could be implemented in the user file
;;;353       */
;;;354    }
;;;355    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Start PROC
;;;377      */
;;;378    HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
000000  2102              MOVS     r1,#2
;;;379    {
;;;380      /* Check the parameters */
;;;381      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;382      
;;;383      /* Set the TIM state */
;;;384      htim->State= HAL_TIM_STATE_BUSY;
000002  6401              STR      r1,[r0,#0x40]
;;;385      
;;;386      /* Enable the Peripheral */
;;;387      __HAL_TIM_ENABLE(htim);
;;;388      
;;;389      /* Change the TIM state*/
;;;390      htim->State= HAL_TIM_STATE_READY;
000004  2201              MOVS     r2,#1
000006  6801              LDR      r1,[r0,#0]            ;387
000008  680b              LDR      r3,[r1,#0]            ;387
00000a  f0430301          ORR      r3,r3,#1              ;387
00000e  600b              STR      r3,[r1,#0]            ;387
000010  6402              STR      r2,[r0,#0x40]
;;;391      
;;;392      /* Return function status */
;;;393      return HAL_OK;
000012  2000              MOVS     r0,#0
;;;394    }
000014  4770              BX       lr
;;;395    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Base_Start_DMA PROC
;;;468      */
;;;469    HAL_StatusTypeDef HAL_TIM_Base_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;470    {
000002  4604              MOV      r4,r0
;;;471      /* Check the parameters */
;;;472      assert_param(IS_TIM_DMA_INSTANCE(htim->Instance)); 
;;;473      
;;;474      if((htim->State == HAL_TIM_STATE_BUSY))
000004  6c00              LDR      r0,[r0,#0x40]
000006  2802              CMP      r0,#2
000008  d004              BEQ      |L7.20|
;;;475      {
;;;476         return HAL_BUSY;
;;;477      }
;;;478      else if((htim->State == HAL_TIM_STATE_READY))
00000a  6c20              LDR      r0,[r4,#0x40]
00000c  2801              CMP      r0,#1
00000e  d104              BNE      |L7.26|
;;;479      {
;;;480        if((pData == 0 ) && (Length > 0)) 
000010  b909              CBNZ     r1,|L7.22|
000012  b102              CBZ      r2,|L7.22|
                  |L7.20|
;;;481        {
;;;482          return HAL_ERROR;                                    
;;;483        }
;;;484        else
;;;485        {
;;;486          htim->State = HAL_TIM_STATE_BUSY;
;;;487        }
;;;488      }  
;;;489      /* Set the DMA Period elapsed callback */
;;;490      htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;491         
;;;492      /* Set the DMA error callback */
;;;493      htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = HAL_TIM_DMAError ;
;;;494      
;;;495      /* Enable the DMA Stream */
;;;496      HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)pData, (uint32_t)&htim->Instance->ARR, Length);
;;;497      
;;;498      /* Enable the TIM Update DMA request */
;;;499      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_UPDATE);
;;;500    
;;;501      /* Enable the Peripheral */
;;;502      __HAL_TIM_ENABLE(htim);  
;;;503      
;;;504      /* Return function status */
;;;505      return HAL_OK;
;;;506    }
000014  bd70              POP      {r4-r6,pc}
                  |L7.22|
000016  2002              MOVS     r0,#2                 ;486
000018  6420              STR      r0,[r4,#0x40]         ;486
                  |L7.26|
00001a  6a23              LDR      r3,[r4,#0x20]         ;490
00001c  480b              LDR      r0,|L7.76|
00001e  6418              STR      r0,[r3,#0x40]         ;493
000020  6a23              LDR      r3,[r4,#0x20]         ;493
000022  480b              LDR      r0,|L7.80|
000024  6518              STR      r0,[r3,#0x50]         ;496
000026  4613              MOV      r3,r2                 ;496
000028  6825              LDR      r5,[r4,#0]            ;496
00002a  6a20              LDR      r0,[r4,#0x20]         ;496
00002c  f105022c          ADD      r2,r5,#0x2c           ;496
000030  f7fffffe          BL       HAL_DMA_Start_IT
000034  6820              LDR      r0,[r4,#0]            ;499
000036  68c1              LDR      r1,[r0,#0xc]          ;499
000038  f4417180          ORR      r1,r1,#0x100          ;499
00003c  60c1              STR      r1,[r0,#0xc]          ;499
00003e  6820              LDR      r0,[r4,#0]            ;502
000040  6801              LDR      r1,[r0,#0]            ;502
000042  f0410101          ORR      r1,r1,#1              ;502
000046  6001              STR      r1,[r0,#0]            ;502
000048  2000              MOVS     r0,#0                 ;505
00004a  bd70              POP      {r4-r6,pc}
;;;507    
                          ENDP

                  |L7.76|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L7.80|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_Base_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Start_IT PROC
;;;425      */
;;;426    HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
000000  6801              LDR      r1,[r0,#0]
;;;427    {
;;;428      /* Check the parameters */
;;;429      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;430      
;;;431      /* Enable the TIM Update interrupt */
;;;432      __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
000002  68ca              LDR      r2,[r1,#0xc]
000004  f0420201          ORR      r2,r2,#1
000008  60ca              STR      r2,[r1,#0xc]
;;;433          
;;;434      /* Enable the Peripheral */
;;;435      __HAL_TIM_ENABLE(htim);
00000a  6800              LDR      r0,[r0,#0]
00000c  6801              LDR      r1,[r0,#0]
00000e  f0410101          ORR      r1,r1,#1
000012  6001              STR      r1,[r0,#0]
;;;436          
;;;437      /* Return function status */
;;;438      return HAL_OK;
000014  2000              MOVS     r0,#0
;;;439    }
000016  4770              BX       lr
;;;440    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Stop PROC
;;;401      */
;;;402    HAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim)
000000  2102              MOVS     r1,#2
;;;403    {
;;;404      /* Check the parameters */
;;;405      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;406      
;;;407      /* Set the TIM state */
;;;408      htim->State= HAL_TIM_STATE_BUSY;
;;;409      
;;;410      /* Disable the Peripheral */
;;;411      __HAL_TIM_DISABLE(htim);
000002  f2411311          MOV      r3,#0x1111
000006  6401              STR      r1,[r0,#0x40]         ;408
000008  6801              LDR      r1,[r0,#0]
00000a  6a0a              LDR      r2,[r1,#0x20]
00000c  421a              TST      r2,r3
00000e  d107              BNE      |L9.32|
000010  6a0a              LDR      r2,[r1,#0x20]
000012  109b              ASRS     r3,r3,#2
000014  421a              TST      r2,r3
000016  d103              BNE      |L9.32|
000018  680a              LDR      r2,[r1,#0]
00001a  f0220201          BIC      r2,r2,#1
00001e  600a              STR      r2,[r1,#0]
                  |L9.32|
;;;412      
;;;413      /* Change the TIM state*/
;;;414      htim->State= HAL_TIM_STATE_READY;
000020  2101              MOVS     r1,#1
000022  6401              STR      r1,[r0,#0x40]
;;;415      
;;;416      /* Return function status */
;;;417      return HAL_OK;
000024  2000              MOVS     r0,#0
;;;418    }
000026  4770              BX       lr
;;;419    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Stop_DMA PROC
;;;513      */
;;;514    HAL_StatusTypeDef HAL_TIM_Base_Stop_DMA(TIM_HandleTypeDef *htim)
000000  6801              LDR      r1,[r0,#0]
;;;515    {
;;;516      /* Check the parameters */
;;;517      assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
;;;518      
;;;519      /* Disable the TIM Update DMA request */
;;;520      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_UPDATE);
;;;521          
;;;522      /* Disable the Peripheral */
;;;523      __HAL_TIM_DISABLE(htim);
000002  f2411311          MOV      r3,#0x1111
000006  68ca              LDR      r2,[r1,#0xc]          ;520
000008  f4227280          BIC      r2,r2,#0x100          ;520
00000c  60ca              STR      r2,[r1,#0xc]          ;520
00000e  6801              LDR      r1,[r0,#0]
000010  6a0a              LDR      r2,[r1,#0x20]
000012  421a              TST      r2,r3
000014  d107              BNE      |L10.38|
000016  6a0a              LDR      r2,[r1,#0x20]
000018  109b              ASRS     r3,r3,#2
00001a  421a              TST      r2,r3
00001c  d103              BNE      |L10.38|
00001e  680a              LDR      r2,[r1,#0]
000020  f0220201          BIC      r2,r2,#1
000024  600a              STR      r2,[r1,#0]
                  |L10.38|
;;;524        
;;;525      /* Change the htim state */
;;;526      htim->State = HAL_TIM_STATE_READY;
000026  2101              MOVS     r1,#1
000028  6401              STR      r1,[r0,#0x40]
;;;527          
;;;528      /* Return function status */
;;;529      return HAL_OK;
00002a  2000              MOVS     r0,#0
;;;530    }
00002c  4770              BX       lr
;;;531    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Stop_IT PROC
;;;446      */
;;;447    HAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim)
000000  6801              LDR      r1,[r0,#0]
;;;448    {
;;;449      /* Check the parameters */
;;;450      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;451      /* Disable the TIM Update interrupt */
;;;452      __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
;;;453          
;;;454      /* Disable the Peripheral */
;;;455      __HAL_TIM_DISABLE(htim);
000002  f2411211          MOV      r2,#0x1111
000006  68cb              LDR      r3,[r1,#0xc]          ;452
000008  f0230301          BIC      r3,r3,#1              ;452
00000c  60cb              STR      r3,[r1,#0xc]          ;452
00000e  6800              LDR      r0,[r0,#0]
000010  6a01              LDR      r1,[r0,#0x20]
000012  4211              TST      r1,r2
000014  d107              BNE      |L11.38|
000016  6a01              LDR      r1,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4211              TST      r1,r2
00001c  d103              BNE      |L11.38|
00001e  6801              LDR      r1,[r0,#0]
000020  f0210101          BIC      r1,r1,#1
000024  6001              STR      r1,[r0,#0]
                  |L11.38|
;;;456        
;;;457      /* Return function status */
;;;458      return HAL_OK;
000026  2000              MOVS     r0,#0
;;;459    }
000028  4770              BX       lr
;;;460    
                          ENDP


                          AREA ||i.HAL_TIM_ConfigClockSource||, CODE, READONLY, ALIGN=2

                  HAL_TIM_ConfigClockSource PROC
;;;4223     */ 
;;;4224   HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef * sClockSourceConfig)    
000000  b570              PUSH     {r4-r6,lr}
;;;4225   {
000002  4604              MOV      r4,r0
;;;4226     uint32_t tmpsmcr = 0;
;;;4227       
;;;4228     /* Process Locked */
;;;4229     __HAL_LOCK(htim);
000004  6bc0              LDR      r0,[r0,#0x3c]
000006  2801              CMP      r0,#1
000008  d015              BEQ      |L12.54|
00000a  2501              MOVS     r5,#1
;;;4230     
;;;4231     htim->State = HAL_TIM_STATE_BUSY;
;;;4232     
;;;4233     /* Check the parameters */
;;;4234     assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
;;;4235     
;;;4236     /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
;;;4237     tmpsmcr = htim->Instance->SMCR;
;;;4238     tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
00000c  4e37              LDR      r6,|L12.236|
00000e  2002              MOVS     r0,#2                 ;4231
000010  e9c4500f          STRD     r5,r0,[r4,#0x3c]      ;4231
000014  6822              LDR      r2,[r4,#0]            ;4237
000016  6890              LDR      r0,[r2,#8]            ;4237
000018  4030              ANDS     r0,r0,r6
;;;4239     tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
00001a  f420407f          BIC      r0,r0,#0xff00
;;;4240     htim->Instance->SMCR = tmpsmcr;
00001e  6090              STR      r0,[r2,#8]
;;;4241     
;;;4242     switch (sClockSourceConfig->ClockSource)
000020  6808              LDR      r0,[r1,#0]
000022  2850              CMP      r0,#0x50
000024  d039              BEQ      |L12.154|
000026  dc0d              BGT      |L12.68|
000028  2820              CMP      r0,#0x20
00002a  d059              BEQ      |L12.224|
00002c  dc05              BGT      |L12.58|
00002e  b398              CBZ      r0,|L12.152|
000030  2810              CMP      r0,#0x10
000032  d143              BNE      |L12.188|
000034  e051              B        |L12.218|
                  |L12.54|
000036  2002              MOVS     r0,#2                 ;4229
;;;4243     {
;;;4244       case TIM_CLOCKSOURCE_INTERNAL:
;;;4245       { 
;;;4246         assert_param(IS_TIM_INSTANCE(htim->Instance));      
;;;4247         /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;4248         htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;4249       }
;;;4250       break;
;;;4251       
;;;4252       case TIM_CLOCKSOURCE_ETRMODE1:
;;;4253       {
;;;4254         assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
;;;4255         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4256         assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
;;;4257         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4258         /* Configure the ETR Clock source */
;;;4259         TIM_ETR_SetConfig(htim->Instance, 
;;;4260                           sClockSourceConfig->ClockPrescaler, 
;;;4261                           sClockSourceConfig->ClockPolarity, 
;;;4262                           sClockSourceConfig->ClockFilter);
;;;4263         /* Get the TIMx SMCR register value */
;;;4264         tmpsmcr = htim->Instance->SMCR;
;;;4265         /* Reset the SMS and TS Bits */
;;;4266         tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
;;;4267         /* Select the External clock mode1 and the ETRF trigger */
;;;4268         tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
;;;4269         /* Write to TIMx SMCR */
;;;4270         htim->Instance->SMCR = tmpsmcr;
;;;4271       }
;;;4272       break;
;;;4273       
;;;4274       case TIM_CLOCKSOURCE_ETRMODE2:
;;;4275       {
;;;4276         assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
;;;4277         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4278         assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
;;;4279         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4280         
;;;4281         /* Configure the ETR Clock source */
;;;4282         TIM_ETR_SetConfig(htim->Instance, 
;;;4283                           sClockSourceConfig->ClockPrescaler, 
;;;4284                           sClockSourceConfig->ClockPolarity,
;;;4285                           sClockSourceConfig->ClockFilter);
;;;4286         /* Enable the External clock mode2 */
;;;4287         htim->Instance->SMCR |= TIM_SMCR_ECE;
;;;4288       }
;;;4289       break;
;;;4290       
;;;4291       case TIM_CLOCKSOURCE_TI1:
;;;4292       {
;;;4293         assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
;;;4294     
;;;4295         /* Check TI1 input conditioning related parameters */
;;;4296         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4297         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4298   
;;;4299         TIM_TI1_ConfigInputStage(htim->Instance, 
;;;4300                           sClockSourceConfig->ClockPolarity, 
;;;4301                           sClockSourceConfig->ClockFilter);
;;;4302         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
;;;4303       }
;;;4304       break;
;;;4305       case TIM_CLOCKSOURCE_TI2:
;;;4306       {
;;;4307         assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
;;;4308         
;;;4309         /* Check TI1 input conditioning related parameters */
;;;4310         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4311         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4312   
;;;4313         TIM_TI2_ConfigInputStage(htim->Instance, 
;;;4314                           sClockSourceConfig->ClockPolarity, 
;;;4315                           sClockSourceConfig->ClockFilter);
;;;4316         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
;;;4317       }
;;;4318       break;
;;;4319       case TIM_CLOCKSOURCE_TI1ED:
;;;4320       {
;;;4321         assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
;;;4322         /* Check TI1 input conditioning related parameters */
;;;4323         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4324         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4325     
;;;4326         TIM_TI1_ConfigInputStage(htim->Instance, 
;;;4327                           sClockSourceConfig->ClockPolarity,
;;;4328                           sClockSourceConfig->ClockFilter);
;;;4329         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
;;;4330       }
;;;4331       break;
;;;4332       case TIM_CLOCKSOURCE_ITR0:
;;;4333       {
;;;4334         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4335         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR0);
;;;4336       }
;;;4337       break;
;;;4338       case TIM_CLOCKSOURCE_ITR1:
;;;4339       {
;;;4340         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4341         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR1);
;;;4342       }
;;;4343       break;
;;;4344       case TIM_CLOCKSOURCE_ITR2:
;;;4345       {
;;;4346         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4347         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR2);
;;;4348       }
;;;4349       break;
;;;4350       case TIM_CLOCKSOURCE_ITR3:
;;;4351       {
;;;4352         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4353         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR3);
;;;4354       }
;;;4355       break;
;;;4356       
;;;4357       default:
;;;4358       break;    
;;;4359     }
;;;4360     htim->State = HAL_TIM_STATE_READY;
;;;4361     
;;;4362     __HAL_UNLOCK(htim);
;;;4363     
;;;4364     return HAL_OK;
;;;4365   }
000038  bd70              POP      {r4-r6,pc}
                  |L12.58|
00003a  2830              CMP      r0,#0x30              ;4242
00003c  d053              BEQ      |L12.230|
00003e  2840              CMP      r0,#0x40              ;4242
000040  d13c              BNE      |L12.188|
000042  e03f              B        |L12.196|
                  |L12.68|
000044  2860              CMP      r0,#0x60              ;4242
000046  d030              BEQ      |L12.170|
000048  2870              CMP      r0,#0x70              ;4242
00004a  d00c              BEQ      |L12.102|
00004c  f5b05f80          CMP      r0,#0x1000            ;4242
000050  d003              BEQ      |L12.90|
000052  f5b05f00          CMP      r0,#0x2000            ;4242
000056  d131              BNE      |L12.188|
000058  e012              B        |L12.128|
                  |L12.90|
00005a  6820              LDR      r0,[r4,#0]            ;4248
00005c  4a23              LDR      r2,|L12.236|
00005e  3270              ADDS     r2,r2,#0x70           ;4248
000060  6881              LDR      r1,[r0,#8]            ;4248
000062  4011              ANDS     r1,r1,r2              ;4248
000064  e016              B        |L12.148|
                  |L12.102|
000066  684a              LDR      r2,[r1,#4]            ;4259
000068  6820              LDR      r0,[r4,#0]            ;4259
00006a  e9d11302          LDRD     r1,r3,[r1,#8]         ;4259
00006e  f7fffffe          BL       TIM_ETR_SetConfig
000072  6821              LDR      r1,[r4,#0]            ;4264
000074  6888              LDR      r0,[r1,#8]            ;4264
000076  4030              ANDS     r0,r0,r6              ;4266
000078  f0400077          ORR      r0,r0,#0x77           ;4268
00007c  6088              STR      r0,[r1,#8]            ;4270
00007e  e01d              B        |L12.188|
                  |L12.128|
000080  684a              LDR      r2,[r1,#4]            ;4282
000082  6820              LDR      r0,[r4,#0]            ;4282
000084  e9d11302          LDRD     r1,r3,[r1,#8]         ;4282
000088  f7fffffe          BL       TIM_ETR_SetConfig
00008c  6820              LDR      r0,[r4,#0]            ;4287
00008e  6881              LDR      r1,[r0,#8]            ;4287
000090  f4414180          ORR      r1,r1,#0x4000         ;4287
                  |L12.148|
000094  6081              STR      r1,[r0,#8]            ;4248
000096  e011              B        |L12.188|
                  |L12.152|
000098  e01c              B        |L12.212|
                  |L12.154|
00009a  68ca              LDR      r2,[r1,#0xc]          ;4299
00009c  6849              LDR      r1,[r1,#4]            ;4299
00009e  6820              LDR      r0,[r4,#0]            ;4299
0000a0  f7fffffe          BL       TIM_TI1_ConfigInputStage
0000a4  6820              LDR      r0,[r4,#0]            ;4304
0000a6  2150              MOVS     r1,#0x50              ;4302
0000a8  e006              B        |L12.184|
                  |L12.170|
0000aa  68ca              LDR      r2,[r1,#0xc]          ;4313
0000ac  6849              LDR      r1,[r1,#4]            ;4313
0000ae  6820              LDR      r0,[r4,#0]            ;4313
0000b0  f7fffffe          BL       TIM_TI2_ConfigInputStage
0000b4  6820              LDR      r0,[r4,#0]            ;4316
0000b6  2160              MOVS     r1,#0x60              ;4316
                  |L12.184|
0000b8  f7fffffe          BL       TIM_ITRx_SetConfig
                  |L12.188|
0000bc  2000              MOVS     r0,#0                 ;4362
0000be  6425              STR      r5,[r4,#0x40]         ;4360
0000c0  63e0              STR      r0,[r4,#0x3c]         ;4364
0000c2  bd70              POP      {r4-r6,pc}
                  |L12.196|
0000c4  68ca              LDR      r2,[r1,#0xc]          ;4326
0000c6  6849              LDR      r1,[r1,#4]            ;4326
0000c8  6820              LDR      r0,[r4,#0]            ;4326
0000ca  f7fffffe          BL       TIM_TI1_ConfigInputStage
0000ce  6820              LDR      r0,[r4,#0]            ;4331
0000d0  2140              MOVS     r1,#0x40              ;4329
0000d2  e7f1              B        |L12.184|
                  |L12.212|
0000d4  6820              LDR      r0,[r4,#0]            ;4337
0000d6  2100              MOVS     r1,#0                 ;4335
0000d8  e7ee              B        |L12.184|
                  |L12.218|
0000da  6820              LDR      r0,[r4,#0]            ;4343
0000dc  2110              MOVS     r1,#0x10              ;4341
0000de  e7eb              B        |L12.184|
                  |L12.224|
0000e0  6820              LDR      r0,[r4,#0]            ;4349
0000e2  2120              MOVS     r1,#0x20              ;4347
0000e4  e7e8              B        |L12.184|
                  |L12.230|
0000e6  6820              LDR      r0,[r4,#0]            ;4355
0000e8  2130              MOVS     r1,#0x30              ;4353
0000ea  e7e5              B        |L12.184|
;;;4366   
                          ENDP

                  |L12.236|
                          DCD      0xfffeff88

                          AREA ||i.HAL_TIM_ConfigOCrefClear||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ConfigOCrefClear PROC
;;;4119     */ 
;;;4120   __weak HAL_StatusTypeDef HAL_TIM_ConfigOCrefClear(TIM_HandleTypeDef *htim, TIM_ClearInputConfigTypeDef * sClearInputConfig, uint32_t Channel)
000000  b5f0              PUSH     {r4-r7,lr}
;;;4121   { 
000002  4604              MOV      r4,r0
;;;4122     /* Check the parameters */
;;;4123     assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4124     assert_param(IS_TIM_CHANNELS(Channel));
;;;4125     assert_param(IS_TIM_CLEARINPUT_SOURCE(sClearInputConfig->ClearInputSource));
;;;4126      
;;;4127     /* Process Locked */
;;;4128     __HAL_LOCK(htim);
000004  6bc0              LDR      r0,[r0,#0x3c]
000006  4617              MOV      r7,r2                 ;4121
000008  460d              MOV      r5,r1                 ;4121
00000a  2801              CMP      r0,#1
00000c  d007              BEQ      |L13.30|
00000e  2601              MOVS     r6,#1
;;;4129     
;;;4130     htim->State = HAL_TIM_STATE_BUSY;
000010  2002              MOVS     r0,#2
000012  e9c4600f          STRD     r6,r0,[r4,#0x3c]
;;;4131     
;;;4132     if(sClearInputConfig->ClearInputSource == TIM_CLEARINPUTSOURCE_ETR)
000016  6868              LDR      r0,[r5,#4]
000018  2801              CMP      r0,#1
00001a  d002              BEQ      |L13.34|
00001c  e007              B        |L13.46|
                  |L13.30|
00001e  2002              MOVS     r0,#2                 ;4128
;;;4133     {
;;;4134       assert_param(IS_TIM_CLEARINPUT_POLARITY(sClearInputConfig->ClearInputPolarity));
;;;4135       assert_param(IS_TIM_CLEARINPUT_PRESCALER(sClearInputConfig->ClearInputPrescaler));
;;;4136       assert_param(IS_TIM_CLEARINPUT_FILTER(sClearInputConfig->ClearInputFilter));
;;;4137     
;;;4138       TIM_ETR_SetConfig(htim->Instance, 
;;;4139                         sClearInputConfig->ClearInputPrescaler,
;;;4140                         sClearInputConfig->ClearInputPolarity,
;;;4141                         sClearInputConfig->ClearInputFilter);
;;;4142     }
;;;4143     
;;;4144     switch (Channel)
;;;4145     {
;;;4146       case TIM_CHANNEL_1:
;;;4147       {        
;;;4148         if(sClearInputConfig->ClearInputState != RESET)  
;;;4149         {
;;;4150           /* Enable the Ocref clear feature for Channel 1 */
;;;4151           htim->Instance->CCMR1 |= TIM_CCMR1_OC1CE;
;;;4152         }
;;;4153         else
;;;4154         {
;;;4155           /* Disable the Ocref clear feature for Channel 1 */
;;;4156           htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1CE;      
;;;4157         }
;;;4158       }    
;;;4159       break;
;;;4160       case TIM_CHANNEL_2:    
;;;4161       { 
;;;4162         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance)); 
;;;4163         if(sClearInputConfig->ClearInputState != RESET)  
;;;4164         {
;;;4165           /* Enable the Ocref clear feature for Channel 2 */
;;;4166           htim->Instance->CCMR1 |= TIM_CCMR1_OC2CE;
;;;4167         }
;;;4168         else
;;;4169         {
;;;4170           /* Disable the Ocref clear feature for Channel 2 */
;;;4171           htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2CE;      
;;;4172         }
;;;4173       } 
;;;4174       break;
;;;4175       case TIM_CHANNEL_3:   
;;;4176       {  
;;;4177         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;4178         if(sClearInputConfig->ClearInputState != RESET)  
;;;4179         {
;;;4180           /* Enable the Ocref clear feature for Channel 3 */
;;;4181           htim->Instance->CCMR2 |= TIM_CCMR2_OC3CE;
;;;4182         }
;;;4183         else
;;;4184         {
;;;4185           /* Disable the Ocref clear feature for Channel 3 */
;;;4186           htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3CE;      
;;;4187         }
;;;4188       } 
;;;4189       break;
;;;4190       case TIM_CHANNEL_4:    
;;;4191       {  
;;;4192         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;4193         if(sClearInputConfig->ClearInputState != RESET)  
;;;4194         {
;;;4195           /* Enable the Ocref clear feature for Channel 4 */
;;;4196           htim->Instance->CCMR2 |= TIM_CCMR2_OC4CE;
;;;4197         }
;;;4198         else
;;;4199         {
;;;4200           /* Disable the Ocref clear feature for Channel 4 */
;;;4201           htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4CE;      
;;;4202         }
;;;4203       } 
;;;4204       break;
;;;4205       default:  
;;;4206       break;
;;;4207     } 
;;;4208   
;;;4209     htim->State = HAL_TIM_STATE_READY;
;;;4210     
;;;4211     __HAL_UNLOCK(htim);
;;;4212     
;;;4213     return HAL_OK;  
;;;4214   }  
000020  bdf0              POP      {r4-r7,pc}
                  |L13.34|
000022  6820              LDR      r0,[r4,#0]            ;4138
000024  692b              LDR      r3,[r5,#0x10]         ;4138
000026  e9d52102          LDRD     r2,r1,[r5,#8]         ;4138
00002a  f7fffffe          BL       TIM_ETR_SetConfig
                  |L13.46|
00002e  b137              CBZ      r7,|L13.62|
000030  2f04              CMP      r7,#4                 ;4144
000032  d00f              BEQ      |L13.84|
000034  2f08              CMP      r7,#8                 ;4144
000036  d019              BEQ      |L13.108|
000038  2f0c              CMP      r7,#0xc               ;4144
00003a  d12d              BNE      |L13.152|
00003c  e021              B        |L13.130|
                  |L13.62|
00003e  6828              LDR      r0,[r5,#0]            ;4148
000040  2800              CMP      r0,#0                 ;4148
000042  6820              LDR      r0,[r4,#0]            ;4156
000044  6981              LDR      r1,[r0,#0x18]         ;4156
000046  d002              BEQ      |L13.78|
000048  f0410180          ORR      r1,r1,#0x80           ;4151
00004c  e00c              B        |L13.104|
                  |L13.78|
00004e  f0210180          BIC      r1,r1,#0x80           ;4156
000052  e009              B        |L13.104|
                  |L13.84|
000054  6828              LDR      r0,[r5,#0]            ;4163
000056  2800              CMP      r0,#0                 ;4163
000058  6820              LDR      r0,[r4,#0]            ;4171
00005a  6981              LDR      r1,[r0,#0x18]         ;4171
00005c  d002              BEQ      |L13.100|
00005e  f4414100          ORR      r1,r1,#0x8000         ;4166
000062  e001              B        |L13.104|
                  |L13.100|
000064  f4214100          BIC      r1,r1,#0x8000         ;4171
                  |L13.104|
000068  6181              STR      r1,[r0,#0x18]         ;4166
00006a  e015              B        |L13.152|
                  |L13.108|
00006c  6828              LDR      r0,[r5,#0]            ;4178
00006e  2800              CMP      r0,#0                 ;4178
000070  6820              LDR      r0,[r4,#0]            ;4186
000072  69c1              LDR      r1,[r0,#0x1c]         ;4186
000074  d002              BEQ      |L13.124|
000076  f0410180          ORR      r1,r1,#0x80           ;4181
00007a  e00c              B        |L13.150|
                  |L13.124|
00007c  f0210180          BIC      r1,r1,#0x80           ;4186
000080  e009              B        |L13.150|
                  |L13.130|
000082  6828              LDR      r0,[r5,#0]            ;4193
000084  2800              CMP      r0,#0                 ;4193
000086  6820              LDR      r0,[r4,#0]            ;4201
000088  69c1              LDR      r1,[r0,#0x1c]         ;4201
00008a  d002              BEQ      |L13.146|
00008c  f4414100          ORR      r1,r1,#0x8000         ;4196
000090  e001              B        |L13.150|
                  |L13.146|
000092  f4214100          BIC      r1,r1,#0x8000         ;4201
                  |L13.150|
000096  61c1              STR      r1,[r0,#0x1c]         ;4196
                  |L13.152|
000098  2000              MOVS     r0,#0                 ;4211
00009a  6426              STR      r6,[r4,#0x40]         ;4209
00009c  63e0              STR      r0,[r4,#0x3c]         ;4211
00009e  bdf0              POP      {r4-r7,pc}
;;;4215   
                          ENDP


                          AREA ||i.HAL_TIM_ConfigTI1Input||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ConfigTI1Input PROC
;;;4379     */
;;;4380   HAL_StatusTypeDef HAL_TIM_ConfigTI1Input(TIM_HandleTypeDef *htim, uint32_t TI1_Selection)
000000  6802              LDR      r2,[r0,#0]
;;;4381   {
;;;4382     uint32_t tmpcr2 = 0;
;;;4383     
;;;4384     /* Check the parameters */
;;;4385     assert_param(IS_TIM_XOR_INSTANCE(htim->Instance)); 
;;;4386     assert_param(IS_TIM_TI1SELECTION(TI1_Selection));
;;;4387   
;;;4388     /* Get the TIMx CR2 register value */
;;;4389     tmpcr2 = htim->Instance->CR2;
000002  6850              LDR      r0,[r2,#4]
;;;4390   
;;;4391     /* Reset the TI1 selection */
;;;4392     tmpcr2 &= ~TIM_CR2_TI1S;
000004  f0200080          BIC      r0,r0,#0x80
;;;4393   
;;;4394     /* Set the TI1 selection */
;;;4395     tmpcr2 |= TI1_Selection;
000008  4308              ORRS     r0,r0,r1
;;;4396     
;;;4397     /* Write to TIMxCR2 */
;;;4398     htim->Instance->CR2 = tmpcr2;
00000a  6050              STR      r0,[r2,#4]
;;;4399   
;;;4400     return HAL_OK;
00000c  2000              MOVS     r0,#0
;;;4401   }
00000e  4770              BX       lr
;;;4402   
                          ENDP


                          AREA ||i.HAL_TIM_DMABurst_ReadStart||, CODE, READONLY, ALIGN=2

                  HAL_TIM_DMABurst_ReadStart PROC
;;;3874     */
;;;3875   HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3876                                                uint32_t  *BurstBuffer, uint32_t  BurstLength)
;;;3877   {
000004  4604              MOV      r4,r0
;;;3878     /* Check the parameters */
;;;3879     assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
;;;3880     assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
;;;3881     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3882     assert_param(IS_TIM_DMA_LENGTH(BurstLength));
;;;3883     
;;;3884     if((htim->State == HAL_TIM_STATE_BUSY))
000006  6c00              LDR      r0,[r0,#0x40]
000008  469c              MOV      r12,r3                ;3877
00000a  4616              MOV      r6,r2                 ;3877
00000c  9d06              LDR      r5,[sp,#0x18]
00000e  4688              MOV      r8,r1                 ;3877
000010  2802              CMP      r0,#2
000012  d006              BEQ      |L15.34|
;;;3885     {
;;;3886        return HAL_BUSY;
;;;3887     }
;;;3888     else if((htim->State == HAL_TIM_STATE_READY))
000014  6c20              LDR      r0,[r4,#0x40]
000016  2801              CMP      r0,#1
000018  d107              BNE      |L15.42|
;;;3889     {
;;;3890       if((BurstBuffer == 0 ) && (BurstLength > 0)) 
00001a  f1bc0f00          CMP      r12,#0
00001e  d102              BNE      |L15.38|
000020  b10d              CBZ      r5,|L15.38|
                  |L15.34|
;;;3891       {
;;;3892         return HAL_ERROR;                                    
;;;3893       }
;;;3894       else
;;;3895       {
;;;3896         htim->State = HAL_TIM_STATE_BUSY;
;;;3897       }
;;;3898     }  
;;;3899     switch(BurstRequestSrc)
;;;3900     {
;;;3901       case TIM_DMA_UPDATE:
;;;3902       {  
;;;3903         /* Set the DMA Period elapsed callback */
;;;3904         htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;3905        
;;;3906         /* Set the DMA error callback */
;;;3907         htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3908     
;;;3909         /* Enable the DMA Stream */
;;;3910          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);     
;;;3911       }
;;;3912       break;
;;;3913       case TIM_DMA_CC1:
;;;3914       {  
;;;3915         /* Set the DMA Period elapsed callback */
;;;3916         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;3917        
;;;3918         /* Set the DMA error callback */
;;;3919         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3920     
;;;3921         /* Enable the DMA Stream */
;;;3922         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
;;;3923       }
;;;3924       break;
;;;3925       case TIM_DMA_CC2:
;;;3926       {  
;;;3927         /* Set the DMA Period elapsed callback */
;;;3928         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;3929        
;;;3930         /* Set the DMA error callback */
;;;3931         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3932     
;;;3933         /* Enable the DMA Stream */
;;;3934         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);     
;;;3935       }
;;;3936       break;
;;;3937       case TIM_DMA_CC3:
;;;3938       {  
;;;3939         /* Set the DMA Period elapsed callback */
;;;3940         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;3941        
;;;3942         /* Set the DMA error callback */
;;;3943         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3944     
;;;3945         /* Enable the DMA Stream */
;;;3946         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
;;;3947       }
;;;3948       break;
;;;3949       case TIM_DMA_CC4:
;;;3950       {  
;;;3951         /* Set the DMA Period elapsed callback */
;;;3952         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;3953        
;;;3954         /* Set the DMA error callback */
;;;3955         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3956     
;;;3957         /* Enable the DMA Stream */
;;;3958         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
;;;3959       }
;;;3960       break;
;;;3961       case TIM_DMA_COM:
;;;3962       {  
;;;3963         /* Set the DMA Period elapsed callback */
;;;3964         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = HAL_TIMEx_DMACommutationCplt;
;;;3965        
;;;3966         /* Set the DMA error callback */
;;;3967         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3968     
;;;3969         /* Enable the DMA Stream */
;;;3970         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
;;;3971       }
;;;3972       break;
;;;3973       case TIM_DMA_TRIGGER:
;;;3974       {  
;;;3975         /* Set the DMA Period elapsed callback */
;;;3976         htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
;;;3977        
;;;3978         /* Set the DMA error callback */
;;;3979         htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3980     
;;;3981         /* Enable the DMA Stream */
;;;3982         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
;;;3983       }
;;;3984       break;
;;;3985       default:
;;;3986       break;  
;;;3987     }
;;;3988   
;;;3989     /* configure the DMA Burst Mode */
;;;3990     htim->Instance->DCR = BurstBaseAddress | BurstLength;  
;;;3991     
;;;3992     /* Enable the TIM DMA Request */
;;;3993     __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
;;;3994     
;;;3995     htim->State = HAL_TIM_STATE_READY;
;;;3996     
;;;3997     /* Return function status */
;;;3998     return HAL_OK;
;;;3999   }
000022  e8bd81f0          POP      {r4-r8,pc}
                  |L15.38|
000026  2002              MOVS     r0,#2                 ;3896
000028  6420              STR      r0,[r4,#0x40]         ;3896
                  |L15.42|
00002a  2701              MOVS     r7,#1                 ;3892
00002c  482e              LDR      r0,|L15.232|
00002e  492f              LDR      r1,|L15.236|
000030  f5b66f00          CMP      r6,#0x800             ;3899
000034  eb072315          ADD      r3,r7,r5,LSR #8       ;3910
000038  d038              BEQ      |L15.172|
00003a  dc09              BGT      |L15.80|
00003c  f5b67f80          CMP      r6,#0x100             ;3899
000040  d010              BEQ      |L15.100|
000042  f5b67f00          CMP      r6,#0x200             ;3899
000046  d015              BEQ      |L15.116|
000048  f5b66f80          CMP      r6,#0x400             ;3899
00004c  d11c              BNE      |L15.136|
00004e  e026              B        |L15.158|
                  |L15.80|
000050  f5b65f80          CMP      r6,#0x1000            ;3899
000054  d031              BEQ      |L15.186|
000056  f5b65f00          CMP      r6,#0x2000            ;3899
00005a  d035              BEQ      |L15.200|
00005c  f5b64f80          CMP      r6,#0x4000            ;3899
000060  d112              BNE      |L15.136|
000062  e039              B        |L15.216|
                  |L15.100|
000064  6a22              LDR      r2,[r4,#0x20]         ;3904
000066  4922              LDR      r1,|L15.240|
000068  6411              STR      r1,[r2,#0x40]         ;3907
00006a  6a21              LDR      r1,[r4,#0x20]         ;3907
00006c  6508              STR      r0,[r1,#0x50]         ;3910
00006e  6821              LDR      r1,[r4,#0]            ;3912
000070  6a20              LDR      r0,[r4,#0x20]         ;3912
000072  e005              B        |L15.128|
                  |L15.116|
000074  6a62              LDR      r2,[r4,#0x24]         ;3916
000076  6411              STR      r1,[r2,#0x40]         ;3919
000078  6a61              LDR      r1,[r4,#0x24]         ;3919
00007a  6508              STR      r0,[r1,#0x50]         ;3922
00007c  6821              LDR      r1,[r4,#0]            ;3922
00007e  6a60              LDR      r0,[r4,#0x24]         ;3922
                  |L15.128|
000080  4662              MOV      r2,r12                ;3910
000082  314c              ADDS     r1,r1,#0x4c           ;3910
000084  f7fffffe          BL       HAL_DMA_Start_IT
                  |L15.136|
000088  6821              LDR      r1,[r4,#0]            ;3990
00008a  ea480005          ORR      r0,r8,r5              ;3990
00008e  6488              STR      r0,[r1,#0x48]         ;3990
000090  6820              LDR      r0,[r4,#0]            ;3993
000092  68c1              LDR      r1,[r0,#0xc]          ;3993
000094  4331              ORRS     r1,r1,r6              ;3993
000096  60c1              STR      r1,[r0,#0xc]          ;3993
000098  6427              STR      r7,[r4,#0x40]         ;3995
00009a  2000              MOVS     r0,#0                 ;3998
00009c  e7c1              B        |L15.34|
                  |L15.158|
00009e  6aa2              LDR      r2,[r4,#0x28]         ;3928
0000a0  6411              STR      r1,[r2,#0x40]         ;3931
0000a2  6aa1              LDR      r1,[r4,#0x28]         ;3931
0000a4  6508              STR      r0,[r1,#0x50]         ;3934
0000a6  6821              LDR      r1,[r4,#0]            ;3936
0000a8  6aa0              LDR      r0,[r4,#0x28]         ;3936
0000aa  e7e9              B        |L15.128|
                  |L15.172|
0000ac  6ae2              LDR      r2,[r4,#0x2c]         ;3940
0000ae  6411              STR      r1,[r2,#0x40]         ;3943
0000b0  6ae1              LDR      r1,[r4,#0x2c]         ;3943
0000b2  6508              STR      r0,[r1,#0x50]         ;3946
0000b4  6821              LDR      r1,[r4,#0]            ;3948
0000b6  6ae0              LDR      r0,[r4,#0x2c]         ;3948
0000b8  e7e2              B        |L15.128|
                  |L15.186|
0000ba  6b22              LDR      r2,[r4,#0x30]         ;3952
0000bc  6411              STR      r1,[r2,#0x40]         ;3955
0000be  6b21              LDR      r1,[r4,#0x30]         ;3955
0000c0  6508              STR      r0,[r1,#0x50]         ;3958
0000c2  6821              LDR      r1,[r4,#0]            ;3960
0000c4  6b20              LDR      r0,[r4,#0x30]         ;3960
0000c6  e7db              B        |L15.128|
                  |L15.200|
0000c8  6b62              LDR      r2,[r4,#0x34]         ;3964
0000ca  490a              LDR      r1,|L15.244|
0000cc  6411              STR      r1,[r2,#0x40]         ;3967
0000ce  6b61              LDR      r1,[r4,#0x34]         ;3967
0000d0  6508              STR      r0,[r1,#0x50]         ;3970
0000d2  6821              LDR      r1,[r4,#0]            ;3972
0000d4  6b60              LDR      r0,[r4,#0x34]         ;3972
0000d6  e7d3              B        |L15.128|
                  |L15.216|
0000d8  6ba2              LDR      r2,[r4,#0x38]         ;3976
0000da  4907              LDR      r1,|L15.248|
0000dc  6411              STR      r1,[r2,#0x40]         ;3979
0000de  6ba1              LDR      r1,[r4,#0x38]         ;3979
0000e0  6508              STR      r0,[r1,#0x50]         ;3982
0000e2  6821              LDR      r1,[r4,#0]            ;3984
0000e4  6ba0              LDR      r0,[r4,#0x38]         ;3984
0000e6  e7cb              B        |L15.128|
;;;4000   
                          ENDP

                  |L15.232|
                          DCD      TIM_DMAError
                  |L15.236|
                          DCD      TIM_DMACaptureCplt
                  |L15.240|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L15.244|
                          DCD      TIMEx_DMACommutationCplt
                  |L15.248|
                          DCD      TIM_DMATriggerCplt

                          AREA ||i.HAL_TIM_DMABurst_ReadStop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_DMABurst_ReadStop PROC
;;;4007     */
;;;4008   HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
000000  b570              PUSH     {r4-r6,lr}
;;;4009   {
;;;4010     /* Check the parameters */
;;;4011     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;4012     
;;;4013     /* Abort the DMA transfer (at least disable the DMA channel) */
;;;4014     switch(BurstRequestSrc)
000002  f5b16f00          CMP      r1,#0x800
000006  460d              MOV      r5,r1                 ;4009
000008  4604              MOV      r4,r0                 ;4009
00000a  d021              BEQ      |L16.80|
00000c  dc09              BGT      |L16.34|
00000e  f5b57f80          CMP      r5,#0x100
000012  d010              BEQ      |L16.54|
000014  f5b57f00          CMP      r5,#0x200
000018  d00f              BEQ      |L16.58|
00001a  f5b56f80          CMP      r5,#0x400
00001e  d10f              BNE      |L16.64|
000020  e014              B        |L16.76|
                  |L16.34|
000022  f5b55f80          CMP      r5,#0x1000
000026  d015              BEQ      |L16.84|
000028  f5b55f00          CMP      r5,#0x2000
00002c  d014              BEQ      |L16.88|
00002e  f5b54f80          CMP      r5,#0x4000
000032  d105              BNE      |L16.64|
000034  e012              B        |L16.92|
                  |L16.54|
;;;4015     {
;;;4016       case TIM_DMA_UPDATE:
;;;4017       {  
;;;4018         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
;;;4019       }
;;;4020       break;
000036  6a20              LDR      r0,[r4,#0x20]
000038  e000              B        |L16.60|
                  |L16.58|
;;;4021       case TIM_DMA_CC1:
;;;4022       {  
;;;4023         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
00003a  6a60              LDR      r0,[r4,#0x24]
                  |L16.60|
00003c  f7fffffe          BL       HAL_DMA_Abort
                  |L16.64|
;;;4024       }
;;;4025       break;
;;;4026       case TIM_DMA_CC2:
;;;4027       {  
;;;4028         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
;;;4029       }
;;;4030       break;
;;;4031       case TIM_DMA_CC3:
;;;4032       {  
;;;4033         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
;;;4034       }
;;;4035       break;
;;;4036       case TIM_DMA_CC4:
;;;4037       {  
;;;4038         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
;;;4039       }
;;;4040       break;
;;;4041       case TIM_DMA_COM:
;;;4042       {  
;;;4043         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
;;;4044       }
;;;4045       break;
;;;4046       case TIM_DMA_TRIGGER:
;;;4047       {  
;;;4048         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
;;;4049       }
;;;4050       break;
;;;4051       default:
;;;4052       break;  
;;;4053     }
;;;4054     
;;;4055     /* Disable the TIM Update DMA request */
;;;4056     __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
000040  6820              LDR      r0,[r4,#0]
000042  68c1              LDR      r1,[r0,#0xc]
000044  43a9              BICS     r1,r1,r5
000046  60c1              STR      r1,[r0,#0xc]
;;;4057         
;;;4058     /* Return function status */
;;;4059     return HAL_OK;  
000048  2000              MOVS     r0,#0
;;;4060   }
00004a  bd70              POP      {r4-r6,pc}
                  |L16.76|
00004c  6aa0              LDR      r0,[r4,#0x28]         ;4030
00004e  e7f5              B        |L16.60|
                  |L16.80|
000050  6ae0              LDR      r0,[r4,#0x2c]         ;4035
000052  e7f3              B        |L16.60|
                  |L16.84|
000054  6b20              LDR      r0,[r4,#0x30]         ;4040
000056  e7f1              B        |L16.60|
                  |L16.88|
000058  6b60              LDR      r0,[r4,#0x34]         ;4045
00005a  e7ef              B        |L16.60|
                  |L16.92|
00005c  6ba0              LDR      r0,[r4,#0x38]         ;4050
00005e  e7ed              B        |L16.60|
;;;4061   
                          ENDP


                          AREA ||i.HAL_TIM_DMABurst_WriteStart||, CODE, READONLY, ALIGN=2

                  HAL_TIM_DMABurst_WriteStart PROC
;;;3649     */
;;;3650   HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3651                                                 uint32_t* BurstBuffer, uint32_t  BurstLength)
;;;3652   {
000004  4604              MOV      r4,r0
;;;3653     /* Check the parameters */
;;;3654     assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
;;;3655     assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
;;;3656     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3657     assert_param(IS_TIM_DMA_LENGTH(BurstLength));
;;;3658     
;;;3659     if((htim->State == HAL_TIM_STATE_BUSY))
000006  6c00              LDR      r0,[r0,#0x40]
000008  469c              MOV      r12,r3                ;3652
00000a  4616              MOV      r6,r2                 ;3652
00000c  9d06              LDR      r5,[sp,#0x18]
00000e  4688              MOV      r8,r1                 ;3652
000010  2802              CMP      r0,#2
000012  d006              BEQ      |L17.34|
;;;3660     {
;;;3661        return HAL_BUSY;
;;;3662     }
;;;3663     else if((htim->State == HAL_TIM_STATE_READY))
000014  6c20              LDR      r0,[r4,#0x40]
000016  2801              CMP      r0,#1
000018  d107              BNE      |L17.42|
;;;3664     {
;;;3665       if((BurstBuffer == 0 ) && (BurstLength > 0)) 
00001a  f1bc0f00          CMP      r12,#0
00001e  d102              BNE      |L17.38|
000020  b10d              CBZ      r5,|L17.38|
                  |L17.34|
;;;3666       {
;;;3667         return HAL_ERROR;                                    
;;;3668       }
;;;3669       else
;;;3670       {
;;;3671         htim->State = HAL_TIM_STATE_BUSY;
;;;3672       }
;;;3673     }
;;;3674     switch(BurstRequestSrc)
;;;3675     {
;;;3676       case TIM_DMA_UPDATE:
;;;3677       {  
;;;3678         /* Set the DMA Period elapsed callback */
;;;3679         htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;3680        
;;;3681         /* Set the DMA error callback */
;;;3682         htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3683     
;;;3684         /* Enable the DMA Stream */
;;;3685         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1); 
;;;3686       }
;;;3687       break;
;;;3688       case TIM_DMA_CC1:
;;;3689       {  
;;;3690         /* Set the DMA Period elapsed callback */
;;;3691         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;3692        
;;;3693         /* Set the DMA error callback */
;;;3694         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3695     
;;;3696         /* Enable the DMA Stream */
;;;3697         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
;;;3698       }
;;;3699       break;
;;;3700       case TIM_DMA_CC2:
;;;3701       {  
;;;3702         /* Set the DMA Period elapsed callback */
;;;3703         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;3704        
;;;3705         /* Set the DMA error callback */
;;;3706         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3707     
;;;3708         /* Enable the DMA Stream */
;;;3709         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
;;;3710       }
;;;3711       break;
;;;3712       case TIM_DMA_CC3:
;;;3713       {  
;;;3714         /* Set the DMA Period elapsed callback */
;;;3715         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;3716        
;;;3717         /* Set the DMA error callback */
;;;3718         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3719     
;;;3720         /* Enable the DMA Stream */
;;;3721         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
;;;3722       }
;;;3723       break;
;;;3724       case TIM_DMA_CC4:
;;;3725       {  
;;;3726         /* Set the DMA Period elapsed callback */
;;;3727         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;3728        
;;;3729         /* Set the DMA error callback */
;;;3730         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3731     
;;;3732         /* Enable the DMA Stream */
;;;3733         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
;;;3734       }
;;;3735       break;
;;;3736       case TIM_DMA_COM:
;;;3737       {  
;;;3738         /* Set the DMA Period elapsed callback */
;;;3739         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = HAL_TIMEx_DMACommutationCplt;
;;;3740        
;;;3741         /* Set the DMA error callback */
;;;3742         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3743     
;;;3744         /* Enable the DMA Stream */
;;;3745         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
;;;3746       }
;;;3747       break;
;;;3748       case TIM_DMA_TRIGGER:
;;;3749       {  
;;;3750         /* Set the DMA Period elapsed callback */
;;;3751         htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
;;;3752        
;;;3753         /* Set the DMA error callback */
;;;3754         htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3755     
;;;3756         /* Enable the DMA Stream */
;;;3757         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
;;;3758       }
;;;3759       break;
;;;3760       default:
;;;3761       break;  
;;;3762     }
;;;3763      /* configure the DMA Burst Mode */
;;;3764      htim->Instance->DCR = BurstBaseAddress | BurstLength;  
;;;3765      
;;;3766      /* Enable the TIM DMA Request */
;;;3767      __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);  
;;;3768      
;;;3769      htim->State = HAL_TIM_STATE_READY;
;;;3770     
;;;3771     /* Return function status */
;;;3772     return HAL_OK;
;;;3773   }
000022  e8bd81f0          POP      {r4-r8,pc}
                  |L17.38|
000026  2002              MOVS     r0,#2                 ;3671
000028  6420              STR      r0,[r4,#0x40]         ;3671
                  |L17.42|
00002a  2701              MOVS     r7,#1                 ;3667
00002c  482e              LDR      r0,|L17.232|
00002e  492f              LDR      r1,|L17.236|
000030  f5b66f00          CMP      r6,#0x800             ;3674
000034  eb072315          ADD      r3,r7,r5,LSR #8       ;3685
000038  d038              BEQ      |L17.172|
00003a  dc09              BGT      |L17.80|
00003c  f5b67f80          CMP      r6,#0x100             ;3674
000040  d010              BEQ      |L17.100|
000042  f5b67f00          CMP      r6,#0x200             ;3674
000046  d015              BEQ      |L17.116|
000048  f5b66f80          CMP      r6,#0x400             ;3674
00004c  d11c              BNE      |L17.136|
00004e  e026              B        |L17.158|
                  |L17.80|
000050  f5b65f80          CMP      r6,#0x1000            ;3674
000054  d031              BEQ      |L17.186|
000056  f5b65f00          CMP      r6,#0x2000            ;3674
00005a  d035              BEQ      |L17.200|
00005c  f5b64f80          CMP      r6,#0x4000            ;3674
000060  d112              BNE      |L17.136|
000062  e039              B        |L17.216|
                  |L17.100|
000064  6a22              LDR      r2,[r4,#0x20]         ;3679
000066  4922              LDR      r1,|L17.240|
000068  6411              STR      r1,[r2,#0x40]         ;3682
00006a  6a21              LDR      r1,[r4,#0x20]         ;3682
00006c  6508              STR      r0,[r1,#0x50]         ;3685
00006e  6822              LDR      r2,[r4,#0]            ;3687
000070  6a20              LDR      r0,[r4,#0x20]         ;3687
000072  e005              B        |L17.128|
                  |L17.116|
000074  6a62              LDR      r2,[r4,#0x24]         ;3691
000076  6411              STR      r1,[r2,#0x40]         ;3694
000078  6a61              LDR      r1,[r4,#0x24]         ;3694
00007a  6508              STR      r0,[r1,#0x50]         ;3697
00007c  6822              LDR      r2,[r4,#0]            ;3697
00007e  6a60              LDR      r0,[r4,#0x24]         ;3697
                  |L17.128|
000080  4661              MOV      r1,r12                ;3685
000082  324c              ADDS     r2,r2,#0x4c           ;3685
000084  f7fffffe          BL       HAL_DMA_Start_IT
                  |L17.136|
000088  6821              LDR      r1,[r4,#0]            ;3764
00008a  ea480005          ORR      r0,r8,r5              ;3764
00008e  6488              STR      r0,[r1,#0x48]         ;3764
000090  6820              LDR      r0,[r4,#0]            ;3767
000092  68c1              LDR      r1,[r0,#0xc]          ;3767
000094  4331              ORRS     r1,r1,r6              ;3767
000096  60c1              STR      r1,[r0,#0xc]          ;3767
000098  6427              STR      r7,[r4,#0x40]         ;3769
00009a  2000              MOVS     r0,#0                 ;3772
00009c  e7c1              B        |L17.34|
                  |L17.158|
00009e  6aa2              LDR      r2,[r4,#0x28]         ;3703
0000a0  6411              STR      r1,[r2,#0x40]         ;3706
0000a2  6aa1              LDR      r1,[r4,#0x28]         ;3706
0000a4  6508              STR      r0,[r1,#0x50]         ;3709
0000a6  6822              LDR      r2,[r4,#0]            ;3711
0000a8  6aa0              LDR      r0,[r4,#0x28]         ;3711
0000aa  e7e9              B        |L17.128|
                  |L17.172|
0000ac  6ae2              LDR      r2,[r4,#0x2c]         ;3715
0000ae  6411              STR      r1,[r2,#0x40]         ;3718
0000b0  6ae1              LDR      r1,[r4,#0x2c]         ;3718
0000b2  6508              STR      r0,[r1,#0x50]         ;3721
0000b4  6822              LDR      r2,[r4,#0]            ;3723
0000b6  6ae0              LDR      r0,[r4,#0x2c]         ;3723
0000b8  e7e2              B        |L17.128|
                  |L17.186|
0000ba  6b22              LDR      r2,[r4,#0x30]         ;3727
0000bc  6411              STR      r1,[r2,#0x40]         ;3730
0000be  6b21              LDR      r1,[r4,#0x30]         ;3730
0000c0  6508              STR      r0,[r1,#0x50]         ;3733
0000c2  6822              LDR      r2,[r4,#0]            ;3735
0000c4  6b20              LDR      r0,[r4,#0x30]         ;3735
0000c6  e7db              B        |L17.128|
                  |L17.200|
0000c8  6b62              LDR      r2,[r4,#0x34]         ;3739
0000ca  490a              LDR      r1,|L17.244|
0000cc  6411              STR      r1,[r2,#0x40]         ;3742
0000ce  6b61              LDR      r1,[r4,#0x34]         ;3742
0000d0  6508              STR      r0,[r1,#0x50]         ;3745
0000d2  6822              LDR      r2,[r4,#0]            ;3747
0000d4  6b60              LDR      r0,[r4,#0x34]         ;3747
0000d6  e7d3              B        |L17.128|
                  |L17.216|
0000d8  6ba2              LDR      r2,[r4,#0x38]         ;3751
0000da  4907              LDR      r1,|L17.248|
0000dc  6411              STR      r1,[r2,#0x40]         ;3754
0000de  6ba1              LDR      r1,[r4,#0x38]         ;3754
0000e0  6508              STR      r0,[r1,#0x50]         ;3757
0000e2  6822              LDR      r2,[r4,#0]            ;3759
0000e4  6ba0              LDR      r0,[r4,#0x38]         ;3759
0000e6  e7cb              B        |L17.128|
;;;3774   
                          ENDP

                  |L17.232|
                          DCD      TIM_DMAError
                  |L17.236|
                          DCD      TIM_DMADelayPulseCplt
                  |L17.240|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L17.244|
                          DCD      TIMEx_DMACommutationCplt
                  |L17.248|
                          DCD      TIM_DMATriggerCplt

                          AREA ||i.HAL_TIM_DMABurst_WriteStop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_DMABurst_WriteStop PROC
;;;3781     */
;;;3782   HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
000000  b570              PUSH     {r4-r6,lr}
;;;3783   {
;;;3784     /* Check the parameters */
;;;3785     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3786     
;;;3787     /* Abort the DMA transfer (at least disable the DMA channel) */
;;;3788     switch(BurstRequestSrc)
000002  f5b16f00          CMP      r1,#0x800
000006  460d              MOV      r5,r1                 ;3783
000008  4604              MOV      r4,r0                 ;3783
00000a  d021              BEQ      |L18.80|
00000c  dc09              BGT      |L18.34|
00000e  f5b57f80          CMP      r5,#0x100
000012  d010              BEQ      |L18.54|
000014  f5b57f00          CMP      r5,#0x200
000018  d00f              BEQ      |L18.58|
00001a  f5b56f80          CMP      r5,#0x400
00001e  d10f              BNE      |L18.64|
000020  e014              B        |L18.76|
                  |L18.34|
000022  f5b55f80          CMP      r5,#0x1000
000026  d015              BEQ      |L18.84|
000028  f5b55f00          CMP      r5,#0x2000
00002c  d014              BEQ      |L18.88|
00002e  f5b54f80          CMP      r5,#0x4000
000032  d105              BNE      |L18.64|
000034  e012              B        |L18.92|
                  |L18.54|
;;;3789     {
;;;3790       case TIM_DMA_UPDATE:
;;;3791       {  
;;;3792         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
;;;3793       }
;;;3794       break;
000036  6a20              LDR      r0,[r4,#0x20]
000038  e000              B        |L18.60|
                  |L18.58|
;;;3795       case TIM_DMA_CC1:
;;;3796       {  
;;;3797         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
00003a  6a60              LDR      r0,[r4,#0x24]
                  |L18.60|
00003c  f7fffffe          BL       HAL_DMA_Abort
                  |L18.64|
;;;3798       }
;;;3799       break;
;;;3800       case TIM_DMA_CC2:
;;;3801       {  
;;;3802         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
;;;3803       }
;;;3804       break;
;;;3805       case TIM_DMA_CC3:
;;;3806       {  
;;;3807         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
;;;3808       }
;;;3809       break;
;;;3810       case TIM_DMA_CC4:
;;;3811       {  
;;;3812         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
;;;3813       }
;;;3814       break;
;;;3815       case TIM_DMA_COM:
;;;3816       {  
;;;3817         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
;;;3818       }
;;;3819       break;
;;;3820       case TIM_DMA_TRIGGER:
;;;3821       {  
;;;3822         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
;;;3823       }
;;;3824       break;
;;;3825       default:
;;;3826       break;
;;;3827     }
;;;3828   
;;;3829     /* Disable the TIM Update DMA request */
;;;3830     __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
000040  6820              LDR      r0,[r4,#0]
000042  68c1              LDR      r1,[r0,#0xc]
000044  43a9              BICS     r1,r1,r5
000046  60c1              STR      r1,[r0,#0xc]
;;;3831         
;;;3832     /* Return function status */
;;;3833     return HAL_OK;  
000048  2000              MOVS     r0,#0
;;;3834   }
00004a  bd70              POP      {r4-r6,pc}
                  |L18.76|
00004c  6aa0              LDR      r0,[r4,#0x28]         ;3804
00004e  e7f5              B        |L18.60|
                  |L18.80|
000050  6ae0              LDR      r0,[r4,#0x2c]         ;3809
000052  e7f3              B        |L18.60|
                  |L18.84|
000054  6b20              LDR      r0,[r4,#0x30]         ;3814
000056  e7f1              B        |L18.60|
                  |L18.88|
000058  6b60              LDR      r0,[r4,#0x34]         ;3819
00005a  e7ef              B        |L18.60|
                  |L18.92|
00005c  6ba0              LDR      r0,[r4,#0x38]         ;3824
00005e  e7ed              B        |L18.60|
;;;3835   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_DeInit PROC
;;;2566     */
;;;2567   HAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;2568   {
000002  4604              MOV      r4,r0
;;;2569     /* Check the parameters */
;;;2570     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;2571     
;;;2572     htim->State = HAL_TIM_STATE_BUSY;
;;;2573     
;;;2574     /* Disable the TIM Peripheral Clock */
;;;2575     __HAL_TIM_DISABLE(htim);
000004  f2411211          MOV      r2,#0x1111
000008  2002              MOVS     r0,#2                 ;2572
00000a  6420              STR      r0,[r4,#0x40]         ;2572
00000c  6820              LDR      r0,[r4,#0]
00000e  6a01              LDR      r1,[r0,#0x20]
000010  4211              TST      r1,r2
000012  d107              BNE      |L19.36|
000014  6a01              LDR      r1,[r0,#0x20]
000016  1092              ASRS     r2,r2,#2
000018  4211              TST      r1,r2
00001a  d103              BNE      |L19.36|
00001c  6801              LDR      r1,[r0,#0]
00001e  f0210101          BIC      r1,r1,#1
000022  6001              STR      r1,[r0,#0]
                  |L19.36|
;;;2576   
;;;2577   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;2578     if(htim->Encoder_MspDeInitCallback == NULL)
;;;2579     {
;;;2580       htim->Encoder_MspDeInitCallback = HAL_TIM_Encoder_MspDeInit;
;;;2581     }
;;;2582     /* DeInit the low level hardware */
;;;2583     htim->Encoder_MspDeInitCallback(htim);
;;;2584   #else
;;;2585     /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;2586     HAL_TIM_Encoder_MspDeInit(htim);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       HAL_TIM_Encoder_MspDeInit
;;;2587   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;2588   
;;;2589     /* Change TIM state */  
;;;2590     htim->State = HAL_TIM_STATE_RESET;
00002a  2000              MOVS     r0,#0
00002c  6420              STR      r0,[r4,#0x40]
;;;2591    
;;;2592     /* Release Lock */
;;;2593     __HAL_UNLOCK(htim);
00002e  63e0              STR      r0,[r4,#0x3c]
;;;2594   
;;;2595     return HAL_OK;
;;;2596   }
000030  bd10              POP      {r4,pc}
;;;2597   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_GetState PROC
;;;5289     */
;;;5290   HAL_TIM_StateTypeDef HAL_TIM_Encoder_GetState(TIM_HandleTypeDef *htim)
000000  6c00              LDR      r0,[r0,#0x40]
;;;5291   {
;;;5292     return htim->State;
;;;5293   }
000002  4770              BX       lr
;;;5294   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Init||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Encoder_Init PROC
;;;2461     */
;;;2462   HAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim,  TIM_Encoder_InitTypeDef* sConfig)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2463   {
000004  0004              MOVS     r4,r0
000006  460d              MOV      r5,r1
000008  d002              BEQ      |L21.16|
;;;2464     uint32_t tmpsmcr = 0;
;;;2465     uint32_t tmpccmr1 = 0;
;;;2466     uint32_t tmpccer = 0;
;;;2467     
;;;2468     /* Check the TIM handle allocation */
;;;2469     if(htim == NULL)
;;;2470     {
;;;2471       return HAL_ERROR;
;;;2472     }
;;;2473      
;;;2474     /* Check the parameters */
;;;2475     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2476     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;2477     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;2478     assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;2479     assert_param(IS_TIM_ENCODER_MODE(sConfig->EncoderMode));
;;;2480     assert_param(IS_TIM_IC_SELECTION(sConfig->IC1Selection));
;;;2481     assert_param(IS_TIM_IC_SELECTION(sConfig->IC2Selection));
;;;2482     assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
;;;2483     assert_param(IS_TIM_IC_POLARITY(sConfig->IC2Polarity));
;;;2484     assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
;;;2485     assert_param(IS_TIM_IC_PRESCALER(sConfig->IC2Prescaler));
;;;2486     assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
;;;2487     assert_param(IS_TIM_IC_FILTER(sConfig->IC2Filter));
;;;2488   
;;;2489     if(htim->State == HAL_TIM_STATE_RESET)
00000a  6c20              LDR      r0,[r4,#0x40]
00000c  b118              CBZ      r0,|L21.22|
00000e  e007              B        |L21.32|
                  |L21.16|
000010  2001              MOVS     r0,#1                 ;2471
                  |L21.18|
;;;2490     {
;;;2491       /* Allocate lock resource and initialize it */
;;;2492       htim->Lock = HAL_UNLOCKED;
;;;2493   
;;;2494   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;2495       /* Reset interrupt callbacks to legacy week callbacks */
;;;2496       TIM_ResetCallback(htim);
;;;2497   
;;;2498       if(htim->Encoder_MspInitCallback == NULL)
;;;2499       {
;;;2500         htim->Encoder_MspInitCallback = HAL_TIM_Encoder_MspInit;
;;;2501       }
;;;2502       /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;2503       htim->Encoder_MspInitCallback(htim);
;;;2504   #else
;;;2505       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;2506       HAL_TIM_Encoder_MspInit(htim);
;;;2507   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;2508     }
;;;2509   
;;;2510     /* Set the TIM state */
;;;2511     htim->State= HAL_TIM_STATE_BUSY;   
;;;2512       
;;;2513     /* Reset the SMS bits */
;;;2514     htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;2515     
;;;2516     /* Configure the Time base in the Encoder Mode */
;;;2517     TIM_Base_SetConfig(htim->Instance, &htim->Init);  
;;;2518     
;;;2519     /* Get the TIMx SMCR register value */
;;;2520     tmpsmcr = htim->Instance->SMCR;
;;;2521   
;;;2522     /* Get the TIMx CCMR1 register value */
;;;2523     tmpccmr1 = htim->Instance->CCMR1;
;;;2524   
;;;2525     /* Get the TIMx CCER register value */
;;;2526     tmpccer = htim->Instance->CCER;
;;;2527   
;;;2528     /* Set the encoder Mode */
;;;2529     tmpsmcr |= sConfig->EncoderMode;
;;;2530   
;;;2531     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;2532     tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
;;;2533     tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8));
;;;2534     
;;;2535     /* Set the Capture Compare 1 and the Capture Compare 2 prescalers and filters */
;;;2536     tmpccmr1 &= ~(TIM_CCMR1_IC1PSC | TIM_CCMR1_IC2PSC);
;;;2537     tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
;;;2538     tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8);
;;;2539     tmpccmr1 |= (sConfig->IC1Filter << 4) | (sConfig->IC2Filter << 12);
;;;2540   
;;;2541     /* Set the TI1 and the TI2 Polarities */
;;;2542     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);
;;;2543     tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
;;;2544     tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4);
;;;2545     
;;;2546     /* Write to TIMx SMCR */
;;;2547     htim->Instance->SMCR = tmpsmcr;
;;;2548   
;;;2549     /* Write to TIMx CCMR1 */
;;;2550     htim->Instance->CCMR1 = tmpccmr1;
;;;2551   
;;;2552     /* Write to TIMx CCER */
;;;2553     htim->Instance->CCER = tmpccer;
;;;2554     
;;;2555     /* Initialize the TIM state*/
;;;2556     htim->State= HAL_TIM_STATE_READY;
;;;2557     
;;;2558     return HAL_OK;
;;;2559   }
000012  e8bd81f0          POP      {r4-r8,pc}
                  |L21.22|
000016  2000              MOVS     r0,#0                 ;2492
000018  63e0              STR      r0,[r4,#0x3c]         ;2506
00001a  4620              MOV      r0,r4                 ;2506
00001c  f7fffffe          BL       HAL_TIM_Encoder_MspInit
                  |L21.32|
000020  4a1e              LDR      r2,|L21.156|
000022  2002              MOVS     r0,#2                 ;2511
000024  6420              STR      r0,[r4,#0x40]         ;2511
000026  6820              LDR      r0,[r4,#0]            ;2514
000028  6881              LDR      r1,[r0,#8]            ;2514
00002a  4011              ANDS     r1,r1,r2              ;2514
00002c  6081              STR      r1,[r0,#8]            ;2514
00002e  6820              LDR      r0,[r4,#0]            ;2517
000030  1d21              ADDS     r1,r4,#4              ;2517
000032  f7fffffe          BL       TIM_Base_SetConfig
000036  6822              LDR      r2,[r4,#0]            ;2533
000038  f2403603          MOV      r6,#0x303             ;2532
00003c  69af              LDR      r7,[r5,#0x18]         ;2520
00003e  f6404c0c          MOV      r12,#0xc0c            ;2536
000042  682b              LDR      r3,[r5,#0]            ;2520
000044  f24f0ef0          MOV      lr,#0xf0f0            ;2537
000048  68a8              LDR      r0,[r5,#8]            ;2520
00004a  6891              LDR      r1,[r2,#8]            ;2520
00004c  430b              ORRS     r3,r3,r1              ;2529
00004e  6991              LDR      r1,[r2,#0x18]         ;2523
000050  43b1              BICS     r1,r1,r6              ;2532
000052  ea412107          ORR      r1,r1,r7,LSL #8       ;2533
000056  4308              ORRS     r0,r0,r1              ;2533
000058  e9d51703          LDRD     r1,r7,[r5,#0xc]       ;2537
00005c  ea20000c          BIC      r0,r0,r12             ;2536
000060  e9d56c07          LDRD     r6,r12,[r5,#0x1c]     ;2539
000064  ea20000e          BIC      r0,r0,lr              ;2537
000068  f8d2e020          LDR      lr,[r2,#0x20]         ;2526
00006c  013f              LSLS     r7,r7,#4              ;2539
00006e  ea402606          ORR      r6,r0,r6,LSL #8       ;2538
000072  6868              LDR      r0,[r5,#4]            ;2544
000074  696d              LDR      r5,[r5,#0x14]         ;2544
000076  4331              ORRS     r1,r1,r6              ;2538
000078  ea47370c          ORR      r7,r7,r12,LSL #12     ;2539
00007c  6093              STR      r3,[r2,#8]            ;2547
00007e  6823              LDR      r3,[r4,#0]            ;2550
000080  430f              ORRS     r7,r7,r1              ;2539
000082  2201              MOVS     r2,#1                 ;2556
000084  619f              STR      r7,[r3,#0x18]         ;2550
000086  f02e01aa          BIC      r1,lr,#0xaa           ;2543
00008a  ea411305          ORR      r3,r1,r5,LSL #4       ;2544
00008e  6821              LDR      r1,[r4,#0]            ;2553
000090  4318              ORRS     r0,r0,r3              ;2544
000092  6208              STR      r0,[r1,#0x20]         ;2553
000094  6422              STR      r2,[r4,#0x40]         ;2556
000096  2000              MOVS     r0,#0                 ;2558
000098  e7bb              B        |L21.18|
;;;2560   
                          ENDP

00009a  0000              DCW      0x0000
                  |L21.156|
                          DCD      0xfffefff8

                          AREA ||i.HAL_TIM_Encoder_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_MspDeInit PROC
;;;2619     */
;;;2620   __weak void HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2621   {
;;;2622     /* Prevent unused argument(s) compilation warning */
;;;2623     UNUSED(htim);
;;;2624    
;;;2625     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2626               the HAL_TIM_Encoder_MspDeInit could be implemented in the user file
;;;2627      */
;;;2628   }
;;;2629   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_MspInit PROC
;;;2603     */
;;;2604   __weak void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2605   {
;;;2606     /* Prevent unused argument(s) compilation warning */
;;;2607     UNUSED(htim);
;;;2608    
;;;2609     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2610               the HAL_TIM_Encoder_MspInit could be implemented in the user file
;;;2611      */
;;;2612   }
;;;2613   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Encoder_Start PROC
;;;2640     */
;;;2641   HAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;2642   {
000002  4604              MOV      r4,r0
;;;2643     /* Check the parameters */
;;;2644     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2645     
;;;2646     /* Enable the encoder interface channels */
;;;2647     switch (Channel)
;;;2648     {
;;;2649       case TIM_CHANNEL_1:
;;;2650       {
;;;2651         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
000004  6800              LDR      r0,[r0,#0]
000006  b191              CBZ      r1,|L24.46|
000008  2904              CMP      r1,#4                 ;2647
00000a  d004              BEQ      |L24.22|
;;;2652         break; 
;;;2653       }
;;;2654       case TIM_CHANNEL_2:
;;;2655       { 
;;;2656         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
;;;2657         break;
;;;2658       }  
;;;2659       default :
;;;2660       {
;;;2661        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
00000c  2201              MOVS     r2,#1
00000e  2100              MOVS     r1,#0
000010  f7fffffe          BL       TIM_CCxChannelCmd
;;;2662        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
000014  6820              LDR      r0,[r4,#0]
                  |L24.22|
000016  2201              MOVS     r2,#1                 ;2656
000018  f05f0104          MOVS.W   r1,#4                 ;2656
                  |L24.28|
00001c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2663        break; 
;;;2664       }
;;;2665     }  
;;;2666     /* Enable the Peripheral */
;;;2667     __HAL_TIM_ENABLE(htim);
000020  6820              LDR      r0,[r4,#0]
000022  6801              LDR      r1,[r0,#0]
000024  f0410101          ORR      r1,r1,#1
000028  6001              STR      r1,[r0,#0]
;;;2668     
;;;2669     /* Return function status */
;;;2670     return HAL_OK;
00002a  2000              MOVS     r0,#0
;;;2671   }
00002c  bd10              POP      {r4,pc}
                  |L24.46|
00002e  2201              MOVS     r2,#1                 ;2651
000030  2100              MOVS     r1,#0                 ;2651
000032  e7f3              B        |L24.28|
;;;2672   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Encoder_Start_DMA PROC
;;;2831     */
;;;2832   HAL_StatusTypeDef HAL_TIM_Encoder_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData1, uint32_t *pData2, uint16_t Length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2833   {
000004  4604              MOV      r4,r0
;;;2834     /* Check the parameters */
;;;2835     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;2836     
;;;2837     if((htim->State == HAL_TIM_STATE_BUSY))
000006  6c00              LDR      r0,[r0,#0x40]
000008  4698              MOV      r8,r3                 ;2833
00000a  9f06              LDR      r7,[sp,#0x18]
00000c  2802              CMP      r0,#2
00000e  d008              BEQ      |L25.34|
;;;2838     {
;;;2839        return HAL_BUSY;
;;;2840     }
;;;2841     else if((htim->State == HAL_TIM_STATE_READY))
000010  6c20              LDR      r0,[r4,#0x40]
000012  2801              CMP      r0,#1
000014  d109              BNE      |L25.42|
;;;2842     {
;;;2843       if((((pData1 == 0) || (pData2 == 0) )) && (Length > 0)) 
000016  b112              CBZ      r2,|L25.30|
000018  f1b80f00          CMP      r8,#0
00001c  d103              BNE      |L25.38|
                  |L25.30|
00001e  b117              CBZ      r7,|L25.38|
;;;2844       {
;;;2845         return HAL_ERROR;                                    
000020  2001              MOVS     r0,#1
                  |L25.34|
;;;2846       }
;;;2847       else
;;;2848       {
;;;2849         htim->State = HAL_TIM_STATE_BUSY;
;;;2850       }
;;;2851     }  
;;;2852      
;;;2853     switch (Channel)
;;;2854     {
;;;2855       case TIM_CHANNEL_1:
;;;2856       {
;;;2857         /* Set the DMA Period elapsed callback */
;;;2858         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;2859        
;;;2860         /* Set the DMA error callback */
;;;2861         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
;;;2862         
;;;2863         /* Enable the DMA Stream */
;;;2864         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t )pData1, Length); 
;;;2865         
;;;2866         /* Enable the TIM Input Capture DMA request */      
;;;2867         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;2868               
;;;2869         /* Enable the Peripheral */
;;;2870         __HAL_TIM_ENABLE(htim);
;;;2871         
;;;2872         /* Enable the Capture compare channel */
;;;2873         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2874       }
;;;2875       break;
;;;2876       
;;;2877       case TIM_CHANNEL_2:
;;;2878       {
;;;2879         /* Set the DMA Period elapsed callback */
;;;2880         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;2881        
;;;2882         /* Set the DMA error callback */
;;;2883         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError;
;;;2884         /* Enable the DMA Stream */
;;;2885         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
;;;2886         
;;;2887         /* Enable the TIM Input Capture  DMA request */
;;;2888         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;2889        
;;;2890         /* Enable the Peripheral */
;;;2891         __HAL_TIM_ENABLE(htim);
;;;2892         
;;;2893         /* Enable the Capture compare channel */
;;;2894         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2895       }
;;;2896       break;
;;;2897       
;;;2898       case TIM_CHANNEL_ALL:
;;;2899       {
;;;2900         /* Set the DMA Period elapsed callback */
;;;2901         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;2902        
;;;2903         /* Set the DMA error callback */
;;;2904         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
;;;2905         
;;;2906         /* Enable the DMA Stream */
;;;2907         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length);
;;;2908         
;;;2909         /* Set the DMA Period elapsed callback */
;;;2910         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;2911        
;;;2912         /* Set the DMA error callback */
;;;2913         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
;;;2914         
;;;2915         /* Enable the DMA Stream */
;;;2916         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
;;;2917             
;;;2918        /* Enable the Peripheral */
;;;2919         __HAL_TIM_ENABLE(htim);
;;;2920         
;;;2921         /* Enable the Capture compare channel */
;;;2922         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2923         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2924         
;;;2925         /* Enable the TIM Input Capture  DMA request */
;;;2926         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;2927         /* Enable the TIM Input Capture  DMA request */
;;;2928         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;2929       }
;;;2930       break;
;;;2931       
;;;2932       default:
;;;2933       break;
;;;2934     }  
;;;2935     /* Return function status */
;;;2936     return HAL_OK;
;;;2937   }
000022  e8bd81f0          POP      {r4-r8,pc}
                  |L25.38|
000026  2002              MOVS     r0,#2                 ;2849
000028  6420              STR      r0,[r4,#0x40]         ;2849
                  |L25.42|
00002a  4d35              LDR      r5,|L25.256|
00002c  4e35              LDR      r6,|L25.260|
00002e  b121              CBZ      r1,|L25.58|
000030  2904              CMP      r1,#4                 ;2853
000032  d01a              BEQ      |L25.106|
000034  293c              CMP      r1,#0x3c              ;2853
000036  d161              BNE      |L25.252|
000038  e032              B        |L25.160|
                  |L25.58|
00003a  6a60              LDR      r0,[r4,#0x24]         ;2858
00003c  463b              MOV      r3,r7                 ;2864
00003e  6405              STR      r5,[r0,#0x40]         ;2861
000040  6a60              LDR      r0,[r4,#0x24]         ;2861
000042  6506              STR      r6,[r0,#0x50]         ;2864
000044  6821              LDR      r1,[r4,#0]            ;2864
000046  6a60              LDR      r0,[r4,#0x24]         ;2864
000048  3134              ADDS     r1,r1,#0x34           ;2864
00004a  f7fffffe          BL       HAL_DMA_Start_IT
00004e  6820              LDR      r0,[r4,#0]            ;2867
000050  68c1              LDR      r1,[r0,#0xc]          ;2867
000052  f4417100          ORR      r1,r1,#0x200          ;2867
000056  60c1              STR      r1,[r0,#0xc]          ;2867
000058  6820              LDR      r0,[r4,#0]            ;2870
00005a  6801              LDR      r1,[r0,#0]            ;2870
00005c  f0410101          ORR      r1,r1,#1              ;2870
000060  6001              STR      r1,[r0,#0]            ;2870
000062  2201              MOVS     r2,#1                 ;2873
000064  6820              LDR      r0,[r4,#0]            ;2875
000066  2100              MOVS     r1,#0                 ;2873
000068  e017              B        |L25.154|
                  |L25.106|
00006a  6aa0              LDR      r0,[r4,#0x28]         ;2880
00006c  463b              MOV      r3,r7                 ;2885
00006e  4642              MOV      r2,r8                 ;2885
000070  6405              STR      r5,[r0,#0x40]         ;2883
000072  6aa0              LDR      r0,[r4,#0x28]         ;2883
000074  6506              STR      r6,[r0,#0x50]         ;2885
000076  6821              LDR      r1,[r4,#0]            ;2885
000078  6aa0              LDR      r0,[r4,#0x28]         ;2885
00007a  3138              ADDS     r1,r1,#0x38           ;2885
00007c  f7fffffe          BL       HAL_DMA_Start_IT
000080  6820              LDR      r0,[r4,#0]            ;2888
000082  68c1              LDR      r1,[r0,#0xc]          ;2888
000084  f4416180          ORR      r1,r1,#0x400          ;2888
000088  60c1              STR      r1,[r0,#0xc]          ;2888
00008a  6820              LDR      r0,[r4,#0]            ;2891
00008c  6801              LDR      r1,[r0,#0]            ;2891
00008e  f0410101          ORR      r1,r1,#1              ;2891
000092  6001              STR      r1,[r0,#0]            ;2891
000094  6820              LDR      r0,[r4,#0]            ;2894
000096  2201              MOVS     r2,#1                 ;2894
000098  2104              MOVS     r1,#4                 ;2894
                  |L25.154|
00009a  f7fffffe          BL       TIM_CCxChannelCmd
00009e  e02d              B        |L25.252|
                  |L25.160|
0000a0  6a60              LDR      r0,[r4,#0x24]         ;2901
0000a2  463b              MOV      r3,r7                 ;2907
0000a4  6405              STR      r5,[r0,#0x40]         ;2904
0000a6  6a60              LDR      r0,[r4,#0x24]         ;2904
0000a8  6506              STR      r6,[r0,#0x50]         ;2907
0000aa  6821              LDR      r1,[r4,#0]            ;2907
0000ac  6a60              LDR      r0,[r4,#0x24]         ;2907
0000ae  3134              ADDS     r1,r1,#0x34           ;2907
0000b0  f7fffffe          BL       HAL_DMA_Start_IT
0000b4  6aa0              LDR      r0,[r4,#0x28]         ;2910
0000b6  463b              MOV      r3,r7                 ;2916
0000b8  4642              MOV      r2,r8                 ;2916
0000ba  6405              STR      r5,[r0,#0x40]         ;2913
0000bc  6aa0              LDR      r0,[r4,#0x28]         ;2913
0000be  6506              STR      r6,[r0,#0x50]         ;2916
0000c0  6821              LDR      r1,[r4,#0]            ;2916
0000c2  6aa0              LDR      r0,[r4,#0x28]         ;2916
0000c4  3138              ADDS     r1,r1,#0x38           ;2916
0000c6  f7fffffe          BL       HAL_DMA_Start_IT
0000ca  6820              LDR      r0,[r4,#0]            ;2919
0000cc  6801              LDR      r1,[r0,#0]            ;2919
0000ce  f0410101          ORR      r1,r1,#1              ;2919
0000d2  6001              STR      r1,[r0,#0]            ;2919
0000d4  6820              LDR      r0,[r4,#0]            ;2922
0000d6  2201              MOVS     r2,#1                 ;2922
0000d8  2100              MOVS     r1,#0                 ;2922
0000da  f7fffffe          BL       TIM_CCxChannelCmd
0000de  6820              LDR      r0,[r4,#0]            ;2923
0000e0  2201              MOVS     r2,#1                 ;2923
0000e2  2104              MOVS     r1,#4                 ;2923
0000e4  f7fffffe          BL       TIM_CCxChannelCmd
0000e8  6820              LDR      r0,[r4,#0]            ;2926
0000ea  68c1              LDR      r1,[r0,#0xc]          ;2926
0000ec  f4417100          ORR      r1,r1,#0x200          ;2926
0000f0  60c1              STR      r1,[r0,#0xc]          ;2926
0000f2  6820              LDR      r0,[r4,#0]            ;2928
0000f4  68c1              LDR      r1,[r0,#0xc]          ;2928
0000f6  f4416180          ORR      r1,r1,#0x400          ;2928
0000fa  60c1              STR      r1,[r0,#0xc]          ;2928
                  |L25.252|
0000fc  2000              MOVS     r0,#0                 ;2936
0000fe  e790              B        |L25.34|
;;;2938   
                          ENDP

                  |L25.256|
                          DCD      TIM_DMACaptureCplt
                  |L25.260|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_Encoder_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Start_IT PROC
;;;2727     */
;;;2728   HAL_StatusTypeDef HAL_TIM_Encoder_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;2729   {
000002  4604              MOV      r4,r0
;;;2730     /* Check the parameters */
;;;2731     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2732     
;;;2733     /* Enable the encoder interface channels */
;;;2734     /* Enable the capture compare Interrupts 1 and/or 2 */
;;;2735     switch (Channel)
;;;2736     {
;;;2737       case TIM_CHANNEL_1:
;;;2738       {
;;;2739         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
000004  6800              LDR      r0,[r0,#0]
000006  b189              CBZ      r1,|L26.44|
000008  2904              CMP      r1,#4                 ;2735
;;;2740         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
;;;2741         break; 
;;;2742       }
;;;2743       case TIM_CHANNEL_2:
;;;2744       { 
;;;2745         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
00000a  f04f0201          MOV      r2,#1
00000e  d016              BEQ      |L26.62|
;;;2746         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2); 
;;;2747         break;
;;;2748       }  
;;;2749       default :
;;;2750       {
;;;2751        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
000010  2100              MOVS     r1,#0
000012  f7fffffe          BL       TIM_CCxChannelCmd
;;;2752        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
000016  6820              LDR      r0,[r4,#0]
000018  2201              MOVS     r2,#1
00001a  2104              MOVS     r1,#4
00001c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2753        __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000020  6820              LDR      r0,[r4,#0]
000022  68c1              LDR      r1,[r0,#0xc]
000024  f0410102          ORR      r1,r1,#2
000028  60c1              STR      r1,[r0,#0xc]
;;;2754        __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
;;;2755        break; 
00002a  e00b              B        |L26.68|
                  |L26.44|
00002c  2201              MOVS     r2,#1                 ;2739
00002e  2100              MOVS     r1,#0                 ;2739
000030  f7fffffe          BL       TIM_CCxChannelCmd
000034  6820              LDR      r0,[r4,#0]            ;2740
000036  68c1              LDR      r1,[r0,#0xc]          ;2740
000038  f0410102          ORR      r1,r1,#2              ;2740
00003c  e006              B        |L26.76|
                  |L26.62|
00003e  2104              MOVS     r1,#4                 ;2745
000040  f7fffffe          BL       TIM_CCxChannelCmd
                  |L26.68|
000044  6820              LDR      r0,[r4,#0]            ;2754
000046  68c1              LDR      r1,[r0,#0xc]          ;2754
000048  f0410104          ORR      r1,r1,#4              ;2754
                  |L26.76|
00004c  60c1              STR      r1,[r0,#0xc]          ;2740
;;;2756       }
;;;2757     }
;;;2758     
;;;2759     /* Enable the Peripheral */
;;;2760     __HAL_TIM_ENABLE(htim);
00004e  6820              LDR      r0,[r4,#0]
000050  6801              LDR      r1,[r0,#0]
000052  f0410101          ORR      r1,r1,#1
000056  6001              STR      r1,[r0,#0]
;;;2761     
;;;2762     /* Return function status */
;;;2763     return HAL_OK;
000058  2000              MOVS     r0,#0
;;;2764   }
00005a  bd10              POP      {r4,pc}
;;;2765   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Encoder_Stop PROC
;;;2683     */
;;;2684   HAL_StatusTypeDef HAL_TIM_Encoder_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;2685   {
000002  4604              MOV      r4,r0
;;;2686     /* Check the parameters */
;;;2687       assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2688       
;;;2689      /* Disable the Input Capture channels 1 and 2
;;;2690       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
;;;2691     switch (Channel)
;;;2692     {
;;;2693       case TIM_CHANNEL_1:
;;;2694       {
;;;2695         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000004  6800              LDR      r0,[r0,#0]
000006  b1d9              CBZ      r1,|L27.64|
000008  2904              CMP      r1,#4                 ;2691
00000a  d004              BEQ      |L27.22|
;;;2696         break; 
;;;2697       }
;;;2698       case TIM_CHANNEL_2:
;;;2699       { 
;;;2700         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
;;;2701         break;
;;;2702       }  
;;;2703       default :
;;;2704       {
;;;2705        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
00000c  2200              MOVS     r2,#0
00000e  4611              MOV      r1,r2
000010  f7fffffe          BL       TIM_CCxChannelCmd
;;;2706        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
000014  6820              LDR      r0,[r4,#0]
                  |L27.22|
000016  2200              MOVS     r2,#0                 ;2700
000018  f05f0104          MOVS.W   r1,#4                 ;2700
                  |L27.28|
00001c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2707        break; 
;;;2708       }
;;;2709     }  
;;;2710     /* Disable the Peripheral */
;;;2711     __HAL_TIM_DISABLE(htim);
000020  6820              LDR      r0,[r4,#0]
000022  f2411211          MOV      r2,#0x1111
000026  6a01              LDR      r1,[r0,#0x20]
000028  4211              TST      r1,r2
00002a  d107              BNE      |L27.60|
00002c  6a01              LDR      r1,[r0,#0x20]
00002e  1092              ASRS     r2,r2,#2
000030  4211              TST      r1,r2
000032  d103              BNE      |L27.60|
000034  6801              LDR      r1,[r0,#0]
000036  f0210101          BIC      r1,r1,#1
00003a  6001              STR      r1,[r0,#0]
                  |L27.60|
;;;2712     
;;;2713     /* Return function status */
;;;2714     return HAL_OK;
00003c  2000              MOVS     r0,#0
;;;2715   }
00003e  bd10              POP      {r4,pc}
                  |L27.64|
000040  2200              MOVS     r2,#0                 ;2695
000042  4611              MOV      r1,r2                 ;2695
000044  e7ea              B        |L27.28|
;;;2716   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Stop_DMA PROC
;;;2949     */
;;;2950   HAL_StatusTypeDef HAL_TIM_Encoder_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;2951   {
000002  4604              MOV      r4,r0
;;;2952     /* Check the parameters */
;;;2953     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;2954     
;;;2955     /* Disable the Input Capture channels 1 and 2
;;;2956       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
;;;2957     if(Channel == TIM_CHANNEL_1)
;;;2958     {
;;;2959       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
000004  6800              LDR      r0,[r0,#0]
000006  b339              CBZ      r1,|L28.88|
;;;2960       
;;;2961       /* Disable the capture compare DMA Request 1 */
;;;2962       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
;;;2963     }  
;;;2964     else if(Channel == TIM_CHANNEL_2)
000008  2904              CMP      r1,#4
;;;2965     {  
;;;2966       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
;;;2967       
;;;2968       /* Disable the capture compare DMA Request 2 */
;;;2969       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
;;;2970     }  
;;;2971     else
;;;2972     {
;;;2973       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
00000a  f04f0200          MOV      r2,#0
00000e  d02c              BEQ      |L28.106|
000010  2100              MOVS     r1,#0
000012  f7fffffe          BL       TIM_CCxChannelCmd
;;;2974       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
000016  6820              LDR      r0,[r4,#0]
000018  2200              MOVS     r2,#0
00001a  2104              MOVS     r1,#4
00001c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2975       
;;;2976       /* Disable the capture compare DMA Request 1 and 2 */
;;;2977       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000020  6820              LDR      r0,[r4,#0]
000022  68c1              LDR      r1,[r0,#0xc]
000024  f4217100          BIC      r1,r1,#0x200
000028  60c1              STR      r1,[r0,#0xc]
                  |L28.42|
00002a  6820              LDR      r0,[r4,#0]            ;2969
00002c  68c1              LDR      r1,[r0,#0xc]          ;2969
00002e  f4216180          BIC      r1,r1,#0x400          ;2969
                  |L28.50|
000032  60c1              STR      r1,[r0,#0xc]          ;2969
;;;2978       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
;;;2979     }
;;;2980     
;;;2981     /* Disable the Peripheral */
;;;2982     __HAL_TIM_DISABLE(htim);
000034  6820              LDR      r0,[r4,#0]
000036  f2411211          MOV      r2,#0x1111
00003a  6a01              LDR      r1,[r0,#0x20]
00003c  4211              TST      r1,r2
00003e  d107              BNE      |L28.80|
000040  6a01              LDR      r1,[r0,#0x20]
000042  1092              ASRS     r2,r2,#2
000044  4211              TST      r1,r2
000046  d103              BNE      |L28.80|
000048  6801              LDR      r1,[r0,#0]
00004a  f0210101          BIC      r1,r1,#1
00004e  6001              STR      r1,[r0,#0]
                  |L28.80|
;;;2983     
;;;2984     /* Change the htim state */
;;;2985     htim->State = HAL_TIM_STATE_READY;
000050  2001              MOVS     r0,#1
000052  6420              STR      r0,[r4,#0x40]
;;;2986     
;;;2987     /* Return function status */
;;;2988     return HAL_OK;
000054  2000              MOVS     r0,#0
;;;2989   }
000056  bd10              POP      {r4,pc}
                  |L28.88|
000058  2200              MOVS     r2,#0                 ;2959
00005a  4611              MOV      r1,r2                 ;2959
00005c  f7fffffe          BL       TIM_CCxChannelCmd
000060  6820              LDR      r0,[r4,#0]            ;2962
000062  68c1              LDR      r1,[r0,#0xc]          ;2962
000064  f4217100          BIC      r1,r1,#0x200          ;2962
000068  e7e3              B        |L28.50|
                  |L28.106|
00006a  2104              MOVS     r1,#4                 ;2966
00006c  f7fffffe          BL       TIM_CCxChannelCmd
000070  e7db              B        |L28.42|
;;;2990   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Stop_IT PROC
;;;2776     */
;;;2777   HAL_StatusTypeDef HAL_TIM_Encoder_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;2778   {
000002  4604              MOV      r4,r0
;;;2779     /* Check the parameters */
;;;2780     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2781       
;;;2782     /* Disable the Input Capture channels 1 and 2
;;;2783       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
;;;2784     if(Channel == TIM_CHANNEL_1)
;;;2785     {
;;;2786       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
000004  6800              LDR      r0,[r0,#0]
000006  b339              CBZ      r1,|L29.88|
;;;2787       
;;;2788       /* Disable the capture compare Interrupts 1 */
;;;2789     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
;;;2790     }  
;;;2791     else if(Channel == TIM_CHANNEL_2)
000008  2904              CMP      r1,#4
;;;2792     {  
;;;2793       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
;;;2794       
;;;2795       /* Disable the capture compare Interrupts 2 */
;;;2796     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
;;;2797     }  
;;;2798     else
;;;2799     {
;;;2800       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
00000a  f04f0200          MOV      r2,#0
00000e  d02c              BEQ      |L29.106|
000010  2100              MOVS     r1,#0
000012  f7fffffe          BL       TIM_CCxChannelCmd
;;;2801       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
000016  6820              LDR      r0,[r4,#0]
000018  2200              MOVS     r2,#0
00001a  2104              MOVS     r1,#4
00001c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2802       
;;;2803       /* Disable the capture compare Interrupts 1 and 2 */
;;;2804       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000020  6820              LDR      r0,[r4,#0]
000022  68c1              LDR      r1,[r0,#0xc]
000024  f0210102          BIC      r1,r1,#2
000028  60c1              STR      r1,[r0,#0xc]
                  |L29.42|
00002a  6820              LDR      r0,[r4,#0]            ;2796
00002c  68c1              LDR      r1,[r0,#0xc]          ;2796
00002e  f0210104          BIC      r1,r1,#4              ;2796
                  |L29.50|
000032  60c1              STR      r1,[r0,#0xc]          ;2796
;;;2805       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
;;;2806     }
;;;2807       
;;;2808     /* Disable the Peripheral */
;;;2809     __HAL_TIM_DISABLE(htim);
000034  6820              LDR      r0,[r4,#0]
000036  f2411211          MOV      r2,#0x1111
00003a  6a01              LDR      r1,[r0,#0x20]
00003c  4211              TST      r1,r2
00003e  d107              BNE      |L29.80|
000040  6a01              LDR      r1,[r0,#0x20]
000042  1092              ASRS     r2,r2,#2
000044  4211              TST      r1,r2
000046  d103              BNE      |L29.80|
000048  6801              LDR      r1,[r0,#0]
00004a  f0210101          BIC      r1,r1,#1
00004e  6001              STR      r1,[r0,#0]
                  |L29.80|
;;;2810     
;;;2811     /* Change the htim state */
;;;2812     htim->State = HAL_TIM_STATE_READY;
000050  2001              MOVS     r0,#1
000052  6420              STR      r0,[r4,#0x40]
;;;2813     
;;;2814     /* Return function status */
;;;2815     return HAL_OK;
000054  2000              MOVS     r0,#0
;;;2816   }
000056  bd10              POP      {r4,pc}
                  |L29.88|
000058  2200              MOVS     r2,#0                 ;2786
00005a  4611              MOV      r1,r2                 ;2786
00005c  f7fffffe          BL       TIM_CCxChannelCmd
000060  6820              LDR      r0,[r4,#0]            ;2789
000062  68c1              LDR      r1,[r0,#0xc]          ;2789
000064  f0210102          BIC      r1,r1,#2              ;2789
000068  e7e3              B        |L29.50|
                  |L29.106|
00006a  2104              MOVS     r1,#4                 ;2793
00006c  f7fffffe          BL       TIM_CCxChannelCmd
000070  e7db              B        |L29.42|
;;;2817   
                          ENDP


                          AREA ||i.HAL_TIM_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ErrorCallback PROC
;;;4767     */
;;;4768   __weak void HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4769   {
;;;4770     /* Prevent unused argument(s) compilation warning */
;;;4771     UNUSED(htim);
;;;4772    
;;;4773     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4774               the HAL_TIM_ErrorCallback could be implemented in the user file
;;;4775      */
;;;4776   }
;;;4777   
                          ENDP


                          AREA ||i.HAL_TIM_GenerateEvent||, CODE, READONLY, ALIGN=1

                  HAL_TIM_GenerateEvent PROC
;;;4081   
;;;4082   HAL_StatusTypeDef HAL_TIM_GenerateEvent(TIM_HandleTypeDef *htim, uint32_t EventSource)
000000  b510              PUSH     {r4,lr}
;;;4083   {
;;;4084     /* Check the parameters */
;;;4085     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;4086     assert_param(IS_TIM_EVENT_SOURCE(EventSource));
;;;4087     
;;;4088     /* Process Locked */
;;;4089     __HAL_LOCK(htim);
000002  6bc2              LDR      r2,[r0,#0x3c]
000004  2a01              CMP      r2,#1
000006  d009              BEQ      |L31.28|
000008  2201              MOVS     r2,#1
;;;4090     
;;;4091     /* Change the TIM state */
;;;4092     htim->State = HAL_TIM_STATE_BUSY;
00000a  2302              MOVS     r3,#2
00000c  6403              STR      r3,[r0,#0x40]
;;;4093     
;;;4094     /* Set the event sources */
;;;4095     htim->Instance->EGR = EventSource;
00000e  6804              LDR      r4,[r0,#0]
;;;4096     
;;;4097     /* Change the TIM state */
;;;4098     htim->State = HAL_TIM_STATE_READY;
;;;4099     
;;;4100     __HAL_UNLOCK(htim);
000010  2300              MOVS     r3,#0
000012  6161              STR      r1,[r4,#0x14]         ;4095
000014  6402              STR      r2,[r0,#0x40]         ;4098
;;;4101     
;;;4102     /* Return function status */
;;;4103     return HAL_OK;  
000016  63c3              STR      r3,[r0,#0x3c]
000018  4618              MOV      r0,r3
;;;4104   }
00001a  bd10              POP      {r4,pc}
                  |L31.28|
00001c  2002              MOVS     r0,#2                 ;4089
00001e  bd10              POP      {r4,pc}
;;;4105   
                          ENDP


                          AREA ||i.HAL_TIM_IC_CaptureCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_CaptureCallback PROC
;;;4719     */
;;;4720   __weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4721   {
;;;4722     /* Prevent unused argument(s) compilation warning */
;;;4723     UNUSED(htim);
;;;4724    
;;;4725     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4726               the __HAL_TIM_IC_CaptureCallback could be implemented in the user file
;;;4727      */
;;;4728   }
;;;4729   
                          ENDP


                          AREA ||i.HAL_TIM_IC_ConfigChannel||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_ConfigChannel PROC
;;;3314     */
;;;3315   HAL_StatusTypeDef HAL_TIM_IC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_IC_InitTypeDef* sConfig, uint32_t Channel)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3316   {
000004  4604              MOV      r4,r0
;;;3317     /* Check the parameters */
;;;3318     assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3319     assert_param(IS_TIM_IC_POLARITY(sConfig->ICPolarity));
;;;3320     assert_param(IS_TIM_IC_SELECTION(sConfig->ICSelection));
;;;3321     assert_param(IS_TIM_IC_PRESCALER(sConfig->ICPrescaler));
;;;3322     assert_param(IS_TIM_IC_FILTER(sConfig->ICFilter));
;;;3323     
;;;3324     __HAL_LOCK(htim);
000006  6bc0              LDR      r0,[r0,#0x3c]
000008  460d              MOV      r5,r1                 ;3316
00000a  2801              CMP      r0,#1
00000c  d039              BEQ      |L33.130|
00000e  2601              MOVS     r6,#1
;;;3325     
;;;3326     htim->State = HAL_TIM_STATE_BUSY;
000010  2002              MOVS     r0,#2
000012  e9c4600f          STRD     r6,r0,[r4,#0x3c]
000016  b39a              CBZ      r2,|L33.128|
;;;3327     
;;;3328     if (Channel == TIM_CHANNEL_1)
;;;3329     {
;;;3330       /* TI1 Configuration */
;;;3331       TIM_TI1_SetConfig(htim->Instance,
;;;3332                  sConfig->ICPolarity,
;;;3333                  sConfig->ICSelection,
;;;3334                  sConfig->ICFilter);
;;;3335                  
;;;3336       /* Reset the IC1PSC Bits */
;;;3337       htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
;;;3338   
;;;3339       /* Set the IC1PSC value */
;;;3340       htim->Instance->CCMR1 |= sConfig->ICPrescaler;
;;;3341     }
;;;3342     else if (Channel == TIM_CHANNEL_2)
000018  2a04              CMP      r2,#4
00001a  d044              BEQ      |L33.166|
;;;3343     {
;;;3344       /* TI2 Configuration */
;;;3345       assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3346       
;;;3347       TIM_TI2_SetConfig(htim->Instance, 
;;;3348                         sConfig->ICPolarity,
;;;3349                         sConfig->ICSelection,
;;;3350                         sConfig->ICFilter);
;;;3351                  
;;;3352       /* Reset the IC2PSC Bits */
;;;3353       htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
;;;3354   
;;;3355       /* Set the IC2PSC value */
;;;3356       htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8);
;;;3357     }
;;;3358     else if (Channel == TIM_CHANNEL_3)
00001c  6820              LDR      r0,[r4,#0]
00001e  2a08              CMP      r2,#8
000020  d053              BEQ      |L33.202|
;;;3359     {
;;;3360       /* TI3 Configuration */
;;;3361       assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3362       
;;;3363       TIM_TI3_SetConfig(htim->Instance,  
;;;3364                  sConfig->ICPolarity,
;;;3365                  sConfig->ICSelection,
;;;3366                  sConfig->ICFilter);
;;;3367                  
;;;3368       /* Reset the IC3PSC Bits */
;;;3369       htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;
;;;3370   
;;;3371       /* Set the IC3PSC value */
;;;3372       htim->Instance->CCMR2 |= sConfig->ICPrescaler;
;;;3373     }
;;;3374     else
;;;3375     {
;;;3376       /* TI4 Configuration */
;;;3377       assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3378       
;;;3379       TIM_TI4_SetConfig(htim->Instance, 
000022  e9d53200          LDRD     r3,r2,[r5,#0]
000026  68e9              LDR      r1,[r5,#0xc]
000028  6a07              LDR      r7,[r0,#0x20]
00002a  f64f7cff          MOV      r12,#0xffff
00002e  f44f4e20          MOV      lr,#0xa000
000032  f4275780          BIC      r7,r7,#0x1000
000036  6207              STR      r7,[r0,#0x20]
000038  ea0c3101          AND      r1,r12,r1,LSL #12
00003c  69c7              LDR      r7,[r0,#0x1c]
00003e  f8d0c020          LDR      r12,[r0,#0x20]
000042  ea0e3303          AND      r3,lr,r3,LSL #12
000046  f4277740          BIC      r7,r7,#0x300
00004a  ea472202          ORR      r2,r7,r2,LSL #8
00004e  f42c4c20          BIC      r12,r12,#0xa000
000052  f4224270          BIC      r2,r2,#0xf000
000056  4311              ORRS     r1,r1,r2
000058  61c1              STR      r1,[r0,#0x1c]
00005a  ea43030c          ORR      r3,r3,r12
00005e  6203              STR      r3,[r0,#0x20]
;;;3380                  sConfig->ICPolarity,
;;;3381                  sConfig->ICSelection,
;;;3382                  sConfig->ICFilter);
;;;3383                  
;;;3384       /* Reset the IC4PSC Bits */
;;;3385       htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;
000060  6820              LDR      r0,[r4,#0]
000062  69c1              LDR      r1,[r0,#0x1c]
000064  f4216140          BIC      r1,r1,#0xc00
000068  61c1              STR      r1,[r0,#0x1c]
;;;3386   
;;;3387       /* Set the IC4PSC value */
;;;3388       htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8);
00006a  6820              LDR      r0,[r4,#0]
00006c  68a9              LDR      r1,[r5,#8]
00006e  69c2              LDR      r2,[r0,#0x1c]
000070  ea422101          ORR      r1,r2,r1,LSL #8
                  |L33.116|
000074  61c1              STR      r1,[r0,#0x1c]         ;3372
                  |L33.118|
;;;3389     }
;;;3390     
;;;3391     htim->State = HAL_TIM_STATE_READY;
;;;3392       
;;;3393     __HAL_UNLOCK(htim);
000076  2000              MOVS     r0,#0
000078  6426              STR      r6,[r4,#0x40]         ;3391
;;;3394     
;;;3395     return HAL_OK; 
00007a  63e0              STR      r0,[r4,#0x3c]
                  |L33.124|
;;;3396   }
00007c  e8bd81f0          POP      {r4-r8,pc}
                  |L33.128|
000080  e001              B        |L33.134|
                  |L33.130|
000082  2002              MOVS     r0,#2                 ;3324
000084  e7fa              B        |L33.124|
                  |L33.134|
000086  68eb              LDR      r3,[r5,#0xc]          ;3331
000088  6820              LDR      r0,[r4,#0]            ;3331
00008a  e9d51200          LDRD     r1,r2,[r5,#0]         ;3331
00008e  f7fffffe          BL       TIM_TI1_SetConfig
000092  6820              LDR      r0,[r4,#0]            ;3337
000094  6981              LDR      r1,[r0,#0x18]         ;3337
000096  f021010c          BIC      r1,r1,#0xc            ;3337
00009a  6181              STR      r1,[r0,#0x18]         ;3337
00009c  6820              LDR      r0,[r4,#0]            ;3340
00009e  6981              LDR      r1,[r0,#0x18]         ;3340
0000a0  68aa              LDR      r2,[r5,#8]            ;3340
0000a2  4311              ORRS     r1,r1,r2              ;3340
0000a4  e00f              B        |L33.198|
                  |L33.166|
0000a6  68eb              LDR      r3,[r5,#0xc]          ;3347
0000a8  6820              LDR      r0,[r4,#0]            ;3347
0000aa  e9d51200          LDRD     r1,r2,[r5,#0]         ;3347
0000ae  f7fffffe          BL       TIM_TI2_SetConfig
0000b2  6820              LDR      r0,[r4,#0]            ;3353
0000b4  6981              LDR      r1,[r0,#0x18]         ;3353
0000b6  f4216140          BIC      r1,r1,#0xc00          ;3353
0000ba  6181              STR      r1,[r0,#0x18]         ;3353
0000bc  6820              LDR      r0,[r4,#0]            ;3356
0000be  6981              LDR      r1,[r0,#0x18]         ;3356
0000c0  68aa              LDR      r2,[r5,#8]            ;3356
0000c2  ea412102          ORR      r1,r1,r2,LSL #8       ;3356
                  |L33.198|
0000c6  6181              STR      r1,[r0,#0x18]         ;3356
0000c8  e7d5              B        |L33.118|
                  |L33.202|
0000ca  e9d52300          LDRD     r2,r3,[r5,#0]         ;3356
0000ce  7b29              LDRB     r1,[r5,#0xc]          ;3363
0000d0  6a07              LDR      r7,[r0,#0x20]         ;3363
0000d2  f44f6c20          MOV      r12,#0xa00            ;3363
0000d6  ea0c2202          AND      r2,r12,r2,LSL #8      ;3363
0000da  0709              LSLS     r1,r1,#28             ;3363
0000dc  f4277780          BIC      r7,r7,#0x100          ;3363
0000e0  6207              STR      r7,[r0,#0x20]         ;3363
0000e2  69c7              LDR      r7,[r0,#0x1c]         ;3363
0000e4  f8d0c020          LDR      r12,[r0,#0x20]        ;3363
0000e8  f0270703          BIC      r7,r7,#3              ;3363
0000ec  431f              ORRS     r7,r7,r3              ;3363
0000ee  f42c6c20          BIC      r12,r12,#0xa00        ;3363
0000f2  f02703f0          BIC      r3,r7,#0xf0           ;3363
0000f6  ea42020c          ORR      r2,r2,r12             ;3363
0000fa  ea436111          ORR      r1,r3,r1,LSR #24      ;3363
0000fe  61c1              STR      r1,[r0,#0x1c]         ;3363
000100  6202              STR      r2,[r0,#0x20]         ;3363
000102  6820              LDR      r0,[r4,#0]            ;3369
000104  69c1              LDR      r1,[r0,#0x1c]         ;3369
000106  f021010c          BIC      r1,r1,#0xc            ;3369
00010a  61c1              STR      r1,[r0,#0x1c]         ;3369
00010c  6820              LDR      r0,[r4,#0]            ;3372
00010e  68aa              LDR      r2,[r5,#8]            ;3372
000110  69c1              LDR      r1,[r0,#0x1c]         ;3372
000112  4311              ORRS     r1,r1,r2              ;3372
000114  e7ae              B        |L33.116|
;;;3397   
                          ENDP


                          AREA ||i.HAL_TIM_IC_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_DeInit PROC
;;;1693     */
;;;1694   HAL_StatusTypeDef HAL_TIM_IC_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1695   {
000002  4604              MOV      r4,r0
;;;1696     /* Check the parameters */
;;;1697     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1698   
;;;1699     htim->State = HAL_TIM_STATE_BUSY;
;;;1700     
;;;1701     /* Disable the TIM Peripheral Clock */
;;;1702     __HAL_TIM_DISABLE(htim);
000004  f2411211          MOV      r2,#0x1111
000008  2002              MOVS     r0,#2                 ;1699
00000a  6420              STR      r0,[r4,#0x40]         ;1699
00000c  6820              LDR      r0,[r4,#0]
00000e  6a01              LDR      r1,[r0,#0x20]
000010  4211              TST      r1,r2
000012  d107              BNE      |L34.36|
000014  6a01              LDR      r1,[r0,#0x20]
000016  1092              ASRS     r2,r2,#2
000018  4211              TST      r1,r2
00001a  d103              BNE      |L34.36|
00001c  6801              LDR      r1,[r0,#0]
00001e  f0210101          BIC      r1,r1,#1
000022  6001              STR      r1,[r0,#0]
                  |L34.36|
;;;1703   
;;;1704   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;1705     if(htim->IC_MspDeInitCallback == NULL)
;;;1706     {
;;;1707       htim->IC_MspDeInitCallback = HAL_TIM_IC_MspDeInit;
;;;1708     }
;;;1709     /* DeInit the low level hardware */
;;;1710     htim->IC_MspDeInitCallback(htim);
;;;1711   #else
;;;1712     /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;1713     HAL_TIM_IC_MspDeInit(htim);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       HAL_TIM_IC_MspDeInit
;;;1714   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;1715   
;;;1716     /* Change TIM state */  
;;;1717     htim->State = HAL_TIM_STATE_RESET;
00002a  2000              MOVS     r0,#0
00002c  6420              STR      r0,[r4,#0x40]
;;;1718   
;;;1719     /* Release Lock */
;;;1720     __HAL_UNLOCK(htim);
00002e  63e0              STR      r0,[r4,#0x3c]
;;;1721   
;;;1722     return HAL_OK;
;;;1723   }
000030  bd10              POP      {r4,pc}
;;;1724   
                          ENDP


                          AREA ||i.HAL_TIM_IC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_GetState PROC
;;;5267     */
;;;5268   HAL_TIM_StateTypeDef HAL_TIM_IC_GetState(TIM_HandleTypeDef *htim)
000000  6c00              LDR      r0,[r0,#0x40]
;;;5269   {
;;;5270     return htim->State;
;;;5271   }
000002  4770              BX       lr
;;;5272   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Init PROC
;;;1640     */
;;;1641   HAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1642   {
000002  0004              MOVS     r4,r0
000004  d002              BEQ      |L36.12|
;;;1643     /* Check the TIM handle allocation */
;;;1644     if(htim == NULL)
;;;1645     {
;;;1646       return HAL_ERROR;
;;;1647     }
;;;1648   
;;;1649     /* Check the parameters */
;;;1650     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1651     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;1652     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision)); 
;;;1653     assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;1654   
;;;1655     if(htim->State == HAL_TIM_STATE_RESET)
000006  6c20              LDR      r0,[r4,#0x40]
000008  b110              CBZ      r0,|L36.16|
00000a  e006              B        |L36.26|
                  |L36.12|
00000c  2001              MOVS     r0,#1                 ;1646
;;;1656     {
;;;1657       /* Allocate lock resource and initialize it */
;;;1658       htim->Lock = HAL_UNLOCKED;
;;;1659   
;;;1660   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;1661       /* Reset interrupt callbacks to legacy week callbacks */
;;;1662       TIM_ResetCallback(htim);
;;;1663   
;;;1664       if(htim->IC_MspInitCallback == NULL)
;;;1665       {
;;;1666         htim->IC_MspInitCallback = HAL_TIM_IC_MspInit;
;;;1667       }
;;;1668       /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;1669       htim->IC_MspInitCallback(htim);
;;;1670   #else
;;;1671       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;1672       HAL_TIM_IC_MspInit(htim);
;;;1673   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;1674     }
;;;1675   
;;;1676     /* Set the TIM state */
;;;1677     htim->State= HAL_TIM_STATE_BUSY;   
;;;1678     
;;;1679     /* Init the base time for the input capture */  
;;;1680     TIM_Base_SetConfig(htim->Instance, &htim->Init); 
;;;1681      
;;;1682     /* Initialize the TIM state*/
;;;1683     htim->State= HAL_TIM_STATE_READY;
;;;1684     
;;;1685     return HAL_OK;
;;;1686   }
00000e  bd10              POP      {r4,pc}
                  |L36.16|
000010  2000              MOVS     r0,#0                 ;1658
000012  63e0              STR      r0,[r4,#0x3c]         ;1672
000014  4620              MOV      r0,r4                 ;1672
000016  f7fffffe          BL       HAL_TIM_IC_MspInit
                  |L36.26|
00001a  2002              MOVS     r0,#2                 ;1677
00001c  6420              STR      r0,[r4,#0x40]         ;1677
00001e  6820              LDR      r0,[r4,#0]            ;1680
000020  1d21              ADDS     r1,r4,#4              ;1680
000022  f7fffffe          BL       TIM_Base_SetConfig
000026  2001              MOVS     r0,#1                 ;1683
000028  6420              STR      r0,[r4,#0x40]         ;1683
00002a  2000              MOVS     r0,#0                 ;1685
00002c  bd10              POP      {r4,pc}
;;;1687   
                          ENDP


                          AREA ||i.HAL_TIM_IC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_MspDeInit PROC
;;;1746     */
;;;1747   __weak void HAL_TIM_IC_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1748   {
;;;1749     /* Prevent unused argument(s) compilation warning */
;;;1750     UNUSED(htim);
;;;1751      
;;;1752     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1753               the HAL_TIM_IC_MspDeInit could be implemented in the user file
;;;1754      */
;;;1755   }
;;;1756   
                          ENDP


                          AREA ||i.HAL_TIM_IC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_MspInit PROC
;;;1730     */
;;;1731   __weak void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1732   {
;;;1733     /* Prevent unused argument(s) compilation warning */
;;;1734     UNUSED(htim);
;;;1735    
;;;1736     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1737               the HAL_TIM_IC_MspInit could be implemented in the user file
;;;1738      */
;;;1739   }
;;;1740   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Start PROC
;;;1768     */
;;;1769   HAL_StatusTypeDef HAL_TIM_IC_Start (TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1770   {
;;;1771     /* Check the parameters */
;;;1772     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1773     
;;;1774     /* Enable the Input Capture channel */
;;;1775     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000002  2201              MOVS     r2,#1
000004  4604              MOV      r4,r0                 ;1770
000006  6800              LDR      r0,[r0,#0]
000008  f7fffffe          BL       TIM_CCxChannelCmd
;;;1776       
;;;1777     /* Enable the Peripheral */
;;;1778     __HAL_TIM_ENABLE(htim);  
00000c  6820              LDR      r0,[r4,#0]
00000e  6801              LDR      r1,[r0,#0]
000010  f0410101          ORR      r1,r1,#1
000014  6001              STR      r1,[r0,#0]
;;;1779   
;;;1780     /* Return function status */
;;;1781     return HAL_OK;  
000016  2000              MOVS     r0,#0
;;;1782   } 
000018  bd10              POP      {r4,pc}
;;;1783   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_IC_Start_DMA PROC
;;;1945     */
;;;1946   HAL_StatusTypeDef HAL_TIM_IC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;1947   {
000002  4604              MOV      r4,r0
;;;1948     /* Check the parameters */
;;;1949     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1950     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;1951     
;;;1952     if((htim->State == HAL_TIM_STATE_BUSY))
000004  6c00              LDR      r0,[r0,#0x40]
000006  460e              MOV      r6,r1                 ;1947
000008  2802              CMP      r0,#2
00000a  d004              BEQ      |L40.22|
;;;1953     {
;;;1954        return HAL_BUSY;
;;;1955     }
;;;1956     else if((htim->State == HAL_TIM_STATE_READY))
00000c  6c20              LDR      r0,[r4,#0x40]
00000e  2801              CMP      r0,#1
000010  d104              BNE      |L40.28|
;;;1957     {
;;;1958       if((pData == 0 ) && (Length > 0)) 
000012  b90a              CBNZ     r2,|L40.24|
000014  b103              CBZ      r3,|L40.24|
                  |L40.22|
;;;1959       {
;;;1960         return HAL_ERROR;                                    
;;;1961       }
;;;1962       else
;;;1963       {
;;;1964         htim->State = HAL_TIM_STATE_BUSY;
;;;1965       }
;;;1966     }  
;;;1967      
;;;1968     switch (Channel)
;;;1969     {
;;;1970       case TIM_CHANNEL_1:
;;;1971       {
;;;1972         /* Set the DMA Period elapsed callback */
;;;1973         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;1974        
;;;1975         /* Set the DMA error callback */
;;;1976         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
;;;1977         
;;;1978         /* Enable the DMA Stream */
;;;1979         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length); 
;;;1980         
;;;1981         /* Enable the TIM Capture/Compare 1 DMA request */      
;;;1982         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;1983       }
;;;1984       break;
;;;1985       
;;;1986       case TIM_CHANNEL_2:
;;;1987       {
;;;1988         /* Set the DMA Period elapsed callback */
;;;1989         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;1990        
;;;1991         /* Set the DMA error callback */
;;;1992         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
;;;1993         
;;;1994         /* Enable the DMA Stream */
;;;1995         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData, Length);
;;;1996         
;;;1997         /* Enable the TIM Capture/Compare 2  DMA request */
;;;1998         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;1999       }
;;;2000       break;
;;;2001       
;;;2002       case TIM_CHANNEL_3:
;;;2003       {
;;;2004         /* Set the DMA Period elapsed callback */
;;;2005         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;2006        
;;;2007         /* Set the DMA error callback */
;;;2008         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
;;;2009         
;;;2010         /* Enable the DMA Stream */
;;;2011         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->CCR3, (uint32_t)pData, Length);
;;;2012         
;;;2013         /* Enable the TIM Capture/Compare 3  DMA request */
;;;2014         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;2015       }
;;;2016       break;
;;;2017       
;;;2018       case TIM_CHANNEL_4:
;;;2019       {
;;;2020         /* Set the DMA Period elapsed callback */
;;;2021         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;2022        
;;;2023         /* Set the DMA error callback */
;;;2024         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
;;;2025         
;;;2026         /* Enable the DMA Stream */
;;;2027         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->CCR4, (uint32_t)pData, Length);
;;;2028         
;;;2029         /* Enable the TIM Capture/Compare 4  DMA request */
;;;2030         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;2031       }
;;;2032       break;
;;;2033       
;;;2034       default:
;;;2035       break;
;;;2036     }
;;;2037   
;;;2038     /* Enable the Input Capture channel */
;;;2039     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;2040      
;;;2041     /* Enable the Peripheral */
;;;2042     __HAL_TIM_ENABLE(htim); 
;;;2043     
;;;2044     /* Return function status */
;;;2045     return HAL_OK;
;;;2046   }
000016  bd70              POP      {r4-r6,pc}
                  |L40.24|
000018  2002              MOVS     r0,#2                 ;1964
00001a  6420              STR      r0,[r4,#0x40]         ;1964
                  |L40.28|
00001c  4826              LDR      r0,|L40.184|
00001e  4d27              LDR      r5,|L40.188|
000020  b136              CBZ      r6,|L40.48|
000022  2e04              CMP      r6,#4                 ;1968
000024  d012              BEQ      |L40.76|
000026  2e08              CMP      r6,#8                 ;1968
000028  d02a              BEQ      |L40.128|
00002a  2e0c              CMP      r6,#0xc               ;1968
00002c  d11c              BNE      |L40.104|
00002e  e035              B        |L40.156|
                  |L40.48|
000030  6a61              LDR      r1,[r4,#0x24]         ;1973
000032  6408              STR      r0,[r1,#0x40]         ;1976
000034  6a60              LDR      r0,[r4,#0x24]         ;1976
000036  6505              STR      r5,[r0,#0x50]         ;1979
000038  6821              LDR      r1,[r4,#0]            ;1979
00003a  6a60              LDR      r0,[r4,#0x24]         ;1979
00003c  3134              ADDS     r1,r1,#0x34           ;1979
00003e  f7fffffe          BL       HAL_DMA_Start_IT
000042  6820              LDR      r0,[r4,#0]            ;1982
000044  68c1              LDR      r1,[r0,#0xc]          ;1982
000046  f4417100          ORR      r1,r1,#0x200          ;1982
00004a  e00c              B        |L40.102|
                  |L40.76|
00004c  6aa1              LDR      r1,[r4,#0x28]         ;1989
00004e  6408              STR      r0,[r1,#0x40]         ;1992
000050  6aa0              LDR      r0,[r4,#0x28]         ;1992
000052  6505              STR      r5,[r0,#0x50]         ;1995
000054  6821              LDR      r1,[r4,#0]            ;1995
000056  6aa0              LDR      r0,[r4,#0x28]         ;1995
000058  3138              ADDS     r1,r1,#0x38           ;1995
00005a  f7fffffe          BL       HAL_DMA_Start_IT
00005e  6820              LDR      r0,[r4,#0]            ;1998
000060  68c1              LDR      r1,[r0,#0xc]          ;1998
000062  f4416180          ORR      r1,r1,#0x400          ;1998
                  |L40.102|
000066  60c1              STR      r1,[r0,#0xc]          ;1982
                  |L40.104|
000068  6820              LDR      r0,[r4,#0]            ;2039
00006a  2201              MOVS     r2,#1                 ;2039
00006c  4631              MOV      r1,r6                 ;2039
00006e  f7fffffe          BL       TIM_CCxChannelCmd
000072  6820              LDR      r0,[r4,#0]            ;2042
000074  6801              LDR      r1,[r0,#0]            ;2042
000076  f0410101          ORR      r1,r1,#1              ;2042
00007a  6001              STR      r1,[r0,#0]            ;2042
00007c  2000              MOVS     r0,#0                 ;2045
00007e  bd70              POP      {r4-r6,pc}
                  |L40.128|
000080  6ae1              LDR      r1,[r4,#0x2c]         ;2005
000082  6408              STR      r0,[r1,#0x40]         ;2008
000084  6ae0              LDR      r0,[r4,#0x2c]         ;2008
000086  6505              STR      r5,[r0,#0x50]         ;2011
000088  6821              LDR      r1,[r4,#0]            ;2011
00008a  6ae0              LDR      r0,[r4,#0x2c]         ;2011
00008c  313c              ADDS     r1,r1,#0x3c           ;2011
00008e  f7fffffe          BL       HAL_DMA_Start_IT
000092  6820              LDR      r0,[r4,#0]            ;2014
000094  68c1              LDR      r1,[r0,#0xc]          ;2014
000096  f4416100          ORR      r1,r1,#0x800          ;2014
00009a  e7e4              B        |L40.102|
                  |L40.156|
00009c  6b21              LDR      r1,[r4,#0x30]         ;2021
00009e  6408              STR      r0,[r1,#0x40]         ;2024
0000a0  6b20              LDR      r0,[r4,#0x30]         ;2024
0000a2  6505              STR      r5,[r0,#0x50]         ;2027
0000a4  6821              LDR      r1,[r4,#0]            ;2027
0000a6  6b20              LDR      r0,[r4,#0x30]         ;2027
0000a8  3140              ADDS     r1,r1,#0x40           ;2027
0000aa  f7fffffe          BL       HAL_DMA_Start_IT
0000ae  6820              LDR      r0,[r4,#0]            ;2030
0000b0  68c1              LDR      r1,[r0,#0xc]          ;2030
0000b2  f4415180          ORR      r1,r1,#0x1000         ;2030
0000b6  e7d6              B        |L40.102|
;;;2047   
                          ENDP

                  |L40.184|
                          DCD      TIM_DMACaptureCplt
                  |L40.188|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_IC_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Start_IT PROC
;;;1822     */
;;;1823   HAL_StatusTypeDef HAL_TIM_IC_Start_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1824   {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L41.22|
;;;1825     /* Check the parameters */
;;;1826     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1827     
;;;1828     switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L41.30|
00000c  2908              CMP      r1,#8
00000e  d015              BEQ      |L41.60|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L41.38|
000014  e016              B        |L41.68|
                  |L41.22|
;;;1829     {
;;;1830       case TIM_CHANNEL_1:
;;;1831       {       
;;;1832         /* Enable the TIM Capture/Compare 1 interrupt */
;;;1833         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f0400002          ORR      r0,r0,#2
;;;1834       }
;;;1835       break;
00001c  e002              B        |L41.36|
                  |L41.30|
;;;1836       
;;;1837       case TIM_CHANNEL_2:
;;;1838       {
;;;1839         /* Enable the TIM Capture/Compare 2 interrupt */
;;;1840         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f0400004          ORR      r0,r0,#4
                  |L41.36|
000024  60d0              STR      r0,[r2,#0xc]          ;1833
                  |L41.38|
;;;1841       }
;;;1842       break;
;;;1843       
;;;1844       case TIM_CHANNEL_3:
;;;1845       {
;;;1846         /* Enable the TIM Capture/Compare 3 interrupt */
;;;1847         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
;;;1848       }
;;;1849       break;
;;;1850       
;;;1851       case TIM_CHANNEL_4:
;;;1852       {
;;;1853         /* Enable the TIM Capture/Compare 4 interrupt */
;;;1854         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
;;;1855       }
;;;1856       break;
;;;1857       
;;;1858       default:
;;;1859       break;
;;;1860     }  
;;;1861     /* Enable the Input Capture channel */
;;;1862     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000026  6820              LDR      r0,[r4,#0]
000028  2201              MOVS     r2,#1
00002a  f7fffffe          BL       TIM_CCxChannelCmd
;;;1863       
;;;1864     /* Enable the Peripheral */
;;;1865     __HAL_TIM_ENABLE(htim);  
00002e  6820              LDR      r0,[r4,#0]
000030  6801              LDR      r1,[r0,#0]
000032  f0410101          ORR      r1,r1,#1
000036  6001              STR      r1,[r0,#0]
;;;1866   
;;;1867     /* Return function status */
;;;1868     return HAL_OK;  
000038  2000              MOVS     r0,#0
;;;1869   } 
00003a  bd10              POP      {r4,pc}
                  |L41.60|
00003c  68d0              LDR      r0,[r2,#0xc]          ;1847
00003e  f0400008          ORR      r0,r0,#8              ;1847
000042  e7ef              B        |L41.36|
                  |L41.68|
000044  68d0              LDR      r0,[r2,#0xc]          ;1854
000046  f0400010          ORR      r0,r0,#0x10           ;1854
00004a  e7eb              B        |L41.36|
;;;1870   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Stop PROC
;;;1795     */
;;;1796   HAL_StatusTypeDef HAL_TIM_IC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1797   { 
;;;1798     /* Check the parameters */
;;;1799     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1800     
;;;1801     /* Disable the Input Capture channel */
;;;1802     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000002  2200              MOVS     r2,#0
000004  4604              MOV      r4,r0                 ;1797
000006  6800              LDR      r0,[r0,#0]
000008  f7fffffe          BL       TIM_CCxChannelCmd
;;;1803     
;;;1804     /* Disable the Peripheral */
;;;1805     __HAL_TIM_DISABLE(htim); 
00000c  6820              LDR      r0,[r4,#0]
00000e  f2411211          MOV      r2,#0x1111
000012  6a01              LDR      r1,[r0,#0x20]
000014  4211              TST      r1,r2
000016  d107              BNE      |L42.40|
000018  6a01              LDR      r1,[r0,#0x20]
00001a  1092              ASRS     r2,r2,#2
00001c  4211              TST      r1,r2
00001e  d103              BNE      |L42.40|
000020  6801              LDR      r1,[r0,#0]
000022  f0210101          BIC      r1,r1,#1
000026  6001              STR      r1,[r0,#0]
                  |L42.40|
;;;1806     
;;;1807     /* Return function status */
;;;1808     return HAL_OK;
000028  2000              MOVS     r0,#0
;;;1809   }
00002a  bd10              POP      {r4,pc}
;;;1810   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Stop_DMA PROC
;;;2059     */
;;;2060   HAL_StatusTypeDef HAL_TIM_IC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;2061   {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L43.22|
;;;2062     /* Check the parameters */
;;;2063     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;2064     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;2065     
;;;2066     switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L43.30|
00000c  2908              CMP      r1,#8
00000e  d020              BEQ      |L43.82|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L43.38|
000014  e021              B        |L43.90|
                  |L43.22|
;;;2067     {
;;;2068       case TIM_CHANNEL_1:
;;;2069       {       
;;;2070         /* Disable the TIM Capture/Compare 1 DMA request */
;;;2071         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f4207000          BIC      r0,r0,#0x200
;;;2072       }
;;;2073       break;
00001c  e002              B        |L43.36|
                  |L43.30|
;;;2074       
;;;2075       case TIM_CHANNEL_2:
;;;2076       {
;;;2077         /* Disable the TIM Capture/Compare 2 DMA request */
;;;2078         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f4206080          BIC      r0,r0,#0x400
                  |L43.36|
000024  60d0              STR      r0,[r2,#0xc]          ;2071
                  |L43.38|
;;;2079       }
;;;2080       break;
;;;2081       
;;;2082       case TIM_CHANNEL_3:
;;;2083       {
;;;2084         /* Disable the TIM Capture/Compare 3  DMA request */
;;;2085         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
;;;2086       }
;;;2087       break;
;;;2088       
;;;2089       case TIM_CHANNEL_4:
;;;2090       {
;;;2091         /* Disable the TIM Capture/Compare 4  DMA request */
;;;2092         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
;;;2093       }
;;;2094       break;
;;;2095       
;;;2096       default:
;;;2097       break;
;;;2098     }
;;;2099   
;;;2100     /* Disable the Input Capture channel */
;;;2101     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000026  6820              LDR      r0,[r4,#0]
000028  2200              MOVS     r2,#0
00002a  f7fffffe          BL       TIM_CCxChannelCmd
;;;2102     
;;;2103     /* Disable the Peripheral */
;;;2104     __HAL_TIM_DISABLE(htim); 
00002e  6820              LDR      r0,[r4,#0]
000030  f2411211          MOV      r2,#0x1111
000034  6a01              LDR      r1,[r0,#0x20]
000036  4211              TST      r1,r2
000038  d107              BNE      |L43.74|
00003a  6a01              LDR      r1,[r0,#0x20]
00003c  1092              ASRS     r2,r2,#2
00003e  4211              TST      r1,r2
000040  d103              BNE      |L43.74|
000042  6801              LDR      r1,[r0,#0]
000044  f0210101          BIC      r1,r1,#1
000048  6001              STR      r1,[r0,#0]
                  |L43.74|
;;;2105     
;;;2106     /* Change the htim state */
;;;2107     htim->State = HAL_TIM_STATE_READY;
00004a  2001              MOVS     r0,#1
00004c  6420              STR      r0,[r4,#0x40]
;;;2108     
;;;2109     /* Return function status */
;;;2110     return HAL_OK;
00004e  2000              MOVS     r0,#0
;;;2111   }  
000050  bd10              POP      {r4,pc}
                  |L43.82|
000052  68d0              LDR      r0,[r2,#0xc]          ;2085
000054  f4206000          BIC      r0,r0,#0x800          ;2085
000058  e7e4              B        |L43.36|
                  |L43.90|
00005a  68d0              LDR      r0,[r2,#0xc]          ;2092
00005c  f4205080          BIC      r0,r0,#0x1000         ;2092
000060  e7e0              B        |L43.36|
;;;2112   /**
                          ENDP


                          AREA ||i.HAL_TIM_IC_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Stop_IT PROC
;;;1882     */
;;;1883   HAL_StatusTypeDef HAL_TIM_IC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1884   {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L44.22|
;;;1885     /* Check the parameters */
;;;1886     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1887     
;;;1888     switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L44.30|
00000c  2908              CMP      r1,#8
00000e  d01e              BEQ      |L44.78|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L44.38|
000014  e01f              B        |L44.86|
                  |L44.22|
;;;1889     {
;;;1890       case TIM_CHANNEL_1:
;;;1891       {       
;;;1892         /* Disable the TIM Capture/Compare 1 interrupt */
;;;1893         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f0200002          BIC      r0,r0,#2
;;;1894       }
;;;1895       break;
00001c  e002              B        |L44.36|
                  |L44.30|
;;;1896       
;;;1897       case TIM_CHANNEL_2:
;;;1898       {
;;;1899         /* Disable the TIM Capture/Compare 2 interrupt */
;;;1900         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f0200004          BIC      r0,r0,#4
                  |L44.36|
000024  60d0              STR      r0,[r2,#0xc]          ;1893
                  |L44.38|
;;;1901       }
;;;1902       break;
;;;1903       
;;;1904       case TIM_CHANNEL_3:
;;;1905       {
;;;1906         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1907         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
;;;1908       }
;;;1909       break;
;;;1910       
;;;1911       case TIM_CHANNEL_4:
;;;1912       {
;;;1913         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1914         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
;;;1915       }
;;;1916       break;
;;;1917       
;;;1918       default:
;;;1919       break; 
;;;1920     } 
;;;1921     
;;;1922     /* Disable the Input Capture channel */
;;;1923     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE); 
000026  6820              LDR      r0,[r4,#0]
000028  2200              MOVS     r2,#0
00002a  f7fffffe          BL       TIM_CCxChannelCmd
;;;1924     
;;;1925     /* Disable the Peripheral */
;;;1926     __HAL_TIM_DISABLE(htim); 
00002e  6820              LDR      r0,[r4,#0]
000030  f2411211          MOV      r2,#0x1111
000034  6a01              LDR      r1,[r0,#0x20]
000036  4211              TST      r1,r2
000038  d107              BNE      |L44.74|
00003a  6a01              LDR      r1,[r0,#0x20]
00003c  1092              ASRS     r2,r2,#2
00003e  4211              TST      r1,r2
000040  d103              BNE      |L44.74|
000042  6801              LDR      r1,[r0,#0]
000044  f0210101          BIC      r1,r1,#1
000048  6001              STR      r1,[r0,#0]
                  |L44.74|
;;;1927     
;;;1928     /* Return function status */
;;;1929     return HAL_OK;
00004a  2000              MOVS     r0,#0
;;;1930   }
00004c  bd10              POP      {r4,pc}
                  |L44.78|
00004e  68d0              LDR      r0,[r2,#0xc]          ;1907
000050  f0200008          BIC      r0,r0,#8              ;1907
000054  e7e6              B        |L44.36|
                  |L44.86|
000056  68d0              LDR      r0,[r2,#0xc]          ;1914
000058  f0200010          BIC      r0,r0,#0x10           ;1914
00005c  e7e2              B        |L44.36|
;;;1931   
                          ENDP


                          AREA ||i.HAL_TIM_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IRQHandler PROC
;;;3012     */
;;;3013   void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
000000  b570              PUSH     {r4-r6,lr}
;;;3014   {
000002  4604              MOV      r4,r0
;;;3015     /* Capture compare 1 event */
;;;3016     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
000004  6800              LDR      r0,[r0,#0]
000006  2500              MOVS     r5,#0
000008  6901              LDR      r1,[r0,#0x10]
00000a  43c9              MVNS     r1,r1
00000c  0789              LSLS     r1,r1,#30
00000e  d415              BMI      |L45.60|
;;;3017     {
;;;3018       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) !=RESET)
000010  68c1              LDR      r1,[r0,#0xc]
000012  43c9              MVNS     r1,r1
000014  0789              LSLS     r1,r1,#30
000016  d411              BMI      |L45.60|
;;;3019       {
;;;3020         {
;;;3021           __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
000018  1eea              SUBS     r2,r5,#3
00001a  6102              STR      r2,[r0,#0x10]
;;;3022           htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
00001c  2101              MOVS     r1,#1
;;;3023           
;;;3024           /* Input capture event */
;;;3025           if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00)
00001e  61e1              STR      r1,[r4,#0x1c]
000020  6820              LDR      r0,[r4,#0]
000022  6980              LDR      r0,[r0,#0x18]
000024  0780              LSLS     r0,r0,#30
;;;3026           {
;;;3027   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3028             htim->IC_CaptureCallback(htim);
;;;3029   #else
;;;3030             HAL_TIM_IC_CaptureCallback(htim);
;;;3031   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3032           }
;;;3033           /* Output compare event */
;;;3034           else
;;;3035           {
;;;3036   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3037             htim->OC_DelayElapsedCallback(htim);
;;;3038             htim->PWM_PulseFinishedCallback(htim);
;;;3039   #else
;;;3040             HAL_TIM_OC_DelayElapsedCallback(htim);
000026  4620              MOV      r0,r4
000028  d002              BEQ      |L45.48|
00002a  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
00002e  e004              B        |L45.58|
                  |L45.48|
000030  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;3041             HAL_TIM_PWM_PulseFinishedCallback(htim);
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L45.58|
;;;3042   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3043           }
;;;3044           htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
00003a  61e5              STR      r5,[r4,#0x1c]
                  |L45.60|
;;;3045         }
;;;3046       }
;;;3047     }
;;;3048     /* Capture compare 2 event */
;;;3049     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
00003c  6820              LDR      r0,[r4,#0]
00003e  6901              LDR      r1,[r0,#0x10]
000040  43c9              MVNS     r1,r1
000042  0749              LSLS     r1,r1,#29
000044  d417              BMI      |L45.118|
;;;3050     {
;;;3051       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) !=RESET)
000046  68c1              LDR      r1,[r0,#0xc]
000048  43c9              MVNS     r1,r1
00004a  0749              LSLS     r1,r1,#29
00004c  d413              BMI      |L45.118|
;;;3052       {
;;;3053         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
;;;3054         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
00004e  2102              MOVS     r1,#2
000050  f06f0204          MVN      r2,#4                 ;3053
000054  6102              STR      r2,[r0,#0x10]         ;3053
;;;3055         /* Input capture event */
;;;3056         if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00)
000056  61e1              STR      r1,[r4,#0x1c]
000058  6820              LDR      r0,[r4,#0]
00005a  6980              LDR      r0,[r0,#0x18]
00005c  f4107f40          TST      r0,#0x300
;;;3057         {
;;;3058   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3059           htim->IC_CaptureCallback(htim);
;;;3060   #else
;;;3061           HAL_TIM_IC_CaptureCallback(htim);
;;;3062   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3063         }
;;;3064         /* Output compare event */
;;;3065         else
;;;3066         {
;;;3067   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3068           htim->OC_DelayElapsedCallback(htim);
;;;3069           htim->PWM_PulseFinishedCallback(htim);
;;;3070   #else
;;;3071           HAL_TIM_OC_DelayElapsedCallback(htim);
000060  4620              MOV      r0,r4
000062  d002              BEQ      |L45.106|
000064  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
000068  e004              B        |L45.116|
                  |L45.106|
00006a  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;3072           HAL_TIM_PWM_PulseFinishedCallback(htim);
00006e  4620              MOV      r0,r4
000070  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L45.116|
;;;3073   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3074         }
;;;3075         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000074  61e5              STR      r5,[r4,#0x1c]
                  |L45.118|
;;;3076       }
;;;3077     }
;;;3078     /* Capture compare 3 event */
;;;3079     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
000076  6820              LDR      r0,[r4,#0]
000078  6901              LDR      r1,[r0,#0x10]
00007a  43c9              MVNS     r1,r1
00007c  0709              LSLS     r1,r1,#28
00007e  d416              BMI      |L45.174|
;;;3080     {
;;;3081       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) !=RESET)
000080  68c1              LDR      r1,[r0,#0xc]
000082  43c9              MVNS     r1,r1
000084  0709              LSLS     r1,r1,#28
000086  d412              BMI      |L45.174|
;;;3082       {
;;;3083         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
;;;3084         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
000088  2104              MOVS     r1,#4
00008a  f06f0208          MVN      r2,#8                 ;3083
00008e  6102              STR      r2,[r0,#0x10]         ;3083
;;;3085         /* Input capture event */
;;;3086         if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00)
000090  61e1              STR      r1,[r4,#0x1c]
000092  6820              LDR      r0,[r4,#0]
000094  69c0              LDR      r0,[r0,#0x1c]
000096  0780              LSLS     r0,r0,#30
;;;3087         {          
;;;3088   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3089           htim->IC_CaptureCallback(htim);
;;;3090   #else
;;;3091           HAL_TIM_IC_CaptureCallback(htim);
;;;3092   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3093         }
;;;3094         /* Output compare event */
;;;3095         else
;;;3096         {
;;;3097   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3098           htim->OC_DelayElapsedCallback(htim);
;;;3099           htim->PWM_PulseFinishedCallback(htim);
;;;3100   #else
;;;3101           HAL_TIM_OC_DelayElapsedCallback(htim);
000098  4620              MOV      r0,r4
00009a  d002              BEQ      |L45.162|
00009c  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
0000a0  e004              B        |L45.172|
                  |L45.162|
0000a2  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;3102           HAL_TIM_PWM_PulseFinishedCallback(htim);
0000a6  4620              MOV      r0,r4
0000a8  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L45.172|
;;;3103   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3104         }
;;;3105         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
0000ac  61e5              STR      r5,[r4,#0x1c]
                  |L45.174|
;;;3106       }
;;;3107     }
;;;3108     /* Capture compare 4 event */
;;;3109     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
0000ae  6820              LDR      r0,[r4,#0]
0000b0  6901              LDR      r1,[r0,#0x10]
0000b2  43c9              MVNS     r1,r1
0000b4  06c9              LSLS     r1,r1,#27
0000b6  d417              BMI      |L45.232|
;;;3110     {
;;;3111       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) !=RESET)
0000b8  68c1              LDR      r1,[r0,#0xc]
0000ba  43c9              MVNS     r1,r1
0000bc  06c9              LSLS     r1,r1,#27
0000be  d413              BMI      |L45.232|
;;;3112       {
;;;3113         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
;;;3114         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
0000c0  2108              MOVS     r1,#8
0000c2  f06f0210          MVN      r2,#0x10              ;3113
0000c6  6102              STR      r2,[r0,#0x10]         ;3113
;;;3115         /* Input capture event */
;;;3116         if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00)
0000c8  61e1              STR      r1,[r4,#0x1c]
0000ca  6820              LDR      r0,[r4,#0]
0000cc  69c0              LDR      r0,[r0,#0x1c]
0000ce  f4107f40          TST      r0,#0x300
;;;3117         {          
;;;3118   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3119           htim->IC_CaptureCallback(htim);
;;;3120   #else
;;;3121           HAL_TIM_IC_CaptureCallback(htim);
;;;3122   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3123         }
;;;3124         /* Output compare event */
;;;3125         else
;;;3126         {
;;;3127   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3128           htim->OC_DelayElapsedCallback(htim);
;;;3129           htim->PWM_PulseFinishedCallback(htim);
;;;3130   #else
;;;3131           HAL_TIM_OC_DelayElapsedCallback(htim);
0000d2  4620              MOV      r0,r4
0000d4  d002              BEQ      |L45.220|
0000d6  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
0000da  e004              B        |L45.230|
                  |L45.220|
0000dc  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;3132           HAL_TIM_PWM_PulseFinishedCallback(htim);
0000e0  4620              MOV      r0,r4
0000e2  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L45.230|
;;;3133   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3134         }
;;;3135         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
0000e6  61e5              STR      r5,[r4,#0x1c]
                  |L45.232|
;;;3136       }
;;;3137     }
;;;3138     /* TIM Update event */
;;;3139     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
0000e8  6820              LDR      r0,[r4,#0]
0000ea  6901              LDR      r1,[r0,#0x10]
0000ec  43c9              MVNS     r1,r1
0000ee  07c9              LSLS     r1,r1,#31
0000f0  d108              BNE      |L45.260|
;;;3140     {
;;;3141       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) !=RESET)
0000f2  68c1              LDR      r1,[r0,#0xc]
0000f4  43c9              MVNS     r1,r1
0000f6  07c9              LSLS     r1,r1,#31
0000f8  d104              BNE      |L45.260|
;;;3142       {
;;;3143         __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
0000fa  1e89              SUBS     r1,r1,#2
0000fc  6101              STR      r1,[r0,#0x10]
;;;3144   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3145         htim->PeriodElapsedCallback(htim);
;;;3146   #else
;;;3147         HAL_TIM_PeriodElapsedCallback(htim);
0000fe  4620              MOV      r0,r4
000100  f7fffffe          BL       HAL_TIM_PeriodElapsedCallback
                  |L45.260|
;;;3148   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3149       }
;;;3150     }
;;;3151     /* TIM Break input event */
;;;3152     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
000104  6820              LDR      r0,[r4,#0]
;;;3153     {
;;;3154       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
;;;3155       {
;;;3156         __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
000106  f06f0580          MVN      r5,#0x80
00010a  6901              LDR      r1,[r0,#0x10]         ;3152
00010c  43c9              MVNS     r1,r1                 ;3152
00010e  0609              LSLS     r1,r1,#24             ;3152
000110  d407              BMI      |L45.290|
000112  68c1              LDR      r1,[r0,#0xc]          ;3154
000114  43c9              MVNS     r1,r1                 ;3154
000116  0609              LSLS     r1,r1,#24             ;3154
000118  d403              BMI      |L45.290|
00011a  6105              STR      r5,[r0,#0x10]
;;;3157   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3158         htim->BreakCallback(htim);
;;;3159   #else
;;;3160         HAL_TIMEx_BreakCallback(htim);
00011c  4620              MOV      r0,r4
00011e  f7fffffe          BL       HAL_TIMEx_BreakCallback
                  |L45.290|
;;;3161   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3162   
;;;3163       }
;;;3164     }
;;;3165     
;;;3166       /* TIM Break input event */
;;;3167     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
000122  6820              LDR      r0,[r4,#0]
000124  6901              LDR      r1,[r0,#0x10]
000126  43c9              MVNS     r1,r1
000128  05c9              LSLS     r1,r1,#23
00012a  d407              BMI      |L45.316|
;;;3168     {
;;;3169       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
00012c  68c1              LDR      r1,[r0,#0xc]
00012e  43c9              MVNS     r1,r1
000130  0609              LSLS     r1,r1,#24
000132  d403              BMI      |L45.316|
;;;3170       {
;;;3171         __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
000134  6105              STR      r5,[r0,#0x10]
;;;3172   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3173         htim->BreakCallback(htim);
;;;3174   #else
;;;3175         HAL_TIMEx_BreakCallback(htim);
000136  4620              MOV      r0,r4
000138  f7fffffe          BL       HAL_TIMEx_BreakCallback
                  |L45.316|
;;;3176   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3177       }
;;;3178     }
;;;3179   
;;;3180     /* TIM Trigger detection event */
;;;3181     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
00013c  6820              LDR      r0,[r4,#0]
00013e  6901              LDR      r1,[r0,#0x10]
000140  43c9              MVNS     r1,r1
000142  0649              LSLS     r1,r1,#25
000144  d409              BMI      |L45.346|
;;;3182     {
;;;3183       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) !=RESET)
000146  68c1              LDR      r1,[r0,#0xc]
000148  43c9              MVNS     r1,r1
00014a  0649              LSLS     r1,r1,#25
00014c  d405              BMI      |L45.346|
;;;3184       {
;;;3185         __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
00014e  f06f0140          MVN      r1,#0x40
000152  6101              STR      r1,[r0,#0x10]
;;;3186   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3187         htim->TriggerCallback(htim);
;;;3188   #else
;;;3189         HAL_TIM_TriggerCallback(htim);
000154  4620              MOV      r0,r4
000156  f7fffffe          BL       HAL_TIM_TriggerCallback
                  |L45.346|
;;;3190   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3191       }
;;;3192     }
;;;3193     /* TIM commutation event */
;;;3194     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
00015a  6820              LDR      r0,[r4,#0]
00015c  6901              LDR      r1,[r0,#0x10]
00015e  43c9              MVNS     r1,r1
000160  0689              LSLS     r1,r1,#26
000162  d40b              BMI      |L45.380|
;;;3195     {
;;;3196       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) !=RESET)
000164  68c1              LDR      r1,[r0,#0xc]
000166  43c9              MVNS     r1,r1
000168  0689              LSLS     r1,r1,#26
00016a  d407              BMI      |L45.380|
;;;3197       {
;;;3198         __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
00016c  f06f0120          MVN      r1,#0x20
000170  6101              STR      r1,[r0,#0x10]
;;;3199   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3200         htim->CommutationCallback(htim);
;;;3201   #else
;;;3202         HAL_TIMEx_CommutationCallback(htim);
000172  4620              MOV      r0,r4
000174  e8bd4070          POP      {r4-r6,lr}
000178  f7ffbffe          B.W      HAL_TIMEx_CommutationCallback
                  |L45.380|
;;;3203   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3204       }
;;;3205     }
;;;3206   }
00017c  bd70              POP      {r4-r6,pc}
;;;3207   
                          ENDP


                          AREA ||i.HAL_TIM_OC_ConfigChannel||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_ConfigChannel PROC
;;;3244     */
;;;3245   __weak HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;3246   {
000002  4604              MOV      r4,r0
;;;3247     /* Check the parameters */ 
;;;3248     assert_param(IS_TIM_CHANNELS(Channel)); 
;;;3249     assert_param(IS_TIM_OC_MODE(sConfig->OCMode));
;;;3250     assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
;;;3251     
;;;3252     /* Check input state */
;;;3253     __HAL_LOCK(htim); 
000004  6bc0              LDR      r0,[r0,#0x3c]
000006  2801              CMP      r0,#1
000008  d00b              BEQ      |L46.34|
00000a  2501              MOVS     r5,#1
;;;3254     
;;;3255     htim->State = HAL_TIM_STATE_BUSY;
00000c  2002              MOVS     r0,#2
00000e  e9c4500f          STRD     r5,r0,[r4,#0x3c]
000012  b142              CBZ      r2,|L46.38|
;;;3256     
;;;3257     switch (Channel)
000014  2a04              CMP      r2,#4
000016  d00a              BEQ      |L46.46|
000018  2a08              CMP      r2,#8
00001a  d00c              BEQ      |L46.54|
00001c  2a0c              CMP      r2,#0xc
00001e  d111              BNE      |L46.68|
000020  e00d              B        |L46.62|
                  |L46.34|
000022  2002              MOVS     r0,#2                 ;3253
;;;3258     {
;;;3259       case TIM_CHANNEL_1:
;;;3260       {
;;;3261         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3262         /* Configure the TIM Channel 1 in Output Compare */
;;;3263         TIM_OC1_SetConfig(htim->Instance, sConfig);
;;;3264       }
;;;3265       break;
;;;3266       
;;;3267       case TIM_CHANNEL_2:
;;;3268       {
;;;3269         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3270         /* Configure the TIM Channel 2 in Output Compare */
;;;3271         TIM_OC2_SetConfig(htim->Instance, sConfig);
;;;3272       }
;;;3273       break;
;;;3274       
;;;3275       case TIM_CHANNEL_3:
;;;3276       {
;;;3277          assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3278         /* Configure the TIM Channel 3 in Output Compare */
;;;3279         TIM_OC3_SetConfig(htim->Instance, sConfig);
;;;3280       }
;;;3281       break;
;;;3282       
;;;3283       case TIM_CHANNEL_4:
;;;3284       {
;;;3285         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3286         /* Configure the TIM Channel 4 in Output Compare */
;;;3287         TIM_OC4_SetConfig(htim->Instance, sConfig);
;;;3288       }
;;;3289       break;
;;;3290       
;;;3291       default:
;;;3292       break;    
;;;3293     }
;;;3294     htim->State = HAL_TIM_STATE_READY;
;;;3295     
;;;3296     __HAL_UNLOCK(htim); 
;;;3297     
;;;3298     return HAL_OK;
;;;3299   }
000024  bd30              POP      {r4,r5,pc}
                  |L46.38|
000026  6820              LDR      r0,[r4,#0]            ;3263
000028  f7fffffe          BL       TIM_OC1_SetConfig
00002c  e00a              B        |L46.68|
                  |L46.46|
00002e  6820              LDR      r0,[r4,#0]            ;3271
000030  f7fffffe          BL       TIM_OC2_SetConfig
000034  e006              B        |L46.68|
                  |L46.54|
000036  6820              LDR      r0,[r4,#0]            ;3279
000038  f7fffffe          BL       TIM_OC3_SetConfig
00003c  e002              B        |L46.68|
                  |L46.62|
00003e  6820              LDR      r0,[r4,#0]            ;3287
000040  f7fffffe          BL       TIM_OC4_SetConfig
                  |L46.68|
000044  2000              MOVS     r0,#0                 ;3296
000046  6425              STR      r5,[r4,#0x40]         ;3294
000048  63e0              STR      r0,[r4,#0x3c]         ;3296
00004a  bd30              POP      {r4,r5,pc}
;;;3300   
                          ENDP


                          AREA ||i.HAL_TIM_OC_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_DeInit PROC
;;;615      */
;;;616    HAL_StatusTypeDef HAL_TIM_OC_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;617    {
000002  4604              MOV      r4,r0
;;;618      /* Check the parameters */
;;;619      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;620      
;;;621       htim->State = HAL_TIM_STATE_BUSY;
;;;622       
;;;623      /* Disable the TIM Peripheral Clock */
;;;624      __HAL_TIM_DISABLE(htim);
000004  f2411211          MOV      r2,#0x1111
000008  2002              MOVS     r0,#2                 ;621
00000a  6420              STR      r0,[r4,#0x40]         ;621
00000c  6820              LDR      r0,[r4,#0]
00000e  6a01              LDR      r1,[r0,#0x20]
000010  4211              TST      r1,r2
000012  d107              BNE      |L47.36|
000014  6a01              LDR      r1,[r0,#0x20]
000016  1092              ASRS     r2,r2,#2
000018  4211              TST      r1,r2
00001a  d103              BNE      |L47.36|
00001c  6801              LDR      r1,[r0,#0]
00001e  f0210101          BIC      r1,r1,#1
000022  6001              STR      r1,[r0,#0]
                  |L47.36|
;;;625    
;;;626    #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;627      if(htim->OC_MspDeInitCallback == NULL)
;;;628      {
;;;629        htim->OC_MspDeInitCallback = HAL_TIM_OC_MspDeInit;
;;;630      }
;;;631      /* DeInit the low level hardware */
;;;632      htim->OC_MspDeInitCallback(htim);
;;;633    #else
;;;634      /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;635      HAL_TIM_OC_MspDeInit(htim);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       HAL_TIM_OC_MspDeInit
;;;636    #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;637    
;;;638      /* Change TIM state */  
;;;639      htim->State = HAL_TIM_STATE_RESET; 
00002a  2000              MOVS     r0,#0
00002c  6420              STR      r0,[r4,#0x40]
;;;640    
;;;641      /* Release Lock */
;;;642      __HAL_UNLOCK(htim);
00002e  63e0              STR      r0,[r4,#0x3c]
;;;643    
;;;644      return HAL_OK;
;;;645    }
000030  bd10              POP      {r4,pc}
;;;646    
                          ENDP


                          AREA ||i.HAL_TIM_OC_DelayElapsedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_DelayElapsedCallback PROC
;;;4704     */
;;;4705   __weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4706   {
;;;4707     /* Prevent unused argument(s) compilation warning */
;;;4708     UNUSED(htim);
;;;4709    
;;;4710     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4711               the __HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
;;;4712      */
;;;4713   }
;;;4714   /**
                          ENDP


                          AREA ||i.HAL_TIM_OC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_GetState PROC
;;;5245     */
;;;5246   HAL_TIM_StateTypeDef HAL_TIM_OC_GetState(TIM_HandleTypeDef *htim)
000000  6c00              LDR      r0,[r0,#0x40]
;;;5247   {
;;;5248     return htim->State;
;;;5249   }
000002  4770              BX       lr
;;;5250   
                          ENDP


                          AREA ||i.HAL_TIM_OC_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_Init PROC
;;;563      */
;;;564    HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef* htim)
000000  b510              PUSH     {r4,lr}
;;;565    {
000002  0004              MOVS     r4,r0
000004  d002              BEQ      |L50.12|
;;;566      /* Check the TIM handle allocation */
;;;567      if(htim == NULL)
;;;568      {
;;;569        return HAL_ERROR;
;;;570      }
;;;571    
;;;572      /* Check the parameters */
;;;573      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;574      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;575      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;576      assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;577    
;;;578      if(htim->State == HAL_TIM_STATE_RESET)
000006  6c20              LDR      r0,[r4,#0x40]
000008  b110              CBZ      r0,|L50.16|
00000a  e006              B        |L50.26|
                  |L50.12|
00000c  2001              MOVS     r0,#1                 ;569
;;;579      {
;;;580        /* Allocate lock resource and initialize it */
;;;581        htim->Lock = HAL_UNLOCKED;
;;;582    
;;;583    #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;584        /* Reset interrupt callbacks to legacy week callbacks */
;;;585        TIM_ResetCallback(htim);
;;;586    
;;;587        if(htim->OC_MspInitCallback == NULL)
;;;588        {
;;;589          htim->OC_MspInitCallback = HAL_TIM_OC_MspDeInit;
;;;590        }
;;;591        /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;592        htim->OC_MspInitCallback(htim);
;;;593    #else
;;;594        /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;595        HAL_TIM_OC_MspInit(htim);
;;;596    #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;597      }
;;;598      /* Set the TIM state */
;;;599      htim->State= HAL_TIM_STATE_BUSY;
;;;600      
;;;601      /* Init the base time for the Output Compare */  
;;;602      TIM_Base_SetConfig(htim->Instance,  &htim->Init); 
;;;603      
;;;604      /* Initialize the TIM state*/
;;;605      htim->State= HAL_TIM_STATE_READY;
;;;606      
;;;607      return HAL_OK;
;;;608    }
00000e  bd10              POP      {r4,pc}
                  |L50.16|
000010  2000              MOVS     r0,#0                 ;581
000012  63e0              STR      r0,[r4,#0x3c]         ;595
000014  4620              MOV      r0,r4                 ;595
000016  f7fffffe          BL       HAL_TIM_OC_MspInit
                  |L50.26|
00001a  2002              MOVS     r0,#2                 ;599
00001c  6420              STR      r0,[r4,#0x40]         ;599
00001e  6820              LDR      r0,[r4,#0]            ;602
000020  1d21              ADDS     r1,r4,#4              ;602
000022  f7fffffe          BL       TIM_Base_SetConfig
000026  2001              MOVS     r0,#1                 ;605
000028  6420              STR      r0,[r4,#0x40]         ;605
00002a  2000              MOVS     r0,#0                 ;607
00002c  bd10              POP      {r4,pc}
;;;609    
                          ENDP


                          AREA ||i.HAL_TIM_OC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_MspDeInit PROC
;;;668      */
;;;669    __weak void HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;670    {
;;;671      /* Prevent unused argument(s) compilation warning */
;;;672      UNUSED(htim);
;;;673     
;;;674      /* NOTE : This function Should not be modified, when the callback is needed,
;;;675                the HAL_TIM_OC_MspDeInit could be implemented in the user file
;;;676       */
;;;677    }
;;;678    
                          ENDP


                          AREA ||i.HAL_TIM_OC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_MspInit PROC
;;;652      */
;;;653    __weak void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;654    {
;;;655      /* Prevent unused argument(s) compilation warning */
;;;656      UNUSED(htim);
;;;657     
;;;658      /* NOTE : This function Should not be modified, when the callback is needed,
;;;659                the HAL_TIM_OC_MspInit could be implemented in the user file
;;;660       */
;;;661    }
;;;662    
                          ENDP


                          AREA ||i.HAL_TIM_OC_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Start PROC
;;;690      */
;;;691    HAL_StatusTypeDef HAL_TIM_OC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;692    {
;;;693      /* Check the parameters */
;;;694      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;695      
;;;696      /* Enable the Output compare channel */
;;;697      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000002  2201              MOVS     r2,#1
000004  4604              MOV      r4,r0                 ;692
000006  6800              LDR      r0,[r0,#0]
000008  f7fffffe          BL       TIM_CCxChannelCmd
;;;698      
;;;699      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00000c  4908              LDR      r1,|L53.48|
00000e  6820              LDR      r0,[r4,#0]
000010  4288              CMP      r0,r1
000012  d002              BEQ      |L53.26|
000014  4907              LDR      r1,|L53.52|
000016  4288              CMP      r0,r1
000018  d103              BNE      |L53.34|
                  |L53.26|
;;;700      {
;;;701        /* Enable the main output */
;;;702        __HAL_TIM_MOE_ENABLE(htim);
00001a  6c41              LDR      r1,[r0,#0x44]
00001c  f4414100          ORR      r1,r1,#0x8000
000020  6441              STR      r1,[r0,#0x44]
                  |L53.34|
;;;703      }
;;;704      
;;;705      /* Enable the Peripheral */
;;;706      __HAL_TIM_ENABLE(htim); 
000022  6820              LDR      r0,[r4,#0]
000024  6801              LDR      r1,[r0,#0]
000026  f0410101          ORR      r1,r1,#1
00002a  6001              STR      r1,[r0,#0]
;;;707      
;;;708      /* Return function status */
;;;709      return HAL_OK;
00002c  2000              MOVS     r0,#0
;;;710    }
00002e  bd10              POP      {r4,pc}
;;;711    
                          ENDP

                  |L53.48|
                          DCD      0x40010000
                  |L53.52|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OC_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Start_DMA PROC
;;;892      */
;;;893    HAL_StatusTypeDef HAL_TIM_OC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;894    {
000002  4604              MOV      r4,r0
;;;895      /* Check the parameters */
;;;896      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;897      
;;;898      if((htim->State == HAL_TIM_STATE_BUSY))
000004  6c00              LDR      r0,[r0,#0x40]
000006  4616              MOV      r6,r2                 ;894
000008  460d              MOV      r5,r1                 ;894
00000a  2802              CMP      r0,#2
00000c  d004              BEQ      |L54.24|
;;;899      {
;;;900         return HAL_BUSY;
;;;901      }
;;;902      else if((htim->State == HAL_TIM_STATE_READY))
00000e  6c20              LDR      r0,[r4,#0x40]
000010  2801              CMP      r0,#1
000012  d104              BNE      |L54.30|
;;;903      {
;;;904        if(((uint32_t)pData == 0 ) && (Length > 0)) 
000014  b90e              CBNZ     r6,|L54.26|
000016  b103              CBZ      r3,|L54.26|
                  |L54.24|
;;;905        {
;;;906          return HAL_ERROR;                                    
;;;907        }
;;;908        else
;;;909        {
;;;910          htim->State = HAL_TIM_STATE_BUSY;
;;;911        }
;;;912      }    
;;;913      switch (Channel)
;;;914      {
;;;915        case TIM_CHANNEL_1:
;;;916        {      
;;;917          /* Set the DMA Period elapsed callback */
;;;918          htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;919         
;;;920          /* Set the DMA error callback */
;;;921          htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
;;;922          
;;;923          /* Enable the DMA Stream */
;;;924          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
;;;925          
;;;926          /* Enable the TIM Capture/Compare 1 DMA request */
;;;927          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;928        }
;;;929        break;
;;;930        
;;;931        case TIM_CHANNEL_2:
;;;932        {
;;;933          /* Set the DMA Period elapsed callback */
;;;934          htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;935         
;;;936          /* Set the DMA error callback */
;;;937          htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
;;;938          
;;;939          /* Enable the DMA Stream */
;;;940          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
;;;941          
;;;942          /* Enable the TIM Capture/Compare 2 DMA request */
;;;943          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;944        }
;;;945        break;
;;;946        
;;;947        case TIM_CHANNEL_3:
;;;948        {
;;;949          /* Set the DMA Period elapsed callback */
;;;950          htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;951         
;;;952          /* Set the DMA error callback */
;;;953          htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
;;;954          
;;;955          /* Enable the DMA Stream */
;;;956          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
;;;957          
;;;958          /* Enable the TIM Capture/Compare 3 DMA request */
;;;959          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;960        }
;;;961        break;
;;;962        
;;;963        case TIM_CHANNEL_4:
;;;964        {
;;;965         /* Set the DMA Period elapsed callback */
;;;966          htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;967         
;;;968          /* Set the DMA error callback */
;;;969          htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
;;;970          
;;;971          /* Enable the DMA Stream */
;;;972          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
;;;973          
;;;974          /* Enable the TIM Capture/Compare 4 DMA request */
;;;975          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;976        }
;;;977        break;
;;;978        
;;;979        default:
;;;980        break;
;;;981      }
;;;982    
;;;983      /* Enable the Output compare channel */
;;;984      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;985      
;;;986      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
;;;987      {
;;;988        /* Enable the main output */
;;;989        __HAL_TIM_MOE_ENABLE(htim);
;;;990      }  
;;;991      
;;;992      /* Enable the Peripheral */
;;;993      __HAL_TIM_ENABLE(htim); 
;;;994      
;;;995      /* Return function status */
;;;996      return HAL_OK;
;;;997    }
000018  bd70              POP      {r4-r6,pc}
                  |L54.26|
00001a  2002              MOVS     r0,#2                 ;910
00001c  6420              STR      r0,[r4,#0x40]         ;910
                  |L54.30|
00001e  482e              LDR      r0,|L54.216|
000020  492e              LDR      r1,|L54.220|
000022  b135              CBZ      r5,|L54.50|
000024  2d04              CMP      r5,#4                 ;913
000026  d013              BEQ      |L54.80|
000028  2d08              CMP      r5,#8                 ;913
00002a  d037              BEQ      |L54.156|
00002c  2d0c              CMP      r5,#0xc               ;913
00002e  d11e              BNE      |L54.110|
000030  e043              B        |L54.186|
                  |L54.50|
000032  6a62              LDR      r2,[r4,#0x24]         ;918
000034  6410              STR      r0,[r2,#0x40]         ;921
000036  6a60              LDR      r0,[r4,#0x24]         ;921
000038  6501              STR      r1,[r0,#0x50]         ;924
00003a  4631              MOV      r1,r6                 ;924
00003c  6822              LDR      r2,[r4,#0]            ;924
00003e  6a60              LDR      r0,[r4,#0x24]         ;924
000040  3234              ADDS     r2,r2,#0x34           ;924
000042  f7fffffe          BL       HAL_DMA_Start_IT
000046  6820              LDR      r0,[r4,#0]            ;927
000048  68c1              LDR      r1,[r0,#0xc]          ;927
00004a  f4417100          ORR      r1,r1,#0x200          ;927
00004e  e00d              B        |L54.108|
                  |L54.80|
000050  6aa2              LDR      r2,[r4,#0x28]         ;934
000052  6410              STR      r0,[r2,#0x40]         ;937
000054  6aa0              LDR      r0,[r4,#0x28]         ;937
000056  6501              STR      r1,[r0,#0x50]         ;940
000058  4631              MOV      r1,r6                 ;940
00005a  6822              LDR      r2,[r4,#0]            ;940
00005c  6aa0              LDR      r0,[r4,#0x28]         ;940
00005e  3238              ADDS     r2,r2,#0x38           ;940
000060  f7fffffe          BL       HAL_DMA_Start_IT
000064  6820              LDR      r0,[r4,#0]            ;943
000066  68c1              LDR      r1,[r0,#0xc]          ;943
000068  f4416180          ORR      r1,r1,#0x400          ;943
                  |L54.108|
00006c  60c1              STR      r1,[r0,#0xc]          ;927
                  |L54.110|
00006e  6820              LDR      r0,[r4,#0]            ;984
000070  2201              MOVS     r2,#1                 ;984
000072  4629              MOV      r1,r5                 ;984
000074  f7fffffe          BL       TIM_CCxChannelCmd
000078  4919              LDR      r1,|L54.224|
00007a  6820              LDR      r0,[r4,#0]            ;986
00007c  4288              CMP      r0,r1                 ;986
00007e  d002              BEQ      |L54.134|
000080  4918              LDR      r1,|L54.228|
000082  4288              CMP      r0,r1                 ;986
000084  d103              BNE      |L54.142|
                  |L54.134|
000086  6c41              LDR      r1,[r0,#0x44]         ;989
000088  f4414100          ORR      r1,r1,#0x8000         ;989
00008c  6441              STR      r1,[r0,#0x44]         ;989
                  |L54.142|
00008e  6820              LDR      r0,[r4,#0]            ;993
000090  6801              LDR      r1,[r0,#0]            ;993
000092  f0410101          ORR      r1,r1,#1              ;993
000096  6001              STR      r1,[r0,#0]            ;993
000098  2000              MOVS     r0,#0                 ;996
00009a  bd70              POP      {r4-r6,pc}
                  |L54.156|
00009c  6ae2              LDR      r2,[r4,#0x2c]         ;950
00009e  6410              STR      r0,[r2,#0x40]         ;953
0000a0  6ae0              LDR      r0,[r4,#0x2c]         ;953
0000a2  6501              STR      r1,[r0,#0x50]         ;956
0000a4  4631              MOV      r1,r6                 ;956
0000a6  6822              LDR      r2,[r4,#0]            ;956
0000a8  6ae0              LDR      r0,[r4,#0x2c]         ;956
0000aa  323c              ADDS     r2,r2,#0x3c           ;956
0000ac  f7fffffe          BL       HAL_DMA_Start_IT
0000b0  6820              LDR      r0,[r4,#0]            ;959
0000b2  68c1              LDR      r1,[r0,#0xc]          ;959
0000b4  f4416100          ORR      r1,r1,#0x800          ;959
0000b8  e7d8              B        |L54.108|
                  |L54.186|
0000ba  6b22              LDR      r2,[r4,#0x30]         ;966
0000bc  6410              STR      r0,[r2,#0x40]         ;969
0000be  6b20              LDR      r0,[r4,#0x30]         ;969
0000c0  6501              STR      r1,[r0,#0x50]         ;972
0000c2  4631              MOV      r1,r6                 ;972
0000c4  6822              LDR      r2,[r4,#0]            ;972
0000c6  6b20              LDR      r0,[r4,#0x30]         ;972
0000c8  3240              ADDS     r2,r2,#0x40           ;972
0000ca  f7fffffe          BL       HAL_DMA_Start_IT
0000ce  6820              LDR      r0,[r4,#0]            ;975
0000d0  68c1              LDR      r1,[r0,#0xc]          ;975
0000d2  f4415180          ORR      r1,r1,#0x1000         ;975
0000d6  e7c9              B        |L54.108|
;;;998    
                          ENDP

                  |L54.216|
                          DCD      TIM_DMADelayPulseCplt
                  |L54.220|
                          DCD      TIM_DMAError
                  |L54.224|
                          DCD      0x40010000
                  |L54.228|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OC_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Start_IT PROC
;;;756      */
;;;757    HAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;758    {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L55.22|
;;;759      /* Check the parameters */
;;;760      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;761      
;;;762      switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L55.30|
00000c  2908              CMP      r1,#8
00000e  d020              BEQ      |L55.82|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L55.38|
000014  e021              B        |L55.90|
                  |L55.22|
;;;763      {
;;;764        case TIM_CHANNEL_1:
;;;765        {       
;;;766          /* Enable the TIM Capture/Compare 1 interrupt */
;;;767          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f0400002          ORR      r0,r0,#2
;;;768        }
;;;769        break;
00001c  e002              B        |L55.36|
                  |L55.30|
;;;770        
;;;771        case TIM_CHANNEL_2:
;;;772        {
;;;773          /* Enable the TIM Capture/Compare 2 interrupt */
;;;774          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f0400004          ORR      r0,r0,#4
                  |L55.36|
000024  60d0              STR      r0,[r2,#0xc]          ;767
                  |L55.38|
;;;775        }
;;;776        break;
;;;777        
;;;778        case TIM_CHANNEL_3:
;;;779        {
;;;780          /* Enable the TIM Capture/Compare 3 interrupt */
;;;781          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
;;;782        }
;;;783        break;
;;;784        
;;;785        case TIM_CHANNEL_4:
;;;786        {
;;;787          /* Enable the TIM Capture/Compare 4 interrupt */
;;;788          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
;;;789        }
;;;790        break;
;;;791        
;;;792        default:
;;;793        break;
;;;794      } 
;;;795    
;;;796      /* Enable the Output compare channel */
;;;797      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000026  6820              LDR      r0,[r4,#0]
000028  2201              MOVS     r2,#1
00002a  f7fffffe          BL       TIM_CCxChannelCmd
;;;798      
;;;799      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00002e  490d              LDR      r1,|L55.100|
000030  6820              LDR      r0,[r4,#0]
000032  4288              CMP      r0,r1
000034  d002              BEQ      |L55.60|
000036  490c              LDR      r1,|L55.104|
000038  4288              CMP      r0,r1
00003a  d103              BNE      |L55.68|
                  |L55.60|
;;;800      {
;;;801        /* Enable the main output */
;;;802        __HAL_TIM_MOE_ENABLE(htim);
00003c  6c41              LDR      r1,[r0,#0x44]
00003e  f4414100          ORR      r1,r1,#0x8000
000042  6441              STR      r1,[r0,#0x44]
                  |L55.68|
;;;803      }
;;;804    
;;;805      /* Enable the Peripheral */
;;;806      __HAL_TIM_ENABLE(htim);
000044  6820              LDR      r0,[r4,#0]
000046  6801              LDR      r1,[r0,#0]
000048  f0410101          ORR      r1,r1,#1
00004c  6001              STR      r1,[r0,#0]
;;;807      
;;;808      /* Return function status */
;;;809      return HAL_OK;
00004e  2000              MOVS     r0,#0
;;;810    }
000050  bd10              POP      {r4,pc}
                  |L55.82|
000052  68d0              LDR      r0,[r2,#0xc]          ;781
000054  f0400008          ORR      r0,r0,#8              ;781
000058  e7e4              B        |L55.36|
                  |L55.90|
00005a  68d0              LDR      r0,[r2,#0xc]          ;788
00005c  f0400010          ORR      r0,r0,#0x10           ;788
000060  e7e0              B        |L55.36|
;;;811    
                          ENDP

000062  0000              DCW      0x0000
                  |L55.100|
                          DCD      0x40010000
                  |L55.104|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OC_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Stop PROC
;;;723      */
;;;724    HAL_StatusTypeDef HAL_TIM_OC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;725    {
;;;726      /* Check the parameters */
;;;727      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;728      
;;;729      /* Disable the Output compare channel */
;;;730      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000002  2200              MOVS     r2,#0
000004  4604              MOV      r4,r0                 ;725
000006  6800              LDR      r0,[r0,#0]
000008  f7fffffe          BL       TIM_CCxChannelCmd
;;;731      
;;;732      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
;;;733      {
;;;734        /* Disable the Main Output */
;;;735        __HAL_TIM_MOE_DISABLE(htim);
00000c  f2411211          MOV      r2,#0x1111
000010  480f              LDR      r0,|L56.80|
000012  6821              LDR      r1,[r4,#0]            ;732
000014  1093              ASRS     r3,r2,#2
000016  4281              CMP      r1,r0                 ;732
000018  d002              BEQ      |L56.32|
00001a  480e              LDR      r0,|L56.84|
00001c  4281              CMP      r1,r0                 ;732
00001e  d109              BNE      |L56.52|
                  |L56.32|
000020  6a08              LDR      r0,[r1,#0x20]
000022  4210              TST      r0,r2
000024  d106              BNE      |L56.52|
000026  6a08              LDR      r0,[r1,#0x20]
000028  4218              TST      r0,r3
00002a  d103              BNE      |L56.52|
00002c  6c48              LDR      r0,[r1,#0x44]
00002e  f4204000          BIC      r0,r0,#0x8000
000032  6448              STR      r0,[r1,#0x44]
                  |L56.52|
;;;736      }  
;;;737      
;;;738      /* Disable the Peripheral */
;;;739      __HAL_TIM_DISABLE(htim);  
000034  6820              LDR      r0,[r4,#0]
000036  6a01              LDR      r1,[r0,#0x20]
000038  4211              TST      r1,r2
00003a  d106              BNE      |L56.74|
00003c  6a01              LDR      r1,[r0,#0x20]
00003e  4219              TST      r1,r3
000040  d103              BNE      |L56.74|
000042  6801              LDR      r1,[r0,#0]
000044  f0210101          BIC      r1,r1,#1
000048  6001              STR      r1,[r0,#0]
                  |L56.74|
;;;740      
;;;741      /* Return function status */
;;;742      return HAL_OK;
00004a  2000              MOVS     r0,#0
;;;743    }  
00004c  bd10              POP      {r4,pc}
;;;744    
                          ENDP

00004e  0000              DCW      0x0000
                  |L56.80|
                          DCD      0x40010000
                  |L56.84|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OC_Stop_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Stop_DMA PROC
;;;1010     */
;;;1011   HAL_StatusTypeDef HAL_TIM_OC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1012   {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L57.22|
;;;1013     /* Check the parameters */
;;;1014     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1015     
;;;1016     switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L57.30|
00000c  2908              CMP      r1,#8
00000e  d031              BEQ      |L57.116|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L57.38|
000014  e032              B        |L57.124|
                  |L57.22|
;;;1017     {
;;;1018       case TIM_CHANNEL_1:
;;;1019       {       
;;;1020         /* Disable the TIM Capture/Compare 1 DMA request */
;;;1021         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f4207000          BIC      r0,r0,#0x200
;;;1022       }
;;;1023       break;
00001c  e002              B        |L57.36|
                  |L57.30|
;;;1024       
;;;1025       case TIM_CHANNEL_2:
;;;1026       {
;;;1027         /* Disable the TIM Capture/Compare 2 DMA request */
;;;1028         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f4206080          BIC      r0,r0,#0x400
                  |L57.36|
000024  60d0              STR      r0,[r2,#0xc]          ;1021
                  |L57.38|
;;;1029       }
;;;1030       break;
;;;1031       
;;;1032       case TIM_CHANNEL_3:
;;;1033       {
;;;1034         /* Disable the TIM Capture/Compare 3 DMA request */
;;;1035         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
;;;1036       }
;;;1037       break;
;;;1038       
;;;1039       case TIM_CHANNEL_4:
;;;1040       {
;;;1041         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1042         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
;;;1043       }
;;;1044       break;
;;;1045       
;;;1046       default:
;;;1047       break;
;;;1048     } 
;;;1049     
;;;1050     /* Disable the Output compare channel */
;;;1051     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000026  6820              LDR      r0,[r4,#0]
000028  2200              MOVS     r2,#0
00002a  f7fffffe          BL       TIM_CCxChannelCmd
;;;1052     
;;;1053     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
;;;1054     {
;;;1055       /* Disable the Main Output */
;;;1056       __HAL_TIM_MOE_DISABLE(htim);
00002e  f2411111          MOV      r1,#0x1111
000032  4b14              LDR      r3,|L57.132|
000034  6820              LDR      r0,[r4,#0]            ;1053
000036  108a              ASRS     r2,r1,#2
000038  4298              CMP      r0,r3                 ;1053
00003a  d002              BEQ      |L57.66|
00003c  4b12              LDR      r3,|L57.136|
00003e  4298              CMP      r0,r3                 ;1053
000040  d109              BNE      |L57.86|
                  |L57.66|
000042  6a03              LDR      r3,[r0,#0x20]
000044  420b              TST      r3,r1
000046  d106              BNE      |L57.86|
000048  6a03              LDR      r3,[r0,#0x20]
00004a  4213              TST      r3,r2
00004c  d103              BNE      |L57.86|
00004e  6c43              LDR      r3,[r0,#0x44]
000050  f4234300          BIC      r3,r3,#0x8000
000054  6443              STR      r3,[r0,#0x44]
                  |L57.86|
;;;1057     }
;;;1058     
;;;1059     /* Disable the Peripheral */
;;;1060     __HAL_TIM_DISABLE(htim);
000056  6820              LDR      r0,[r4,#0]
000058  6a03              LDR      r3,[r0,#0x20]
00005a  420b              TST      r3,r1
00005c  d106              BNE      |L57.108|
00005e  6a01              LDR      r1,[r0,#0x20]
000060  4211              TST      r1,r2
000062  d103              BNE      |L57.108|
000064  6801              LDR      r1,[r0,#0]
000066  f0210101          BIC      r1,r1,#1
00006a  6001              STR      r1,[r0,#0]
                  |L57.108|
;;;1061     
;;;1062     /* Change the htim state */
;;;1063     htim->State = HAL_TIM_STATE_READY;
00006c  2001              MOVS     r0,#1
00006e  6420              STR      r0,[r4,#0x40]
;;;1064     
;;;1065     /* Return function status */
;;;1066     return HAL_OK;
000070  2000              MOVS     r0,#0
;;;1067   }
000072  bd10              POP      {r4,pc}
                  |L57.116|
000074  68d0              LDR      r0,[r2,#0xc]          ;1035
000076  f4206000          BIC      r0,r0,#0x800          ;1035
00007a  e7d3              B        |L57.36|
                  |L57.124|
00007c  68d0              LDR      r0,[r2,#0xc]          ;1042
00007e  f4205080          BIC      r0,r0,#0x1000         ;1042
000082  e7cf              B        |L57.36|
;;;1068   
                          ENDP

                  |L57.132|
                          DCD      0x40010000
                  |L57.136|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OC_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Stop_IT PROC
;;;823      */
;;;824    HAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;825    {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L58.22|
;;;826      /* Check the parameters */
;;;827      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;828      
;;;829      switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L58.30|
00000c  2908              CMP      r1,#8
00000e  d02f              BEQ      |L58.112|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L58.38|
000014  e030              B        |L58.120|
                  |L58.22|
;;;830      {
;;;831        case TIM_CHANNEL_1:
;;;832        {       
;;;833          /* Disable the TIM Capture/Compare 1 interrupt */
;;;834          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f0200002          BIC      r0,r0,#2
;;;835        }
;;;836        break;
00001c  e002              B        |L58.36|
                  |L58.30|
;;;837        
;;;838        case TIM_CHANNEL_2:
;;;839        {
;;;840          /* Disable the TIM Capture/Compare 2 interrupt */
;;;841          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f0200004          BIC      r0,r0,#4
                  |L58.36|
000024  60d0              STR      r0,[r2,#0xc]          ;834
                  |L58.38|
;;;842        }
;;;843        break;
;;;844        
;;;845        case TIM_CHANNEL_3:
;;;846        {
;;;847          /* Disable the TIM Capture/Compare 3 interrupt */
;;;848          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
;;;849        }
;;;850        break;
;;;851        
;;;852        case TIM_CHANNEL_4:
;;;853        {
;;;854          /* Disable the TIM Capture/Compare 4 interrupt */
;;;855          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
;;;856        }
;;;857        break;
;;;858        
;;;859        default:
;;;860        break; 
;;;861      } 
;;;862      
;;;863      /* Disable the Output compare channel */
;;;864      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE); 
000026  6820              LDR      r0,[r4,#0]
000028  2200              MOVS     r2,#0
00002a  f7fffffe          BL       TIM_CCxChannelCmd
;;;865      
;;;866      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
;;;867      {
;;;868        /* Disable the Main Output */
;;;869        __HAL_TIM_MOE_DISABLE(htim);
00002e  f2411311          MOV      r3,#0x1111
000032  4813              LDR      r0,|L58.128|
000034  6821              LDR      r1,[r4,#0]            ;866
000036  109a              ASRS     r2,r3,#2
000038  4281              CMP      r1,r0                 ;866
00003a  d002              BEQ      |L58.66|
00003c  4811              LDR      r0,|L58.132|
00003e  4281              CMP      r1,r0                 ;866
000040  d109              BNE      |L58.86|
                  |L58.66|
000042  6a08              LDR      r0,[r1,#0x20]
000044  4218              TST      r0,r3
000046  d106              BNE      |L58.86|
000048  6a08              LDR      r0,[r1,#0x20]
00004a  4210              TST      r0,r2
00004c  d103              BNE      |L58.86|
00004e  6c48              LDR      r0,[r1,#0x44]
000050  f4204000          BIC      r0,r0,#0x8000
000054  6448              STR      r0,[r1,#0x44]
                  |L58.86|
;;;870      }
;;;871      
;;;872      /* Disable the Peripheral */
;;;873      __HAL_TIM_DISABLE(htim);  
000056  6820              LDR      r0,[r4,#0]
000058  6a01              LDR      r1,[r0,#0x20]
00005a  4219              TST      r1,r3
00005c  d106              BNE      |L58.108|
00005e  6a01              LDR      r1,[r0,#0x20]
000060  4211              TST      r1,r2
000062  d103              BNE      |L58.108|
000064  6801              LDR      r1,[r0,#0]
000066  f0210101          BIC      r1,r1,#1
00006a  6001              STR      r1,[r0,#0]
                  |L58.108|
;;;874      
;;;875      /* Return function status */
;;;876      return HAL_OK;
00006c  2000              MOVS     r0,#0
;;;877    }
00006e  bd10              POP      {r4,pc}
                  |L58.112|
000070  68d0              LDR      r0,[r2,#0xc]          ;848
000072  f0200008          BIC      r0,r0,#8              ;848
000076  e7d5              B        |L58.36|
                  |L58.120|
000078  68d0              LDR      r0,[r2,#0xc]          ;855
00007a  f0200010          BIC      r0,r0,#0x10           ;855
00007e  e7d1              B        |L58.36|
;;;878    
                          ENDP

                  |L58.128|
                          DCD      0x40010000
                  |L58.132|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OnePulse_ConfigChannel||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_ConfigChannel PROC
;;;3512     */
;;;3513   HAL_StatusTypeDef HAL_TIM_OnePulse_ConfigChannel(TIM_HandleTypeDef *htim,  TIM_OnePulse_InitTypeDef* sConfig, uint32_t OutputChannel,  uint32_t InputChannel)
000000  b5f0              PUSH     {r4-r7,lr}
;;;3514   {
000002  461e              MOV      r6,r3
000004  460d              MOV      r5,r1
;;;3515     TIM_OC_InitTypeDef temp1;
;;;3516     
;;;3517     /* Check the parameters */
;;;3518     assert_param(IS_TIM_OPM_CHANNELS(OutputChannel));
;;;3519     assert_param(IS_TIM_OPM_CHANNELS(InputChannel));
;;;3520   
;;;3521     if(OutputChannel != InputChannel)  
000006  42b2              CMP      r2,r6
000008  4604              MOV      r4,r0                 ;3514
00000a  b087              SUB      sp,sp,#0x1c           ;3514
00000c  d05f              BEQ      |L59.206|
;;;3522     {
;;;3523       __HAL_LOCK(htim);
00000e  6be0              LDR      r0,[r4,#0x3c]
000010  2801              CMP      r0,#1
000012  d013              BEQ      |L59.60|
000014  2701              MOVS     r7,#1
;;;3524     
;;;3525       htim->State = HAL_TIM_STATE_BUSY;
000016  2002              MOVS     r0,#2
000018  e9c4700f          STRD     r7,r0,[r4,#0x3c]
;;;3526   
;;;3527       /* Extract the Output compare configuration from sConfig structure */  
;;;3528       temp1.OCMode = sConfig->OCMode;
00001c  6828              LDR      r0,[r5,#0]
;;;3529       temp1.Pulse = sConfig->Pulse;
00001e  9000              STR      r0,[sp,#0]
000020  6868              LDR      r0,[r5,#4]
;;;3530       temp1.OCPolarity = sConfig->OCPolarity;
000022  9001              STR      r0,[sp,#4]
000024  68a8              LDR      r0,[r5,#8]
;;;3531       temp1.OCNPolarity = sConfig->OCNPolarity;
000026  9002              STR      r0,[sp,#8]
000028  68e8              LDR      r0,[r5,#0xc]
;;;3532       temp1.OCIdleState = sConfig->OCIdleState;
00002a  9003              STR      r0,[sp,#0xc]
00002c  6928              LDR      r0,[r5,#0x10]
;;;3533       temp1.OCNIdleState = sConfig->OCNIdleState; 
00002e  9005              STR      r0,[sp,#0x14]
000030  6968              LDR      r0,[r5,#0x14]
000032  9006              STR      r0,[sp,#0x18]         ;3523
000034  b12a              CBZ      r2,|L59.66|
;;;3534       
;;;3535       switch (OutputChannel)
000036  2a04              CMP      r2,#4
000038  d10c              BNE      |L59.84|
00003a  e007              B        |L59.76|
                  |L59.60|
00003c  2002              MOVS     r0,#2                 ;3523
                  |L59.62|
;;;3536       {
;;;3537         case TIM_CHANNEL_1:
;;;3538         {
;;;3539           assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3540         
;;;3541           TIM_OC1_SetConfig(htim->Instance, &temp1); 
;;;3542         }
;;;3543         break;
;;;3544         case TIM_CHANNEL_2:
;;;3545         {
;;;3546           assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3547         
;;;3548           TIM_OC2_SetConfig(htim->Instance, &temp1);
;;;3549         }
;;;3550         break;
;;;3551         default:
;;;3552         break;  
;;;3553       } 
;;;3554       switch (InputChannel)
;;;3555       {
;;;3556         case TIM_CHANNEL_1:
;;;3557         {
;;;3558           assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3559         
;;;3560           TIM_TI1_SetConfig(htim->Instance, sConfig->ICPolarity,
;;;3561                           sConfig->ICSelection, sConfig->ICFilter);
;;;3562                  
;;;3563           /* Reset the IC1PSC Bits */
;;;3564           htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
;;;3565   
;;;3566           /* Select the Trigger source */
;;;3567           htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;3568           htim->Instance->SMCR |= TIM_TS_TI1FP1;
;;;3569         
;;;3570           /* Select the Slave Mode */      
;;;3571           htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;3572           htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
;;;3573         }
;;;3574         break;
;;;3575         case TIM_CHANNEL_2:
;;;3576         {
;;;3577           assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3578         
;;;3579           TIM_TI2_SetConfig(htim->Instance, sConfig->ICPolarity,
;;;3580                    sConfig->ICSelection, sConfig->ICFilter);
;;;3581                  
;;;3582           /* Reset the IC2PSC Bits */
;;;3583           htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
;;;3584   
;;;3585           /* Select the Trigger source */
;;;3586           htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;3587           htim->Instance->SMCR |= TIM_TS_TI2FP2;
;;;3588         
;;;3589           /* Select the Slave Mode */      
;;;3590           htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;3591           htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
;;;3592         }
;;;3593         break;
;;;3594       
;;;3595         default:
;;;3596         break;  
;;;3597       }
;;;3598     
;;;3599       htim->State = HAL_TIM_STATE_READY;
;;;3600       
;;;3601       __HAL_UNLOCK(htim);
;;;3602     
;;;3603       return HAL_OK;
;;;3604     }
;;;3605     else
;;;3606     {
;;;3607       return HAL_ERROR;
;;;3608     }
;;;3609   } 
00003e  b007              ADD      sp,sp,#0x1c
000040  bdf0              POP      {r4-r7,pc}
                  |L59.66|
000042  6820              LDR      r0,[r4,#0]            ;3541
000044  4669              MOV      r1,sp                 ;3541
000046  f7fffffe          BL       TIM_OC1_SetConfig
00004a  e003              B        |L59.84|
                  |L59.76|
00004c  6820              LDR      r0,[r4,#0]            ;3548
00004e  4669              MOV      r1,sp                 ;3548
000050  f7fffffe          BL       TIM_OC2_SetConfig
                  |L59.84|
000054  0030              MOVS     r0,r6                 ;3554
000056  4e1f              LDR      r6,|L59.212|
000058  d002              BEQ      |L59.96|
00005a  2804              CMP      r0,#4                 ;3554
00005c  d133              BNE      |L59.198|
00005e  e014              B        |L59.138|
                  |L59.96|
000060  3518              ADDS     r5,r5,#0x18           ;3554
000062  6820              LDR      r0,[r4,#0]            ;3560
000064  e895000e          LDM      r5,{r1-r3}            ;3554
000068  f7fffffe          BL       TIM_TI1_SetConfig
00006c  6820              LDR      r0,[r4,#0]            ;3564
00006e  6981              LDR      r1,[r0,#0x18]         ;3564
000070  f021010c          BIC      r1,r1,#0xc            ;3564
000074  6181              STR      r1,[r0,#0x18]         ;3564
000076  6820              LDR      r0,[r4,#0]            ;3567
000078  6881              LDR      r1,[r0,#8]            ;3567
00007a  f0210170          BIC      r1,r1,#0x70           ;3567
00007e  6081              STR      r1,[r0,#8]            ;3567
000080  6820              LDR      r0,[r4,#0]            ;3568
000082  6881              LDR      r1,[r0,#8]            ;3568
000084  f0410150          ORR      r1,r1,#0x50           ;3568
000088  e013              B        |L59.178|
                  |L59.138|
00008a  3518              ADDS     r5,r5,#0x18           ;3574
00008c  6820              LDR      r0,[r4,#0]            ;3579
00008e  e895000e          LDM      r5,{r1-r3}            ;3574
000092  f7fffffe          BL       TIM_TI2_SetConfig
000096  6820              LDR      r0,[r4,#0]            ;3583
000098  6981              LDR      r1,[r0,#0x18]         ;3583
00009a  f4216140          BIC      r1,r1,#0xc00          ;3583
00009e  6181              STR      r1,[r0,#0x18]         ;3583
0000a0  6820              LDR      r0,[r4,#0]            ;3586
0000a2  6881              LDR      r1,[r0,#8]            ;3586
0000a4  f0210170          BIC      r1,r1,#0x70           ;3586
0000a8  6081              STR      r1,[r0,#8]            ;3586
0000aa  6820              LDR      r0,[r4,#0]            ;3587
0000ac  6881              LDR      r1,[r0,#8]            ;3587
0000ae  f0410160          ORR      r1,r1,#0x60           ;3587
                  |L59.178|
0000b2  6081              STR      r1,[r0,#8]            ;3568
0000b4  6820              LDR      r0,[r4,#0]            ;3571
0000b6  6881              LDR      r1,[r0,#8]            ;3571
0000b8  4031              ANDS     r1,r1,r6              ;3571
0000ba  6081              STR      r1,[r0,#8]            ;3571
0000bc  6820              LDR      r0,[r4,#0]            ;3572
0000be  6881              LDR      r1,[r0,#8]            ;3572
0000c0  f0410106          ORR      r1,r1,#6              ;3572
0000c4  6081              STR      r1,[r0,#8]            ;3572
                  |L59.198|
0000c6  2000              MOVS     r0,#0                 ;3601
0000c8  6427              STR      r7,[r4,#0x40]         ;3599
0000ca  63e0              STR      r0,[r4,#0x3c]         ;3603
0000cc  e7b7              B        |L59.62|
                  |L59.206|
0000ce  2001              MOVS     r0,#1                 ;3607
0000d0  e7b5              B        |L59.62|
;;;3610   
                          ENDP

0000d2  0000              DCW      0x0000
                  |L59.212|
                          DCD      0xfffefff8

                          AREA ||i.HAL_TIM_OnePulse_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_DeInit PROC
;;;2207     */
;;;2208   HAL_StatusTypeDef HAL_TIM_OnePulse_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;2209   {
000002  4604              MOV      r4,r0
;;;2210     /* Check the parameters */
;;;2211     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;2212     
;;;2213     htim->State = HAL_TIM_STATE_BUSY;
;;;2214     
;;;2215     /* Disable the TIM Peripheral Clock */
;;;2216     __HAL_TIM_DISABLE(htim);
000004  f2411211          MOV      r2,#0x1111
000008  2002              MOVS     r0,#2                 ;2213
00000a  6420              STR      r0,[r4,#0x40]         ;2213
00000c  6820              LDR      r0,[r4,#0]
00000e  6a01              LDR      r1,[r0,#0x20]
000010  4211              TST      r1,r2
000012  d107              BNE      |L60.36|
000014  6a01              LDR      r1,[r0,#0x20]
000016  1092              ASRS     r2,r2,#2
000018  4211              TST      r1,r2
00001a  d103              BNE      |L60.36|
00001c  6801              LDR      r1,[r0,#0]
00001e  f0210101          BIC      r1,r1,#1
000022  6001              STR      r1,[r0,#0]
                  |L60.36|
;;;2217   
;;;2218   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;2219     if(htim->OnePulse_MspDeInitCallback == NULL)
;;;2220     {
;;;2221       htim->OnePulse_MspDeInitCallback = HAL_TIM_OnePulse_MspDeInit;
;;;2222     }
;;;2223     /* DeInit the low level hardware */
;;;2224     htim->OnePulse_MspDeInitCallback(htim);
;;;2225   #else
;;;2226     /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;2227     HAL_TIM_OnePulse_MspDeInit(htim);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       HAL_TIM_OnePulse_MspDeInit
;;;2228   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;2229   
;;;2230     /* Change TIM state */  
;;;2231     htim->State = HAL_TIM_STATE_RESET;
00002a  2000              MOVS     r0,#0
00002c  6420              STR      r0,[r4,#0x40]
;;;2232   
;;;2233     /* Release Lock */
;;;2234     __HAL_UNLOCK(htim);
00002e  63e0              STR      r0,[r4,#0x3c]
;;;2235   
;;;2236     return HAL_OK;
;;;2237   }
000030  bd10              POP      {r4,pc}
;;;2238   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_GetState PROC
;;;5278     */
;;;5279   HAL_TIM_StateTypeDef HAL_TIM_OnePulse_GetState(TIM_HandleTypeDef *htim)
000000  6c00              LDR      r0,[r0,#0x40]
;;;5280   {
;;;5281     return htim->State;
;;;5282   }
000002  4770              BX       lr
;;;5283   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_Init PROC
;;;2147     */
;;;2148   HAL_StatusTypeDef HAL_TIM_OnePulse_Init(TIM_HandleTypeDef *htim, uint32_t OnePulseMode)
000000  b570              PUSH     {r4-r6,lr}
;;;2149   {
000002  0004              MOVS     r4,r0
000004  460d              MOV      r5,r1
000006  d002              BEQ      |L62.14|
;;;2150     /* Check the TIM handle allocation */
;;;2151     if(htim == NULL)
;;;2152     {
;;;2153       return HAL_ERROR;
;;;2154     }
;;;2155   
;;;2156     /* Check the parameters */
;;;2157     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;2158     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;2159     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;2160     assert_param(IS_TIM_OPM_MODE(OnePulseMode));
;;;2161     assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;2162   
;;;2163     if(htim->State == HAL_TIM_STATE_RESET)
000008  6c20              LDR      r0,[r4,#0x40]
00000a  b110              CBZ      r0,|L62.18|
00000c  e006              B        |L62.28|
                  |L62.14|
00000e  2001              MOVS     r0,#1                 ;2153
;;;2164     {
;;;2165       /* Allocate lock resource and initialize it */
;;;2166       htim->Lock = HAL_UNLOCKED;
;;;2167   
;;;2168   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;2169       /* Reset interrupt callbacks to legacy week callbacks */
;;;2170       TIM_ResetCallback(htim);
;;;2171   
;;;2172       if(htim->OnePulse_MspDeInitCallback == NULL)
;;;2173       {
;;;2174         htim->OnePulse_MspDeInitCallback = HAL_TIM_OnePulse_MspInit;
;;;2175       }
;;;2176       /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;2177       htim->OnePulse_MspDeInitCallback(htim);
;;;2178   #else
;;;2179       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;2180       HAL_TIM_OnePulse_MspInit(htim);
;;;2181   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;2182     }
;;;2183   
;;;2184     /* Set the TIM state */
;;;2185     htim->State= HAL_TIM_STATE_BUSY;  
;;;2186     
;;;2187     /* Configure the Time base in the One Pulse Mode */
;;;2188     TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;2189     
;;;2190     /* Reset the OPM Bit */
;;;2191     htim->Instance->CR1 &= ~TIM_CR1_OPM;
;;;2192   
;;;2193     /* Configure the OPM Mode */
;;;2194     htim->Instance->CR1 |= OnePulseMode;
;;;2195      
;;;2196     /* Initialize the TIM state*/
;;;2197     htim->State= HAL_TIM_STATE_READY;
;;;2198     
;;;2199     return HAL_OK;
;;;2200   }
000010  bd70              POP      {r4-r6,pc}
                  |L62.18|
000012  2000              MOVS     r0,#0                 ;2166
000014  63e0              STR      r0,[r4,#0x3c]         ;2180
000016  4620              MOV      r0,r4                 ;2180
000018  f7fffffe          BL       HAL_TIM_OnePulse_MspInit
                  |L62.28|
00001c  2002              MOVS     r0,#2                 ;2185
00001e  6420              STR      r0,[r4,#0x40]         ;2185
000020  6820              LDR      r0,[r4,#0]            ;2188
000022  1d21              ADDS     r1,r4,#4              ;2188
000024  f7fffffe          BL       TIM_Base_SetConfig
000028  6820              LDR      r0,[r4,#0]            ;2191
00002a  2201              MOVS     r2,#1                 ;2197
00002c  6801              LDR      r1,[r0,#0]            ;2191
00002e  f0210108          BIC      r1,r1,#8              ;2191
000032  6001              STR      r1,[r0,#0]            ;2191
000034  6820              LDR      r0,[r4,#0]            ;2194
000036  6801              LDR      r1,[r0,#0]            ;2194
000038  4329              ORRS     r1,r1,r5              ;2194
00003a  6001              STR      r1,[r0,#0]            ;2194
00003c  6422              STR      r2,[r4,#0x40]         ;2197
00003e  2000              MOVS     r0,#0                 ;2199
000040  bd70              POP      {r4-r6,pc}
;;;2201   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_MspDeInit PROC
;;;2260     */
;;;2261   __weak void HAL_TIM_OnePulse_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2262   {
;;;2263     /* Prevent unused argument(s) compilation warning */
;;;2264     UNUSED(htim);
;;;2265    
;;;2266     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2267               the HAL_TIM_OnePulse_MspDeInit could be implemented in the user file
;;;2268      */
;;;2269   }
;;;2270   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_MspInit PROC
;;;2244     */
;;;2245   __weak void HAL_TIM_OnePulse_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2246   {
;;;2247     /* Prevent unused argument(s) compilation warning */
;;;2248     UNUSED(htim);
;;;2249    
;;;2250     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2251               the HAL_TIM_OnePulse_MspInit could be implemented in the user file
;;;2252      */
;;;2253   }
;;;2254   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Start PROC
;;;2280     */
;;;2281   HAL_StatusTypeDef HAL_TIM_OnePulse_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b510              PUSH     {r4,lr}
;;;2282   {
;;;2283     /* Prevent unused argument(s) compilation warning */
;;;2284     UNUSED(OutputChannel);
;;;2285   
;;;2286     /* Enable the Capture compare and the Input Capture channels 
;;;2287       (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2288       if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2289       if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2290       in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
;;;2291       
;;;2292       No need to enable the counter, it's enabled automatically by hardware 
;;;2293       (the counter starts in response to a stimulus and generate a pulse */
;;;2294     
;;;2295     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE); 
000002  2201              MOVS     r2,#1
000004  4604              MOV      r4,r0                 ;2282
000006  6800              LDR      r0,[r0,#0]
000008  2100              MOVS     r1,#0
00000a  f7fffffe          BL       TIM_CCxChannelCmd
;;;2296     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
00000e  6820              LDR      r0,[r4,#0]
000010  2201              MOVS     r2,#1
000012  2104              MOVS     r1,#4
000014  f7fffffe          BL       TIM_CCxChannelCmd
;;;2297     
;;;2298     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000018  4906              LDR      r1,|L65.52|
00001a  6820              LDR      r0,[r4,#0]
00001c  4288              CMP      r0,r1
00001e  d002              BEQ      |L65.38|
000020  4905              LDR      r1,|L65.56|
000022  4288              CMP      r0,r1
000024  d103              BNE      |L65.46|
                  |L65.38|
;;;2299     {
;;;2300       /* Enable the main output */
;;;2301       __HAL_TIM_MOE_ENABLE(htim);
000026  6c41              LDR      r1,[r0,#0x44]
000028  f4414100          ORR      r1,r1,#0x8000
00002c  6441              STR      r1,[r0,#0x44]
                  |L65.46|
;;;2302     }
;;;2303     
;;;2304     /* Return function status */
;;;2305     return HAL_OK;
00002e  2000              MOVS     r0,#0
;;;2306   }
000030  bd10              POP      {r4,pc}
;;;2307   
                          ENDP

000032  0000              DCW      0x0000
                  |L65.52|
                          DCD      0x40010000
                  |L65.56|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OnePulse_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Start_IT PROC
;;;2354     */
;;;2355   HAL_StatusTypeDef HAL_TIM_OnePulse_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b510              PUSH     {r4,lr}
;;;2356   {
000002  4604              MOV      r4,r0
;;;2357     /* Enable the Capture compare and the Input Capture channels 
;;;2358       (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2359       if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2360       if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2361       in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
;;;2362       
;;;2363       No need to enable the counter, it's enabled automatically by hardware 
;;;2364       (the counter starts in response to a stimulus and generate a pulse */
;;;2365   
;;;2366     /* Prevent unused argument(s) compilation warning */
;;;2367     UNUSED(OutputChannel);
;;;2368   
;;;2369     /* Enable the TIM Capture/Compare 1 interrupt */
;;;2370     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000004  6800              LDR      r0,[r0,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f0410102          ORR      r1,r1,#2
00000c  60c1              STR      r1,[r0,#0xc]
;;;2371     
;;;2372     /* Enable the TIM Capture/Compare 2 interrupt */
;;;2373     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
00000e  6820              LDR      r0,[r4,#0]
000010  68c1              LDR      r1,[r0,#0xc]
000012  f0410104          ORR      r1,r1,#4
000016  60c1              STR      r1,[r0,#0xc]
;;;2374     
;;;2375     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE); 
000018  6820              LDR      r0,[r4,#0]
00001a  2201              MOVS     r2,#1
00001c  2100              MOVS     r1,#0
00001e  f7fffffe          BL       TIM_CCxChannelCmd
;;;2376     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
000022  6820              LDR      r0,[r4,#0]
000024  2201              MOVS     r2,#1
000026  2104              MOVS     r1,#4
000028  f7fffffe          BL       TIM_CCxChannelCmd
;;;2377     
;;;2378     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00002c  4906              LDR      r1,|L66.72|
00002e  6820              LDR      r0,[r4,#0]
000030  4288              CMP      r0,r1
000032  d002              BEQ      |L66.58|
000034  4905              LDR      r1,|L66.76|
000036  4288              CMP      r0,r1
000038  d103              BNE      |L66.66|
                  |L66.58|
;;;2379     {
;;;2380       /* Enable the main output */
;;;2381       __HAL_TIM_MOE_ENABLE(htim);
00003a  6c41              LDR      r1,[r0,#0x44]
00003c  f4414100          ORR      r1,r1,#0x8000
000040  6441              STR      r1,[r0,#0x44]
                  |L66.66|
;;;2382     }
;;;2383     
;;;2384     /* Return function status */
;;;2385     return HAL_OK;
000042  2000              MOVS     r0,#0
;;;2386   }
000044  bd10              POP      {r4,pc}
;;;2387   
                          ENDP

000046  0000              DCW      0x0000
                  |L66.72|
                          DCD      0x40010000
                  |L66.76|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OnePulse_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Stop PROC
;;;2317     */
;;;2318   HAL_StatusTypeDef HAL_TIM_OnePulse_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  2200              MOVS     r2,#0
;;;2319   {
000002  b510              PUSH     {r4,lr}
000004  4604              MOV      r4,r0
;;;2320     /* Prevent unused argument(s) compilation warning */
;;;2321     UNUSED(OutputChannel);
;;;2322   
;;;2323     /* Disable the Capture compare and the Input Capture channels 
;;;2324     (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2325     if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2326     if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2327     in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
;;;2328     
;;;2329     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
000006  6800              LDR      r0,[r0,#0]
000008  4611              MOV      r1,r2
00000a  f7fffffe          BL       TIM_CCxChannelCmd
;;;2330     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
00000e  6820              LDR      r0,[r4,#0]
000010  2200              MOVS     r2,#0
000012  2104              MOVS     r1,#4
000014  f7fffffe          BL       TIM_CCxChannelCmd
;;;2331       
;;;2332     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
;;;2333     {
;;;2334       /* Disable the Main Output */
;;;2335       __HAL_TIM_MOE_DISABLE(htim);
000018  f2411211          MOV      r2,#0x1111
00001c  480f              LDR      r0,|L67.92|
00001e  6821              LDR      r1,[r4,#0]            ;2332
000020  1093              ASRS     r3,r2,#2
000022  4281              CMP      r1,r0                 ;2332
000024  d002              BEQ      |L67.44|
000026  480e              LDR      r0,|L67.96|
000028  4281              CMP      r1,r0                 ;2332
00002a  d109              BNE      |L67.64|
                  |L67.44|
00002c  6a08              LDR      r0,[r1,#0x20]
00002e  4210              TST      r0,r2
000030  d106              BNE      |L67.64|
000032  6a08              LDR      r0,[r1,#0x20]
000034  4218              TST      r0,r3
000036  d103              BNE      |L67.64|
000038  6c48              LDR      r0,[r1,#0x44]
00003a  f4204000          BIC      r0,r0,#0x8000
00003e  6448              STR      r0,[r1,#0x44]
                  |L67.64|
;;;2336     }
;;;2337       
;;;2338     /* Disable the Peripheral */
;;;2339     __HAL_TIM_DISABLE(htim); 
000040  6820              LDR      r0,[r4,#0]
000042  6a01              LDR      r1,[r0,#0x20]
000044  4211              TST      r1,r2
000046  d106              BNE      |L67.86|
000048  6a01              LDR      r1,[r0,#0x20]
00004a  4219              TST      r1,r3
00004c  d103              BNE      |L67.86|
00004e  6801              LDR      r1,[r0,#0]
000050  f0210101          BIC      r1,r1,#1
000054  6001              STR      r1,[r0,#0]
                  |L67.86|
;;;2340     
;;;2341     /* Return function status */
;;;2342     return HAL_OK;
000056  2000              MOVS     r0,#0
;;;2343   }
000058  bd10              POP      {r4,pc}
;;;2344   
                          ENDP

00005a  0000              DCW      0x0000
                  |L67.92|
                          DCD      0x40010000
                  |L67.96|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OnePulse_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Stop_IT PROC
;;;2397     */
;;;2398   HAL_StatusTypeDef HAL_TIM_OnePulse_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b510              PUSH     {r4,lr}
;;;2399   {
000002  4604              MOV      r4,r0
;;;2400     /* Prevent unused argument(s) compilation warning */
;;;2401     UNUSED(OutputChannel);
;;;2402     
;;;2403     /* Disable the TIM Capture/Compare 1 interrupt */
;;;2404     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);  
000004  6800              LDR      r0,[r0,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f0210102          BIC      r1,r1,#2
00000c  60c1              STR      r1,[r0,#0xc]
;;;2405     
;;;2406     /* Disable the TIM Capture/Compare 2 interrupt */
;;;2407     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00000e  6820              LDR      r0,[r4,#0]
000010  68c1              LDR      r1,[r0,#0xc]
000012  f0210104          BIC      r1,r1,#4
000016  60c1              STR      r1,[r0,#0xc]
;;;2408     
;;;2409     /* Disable the Capture compare and the Input Capture channels 
;;;2410     (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2411     if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2412     if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2413     in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */  
;;;2414     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
000018  2200              MOVS     r2,#0
00001a  6820              LDR      r0,[r4,#0]
00001c  4611              MOV      r1,r2
00001e  f7fffffe          BL       TIM_CCxChannelCmd
;;;2415     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
000022  6820              LDR      r0,[r4,#0]
000024  2200              MOVS     r2,#0
000026  2104              MOVS     r1,#4
000028  f7fffffe          BL       TIM_CCxChannelCmd
;;;2416       
;;;2417     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
;;;2418     {
;;;2419       /* Disable the Main Output */
;;;2420       __HAL_TIM_MOE_DISABLE(htim);
00002c  f2411111          MOV      r1,#0x1111
000030  4b0f              LDR      r3,|L68.112|
000032  6820              LDR      r0,[r4,#0]            ;2417
000034  108a              ASRS     r2,r1,#2
000036  4298              CMP      r0,r3                 ;2417
000038  d002              BEQ      |L68.64|
00003a  4b0e              LDR      r3,|L68.116|
00003c  4298              CMP      r0,r3                 ;2417
00003e  d109              BNE      |L68.84|
                  |L68.64|
000040  6a03              LDR      r3,[r0,#0x20]
000042  420b              TST      r3,r1
000044  d106              BNE      |L68.84|
000046  6a03              LDR      r3,[r0,#0x20]
000048  4213              TST      r3,r2
00004a  d103              BNE      |L68.84|
00004c  6c43              LDR      r3,[r0,#0x44]
00004e  f4234300          BIC      r3,r3,#0x8000
000052  6443              STR      r3,[r0,#0x44]
                  |L68.84|
;;;2421     }
;;;2422       
;;;2423     /* Disable the Peripheral */
;;;2424      __HAL_TIM_DISABLE(htim);  
000054  6820              LDR      r0,[r4,#0]
000056  6a03              LDR      r3,[r0,#0x20]
000058  420b              TST      r3,r1
00005a  d106              BNE      |L68.106|
00005c  6a01              LDR      r1,[r0,#0x20]
00005e  4211              TST      r1,r2
000060  d103              BNE      |L68.106|
000062  6801              LDR      r1,[r0,#0]
000064  f0210101          BIC      r1,r1,#1
000068  6001              STR      r1,[r0,#0]
                  |L68.106|
;;;2425     
;;;2426     /* Return function status */
;;;2427     return HAL_OK;
00006a  2000              MOVS     r0,#0
;;;2428   }
00006c  bd10              POP      {r4,pc}
;;;2429   
                          ENDP

00006e  0000              DCW      0x0000
                  |L68.112|
                          DCD      0x40010000
                  |L68.116|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_PWM_ConfigChannel||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_ConfigChannel PROC
;;;3411     */
;;;3412   __weak HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;3413   {
000002  4604              MOV      r4,r0
;;;3414     __HAL_LOCK(htim);
000004  6bc0              LDR      r0,[r0,#0x3c]
000006  460d              MOV      r5,r1                 ;3413
000008  2801              CMP      r0,#1
00000a  d00b              BEQ      |L69.36|
00000c  2601              MOVS     r6,#1
;;;3415     
;;;3416     /* Check the parameters */ 
;;;3417     assert_param(IS_TIM_CHANNELS(Channel)); 
;;;3418     assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
;;;3419     assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
;;;3420     assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode)); 
;;;3421     
;;;3422     htim->State = HAL_TIM_STATE_BUSY;
00000e  2002              MOVS     r0,#2
000010  e9c4600f          STRD     r6,r0,[r4,#0x3c]
000014  b142              CBZ      r2,|L69.40|
;;;3423       
;;;3424     switch (Channel)
000016  2a04              CMP      r2,#4
000018  d018              BEQ      |L69.76|
00001a  2a08              CMP      r2,#8
00001c  d02a              BEQ      |L69.116|
00001e  2a0c              CMP      r2,#0xc
000020  d14d              BNE      |L69.190|
000022  e039              B        |L69.152|
                  |L69.36|
000024  2002              MOVS     r0,#2                 ;3414
;;;3425     {
;;;3426       case TIM_CHANNEL_1:
;;;3427       {
;;;3428         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3429         /* Configure the Channel 1 in PWM mode */
;;;3430         TIM_OC1_SetConfig(htim->Instance, sConfig);
;;;3431         
;;;3432         /* Set the Preload enable bit for channel1 */
;;;3433         htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
;;;3434         
;;;3435         /* Configure the Output Fast mode */
;;;3436         htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
;;;3437         htim->Instance->CCMR1 |= sConfig->OCFastMode;
;;;3438       }
;;;3439       break;
;;;3440       
;;;3441       case TIM_CHANNEL_2:
;;;3442       {
;;;3443         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3444         /* Configure the Channel 2 in PWM mode */
;;;3445         TIM_OC2_SetConfig(htim->Instance, sConfig);
;;;3446         
;;;3447         /* Set the Preload enable bit for channel2 */
;;;3448         htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
;;;3449         
;;;3450         /* Configure the Output Fast mode */
;;;3451         htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
;;;3452         htim->Instance->CCMR1 |= sConfig->OCFastMode << 8;
;;;3453       }
;;;3454       break;
;;;3455       
;;;3456       case TIM_CHANNEL_3:
;;;3457       {
;;;3458         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3459         /* Configure the Channel 3 in PWM mode */
;;;3460         TIM_OC3_SetConfig(htim->Instance, sConfig);
;;;3461         
;;;3462         /* Set the Preload enable bit for channel3 */
;;;3463         htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
;;;3464         
;;;3465        /* Configure the Output Fast mode */
;;;3466         htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
;;;3467         htim->Instance->CCMR2 |= sConfig->OCFastMode;  
;;;3468       }
;;;3469       break;
;;;3470       
;;;3471       case TIM_CHANNEL_4:
;;;3472       {
;;;3473         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3474         /* Configure the Channel 4 in PWM mode */
;;;3475         TIM_OC4_SetConfig(htim->Instance, sConfig);
;;;3476         
;;;3477         /* Set the Preload enable bit for channel4 */
;;;3478         htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
;;;3479         
;;;3480        /* Configure the Output Fast mode */
;;;3481         htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
;;;3482         htim->Instance->CCMR2 |= sConfig->OCFastMode << 8;  
;;;3483       }
;;;3484       break;
;;;3485       
;;;3486       default:
;;;3487       break;    
;;;3488     }
;;;3489     
;;;3490     htim->State = HAL_TIM_STATE_READY;
;;;3491       
;;;3492     __HAL_UNLOCK(htim);
;;;3493     
;;;3494     return HAL_OK;
;;;3495   }
000026  bd70              POP      {r4-r6,pc}
                  |L69.40|
000028  6820              LDR      r0,[r4,#0]            ;3430
00002a  f7fffffe          BL       TIM_OC1_SetConfig
00002e  6820              LDR      r0,[r4,#0]            ;3433
000030  6981              LDR      r1,[r0,#0x18]         ;3433
000032  f0410108          ORR      r1,r1,#8              ;3433
000036  6181              STR      r1,[r0,#0x18]         ;3433
000038  6820              LDR      r0,[r4,#0]            ;3436
00003a  6981              LDR      r1,[r0,#0x18]         ;3436
00003c  f0210104          BIC      r1,r1,#4              ;3436
000040  6181              STR      r1,[r0,#0x18]         ;3436
000042  6820              LDR      r0,[r4,#0]            ;3437
000044  692a              LDR      r2,[r5,#0x10]         ;3437
000046  6981              LDR      r1,[r0,#0x18]         ;3437
000048  4311              ORRS     r1,r1,r2              ;3437
00004a  e011              B        |L69.112|
                  |L69.76|
00004c  6820              LDR      r0,[r4,#0]            ;3445
00004e  f7fffffe          BL       TIM_OC2_SetConfig
000052  6820              LDR      r0,[r4,#0]            ;3448
000054  6981              LDR      r1,[r0,#0x18]         ;3448
000056  f4416100          ORR      r1,r1,#0x800          ;3448
00005a  6181              STR      r1,[r0,#0x18]         ;3448
00005c  6820              LDR      r0,[r4,#0]            ;3451
00005e  6981              LDR      r1,[r0,#0x18]         ;3451
000060  f4216180          BIC      r1,r1,#0x400          ;3451
000064  6181              STR      r1,[r0,#0x18]         ;3451
000066  6820              LDR      r0,[r4,#0]            ;3452
000068  6929              LDR      r1,[r5,#0x10]         ;3452
00006a  6982              LDR      r2,[r0,#0x18]         ;3452
00006c  ea422101          ORR      r1,r2,r1,LSL #8       ;3452
                  |L69.112|
000070  6181              STR      r1,[r0,#0x18]         ;3437
000072  e024              B        |L69.190|
                  |L69.116|
000074  6820              LDR      r0,[r4,#0]            ;3460
000076  f7fffffe          BL       TIM_OC3_SetConfig
00007a  6820              LDR      r0,[r4,#0]            ;3463
00007c  69c1              LDR      r1,[r0,#0x1c]         ;3463
00007e  f0410108          ORR      r1,r1,#8              ;3463
000082  61c1              STR      r1,[r0,#0x1c]         ;3463
000084  6820              LDR      r0,[r4,#0]            ;3466
000086  69c1              LDR      r1,[r0,#0x1c]         ;3466
000088  f0210104          BIC      r1,r1,#4              ;3466
00008c  61c1              STR      r1,[r0,#0x1c]         ;3466
00008e  6820              LDR      r0,[r4,#0]            ;3467
000090  692a              LDR      r2,[r5,#0x10]         ;3467
000092  69c1              LDR      r1,[r0,#0x1c]         ;3467
000094  4311              ORRS     r1,r1,r2              ;3467
000096  e011              B        |L69.188|
                  |L69.152|
000098  6820              LDR      r0,[r4,#0]            ;3475
00009a  f7fffffe          BL       TIM_OC4_SetConfig
00009e  6820              LDR      r0,[r4,#0]            ;3478
0000a0  69c1              LDR      r1,[r0,#0x1c]         ;3478
0000a2  f4416100          ORR      r1,r1,#0x800          ;3478
0000a6  61c1              STR      r1,[r0,#0x1c]         ;3478
0000a8  6820              LDR      r0,[r4,#0]            ;3481
0000aa  69c1              LDR      r1,[r0,#0x1c]         ;3481
0000ac  f4216180          BIC      r1,r1,#0x400          ;3481
0000b0  61c1              STR      r1,[r0,#0x1c]         ;3481
0000b2  6820              LDR      r0,[r4,#0]            ;3482
0000b4  6929              LDR      r1,[r5,#0x10]         ;3482
0000b6  69c2              LDR      r2,[r0,#0x1c]         ;3482
0000b8  ea422101          ORR      r1,r2,r1,LSL #8       ;3482
                  |L69.188|
0000bc  61c1              STR      r1,[r0,#0x1c]         ;3467
                  |L69.190|
0000be  2000              MOVS     r0,#0                 ;3492
0000c0  6426              STR      r6,[r4,#0x40]         ;3490
0000c2  63e0              STR      r0,[r4,#0x3c]         ;3492
0000c4  bd70              POP      {r4-r6,pc}
;;;3496   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_DeInit PROC
;;;1152     */
;;;1153   HAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1154   {
000002  4604              MOV      r4,r0
;;;1155     /* Check the parameters */
;;;1156     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1157     
;;;1158     htim->State = HAL_TIM_STATE_BUSY;
;;;1159     
;;;1160     /* Disable the TIM Peripheral Clock */
;;;1161     __HAL_TIM_DISABLE(htim);
000004  f2411211          MOV      r2,#0x1111
000008  2002              MOVS     r0,#2                 ;1158
00000a  6420              STR      r0,[r4,#0x40]         ;1158
00000c  6820              LDR      r0,[r4,#0]
00000e  6a01              LDR      r1,[r0,#0x20]
000010  4211              TST      r1,r2
000012  d107              BNE      |L70.36|
000014  6a01              LDR      r1,[r0,#0x20]
000016  1092              ASRS     r2,r2,#2
000018  4211              TST      r1,r2
00001a  d103              BNE      |L70.36|
00001c  6801              LDR      r1,[r0,#0]
00001e  f0210101          BIC      r1,r1,#1
000022  6001              STR      r1,[r0,#0]
                  |L70.36|
;;;1162   
;;;1163   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;1164     if(htim->PWM_MspDeInitCallback == NULL)
;;;1165     {
;;;1166       htim->PWM_MspDeInitCallback = HAL_TIM_PWM_MspDeInit;
;;;1167     }
;;;1168     /* DeInit the low level hardware */
;;;1169     htim->PWM_MspDeInitCallback(htim);
;;;1170   #else
;;;1171     /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;1172     HAL_TIM_PWM_MspDeInit(htim);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       HAL_TIM_PWM_MspDeInit
;;;1173   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;1174   
;;;1175     /* Change TIM state */  
;;;1176     htim->State = HAL_TIM_STATE_RESET; 
00002a  2000              MOVS     r0,#0
00002c  6420              STR      r0,[r4,#0x40]
;;;1177   
;;;1178     /* Release Lock */
;;;1179     __HAL_UNLOCK(htim);
00002e  63e0              STR      r0,[r4,#0x3c]
;;;1180   
;;;1181     return HAL_OK;
;;;1182   }
000030  bd10              POP      {r4,pc}
;;;1183   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_GetState PROC
;;;5256     */
;;;5257   HAL_TIM_StateTypeDef HAL_TIM_PWM_GetState(TIM_HandleTypeDef *htim)
000000  6c00              LDR      r0,[r0,#0x40]
;;;5258   {
;;;5259     return htim->State;
;;;5260   }
000002  4770              BX       lr
;;;5261   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_Init PROC
;;;1100     */
;;;1101   HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1102   {
000002  0004              MOVS     r4,r0
000004  d002              BEQ      |L72.12|
;;;1103     /* Check the TIM handle allocation */
;;;1104     if(htim == NULL)
;;;1105     {
;;;1106       return HAL_ERROR;
;;;1107     }
;;;1108   
;;;1109     /* Check the parameters */
;;;1110     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1111     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;1112     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;1113     assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;1114   
;;;1115     if(htim->State == HAL_TIM_STATE_RESET)
000006  6c20              LDR      r0,[r4,#0x40]
000008  b110              CBZ      r0,|L72.16|
00000a  e006              B        |L72.26|
                  |L72.12|
00000c  2001              MOVS     r0,#1                 ;1106
;;;1116     {
;;;1117       /* Allocate lock resource and initialize it */
;;;1118       htim->Lock = HAL_UNLOCKED;
;;;1119   
;;;1120   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;1121       /* Reset interrupt callbacks to legacy week callbacks */
;;;1122       TIM_ResetCallback(htim);
;;;1123   
;;;1124       if(htim->PWM_MspInitCallback == NULL)
;;;1125       {
;;;1126         htim->PWM_MspInitCallback = HAL_TIM_PWM_MspInit;
;;;1127       }
;;;1128       /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;1129       htim->PWM_MspInitCallback(htim);
;;;1130   #else
;;;1131       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;1132       HAL_TIM_PWM_MspInit(htim);
;;;1133   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;1134     }
;;;1135     /* Set the TIM state */
;;;1136     htim->State= HAL_TIM_STATE_BUSY;  
;;;1137     
;;;1138     /* Init the base time for the PWM */  
;;;1139     TIM_Base_SetConfig(htim->Instance, &htim->Init); 
;;;1140      
;;;1141     /* Initialize the TIM state*/
;;;1142     htim->State= HAL_TIM_STATE_READY;
;;;1143     
;;;1144     return HAL_OK;
;;;1145   }  
00000e  bd10              POP      {r4,pc}
                  |L72.16|
000010  2000              MOVS     r0,#0                 ;1118
000012  63e0              STR      r0,[r4,#0x3c]         ;1132
000014  4620              MOV      r0,r4                 ;1132
000016  f7fffffe          BL       HAL_TIM_PWM_MspInit
                  |L72.26|
00001a  2002              MOVS     r0,#2                 ;1136
00001c  6420              STR      r0,[r4,#0x40]         ;1136
00001e  6820              LDR      r0,[r4,#0]            ;1139
000020  1d21              ADDS     r1,r4,#4              ;1139
000022  f7fffffe          BL       TIM_Base_SetConfig
000026  2001              MOVS     r0,#1                 ;1142
000028  6420              STR      r0,[r4,#0x40]         ;1142
00002a  2000              MOVS     r0,#0                 ;1144
00002c  bd10              POP      {r4,pc}
;;;1146   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_MspDeInit PROC
;;;1205     */
;;;1206   __weak void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1207   {
;;;1208     /* Prevent unused argument(s) compilation warning */
;;;1209     UNUSED(htim);
;;;1210    
;;;1211     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1212               the HAL_TIM_PWM_MspDeInit could be implemented in the user file
;;;1213      */
;;;1214   }
;;;1215   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_MspInit PROC
;;;1189     */
;;;1190   __weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1191   {
;;;1192     /* Prevent unused argument(s) compilation warning */
;;;1193     UNUSED(htim);
;;;1194    
;;;1195     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1196               the HAL_TIM_PWM_MspInit could be implemented in the user file
;;;1197      */
;;;1198   }
;;;1199   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_PulseFinishedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_PulseFinishedCallback PROC
;;;4735     */
;;;4736   __weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4737   {
;;;4738     /* Prevent unused argument(s) compilation warning */
;;;4739     UNUSED(htim);
;;;4740    
;;;4741     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4742               the __HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
;;;4743      */
;;;4744   }
;;;4745   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Start PROC
;;;1227     */
;;;1228   HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1229   {
;;;1230     /* Check the parameters */
;;;1231     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1232   
;;;1233     /* Enable the Capture compare channel */
;;;1234     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000002  2201              MOVS     r2,#1
000004  4604              MOV      r4,r0                 ;1229
000006  6800              LDR      r0,[r0,#0]
000008  f7fffffe          BL       TIM_CCxChannelCmd
;;;1235     
;;;1236     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00000c  4908              LDR      r1,|L76.48|
00000e  6820              LDR      r0,[r4,#0]
000010  4288              CMP      r0,r1
000012  d002              BEQ      |L76.26|
000014  4907              LDR      r1,|L76.52|
000016  4288              CMP      r0,r1
000018  d103              BNE      |L76.34|
                  |L76.26|
;;;1237     {
;;;1238       /* Enable the main output */
;;;1239       __HAL_TIM_MOE_ENABLE(htim);
00001a  6c41              LDR      r1,[r0,#0x44]
00001c  f4414100          ORR      r1,r1,#0x8000
000020  6441              STR      r1,[r0,#0x44]
                  |L76.34|
;;;1240     }
;;;1241       
;;;1242     /* Enable the Peripheral */
;;;1243     __HAL_TIM_ENABLE(htim);
000022  6820              LDR      r0,[r4,#0]
000024  6801              LDR      r1,[r0,#0]
000026  f0410101          ORR      r1,r1,#1
00002a  6001              STR      r1,[r0,#0]
;;;1244     
;;;1245     /* Return function status */
;;;1246     return HAL_OK;
00002c  2000              MOVS     r0,#0
;;;1247   } 
00002e  bd10              POP      {r4,pc}
;;;1248   
                          ENDP

                  |L76.48|
                          DCD      0x40010000
                  |L76.52|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_PWM_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Start_DMA PROC
;;;1432     */
;;;1433   HAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;1434   {
000002  4604              MOV      r4,r0
;;;1435     /* Check the parameters */
;;;1436     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1437     
;;;1438     if((htim->State == HAL_TIM_STATE_BUSY))
000004  6c00              LDR      r0,[r0,#0x40]
000006  4616              MOV      r6,r2                 ;1434
000008  460d              MOV      r5,r1                 ;1434
00000a  2802              CMP      r0,#2
00000c  d004              BEQ      |L77.24|
;;;1439     {
;;;1440        return HAL_BUSY;
;;;1441     }
;;;1442     else if((htim->State == HAL_TIM_STATE_READY))
00000e  6c20              LDR      r0,[r4,#0x40]
000010  2801              CMP      r0,#1
000012  d104              BNE      |L77.30|
;;;1443     {
;;;1444       if(((uint32_t)pData == 0 ) && (Length > 0)) 
000014  b90e              CBNZ     r6,|L77.26|
000016  b103              CBZ      r3,|L77.26|
                  |L77.24|
;;;1445       {
;;;1446         return HAL_ERROR;                                    
;;;1447       }
;;;1448       else
;;;1449       {
;;;1450         htim->State = HAL_TIM_STATE_BUSY;
;;;1451       }
;;;1452     }    
;;;1453     switch (Channel)
;;;1454     {
;;;1455       case TIM_CHANNEL_1:
;;;1456       {      
;;;1457         /* Set the DMA Period elapsed callback */
;;;1458         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;1459        
;;;1460         /* Set the DMA error callback */
;;;1461         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
;;;1462         
;;;1463         /* Enable the DMA Stream */
;;;1464         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
;;;1465         
;;;1466         /* Enable the TIM Capture/Compare 1 DMA request */
;;;1467         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;1468       }
;;;1469       break;
;;;1470       
;;;1471       case TIM_CHANNEL_2:
;;;1472       {
;;;1473         /* Set the DMA Period elapsed callback */
;;;1474         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;1475        
;;;1476         /* Set the DMA error callback */
;;;1477         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
;;;1478         
;;;1479         /* Enable the DMA Stream */
;;;1480         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
;;;1481         
;;;1482         /* Enable the TIM Capture/Compare 2 DMA request */
;;;1483         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;1484       }
;;;1485       break;
;;;1486       
;;;1487       case TIM_CHANNEL_3:
;;;1488       {
;;;1489         /* Set the DMA Period elapsed callback */
;;;1490         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;1491        
;;;1492         /* Set the DMA error callback */
;;;1493         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
;;;1494         
;;;1495         /* Enable the DMA Stream */
;;;1496         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
;;;1497         
;;;1498         /* Enable the TIM Output Capture/Compare 3 request */
;;;1499         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;1500       }
;;;1501       break;
;;;1502       
;;;1503       case TIM_CHANNEL_4:
;;;1504       {
;;;1505        /* Set the DMA Period elapsed callback */
;;;1506         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;1507        
;;;1508         /* Set the DMA error callback */
;;;1509         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
;;;1510         
;;;1511         /* Enable the DMA Stream */
;;;1512         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
;;;1513         
;;;1514         /* Enable the TIM Capture/Compare 4 DMA request */
;;;1515         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;1516       }
;;;1517       break;
;;;1518       
;;;1519       default:
;;;1520       break;
;;;1521     }
;;;1522   
;;;1523     /* Enable the Capture compare channel */
;;;1524     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1525       
;;;1526     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
;;;1527     {
;;;1528       /* Enable the main output */
;;;1529       __HAL_TIM_MOE_ENABLE(htim);
;;;1530     }
;;;1531     
;;;1532     /* Enable the Peripheral */
;;;1533     __HAL_TIM_ENABLE(htim); 
;;;1534     
;;;1535     /* Return function status */
;;;1536     return HAL_OK;
;;;1537   }
000018  bd70              POP      {r4-r6,pc}
                  |L77.26|
00001a  2002              MOVS     r0,#2                 ;1450
00001c  6420              STR      r0,[r4,#0x40]         ;1450
                  |L77.30|
00001e  482e              LDR      r0,|L77.216|
000020  492e              LDR      r1,|L77.220|
000022  b135              CBZ      r5,|L77.50|
000024  2d04              CMP      r5,#4                 ;1453
000026  d013              BEQ      |L77.80|
000028  2d08              CMP      r5,#8                 ;1453
00002a  d037              BEQ      |L77.156|
00002c  2d0c              CMP      r5,#0xc               ;1453
00002e  d11e              BNE      |L77.110|
000030  e043              B        |L77.186|
                  |L77.50|
000032  6a62              LDR      r2,[r4,#0x24]         ;1458
000034  6410              STR      r0,[r2,#0x40]         ;1461
000036  6a60              LDR      r0,[r4,#0x24]         ;1461
000038  6501              STR      r1,[r0,#0x50]         ;1464
00003a  4631              MOV      r1,r6                 ;1464
00003c  6822              LDR      r2,[r4,#0]            ;1464
00003e  6a60              LDR      r0,[r4,#0x24]         ;1464
000040  3234              ADDS     r2,r2,#0x34           ;1464
000042  f7fffffe          BL       HAL_DMA_Start_IT
000046  6820              LDR      r0,[r4,#0]            ;1467
000048  68c1              LDR      r1,[r0,#0xc]          ;1467
00004a  f4417100          ORR      r1,r1,#0x200          ;1467
00004e  e00d              B        |L77.108|
                  |L77.80|
000050  6aa2              LDR      r2,[r4,#0x28]         ;1474
000052  6410              STR      r0,[r2,#0x40]         ;1477
000054  6aa0              LDR      r0,[r4,#0x28]         ;1477
000056  6501              STR      r1,[r0,#0x50]         ;1480
000058  4631              MOV      r1,r6                 ;1480
00005a  6822              LDR      r2,[r4,#0]            ;1480
00005c  6aa0              LDR      r0,[r4,#0x28]         ;1480
00005e  3238              ADDS     r2,r2,#0x38           ;1480
000060  f7fffffe          BL       HAL_DMA_Start_IT
000064  6820              LDR      r0,[r4,#0]            ;1483
000066  68c1              LDR      r1,[r0,#0xc]          ;1483
000068  f4416180          ORR      r1,r1,#0x400          ;1483
                  |L77.108|
00006c  60c1              STR      r1,[r0,#0xc]          ;1467
                  |L77.110|
00006e  6820              LDR      r0,[r4,#0]            ;1524
000070  2201              MOVS     r2,#1                 ;1524
000072  4629              MOV      r1,r5                 ;1524
000074  f7fffffe          BL       TIM_CCxChannelCmd
000078  4919              LDR      r1,|L77.224|
00007a  6820              LDR      r0,[r4,#0]            ;1526
00007c  4288              CMP      r0,r1                 ;1526
00007e  d002              BEQ      |L77.134|
000080  4918              LDR      r1,|L77.228|
000082  4288              CMP      r0,r1                 ;1526
000084  d103              BNE      |L77.142|
                  |L77.134|
000086  6c41              LDR      r1,[r0,#0x44]         ;1529
000088  f4414100          ORR      r1,r1,#0x8000         ;1529
00008c  6441              STR      r1,[r0,#0x44]         ;1529
                  |L77.142|
00008e  6820              LDR      r0,[r4,#0]            ;1533
000090  6801              LDR      r1,[r0,#0]            ;1533
000092  f0410101          ORR      r1,r1,#1              ;1533
000096  6001              STR      r1,[r0,#0]            ;1533
000098  2000              MOVS     r0,#0                 ;1536
00009a  bd70              POP      {r4-r6,pc}
                  |L77.156|
00009c  6ae2              LDR      r2,[r4,#0x2c]         ;1490
00009e  6410              STR      r0,[r2,#0x40]         ;1493
0000a0  6ae0              LDR      r0,[r4,#0x2c]         ;1493
0000a2  6501              STR      r1,[r0,#0x50]         ;1496
0000a4  4631              MOV      r1,r6                 ;1496
0000a6  6822              LDR      r2,[r4,#0]            ;1496
0000a8  6ae0              LDR      r0,[r4,#0x2c]         ;1496
0000aa  323c              ADDS     r2,r2,#0x3c           ;1496
0000ac  f7fffffe          BL       HAL_DMA_Start_IT
0000b0  6820              LDR      r0,[r4,#0]            ;1499
0000b2  68c1              LDR      r1,[r0,#0xc]          ;1499
0000b4  f4416100          ORR      r1,r1,#0x800          ;1499
0000b8  e7d8              B        |L77.108|
                  |L77.186|
0000ba  6b22              LDR      r2,[r4,#0x30]         ;1506
0000bc  6410              STR      r0,[r2,#0x40]         ;1509
0000be  6b20              LDR      r0,[r4,#0x30]         ;1509
0000c0  6501              STR      r1,[r0,#0x50]         ;1512
0000c2  4631              MOV      r1,r6                 ;1512
0000c4  6822              LDR      r2,[r4,#0]            ;1512
0000c6  6b20              LDR      r0,[r4,#0x30]         ;1512
0000c8  3240              ADDS     r2,r2,#0x40           ;1512
0000ca  f7fffffe          BL       HAL_DMA_Start_IT
0000ce  6820              LDR      r0,[r4,#0]            ;1515
0000d0  68c1              LDR      r1,[r0,#0xc]          ;1515
0000d2  f4415180          ORR      r1,r1,#0x1000         ;1515
0000d6  e7c9              B        |L77.108|
;;;1538   
                          ENDP

                  |L77.216|
                          DCD      TIM_DMADelayPulseCplt
                  |L77.220|
                          DCD      TIM_DMAError
                  |L77.224|
                          DCD      0x40010000
                  |L77.228|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_PWM_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Start_IT PROC
;;;1296     */
;;;1297   HAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1298   {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L78.22|
;;;1299     /* Check the parameters */
;;;1300     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1301     
;;;1302     switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L78.30|
00000c  2908              CMP      r1,#8
00000e  d020              BEQ      |L78.82|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L78.38|
000014  e021              B        |L78.90|
                  |L78.22|
;;;1303     {
;;;1304       case TIM_CHANNEL_1:
;;;1305       {       
;;;1306         /* Enable the TIM Capture/Compare 1 interrupt */
;;;1307         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f0400002          ORR      r0,r0,#2
;;;1308       }
;;;1309       break;
00001c  e002              B        |L78.36|
                  |L78.30|
;;;1310       
;;;1311       case TIM_CHANNEL_2:
;;;1312       {
;;;1313         /* Enable the TIM Capture/Compare 2 interrupt */
;;;1314         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f0400004          ORR      r0,r0,#4
                  |L78.36|
000024  60d0              STR      r0,[r2,#0xc]          ;1307
                  |L78.38|
;;;1315       }
;;;1316       break;
;;;1317       
;;;1318       case TIM_CHANNEL_3:
;;;1319       {
;;;1320         /* Enable the TIM Capture/Compare 3 interrupt */
;;;1321         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
;;;1322       }
;;;1323       break;
;;;1324       
;;;1325       case TIM_CHANNEL_4:
;;;1326       {
;;;1327         /* Enable the TIM Capture/Compare 4 interrupt */
;;;1328         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
;;;1329       }
;;;1330       break;
;;;1331       
;;;1332       default:
;;;1333       break;
;;;1334     } 
;;;1335     
;;;1336     /* Enable the Capture compare channel */
;;;1337     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000026  6820              LDR      r0,[r4,#0]
000028  2201              MOVS     r2,#1
00002a  f7fffffe          BL       TIM_CCxChannelCmd
;;;1338     
;;;1339     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00002e  490d              LDR      r1,|L78.100|
000030  6820              LDR      r0,[r4,#0]
000032  4288              CMP      r0,r1
000034  d002              BEQ      |L78.60|
000036  490c              LDR      r1,|L78.104|
000038  4288              CMP      r0,r1
00003a  d103              BNE      |L78.68|
                  |L78.60|
;;;1340     {
;;;1341       /* Enable the main output */
;;;1342       __HAL_TIM_MOE_ENABLE(htim);
00003c  6c41              LDR      r1,[r0,#0x44]
00003e  f4414100          ORR      r1,r1,#0x8000
000042  6441              STR      r1,[r0,#0x44]
                  |L78.68|
;;;1343     }
;;;1344   
;;;1345     /* Enable the Peripheral */
;;;1346     __HAL_TIM_ENABLE(htim);
000044  6820              LDR      r0,[r4,#0]
000046  6801              LDR      r1,[r0,#0]
000048  f0410101          ORR      r1,r1,#1
00004c  6001              STR      r1,[r0,#0]
;;;1347     
;;;1348     /* Return function status */
;;;1349     return HAL_OK;
00004e  2000              MOVS     r0,#0
;;;1350   } 
000050  bd10              POP      {r4,pc}
                  |L78.82|
000052  68d0              LDR      r0,[r2,#0xc]          ;1321
000054  f0400008          ORR      r0,r0,#8              ;1321
000058  e7e4              B        |L78.36|
                  |L78.90|
00005a  68d0              LDR      r0,[r2,#0xc]          ;1328
00005c  f0400010          ORR      r0,r0,#0x10           ;1328
000060  e7e0              B        |L78.36|
;;;1351   
                          ENDP

000062  0000              DCW      0x0000
                  |L78.100|
                          DCD      0x40010000
                  |L78.104|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_PWM_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Stop PROC
;;;1260     */
;;;1261   HAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1262   { 
;;;1263     /* Check the parameters */
;;;1264     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1265       
;;;1266     /* Disable the Capture compare channel */
;;;1267     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000002  2200              MOVS     r2,#0
000004  4604              MOV      r4,r0                 ;1262
000006  6800              LDR      r0,[r0,#0]
000008  f7fffffe          BL       TIM_CCxChannelCmd
;;;1268     
;;;1269     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
;;;1270     {
;;;1271       /* Disable the Main Output */
;;;1272       __HAL_TIM_MOE_DISABLE(htim);
00000c  f2411211          MOV      r2,#0x1111
000010  4810              LDR      r0,|L79.84|
000012  6821              LDR      r1,[r4,#0]            ;1269
000014  1093              ASRS     r3,r2,#2
000016  4281              CMP      r1,r0                 ;1269
000018  d002              BEQ      |L79.32|
00001a  480f              LDR      r0,|L79.88|
00001c  4281              CMP      r1,r0                 ;1269
00001e  d109              BNE      |L79.52|
                  |L79.32|
000020  6a08              LDR      r0,[r1,#0x20]
000022  4210              TST      r0,r2
000024  d106              BNE      |L79.52|
000026  6a08              LDR      r0,[r1,#0x20]
000028  4218              TST      r0,r3
00002a  d103              BNE      |L79.52|
00002c  6c48              LDR      r0,[r1,#0x44]
00002e  f4204000          BIC      r0,r0,#0x8000
000032  6448              STR      r0,[r1,#0x44]
                  |L79.52|
;;;1273     }
;;;1274     
;;;1275     /* Disable the Peripheral */
;;;1276     __HAL_TIM_DISABLE(htim);
000034  6820              LDR      r0,[r4,#0]
000036  6a01              LDR      r1,[r0,#0x20]
000038  4211              TST      r1,r2
00003a  d106              BNE      |L79.74|
00003c  6a01              LDR      r1,[r0,#0x20]
00003e  4219              TST      r1,r3
000040  d103              BNE      |L79.74|
000042  6801              LDR      r1,[r0,#0]
000044  f0210101          BIC      r1,r1,#1
000048  6001              STR      r1,[r0,#0]
                  |L79.74|
;;;1277     
;;;1278     /* Change the htim state */
;;;1279     htim->State = HAL_TIM_STATE_READY;
00004a  2001              MOVS     r0,#1
00004c  6420              STR      r0,[r4,#0x40]
;;;1280     
;;;1281     /* Return function status */
;;;1282     return HAL_OK;
00004e  2000              MOVS     r0,#0
;;;1283   } 
000050  bd10              POP      {r4,pc}
;;;1284   
                          ENDP

000052  0000              DCW      0x0000
                  |L79.84|
                          DCD      0x40010000
                  |L79.88|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_PWM_Stop_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Stop_DMA PROC
;;;1550     */
;;;1551   HAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1552   {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L80.22|
;;;1553     /* Check the parameters */
;;;1554     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1555     
;;;1556     switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L80.30|
00000c  2908              CMP      r1,#8
00000e  d031              BEQ      |L80.116|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L80.38|
000014  e032              B        |L80.124|
                  |L80.22|
;;;1557     {
;;;1558       case TIM_CHANNEL_1:
;;;1559       {       
;;;1560         /* Disable the TIM Capture/Compare 1 DMA request */
;;;1561         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f4207000          BIC      r0,r0,#0x200
;;;1562       }
;;;1563       break;
00001c  e002              B        |L80.36|
                  |L80.30|
;;;1564       
;;;1565       case TIM_CHANNEL_2:
;;;1566       {
;;;1567         /* Disable the TIM Capture/Compare 2 DMA request */
;;;1568         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f4206080          BIC      r0,r0,#0x400
                  |L80.36|
000024  60d0              STR      r0,[r2,#0xc]          ;1561
                  |L80.38|
;;;1569       }
;;;1570       break;
;;;1571       
;;;1572       case TIM_CHANNEL_3:
;;;1573       {
;;;1574         /* Disable the TIM Capture/Compare 3 DMA request */
;;;1575         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
;;;1576       }
;;;1577       break;
;;;1578       
;;;1579       case TIM_CHANNEL_4:
;;;1580       {
;;;1581         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1582         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
;;;1583       }
;;;1584       break;
;;;1585       
;;;1586       default:
;;;1587       break;
;;;1588     } 
;;;1589     
;;;1590     /* Disable the Capture compare channel */
;;;1591     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000026  6820              LDR      r0,[r4,#0]
000028  2200              MOVS     r2,#0
00002a  f7fffffe          BL       TIM_CCxChannelCmd
;;;1592     
;;;1593     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
;;;1594     {
;;;1595       /* Disable the Main Output */
;;;1596       __HAL_TIM_MOE_DISABLE(htim);
00002e  f2411111          MOV      r1,#0x1111
000032  4b14              LDR      r3,|L80.132|
000034  6820              LDR      r0,[r4,#0]            ;1593
000036  108a              ASRS     r2,r1,#2
000038  4298              CMP      r0,r3                 ;1593
00003a  d002              BEQ      |L80.66|
00003c  4b12              LDR      r3,|L80.136|
00003e  4298              CMP      r0,r3                 ;1593
000040  d109              BNE      |L80.86|
                  |L80.66|
000042  6a03              LDR      r3,[r0,#0x20]
000044  420b              TST      r3,r1
000046  d106              BNE      |L80.86|
000048  6a03              LDR      r3,[r0,#0x20]
00004a  4213              TST      r3,r2
00004c  d103              BNE      |L80.86|
00004e  6c43              LDR      r3,[r0,#0x44]
000050  f4234300          BIC      r3,r3,#0x8000
000054  6443              STR      r3,[r0,#0x44]
                  |L80.86|
;;;1597     }
;;;1598     
;;;1599     /* Disable the Peripheral */
;;;1600     __HAL_TIM_DISABLE(htim);
000056  6820              LDR      r0,[r4,#0]
000058  6a03              LDR      r3,[r0,#0x20]
00005a  420b              TST      r3,r1
00005c  d106              BNE      |L80.108|
00005e  6a01              LDR      r1,[r0,#0x20]
000060  4211              TST      r1,r2
000062  d103              BNE      |L80.108|
000064  6801              LDR      r1,[r0,#0]
000066  f0210101          BIC      r1,r1,#1
00006a  6001              STR      r1,[r0,#0]
                  |L80.108|
;;;1601     
;;;1602     /* Change the htim state */
;;;1603     htim->State = HAL_TIM_STATE_READY;
00006c  2001              MOVS     r0,#1
00006e  6420              STR      r0,[r4,#0x40]
;;;1604     
;;;1605     /* Return function status */
;;;1606     return HAL_OK;
000070  2000              MOVS     r0,#0
;;;1607   }
000072  bd10              POP      {r4,pc}
                  |L80.116|
000074  68d0              LDR      r0,[r2,#0xc]          ;1575
000076  f4206000          BIC      r0,r0,#0x800          ;1575
00007a  e7d3              B        |L80.36|
                  |L80.124|
00007c  68d0              LDR      r0,[r2,#0xc]          ;1582
00007e  f4205080          BIC      r0,r0,#0x1000         ;1582
000082  e7cf              B        |L80.36|
;;;1608   
                          ENDP

                  |L80.132|
                          DCD      0x40010000
                  |L80.136|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_PWM_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Stop_IT PROC
;;;1363     */
;;;1364   HAL_StatusTypeDef HAL_TIM_PWM_Stop_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1365   {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L81.22|
;;;1366     /* Check the parameters */
;;;1367     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1368     
;;;1369     switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L81.30|
00000c  2908              CMP      r1,#8
00000e  d02f              BEQ      |L81.112|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L81.38|
000014  e030              B        |L81.120|
                  |L81.22|
;;;1370     {
;;;1371       case TIM_CHANNEL_1:
;;;1372       {       
;;;1373         /* Disable the TIM Capture/Compare 1 interrupt */
;;;1374         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f0200002          BIC      r0,r0,#2
;;;1375       }
;;;1376       break;
00001c  e002              B        |L81.36|
                  |L81.30|
;;;1377       
;;;1378       case TIM_CHANNEL_2:
;;;1379       {
;;;1380         /* Disable the TIM Capture/Compare 2 interrupt */
;;;1381         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f0200004          BIC      r0,r0,#4
                  |L81.36|
000024  60d0              STR      r0,[r2,#0xc]          ;1374
                  |L81.38|
;;;1382       }
;;;1383       break;
;;;1384       
;;;1385       case TIM_CHANNEL_3:
;;;1386       {
;;;1387         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1388         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
;;;1389       }
;;;1390       break;
;;;1391       
;;;1392       case TIM_CHANNEL_4:
;;;1393       {
;;;1394         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1395         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
;;;1396       }
;;;1397       break;
;;;1398       
;;;1399       default:
;;;1400       break; 
;;;1401     }
;;;1402     
;;;1403     /* Disable the Capture compare channel */
;;;1404     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000026  6820              LDR      r0,[r4,#0]
000028  2200              MOVS     r2,#0
00002a  f7fffffe          BL       TIM_CCxChannelCmd
;;;1405     
;;;1406     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
;;;1407     {
;;;1408       /* Disable the Main Output */
;;;1409       __HAL_TIM_MOE_DISABLE(htim);
00002e  f2411311          MOV      r3,#0x1111
000032  4813              LDR      r0,|L81.128|
000034  6821              LDR      r1,[r4,#0]            ;1406
000036  109a              ASRS     r2,r3,#2
000038  4281              CMP      r1,r0                 ;1406
00003a  d002              BEQ      |L81.66|
00003c  4811              LDR      r0,|L81.132|
00003e  4281              CMP      r1,r0                 ;1406
000040  d109              BNE      |L81.86|
                  |L81.66|
000042  6a08              LDR      r0,[r1,#0x20]
000044  4218              TST      r0,r3
000046  d106              BNE      |L81.86|
000048  6a08              LDR      r0,[r1,#0x20]
00004a  4210              TST      r0,r2
00004c  d103              BNE      |L81.86|
00004e  6c48              LDR      r0,[r1,#0x44]
000050  f4204000          BIC      r0,r0,#0x8000
000054  6448              STR      r0,[r1,#0x44]
                  |L81.86|
;;;1410     }
;;;1411     
;;;1412     /* Disable the Peripheral */
;;;1413     __HAL_TIM_DISABLE(htim);
000056  6820              LDR      r0,[r4,#0]
000058  6a01              LDR      r1,[r0,#0x20]
00005a  4219              TST      r1,r3
00005c  d106              BNE      |L81.108|
00005e  6a01              LDR      r1,[r0,#0x20]
000060  4211              TST      r1,r2
000062  d103              BNE      |L81.108|
000064  6801              LDR      r1,[r0,#0]
000066  f0210101          BIC      r1,r1,#1
00006a  6001              STR      r1,[r0,#0]
                  |L81.108|
;;;1414     
;;;1415     /* Return function status */
;;;1416     return HAL_OK;
00006c  2000              MOVS     r0,#0
;;;1417   } 
00006e  bd10              POP      {r4,pc}
                  |L81.112|
000070  68d0              LDR      r0,[r2,#0xc]          ;1388
000072  f0200008          BIC      r0,r0,#8              ;1388
000076  e7d5              B        |L81.36|
                  |L81.120|
000078  68d0              LDR      r0,[r2,#0xc]          ;1395
00007a  f0200010          BIC      r0,r0,#0x10           ;1395
00007e  e7d1              B        |L81.36|
;;;1418   
                          ENDP

                  |L81.128|
                          DCD      0x40010000
                  |L81.132|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_PeriodElapsedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PeriodElapsedCallback PROC
;;;4688     */
;;;4689   __weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4690   {
;;;4691     /* Prevent unused argument(s) compilation warning */
;;;4692     UNUSED(htim);
;;;4693    
;;;4694     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4695               the __HAL_TIM_PeriodElapsedCallback could be implemented in the user file
;;;4696      */
;;;4697     
;;;4698   }
;;;4699   /**
                          ENDP


                          AREA ||i.HAL_TIM_ReadCapturedValue||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ReadCapturedValue PROC
;;;4598     */
;;;4599   uint32_t HAL_TIM_ReadCapturedValue(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  6bc3              LDR      r3,[r0,#0x3c]
;;;4600   {
;;;4601     uint32_t tmpreg = 0;
000002  2200              MOVS     r2,#0
;;;4602     
;;;4603     __HAL_LOCK(htim);
000004  2b01              CMP      r3,#1
000006  d009              BEQ      |L83.28|
000008  2301              MOVS     r3,#1
00000a  63c3              STR      r3,[r0,#0x3c]
00000c  b141              CBZ      r1,|L83.32|
;;;4604     
;;;4605     switch (Channel)
00000e  2904              CMP      r1,#4
000010  d009              BEQ      |L83.38|
000012  2908              CMP      r1,#8
000014  d00a              BEQ      |L83.44|
000016  290c              CMP      r1,#0xc
000018  d10d              BNE      |L83.54|
00001a  e00a              B        |L83.50|
                  |L83.28|
00001c  2002              MOVS     r0,#2                 ;4603
;;;4606     {
;;;4607       case TIM_CHANNEL_1:
;;;4608       {
;;;4609         /* Check the parameters */
;;;4610         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4611         
;;;4612         /* Return the capture 1 value */
;;;4613         tmpreg = htim->Instance->CCR1;
;;;4614         
;;;4615         break;
;;;4616       }
;;;4617       case TIM_CHANNEL_2:
;;;4618       {
;;;4619         /* Check the parameters */
;;;4620         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4621         
;;;4622         /* Return the capture 2 value */
;;;4623         tmpreg = htim->Instance->CCR2;
;;;4624         
;;;4625         break;
;;;4626       }
;;;4627       
;;;4628       case TIM_CHANNEL_3:
;;;4629       {
;;;4630         /* Check the parameters */
;;;4631         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;4632         
;;;4633         /* Return the capture 3 value */
;;;4634         tmpreg = htim->Instance->CCR3;
;;;4635         
;;;4636         break;
;;;4637       }
;;;4638       
;;;4639       case TIM_CHANNEL_4:
;;;4640       {
;;;4641         /* Check the parameters */
;;;4642         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;4643         
;;;4644         /* Return the capture 4 value */
;;;4645         tmpreg = htim->Instance->CCR4;
;;;4646         
;;;4647         break;
;;;4648       }
;;;4649       
;;;4650       default:
;;;4651       break;  
;;;4652     }
;;;4653        
;;;4654     __HAL_UNLOCK(htim);  
;;;4655     return tmpreg;
;;;4656   }
00001e  4770              BX       lr
                  |L83.32|
000020  6801              LDR      r1,[r0,#0]            ;4613
000022  6b4a              LDR      r2,[r1,#0x34]         ;4613
000024  e007              B        |L83.54|
                  |L83.38|
000026  6801              LDR      r1,[r0,#0]            ;4623
000028  6b8a              LDR      r2,[r1,#0x38]         ;4623
00002a  e004              B        |L83.54|
                  |L83.44|
00002c  6801              LDR      r1,[r0,#0]            ;4634
00002e  6bca              LDR      r2,[r1,#0x3c]         ;4634
000030  e001              B        |L83.54|
                  |L83.50|
000032  6801              LDR      r1,[r0,#0]            ;4645
000034  6c0a              LDR      r2,[r1,#0x40]         ;4645
                  |L83.54|
000036  2100              MOVS     r1,#0                 ;4654
000038  63c1              STR      r1,[r0,#0x3c]         ;4655
00003a  4610              MOV      r0,r2                 ;4655
00003c  4770              BX       lr
;;;4657   
                          ENDP


                          AREA ||i.HAL_TIM_SlaveConfigSynchronization||, CODE, READONLY, ALIGN=2

                  HAL_TIM_SlaveConfigSynchronization PROC
;;;4412     */
;;;4413   HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization(TIM_HandleTypeDef *htim, TIM_SlaveConfigTypeDef * sSlaveConfig)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;4414   {
000004  4604              MOV      r4,r0
;;;4415     uint32_t tmpsmcr  = 0;
;;;4416     uint32_t tmpccmr1 = 0;
;;;4417     uint32_t tmpccer = 0;
;;;4418   
;;;4419     /* Check the parameters */
;;;4420     assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
;;;4421     assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
;;;4422     assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
;;;4423      
;;;4424     __HAL_LOCK(htim);
000006  6bc0              LDR      r0,[r0,#0x3c]
000008  2801              CMP      r0,#1
00000a  d013              BEQ      |L84.52|
00000c  2501              MOVS     r5,#1
;;;4425     
;;;4426     htim->State = HAL_TIM_STATE_BUSY;
00000e  2002              MOVS     r0,#2
000010  e9c4500f          STRD     r5,r0,[r4,#0x3c]
;;;4427   
;;;4428     /* Get the TIMx SMCR register value */
;;;4429     tmpsmcr = htim->Instance->SMCR;
;;;4430   
;;;4431     /* Reset the Trigger Selection Bits */
;;;4432     tmpsmcr &= ~TIM_SMCR_TS;
;;;4433     /* Set the Input Trigger source */
;;;4434     tmpsmcr |= sSlaveConfig->InputTrigger;
000014  6823              LDR      r3,[r4,#0]
000016  684a              LDR      r2,[r1,#4]            ;4429
000018  6898              LDR      r0,[r3,#8]            ;4429
;;;4435   
;;;4436     /* Reset the slave mode Bits */
;;;4437     tmpsmcr &= ~TIM_SMCR_SMS;
00001a  4f20              LDR      r7,|L84.156|
00001c  f0200670          BIC      r6,r0,#0x70           ;4432
;;;4438     /* Set the slave mode */
;;;4439     tmpsmcr |= sSlaveConfig->SlaveMode;
000020  6808              LDR      r0,[r1,#0]
000022  4332              ORRS     r2,r2,r6              ;4434
000024  403a              ANDS     r2,r2,r7              ;4437
000026  4310              ORRS     r0,r0,r2
;;;4440   
;;;4441     /* Write to TIMx SMCR */
;;;4442     htim->Instance->SMCR = tmpsmcr;
000028  6098              STR      r0,[r3,#8]
;;;4443     
;;;4444     /* Configure the trigger prescaler, filter, and polarity */
;;;4445     switch (sSlaveConfig->InputTrigger)
00002a  6848              LDR      r0,[r1,#4]
00002c  f0100f0f          TST      r0,#0xf
000030  d003              BEQ      |L84.58|
000032  e02e              B        |L84.146|
                  |L84.52|
000034  2002              MOVS     r0,#2                 ;4424
                  |L84.54|
;;;4446     {
;;;4447     case TIM_TS_ETRF:
;;;4448       {
;;;4449         /* Check the parameters */
;;;4450         assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
;;;4451         assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));
;;;4452         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;4453         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;4454         /* Configure the ETR Trigger source */
;;;4455         TIM_ETR_SetConfig(htim->Instance, 
;;;4456                           sSlaveConfig->TriggerPrescaler, 
;;;4457                           sSlaveConfig->TriggerPolarity, 
;;;4458                           sSlaveConfig->TriggerFilter);
;;;4459       }
;;;4460       break;
;;;4461       
;;;4462     case TIM_TS_TI1F_ED:
;;;4463       {
;;;4464         /* Check the parameters */
;;;4465         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4466         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;4467         
;;;4468         /* Disable the Channel 1: Reset the CC1E Bit */
;;;4469         tmpccer = htim->Instance->CCER;
;;;4470         htim->Instance->CCER &= ~TIM_CCER_CC1E;
;;;4471         tmpccmr1 = htim->Instance->CCMR1;    
;;;4472         
;;;4473         /* Set the filter */
;;;4474         tmpccmr1 &= ~TIM_CCMR1_IC1F;
;;;4475         tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4);
;;;4476         
;;;4477         /* Write to TIMx CCMR1 and CCER registers */
;;;4478         htim->Instance->CCMR1 = tmpccmr1;
;;;4479         htim->Instance->CCER = tmpccer;                               
;;;4480                                  
;;;4481       }
;;;4482       break;
;;;4483       
;;;4484     case TIM_TS_TI1FP1:
;;;4485       {
;;;4486         /* Check the parameters */
;;;4487         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4488         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;4489         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;4490   
;;;4491         /* Configure TI1 Filter and Polarity */
;;;4492         TIM_TI1_ConfigInputStage(htim->Instance,
;;;4493                                  sSlaveConfig->TriggerPolarity,
;;;4494                                  sSlaveConfig->TriggerFilter);
;;;4495       }
;;;4496       break;
;;;4497       
;;;4498     case TIM_TS_TI2FP2:
;;;4499       {
;;;4500         /* Check the parameters */
;;;4501         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4502         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;4503         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;4504         
;;;4505         /* Configure TI2 Filter and Polarity */
;;;4506         TIM_TI2_ConfigInputStage(htim->Instance,
;;;4507                                   sSlaveConfig->TriggerPolarity,
;;;4508                                   sSlaveConfig->TriggerFilter);
;;;4509       }
;;;4510       break;
;;;4511       
;;;4512     case TIM_TS_ITR0:
;;;4513       {
;;;4514         /* Check the parameter */
;;;4515         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4516       }
;;;4517       break;
;;;4518       
;;;4519     case TIM_TS_ITR1:
;;;4520       {
;;;4521         /* Check the parameter */
;;;4522         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4523       }
;;;4524       break;
;;;4525       
;;;4526     case TIM_TS_ITR2:
;;;4527       {
;;;4528         /* Check the parameter */
;;;4529         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4530       }
;;;4531       break;
;;;4532       
;;;4533     case TIM_TS_ITR3:
;;;4534       {
;;;4535         /* Check the parameter */
;;;4536         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4537       }
;;;4538       break;
;;;4539          
;;;4540     default:
;;;4541       break;
;;;4542     }
;;;4543     
;;;4544     htim->State = HAL_TIM_STATE_READY;
;;;4545        
;;;4546     __HAL_UNLOCK(htim);  
;;;4547     
;;;4548     return HAL_OK;
;;;4549   } 
000036  e8bd81f0          POP      {r4-r8,pc}
                  |L84.58|
00003a  1100              ASRS     r0,r0,#4              ;4445
00003c  2808              CMP      r0,#8                 ;4445
00003e  d228              BCS      |L84.146|
000040  e8dff000          TBB      [pc,r0]               ;4445
000044  27272727          DCB      0x27,0x27,0x27,0x27
000048  0b1c2204          DCB      0x0b,0x1c,0x22,0x04
00004c  688a              LDR      r2,[r1,#8]            ;4455
00004e  6820              LDR      r0,[r4,#0]            ;4455
000050  e9d11303          LDRD     r1,r3,[r1,#0xc]       ;4455
000054  f7fffffe          BL       TIM_ETR_SetConfig
000058  e01b              B        |L84.146|
00005a  6820              LDR      r0,[r4,#0]            ;4469
00005c  6a02              LDR      r2,[r0,#0x20]         ;4469
00005e  6a03              LDR      r3,[r0,#0x20]         ;4470
000060  f0230301          BIC      r3,r3,#1              ;4470
000064  6203              STR      r3,[r0,#0x20]         ;4470
000066  6820              LDR      r0,[r4,#0]            ;4475
000068  690b              LDR      r3,[r1,#0x10]         ;4471
00006a  6981              LDR      r1,[r0,#0x18]         ;4471
00006c  f02101f0          BIC      r1,r1,#0xf0           ;4474
000070  ea411103          ORR      r1,r1,r3,LSL #4       ;4475
000074  6181              STR      r1,[r0,#0x18]         ;4478
000076  6820              LDR      r0,[r4,#0]            ;4479
000078  6202              STR      r2,[r0,#0x20]         ;4479
00007a  e00a              B        |L84.146|
00007c  690a              LDR      r2,[r1,#0x10]         ;4492
00007e  6820              LDR      r0,[r4,#0]            ;4492
000080  6889              LDR      r1,[r1,#8]            ;4492
000082  f7fffffe          BL       TIM_TI1_ConfigInputStage
000086  e004              B        |L84.146|
000088  690a              LDR      r2,[r1,#0x10]         ;4506
00008a  6820              LDR      r0,[r4,#0]            ;4506
00008c  6889              LDR      r1,[r1,#8]            ;4506
00008e  f7fffffe          BL       TIM_TI2_ConfigInputStage
                  |L84.146|
000092  2000              MOVS     r0,#0                 ;4546
000094  6425              STR      r5,[r4,#0x40]         ;4544
000096  63e0              STR      r0,[r4,#0x3c]         ;4546
000098  e7cd              B        |L84.54|
;;;4550   
                          ENDP

00009a  0000              DCW      0x0000
                  |L84.156|
                          DCD      0xfffefff8

                          AREA ||i.HAL_TIM_SlaveConfigSynchronization_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_SlaveConfigSynchronization_IT PROC
;;;4559     */
;;;4560   HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization_IT(TIM_HandleTypeDef *htim, 
000000  b570              PUSH     {r4-r6,lr}
;;;4561                                                           TIM_SlaveConfigTypeDef * sSlaveConfig)
;;;4562   {
000002  4604              MOV      r4,r0
;;;4563     /* Check the parameters */
;;;4564     assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
;;;4565     assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
;;;4566     assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
;;;4567     
;;;4568     __HAL_LOCK(htim);
000004  6bc0              LDR      r0,[r0,#0x3c]
000006  2801              CMP      r0,#1
000008  d015              BEQ      |L85.54|
00000a  2501              MOVS     r5,#1
;;;4569   
;;;4570     htim->State = HAL_TIM_STATE_BUSY;
00000c  2002              MOVS     r0,#2
00000e  e9c4500f          STRD     r5,r0,[r4,#0x3c]
;;;4571     
;;;4572     TIM_SlaveTimer_SetConfig(htim, sSlaveConfig);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       TIM_SlaveTimer_SetConfig
;;;4573     
;;;4574     /* Enable Trigger Interrupt */
;;;4575     __HAL_TIM_ENABLE_IT(htim, TIM_IT_TRIGGER);
000018  6820              LDR      r0,[r4,#0]
;;;4576     
;;;4577     /* Disable Trigger DMA request */
;;;4578     __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
;;;4579     
;;;4580     htim->State = HAL_TIM_STATE_READY;
;;;4581        
;;;4582     __HAL_UNLOCK(htim);  
00001a  2100              MOVS     r1,#0
00001c  68c2              LDR      r2,[r0,#0xc]          ;4575
00001e  f0420240          ORR      r2,r2,#0x40           ;4575
000022  60c2              STR      r2,[r0,#0xc]          ;4575
000024  6820              LDR      r0,[r4,#0]            ;4578
000026  68c2              LDR      r2,[r0,#0xc]          ;4578
000028  f4224280          BIC      r2,r2,#0x4000         ;4578
00002c  60c2              STR      r2,[r0,#0xc]          ;4578
00002e  6425              STR      r5,[r4,#0x40]         ;4580
;;;4583     
;;;4584     return HAL_OK;
000030  4608              MOV      r0,r1
000032  63e1              STR      r1,[r4,#0x3c]         ;4568
;;;4585   }
000034  bd70              POP      {r4-r6,pc}
                  |L85.54|
000036  2002              MOVS     r0,#2                 ;4568
000038  bd70              POP      {r4-r6,pc}
;;;4586   
                          ENDP


                          AREA ||i.HAL_TIM_TriggerCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_TriggerCallback PROC
;;;4751     */
;;;4752   __weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4753   {
;;;4754     /* Prevent unused argument(s) compilation warning */
;;;4755     UNUSED(htim);
;;;4756    
;;;4757     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4758               the HAL_TIM_TriggerCallback could be implemented in the user file
;;;4759      */
;;;4760   }
;;;4761   
                          ENDP


                          AREA ||i.TIM_Base_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_Base_SetConfig PROC
;;;5431     */
;;;5432   void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
000000  b5f0              PUSH     {r4-r7,lr}
;;;5433   {
;;;5434     uint32_t tmpcr1 = 0;
;;;5435     tmpcr1 = TIMx->CR1;
;;;5436     
;;;5437     /* Set TIM Time Base Unit parameters ---------------------------------------*/
;;;5438     if(IS_TIM_CC3_INSTANCE(TIMx) != RESET)   
000002  4b27              LDR      r3,|L87.160|
000004  f04f4e80          MOV      lr,#0x40000000
000008  4d26              LDR      r5,|L87.164|
00000a  6802              LDR      r2,[r0,#0]            ;5435
00000c  4298              CMP      r0,r3
00000e  4e26              LDR      r6,|L87.168|
000010  4f26              LDR      r7,|L87.172|
000012  4c27              LDR      r4,|L87.176|
000014  d009              BEQ      |L87.42|
000016  4570              CMP      r0,lr
000018  d007              BEQ      |L87.42|
00001a  42a8              CMP      r0,r5
00001c  d005              BEQ      |L87.42|
00001e  42b0              CMP      r0,r6
000020  d003              BEQ      |L87.42|
000022  42b8              CMP      r0,r7
000024  d001              BEQ      |L87.42|
000026  42a0              CMP      r0,r4
000028  d105              BNE      |L87.54|
                  |L87.42|
;;;5439     {
;;;5440       /* Select the Counter Mode */
;;;5441       tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
;;;5442       tmpcr1 |= Structure->CounterMode;
00002a  f8d1c004          LDR      r12,[r1,#4]
00002e  f0220270          BIC      r2,r2,#0x70           ;5441
000032  ea4c0202          ORR      r2,r12,r2
                  |L87.54|
;;;5443     }
;;;5444    
;;;5445     if(IS_TIM_CC1_INSTANCE(TIMx) != RESET)  
000036  4298              CMP      r0,r3
000038  d01b              BEQ      |L87.114|
00003a  4570              CMP      r0,lr
00003c  d019              BEQ      |L87.114|
00003e  42a8              CMP      r0,r5
000040  d017              BEQ      |L87.114|
000042  42b0              CMP      r0,r6
000044  d015              BEQ      |L87.114|
000046  42b8              CMP      r0,r7
000048  d013              BEQ      |L87.114|
00004a  42a0              CMP      r0,r4
00004c  d011              BEQ      |L87.114|
00004e  4d19              LDR      r5,|L87.180|
000050  42a8              CMP      r0,r5
000052  d00e              BEQ      |L87.114|
000054  4d18              LDR      r5,|L87.184|
000056  42a8              CMP      r0,r5
000058  d00b              BEQ      |L87.114|
00005a  4d18              LDR      r5,|L87.188|
00005c  42a8              CMP      r0,r5
00005e  d008              BEQ      |L87.114|
000060  4d17              LDR      r5,|L87.192|
000062  42a8              CMP      r0,r5
000064  d005              BEQ      |L87.114|
000066  4d17              LDR      r5,|L87.196|
000068  42a8              CMP      r0,r5
00006a  d002              BEQ      |L87.114|
00006c  4d16              LDR      r5,|L87.200|
00006e  42a8              CMP      r0,r5
000070  d103              BNE      |L87.122|
                  |L87.114|
;;;5446     {
;;;5447       /* Set the clock division */
;;;5448       tmpcr1 &= ~TIM_CR1_CKD;
;;;5449       tmpcr1 |= (uint32_t)Structure->ClockDivision;
000072  68cd              LDR      r5,[r1,#0xc]
000074  f4227240          BIC      r2,r2,#0x300          ;5448
000078  432a              ORRS     r2,r2,r5
                  |L87.122|
;;;5450     }
;;;5451   
;;;5452     /* Set the auto-reload preload */
;;;5453     MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
00007a  694d              LDR      r5,[r1,#0x14]
00007c  f0220280          BIC      r2,r2,#0x80
000080  432a              ORRS     r2,r2,r5
;;;5454   
;;;5455     TIMx->CR1 = tmpcr1;
000082  6002              STR      r2,[r0,#0]
;;;5456   
;;;5457     /* Set the Auto-reload value */
;;;5458     TIMx->ARR = (uint32_t)Structure->Period ;
;;;5459    
;;;5460     /* Set the Prescaler value */
;;;5461     TIMx->PSC = (uint32_t)Structure->Prescaler;
;;;5462       
;;;5463     if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)  
000084  4298              CMP      r0,r3
000086  688a              LDR      r2,[r1,#8]            ;5458
000088  62c2              STR      r2,[r0,#0x2c]         ;5458
00008a  680a              LDR      r2,[r1,#0]            ;5461
00008c  6282              STR      r2,[r0,#0x28]         ;5461
00008e  d001              BEQ      |L87.148|
000090  42a0              CMP      r0,r4
000092  d101              BNE      |L87.152|
                  |L87.148|
;;;5464     {
;;;5465       /* Set the Repetition Counter value */
;;;5466       TIMx->RCR = Structure->RepetitionCounter;
000094  6909              LDR      r1,[r1,#0x10]
000096  6301              STR      r1,[r0,#0x30]
                  |L87.152|
;;;5467     }
;;;5468   
;;;5469     /* Generate an update event to reload the Prescaler 
;;;5470        and the repetition counter(only for TIM1 and TIM8) value immediately */
;;;5471     TIMx->EGR = TIM_EGR_UG;
000098  2101              MOVS     r1,#1
00009a  6141              STR      r1,[r0,#0x14]
;;;5472   }
00009c  bdf0              POP      {r4-r7,pc}
;;;5473   
                          ENDP

00009e  0000              DCW      0x0000
                  |L87.160|
                          DCD      0x40010000
                  |L87.164|
                          DCD      0x40000400
                  |L87.168|
                          DCD      0x40000800
                  |L87.172|
                          DCD      0x40000c00
                  |L87.176|
                          DCD      0x40010400
                  |L87.180|
                          DCD      0x40014000
                  |L87.184|
                          DCD      0x40014400
                  |L87.188|
                          DCD      0x40014800
                  |L87.192|
                          DCD      0x40001800
                  |L87.196|
                          DCD      0x40001c00
                  |L87.200|
                          DCD      0x40002000

                          AREA ||i.TIM_CCxChannelCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxChannelCmd PROC
;;;6205     */
;;;6206   void TIM_CCxChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelState)
000000  b510              PUSH     {r4,lr}
;;;6207   {
;;;6208     uint32_t tmp = 0;
;;;6209   
;;;6210     /* Check the parameters */
;;;6211     assert_param(IS_TIM_CC1_INSTANCE(TIMx)); 
;;;6212     assert_param(IS_TIM_CHANNELS(Channel));
;;;6213   
;;;6214     tmp = TIM_CCER_CC1E << Channel;
;;;6215   
;;;6216     /* Reset the CCxE Bit */
;;;6217     TIMx->CCER &= ~tmp;
000002  6a04              LDR      r4,[r0,#0x20]
000004  2301              MOVS     r3,#1                 ;6214
;;;6218   
;;;6219     /* Set or reset the CCxE Bit */ 
;;;6220     TIMx->CCER |= (uint32_t)(ChannelState << Channel);
000006  408a              LSLS     r2,r2,r1
000008  408b              LSLS     r3,r3,r1              ;6214
00000a  439c              BICS     r4,r4,r3              ;6217
00000c  6204              STR      r4,[r0,#0x20]         ;6217
00000e  6a01              LDR      r1,[r0,#0x20]
000010  4311              ORRS     r1,r1,r2
000012  6201              STR      r1,[r0,#0x20]
;;;6221   }
000014  bd10              POP      {r4,pc}
;;;6222   
                          ENDP


                          AREA ||i.TIM_DMACaptureCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMACaptureCplt PROC
;;;5358     */
;;;5359   void HAL_TIM_DMACaptureCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;5360   {
;;;5361     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
;;;5362       
;;;5363      htim->State= HAL_TIM_STATE_READY; 
000002  6bc4              LDR      r4,[r0,#0x3c]
000004  2101              MOVS     r1,#1
000006  6421              STR      r1,[r4,#0x40]
;;;5364       
;;;5365     if (hdma == htim->hdma[TIM_DMA_ID_CC1])
000008  6a62              LDR      r2,[r4,#0x24]
00000a  4282              CMP      r2,r0
00000c  d101              BNE      |L89.18|
;;;5366     {
;;;5367       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
00000e  61e1              STR      r1,[r4,#0x1c]
000010  e00e              B        |L89.48|
                  |L89.18|
;;;5368     }
;;;5369     else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
000012  6aa1              LDR      r1,[r4,#0x28]
000014  4281              CMP      r1,r0
000016  d101              BNE      |L89.28|
;;;5370     {
;;;5371       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
000018  2002              MOVS     r0,#2
00001a  e008              B        |L89.46|
                  |L89.28|
;;;5372     }
;;;5373     else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
00001c  6ae1              LDR      r1,[r4,#0x2c]
00001e  4281              CMP      r1,r0
000020  d101              BNE      |L89.38|
;;;5374     {
;;;5375       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
000022  2004              MOVS     r0,#4
000024  e003              B        |L89.46|
                  |L89.38|
;;;5376     }
;;;5377     else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
000026  6b21              LDR      r1,[r4,#0x30]
000028  4281              CMP      r1,r0
00002a  d101              BNE      |L89.48|
;;;5378     {
;;;5379       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
00002c  2008              MOVS     r0,#8
                  |L89.46|
00002e  61e0              STR      r0,[r4,#0x1c]
                  |L89.48|
;;;5380     }
;;;5381   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;5382     htim->IC_CaptureCallback(htim);
;;;5383   #else
;;;5384     HAL_TIM_IC_CaptureCallback(htim);
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
;;;5385   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;5386     htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000036  2000              MOVS     r0,#0
000038  61e0              STR      r0,[r4,#0x1c]
;;;5387   
;;;5388   }
00003a  bd10              POP      {r4,pc}
;;;5389   
                          ENDP


                          AREA ||i.TIM_DMADelayPulseCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMADelayPulseCplt PROC
;;;5322     */
;;;5323   void HAL_TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;5324   {
;;;5325     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
;;;5326     
;;;5327     htim->State= HAL_TIM_STATE_READY; 
000002  6bc4              LDR      r4,[r0,#0x3c]
000004  2101              MOVS     r1,#1
000006  6421              STR      r1,[r4,#0x40]
;;;5328     
;;;5329     if (hdma == htim->hdma[TIM_DMA_ID_CC1])
000008  6a62              LDR      r2,[r4,#0x24]
00000a  4282              CMP      r2,r0
00000c  d101              BNE      |L90.18|
;;;5330     {
;;;5331       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
00000e  61e1              STR      r1,[r4,#0x1c]
000010  e00e              B        |L90.48|
                  |L90.18|
;;;5332     }
;;;5333     else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
000012  6aa1              LDR      r1,[r4,#0x28]
000014  4281              CMP      r1,r0
000016  d101              BNE      |L90.28|
;;;5334     {
;;;5335       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
000018  2002              MOVS     r0,#2
00001a  e008              B        |L90.46|
                  |L90.28|
;;;5336     }
;;;5337     else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
00001c  6ae1              LDR      r1,[r4,#0x2c]
00001e  4281              CMP      r1,r0
000020  d101              BNE      |L90.38|
;;;5338     {
;;;5339       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
000022  2004              MOVS     r0,#4
000024  e003              B        |L90.46|
                  |L90.38|
;;;5340     }
;;;5341     else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
000026  6b21              LDR      r1,[r4,#0x30]
000028  4281              CMP      r1,r0
00002a  d101              BNE      |L90.48|
;;;5342     {
;;;5343       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
00002c  2008              MOVS     r0,#8
                  |L90.46|
00002e  61e0              STR      r0,[r4,#0x1c]
                  |L90.48|
;;;5344     }
;;;5345   
;;;5346   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;5347     htim->PWM_PulseFinishedCallback(htim);
;;;5348   #else
;;;5349     HAL_TIM_PWM_PulseFinishedCallback(htim);
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
;;;5350   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;5351     htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000036  2000              MOVS     r0,#0
000038  61e0              STR      r0,[r4,#0x1c]
;;;5352   }
00003a  bd10              POP      {r4,pc}
;;;5353   /**
                          ENDP


                          AREA ||i.TIM_DMAError||, CODE, READONLY, ALIGN=1

                  TIM_DMAError PROC
;;;5304     */
;;;5305   void HAL_TIM_DMAError(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;5306   {
;;;5307     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6bc0              LDR      r0,[r0,#0x3c]
;;;5308     
;;;5309     htim->State= HAL_TIM_STATE_READY;
000004  2101              MOVS     r1,#1
000006  6401              STR      r1,[r0,#0x40]
;;;5310   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;5311      htim->ErrorCallback(htim);
;;;5312   #else
;;;5313     HAL_TIM_ErrorCallback(htim);
000008  f7fffffe          BL       HAL_TIM_ErrorCallback
;;;5314   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;5315   }
00000c  bd10              POP      {r4,pc}
;;;5316   
                          ENDP


                          AREA ||i.TIM_DMAPeriodElapsedCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMAPeriodElapsedCplt PROC
;;;5395     */
;;;5396   static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;5397   {
;;;5398     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6bc0              LDR      r0,[r0,#0x3c]
;;;5399   
;;;5400     htim->State= HAL_TIM_STATE_READY;
000004  2101              MOVS     r1,#1
000006  6401              STR      r1,[r0,#0x40]
;;;5401   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;5402     htim->PeriodElapsedCallback(htim);
;;;5403   #else
;;;5404     HAL_TIM_PeriodElapsedCallback(htim);
000008  f7fffffe          BL       HAL_TIM_PeriodElapsedCallback
;;;5405   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;5406   }
00000c  bd10              POP      {r4,pc}
;;;5407   
                          ENDP


                          AREA ||i.TIM_DMATriggerCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMATriggerCplt PROC
;;;5413     */
;;;5414   static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;5415   {
;;;5416     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;  
000002  6bc0              LDR      r0,[r0,#0x3c]
;;;5417     
;;;5418     htim->State= HAL_TIM_STATE_READY; 
000004  2101              MOVS     r1,#1
000006  6401              STR      r1,[r0,#0x40]
;;;5419   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;5420     htim->TriggerCallback(htim);
;;;5421   #else
;;;5422     HAL_TIM_TriggerCallback(htim);
000008  f7fffffe          BL       HAL_TIM_TriggerCallback
;;;5423    #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;5424   }
00000c  bd10              POP      {r4,pc}
;;;5425   
                          ENDP


                          AREA ||i.TIM_ETR_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_ETR_SetConfig PROC
;;;6175     */
;;;6176   void TIM_ETR_SetConfig(TIM_TypeDef* TIMx, uint32_t TIM_ExtTRGPrescaler,
000000  ea422203          ORR      r2,r2,r3,LSL #8
;;;6177                          uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
;;;6178   {
;;;6179     uint32_t tmpsmcr = 0;
;;;6180   
;;;6181     tmpsmcr = TIMx->SMCR;
000004  6883              LDR      r3,[r0,#8]
;;;6182   
;;;6183     /* Reset the ETR Bits */
;;;6184     tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
;;;6185   
;;;6186     /* Set the Prescaler, the Filter value and the Polarity */
;;;6187     tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8)));
000006  430a              ORRS     r2,r2,r1
000008  f423417f          BIC      r1,r3,#0xff00         ;6184
00000c  430a              ORRS     r2,r2,r1
;;;6188   
;;;6189     /* Write to TIMx SMCR */
;;;6190     TIMx->SMCR = tmpsmcr;
00000e  6082              STR      r2,[r0,#8]
;;;6191   } 
000010  4770              BX       lr
;;;6192   
                          ENDP


                          AREA ||i.TIM_ITRx_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITRx_SetConfig PROC
;;;6144     */
;;;6145   static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint16_t TIM_ITRx)
000000  6882              LDR      r2,[r0,#8]
;;;6146   {
;;;6147     uint32_t tmpsmcr = 0;
;;;6148     
;;;6149      /* Get the TIMx SMCR register value */
;;;6150      tmpsmcr = TIMx->SMCR;
;;;6151      /* Reset the TS Bits */
;;;6152      tmpsmcr &= ~TIM_SMCR_TS;
000002  f0220270          BIC      r2,r2,#0x70
;;;6153      /* Set the Input Trigger source and the slave mode*/
;;;6154      tmpsmcr |= TIM_ITRx | TIM_SLAVEMODE_EXTERNAL1;
000006  430a              ORRS     r2,r2,r1
000008  f0420107          ORR      r1,r2,#7
;;;6155      /* Write to TIMx SMCR */
;;;6156      TIMx->SMCR = tmpsmcr;
00000c  6081              STR      r1,[r0,#8]
;;;6157   }
00000e  4770              BX       lr
;;;6158   
                          ENDP


                          AREA ||i.TIM_OC1_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC1_SetConfig PROC
;;;5479     */
;;;5480   void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b5f0              PUSH     {r4-r7,lr}
;;;5481   {
;;;5482     uint32_t tmpccmrx = 0;
;;;5483     uint32_t tmpccer = 0;
;;;5484     uint32_t tmpcr2 = 0;  
;;;5485   
;;;5486     /* Disable the Channel 1: Reset the CC1E Bit */
;;;5487     TIMx->CCER &= ~TIM_CCER_CC1E;
000002  6a02              LDR      r2,[r0,#0x20]
;;;5488     
;;;5489     /* Get the TIMx CCER register value */
;;;5490     tmpccer = TIMx->CCER;
;;;5491     /* Get the TIMx CR2 register value */
;;;5492     tmpcr2 = TIMx->CR2;
;;;5493     
;;;5494     /* Get the TIMx CCMR1 register value */
;;;5495     tmpccmrx = TIMx->CCMR1;
;;;5496       
;;;5497     /* Reset the Output Compare Mode Bits */
;;;5498     tmpccmrx &= ~TIM_CCMR1_OC1M;
;;;5499     tmpccmrx &= ~TIM_CCMR1_CC1S;
;;;5500     /* Select the Output Compare Mode */
;;;5501     tmpccmrx |= OC_Config->OCMode;
;;;5502     
;;;5503     /* Reset the Output Polarity level */
;;;5504     tmpccer &= ~TIM_CCER_CC1P;
;;;5505     /* Set the Output Compare Polarity */
;;;5506     tmpccer |= OC_Config->OCPolarity;
;;;5507   
;;;5508       
;;;5509     if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
000004  4b16              LDR      r3,|L96.96|
000006  4f15              LDR      r7,|L96.92|
000008  f0220201          BIC      r2,r2,#1              ;5487
00000c  4298              CMP      r0,r3
00000e  6202              STR      r2,[r0,#0x20]         ;5487
000010  6a06              LDR      r6,[r0,#0x20]         ;5490
000012  6842              LDR      r2,[r0,#4]            ;5492
000014  6984              LDR      r4,[r0,#0x18]         ;5495
000016  f0260602          BIC      r6,r6,#2              ;5504
00001a  688b              LDR      r3,[r1,#8]            ;5506
00001c  680d              LDR      r5,[r1,#0]            ;5501
00001e  ea040407          AND      r4,r4,r7              ;5498
000022  f0240403          BIC      r4,r4,#3              ;5499
000026  ea430306          ORR      r3,r3,r6              ;5506
00002a  ea450504          ORR      r5,r5,r4              ;5501
00002e  d002              BEQ      |L96.54|
000030  4c0c              LDR      r4,|L96.100|
000032  42a0              CMP      r0,r4
000034  d10b              BNE      |L96.78|
                  |L96.54|
;;;5510     {   
;;;5511       /* Reset the Output N Polarity level */
;;;5512       tmpccer &= ~TIM_CCER_CC1NP;
;;;5513       /* Set the Output N Polarity */
;;;5514       tmpccer |= OC_Config->OCNPolarity;
000036  68cc              LDR      r4,[r1,#0xc]
;;;5515       /* Reset the Output N State */
;;;5516       tmpccer &= ~TIM_CCER_CC1NE;
;;;5517       
;;;5518       /* Reset the Output Compare and Output Compare N IDLE State */
;;;5519       tmpcr2 &= ~TIM_CR2_OIS1;
;;;5520       tmpcr2 &= ~TIM_CR2_OIS1N;
000038  f4227740          BIC      r7,r2,#0x300
00003c  e9d16205          LDRD     r6,r2,[r1,#0x14]      ;5514
000040  f0230308          BIC      r3,r3,#8              ;5512
000044  431c              ORRS     r4,r4,r3              ;5514
;;;5521       /* Set the Output Idle state */
;;;5522       tmpcr2 |= OC_Config->OCIdleState;
000046  433e              ORRS     r6,r6,r7
;;;5523       /* Set the Output N Idle state */
;;;5524       tmpcr2 |= OC_Config->OCNIdleState;
000048  4332              ORRS     r2,r2,r6
00004a  f0240304          BIC      r3,r4,#4              ;5516
                  |L96.78|
;;;5525     }
;;;5526     /* Write to TIMx CR2 */
;;;5527     TIMx->CR2 = tmpcr2;
00004e  6042              STR      r2,[r0,#4]
;;;5528     
;;;5529     /* Write to TIMx CCMR1 */
;;;5530     TIMx->CCMR1 = tmpccmrx;
000050  6185              STR      r5,[r0,#0x18]
;;;5531     
;;;5532     /* Set the Capture Compare Register value */
;;;5533     TIMx->CCR1 = OC_Config->Pulse;
000052  6849              LDR      r1,[r1,#4]
000054  6341              STR      r1,[r0,#0x34]
;;;5534     
;;;5535     /* Write to TIMx CCER */
;;;5536     TIMx->CCER = tmpccer;  
000056  6203              STR      r3,[r0,#0x20]
;;;5537   } 
000058  bdf0              POP      {r4-r7,pc}
;;;5538   
                          ENDP

00005a  0000              DCW      0x0000
                  |L96.92|
                          DCD      0xfffeff8f
                  |L96.96|
                          DCD      0x40010000
                  |L96.100|
                          DCD      0x40010400

                          AREA ||i.TIM_OC2_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC2_SetConfig PROC
;;;5544     */
;;;5545   void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b5f0              PUSH     {r4-r7,lr}
;;;5546   {
;;;5547     uint32_t tmpccmrx = 0;
;;;5548     uint32_t tmpccer = 0;
;;;5549     uint32_t tmpcr2 = 0;
;;;5550      
;;;5551     /* Disable the Channel 2: Reset the CC2E Bit */
;;;5552     TIMx->CCER &= ~TIM_CCER_CC2E;
000002  6a02              LDR      r2,[r0,#0x20]
;;;5553     
;;;5554     /* Get the TIMx CCER register value */  
;;;5555     tmpccer = TIMx->CCER;
;;;5556     /* Get the TIMx CR2 register value */
;;;5557     tmpcr2 = TIMx->CR2;
;;;5558     
;;;5559     /* Get the TIMx CCMR1 register value */
;;;5560     tmpccmrx = TIMx->CCMR1;
;;;5561       
;;;5562     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;5563     tmpccmrx &= ~TIM_CCMR1_OC2M;
;;;5564     tmpccmrx &= ~TIM_CCMR1_CC2S;
;;;5565     
;;;5566     /* Select the Output Compare Mode */
;;;5567     tmpccmrx |= (OC_Config->OCMode << 8);
;;;5568     
;;;5569     /* Reset the Output Polarity level */
;;;5570     tmpccer &= ~TIM_CCER_CC2P;
;;;5571     /* Set the Output Compare Polarity */
;;;5572     tmpccer |= (OC_Config->OCPolarity << 4);
;;;5573       
;;;5574     if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
000004  4b17              LDR      r3,|L97.100|
000006  4d16              LDR      r5,|L97.96|
000008  f0220210          BIC      r2,r2,#0x10           ;5552
00000c  4298              CMP      r0,r3
00000e  6202              STR      r2,[r0,#0x20]         ;5552
000010  6a04              LDR      r4,[r0,#0x20]         ;5555
000012  6842              LDR      r2,[r0,#4]            ;5557
000014  6983              LDR      r3,[r0,#0x18]         ;5560
000016  f0240420          BIC      r4,r4,#0x20           ;5570
00001a  688f              LDR      r7,[r1,#8]            ;5572
00001c  680e              LDR      r6,[r1,#0]            ;5567
00001e  ea030305          AND      r3,r3,r5              ;5563
000022  f4237540          BIC      r5,r3,#0x300          ;5564
000026  ea441307          ORR      r3,r4,r7,LSL #4       ;5572
00002a  ea452406          ORR      r4,r5,r6,LSL #8       ;5567
00002e  d002              BEQ      |L97.54|
000030  4d0d              LDR      r5,|L97.104|
000032  42a8              CMP      r0,r5
000034  d10e              BNE      |L97.84|
                  |L97.54|
;;;5575     {
;;;5576       assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
;;;5577       
;;;5578       /* Reset the Output N Polarity level */
;;;5579       tmpccer &= ~TIM_CCER_CC2NP;
;;;5580       /* Set the Output N Polarity */
;;;5581       tmpccer |= (OC_Config->OCNPolarity << 4);
000036  68cd              LDR      r5,[r1,#0xc]
000038  f0230380          BIC      r3,r3,#0x80           ;5579
00003c  e9d16705          LDRD     r6,r7,[r1,#0x14]
;;;5582       /* Reset the Output N State */
;;;5583       tmpccer &= ~TIM_CCER_CC2NE;
;;;5584       
;;;5585       /* Reset the Output Compare and Output Compare N IDLE State */
;;;5586       tmpcr2 &= ~TIM_CR2_OIS2;
;;;5587       tmpcr2 &= ~TIM_CR2_OIS2N;
000040  f4226240          BIC      r2,r2,#0xc00
000044  ea431305          ORR      r3,r3,r5,LSL #4       ;5581
;;;5588       /* Set the Output Idle state */
;;;5589       tmpcr2 |= (OC_Config->OCIdleState << 2);
000048  ea420286          ORR      r2,r2,r6,LSL #2
00004c  f0230340          BIC      r3,r3,#0x40           ;5583
;;;5590       /* Set the Output N Idle state */
;;;5591       tmpcr2 |= (OC_Config->OCNIdleState << 2);
000050  ea420287          ORR      r2,r2,r7,LSL #2
                  |L97.84|
;;;5592     }
;;;5593     /* Write to TIMx CR2 */
;;;5594     TIMx->CR2 = tmpcr2;
000054  6042              STR      r2,[r0,#4]
;;;5595     
;;;5596     /* Write to TIMx CCMR1 */
;;;5597     TIMx->CCMR1 = tmpccmrx;
000056  6184              STR      r4,[r0,#0x18]
;;;5598     
;;;5599     /* Set the Capture Compare Register value */
;;;5600     TIMx->CCR2 = OC_Config->Pulse;
000058  6849              LDR      r1,[r1,#4]
00005a  6381              STR      r1,[r0,#0x38]
;;;5601     
;;;5602     /* Write to TIMx CCER */
;;;5603     TIMx->CCER = tmpccer;
00005c  6203              STR      r3,[r0,#0x20]
;;;5604   }
00005e  bdf0              POP      {r4-r7,pc}
;;;5605   
                          ENDP

                  |L97.96|
                          DCD      0xfeff8fff
                  |L97.100|
                          DCD      0x40010000
                  |L97.104|
                          DCD      0x40010400

                          AREA ||i.TIM_OC3_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC3_SetConfig PROC
;;;5611     */
;;;5612   void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b5f0              PUSH     {r4-r7,lr}
;;;5613   {
;;;5614     uint32_t tmpccmrx = 0;
;;;5615     uint32_t tmpccer = 0;
;;;5616     uint32_t tmpcr2 = 0;   
;;;5617   
;;;5618     /* Disable the Channel 3: Reset the CC2E Bit */
;;;5619     TIMx->CCER &= ~TIM_CCER_CC3E;
000002  6a02              LDR      r2,[r0,#0x20]
;;;5620     
;;;5621     /* Get the TIMx CCER register value */
;;;5622     tmpccer = TIMx->CCER;
;;;5623     /* Get the TIMx CR2 register value */
;;;5624     tmpcr2 = TIMx->CR2;
;;;5625     
;;;5626     /* Get the TIMx CCMR2 register value */
;;;5627     tmpccmrx = TIMx->CCMR2;
;;;5628       
;;;5629     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;5630     tmpccmrx &= ~TIM_CCMR2_OC3M;
;;;5631     tmpccmrx &= ~TIM_CCMR2_CC3S;  
;;;5632     /* Select the Output Compare Mode */
;;;5633     tmpccmrx |= OC_Config->OCMode;
;;;5634     
;;;5635     /* Reset the Output Polarity level */
;;;5636     tmpccer &= ~TIM_CCER_CC3P;
;;;5637     /* Set the Output Compare Polarity */
;;;5638     tmpccer |= (OC_Config->OCPolarity << 8);
;;;5639       
;;;5640     if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
000004  4b17              LDR      r3,|L98.100|
000006  4f16              LDR      r7,|L98.96|
000008  f4227280          BIC      r2,r2,#0x100          ;5619
00000c  4298              CMP      r0,r3
00000e  6202              STR      r2,[r0,#0x20]         ;5619
000010  6a05              LDR      r5,[r0,#0x20]         ;5622
000012  6843              LDR      r3,[r0,#4]            ;5624
000014  69c2              LDR      r2,[r0,#0x1c]         ;5627
000016  f4257500          BIC      r5,r5,#0x200          ;5636
00001a  688e              LDR      r6,[r1,#8]            ;5638
00001c  ea020207          AND      r2,r2,r7              ;5630
000020  680c              LDR      r4,[r1,#0]            ;5633
000022  f0220703          BIC      r7,r2,#3              ;5631
000026  ea452206          ORR      r2,r5,r6,LSL #8       ;5638
00002a  ea440407          ORR      r4,r4,r7              ;5633
00002e  d002              BEQ      |L98.54|
000030  4d0d              LDR      r5,|L98.104|
000032  42a8              CMP      r0,r5
000034  d10e              BNE      |L98.84|
                  |L98.54|
;;;5641     {
;;;5642       assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
;;;5643       
;;;5644       /* Reset the Output N Polarity level */
;;;5645       tmpccer &= ~TIM_CCER_CC3NP;
;;;5646       /* Set the Output N Polarity */
;;;5647       tmpccer |= (OC_Config->OCNPolarity << 8);
000036  68cd              LDR      r5,[r1,#0xc]
000038  f4226200          BIC      r2,r2,#0x800          ;5645
00003c  e9d16705          LDRD     r6,r7,[r1,#0x14]
;;;5648       /* Reset the Output N State */
;;;5649       tmpccer &= ~TIM_CCER_CC3NE;
;;;5650       
;;;5651       /* Reset the Output Compare and Output Compare N IDLE State */
;;;5652       tmpcr2 &= ~TIM_CR2_OIS3;
;;;5653       tmpcr2 &= ~TIM_CR2_OIS3N;
000040  f4235340          BIC      r3,r3,#0x3000
000044  ea422205          ORR      r2,r2,r5,LSL #8       ;5647
;;;5654       /* Set the Output Idle state */
;;;5655       tmpcr2 |= (OC_Config->OCIdleState << 4);
000048  ea431306          ORR      r3,r3,r6,LSL #4
00004c  f4226280          BIC      r2,r2,#0x400          ;5649
;;;5656       /* Set the Output N Idle state */
;;;5657       tmpcr2 |= (OC_Config->OCNIdleState << 4);
000050  ea431307          ORR      r3,r3,r7,LSL #4
                  |L98.84|
;;;5658     }
;;;5659     /* Write to TIMx CR2 */
;;;5660     TIMx->CR2 = tmpcr2;
000054  6043              STR      r3,[r0,#4]
;;;5661     
;;;5662     /* Write to TIMx CCMR2 */
;;;5663     TIMx->CCMR2 = tmpccmrx;
000056  61c4              STR      r4,[r0,#0x1c]
;;;5664     
;;;5665     /* Set the Capture Compare Register value */
;;;5666     TIMx->CCR3 = OC_Config->Pulse;
000058  6849              LDR      r1,[r1,#4]
00005a  63c1              STR      r1,[r0,#0x3c]
;;;5667     
;;;5668     /* Write to TIMx CCER */
;;;5669     TIMx->CCER = tmpccer;
00005c  6202              STR      r2,[r0,#0x20]
;;;5670   }
00005e  bdf0              POP      {r4-r7,pc}
;;;5671   
                          ENDP

                  |L98.96|
                          DCD      0xfffeff8f
                  |L98.100|
                          DCD      0x40010000
                  |L98.104|
                          DCD      0x40010400

                          AREA ||i.TIM_OC4_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC4_SetConfig PROC
;;;5677     */
;;;5678   void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b5f0              PUSH     {r4-r7,lr}
;;;5679   {
;;;5680     uint32_t tmpccmrx = 0;
;;;5681     uint32_t tmpccer = 0;
;;;5682     uint32_t tmpcr2 = 0;
;;;5683   
;;;5684     /* Disable the Channel 4: Reset the CC4E Bit */
;;;5685     TIMx->CCER &= ~TIM_CCER_CC4E;
000002  6a02              LDR      r2,[r0,#0x20]
;;;5686     
;;;5687     /* Get the TIMx CCER register value */
;;;5688     tmpccer = TIMx->CCER;
;;;5689     /* Get the TIMx CR2 register value */
;;;5690     tmpcr2 = TIMx->CR2;
;;;5691     
;;;5692     /* Get the TIMx CCMR2 register value */
;;;5693     tmpccmrx = TIMx->CCMR2;
;;;5694       
;;;5695     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;5696     tmpccmrx &= ~TIM_CCMR2_OC4M;
;;;5697     tmpccmrx &= ~TIM_CCMR2_CC4S;
;;;5698     
;;;5699     /* Select the Output Compare Mode */
;;;5700     tmpccmrx |= (OC_Config->OCMode << 8);
;;;5701     
;;;5702     /* Reset the Output Polarity level */
;;;5703     tmpccer &= ~TIM_CCER_CC4P;
;;;5704     /* Set the Output Compare Polarity */
;;;5705     tmpccer |= (OC_Config->OCPolarity << 12);
;;;5706      
;;;5707     /*if((TIMx == TIM1) || (TIMx == TIM8))*/
;;;5708     if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
000004  4b12              LDR      r3,|L99.80|
000006  4f11              LDR      r7,|L99.76|
000008  f4225280          BIC      r2,r2,#0x1000         ;5685
00000c  4298              CMP      r0,r3
00000e  6202              STR      r2,[r0,#0x20]         ;5685
000010  6a04              LDR      r4,[r0,#0x20]         ;5688
000012  6842              LDR      r2,[r0,#4]            ;5690
000014  69c3              LDR      r3,[r0,#0x1c]         ;5693
000016  f4245400          BIC      r4,r4,#0x2000         ;5703
00001a  688e              LDR      r6,[r1,#8]            ;5705
00001c  680d              LDR      r5,[r1,#0]            ;5700
00001e  ea030307          AND      r3,r3,r7              ;5696
000022  f4237340          BIC      r3,r3,#0x300          ;5697
000026  ea443406          ORR      r4,r4,r6,LSL #12      ;5705
00002a  ea432305          ORR      r3,r3,r5,LSL #8       ;5700
00002e  d002              BEQ      |L99.54|
000030  4d08              LDR      r5,|L99.84|
000032  42a8              CMP      r0,r5
000034  d104              BNE      |L99.64|
                  |L99.54|
;;;5709     {
;;;5710       assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
;;;5711       /* Reset the Output Compare IDLE State */
;;;5712       tmpcr2 &= ~TIM_CR2_OIS4;
;;;5713       /* Set the Output Idle state */
;;;5714       tmpcr2 |= (OC_Config->OCIdleState << 6);
000036  694d              LDR      r5,[r1,#0x14]
000038  f4224280          BIC      r2,r2,#0x4000         ;5712
00003c  ea421285          ORR      r2,r2,r5,LSL #6
                  |L99.64|
;;;5715     }
;;;5716     /* Write to TIMx CR2 */
;;;5717     TIMx->CR2 = tmpcr2;
000040  6042              STR      r2,[r0,#4]
;;;5718     
;;;5719     /* Write to TIMx CCMR2 */  
;;;5720     TIMx->CCMR2 = tmpccmrx;
000042  61c3              STR      r3,[r0,#0x1c]
;;;5721       
;;;5722     /* Set the Capture Compare Register value */
;;;5723     TIMx->CCR4 = OC_Config->Pulse;
000044  6849              LDR      r1,[r1,#4]
000046  6401              STR      r1,[r0,#0x40]
;;;5724     
;;;5725     /* Write to TIMx CCER */
;;;5726     TIMx->CCER = tmpccer;
000048  6204              STR      r4,[r0,#0x20]
;;;5727   }
00004a  bdf0              POP      {r4-r7,pc}
;;;5728   
                          ENDP

                  |L99.76|
                          DCD      0xfeff8fff
                  |L99.80|
                          DCD      0x40010000
                  |L99.84|
                          DCD      0x40010400

                          AREA ||i.TIM_SlaveTimer_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_SlaveTimer_SetConfig PROC
;;;5735     */
;;;5736   static void TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
000000  b4f0              PUSH     {r4-r7}
;;;5737                                 TIM_SlaveConfigTypeDef * sSlaveConfig)
;;;5738   {
;;;5739     uint32_t tmpsmcr = 0;
;;;5740     uint32_t tmpccmr1 = 0;
;;;5741     uint32_t tmpccer = 0;
;;;5742   
;;;5743    /* Get the TIMx SMCR register value */
;;;5744     tmpsmcr = htim->Instance->SMCR;
;;;5745   
;;;5746     /* Reset the Trigger Selection Bits */
;;;5747     tmpsmcr &= ~TIM_SMCR_TS;
;;;5748     /* Set the Input Trigger source */
;;;5749     tmpsmcr |= sSlaveConfig->InputTrigger;
;;;5750   
;;;5751     /* Reset the slave mode Bits */
;;;5752     tmpsmcr &= ~TIM_SMCR_SMS;
000002  e9d12300          LDRD     r2,r3,[r1,#0]
000006  6804              LDR      r4,[r0,#0]            ;5744
000008  4e1c              LDR      r6,|L100.124|
00000a  68a5              LDR      r5,[r4,#8]            ;5744
00000c  f0250570          BIC      r5,r5,#0x70           ;5747
000010  432b              ORRS     r3,r3,r5              ;5749
000012  4033              ANDS     r3,r3,r6
;;;5753     /* Set the slave mode */
;;;5754     tmpsmcr |= sSlaveConfig->SlaveMode;
000014  431a              ORRS     r2,r2,r3
;;;5755   
;;;5756     /* Write to TIMx SMCR */
;;;5757     htim->Instance->SMCR = tmpsmcr;
000016  60a2              STR      r2,[r4,#8]
;;;5758    
;;;5759     /* Configure the trigger prescaler, filter, and polarity */
;;;5760     switch (sSlaveConfig->InputTrigger)
000018  684a              LDR      r2,[r1,#4]
00001a  f0120f0f          TST      r2,#0xf
00001e  d11f              BNE      |L100.96|
000020  1112              ASRS     r2,r2,#4
000022  2a08              CMP      r2,#8
000024  d21c              BCS      |L100.96|
000026  e8dff002          TBB      [pc,r2]
00002a  1b1b              DCB      0x1b,0x1b
00002c  1b1b0b1d          DCB      0x1b,0x1b,0x0b,0x1d
000030  2304              DCB      0x23,0x04
;;;5761     {
;;;5762     case TIM_TS_ETRF:
;;;5763       {
;;;5764         /* Check the parameters */
;;;5765         assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
;;;5766         assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));
;;;5767         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;5768         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;5769         /* Configure the ETR Trigger source */
;;;5770         TIM_ETR_SetConfig(htim->Instance, 
000032  688a              LDR      r2,[r1,#8]
000034  6800              LDR      r0,[r0,#0]
000036  e9d11303          LDRD     r1,r3,[r1,#0xc]
00003a  bcf0              POP      {r4-r7}
00003c  f7ffbffe          B.W      TIM_ETR_SetConfig
;;;5771                           sSlaveConfig->TriggerPrescaler, 
;;;5772                           sSlaveConfig->TriggerPolarity, 
;;;5773                           sSlaveConfig->TriggerFilter);
;;;5774       }
;;;5775       break;
;;;5776       
;;;5777     case TIM_TS_TI1F_ED:
;;;5778       {
;;;5779         /* Check the parameters */
;;;5780         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;5781         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;5782         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;5783     
;;;5784         /* Disable the Channel 1: Reset the CC1E Bit */
;;;5785         tmpccer = htim->Instance->CCER;
000040  6802              LDR      r2,[r0,#0]
000042  6a13              LDR      r3,[r2,#0x20]
;;;5786         htim->Instance->CCER &= ~TIM_CCER_CC1E;
000044  6a14              LDR      r4,[r2,#0x20]
000046  f0240401          BIC      r4,r4,#1
00004a  6214              STR      r4,[r2,#0x20]
;;;5787         tmpccmr1 = htim->Instance->CCMR1;    
;;;5788         
;;;5789         /* Set the filter */
;;;5790         tmpccmr1 &= ~TIM_CCMR1_IC1F;
;;;5791         tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4);
00004c  6802              LDR      r2,[r0,#0]
00004e  690c              LDR      r4,[r1,#0x10]         ;5787
000050  6991              LDR      r1,[r2,#0x18]         ;5787
000052  f02101f0          BIC      r1,r1,#0xf0           ;5790
000056  ea411104          ORR      r1,r1,r4,LSL #4
;;;5792         
;;;5793         /* Write to TIMx CCMR1 and CCER registers */
;;;5794         htim->Instance->CCMR1 = tmpccmr1;
00005a  6191              STR      r1,[r2,#0x18]
;;;5795         htim->Instance->CCER = tmpccer;                               
00005c  6800              LDR      r0,[r0,#0]
00005e  6203              STR      r3,[r0,#0x20]
                  |L100.96|
;;;5796                                  
;;;5797       }
;;;5798       break;
;;;5799       
;;;5800     case TIM_TS_TI1FP1:
;;;5801       {
;;;5802         /* Check the parameters */
;;;5803         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;5804         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;5805         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;5806   
;;;5807         /* Configure TI1 Filter and Polarity */
;;;5808         TIM_TI1_ConfigInputStage(htim->Instance,
;;;5809                                  sSlaveConfig->TriggerPolarity,
;;;5810                                  sSlaveConfig->TriggerFilter);
;;;5811       }
;;;5812       break;
;;;5813       
;;;5814     case TIM_TS_TI2FP2:
;;;5815       {
;;;5816         /* Check the parameters */
;;;5817         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5818         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;5819         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;5820     
;;;5821         /* Configure TI2 Filter and Polarity */
;;;5822         TIM_TI2_ConfigInputStage(htim->Instance,
;;;5823                                   sSlaveConfig->TriggerPolarity,
;;;5824                                   sSlaveConfig->TriggerFilter);
;;;5825       }
;;;5826       break;
;;;5827       
;;;5828     case TIM_TS_ITR0:
;;;5829       {
;;;5830         /* Check the parameter */
;;;5831         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5832       }
;;;5833       break;
;;;5834       
;;;5835     case TIM_TS_ITR1:
;;;5836       {
;;;5837         /* Check the parameter */
;;;5838         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5839       }
;;;5840       break;
;;;5841       
;;;5842     case TIM_TS_ITR2:
;;;5843       {
;;;5844         /* Check the parameter */
;;;5845         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5846       }
;;;5847       break;
;;;5848       
;;;5849     case TIM_TS_ITR3:
;;;5850       {
;;;5851         /* Check the parameter */
;;;5852         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5853       }
;;;5854       break;
;;;5855          
;;;5856     default:
;;;5857       break;
;;;5858     }
;;;5859   }
000060  bcf0              POP      {r4-r7}
000062  4770              BX       lr
000064  690a              LDR      r2,[r1,#0x10]         ;5808
000066  6800              LDR      r0,[r0,#0]            ;5808
000068  6889              LDR      r1,[r1,#8]            ;5808
00006a  bcf0              POP      {r4-r7}               ;5808
00006c  f7ffbffe          B.W      TIM_TI1_ConfigInputStage
000070  690a              LDR      r2,[r1,#0x10]         ;5822
000072  6800              LDR      r0,[r0,#0]            ;5822
000074  6889              LDR      r1,[r1,#8]            ;5822
000076  bcf0              POP      {r4-r7}               ;5822
000078  f7ffbffe          B.W      TIM_TI2_ConfigInputStage
;;;5860   
                          ENDP

                  |L100.124|
                          DCD      0xfffefff8

                          AREA ||i.TIM_TI1_ConfigInputStage||, CODE, READONLY, ALIGN=1

                  TIM_TI1_ConfigInputStage PROC
;;;5927     */
;;;5928   static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
000000  b510              PUSH     {r4,lr}
;;;5929   {
;;;5930     uint32_t tmpccmr1 = 0;
;;;5931     uint32_t tmpccer = 0;
;;;5932     
;;;5933     /* Disable the Channel 1: Reset the CC1E Bit */
;;;5934     tmpccer = TIMx->CCER;
000002  6a03              LDR      r3,[r0,#0x20]
;;;5935     TIMx->CCER &= ~TIM_CCER_CC1E;
000004  6a04              LDR      r4,[r0,#0x20]
;;;5936     tmpccmr1 = TIMx->CCMR1;    
;;;5937     
;;;5938     /* Set the filter */
;;;5939     tmpccmr1 &= ~TIM_CCMR1_IC1F;
;;;5940     tmpccmr1 |= (TIM_ICFilter << 4);
;;;5941     
;;;5942     /* Select the Polarity and set the CC1E Bit */
;;;5943     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
000006  f023030a          BIC      r3,r3,#0xa
00000a  f0240401          BIC      r4,r4,#1              ;5935
00000e  6204              STR      r4,[r0,#0x20]         ;5935
000010  6984              LDR      r4,[r0,#0x18]         ;5936
;;;5944     tmpccer |= TIM_ICPolarity;
000012  430b              ORRS     r3,r3,r1
000014  f02401f0          BIC      r1,r4,#0xf0           ;5939
000018  ea411102          ORR      r1,r1,r2,LSL #4       ;5940
;;;5945     
;;;5946     /* Write to TIMx CCMR1 and CCER registers */
;;;5947     TIMx->CCMR1 = tmpccmr1;
00001c  6181              STR      r1,[r0,#0x18]
;;;5948     TIMx->CCER = tmpccer;
00001e  6203              STR      r3,[r0,#0x20]
;;;5949   }
000020  bd10              POP      {r4,pc}
;;;5950   
                          ENDP


                          AREA ||i.TIM_TI1_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_TI1_SetConfig PROC
;;;5880     */
;;;5881   void TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
000000  b570              PUSH     {r4-r6,lr}
;;;5882                          uint32_t TIM_ICFilter)
;;;5883   {
;;;5884     uint32_t tmpccmr1 = 0;
;;;5885     uint32_t tmpccer = 0;
;;;5886   
;;;5887     /* Disable the Channel 1: Reset the CC1E Bit */
;;;5888     TIMx->CCER &= ~TIM_CCER_CC1E;
000002  6a04              LDR      r4,[r0,#0x20]
;;;5889     tmpccmr1 = TIMx->CCMR1;
;;;5890     tmpccer = TIMx->CCER;
;;;5891   
;;;5892     /* Select the Input */
;;;5893     if(IS_TIM_CC2_INSTANCE(TIMx) != RESET)
000004  4d17              LDR      r5,|L102.100|
000006  f0240401          BIC      r4,r4,#1              ;5888
00000a  6204              STR      r4,[r0,#0x20]         ;5888
00000c  42a8              CMP      r0,r5
00000e  6984              LDR      r4,[r0,#0x18]         ;5889
000010  6a05              LDR      r5,[r0,#0x20]         ;5890
000012  d014              BEQ      |L102.62|
000014  f1b04f80          CMP      r0,#0x40000000
000018  d011              BEQ      |L102.62|
00001a  4e13              LDR      r6,|L102.104|
00001c  42b0              CMP      r0,r6
00001e  d00e              BEQ      |L102.62|
000020  4e12              LDR      r6,|L102.108|
000022  42b0              CMP      r0,r6
000024  d00b              BEQ      |L102.62|
000026  4e12              LDR      r6,|L102.112|
000028  42b0              CMP      r0,r6
00002a  d008              BEQ      |L102.62|
00002c  4e11              LDR      r6,|L102.116|
00002e  42b0              CMP      r0,r6
000030  d005              BEQ      |L102.62|
000032  4e11              LDR      r6,|L102.120|
000034  42b0              CMP      r0,r6
000036  d002              BEQ      |L102.62|
000038  4e10              LDR      r6,|L102.124|
00003a  42b0              CMP      r0,r6
00003c  d103              BNE      |L102.70|
                  |L102.62|
;;;5894     {
;;;5895       tmpccmr1 &= ~TIM_CCMR1_CC1S;
00003e  f0240403          BIC      r4,r4,#3
;;;5896       tmpccmr1 |= TIM_ICSelection;
000042  4314              ORRS     r4,r4,r2
000044  e001              B        |L102.74|
                  |L102.70|
;;;5897     } 
;;;5898     else
;;;5899     {
;;;5900       tmpccmr1 |= TIM_CCMR1_CC1S_0;
000046  f0440401          ORR      r4,r4,#1
                  |L102.74|
00004a  071a              LSLS     r2,r3,#28
;;;5901     }
;;;5902     
;;;5903     /* Set the filter */
;;;5904     tmpccmr1 &= ~TIM_CCMR1_IC1F;
00004c  f02403f0          BIC      r3,r4,#0xf0
;;;5905     tmpccmr1 |= ((TIM_ICFilter << 4) & TIM_CCMR1_IC1F);
;;;5906   
;;;5907     /* Select the Polarity and set the CC1E Bit */
;;;5908     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
000050  f025040a          BIC      r4,r5,#0xa
;;;5909     tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));
000054  f001010a          AND      r1,r1,#0xa
000058  4321              ORRS     r1,r1,r4
00005a  ea436212          ORR      r2,r3,r2,LSR #24      ;5905
;;;5910   
;;;5911     /* Write to TIMx CCMR1 and CCER registers */
;;;5912     TIMx->CCMR1 = tmpccmr1;
00005e  6182              STR      r2,[r0,#0x18]
;;;5913     TIMx->CCER = tmpccer;
000060  6201              STR      r1,[r0,#0x20]
;;;5914   }
000062  bd70              POP      {r4-r6,pc}
;;;5915   
                          ENDP

                  |L102.100|
                          DCD      0x40010000
                  |L102.104|
                          DCD      0x40000400
                  |L102.108|
                          DCD      0x40000800
                  |L102.112|
                          DCD      0x40000c00
                  |L102.116|
                          DCD      0x40010400
                  |L102.120|
                          DCD      0x40014000
                  |L102.124|
                          DCD      0x40001800

                          AREA ||i.TIM_TI2_ConfigInputStage||, CODE, READONLY, ALIGN=1

                  TIM_TI2_ConfigInputStage PROC
;;;6010     */
;;;6011   static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
000000  b510              PUSH     {r4,lr}
;;;6012   {
;;;6013   uint32_t tmpccmr1 = 0;
;;;6014     uint32_t tmpccer = 0;
;;;6015     
;;;6016     /* Disable the Channel 2: Reset the CC2E Bit */
;;;6017     TIMx->CCER &= ~TIM_CCER_CC2E;
000002  6a03              LDR      r3,[r0,#0x20]
000004  f0230310          BIC      r3,r3,#0x10
000008  6203              STR      r3,[r0,#0x20]
;;;6018     tmpccmr1 = TIMx->CCMR1;
00000a  6983              LDR      r3,[r0,#0x18]
;;;6019     tmpccer = TIMx->CCER;
00000c  6a04              LDR      r4,[r0,#0x20]
;;;6020     
;;;6021     /* Set the filter */
;;;6022     tmpccmr1 &= ~TIM_CCMR1_IC2F;
00000e  f4234370          BIC      r3,r3,#0xf000
;;;6023     tmpccmr1 |= (TIM_ICFilter << 12);
;;;6024   
;;;6025     /* Select the Polarity and set the CC2E Bit */
;;;6026     tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
000012  f02404a0          BIC      r4,r4,#0xa0
000016  ea433202          ORR      r2,r3,r2,LSL #12      ;6023
;;;6027     tmpccer |= (TIM_ICPolarity << 4);
;;;6028   
;;;6029     /* Write to TIMx CCMR1 and CCER registers */
;;;6030     TIMx->CCMR1 = tmpccmr1 ;
00001a  6182              STR      r2,[r0,#0x18]
00001c  ea441101          ORR      r1,r4,r1,LSL #4       ;6027
;;;6031     TIMx->CCER = tmpccer;
000020  6201              STR      r1,[r0,#0x20]
;;;6032   }
000022  bd10              POP      {r4,pc}
;;;6033   
                          ENDP


                          AREA ||i.TIM_TI2_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_TI2_SetConfig PROC
;;;5970     */
;;;5971   static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
000000  b570              PUSH     {r4-r6,lr}
;;;5972                          uint32_t TIM_ICFilter)
;;;5973   {
;;;5974     uint32_t tmpccmr1 = 0;
;;;5975     uint32_t tmpccer = 0;
;;;5976   
;;;5977     /* Disable the Channel 2: Reset the CC2E Bit */
;;;5978     TIMx->CCER &= ~TIM_CCER_CC2E;
000002  6a05              LDR      r5,[r0,#0x20]
;;;5979     tmpccmr1 = TIMx->CCMR1;
;;;5980     tmpccer = TIMx->CCER;
;;;5981   
;;;5982     /* Select the Input */
;;;5983     tmpccmr1 &= ~TIM_CCMR1_CC2S;
;;;5984     tmpccmr1 |= (TIM_ICSelection << 8);
;;;5985   
;;;5986     /* Set the filter */
;;;5987     tmpccmr1 &= ~TIM_CCMR1_IC2F;
;;;5988     tmpccmr1 |= ((TIM_ICFilter << 12) & TIM_CCMR1_IC2F);
;;;5989   
;;;5990     /* Select the Polarity and set the CC2E Bit */
;;;5991     tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
;;;5992     tmpccer |= ((TIM_ICPolarity << 4) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
000004  24a0              MOVS     r4,#0xa0
000006  f64f76ff          MOV      r6,#0xffff            ;5988
00000a  ea063303          AND      r3,r6,r3,LSL #12      ;5988
00000e  f0250510          BIC      r5,r5,#0x10           ;5978
000012  6205              STR      r5,[r0,#0x20]         ;5978
000014  ea041101          AND      r1,r4,r1,LSL #4
000018  6984              LDR      r4,[r0,#0x18]         ;5979
00001a  6a05              LDR      r5,[r0,#0x20]         ;5980
00001c  f4247440          BIC      r4,r4,#0x300          ;5983
000020  f02505a0          BIC      r5,r5,#0xa0           ;5991
000024  ea442202          ORR      r2,r4,r2,LSL #8       ;5984
000028  4329              ORRS     r1,r1,r5
00002a  f4224270          BIC      r2,r2,#0xf000         ;5987
00002e  4313              ORRS     r3,r3,r2              ;5988
;;;5993   
;;;5994     /* Write to TIMx CCMR1 and CCER registers */
;;;5995     TIMx->CCMR1 = tmpccmr1 ;
000030  6183              STR      r3,[r0,#0x18]
;;;5996     TIMx->CCER = tmpccer;
000032  6201              STR      r1,[r0,#0x20]
;;;5997   }
000034  bd70              POP      {r4-r6,pc}
;;;5998   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F7_V1.11.0\\Drivers\\STM32F7xx_HAL_Driver\\Src\\stm32f7xx_hal_tim.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f7xx_hal_tim_c_a9d95b52____REV16|
#line 468 "D:\\Program_Files_x86\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.3.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___19_stm32f7xx_hal_tim_c_a9d95b52____REV16| PROC
#line 469

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f7xx_hal_tim_c_a9d95b52____REVSH|
#line 483
|__asm___19_stm32f7xx_hal_tim_c_a9d95b52____REVSH| PROC
#line 484

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f7xx_hal_tim_c_a9d95b52____RRX|
#line 670
|__asm___19_stm32f7xx_hal_tim_c_a9d95b52____RRX| PROC
#line 671

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
