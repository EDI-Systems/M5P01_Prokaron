; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f7xx_hal_tim_ex.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f7xx_hal_tim_ex.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Core -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Inc -I.\Source -I.\Drivers -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6-FPU\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f7xx_hal_tim_ex.crf ..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_tim_ex.c]
                          THUMB

                          AREA ||i.HAL_TIMEx_BreakCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_BreakCallback PROC
;;;1990     */
;;;1991   __weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1992   {
;;;1993     /* Prevent unused argument(s) compilation warning */
;;;1994     UNUSED(htim);
;;;1995    
;;;1996     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1997               the HAL_TIMEx_BreakCallback could be implemented in the user file
;;;1998      */
;;;1999   }
;;;2000   
                          ENDP


                          AREA ||i.HAL_TIMEx_CommutationCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_CommutationCallback PROC
;;;1974     */
;;;1975   __weak void HAL_TIMEx_CommutationCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1976   {
;;;1977     /* Prevent unused argument(s) compilation warning */
;;;1978     UNUSED(htim);
;;;1979    
;;;1980     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1981               the HAL_TIMEx_CommutationCallback could be implemented in the user file
;;;1982      */
;;;1983   }
;;;1984   
                          ENDP


                          AREA ||i.HAL_TIMEx_ConfigBreakDeadTime||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_ConfigBreakDeadTime PROC
;;;1713     */ 
;;;1714   HAL_StatusTypeDef HAL_TIMEx_ConfigBreakDeadTime(TIM_HandleTypeDef *htim, 
000000  b5f0              PUSH     {r4-r7,lr}
;;;1715                                                 TIM_BreakDeadTimeConfigTypeDef * sBreakDeadTimeConfig)
;;;1716   {
;;;1717     uint32_t tmpbdtr = 0;
;;;1718     
;;;1719     /* Check the parameters */
;;;1720     assert_param(IS_TIM_BREAK_INSTANCE(htim->Instance));
;;;1721     assert_param(IS_TIM_OSSR_STATE(sBreakDeadTimeConfig->OffStateRunMode));
;;;1722     assert_param(IS_TIM_OSSI_STATE(sBreakDeadTimeConfig->OffStateIDLEMode));
;;;1723     assert_param(IS_TIM_LOCK_LEVEL(sBreakDeadTimeConfig->LockLevel));
;;;1724     assert_param(IS_TIM_DEADTIME(sBreakDeadTimeConfig->DeadTime));
;;;1725     assert_param(IS_TIM_BREAK_STATE(sBreakDeadTimeConfig->BreakState));
;;;1726     assert_param(IS_TIM_BREAK_POLARITY(sBreakDeadTimeConfig->BreakPolarity));
;;;1727     assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig->BreakFilter));
;;;1728     assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(sBreakDeadTimeConfig->AutomaticOutput));
;;;1729     assert_param(IS_TIM_BREAK2_STATE(sBreakDeadTimeConfig->Break2State));
;;;1730     assert_param(IS_TIM_BREAK2_POLARITY(sBreakDeadTimeConfig->Break2Polarity));
;;;1731     assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig->Break2Filter));
;;;1732     
;;;1733     /* Check input state */
;;;1734     __HAL_LOCK(htim);
000002  6bc2              LDR      r2,[r0,#0x3c]
000004  2a01              CMP      r2,#1
000006  d03b              BEQ      |L3.128|
000008  2201              MOVS     r2,#1
00000a  63c2              STR      r2,[r0,#0x3c]
00000c  e9d13202          LDRD     r3,r2,[r1,#8]
;;;1735   
;;;1736     /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
;;;1737        the OSSI State, the dead time value and the Automatic Output Enable Bit */
;;;1738     /* Set the BDTR bits */
;;;1739     MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, sBreakDeadTimeConfig->DeadTime);
;;;1740     MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
;;;1741     MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig->OffStateIDLEMode);
;;;1742     MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);
;;;1743     MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);
;;;1744     MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
;;;1745     MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
;;;1746     MODIFY_REG(tmpbdtr, TIM_BDTR_MOE, sBreakDeadTimeConfig->AutomaticOutput);
;;;1747     MODIFY_REG(tmpbdtr, TIM_BDTR_BKF, (sBreakDeadTimeConfig->BreakFilter << BDTR_BKF_SHIFT));
000010  8b0d              LDRH     r5,[r1,#0x18]
;;;1748     
;;;1749     if (IS_TIM_BKIN2_INSTANCE(htim->Instance))
000012  4e1c              LDR      r6,|L3.132|
000014  f4227240          BIC      r2,r2,#0x300          ;1740
000018  431a              ORRS     r2,r2,r3              ;1740
00001a  e9d13400          LDRD     r3,r4,[r1,#0]         ;1741
00001e  f4226280          BIC      r2,r2,#0x400          ;1741
000022  4322              ORRS     r2,r2,r4              ;1741
000024  f4226200          BIC      r2,r2,#0x800          ;1742
000028  431a              ORRS     r2,r2,r3              ;1742
00002a  e9d14304          LDRD     r4,r3,[r1,#0x10]      ;1743
00002e  f4225280          BIC      r2,r2,#0x1000         ;1743
000032  4322              ORRS     r2,r2,r4              ;1743
000034  6a8c              LDR      r4,[r1,#0x28]         ;1745
000036  f4225200          BIC      r2,r2,#0x2000         ;1744
00003a  431a              ORRS     r2,r2,r3              ;1744
00003c  6803              LDR      r3,[r0,#0]
00003e  f4224280          BIC      r2,r2,#0x4000         ;1745
000042  4322              ORRS     r2,r2,r4              ;1745
000044  f4224200          BIC      r2,r2,#0x8000         ;1746
000048  4322              ORRS     r2,r2,r4              ;1746
00004a  2400              MOVS     r4,#0                 ;1739
00004c  f4222270          BIC      r2,r2,#0xf0000        ;1747
000050  42b3              CMP      r3,r6
000052  ea424205          ORR      r2,r2,r5,LSL #16      ;1747
000056  d002              BEQ      |L3.94|
000058  4d0b              LDR      r5,|L3.136|
00005a  42ab              CMP      r3,r5
00005c  d10c              BNE      |L3.120|
                  |L3.94|
;;;1750     {
;;;1751       assert_param(IS_TIM_BREAK2_STATE(sBreakDeadTimeConfig->Break2State));
;;;1752       assert_param(IS_TIM_BREAK2_POLARITY(sBreakDeadTimeConfig->Break2Polarity));
;;;1753       assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig->Break2Filter));
;;;1754       
;;;1755       /* Set the BREAK2 input related BDTR bits */
;;;1756       MODIFY_REG(tmpbdtr, TIM_BDTR_BK2F, (sBreakDeadTimeConfig->Break2Filter << BDTR_BK2F_SHIFT));
00005e  8c8e              LDRH     r6,[r1,#0x24]
000060  f4220770          BIC      r7,r2,#0xf00000
000064  e9d12507          LDRD     r2,r5,[r1,#0x1c]
000068  ea475106          ORR      r1,r7,r6,LSL #20
;;;1757       MODIFY_REG(tmpbdtr, TIM_BDTR_BK2E, sBreakDeadTimeConfig->Break2State);
00006c  f0217180          BIC      r1,r1,#0x1000000
000070  4311              ORRS     r1,r1,r2
;;;1758       MODIFY_REG(tmpbdtr, TIM_BDTR_BK2P, sBreakDeadTimeConfig->Break2Polarity);
000072  f0217200          BIC      r2,r1,#0x2000000
000076  432a              ORRS     r2,r2,r5
                  |L3.120|
;;;1759     }
;;;1760     
;;;1761   
;;;1762     
;;;1763     /* Set TIMx_BDTR */
;;;1764     htim->Instance->BDTR = tmpbdtr;
000078  645a              STR      r2,[r3,#0x44]
;;;1765     
;;;1766     __HAL_UNLOCK(htim);
;;;1767     
;;;1768     return HAL_OK;
00007a  63c4              STR      r4,[r0,#0x3c]
00007c  2000              MOVS     r0,#0
;;;1769   }
00007e  bdf0              POP      {r4-r7,pc}
                  |L3.128|
000080  2002              MOVS     r0,#2                 ;1734
000082  bdf0              POP      {r4-r7,pc}
;;;1770   #if defined (STM32F765xx) || defined(STM32F767xx) || defined(STM32F769xx) || defined(STM32F777xx) || defined(STM32F779xx)
                          ENDP

                  |L3.132|
                          DCD      0x40010000
                  |L3.136|
                          DCD      0x40010400

                          AREA ||i.HAL_TIMEx_ConfigBreakInput||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_ConfigBreakInput PROC
;;;1780     */
;;;1781   HAL_StatusTypeDef HAL_TIMEx_ConfigBreakInput(TIM_HandleTypeDef *htim,
000000  b5f0              PUSH     {r4-r7,lr}
;;;1782                                                uint32_t BreakInput,
;;;1783                                                TIMEx_BreakInputConfigTypeDef *sBreakInputConfig)
;;;1784   
;;;1785   {
;;;1786     uint32_t tmporx = 0;
;;;1787     uint32_t bkin_enable_mask = 0;
000002  2300              MOVS     r3,#0
;;;1788     uint32_t bkin_polarity_mask = 0;
;;;1789     uint32_t bkin_enable_bitpos = 0;
;;;1790     uint32_t bkin_polarity_bitpos = 0;
;;;1791   
;;;1792     /* Check the parameters */
;;;1793     assert_param(IS_TIM_BREAK_INSTANCE(htim->Instance));
;;;1794     assert_param(IS_TIM_BREAKINPUT(BreakInput));
;;;1795     assert_param(IS_TIM_BREAKINPUTSOURCE(sBreakInputConfig->Source));
;;;1796     assert_param(IS_TIM_BREAKINPUTSOURCE_STATE(sBreakInputConfig->Enable));
;;;1797     if (sBreakInputConfig->Source != TIM_BREAKINPUTSOURCE_DFSDM1)
;;;1798     {
;;;1799       assert_param(IS_TIM_BREAKINPUTSOURCE_POLARITY(sBreakInputConfig->Polarity));
;;;1800     }
;;;1801   
;;;1802     /* Check input state */
;;;1803     __HAL_LOCK(htim);
000004  6bc5              LDR      r5,[r0,#0x3c]
000006  461c              MOV      r4,r3                 ;1788
000008  461f              MOV      r7,r3                 ;1789
00000a  2d01              CMP      r5,#1
00000c  461e              MOV      r6,r3                 ;1790
00000e  d00a              BEQ      |L4.38|
000010  2501              MOVS     r5,#1
;;;1804     
;;;1805     switch(sBreakInputConfig->Source)
000012  63c5              STR      r5,[r0,#0x3c]
000014  f8d2c000          LDR      r12,[r2,#0]
000018  f1bc0f01          CMP      r12,#1
00001c  d005              BEQ      |L4.42|
00001e  f1bc0f08          CMP      r12,#8
000022  d109              BNE      |L4.56|
000024  e005              B        |L4.50|
                  |L4.38|
000026  2002              MOVS     r0,#2                 ;1803
;;;1806     {
;;;1807     case TIM_BREAKINPUTSOURCE_BKIN:
;;;1808       {
;;;1809         bkin_enable_mask = TIM1_AF1_BKINE;
;;;1810         bkin_enable_bitpos = 0;
;;;1811         bkin_polarity_mask = TIM1_AF1_BKINP;
;;;1812         bkin_polarity_bitpos = 9;
;;;1813       }
;;;1814       break;
;;;1815     
;;;1816     case TIM_BREAKINPUTSOURCE_DFSDM1:
;;;1817       {
;;;1818         bkin_enable_mask = TIM1_AF1_BKDF1BKE;
;;;1819         bkin_enable_bitpos = 8;
;;;1820       }
;;;1821       break;    
;;;1822   
;;;1823     default:
;;;1824       break;
;;;1825     }
;;;1826     
;;;1827     switch(BreakInput)
;;;1828     {
;;;1829       case TIM_BREAKINPUT_BRK:
;;;1830         {
;;;1831           /* Get the TIMx_AF1 register value */
;;;1832           tmporx = htim->Instance->AF1;
;;;1833           
;;;1834           /* Enable the break input */
;;;1835           tmporx &= ~bkin_enable_mask;
;;;1836           tmporx |= (sBreakInputConfig->Enable << bkin_enable_bitpos) & bkin_enable_mask;
;;;1837           
;;;1838           if(sBreakInputConfig->Source != TIM_BREAKINPUTSOURCE_DFSDM1)
;;;1839           {
;;;1840             tmporx &= ~bkin_polarity_mask;
;;;1841             tmporx |= (sBreakInputConfig->Polarity << bkin_polarity_bitpos) & bkin_polarity_mask;
;;;1842           }
;;;1843           /* Set TIMx_AF1 */
;;;1844           htim->Instance->AF1 = tmporx;        
;;;1845         }
;;;1846           break;
;;;1847       case TIM_BREAKINPUT_BRK2:
;;;1848         {
;;;1849           /* Get the TIMx_AF2 register value */
;;;1850           tmporx = htim->Instance->AF2;
;;;1851   
;;;1852           /* Enable the break input */
;;;1853           tmporx &= ~bkin_enable_mask;
;;;1854           tmporx |= (sBreakInputConfig->Enable << bkin_enable_bitpos) & bkin_enable_mask;
;;;1855   
;;;1856           if (sBreakInputConfig->Source != TIM_BREAKINPUTSOURCE_DFSDM1)
;;;1857           {
;;;1858             tmporx &= ~bkin_polarity_mask;
;;;1859             tmporx |= (sBreakInputConfig->Polarity << bkin_polarity_bitpos) & bkin_polarity_mask;
;;;1860           }
;;;1861   
;;;1862           /* Set TIMx_AF2 */
;;;1863           htim->Instance->AF2 = tmporx;        
;;;1864         }
;;;1865         break;    
;;;1866     default:
;;;1867       break;
;;;1868     }
;;;1869     
;;;1870     __HAL_UNLOCK(htim);
;;;1871   
;;;1872     return HAL_OK;
;;;1873   }
000028  bdf0              POP      {r4-r7,pc}
                  |L4.42|
00002a  2301              MOVS     r3,#1                 ;1809
00002c  025c              LSLS     r4,r3,#9              ;1811
00002e  2609              MOVS     r6,#9                 ;1812
000030  e002              B        |L4.56|
                  |L4.50|
000032  2708              MOVS     r7,#8                 ;1819
000034  f44f7380          MOV      r3,#0x100             ;1818
                  |L4.56|
000038  2901              CMP      r1,#1                 ;1827
00003a  d002              BEQ      |L4.66|
00003c  2902              CMP      r1,#2                 ;1827
00003e  d129              BNE      |L4.148|
000040  e014              B        |L4.108|
                  |L4.66|
000042  f8d0e000          LDR      lr,[r0,#0]            ;1836
000046  6851              LDR      r1,[r2,#4]            ;1832
000048  f8de5060          LDR      r5,[lr,#0x60]         ;1832
00004c  40b9              LSLS     r1,r1,r7              ;1836
00004e  4019              ANDS     r1,r1,r3              ;1836
000050  439d              BICS     r5,r5,r3              ;1835
000052  f1bc0f08          CMP      r12,#8                ;1838
000056  ea410105          ORR      r1,r1,r5              ;1836
00005a  d004              BEQ      |L4.102|
00005c  6892              LDR      r2,[r2,#8]            ;1841
00005e  43a1              BICS     r1,r1,r4              ;1840
000060  40b2              LSLS     r2,r2,r6              ;1841
000062  4022              ANDS     r2,r2,r4              ;1841
000064  4311              ORRS     r1,r1,r2              ;1841
                  |L4.102|
000066  f8ce1060          STR      r1,[lr,#0x60]         ;1844
00006a  e013              B        |L4.148|
                  |L4.108|
00006c  f8d0e000          LDR      lr,[r0,#0]            ;1854
000070  6851              LDR      r1,[r2,#4]            ;1850
000072  f8de5064          LDR      r5,[lr,#0x64]         ;1850
000076  40b9              LSLS     r1,r1,r7              ;1854
000078  4019              ANDS     r1,r1,r3              ;1854
00007a  439d              BICS     r5,r5,r3              ;1853
00007c  f1bc0f08          CMP      r12,#8                ;1856
000080  ea410105          ORR      r1,r1,r5              ;1854
000084  d004              BEQ      |L4.144|
000086  6892              LDR      r2,[r2,#8]            ;1859
000088  43a1              BICS     r1,r1,r4              ;1858
00008a  40b2              LSLS     r2,r2,r6              ;1859
00008c  4022              ANDS     r2,r2,r4              ;1859
00008e  4311              ORRS     r1,r1,r2              ;1859
                  |L4.144|
000090  f8ce1064          STR      r1,[lr,#0x64]         ;1863
                  |L4.148|
000094  2100              MOVS     r1,#0                 ;1870
000096  63c1              STR      r1,[r0,#0x3c]         ;1872
000098  4608              MOV      r0,r1                 ;1872
00009a  bdf0              POP      {r4-r7,pc}
;;;1874   #endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
                          ENDP


                          AREA ||i.HAL_TIMEx_ConfigCommutationEvent||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_ConfigCommutationEvent PROC
;;;1503     */
;;;1504   HAL_StatusTypeDef HAL_TIMEx_ConfigCommutationEvent(TIM_HandleTypeDef *htim, uint32_t  InputTrigger, uint32_t  CommutationSource)
000000  b510              PUSH     {r4,lr}
;;;1505   {
;;;1506     /* Check the parameters */
;;;1507     assert_param(IS_TIM_ADVANCED_INSTANCE(htim->Instance));
;;;1508     assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
;;;1509     
;;;1510     __HAL_LOCK(htim);
000002  6bc3              LDR      r3,[r0,#0x3c]
000004  2b01              CMP      r3,#1
000006  d009              BEQ      |L5.28|
000008  2301              MOVS     r3,#1
00000a  63c3              STR      r3,[r0,#0x3c]
00000c  b141              CBZ      r1,|L5.32|
;;;1511     
;;;1512     if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
00000e  2910              CMP      r1,#0x10
000010  d006              BEQ      |L5.32|
;;;1513         (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
000012  2920              CMP      r1,#0x20
000014  d004              BEQ      |L5.32|
000016  2930              CMP      r1,#0x30
000018  d002              BEQ      |L5.32|
00001a  e00a              B        |L5.50|
                  |L5.28|
00001c  2002              MOVS     r0,#2                 ;1510
;;;1514     {    
;;;1515       /* Select the Input trigger */
;;;1516       htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;1517       htim->Instance->SMCR |= InputTrigger;
;;;1518     }
;;;1519       
;;;1520     /* Select the Capture Compare preload feature */
;;;1521     htim->Instance->CR2 |= TIM_CR2_CCPC;
;;;1522     /* Select the Commutation event source */
;;;1523     htim->Instance->CR2 &= ~TIM_CR2_CCUS;
;;;1524     htim->Instance->CR2 |= CommutationSource;
;;;1525       
;;;1526     __HAL_UNLOCK(htim);
;;;1527     
;;;1528     return HAL_OK;
;;;1529   }
00001e  bd10              POP      {r4,pc}
                  |L5.32|
000020  6803              LDR      r3,[r0,#0]            ;1516
000022  689c              LDR      r4,[r3,#8]            ;1516
000024  f0240470          BIC      r4,r4,#0x70           ;1516
000028  609c              STR      r4,[r3,#8]            ;1516
00002a  6803              LDR      r3,[r0,#0]            ;1517
00002c  689c              LDR      r4,[r3,#8]            ;1517
00002e  430c              ORRS     r4,r4,r1              ;1517
000030  609c              STR      r4,[r3,#8]            ;1517
                  |L5.50|
000032  6801              LDR      r1,[r0,#0]            ;1521
000034  2300              MOVS     r3,#0                 ;1526
000036  684c              LDR      r4,[r1,#4]            ;1521
000038  f0440401          ORR      r4,r4,#1              ;1521
00003c  604c              STR      r4,[r1,#4]            ;1521
00003e  6801              LDR      r1,[r0,#0]            ;1523
000040  684c              LDR      r4,[r1,#4]            ;1523
000042  f0240404          BIC      r4,r4,#4              ;1523
000046  604c              STR      r4,[r1,#4]            ;1523
000048  6801              LDR      r1,[r0,#0]            ;1524
00004a  684c              LDR      r4,[r1,#4]            ;1524
00004c  4314              ORRS     r4,r4,r2              ;1524
00004e  604c              STR      r4,[r1,#4]            ;1524
000050  63c3              STR      r3,[r0,#0x3c]         ;1528
000052  4618              MOV      r0,r3                 ;1528
000054  bd10              POP      {r4,pc}
;;;1530   
                          ENDP


                          AREA ||i.HAL_TIMEx_ConfigCommutationEvent_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_ConfigCommutationEvent_DMA PROC
;;;1607     */
;;;1608   HAL_StatusTypeDef HAL_TIMEx_ConfigCommutationEvent_DMA(TIM_HandleTypeDef *htim, uint32_t  InputTrigger, uint32_t  CommutationSource)
000000  b510              PUSH     {r4,lr}
;;;1609   {
;;;1610     /* Check the parameters */
;;;1611     assert_param(IS_TIM_ADVANCED_INSTANCE(htim->Instance));
;;;1612     assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
;;;1613     
;;;1614     __HAL_LOCK(htim);
000002  6bc3              LDR      r3,[r0,#0x3c]
000004  2b01              CMP      r3,#1
000006  d009              BEQ      |L6.28|
000008  2301              MOVS     r3,#1
00000a  63c3              STR      r3,[r0,#0x3c]
00000c  b141              CBZ      r1,|L6.32|
;;;1615     
;;;1616     if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
00000e  2910              CMP      r1,#0x10
000010  d006              BEQ      |L6.32|
;;;1617         (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
000012  2920              CMP      r1,#0x20
000014  d004              BEQ      |L6.32|
000016  2930              CMP      r1,#0x30
000018  d002              BEQ      |L6.32|
00001a  e00a              B        |L6.50|
                  |L6.28|
00001c  2002              MOVS     r0,#2                 ;1614
;;;1618     {    
;;;1619       /* Select the Input trigger */
;;;1620       htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;1621       htim->Instance->SMCR |= InputTrigger;
;;;1622     }
;;;1623     
;;;1624     /* Select the Capture Compare preload feature */
;;;1625     htim->Instance->CR2 |= TIM_CR2_CCPC;
;;;1626     /* Select the Commutation event source */
;;;1627     htim->Instance->CR2 &= ~TIM_CR2_CCUS;
;;;1628     htim->Instance->CR2 |= CommutationSource;
;;;1629     
;;;1630     /* Enable the Commutation DMA Request */
;;;1631     /* Set the DMA Commutation Callback */
;;;1632     htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = HAL_TIMEx_DMACommutationCplt;     
;;;1633     /* Set the DMA error callback */
;;;1634     htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = HAL_TIM_DMAError;
;;;1635     
;;;1636     /* Enable the Commutation DMA Request */
;;;1637     __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_COM);
;;;1638   
;;;1639     __HAL_UNLOCK(htim);
;;;1640     
;;;1641     return HAL_OK;
;;;1642   }  
00001e  bd10              POP      {r4,pc}
                  |L6.32|
000020  6803              LDR      r3,[r0,#0]            ;1620
000022  689c              LDR      r4,[r3,#8]            ;1620
000024  f0240470          BIC      r4,r4,#0x70           ;1620
000028  609c              STR      r4,[r3,#8]            ;1620
00002a  6803              LDR      r3,[r0,#0]            ;1621
00002c  689c              LDR      r4,[r3,#8]            ;1621
00002e  430c              ORRS     r4,r4,r1              ;1621
000030  609c              STR      r4,[r3,#8]            ;1621
                  |L6.50|
000032  6801              LDR      r1,[r0,#0]            ;1625
000034  2300              MOVS     r3,#0                 ;1639
000036  684c              LDR      r4,[r1,#4]            ;1625
000038  f0440401          ORR      r4,r4,#1              ;1625
00003c  604c              STR      r4,[r1,#4]            ;1625
00003e  6801              LDR      r1,[r0,#0]            ;1627
000040  684c              LDR      r4,[r1,#4]            ;1627
000042  f0240404          BIC      r4,r4,#4              ;1627
000046  604c              STR      r4,[r1,#4]            ;1627
000048  6801              LDR      r1,[r0,#0]            ;1628
00004a  684c              LDR      r4,[r1,#4]            ;1628
00004c  4314              ORRS     r4,r4,r2              ;1628
00004e  604c              STR      r4,[r1,#4]            ;1628
000050  6b42              LDR      r2,[r0,#0x34]         ;1632
000052  4906              LDR      r1,|L6.108|
000054  6411              STR      r1,[r2,#0x40]         ;1634
000056  6b42              LDR      r2,[r0,#0x34]         ;1634
000058  4905              LDR      r1,|L6.112|
00005a  6511              STR      r1,[r2,#0x50]         ;1637
00005c  6801              LDR      r1,[r0,#0]            ;1637
00005e  68ca              LDR      r2,[r1,#0xc]          ;1637
000060  f4425200          ORR      r2,r2,#0x2000         ;1637
000064  60ca              STR      r2,[r1,#0xc]          ;1637
000066  63c3              STR      r3,[r0,#0x3c]         ;1641
000068  2000              MOVS     r0,#0                 ;1641
00006a  bd10              POP      {r4,pc}
;;;1643   
                          ENDP

                  |L6.108|
                          DCD      TIMEx_DMACommutationCplt
                  |L6.112|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIMEx_ConfigCommutationEvent_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_ConfigCommutationEvent_IT PROC
;;;1553     */
;;;1554   HAL_StatusTypeDef HAL_TIMEx_ConfigCommutationEvent_IT(TIM_HandleTypeDef *htim, uint32_t  InputTrigger, uint32_t  CommutationSource)
000000  b510              PUSH     {r4,lr}
;;;1555   {
;;;1556     /* Check the parameters */
;;;1557     assert_param(IS_TIM_ADVANCED_INSTANCE(htim->Instance));
;;;1558     assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
;;;1559     
;;;1560     __HAL_LOCK(htim);
000002  6bc3              LDR      r3,[r0,#0x3c]
000004  2b01              CMP      r3,#1
000006  d009              BEQ      |L7.28|
000008  2301              MOVS     r3,#1
00000a  63c3              STR      r3,[r0,#0x3c]
00000c  b141              CBZ      r1,|L7.32|
;;;1561     
;;;1562     if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
00000e  2910              CMP      r1,#0x10
000010  d006              BEQ      |L7.32|
;;;1563         (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
000012  2920              CMP      r1,#0x20
000014  d004              BEQ      |L7.32|
000016  2930              CMP      r1,#0x30
000018  d002              BEQ      |L7.32|
00001a  e00a              B        |L7.50|
                  |L7.28|
00001c  2002              MOVS     r0,#2                 ;1560
;;;1564     {    
;;;1565       /* Select the Input trigger */
;;;1566       htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;1567       htim->Instance->SMCR |= InputTrigger;
;;;1568     }
;;;1569     
;;;1570     /* Select the Capture Compare preload feature */
;;;1571     htim->Instance->CR2 |= TIM_CR2_CCPC;
;;;1572     /* Select the Commutation event source */
;;;1573     htim->Instance->CR2 &= ~TIM_CR2_CCUS;
;;;1574     htim->Instance->CR2 |= CommutationSource;
;;;1575       
;;;1576     /* Enable the Commutation Interrupt Request */
;;;1577     __HAL_TIM_ENABLE_IT(htim, TIM_IT_COM);
;;;1578   
;;;1579     __HAL_UNLOCK(htim);
;;;1580     
;;;1581     return HAL_OK;
;;;1582   }
00001e  bd10              POP      {r4,pc}
                  |L7.32|
000020  6803              LDR      r3,[r0,#0]            ;1566
000022  689c              LDR      r4,[r3,#8]            ;1566
000024  f0240470          BIC      r4,r4,#0x70           ;1566
000028  609c              STR      r4,[r3,#8]            ;1566
00002a  6803              LDR      r3,[r0,#0]            ;1567
00002c  689c              LDR      r4,[r3,#8]            ;1567
00002e  430c              ORRS     r4,r4,r1              ;1567
000030  609c              STR      r4,[r3,#8]            ;1567
                  |L7.50|
000032  6801              LDR      r1,[r0,#0]            ;1571
000034  2300              MOVS     r3,#0                 ;1579
000036  684c              LDR      r4,[r1,#4]            ;1571
000038  f0440401          ORR      r4,r4,#1              ;1571
00003c  604c              STR      r4,[r1,#4]            ;1571
00003e  6801              LDR      r1,[r0,#0]            ;1573
000040  684c              LDR      r4,[r1,#4]            ;1573
000042  f0240404          BIC      r4,r4,#4              ;1573
000046  604c              STR      r4,[r1,#4]            ;1573
000048  6801              LDR      r1,[r0,#0]            ;1574
00004a  684c              LDR      r4,[r1,#4]            ;1574
00004c  4314              ORRS     r4,r4,r2              ;1574
00004e  604c              STR      r4,[r1,#4]            ;1574
000050  6801              LDR      r1,[r0,#0]            ;1577
000052  68ca              LDR      r2,[r1,#0xc]          ;1577
000054  f0420220          ORR      r2,r2,#0x20           ;1577
000058  60ca              STR      r2,[r1,#0xc]          ;1577
00005a  63c3              STR      r3,[r0,#0x3c]         ;1581
00005c  2000              MOVS     r0,#0                 ;1581
00005e  bd10              POP      {r4,pc}
;;;1583   
                          ENDP


                          AREA ||i.HAL_TIMEx_GroupChannel5||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_GroupChannel5 PROC
;;;1925     */
;;;1926   HAL_StatusTypeDef HAL_TIMEx_GroupChannel5(TIM_HandleTypeDef *htim, uint32_t OCRef)
000000  b510              PUSH     {r4,lr}
;;;1927   {
;;;1928     /* Check parameters */
;;;1929     assert_param(IS_TIM_COMBINED3PHASEPWM_INSTANCE(htim->Instance));
;;;1930     assert_param(IS_TIM_GROUPCH5(OCRef));
;;;1931   
;;;1932     /* Process Locked */
;;;1933     __HAL_LOCK(htim);
000002  6bc2              LDR      r2,[r0,#0x3c]
000004  2a01              CMP      r2,#1
000006  d011              BEQ      |L8.44|
000008  2201              MOVS     r2,#1
;;;1934     
;;;1935     htim->State = HAL_TIM_STATE_BUSY;
00000a  2302              MOVS     r3,#2
00000c  e9c0230f          STRD     r2,r3,[r0,#0x3c]
;;;1936     
;;;1937     /* Clear GC5Cx bit fields */
;;;1938     htim->Instance->CCR5 &= ~(TIM_CCR5_GC5C3|TIM_CCR5_GC5C2|TIM_CCR5_GC5C1);
000010  6803              LDR      r3,[r0,#0]
000012  6d9c              LDR      r4,[r3,#0x58]
000014  f0244460          BIC      r4,r4,#0xe0000000
000018  659c              STR      r4,[r3,#0x58]
;;;1939     
;;;1940     /* Set GC5Cx bit fields */
;;;1941     htim->Instance->CCR5 |= OCRef;
00001a  6803              LDR      r3,[r0,#0]
00001c  6d9c              LDR      r4,[r3,#0x58]
00001e  430c              ORRS     r4,r4,r1
000020  659c              STR      r4,[r3,#0x58]
;;;1942                                      
;;;1943     htim->State = HAL_TIM_STATE_READY;                                 
;;;1944     
;;;1945     __HAL_UNLOCK(htim);
000022  2100              MOVS     r1,#0
000024  6402              STR      r2,[r0,#0x40]         ;1943
;;;1946     
;;;1947     return HAL_OK;
000026  63c1              STR      r1,[r0,#0x3c]
000028  4608              MOV      r0,r1
;;;1948   }
00002a  bd10              POP      {r4,pc}
                  |L8.44|
00002c  2002              MOVS     r0,#2                 ;1933
00002e  bd10              POP      {r4,pc}
;;;1949   /**
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_DeInit PROC
;;;255      */
;;;256    HAL_StatusTypeDef HAL_TIMEx_HallSensor_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;257    {
000002  4604              MOV      r4,r0
;;;258      /* Check the parameters */
;;;259      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;260    
;;;261      htim->State = HAL_TIM_STATE_BUSY;
;;;262      
;;;263      /* Disable the TIM Peripheral Clock */
;;;264      __HAL_TIM_DISABLE(htim);
000004  f2411211          MOV      r2,#0x1111
000008  2002              MOVS     r0,#2                 ;261
00000a  6420              STR      r0,[r4,#0x40]         ;261
00000c  6820              LDR      r0,[r4,#0]
00000e  6a01              LDR      r1,[r0,#0x20]
000010  4211              TST      r1,r2
000012  d107              BNE      |L9.36|
000014  6a01              LDR      r1,[r0,#0x20]
000016  1092              ASRS     r2,r2,#2
000018  4211              TST      r1,r2
00001a  d103              BNE      |L9.36|
00001c  6801              LDR      r1,[r0,#0]
00001e  f0210101          BIC      r1,r1,#1
000022  6001              STR      r1,[r0,#0]
                  |L9.36|
;;;265    
;;;266    #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;267      if(htim->HallSensor_MspDeInitCallback == NULL)
;;;268      {
;;;269        htim->HallSensor_MspDeInitCallback = HAL_TIMEx_HallSensor_MspDeInit;
;;;270      }
;;;271      /* DeInit the low level hardware */
;;;272      htim->HallSensor_MspDeInitCallback(htim);
;;;273    #else
;;;274      /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;275      HAL_TIMEx_HallSensor_MspDeInit(htim);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       HAL_TIMEx_HallSensor_MspDeInit
;;;276    #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;277    
;;;278      /* Change TIM state */  
;;;279      htim->State = HAL_TIM_STATE_RESET; 
00002a  2000              MOVS     r0,#0
00002c  6420              STR      r0,[r4,#0x40]
;;;280    
;;;281      /* Release Lock */
;;;282      __HAL_UNLOCK(htim);
00002e  63e0              STR      r0,[r4,#0x3c]
;;;283    
;;;284      return HAL_OK;
;;;285    }
000030  bd10              POP      {r4,pc}
;;;286    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_GetState PROC
;;;2025     */
;;;2026   HAL_TIM_StateTypeDef HAL_TIMEx_HallSensor_GetState(TIM_HandleTypeDef *htim)
000000  6c00              LDR      r0,[r0,#0x40]
;;;2027   {
;;;2028     return htim->State;
;;;2029   }
000002  4770              BX       lr
;;;2030   
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Init||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_HallSensor_Init PROC
;;;163      */
;;;164    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Init(TIM_HandleTypeDef *htim, TIM_HallSensor_InitTypeDef* sConfig)
000000  b5f0              PUSH     {r4-r7,lr}
;;;165    {
000002  0004              MOVS     r4,r0
000004  460f              MOV      r7,r1
000006  b087              SUB      sp,sp,#0x1c
000008  d003              BEQ      |L11.18|
;;;166      TIM_OC_InitTypeDef OC_Config;
;;;167        
;;;168      /* Check the TIM handle allocation */
;;;169      if(htim == NULL)
;;;170      {
;;;171        return HAL_ERROR;
;;;172      }
;;;173      
;;;174      assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;175      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;176      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;177      assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;178      assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
;;;179      assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
;;;180      assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
;;;181    
;;;182      if(htim->State == HAL_TIM_STATE_RESET)
00000a  6c20              LDR      r0,[r4,#0x40]
00000c  2500              MOVS     r5,#0
00000e  b118              CBZ      r0,|L11.24|
000010  e006              B        |L11.32|
                  |L11.18|
000012  2001              MOVS     r0,#1                 ;171
                  |L11.20|
;;;183      {
;;;184        /* Allocate lock resource and initialize it */
;;;185        htim->Lock = HAL_UNLOCKED;
;;;186    
;;;187    #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;188        /* Reset interrupt callbacks to legacy week callbacks */
;;;189        TIM_ResetCallback(htim);
;;;190    
;;;191        if(htim->HallSensor_MspInitCallback == NULL)
;;;192        {
;;;193          htim->HallSensor_MspInitCallback = HAL_TIMEx_HallSensor_MspInit;
;;;194        }
;;;195        /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;196        htim->HallSensor_MspInitCallback(htim);
;;;197    #else
;;;198        /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;199        HAL_TIMEx_HallSensor_MspInit(htim);
;;;200    #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;201      }
;;;202    
;;;203      /* Set the TIM state */
;;;204      htim->State= HAL_TIM_STATE_BUSY;
;;;205    
;;;206      /* Configure the Time base in the Encoder Mode */
;;;207      TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;208      
;;;209      /* Configure the Channel 1 as Input Channel to interface with the three Outputs of the  Hall sensor */
;;;210      TIM_TI1_SetConfig(htim->Instance, sConfig->IC1Polarity, TIM_ICSELECTION_TRC, sConfig->IC1Filter);
;;;211      
;;;212      /* Reset the IC1PSC Bits */
;;;213      htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
;;;214      /* Set the IC1PSC value */
;;;215      htim->Instance->CCMR1 |= sConfig->IC1Prescaler;
;;;216      
;;;217      /* Enable the Hall sensor interface (XOR function of the three inputs) */
;;;218      htim->Instance->CR2 |= TIM_CR2_TI1S;
;;;219      
;;;220      /* Select the TIM_TS_TI1F_ED signal as Input trigger for the TIM */
;;;221      htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;222      htim->Instance->SMCR |= TIM_TS_TI1F_ED;
;;;223      
;;;224      /* Use the TIM_TS_TI1F_ED signal to reset the TIM counter each edge detection */  
;;;225      htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;226      htim->Instance->SMCR |= TIM_SLAVEMODE_RESET;
;;;227      
;;;228      /* Program channel 2 in PWM 2 mode with the desired Commutation_Delay*/
;;;229      OC_Config.OCFastMode = TIM_OCFAST_DISABLE;
;;;230      OC_Config.OCIdleState = TIM_OCIDLESTATE_RESET;
;;;231      OC_Config.OCMode = TIM_OCMODE_PWM2;
;;;232      OC_Config.OCNIdleState = TIM_OCNIDLESTATE_RESET;
;;;233      OC_Config.OCNPolarity = TIM_OCNPOLARITY_HIGH;
;;;234      OC_Config.OCPolarity = TIM_OCPOLARITY_HIGH;
;;;235      OC_Config.Pulse = sConfig->Commutation_Delay; 
;;;236        
;;;237      TIM_OC2_SetConfig(htim->Instance, &OC_Config);
;;;238      
;;;239      /* Select OC2REF as trigger output on TRGO: write the MMS bits in the TIMx_CR2
;;;240        register to 101 */
;;;241      htim->Instance->CR2 &= ~TIM_CR2_MMS;
;;;242      htim->Instance->CR2 |= TIM_TRGO_OC2REF; 
;;;243      
;;;244      /* Initialize the TIM state*/
;;;245      htim->State= HAL_TIM_STATE_READY;
;;;246    
;;;247      return HAL_OK;
;;;248    }
000014  b007              ADD      sp,sp,#0x1c
000016  bdf0              POP      {r4-r7,pc}
                  |L11.24|
000018  4620              MOV      r0,r4                 ;199
00001a  63e5              STR      r5,[r4,#0x3c]         ;199
00001c  f7fffffe          BL       HAL_TIMEx_HallSensor_MspInit
                  |L11.32|
000020  2002              MOVS     r0,#2                 ;204
000022  6420              STR      r0,[r4,#0x40]         ;204
000024  6820              LDR      r0,[r4,#0]            ;207
000026  1d21              ADDS     r1,r4,#4              ;207
000028  f7fffffe          BL       TIM_Base_SetConfig
00002c  68bb              LDR      r3,[r7,#8]            ;210
00002e  2203              MOVS     r2,#3                 ;210
000030  6839              LDR      r1,[r7,#0]            ;210
000032  6820              LDR      r0,[r4,#0]            ;210
000034  f7fffffe          BL       TIM_TI1_SetConfig
000038  6820              LDR      r0,[r4,#0]            ;213
00003a  2370              MOVS     r3,#0x70              ;231
00003c  4a1d              LDR      r2,|L11.180|
00003e  6981              LDR      r1,[r0,#0x18]         ;213
000040  f021010c          BIC      r1,r1,#0xc            ;213
000044  6181              STR      r1,[r0,#0x18]         ;213
000046  6820              LDR      r0,[r4,#0]            ;215
000048  6981              LDR      r1,[r0,#0x18]         ;215
00004a  687e              LDR      r6,[r7,#4]            ;215
00004c  4331              ORRS     r1,r1,r6              ;215
00004e  6181              STR      r1,[r0,#0x18]         ;215
000050  6820              LDR      r0,[r4,#0]            ;218
000052  6841              LDR      r1,[r0,#4]            ;218
000054  f0410180          ORR      r1,r1,#0x80           ;218
000058  6041              STR      r1,[r0,#4]            ;218
00005a  6820              LDR      r0,[r4,#0]            ;221
00005c  6881              LDR      r1,[r0,#8]            ;221
00005e  f0210170          BIC      r1,r1,#0x70           ;221
000062  6081              STR      r1,[r0,#8]            ;221
000064  6820              LDR      r0,[r4,#0]            ;222
000066  6881              LDR      r1,[r0,#8]            ;222
000068  f0410140          ORR      r1,r1,#0x40           ;222
00006c  6081              STR      r1,[r0,#8]            ;222
00006e  6821              LDR      r1,[r4,#0]            ;225
000070  6888              LDR      r0,[r1,#8]            ;225
000072  4010              ANDS     r0,r0,r2              ;225
000074  6088              STR      r0,[r1,#8]            ;225
000076  6820              LDR      r0,[r4,#0]            ;226
000078  6881              LDR      r1,[r0,#8]            ;226
00007a  f0410104          ORR      r1,r1,#4              ;226
00007e  6081              STR      r1,[r0,#8]            ;226
000080  9505              STR      r5,[sp,#0x14]         ;232
000082  4669              MOV      r1,sp                 ;237
000084  9504              STR      r5,[sp,#0x10]         ;230
000086  9506              STR      r5,[sp,#0x18]         ;233
000088  9503              STR      r5,[sp,#0xc]          ;234
00008a  9502              STR      r5,[sp,#8]            ;235
00008c  9300              STR      r3,[sp,#0]            ;235
00008e  68f8              LDR      r0,[r7,#0xc]          ;235
000090  9001              STR      r0,[sp,#4]            ;237
000092  6820              LDR      r0,[r4,#0]            ;237
000094  f7fffffe          BL       TIM_OC2_SetConfig
000098  6820              LDR      r0,[r4,#0]            ;241
00009a  2101              MOVS     r1,#1                 ;245
00009c  6842              LDR      r2,[r0,#4]            ;241
00009e  f0220270          BIC      r2,r2,#0x70           ;241
0000a2  6042              STR      r2,[r0,#4]            ;241
0000a4  6820              LDR      r0,[r4,#0]            ;242
0000a6  6842              LDR      r2,[r0,#4]            ;242
0000a8  f0420250          ORR      r2,r2,#0x50           ;242
0000ac  6042              STR      r2,[r0,#4]            ;242
0000ae  6421              STR      r1,[r4,#0x40]         ;245
0000b0  2000              MOVS     r0,#0                 ;247
0000b2  e7af              B        |L11.20|
;;;249    
                          ENDP

                  |L11.180|
                          DCD      0xfffefff8

                          AREA ||i.HAL_TIMEx_HallSensor_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_MspDeInit PROC
;;;308      */
;;;309    __weak void HAL_TIMEx_HallSensor_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;310    {
;;;311      /* Prevent unused argument(s) compilation warning */
;;;312      UNUSED(htim);
;;;313     
;;;314      /* NOTE : This function Should not be modified, when the callback is needed,
;;;315                the HAL_TIMEx_HallSensor_MspDeInit could be implemented in the user file
;;;316       */
;;;317    }
;;;318    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_MspInit PROC
;;;292      */
;;;293    __weak void HAL_TIMEx_HallSensor_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;294    {
;;;295      /* Prevent unused argument(s) compilation warning */
;;;296      UNUSED(htim);
;;;297     
;;;298      /* NOTE : This function Should not be modified, when the callback is needed,
;;;299                the HAL_TIMEx_HallSensor_MspInit could be implemented in the user file
;;;300       */
;;;301    }
;;;302    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_Start PROC
;;;324      */
;;;325    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;326    {
;;;327      /* Check the parameters */
;;;328      assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;329      
;;;330      /* Enable the Input Capture channels 1
;;;331        (in the Hall Sensor Interface the Three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */  
;;;332      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE); 
000002  2201              MOVS     r2,#1
000004  4604              MOV      r4,r0                 ;326
000006  6800              LDR      r0,[r0,#0]
000008  2100              MOVS     r1,#0
00000a  f7fffffe          BL       TIM_CCxChannelCmd
;;;333      
;;;334      /* Enable the Peripheral */
;;;335      __HAL_TIM_ENABLE(htim);
00000e  6820              LDR      r0,[r4,#0]
000010  6801              LDR      r1,[r0,#0]
000012  f0410101          ORR      r1,r1,#1
000016  6001              STR      r1,[r0,#0]
;;;336      
;;;337      /* Return function status */
;;;338      return HAL_OK;
000018  2000              MOVS     r0,#0
;;;339    }
00001a  bd10              POP      {r4,pc}
;;;340    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_HallSensor_Start_DMA PROC
;;;420      */
;;;421    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;422    {
000002  4604              MOV      r4,r0
;;;423      /* Check the parameters */
;;;424      assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;425      
;;;426       if((htim->State == HAL_TIM_STATE_BUSY))
000004  6c00              LDR      r0,[r0,#0x40]
000006  4615              MOV      r5,r2                 ;422
000008  460e              MOV      r6,r1                 ;422
00000a  2802              CMP      r0,#2
00000c  d004              BEQ      |L15.24|
;;;427      {
;;;428         return HAL_BUSY;
;;;429      }
;;;430      else if((htim->State == HAL_TIM_STATE_READY))
00000e  6c20              LDR      r0,[r4,#0x40]
000010  2801              CMP      r0,#1
000012  d104              BNE      |L15.30|
;;;431      {
;;;432        if(((uint32_t)pData == 0 ) && (Length > 0)) 
000014  b90e              CBNZ     r6,|L15.26|
000016  b105              CBZ      r5,|L15.26|
                  |L15.24|
;;;433        {
;;;434          return HAL_ERROR;                                    
;;;435        }
;;;436        else
;;;437        {
;;;438          htim->State = HAL_TIM_STATE_BUSY;
;;;439        }
;;;440      }
;;;441      /* Enable the Input Capture channels 1
;;;442        (in the Hall Sensor Interface the Three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */  
;;;443      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE); 
;;;444      
;;;445      /* Set the DMA Input Capture 1 Callback */
;;;446      htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMACaptureCplt;     
;;;447      /* Set the DMA error callback */
;;;448      htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
;;;449      
;;;450      /* Enable the DMA Stream for Capture 1*/
;;;451      HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length);    
;;;452      
;;;453      /* Enable the capture compare 1 Interrupt */
;;;454      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;455     
;;;456      /* Enable the Peripheral */
;;;457      __HAL_TIM_ENABLE(htim);
;;;458      
;;;459      /* Return function status */
;;;460      return HAL_OK;
;;;461    }
000018  bd70              POP      {r4-r6,pc}
                  |L15.26|
00001a  2002              MOVS     r0,#2                 ;438
00001c  6420              STR      r0,[r4,#0x40]         ;438
                  |L15.30|
00001e  6820              LDR      r0,[r4,#0]            ;443
000020  2201              MOVS     r2,#1                 ;443
000022  2100              MOVS     r1,#0                 ;443
000024  f7fffffe          BL       TIM_CCxChannelCmd
000028  6a61              LDR      r1,[r4,#0x24]         ;446
00002a  462b              MOV      r3,r5                 ;451
00002c  480b              LDR      r0,|L15.92|
00002e  4632              MOV      r2,r6                 ;451
000030  6408              STR      r0,[r1,#0x40]         ;448
000032  6a61              LDR      r1,[r4,#0x24]         ;448
000034  480a              LDR      r0,|L15.96|
000036  6508              STR      r0,[r1,#0x50]         ;451
000038  6821              LDR      r1,[r4,#0]            ;451
00003a  6a60              LDR      r0,[r4,#0x24]         ;451
00003c  3134              ADDS     r1,r1,#0x34           ;451
00003e  f7fffffe          BL       HAL_DMA_Start_IT
000042  6820              LDR      r0,[r4,#0]            ;454
000044  68c1              LDR      r1,[r0,#0xc]          ;454
000046  f4417100          ORR      r1,r1,#0x200          ;454
00004a  60c1              STR      r1,[r0,#0xc]          ;454
00004c  6820              LDR      r0,[r4,#0]            ;457
00004e  6801              LDR      r1,[r0,#0]            ;457
000050  f0410101          ORR      r1,r1,#1              ;457
000054  6001              STR      r1,[r0,#0]            ;457
000056  2000              MOVS     r0,#0                 ;460
000058  bd70              POP      {r4-r6,pc}
;;;462    
                          ENDP

00005a  0000              DCW      0x0000
                  |L15.92|
                          DCD      TIM_DMACaptureCplt
                  |L15.96|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIMEx_HallSensor_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_Start_IT PROC
;;;368      */
;;;369    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_IT(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;370    { 
000002  4604              MOV      r4,r0
;;;371      /* Check the parameters */
;;;372      assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;373      
;;;374      /* Enable the capture compare Interrupts 1 event */
;;;375      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000004  6800              LDR      r0,[r0,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f0410102          ORR      r1,r1,#2
00000c  60c1              STR      r1,[r0,#0xc]
;;;376      
;;;377      /* Enable the Input Capture channels 1
;;;378        (in the Hall Sensor Interface the Three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */  
;;;379      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);  
00000e  6820              LDR      r0,[r4,#0]
000010  2201              MOVS     r2,#1
000012  2100              MOVS     r1,#0
000014  f7fffffe          BL       TIM_CCxChannelCmd
;;;380      
;;;381      /* Enable the Peripheral */
;;;382      __HAL_TIM_ENABLE(htim);
000018  6820              LDR      r0,[r4,#0]
00001a  6801              LDR      r1,[r0,#0]
00001c  f0410101          ORR      r1,r1,#1
000020  6001              STR      r1,[r0,#0]
;;;383      
;;;384      /* Return function status */
;;;385      return HAL_OK;
000022  2000              MOVS     r0,#0
;;;386    }
000024  bd10              POP      {r4,pc}
;;;387    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_Stop PROC
;;;346      */
;;;347    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop(TIM_HandleTypeDef *htim)
000000  2200              MOVS     r2,#0
;;;348    {
000002  b510              PUSH     {r4,lr}
000004  4604              MOV      r4,r0
;;;349      /* Check the parameters */
;;;350      assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;351      
;;;352      /* Disable the Input Capture channels 1, 2 and 3
;;;353        (in the Hall Sensor Interface the Three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */  
;;;354      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
000006  6800              LDR      r0,[r0,#0]
000008  4611              MOV      r1,r2
00000a  f7fffffe          BL       TIM_CCxChannelCmd
;;;355    
;;;356      /* Disable the Peripheral */
;;;357      __HAL_TIM_DISABLE(htim);
00000e  6820              LDR      r0,[r4,#0]
000010  f2411211          MOV      r2,#0x1111
000014  6a01              LDR      r1,[r0,#0x20]
000016  4211              TST      r1,r2
000018  d107              BNE      |L17.42|
00001a  6a01              LDR      r1,[r0,#0x20]
00001c  1092              ASRS     r2,r2,#2
00001e  4211              TST      r1,r2
000020  d103              BNE      |L17.42|
000022  6801              LDR      r1,[r0,#0]
000024  f0210101          BIC      r1,r1,#1
000028  6001              STR      r1,[r0,#0]
                  |L17.42|
;;;358      
;;;359      /* Return function status */
;;;360      return HAL_OK;
00002a  2000              MOVS     r0,#0
;;;361    }
00002c  bd10              POP      {r4,pc}
;;;362    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_Stop_DMA PROC
;;;468      */
;;;469    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_DMA(TIM_HandleTypeDef *htim)
000000  2200              MOVS     r2,#0
;;;470    {
000002  b510              PUSH     {r4,lr}
000004  4604              MOV      r4,r0
;;;471      /* Check the parameters */
;;;472      assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;473      
;;;474      /* Disable the Input Capture channels 1
;;;475        (in the Hall Sensor Interface the Three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */  
;;;476      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
000006  6800              LDR      r0,[r0,#0]
000008  4611              MOV      r1,r2
00000a  f7fffffe          BL       TIM_CCxChannelCmd
;;;477     
;;;478      
;;;479      /* Disable the capture compare Interrupts 1 event */
;;;480      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
00000e  6820              LDR      r0,[r4,#0]
;;;481     
;;;482      /* Disable the Peripheral */
;;;483      __HAL_TIM_DISABLE(htim);
000010  f2411211          MOV      r2,#0x1111
000014  68c1              LDR      r1,[r0,#0xc]          ;480
000016  f4217100          BIC      r1,r1,#0x200          ;480
00001a  60c1              STR      r1,[r0,#0xc]          ;480
00001c  6820              LDR      r0,[r4,#0]
00001e  6a01              LDR      r1,[r0,#0x20]
000020  4211              TST      r1,r2
000022  d107              BNE      |L18.52|
000024  6a01              LDR      r1,[r0,#0x20]
000026  1092              ASRS     r2,r2,#2
000028  4211              TST      r1,r2
00002a  d103              BNE      |L18.52|
00002c  6801              LDR      r1,[r0,#0]
00002e  f0210101          BIC      r1,r1,#1
000032  6001              STR      r1,[r0,#0]
                  |L18.52|
;;;484      
;;;485      /* Return function status */
;;;486      return HAL_OK;
000034  2000              MOVS     r0,#0
;;;487    }
000036  bd10              POP      {r4,pc}
;;;488    
                          ENDP


                          AREA ||i.HAL_TIMEx_HallSensor_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_HallSensor_Stop_IT PROC
;;;393      */
;;;394    HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_IT(TIM_HandleTypeDef *htim)
000000  2200              MOVS     r2,#0
;;;395    {
000002  b510              PUSH     {r4,lr}
000004  4604              MOV      r4,r0
;;;396      /* Check the parameters */
;;;397      assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;398      
;;;399      /* Disable the Input Capture channels 1
;;;400        (in the Hall Sensor Interface the Three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */  
;;;401      TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
000006  6800              LDR      r0,[r0,#0]
000008  4611              MOV      r1,r2
00000a  f7fffffe          BL       TIM_CCxChannelCmd
;;;402      
;;;403      /* Disable the capture compare Interrupts event */
;;;404      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
00000e  6820              LDR      r0,[r4,#0]
;;;405      
;;;406      /* Disable the Peripheral */
;;;407      __HAL_TIM_DISABLE(htim);
000010  f2411211          MOV      r2,#0x1111
000014  68c1              LDR      r1,[r0,#0xc]          ;404
000016  f0210102          BIC      r1,r1,#2              ;404
00001a  60c1              STR      r1,[r0,#0xc]          ;404
00001c  6820              LDR      r0,[r4,#0]
00001e  6a01              LDR      r1,[r0,#0x20]
000020  4211              TST      r1,r2
000022  d107              BNE      |L19.52|
000024  6a01              LDR      r1,[r0,#0x20]
000026  1092              ASRS     r2,r2,#2
000028  4211              TST      r1,r2
00002a  d103              BNE      |L19.52|
00002c  6801              LDR      r1,[r0,#0]
00002e  f0210101          BIC      r1,r1,#1
000032  6001              STR      r1,[r0,#0]
                  |L19.52|
;;;408      
;;;409      /* Return function status */
;;;410      return HAL_OK;
000034  2000              MOVS     r0,#0
;;;411    }
000036  bd10              POP      {r4,pc}
;;;412    
                          ENDP


                          AREA ||i.HAL_TIMEx_MasterConfigSynchronization||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_MasterConfigSynchronization PROC
;;;1652     */
;;;1653   HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim, TIM_MasterConfigTypeDef * sMasterConfig)
000000  b570              PUSH     {r4-r6,lr}
;;;1654   {
;;;1655     uint32_t tmpcr2;  
;;;1656     uint32_t tmpsmcr;  
;;;1657   
;;;1658     /* Check the parameters */
;;;1659     assert_param(IS_TIM_SYNCHRO_INSTANCE(htim->Instance));
;;;1660     assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
;;;1661     assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));
;;;1662     
;;;1663     /* Check input state */
;;;1664     __HAL_LOCK(htim);
000002  6bc2              LDR      r2,[r0,#0x3c]
000004  2a01              CMP      r2,#1
000006  d01d              BEQ      |L20.68|
000008  2201              MOVS     r2,#1
;;;1665   
;;;1666    /* Get the TIMx CR2 register value */
;;;1667     tmpcr2 = htim->Instance->CR2;
00000a  63c2              STR      r2,[r0,#0x3c]
00000c  6802              LDR      r2,[r0,#0]
;;;1668   
;;;1669     /* Get the TIMx SMCR register value */
;;;1670     tmpsmcr = htim->Instance->SMCR;
;;;1671   
;;;1672     /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
;;;1673     if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
00000e  4c0e              LDR      r4,|L20.72|
000010  6853              LDR      r3,[r2,#4]            ;1667
000012  42a2              CMP      r2,r4
000014  6895              LDR      r5,[r2,#8]            ;1670
000016  d002              BEQ      |L20.30|
000018  4c0c              LDR      r4,|L20.76|
00001a  42a2              CMP      r2,r4
00001c  d103              BNE      |L20.38|
                  |L20.30|
;;;1674     {
;;;1675       /* Check the parameters */
;;;1676       assert_param(IS_TIM_TRGO2_SOURCE(sMasterConfig->MasterOutputTrigger2));
;;;1677       
;;;1678       /* Clear the MMS2 bits */
;;;1679       tmpcr2 &= ~TIM_CR2_MMS2;
;;;1680       /* Select the TRGO2 source*/
;;;1681       tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
00001e  684c              LDR      r4,[r1,#4]
000020  f4230370          BIC      r3,r3,#0xf00000       ;1679
000024  4323              ORRS     r3,r3,r4
                  |L20.38|
;;;1682     }
;;;1683     
;;;1684     /* Reset the MMS Bits */
;;;1685     tmpcr2 &= ~TIM_CR2_MMS;
;;;1686     /* Select the TRGO source */
;;;1687     tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
;;;1688   
;;;1689     /* Reset the MSM Bit */
;;;1690     tmpsmcr &= ~TIM_SMCR_MSM;
;;;1691     /* Set master mode */
;;;1692     tmpsmcr |= sMasterConfig->MasterSlaveMode;
000026  680c              LDR      r4,[r1,#0]
000028  6889              LDR      r1,[r1,#8]
;;;1693     
;;;1694     /* Update TIMx CR2 */
;;;1695     htim->Instance->CR2 = tmpcr2;
;;;1696     
;;;1697     /* Update TIMx SMCR */
;;;1698     htim->Instance->SMCR = tmpsmcr;
;;;1699   
;;;1700     __HAL_UNLOCK(htim);
00002a  2600              MOVS     r6,#0
00002c  f0230370          BIC      r3,r3,#0x70           ;1685
000030  431c              ORRS     r4,r4,r3              ;1687
000032  6054              STR      r4,[r2,#4]            ;1695
000034  f0250580          BIC      r5,r5,#0x80           ;1690
000038  6802              LDR      r2,[r0,#0]            ;1698
00003a  4329              ORRS     r1,r1,r5              ;1692
00003c  6091              STR      r1,[r2,#8]            ;1698
;;;1701     
;;;1702     return HAL_OK;
00003e  63c6              STR      r6,[r0,#0x3c]
000040  4630              MOV      r0,r6
;;;1703   } 
000042  bd70              POP      {r4-r6,pc}
                  |L20.68|
000044  2002              MOVS     r0,#2                 ;1664
000046  bd70              POP      {r4-r6,pc}
;;;1704                                                        
                          ENDP

                  |L20.72|
                          DCD      0x40010000
                  |L20.76|
                          DCD      0x40010400

                          AREA ||i.HAL_TIMEx_OCN_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OCN_Start PROC
;;;524      */
;;;525    HAL_StatusTypeDef HAL_TIMEx_OCN_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;526    {
;;;527      /* Check the parameters */
;;;528      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
;;;529      
;;;530         /* Enable the Capture compare channel N */
;;;531         TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
000002  2204              MOVS     r2,#4
000004  4604              MOV      r4,r0                 ;526
000006  6800              LDR      r0,[r0,#0]
000008  f7fffffe          BL       TIM_CCxNChannelCmd
;;;532        
;;;533      /* Enable the Main Output */
;;;534        __HAL_TIM_MOE_ENABLE(htim);
00000c  6820              LDR      r0,[r4,#0]
00000e  6c41              LDR      r1,[r0,#0x44]
000010  f4414100          ORR      r1,r1,#0x8000
000014  6441              STR      r1,[r0,#0x44]
;;;535    
;;;536      /* Enable the Peripheral */
;;;537      __HAL_TIM_ENABLE(htim);
000016  6820              LDR      r0,[r4,#0]
000018  6801              LDR      r1,[r0,#0]
00001a  f0410101          ORR      r1,r1,#1
00001e  6001              STR      r1,[r0,#0]
;;;538      
;;;539      /* Return function status */
;;;540      return HAL_OK;
000020  2000              MOVS     r0,#0
;;;541    } 
000022  bd10              POP      {r4,pc}
;;;542    
                          ENDP


                          AREA ||i.HAL_TIMEx_OCN_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_OCN_Start_DMA PROC
;;;726      */
;;;727    HAL_StatusTypeDef HAL_TIMEx_OCN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;728    {
000002  4604              MOV      r4,r0
;;;729      /* Check the parameters */
;;;730      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
;;;731      
;;;732      if((htim->State == HAL_TIM_STATE_BUSY))
000004  6c00              LDR      r0,[r0,#0x40]
000006  4616              MOV      r6,r2                 ;728
000008  460d              MOV      r5,r1                 ;728
00000a  2802              CMP      r0,#2
00000c  d004              BEQ      |L22.24|
;;;733      {
;;;734         return HAL_BUSY;
;;;735      }
;;;736      else if((htim->State == HAL_TIM_STATE_READY))
00000e  6c20              LDR      r0,[r4,#0x40]
000010  2801              CMP      r0,#1
000012  d104              BNE      |L22.30|
;;;737      {
;;;738        if(((uint32_t)pData == 0 ) && (Length > 0)) 
000014  b90e              CBNZ     r6,|L22.26|
000016  b103              CBZ      r3,|L22.26|
                  |L22.24|
;;;739        {
;;;740          return HAL_ERROR;                                    
;;;741        }
;;;742        else
;;;743        {
;;;744          htim->State = HAL_TIM_STATE_BUSY;
;;;745        }
;;;746      }    
;;;747      switch (Channel)
;;;748      {
;;;749        case TIM_CHANNEL_1:
;;;750        {      
;;;751          /* Set the DMA Period elapsed callback */
;;;752          htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;753         
;;;754          /* Set the DMA error callback */
;;;755          htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
;;;756          
;;;757          /* Enable the DMA Stream */
;;;758          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
;;;759          
;;;760          /* Enable the TIM Output Compare DMA request */
;;;761          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;762        }
;;;763        break;
;;;764        
;;;765        case TIM_CHANNEL_2:
;;;766        {
;;;767          /* Set the DMA Period elapsed callback */
;;;768          htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;769         
;;;770          /* Set the DMA error callback */
;;;771          htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
;;;772          
;;;773          /* Enable the DMA Stream */
;;;774          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
;;;775          
;;;776          /* Enable the TIM Output Compare DMA request */
;;;777          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;778        }
;;;779        break;
;;;780        
;;;781        case TIM_CHANNEL_3:
;;;782    {
;;;783          /* Set the DMA Period elapsed callback */
;;;784          htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;785         
;;;786          /* Set the DMA error callback */
;;;787          htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
;;;788          
;;;789          /* Enable the DMA Stream */
;;;790          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
;;;791          
;;;792          /* Enable the TIM Output Compare DMA request */
;;;793          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;794        }
;;;795        break;
;;;796        
;;;797        case TIM_CHANNEL_4:
;;;798        {
;;;799         /* Set the DMA Period elapsed callback */
;;;800          htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;801         
;;;802          /* Set the DMA error callback */
;;;803          htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
;;;804          
;;;805          /* Enable the DMA Stream */
;;;806          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
;;;807          
;;;808          /* Enable the TIM Output Compare DMA request */
;;;809          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;810        }
;;;811        break;
;;;812        
;;;813        default:
;;;814        break;
;;;815      }
;;;816    
;;;817      /* Enable the Capture compare channel N */
;;;818      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
;;;819      
;;;820      /* Enable the Main Output */
;;;821      __HAL_TIM_MOE_ENABLE(htim);
;;;822      
;;;823      /* Enable the Peripheral */
;;;824      __HAL_TIM_ENABLE(htim); 
;;;825      
;;;826      /* Return function status */
;;;827      return HAL_OK;
;;;828    }
000018  bd70              POP      {r4-r6,pc}
                  |L22.26|
00001a  2002              MOVS     r0,#2                 ;744
00001c  6420              STR      r0,[r4,#0x40]         ;744
                  |L22.30|
00001e  482b              LDR      r0,|L22.204|
000020  492b              LDR      r1,|L22.208|
000022  b135              CBZ      r5,|L22.50|
000024  2d04              CMP      r5,#4                 ;747
000026  d013              BEQ      |L22.80|
000028  2d08              CMP      r5,#8                 ;747
00002a  d031              BEQ      |L22.144|
00002c  2d0c              CMP      r5,#0xc               ;747
00002e  d11e              BNE      |L22.110|
000030  e03d              B        |L22.174|
                  |L22.50|
000032  6a62              LDR      r2,[r4,#0x24]         ;752
000034  6410              STR      r0,[r2,#0x40]         ;755
000036  6a60              LDR      r0,[r4,#0x24]         ;755
000038  6501              STR      r1,[r0,#0x50]         ;758
00003a  4631              MOV      r1,r6                 ;758
00003c  6822              LDR      r2,[r4,#0]            ;758
00003e  6a60              LDR      r0,[r4,#0x24]         ;758
000040  3234              ADDS     r2,r2,#0x34           ;758
000042  f7fffffe          BL       HAL_DMA_Start_IT
000046  6820              LDR      r0,[r4,#0]            ;761
000048  68c1              LDR      r1,[r0,#0xc]          ;761
00004a  f4417100          ORR      r1,r1,#0x200          ;761
00004e  e00d              B        |L22.108|
                  |L22.80|
000050  6aa2              LDR      r2,[r4,#0x28]         ;768
000052  6410              STR      r0,[r2,#0x40]         ;771
000054  6aa0              LDR      r0,[r4,#0x28]         ;771
000056  6501              STR      r1,[r0,#0x50]         ;774
000058  4631              MOV      r1,r6                 ;774
00005a  6822              LDR      r2,[r4,#0]            ;774
00005c  6aa0              LDR      r0,[r4,#0x28]         ;774
00005e  3238              ADDS     r2,r2,#0x38           ;774
000060  f7fffffe          BL       HAL_DMA_Start_IT
000064  6820              LDR      r0,[r4,#0]            ;777
000066  68c1              LDR      r1,[r0,#0xc]          ;777
000068  f4416180          ORR      r1,r1,#0x400          ;777
                  |L22.108|
00006c  60c1              STR      r1,[r0,#0xc]          ;761
                  |L22.110|
00006e  6820              LDR      r0,[r4,#0]            ;818
000070  2204              MOVS     r2,#4                 ;818
000072  4629              MOV      r1,r5                 ;818
000074  f7fffffe          BL       TIM_CCxNChannelCmd
000078  6820              LDR      r0,[r4,#0]            ;821
00007a  6c41              LDR      r1,[r0,#0x44]         ;821
00007c  f4414100          ORR      r1,r1,#0x8000         ;821
000080  6441              STR      r1,[r0,#0x44]         ;821
000082  6820              LDR      r0,[r4,#0]            ;824
000084  6801              LDR      r1,[r0,#0]            ;824
000086  f0410101          ORR      r1,r1,#1              ;824
00008a  6001              STR      r1,[r0,#0]            ;824
00008c  2000              MOVS     r0,#0                 ;827
00008e  bd70              POP      {r4-r6,pc}
                  |L22.144|
000090  6ae2              LDR      r2,[r4,#0x2c]         ;784
000092  6410              STR      r0,[r2,#0x40]         ;787
000094  6ae0              LDR      r0,[r4,#0x2c]         ;787
000096  6501              STR      r1,[r0,#0x50]         ;790
000098  4631              MOV      r1,r6                 ;790
00009a  6822              LDR      r2,[r4,#0]            ;790
00009c  6ae0              LDR      r0,[r4,#0x2c]         ;790
00009e  323c              ADDS     r2,r2,#0x3c           ;790
0000a0  f7fffffe          BL       HAL_DMA_Start_IT
0000a4  6820              LDR      r0,[r4,#0]            ;793
0000a6  68c1              LDR      r1,[r0,#0xc]          ;793
0000a8  f4416100          ORR      r1,r1,#0x800          ;793
0000ac  e7de              B        |L22.108|
                  |L22.174|
0000ae  6b22              LDR      r2,[r4,#0x30]         ;800
0000b0  6410              STR      r0,[r2,#0x40]         ;803
0000b2  6b20              LDR      r0,[r4,#0x30]         ;803
0000b4  6501              STR      r1,[r0,#0x50]         ;806
0000b6  4631              MOV      r1,r6                 ;806
0000b8  6822              LDR      r2,[r4,#0]            ;806
0000ba  6b20              LDR      r0,[r4,#0x30]         ;806
0000bc  3240              ADDS     r2,r2,#0x40           ;806
0000be  f7fffffe          BL       HAL_DMA_Start_IT
0000c2  6820              LDR      r0,[r4,#0]            ;809
0000c4  68c1              LDR      r1,[r0,#0xc]          ;809
0000c6  f4415180          ORR      r1,r1,#0x1000         ;809
0000ca  e7cf              B        |L22.108|
;;;829    
                          ENDP

                  |L22.204|
                          DCD      TIM_DMADelayPulseCplt
                  |L22.208|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIMEx_OCN_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OCN_Start_IT PROC
;;;584      */
;;;585    HAL_StatusTypeDef HAL_TIMEx_OCN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;586    {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L23.22|
;;;587      /* Check the parameters */
;;;588      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
;;;589      
;;;590      switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L23.30|
00000c  2908              CMP      r1,#8
00000e  d01f              BEQ      |L23.80|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L23.38|
000014  e020              B        |L23.88|
                  |L23.22|
;;;591      {
;;;592        case TIM_CHANNEL_1:
;;;593        {       
;;;594          /* Enable the TIM Output Compare interrupt */
;;;595          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f0400002          ORR      r0,r0,#2
;;;596        }
;;;597        break;
00001c  e002              B        |L23.36|
                  |L23.30|
;;;598        
;;;599        case TIM_CHANNEL_2:
;;;600        {
;;;601          /* Enable the TIM Output Compare interrupt */
;;;602          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f0400004          ORR      r0,r0,#4
                  |L23.36|
000024  60d0              STR      r0,[r2,#0xc]          ;595
                  |L23.38|
;;;603        }
;;;604        break;
;;;605        
;;;606        case TIM_CHANNEL_3:
;;;607        {
;;;608          /* Enable the TIM Output Compare interrupt */
;;;609          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
;;;610        }
;;;611        break;
;;;612        
;;;613        case TIM_CHANNEL_4:
;;;614        {
;;;615          /* Enable the TIM Output Compare interrupt */
;;;616          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
;;;617        }
;;;618        break;
;;;619        
;;;620        default:
;;;621        break;
;;;622      } 
;;;623      
;;;624      /* Enable the TIM Break interrupt */
;;;625      __HAL_TIM_ENABLE_IT(htim, TIM_IT_BREAK);
000026  6820              LDR      r0,[r4,#0]
000028  68c2              LDR      r2,[r0,#0xc]
00002a  f0420280          ORR      r2,r2,#0x80
00002e  60c2              STR      r2,[r0,#0xc]
;;;626      
;;;627      /* Enable the Capture compare channel N */
;;;628      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
000030  6820              LDR      r0,[r4,#0]
000032  2204              MOVS     r2,#4
000034  f7fffffe          BL       TIM_CCxNChannelCmd
;;;629    
;;;630      /* Enable the Main Output */
;;;631     __HAL_TIM_MOE_ENABLE(htim);
000038  6820              LDR      r0,[r4,#0]
00003a  6c41              LDR      r1,[r0,#0x44]
00003c  f4414100          ORR      r1,r1,#0x8000
000040  6441              STR      r1,[r0,#0x44]
;;;632    
;;;633      /* Enable the Peripheral */
;;;634      __HAL_TIM_ENABLE(htim);
000042  6820              LDR      r0,[r4,#0]
000044  6801              LDR      r1,[r0,#0]
000046  f0410101          ORR      r1,r1,#1
00004a  6001              STR      r1,[r0,#0]
;;;635      
;;;636      /* Return function status */
;;;637      return HAL_OK;
00004c  2000              MOVS     r0,#0
;;;638    } 
00004e  bd10              POP      {r4,pc}
                  |L23.80|
000050  68d0              LDR      r0,[r2,#0xc]          ;609
000052  f0400008          ORR      r0,r0,#8              ;609
000056  e7e5              B        |L23.36|
                  |L23.88|
000058  68d0              LDR      r0,[r2,#0xc]          ;616
00005a  f0400010          ORR      r0,r0,#0x10           ;616
00005e  e7e1              B        |L23.36|
;;;639    
                          ENDP


                          AREA ||i.HAL_TIMEx_OCN_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OCN_Stop PROC
;;;554      */
;;;555    HAL_StatusTypeDef HAL_TIMEx_OCN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;556    { 
;;;557      /* Check the parameters */
;;;558      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
;;;559      
;;;560        /* Disable the Capture compare channel N */
;;;561      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
000002  2200              MOVS     r2,#0
000004  4604              MOV      r4,r0                 ;556
000006  6800              LDR      r0,[r0,#0]
000008  f7fffffe          BL       TIM_CCxNChannelCmd
;;;562        
;;;563      /* Disable the Main Output */
;;;564        __HAL_TIM_MOE_DISABLE(htim);
00000c  6820              LDR      r0,[r4,#0]
00000e  f2411111          MOV      r1,#0x1111
000012  108a              ASRS     r2,r1,#2
000014  6a03              LDR      r3,[r0,#0x20]
000016  420b              TST      r3,r1
000018  d106              BNE      |L24.40|
00001a  6a03              LDR      r3,[r0,#0x20]
00001c  4213              TST      r3,r2
00001e  d103              BNE      |L24.40|
000020  6c43              LDR      r3,[r0,#0x44]
000022  f4234300          BIC      r3,r3,#0x8000
000026  6443              STR      r3,[r0,#0x44]
                  |L24.40|
;;;565    
;;;566      /* Disable the Peripheral */
;;;567      __HAL_TIM_DISABLE(htim);
000028  6820              LDR      r0,[r4,#0]
00002a  6a03              LDR      r3,[r0,#0x20]
00002c  420b              TST      r3,r1
00002e  d106              BNE      |L24.62|
000030  6a01              LDR      r1,[r0,#0x20]
000032  4211              TST      r1,r2
000034  d103              BNE      |L24.62|
000036  6801              LDR      r1,[r0,#0]
000038  f0210101          BIC      r1,r1,#1
00003c  6001              STR      r1,[r0,#0]
                  |L24.62|
;;;568      
;;;569      /* Return function status */
;;;570      return HAL_OK;
00003e  2000              MOVS     r0,#0
;;;571    } 
000040  bd10              POP      {r4,pc}
;;;572    
                          ENDP


                          AREA ||i.HAL_TIMEx_OCN_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OCN_Stop_DMA PROC
;;;841      */
;;;842    HAL_StatusTypeDef HAL_TIMEx_OCN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;843    {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L25.22|
;;;844      /* Check the parameters */
;;;845      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
;;;846      
;;;847      switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L25.30|
00000c  2908              CMP      r1,#8
00000e  d02b              BEQ      |L25.104|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L25.38|
000014  e02c              B        |L25.112|
                  |L25.22|
;;;848      {
;;;849        case TIM_CHANNEL_1:
;;;850        {       
;;;851          /* Disable the TIM Output Compare DMA request */
;;;852          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f4207000          BIC      r0,r0,#0x200
;;;853        }
;;;854        break;
00001c  e002              B        |L25.36|
                  |L25.30|
;;;855        
;;;856        case TIM_CHANNEL_2:
;;;857        {
;;;858          /* Disable the TIM Output Compare DMA request */
;;;859          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f4206080          BIC      r0,r0,#0x400
                  |L25.36|
000024  60d0              STR      r0,[r2,#0xc]          ;852
                  |L25.38|
;;;860        }
;;;861        break;
;;;862        
;;;863        case TIM_CHANNEL_3:
;;;864        {
;;;865          /* Disable the TIM Output Compare DMA request */
;;;866          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
;;;867        }
;;;868        break;
;;;869        
;;;870        case TIM_CHANNEL_4:
;;;871        {
;;;872          /* Disable the TIM Output Compare interrupt */
;;;873          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
;;;874        }
;;;875        break;
;;;876        
;;;877        default:
;;;878        break;
;;;879      } 
;;;880      
;;;881      /* Disable the Capture compare channel N */
;;;882      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
000026  6820              LDR      r0,[r4,#0]
000028  2200              MOVS     r2,#0
00002a  f7fffffe          BL       TIM_CCxNChannelCmd
;;;883      
;;;884      /* Disable the Main Output */
;;;885      __HAL_TIM_MOE_DISABLE(htim);
00002e  6820              LDR      r0,[r4,#0]
000030  f2411111          MOV      r1,#0x1111
000034  108a              ASRS     r2,r1,#2
000036  6a03              LDR      r3,[r0,#0x20]
000038  420b              TST      r3,r1
00003a  d106              BNE      |L25.74|
00003c  6a03              LDR      r3,[r0,#0x20]
00003e  4213              TST      r3,r2
000040  d103              BNE      |L25.74|
000042  6c43              LDR      r3,[r0,#0x44]
000044  f4234300          BIC      r3,r3,#0x8000
000048  6443              STR      r3,[r0,#0x44]
                  |L25.74|
;;;886      
;;;887      /* Disable the Peripheral */
;;;888      __HAL_TIM_DISABLE(htim);
00004a  6820              LDR      r0,[r4,#0]
00004c  6a03              LDR      r3,[r0,#0x20]
00004e  420b              TST      r3,r1
000050  d106              BNE      |L25.96|
000052  6a01              LDR      r1,[r0,#0x20]
000054  4211              TST      r1,r2
000056  d103              BNE      |L25.96|
000058  6801              LDR      r1,[r0,#0]
00005a  f0210101          BIC      r1,r1,#1
00005e  6001              STR      r1,[r0,#0]
                  |L25.96|
;;;889      
;;;890      /* Change the htim state */
;;;891      htim->State = HAL_TIM_STATE_READY;
000060  2001              MOVS     r0,#1
000062  6420              STR      r0,[r4,#0x40]
;;;892      
;;;893      /* Return function status */
;;;894      return HAL_OK;
000064  2000              MOVS     r0,#0
;;;895    }
000066  bd10              POP      {r4,pc}
                  |L25.104|
000068  68d0              LDR      r0,[r2,#0xc]          ;866
00006a  f4206000          BIC      r0,r0,#0x800          ;866
00006e  e7d9              B        |L25.36|
                  |L25.112|
000070  68d0              LDR      r0,[r2,#0xc]          ;873
000072  f4205080          BIC      r0,r0,#0x1000         ;873
000076  e7d5              B        |L25.36|
;;;896    
                          ENDP


                          AREA ||i.HAL_TIMEx_OCN_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OCN_Stop_IT PROC
;;;651      */
;;;652    HAL_StatusTypeDef HAL_TIMEx_OCN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;653    {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L26.22|
;;;654      uint32_t tmpccer = 0; 
;;;655    
;;;656      /* Check the parameters */
;;;657      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
;;;658      
;;;659      switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L26.30|
00000c  2908              CMP      r1,#8
00000e  d032              BEQ      |L26.118|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L26.38|
000014  e033              B        |L26.126|
                  |L26.22|
;;;660      {
;;;661        case TIM_CHANNEL_1:
;;;662        {       
;;;663          /* Disable the TIM Output Compare interrupt */
;;;664          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f0200002          BIC      r0,r0,#2
;;;665        }
;;;666        break;
00001c  e002              B        |L26.36|
                  |L26.30|
;;;667        
;;;668        case TIM_CHANNEL_2:
;;;669        {
;;;670          /* Disable the TIM Output Compare interrupt */
;;;671          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f0200004          BIC      r0,r0,#4
                  |L26.36|
000024  60d0              STR      r0,[r2,#0xc]          ;664
                  |L26.38|
;;;672        }
;;;673        break;
;;;674        
;;;675        case TIM_CHANNEL_3:
;;;676        {
;;;677          /* Disable the TIM Output Compare interrupt */
;;;678          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
;;;679        }
;;;680        break;
;;;681        
;;;682        case TIM_CHANNEL_4:
;;;683        {
;;;684          /* Disable the TIM Output Compare interrupt */
;;;685          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
;;;686        }
;;;687        break;
;;;688        
;;;689        default:
;;;690        break; 
;;;691      }
;;;692    
;;;693      /* Disable the Capture compare channel N */
;;;694      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
000026  6820              LDR      r0,[r4,#0]
000028  2200              MOVS     r2,#0
00002a  f7fffffe          BL       TIM_CCxNChannelCmd
;;;695    
;;;696      /* Disable the TIM Break interrupt (only if no more channel is active) */
;;;697      tmpccer = htim->Instance->CCER;
00002e  6820              LDR      r0,[r4,#0]
;;;698      if ((tmpccer & (TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE)) == RESET)
000030  f2404144          MOV      r1,#0x444
000034  6a02              LDR      r2,[r0,#0x20]         ;697
000036  420a              TST      r2,r1
000038  d103              BNE      |L26.66|
;;;699      {
;;;700        __HAL_TIM_DISABLE_IT(htim, TIM_IT_BREAK);
00003a  68c2              LDR      r2,[r0,#0xc]
00003c  f0220280          BIC      r2,r2,#0x80
000040  60c2              STR      r2,[r0,#0xc]
                  |L26.66|
;;;701      }
;;;702    
;;;703      /* Disable the Main Output */
;;;704      __HAL_TIM_MOE_DISABLE(htim);
000042  6820              LDR      r0,[r4,#0]
000044  f2411211          MOV      r2,#0x1111
000048  6a03              LDR      r3,[r0,#0x20]
00004a  4213              TST      r3,r2
00004c  d106              BNE      |L26.92|
00004e  6a03              LDR      r3,[r0,#0x20]
000050  420b              TST      r3,r1
000052  d103              BNE      |L26.92|
000054  6c43              LDR      r3,[r0,#0x44]
000056  f4234300          BIC      r3,r3,#0x8000
00005a  6443              STR      r3,[r0,#0x44]
                  |L26.92|
;;;705    
;;;706      /* Disable the Peripheral */
;;;707      __HAL_TIM_DISABLE(htim);
00005c  6820              LDR      r0,[r4,#0]
00005e  6a03              LDR      r3,[r0,#0x20]
000060  4213              TST      r3,r2
000062  d106              BNE      |L26.114|
000064  6a02              LDR      r2,[r0,#0x20]
000066  420a              TST      r2,r1
000068  d103              BNE      |L26.114|
00006a  6801              LDR      r1,[r0,#0]
00006c  f0210101          BIC      r1,r1,#1
000070  6001              STR      r1,[r0,#0]
                  |L26.114|
;;;708      
;;;709      /* Return function status */
;;;710      return HAL_OK;
000072  2000              MOVS     r0,#0
;;;711    } 
000074  bd10              POP      {r4,pc}
                  |L26.118|
000076  68d0              LDR      r0,[r2,#0xc]          ;678
000078  f0200008          BIC      r0,r0,#8              ;678
00007c  e7d2              B        |L26.36|
                  |L26.126|
00007e  68d0              LDR      r0,[r2,#0xc]          ;685
000080  f0200010          BIC      r0,r0,#0x10           ;685
000084  e7ce              B        |L26.36|
;;;712    
                          ENDP


                          AREA ||i.HAL_TIMEx_OnePulseN_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OnePulseN_Start PROC
;;;1345     */
;;;1346   HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b510              PUSH     {r4,lr}
;;;1347     {
;;;1348     /* Check the parameters */
;;;1349     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel)); 
;;;1350     
;;;1351     /* Enable the complementary One Pulse output */
;;;1352     TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE); 
000002  2204              MOVS     r2,#4
000004  4604              MOV      r4,r0                 ;1347
000006  6800              LDR      r0,[r0,#0]
000008  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1353     
;;;1354     /* Enable the Main Output */
;;;1355     __HAL_TIM_MOE_ENABLE(htim);
00000c  6820              LDR      r0,[r4,#0]
00000e  6c41              LDR      r1,[r0,#0x44]
000010  f4414100          ORR      r1,r1,#0x8000
000014  6441              STR      r1,[r0,#0x44]
;;;1356     
;;;1357     /* Return function status */
;;;1358     return HAL_OK;
000016  2000              MOVS     r0,#0
;;;1359   }
000018  bd10              POP      {r4,pc}
;;;1360   
                          ENDP


                          AREA ||i.HAL_TIMEx_OnePulseN_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OnePulseN_Start_IT PROC
;;;1401     */
;;;1402   HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b510              PUSH     {r4,lr}
;;;1403   {
000002  4604              MOV      r4,r0
;;;1404     /* Check the parameters */
;;;1405     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel)); 
;;;1406   
;;;1407     /* Enable the TIM Capture/Compare 1 interrupt */
;;;1408     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000004  6800              LDR      r0,[r0,#0]
000006  68c2              LDR      r2,[r0,#0xc]
000008  f0420202          ORR      r2,r2,#2
00000c  60c2              STR      r2,[r0,#0xc]
;;;1409     
;;;1410     /* Enable the TIM Capture/Compare 2 interrupt */
;;;1411     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
00000e  6820              LDR      r0,[r4,#0]
000010  68c2              LDR      r2,[r0,#0xc]
000012  f0420204          ORR      r2,r2,#4
000016  60c2              STR      r2,[r0,#0xc]
;;;1412     
;;;1413     /* Enable the complementary One Pulse output */
;;;1414     TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE); 
000018  6820              LDR      r0,[r4,#0]
00001a  2204              MOVS     r2,#4
00001c  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1415     
;;;1416     /* Enable the Main Output */
;;;1417     __HAL_TIM_MOE_ENABLE(htim);
000020  6820              LDR      r0,[r4,#0]
000022  6c41              LDR      r1,[r0,#0x44]
000024  f4414100          ORR      r1,r1,#0x8000
000028  6441              STR      r1,[r0,#0x44]
;;;1418     
;;;1419     /* Return function status */
;;;1420     return HAL_OK;
00002a  2000              MOVS     r0,#0
;;;1421     } 
00002c  bd10              POP      {r4,pc}
;;;1422     
                          ENDP


                          AREA ||i.HAL_TIMEx_OnePulseN_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OnePulseN_Stop PROC
;;;1371     */
;;;1372   HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b510              PUSH     {r4,lr}
;;;1373   {
;;;1374   
;;;1375     /* Check the parameters */
;;;1376     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel)); 
;;;1377   
;;;1378     /* Disable the complementary One Pulse output */
;;;1379       TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);
000002  2200              MOVS     r2,#0
000004  4604              MOV      r4,r0                 ;1373
000006  6800              LDR      r0,[r0,#0]
000008  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1380     
;;;1381     /* Disable the Main Output */
;;;1382       __HAL_TIM_MOE_DISABLE(htim);
00000c  6820              LDR      r0,[r4,#0]
00000e  f2411111          MOV      r1,#0x1111
000012  108a              ASRS     r2,r1,#2
000014  6a03              LDR      r3,[r0,#0x20]
000016  420b              TST      r3,r1
000018  d106              BNE      |L29.40|
00001a  6a03              LDR      r3,[r0,#0x20]
00001c  4213              TST      r3,r2
00001e  d103              BNE      |L29.40|
000020  6c43              LDR      r3,[r0,#0x44]
000022  f4234300          BIC      r3,r3,#0x8000
000026  6443              STR      r3,[r0,#0x44]
                  |L29.40|
;;;1383     
;;;1384     /* Disable the Peripheral */
;;;1385     __HAL_TIM_DISABLE(htim); 
000028  6820              LDR      r0,[r4,#0]
00002a  6a03              LDR      r3,[r0,#0x20]
00002c  420b              TST      r3,r1
00002e  d106              BNE      |L29.62|
000030  6a01              LDR      r1,[r0,#0x20]
000032  4211              TST      r1,r2
000034  d103              BNE      |L29.62|
000036  6801              LDR      r1,[r0,#0]
000038  f0210101          BIC      r1,r1,#1
00003c  6001              STR      r1,[r0,#0]
                  |L29.62|
;;;1386      
;;;1387     /* Return function status */
;;;1388     return HAL_OK;
00003e  2000              MOVS     r0,#0
;;;1389   }
000040  bd10              POP      {r4,pc}
;;;1390   
                          ENDP


                          AREA ||i.HAL_TIMEx_OnePulseN_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_OnePulseN_Stop_IT PROC
;;;1433     */
;;;1434   HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b510              PUSH     {r4,lr}
;;;1435   {
000002  4604              MOV      r4,r0
;;;1436     /* Check the parameters */
;;;1437     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel)); 
;;;1438   
;;;1439     /* Disable the TIM Capture/Compare 1 interrupt */
;;;1440     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000004  6800              LDR      r0,[r0,#0]
000006  68c2              LDR      r2,[r0,#0xc]
000008  f0220202          BIC      r2,r2,#2
00000c  60c2              STR      r2,[r0,#0xc]
;;;1441     
;;;1442     /* Disable the TIM Capture/Compare 2 interrupt */
;;;1443     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00000e  6820              LDR      r0,[r4,#0]
000010  68c2              LDR      r2,[r0,#0xc]
000012  f0220204          BIC      r2,r2,#4
000016  60c2              STR      r2,[r0,#0xc]
;;;1444     
;;;1445     /* Disable the complementary One Pulse output */
;;;1446     TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);
000018  6820              LDR      r0,[r4,#0]
00001a  2200              MOVS     r2,#0
00001c  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1447     
;;;1448     /* Disable the Main Output */
;;;1449     __HAL_TIM_MOE_DISABLE(htim);
000020  6820              LDR      r0,[r4,#0]
000022  f2411111          MOV      r1,#0x1111
000026  108a              ASRS     r2,r1,#2
000028  6a03              LDR      r3,[r0,#0x20]
00002a  420b              TST      r3,r1
00002c  d106              BNE      |L30.60|
00002e  6a03              LDR      r3,[r0,#0x20]
000030  4213              TST      r3,r2
000032  d103              BNE      |L30.60|
000034  6c43              LDR      r3,[r0,#0x44]
000036  f4234300          BIC      r3,r3,#0x8000
00003a  6443              STR      r3,[r0,#0x44]
                  |L30.60|
;;;1450     
;;;1451     /* Disable the Peripheral */
;;;1452      __HAL_TIM_DISABLE(htim);  
00003c  6820              LDR      r0,[r4,#0]
00003e  6a03              LDR      r3,[r0,#0x20]
000040  420b              TST      r3,r1
000042  d106              BNE      |L30.82|
000044  6a01              LDR      r1,[r0,#0x20]
000046  4211              TST      r1,r2
000048  d103              BNE      |L30.82|
00004a  6801              LDR      r1,[r0,#0]
00004c  f0210101          BIC      r1,r1,#1
000050  6001              STR      r1,[r0,#0]
                  |L30.82|
;;;1453     
;;;1454     /* Return function status */
;;;1455     return HAL_OK;
000052  2000              MOVS     r0,#0
;;;1456   }
000054  bd10              POP      {r4,pc}
;;;1457   
                          ENDP


                          AREA ||i.HAL_TIMEx_PWMN_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_PWMN_Start PROC
;;;941      */
;;;942    HAL_StatusTypeDef HAL_TIMEx_PWMN_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;943    {
;;;944      /* Check the parameters */
;;;945      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
;;;946      
;;;947      /* Enable the complementary PWM output  */
;;;948      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
000002  2204              MOVS     r2,#4
000004  4604              MOV      r4,r0                 ;943
000006  6800              LDR      r0,[r0,#0]
000008  f7fffffe          BL       TIM_CCxNChannelCmd
;;;949      
;;;950      /* Enable the Main Output */
;;;951      __HAL_TIM_MOE_ENABLE(htim);
00000c  6820              LDR      r0,[r4,#0]
00000e  6c41              LDR      r1,[r0,#0x44]
000010  f4414100          ORR      r1,r1,#0x8000
000014  6441              STR      r1,[r0,#0x44]
;;;952      
;;;953      /* Enable the Peripheral */
;;;954      __HAL_TIM_ENABLE(htim);
000016  6820              LDR      r0,[r4,#0]
000018  6801              LDR      r1,[r0,#0]
00001a  f0410101          ORR      r1,r1,#1
00001e  6001              STR      r1,[r0,#0]
;;;955      
;;;956      /* Return function status */
;;;957      return HAL_OK;
000020  2000              MOVS     r0,#0
;;;958    } 
000022  bd10              POP      {r4,pc}
;;;959    
                          ENDP


                          AREA ||i.HAL_TIMEx_PWMN_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIMEx_PWMN_Start_DMA PROC
;;;1142     */
;;;1143   HAL_StatusTypeDef HAL_TIMEx_PWMN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;1144   {
000002  4604              MOV      r4,r0
;;;1145     /* Check the parameters */
;;;1146     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
;;;1147     
;;;1148     if((htim->State == HAL_TIM_STATE_BUSY))
000004  6c00              LDR      r0,[r0,#0x40]
000006  4616              MOV      r6,r2                 ;1144
000008  460d              MOV      r5,r1                 ;1144
00000a  2802              CMP      r0,#2
00000c  d004              BEQ      |L32.24|
;;;1149     {
;;;1150        return HAL_BUSY;
;;;1151     }
;;;1152     else if((htim->State == HAL_TIM_STATE_READY))
00000e  6c20              LDR      r0,[r4,#0x40]
000010  2801              CMP      r0,#1
000012  d104              BNE      |L32.30|
;;;1153     {
;;;1154       if(((uint32_t)pData == 0 ) && (Length > 0)) 
000014  b90e              CBNZ     r6,|L32.26|
000016  b103              CBZ      r3,|L32.26|
                  |L32.24|
;;;1155       {
;;;1156         return HAL_ERROR;                                    
;;;1157       }
;;;1158       else
;;;1159       {
;;;1160         htim->State = HAL_TIM_STATE_BUSY;
;;;1161       }
;;;1162     }    
;;;1163     switch (Channel)
;;;1164     {
;;;1165       case TIM_CHANNEL_1:
;;;1166       {      
;;;1167         /* Set the DMA Period elapsed callback */
;;;1168         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;1169        
;;;1170         /* Set the DMA error callback */
;;;1171         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
;;;1172         
;;;1173         /* Enable the DMA Stream */
;;;1174         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
;;;1175         
;;;1176         /* Enable the TIM Capture/Compare 1 DMA request */
;;;1177         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;1178       }
;;;1179       break;
;;;1180       
;;;1181       case TIM_CHANNEL_2:
;;;1182       {
;;;1183         /* Set the DMA Period elapsed callback */
;;;1184         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;1185        
;;;1186         /* Set the DMA error callback */
;;;1187         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
;;;1188         
;;;1189         /* Enable the DMA Stream */
;;;1190         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
;;;1191         
;;;1192         /* Enable the TIM Capture/Compare 2 DMA request */
;;;1193         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;1194       }
;;;1195       break;
;;;1196       
;;;1197       case TIM_CHANNEL_3:
;;;1198       {
;;;1199         /* Set the DMA Period elapsed callback */
;;;1200         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;1201        
;;;1202         /* Set the DMA error callback */
;;;1203         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
;;;1204         
;;;1205         /* Enable the DMA Stream */
;;;1206         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
;;;1207         
;;;1208         /* Enable the TIM Capture/Compare 3 DMA request */
;;;1209         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;1210       }
;;;1211       break;
;;;1212       
;;;1213       case TIM_CHANNEL_4:
;;;1214       {
;;;1215        /* Set the DMA Period elapsed callback */
;;;1216         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;1217        
;;;1218         /* Set the DMA error callback */
;;;1219         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
;;;1220         
;;;1221         /* Enable the DMA Stream */
;;;1222         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
;;;1223         
;;;1224         /* Enable the TIM Capture/Compare 4 DMA request */
;;;1225         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;1226       }
;;;1227       break;
;;;1228       
;;;1229       default:
;;;1230       break;
;;;1231     }
;;;1232   
;;;1233     /* Enable the complementary PWM output  */
;;;1234        TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
;;;1235       
;;;1236     /* Enable the Main Output */
;;;1237       __HAL_TIM_MOE_ENABLE(htim);
;;;1238     
;;;1239     /* Enable the Peripheral */
;;;1240     __HAL_TIM_ENABLE(htim); 
;;;1241     
;;;1242     /* Return function status */
;;;1243     return HAL_OK;
;;;1244   }
000018  bd70              POP      {r4-r6,pc}
                  |L32.26|
00001a  2002              MOVS     r0,#2                 ;1160
00001c  6420              STR      r0,[r4,#0x40]         ;1160
                  |L32.30|
00001e  482b              LDR      r0,|L32.204|
000020  492b              LDR      r1,|L32.208|
000022  b135              CBZ      r5,|L32.50|
000024  2d04              CMP      r5,#4                 ;1163
000026  d013              BEQ      |L32.80|
000028  2d08              CMP      r5,#8                 ;1163
00002a  d031              BEQ      |L32.144|
00002c  2d0c              CMP      r5,#0xc               ;1163
00002e  d11e              BNE      |L32.110|
000030  e03d              B        |L32.174|
                  |L32.50|
000032  6a62              LDR      r2,[r4,#0x24]         ;1168
000034  6410              STR      r0,[r2,#0x40]         ;1171
000036  6a60              LDR      r0,[r4,#0x24]         ;1171
000038  6501              STR      r1,[r0,#0x50]         ;1174
00003a  4631              MOV      r1,r6                 ;1174
00003c  6822              LDR      r2,[r4,#0]            ;1174
00003e  6a60              LDR      r0,[r4,#0x24]         ;1174
000040  3234              ADDS     r2,r2,#0x34           ;1174
000042  f7fffffe          BL       HAL_DMA_Start_IT
000046  6820              LDR      r0,[r4,#0]            ;1177
000048  68c1              LDR      r1,[r0,#0xc]          ;1177
00004a  f4417100          ORR      r1,r1,#0x200          ;1177
00004e  e00d              B        |L32.108|
                  |L32.80|
000050  6aa2              LDR      r2,[r4,#0x28]         ;1184
000052  6410              STR      r0,[r2,#0x40]         ;1187
000054  6aa0              LDR      r0,[r4,#0x28]         ;1187
000056  6501              STR      r1,[r0,#0x50]         ;1190
000058  4631              MOV      r1,r6                 ;1190
00005a  6822              LDR      r2,[r4,#0]            ;1190
00005c  6aa0              LDR      r0,[r4,#0x28]         ;1190
00005e  3238              ADDS     r2,r2,#0x38           ;1190
000060  f7fffffe          BL       HAL_DMA_Start_IT
000064  6820              LDR      r0,[r4,#0]            ;1193
000066  68c1              LDR      r1,[r0,#0xc]          ;1193
000068  f4416180          ORR      r1,r1,#0x400          ;1193
                  |L32.108|
00006c  60c1              STR      r1,[r0,#0xc]          ;1177
                  |L32.110|
00006e  6820              LDR      r0,[r4,#0]            ;1234
000070  2204              MOVS     r2,#4                 ;1234
000072  4629              MOV      r1,r5                 ;1234
000074  f7fffffe          BL       TIM_CCxNChannelCmd
000078  6820              LDR      r0,[r4,#0]            ;1237
00007a  6c41              LDR      r1,[r0,#0x44]         ;1237
00007c  f4414100          ORR      r1,r1,#0x8000         ;1237
000080  6441              STR      r1,[r0,#0x44]         ;1237
000082  6820              LDR      r0,[r4,#0]            ;1240
000084  6801              LDR      r1,[r0,#0]            ;1240
000086  f0410101          ORR      r1,r1,#1              ;1240
00008a  6001              STR      r1,[r0,#0]            ;1240
00008c  2000              MOVS     r0,#0                 ;1243
00008e  bd70              POP      {r4-r6,pc}
                  |L32.144|
000090  6ae2              LDR      r2,[r4,#0x2c]         ;1200
000092  6410              STR      r0,[r2,#0x40]         ;1203
000094  6ae0              LDR      r0,[r4,#0x2c]         ;1203
000096  6501              STR      r1,[r0,#0x50]         ;1206
000098  4631              MOV      r1,r6                 ;1206
00009a  6822              LDR      r2,[r4,#0]            ;1206
00009c  6ae0              LDR      r0,[r4,#0x2c]         ;1206
00009e  323c              ADDS     r2,r2,#0x3c           ;1206
0000a0  f7fffffe          BL       HAL_DMA_Start_IT
0000a4  6820              LDR      r0,[r4,#0]            ;1209
0000a6  68c1              LDR      r1,[r0,#0xc]          ;1209
0000a8  f4416100          ORR      r1,r1,#0x800          ;1209
0000ac  e7de              B        |L32.108|
                  |L32.174|
0000ae  6b22              LDR      r2,[r4,#0x30]         ;1216
0000b0  6410              STR      r0,[r2,#0x40]         ;1219
0000b2  6b20              LDR      r0,[r4,#0x30]         ;1219
0000b4  6501              STR      r1,[r0,#0x50]         ;1222
0000b6  4631              MOV      r1,r6                 ;1222
0000b8  6822              LDR      r2,[r4,#0]            ;1222
0000ba  6b20              LDR      r0,[r4,#0x30]         ;1222
0000bc  3240              ADDS     r2,r2,#0x40           ;1222
0000be  f7fffffe          BL       HAL_DMA_Start_IT
0000c2  6820              LDR      r0,[r4,#0]            ;1225
0000c4  68c1              LDR      r1,[r0,#0xc]          ;1225
0000c6  f4415180          ORR      r1,r1,#0x1000         ;1225
0000ca  e7cf              B        |L32.108|
;;;1245   
                          ENDP

                  |L32.204|
                          DCD      TIM_DMADelayPulseCplt
                  |L32.208|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIMEx_PWMN_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_PWMN_Start_IT PROC
;;;1000     */
;;;1001   HAL_StatusTypeDef HAL_TIMEx_PWMN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1002   {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L33.22|
;;;1003     /* Check the parameters */
;;;1004     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
;;;1005     
;;;1006     switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L33.30|
00000c  2908              CMP      r1,#8
00000e  d01f              BEQ      |L33.80|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L33.38|
000014  e020              B        |L33.88|
                  |L33.22|
;;;1007     {
;;;1008       case TIM_CHANNEL_1:
;;;1009       {       
;;;1010         /* Enable the TIM Capture/Compare 1 interrupt */
;;;1011         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f0400002          ORR      r0,r0,#2
;;;1012       }
;;;1013       break;
00001c  e002              B        |L33.36|
                  |L33.30|
;;;1014       
;;;1015       case TIM_CHANNEL_2:
;;;1016       {
;;;1017         /* Enable the TIM Capture/Compare 2 interrupt */
;;;1018         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f0400004          ORR      r0,r0,#4
                  |L33.36|
000024  60d0              STR      r0,[r2,#0xc]          ;1011
                  |L33.38|
;;;1019       }
;;;1020       break;
;;;1021       
;;;1022       case TIM_CHANNEL_3:
;;;1023       {
;;;1024         /* Enable the TIM Capture/Compare 3 interrupt */
;;;1025         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
;;;1026       }
;;;1027       break;
;;;1028       
;;;1029       case TIM_CHANNEL_4:
;;;1030       {
;;;1031         /* Enable the TIM Capture/Compare 4 interrupt */
;;;1032         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
;;;1033       }
;;;1034       break;
;;;1035       
;;;1036       default:
;;;1037       break;
;;;1038     } 
;;;1039     
;;;1040     /* Enable the TIM Break interrupt */
;;;1041     __HAL_TIM_ENABLE_IT(htim, TIM_IT_BREAK);
000026  6820              LDR      r0,[r4,#0]
000028  68c2              LDR      r2,[r0,#0xc]
00002a  f0420280          ORR      r2,r2,#0x80
00002e  60c2              STR      r2,[r0,#0xc]
;;;1042     
;;;1043     /* Enable the complementary PWM output  */
;;;1044     TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
000030  6820              LDR      r0,[r4,#0]
000032  2204              MOVS     r2,#4
000034  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1045     
;;;1046     /* Enable the Main Output */
;;;1047     __HAL_TIM_MOE_ENABLE(htim);
000038  6820              LDR      r0,[r4,#0]
00003a  6c41              LDR      r1,[r0,#0x44]
00003c  f4414100          ORR      r1,r1,#0x8000
000040  6441              STR      r1,[r0,#0x44]
;;;1048     
;;;1049     /* Enable the Peripheral */
;;;1050     __HAL_TIM_ENABLE(htim);
000042  6820              LDR      r0,[r4,#0]
000044  6801              LDR      r1,[r0,#0]
000046  f0410101          ORR      r1,r1,#1
00004a  6001              STR      r1,[r0,#0]
;;;1051     
;;;1052     /* Return function status */
;;;1053     return HAL_OK;
00004c  2000              MOVS     r0,#0
;;;1054   } 
00004e  bd10              POP      {r4,pc}
                  |L33.80|
000050  68d0              LDR      r0,[r2,#0xc]          ;1025
000052  f0400008          ORR      r0,r0,#8              ;1025
000056  e7e5              B        |L33.36|
                  |L33.88|
000058  68d0              LDR      r0,[r2,#0xc]          ;1032
00005a  f0400010          ORR      r0,r0,#0x10           ;1032
00005e  e7e1              B        |L33.36|
;;;1055   
                          ENDP


                          AREA ||i.HAL_TIMEx_PWMN_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_PWMN_Stop PROC
;;;970      */
;;;971    HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;972    { 
;;;973      /* Check the parameters */
;;;974      assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
;;;975      
;;;976      /* Disable the complementary PWM output  */
;;;977      TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);  
000002  2200              MOVS     r2,#0
000004  4604              MOV      r4,r0                 ;972
000006  6800              LDR      r0,[r0,#0]
000008  f7fffffe          BL       TIM_CCxNChannelCmd
;;;978      
;;;979      /* Disable the Main Output */
;;;980      __HAL_TIM_MOE_DISABLE(htim);
00000c  6820              LDR      r0,[r4,#0]
00000e  f2411111          MOV      r1,#0x1111
000012  108a              ASRS     r2,r1,#2
000014  6a03              LDR      r3,[r0,#0x20]
000016  420b              TST      r3,r1
000018  d106              BNE      |L34.40|
00001a  6a03              LDR      r3,[r0,#0x20]
00001c  4213              TST      r3,r2
00001e  d103              BNE      |L34.40|
000020  6c43              LDR      r3,[r0,#0x44]
000022  f4234300          BIC      r3,r3,#0x8000
000026  6443              STR      r3,[r0,#0x44]
                  |L34.40|
;;;981      
;;;982      /* Disable the Peripheral */
;;;983      __HAL_TIM_DISABLE(htim);
000028  6820              LDR      r0,[r4,#0]
00002a  6a03              LDR      r3,[r0,#0x20]
00002c  420b              TST      r3,r1
00002e  d106              BNE      |L34.62|
000030  6a01              LDR      r1,[r0,#0x20]
000032  4211              TST      r1,r2
000034  d103              BNE      |L34.62|
000036  6801              LDR      r1,[r0,#0]
000038  f0210101          BIC      r1,r1,#1
00003c  6001              STR      r1,[r0,#0]
                  |L34.62|
;;;984      
;;;985      /* Return function status */
;;;986      return HAL_OK;
00003e  2000              MOVS     r0,#0
;;;987    } 
000040  bd10              POP      {r4,pc}
;;;988    
                          ENDP


                          AREA ||i.HAL_TIMEx_PWMN_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_PWMN_Stop_DMA PROC
;;;1257     */
;;;1258   HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1259   {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L35.22|
;;;1260     /* Check the parameters */
;;;1261     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
;;;1262     
;;;1263     switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L35.30|
00000c  2908              CMP      r1,#8
00000e  d02b              BEQ      |L35.104|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L35.38|
000014  e02c              B        |L35.112|
                  |L35.22|
;;;1264     {
;;;1265       case TIM_CHANNEL_1:
;;;1266       {       
;;;1267         /* Disable the TIM Capture/Compare 1 DMA request */
;;;1268         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f4207000          BIC      r0,r0,#0x200
;;;1269       }
;;;1270       break;
00001c  e002              B        |L35.36|
                  |L35.30|
;;;1271       
;;;1272       case TIM_CHANNEL_2:
;;;1273       {
;;;1274         /* Disable the TIM Capture/Compare 2 DMA request */
;;;1275         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f4206080          BIC      r0,r0,#0x400
                  |L35.36|
000024  60d0              STR      r0,[r2,#0xc]          ;1268
                  |L35.38|
;;;1276       }
;;;1277       break;
;;;1278       
;;;1279       case TIM_CHANNEL_3:
;;;1280       {
;;;1281         /* Disable the TIM Capture/Compare 3 DMA request */
;;;1282         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
;;;1283       }
;;;1284       break;
;;;1285       
;;;1286       case TIM_CHANNEL_4:
;;;1287       {
;;;1288         /* Disable the TIM Capture/Compare 4 DMA request */
;;;1289         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
;;;1290       }
;;;1291       break;
;;;1292       
;;;1293       default:
;;;1294       break;
;;;1295     } 
;;;1296     
;;;1297     /* Disable the complementary PWM output */
;;;1298       TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
000026  6820              LDR      r0,[r4,#0]
000028  2200              MOVS     r2,#0
00002a  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1299        
;;;1300     /* Disable the Main Output */
;;;1301       __HAL_TIM_MOE_DISABLE(htim);
00002e  6820              LDR      r0,[r4,#0]
000030  f2411111          MOV      r1,#0x1111
000034  108a              ASRS     r2,r1,#2
000036  6a03              LDR      r3,[r0,#0x20]
000038  420b              TST      r3,r1
00003a  d106              BNE      |L35.74|
00003c  6a03              LDR      r3,[r0,#0x20]
00003e  4213              TST      r3,r2
000040  d103              BNE      |L35.74|
000042  6c43              LDR      r3,[r0,#0x44]
000044  f4234300          BIC      r3,r3,#0x8000
000048  6443              STR      r3,[r0,#0x44]
                  |L35.74|
;;;1302   
;;;1303     /* Disable the Peripheral */
;;;1304     __HAL_TIM_DISABLE(htim);
00004a  6820              LDR      r0,[r4,#0]
00004c  6a03              LDR      r3,[r0,#0x20]
00004e  420b              TST      r3,r1
000050  d106              BNE      |L35.96|
000052  6a01              LDR      r1,[r0,#0x20]
000054  4211              TST      r1,r2
000056  d103              BNE      |L35.96|
000058  6801              LDR      r1,[r0,#0]
00005a  f0210101          BIC      r1,r1,#1
00005e  6001              STR      r1,[r0,#0]
                  |L35.96|
;;;1305     
;;;1306     /* Change the htim state */
;;;1307     htim->State = HAL_TIM_STATE_READY;
000060  2001              MOVS     r0,#1
000062  6420              STR      r0,[r4,#0x40]
;;;1308     
;;;1309     /* Return function status */
;;;1310     return HAL_OK;
000064  2000              MOVS     r0,#0
;;;1311   }
000066  bd10              POP      {r4,pc}
                  |L35.104|
000068  68d0              LDR      r0,[r2,#0xc]          ;1282
00006a  f4206000          BIC      r0,r0,#0x800          ;1282
00006e  e7d9              B        |L35.36|
                  |L35.112|
000070  68d0              LDR      r0,[r2,#0xc]          ;1289
000072  f4205080          BIC      r0,r0,#0x1000         ;1289
000076  e7d5              B        |L35.36|
;;;1312   
                          ENDP


                          AREA ||i.HAL_TIMEx_PWMN_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_PWMN_Stop_IT PROC
;;;1067     */
;;;1068   HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1069   {
000002  6802              LDR      r2,[r0,#0]
000004  4604              MOV      r4,r0
000006  b131              CBZ      r1,|L36.22|
;;;1070     uint32_t tmpccer = 0;
;;;1071     
;;;1072     /* Check the parameters */
;;;1073     assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel)); 
;;;1074   
;;;1075     switch (Channel)
000008  2904              CMP      r1,#4
00000a  d008              BEQ      |L36.30|
00000c  2908              CMP      r1,#8
00000e  d032              BEQ      |L36.118|
000010  290c              CMP      r1,#0xc
000012  d108              BNE      |L36.38|
000014  e033              B        |L36.126|
                  |L36.22|
;;;1076     {
;;;1077       case TIM_CHANNEL_1:
;;;1078       {       
;;;1079         /* Disable the TIM Capture/Compare 1 interrupt */
;;;1080         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000016  68d0              LDR      r0,[r2,#0xc]
000018  f0200002          BIC      r0,r0,#2
;;;1081       }
;;;1082       break;
00001c  e002              B        |L36.36|
                  |L36.30|
;;;1083       
;;;1084       case TIM_CHANNEL_2:
;;;1085       {
;;;1086         /* Disable the TIM Capture/Compare 2 interrupt */
;;;1087         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00001e  68d0              LDR      r0,[r2,#0xc]
000020  f0200004          BIC      r0,r0,#4
                  |L36.36|
000024  60d0              STR      r0,[r2,#0xc]          ;1080
                  |L36.38|
;;;1088       }
;;;1089       break;
;;;1090       
;;;1091       case TIM_CHANNEL_3:
;;;1092       {
;;;1093         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1094         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
;;;1095       }
;;;1096       break;
;;;1097       
;;;1098       case TIM_CHANNEL_4:
;;;1099       {
;;;1100         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1101         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
;;;1102       }
;;;1103       break;
;;;1104       
;;;1105       default:
;;;1106       break; 
;;;1107     }
;;;1108     
;;;1109     /* Disable the complementary PWM output  */
;;;1110     TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
000026  6820              LDR      r0,[r4,#0]
000028  2200              MOVS     r2,#0
00002a  f7fffffe          BL       TIM_CCxNChannelCmd
;;;1111     
;;;1112     /* Disable the TIM Break interrupt (only if no more channel is active) */
;;;1113     tmpccer = htim->Instance->CCER;
00002e  6820              LDR      r0,[r4,#0]
;;;1114     if ((tmpccer & (TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE)) == RESET)
000030  f2404144          MOV      r1,#0x444
000034  6a02              LDR      r2,[r0,#0x20]         ;1113
000036  420a              TST      r2,r1
000038  d103              BNE      |L36.66|
;;;1115     {
;;;1116       __HAL_TIM_DISABLE_IT(htim, TIM_IT_BREAK);
00003a  68c2              LDR      r2,[r0,#0xc]
00003c  f0220280          BIC      r2,r2,#0x80
000040  60c2              STR      r2,[r0,#0xc]
                  |L36.66|
;;;1117     }
;;;1118     
;;;1119     /* Disable the Main Output */
;;;1120     __HAL_TIM_MOE_DISABLE(htim);
000042  6820              LDR      r0,[r4,#0]
000044  f2411211          MOV      r2,#0x1111
000048  6a03              LDR      r3,[r0,#0x20]
00004a  4213              TST      r3,r2
00004c  d106              BNE      |L36.92|
00004e  6a03              LDR      r3,[r0,#0x20]
000050  420b              TST      r3,r1
000052  d103              BNE      |L36.92|
000054  6c43              LDR      r3,[r0,#0x44]
000056  f4234300          BIC      r3,r3,#0x8000
00005a  6443              STR      r3,[r0,#0x44]
                  |L36.92|
;;;1121     
;;;1122     /* Disable the Peripheral */
;;;1123     __HAL_TIM_DISABLE(htim);
00005c  6820              LDR      r0,[r4,#0]
00005e  6a03              LDR      r3,[r0,#0x20]
000060  4213              TST      r3,r2
000062  d106              BNE      |L36.114|
000064  6a02              LDR      r2,[r0,#0x20]
000066  420a              TST      r2,r1
000068  d103              BNE      |L36.114|
00006a  6801              LDR      r1,[r0,#0]
00006c  f0210101          BIC      r1,r1,#1
000070  6001              STR      r1,[r0,#0]
                  |L36.114|
;;;1124     
;;;1125     /* Return function status */
;;;1126     return HAL_OK;
000072  2000              MOVS     r0,#0
;;;1127   } 
000074  bd10              POP      {r4,pc}
                  |L36.118|
000076  68d0              LDR      r0,[r2,#0xc]          ;1094
000078  f0200008          BIC      r0,r0,#8              ;1094
00007c  e7d2              B        |L36.36|
                  |L36.126|
00007e  68d0              LDR      r0,[r2,#0xc]          ;1101
000080  f0200010          BIC      r0,r0,#0x10           ;1101
000084  e7ce              B        |L36.36|
;;;1128   
                          ENDP


                          AREA ||i.HAL_TIMEx_RemapConfig||, CODE, READONLY, ALIGN=1

                  HAL_TIMEx_RemapConfig PROC
;;;1896     */
;;;1897   HAL_StatusTypeDef HAL_TIMEx_RemapConfig(TIM_HandleTypeDef *htim, uint32_t Remap)
000000  b510              PUSH     {r4,lr}
;;;1898   {
;;;1899     __HAL_LOCK(htim);
000002  6bc2              LDR      r2,[r0,#0x3c]
000004  2a01              CMP      r2,#1
000006  d007              BEQ      |L37.24|
;;;1900       
;;;1901     /* Check parameters */
;;;1902     assert_param(IS_TIM_REMAP_INSTANCE(htim->Instance));
;;;1903     assert_param(IS_TIM_REMAP(Remap));
;;;1904     
;;;1905     /* Set the Timer remapping configuration */
;;;1906     htim->Instance->OR = Remap;
000008  6804              LDR      r4,[r0,#0]
00000a  2201              MOVS     r2,#1                 ;1899
;;;1907     
;;;1908     htim->State = HAL_TIM_STATE_READY;
;;;1909     
;;;1910     __HAL_UNLOCK(htim);  
00000c  2300              MOVS     r3,#0
00000e  6521              STR      r1,[r4,#0x50]         ;1906
000010  6402              STR      r2,[r0,#0x40]         ;1908
;;;1911     
;;;1912     return HAL_OK;
000012  63c3              STR      r3,[r0,#0x3c]
000014  4618              MOV      r0,r3
;;;1913   }
000016  bd10              POP      {r4,pc}
                  |L37.24|
000018  2002              MOVS     r0,#2                 ;1899
00001a  bd10              POP      {r4,pc}
;;;1914   
                          ENDP


                          AREA ||i.HAL_TIM_ConfigOCrefClear||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ConfigOCrefClear PROC
;;;2071     */ 
;;;2072   HAL_StatusTypeDef HAL_TIM_ConfigOCrefClear(TIM_HandleTypeDef *htim,
000000  b570              PUSH     {r4-r6,lr}
;;;2073                                              TIM_ClearInputConfigTypeDef *sClearInputConfig,
;;;2074                                              uint32_t Channel)
;;;2075   { 
000002  4604              MOV      r4,r0
;;;2076     uint32_t tmpsmcr = 0;
;;;2077   
;;;2078     /* Check the parameters */ 
;;;2079     assert_param(IS_TIM_OCXREF_CLEAR_INSTANCE(htim->Instance));
;;;2080     assert_param(IS_TIM_CLEARINPUT_SOURCE(sClearInputConfig->ClearInputSource));
;;;2081                                           
;;;2082     /* Check input state */
;;;2083     __HAL_LOCK(htim);
000004  6bc0              LDR      r0,[r0,#0x3c]
000006  4616              MOV      r6,r2                 ;2075
000008  460d              MOV      r5,r1                 ;2075
00000a  2801              CMP      r0,#1
00000c  d006              BEQ      |L38.28|
00000e  2001              MOVS     r0,#1
;;;2084     
;;;2085     switch (sClearInputConfig->ClearInputSource)
000010  63e0              STR      r0,[r4,#0x3c]
000012  6868              LDR      r0,[r5,#4]            ;2083
000014  b120              CBZ      r0,|L38.32|
000016  2801              CMP      r0,#1
000018  d10e              BNE      |L38.56|
00001a  e007              B        |L38.44|
                  |L38.28|
00001c  2002              MOVS     r0,#2                 ;2083
;;;2086     {
;;;2087       case TIM_CLEARINPUTSOURCE_NONE:
;;;2088       {
;;;2089         /* Get the TIMx SMCR register value */
;;;2090         tmpsmcr = htim->Instance->SMCR;
;;;2091         
;;;2092         /* Clear the ETR Bits */
;;;2093         tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
;;;2094         
;;;2095         /* Set TIMx_SMCR */
;;;2096         htim->Instance->SMCR = tmpsmcr;
;;;2097      }
;;;2098       break;
;;;2099   
;;;2100       case TIM_CLEARINPUTSOURCE_ETR:
;;;2101       {
;;;2102         /* Check the parameters */ 
;;;2103         assert_param(IS_TIM_CLEARINPUT_POLARITY(sClearInputConfig->ClearInputPolarity));
;;;2104         assert_param(IS_TIM_CLEARINPUT_PRESCALER(sClearInputConfig->ClearInputPrescaler));
;;;2105         assert_param(IS_TIM_CLEARINPUT_FILTER(sClearInputConfig->ClearInputFilter));
;;;2106         
;;;2107         TIM_ETR_SetConfig(htim->Instance,
;;;2108                           sClearInputConfig->ClearInputPrescaler,
;;;2109                           sClearInputConfig->ClearInputPolarity,
;;;2110                           sClearInputConfig->ClearInputFilter);
;;;2111       }
;;;2112       break;
;;;2113       default:  
;;;2114       break;
;;;2115     }
;;;2116     
;;;2117     switch (Channel)
;;;2118     { 
;;;2119       case TIM_CHANNEL_1:
;;;2120         {
;;;2121           if(sClearInputConfig->ClearInputState != RESET)
;;;2122           {
;;;2123             /* Enable the Ocref clear feature for Channel 1 */
;;;2124             htim->Instance->CCMR1 |= TIM_CCMR1_OC1CE;
;;;2125           }
;;;2126           else
;;;2127           {
;;;2128             /* Disable the Ocref clear feature for Channel 1 */
;;;2129             htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1CE;      
;;;2130           }
;;;2131         }    
;;;2132         break;
;;;2133       case TIM_CHANNEL_2:    
;;;2134         {
;;;2135           if(sClearInputConfig->ClearInputState != RESET)
;;;2136           {
;;;2137             /* Enable the Ocref clear feature for Channel 2 */
;;;2138             htim->Instance->CCMR1 |= TIM_CCMR1_OC2CE;
;;;2139           }
;;;2140           else
;;;2141           {
;;;2142             /* Disable the Ocref clear feature for Channel 2 */
;;;2143             htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2CE;      
;;;2144           }
;;;2145         }    
;;;2146       break;
;;;2147       case TIM_CHANNEL_3:    
;;;2148         {
;;;2149           if(sClearInputConfig->ClearInputState != RESET)
;;;2150           {
;;;2151             /* Enable the Ocref clear feature for Channel 3 */
;;;2152             htim->Instance->CCMR2 |= TIM_CCMR2_OC3CE;
;;;2153           }
;;;2154           else
;;;2155           {
;;;2156             /* Disable the Ocref clear feature for Channel 3 */
;;;2157             htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3CE;      
;;;2158           }
;;;2159         }    
;;;2160       break;
;;;2161       case TIM_CHANNEL_4:    
;;;2162         {
;;;2163           if(sClearInputConfig->ClearInputState != RESET)
;;;2164           {
;;;2165             /* Enable the Ocref clear feature for Channel 4 */
;;;2166             htim->Instance->CCMR2 |= TIM_CCMR2_OC4CE;
;;;2167           }
;;;2168           else
;;;2169           {
;;;2170             /* Disable the Ocref clear feature for Channel 4 */
;;;2171             htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4CE;      
;;;2172           }
;;;2173         }    
;;;2174       break;
;;;2175       case TIM_CHANNEL_5:    
;;;2176         {
;;;2177           if(sClearInputConfig->ClearInputState != RESET)
;;;2178           {
;;;2179             /* Enable the Ocref clear feature for Channel 1 */
;;;2180             htim->Instance->CCMR3 |= TIM_CCMR3_OC5CE;
;;;2181           }
;;;2182           else
;;;2183           {
;;;2184             /* Disable the Ocref clear feature for Channel 1 */
;;;2185             htim->Instance->CCMR3 &= ~TIM_CCMR3_OC5CE;      
;;;2186           }
;;;2187         }    
;;;2188       break;
;;;2189       case TIM_CHANNEL_6:    
;;;2190         {
;;;2191           if(sClearInputConfig->ClearInputState != RESET)
;;;2192           {
;;;2193             /* Enable the Ocref clear feature for Channel 1 */
;;;2194             htim->Instance->CCMR3 |= TIM_CCMR3_OC6CE;
;;;2195           }
;;;2196           else
;;;2197           {
;;;2198             /* Disable the Ocref clear feature for Channel 1 */
;;;2199             htim->Instance->CCMR3 &= ~TIM_CCMR3_OC6CE;      
;;;2200           }
;;;2201         }    
;;;2202       break;
;;;2203       default:  
;;;2204       break;
;;;2205     } 
;;;2206     
;;;2207     __HAL_UNLOCK(htim);
;;;2208   
;;;2209     return HAL_OK;  
;;;2210   }
00001e  bd70              POP      {r4-r6,pc}
                  |L38.32|
000020  6820              LDR      r0,[r4,#0]            ;2090
000022  6881              LDR      r1,[r0,#8]            ;2090
000024  f421417f          BIC      r1,r1,#0xff00         ;2093
000028  6081              STR      r1,[r0,#8]            ;2096
00002a  e005              B        |L38.56|
                  |L38.44|
00002c  6820              LDR      r0,[r4,#0]            ;2107
00002e  692b              LDR      r3,[r5,#0x10]         ;2107
000030  e9d52102          LDRD     r2,r1,[r5,#8]         ;2107
000034  f7fffffe          BL       TIM_ETR_SetConfig
                  |L38.56|
000038  2e0c              CMP      r6,#0xc               ;2117
00003a  d02d              BEQ      |L38.152|
00003c  dc05              BGT      |L38.74|
00003e  b14e              CBZ      r6,|L38.84|
000040  2e04              CMP      r6,#4                 ;2117
000042  d012              BEQ      |L38.106|
000044  2e08              CMP      r6,#8                 ;2117
000046  d149              BNE      |L38.220|
000048  e01b              B        |L38.130|
                  |L38.74|
00004a  2e10              CMP      r6,#0x10              ;2117
00004c  d030              BEQ      |L38.176|
00004e  2e14              CMP      r6,#0x14              ;2117
000050  d144              BNE      |L38.220|
000052  e038              B        |L38.198|
                  |L38.84|
000054  6828              LDR      r0,[r5,#0]            ;2121
000056  2800              CMP      r0,#0                 ;2121
000058  6820              LDR      r0,[r4,#0]            ;2129
00005a  6981              LDR      r1,[r0,#0x18]         ;2129
00005c  d002              BEQ      |L38.100|
00005e  f0410180          ORR      r1,r1,#0x80           ;2124
000062  e00c              B        |L38.126|
                  |L38.100|
000064  f0210180          BIC      r1,r1,#0x80           ;2129
000068  e009              B        |L38.126|
                  |L38.106|
00006a  6828              LDR      r0,[r5,#0]            ;2135
00006c  2800              CMP      r0,#0                 ;2135
00006e  6820              LDR      r0,[r4,#0]            ;2143
000070  6981              LDR      r1,[r0,#0x18]         ;2143
000072  d002              BEQ      |L38.122|
000074  f4414100          ORR      r1,r1,#0x8000         ;2138
000078  e001              B        |L38.126|
                  |L38.122|
00007a  f4214100          BIC      r1,r1,#0x8000         ;2143
                  |L38.126|
00007e  6181              STR      r1,[r0,#0x18]         ;2138
000080  e02c              B        |L38.220|
                  |L38.130|
000082  6828              LDR      r0,[r5,#0]            ;2149
000084  2800              CMP      r0,#0                 ;2149
000086  6820              LDR      r0,[r4,#0]            ;2157
000088  69c1              LDR      r1,[r0,#0x1c]         ;2157
00008a  d002              BEQ      |L38.146|
00008c  f0410180          ORR      r1,r1,#0x80           ;2152
000090  e00c              B        |L38.172|
                  |L38.146|
000092  f0210180          BIC      r1,r1,#0x80           ;2157
000096  e009              B        |L38.172|
                  |L38.152|
000098  6828              LDR      r0,[r5,#0]            ;2163
00009a  2800              CMP      r0,#0                 ;2163
00009c  6820              LDR      r0,[r4,#0]            ;2171
00009e  69c1              LDR      r1,[r0,#0x1c]         ;2171
0000a0  d002              BEQ      |L38.168|
0000a2  f4414100          ORR      r1,r1,#0x8000         ;2166
0000a6  e001              B        |L38.172|
                  |L38.168|
0000a8  f4214100          BIC      r1,r1,#0x8000         ;2171
                  |L38.172|
0000ac  61c1              STR      r1,[r0,#0x1c]         ;2166
0000ae  e015              B        |L38.220|
                  |L38.176|
0000b0  6828              LDR      r0,[r5,#0]            ;2177
0000b2  2800              CMP      r0,#0                 ;2177
0000b4  6820              LDR      r0,[r4,#0]            ;2185
0000b6  6d41              LDR      r1,[r0,#0x54]         ;2185
0000b8  d002              BEQ      |L38.192|
0000ba  f0410180          ORR      r1,r1,#0x80           ;2180
0000be  e00c              B        |L38.218|
                  |L38.192|
0000c0  f0210180          BIC      r1,r1,#0x80           ;2185
0000c4  e009              B        |L38.218|
                  |L38.198|
0000c6  6828              LDR      r0,[r5,#0]            ;2191
0000c8  2800              CMP      r0,#0                 ;2191
0000ca  6820              LDR      r0,[r4,#0]            ;2199
0000cc  6d41              LDR      r1,[r0,#0x54]         ;2199
0000ce  d002              BEQ      |L38.214|
0000d0  f4414100          ORR      r1,r1,#0x8000         ;2194
0000d4  e001              B        |L38.218|
                  |L38.214|
0000d6  f4214100          BIC      r1,r1,#0x8000         ;2199
                  |L38.218|
0000da  6541              STR      r1,[r0,#0x54]         ;2194
                  |L38.220|
0000dc  2000              MOVS     r0,#0                 ;2207
0000de  63e0              STR      r0,[r4,#0x3c]         ;2207
0000e0  bd70              POP      {r4-r6,pc}
;;;2211   
                          ENDP


                          AREA ||i.HAL_TIM_OC_ConfigChannel||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_ConfigChannel PROC
;;;2226     */
;;;2227   HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;2228   {  
000002  4604              MOV      r4,r0
;;;2229     /* Check the parameters */
;;;2230     assert_param(IS_TIM_CHANNELS(Channel)); 
;;;2231     assert_param(IS_TIM_OC_MODE(sConfig->OCMode));
;;;2232     assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
;;;2233     
;;;2234     /* Check input state */
;;;2235     __HAL_LOCK(htim); 
000004  6bc0              LDR      r0,[r0,#0x3c]
000006  2801              CMP      r0,#1
000008  d00c              BEQ      |L39.36|
00000a  2501              MOVS     r5,#1
;;;2236     
;;;2237     htim->State = HAL_TIM_STATE_BUSY;
;;;2238     
;;;2239     switch (Channel)
00000c  63e5              STR      r5,[r4,#0x3c]
00000e  2002              MOVS     r0,#2                 ;2237
000010  6420              STR      r0,[r4,#0x40]         ;2237
000012  2a0c              CMP      r2,#0xc
000014  d019              BEQ      |L39.74|
000016  dc07              BGT      |L39.40|
000018  b15a              CBZ      r2,|L39.50|
00001a  2a04              CMP      r2,#4
00001c  d00d              BEQ      |L39.58|
00001e  2a08              CMP      r2,#8
000020  d11e              BNE      |L39.96|
000022  e00e              B        |L39.66|
                  |L39.36|
000024  2002              MOVS     r0,#2                 ;2235
;;;2240     {
;;;2241       case TIM_CHANNEL_1:
;;;2242       {
;;;2243         /* Check the parameters */
;;;2244         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance)); 
;;;2245         
;;;2246        /* Configure the TIM Channel 1 in Output Compare */
;;;2247         TIM_OC1_SetConfig(htim->Instance, sConfig);
;;;2248       }
;;;2249       break;
;;;2250       
;;;2251       case TIM_CHANNEL_2:
;;;2252       {
;;;2253         /* Check the parameters */
;;;2254         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance)); 
;;;2255         
;;;2256         /* Configure the TIM Channel 2 in Output Compare */
;;;2257         TIM_OC2_SetConfig(htim->Instance, sConfig);
;;;2258       }
;;;2259       break;
;;;2260       
;;;2261       case TIM_CHANNEL_3:
;;;2262       {
;;;2263         /* Check the parameters */
;;;2264         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance)); 
;;;2265         
;;;2266         /* Configure the TIM Channel 3 in Output Compare */
;;;2267         TIM_OC3_SetConfig(htim->Instance, sConfig);
;;;2268       }
;;;2269       break;
;;;2270       
;;;2271       case TIM_CHANNEL_4:
;;;2272       {
;;;2273         /* Check the parameters */
;;;2274         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance)); 
;;;2275         
;;;2276          /* Configure the TIM Channel 4 in Output Compare */
;;;2277          TIM_OC4_SetConfig(htim->Instance, sConfig);
;;;2278       }
;;;2279       break;
;;;2280       
;;;2281       case TIM_CHANNEL_5:
;;;2282       {
;;;2283         /* Check the parameters */
;;;2284         assert_param(IS_TIM_CC5_INSTANCE(htim->Instance)); 
;;;2285         
;;;2286          /* Configure the TIM Channel 5 in Output Compare */
;;;2287          TIM_OC5_SetConfig(htim->Instance, sConfig);
;;;2288       }
;;;2289       break;
;;;2290       
;;;2291       case TIM_CHANNEL_6:
;;;2292       {
;;;2293         /* Check the parameters */
;;;2294         assert_param(IS_TIM_CC6_INSTANCE(htim->Instance)); 
;;;2295         
;;;2296          /* Configure the TIM Channel 6 in Output Compare */
;;;2297          TIM_OC6_SetConfig(htim->Instance, sConfig);
;;;2298       }
;;;2299       break;
;;;2300           
;;;2301       default:
;;;2302       break;    
;;;2303     }
;;;2304     
;;;2305     htim->State = HAL_TIM_STATE_READY;
;;;2306     
;;;2307     __HAL_UNLOCK(htim); 
;;;2308     
;;;2309     return HAL_OK;
;;;2310   }
000026  bd70              POP      {r4-r6,pc}
                  |L39.40|
000028  2a10              CMP      r2,#0x10              ;2239
00002a  d012              BEQ      |L39.82|
00002c  2a14              CMP      r2,#0x14              ;2239
00002e  d117              BNE      |L39.96|
000030  e013              B        |L39.90|
                  |L39.50|
000032  6820              LDR      r0,[r4,#0]            ;2247
000034  f7fffffe          BL       TIM_OC1_SetConfig
000038  e012              B        |L39.96|
                  |L39.58|
00003a  6820              LDR      r0,[r4,#0]            ;2257
00003c  f7fffffe          BL       TIM_OC2_SetConfig
000040  e00e              B        |L39.96|
                  |L39.66|
000042  6820              LDR      r0,[r4,#0]            ;2267
000044  f7fffffe          BL       TIM_OC3_SetConfig
000048  e00a              B        |L39.96|
                  |L39.74|
00004a  6820              LDR      r0,[r4,#0]            ;2277
00004c  f7fffffe          BL       TIM_OC4_SetConfig
000050  e006              B        |L39.96|
                  |L39.82|
000052  6820              LDR      r0,[r4,#0]            ;2287
000054  f7fffffe          BL       TIM_OC5_SetConfig
000058  e002              B        |L39.96|
                  |L39.90|
00005a  6820              LDR      r0,[r4,#0]            ;2297
00005c  f7fffffe          BL       TIM_OC6_SetConfig
                  |L39.96|
000060  2000              MOVS     r0,#0                 ;2307
000062  6425              STR      r5,[r4,#0x40]         ;2305
000064  63e0              STR      r0,[r4,#0x3c]         ;2307
000066  bd70              POP      {r4-r6,pc}
;;;2311   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_ConfigChannel||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_ConfigChannel PROC
;;;2326     */
;;;2327   HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, 
000000  b570              PUSH     {r4-r6,lr}
;;;2328                                               TIM_OC_InitTypeDef* sConfig, 
;;;2329                                               uint32_t Channel)
;;;2330   {
000002  4604              MOV      r4,r0
;;;2331     /* Check the parameters */
;;;2332     assert_param(IS_TIM_CHANNELS(Channel)); 
;;;2333     assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
;;;2334     assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
;;;2335     assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));
;;;2336     
;;;2337     /* Check input state */
;;;2338     __HAL_LOCK(htim);
000004  6bc0              LDR      r0,[r0,#0x3c]
000006  460d              MOV      r5,r1                 ;2330
000008  2801              CMP      r0,#1
00000a  d00c              BEQ      |L40.38|
00000c  2601              MOVS     r6,#1
;;;2339     
;;;2340     htim->State = HAL_TIM_STATE_BUSY;
;;;2341       
;;;2342     switch (Channel)
00000e  63e6              STR      r6,[r4,#0x3c]
000010  2002              MOVS     r0,#2                 ;2340
000012  6420              STR      r0,[r4,#0x40]         ;2340
000014  2a0c              CMP      r2,#0xc
000016  d045              BEQ      |L40.164|
000018  dc07              BGT      |L40.42|
00001a  b15a              CBZ      r2,|L40.52|
00001c  2a04              CMP      r2,#4
00001e  d01b              BEQ      |L40.88|
000020  2a08              CMP      r2,#8
000022  d178              BNE      |L40.278|
000024  e02c              B        |L40.128|
                  |L40.38|
000026  2002              MOVS     r0,#2                 ;2338
;;;2343     {
;;;2344       case TIM_CHANNEL_1:
;;;2345       {
;;;2346         /* Check the parameters */
;;;2347         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance)); 
;;;2348         
;;;2349         /* Configure the Channel 1 in PWM mode */
;;;2350         TIM_OC1_SetConfig(htim->Instance, sConfig);
;;;2351         
;;;2352         /* Set the Preload enable bit for channel1 */
;;;2353         htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
;;;2354         
;;;2355         /* Configure the Output Fast mode */
;;;2356         htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
;;;2357         htim->Instance->CCMR1 |= sConfig->OCFastMode;
;;;2358       }
;;;2359       break;
;;;2360       
;;;2361       case TIM_CHANNEL_2:
;;;2362       {
;;;2363         /* Check the parameters */
;;;2364         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance)); 
;;;2365         
;;;2366         /* Configure the Channel 2 in PWM mode */
;;;2367         TIM_OC2_SetConfig(htim->Instance, sConfig);
;;;2368         
;;;2369         /* Set the Preload enable bit for channel2 */
;;;2370         htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
;;;2371         
;;;2372         /* Configure the Output Fast mode */
;;;2373         htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
;;;2374         htim->Instance->CCMR1 |= sConfig->OCFastMode << 8;
;;;2375       }
;;;2376       break;
;;;2377       
;;;2378       case TIM_CHANNEL_3:
;;;2379       {
;;;2380         /* Check the parameters */
;;;2381         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance)); 
;;;2382         
;;;2383         /* Configure the Channel 3 in PWM mode */
;;;2384         TIM_OC3_SetConfig(htim->Instance, sConfig);
;;;2385         
;;;2386         /* Set the Preload enable bit for channel3 */
;;;2387         htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
;;;2388         
;;;2389        /* Configure the Output Fast mode */
;;;2390         htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
;;;2391         htim->Instance->CCMR2 |= sConfig->OCFastMode;  
;;;2392       }
;;;2393       break;
;;;2394       
;;;2395       case TIM_CHANNEL_4:
;;;2396       {
;;;2397         /* Check the parameters */
;;;2398         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance)); 
;;;2399         
;;;2400         /* Configure the Channel 4 in PWM mode */
;;;2401         TIM_OC4_SetConfig(htim->Instance, sConfig);
;;;2402         
;;;2403         /* Set the Preload enable bit for channel4 */
;;;2404         htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
;;;2405         
;;;2406        /* Configure the Output Fast mode */
;;;2407         htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
;;;2408         htim->Instance->CCMR2 |= sConfig->OCFastMode << 8;  
;;;2409       }
;;;2410       break;
;;;2411       
;;;2412       case TIM_CHANNEL_5:
;;;2413       {
;;;2414          /* Check the parameters */
;;;2415         assert_param(IS_TIM_CC5_INSTANCE(htim->Instance)); 
;;;2416         
;;;2417        /* Configure the Channel 5 in PWM mode */
;;;2418         TIM_OC5_SetConfig(htim->Instance, sConfig);
;;;2419         
;;;2420         /* Set the Preload enable bit for channel5*/
;;;2421         htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
;;;2422         
;;;2423        /* Configure the Output Fast mode */
;;;2424         htim->Instance->CCMR3 &= ~TIM_CCMR3_OC5FE;
;;;2425         htim->Instance->CCMR3 |= sConfig->OCFastMode;  
;;;2426       }
;;;2427       break;
;;;2428       
;;;2429       case TIM_CHANNEL_6:
;;;2430       {
;;;2431          /* Check the parameters */
;;;2432         assert_param(IS_TIM_CC6_INSTANCE(htim->Instance)); 
;;;2433         
;;;2434        /* Configure the Channel 5 in PWM mode */
;;;2435         TIM_OC6_SetConfig(htim->Instance, sConfig);
;;;2436         
;;;2437         /* Set the Preload enable bit for channel6 */
;;;2438         htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
;;;2439         
;;;2440        /* Configure the Output Fast mode */
;;;2441         htim->Instance->CCMR3 &= ~TIM_CCMR3_OC6FE;
;;;2442         htim->Instance->CCMR3 |= sConfig->OCFastMode << 8;  
;;;2443       }
;;;2444       break;
;;;2445       
;;;2446       default:
;;;2447       break;    
;;;2448     }
;;;2449     
;;;2450     htim->State = HAL_TIM_STATE_READY;
;;;2451       
;;;2452     __HAL_UNLOCK(htim);
;;;2453     
;;;2454     return HAL_OK;
;;;2455   }
000028  bd70              POP      {r4-r6,pc}
                  |L40.42|
00002a  2a10              CMP      r2,#0x10              ;2342
00002c  d04e              BEQ      |L40.204|
00002e  2a14              CMP      r2,#0x14              ;2342
000030  d171              BNE      |L40.278|
000032  e05d              B        |L40.240|
                  |L40.52|
000034  6820              LDR      r0,[r4,#0]            ;2350
000036  f7fffffe          BL       TIM_OC1_SetConfig
00003a  6820              LDR      r0,[r4,#0]            ;2353
00003c  6981              LDR      r1,[r0,#0x18]         ;2353
00003e  f0410108          ORR      r1,r1,#8              ;2353
000042  6181              STR      r1,[r0,#0x18]         ;2353
000044  6820              LDR      r0,[r4,#0]            ;2356
000046  6981              LDR      r1,[r0,#0x18]         ;2356
000048  f0210104          BIC      r1,r1,#4              ;2356
00004c  6181              STR      r1,[r0,#0x18]         ;2356
00004e  6820              LDR      r0,[r4,#0]            ;2357
000050  692a              LDR      r2,[r5,#0x10]         ;2357
000052  6981              LDR      r1,[r0,#0x18]         ;2357
000054  4311              ORRS     r1,r1,r2              ;2357
000056  e011              B        |L40.124|
                  |L40.88|
000058  6820              LDR      r0,[r4,#0]            ;2367
00005a  f7fffffe          BL       TIM_OC2_SetConfig
00005e  6820              LDR      r0,[r4,#0]            ;2370
000060  6981              LDR      r1,[r0,#0x18]         ;2370
000062  f4416100          ORR      r1,r1,#0x800          ;2370
000066  6181              STR      r1,[r0,#0x18]         ;2370
000068  6820              LDR      r0,[r4,#0]            ;2373
00006a  6981              LDR      r1,[r0,#0x18]         ;2373
00006c  f4216180          BIC      r1,r1,#0x400          ;2373
000070  6181              STR      r1,[r0,#0x18]         ;2373
000072  6820              LDR      r0,[r4,#0]            ;2374
000074  6929              LDR      r1,[r5,#0x10]         ;2374
000076  6982              LDR      r2,[r0,#0x18]         ;2374
000078  ea422101          ORR      r1,r2,r1,LSL #8       ;2374
                  |L40.124|
00007c  6181              STR      r1,[r0,#0x18]         ;2357
00007e  e04a              B        |L40.278|
                  |L40.128|
000080  6820              LDR      r0,[r4,#0]            ;2384
000082  f7fffffe          BL       TIM_OC3_SetConfig
000086  6820              LDR      r0,[r4,#0]            ;2387
000088  69c1              LDR      r1,[r0,#0x1c]         ;2387
00008a  f0410108          ORR      r1,r1,#8              ;2387
00008e  61c1              STR      r1,[r0,#0x1c]         ;2387
000090  6820              LDR      r0,[r4,#0]            ;2390
000092  69c1              LDR      r1,[r0,#0x1c]         ;2390
000094  f0210104          BIC      r1,r1,#4              ;2390
000098  61c1              STR      r1,[r0,#0x1c]         ;2390
00009a  6820              LDR      r0,[r4,#0]            ;2391
00009c  692a              LDR      r2,[r5,#0x10]         ;2391
00009e  69c1              LDR      r1,[r0,#0x1c]         ;2391
0000a0  4311              ORRS     r1,r1,r2              ;2391
0000a2  e011              B        |L40.200|
                  |L40.164|
0000a4  6820              LDR      r0,[r4,#0]            ;2401
0000a6  f7fffffe          BL       TIM_OC4_SetConfig
0000aa  6820              LDR      r0,[r4,#0]            ;2404
0000ac  69c1              LDR      r1,[r0,#0x1c]         ;2404
0000ae  f4416100          ORR      r1,r1,#0x800          ;2404
0000b2  61c1              STR      r1,[r0,#0x1c]         ;2404
0000b4  6820              LDR      r0,[r4,#0]            ;2407
0000b6  69c1              LDR      r1,[r0,#0x1c]         ;2407
0000b8  f4216180          BIC      r1,r1,#0x400          ;2407
0000bc  61c1              STR      r1,[r0,#0x1c]         ;2407
0000be  6820              LDR      r0,[r4,#0]            ;2408
0000c0  6929              LDR      r1,[r5,#0x10]         ;2408
0000c2  69c2              LDR      r2,[r0,#0x1c]         ;2408
0000c4  ea422101          ORR      r1,r2,r1,LSL #8       ;2408
                  |L40.200|
0000c8  61c1              STR      r1,[r0,#0x1c]         ;2391
0000ca  e024              B        |L40.278|
                  |L40.204|
0000cc  6820              LDR      r0,[r4,#0]            ;2418
0000ce  f7fffffe          BL       TIM_OC5_SetConfig
0000d2  6820              LDR      r0,[r4,#0]            ;2421
0000d4  6d41              LDR      r1,[r0,#0x54]         ;2421
0000d6  f0410108          ORR      r1,r1,#8              ;2421
0000da  6541              STR      r1,[r0,#0x54]         ;2421
0000dc  6820              LDR      r0,[r4,#0]            ;2424
0000de  6d41              LDR      r1,[r0,#0x54]         ;2424
0000e0  f0210104          BIC      r1,r1,#4              ;2424
0000e4  6541              STR      r1,[r0,#0x54]         ;2424
0000e6  6820              LDR      r0,[r4,#0]            ;2425
0000e8  692a              LDR      r2,[r5,#0x10]         ;2425
0000ea  6d41              LDR      r1,[r0,#0x54]         ;2425
0000ec  4311              ORRS     r1,r1,r2              ;2425
0000ee  e011              B        |L40.276|
                  |L40.240|
0000f0  6820              LDR      r0,[r4,#0]            ;2435
0000f2  f7fffffe          BL       TIM_OC6_SetConfig
0000f6  6820              LDR      r0,[r4,#0]            ;2438
0000f8  6d41              LDR      r1,[r0,#0x54]         ;2438
0000fa  f4416100          ORR      r1,r1,#0x800          ;2438
0000fe  6541              STR      r1,[r0,#0x54]         ;2438
000100  6820              LDR      r0,[r4,#0]            ;2441
000102  6d41              LDR      r1,[r0,#0x54]         ;2441
000104  f4216180          BIC      r1,r1,#0x400          ;2441
000108  6541              STR      r1,[r0,#0x54]         ;2441
00010a  6820              LDR      r0,[r4,#0]            ;2442
00010c  6929              LDR      r1,[r5,#0x10]         ;2442
00010e  6d42              LDR      r2,[r0,#0x54]         ;2442
000110  ea422101          ORR      r1,r2,r1,LSL #8       ;2442
                  |L40.276|
000114  6541              STR      r1,[r0,#0x54]         ;2425
                  |L40.278|
000116  2000              MOVS     r0,#0                 ;2452
000118  6426              STR      r6,[r4,#0x40]         ;2450
00011a  63e0              STR      r0,[r4,#0x3c]         ;2452
00011c  bd70              POP      {r4-r6,pc}
;;;2456   
                          ENDP


                          AREA ||i.TIMEx_DMACommutationCplt||, CODE, READONLY, ALIGN=1

                  TIMEx_DMACommutationCplt PROC
;;;2040     */
;;;2041   void HAL_TIMEx_DMACommutationCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2042   {
;;;2043     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6bc0              LDR      r0,[r0,#0x3c]
;;;2044     
;;;2045     htim->State= HAL_TIM_STATE_READY;
000004  2101              MOVS     r1,#1
000006  6401              STR      r1,[r0,#0x40]
;;;2046   
;;;2047   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;2048     htim->CommutationCallback(htim);
;;;2049   #else
;;;2050     HAL_TIMEx_CommutationCallback(htim); 
000008  f7fffffe          BL       HAL_TIMEx_CommutationCallback
;;;2051   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;2052   }
00000c  bd10              POP      {r4,pc}
;;;2053   /**
                          ENDP


                          AREA ||i.TIM_CCxNChannelCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxNChannelCmd PROC
;;;2468     */
;;;2469   static void TIM_CCxNChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelNState)
000000  b510              PUSH     {r4,lr}
;;;2470   {
;;;2471     uint32_t tmp = 0;
;;;2472   
;;;2473     /* Check the parameters */
;;;2474     assert_param(IS_TIM_ADVANCED_INSTANCE(TIMx));
;;;2475     assert_param(IS_TIM_COMPLEMENTARY_CHANNELS(Channel));
;;;2476   
;;;2477     tmp = TIM_CCER_CC1NE << Channel;
;;;2478   
;;;2479     /* Reset the CCxNE Bit */
;;;2480     TIMx->CCER &= ~tmp;
000002  6a04              LDR      r4,[r0,#0x20]
000004  2304              MOVS     r3,#4                 ;2477
;;;2481   
;;;2482     /* Set or reset the CCxNE Bit */ 
;;;2483     TIMx->CCER |= (uint32_t)(ChannelNState << Channel);
000006  408a              LSLS     r2,r2,r1
000008  408b              LSLS     r3,r3,r1              ;2477
00000a  439c              BICS     r4,r4,r3              ;2480
00000c  6204              STR      r4,[r0,#0x20]         ;2480
00000e  6a01              LDR      r1,[r0,#0x20]
000010  4311              ORRS     r1,r1,r2
000012  6201              STR      r1,[r0,#0x20]
;;;2484   }
000014  bd10              POP      {r4,pc}
;;;2485   
                          ENDP


                          AREA ||i.TIM_OC5_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC5_SetConfig PROC
;;;2491     */
;;;2492   static void TIM_OC5_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b5f0              PUSH     {r4-r7,lr}
;;;2493   {
;;;2494     uint32_t tmpccmrx = 0;
;;;2495     uint32_t tmpccer = 0;
;;;2496     uint32_t tmpcr2 = 0; 
;;;2497   
;;;2498     /* Disable the output: Reset the CCxE Bit */
;;;2499     TIMx->CCER &= ~TIM_CCER_CC5E;
000002  6a02              LDR      r2,[r0,#0x20]
;;;2500     
;;;2501     /* Get the TIMx CCER register value */
;;;2502     tmpccer = TIMx->CCER;
;;;2503     /* Get the TIMx CR2 register value */
;;;2504     tmpcr2 =  TIMx->CR2; 
;;;2505     /* Get the TIMx CCMR1 register value */
;;;2506     tmpccmrx = TIMx->CCMR3;
;;;2507   
;;;2508     /* Reset the Output Compare Mode Bits */
;;;2509     tmpccmrx &= ~(TIM_CCMR3_OC5M);
;;;2510     /* Select the Output Compare Mode */
;;;2511     tmpccmrx |= OC_Config->OCMode;
;;;2512     
;;;2513     /* Reset the Output Polarity level */
;;;2514     tmpccer &= ~TIM_CCER_CC5P;
;;;2515     /* Set the Output Compare Polarity */
;;;2516     tmpccer |= (OC_Config->OCPolarity << 16);
;;;2517   
;;;2518     if(IS_TIM_BREAK_INSTANCE(TIMx))
000004  f8dfc044          LDR      r12,|L43.76|
000008  f4223280          BIC      r2,r2,#0x10000        ;2499
00000c  6202              STR      r2,[r0,#0x20]         ;2499
00000e  6a05              LDR      r5,[r0,#0x20]         ;2502
000010  6842              LDR      r2,[r0,#4]            ;2504
000012  6d44              LDR      r4,[r0,#0x54]         ;2506
000014  f4253500          BIC      r5,r5,#0x20000        ;2514
000018  890e              LDRH     r6,[r1,#8]            ;2516
00001a  4560              CMP      r0,r12
00001c  4f0c              LDR      r7,|L43.80|
00001e  680b              LDR      r3,[r1,#0]
000020  ea040407          AND      r4,r4,r7              ;2509
000024  ea454506          ORR      r5,r5,r6,LSL #16      ;2516
000028  ea430304          ORR      r3,r3,r4              ;2511
00002c  d002              BEQ      |L43.52|
00002e  4c09              LDR      r4,|L43.84|
000030  42a0              CMP      r0,r4
000032  d104              BNE      |L43.62|
                  |L43.52|
;;;2519     {   
;;;2520       /* Reset the Output Compare IDLE State */
;;;2521       tmpcr2 &= ~TIM_CR2_OIS5;
;;;2522       /* Set the Output Idle state */
;;;2523       tmpcr2 |= (OC_Config->OCIdleState << 8);
000034  694c              LDR      r4,[r1,#0x14]
000036  f4223280          BIC      r2,r2,#0x10000        ;2521
00003a  ea422204          ORR      r2,r2,r4,LSL #8
                  |L43.62|
;;;2524     }
;;;2525     /* Write to TIMx CR2 */
;;;2526     TIMx->CR2 = tmpcr2;
00003e  6042              STR      r2,[r0,#4]
;;;2527     
;;;2528     /* Write to TIMx CCMR3 */
;;;2529     TIMx->CCMR3 = tmpccmrx;
000040  6543              STR      r3,[r0,#0x54]
;;;2530     
;;;2531     /* Set the Capture Compare Register value */
;;;2532     TIMx->CCR5 = OC_Config->Pulse;
000042  6849              LDR      r1,[r1,#4]
000044  6581              STR      r1,[r0,#0x58]
;;;2533     
;;;2534     /* Write to TIMx CCER */
;;;2535     TIMx->CCER = tmpccer;  
000046  6205              STR      r5,[r0,#0x20]
;;;2536   }
000048  bdf0              POP      {r4-r7,pc}
;;;2537   
                          ENDP

00004a  0000              DCW      0x0000
                  |L43.76|
                          DCD      0x40010000
                  |L43.80|
                          DCD      0xfffeff8f
                  |L43.84|
                          DCD      0x40010400

                          AREA ||i.TIM_OC6_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC6_SetConfig PROC
;;;2543     */
;;;2544   static void TIM_OC6_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b5f0              PUSH     {r4-r7,lr}
;;;2545   {
;;;2546     uint32_t tmpccmrx = 0;
;;;2547     uint32_t tmpccer = 0;
;;;2548     uint32_t tmpcr2 = 0; 
;;;2549   
;;;2550     /* Disable the output: Reset the CCxE Bit */
;;;2551     TIMx->CCER &= ~TIM_CCER_CC6E;
000002  6a02              LDR      r2,[r0,#0x20]
;;;2552     
;;;2553     /* Get the TIMx CCER register value */
;;;2554     tmpccer = TIMx->CCER;
;;;2555     /* Get the TIMx CR2 register value */
;;;2556     tmpcr2 =  TIMx->CR2; 
;;;2557     /* Get the TIMx CCMR1 register value */
;;;2558     tmpccmrx = TIMx->CCMR3;
;;;2559       
;;;2560     /* Reset the Output Compare Mode Bits */
;;;2561     tmpccmrx &= ~(TIM_CCMR3_OC6M);
;;;2562     /* Select the Output Compare Mode */
;;;2563     tmpccmrx |= (OC_Config->OCMode << 8);
;;;2564     
;;;2565     /* Reset the Output Polarity level */
;;;2566     tmpccer &= (uint32_t)~TIM_CCER_CC6P;
;;;2567     /* Set the Output Compare Polarity */
;;;2568     tmpccer |= (OC_Config->OCPolarity << 20);
;;;2569   
;;;2570     if(IS_TIM_BREAK_INSTANCE(TIMx))
000004  f8dfc044          LDR      r12,|L44.76|
000008  f4221280          BIC      r2,r2,#0x100000       ;2551
00000c  6202              STR      r2,[r0,#0x20]         ;2551
00000e  6a04              LDR      r4,[r0,#0x20]         ;2554
000010  6842              LDR      r2,[r0,#4]            ;2556
000012  6d43              LDR      r3,[r0,#0x54]         ;2558
000014  f4241400          BIC      r4,r4,#0x200000       ;2566
000018  890e              LDRH     r6,[r1,#8]            ;2568
00001a  4560              CMP      r0,r12
00001c  4f0c              LDR      r7,|L44.80|
00001e  680d              LDR      r5,[r1,#0]
000020  ea030307          AND      r3,r3,r7              ;2561
000024  ea445406          ORR      r4,r4,r6,LSL #20      ;2568
000028  ea432305          ORR      r3,r3,r5,LSL #8       ;2563
00002c  d002              BEQ      |L44.52|
00002e  4d09              LDR      r5,|L44.84|
000030  42a8              CMP      r0,r5
000032  d104              BNE      |L44.62|
                  |L44.52|
;;;2571     {   
;;;2572       /* Reset the Output Compare IDLE State */
;;;2573       tmpcr2 &= ~TIM_CR2_OIS6;
;;;2574       /* Set the Output Idle state */
;;;2575       tmpcr2 |= (OC_Config->OCIdleState << 10);
000034  694d              LDR      r5,[r1,#0x14]
000036  f4222280          BIC      r2,r2,#0x40000        ;2573
00003a  ea422285          ORR      r2,r2,r5,LSL #10
                  |L44.62|
;;;2576     }
;;;2577     
;;;2578     /* Write to TIMx CR2 */
;;;2579     TIMx->CR2 = tmpcr2;
00003e  6042              STR      r2,[r0,#4]
;;;2580     
;;;2581     /* Write to TIMx CCMR3 */
;;;2582     TIMx->CCMR3 = tmpccmrx;
000040  6543              STR      r3,[r0,#0x54]
;;;2583     
;;;2584     /* Set the Capture Compare Register value */
;;;2585     TIMx->CCR6 = OC_Config->Pulse;
000042  6849              LDR      r1,[r1,#4]
000044  65c1              STR      r1,[r0,#0x5c]
;;;2586     
;;;2587     /* Write to TIMx CCER */
;;;2588     TIMx->CCER = tmpccer;  
000046  6204              STR      r4,[r0,#0x20]
;;;2589   }
000048  bdf0              POP      {r4-r7,pc}
;;;2590   
                          ENDP

00004a  0000              DCW      0x0000
                  |L44.76|
                          DCD      0x40010000
                  |L44.80|
                          DCD      0xfeff8fff
                  |L44.84|
                          DCD      0x40010400

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F7_V1.11.0\\Drivers\\STM32F7xx_HAL_Driver\\Src\\stm32f7xx_hal_tim_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f7xx_hal_tim_ex_c_e8ef3920____REV16|
#line 468 "D:\\Program_Files_x86\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.3.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___22_stm32f7xx_hal_tim_ex_c_e8ef3920____REV16| PROC
#line 469

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f7xx_hal_tim_ex_c_e8ef3920____REVSH|
#line 483
|__asm___22_stm32f7xx_hal_tim_ex_c_e8ef3920____REVSH| PROC
#line 484

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f7xx_hal_tim_ex_c_e8ef3920____RRX|
#line 670
|__asm___22_stm32f7xx_hal_tim_ex_c_e8ef3920____RRX| PROC
#line 671

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
