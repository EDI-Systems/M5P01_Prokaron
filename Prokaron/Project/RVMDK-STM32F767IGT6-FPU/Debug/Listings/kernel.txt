; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\kernel.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\kernel.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Core -I..\..\..\M0P0_Library\STM32F7xx_HAL_Driver\Inc -I.\Source -I.\Drivers -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6-ALIENTEK\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\kernel.crf ..\..\MProkaron\Kernel\kernel.c]
                          THUMB

                          AREA ||i.RMP_CRC16||, CODE, READONLY, ALIGN=2

                  RMP_CRC16 PROC
;;;264    #ifdef __U16__
;;;265    ptr_t RMP_CRC16(const u8* Data, ptr_t Length)
000000  b5f0              PUSH     {r4-r7,lr}
;;;266    {
000002  b0c1              SUB      sp,sp,#0x104
000004  460c              MOV      r4,r1
;;;267        ptr_t Data_Cnt;
;;;268        u8 Index;
;;;269        u8 Temp_High;
;;;270        u8 Temp_Low;
;;;271        
;;;272        /* CRC16 constants with X^16+X^15+X^2+1 */
;;;273        static const u8 CRC16_High[256]=
;;;274        {
;;;275            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;276            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;277            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;278            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;279            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;280            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;281            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;282            0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;283            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;284            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;285            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;286            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;287            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;288            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;289            0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;290            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;291            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;292            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;293            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;294            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;295            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;296            0x00, 0xC1, 0x81, 0x40
;;;297        };
;;;298    
;;;299        const u8 CRC16_Low[256]=
000006  490c              LDR      r1,|L1.56|
000008  f44f7280          MOV      r2,#0x100
00000c  4605              MOV      r5,r0                 ;266
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       __aeabi_memcpy4
;;;300        {
;;;301            0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7,
;;;302            0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E,
;;;303            0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9,
;;;304            0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC,
;;;305            0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
;;;306            0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32,
;;;307            0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D,
;;;308            0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38,
;;;309            0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF,
;;;310            0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
;;;311            0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1,
;;;312            0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4,
;;;313            0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB,
;;;314            0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA,
;;;315            0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
;;;316            0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0,
;;;317            0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97,
;;;318            0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E,
;;;319            0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89,
;;;320            0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
;;;321            0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83,
;;;322            0x41, 0x81, 0x80, 0x40
;;;323        };
;;;324    
;;;325        Temp_High=0xFF;
000014  20ff              MOVS     r0,#0xff
;;;326        Temp_Low=0xFF;
;;;327        for(Data_Cnt=0;Data_Cnt<Length;Data_Cnt++)
;;;328        {
;;;329            Index=Temp_Low^Data[Data_Cnt];
;;;330            Temp_Low=(u8)(Temp_High^CRC16_High[Index]);
000016  4f09              LDR      r7,|L1.60|
000018  2200              MOVS     r2,#0                 ;327
00001a  4603              MOV      r3,r0                 ;326
00001c  466e              MOV      r6,sp                 ;299
00001e  e005              B        |L1.44|
                  |L1.32|
000020  5ca9              LDRB     r1,[r5,r2]            ;329
000022  4059              EORS     r1,r1,r3              ;329
000024  5c7b              LDRB     r3,[r7,r1]
000026  4043              EORS     r3,r3,r0
;;;331            Temp_High=CRC16_Low[Index];
000028  5c70              LDRB     r0,[r6,r1]
00002a  1c52              ADDS     r2,r2,#1
                  |L1.44|
00002c  42a2              CMP      r2,r4                 ;327
00002e  d3f7              BCC      |L1.32|
;;;332        }
;;;333    
;;;334        return (u16)(((u16)Temp_High)<<8|Temp_Low);
;;;335    }
000030  b041              ADD      sp,sp,#0x104
000032  ea432000          ORR      r0,r3,r0,LSL #8       ;334
000036  bdf0              POP      {r4-r7,pc}
;;;336    #endif
                          ENDP

                  |L1.56|
                          DCD      ||.constdata||+0x4e0
                  |L1.60|
                          DCD      ||.constdata||+0x100

                          AREA ||i.RMP_Checkbox||, CODE, READONLY, ALIGN=1

                  RMP_Checkbox PROC
;;;2964   ******************************************************************************/
;;;2965   void RMP_Checkbox(cnt_t Coord_X, cnt_t Coord_Y, cnt_t Length, ptr_t Status)    
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;2966   {   
;;;2967       /* Clear the area */
;;;2968       RMP_Rectangle(Coord_X,Coord_Y,Length,Length,RMP_CTL_WHITE,RMP_CTL_WHITE);
000004  f64f78ff          MOV      r8,#0xffff
000008  469b              MOV      r11,r3                ;2966
00000a  4606              MOV      r6,r0                 ;2966
00000c  4692              MOV      r10,r2                ;2966
00000e  460d              MOV      r5,r1                 ;2966
000010  4613              MOV      r3,r2
000012  f8cd8000          STR      r8,[sp,#0]
000016  f8cd8004          STR      r8,[sp,#4]
00001a  f7fffffe          BL       RMP_Rectangle
;;;2969                                                                        
;;;2970       /* Draw checkbox outline */
;;;2971       RMP_Line(Coord_X,Coord_Y,Coord_X+Length-1,Coord_Y,RMP_CTL_DARK);                 
00001e  eb06040a          ADD      r4,r6,r10
000022  462b              MOV      r3,r5
000024  1e62              SUBS     r2,r4,#1
000026  f64739ef          MOV      r9,#0x7bef
00002a  4619              MOV      r1,r3
00002c  4630              MOV      r0,r6
00002e  f8cd9000          STR      r9,[sp,#0]
000032  f7fffffe          BL       RMP_Line
;;;2972       RMP_Line(Coord_X+Length-1,Coord_Y,Coord_X+Length-1,Coord_Y+Length-1,RMP_CTL_WHITE);
000036  1e62              SUBS     r2,r4,#1
000038  4629              MOV      r1,r5
00003a  eb05070a          ADD      r7,r5,r10
00003e  4610              MOV      r0,r2
000040  1e7b              SUBS     r3,r7,#1
000042  f8cd8000          STR      r8,[sp,#0]
000046  f7fffffe          BL       RMP_Line
;;;2973       RMP_Line(Coord_X+Length-1,Coord_Y+Length-1,Coord_X,Coord_Y+Length-1,RMP_CTL_WHITE);
00004a  1e7b              SUBS     r3,r7,#1
00004c  4632              MOV      r2,r6
00004e  1e79              SUBS     r1,r7,#1
000050  f8cd8000          STR      r8,[sp,#0]
000054  1e60              SUBS     r0,r4,#1
000056  f7fffffe          BL       RMP_Line
;;;2974       RMP_Line(Coord_X,Coord_Y+Length-1,Coord_X,Coord_Y,RMP_CTL_DARK);
00005a  4632              MOV      r2,r6
00005c  462b              MOV      r3,r5
00005e  1e79              SUBS     r1,r7,#1
000060  4610              MOV      r0,r2
000062  f8cd9000          STR      r9,[sp,#0]
000066  f7fffffe          BL       RMP_Line
;;;2975   
;;;2976       RMP_Line(Coord_X+1,Coord_Y+1,Coord_X+Length-2,Coord_Y+1,RMP_CTL_BLACK);
00006a  1ea2              SUBS     r2,r4,#2
00006c  f04f0800          MOV      r8,#0
000070  1c6b              ADDS     r3,r5,#1
000072  f8cd8000          STR      r8,[sp,#0]
000076  1c69              ADDS     r1,r5,#1
000078  1c70              ADDS     r0,r6,#1
00007a  f7fffffe          BL       RMP_Line
;;;2977       RMP_Line(Coord_X+Length-2,Coord_Y+1,Coord_X+Length-2,Coord_Y+Length-2,RMP_CTL_DARK);
00007e  1ea2              SUBS     r2,r4,#2
000080  f8cd9000          STR      r9,[sp,#0]
000084  1ebb              SUBS     r3,r7,#2
000086  4610              MOV      r0,r2
000088  1c69              ADDS     r1,r5,#1
00008a  f7fffffe          BL       RMP_Line
;;;2978       RMP_Line(Coord_X+Length-2,Coord_Y+Length-2,Coord_X,Coord_Y+Length-2,RMP_CTL_DARK);
00008e  1ea0              SUBS     r0,r4,#2
000090  4632              MOV      r2,r6
000092  1ebb              SUBS     r3,r7,#2
000094  f8cd9000          STR      r9,[sp,#0]
000098  1eb9              SUBS     r1,r7,#2
00009a  f7fffffe          BL       RMP_Line
;;;2979       RMP_Line(Coord_X+1,Coord_Y+Length-2,Coord_X+1,Coord_Y+1,RMP_CTL_BLACK);
00009e  1eb9              SUBS     r1,r7,#2
0000a0  f8cd8000          STR      r8,[sp,#0]
0000a4  1c6b              ADDS     r3,r5,#1
0000a6  1c72              ADDS     r2,r6,#1
0000a8  1c70              ADDS     r0,r6,#1
0000aa  f7fffffe          BL       RMP_Line
;;;2980       
;;;2981       if(Status!=0)
0000ae  f1bb0f00          CMP      r11,#0
0000b2  d007              BEQ      |L2.196|
;;;2982           RMP_Checkbox_Set(Coord_X, Coord_Y, Length);
0000b4  b002              ADD      sp,sp,#8
0000b6  4652              MOV      r2,r10
0000b8  4629              MOV      r1,r5
0000ba  4630              MOV      r0,r6
0000bc  e8bd5ff0          POP      {r4-r12,lr}
0000c0  f7ffbffe          B.W      RMP_Checkbox_Set
                  |L2.196|
;;;2983   }
0000c4  e8bd9ffc          POP      {r2-r12,pc}
;;;2984   /* End Function:RMP_Checkbox *************************************************/
                          ENDP


                          AREA ||i.RMP_Checkbox_Clr||, CODE, READONLY, ALIGN=2

                  RMP_Checkbox_Clr PROC
;;;2937   ******************************************************************************/
;;;2938   void RMP_Checkbox_Clr(cnt_t Coord_X, cnt_t Coord_Y, cnt_t Length)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;2939   {
000004  4615              MOV      r5,r2
000006  460e              MOV      r6,r1
;;;2940       cnt_t Count;
;;;2941       
;;;2942       /* Erase the tick inside */
;;;2943       for(Count=0;Count<=2*Length/13;Count++)
000008  2400              MOVS     r4,#0
00000a  4681              MOV      r9,r0                 ;2939
;;;2944       {
;;;2945           RMP_Line(Coord_X+4*Length/13+Count,Coord_Y+6*Length/13+Count,
00000c  eb020145          ADD      r1,r2,r5,LSL #1
000010  0097              LSLS     r7,r2,#2
000012  0050              LSLS     r0,r2,#1              ;2943
000014  9001              STR      r0,[sp,#4]            ;2939
000016  ea4f0a41          LSL      r10,r1,#1
00001a  ea4f0bc2          LSL      r11,r2,#3
00001e  e016              B        |L3.78|
                  |L3.32|
000020  fb9bf3f0          SDIV     r3,r11,r0
000024  fb9af1f0          SDIV     r1,r10,r0
000028  fb97f2f0          SDIV     r2,r7,r0
00002c  fb97f0f0          SDIV     r0,r7,r0
000030  f64f7cff          MOV      r12,#0xffff
000034  f8cdc000          STR      r12,[sp,#0]
000038  4433              ADD      r3,r3,r6
00003a  4431              ADD      r1,r1,r6
00003c  444a              ADD      r2,r2,r9
00003e  4448              ADD      r0,r0,r9
000040  4423              ADD      r3,r3,r4
000042  4422              ADD      r2,r2,r4
000044  4421              ADD      r1,r1,r4
000046  4420              ADD      r0,r0,r4
000048  f7fffffe          BL       RMP_Line
00004c  1c64              ADDS     r4,r4,#1
                  |L3.78|
00004e  9901              LDR      r1,[sp,#4]            ;2943
000050  200d              MOVS     r0,#0xd               ;2943
000052  fb91f1f0          SDIV     r1,r1,r0              ;2943
000056  42a1              CMP      r1,r4                 ;2943
000058  dae2              BGE      |L3.32|
;;;2946                    Coord_X+4*Length/13+Count,Coord_Y+8*Length/13+Count,RMP_CTL_WHITE);
;;;2947       }
;;;2948       for(Count=0;Count<=4*Length/13;Count++)
00005a  2400              MOVS     r4,#0
00005c  e01a              B        |L3.148|
;;;2949       {
;;;2950           RMP_Line(Coord_X+6*Length/13+Count,Coord_Y+8*Length/13-Count,
00005e  bf00              NOP      
                  |L3.96|
000060  eb050185          ADD      r1,r5,r5,LSL #2
000064  f64f7cff          MOV      r12,#0xffff
000068  fb9af2f0          SDIV     r2,r10,r0
00006c  0049              LSLS     r1,r1,#1
00006e  f8cdc000          STR      r12,[sp,#0]
000072  fb91f3f0          SDIV     r3,r1,r0
000076  fb9bf1f0          SDIV     r1,r11,r0
00007a  fb9af0f0          SDIV     r0,r10,r0
00007e  444a              ADD      r2,r2,r9
000080  4422              ADD      r2,r2,r4
000082  4433              ADD      r3,r3,r6
000084  4431              ADD      r1,r1,r6
000086  4448              ADD      r0,r0,r9
000088  1b1b              SUBS     r3,r3,r4
00008a  1b09              SUBS     r1,r1,r4
00008c  4420              ADD      r0,r0,r4
00008e  f7fffffe          BL       RMP_Line
000092  1c64              ADDS     r4,r4,#1
                  |L3.148|
000094  200d              MOVS     r0,#0xd               ;2948
000096  fb97f1f0          SDIV     r1,r7,r0              ;2948
00009a  42a1              CMP      r1,r4                 ;2948
00009c  dae0              BGE      |L3.96|
;;;2951                    Coord_X+6*Length/13+Count,Coord_Y+10*Length/13-Count,RMP_CTL_WHITE);
;;;2952       }
;;;2953   }
00009e  e8bd9ffc          POP      {r2-r12,pc}
;;;2954   /* End Function:RMP_Checkbox_Clr *********************************************/
                          ENDP


                          AREA ||i.RMP_Checkbox_Set||, CODE, READONLY, ALIGN=2

                  RMP_Checkbox_Set PROC
;;;2911   ******************************************************************************/
;;;2912   void RMP_Checkbox_Set(cnt_t Coord_X, cnt_t Coord_Y, cnt_t Length)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;2913   {
000004  4615              MOV      r5,r2
000006  460e              MOV      r6,r1
;;;2914       cnt_t Count;
;;;2915       
;;;2916       /* Draw a tick inside */
;;;2917       for(Count=0;Count<=2*Length/13;Count++)
000008  2400              MOVS     r4,#0
00000a  4681              MOV      r9,r0                 ;2913
;;;2918       {
;;;2919           RMP_Line(Coord_X+4*Length/13+Count,Coord_Y+6*Length/13+Count,
00000c  eb020145          ADD      r1,r2,r5,LSL #1
000010  0097              LSLS     r7,r2,#2
000012  0050              LSLS     r0,r2,#1              ;2917
000014  9001              STR      r0,[sp,#4]            ;2913
000016  ea4f0a41          LSL      r10,r1,#1
00001a  ea4f0bc2          LSL      r11,r2,#3
00001e  e016              B        |L4.78|
                  |L4.32|
000020  fb9bf3f0          SDIV     r3,r11,r0
000024  fb9af1f0          SDIV     r1,r10,r0
000028  fb97f2f0          SDIV     r2,r7,r0
00002c  fb97f0f0          SDIV     r0,r7,r0
000030  f04f0c00          MOV      r12,#0
000034  f8cdc000          STR      r12,[sp,#0]
000038  4433              ADD      r3,r3,r6
00003a  4431              ADD      r1,r1,r6
00003c  444a              ADD      r2,r2,r9
00003e  4448              ADD      r0,r0,r9
000040  4423              ADD      r3,r3,r4
000042  4422              ADD      r2,r2,r4
000044  4421              ADD      r1,r1,r4
000046  4420              ADD      r0,r0,r4
000048  f7fffffe          BL       RMP_Line
00004c  1c64              ADDS     r4,r4,#1
                  |L4.78|
00004e  9901              LDR      r1,[sp,#4]            ;2917
000050  200d              MOVS     r0,#0xd               ;2917
000052  fb91f1f0          SDIV     r1,r1,r0              ;2917
000056  42a1              CMP      r1,r4                 ;2917
000058  dae2              BGE      |L4.32|
;;;2920                    Coord_X+4*Length/13+Count,Coord_Y+8*Length/13+Count,RMP_CTL_BLACK);
;;;2921       }
;;;2922       for(Count=0;Count<=4*Length/13;Count++)
00005a  2400              MOVS     r4,#0
00005c  e01a              B        |L4.148|
;;;2923       {
;;;2924           RMP_Line(Coord_X+6*Length/13+Count,Coord_Y+8*Length/13-Count,
00005e  bf00              NOP      
                  |L4.96|
000060  eb050185          ADD      r1,r5,r5,LSL #2
000064  f04f0c00          MOV      r12,#0
000068  fb9af2f0          SDIV     r2,r10,r0
00006c  0049              LSLS     r1,r1,#1
00006e  f8cdc000          STR      r12,[sp,#0]
000072  fb91f3f0          SDIV     r3,r1,r0
000076  fb9bf1f0          SDIV     r1,r11,r0
00007a  fb9af0f0          SDIV     r0,r10,r0
00007e  444a              ADD      r2,r2,r9
000080  4422              ADD      r2,r2,r4
000082  4433              ADD      r3,r3,r6
000084  4431              ADD      r1,r1,r6
000086  4448              ADD      r0,r0,r9
000088  1b1b              SUBS     r3,r3,r4
00008a  1b09              SUBS     r1,r1,r4
00008c  4420              ADD      r0,r0,r4
00008e  f7fffffe          BL       RMP_Line
000092  1c64              ADDS     r4,r4,#1
                  |L4.148|
000094  200d              MOVS     r0,#0xd               ;2922
000096  fb97f1f0          SDIV     r1,r7,r0              ;2922
00009a  42a1              CMP      r1,r4                 ;2922
00009c  dae0              BGE      |L4.96|
;;;2925                    Coord_X+6*Length/13+Count,Coord_Y+10*Length/13-Count,RMP_CTL_BLACK);
;;;2926       }
;;;2927   }
00009e  e8bd9ffc          POP      {r2-r12,pc}
;;;2928   /* End Function:RMP_Checkbox_Set *********************************************/
                          ENDP


                          AREA ||i.RMP_Circle||, CODE, READONLY, ALIGN=1

                  RMP_Circle PROC
;;;2422   ******************************************************************************/
;;;2423   void RMP_Circle(cnt_t Center_X, cnt_t Center_Y, cnt_t Radius, ptr_t Border, ptr_t Fill)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;2424   {
000004  b085              SUB      sp,sp,#0x14
000006  460e              MOV      r6,r1
;;;2425       cnt_t Cur_X;
;;;2426       cnt_t Cur_Y;
;;;2427       cnt_t Fill_Y;
;;;2428       cnt_t Error;  
;;;2429       cnt_t Quick;
;;;2430   
;;;2431       Cur_X=0;
;;;2432       Cur_Y=Radius;
;;;2433       Error=3-(Radius<<1);
000008  2103              MOVS     r1,#3
00000a  4607              MOV      r7,r0                 ;2424
00000c  eba10a42          SUB      r10,r1,r2,LSL #1
000010  f04f0400          MOV      r4,#0                 ;2431
;;;2434   
;;;2435       if(Fill!=RMP_TRANS)
000014  9812              LDR      r0,[sp,#0x48]
000016  4615              MOV      r5,r2                 ;2432
000018  2801              CMP      r0,#1
00001a  d07d              BEQ      |L5.280|
;;;2436       {  
;;;2437           /* When we are filling the circle, we can try not to fill the areas that have been filled
;;;2438            * using the rectangle fill method to increase fill speed.
;;;2439            * Square 2 is 1.414. Here we let the condition to be 1.5. */
;;;2440           Quick=(Radius<<1)/3;
00001c  006a              LSLS     r2,r5,#1
;;;2441           /* First, fill the square hole using the fast direct-fill method */
;;;2442           RMP_Rectangle(Center_X-Quick,Center_Y-Quick, (Quick<<1)+1,(Quick<<1)+1, Fill, Fill);  
00001e  9812              LDR      r0,[sp,#0x48]
000020  fb92f9f1          SDIV     r9,r2,r1              ;2440
000024  2301              MOVS     r3,#1
000026  9000              STR      r0,[sp,#0]
000028  9001              STR      r0,[sp,#4]
00002a  eba60109          SUB      r1,r6,r9
00002e  eb030249          ADD      r2,r3,r9,LSL #1
000032  eba70009          SUB      r0,r7,r9
000036  4613              MOV      r3,r2
000038  f7fffffe          BL       RMP_Rectangle
;;;2443   
;;;2444           while(Cur_X<=Cur_Y) 
00003c  e0bd              B        |L5.442|
                  |L5.62|
;;;2445           {  
;;;2446               if(Cur_X<Quick)
00003e  454c              CMP      r4,r9
000040  da3c              BGE      |L5.188|
;;;2447               {
;;;2448                   for(Fill_Y=Cur_X;Fill_Y<=Cur_Y;Fill_Y++)  
000042  46a0              MOV      r8,r4
000044  e037              B        |L5.182|
                  |L5.70|
;;;2449                   {
;;;2450                       if(Fill_Y<Quick)
000046  45c8              CMP      r8,r9
000048  db33              BLT      |L5.178|
;;;2451                           continue;
;;;2452                       
;;;2453                       RMP_POINT(Center_X+Cur_X,Center_Y+Fill_Y,Fill);  
00004a  eb060108          ADD      r1,r6,r8
00004e  9a12              LDR      r2,[sp,#0x48]
000050  1938              ADDS     r0,r7,r4
000052  468b              MOV      r11,r1
000054  9001              STR      r0,[sp,#4]
000056  f7fffffe          BL       RMP_Point
;;;2454                       RMP_POINT(Center_X-Cur_X,Center_Y+Fill_Y,Fill);  
00005a  9a12              LDR      r2,[sp,#0x48]
00005c  1b38              SUBS     r0,r7,r4
00005e  4659              MOV      r1,r11                ;2453
000060  9000              STR      r0,[sp,#0]
000062  f7fffffe          BL       RMP_Point
;;;2455                       RMP_POINT(Center_X+Cur_X,Center_Y-Fill_Y,Fill); 
000066  eba60108          SUB      r1,r6,r8
00006a  9a12              LDR      r2,[sp,#0x48]
00006c  9801              LDR      r0,[sp,#4]
00006e  468b              MOV      r11,r1
000070  f7fffffe          BL       RMP_Point
;;;2456                       RMP_POINT(Center_X-Cur_X,Center_Y-Fill_Y,Fill);  
000074  9a12              LDR      r2,[sp,#0x48]
000076  4659              MOV      r1,r11                ;2455
000078  9800              LDR      r0,[sp,#0]
00007a  f7fffffe          BL       RMP_Point
;;;2457                       RMP_POINT(Center_X+Fill_Y,Center_Y+Cur_X,Fill); 
00007e  1931              ADDS     r1,r6,r4
000080  9a12              LDR      r2,[sp,#0x48]
000082  eb070008          ADD      r0,r7,r8
000086  468b              MOV      r11,r1
000088  9001              STR      r0,[sp,#4]
00008a  f7fffffe          BL       RMP_Point
;;;2458                       RMP_POINT(Center_X-Fill_Y,Center_Y+Cur_X,Fill);  
00008e  9a12              LDR      r2,[sp,#0x48]
000090  eba70008          SUB      r0,r7,r8
000094  4659              MOV      r1,r11                ;2457
000096  9000              STR      r0,[sp,#0]
000098  f7fffffe          BL       RMP_Point
;;;2459                       RMP_POINT(Center_X+Fill_Y,Center_Y-Cur_X,Fill);  
00009c  1b31              SUBS     r1,r6,r4
00009e  9a12              LDR      r2,[sp,#0x48]
0000a0  9801              LDR      r0,[sp,#4]
0000a2  468b              MOV      r11,r1
0000a4  f7fffffe          BL       RMP_Point
;;;2460                       RMP_POINT(Center_X-Fill_Y,Center_Y-Cur_X,Fill);
0000a8  9a12              LDR      r2,[sp,#0x48]
0000aa  4659              MOV      r1,r11                ;2459
0000ac  9800              LDR      r0,[sp,#0]
0000ae  f7fffffe          BL       RMP_Point
                  |L5.178|
0000b2  f1080801          ADD      r8,r8,#1              ;2448
                  |L5.182|
0000b6  45a8              CMP      r8,r5                 ;2448
0000b8  ddc5              BLE      |L5.70|
0000ba  e03f              B        |L5.316|
                  |L5.188|
0000bc  1b30              SUBS     r0,r6,r4              ;2459
0000be  9001              STR      r0,[sp,#4]            ;2457
0000c0  1930              ADDS     r0,r6,r4              ;2457
0000c2  9004              STR      r0,[sp,#0x10]         ;2454
0000c4  1b38              SUBS     r0,r7,r4              ;2454
;;;2461                   }
;;;2462               }
;;;2463               /* Here the "Cur_X" is already out of range. We do not check the conditions anymore */
;;;2464               else
;;;2465               {
;;;2466                   for(Fill_Y=Cur_X;Fill_Y<=Cur_Y;Fill_Y++)  
0000c6  46a0              MOV      r8,r4
0000c8  eb070b04          ADD      r11,r7,r4             ;2453
0000cc  9000              STR      r0,[sp,#0]
0000ce  e033              B        |L5.312|
                  |L5.208|
;;;2467                   {                   
;;;2468                       RMP_POINT(Center_X+Cur_X,Center_Y+Fill_Y,Fill);  
0000d0  9a12              LDR      r2,[sp,#0x48]
0000d2  eb060108          ADD      r1,r6,r8
0000d6  4658              MOV      r0,r11                ;2466
0000d8  9102              STR      r1,[sp,#8]
0000da  f7fffffe          BL       RMP_Point
;;;2469                       RMP_POINT(Center_X-Cur_X,Center_Y+Fill_Y,Fill);  
0000de  9a12              LDR      r2,[sp,#0x48]
0000e0  9902              LDR      r1,[sp,#8]
0000e2  9800              LDR      r0,[sp,#0]
0000e4  f7fffffe          BL       RMP_Point
;;;2470                       RMP_POINT(Center_X+Cur_X,Center_Y-Fill_Y,Fill); 
0000e8  9a12              LDR      r2,[sp,#0x48]
0000ea  eba60108          SUB      r1,r6,r8
0000ee  4658              MOV      r0,r11                ;2469
0000f0  9102              STR      r1,[sp,#8]
0000f2  f7fffffe          BL       RMP_Point
;;;2471                       RMP_POINT(Center_X-Cur_X,Center_Y-Fill_Y,Fill);  
0000f6  9a12              LDR      r2,[sp,#0x48]
0000f8  9902              LDR      r1,[sp,#8]
0000fa  9800              LDR      r0,[sp,#0]
0000fc  f7fffffe          BL       RMP_Point
;;;2472                       RMP_POINT(Center_X+Fill_Y,Center_Y+Cur_X,Fill); 
000100  eb070008          ADD      r0,r7,r8
000104  9003              STR      r0,[sp,#0xc]
000106  9904              LDR      r1,[sp,#0x10]
000108  9a12              LDR      r2,[sp,#0x48]
00010a  f7fffffe          BL       RMP_Point
;;;2473                       RMP_POINT(Center_X-Fill_Y,Center_Y+Cur_X,Fill);  
00010e  9904              LDR      r1,[sp,#0x10]
000110  eba70008          SUB      r0,r7,r8
000114  9002              STR      r0,[sp,#8]
000116  e000              B        |L5.282|
                  |L5.280|
000118  e092              B        |L5.576|
                  |L5.282|
00011a  9a12              LDR      r2,[sp,#0x48]
00011c  f7fffffe          BL       RMP_Point
;;;2474                       RMP_POINT(Center_X+Fill_Y,Center_Y-Cur_X,Fill);  
000120  9a12              LDR      r2,[sp,#0x48]
000122  9901              LDR      r1,[sp,#4]
000124  9803              LDR      r0,[sp,#0xc]
000126  f7fffffe          BL       RMP_Point
;;;2475                       RMP_POINT(Center_X-Fill_Y,Center_Y-Cur_X,Fill);
00012a  9a12              LDR      r2,[sp,#0x48]
00012c  e9dd1001          LDRD     r1,r0,[sp,#4]
000130  f7fffffe          BL       RMP_Point
000134  f1080801          ADD      r8,r8,#1              ;2466
                  |L5.312|
000138  45a8              CMP      r8,r5                 ;2466
00013a  ddc9              BLE      |L5.208|
                  |L5.316|
;;;2476                   }
;;;2477               }
;;;2478               RMP_POINT(Center_X+Cur_X,Center_Y+Cur_Y,Border);  
00013c  1971              ADDS     r1,r6,r5
00013e  9a08              LDR      r2,[sp,#0x20]
000140  1938              ADDS     r0,r7,r4
000142  4688              MOV      r8,r1
000144  9000              STR      r0,[sp,#0]
000146  f7fffffe          BL       RMP_Point
;;;2479               RMP_POINT(Center_X-Cur_X,Center_Y+Cur_Y,Border);  
00014a  1b38              SUBS     r0,r7,r4
00014c  9a08              LDR      r2,[sp,#0x20]
00014e  4641              MOV      r1,r8                 ;2478
000150  4683              MOV      r11,r0
000152  f7fffffe          BL       RMP_Point
;;;2480               RMP_POINT(Center_X+Cur_X,Center_Y-Cur_Y,Border); 
000156  1b71              SUBS     r1,r6,r5
000158  9a08              LDR      r2,[sp,#0x20]
00015a  9800              LDR      r0,[sp,#0]
00015c  4688              MOV      r8,r1
00015e  f7fffffe          BL       RMP_Point
;;;2481               RMP_POINT(Center_X-Cur_X,Center_Y-Cur_Y,Border);  
000162  9a08              LDR      r2,[sp,#0x20]
000164  4641              MOV      r1,r8                 ;2480
000166  4658              MOV      r0,r11                ;2480
000168  f7fffffe          BL       RMP_Point
;;;2482               RMP_POINT(Center_X+Cur_Y,Center_Y+Cur_X,Border); 
00016c  1931              ADDS     r1,r6,r4
00016e  9a08              LDR      r2,[sp,#0x20]
000170  1978              ADDS     r0,r7,r5
000172  4688              MOV      r8,r1
000174  4683              MOV      r11,r0
000176  f7fffffe          BL       RMP_Point
;;;2483               RMP_POINT(Center_X-Cur_Y,Center_Y+Cur_X,Border);  
00017a  9a08              LDR      r2,[sp,#0x20]
00017c  1b78              SUBS     r0,r7,r5
00017e  4641              MOV      r1,r8                 ;2482
000180  9000              STR      r0,[sp,#0]
000182  f7fffffe          BL       RMP_Point
;;;2484               RMP_POINT(Center_X+Cur_Y,Center_Y-Cur_X,Border);  
000186  1b31              SUBS     r1,r6,r4
000188  9a08              LDR      r2,[sp,#0x20]
00018a  4658              MOV      r0,r11                ;2483
00018c  4688              MOV      r8,r1
00018e  f7fffffe          BL       RMP_Point
;;;2485               RMP_POINT(Center_X-Cur_Y,Center_Y-Cur_X,Border);
000192  9a08              LDR      r2,[sp,#0x20]
000194  4641              MOV      r1,r8                 ;2484
000196  9800              LDR      r0,[sp,#0]
000198  f7fffffe          BL       RMP_Point
;;;2486   
;;;2487               if(Error<0) 
00019c  f1ba0f00          CMP      r10,#0
0001a0  da04              BGE      |L5.428|
;;;2488                   Error=Error+(Cur_X<<2)+6;
0001a2  eb0a0084          ADD      r0,r10,r4,LSL #2
0001a6  f1000a06          ADD      r10,r0,#6
0001aa  e005              B        |L5.440|
                  |L5.428|
;;;2489               else 
;;;2490               {  
;;;2491                   Error=Error+((Cur_X-Cur_Y)<<2)+10;  
0001ac  1b61              SUBS     r1,r4,r5
0001ae  1e6d              SUBS     r5,r5,#1
0001b0  eb0a0081          ADD      r0,r10,r1,LSL #2
0001b4  f1000a0a          ADD      r10,r0,#0xa
                  |L5.440|
0001b8  1c64              ADDS     r4,r4,#1
                  |L5.442|
0001ba  42ac              CMP      r4,r5                 ;2444
0001bc  f77faf3f          BLE      |L5.62|
                  |L5.448|
;;;2492                   Cur_Y--;  
;;;2493               }  
;;;2494               Cur_X++;  
;;;2495           }
;;;2496       }
;;;2497       else 
;;;2498       {  
;;;2499           /* Border only */ 
;;;2500           while(Cur_X<=Cur_Y) 
;;;2501           {
;;;2502               RMP_POINT(Center_X+Cur_X,Center_Y+Cur_Y,Border);  
;;;2503               RMP_POINT(Center_X-Cur_X,Center_Y+Cur_Y,Border);  
;;;2504               RMP_POINT(Center_X+Cur_X,Center_Y-Cur_Y,Border); 
;;;2505               RMP_POINT(Center_X-Cur_X,Center_Y-Cur_Y,Border);  
;;;2506               RMP_POINT(Center_X+Cur_Y,Center_Y+Cur_X,Border); 
;;;2507               RMP_POINT(Center_X-Cur_Y,Center_Y+Cur_X,Border);  
;;;2508               RMP_POINT(Center_X+Cur_Y,Center_Y-Cur_X,Border);  
;;;2509               RMP_POINT(Center_X-Cur_Y,Center_Y-Cur_X,Border);
;;;2510   
;;;2511               if(Error<0)
;;;2512                   Error=Error+(Cur_X<<2)+6;
;;;2513               else 
;;;2514               {
;;;2515                   Error=Error+((Cur_X-Cur_Y)<<2);
;;;2516                   Cur_Y--;
;;;2517               }
;;;2518               Cur_X++;  
;;;2519           }  
;;;2520       }
;;;2521   }
0001c0  b009              ADD      sp,sp,#0x24
0001c2  e8bd8ff0          POP      {r4-r11,pc}
                  |L5.454|
0001c6  1971              ADDS     r1,r6,r5              ;2502
0001c8  9a08              LDR      r2,[sp,#0x20]         ;2502
0001ca  1938              ADDS     r0,r7,r4              ;2502
0001cc  4688              MOV      r8,r1                 ;2502
0001ce  4683              MOV      r11,r0                ;2502
0001d0  f7fffffe          BL       RMP_Point
0001d4  1b38              SUBS     r0,r7,r4              ;2503
0001d6  9a08              LDR      r2,[sp,#0x20]         ;2503
0001d8  4641              MOV      r1,r8                 ;2502
0001da  4681              MOV      r9,r0                 ;2503
0001dc  f7fffffe          BL       RMP_Point
0001e0  1b71              SUBS     r1,r6,r5              ;2504
0001e2  9a08              LDR      r2,[sp,#0x20]         ;2504
0001e4  4658              MOV      r0,r11                ;2503
0001e6  4688              MOV      r8,r1                 ;2504
0001e8  f7fffffe          BL       RMP_Point
0001ec  9a08              LDR      r2,[sp,#0x20]         ;2505
0001ee  4641              MOV      r1,r8                 ;2504
0001f0  4648              MOV      r0,r9                 ;2504
0001f2  f7fffffe          BL       RMP_Point
0001f6  1931              ADDS     r1,r6,r4              ;2506
0001f8  9a08              LDR      r2,[sp,#0x20]         ;2506
0001fa  1978              ADDS     r0,r7,r5              ;2506
0001fc  4688              MOV      r8,r1                 ;2506
0001fe  4683              MOV      r11,r0                ;2506
000200  f7fffffe          BL       RMP_Point
000204  1b78              SUBS     r0,r7,r5              ;2507
000206  9a08              LDR      r2,[sp,#0x20]         ;2507
000208  4641              MOV      r1,r8                 ;2506
00020a  4681              MOV      r9,r0                 ;2507
00020c  f7fffffe          BL       RMP_Point
000210  1b31              SUBS     r1,r6,r4              ;2508
000212  9a08              LDR      r2,[sp,#0x20]         ;2508
000214  4658              MOV      r0,r11                ;2507
000216  4688              MOV      r8,r1                 ;2508
000218  f7fffffe          BL       RMP_Point
00021c  9a08              LDR      r2,[sp,#0x20]         ;2509
00021e  4641              MOV      r1,r8                 ;2508
000220  4648              MOV      r0,r9                 ;2508
000222  f7fffffe          BL       RMP_Point
000226  f1ba0f00          CMP      r10,#0                ;2511
00022a  da04              BGE      |L5.566|
00022c  eb0a0084          ADD      r0,r10,r4,LSL #2      ;2512
000230  f1000a06          ADD      r10,r0,#6             ;2512
000234  e003              B        |L5.574|
                  |L5.566|
000236  1b61              SUBS     r1,r4,r5              ;2515
000238  1e6d              SUBS     r5,r5,#1              ;2515
00023a  eb0a0a81          ADD      r10,r10,r1,LSL #2     ;2515
                  |L5.574|
00023e  1c64              ADDS     r4,r4,#1              ;2515
                  |L5.576|
000240  42ac              CMP      r4,r5                 ;2500
000242  ddc0              BLE      |L5.454|
000244  e7bc              B        |L5.448|
;;;2522   /* End Function:RMP_Circle ***************************************************/
                          ENDP


                          AREA ||i.RMP_Clear||, CODE, READONLY, ALIGN=2

                  RMP_Clear PROC
;;;37     ******************************************************************************/
;;;38     void RMP_Clear(volatile void* Addr, ptr_t Size)
000000  2300              MOVS     r3,#0
;;;39     {
;;;40         ptr_t* Word_Inc;
;;;41         u8* Byte_Inc;
;;;42         ptr_t Words;
;;;43         ptr_t Bytes;
;;;44         
;;;45         /* On processors not that fast, copy by word is really important */
;;;46         Word_Inc=(ptr_t*)Addr;
;;;47         for(Words=Size/sizeof(ptr_t);Words>0;Words--)
000002  088a              LSRS     r2,r1,#2
000004  d002              BEQ      |L6.12|
                  |L6.6|
;;;48         {
;;;49             *Word_Inc=0;
000006  1e52              SUBS     r2,r2,#1
000008  c008              STM      r0!,{r3}
00000a  d1fc              BNE      |L6.6|
                  |L6.12|
;;;50             Word_Inc++;
;;;51         }
;;;52         
;;;53         /* Get the final bytes */
;;;54         Byte_Inc=(u8*)Word_Inc;
;;;55         for(Bytes=Size%sizeof(ptr_t);Bytes>0;Bytes--)
00000c  f0110103          ANDS     r1,r1,#3
000010  d004              BEQ      |L6.28|
;;;56         {
;;;57             *Byte_Inc=0;
000012  bf00              NOP      
                  |L6.20|
000014  1e49              SUBS     r1,r1,#1
000016  f8003b01          STRB     r3,[r0],#1
00001a  d1fb              BNE      |L6.20|
                  |L6.28|
;;;58             Byte_Inc++;
;;;59         }
;;;60     }
00001c  4770              BX       lr
;;;61     /* End Function:RMP_Clear ****************************************************/
                          ENDP


                          AREA ||i.RMP_Cmdbtn||, CODE, READONLY, ALIGN=1

                  RMP_Cmdbtn PROC
;;;3043   ******************************************************************************/
;;;3044   void RMP_Cmdbtn(cnt_t Coord_X, cnt_t Coord_Y, cnt_t Length, cnt_t Width, ptr_t Status)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;3045   {
000004  4680              MOV      r8,r0
;;;3046       RMP_Rectangle(Coord_X,Coord_Y,Length,Width,RMP_CTL_GREY,RMP_CTL_GREY);
000006  f64b50d7          MOV      r0,#0xbdd7
00000a  461d              MOV      r5,r3                 ;3045
00000c  4616              MOV      r6,r2                 ;3045
00000e  9c08              LDR      r4,[sp,#0x20]
000010  460f              MOV      r7,r1                 ;3045
000012  9000              STR      r0,[sp,#0]
000014  9001              STR      r0,[sp,#4]
000016  4640              MOV      r0,r8
000018  f7fffffe          BL       RMP_Rectangle
;;;3047   
;;;3048       if(Status!=0)
;;;3049           RMP_Cmdbtn_Down(Coord_X, Coord_Y, Length, Width);
;;;3050       else
;;;3051           RMP_Cmdbtn_Up(Coord_X, Coord_Y, Length, Width);
00001c  462b              MOV      r3,r5
00001e  4632              MOV      r2,r6
000020  4639              MOV      r1,r7
000022  4640              MOV      r0,r8
000024  b124              CBZ      r4,|L7.48|
000026  b002              ADD      sp,sp,#8              ;3049
000028  e8bd41f0          POP      {r4-r8,lr}            ;3049
00002c  f7ffbffe          B.W      RMP_Cmdbtn_Down
                  |L7.48|
000030  b002              ADD      sp,sp,#8
000032  e8bd41f0          POP      {r4-r8,lr}
000036  f7ffbffe          B.W      RMP_Cmdbtn_Up
;;;3052   }
;;;3053   /* End Function:RMP_Cmdbtn ***************************************************/
                          ENDP


                          AREA ||i.RMP_Cmdbtn_Down||, CODE, READONLY, ALIGN=1

                  RMP_Cmdbtn_Down PROC
;;;2994   ******************************************************************************/
;;;2995   void RMP_Cmdbtn_Down(cnt_t Coord_X, cnt_t Coord_Y, cnt_t Length, cnt_t Width)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;2996   {
;;;2997       RMP_Line(Coord_X,Coord_Y,Coord_X+Length-1,Coord_Y,RMP_CTL_BLACK);
000004  1884              ADDS     r4,r0,r2
000006  461f              MOV      r7,r3                 ;2996
000008  1e62              SUBS     r2,r4,#1
00000a  460d              MOV      r5,r1                 ;2996
00000c  4606              MOV      r6,r0                 ;2996
00000e  f04f0900          MOV      r9,#0
000012  460b              MOV      r3,r1
000014  f8cd9000          STR      r9,[sp,#0]
000018  f7fffffe          BL       RMP_Line
;;;2998       RMP_Line(Coord_X+Length-1,Coord_Y,Coord_X+Length-1,Coord_Y+Width-1,RMP_CTL_WHITE);
00001c  1e62              SUBS     r2,r4,#1
00001e  f64f78ff          MOV      r8,#0xffff
000022  442f              ADD      r7,r7,r5
000024  4610              MOV      r0,r2
000026  1e7b              SUBS     r3,r7,#1
000028  4629              MOV      r1,r5
00002a  f8cd8000          STR      r8,[sp,#0]
00002e  f7fffffe          BL       RMP_Line
;;;2999       RMP_Line(Coord_X+Length-1,Coord_Y+Width-1,Coord_X,Coord_Y+Width-1,RMP_CTL_WHITE);
000032  1e7b              SUBS     r3,r7,#1
000034  4632              MOV      r2,r6
000036  1e79              SUBS     r1,r7,#1
000038  f8cd8000          STR      r8,[sp,#0]
00003c  1e60              SUBS     r0,r4,#1
00003e  f7fffffe          BL       RMP_Line
;;;3000       RMP_Line(Coord_X,Coord_Y+Width-1,Coord_X,Coord_Y,RMP_CTL_BLACK);
000042  4632              MOV      r2,r6
000044  462b              MOV      r3,r5
000046  1e79              SUBS     r1,r7,#1
000048  4610              MOV      r0,r2
00004a  f8cd9000          STR      r9,[sp,#0]
00004e  f7fffffe          BL       RMP_Line
;;;3001       /* Clear the old shadow */
;;;3002       RMP_Line(Coord_X+Length-2,Coord_Y+Width-2,Coord_X+1,Coord_Y+Width-2,RMP_CTL_GREY);    
000052  1ebb              SUBS     r3,r7,#2
000054  f64b58d7          MOV      r8,#0xbdd7
000058  1eb9              SUBS     r1,r7,#2
00005a  f8cd8000          STR      r8,[sp,#0]
00005e  1ea0              SUBS     r0,r4,#2
000060  1c72              ADDS     r2,r6,#1
000062  f7fffffe          BL       RMP_Line
;;;3003       RMP_Line(Coord_X+Length-2,Coord_Y+1,Coord_X+Length-2,Coord_Y+Width-2,RMP_CTL_GREY);    
000066  1ea2              SUBS     r2,r4,#2
000068  f8cd8000          STR      r8,[sp,#0]
00006c  1ebb              SUBS     r3,r7,#2
00006e  4610              MOV      r0,r2
000070  1c69              ADDS     r1,r5,#1
000072  f7fffffe          BL       RMP_Line
;;;3004       /* The shadow */                            
;;;3005       RMP_Line(Coord_X+1,Coord_Y+Width-2,Coord_X+1,Coord_Y+1,RMP_CTL_DARK);    
000076  1eb9              SUBS     r1,r7,#2
000078  f64738ef          MOV      r8,#0x7bef
00007c  1c6b              ADDS     r3,r5,#1
00007e  f8cd8000          STR      r8,[sp,#0]
000082  1c72              ADDS     r2,r6,#1
000084  1c70              ADDS     r0,r6,#1
000086  f7fffffe          BL       RMP_Line
;;;3006       RMP_Line(Coord_X+1,Coord_Y+1,Coord_X+Length-2,Coord_Y+1,RMP_CTL_DARK);    
00008a  1ea2              SUBS     r2,r4,#2
00008c  f8cd8000          STR      r8,[sp,#0]
000090  1c6b              ADDS     r3,r5,#1
000092  1c69              ADDS     r1,r5,#1
000094  1c70              ADDS     r0,r6,#1
000096  f7fffffe          BL       RMP_Line
;;;3007   }
00009a  e8bd83f8          POP      {r3-r9,pc}
;;;3008   /* End Function:RMP_Cmdbtn_Down **********************************************/
                          ENDP


                          AREA ||i.RMP_Cmdbtn_Up||, CODE, READONLY, ALIGN=1

                  RMP_Cmdbtn_Up PROC
;;;3018   ******************************************************************************/
;;;3019   void RMP_Cmdbtn_Up(cnt_t Coord_X, cnt_t Coord_Y, cnt_t Length, cnt_t Width)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;3020   {
;;;3021       RMP_Line(Coord_X,Coord_Y,Coord_X+Length-1,Coord_Y,RMP_CTL_WHITE);
000004  1885              ADDS     r5,r0,r2
000006  461c              MOV      r4,r3                 ;3020
000008  1e6a              SUBS     r2,r5,#1
00000a  460e              MOV      r6,r1                 ;3020
00000c  4607              MOV      r7,r0                 ;3020
00000e  f64f79ff          MOV      r9,#0xffff
000012  460b              MOV      r3,r1
000014  f8cd9000          STR      r9,[sp,#0]
000018  f7fffffe          BL       RMP_Line
;;;3022       RMP_Line(Coord_X+Length-1,Coord_Y,Coord_X+Length-1,Coord_Y+Width-1,RMP_CTL_BLACK);
00001c  1e6a              SUBS     r2,r5,#1
00001e  f04f0800          MOV      r8,#0
000022  4434              ADD      r4,r4,r6
000024  4610              MOV      r0,r2
000026  1e63              SUBS     r3,r4,#1
000028  4631              MOV      r1,r6
00002a  f8cd8000          STR      r8,[sp,#0]
00002e  f7fffffe          BL       RMP_Line
;;;3023       RMP_Line(Coord_X+Length-1,Coord_Y+Width-1,Coord_X,Coord_Y+Width-1,RMP_CTL_BLACK);
000032  1e63              SUBS     r3,r4,#1
000034  463a              MOV      r2,r7
000036  1e68              SUBS     r0,r5,#1
000038  4619              MOV      r1,r3
00003a  f8cd8000          STR      r8,[sp,#0]
00003e  f7fffffe          BL       RMP_Line
;;;3024       RMP_Line(Coord_X,Coord_Y+Width-1,Coord_X,Coord_Y,RMP_CTL_WHITE);
000042  463a              MOV      r2,r7
000044  4633              MOV      r3,r6
000046  1e61              SUBS     r1,r4,#1
000048  4610              MOV      r0,r2
00004a  f8cd9000          STR      r9,[sp,#0]
00004e  f7fffffe          BL       RMP_Line
;;;3025       /* Clear the old shadow */
;;;3026       RMP_Line(Coord_X+1,Coord_Y+Width-2,Coord_X+1,Coord_Y+1,RMP_CTL_GREY);    
000052  1ea1              SUBS     r1,r4,#2
000054  f64b58d7          MOV      r8,#0xbdd7
000058  1c73              ADDS     r3,r6,#1
00005a  f8cd8000          STR      r8,[sp,#0]
00005e  1c7a              ADDS     r2,r7,#1
000060  1c78              ADDS     r0,r7,#1
000062  f7fffffe          BL       RMP_Line
;;;3027       RMP_Line(Coord_X+1,Coord_Y+1,Coord_X+Length-2,Coord_Y+1,RMP_CTL_GREY);    
000066  1eaa              SUBS     r2,r5,#2
000068  f8cd8000          STR      r8,[sp,#0]
00006c  1c73              ADDS     r3,r6,#1
00006e  1c71              ADDS     r1,r6,#1
000070  1c78              ADDS     r0,r7,#1
000072  f7fffffe          BL       RMP_Line
;;;3028       /* The shadow */
;;;3029       RMP_Line(Coord_X+Length-2,Coord_Y+Width-2,Coord_X+1,Coord_Y+Width-2,RMP_CTL_DARK);    
000076  1ea3              SUBS     r3,r4,#2
000078  f64738ef          MOV      r8,#0x7bef
00007c  1ea8              SUBS     r0,r5,#2
00007e  4619              MOV      r1,r3
000080  1c7a              ADDS     r2,r7,#1
000082  f8cd8000          STR      r8,[sp,#0]
000086  f7fffffe          BL       RMP_Line
;;;3030       RMP_Line(Coord_X+Length-2,Coord_Y+1,Coord_X+Length-2,Coord_Y+Width-2,RMP_CTL_DARK);    
00008a  1eaa              SUBS     r2,r5,#2
00008c  f8cd8000          STR      r8,[sp,#0]
000090  1ea3              SUBS     r3,r4,#2
000092  4610              MOV      r0,r2
000094  1c71              ADDS     r1,r6,#1
000096  f7fffffe          BL       RMP_Line
;;;3031   }
00009a  e8bd83f8          POP      {r3-r9,pc}
;;;3032   /* End Function:RMP_Cmdbtn_Up ************************************************/
                          ENDP


                          AREA ||i.RMP_Cursor||, CODE, READONLY, ALIGN=2

                  RMP_Cursor PROC
;;;2734   #ifdef RMP_CTL_BLACK
;;;2735   void RMP_Cursor(cnt_t Coord_X, cnt_t Coord_Y, ptr_t Style)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;2736   {
;;;2737       cnt_t Count;
;;;2738       cnt_t Size_B;
;;;2739       cnt_t Size_W;
;;;2740       const u8* Black;
;;;2741       const u8* White;
;;;2742   
;;;2743       /* Normal Mouse - all matrix encoded in (Y,X) */
;;;2744       static const u8 Arrow_B[]=
;;;2745       {
;;;2746           0x00,0x10,0x11,0x20,0x22,0x30,0x33,0x40,0x44,0x50,0x55,0x60,0x66,0x70,0x77,0x80,
;;;2747           0x88,0x90,0x95,0x96,0x97,0x98,0x99,0xA0,0xA2,0xA3,0xA5,0xB0,0xB1,0xB3,0xB6,0xC0,
;;;2748           0xC1,0xC4,0xC6,0xD0,0xD4,0xD7,0xE5,0xE7,0xF5,0xF6
;;;2749       };
;;;2750       static const u8 Arrow_W[]=
;;;2751       {
;;;2752           0x21,0x31,0x32,0x41,0x42,0x43,0x51,0x52,0x53,0x54,0x61,0x62,0x63,0x64,0x65,0x71,
;;;2753           0x72,0x73,0x74,0x75,0x76,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x91,0x92,0x93,0x94,
;;;2754           0xA1,0xA4,0xB4,0xB5,0xC5,0xD5,0xD6,0xE6
;;;2755       };
;;;2756       /* Busy mark - no white part */
;;;2757       static const u8 Busy_B[]=
;;;2758       {
;;;2759           0x0A,0x0B,0x0C,0x0D,0x0E,0x1A,0x1B,0x1D,0x1E,0x2A,0x2C,0x2E,0x3B,0x3D,0x4C,0x5B,
;;;2760           0x5D,0x6A,0x6E,0x7A,0x7C,0x7E,0x8A,0x8B,0x8C,0x8D,0x8E
;;;2761       };
;;;2762       static const u8 Busy_W[]=
;;;2763       {
;;;2764           0x1C,0x2B,0x2D,0x3C,0x5C,0x6B,0x6C,0x6D,0x7B,0x7D
;;;2765       };
;;;2766       /* Question mark - no white part */
;;;2767       static const u8 Question[]=
;;;2768       {
;;;2769           0x0B,0x0C,0x0D,0x1A,0x1B,0x1C,0x1D,0x1E,0x29,0x2A,0x2B,0x2D,0x2E,0x2F,0x39,0x3A,
;;;2770           0x3E,0x3F,0x4A,0x4D,0x4E,0x4F,0x5C,0x5D,0x5E,0x6C,0x6D,0x8D,0x8E,0x9D,0x9E
;;;2771       };
;;;2772       /* Hand-shaped cursor */
;;;2773       static const u8 Hand_B[]=
;;;2774       {
;;;2775           0x05,0x06,0x14,0x17,0x24,0x27,0x34,0x37,0x39,0x44,0x47,0x48,0x4A,0x4C,0x51,0x52,
;;;2776           0x54,0x57,0x5A,0x5B,0x5D,0x5E,0x60,0x63,0x64,0x67,0x6A,0x6D,0x6F,0x70,0x74,0x77,
;;;2777           0x7A,0x7D,0x7F,0x80,0x8F,0x90,0x9F,0xA0,0xAF,0xB0,0xBF,0xC1,0xCE,0xD1,0xD2,0xD3,
;;;2778           0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xE1,0xEE,0xF2,0xF3,0xF4,
;;;2779           0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD
;;;2780       };
;;;2781       static const u8 Hand_W[]=
;;;2782       {
;;;2783           0x15,0x16,0x25,0x26,0x35,0x36,0x45,0x46,0x49,0x55,0x56,0x58,0x59,0x5C,0x61,0x62,
;;;2784           0x65,0x66,0x68,0x69,0x6B,0x6C,0x6E,0x71,0x72,0x73,0x75,0x76,0x78,0x79,0x7B,0x7C,
;;;2785           0x7E,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x91,
;;;2786           0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0xA1,0xA2,0xA3,
;;;2787           0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xB1,0xB2,0xB3,0xB4,0xB5,
;;;2788           0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,
;;;2789           0xC9,0xCA,0xCB,0xCC,0xCD,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,
;;;2790           0xED
;;;2791       };
;;;2792       /* The cursor for text editing - no white part */
;;;2793       static const u8 Text[]=
;;;2794       {
;;;2795           0x00,0x01,0x02,0x04,0x05,0x06,0x13,0x23,0x33,0x43,0x53,0x63,0x73,0x83,0x93,0xA3,
;;;2796           0xB3,0xC3,0xD3,0xE3,0xF0,0xF1,0xF2,0xF4,0xF5,0xF6
;;;2797       };
;;;2798       /* The stop cursor */
;;;2799       static const u8 Stop_B[]=
;;;2800       {
;;;2801           0x05,0x06,0x07,0x08,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x22,0x23,0x24,0x29,
;;;2802           0x2A,0x2B,0x31,0x32,0x33,0x34,0x3A,0x3B,0x3C,0x41,0x42,0x43,0x44,0x45,0x4B,0x4C,
;;;2803           0x50,0x51,0x54,0x55,0x56,0x5C,0x5D,0x60,0x61,0x65,0x66,0x67,0x6C,0x6D,0x70,0x71,
;;;2804           0x76,0x77,0x78,0x7C,0x7D,0x80,0x81,0x87,0x88,0x89,0x8C,0x8D,0x91,0x92,0x98,0x99,
;;;2805           0x9A,0x9B,0x9C,0xA1,0xA2,0xA3,0xA9,0xAA,0xAB,0xAC,0xB2,0xB3,0xB4,0xB9,0xBA,0xBB,
;;;2806           0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xD5,0xD6,0xD7,0xD8
;;;2807       };
;;;2808       static const u8 Stop_W[]=
;;;2809       {
;;;2810           0x25,0x26,0x27,0x28,0x35,0x36,0x37,0x38,0x39,0x46,0x47,0x48,0x49,0x4A,0x52,0x53,
;;;2811           0x57,0x58,0x59,0x5A,0x5B,0x62,0x63,0x64,0x68,0x69,0x6A,0x6B,0x72,0x73,0x74,0x75,
;;;2812           0x79,0x7A,0x7B,0x82,0x83,0x84,0x85,0x86,0x8A,0x8B,0x93,0x94,0x95,0x96,0x97,0xA4,
;;;2813           0xA5,0xA6,0xA7,0xA8,0xB5,0xB6,0xB7,0xB8
;;;2814       };
;;;2815          /* Cross arrow - no white part  */
;;;2816       static const u8 Adj_ALL[]=
;;;2817       {
;;;2818           0x07,0x16,0x17,0x18,0x25,0x26,0x27,0x28,0x29,0x37,0x47,0x52,0x57,0x5C,0x61,0x62,
;;;2819           0x67,0x6C,0x6D,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7A,0x7B,0x7C,
;;;2820           0x7D,0x7E,0x81,0x82,0x87,0x8C,0x8D,0x92,0x97,0x9C,0xA7,0xB7,0xC5,0xC6,0xC7,0xC8,
;;;2821           0xC9,0xD6,0xD7,0xD8,0xE7
;;;2822       };    
;;;2823       /* Left to right arrow - no white part */
;;;2824       static const u8 Adj_LR[]=
;;;2825       {
;;;2826           0x52,0x5D,0x61,0x62,0x6D,0x6E,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,
;;;2827           0x7A,0x7B,0x7C,0x7D,0x7E,0x7F,0x81,0x82,0x8D,0x8E,0x92,0x9D
;;;2828       };
;;;2829       /* Up to down arrow - no white part */
;;;2830       static const u8 Adj_UD[]=
;;;2831       {
;;;2832           0x07,0x16,0x17,0x18,0x25,0x26,0x27,0x28,0x29,0x37,0x47,0x57,0x67,0x77,0x87,0x97,
;;;2833           0xA7,0xB7,0xC7,0xD5,0xD6,0xD7,0xD8,0xD9,0xE6,0xE7,0xE8,0xF7
;;;2834   
;;;2835       };
;;;2836       /* Bottom-right to top-left arrow - no white part */
;;;2837       static const u8 Adj_BRUL[]=
;;;2838       {
;;;2839           0x00,0x01,0x02,0x03,0x04,0x10,0x11,0x12,0x13,0x20,0x21,0x22,0x30,0x31,0x33,0x40,
;;;2840           0x44,0x55,0x66,0x77,0x88,0x99,0xAA,0xBB,0xBF,0xCC,0xCE,0xCF,0xDD,0xDE,0xDF,0xEC,
;;;2841           0xED,0xEE,0xEF,0xFB,0xFC,0xFD,0xFE,0xFF
;;;2842       };
;;;2843       /* Bottom-left to top-right arrow - no white part */
;;;2844       static const u8 Adj_BLUR[]=
;;;2845       {
;;;2846           0x0B,0x0C,0x0D,0x0E,0x0F,0x1C,0x1D,0x1E,0x1F,0x2D,0x2E,0x2F,0x3C,0x3E,0x3F,0x4B,
;;;2847           0x4F,0x5A,0x69,0x78,0x87,0x96,0xA5,0xB0,0xB4,0xC0,0xC1,0xC3,0xD0,0xD1,0xD2,0xE0,
;;;2848           0xE1,0xE2,0xE3,0xF0,0xF1,0xF2,0xF3,0xF4
;;;2849       };
;;;2850       /* The crosshair cursor - no white part */
;;;2851       static const u8 Cross[]=
;;;2852       {
;;;2853           0x07,0x17,0x27,0x37,0x46,0x47,0x48,0x55,0x57,0x59,0x64,0x6A,0x70,0x71,0x72,0x73,
;;;2854           0x74,0x75,0x77,0x79,0x7A,0x7B,0x7C,0x7D,0x7E,0x84,0x8A,0x95,0x97,0x99,0xA6,0xA7,
;;;2855           0xA8,0xB7,0xC7,0xD7,0xE7
;;;2856       };
;;;2857       
;;;2858       /* Draw them */
;;;2859       switch(Style)
000004  2a0c              CMP      r2,#0xc
000006  4615              MOV      r5,r2                 ;2736
000008  4689              MOV      r9,r1                 ;2736
00000a  4682              MOV      r10,r0                ;2736
;;;2860       {
;;;2861           case RMP_CUR_NORM:{Size_B=sizeof(Arrow_B);Size_W=sizeof(Arrow_W);Black=Arrow_B;White=Arrow_W;break;}
;;;2862           case RMP_CUR_BUSY:case RMP_CUR_QUESTION:
;;;2863           {
;;;2864               for(Count=0;Count<sizeof(Arrow_B);Count++)                                                              
;;;2865                   RMP_POINT(Coord_X+(Arrow_B[Count]&0x0F),Coord_Y+(Arrow_B[Count]>>4),RMP_CTL_BLACK);
;;;2866               for(Count=0;Count<sizeof(Arrow_W);Count++)                                                              
;;;2867                   RMP_POINT(Coord_X+(Arrow_W[Count]&0x0F),Coord_Y+(Arrow_W[Count]>>4),RMP_CTL_WHITE);
00000c  f64f7bff          MOV      r11,#0xffff
000010  d27b              BCS      |L10.266|
000012  e8dff002          TBB      [pc,r2]               ;2859
000016  060d              DCB      0x06,0x0d
000018  0d3c4448          DCB      0x0d,0x3c,0x44,0x48
00001c  5055585d          DCB      0x50,0x55,0x58,0x5d
000020  5f64              DCB      0x5f,0x64
000022  4c42              LDR      r4,|L10.300|
000024  262a              MOVS     r6,#0x2a              ;2861
000026  2528              MOVS     r5,#0x28              ;2861
;;;2868               
;;;2869               if(Style==RMP_CUR_BUSY)
;;;2870               {
;;;2871                   Size_B=sizeof(Busy_B);
;;;2872                   Size_W=sizeof(Busy_W);
;;;2873                   Black=Busy_B;
;;;2874                   White=Busy_W;
;;;2875               }
;;;2876               else
;;;2877               {
;;;2878                   Size_B=sizeof(Question);
;;;2879                   Size_W=0;
;;;2880                   Black=Question;
;;;2881                   White=0;
;;;2882               }
;;;2883               break;
;;;2884           }       
;;;2885           case RMP_CUR_HAND:{Size_B=sizeof(Hand_B);Size_W=sizeof(Hand_W);Black=Hand_B;White=Hand_W;break;}
;;;2886           case RMP_CUR_TEXT:{Size_B=sizeof(Text);Size_W=0;Black=Text;White=0;break;}
;;;2887           case RMP_CUR_STOP:{Size_B=sizeof(Stop_B);Size_W=sizeof(Stop_W);Black=Stop_B;White=Stop_W;break;}
;;;2888           case RMP_CUR_MOVE:{Size_B=sizeof(Adj_ALL);Size_W=0;Black=Adj_ALL;White=0;break;}
;;;2889           case RMP_CUR_LR:{Size_B=sizeof(Adj_LR);Size_W=0;Black=Adj_LR;White=0;break;}
;;;2890           case RMP_CUR_UD:{Size_B=sizeof(Adj_UD);Size_W=0;Black=Adj_UD;White=0;break;}
;;;2891           case RMP_CUR_ULBR:{Size_B=sizeof(Adj_BRUL);Size_W=0;Black=Adj_BRUL;White=0;break;}
;;;2892           case RMP_CUR_URBL:{Size_B=sizeof(Adj_BLUR);Size_W=0;Black=Adj_BLUR;White=0;break;}
;;;2893           case RMP_CUR_CROSS:{Size_B=sizeof(Cross);Size_W=0;Black=Cross;White=0;break;}
;;;2894           default:return;
;;;2895       }
;;;2896       
;;;2897       for(Count=0;Count<Size_B;Count++)                                                              
000028  2700              MOVS     r7,#0
00002a  f104082a          ADD      r8,r4,#0x2a           ;2861
00002e  e05c              B        |L10.234|
000030  4e3e              LDR      r6,|L10.300|
000032  2400              MOVS     r4,#0                 ;2864
                  |L10.52|
000034  5d30              LDRB     r0,[r6,r4]            ;2865
000036  f000020f          AND      r2,r0,#0xf            ;2865
00003a  eb091110          ADD      r1,r9,r0,LSR #4       ;2865
00003e  eb02000a          ADD      r0,r2,r10             ;2865
000042  2200              MOVS     r2,#0                 ;2865
000044  f7fffffe          BL       RMP_Point
000048  1c64              ADDS     r4,r4,#1              ;2865
00004a  2c2a              CMP      r4,#0x2a              ;2864
00004c  d3f2              BCC      |L10.52|
00004e  4e37              LDR      r6,|L10.300|
000050  2400              MOVS     r4,#0                 ;2866
000052  465f              MOV      r7,r11                ;2867
000054  362a              ADDS     r6,r6,#0x2a           ;2861
                  |L10.86|
000056  5d30              LDRB     r0,[r6,r4]            ;2867
000058  f000020f          AND      r2,r0,#0xf            ;2867
00005c  eb091110          ADD      r1,r9,r0,LSR #4       ;2867
000060  eb02000a          ADD      r0,r2,r10             ;2867
000064  463a              MOV      r2,r7                 ;2867
000066  f7fffffe          BL       RMP_Point
00006a  1c64              ADDS     r4,r4,#1              ;2867
00006c  2c28              CMP      r4,#0x28              ;2866
00006e  d3f2              BCC      |L10.86|
000070  2d01              CMP      r5,#1                 ;2869
000072  d004              BEQ      |L10.126|
000074  4c2d              LDR      r4,|L10.300|
000076  2700              MOVS     r7,#0
000078  3477              ADDS     r4,r4,#0x77           ;2880
00007a  261f              MOVS     r6,#0x1f              ;2878
00007c  e033              B        |L10.230|
                  |L10.126|
00007e  4c2b              LDR      r4,|L10.300|
000080  2700              MOVS     r7,#0
000082  261b              MOVS     r6,#0x1b              ;2871
000084  3452              ADDS     r4,r4,#0x52           ;2873
000086  250a              MOVS     r5,#0xa               ;2872
000088  f104081b          ADD      r8,r4,#0x1b           ;2874
00008c  e02d              B        |L10.234|
00008e  4c27              LDR      r4,|L10.300|
000090  2700              MOVS     r7,#0
000092  2649              MOVS     r6,#0x49              ;2885
000094  3496              ADDS     r4,r4,#0x96           ;2885
000096  2571              MOVS     r5,#0x71              ;2885
000098  f1040849          ADD      r8,r4,#0x49           ;2885
00009c  e025              B        |L10.234|
00009e  2700              MOVS     r7,#0
0000a0  4c23              LDR      r4,|L10.304|
0000a2  261a              MOVS     r6,#0x1a              ;2886
0000a4  e01f              B        |L10.230|
0000a6  4c22              LDR      r4,|L10.304|
0000a8  2700              MOVS     r7,#0
0000aa  265c              MOVS     r6,#0x5c              ;2887
0000ac  341a              ADDS     r4,r4,#0x1a           ;2887
0000ae  2538              MOVS     r5,#0x38              ;2887
0000b0  f104085c          ADD      r8,r4,#0x5c           ;2887
0000b4  e019              B        |L10.234|
0000b6  4c1e              LDR      r4,|L10.304|
0000b8  2700              MOVS     r7,#0
0000ba  34ae              ADDS     r4,r4,#0xae           ;2888
0000bc  2635              MOVS     r6,#0x35              ;2888
0000be  e012              B        |L10.230|
0000c0  4c1b              LDR      r4,|L10.304|
0000c2  34e3              ADDS     r4,r4,#0xe3           ;2889
0000c4  e001              B        |L10.202|
0000c6  4c1a              LDR      r4,|L10.304|
0000c8  34ff              ADDS     r4,r4,#0xff           ;2890
                  |L10.202|
0000ca  2700              MOVS     r7,#0
0000cc  261c              MOVS     r6,#0x1c              ;2889
0000ce  e00a              B        |L10.230|
0000d0  4c18              LDR      r4,|L10.308|
0000d2  e001              B        |L10.216|
0000d4  4c17              LDR      r4,|L10.308|
0000d6  3428              ADDS     r4,r4,#0x28           ;2892
                  |L10.216|
0000d8  2700              MOVS     r7,#0
0000da  2628              MOVS     r6,#0x28              ;2891
0000dc  e003              B        |L10.230|
0000de  4c15              LDR      r4,|L10.308|
0000e0  2700              MOVS     r7,#0
0000e2  3450              ADDS     r4,r4,#0x50           ;2893
0000e4  2625              MOVS     r6,#0x25              ;2893
                  |L10.230|
0000e6  2500              MOVS     r5,#0                 ;2893
0000e8  46a8              MOV      r8,r5                 ;2893
                  |L10.234|
;;;2898           RMP_POINT(Coord_X+(Black[Count]&0x0F),Coord_Y+(Black[Count]>>4),RMP_CTL_BLACK);
0000ea  5de0              LDRB     r0,[r4,r7]
0000ec  f000020f          AND      r2,r0,#0xf
0000f0  eb091110          ADD      r1,r9,r0,LSR #4
0000f4  eb02000a          ADD      r0,r2,r10
0000f8  2200              MOVS     r2,#0
0000fa  f7fffffe          BL       RMP_Point
0000fe  1c7f              ADDS     r7,r7,#1
000100  42b7              CMP      r7,r6                 ;2897
000102  dbf2              BLT      |L10.234|
;;;2899       for(Count=0;Count<Size_W;Count++)                                                              
000104  2400              MOVS     r4,#0
000106  465e              MOV      r6,r11                ;2867
000108  e00c              B        |L10.292|
                  |L10.266|
00010a  e00d              B        |L10.296|
                  |L10.268|
;;;2900           RMP_POINT(Coord_X+(White[Count]&0x0F),Coord_Y+(White[Count]>>4),RMP_CTL_WHITE);
00010c  f8180004          LDRB     r0,[r8,r4]
000110  f000020f          AND      r2,r0,#0xf
000114  eb091110          ADD      r1,r9,r0,LSR #4
000118  eb02000a          ADD      r0,r2,r10
00011c  4632              MOV      r2,r6
00011e  f7fffffe          BL       RMP_Point
000122  1c64              ADDS     r4,r4,#1
                  |L10.292|
000124  42ac              CMP      r4,r5                 ;2899
000126  dbf1              BLT      |L10.268|
                  |L10.296|
;;;2901   }
000128  e8bd9ff0          POP      {r4-r12,pc}
;;;2902   /* End Function: RMP_Cursor **************************************************/
                          ENDP

                  |L10.300|
                          DCD      ||.constdata||+0x200
                  |L10.304|
                          DCD      ||.constdata||+0x350
                  |L10.308|
                          DCD      ||.constdata||+0x46b

                          AREA ||i.RMP_Dot_Line||, CODE, READONLY, ALIGN=1

                  RMP_Dot_Line PROC
;;;2262   ******************************************************************************/
;;;2263   void RMP_Dot_Line(cnt_t Start_X, cnt_t Start_Y, cnt_t End_X,cnt_t End_Y, ptr_t Dot, ptr_t Space)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;2264   {
;;;2265       cnt_t Trav_X;
;;;2266       cnt_t Trav_Y;
;;;2267       cnt_t Dir_X;
;;;2268       cnt_t Dir_Y;
;;;2269       cnt_t Error;
;;;2270       cnt_t Cur_X;
;;;2271       cnt_t Cur_Y;
;;;2272   
;;;2273       Error=0;
;;;2274       /* Get their absolute value, and then draw the line */
;;;2275       Trav_X=(Start_X>End_X)?(Start_X-End_X):(End_X-Start_X);
000004  4290              CMP      r0,r2
000006  f04f0400          MOV      r4,#0                 ;2273
00000a  eba20700          SUB      r7,r2,r0
00000e  dd01              BLE      |L11.20|
000010  1a86              SUBS     r6,r0,r2
000012  e000              B        |L11.22|
                  |L11.20|
000014  463e              MOV      r6,r7
                  |L11.22|
;;;2276       Trav_Y=(Start_Y>End_Y)?(Start_Y-End_Y):(End_Y-Start_Y);
000016  4299              CMP      r1,r3
000018  eba30c01          SUB      r12,r3,r1
00001c  dd01              BLE      |L11.34|
00001e  1acd              SUBS     r5,r1,r3
000020  e000              B        |L11.36|
                  |L11.34|
000022  4665              MOV      r5,r12
                  |L11.36|
;;;2277   
;;;2278       /* Decide the increment direction */
;;;2279       if(End_X-Start_X>0)
000024  2f00              CMP      r7,#0
;;;2280           Dir_X=1;
;;;2281       else
;;;2282           Dir_X=-1;
000026  f04f37ff          MOV      r7,#0xffffffff
00002a  dd02              BLE      |L11.50|
00002c  f04f0901          MOV      r9,#1                 ;2280
000030  e000              B        |L11.52|
                  |L11.50|
000032  46b9              MOV      r9,r7
                  |L11.52|
;;;2283   
;;;2284       if(End_Y-Start_Y>0)
000034  f1bc0f00          CMP      r12,#0
000038  dd00              BLE      |L11.60|
;;;2285           Dir_Y=1;
00003a  2701              MOVS     r7,#1
                  |L11.60|
;;;2286       else
;;;2287           Dir_Y=-1;
;;;2288   
;;;2289       if(Trav_X>Trav_Y)
00003c  42ae              CMP      r6,r5
00003e  46b8              MOV      r8,r7                 ;2287
000040  dd1b              BLE      |L11.122|
;;;2290       {
;;;2291           Cur_Y=Start_Y;
;;;2292           for(Cur_X=Start_X;Cur_X!=End_X+Dir_X;Cur_X+=Dir_X)
000042  eb020a09          ADD      r10,r2,r9
000046  468b              MOV      r11,r1                ;2291
000048  4607              MOV      r7,r0
00004a  e012              B        |L11.114|
                  |L11.76|
;;;2293           {
;;;2294               /* Draw the dot and the white space alternatively */
;;;2295               if((Cur_X&0x01)!=0)
00004c  07f8              LSLS     r0,r7,#31
00004e  d001              BEQ      |L11.84|
;;;2296                   RMP_POINT(Cur_X,Cur_Y,Dot);
000050  9a0a              LDR      r2,[sp,#0x28]
000052  e003              B        |L11.92|
                  |L11.84|
;;;2297               else
;;;2298               {
;;;2299                   if(Space!=RMP_TRANS)
000054  980b              LDR      r0,[sp,#0x2c]
000056  2801              CMP      r0,#1
000058  d004              BEQ      |L11.100|
;;;2300                       RMP_POINT(Cur_X,Cur_Y,Space);
00005a  4602              MOV      r2,r0
                  |L11.92|
00005c  4659              MOV      r1,r11
00005e  4638              MOV      r0,r7
000060  f7fffffe          BL       RMP_Point
                  |L11.100|
;;;2301               }
;;;2302               Error+=Trav_Y;
000064  442c              ADD      r4,r4,r5
;;;2303               if((Error<<1)>=Trav_X)
000066  ebb60f44          CMP      r6,r4,LSL #1
00006a  dc01              BGT      |L11.112|
;;;2304               {
;;;2305                   Cur_Y+=Dir_Y;
;;;2306                   Error-=Trav_X;
00006c  1ba4              SUBS     r4,r4,r6
00006e  44c3              ADD      r11,r11,r8            ;2305
                  |L11.112|
000070  444f              ADD      r7,r7,r9              ;2292
                  |L11.114|
000072  45ba              CMP      r10,r7                ;2292
000074  d1ea              BNE      |L11.76|
                  |L11.118|
;;;2307               }
;;;2308           }
;;;2309       }
;;;2310       else
;;;2311       {
;;;2312           Cur_X=Start_X;
;;;2313           for(Cur_Y=Start_Y;Cur_Y!=End_Y+Dir_Y;Cur_Y+=Dir_Y)
;;;2314           {
;;;2315               /* Draw the dot and the white space alternatively */
;;;2316               if((Cur_Y&0x01)!=0)
;;;2317                   RMP_POINT(Cur_X,Cur_Y,Dot);
;;;2318               else
;;;2319               {
;;;2320                   if(Space!=RMP_TRANS)
;;;2321                       RMP_POINT(Cur_X,Cur_Y,Space);
;;;2322               }
;;;2323   
;;;2324               Error+=Trav_X;
;;;2325               if((Error<<1)>=Trav_Y)
;;;2326               {
;;;2327                   Cur_X+=Dir_X;
;;;2328                   Error-=Trav_Y;
;;;2329               }
;;;2330           }
;;;2331       }
;;;2332   }
000076  e8bd9ff0          POP      {r4-r12,pc}
                  |L11.122|
00007a  eb030a08          ADD      r10,r3,r8             ;2313
00007e  4683              MOV      r11,r0                ;2312
000080  460f              MOV      r7,r1                 ;2313
000082  e012              B        |L11.170|
                  |L11.132|
000084  07f8              LSLS     r0,r7,#31             ;2316
000086  d001              BEQ      |L11.140|
000088  9a0a              LDR      r2,[sp,#0x28]         ;2317
00008a  e003              B        |L11.148|
                  |L11.140|
00008c  980b              LDR      r0,[sp,#0x2c]         ;2320
00008e  2801              CMP      r0,#1                 ;2320
000090  d004              BEQ      |L11.156|
000092  4602              MOV      r2,r0                 ;2321
                  |L11.148|
000094  4639              MOV      r1,r7                 ;2321
000096  4658              MOV      r0,r11                ;2321
000098  f7fffffe          BL       RMP_Point
                  |L11.156|
00009c  4434              ADD      r4,r4,r6              ;2324
00009e  ebb50f44          CMP      r5,r4,LSL #1          ;2325
0000a2  dc01              BGT      |L11.168|
0000a4  1b64              SUBS     r4,r4,r5              ;2328
0000a6  44cb              ADD      r11,r11,r9            ;2327
                  |L11.168|
0000a8  4447              ADD      r7,r7,r8              ;2313
                  |L11.170|
0000aa  45ba              CMP      r10,r7                ;2313
0000ac  d1ea              BNE      |L11.132|
0000ae  e7e2              B        |L11.118|
;;;2333   /* End Function:RMP_Dot_Line *************************************************/
                          ENDP


                          AREA ||i.RMP_Free||, CODE, READONLY, ALIGN=1

                  RMP_Free PROC
;;;2080   ******************************************************************************/
;;;2081   void RMP_Free(volatile void* Pool, void* Mem_Ptr)
000000  b570              PUSH     {r4-r6,lr}
;;;2082   {
000002  4605              MOV      r5,r0
;;;2083       volatile struct RMP_Mem* Mem; 
;;;2084       volatile struct RMP_Mem_Head* Mem_Head;
;;;2085       volatile struct RMP_Mem_Head* Left_Head;
;;;2086       volatile struct RMP_Mem_Head* Right_Head;
;;;2087       cnt_t Merge_Left;
;;;2088   
;;;2089       /* See if the address is within the allocatable address range. If not, abort directly. */
;;;2090       Mem=(volatile struct RMP_Mem*)Pool;
;;;2091       if((((ptr_t)Mem_Ptr)<=((ptr_t)Mem))||(((ptr_t)Mem_Ptr)>=(((ptr_t)Mem)+Mem->Size)))
000004  42a9              CMP      r1,r5
000006  d939              BLS      |L12.124|
000008  6902              LDR      r2,[r0,#0x10]
00000a  1950              ADDS     r0,r2,r5
00000c  4288              CMP      r0,r1
00000e  d935              BLS      |L12.124|
;;;2092           return;
;;;2093   
;;;2094       Mem_Head=(struct RMP_Mem_Head*)(((ptr_t)Mem_Ptr)-sizeof(struct RMP_Mem_Head));
000010  f1a10410          SUB      r4,r1,#0x10
;;;2095       /* See if the block can really be freed by this PID. If cannot, return directly */
;;;2096       if(Mem_Head->State==RMP_MEM_FREE)
000014  68a0              LDR      r0,[r4,#8]
000016  2800              CMP      r0,#0
000018  d030              BEQ      |L12.124|
;;;2097           return;
;;;2098   
;;;2099       /* Now we are sure that it can be freed. Delete it from the allocated list now */
;;;2100       RMP_List_Del(Mem_Head->Head.Prev,Mem_Head->Head.Next);
00001a  6820              LDR      r0,[r4,#0]
00001c  6861              LDR      r1,[r4,#4]
00001e  6008              STR      r0,[r1,#0]
000020  6041              STR      r1,[r0,#4]
;;;2101       Mem_Head->State=RMP_MEM_FREE;
000022  2000              MOVS     r0,#0
000024  60a0              STR      r0,[r4,#8]
;;;2102       
;;;2103       /* Now check if we can merge it with the higher blocks */
;;;2104       Right_Head=(struct RMP_Mem_Head*)(((ptr_t)(Mem_Head->Tail))+sizeof(struct RMP_Mem_Tail));
000026  68e6              LDR      r6,[r4,#0xc]
;;;2105       if(((ptr_t)Right_Head)!=(((ptr_t)Mem)+Mem->Size))
000028  6929              LDR      r1,[r5,#0x10]
00002a  1d36              ADDS     r6,r6,#4
00002c  1948              ADDS     r0,r1,r5
00002e  42b0              CMP      r0,r6
000030  d00b              BEQ      |L12.74|
;;;2106       {
;;;2107           /* If this one is unoccupied */
;;;2108           if((Right_Head->State)==RMP_MEM_FREE)
000032  68b0              LDR      r0,[r6,#8]
000034  b948              CBNZ     r0,|L12.74|
;;;2109           {
;;;2110               /* Delete, merge */
;;;2111               _RMP_Mem_Del(Pool,Right_Head);
000036  4631              MOV      r1,r6
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       _RMP_Mem_Del
;;;2112               _RMP_Mem_Block(Mem_Head,
00003e  68f0              LDR      r0,[r6,#0xc]
000040  1b01              SUBS     r1,r0,r4
000042  4620              MOV      r0,r4
000044  1d09              ADDS     r1,r1,#4
000046  f7fffffe          BL       _RMP_Mem_Block
                  |L12.74|
;;;2113                              ((ptr_t)(Right_Head->Tail))+sizeof(struct RMP_Mem_Tail)-(ptr_t)Mem_Head);
;;;2114           }
;;;2115       }
;;;2116   
;;;2117       /* Now check if we can merge it with the lower blocks */
;;;2118       Merge_Left=0;
;;;2119       if((ptr_t)Mem_Head!=Mem->Start)
00004a  68e8              LDR      r0,[r5,#0xc]
00004c  42a0              CMP      r0,r4
00004e  d003              BEQ      |L12.88|
;;;2120       {
;;;2121           Left_Head=((struct RMP_Mem_Tail*)(((ptr_t)Mem_Head)-sizeof(struct RMP_Mem_Tail)))->Head;
000050  f8546c04          LDR      r6,[r4,#-4]
;;;2122   
;;;2123           /* If this one is unoccupied */
;;;2124           if(Left_Head->State==RMP_MEM_FREE)
000054  68b0              LDR      r0,[r6,#8]
000056  b128              CBZ      r0,|L12.100|
                  |L12.88|
;;;2125           {
;;;2126               /* Delete, merge */
;;;2127               _RMP_Mem_Del(Pool, Left_Head);
;;;2128               _RMP_Mem_Block(Left_Head,
;;;2129                              (ptr_t)((ptr_t)(Mem_Head->Tail)+sizeof(struct RMP_Mem_Tail)-(ptr_t)Left_Head));
;;;2130   
;;;2131               /* We have completed the merge here and the original block has destroyed.
;;;2132                * Thus there's no need to insert it into the list again */
;;;2133               Merge_Left=1;
;;;2134           }
;;;2135       }
;;;2136   
;;;2137       /* If we did not merge it with the left-side blocks, insert the original pointer's block 
;;;2138        * into the TLSF table(Merging with the right-side one won't disturb this) */
;;;2139       if(Merge_Left==0)
;;;2140           _RMP_Mem_Ins(Pool, Mem_Head);
000058  4621              MOV      r1,r4
                  |L12.90|
00005a  4628              MOV      r0,r5
00005c  e8bd4070          POP      {r4-r6,lr}
000060  f7ffbffe          B.W      _RMP_Mem_Ins
                  |L12.100|
000064  4631              MOV      r1,r6                 ;2127
000066  4628              MOV      r0,r5                 ;2127
000068  f7fffffe          BL       _RMP_Mem_Del
00006c  68e0              LDR      r0,[r4,#0xc]          ;2128
00006e  1b81              SUBS     r1,r0,r6              ;2128
000070  4630              MOV      r0,r6                 ;2128
000072  1d09              ADDS     r1,r1,#4              ;2128
000074  f7fffffe          BL       _RMP_Mem_Block
;;;2141       else
;;;2142           _RMP_Mem_Ins(Pool, Left_Head);
000078  4631              MOV      r1,r6
00007a  e7ee              B        |L12.90|
                  |L12.124|
;;;2143   }
00007c  bd70              POP      {r4-r6,pc}
;;;2144   /* End Function:RMP_Free *****************************************************/
                          ENDP


                          AREA ||i.RMP_Init||, CODE, READONLY, ALIGN=1

                  RMP_Init PROC
;;;1592   ******************************************************************************/
;;;1593   void RMP_Init(void)
000000  f7fffffe          BL       RMP_Lock_Sched
;;;1594   {
;;;1595       RMP_Lock_Sched();
;;;1596       
;;;1597       /* Platform will use this hook to do something */
;;;1598       _RMP_Plat_Hook();
000004  f7fffffe          BL       _RMP_Plat_Hook
;;;1599       /* Start the second thread here */
;;;1600       RMP_Init_Hook();
000008  f7fffffe          BL       RMP_Init_Hook
;;;1601       
;;;1602       RMP_Unlock_Sched();
00000c  f7fffffe          BL       RMP_Unlock_Sched
                  |L13.16|
;;;1603       
;;;1604       while(1)
;;;1605       {
;;;1606           RMP_Init_Idle();
000010  f7fffffe          BL       RMP_Init_Idle
000014  e7fc              B        |L13.16|
;;;1607       };
;;;1608   }
;;;1609   /* End Function:RMP_Init *****************************************************/
                          ENDP


                          AREA ||i.RMP_LSB_Get||, CODE, READONLY, ALIGN=1

                  RMP_LSB_Get PROC
;;;1733   ******************************************************************************/
;;;1734   ptr_t RMP_LSB_Get(ptr_t Val)
000000  b510              PUSH     {r4,lr}
;;;1735   {
;;;1736   #if(RMP_WORD_ORDER==4)
;;;1737       return 15-RMP_MSB_Get(RMP_RBIT_Get(Val));
;;;1738   #elif(RMP_WORD_ORDER==5)
;;;1739       return 31-RMP_MSB_Get(RMP_RBIT_Get(Val));
000002  f7fffffe          BL       RMP_RBIT_Get
000006  f7fffffe          BL       RMP_MSB_Get
00000a  f1c0001f          RSB      r0,r0,#0x1f
;;;1740   #else
;;;1741       return 63-RMP_MSB_Get(RMP_RBIT_Get(Val));
;;;1742   #endif 
;;;1743   }
00000e  bd10              POP      {r4,pc}
;;;1744   /* End Function:RMP_LSB_Get **************************************************/
                          ENDP


                          AREA ||i.RMP_Line||, CODE, READONLY, ALIGN=1

                  RMP_Line PROC
;;;2156   #ifdef RMP_POINT
;;;2157   void RMP_Line(cnt_t Start_X, cnt_t Start_Y, cnt_t End_X, cnt_t End_Y, ptr_t Color)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;2158   {
;;;2159       cnt_t Trav_X;
;;;2160       cnt_t Trav_Y;
;;;2161       cnt_t Dir_X;
;;;2162       cnt_t Dir_Y;
;;;2163       cnt_t Error;
;;;2164       cnt_t Cur_X;
;;;2165       cnt_t Cur_Y;
;;;2166       
;;;2167       /* See if this line is horizontal or vertical. If so we speed it up */
;;;2168       if(Start_X==End_X)
000004  4290              CMP      r0,r2
000006  460c              MOV      r4,r1                 ;2158
000008  4605              MOV      r5,r0                 ;2158
00000a  d110              BNE      |L15.46|
;;;2169       {
;;;2170           /* Vertical */
;;;2171           if(Start_Y>End_Y)
00000c  429c              CMP      r4,r3
00000e  dd01              BLE      |L15.20|
;;;2172           {
;;;2173               Dir_Y=End_Y;
000010  461e              MOV      r6,r3
;;;2174               Trav_Y=Start_Y;
000012  e008              B        |L15.38|
                  |L15.20|
;;;2175           }
;;;2176           else
;;;2177           {
;;;2178               Dir_Y=Start_Y;
000014  460e              MOV      r6,r1
;;;2179               Trav_Y=End_Y;
000016  461c              MOV      r4,r3
000018  e005              B        |L15.38|
                  |L15.26|
;;;2180           }
;;;2181           
;;;2182           for(Cur_Y=Dir_Y;Cur_Y<=Trav_Y;Cur_Y++)
;;;2183               RMP_POINT(Start_X,Cur_Y,Color);
00001a  9a0a              LDR      r2,[sp,#0x28]
00001c  4631              MOV      r1,r6
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       RMP_Point
000024  1c76              ADDS     r6,r6,#1
                  |L15.38|
000026  42a6              CMP      r6,r4                 ;2182
000028  ddf7              BLE      |L15.26|
                  |L15.42|
;;;2184           return;
;;;2185       }
;;;2186       else if(Start_Y==End_Y)
;;;2187       {
;;;2188           /* Horizontal */
;;;2189           if(Start_X>End_X)
;;;2190           {
;;;2191               Dir_X=End_X;
;;;2192               Trav_X=Start_X;
;;;2193           }
;;;2194           else
;;;2195           {
;;;2196               Dir_X=Start_X;
;;;2197               Trav_X=End_X;
;;;2198           }
;;;2199           
;;;2200           for(Cur_X=Dir_X;Cur_X<=Trav_X;Cur_X++)
;;;2201               RMP_POINT(Cur_X,Start_Y,Color);
;;;2202           return;
;;;2203       }
;;;2204   
;;;2205       Error=0;
;;;2206       /* Get their absolute value, and then draw the line */
;;;2207       Trav_X=(Start_X>End_X)?(Start_X-End_X):(End_X-Start_X);
;;;2208       Trav_Y=(Start_Y>End_Y)?(Start_Y-End_Y):(End_Y-Start_Y);
;;;2209   
;;;2210       /* Decide the increment direction */
;;;2211       if(End_X-Start_X>0)
;;;2212           Dir_X=1;
;;;2213       else
;;;2214           Dir_X=-1;
;;;2215   
;;;2216       if(End_Y-Start_Y>0)
;;;2217           Dir_Y=1;
;;;2218       else
;;;2219           Dir_Y=-1;
;;;2220   
;;;2221       if(Trav_X>Trav_Y)
;;;2222       {
;;;2223           Cur_Y=Start_Y;
;;;2224           for(Cur_X=Start_X;Cur_X!=End_X+Dir_X;Cur_X+=Dir_X)
;;;2225           {
;;;2226               RMP_POINT(Cur_X,Cur_Y,Color);
;;;2227               Error+=Trav_Y;
;;;2228               if((Error<<1)>=Trav_X)
;;;2229               {
;;;2230                   Cur_Y+=Dir_Y;
;;;2231                   Error-=Trav_X;
;;;2232               }
;;;2233           }
;;;2234       }
;;;2235       else
;;;2236       {
;;;2237           Cur_X=Start_X;
;;;2238           for(Cur_Y=Start_Y;Cur_Y!=End_Y+Dir_Y;Cur_Y+=Dir_Y)
;;;2239           {
;;;2240               RMP_POINT(Cur_X,Cur_Y,Color);
;;;2241               Error+=Trav_X;
;;;2242               if((Error<<1)>=Trav_Y)
;;;2243               {
;;;2244                   Cur_X+=Dir_X;
;;;2245                   Error-=Trav_Y;
;;;2246               }
;;;2247           }
;;;2248       }
;;;2249   }
00002a  e8bd9ff0          POP      {r4-r12,pc}
                  |L15.46|
00002e  429c              CMP      r4,r3                 ;2186
000030  d10f              BNE      |L15.82|
000032  4295              CMP      r5,r2                 ;2189
000034  dd01              BLE      |L15.58|
000036  4616              MOV      r6,r2                 ;2191
000038  e008              B        |L15.76|
                  |L15.58|
00003a  4606              MOV      r6,r0                 ;2196
00003c  4615              MOV      r5,r2                 ;2197
00003e  e005              B        |L15.76|
                  |L15.64|
000040  9a0a              LDR      r2,[sp,#0x28]         ;2201
000042  4621              MOV      r1,r4                 ;2201
000044  4630              MOV      r0,r6                 ;2201
000046  f7fffffe          BL       RMP_Point
00004a  1c76              ADDS     r6,r6,#1              ;2201
                  |L15.76|
00004c  42ae              CMP      r6,r5                 ;2200
00004e  ddf7              BLE      |L15.64|
000050  e7eb              B        |L15.42|
                  |L15.82|
000052  2600              MOVS     r6,#0                 ;2205
000054  1b51              SUBS     r1,r2,r5              ;2207
000056  4295              CMP      r5,r2                 ;2207
000058  dd01              BLE      |L15.94|
00005a  1aa8              SUBS     r0,r5,r2              ;2207
00005c  e000              B        |L15.96|
                  |L15.94|
00005e  4608              MOV      r0,r1                 ;2207
                  |L15.96|
000060  4680              MOV      r8,r0                 ;2207
000062  1b18              SUBS     r0,r3,r4              ;2208
000064  429c              CMP      r4,r3                 ;2208
000066  dd01              BLE      |L15.108|
000068  1ae7              SUBS     r7,r4,r3              ;2208
00006a  e000              B        |L15.110|
                  |L15.108|
00006c  4607              MOV      r7,r0                 ;2208
                  |L15.110|
00006e  2900              CMP      r1,#0                 ;2211
000070  f04f31ff          MOV      r1,#0xffffffff        ;2214
000074  dd02              BLE      |L15.124|
000076  f04f0a01          MOV      r10,#1                ;2212
00007a  e000              B        |L15.126|
                  |L15.124|
00007c  468a              MOV      r10,r1                ;2214
                  |L15.126|
00007e  2800              CMP      r0,#0                 ;2216
000080  dd02              BLE      |L15.136|
000082  f04f0901          MOV      r9,#1                 ;2217
000086  e000              B        |L15.138|
                  |L15.136|
000088  4689              MOV      r9,r1                 ;2219
                  |L15.138|
00008a  45b8              CMP      r8,r7                 ;2221
00008c  dd12              BLE      |L15.180|
00008e  eb020b0a          ADD      r11,r2,r10            ;2224
000092  e00c              B        |L15.174|
                  |L15.148|
000094  9a0a              LDR      r2,[sp,#0x28]         ;2226
000096  4621              MOV      r1,r4                 ;2226
000098  4628              MOV      r0,r5                 ;2226
00009a  f7fffffe          BL       RMP_Point
00009e  443e              ADD      r6,r6,r7              ;2227
0000a0  ebb80f46          CMP      r8,r6,LSL #1          ;2228
0000a4  dc02              BGT      |L15.172|
0000a6  444c              ADD      r4,r4,r9              ;2230
0000a8  eba60608          SUB      r6,r6,r8              ;2231
                  |L15.172|
0000ac  4455              ADD      r5,r5,r10             ;2224
                  |L15.174|
0000ae  45ab              CMP      r11,r5                ;2224
0000b0  d1f0              BNE      |L15.148|
0000b2  e7ba              B        |L15.42|
                  |L15.180|
0000b4  eb030b09          ADD      r11,r3,r9             ;2238
0000b8  e00b              B        |L15.210|
                  |L15.186|
0000ba  9a0a              LDR      r2,[sp,#0x28]         ;2240
0000bc  4621              MOV      r1,r4                 ;2240
0000be  4628              MOV      r0,r5                 ;2240
0000c0  f7fffffe          BL       RMP_Point
0000c4  4446              ADD      r6,r6,r8              ;2241
0000c6  ebb70f46          CMP      r7,r6,LSL #1          ;2242
0000ca  dc01              BGT      |L15.208|
0000cc  1bf6              SUBS     r6,r6,r7              ;2245
0000ce  4455              ADD      r5,r5,r10             ;2244
                  |L15.208|
0000d0  444c              ADD      r4,r4,r9              ;2238
                  |L15.210|
0000d2  45a3              CMP      r11,r4                ;2238
0000d4  d1f1              BNE      |L15.186|
0000d6  e7a8              B        |L15.42|
;;;2250   /* End Function:RMP_Line *****************************************************/
                          ENDP


                          AREA ||i.RMP_Lineedit||, CODE, READONLY, ALIGN=1

                  RMP_Lineedit PROC
;;;3081   ******************************************************************************/
;;;3082   void RMP_Lineedit(cnt_t Coord_X, cnt_t Coord_Y, cnt_t Length, cnt_t Width)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;3083   {
;;;3084       RMP_Rectangle(Coord_X,Coord_Y,Length,Width,RMP_CTL_WHITE,RMP_CTL_WHITE);
000004  f64f78ff          MOV      r8,#0xffff
000008  4606              MOV      r6,r0                 ;3083
00000a  469a              MOV      r10,r3                ;3083
00000c  4614              MOV      r4,r2                 ;3083
00000e  460d              MOV      r5,r1                 ;3083
000010  f8cd8000          STR      r8,[sp,#0]
000014  f8cd8004          STR      r8,[sp,#4]
000018  f7fffffe          BL       RMP_Rectangle
;;;3085       
;;;3086       /* Now draw the border */
;;;3087       RMP_Line(Coord_X,Coord_Y,Coord_X+Length-1,Coord_Y,RMP_CTL_DARK);
00001c  1937              ADDS     r7,r6,r4
00001e  462b              MOV      r3,r5
000020  1e7a              SUBS     r2,r7,#1
000022  f64739ef          MOV      r9,#0x7bef
000026  4619              MOV      r1,r3
000028  4630              MOV      r0,r6
00002a  f8cd9000          STR      r9,[sp,#0]
00002e  f7fffffe          BL       RMP_Line
;;;3088       RMP_Line(Coord_X+Length-1,Coord_Y,Coord_X+Length-1,Coord_Y+Width-1,RMP_CTL_WHITE);
000032  eb05040a          ADD      r4,r5,r10
000036  4629              MOV      r1,r5
000038  1e7a              SUBS     r2,r7,#1
00003a  f8cd8000          STR      r8,[sp,#0]
00003e  1e78              SUBS     r0,r7,#1
000040  1e63              SUBS     r3,r4,#1
000042  f7fffffe          BL       RMP_Line
;;;3089       RMP_Line(Coord_X+Length-1,Coord_Y+Width-1,Coord_X,Coord_Y+Width-1,RMP_CTL_WHITE);
000046  1e63              SUBS     r3,r4,#1
000048  4632              MOV      r2,r6
00004a  1e78              SUBS     r0,r7,#1
00004c  4619              MOV      r1,r3
00004e  f8cd8000          STR      r8,[sp,#0]
000052  f7fffffe          BL       RMP_Line
;;;3090       RMP_Line(Coord_X,Coord_Y+Width-1,Coord_X,Coord_Y,RMP_CTL_DARK);
000056  4632              MOV      r2,r6
000058  462b              MOV      r3,r5
00005a  1e61              SUBS     r1,r4,#1
00005c  4610              MOV      r0,r2
00005e  f8cd9000          STR      r9,[sp,#0]
000062  f7fffffe          BL       RMP_Line
;;;3091       /* The shadow */
;;;3092       RMP_Line(Coord_X+1,Coord_Y+Width-2,Coord_X+1,Coord_Y+1,RMP_CTL_BLACK);    
000066  1ea1              SUBS     r1,r4,#2
000068  f04f0800          MOV      r8,#0
00006c  1c6b              ADDS     r3,r5,#1
00006e  f8cd8000          STR      r8,[sp,#0]
000072  1c72              ADDS     r2,r6,#1
000074  1c70              ADDS     r0,r6,#1
000076  f7fffffe          BL       RMP_Line
;;;3093       RMP_Line(Coord_X+1,Coord_Y+1,Coord_X+Length-2,Coord_Y+1,RMP_CTL_BLACK);
00007a  1eba              SUBS     r2,r7,#2
00007c  f8cd8000          STR      r8,[sp,#0]
000080  1c6b              ADDS     r3,r5,#1
000082  1c69              ADDS     r1,r5,#1
000084  1c70              ADDS     r0,r6,#1
000086  f7fffffe          BL       RMP_Line
;;;3094   }
00008a  e8bd87fc          POP      {r2-r10,pc}
;;;3095   /* End Function:RMP_Lineedit *************************************************/
                          ENDP


                          AREA ||i.RMP_Lineedit_Clr||, CODE, READONLY, ALIGN=1

                  RMP_Lineedit_Clr PROC
;;;3065   ******************************************************************************/
;;;3066   void RMP_Lineedit_Clr(cnt_t Coord_X, cnt_t Coord_Y, cnt_t Length,
000000  b51c              PUSH     {r2-r4,lr}
;;;3067                         cnt_t Width, cnt_t Clr_X, cnt_t Clr_Len)
;;;3068   {
;;;3069       RMP_Rectangle(Clr_X,Coord_Y+1,Clr_Len,Width-2,RMP_CTL_WHITE,RMP_CTL_WHITE);
000002  f64f74ff          MOV      r4,#0xffff
000006  1c49              ADDS     r1,r1,#1
000008  e9dd0204          LDRD     r0,r2,[sp,#0x10]      ;3068
00000c  1e9b              SUBS     r3,r3,#2
00000e  9400              STR      r4,[sp,#0]
000010  9401              STR      r4,[sp,#4]
000012  f7fffffe          BL       RMP_Rectangle
;;;3070   }
000016  bd1c              POP      {r2-r4,pc}
;;;3071   /* End Function:RMP_Lineedit_Clr *********************************************/
                          ENDP


                          AREA ||i.RMP_List_Crt||, CODE, READONLY, ALIGN=1

                  RMP_List_Crt PROC
;;;215    ******************************************************************************/
;;;216    void RMP_List_Crt(volatile struct RMP_List* Head)
000000  6000              STR      r0,[r0,#0]
;;;217    {
;;;218        Head->Prev=(struct RMP_List*)Head;
;;;219        Head->Next=(struct RMP_List*)Head;
000002  6040              STR      r0,[r0,#4]
;;;220    }
000004  4770              BX       lr
;;;221    /* End Function:RMP_List_Crt *************************************************/
                          ENDP


                          AREA ||i.RMP_List_Del||, CODE, READONLY, ALIGN=1

                  RMP_List_Del PROC
;;;229    ******************************************************************************/
;;;230    void RMP_List_Del(volatile struct RMP_List* Prev,volatile struct RMP_List* Next)
000000  6008              STR      r0,[r1,#0]
;;;231    {
;;;232        Next->Prev=(struct RMP_List*)Prev;
;;;233        Prev->Next=(struct RMP_List*)Next;
000002  6041              STR      r1,[r0,#4]
;;;234    }
000004  4770              BX       lr
;;;235    /* End Function:RMP_List_Del *************************************************/
                          ENDP


                          AREA ||i.RMP_List_Ins||, CODE, READONLY, ALIGN=1

                  RMP_List_Ins PROC
;;;244    ******************************************************************************/
;;;245    void RMP_List_Ins(volatile struct RMP_List* New,
000000  6010              STR      r0,[r2,#0]
;;;246                      volatile struct RMP_List* Prev,
;;;247                      volatile struct RMP_List* Next)
;;;248    {
;;;249        Next->Prev=(struct RMP_List*)New;
;;;250        New->Next=(struct RMP_List*)Next;
000002  6042              STR      r2,[r0,#4]
;;;251        New->Prev=(struct RMP_List*)Prev;
000004  6001              STR      r1,[r0,#0]
;;;252        Prev->Next=(struct RMP_List*)New;
000006  6048              STR      r0,[r1,#4]
;;;253    }
000008  4770              BX       lr
;;;254    /* End Function:RMP_List_Ins *************************************************/
                          ENDP


                          AREA ||i.RMP_Load_Ctx||, CODE, READONLY, ALIGN=1

                  RMP_Load_Ctx PROC
;;;1560   #if(RMP_USE_HOOKS==RMP_FALSE)
;;;1561   void RMP_Load_Ctx(void)
000000  4770              BX       lr
;;;1562   {
;;;1563       return;
;;;1564   }
;;;1565   #endif
                          ENDP


                          AREA ||i.RMP_Lock_Sched||, CODE, READONLY, ALIGN=2

                  RMP_Lock_Sched PROC
;;;345    ******************************************************************************/
;;;346    void RMP_Lock_Sched(void)
000000  20ff              MOVS     r0,#0xff
;;;347    {
000002  b510              PUSH     {r4,lr}
;;;348        RMP_MASK_INT();
000004  f7fffffe          BL       RMP_Mask_Int
;;;349        RMP_Sched_Locked=1;
000008  4803              LDR      r0,|L22.24|
00000a  2101              MOVS     r1,#1
00000c  60c1              STR      r1,[r0,#0xc]  ; RMP_Sched_Locked
;;;350        RMP_Sched_Lock_Cnt++;
00000e  6881              LDR      r1,[r0,#8]  ; RMP_Sched_Lock_Cnt
000010  1c49              ADDS     r1,r1,#1
000012  6081              STR      r1,[r0,#8]  ; RMP_Sched_Lock_Cnt
;;;351    }
000014  bd10              POP      {r4,pc}
;;;352    /* End Function:RMP_Lock_Sched ***********************************************/
                          ENDP

000016  0000              DCW      0x0000
                  |L22.24|
                          DCD      ||.data||

                          AREA ||i.RMP_Malloc||, CODE, READONLY, ALIGN=1

                  RMP_Malloc PROC
;;;2018   ******************************************************************************/
;;;2019   void* RMP_Malloc(volatile void* Pool, ptr_t Size)                                                       
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;2020   {    
000004  4606              MOV      r6,r0
000006  b179              CBZ      r1,|L23.40|
;;;2021       cnt_t FLI_Level;
;;;2022       cnt_t SLI_Level;
;;;2023       volatile struct RMP_Mem* Mem;
;;;2024       ptr_t Old_Size;
;;;2025       volatile struct RMP_Mem_Head* Mem_Head;
;;;2026       ptr_t Rounded_Size;
;;;2027       volatile struct RMP_Mem_Head* New_Mem;
;;;2028       ptr_t New_Size;
;;;2029       
;;;2030       if(Size==0)
;;;2031           return (void*)(0);
;;;2032       
;;;2033       /* Round up the size:a multiple of 8 and bigger than 64B. In fact, we will add
;;;2034        * extra 8 bytes at the end if the size is a multiple of 8 for safety. */
;;;2035       Rounded_Size=(((Size-1)>>3)+1)<<3;
000008  1e49              SUBS     r1,r1,#1
00000a  f04f0901          MOV      r9,#1
00000e  08c8              LSRS     r0,r1,#3
000010  00c4              LSLS     r4,r0,#3
000012  3408              ADDS     r4,r4,#8
;;;2036       /* See if it is smaller than the smallest block */
;;;2037       Rounded_Size=(Rounded_Size>64)?Rounded_Size:64;
000014  2c40              CMP      r4,#0x40
000016  d800              BHI      |L23.26|
000018  2440              MOVS     r4,#0x40
                  |L23.26|
;;;2038   
;;;2039       /* See if such block exists, if not, abort */
;;;2040       if(_RMP_Mem_Search(Pool,Rounded_Size,&FLI_Level,&SLI_Level)!=0)
00001a  466a              MOV      r2,sp
00001c  ab01              ADD      r3,sp,#4
00001e  4621              MOV      r1,r4
000020  4630              MOV      r0,r6
000022  f7fffffe          BL       _RMP_Mem_Search
000026  b110              CBZ      r0,|L23.46|
                  |L23.40|
;;;2041           return (void*)(0);
000028  2000              MOVS     r0,#0
                  |L23.42|
;;;2042       
;;;2043       Mem=(volatile struct RMP_Mem*)Pool;
;;;2044       
;;;2045       /* There is such block. Get it and delete it from the TLSF list. */
;;;2046       Mem_Head=(struct RMP_Mem_Head*)(Mem->Table[RMP_MEM_POS(FLI_Level,SLI_Level)].Next);
;;;2047       _RMP_Mem_Del(Pool, Mem_Head);
;;;2048   
;;;2049       /* Allocate and calculate if the space left could be big enough to be a new 
;;;2050        * block. If so, we will put the block back into the TLSF table */
;;;2051       New_Size=(ptr_t)(Mem_Head->Tail)-((ptr_t)Mem_Head)-sizeof(struct RMP_Mem_Head)-Rounded_Size;
;;;2052       if(New_Size>=sizeof(struct RMP_Mem_Head)+64+sizeof(struct RMP_Mem_Tail))
;;;2053       {
;;;2054           Old_Size=sizeof(struct RMP_Mem_Head)+Rounded_Size+sizeof(struct RMP_Mem_Tail);
;;;2055           New_Mem=(volatile struct RMP_Mem_Head*)(((ptr_t)Mem_Head)+Old_Size);
;;;2056   
;;;2057           _RMP_Mem_Block(Mem_Head, Old_Size);
;;;2058           _RMP_Mem_Block(New_Mem, New_Size);
;;;2059   
;;;2060           /* Put the extra block back */
;;;2061           _RMP_Mem_Ins(Pool, New_Mem);
;;;2062       }
;;;2063   
;;;2064       /* Insert the allocated block into the lists */
;;;2065       RMP_List_Ins(&(Mem_Head->Head),&(Mem->Alloc),Mem->Alloc.Next);
;;;2066       Mem_Head->State=RMP_MEM_USED;
;;;2067   
;;;2068       /* Finally, return the start address */
;;;2069       return (void*)(((ptr_t)Mem_Head)+sizeof(struct RMP_Mem_Head));
;;;2070   }
00002a  e8bd87fc          POP      {r2-r10,pc}
                  |L23.46|
00002e  e9dd1000          LDRD     r1,r0,[sp,#0]
000032  eb0000c1          ADD      r0,r0,r1,LSL #3       ;2046
000036  eb0600c0          ADD      r0,r6,r0,LSL #3       ;2046
00003a  6ac5              LDR      r5,[r0,#0x2c]         ;2046
00003c  4630              MOV      r0,r6                 ;2047
00003e  4629              MOV      r1,r5                 ;2047
000040  f7fffffe          BL       _RMP_Mem_Del
000044  68e8              LDR      r0,[r5,#0xc]          ;2051
000046  1b40              SUBS     r0,r0,r5              ;2051
000048  1b07              SUBS     r7,r0,r4              ;2051
00004a  3f10              SUBS     r7,r7,#0x10           ;2051
00004c  2f54              CMP      r7,#0x54              ;2052
00004e  d30e              BCC      |L23.110|
000050  f1040114          ADD      r1,r4,#0x14           ;2054
000054  4628              MOV      r0,r5                 ;2057
000056  eb050801          ADD      r8,r5,r1              ;2055
00005a  f7fffffe          BL       _RMP_Mem_Block
00005e  4639              MOV      r1,r7                 ;2058
000060  4640              MOV      r0,r8                 ;2058
000062  f7fffffe          BL       _RMP_Mem_Block
000066  4641              MOV      r1,r8                 ;2061
000068  4630              MOV      r0,r6                 ;2061
00006a  f7fffffe          BL       _RMP_Mem_Ins
                  |L23.110|
00006e  6872              LDR      r2,[r6,#4]            ;2065
000070  4631              MOV      r1,r6                 ;2065
000072  4628              MOV      r0,r5                 ;2065
000074  f7fffffe          BL       RMP_List_Ins
000078  f8c59008          STR      r9,[r5,#8]            ;2066
00007c  f1050010          ADD      r0,r5,#0x10           ;2069
000080  e7d3              B        |L23.42|
;;;2071   /* End Function:RMP_Malloc ***************************************************/
                          ENDP


                          AREA ||i.RMP_Matrix||, CODE, READONLY, ALIGN=2

                  RMP_Matrix PROC
;;;2534   ******************************************************************************/
;;;2535   void RMP_Matrix(cnt_t Coord_X, cnt_t Coord_Y, const u8* Matrix,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;2536                   cnt_t Bit_Order, cnt_t Length, cnt_t Width, ptr_t Color)
;;;2537   {
000004  ea5f0902          MOVS     r9,r2
000008  4682              MOV      r10,r0
00000a  e9dd020a          LDRD     r0,r2,[sp,#0x28]
00000e  d029              BEQ      |L24.100|
;;;2538       cnt_t Len_Cnt;
;;;2539       cnt_t Wid_Cnt;
;;;2540       cnt_t Mat_Pos;
;;;2541       
;;;2542       if((Matrix==0)||((Length&0x07)!=0)||(Length==0)||(Width==0))
000010  0744              LSLS     r4,r0,#29
000012  d127              BNE      |L24.100|
000014  2800              CMP      r0,#0
000016  d025              BEQ      |L24.100|
000018  2a00              CMP      r2,#0
00001a  d023              BEQ      |L24.100|
;;;2543           return;
;;;2544       
;;;2545       Mat_Pos=0;
;;;2546       /* Natural order */
;;;2547       if(Bit_Order==RMP_MAT_BIG)
;;;2548       {
;;;2549           for(Wid_Cnt=Coord_Y;Wid_Cnt<Width+Coord_Y;Wid_Cnt++)
00001c  1857              ADDS     r7,r2,r1
00001e  f04f0b01          MOV      r11,#1                ;2537
000022  2b01              CMP      r3,#1                 ;2547
;;;2550           {
;;;2551               for(Len_Cnt=Coord_X;Len_Cnt<Length+Coord_X;Len_Cnt++)
;;;2552               {
;;;2553                   if(RMP_MAT_BPOS(Matrix,Mat_Pos)!=0)
;;;2554                       RMP_Point(Len_Cnt,Wid_Cnt,Color);
;;;2555                   Mat_Pos++;
;;;2556               }
;;;2557           }
;;;2558       }
;;;2559       /* Small order */
;;;2560       else
;;;2561       {
;;;2562           for(Wid_Cnt=Coord_Y;Wid_Cnt<Width+Coord_Y;Wid_Cnt++)
000024  4688              MOV      r8,r1
000026  eb00060a          ADD      r6,r0,r10             ;2551
00002a  d019              BEQ      |L24.96|
00002c  e032              B        |L24.148|
                  |L24.46|
00002e  4655              MOV      r5,r10                ;2551
000030  e012              B        |L24.88|
000032  bf00              NOP                            ;2553
                  |L24.52|
000034  eb0901e4          ADD      r1,r9,r4,ASR #3       ;2553
000038  f0040207          AND      r2,r4,#7              ;2553
00003c  f1c20207          RSB      r2,r2,#7              ;2553
000040  7809              LDRB     r1,[r1,#0]            ;2553
000042  fa0bf002          LSL      r0,r11,r2             ;2553
000046  4201              TST      r1,r0                 ;2553
000048  d004              BEQ      |L24.84|
00004a  9a0c              LDR      r2,[sp,#0x30]         ;2554
00004c  4641              MOV      r1,r8                 ;2554
00004e  4628              MOV      r0,r5                 ;2554
000050  f7fffffe          BL       RMP_Point
                  |L24.84|
000054  1c64              ADDS     r4,r4,#1              ;2554
000056  1c6d              ADDS     r5,r5,#1              ;2554
                  |L24.88|
000058  42ae              CMP      r6,r5                 ;2551
00005a  dceb              BGT      |L24.52|
00005c  f1080801          ADD      r8,r8,#1              ;2549
                  |L24.96|
000060  4547              CMP      r7,r8                 ;2549
000062  dce4              BGT      |L24.46|
                  |L24.100|
;;;2563           {
;;;2564               for(Len_Cnt=Coord_X;Len_Cnt<Length+Coord_X;Len_Cnt++)
;;;2565               {
;;;2566                   if(RMP_MAT_SPOS(Matrix,Mat_Pos)!=0)
;;;2567                       RMP_Point(Len_Cnt,Wid_Cnt,Color);
;;;2568                   Mat_Pos++;
;;;2569               }
;;;2570           }
;;;2571       }
;;;2572   }
000064  e8bd9ff0          POP      {r4-r12,pc}
                  |L24.104|
000068  4655              MOV      r5,r10                ;2564
00006a  e00f              B        |L24.140|
                  |L24.108|
00006c  eb0900e4          ADD      r0,r9,r4,ASR #3       ;2566
000070  f0040207          AND      r2,r4,#7              ;2566
000074  7801              LDRB     r1,[r0,#0]            ;2566
000076  fa0bf002          LSL      r0,r11,r2             ;2566
00007a  4201              TST      r1,r0                 ;2566
00007c  d004              BEQ      |L24.136|
00007e  9a0c              LDR      r2,[sp,#0x30]         ;2567
000080  4641              MOV      r1,r8                 ;2567
000082  4628              MOV      r0,r5                 ;2567
000084  f7fffffe          BL       RMP_Point
                  |L24.136|
000088  1c64              ADDS     r4,r4,#1              ;2567
00008a  1c6d              ADDS     r5,r5,#1              ;2567
                  |L24.140|
00008c  42ae              CMP      r6,r5                 ;2564
00008e  dced              BGT      |L24.108|
000090  f1080801          ADD      r8,r8,#1              ;2562
                  |L24.148|
000094  4547              CMP      r7,r8                 ;2562
000096  dce7              BGT      |L24.104|
000098  e7e4              B        |L24.100|
;;;2573   /* End Function:RMP_Matrix ***************************************************/
                          ENDP


                          AREA ||i.RMP_Matrix_AA||, CODE, READONLY, ALIGN=2

                  RMP_Matrix_AA PROC
;;;2592   #ifdef RMP_COLOR_75P
;;;2593   void RMP_Matrix_AA(cnt_t Coord_X, cnt_t Coord_Y, const u8* Matrix,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;2594                      cnt_t Bit_Order, cnt_t Length, cnt_t Width, ptr_t Color, ptr_t Back)
;;;2595   {
000004  b085              SUB      sp,sp,#0x14
000006  4682              MOV      r10,r0
000008  ea5f0802          MOVS     r8,r2
00000c  468b              MOV      r11,r1
00000e  e9dd520e          LDRD     r5,r2,[sp,#0x38]
000012  9811              LDR      r0,[sp,#0x44]
000014  d07e              BEQ      |L25.276|
;;;2596       cnt_t Len_Cnt;
;;;2597       cnt_t Wid_Cnt;
;;;2598       cnt_t Mat_Pos;
;;;2599       cnt_t Anti_Alias;
;;;2600       ptr_t Color_25;
;;;2601       ptr_t Color_50;
;;;2602       ptr_t Color_75;
;;;2603       ptr_t Total;
;;;2604       
;;;2605       if((Matrix==0)||((Length&0x07)!=0)||(Length==0)||(Width==0))
000016  0769              LSLS     r1,r5,#29
000018  d17c              BNE      |L25.276|
00001a  2d00              CMP      r5,#0
00001c  d07a              BEQ      |L25.276|
00001e  2a00              CMP      r2,#0
000020  d078              BEQ      |L25.276|
;;;2606           return;
;;;2607       
;;;2608       Mat_Pos=0;
;;;2609       Total=Length*Width;
;;;2610       Color_25=RMP_COLOR_25P(Color,Back);
;;;2611       Color_50=RMP_COLOR_50P(Color,Back);
000022  9910              LDR      r1,[sp,#0x40]
;;;2612       Color_75=RMP_COLOR_75P(Color,Back);
;;;2613       
;;;2614       /* Natural order */
;;;2615       if(Bit_Order==RMP_MAT_BIG)
;;;2616       {
;;;2617           for(Wid_Cnt=Coord_Y;Wid_Cnt<Width+Coord_Y;Wid_Cnt++)
000024  eb02090b          ADD      r9,r2,r11
000028  436a              MULS     r2,r5,r2              ;2609
00002a  0acc              LSRS     r4,r1,#11             ;2611
00002c  9200              STR      r2,[sp,#0]            ;2615
00002e  0ac6              LSRS     r6,r0,#11             ;2610
000030  9a10              LDR      r2,[sp,#0x40]         ;2610
000032  2b01              CMP      r3,#1                 ;2615
000034  9b10              LDR      r3,[sp,#0x40]         ;2610
000036  eb060646          ADD      r6,r6,r6,LSL #1       ;2610
00003a  f3c01145          UBFX     r1,r0,#5,#6           ;2610
00003e  eb0623d3          ADD      r3,r6,r3,LSR #11      ;2610
000042  eb010641          ADD      r6,r1,r1,LSL #1       ;2610
000046  f3c21245          UBFX     r2,r2,#5,#6           ;2610
00004a  4416              ADD      r6,r6,r2              ;2610
00004c  ea4f0393          LSR      r3,r3,#2              ;2610
000050  ea4f0696          LSR      r6,r6,#2              ;2610
000054  ea4f23c3          LSL      r3,r3,#11             ;2610
000058  ea431346          ORR      r3,r3,r6,LSL #5       ;2610
00005c  eb040744          ADD      r7,r4,r4,LSL #1       ;2612
000060  eb0426d0          ADD      r6,r4,r0,LSR #11      ;2611
000064  eb0727d0          ADD      r7,r7,r0,LSR #11      ;2612
000068  eb020442          ADD      r4,r2,r2,LSL #1       ;2612
00006c  ea4f0c56          LSR      r12,r6,#1             ;2611
000070  440a              ADD      r2,r2,r1              ;2611
000072  ea4f0697          LSR      r6,r7,#2              ;2612
000076  440c              ADD      r4,r4,r1              ;2612
000078  9910              LDR      r1,[sp,#0x40]         ;2610
00007a  ea4f27cc          LSL      r7,r12,#11            ;2611
00007e  ea4f0252          LSR      r2,r2,#1              ;2611
000082  f001011f          AND      r1,r1,#0x1f           ;2610
000086  f000001f          AND      r0,r0,#0x1f           ;2610
00008a  ea471242          ORR      r2,r7,r2,LSL #5       ;2611
00008e  eb000740          ADD      r7,r0,r0,LSL #1       ;2610
000092  440f              ADD      r7,r7,r1              ;2610
000094  ea4f0c94          LSR      r12,r4,#2             ;2612
000098  eb010441          ADD      r4,r1,r1,LSL #1       ;2612
00009c  4401              ADD      r1,r1,r0              ;2611
00009e  ea4f26c6          LSL      r6,r6,#11             ;2612
0000a2  ea430397          ORR      r3,r3,r7,LSR #2       ;2610
0000a6  9304              STR      r3,[sp,#0x10]         ;2612
0000a8  4404              ADD      r4,r4,r0              ;2612
0000aa  ea46134c          ORR      r3,r6,r12,LSL #5      ;2612
0000ae  ea420151          ORR      r1,r2,r1,LSR #1       ;2611
0000b2  9103              STR      r1,[sp,#0xc]          ;2612
0000b4  ea430194          ORR      r1,r3,r4,LSR #2       ;2612
0000b8  f04f0400          MOV      r4,#0                 ;2608
;;;2618           {
;;;2619               for(Len_Cnt=Coord_X;Len_Cnt<Length+Coord_X;Len_Cnt++)
;;;2620               {
;;;2621                   if(RMP_MAT_BPOS(Matrix,Mat_Pos)!=0)
;;;2622                       RMP_Point(Len_Cnt,Wid_Cnt,Color);
;;;2623                   else
;;;2624                   {
;;;2625                       /* Anti-aliasing */
;;;2626                       Anti_Alias=0;
;;;2627                       
;;;2628                       if(Mat_Pos-1>=0)
;;;2629                       {
;;;2630                           if((Len_Cnt!=Coord_X)&&(RMP_MAT_BPOS(Matrix,Mat_Pos-1)!=0))
;;;2631                               Anti_Alias++;
;;;2632                           if((Mat_Pos-Length>=0)&&(RMP_MAT_BPOS(Matrix,Mat_Pos-Length)!=0))
;;;2633                               Anti_Alias++;
;;;2634                       }
;;;2635                       
;;;2636                       if(Mat_Pos+1<Total)
;;;2637                       {
;;;2638                           if((Len_Cnt!=Coord_X+Length-1)&&(RMP_MAT_BPOS(Matrix,Mat_Pos+1)!=0))
0000bc  eb0a0005          ADD      r0,r10,r5
0000c0  f1a00001          SUB      r0,r0,#1              ;2608
0000c4  e9cd0101          STRD     r0,r1,[sp,#4]         ;2608
0000c8  eb05070a          ADD      r7,r5,r10             ;2619
0000cc  d06c              BEQ      |L25.424|
0000ce  e0d1              B        |L25.628|
                  |L25.208|
0000d0  4656              MOV      r6,r10                ;2619
0000d2  e065              B        |L25.416|
                  |L25.212|
0000d4  eb0800e4          ADD      r0,r8,r4,ASR #3       ;2621
0000d8  f04f0c01          MOV      r12,#1                ;2621
0000dc  f0040207          AND      r2,r4,#7              ;2621
0000e0  f1c20207          RSB      r2,r2,#7              ;2621
0000e4  7801              LDRB     r1,[r0,#0]            ;2621
0000e6  fa0cf002          LSL      r0,r12,r2             ;2621
0000ea  4201              TST      r1,r0                 ;2621
0000ec  d001              BEQ      |L25.242|
0000ee  9a10              LDR      r2,[sp,#0x40]         ;2622
0000f0  e050              B        |L25.404|
                  |L25.242|
0000f2  2000              MOVS     r0,#0                 ;2626
0000f4  2c01              CMP      r4,#1                 ;2628
0000f6  d41e              BMI      |L25.310|
0000f8  4556              CMP      r6,r10                ;2630
0000fa  d00e              BEQ      |L25.282|
0000fc  1e61              SUBS     r1,r4,#1              ;2630
0000fe  f0010307          AND      r3,r1,#7              ;2630
000102  eb0802e1          ADD      r2,r8,r1,ASR #3       ;2630
000106  f1c30307          RSB      r3,r3,#7              ;2630
00010a  7812              LDRB     r2,[r2,#0]            ;2630
00010c  fa0cf103          LSL      r1,r12,r3             ;2630
000110  420a              TST      r2,r1                 ;2630
000112  e000              B        |L25.278|
                  |L25.276|
000114  e04a              B        |L25.428|
                  |L25.278|
000116  d000              BEQ      |L25.282|
000118  2001              MOVS     r0,#1                 ;2631
                  |L25.282|
00011a  1b61              SUBS     r1,r4,r5              ;2632
00011c  d40b              BMI      |L25.310|
00011e  eb0802e1          ADD      r2,r8,r1,ASR #3       ;2632
000122  f0010307          AND      r3,r1,#7              ;2632
000126  f1c30307          RSB      r3,r3,#7              ;2632
00012a  7812              LDRB     r2,[r2,#0]            ;2632
00012c  fa0cf103          LSL      r1,r12,r3             ;2632
000130  420a              TST      r2,r1                 ;2632
000132  d000              BEQ      |L25.310|
000134  1c40              ADDS     r0,r0,#1              ;2632
                  |L25.310|
000136  9a00              LDR      r2,[sp,#0]            ;2636
000138  1c61              ADDS     r1,r4,#1              ;2636
00013a  4291              CMP      r1,r2                 ;2636
00013c  d21e              BCS      |L25.380|
00013e  9a01              LDR      r2,[sp,#4]
000140  42b2              CMP      r2,r6
000142  d00b              BEQ      |L25.348|
000144  eb0802e1          ADD      r2,r8,r1,ASR #3
000148  f0010307          AND      r3,r1,#7
00014c  f1c30307          RSB      r3,r3,#7
000150  7812              LDRB     r2,[r2,#0]
000152  fa0cf103          LSL      r1,r12,r3
000156  420a              TST      r2,r1
000158  d000              BEQ      |L25.348|
00015a  1c40              ADDS     r0,r0,#1
                  |L25.348|
;;;2639                               Anti_Alias++;
;;;2640                           if((Mat_Pos+Length<Total)&&(RMP_MAT_BPOS(Matrix,Mat_Pos+Length)!=0))
00015c  9a00              LDR      r2,[sp,#0]
00015e  1961              ADDS     r1,r4,r5
000160  4291              CMP      r1,r2
000162  d20b              BCS      |L25.380|
000164  eb0802e1          ADD      r2,r8,r1,ASR #3
000168  f0010307          AND      r3,r1,#7
00016c  f1c30307          RSB      r3,r3,#7
000170  7812              LDRB     r2,[r2,#0]
000172  fa0cf103          LSL      r1,r12,r3
000176  420a              TST      r2,r1
000178  d000              BEQ      |L25.380|
00017a  1c40              ADDS     r0,r0,#1
                  |L25.380|
;;;2641                               Anti_Alias++;
;;;2642                       }
;;;2643                       
;;;2644                       switch(Anti_Alias)
00017c  2801              CMP      r0,#1
00017e  d004              BEQ      |L25.394|
000180  2802              CMP      r0,#2
000182  d004              BEQ      |L25.398|
000184  2803              CMP      r0,#3
000186  d109              BNE      |L25.412|
000188  e003              B        |L25.402|
                  |L25.394|
;;;2645                       {
;;;2646                           case 1:RMP_Point(Len_Cnt,Wid_Cnt,Color_25);break;
00018a  9a04              LDR      r2,[sp,#0x10]
00018c  e002              B        |L25.404|
                  |L25.398|
;;;2647                           case 2:RMP_Point(Len_Cnt,Wid_Cnt,Color_50);break;
00018e  9a03              LDR      r2,[sp,#0xc]
000190  e000              B        |L25.404|
                  |L25.402|
;;;2648                           case 3:RMP_Point(Len_Cnt,Wid_Cnt,Color_75);break;
000192  9a02              LDR      r2,[sp,#8]
                  |L25.404|
000194  4659              MOV      r1,r11
000196  4630              MOV      r0,r6
000198  f7fffffe          BL       RMP_Point
                  |L25.412|
00019c  1c64              ADDS     r4,r4,#1
00019e  1c76              ADDS     r6,r6,#1
                  |L25.416|
0001a0  42b7              CMP      r7,r6                 ;2619
0001a2  dc97              BGT      |L25.212|
0001a4  f10b0b01          ADD      r11,r11,#1            ;2617
                  |L25.424|
0001a8  45d9              CMP      r9,r11                ;2617
0001aa  dc91              BGT      |L25.208|
                  |L25.428|
;;;2649                           default:break;
;;;2650                       }
;;;2651                   }
;;;2652                   
;;;2653                   Mat_Pos++;
;;;2654               }
;;;2655           }
;;;2656       }
;;;2657       /* Small order */
;;;2658       else
;;;2659       {
;;;2660           for(Wid_Cnt=Coord_Y;Wid_Cnt<Width+Coord_Y;Wid_Cnt++)
;;;2661           {
;;;2662               for(Len_Cnt=Coord_X;Len_Cnt<Length+Coord_X;Len_Cnt++)
;;;2663               {
;;;2664                   if(RMP_MAT_SPOS(Matrix,Mat_Pos)!=0)
;;;2665                       RMP_Point(Len_Cnt,Wid_Cnt,Color);
;;;2666                   else
;;;2667                   {
;;;2668                       /* Anti-aliasing */
;;;2669                       Anti_Alias=0;
;;;2670                       
;;;2671                       if(Mat_Pos-1>=0)
;;;2672                       {
;;;2673                           if((Len_Cnt!=Coord_X)&&(RMP_MAT_SPOS(Matrix,Mat_Pos-1)!=0))
;;;2674                               Anti_Alias++;
;;;2675                           if((Mat_Pos-Length>=0)&&(RMP_MAT_SPOS(Matrix,Mat_Pos-Length)!=0))
;;;2676                               Anti_Alias++;
;;;2677                       }
;;;2678                       
;;;2679                       if(Mat_Pos+1<Total)
;;;2680                       {
;;;2681                           if((Len_Cnt!=Coord_X+Length-1)&&(RMP_MAT_SPOS(Matrix,Mat_Pos+1)!=0))
;;;2682                               Anti_Alias++;
;;;2683                           if((Mat_Pos+Length<Total)&&(RMP_MAT_SPOS(Matrix,Mat_Pos+Length)!=0))
;;;2684                               Anti_Alias++;
;;;2685                       }
;;;2686                       
;;;2687                       switch(Anti_Alias)
;;;2688                       {
;;;2689                           case 1:RMP_Point(Len_Cnt,Wid_Cnt,Color_25);break;
;;;2690                           case 2:RMP_Point(Len_Cnt,Wid_Cnt,Color_50);break;
;;;2691                           case 3:RMP_Point(Len_Cnt,Wid_Cnt,Color_75);break;
;;;2692                           default:break;
;;;2693                       }
;;;2694                   }
;;;2695                   
;;;2696                   Mat_Pos++;
;;;2697               }
;;;2698           }
;;;2699       }
;;;2700   }
0001ac  b005              ADD      sp,sp,#0x14
0001ae  e8bd8ff0          POP      {r4-r11,pc}
                  |L25.434|
0001b2  4656              MOV      r6,r10                ;2662
0001b4  e05a              B        |L25.620|
0001b6  bf00              NOP                            ;2664
                  |L25.440|
0001b8  eb0800e4          ADD      r0,r8,r4,ASR #3       ;2664
0001bc  f04f0e01          MOV      lr,#1                 ;2664
0001c0  f0040207          AND      r2,r4,#7              ;2664
0001c4  7801              LDRB     r1,[r0,#0]            ;2664
0001c6  fa0ef002          LSL      r0,lr,r2              ;2664
0001ca  4201              TST      r1,r0                 ;2664
0001cc  d001              BEQ      |L25.466|
0001ce  9a10              LDR      r2,[sp,#0x40]         ;2665
0001d0  e046              B        |L25.608|
                  |L25.466|
0001d2  2000              MOVS     r0,#0                 ;2669
0001d4  2c01              CMP      r4,#1                 ;2671
0001d6  d418              BMI      |L25.522|
0001d8  4556              CMP      r6,r10                ;2673
0001da  d00a              BEQ      |L25.498|
0001dc  1e61              SUBS     r1,r4,#1              ;2673
0001de  f0010c07          AND      r12,r1,#7             ;2673
0001e2  eb0803e1          ADD      r3,r8,r1,ASR #3       ;2673
0001e6  fa0ef20c          LSL      r2,lr,r12             ;2673
0001ea  7819              LDRB     r1,[r3,#0]            ;2673
0001ec  4211              TST      r1,r2                 ;2673
0001ee  d000              BEQ      |L25.498|
0001f0  2001              MOVS     r0,#1                 ;2674
                  |L25.498|
0001f2  1b61              SUBS     r1,r4,r5              ;2675
0001f4  d409              BMI      |L25.522|
0001f6  eb0802e1          ADD      r2,r8,r1,ASR #3       ;2675
0001fa  f0010307          AND      r3,r1,#7              ;2675
0001fe  7812              LDRB     r2,[r2,#0]            ;2675
000200  fa0ef103          LSL      r1,lr,r3              ;2675
000204  420a              TST      r2,r1                 ;2675
000206  d000              BEQ      |L25.522|
000208  1c40              ADDS     r0,r0,#1              ;2675
                  |L25.522|
00020a  9a00              LDR      r2,[sp,#0]            ;2679
00020c  1c61              ADDS     r1,r4,#1              ;2679
00020e  4291              CMP      r1,r2                 ;2679
000210  d21a              BCS      |L25.584|
000212  9a01              LDR      r2,[sp,#4]            ;2681
000214  42b2              CMP      r2,r6                 ;2681
000216  d009              BEQ      |L25.556|
000218  eb0802e1          ADD      r2,r8,r1,ASR #3       ;2681
00021c  f0010307          AND      r3,r1,#7              ;2681
000220  7812              LDRB     r2,[r2,#0]            ;2681
000222  fa0ef103          LSL      r1,lr,r3              ;2681
000226  420a              TST      r2,r1                 ;2681
000228  d000              BEQ      |L25.556|
00022a  1c40              ADDS     r0,r0,#1              ;2681
                  |L25.556|
00022c  9a00              LDR      r2,[sp,#0]            ;2683
00022e  1961              ADDS     r1,r4,r5              ;2683
000230  4291              CMP      r1,r2                 ;2683
000232  d209              BCS      |L25.584|
000234  eb0802e1          ADD      r2,r8,r1,ASR #3       ;2683
000238  f0010307          AND      r3,r1,#7              ;2683
00023c  7812              LDRB     r2,[r2,#0]            ;2683
00023e  fa0ef103          LSL      r1,lr,r3              ;2683
000242  420a              TST      r2,r1                 ;2683
000244  d000              BEQ      |L25.584|
000246  1c40              ADDS     r0,r0,#1              ;2683
                  |L25.584|
000248  2801              CMP      r0,#1                 ;2687
00024a  d004              BEQ      |L25.598|
00024c  2802              CMP      r0,#2                 ;2687
00024e  d004              BEQ      |L25.602|
000250  2803              CMP      r0,#3                 ;2687
000252  d109              BNE      |L25.616|
000254  e003              B        |L25.606|
                  |L25.598|
000256  9a04              LDR      r2,[sp,#0x10]         ;2689
000258  e002              B        |L25.608|
                  |L25.602|
00025a  9a03              LDR      r2,[sp,#0xc]          ;2690
00025c  e000              B        |L25.608|
                  |L25.606|
00025e  9a02              LDR      r2,[sp,#8]            ;2691
                  |L25.608|
000260  4659              MOV      r1,r11                ;2691
000262  4630              MOV      r0,r6                 ;2691
000264  f7fffffe          BL       RMP_Point
                  |L25.616|
000268  1c64              ADDS     r4,r4,#1              ;2691
00026a  1c76              ADDS     r6,r6,#1              ;2691
                  |L25.620|
00026c  42b7              CMP      r7,r6                 ;2662
00026e  dca3              BGT      |L25.440|
000270  f10b0b01          ADD      r11,r11,#1            ;2660
                  |L25.628|
000274  45d9              CMP      r9,r11                ;2660
000276  dc9c              BGT      |L25.434|
000278  e798              B        |L25.428|
;;;2701   #endif
                          ENDP


                          AREA ||i.RMP_Mem_Init||, CODE, READONLY, ALIGN=2

                  RMP_Mem_Init PROC
;;;1779   ******************************************************************************/
;;;1780   ret_t RMP_Mem_Init(volatile void* Pool, ptr_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;1781   {
000002  0004              MOVS     r4,r0
000004  460d              MOV      r5,r1
;;;1782       cnt_t FLI_Cnt;
;;;1783       ptr_t Usable_Size;
;;;1784       volatile struct RMP_Mem* Mem;
;;;1785       volatile struct RMP_Mem_Head* Mem_Head;
;;;1786       
;;;1787       /* See if the memory pool is large enough to enable dynamic allocation - at least 4096 words */
;;;1788       if((Pool==0)||(Size<(4096*sizeof(ptr_t)))||((Size>>27)>0))
;;;1789           return RMP_ERR_MEM;
000006  f06f0006          MVN      r0,#6
00000a  d04a              BEQ      |L26.162|
00000c  f5b54f80          CMP      r5,#0x4000            ;1788
000010  d347              BCC      |L26.162|
000012  0ee9              LSRS     r1,r5,#27             ;1788
000014  d145              BNE      |L26.162|
;;;1790       
;;;1791       /* See if the address and size is word-aligned */
;;;1792       if((((ptr_t)Pool&(RMP_WORD_MASK>>2))!=0)||((Size&(RMP_WORD_MASK>>2))!=0))
000016  ea440105          ORR      r1,r4,r5
00001a  0789              LSLS     r1,r1,#30
00001c  d141              BNE      |L26.162|
;;;1793           return RMP_ERR_MEM;
;;;1794           
;;;1795       Mem=(volatile struct RMP_Mem*)Pool;
;;;1796       Mem->Size=Size;
00001e  6125              STR      r5,[r4,#0x10]
000020  6024              STR      r4,[r4,#0]
000022  6064              STR      r4,[r4,#4]
;;;1797       /* Initialize the allocated block list */
;;;1798       RMP_List_Crt(&(Mem->Alloc));
;;;1799       /* Calculate the FLI value needed for this - we always align to 64 byte */
;;;1800       Mem->FLI_Num=RMP_MSB_Get(Size-sizeof(struct RMP_Mem))-6+1;
000024  f5a5700a          SUB      r0,r5,#0x228
000028  f7fffffe          BL       RMP_MSB_Get
;;;1801       /* Initialize the TLSF allocation table first */
;;;1802       for(FLI_Cnt=0;FLI_Cnt<(cnt_t)(Mem->FLI_Num);FLI_Cnt++)
00002c  2100              MOVS     r1,#0
00002e  1f40              SUBS     r0,r0,#5
000030  60a0              STR      r0,[r4,#8]            ;1800
000032  e01b              B        |L26.108|
                  |L26.52|
;;;1803       {
;;;1804           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,0)]));
000034  eb041081          ADD      r0,r4,r1,LSL #6
000038  f1000228          ADD      r2,r0,#0x28
00003c  6282              STR      r2,[r0,#0x28]
00003e  62c2              STR      r2,[r0,#0x2c]
;;;1805           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,1)]));
000040  3208              ADDS     r2,r2,#8
000042  6302              STR      r2,[r0,#0x30]
000044  6342              STR      r2,[r0,#0x34]
;;;1806           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,2)]));
000046  3208              ADDS     r2,r2,#8
000048  6382              STR      r2,[r0,#0x38]
00004a  63c2              STR      r2,[r0,#0x3c]
;;;1807           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,3)]));
00004c  3208              ADDS     r2,r2,#8
00004e  6402              STR      r2,[r0,#0x40]
000050  6442              STR      r2,[r0,#0x44]
;;;1808           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,4)]));
000052  3208              ADDS     r2,r2,#8
000054  6482              STR      r2,[r0,#0x48]
000056  64c2              STR      r2,[r0,#0x4c]
;;;1809           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,5)]));
000058  3208              ADDS     r2,r2,#8
00005a  6502              STR      r2,[r0,#0x50]
00005c  6542              STR      r2,[r0,#0x54]
;;;1810           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,6)]));
00005e  3208              ADDS     r2,r2,#8
000060  6582              STR      r2,[r0,#0x58]
000062  65c2              STR      r2,[r0,#0x5c]
000064  3060              ADDS     r0,r0,#0x60
000066  6000              STR      r0,[r0,#0]
000068  6040              STR      r0,[r0,#4]
00006a  1c49              ADDS     r1,r1,#1
                  |L26.108|
00006c  68a0              LDR      r0,[r4,#8]            ;1802
00006e  4288              CMP      r0,r1                 ;1802
000070  dce0              BGT      |L26.52|
;;;1811           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,7)]));
;;;1812       }
;;;1813       for(FLI_Cnt=0;FLI_Cnt<5;FLI_Cnt++)
000072  2000              MOVS     r0,#0
000074  ea4f0100          MOV.W    r1,r0
                  |L26.120|
;;;1814           Mem->Bitmap[FLI_Cnt]=0;
000078  eb040280          ADD      r2,r4,r0,LSL #2
00007c  6151              STR      r1,[r2,#0x14]
00007e  1c40              ADDS     r0,r0,#1
000080  2805              CMP      r0,#5                 ;1813
000082  dbf9              BLT      |L26.120|
;;;1815       
;;;1816       /* Get the big memory block's size and position */
;;;1817       Usable_Size=sizeof(struct RMP_Mem)+(sizeof(struct RMP_List)<<3)*(Mem->FLI_Num-8);
000084  68a0              LDR      r0,[r4,#8]
000086  2128              MOVS     r1,#0x28
000088  eb011080          ADD      r0,r1,r0,LSL #6
;;;1818       Mem_Head=(struct RMP_Mem_Head*)(((ptr_t)Pool)+Usable_Size);
00008c  1826              ADDS     r6,r4,r0
;;;1819       Mem->Start=(ptr_t)Mem_Head;
00008e  60e6              STR      r6,[r4,#0xc]
;;;1820       Usable_Size=Size-Usable_Size;
000090  1a29              SUBS     r1,r5,r0
;;;1821       
;;;1822       /* Initialize the big block */
;;;1823       _RMP_Mem_Block(Mem_Head,Usable_Size);
000092  4630              MOV      r0,r6
000094  f7fffffe          BL       _RMP_Mem_Block
;;;1824       
;;;1825       /* Insert the memory into the corresponding level */
;;;1826       _RMP_Mem_Ins(Pool, Mem_Head);
000098  4631              MOV      r1,r6
00009a  4620              MOV      r0,r4
00009c  f7fffffe          BL       _RMP_Mem_Ins
;;;1827       return 0;
0000a0  2000              MOVS     r0,#0
                  |L26.162|
;;;1828   }
0000a2  bd70              POP      {r4-r6,pc}
;;;1829   /* End Function:RMP_Mem_Init *************************************************/
                          ENDP


                          AREA ||i.RMP_Print_Int||, CODE, READONLY, ALIGN=2

                  RMP_Print_Int PROC
;;;69     ******************************************************************************/
;;;70     cnt_t RMP_Print_Int(cnt_t Int)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;71     {
;;;72         ptr_t Iter;
;;;73         cnt_t Count;
;;;74         cnt_t Num;
;;;75         ptr_t Div;
;;;76         
;;;77         /* how many digits are there? */
;;;78         if(Int==0)
000004  2800              CMP      r0,#0
;;;79         {
;;;80             RMP_Putchar('0');
;;;81             return 1;
;;;82         }
;;;83         else if(Int<0)
;;;84         {
;;;85             /* How many digits are there? */
;;;86             Count=0;
;;;87             Div=1;
;;;88             Iter=-Int;
;;;89             while(Iter!=0)
;;;90             {
;;;91                 Iter/=10;
000006  f04f010a          MOV      r1,#0xa
00000a  d008              BEQ      |L27.30|
00000c  da2e              BGE      |L27.108|
00000e  f1c00000          RSB      r0,r0,#0              ;88
000012  f04f0500          MOV      r5,#0                 ;86
000016  4606              MOV      r6,r0                 ;88
000018  f04f0201          MOV      r2,#1                 ;87
00001c  e00c              B        |L27.56|
                  |L27.30|
00001e  f04f0030          MOV      r0,#0x30              ;80
000022  f7fffffe          BL       RMP_Putchar
000026  2001              MOVS     r0,#1                 ;81
                  |L27.40|
;;;92                 Count++;
;;;93                 Div*=10;
;;;94             }
;;;95             Div/=10;
;;;96             
;;;97             RMP_Putchar('-');
;;;98             Iter=-Int;
;;;99             Num=Count+1;
;;;100            
;;;101            while(Count>0)
;;;102            {
;;;103                Count--;
;;;104                RMP_Putchar(Iter/Div+'0');
;;;105                Iter=Iter%Div;
;;;106                Div/=10;
;;;107            }
;;;108        }
;;;109        else
;;;110        {
;;;111            /* How many digits are there? */
;;;112            Count=0;
;;;113            Div=1;
;;;114            Iter=Int;
;;;115            while(Iter!=0)
;;;116            {
;;;117                Iter/=10;
;;;118                Count++;
;;;119                Div*=10;
;;;120            }
;;;121            Div/=10;
;;;122            
;;;123            Iter=Int;
;;;124            Num=Count;
;;;125            
;;;126            while(Count>0)
;;;127            {
;;;128                Count--;
;;;129                RMP_Putchar(Iter/Div+'0');
;;;130                Iter=Iter%Div;
;;;131                Div/=10;
;;;132            }
;;;133        }
;;;134        
;;;135        return Num;
;;;136    }
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L27.44|
00002c  fbb0f0f1          UDIV     r0,r0,r1              ;91
000030  eb020282          ADD      r2,r2,r2,LSL #2       ;93
000034  0052              LSLS     r2,r2,#1              ;93
000036  1c6d              ADDS     r5,r5,#1              ;93
                  |L27.56|
000038  2800              CMP      r0,#0                 ;89
00003a  d1f7              BNE      |L27.44|
00003c  4688              MOV      r8,r1                 ;95
00003e  fbb2f4f8          UDIV     r4,r2,r8              ;95
000042  202d              MOVS     r0,#0x2d              ;97
000044  f7fffffe          BL       RMP_Putchar
000048  1c6f              ADDS     r7,r5,#1              ;99
00004a  e00c              B        |L27.102|
                  |L27.76|
00004c  fbb6f0f4          UDIV     r0,r6,r4              ;104
000050  1e6d              SUBS     r5,r5,#1              ;104
000052  3030              ADDS     r0,r0,#0x30           ;104
000054  b240              SXTB     r0,r0                 ;104
000056  f7fffffe          BL       RMP_Putchar
00005a  fbb6f1f4          UDIV     r1,r6,r4              ;105
00005e  fb046611          MLS      r6,r4,r1,r6           ;105
000062  fbb4f4f8          UDIV     r4,r4,r8              ;106
                  |L27.102|
000066  2d00              CMP      r5,#0                 ;101
000068  dcf0              BGT      |L27.76|
00006a  e020              B        |L27.174|
                  |L27.108|
00006c  2400              MOVS     r4,#0                 ;112
00006e  ea4f0200          MOV.W    r2,r0                 ;114
000072  2301              MOVS     r3,#1                 ;113
                  |L27.116|
000074  fbb2f2f1          UDIV     r2,r2,r1              ;117
000078  eb030383          ADD      r3,r3,r3,LSL #2       ;119
00007c  1c64              ADDS     r4,r4,#1              ;119
00007e  005b              LSLS     r3,r3,#1              ;119
000080  2a00              CMP      r2,#0                 ;119
000082  d1f7              BNE      |L27.116|
000084  4688              MOV      r8,r1                 ;91
000086  4605              MOV      r5,r0                 ;123
000088  fbb3f6f8          UDIV     r6,r3,r8              ;121
00008c  4627              MOV      r7,r4                 ;124
00008e  e00c              B        |L27.170|
                  |L27.144|
000090  fbb5f0f6          UDIV     r0,r5,r6              ;129
000094  1e64              SUBS     r4,r4,#1              ;129
000096  3030              ADDS     r0,r0,#0x30           ;129
000098  b240              SXTB     r0,r0                 ;129
00009a  f7fffffe          BL       RMP_Putchar
00009e  fbb5f1f6          UDIV     r1,r5,r6              ;130
0000a2  fb065511          MLS      r5,r6,r1,r5           ;130
0000a6  fbb6f6f8          UDIV     r6,r6,r8              ;131
                  |L27.170|
0000aa  2c00              CMP      r4,#0                 ;126
0000ac  dcf0              BGT      |L27.144|
                  |L27.174|
0000ae  4638              MOV      r0,r7                 ;135
0000b0  e7ba              B        |L27.40|
;;;137    /* End Function:RMP_Print_Int ************************************************/
                          ENDP


                          AREA ||i.RMP_Print_String||, CODE, READONLY, ALIGN=1

                  RMP_Print_String PROC
;;;192    ******************************************************************************/
;;;193    cnt_t RMP_Print_String(s8* String)
000000  b570              PUSH     {r4-r6,lr}
;;;194    {
;;;195        cnt_t Count;
;;;196        
;;;197        Count=0;
000002  2400              MOVS     r4,#0
000004  4605              MOV      r5,r0                 ;194
                  |L28.6|
;;;198        while(Count<RMP_KERNEL_DEBUG_MAX_STR)
;;;199        {
;;;200            if(String[Count]=='\0')
000006  5728              LDRSB    r0,[r5,r4]
000008  b120              CBZ      r0,|L28.20|
00000a  1c64              ADDS     r4,r4,#1
;;;201                break;
;;;202            
;;;203            RMP_Putchar(String[Count++]);
00000c  f7fffffe          BL       RMP_Putchar
000010  2cff              CMP      r4,#0xff              ;198
000012  dbf8              BLT      |L28.6|
                  |L28.20|
;;;204        }
;;;205        
;;;206        return Count;
000014  4620              MOV      r0,r4
;;;207    }
000016  bd70              POP      {r4-r6,pc}
;;;208    /* End Function:RMP_Print_String *********************************************/
                          ENDP


                          AREA ||i.RMP_Print_Uint||, CODE, READONLY, ALIGN=1

                  RMP_Print_Uint PROC
;;;145    ******************************************************************************/
;;;146    cnt_t RMP_Print_Uint(ptr_t Uint)
000000  b570              PUSH     {r4-r6,lr}
;;;147    {
000002  0004              MOVS     r4,r0
000004  d001              BEQ      |L29.10|
;;;148        ptr_t Iter;
;;;149        cnt_t Count;
;;;150        cnt_t Num;
;;;151        
;;;152        /* how many digits are there? */
;;;153        if(Uint==0)
;;;154        {
;;;155            RMP_Putchar('0');
;;;156            return 1;
;;;157        }
;;;158        else
;;;159        {
;;;160            /* Filter out all the zeroes */
;;;161            Count=0;
000006  2100              MOVS     r1,#0
;;;162            Iter=Uint;
;;;163            while((Iter>>((sizeof(ptr_t)*8)-4))==0)
000008  e006              B        |L29.24|
                  |L29.10|
00000a  2030              MOVS     r0,#0x30              ;155
00000c  f7fffffe          BL       RMP_Putchar
000010  2001              MOVS     r0,#1                 ;156
;;;164            {
;;;165                Iter<<=4;
;;;166                Count++;
;;;167            }
;;;168            /* Count is the number of pts to print */
;;;169            Count=sizeof(ptr_t)*2-Count;
;;;170            Num=Count;
;;;171            while(Count>0)
;;;172            {
;;;173                Count--;
;;;174                Iter=(Uint>>(Count*4))&0x0F;
;;;175                if(Iter<10)
;;;176                    RMP_Putchar('0'+Iter);
;;;177                else
;;;178                    RMP_Putchar('A'+Iter-10);
;;;179            }
;;;180        }
;;;181        
;;;182        return Num;
;;;183    }
000012  bd70              POP      {r4-r6,pc}
                  |L29.20|
000014  0100              LSLS     r0,r0,#4              ;165
000016  1c49              ADDS     r1,r1,#1              ;165
                  |L29.24|
000018  0f02              LSRS     r2,r0,#28             ;163
00001a  d0fb              BEQ      |L29.20|
00001c  f1c10508          RSB      r5,r1,#8              ;169
000020  462e              MOV      r6,r5                 ;170
000022  e00e              B        |L29.66|
                  |L29.36|
000024  4628              MOV      r0,r5                 ;173
000026  1e6d              SUBS     r5,r5,#1              ;173
000028  0081              LSLS     r1,r0,#2              ;173
00002a  1f09              SUBS     r1,r1,#4              ;173
00002c  fa24f001          LSR      r0,r4,r1              ;174
000030  f000000f          AND      r0,r0,#0xf            ;174
000034  280a              CMP      r0,#0xa               ;175
000036  d201              BCS      |L29.60|
000038  3030              ADDS     r0,r0,#0x30           ;175
00003a  e000              B        |L29.62|
                  |L29.60|
00003c  3037              ADDS     r0,r0,#0x37           ;176
                  |L29.62|
00003e  f7fffffe          BL       RMP_Putchar
                  |L29.66|
000042  2d00              CMP      r5,#0                 ;171
000044  dcee              BGT      |L29.36|
000046  4630              MOV      r0,r6                 ;182
000048  bd70              POP      {r4-r6,pc}
;;;184    /* End Function:RMP_Print_Uint ***********************************************/
                          ENDP


                          AREA ||i.RMP_Progbar||, CODE, READONLY, ALIGN=1

                  RMP_Progbar PROC
;;;3388   ******************************************************************************/
;;;3389   void RMP_Progbar(cnt_t Coord_X, cnt_t Coord_Y, cnt_t Length, cnt_t Width,
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;3390                    cnt_t Style, cnt_t Prog, ptr_t Fore, ptr_t Back)
;;;3391   {
000004  ad0a              ADD      r5,sp,#0x28
000006  461f              MOV      r7,r3
000008  4614              MOV      r4,r2
00000a  4688              MOV      r8,r1
00000c  4606              MOV      r6,r0
00000e  e895000f          LDM      r5,{r0-r3}
000012  e88d000f          STM      sp,{r0-r3}
;;;3392       /* Draw the progress bar according to the style of the progress bar */
;;;3393       RMP_Progbar_Prog(Coord_X,Coord_Y,Length,Width,Style,Prog,Fore,Back);
000016  463b              MOV      r3,r7
000018  4622              MOV      r2,r4
00001a  4641              MOV      r1,r8
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       RMP_Progbar_Prog
;;;3394       /* Now draw the border */
;;;3395       RMP_Line(Coord_X,Coord_Y,Coord_X+Length-1,Coord_Y,RMP_CTL_BLACK);
000022  4434              ADD      r4,r4,r6
000024  4643              MOV      r3,r8
000026  2500              MOVS     r5,#0
000028  4619              MOV      r1,r3
00002a  1e62              SUBS     r2,r4,#1
00002c  4630              MOV      r0,r6
00002e  9500              STR      r5,[sp,#0]
000030  f7fffffe          BL       RMP_Line
;;;3396       RMP_Line(Coord_X+Length-1,Coord_Y,Coord_X+Length-1,Coord_Y+Width-1,RMP_CTL_BLACK);
000034  1e62              SUBS     r2,r4,#1
000036  4641              MOV      r1,r8
000038  4447              ADD      r7,r7,r8
00003a  4610              MOV      r0,r2
00003c  1e7b              SUBS     r3,r7,#1
00003e  9500              STR      r5,[sp,#0]
000040  f7fffffe          BL       RMP_Line
;;;3397       RMP_Line(Coord_X+Length-1,Coord_Y+Width-1,Coord_X,Coord_Y+Width-1,RMP_CTL_BLACK);
000044  1e60              SUBS     r0,r4,#1
000046  4632              MOV      r2,r6
000048  1e7b              SUBS     r3,r7,#1
00004a  9500              STR      r5,[sp,#0]
00004c  1e79              SUBS     r1,r7,#1
00004e  f7fffffe          BL       RMP_Line
;;;3398       RMP_Line(Coord_X,Coord_Y+Width-1,Coord_X,Coord_Y,RMP_CTL_BLACK);
000052  4632              MOV      r2,r6
000054  4643              MOV      r3,r8
000056  1e79              SUBS     r1,r7,#1
000058  4610              MOV      r0,r2
00005a  9500              STR      r5,[sp,#0]
00005c  f7fffffe          BL       RMP_Line
;;;3399   }
000060  e8bd81ff          POP      {r0-r8,pc}
;;;3400   #endif
                          ENDP


                          AREA ||i.RMP_Progbar_Prog||, CODE, READONLY, ALIGN=1

                  RMP_Progbar_Prog PROC
;;;3326   ******************************************************************************/
;;;3327   void RMP_Progbar_Prog(cnt_t Coord_X, cnt_t Coord_Y, cnt_t Length, cnt_t Width,
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;3328                         cnt_t Style, cnt_t Prog, ptr_t Fore, ptr_t Back)
;;;3329   {
000004  4682              MOV      r10,r0
000006  4616              MOV      r6,r2
000008  461d              MOV      r5,r3
00000a  4689              MOV      r9,r1
00000c  e9dd400b          LDRD     r4,r0,[sp,#0x2c]
;;;3330       /* The critical value for drawing the bar */
;;;3331       ptr_t Pivot;
;;;3332       
;;;3333       switch(Style)
000010  f8ddc028          LDR      r12,[sp,#0x28]
;;;3334       {
;;;3335           case RMP_PBAR_L2R:
;;;3336           {
;;;3337               Pivot=Length*Prog/100;
000014  f04f0264          MOV      r2,#0x64
000018  9f0d              LDR      r7,[sp,#0x34]         ;3333
00001a  fb06f304          MUL      r3,r6,r4
00001e  f1bc0f00          CMP      r12,#0                ;3333
000022  d021              BEQ      |L31.104|
;;;3338               if(Prog!=0)
;;;3339                   RMP_Rectangle(Coord_X,Coord_Y,Pivot,Width,Fore,Fore);
;;;3340               if(Prog!=100)
;;;3341                   RMP_Rectangle(Coord_X+Pivot,Coord_Y,Length-Pivot,Width,Back,Back);
;;;3342               break;
;;;3343           }
;;;3344           case RMP_PBAR_D2U:
;;;3345           {
;;;3346               Pivot=Width*Prog/100;
000024  fb05f104          MUL      r1,r5,r4
000028  f1bc0f01          CMP      r12,#1                ;3333
00002c  d036              BEQ      |L31.156|
00002e  f1bc0f02          CMP      r12,#2                ;3333
000032  d049              BEQ      |L31.200|
000034  f1bc0f03          CMP      r12,#3                ;3333
000038  d12e              BNE      |L31.152|
;;;3347               if(Prog!=0)
;;;3348                   RMP_Rectangle(Coord_X,Coord_Y+Width-Pivot,Length,Pivot,Fore,Fore);
;;;3349               if(Prog!=100)
;;;3350                   RMP_Rectangle(Coord_X,Coord_Y,Length,Width-Pivot,Back,Back);
;;;3351               break;
;;;3352           }
;;;3353           case RMP_PBAR_R2L:
;;;3354           {
;;;3355               Pivot=Length*Prog/100;
;;;3356               if(Prog!=0)
;;;3357                   RMP_Rectangle(Coord_X+Length-Pivot,Coord_Y,Pivot,Width,Fore,Fore);
;;;3358               if(Prog!=100)
;;;3359                   RMP_Rectangle(Coord_X,Coord_Y,Length-Pivot,Width,Back,Back);
;;;3360               break;
;;;3361           }
;;;3362           case RMP_PBAR_U2D:
;;;3363           {
;;;3364               Pivot=Width*Prog/100;
00003a  fb91f1f2          SDIV     r1,r1,r2
00003e  4688              MOV      r8,r1
;;;3365               if(Prog!=0)
000040  b14c              CBZ      r4,|L31.86|
;;;3366                   RMP_Rectangle(Coord_X,Coord_Y,Length,Pivot,Fore,Fore);
000042  460b              MOV      r3,r1
000044  4632              MOV      r2,r6
000046  4649              MOV      r1,r9
000048  9000              STR      r0,[sp,#0]
00004a  9001              STR      r0,[sp,#4]
00004c  4650              MOV      r0,r10
00004e  f7fffffe          BL       RMP_Rectangle
;;;3367               if(Prog!=100)
000052  2c64              CMP      r4,#0x64
000054  d020              BEQ      |L31.152|
                  |L31.86|
;;;3368                   RMP_Rectangle(Coord_X,Coord_Y+Pivot,Length,Width-Pivot,Back,Back);
000056  eba50308          SUB      r3,r5,r8
00005a  4632              MOV      r2,r6
00005c  eb090108          ADD      r1,r9,r8
000060  9700              STR      r7,[sp,#0]
000062  9701              STR      r7,[sp,#4]
                  |L31.100|
000064  4650              MOV      r0,r10
000066  e015              B        |L31.148|
                  |L31.104|
000068  fb93f1f2          SDIV     r1,r3,r2              ;3337
00006c  4688              MOV      r8,r1                 ;3337
00006e  b14c              CBZ      r4,|L31.132|
000070  462b              MOV      r3,r5                 ;3339
000072  460a              MOV      r2,r1                 ;3339
000074  4649              MOV      r1,r9                 ;3339
000076  9000              STR      r0,[sp,#0]            ;3339
000078  9001              STR      r0,[sp,#4]            ;3339
00007a  4650              MOV      r0,r10                ;3339
00007c  f7fffffe          BL       RMP_Rectangle
000080  2c64              CMP      r4,#0x64              ;3340
000082  d009              BEQ      |L31.152|
                  |L31.132|
000084  eba60208          SUB      r2,r6,r8              ;3341
000088  462b              MOV      r3,r5                 ;3341
00008a  eb0a0008          ADD      r0,r10,r8             ;3341
00008e  4649              MOV      r1,r9                 ;3341
000090  9700              STR      r7,[sp,#0]            ;3341
000092  9701              STR      r7,[sp,#4]            ;3341
                  |L31.148|
000094  f7fffffe          BL       RMP_Rectangle
                  |L31.152|
;;;3369               break;
;;;3370           }
;;;3371           default: break;
;;;3372       }
;;;3373   }
000098  e8bd87fc          POP      {r2-r10,pc}
                  |L31.156|
00009c  fb91f8f2          SDIV     r8,r1,r2              ;3346
0000a0  b164              CBZ      r4,|L31.188|
0000a2  eb090105          ADD      r1,r9,r5              ;3348
0000a6  4643              MOV      r3,r8                 ;3348
0000a8  eba10108          SUB      r1,r1,r8              ;3348
0000ac  4632              MOV      r2,r6                 ;3348
0000ae  9000              STR      r0,[sp,#0]            ;3348
0000b0  9001              STR      r0,[sp,#4]            ;3348
0000b2  4650              MOV      r0,r10                ;3348
0000b4  f7fffffe          BL       RMP_Rectangle
0000b8  2c64              CMP      r4,#0x64              ;3349
0000ba  d0ed              BEQ      |L31.152|
                  |L31.188|
0000bc  eba50308          SUB      r3,r5,r8              ;3350
0000c0  4632              MOV      r2,r6                 ;3350
0000c2  9700              STR      r7,[sp,#0]            ;3350
0000c4  9701              STR      r7,[sp,#4]            ;3350
0000c6  e014              B        |L31.242|
                  |L31.200|
0000c8  fb93f8f2          SDIV     r8,r3,r2              ;3355
0000cc  b164              CBZ      r4,|L31.232|
0000ce  eb0a0106          ADD      r1,r10,r6             ;3357
0000d2  9000              STR      r0,[sp,#0]            ;3357
0000d4  9001              STR      r0,[sp,#4]            ;3357
0000d6  eba10008          SUB      r0,r1,r8              ;3357
0000da  462b              MOV      r3,r5                 ;3357
0000dc  4642              MOV      r2,r8                 ;3357
0000de  4649              MOV      r1,r9                 ;3357
0000e0  f7fffffe          BL       RMP_Rectangle
0000e4  2c64              CMP      r4,#0x64              ;3358
0000e6  d0d7              BEQ      |L31.152|
                  |L31.232|
0000e8  eba60208          SUB      r2,r6,r8              ;3359
0000ec  462b              MOV      r3,r5                 ;3359
0000ee  9700              STR      r7,[sp,#0]            ;3359
0000f0  9701              STR      r7,[sp,#4]            ;3359
                  |L31.242|
0000f2  4649              MOV      r1,r9                 ;3350
0000f4  e7b6              B        |L31.100|
;;;3374   /* End Function:RMP_Progbar_Prog *********************************************/
                          ENDP


                          AREA ||i.RMP_Progbar_Set||, CODE, READONLY, ALIGN=2

                  RMP_Progbar_Set PROC
;;;3247   ******************************************************************************/
;;;3248   void RMP_Progbar_Set(cnt_t Coord_X, cnt_t Coord_Y, cnt_t Length, cnt_t Width,
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;3249                        cnt_t Style, cnt_t Old_Prog, cnt_t New_Prog, ptr_t Fore, ptr_t Back)
;;;3250   {
000004  e9dd8b0d          LDRD     r8,r11,[sp,#0x34]
000008  e9dd650f          LDRD     r6,r5,[sp,#0x3c]
;;;3251       /* The critical values for drawing the bar */
;;;3252       ptr_t Old_Pivot;
;;;3253       ptr_t New_Pivot;
;;;3254       
;;;3255       /* If things does not change, return to save time */
;;;3256       if(Old_Prog==New_Prog)
00000c  f8ddc030          LDR      r12,[sp,#0x30]
000010  45d8              CMP      r8,r11
000012  d037              BEQ      |L32.132|
;;;3257           return;
;;;3258       
;;;3259       switch(Style)
;;;3260       {
;;;3261           case RMP_PBAR_L2R:
;;;3262           {
;;;3263               Old_Pivot=(Length-2)*Old_Prog/100;
000014  1e94              SUBS     r4,r2,#2
000016  f04f0e64          MOV      lr,#0x64
00001a  f1bc0f00          CMP      r12,#0                ;3259
00001e  fb04fa08          MUL      r10,r4,r8
;;;3264               New_Pivot=(Length-2)*New_Prog/100;
000022  fb04f70b          MUL      r7,r4,r11
000026  d019              BEQ      |L32.92|
;;;3265               /* Progress decreased */
;;;3266               if(Old_Pivot>New_Pivot)
;;;3267                   RMP_Rectangle(Coord_X+1+New_Pivot,Coord_Y+1,Old_Pivot-New_Pivot,Width-2,Back,Back);
000028  1e9c              SUBS     r4,r3,#2
00002a  9400              STR      r4,[sp,#0]            ;3259
00002c  f1bc0f01          CMP      r12,#1                ;3259
;;;3268               /* Progress increased */
;;;3269               else
;;;3270                   RMP_Rectangle(Coord_X+1+Old_Pivot,Coord_Y+1,New_Pivot-Old_Pivot,Width-2,Fore,Fore);
;;;3271               break;
;;;3272           }
;;;3273           case RMP_PBAR_D2U:
;;;3274           {
;;;3275               Old_Pivot=(Width-2)*Old_Prog/100;
000030  fb04f908          MUL      r9,r4,r8
;;;3276               New_Pivot=(Width-2)*New_Prog/100;
000034  fb04f40b          MUL      r4,r4,r11
000038  d026              BEQ      |L32.136|
00003a  f1bc0f02          CMP      r12,#2                ;3259
00003e  d036              BEQ      |L32.174|
000040  f1bc0f03          CMP      r12,#3                ;3259
000044  d11e              BNE      |L32.132|
;;;3277               /* Progress decreased */
;;;3278               if(Old_Pivot>New_Pivot)
;;;3279                   RMP_Rectangle(Coord_X+1,Coord_Y-1+Width-Old_Pivot,Length-2,Old_Pivot-New_Pivot,Back,Back);
;;;3280               /* Progress increased */
;;;3281               else
;;;3282                   RMP_Rectangle(Coord_X+1,Coord_Y-1+Width-New_Pivot,Length-2,New_Pivot-Old_Pivot,Fore,Fore);
;;;3283               break;
;;;3284           }
;;;3285           case RMP_PBAR_R2L:
;;;3286           {
;;;3287               Old_Pivot=(Length-2)*Old_Prog/100;
;;;3288               New_Pivot=(Length-2)*New_Prog/100;
;;;3289               /* Progress decreased */
;;;3290               if(Old_Pivot>New_Pivot)
;;;3291                   RMP_Rectangle(Coord_X-1+Length-Old_Pivot,Coord_Y+1,Old_Pivot-New_Pivot,Width-2,Back,Back);
;;;3292               /* Progress increased */
;;;3293               else
;;;3294                   RMP_Rectangle(Coord_X-1+Length-New_Pivot,Coord_Y+1,New_Pivot-Old_Pivot,Width-2,Fore,Fore);
;;;3295               break;
;;;3296           }
;;;3297           case RMP_PBAR_U2D:
;;;3298           {
;;;3299               Old_Pivot=(Width-2)*Old_Prog/100;
000046  fb99f3fe          SDIV     r3,r9,lr
;;;3300               New_Pivot=(Width-2)*New_Prog/100;
00004a  fb94f4fe          SDIV     r4,r4,lr
;;;3301               /* Progress decreased */
;;;3302               if(Old_Pivot>New_Pivot)
00004e  42a3              CMP      r3,r4
000050  d941              BLS      |L32.214|
;;;3303                   RMP_Rectangle(Coord_X+1,Coord_Y+1+New_Pivot,Length-2,Old_Pivot-New_Pivot,Back,Back);
000052  1b1b              SUBS     r3,r3,r4
000054  9500              STR      r5,[sp,#0]
000056  4421              ADD      r1,r1,r4
000058  9501              STR      r5,[sp,#4]
00005a  e040              B        |L32.222|
                  |L32.92|
00005c  fb9af2fe          SDIV     r2,r10,lr             ;3263
000060  fb97f4fe          SDIV     r4,r7,lr              ;3264
000064  42a2              CMP      r2,r4                 ;3266
000066  d904              BLS      |L32.114|
000068  1b12              SUBS     r2,r2,r4              ;3267
00006a  9500              STR      r5,[sp,#0]            ;3267
00006c  4420              ADD      r0,r0,r4              ;3267
00006e  9501              STR      r5,[sp,#4]            ;3267
000070  e003              B        |L32.122|
                  |L32.114|
000072  4410              ADD      r0,r0,r2              ;3270
000074  9600              STR      r6,[sp,#0]            ;3270
000076  1aa2              SUBS     r2,r4,r2              ;3270
000078  9601              STR      r6,[sp,#4]            ;3270
                  |L32.122|
00007a  1c40              ADDS     r0,r0,#1              ;3270
00007c  e028              B        |L32.208|
00007e  bf00              NOP                            ;3270
                  |L32.128|
000080  f7fffffe          BL       RMP_Rectangle
                  |L32.132|
;;;3304               /* Progress increased */
;;;3305               else
;;;3306                   RMP_Rectangle(Coord_X+1,Coord_Y+1+Old_Pivot,Length-2,New_Pivot-Old_Pivot,Fore,Fore);
;;;3307               break;
;;;3308           }
;;;3309           default: break;
;;;3310       }
;;;3311   }
000084  e8bd9ffc          POP      {r2-r12,pc}
                  |L32.136|
000088  4419              ADD      r1,r1,r3              ;3279
00008a  fb99f3fe          SDIV     r3,r9,lr              ;3275
00008e  fb94f4fe          SDIV     r4,r4,lr              ;3276
000092  42a3              CMP      r3,r4                 ;3278
000094  d904              BLS      |L32.160|
000096  1ac9              SUBS     r1,r1,r3              ;3279
000098  9500              STR      r5,[sp,#0]            ;3279
00009a  1b1b              SUBS     r3,r3,r4              ;3279
00009c  9501              STR      r5,[sp,#4]            ;3279
00009e  e003              B        |L32.168|
                  |L32.160|
0000a0  1b09              SUBS     r1,r1,r4              ;3282
0000a2  9600              STR      r6,[sp,#0]            ;3282
0000a4  1ae3              SUBS     r3,r4,r3              ;3282
0000a6  9601              STR      r6,[sp,#4]            ;3282
                  |L32.168|
0000a8  1c40              ADDS     r0,r0,#1              ;3282
0000aa  1e49              SUBS     r1,r1,#1              ;3282
0000ac  e019              B        |L32.226|
                  |L32.174|
0000ae  4410              ADD      r0,r0,r2              ;3291
0000b0  fb9af2fe          SDIV     r2,r10,lr             ;3287
0000b4  fb97f4fe          SDIV     r4,r7,lr              ;3288
0000b8  42a2              CMP      r2,r4                 ;3290
0000ba  d904              BLS      |L32.198|
0000bc  1a80              SUBS     r0,r0,r2              ;3291
0000be  9500              STR      r5,[sp,#0]            ;3291
0000c0  1b12              SUBS     r2,r2,r4              ;3291
0000c2  9501              STR      r5,[sp,#4]            ;3291
0000c4  e003              B        |L32.206|
                  |L32.198|
0000c6  1b00              SUBS     r0,r0,r4              ;3294
0000c8  9600              STR      r6,[sp,#0]            ;3294
0000ca  1aa2              SUBS     r2,r4,r2              ;3294
0000cc  9601              STR      r6,[sp,#4]            ;3294
                  |L32.206|
0000ce  1e40              SUBS     r0,r0,#1              ;3294
                  |L32.208|
0000d0  1c49              ADDS     r1,r1,#1              ;3294
0000d2  1e9b              SUBS     r3,r3,#2              ;3294
0000d4  e7d4              B        |L32.128|
                  |L32.214|
0000d6  4419              ADD      r1,r1,r3              ;3306
0000d8  9600              STR      r6,[sp,#0]            ;3306
0000da  1ae3              SUBS     r3,r4,r3              ;3306
0000dc  9601              STR      r6,[sp,#4]            ;3306
                  |L32.222|
0000de  1c40              ADDS     r0,r0,#1              ;3306
0000e0  1c49              ADDS     r1,r1,#1              ;3306
                  |L32.226|
0000e2  1e92              SUBS     r2,r2,#2              ;3306
0000e4  e7cc              B        |L32.128|
;;;3312   /* End Function:RMP_Progbar_Set **********************************************/
                          ENDP


                          AREA ||i.RMP_RBIT_Get||, CODE, READONLY, ALIGN=2

                  RMP_RBIT_Get PROC
;;;1694   
;;;1695   ptr_t RMP_RBIT_Get(ptr_t Val)
000000  b570              PUSH     {r4-r6,lr}
;;;1696   {
;;;1697       ptr_t Ret;
;;;1698       u8* To;
;;;1699       u8* From;
;;;1700       
;;;1701       To=(u8*)(&Ret);
;;;1702       From=(u8*)(&Val);
;;;1703       
;;;1704   #if(RMP_WORD_ORDER==4)
;;;1705       To[0]=RMP_RBIT_Table[From[1]];
;;;1706       To[1]=RMP_RBIT_Table[From[0]];
;;;1707   #elif(RMP_WORD_ORDER==5)
;;;1708       To[0]=RMP_RBIT_Table[From[3]];
000002  490a              LDR      r1,|L33.44|
000004  0e06              LSRS     r6,r0,#24             ;1696
000006  f3c04407          UBFX     r4,r0,#16,#8
00000a  f3c02307          UBFX     r3,r0,#8,#8
00000e  b2c5              UXTB     r5,r0
000010  5d88              LDRB     r0,[r1,r6]
;;;1709       To[1]=RMP_RBIT_Table[From[2]];
000012  5d0c              LDRB     r4,[r1,r4]
;;;1710       To[2]=RMP_RBIT_Table[From[1]];
000014  5ccb              LDRB     r3,[r1,r3]
;;;1711       To[3]=RMP_RBIT_Table[From[0]];
000016  f3600207          BFI      r2,r0,#0,#8
00001a  5d49              LDRB     r1,[r1,r5]
00001c  4610              MOV      r0,r2
00001e  f364200f          BFI      r0,r4,#8,#8
000022  f3634017          BFI      r0,r3,#16,#8
000026  f361601f          BFI      r0,r1,#24,#8
;;;1712   #else
;;;1713       To[0]=RMP_RBIT_Table[From[7]];
;;;1714       To[1]=RMP_RBIT_Table[From[6]];
;;;1715       To[2]=RMP_RBIT_Table[From[5]];
;;;1716       To[3]=RMP_RBIT_Table[From[4]];
;;;1717       To[4]=RMP_RBIT_Table[From[3]];
;;;1718       To[5]=RMP_RBIT_Table[From[2]];
;;;1719       To[6]=RMP_RBIT_Table[From[1]];
;;;1720       To[7]=RMP_RBIT_Table[From[0]];
;;;1721   #endif
;;;1722   
;;;1723       return Ret;
;;;1724   }
00002a  bd70              POP      {r4-r6,pc}
;;;1725   /* End Function:RMP_RBIT_Get *************************************************/
                          ENDP

                  |L33.44|
                          DCD      ||.constdata||

                          AREA ||i.RMP_Radiobtn||, CODE, READONLY, ALIGN=1

                  RMP_Radiobtn PROC
;;;3219   ******************************************************************************/
;;;3220   void RMP_Radiobtn(cnt_t Coord_X, cnt_t Coord_Y, cnt_t Length, ptr_t Status)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;3221   {   
000004  4607              MOV      r7,r0
;;;3222       /* Fill the area with rect */
;;;3223       RMP_Rectangle(Coord_X,Coord_Y,Length,Length,RMP_CTL_GREY,RMP_CTL_GREY);
000006  f64b50d7          MOV      r0,#0xbdd7
00000a  461c              MOV      r4,r3                 ;3221
00000c  4615              MOV      r5,r2                 ;3221
00000e  460e              MOV      r6,r1                 ;3221
000010  4613              MOV      r3,r2
000012  9000              STR      r0,[sp,#0]
000014  9001              STR      r0,[sp,#4]
000016  4638              MOV      r0,r7
000018  f7fffffe          BL       RMP_Rectangle
;;;3224       
;;;3225       /* Draw the circle first */
;;;3226       RMP_Radiobtn_Circle(Coord_X,Coord_Y,Length);
00001c  462a              MOV      r2,r5
00001e  4631              MOV      r1,r6
000020  4638              MOV      r0,r7
000022  f7fffffe          BL       RMP_Radiobtn_Circle
;;;3227       
;;;3228       /* See if the radio button is selected */
;;;3229       if(Status==RMP_RBTN_SEL)
000026  2c01              CMP      r4,#1
000028  d107              BNE      |L34.58|
;;;3230           RMP_Radiobtn_Set(Coord_X, Coord_Y, Length);
00002a  b002              ADD      sp,sp,#8
00002c  462a              MOV      r2,r5
00002e  4631              MOV      r1,r6
000030  4638              MOV      r0,r7
000032  e8bd41f0          POP      {r4-r8,lr}
000036  f7ffbffe          B.W      RMP_Radiobtn_Set
                  |L34.58|
;;;3231   }
00003a  e8bd81fc          POP      {r2-r8,pc}
;;;3232   /* End Function:RMP_Radiobtn *************************************************/
                          ENDP


                          AREA ||i.RMP_Radiobtn_Circle||, CODE, READONLY, ALIGN=1

                  RMP_Radiobtn_Circle PROC
;;;3104   ******************************************************************************/
;;;3105   void RMP_Radiobtn_Circle(cnt_t Coord_X,cnt_t Coord_Y,cnt_t Length)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;3106   {   
;;;3107       cnt_t Radius;
;;;3108       cnt_t Center_X;
;;;3109       cnt_t Center_Y;
;;;3110       cnt_t Cur_X;
;;;3111       cnt_t Cur_Y;
;;;3112       cnt_t Error;
;;;3113       
;;;3114       /* The radius is the length/2 */
;;;3115       Radius=Length>>1;
000004  ea4f0862          ASR      r8,r2,#1
;;;3116       Center_X=Coord_X+Radius;
;;;3117       Center_Y=Coord_Y+Radius;
;;;3118       
;;;3119       /* Now we begin to draw the inner halfcircle */
;;;3120       Cur_X=0;
;;;3121       Cur_Y=Radius-1;
;;;3122       Error=3-((Radius-1)<<1);  
000008  2305              MOVS     r3,#5
00000a  2500              MOVS     r5,#0                 ;3120
00000c  eb000708          ADD      r7,r0,r8              ;3116
000010  eb010608          ADD      r6,r1,r8              ;3117
000014  eba30948          SUB      r9,r3,r8,LSL #1
000018  f1a80401          SUB      r4,r8,#1              ;3121
00001c  e044              B        |L35.168|
                  |L35.30|
;;;3123       
;;;3124       while(Cur_X<=Cur_Y) 
;;;3125       {  
;;;3126           /* This is the upper-left part */
;;;3127           RMP_POINT(Center_X+Cur_X,Center_Y-Cur_Y,RMP_CTL_DDARK);
00001e  1b31              SUBS     r1,r6,r4
000020  f646324d          MOV      r2,#0x6b4d
000024  1978              ADDS     r0,r7,r5
000026  468b              MOV      r11,r1
000028  4682              MOV      r10,r0
00002a  f7fffffe          BL       RMP_Point
;;;3128           RMP_POINT(Center_X-Cur_X,Center_Y-Cur_Y,RMP_CTL_DDARK);
00002e  1b78              SUBS     r0,r7,r5
000030  4659              MOV      r1,r11                ;3127
000032  4683              MOV      r11,r0
000034  f646324d          MOV      r2,#0x6b4d
000038  f7fffffe          BL       RMP_Point
;;;3129           RMP_POINT(Center_X-Cur_Y,Center_Y-Cur_X,RMP_CTL_DDARK);
00003c  1b71              SUBS     r1,r6,r5
00003e  f646324d          MOV      r2,#0x6b4d
000042  1b38              SUBS     r0,r7,r4
000044  9102              STR      r1,[sp,#8]
000046  9000              STR      r0,[sp,#0]
000048  f7fffffe          BL       RMP_Point
;;;3130           RMP_POINT(Center_X-Cur_Y,Center_Y+Cur_X,RMP_CTL_DDARK);
00004c  9800              LDR      r0,[sp,#0]
00004e  1971              ADDS     r1,r6,r5
000050  f646324d          MOV      r2,#0x6b4d
000054  9101              STR      r1,[sp,#4]
000056  f7fffffe          BL       RMP_Point
;;;3131           
;;;3132           /* This is the lower-right part */
;;;3133           RMP_POINT(Center_X+Cur_X,Center_Y+Cur_Y,RMP_CTL_LGREY);
00005a  1931              ADDS     r1,r6,r4
00005c  4650              MOV      r0,r10
00005e  f24e721c          MOV      r2,#0xe71c
000062  9100              STR      r1,[sp,#0]
000064  f7fffffe          BL       RMP_Point
;;;3134           RMP_POINT(Center_X-Cur_X,Center_Y+Cur_Y,RMP_CTL_LGREY);  
000068  9900              LDR      r1,[sp,#0]
00006a  4658              MOV      r0,r11                ;3133
00006c  f24e721c          MOV      r2,#0xe71c
000070  f7fffffe          BL       RMP_Point
;;;3135           RMP_POINT(Center_X+Cur_Y,Center_Y+Cur_X,RMP_CTL_LGREY); 
000074  1938              ADDS     r0,r7,r4
000076  9901              LDR      r1,[sp,#4]
000078  4682              MOV      r10,r0
00007a  f24e721c          MOV      r2,#0xe71c
00007e  f7fffffe          BL       RMP_Point
;;;3136           RMP_POINT(Center_X+Cur_Y,Center_Y-Cur_X,RMP_CTL_LGREY);  
000082  9902              LDR      r1,[sp,#8]
000084  4650              MOV      r0,r10                ;3135
000086  f24e721c          MOV      r2,#0xe71c
00008a  f7fffffe          BL       RMP_Point
;;;3137           
;;;3138           if(Error<0) 
00008e  f1b90f00          CMP      r9,#0
000092  da04              BGE      |L35.158|
;;;3139           {
;;;3140               Error=Error+(Cur_X<<2)+6;
000094  eb090085          ADD      r0,r9,r5,LSL #2
000098  f1000906          ADD      r9,r0,#6
00009c  e003              B        |L35.166|
                  |L35.158|
;;;3141           }
;;;3142           else 
;;;3143           {
;;;3144               Error=Error+((Cur_X-Cur_Y)<<2);
00009e  1b29              SUBS     r1,r5,r4
0000a0  1e64              SUBS     r4,r4,#1
0000a2  eb090981          ADD      r9,r9,r1,LSL #2
                  |L35.166|
0000a6  1c6d              ADDS     r5,r5,#1
                  |L35.168|
0000a8  42a5              CMP      r5,r4                 ;3124
0000aa  ddb8              BLE      |L35.30|
;;;3145               Cur_Y--;
;;;3146           }
;;;3147           Cur_X++;
;;;3148       } 
;;;3149       
;;;3150       /* Now we begin to draw the outer halfcircle */
;;;3151       Cur_X=0;
;;;3152       Cur_Y=Radius;
;;;3153       Error=3-(Radius<<1);  
0000ac  2103              MOVS     r1,#3
0000ae  4645              MOV      r5,r8                 ;3152
0000b0  2400              MOVS     r4,#0                 ;3151
0000b2  eba10948          SUB      r9,r1,r8,LSL #1
;;;3154       
;;;3155       while(Cur_X<=Cur_Y) 
0000b6  e044              B        |L35.322|
                  |L35.184|
;;;3156       {  
;;;3157           /* This is the upper-left part */
;;;3158           RMP_POINT(Center_X+Cur_X,Center_Y-Cur_Y,RMP_CTL_DGREY);
0000b8  1b71              SUBS     r1,r6,r5
0000ba  f24a5214          MOV      r2,#0xa514
0000be  1938              ADDS     r0,r7,r4
0000c0  4688              MOV      r8,r1
0000c2  4682              MOV      r10,r0
0000c4  f7fffffe          BL       RMP_Point
;;;3159           RMP_POINT(Center_X-Cur_X,Center_Y-Cur_Y,RMP_CTL_DGREY);
0000c8  1b38              SUBS     r0,r7,r4
0000ca  4641              MOV      r1,r8                 ;3158
0000cc  f24a5214          MOV      r2,#0xa514
0000d0  9001              STR      r0,[sp,#4]
0000d2  f7fffffe          BL       RMP_Point
;;;3160           RMP_POINT(Center_X-Cur_Y,Center_Y-Cur_X,RMP_CTL_DGREY);
0000d6  1b78              SUBS     r0,r7,r5
0000d8  f24a5214          MOV      r2,#0xa514
0000dc  1b31              SUBS     r1,r6,r4
0000de  4680              MOV      r8,r0
0000e0  9100              STR      r1,[sp,#0]
0000e2  f7fffffe          BL       RMP_Point
;;;3161           RMP_POINT(Center_X-Cur_Y,Center_Y+Cur_X,RMP_CTL_DGREY);
0000e6  1931              ADDS     r1,r6,r4
0000e8  4640              MOV      r0,r8                 ;3160
0000ea  468b              MOV      r11,r1
0000ec  f24a5214          MOV      r2,#0xa514
0000f0  f7fffffe          BL       RMP_Point
;;;3162           
;;;3163           /* This is the lower-right part */
;;;3164           RMP_POINT(Center_X+Cur_X,Center_Y+Cur_Y,RMP_CTL_WHITE);
0000f4  1971              ADDS     r1,r6,r5
0000f6  4650              MOV      r0,r10
0000f8  4688              MOV      r8,r1
0000fa  f64f72ff          MOV      r2,#0xffff
0000fe  f7fffffe          BL       RMP_Point
;;;3165           RMP_POINT(Center_X-Cur_X,Center_Y+Cur_Y,RMP_CTL_WHITE);  
000102  9801              LDR      r0,[sp,#4]
000104  4641              MOV      r1,r8                 ;3164
000106  f64f72ff          MOV      r2,#0xffff
00010a  f7fffffe          BL       RMP_Point
;;;3166           RMP_POINT(Center_X+Cur_Y,Center_Y+Cur_X,RMP_CTL_WHITE); 
00010e  1978              ADDS     r0,r7,r5
000110  4659              MOV      r1,r11                ;3165
000112  4680              MOV      r8,r0
000114  f64f72ff          MOV      r2,#0xffff
000118  f7fffffe          BL       RMP_Point
;;;3167           RMP_POINT(Center_X+Cur_Y,Center_Y-Cur_X,RMP_CTL_WHITE);  
00011c  9900              LDR      r1,[sp,#0]
00011e  4640              MOV      r0,r8                 ;3166
000120  f64f72ff          MOV      r2,#0xffff
000124  f7fffffe          BL       RMP_Point
;;;3168           
;;;3169           if(Error<0) 
000128  f1b90f00          CMP      r9,#0
00012c  da04              BGE      |L35.312|
;;;3170           {  
;;;3171               Error=Error+(Cur_X<<2)+6;  
00012e  eb090084          ADD      r0,r9,r4,LSL #2
000132  f1000906          ADD      r9,r0,#6
000136  e003              B        |L35.320|
                  |L35.312|
;;;3172           } 
;;;3173           else 
;;;3174           {  
;;;3175               Error=Error+((Cur_X-Cur_Y)<<2);  
000138  1b61              SUBS     r1,r4,r5
00013a  1e6d              SUBS     r5,r5,#1
00013c  eb090981          ADD      r9,r9,r1,LSL #2
                  |L35.320|
000140  1c64              ADDS     r4,r4,#1
                  |L35.322|
000142  42ac              CMP      r4,r5                 ;3155
000144  ddb8              BLE      |L35.184|
;;;3176               Cur_Y--;  
;;;3177           }  
;;;3178           Cur_X++;  
;;;3179       } 
;;;3180   }
000146  e8bd8ffe          POP      {r1-r11,pc}
;;;3181   /* End Function:RMP_Radiobtn_Circle ******************************************/
                          ENDP


                          AREA ||i.RMP_Radiobtn_Clr||, CODE, READONLY, ALIGN=1

                  RMP_Radiobtn_Clr PROC
;;;3204   ******************************************************************************/
;;;3205   void RMP_Radiobtn_Clr(cnt_t Coord_X, cnt_t Coord_Y, cnt_t Length)
000000  b538              PUSH     {r3-r5,lr}
;;;3206   {
;;;3207       RMP_Circle(Coord_X+Length/2,Coord_Y+Length/2,Length/6,RMP_CTL_GREY,RMP_CTL_GREY);
000002  2506              MOVS     r5,#6
000004  4614              MOV      r4,r2
000006  fb92f2f5          SDIV     r2,r2,r5
00000a  eb0474d4          ADD      r4,r4,r4,LSR #31
00000e  f64b53d7          MOV      r3,#0xbdd7
000012  9300              STR      r3,[sp,#0]
000014  eb010164          ADD      r1,r1,r4,ASR #1
000018  eb000064          ADD      r0,r0,r4,ASR #1
00001c  f7fffffe          BL       RMP_Circle
;;;3208   }
000020  bd38              POP      {r3-r5,pc}
;;;3209   /* End Function:RMP_Radiobtn_Clr *********************************************/
                          ENDP


                          AREA ||i.RMP_Radiobtn_Set||, CODE, READONLY, ALIGN=1

                  RMP_Radiobtn_Set PROC
;;;3190   ******************************************************************************/
;;;3191   void RMP_Radiobtn_Set(cnt_t Coord_X, cnt_t Coord_Y, cnt_t Length)
000000  b538              PUSH     {r3-r5,lr}
;;;3192   {
;;;3193       RMP_Circle(Coord_X+Length/2,Coord_Y+Length/2,Length/6,RMP_CTL_BLACK,RMP_CTL_BLACK);
000002  2506              MOVS     r5,#6
000004  4613              MOV      r3,r2
000006  fb92f2f5          SDIV     r2,r2,r5
00000a  eb0373d3          ADD      r3,r3,r3,LSR #31
00000e  2400              MOVS     r4,#0
000010  9400              STR      r4,[sp,#0]
000012  eb010163          ADD      r1,r1,r3,ASR #1
000016  eb000063          ADD      r0,r0,r3,ASR #1
00001a  4623              MOV      r3,r4
00001c  f7fffffe          BL       RMP_Circle
;;;3194   }
000020  bd38              POP      {r3-r5,pc}
;;;3195   /* End Function:RMP_Radiobtn_Set *********************************************/
                          ENDP


                          AREA ||i.RMP_Rectangle||, CODE, READONLY, ALIGN=1

                  RMP_Rectangle PROC
;;;2348   ******************************************************************************/
;;;2349   void RMP_Rectangle(cnt_t Coord_X, cnt_t Coord_Y, cnt_t Length, cnt_t Width, ptr_t Border, ptr_t Fill)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;2350   {
;;;2351       cnt_t Line_Cnt;
;;;2352       
;;;2353       if(Fill!=RMP_TRANS)
;;;2354       {
;;;2355           for(Line_Cnt=0;Line_Cnt<Width;Line_Cnt++)
;;;2356               RMP_Line(Coord_X,Coord_Y+Line_Cnt,Coord_X+Length-1,Coord_Y+Line_Cnt,Fill);
000004  eb000402          ADD      r4,r0,r2
000008  461f              MOV      r7,r3                 ;2350
00000a  4688              MOV      r8,r1                 ;2350
00000c  4682              MOV      r10,r0                ;2350
00000e  e9dd690a          LDRD     r6,r9,[sp,#0x28]      ;2350
000012  f1b90f01          CMP      r9,#1                 ;2353
000016  d00d              BEQ      |L38.52|
000018  2500              MOVS     r5,#0                 ;2355
00001a  e009              B        |L38.48|
                  |L38.28|
00001c  eb080305          ADD      r3,r8,r5
000020  4650              MOV      r0,r10
000022  1e62              SUBS     r2,r4,#1
000024  4619              MOV      r1,r3
000026  f8cd9000          STR      r9,[sp,#0]
00002a  f7fffffe          BL       RMP_Line
00002e  1c6d              ADDS     r5,r5,#1
                  |L38.48|
000030  42bd              CMP      r5,r7                 ;2355
000032  dbf3              BLT      |L38.28|
                  |L38.52|
;;;2357       }
;;;2358   
;;;2359       if(Border!=RMP_TRANS)
000034  2e01              CMP      r6,#1
000036  d01d              BEQ      |L38.116|
;;;2360       {
;;;2361           RMP_Line(Coord_X,Coord_Y,Coord_X+Length-1,Coord_Y,Border);
000038  4643              MOV      r3,r8
00003a  4650              MOV      r0,r10
00003c  1e62              SUBS     r2,r4,#1
00003e  4619              MOV      r1,r3
000040  9600              STR      r6,[sp,#0]
000042  f7fffffe          BL       RMP_Line
;;;2362           RMP_Line(Coord_X+Length-1,Coord_Y,Coord_X+Length-1,Coord_Y+Width-1,Border);
000046  eb080507          ADD      r5,r8,r7
00004a  4641              MOV      r1,r8
00004c  1e62              SUBS     r2,r4,#1
00004e  9600              STR      r6,[sp,#0]
000050  1e6b              SUBS     r3,r5,#1
000052  1e60              SUBS     r0,r4,#1
000054  f7fffffe          BL       RMP_Line
;;;2363           RMP_Line(Coord_X+Length-1,Coord_Y+Width-1,Coord_X,Coord_Y+Width-1,Border);
000058  1e60              SUBS     r0,r4,#1
00005a  4652              MOV      r2,r10
00005c  1e6b              SUBS     r3,r5,#1
00005e  9600              STR      r6,[sp,#0]
000060  1e69              SUBS     r1,r5,#1
000062  f7fffffe          BL       RMP_Line
;;;2364           RMP_Line(Coord_X,Coord_Y+Width-1,Coord_X,Coord_Y,Border);
000066  4652              MOV      r2,r10
000068  4643              MOV      r3,r8
00006a  1e69              SUBS     r1,r5,#1
00006c  4610              MOV      r0,r2
00006e  9600              STR      r6,[sp,#0]
000070  f7fffffe          BL       RMP_Line
                  |L38.116|
;;;2365       }
;;;2366   }
000074  e8bd8ff8          POP      {r3-r11,pc}
;;;2367   /* End Function:RMP_Rectangle ************************************************/
                          ENDP


                          AREA ||i.RMP_Round_Rect||, CODE, READONLY, ALIGN=1

                  RMP_Round_Rect PROC
;;;2380   ******************************************************************************/
;;;2381   void RMP_Round_Rect(cnt_t Coord_X, cnt_t Coord_Y, cnt_t Length, cnt_t Width, 
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;2382                       cnt_t Round, ptr_t Fore, ptr_t Back)
;;;2383   {
;;;2384       cnt_t Cir_X_0;
;;;2385       cnt_t Cir_X_1;
;;;2386       cnt_t Cir_Y_0;
;;;2387       cnt_t Cir_Y_1;
;;;2388       
;;;2389       Cir_X_0=Coord_X+Round+1;
;;;2390       Cir_X_1=Coord_X+Length-Round-1;
;;;2391       Cir_Y_0=Coord_Y+Round+1;
;;;2392       Cir_Y_1=Coord_Y+Width-Round-1;
000004  eb010803          ADD      r8,r1,r3
000008  1887              ADDS     r7,r0,r2              ;2390
00000a  e9dd460c          LDRD     r4,r6,[sp,#0x30]      ;2383
;;;2393       
;;;2394       RMP_Rectangle(Coord_X,Coord_Y,Length,Width,Fore,Fore);
00000e  9d0e              LDR      r5,[sp,#0x38]
000010  eb000c04          ADD      r12,r0,r4             ;2389
000014  9600              STR      r6,[sp,#0]
000016  f10c0901          ADD      r9,r12,#1             ;2389
00001a  eba80c04          SUB      r12,r8,r4             ;2392
00001e  1b3f              SUBS     r7,r7,r4              ;2390
000020  f1ac0c01          SUB      r12,r12,#1
000024  f1a70b01          SUB      r11,r7,#1             ;2392
000028  190f              ADDS     r7,r1,r4              ;2391
00002a  1c7f              ADDS     r7,r7,#1
00002c  e9cd6c01          STRD     r6,r12,[sp,#4]
000030  f7fffffe          BL       RMP_Rectangle
;;;2395       
;;;2396       RMP_Rectangle(Cir_X_0-Round-1,Cir_Y_0-Round-1,Round+1,Round+1,Back,Back);
000034  eba70a04          SUB      r10,r7,r4
000038  9500              STR      r5,[sp,#0]
00003a  eba90804          SUB      r8,r9,r4
00003e  9501              STR      r5,[sp,#4]
000040  1c63              ADDS     r3,r4,#1
000042  1c62              ADDS     r2,r4,#1
000044  f1a80001          SUB      r0,r8,#1
000048  f1aa0101          SUB      r1,r10,#1
00004c  f7fffffe          BL       RMP_Rectangle
;;;2397       RMP_Rectangle(Cir_X_1,Cir_Y_0-Round-1,Round+1,Round+1,Back,Back);
000050  1c63              ADDS     r3,r4,#1
000052  4658              MOV      r0,r11
000054  1c62              ADDS     r2,r4,#1
000056  9500              STR      r5,[sp,#0]
000058  f1aa0101          SUB      r1,r10,#1
00005c  9501              STR      r5,[sp,#4]
00005e  f7fffffe          BL       RMP_Rectangle
;;;2398       RMP_Rectangle(Cir_X_0-Round-1,Cir_Y_1,Round+1,Round+1,Back,Back);
000062  9902              LDR      r1,[sp,#8]
000064  1c63              ADDS     r3,r4,#1
000066  1c62              ADDS     r2,r4,#1
000068  9500              STR      r5,[sp,#0]
00006a  f1a80001          SUB      r0,r8,#1
00006e  9501              STR      r5,[sp,#4]
000070  f7fffffe          BL       RMP_Rectangle
;;;2399       RMP_Rectangle(Cir_X_1,Cir_Y_1,Round+1,Round+1,Back,Back);
000074  9902              LDR      r1,[sp,#8]
000076  1c63              ADDS     r3,r4,#1
000078  1c62              ADDS     r2,r4,#1
00007a  4658              MOV      r0,r11
00007c  9500              STR      r5,[sp,#0]
00007e  9501              STR      r5,[sp,#4]
000080  f7fffffe          BL       RMP_Rectangle
;;;2400       
;;;2401       RMP_Circle(Cir_X_0,Cir_Y_0,Round,Fore,Fore);
000084  4633              MOV      r3,r6
000086  4622              MOV      r2,r4
000088  4639              MOV      r1,r7
00008a  4648              MOV      r0,r9
00008c  9600              STR      r6,[sp,#0]
00008e  f7fffffe          BL       RMP_Circle
;;;2402       RMP_Circle(Cir_X_1,Cir_Y_0,Round,Fore,Fore);
000092  4633              MOV      r3,r6
000094  4622              MOV      r2,r4
000096  4639              MOV      r1,r7
000098  4658              MOV      r0,r11
00009a  9600              STR      r6,[sp,#0]
00009c  f7fffffe          BL       RMP_Circle
;;;2403       RMP_Circle(Cir_X_0,Cir_Y_1,Round,Fore,Fore);
0000a0  9902              LDR      r1,[sp,#8]
0000a2  4633              MOV      r3,r6
0000a4  4622              MOV      r2,r4
0000a6  4648              MOV      r0,r9
0000a8  9600              STR      r6,[sp,#0]
0000aa  f7fffffe          BL       RMP_Circle
;;;2404       RMP_Circle(Cir_X_1,Cir_Y_1,Round,Fore,Fore);
0000ae  9902              LDR      r1,[sp,#8]
0000b0  4633              MOV      r3,r6
0000b2  4622              MOV      r2,r4
0000b4  4658              MOV      r0,r11
0000b6  9600              STR      r6,[sp,#0]
0000b8  f7fffffe          BL       RMP_Circle
;;;2405   }
0000bc  e8bd8ffe          POP      {r1-r11,pc}
;;;2406   /* End Function:RMP_Round_Rect ***********************************************/
                          ENDP


                          AREA ||i.RMP_Save_Ctx||, CODE, READONLY, ALIGN=1

                  RMP_Save_Ctx PROC
;;;1546   #if(RMP_USE_HOOKS==RMP_FALSE)
;;;1547   void RMP_Save_Ctx(void)
000000  4770              BX       lr
;;;1548   {
;;;1549       return;
;;;1550   }
;;;1551   #endif
                          ENDP


                          AREA ||i.RMP_Sem_Abort||, CODE, READONLY, ALIGN=1

                  RMP_Sem_Abort PROC
;;;1374   ******************************************************************************/
;;;1375   ret_t RMP_Sem_Abort(volatile struct RMP_Thd* Thread)
000000  b570              PUSH     {r4-r6,lr}
;;;1376   {
000002  0004              MOVS     r4,r0
;;;1377       /* Check if this thread structure could possibly be in use */
;;;1378       if(Thread==0)
;;;1379           return RMP_ERR_THD;
000004  f04f35ff          MOV      r5,#0xffffffff
000008  d011              BEQ      |L41.46|
;;;1380   
;;;1381       RMP_Lock_Sched();
00000a  f7fffffe          BL       RMP_Lock_Sched
;;;1382       
;;;1383       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
00000e  69a0              LDR      r0,[r4,#0x18]
000010  f0100fff          TST      r0,#0xff
000014  d00d              BEQ      |L41.50|
;;;1384       {
;;;1385           RMP_Unlock_Sched();
;;;1386           return RMP_ERR_THD;
;;;1387       }
;;;1388       
;;;1389       /* Is it waiting on a semaphore? If no, we abort and return an error code */
;;;1390       if((RMP_THD_STATE(Thread->State)!=RMP_THD_SEMBLK)&&
000016  69a0              LDR      r0,[r4,#0x18]
000018  b2c0              UXTB     r0,r0
00001a  2807              CMP      r0,#7
00001c  d00c              BEQ      |L41.56|
;;;1391          (RMP_THD_STATE(Thread->State)!=RMP_THD_SEMDLY))
00001e  69a0              LDR      r0,[r4,#0x18]
000020  b2c0              UXTB     r0,r0
000022  2808              CMP      r0,#8
000024  d008              BEQ      |L41.56|
;;;1392       {
;;;1393           RMP_Unlock_Sched();
000026  f7fffffe          BL       RMP_Unlock_Sched
;;;1394           return RMP_ERR_STATE;
00002a  00a8              LSLS     r0,r5,#2
;;;1395       }
;;;1396   
;;;1397       /* Waiting for a semaphore. We abort it and return */
;;;1398       RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1399       if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1400           RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1401       
;;;1402       RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1403   
;;;1404       /* Only when when this thread is not suspended do we change it back */
;;;1405       if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;1406           _RMP_Set_Rdy(Thread);
;;;1407       
;;;1408       Thread->Retval=RMP_ERR_OPER;
;;;1409       
;;;1410       RMP_Unlock_Sched();
;;;1411   
;;;1412       return 0;
;;;1413   }
00002c  bd70              POP      {r4-r6,pc}
                  |L41.46|
00002e  4628              MOV      r0,r5                 ;1379
000030  bd70              POP      {r4-r6,pc}
                  |L41.50|
000032  f7fffffe          BL       RMP_Unlock_Sched
000036  e7fa              B        |L41.46|
                  |L41.56|
000038  6820              LDR      r0,[r4,#0]            ;1398
00003a  6861              LDR      r1,[r4,#4]            ;1398
00003c  6008              STR      r0,[r1,#0]            ;1398
00003e  6041              STR      r1,[r0,#4]            ;1398
000040  69a0              LDR      r0,[r4,#0x18]         ;1399
000042  b2c0              UXTB     r0,r0                 ;1399
000044  2808              CMP      r0,#8                 ;1399
000046  d103              BNE      |L41.80|
000048  68a1              LDR      r1,[r4,#8]            ;1400
00004a  68e0              LDR      r0,[r4,#0xc]          ;1400
00004c  6001              STR      r1,[r0,#0]            ;1400
00004e  6048              STR      r0,[r1,#4]            ;1400
                  |L41.80|
000050  69a0              LDR      r0,[r4,#0x18]         ;1402
000052  f02000ff          BIC      r0,r0,#0xff           ;1402
000056  1c40              ADDS     r0,r0,#1              ;1402
000058  61a0              STR      r0,[r4,#0x18]         ;1402
00005a  69a0              LDR      r0,[r4,#0x18]         ;1405
00005c  05c0              LSLS     r0,r0,#23             ;1405
00005e  d402              BMI      |L41.102|
000060  4620              MOV      r0,r4                 ;1406
000062  f7fffffe          BL       _RMP_Set_Rdy
                  |L41.102|
000066  f06f0004          MVN      r0,#4                 ;1408
00006a  63a0              STR      r0,[r4,#0x38]         ;1408
00006c  f7fffffe          BL       RMP_Unlock_Sched
000070  2000              MOVS     r0,#0                 ;1412
000072  bd70              POP      {r4-r6,pc}
;;;1414   /* End Function:RMP_Sem_Abort ************************************************/
                          ENDP


                          AREA ||i.RMP_Sem_Crt||, CODE, READONLY, ALIGN=1

                  RMP_Sem_Crt PROC
;;;1232   ******************************************************************************/
;;;1233   ret_t RMP_Sem_Crt(volatile struct RMP_Sem* Semaphore, ptr_t Number)
000000  b570              PUSH     {r4-r6,lr}
;;;1234   {
000002  0004              MOVS     r4,r0
000004  460d              MOV      r5,r1
;;;1235       /* Check if this semaphore structure could possibly be in use */
;;;1236       if(Semaphore==0)
;;;1237           return RMP_ERR_SEM;
000006  f06f0605          MVN      r6,#5
00000a  d005              BEQ      |L42.24|
;;;1238       
;;;1239       RMP_Lock_Sched();
00000c  f7fffffe          BL       RMP_Lock_Sched
;;;1240       
;;;1241       if(Semaphore->State!=RMP_SEM_FREE)
000010  68a0              LDR      r0,[r4,#8]
000012  b118              CBZ      r0,|L42.28|
;;;1242       {
;;;1243           RMP_Unlock_Sched();
000014  f7fffffe          BL       RMP_Unlock_Sched
                  |L42.24|
000018  4630              MOV      r0,r6                 ;1237
;;;1244           return RMP_ERR_SEM;
;;;1245       }
;;;1246       
;;;1247       /* Is the number too great to initialize? */
;;;1248       if(Number>=RMP_SEM_MAX_NUM)
;;;1249       {
;;;1250           RMP_Unlock_Sched();
;;;1251           return RMP_ERR_OPER;
;;;1252       }
;;;1253   
;;;1254       /* Initialize contents */
;;;1255       Semaphore->Cur_Num=Number;
;;;1256       Semaphore->State=RMP_SEM_USED;
;;;1257       RMP_List_Crt(&(Semaphore->Wait_List));
;;;1258       
;;;1259       RMP_Unlock_Sched();
;;;1260       
;;;1261       return 0;
;;;1262   }
00001a  bd70              POP      {r4-r6,pc}
                  |L42.28|
00001c  f5b57f7a          CMP      r5,#0x3e8             ;1248
000020  d304              BCC      |L42.44|
000022  f7fffffe          BL       RMP_Unlock_Sched
000026  f06f0004          MVN      r0,#4                 ;1251
00002a  bd70              POP      {r4-r6,pc}
                  |L42.44|
00002c  2001              MOVS     r0,#1                 ;1256
00002e  60e5              STR      r5,[r4,#0xc]          ;1255
000030  60a0              STR      r0,[r4,#8]            ;1256
000032  6024              STR      r4,[r4,#0]            ;1256
000034  6064              STR      r4,[r4,#4]            ;1256
000036  f7fffffe          BL       RMP_Unlock_Sched
00003a  2000              MOVS     r0,#0                 ;1261
00003c  bd70              POP      {r4-r6,pc}
;;;1263   /* End Function:RMP_Sem_Crt **************************************************/
                          ENDP


                          AREA ||i.RMP_Sem_Del||, CODE, READONLY, ALIGN=1

                  RMP_Sem_Del PROC
;;;1270   ******************************************************************************/
;;;1271   ret_t RMP_Sem_Del(volatile struct RMP_Sem* Semaphore)
000000  b570              PUSH     {r4-r6,lr}
;;;1272   {
000002  0005              MOVS     r5,r0
;;;1273       struct RMP_Thd* Thread;
;;;1274       
;;;1275       /* Check if this semaphore structure could possibly be in use */
;;;1276       if(Semaphore==0)
;;;1277           return RMP_ERR_SEM;
000004  f06f0405          MVN      r4,#5
000008  d006              BEQ      |L43.24|
;;;1278       
;;;1279       RMP_Lock_Sched();
00000a  f7fffffe          BL       RMP_Lock_Sched
;;;1280       
;;;1281       if(Semaphore->State!=RMP_SEM_USED)
00000e  68a8              LDR      r0,[r5,#8]
000010  2801              CMP      r0,#1
000012  d01c              BEQ      |L43.78|
;;;1282       {
;;;1283           RMP_Unlock_Sched();
000014  f7fffffe          BL       RMP_Unlock_Sched
                  |L43.24|
000018  4620              MOV      r0,r4                 ;1277
;;;1284           return RMP_ERR_SEM;
;;;1285       }
;;;1286   
;;;1287       /* Get rid of all guys waiting on it */
;;;1288       while(&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)
;;;1289       {
;;;1290           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
;;;1291           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1292           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1293               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1294   
;;;1295           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1296   
;;;1297           /* Is it suspended? If yes, we can't directly send it running */
;;;1298           if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;1299              _RMP_Set_Rdy(Thread);
;;;1300           
;;;1301           Thread->Retval=RMP_ERR_OPER;
;;;1302       }
;;;1303       Semaphore->State=RMP_SEM_FREE;
;;;1304       
;;;1305       RMP_Unlock_Sched();
;;;1306   
;;;1307       return 0;
;;;1308   }
00001a  bd70              POP      {r4-r6,pc}
                  |L43.28|
00001c  686c              LDR      r4,[r5,#4]            ;1290
00001e  e9d40100          LDRD     r0,r1,[r4,#0]         ;1290
000022  6008              STR      r0,[r1,#0]            ;1290
000024  6041              STR      r1,[r0,#4]            ;1290
000026  7e20              LDRB     r0,[r4,#0x18]         ;1292
000028  2808              CMP      r0,#8                 ;1292
00002a  d103              BNE      |L43.52|
00002c  e9d40102          LDRD     r0,r1,[r4,#8]         ;1292
000030  6008              STR      r0,[r1,#0]            ;1292
000032  6041              STR      r1,[r0,#4]            ;1292
                  |L43.52|
000034  69a0              LDR      r0,[r4,#0x18]         ;1295
000036  f02000ff          BIC      r0,r0,#0xff           ;1295
00003a  1c40              ADDS     r0,r0,#1              ;1295
00003c  61a0              STR      r0,[r4,#0x18]         ;1298
00003e  05c1              LSLS     r1,r0,#23             ;1298
000040  d402              BMI      |L43.72|
000042  4620              MOV      r0,r4                 ;1299
000044  f7fffffe          BL       _RMP_Set_Rdy
                  |L43.72|
000048  f06f0004          MVN      r0,#4                 ;1301
00004c  63a0              STR      r0,[r4,#0x38]         ;1301
                  |L43.78|
00004e  6868              LDR      r0,[r5,#4]            ;1288
000050  42a8              CMP      r0,r5                 ;1288
000052  d1e3              BNE      |L43.28|
000054  2000              MOVS     r0,#0                 ;1303
000056  60a8              STR      r0,[r5,#8]            ;1303
000058  f7fffffe          BL       RMP_Unlock_Sched
00005c  2000              MOVS     r0,#0                 ;1307
00005e  bd70              POP      {r4-r6,pc}
;;;1309   /* End Function:RMP_Sem_Del **************************************************/
                          ENDP


                          AREA ||i.RMP_Sem_Pend||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Pend PROC
;;;1317   ******************************************************************************/
;;;1318   ret_t RMP_Sem_Pend(volatile struct RMP_Sem* Semaphore, ptr_t Slices)
000000  b570              PUSH     {r4-r6,lr}
;;;1319   {
000002  0005              MOVS     r5,r0
000004  460e              MOV      r6,r1
;;;1320       /* Check if this semaphore structure could possibly be in use */
;;;1321       if(Semaphore==0)
;;;1322           return RMP_ERR_SEM;
000006  f06f0405          MVN      r4,#5
00000a  d006              BEQ      |L44.26|
;;;1323       
;;;1324       RMP_Lock_Sched();
00000c  f7fffffe          BL       RMP_Lock_Sched
;;;1325       
;;;1326       if(Semaphore->State!=RMP_SEM_USED)
000010  68a8              LDR      r0,[r5,#8]
000012  2801              CMP      r0,#1
000014  d003              BEQ      |L44.30|
;;;1327       {
;;;1328           RMP_Unlock_Sched();
000016  f7fffffe          BL       RMP_Unlock_Sched
                  |L44.26|
00001a  4620              MOV      r0,r4                 ;1322
;;;1329           return RMP_ERR_SEM;
;;;1330       }
;;;1331       
;;;1332       /* Check if we can get one immediately */
;;;1333       if(Semaphore->Cur_Num!=0)
;;;1334       {
;;;1335           Semaphore->Cur_Num--;
;;;1336           RMP_Unlock_Sched();
;;;1337           return Semaphore->Cur_Num;
;;;1338       }
;;;1339       else
;;;1340       {
;;;1341           /* Cannot get one, we need to block */
;;;1342           if(Slices==0)
;;;1343           {
;;;1344               RMP_Unlock_Sched();
;;;1345               return RMP_ERR_OPER;
;;;1346           }
;;;1347   
;;;1348           /* We must be running - place into waitlist now */
;;;1349           _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1350           RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),Semaphore->Wait_List.Prev,&(Semaphore->Wait_List));
;;;1351           
;;;1352           if(Slices<RMP_MAX_SLICES)
;;;1353           {
;;;1354               _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1355               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SEMDLY);
;;;1356           }
;;;1357           else
;;;1358               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SEMBLK);
;;;1359           
;;;1360           RMP_Cur_Thd->Retval=0;
;;;1361       }
;;;1362       
;;;1363       RMP_Unlock_Sched();
;;;1364   
;;;1365       return RMP_Cur_Thd->Retval;
;;;1366   }
00001c  bd70              POP      {r4-r6,pc}
                  |L44.30|
00001e  68e8              LDR      r0,[r5,#0xc]          ;1333
000020  b130              CBZ      r0,|L44.48|
000022  68e8              LDR      r0,[r5,#0xc]          ;1335
000024  1e40              SUBS     r0,r0,#1              ;1335
000026  60e8              STR      r0,[r5,#0xc]          ;1335
000028  f7fffffe          BL       RMP_Unlock_Sched
00002c  68e8              LDR      r0,[r5,#0xc]          ;1337
00002e  bd70              POP      {r4-r6,pc}
                  |L44.48|
000030  b1be              CBZ      r6,|L44.98|
000032  4c16              LDR      r4,|L44.140|
000034  69a0              LDR      r0,[r4,#0x18]         ;1349  ; RMP_Cur_Thd
000036  f7fffffe          BL       _RMP_Clr_Rdy
00003a  6829              LDR      r1,[r5,#0]            ;1350
00003c  462a              MOV      r2,r5                 ;1350
00003e  69a0              LDR      r0,[r4,#0x18]         ;1350  ; RMP_Cur_Thd
000040  f7fffffe          BL       RMP_List_Ins
000044  4812              LDR      r0,|L44.144|
000046  4286              CMP      r6,r0                 ;1352
000048  d210              BCS      |L44.108|
00004a  69a0              LDR      r0,[r4,#0x18]         ;1354  ; RMP_Cur_Thd
00004c  4631              MOV      r1,r6                 ;1354
00004e  f7fffffe          BL       _RMP_Dly_Ins
000052  69a0              LDR      r0,[r4,#0x18]         ;1355  ; RMP_Cur_Thd
000054  69a1              LDR      r1,[r4,#0x18]         ;1355  ; RMP_Cur_Thd
000056  6980              LDR      r0,[r0,#0x18]         ;1355
000058  f02000ff          BIC      r0,r0,#0xff           ;1355
00005c  f0400008          ORR      r0,r0,#8              ;1355
000060  e00a              B        |L44.120|
                  |L44.98|
000062  f7fffffe          BL       RMP_Unlock_Sched
000066  f06f0004          MVN      r0,#4                 ;1345
00006a  bd70              POP      {r4-r6,pc}
                  |L44.108|
00006c  69a0              LDR      r0,[r4,#0x18]         ;1358  ; RMP_Cur_Thd
00006e  69a1              LDR      r1,[r4,#0x18]         ;1358  ; RMP_Cur_Thd
000070  6980              LDR      r0,[r0,#0x18]         ;1358
000072  f02000ff          BIC      r0,r0,#0xff           ;1358
000076  1dc0              ADDS     r0,r0,#7              ;1358
                  |L44.120|
000078  6188              STR      r0,[r1,#0x18]         ;1360
00007a  69a1              LDR      r1,[r4,#0x18]         ;1360  ; RMP_Cur_Thd
00007c  2000              MOVS     r0,#0                 ;1360
00007e  6388              STR      r0,[r1,#0x38]         ;1363
000080  f7fffffe          BL       RMP_Unlock_Sched
000084  69a0              LDR      r0,[r4,#0x18]         ;1365  ; RMP_Cur_Thd
000086  6b80              LDR      r0,[r0,#0x38]         ;1365
000088  bd70              POP      {r4-r6,pc}
;;;1367   /* End Function:RMP_Sem_Pend *************************************************/
                          ENDP

00008a  0000              DCW      0x0000
                  |L44.140|
                          DCD      ||.data||
                  |L44.144|
                          DCD      0x000186a0

                          AREA ||i.RMP_Sem_Post||, CODE, READONLY, ALIGN=1

                  RMP_Sem_Post PROC
;;;1424   ******************************************************************************/
;;;1425   ret_t RMP_Sem_Post(volatile struct RMP_Sem* Semaphore, ptr_t Number)
000000  b570              PUSH     {r4-r6,lr}
;;;1426   {
000002  0004              MOVS     r4,r0
000004  460d              MOV      r5,r1
;;;1427       struct RMP_Thd* Thread;
;;;1428       
;;;1429       /* Check if this semaphore structure could possibly be in use */
;;;1430       if((Semaphore==0)||(Number==0))
;;;1431           return RMP_ERR_SEM;
000006  f06f0605          MVN      r6,#5
00000a  d007              BEQ      |L45.28|
00000c  b135              CBZ      r5,|L45.28|
;;;1432       
;;;1433       RMP_Lock_Sched();
00000e  f7fffffe          BL       RMP_Lock_Sched
;;;1434       
;;;1435       if(Semaphore->State!=RMP_SEM_USED)
000012  68a0              LDR      r0,[r4,#8]
000014  2801              CMP      r0,#1
000016  d003              BEQ      |L45.32|
;;;1436       {
;;;1437           RMP_Unlock_Sched();
000018  f7fffffe          BL       RMP_Unlock_Sched
                  |L45.28|
00001c  4630              MOV      r0,r6                 ;1431
;;;1438           return RMP_ERR_SEM;
;;;1439       }
;;;1440       
;;;1441       /* Would the maximum value be exceeded if this is posted? */
;;;1442       if((Semaphore->Cur_Num+Number)>=RMP_SEM_MAX_NUM)
;;;1443       {
;;;1444           RMP_Unlock_Sched();
;;;1445           return RMP_ERR_OPER;
;;;1446       }
;;;1447       
;;;1448       Semaphore->Cur_Num+=Number;
;;;1449       /* Is there any thread waiting on it? If there are, clean them up*/
;;;1450       while((&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)&&(Semaphore->Cur_Num!=0))
;;;1451       {
;;;1452           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
;;;1453           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1454           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1455               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1456           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1457   
;;;1458           /* Only when when this thread is not suspended do we change it back */
;;;1459           if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;1460               _RMP_Set_Rdy(Thread);
;;;1461   
;;;1462           /* Finally, return success */
;;;1463           Thread->Retval=0;
;;;1464           Semaphore->Cur_Num--;
;;;1465       }
;;;1466   
;;;1467       RMP_Unlock_Sched();
;;;1468   
;;;1469       return 0;
;;;1470   }
00001e  bd70              POP      {r4-r6,pc}
                  |L45.32|
000020  68e0              LDR      r0,[r4,#0xc]          ;1442
000022  4428              ADD      r0,r0,r5              ;1442
000024  f5b07f7a          CMP      r0,#0x3e8             ;1442
000028  d304              BCC      |L45.52|
00002a  f7fffffe          BL       RMP_Unlock_Sched
00002e  f06f0004          MVN      r0,#4                 ;1445
000032  bd70              POP      {r4-r6,pc}
                  |L45.52|
000034  68e0              LDR      r0,[r4,#0xc]          ;1448
000036  4428              ADD      r0,r0,r5              ;1448
000038  e019              B        |L45.110|
                  |L45.58|
00003a  6865              LDR      r5,[r4,#4]            ;1452
00003c  e9d50100          LDRD     r0,r1,[r5,#0]         ;1452
000040  6008              STR      r0,[r1,#0]            ;1452
000042  6041              STR      r1,[r0,#4]            ;1452
000044  7e28              LDRB     r0,[r5,#0x18]         ;1454
000046  2808              CMP      r0,#8                 ;1454
000048  d103              BNE      |L45.82|
00004a  e9d50102          LDRD     r0,r1,[r5,#8]         ;1454
00004e  6008              STR      r0,[r1,#0]            ;1454
000050  6041              STR      r1,[r0,#4]            ;1454
                  |L45.82|
000052  69a8              LDR      r0,[r5,#0x18]         ;1456
000054  f02000ff          BIC      r0,r0,#0xff           ;1456
000058  1c40              ADDS     r0,r0,#1              ;1456
00005a  61a8              STR      r0,[r5,#0x18]         ;1459
00005c  05c1              LSLS     r1,r0,#23             ;1459
00005e  d402              BMI      |L45.102|
000060  4628              MOV      r0,r5                 ;1460
000062  f7fffffe          BL       _RMP_Set_Rdy
                  |L45.102|
000066  2000              MOVS     r0,#0                 ;1463
000068  63a8              STR      r0,[r5,#0x38]         ;1464
00006a  68e0              LDR      r0,[r4,#0xc]          ;1464
00006c  1e40              SUBS     r0,r0,#1              ;1464
                  |L45.110|
00006e  60e0              STR      r0,[r4,#0xc]          ;1448
000070  6860              LDR      r0,[r4,#4]            ;1450
000072  42a0              CMP      r0,r4                 ;1450
000074  d002              BEQ      |L45.124|
000076  68e0              LDR      r0,[r4,#0xc]          ;1450
000078  2800              CMP      r0,#0                 ;1450
00007a  d1de              BNE      |L45.58|
                  |L45.124|
00007c  f7fffffe          BL       RMP_Unlock_Sched
000080  2000              MOVS     r0,#0                 ;1469
000082  bd70              POP      {r4-r6,pc}
;;;1471   /* End Function:RMP_Sem_Post *************************************************/
                          ENDP


                          AREA ||i.RMP_Sem_Post_ISR||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Post_ISR PROC
;;;1479   ******************************************************************************/
;;;1480   ret_t RMP_Sem_Post_ISR(volatile struct RMP_Sem* Semaphore, ptr_t Number)
000000  b570              PUSH     {r4-r6,lr}
;;;1481   {
000002  0004              MOVS     r4,r0
;;;1482       struct RMP_Thd* Thread;
;;;1483       /* Check if this semaphore structure could possibly be in use */
;;;1484       if((Semaphore==0)||(Number==0))
;;;1485           return RMP_ERR_SEM;
000004  f06f0005          MVN      r0,#5
000008  d03a              BEQ      |L46.128|
00000a  2900              CMP      r1,#0                 ;1484
00000c  d038              BEQ      |L46.128|
;;;1486       
;;;1487       if(Semaphore->State!=RMP_SEM_USED)
00000e  68a2              LDR      r2,[r4,#8]
000010  2a01              CMP      r2,#1
000012  d135              BNE      |L46.128|
;;;1488           return RMP_ERR_SEM;
;;;1489   
;;;1490       if(RMP_Sched_Locked!=0)
000014  4e1b              LDR      r6,|L46.132|
;;;1491           return RMP_ERR_OPER;
000016  1c40              ADDS     r0,r0,#1
000018  68f2              LDR      r2,[r6,#0xc]          ;1490  ; RMP_Sched_Locked
00001a  2a00              CMP      r2,#0                 ;1490
00001c  d130              BNE      |L46.128|
;;;1492   
;;;1493       /* Would the maximum value be exceeded if this is posted? */
;;;1494       if((Semaphore->Cur_Num+Number)>=RMP_SEM_MAX_NUM)
00001e  68e2              LDR      r2,[r4,#0xc]
000020  440a              ADD      r2,r2,r1
000022  f5b27f7a          CMP      r2,#0x3e8
000026  d22b              BCS      |L46.128|
;;;1495           return RMP_ERR_OPER;
;;;1496       
;;;1497       Semaphore->Cur_Num+=Number;
000028  68e0              LDR      r0,[r4,#0xc]
00002a  4408              ADD      r0,r0,r1
;;;1498       /* Is there any thread waiting on it? If there are, clean them up*/
;;;1499       while((&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)&&(Semaphore->Cur_Num!=0))
00002c  e020              B        |L46.112|
                  |L46.46|
;;;1500       {
;;;1501           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
00002e  6865              LDR      r5,[r4,#4]
000030  e9d50100          LDRD     r0,r1,[r5,#0]
000034  6008              STR      r0,[r1,#0]
000036  6041              STR      r1,[r0,#4]
;;;1502           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1503           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
000038  7e28              LDRB     r0,[r5,#0x18]
00003a  2808              CMP      r0,#8
00003c  d103              BNE      |L46.70|
00003e  e9d50102          LDRD     r0,r1,[r5,#8]
000042  6008              STR      r0,[r1,#0]
000044  6041              STR      r1,[r0,#4]
                  |L46.70|
;;;1504               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1505           
;;;1506           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
000046  69a8              LDR      r0,[r5,#0x18]
000048  f02000ff          BIC      r0,r0,#0xff
00004c  1c40              ADDS     r0,r0,#1
;;;1507   
;;;1508           /* Only when when this thread is not suspended do we change it back */
;;;1509           if((Thread->State&RMP_THD_SUSPENDED)==0)
00004e  61a8              STR      r0,[r5,#0x18]
000050  05c1              LSLS     r1,r0,#23
000052  d409              BMI      |L46.104|
;;;1510           {
;;;1511               _RMP_Set_Rdy(Thread);
000054  4628              MOV      r0,r5
000056  f7fffffe          BL       _RMP_Set_Rdy
;;;1512               if(Thread->Prio>RMP_Cur_Thd->Prio)
00005a  69b1              LDR      r1,[r6,#0x18]  ; RMP_Cur_Thd
00005c  6a68              LDR      r0,[r5,#0x24]
00005e  6a49              LDR      r1,[r1,#0x24]
000060  4288              CMP      r0,r1
000062  d901              BLS      |L46.104|
;;;1513                   _RMP_Yield();
000064  f7fffffe          BL       _RMP_Yield
                  |L46.104|
;;;1514           }
;;;1515   
;;;1516           /* Finally, return success */
;;;1517           Thread->Retval=0;
000068  2000              MOVS     r0,#0
;;;1518           Semaphore->Cur_Num--;
00006a  63a8              STR      r0,[r5,#0x38]
00006c  68e0              LDR      r0,[r4,#0xc]
00006e  1e40              SUBS     r0,r0,#1
                  |L46.112|
000070  60e0              STR      r0,[r4,#0xc]          ;1497
000072  6860              LDR      r0,[r4,#4]            ;1499
000074  42a0              CMP      r0,r4                 ;1499
000076  d002              BEQ      |L46.126|
000078  68e0              LDR      r0,[r4,#0xc]          ;1499
00007a  2800              CMP      r0,#0                 ;1499
00007c  d1d7              BNE      |L46.46|
                  |L46.126|
;;;1519       }
;;;1520   
;;;1521       return 0;
00007e  2000              MOVS     r0,#0
                  |L46.128|
;;;1522   }
000080  bd70              POP      {r4-r6,pc}
;;;1523   /* End Function:RMP_Sem_Post_ISR *********************************************/
                          ENDP

000082  0000              DCW      0x0000
                  |L46.132|
                          DCD      ||.data||

                          AREA ||i.RMP_Start_Hook||, CODE, READONLY, ALIGN=1

                  RMP_Start_Hook PROC
;;;1532   #if(RMP_USE_HOOKS==RMP_FALSE)
;;;1533   void RMP_Start_Hook(void)
000000  4770              BX       lr
;;;1534   {
;;;1535       return;
;;;1536   }
;;;1537   #endif
                          ENDP


                          AREA ||i.RMP_Thd_Cancel||, CODE, READONLY, ALIGN=1

                  RMP_Thd_Cancel PROC
;;;1194   ******************************************************************************/
;;;1195   ret_t RMP_Thd_Cancel(volatile struct RMP_Thd* Thread)
000000  b510              PUSH     {r4,lr}
;;;1196   {
000002  0004              MOVS     r4,r0
000004  d00a              BEQ      |L48.28|
;;;1197       /* Check if this thread structure could possibly be in use */
;;;1198       if(Thread==0)
;;;1199           return RMP_ERR_THD;
;;;1200       
;;;1201       RMP_Lock_Sched();
000006  f7fffffe          BL       RMP_Lock_Sched
;;;1202       
;;;1203       /* Is it delayed? */
;;;1204       if(RMP_THD_STATE(Thread->State)!=RMP_THD_DELAYED)
00000a  69a0              LDR      r0,[r4,#0x18]
00000c  b2c0              UXTB     r0,r0
00000e  2806              CMP      r0,#6
000010  d007              BEQ      |L48.34|
;;;1205       {
;;;1206           RMP_Unlock_Sched();
000012  f7fffffe          BL       RMP_Unlock_Sched
;;;1207           return RMP_ERR_STATE;
000016  f06f0003          MVN      r0,#3
;;;1208       }
;;;1209   
;;;1210       /* Delete it from the delay list */
;;;1211       RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1212       RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1213       
;;;1214       /* Only when when this thread is not suspended do we change it back */
;;;1215       if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;1216           _RMP_Set_Rdy(Thread);
;;;1217       
;;;1218       Thread->Retval=RMP_ERR_OPER;
;;;1219       
;;;1220       RMP_Unlock_Sched();
;;;1221   
;;;1222       return 0;
;;;1223   }
00001a  bd10              POP      {r4,pc}
                  |L48.28|
00001c  f04f30ff          MOV      r0,#0xffffffff        ;1199
000020  bd10              POP      {r4,pc}
                  |L48.34|
000022  68a0              LDR      r0,[r4,#8]            ;1211
000024  68e1              LDR      r1,[r4,#0xc]          ;1211
000026  6008              STR      r0,[r1,#0]            ;1211
000028  6041              STR      r1,[r0,#4]            ;1211
00002a  69a0              LDR      r0,[r4,#0x18]         ;1212
00002c  f02000ff          BIC      r0,r0,#0xff           ;1212
000030  1c40              ADDS     r0,r0,#1              ;1212
000032  61a0              STR      r0,[r4,#0x18]         ;1212
000034  69a0              LDR      r0,[r4,#0x18]         ;1215
000036  05c0              LSLS     r0,r0,#23             ;1215
000038  d402              BMI      |L48.64|
00003a  4620              MOV      r0,r4                 ;1216
00003c  f7fffffe          BL       _RMP_Set_Rdy
                  |L48.64|
000040  f06f0004          MVN      r0,#4                 ;1218
000044  63a0              STR      r0,[r4,#0x38]         ;1218
000046  f7fffffe          BL       RMP_Unlock_Sched
00004a  2000              MOVS     r0,#0                 ;1222
00004c  bd10              POP      {r4,pc}
;;;1224   /* End Function:RMP_Thd_Cancel ***********************************************/
                          ENDP


                          AREA ||i.RMP_Thd_Crt||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Crt PROC
;;;674    ******************************************************************************/
;;;675    ret_t RMP_Thd_Crt(volatile struct RMP_Thd* Thread, void* Entry, void* Stack, void* Arg, ptr_t Prio, ptr_t Slices)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;676    {
000004  4699              MOV      r9,r3
000006  4690              MOV      r8,r2
000008  468a              MOV      r10,r1
00000a  4604              MOV      r4,r0
00000c  e9dd6508          LDRD     r6,r5,[sp,#0x20]
;;;677        /* Check if the priority and timeslice range is correct */
;;;678        if(Prio>=RMP_MAX_PREEMPT_PRIO)
000010  2e20              CMP      r6,#0x20
000012  d303              BCC      |L49.28|
;;;679            return RMP_ERR_PRIO;
000014  f06f0001          MVN      r0,#1
                  |L49.24|
;;;680        if((Slices==0)||(Slices>=RMP_MAX_SLICES))
;;;681            return RMP_ERR_SLICE;
;;;682        
;;;683        /* Check if this thread structure could possibly be in use */
;;;684        if(Thread==0)
;;;685            return RMP_ERR_THD;
;;;686        
;;;687        RMP_Lock_Sched();
;;;688        
;;;689        if(RMP_THD_STATE(Thread->State)!=RMP_THD_FREE)
;;;690        {
;;;691            RMP_Unlock_Sched();
;;;692            return RMP_ERR_THD;
;;;693        }
;;;694        
;;;695        /* Create the thread and insert it into the list */
;;;696        Thread->Prio=Prio;
;;;697        Thread->Slices=Slices;
;;;698        Thread->Slices_Left=Slices;
;;;699        Thread->Stack=(ptr_t)Stack;
;;;700        
;;;701        /* Initialize its stack and sending list */
;;;702        _RMP_Stack_Init((ptr_t)Entry, (ptr_t)Stack, (ptr_t)Arg);
;;;703        RMP_List_Crt(&(Thread->Snd_List));
;;;704        
;;;705        /* Notify the scheduler that we have created something new, also check locks */
;;;706        Thread->State=RMP_THD_RUNNING;
;;;707        _RMP_Set_Rdy(Thread);
;;;708        
;;;709        RMP_Unlock_Sched();
;;;710    
;;;711        return 0;
;;;712    }
000018  e8bd87f0          POP      {r4-r10,pc}
                  |L49.28|
00001c  b115              CBZ      r5,|L49.36|
00001e  4815              LDR      r0,|L49.116|
000020  4285              CMP      r5,r0                 ;680
000022  d302              BCC      |L49.42|
                  |L49.36|
000024  f06f0002          MVN      r0,#2                 ;681
000028  e7f6              B        |L49.24|
                  |L49.42|
00002a  f04f37ff          MOV      r7,#0xffffffff        ;685
00002e  b13c              CBZ      r4,|L49.64|
000030  f7fffffe          BL       RMP_Lock_Sched
000034  69a0              LDR      r0,[r4,#0x18]         ;689
000036  f0100fff          TST      r0,#0xff              ;689
00003a  d003              BEQ      |L49.68|
00003c  f7fffffe          BL       RMP_Unlock_Sched
                  |L49.64|
000040  4638              MOV      r0,r7                 ;685
000042  e7e9              B        |L49.24|
                  |L49.68|
000044  6266              STR      r6,[r4,#0x24]         ;696
000046  61e5              STR      r5,[r4,#0x1c]         ;697
000048  6225              STR      r5,[r4,#0x20]         ;698
00004a  f8c48034          STR      r8,[r4,#0x34]         ;699
00004e  464a              MOV      r2,r9                 ;702
000050  4641              MOV      r1,r8                 ;702
000052  4650              MOV      r0,r10                ;702
000054  f7fffffe          BL       _RMP_Stack_Init
000058  f1040010          ADD      r0,r4,#0x10           ;703
00005c  6120              STR      r0,[r4,#0x10]         ;703
00005e  6160              STR      r0,[r4,#0x14]         ;703
000060  2001              MOVS     r0,#1                 ;706
000062  61a0              STR      r0,[r4,#0x18]         ;706
000064  4620              MOV      r0,r4                 ;707
000066  f7fffffe          BL       _RMP_Set_Rdy
00006a  f7fffffe          BL       RMP_Unlock_Sched
00006e  2000              MOVS     r0,#0                 ;711
000070  e7d2              B        |L49.24|
;;;713    /* End Function:RMP_Thd_Crt **************************************************/
                          ENDP

000072  0000              DCW      0x0000
                  |L49.116|
                          DCD      0x000186a0

                          AREA ||i.RMP_Thd_Del||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Del PROC
;;;720    ******************************************************************************/
;;;721    ret_t RMP_Thd_Del(volatile struct RMP_Thd* Thread)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;722    {
000004  0004              MOVS     r4,r0
;;;723        struct RMP_Thd* Release;
;;;724        ptr_t Self_Del;
;;;725        
;;;726        /* Check if this thread structure could possibly be in use */
;;;727        if(Thread==0)
;;;728            return RMP_ERR_THD;
000006  f04f35ff          MOV      r5,#0xffffffff
00000a  d014              BEQ      |L50.54|
;;;729        
;;;730        RMP_Lock_Sched();
00000c  f7fffffe          BL       RMP_Lock_Sched
;;;731        
;;;732        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
000010  69a0              LDR      r0,[r4,#0x18]
;;;733        {
;;;734            RMP_Unlock_Sched();
;;;735            return RMP_ERR_THD;
;;;736        }
;;;737        
;;;738        /* See if anyone waiting to send to this thread. If there is, release all these threads */
;;;739        while(&(Thread->Snd_List)!=Thread->Snd_List.Next)
;;;740        {
;;;741            Release=(struct RMP_Thd*)(Thread->Snd_List.Next);
;;;742            RMP_List_Del(Release->Run_Head.Prev,Release->Run_Head.Next);
;;;743            if(RMP_THD_STATE(Release->State)==RMP_THD_SNDDLY)
;;;744                RMP_List_Del(Release->Dly_Head.Prev,Release->Dly_Head.Next);
;;;745    
;;;746            RMP_THD_STATE_SET(Release->State,RMP_THD_RUNNING);
;;;747    
;;;748            /* Is it suspended? If yes, we can't directly send it running */
;;;749            if((Release->State&RMP_THD_SUSPENDED)==0)
;;;750               _RMP_Set_Rdy(Release);
;;;751            
;;;752            Release->Retval=RMP_ERR_OPER;
000012  1f2f              SUBS     r7,r5,#4
000014  f0100fff          TST      r0,#0xff              ;732
000018  d010              BEQ      |L50.60|
00001a  f1040610          ADD      r6,r4,#0x10           ;739
                  |L50.30|
00001e  6960              LDR      r0,[r4,#0x14]         ;739
000020  42b0              CMP      r0,r6                 ;739
000022  d01e              BEQ      |L50.98|
000024  6965              LDR      r5,[r4,#0x14]         ;741
000026  e9d50100          LDRD     r0,r1,[r5,#0]         ;741
00002a  6008              STR      r0,[r1,#0]            ;741
00002c  6041              STR      r1,[r0,#4]            ;741
00002e  7e28              LDRB     r0,[r5,#0x18]         ;743
000030  2803              CMP      r0,#3                 ;743
000032  d006              BEQ      |L50.66|
000034  e009              B        |L50.74|
                  |L50.54|
000036  4628              MOV      r0,r5                 ;728
                  |L50.56|
;;;753        }
;;;754        
;;;755        /* See what is it state */
;;;756        Self_Del=0;
;;;757        if(RMP_Cur_Thd==Thread)
;;;758            Self_Del=1;
;;;759        
;;;760        switch(RMP_THD_STATE(Thread->State))
;;;761        {
;;;762            case RMP_THD_RUNNING:
;;;763            {
;;;764                if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;765                    _RMP_Clr_Rdy(Thread);
;;;766                break;
;;;767            }
;;;768            
;;;769            case RMP_THD_SNDDLY:
;;;770            case RMP_THD_SEMDLY:
;;;771            {
;;;772                if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;773                    RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;774                RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;775                Thread->Retval=RMP_ERR_OPER;
;;;776                break;
;;;777            }
;;;778                
;;;779            case RMP_THD_RCVDLY:
;;;780            {
;;;781                RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;782                Thread->Retval=RMP_ERR_OPER;
;;;783                break;
;;;784            }
;;;785                
;;;786            case RMP_THD_DELAYED:
;;;787            {
;;;788                RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;789                Thread->Retval=RMP_ERR_OPER;
;;;790                break;
;;;791            }
;;;792            /* Should not get here */
;;;793            default:break;
;;;794        }
;;;795        Thread->State=RMP_THD_FREE;
;;;796        
;;;797        RMP_Unlock_Sched();
;;;798        
;;;799        /* If we are deleting ourself, just stop the execution here */
;;;800        if(Self_Del!=0)
;;;801            while(1);
;;;802    
;;;803        return 0;
;;;804    }
000038  e8bd81f0          POP      {r4-r8,pc}
                  |L50.60|
00003c  f7fffffe          BL       RMP_Unlock_Sched
000040  e7f9              B        |L50.54|
                  |L50.66|
000042  e9d50102          LDRD     r0,r1,[r5,#8]         ;735
000046  6008              STR      r0,[r1,#0]            ;735
000048  6041              STR      r1,[r0,#4]            ;735
                  |L50.74|
00004a  69a8              LDR      r0,[r5,#0x18]         ;746
00004c  f02000ff          BIC      r0,r0,#0xff           ;746
000050  1c40              ADDS     r0,r0,#1              ;746
000052  61a8              STR      r0,[r5,#0x18]         ;749
000054  05c1              LSLS     r1,r0,#23             ;749
000056  d402              BMI      |L50.94|
000058  4628              MOV      r0,r5                 ;750
00005a  f7fffffe          BL       _RMP_Set_Rdy
                  |L50.94|
00005e  63af              STR      r7,[r5,#0x38]         ;752
000060  e7dd              B        |L50.30|
                  |L50.98|
000062  4818              LDR      r0,|L50.196|
000064  6980              LDR      r0,[r0,#0x18]         ;757  ; RMP_Cur_Thd
000066  2500              MOVS     r5,#0                 ;756
000068  42a0              CMP      r0,r4                 ;757
00006a  d100              BNE      |L50.110|
00006c  2501              MOVS     r5,#1                 ;758
                  |L50.110|
00006e  69a0              LDR      r0,[r4,#0x18]         ;760
000070  b2c0              UXTB     r0,r0                 ;760
000072  2809              CMP      r0,#9                 ;760
000074  d219              BCS      |L50.170|
000076  e8dff000          TBB      [pc,r0]               ;760
00007a  1805              DCB      0x18,0x05
00007c  180c1813          DCB      0x18,0x0c,0x18,0x13
000080  1e180c00          DCB      0x1e,0x18,0x0c,0x00
000084  69a0              LDR      r0,[r4,#0x18]         ;764
000086  05c0              LSLS     r0,r0,#23             ;764
000088  d40f              BMI      |L50.170|
00008a  4620              MOV      r0,r4                 ;765
00008c  f7fffffe          BL       _RMP_Clr_Rdy
000090  e00b              B        |L50.170|
000092  69a0              LDR      r0,[r4,#0x18]         ;772
000094  05c0              LSLS     r0,r0,#23             ;772
000096  d403              BMI      |L50.160|
000098  6820              LDR      r0,[r4,#0]            ;773
00009a  6861              LDR      r1,[r4,#4]            ;773
00009c  6008              STR      r0,[r1,#0]            ;773
00009e  6041              STR      r1,[r0,#4]            ;773
                  |L50.160|
0000a0  68a0              LDR      r0,[r4,#8]            ;774
0000a2  68e1              LDR      r1,[r4,#0xc]          ;774
0000a4  6008              STR      r0,[r1,#0]            ;774
0000a6  6041              STR      r1,[r0,#4]            ;774
                  |L50.168|
0000a8  63a7              STR      r7,[r4,#0x38]         ;775
                  |L50.170|
0000aa  2000              MOVS     r0,#0                 ;795
0000ac  61a0              STR      r0,[r4,#0x18]         ;795
0000ae  f7fffffe          BL       RMP_Unlock_Sched
0000b2  b12d              CBZ      r5,|L50.192|
                  |L50.180|
0000b4  e7fe              B        |L50.180|
0000b6  68a1              LDR      r1,[r4,#8]            ;788
0000b8  68e0              LDR      r0,[r4,#0xc]          ;788
0000ba  6001              STR      r1,[r0,#0]            ;788
0000bc  6048              STR      r0,[r1,#4]            ;788
0000be  e7f3              B        |L50.168|
                  |L50.192|
0000c0  2000              MOVS     r0,#0                 ;803
0000c2  e7b9              B        |L50.56|
;;;805    /* End Function:RMP_Thd_Del **************************************************/
                          ENDP

                  |L50.196|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Delay||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Delay PROC
;;;1167   ******************************************************************************/
;;;1168   ret_t RMP_Thd_Delay(ptr_t Slices)
000000  b570              PUSH     {r4-r6,lr}
;;;1169   {
000002  0005              MOVS     r5,r0
000004  d002              BEQ      |L51.12|
;;;1170       if((Slices==0)||(Slices>=RMP_MAX_SLICES))
000006  480f              LDR      r0,|L51.68|
000008  4285              CMP      r5,r0
00000a  d302              BCC      |L51.18|
                  |L51.12|
;;;1171           return RMP_ERR_SLICE;
00000c  f06f0002          MVN      r0,#2
;;;1172       
;;;1173       RMP_Lock_Sched();
;;;1174   
;;;1175       /* We must be running */
;;;1176       _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1177       RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_DELAYED);
;;;1178       _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1179   
;;;1180       RMP_Cur_Thd->Retval=0;
;;;1181       
;;;1182       RMP_Unlock_Sched();
;;;1183       
;;;1184       /* Need to return if successful or not */
;;;1185       return RMP_Cur_Thd->Retval;
;;;1186   }
000010  bd70              POP      {r4-r6,pc}
                  |L51.18|
000012  f7fffffe          BL       RMP_Lock_Sched
000016  4c0c              LDR      r4,|L51.72|
000018  69a0              LDR      r0,[r4,#0x18]         ;1176  ; RMP_Cur_Thd
00001a  f7fffffe          BL       _RMP_Clr_Rdy
00001e  69a0              LDR      r0,[r4,#0x18]         ;1177  ; RMP_Cur_Thd
000020  69a1              LDR      r1,[r4,#0x18]         ;1177  ; RMP_Cur_Thd
000022  6980              LDR      r0,[r0,#0x18]         ;1177
000024  f02000ff          BIC      r0,r0,#0xff           ;1177
000028  1d80              ADDS     r0,r0,#6              ;1177
00002a  6188              STR      r0,[r1,#0x18]         ;1178
00002c  69a0              LDR      r0,[r4,#0x18]         ;1178  ; RMP_Cur_Thd
00002e  4629              MOV      r1,r5                 ;1178
000030  f7fffffe          BL       _RMP_Dly_Ins
000034  69a1              LDR      r1,[r4,#0x18]         ;1180  ; RMP_Cur_Thd
000036  2000              MOVS     r0,#0                 ;1180
000038  6388              STR      r0,[r1,#0x38]         ;1182
00003a  f7fffffe          BL       RMP_Unlock_Sched
00003e  69a0              LDR      r0,[r4,#0x18]         ;1185  ; RMP_Cur_Thd
000040  6b80              LDR      r0,[r0,#0x38]         ;1185
000042  bd70              POP      {r4-r6,pc}
;;;1187   /* End Function:RMP_Thd_Delay ************************************************/
                          ENDP

                  |L51.68|
                          DCD      0x000186a0
                  |L51.72|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Rcv||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Rcv PROC
;;;1088   ******************************************************************************/
;;;1089   ret_t RMP_Thd_Rcv(ptr_t* Data, ptr_t Slices)
000000  b570              PUSH     {r4-r6,lr}
;;;1090   {
000002  460e              MOV      r6,r1
000004  4605              MOV      r5,r0
;;;1091       struct RMP_Thd* Sender;
;;;1092       
;;;1093       RMP_Lock_Sched();
000006  f7fffffe          BL       RMP_Lock_Sched
;;;1094   
;;;1095       /* Check if there is a value in our mailbox. If yes, we return with that value */
;;;1096       if((RMP_Cur_Thd->State&RMP_THD_MBOXFUL)!=0)
00000a  4c31              LDR      r4,|L52.208|
00000c  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
00000e  8b00              LDRH     r0,[r0,#0x18]
000010  0580              LSLS     r0,r0,#22
000012  d50b              BPL      |L52.44|
;;;1097       {
;;;1098           /* Get the value from mailbox */
;;;1099           *Data=RMP_Cur_Thd->Mailbox;
000014  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
000016  6ac0              LDR      r0,[r0,#0x2c]
;;;1100           RMP_Cur_Thd->State&=~RMP_THD_MBOXFUL;
000018  6028              STR      r0,[r5,#0]
00001a  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
00001c  6981              LDR      r1,[r0,#0x18]
00001e  f4217100          BIC      r1,r1,#0x200
;;;1101           RMP_Unlock_Sched();
000022  6181              STR      r1,[r0,#0x18]
000024  f7fffffe          BL       RMP_Unlock_Sched
;;;1102           return 0;
000028  2000              MOVS     r0,#0
;;;1103       }
;;;1104       else
;;;1105       {
;;;1106           /* Is there any other guy waiting on us? If there is, unblock it and set it running */
;;;1107           if(&(RMP_Cur_Thd->Snd_List)!=RMP_Cur_Thd->Snd_List.Next)
;;;1108           {
;;;1109               /* Read the data */
;;;1110               Sender=(struct RMP_Thd*)(RMP_Cur_Thd->Snd_List.Next);
;;;1111               RMP_List_Del(Sender->Run_Head.Prev,Sender->Run_Head.Next);
;;;1112               *Data=Sender->Data;
;;;1113               /* Now we unblock it - what state is it in? */
;;;1114               if((RMP_THD_STATE(Sender->State)==RMP_THD_SNDDLY))
;;;1115                   RMP_List_Del(Sender->Dly_Head.Prev,Sender->Dly_Head.Next);
;;;1116               
;;;1117               RMP_THD_STATE_SET(Sender->State,RMP_THD_RUNNING);
;;;1118   
;;;1119               /* Is it suspended? If yes, we can't directly send it running */
;;;1120               if((Sender->State&RMP_THD_SUSPENDED)==0)
;;;1121                   _RMP_Set_Rdy(Sender);
;;;1122               
;;;1123               RMP_Unlock_Sched();
;;;1124           }
;;;1125           /* No sender waiting on us, we need to block */
;;;1126           else
;;;1127           {
;;;1128               /* No such value in our mailbox, we need to block */
;;;1129               if(Slices==0)
;;;1130               {
;;;1131                   RMP_Unlock_Sched();
;;;1132                   return RMP_ERR_OPER;
;;;1133               }
;;;1134   
;;;1135               /* We must be running */
;;;1136               _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1137   
;;;1138               if(Slices<RMP_MAX_SLICES)
;;;1139               {
;;;1140                   _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1141                   RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_RCVDLY);
;;;1142               }
;;;1143               else
;;;1144                   RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_RCVBLK);
;;;1145               
;;;1146               RMP_Unlock_Sched();
;;;1147               /* Dummy read - to separate the lock & unlock. If the compiler optimizes these two
;;;1148                * functions(inline them) on some architectures sometimes we never block. */
;;;1149               *Data=RMP_Cur_Thd->Mailbox;
;;;1150               /* We've been unblocked. There must be something in our mbox, or we should have failed */
;;;1151               RMP_Lock_Sched();
;;;1152               *Data=RMP_Cur_Thd->Mailbox;
;;;1153               RMP_Cur_Thd->State&=~RMP_THD_MBOXFUL;
;;;1154               RMP_Unlock_Sched();
;;;1155           }
;;;1156       }
;;;1157       
;;;1158       return RMP_Cur_Thd->Retval;
;;;1159   }
00002a  bd70              POP      {r4-r6,pc}
                  |L52.44|
00002c  69a1              LDR      r1,[r4,#0x18]         ;1107  ; RMP_Cur_Thd
00002e  69a0              LDR      r0,[r4,#0x18]         ;1107  ; RMP_Cur_Thd
000030  3010              ADDS     r0,r0,#0x10           ;1107
000032  6949              LDR      r1,[r1,#0x14]         ;1107
000034  4281              CMP      r1,r0                 ;1107
000036  d01c              BEQ      |L52.114|
000038  69a0              LDR      r0,[r4,#0x18]         ;1110  ; RMP_Cur_Thd
00003a  6940              LDR      r0,[r0,#0x14]         ;1110
00003c  e9d01200          LDRD     r1,r2,[r0,#0]         ;1110
000040  6011              STR      r1,[r2,#0]            ;1110
000042  604a              STR      r2,[r1,#4]            ;1110
000044  6b01              LDR      r1,[r0,#0x30]         ;1112
000046  6029              STR      r1,[r5,#0]            ;1114
000048  7e01              LDRB     r1,[r0,#0x18]         ;1114
00004a  2903              CMP      r1,#3                 ;1114
00004c  d103              BNE      |L52.86|
00004e  e9d01202          LDRD     r1,r2,[r0,#8]         ;1114
000052  6011              STR      r1,[r2,#0]            ;1114
000054  604a              STR      r2,[r1,#4]            ;1114
                  |L52.86|
000056  6981              LDR      r1,[r0,#0x18]         ;1117
000058  f02101ff          BIC      r1,r1,#0xff           ;1117
00005c  1c49              ADDS     r1,r1,#1              ;1117
00005e  6181              STR      r1,[r0,#0x18]         ;1120
000060  05ca              LSLS     r2,r1,#23             ;1120
000062  d401              BMI      |L52.104|
000064  f7fffffe          BL       _RMP_Set_Rdy
                  |L52.104|
000068  f7fffffe          BL       RMP_Unlock_Sched
00006c  69a0              LDR      r0,[r4,#0x18]         ;1158  ; RMP_Cur_Thd
00006e  6b80              LDR      r0,[r0,#0x38]         ;1158
000070  bd70              POP      {r4-r6,pc}
                  |L52.114|
000072  b186              CBZ      r6,|L52.150|
000074  69a0              LDR      r0,[r4,#0x18]         ;1136  ; RMP_Cur_Thd
000076  f7fffffe          BL       _RMP_Clr_Rdy
00007a  4816              LDR      r0,|L52.212|
00007c  4286              CMP      r6,r0                 ;1138
00007e  d20f              BCS      |L52.160|
000080  69a0              LDR      r0,[r4,#0x18]         ;1140  ; RMP_Cur_Thd
000082  4631              MOV      r1,r6                 ;1140
000084  f7fffffe          BL       _RMP_Dly_Ins
000088  69a0              LDR      r0,[r4,#0x18]         ;1141  ; RMP_Cur_Thd
00008a  69a1              LDR      r1,[r4,#0x18]         ;1141  ; RMP_Cur_Thd
00008c  6980              LDR      r0,[r0,#0x18]         ;1141
00008e  f02000ff          BIC      r0,r0,#0xff           ;1141
000092  1d40              ADDS     r0,r0,#5              ;1141
000094  e00a              B        |L52.172|
                  |L52.150|
000096  f7fffffe          BL       RMP_Unlock_Sched
00009a  f06f0004          MVN      r0,#4                 ;1132
00009e  bd70              POP      {r4-r6,pc}
                  |L52.160|
0000a0  69a0              LDR      r0,[r4,#0x18]         ;1144  ; RMP_Cur_Thd
0000a2  69a1              LDR      r1,[r4,#0x18]         ;1144  ; RMP_Cur_Thd
0000a4  6980              LDR      r0,[r0,#0x18]         ;1144
0000a6  f02000ff          BIC      r0,r0,#0xff           ;1144
0000aa  1d00              ADDS     r0,r0,#4              ;1144
                  |L52.172|
0000ac  6188              STR      r0,[r1,#0x18]         ;1146
0000ae  f7fffffe          BL       RMP_Unlock_Sched
0000b2  69a0              LDR      r0,[r4,#0x18]         ;1149  ; RMP_Cur_Thd
0000b4  6ac0              LDR      r0,[r0,#0x2c]         ;1149
0000b6  6028              STR      r0,[r5,#0]            ;1151
0000b8  f7fffffe          BL       RMP_Lock_Sched
0000bc  69a0              LDR      r0,[r4,#0x18]         ;1152  ; RMP_Cur_Thd
0000be  6ac0              LDR      r0,[r0,#0x2c]         ;1152
0000c0  6028              STR      r0,[r5,#0]            ;1153
0000c2  69a0              LDR      r0,[r4,#0x18]         ;1153  ; RMP_Cur_Thd
0000c4  6981              LDR      r1,[r0,#0x18]         ;1153
0000c6  f4217100          BIC      r1,r1,#0x200          ;1153
0000ca  6181              STR      r1,[r0,#0x18]         ;1154
0000cc  e7cc              B        |L52.104|
;;;1160   /* End Function:RMP_Thd_Rcv **************************************************/
                          ENDP

0000ce  0000              DCW      0x0000
                  |L52.208|
                          DCD      ||.data||
                  |L52.212|
                          DCD      0x000186a0

                          AREA ||i.RMP_Thd_Resume||, CODE, READONLY, ALIGN=1

                  RMP_Thd_Resume PROC
;;;910    ******************************************************************************/
;;;911    ret_t RMP_Thd_Resume(volatile struct RMP_Thd* Thread)
000000  b570              PUSH     {r4-r6,lr}
;;;912    {
000002  0004              MOVS     r4,r0
;;;913        ret_t Retval;
;;;914        
;;;915        /* Check if this thread structure could possibly be in use */
;;;916        if(Thread==0)
;;;917            return RMP_ERR_THD;
000004  f04f35ff          MOV      r5,#0xffffffff
000008  d011              BEQ      |L53.46|
;;;918    
;;;919        RMP_Lock_Sched();
00000a  f7fffffe          BL       RMP_Lock_Sched
;;;920        
;;;921        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
00000e  69a0              LDR      r0,[r4,#0x18]
000010  f0100fff          TST      r0,#0xff
000014  d00d              BEQ      |L53.50|
;;;922        {
;;;923            RMP_Unlock_Sched();
;;;924            return RMP_ERR_THD;
;;;925        }
;;;926        
;;;927        /* Check if the thread is suspended, if not, then throw an error */
;;;928        if((Thread->State&RMP_THD_SUSPENDED)!=0)
000016  69a0              LDR      r0,[r4,#0x18]
000018  05c0              LSLS     r0,r0,#23
00001a  d512              BPL      |L53.66|
;;;929        {
;;;930            /* Suspended */
;;;931            Thread->State&=~RMP_THD_SUSPENDED;
00001c  69a0              LDR      r0,[r4,#0x18]
00001e  f4207080          BIC      r0,r0,#0x100
000022  61a0              STR      r0,[r4,#0x18]
;;;932            if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
000024  69a0              LDR      r0,[r4,#0x18]
000026  b2c0              UXTB     r0,r0
000028  2801              CMP      r0,#1
00002a  d005              BEQ      |L53.56|
00002c  e007              B        |L53.62|
                  |L53.46|
00002e  4628              MOV      r0,r5                 ;917
;;;933                _RMP_Set_Rdy(Thread);
;;;934            Retval=0;
;;;935        }
;;;936        else
;;;937            Retval=RMP_ERR_STATE;
;;;938        
;;;939        RMP_Unlock_Sched();
;;;940    
;;;941        return Retval;
;;;942    }
000030  bd70              POP      {r4-r6,pc}
                  |L53.50|
000032  f7fffffe          BL       RMP_Unlock_Sched
000036  e7fa              B        |L53.46|
                  |L53.56|
000038  4620              MOV      r0,r4                 ;933
00003a  f7fffffe          BL       _RMP_Set_Rdy
                  |L53.62|
00003e  2400              MOVS     r4,#0                 ;934
000040  e001              B        |L53.70|
                  |L53.66|
000042  f06f0403          MVN      r4,#3                 ;937
                  |L53.70|
000046  f7fffffe          BL       RMP_Unlock_Sched
00004a  4620              MOV      r0,r4                 ;941
00004c  bd70              POP      {r4-r6,pc}
;;;943    /* End Function:RMP_Thd_Resume ***********************************************/
                          ENDP


                          AREA ||i.RMP_Thd_Set||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Set PROC
;;;816    ******************************************************************************/
;;;817    ret_t RMP_Thd_Set(volatile struct RMP_Thd* Thread, ptr_t Prio, ptr_t Slices)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;818    {
000004  0015              MOVS     r5,r2
000006  460e              MOV      r6,r1
000008  4604              MOV      r4,r0
00000a  d018              BEQ      |L54.62|
;;;819        /* Check if the priority and timeslice range is correct */
;;;820        if(Slices==0)
;;;821            return RMP_ERR_SLICE;
;;;822        
;;;823        /* Check if this thread structure could possibly be in use */
;;;824        if(Thread==0)
;;;825            return RMP_ERR_THD;
00000c  f04f37ff          MOV      r7,#0xffffffff
000010  b1c4              CBZ      r4,|L54.68|
;;;826        
;;;827        RMP_Lock_Sched();
000012  f7fffffe          BL       RMP_Lock_Sched
;;;828        
;;;829        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
000016  69a0              LDR      r0,[r4,#0x18]
000018  f0100fff          TST      r0,#0xff
00001c  d014              BEQ      |L54.72|
;;;830        {
;;;831            RMP_Unlock_Sched();
;;;832            return RMP_ERR_THD;
;;;833        }
;;;834        
;;;835        /* See if the thread is in running state */
;;;836        if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
00001e  69a0              LDR      r0,[r4,#0x18]
;;;837        {
;;;838            /* See if we are gonna change one of it or both */
;;;839            if(Prio<RMP_MAX_PREEMPT_PRIO)
;;;840            {
;;;841                if(Thread->Prio!=Prio)
;;;842                {
;;;843                    _RMP_Clr_Rdy(Thread);
;;;844                    Thread->Prio=Prio;
;;;845                    _RMP_Set_Rdy(Thread);
;;;846                }
;;;847            }
;;;848            
;;;849            if(Slices<RMP_MAX_SLICES)
000020  4f11              LDR      r7,|L54.104|
000022  b2c0              UXTB     r0,r0                 ;836
000024  2801              CMP      r0,#1                 ;836
000026  d012              BEQ      |L54.78|
;;;850                Thread->Slices=Slices;
;;;851        }
;;;852        else
;;;853        {
;;;854            if(Prio<RMP_MAX_PREEMPT_PRIO)
000028  2e20              CMP      r6,#0x20
00002a  d200              BCS      |L54.46|
;;;855                Thread->Prio=Prio;
00002c  6266              STR      r6,[r4,#0x24]
                  |L54.46|
;;;856            
;;;857            if(Slices<RMP_MAX_SLICES)
00002e  42bd              CMP      r5,r7
000030  d200              BCS      |L54.52|
;;;858                Thread->Slices=Slices;
000032  61e5              STR      r5,[r4,#0x1c]
                  |L54.52|
;;;859        }
;;;860        
;;;861        RMP_Unlock_Sched();
000034  f7fffffe          BL       RMP_Unlock_Sched
;;;862        
;;;863        return 0;
000038  2000              MOVS     r0,#0
                  |L54.58|
;;;864    }
00003a  e8bd81f0          POP      {r4-r8,pc}
                  |L54.62|
00003e  f06f0002          MVN      r0,#2                 ;821
000042  e7fa              B        |L54.58|
                  |L54.68|
000044  4638              MOV      r0,r7                 ;825
000046  e7f8              B        |L54.58|
                  |L54.72|
000048  f7fffffe          BL       RMP_Unlock_Sched
00004c  e7fa              B        |L54.68|
                  |L54.78|
00004e  2e20              CMP      r6,#0x20              ;839
000050  d2ed              BCS      |L54.46|
000052  6a60              LDR      r0,[r4,#0x24]         ;841
000054  42b0              CMP      r0,r6                 ;841
000056  d0ea              BEQ      |L54.46|
000058  4620              MOV      r0,r4                 ;843
00005a  f7fffffe          BL       _RMP_Clr_Rdy
00005e  6266              STR      r6,[r4,#0x24]         ;844
000060  4620              MOV      r0,r4                 ;845
000062  f7fffffe          BL       _RMP_Set_Rdy
000066  e7e2              B        |L54.46|
;;;865    /* End Function:RMP_Thd_Set **************************************************/
                          ENDP

                  |L54.104|
                          DCD      0x000186a0

                          AREA ||i.RMP_Thd_Snd||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Snd PROC
;;;953    ******************************************************************************/
;;;954    ret_t RMP_Thd_Snd(volatile struct RMP_Thd* Thread, ptr_t Data, ptr_t Slices)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;955    {
000004  0004              MOVS     r4,r0
000006  4616              MOV      r6,r2
000008  460f              MOV      r7,r1
;;;956        /* Check if this thread structure could possibly be in use */
;;;957        if(Thread==0)
;;;958            return RMP_ERR_THD;
00000a  f04f35ff          MOV      r5,#0xffffffff
00000e  d029              BEQ      |L55.100|
;;;959        
;;;960        RMP_Lock_Sched();
000010  f7fffffe          BL       RMP_Lock_Sched
;;;961        
;;;962        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
000014  69a0              LDR      r0,[r4,#0x18]
000016  f0100fff          TST      r0,#0xff
00001a  d026              BEQ      |L55.106|
;;;963        {
;;;964            RMP_Unlock_Sched();
;;;965            return RMP_ERR_THD;
;;;966        }
;;;967        
;;;968        /* Are we sending to ourself? This is not allowed */
;;;969        if(RMP_Cur_Thd==Thread)
00001c  4d2e              LDR      r5,|L55.216|
;;;970        {
;;;971            RMP_Unlock_Sched();
;;;972            return RMP_ERR_OPER;
00001e  f06f0804          MVN      r8,#4
000022  69a8              LDR      r0,[r5,#0x18]         ;969  ; RMP_Cur_Thd
000024  42a0              CMP      r0,r4                 ;969
000026  d023              BEQ      |L55.112|
;;;973        }
;;;974        
;;;975        RMP_Cur_Thd->Retval=0;
000028  69a9              LDR      r1,[r5,#0x18]  ; RMP_Cur_Thd
00002a  2000              MOVS     r0,#0
;;;976    
;;;977        /* See if there are already a value in the mailbox, if there is, we block */
;;;978        if((Thread->State&RMP_THD_MBOXFUL)!=0)
00002c  6388              STR      r0,[r1,#0x38]
00002e  69a0              LDR      r0,[r4,#0x18]
000030  0580              LSLS     r0,r0,#22
000032  d52b              BPL      |L55.140|
;;;979        {
;;;980            /* Mailbox full, we block, and put ourself into the queue */
;;;981            if(Slices==0)
000034  b1e6              CBZ      r6,|L55.112|
;;;982            {
;;;983                RMP_Unlock_Sched();
;;;984                return RMP_ERR_OPER;
;;;985            }
;;;986    
;;;987            /* We must be running */
;;;988            _RMP_Clr_Rdy(RMP_Cur_Thd);
000036  69a8              LDR      r0,[r5,#0x18]  ; RMP_Cur_Thd
000038  f7fffffe          BL       _RMP_Clr_Rdy
;;;989            RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),Thread->Snd_List.Prev,&(Thread->Snd_List));
00003c  6921              LDR      r1,[r4,#0x10]
00003e  f1040210          ADD      r2,r4,#0x10
000042  69a8              LDR      r0,[r5,#0x18]  ; RMP_Cur_Thd
000044  f7fffffe          BL       RMP_List_Ins
;;;990    
;;;991            if(Slices<RMP_MAX_SLICES)
000048  4824              LDR      r0,|L55.220|
00004a  4286              CMP      r6,r0
00004c  d214              BCS      |L55.120|
;;;992            {
;;;993                _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
00004e  69a8              LDR      r0,[r5,#0x18]  ; RMP_Cur_Thd
000050  4631              MOV      r1,r6
000052  f7fffffe          BL       _RMP_Dly_Ins
;;;994                RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SNDDLY);
000056  69a8              LDR      r0,[r5,#0x18]  ; RMP_Cur_Thd
000058  69a9              LDR      r1,[r5,#0x18]  ; RMP_Cur_Thd
00005a  6980              LDR      r0,[r0,#0x18]
00005c  f02000ff          BIC      r0,r0,#0xff
000060  1cc0              ADDS     r0,r0,#3
000062  e00f              B        |L55.132|
                  |L55.100|
000064  4628              MOV      r0,r5                 ;958
                  |L55.102|
;;;995            }
;;;996            else
;;;997                RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SNDBLK);
;;;998    
;;;999            RMP_Cur_Thd->Data=Data;
;;;1000       }
;;;1001       else
;;;1002       {
;;;1003           /* Mailbox not full. We need to check if the receiver is waiting for us */
;;;1004           if((RMP_THD_STATE(Thread->State)==RMP_THD_RCVBLK)||
;;;1005              (RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY))
;;;1006           {
;;;1007               /* The receiver is blocked, wake it up and return the value */
;;;1008               if(RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY)
;;;1009                   RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1010               
;;;1011               RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1012   
;;;1013               /* Is it suspended? If yes, we can't directly send it running */
;;;1014               if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;1015                   _RMP_Set_Rdy(Thread);
;;;1016           }
;;;1017           
;;;1018           /* Set the mailbox */
;;;1019           Thread->Mailbox=Data;
;;;1020           Thread->State|=RMP_THD_MBOXFUL;
;;;1021       }
;;;1022       
;;;1023       RMP_Unlock_Sched();
;;;1024   
;;;1025       return RMP_Cur_Thd->Retval;
;;;1026   }
000066  e8bd81f0          POP      {r4-r8,pc}
                  |L55.106|
00006a  f7fffffe          BL       RMP_Unlock_Sched
00006e  e7f9              B        |L55.100|
                  |L55.112|
000070  f7fffffe          BL       RMP_Unlock_Sched
000074  4640              MOV      r0,r8                 ;984
000076  e7f6              B        |L55.102|
                  |L55.120|
000078  69a8              LDR      r0,[r5,#0x18]         ;997  ; RMP_Cur_Thd
00007a  69a9              LDR      r1,[r5,#0x18]         ;997  ; RMP_Cur_Thd
00007c  6980              LDR      r0,[r0,#0x18]         ;997
00007e  f02000ff          BIC      r0,r0,#0xff           ;997
000082  1c80              ADDS     r0,r0,#2              ;997
                  |L55.132|
000084  6188              STR      r0,[r1,#0x18]         ;999
000086  69a8              LDR      r0,[r5,#0x18]         ;999  ; RMP_Cur_Thd
000088  6307              STR      r7,[r0,#0x30]         ;999
00008a  e01f              B        |L55.204|
                  |L55.140|
00008c  69a0              LDR      r0,[r4,#0x18]         ;1004
00008e  b2c0              UXTB     r0,r0                 ;1004
000090  2804              CMP      r0,#4                 ;1004
000092  d003              BEQ      |L55.156|
000094  69a0              LDR      r0,[r4,#0x18]         ;1005
000096  b2c0              UXTB     r0,r0                 ;1005
000098  2805              CMP      r0,#5                 ;1005
00009a  d112              BNE      |L55.194|
                  |L55.156|
00009c  69a0              LDR      r0,[r4,#0x18]         ;1008
00009e  b2c0              UXTB     r0,r0                 ;1008
0000a0  2805              CMP      r0,#5                 ;1008
0000a2  d103              BNE      |L55.172|
0000a4  68a0              LDR      r0,[r4,#8]            ;1009
0000a6  68e1              LDR      r1,[r4,#0xc]          ;1009
0000a8  6008              STR      r0,[r1,#0]            ;1009
0000aa  6041              STR      r1,[r0,#4]            ;1009
                  |L55.172|
0000ac  69a0              LDR      r0,[r4,#0x18]         ;1011
0000ae  f02000ff          BIC      r0,r0,#0xff           ;1011
0000b2  1c40              ADDS     r0,r0,#1              ;1011
0000b4  61a0              STR      r0,[r4,#0x18]         ;1011
0000b6  69a0              LDR      r0,[r4,#0x18]         ;1014
0000b8  05c0              LSLS     r0,r0,#23             ;1014
0000ba  d402              BMI      |L55.194|
0000bc  4620              MOV      r0,r4                 ;1015
0000be  f7fffffe          BL       _RMP_Set_Rdy
                  |L55.194|
0000c2  62e7              STR      r7,[r4,#0x2c]         ;1019
0000c4  69a0              LDR      r0,[r4,#0x18]         ;1020
0000c6  f4407000          ORR      r0,r0,#0x200          ;1020
0000ca  61a0              STR      r0,[r4,#0x18]         ;1020
                  |L55.204|
0000cc  f7fffffe          BL       RMP_Unlock_Sched
0000d0  69a8              LDR      r0,[r5,#0x18]         ;1025  ; RMP_Cur_Thd
0000d2  6b80              LDR      r0,[r0,#0x38]         ;1025
0000d4  e7c7              B        |L55.102|
;;;1027   /* End Function:RMP_Thd_Snd **************************************************/
                          ENDP

0000d6  0000              DCW      0x0000
                  |L55.216|
                          DCD      ||.data||
                  |L55.220|
                          DCD      0x000186a0

                          AREA ||i.RMP_Thd_Snd_ISR||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Snd_ISR PROC
;;;1037   ******************************************************************************/
;;;1038   ret_t RMP_Thd_Snd_ISR(volatile struct RMP_Thd* Thread, ptr_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;1039   {
000002  0004              MOVS     r4,r0
000004  460e              MOV      r6,r1
;;;1040       /* Check if this thread structure could possibly be in use */
;;;1041       if(Thread==0)
;;;1042           return RMP_ERR_THD;
000006  f04f30ff          MOV      r0,#0xffffffff
00000a  d033              BEQ      |L56.116|
;;;1043       
;;;1044       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
00000c  69a1              LDR      r1,[r4,#0x18]
00000e  f0110fff          TST      r1,#0xff
000012  d02f              BEQ      |L56.116|
;;;1045           return RMP_ERR_THD;
;;;1046       
;;;1047       if(RMP_Sched_Locked!=0)
000014  4d18              LDR      r5,|L56.120|
;;;1048           return RMP_ERR_OPER;
000016  1f00              SUBS     r0,r0,#4
000018  68e9              LDR      r1,[r5,#0xc]          ;1047  ; RMP_Sched_Locked
00001a  2900              CMP      r1,#0                 ;1047
00001c  d12a              BNE      |L56.116|
;;;1049   
;;;1050       /* See if there are already a value in the mailbox, if there is, we abort */
;;;1051       if((Thread->State&RMP_THD_MBOXFUL)!=0)
00001e  69a1              LDR      r1,[r4,#0x18]
000020  0589              LSLS     r1,r1,#22
000022  d427              BMI      |L56.116|
;;;1052           return RMP_ERR_OPER;
;;;1053       else
;;;1054       {
;;;1055           /* Mailbox not full. We need to check if the receiver is waiting for us */
;;;1056           if((RMP_THD_STATE(Thread->State)==RMP_THD_RCVBLK)||
000024  69a0              LDR      r0,[r4,#0x18]
000026  b2c0              UXTB     r0,r0
000028  2804              CMP      r0,#4
00002a  d003              BEQ      |L56.52|
;;;1057              (RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY))
00002c  69a0              LDR      r0,[r4,#0x18]
00002e  b2c0              UXTB     r0,r0
000030  2805              CMP      r0,#5
000032  d119              BNE      |L56.104|
                  |L56.52|
;;;1058           {
;;;1059               /* The receiver is blocked, wake it up and return the value */
;;;1060               if(RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY)
000034  69a0              LDR      r0,[r4,#0x18]
000036  b2c0              UXTB     r0,r0
000038  2805              CMP      r0,#5
00003a  d103              BNE      |L56.68|
;;;1061                   RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
00003c  68a0              LDR      r0,[r4,#8]
00003e  68e1              LDR      r1,[r4,#0xc]
000040  6008              STR      r0,[r1,#0]
000042  6041              STR      r1,[r0,#4]
                  |L56.68|
;;;1062               
;;;1063               RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
000044  69a0              LDR      r0,[r4,#0x18]
000046  f02000ff          BIC      r0,r0,#0xff
00004a  1c40              ADDS     r0,r0,#1
00004c  61a0              STR      r0,[r4,#0x18]
;;;1064   
;;;1065               /* Is it suspended? If yes, we can't directly send it running */
;;;1066               if((Thread->State&RMP_THD_SUSPENDED)==0)
00004e  69a0              LDR      r0,[r4,#0x18]
000050  05c0              LSLS     r0,r0,#23
000052  d409              BMI      |L56.104|
;;;1067               {
;;;1068                   _RMP_Set_Rdy(Thread);
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       _RMP_Set_Rdy
;;;1069                   if(Thread->Prio>RMP_Cur_Thd->Prio)
00005a  6a60              LDR      r0,[r4,#0x24]
00005c  69a9              LDR      r1,[r5,#0x18]  ; RMP_Cur_Thd
00005e  6a49              LDR      r1,[r1,#0x24]
000060  4288              CMP      r0,r1
000062  d901              BLS      |L56.104|
;;;1070                       _RMP_Yield();
000064  f7fffffe          BL       _RMP_Yield
                  |L56.104|
;;;1071               }
;;;1072           }
;;;1073           
;;;1074           /* Set the mailbox */
;;;1075           Thread->Mailbox=Data;
000068  62e6              STR      r6,[r4,#0x2c]
;;;1076           Thread->State|=RMP_THD_MBOXFUL;
00006a  69a0              LDR      r0,[r4,#0x18]
00006c  f4407000          ORR      r0,r0,#0x200
000070  61a0              STR      r0,[r4,#0x18]
;;;1077       }
;;;1078   
;;;1079       return 0;
000072  2000              MOVS     r0,#0
                  |L56.116|
;;;1080   }
000074  bd70              POP      {r4-r6,pc}
;;;1081   /* End Function:RMP_Thd_Snd_ISR **********************************************/
                          ENDP

000076  0000              DCW      0x0000
                  |L56.120|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Suspend||, CODE, READONLY, ALIGN=1

                  RMP_Thd_Suspend PROC
;;;872    ******************************************************************************/
;;;873    ret_t RMP_Thd_Suspend(volatile struct RMP_Thd* Thread)
000000  b570              PUSH     {r4-r6,lr}
;;;874    {
000002  0004              MOVS     r4,r0
;;;875        /* Check if this thread structure could possibly be in use */
;;;876        if(Thread==0)
;;;877            return RMP_ERR_THD;
000004  f04f35ff          MOV      r5,#0xffffffff
000008  d00c              BEQ      |L57.36|
;;;878        
;;;879        RMP_Lock_Sched();
00000a  f7fffffe          BL       RMP_Lock_Sched
;;;880        
;;;881        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
00000e  69a0              LDR      r0,[r4,#0x18]
000010  f0100fff          TST      r0,#0xff
000014  d008              BEQ      |L57.40|
;;;882        {
;;;883            RMP_Unlock_Sched();
;;;884            return RMP_ERR_THD;
;;;885        }
;;;886        
;;;887        /* Suspend it */
;;;888        if((Thread->State&RMP_THD_SUSPENDED)!=0)
000016  69a0              LDR      r0,[r4,#0x18]
000018  05c0              LSLS     r0,r0,#23
00001a  d508              BPL      |L57.46|
;;;889        {
;;;890            RMP_Unlock_Sched();
00001c  f7fffffe          BL       RMP_Unlock_Sched
;;;891            return RMP_ERR_STATE;
000020  00a8              LSLS     r0,r5,#2
;;;892        }
;;;893        /* Mark this as suspended */
;;;894        Thread->State|=RMP_THD_SUSPENDED;
;;;895        /* Only when it is running do we clear this */
;;;896        if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
;;;897            _RMP_Clr_Rdy(Thread);
;;;898        
;;;899        RMP_Unlock_Sched();
;;;900    
;;;901        return 0;
;;;902    }
000022  bd70              POP      {r4-r6,pc}
                  |L57.36|
000024  4628              MOV      r0,r5                 ;877
000026  bd70              POP      {r4-r6,pc}
                  |L57.40|
000028  f7fffffe          BL       RMP_Unlock_Sched
00002c  e7fa              B        |L57.36|
                  |L57.46|
00002e  69a0              LDR      r0,[r4,#0x18]         ;894
000030  f4407080          ORR      r0,r0,#0x100          ;894
000034  61a0              STR      r0,[r4,#0x18]         ;894
000036  69a0              LDR      r0,[r4,#0x18]         ;896
000038  b2c0              UXTB     r0,r0                 ;896
00003a  2801              CMP      r0,#1                 ;896
00003c  d102              BNE      |L57.68|
00003e  4620              MOV      r0,r4                 ;897
000040  f7fffffe          BL       _RMP_Clr_Rdy
                  |L57.68|
000044  f7fffffe          BL       RMP_Unlock_Sched
000048  2000              MOVS     r0,#0                 ;901
00004a  bd70              POP      {r4-r6,pc}
;;;903    /* End Function:RMP_Thd_Suspend **********************************************/
                          ENDP


                          AREA ||i.RMP_Tick_Hook||, CODE, READONLY, ALIGN=1

                  RMP_Tick_Hook PROC
;;;1576   #if(RMP_USE_HOOKS==RMP_FALSE)
;;;1577   void RMP_Tick_Hook(ptr_t Ticks)
000000  4770              BX       lr
;;;1578   {
;;;1579       Ticks=Ticks;
;;;1580       return;
;;;1581   }
;;;1582   #endif
                          ENDP


                          AREA ||i.RMP_Unlock_Sched||, CODE, READONLY, ALIGN=2

                  RMP_Unlock_Sched PROC
;;;359    ******************************************************************************/
;;;360    void RMP_Unlock_Sched(void)
000000  490c              LDR      r1,|L59.52|
;;;361    {
000002  b510              PUSH     {r4,lr}
;;;362        if(RMP_Sched_Lock_Cnt==1)
000004  6888              LDR      r0,[r1,#8]  ; RMP_Sched_Lock_Cnt
000006  2801              CMP      r0,#1
000008  d006              BEQ      |L59.24|
;;;363        {
;;;364            /* Clear the count before enabling */
;;;365            RMP_Sched_Lock_Cnt=0;
;;;366            RMP_Sched_Locked=0;
;;;367            /* Now see if the scheduler scheduling action is pended in the lock-unlock 
;;;368             * period. If yes, perform a schedule now */
;;;369            if(RMP_Sched_Pend!=0)
;;;370            {
;;;371                /* Reset the count and trigger the context switch */
;;;372                RMP_Sched_Pend=0;
;;;373                _RMP_Yield();
;;;374            }
;;;375            RMP_UNMASK_INT();
;;;376        }
;;;377        else if(RMP_Sched_Lock_Cnt>1)
00000a  6888              LDR      r0,[r1,#8]  ; RMP_Sched_Lock_Cnt
00000c  2801              CMP      r0,#1
00000e  d910              BLS      |L59.50|
;;;378            RMP_Sched_Lock_Cnt--;
000010  6888              LDR      r0,[r1,#8]  ; RMP_Sched_Lock_Cnt
000012  1e40              SUBS     r0,r0,#1
000014  6088              STR      r0,[r1,#8]  ; RMP_Sched_Lock_Cnt
;;;379        /* Trying to unlock a scheduler that is not locked */
;;;380        else
;;;381            while(1);
;;;382    }
000016  bd10              POP      {r4,pc}
                  |L59.24|
000018  2000              MOVS     r0,#0                 ;365
00001a  6088              STR      r0,[r1,#8]            ;365  ; RMP_Sched_Lock_Cnt
00001c  60c8              STR      r0,[r1,#0xc]          ;366  ; RMP_Sched_Locked
00001e  690a              LDR      r2,[r1,#0x10]         ;369  ; RMP_Sched_Pend
000020  b112              CBZ      r2,|L59.40|
000022  6108              STR      r0,[r1,#0x10]         ;372  ; RMP_Sched_Pend
000024  f7fffffe          BL       _RMP_Yield
                  |L59.40|
000028  e8bd4010          POP      {r4,lr}               ;375
00002c  2000              MOVS     r0,#0                 ;375
00002e  f7ffbffe          B.W      RMP_Mask_Int
                  |L59.50|
000032  e7fe              B        |L59.50|
;;;383    /* End Function:RMP_Unlock_Sched *********************************************/
                          ENDP

                  |L59.52|
                          DCD      ||.data||

                          AREA ||i.RMP_Yield||, CODE, READONLY, ALIGN=2

                  RMP_Yield PROC
;;;390    ******************************************************************************/
;;;391    void RMP_Yield(void)
000000  4803              LDR      r0,|L60.16|
;;;392    {
;;;393        if(RMP_Sched_Locked==0)
000002  68c1              LDR      r1,[r0,#0xc]  ; RMP_Sched_Locked
000004  b111              CBZ      r1,|L60.12|
;;;394        {
;;;395            /* Now see if the scheduler scheduling action is pended in the lock-unlock 
;;;396             * period. If yes, perform a schedule now */
;;;397            _RMP_Yield();
;;;398        }
;;;399        else
;;;400            RMP_Sched_Pend=1;
000006  2101              MOVS     r1,#1
000008  6101              STR      r1,[r0,#0x10]  ; RMP_Sched_Pend
;;;401    }
00000a  4770              BX       lr
                  |L60.12|
00000c  f7ffbffe          B.W      _RMP_Yield
;;;402    /* End Function:RMP_Yield ****************************************************/
                          ENDP

                  |L60.16|
                          DCD      ||.data||

                          AREA ||i._RMP_Clr_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Clr_Rdy PROC
;;;619    ******************************************************************************/
;;;620    void _RMP_Clr_Rdy(volatile struct RMP_Thd* Thread)
000000  b510              PUSH     {r4,lr}
;;;621    {
;;;622        /* See if it is the last thread on the priority level */
;;;623        if(Thread->Run_Head.Prev==Thread->Run_Head.Next)
000002  6801              LDR      r1,[r0,#0]
000004  6842              LDR      r2,[r0,#4]
;;;624            RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]&=~(((ptr_t)1)<<(Thread->Prio&RMP_WORD_MASK));
000006  2301              MOVS     r3,#1
000008  4291              CMP      r1,r2                 ;623
00000a  d10c              BNE      |L61.38|
00000c  6a41              LDR      r1,[r0,#0x24]
00000e  4a0b              LDR      r2,|L61.60|
000010  0949              LSRS     r1,r1,#5
000012  eb020181          ADD      r1,r2,r1,LSL #2
000016  680a              LDR      r2,[r1,#0]
000018  6a44              LDR      r4,[r0,#0x24]
00001a  f004040f          AND      r4,r4,#0xf
00001e  fa03f404          LSL      r4,r3,r4
000022  43a2              BICS     r2,r2,r4
000024  600a              STR      r2,[r1,#0]
                  |L61.38|
;;;625        
;;;626        /* Insert this into the corresponding runqueue */
;;;627        RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
000026  6802              LDR      r2,[r0,#0]
000028  6841              LDR      r1,[r0,#4]
00002a  600a              STR      r2,[r1,#0]
00002c  6051              STR      r1,[r2,#4]
;;;628        
;;;629        /* If it is the current thread, request a context switch */
;;;630        if(Thread==RMP_Cur_Thd)
00002e  4903              LDR      r1,|L61.60|
000030  698a              LDR      r2,[r1,#0x18]  ; RMP_Cur_Thd
000032  4290              CMP      r0,r2
000034  d100              BNE      |L61.56|
;;;631            RMP_Sched_Pend=1;
000036  610b              STR      r3,[r1,#0x10]  ; RMP_Sched_Pend
                  |L61.56|
;;;632    }
000038  bd10              POP      {r4,pc}
;;;633    /* End Function:_RMP_Clr_Rdy *************************************************/
                          ENDP

00003a  0000              DCW      0x0000
                  |L61.60|
                          DCD      ||.data||

                          AREA ||i._RMP_Dly_Ins||, CODE, READONLY, ALIGN=2

                  _RMP_Dly_Ins PROC
;;;642    ******************************************************************************/
;;;643    void _RMP_Dly_Ins(volatile struct RMP_Thd* Thread, ptr_t Slices)
000000  b4f0              PUSH     {r4-r7}
;;;644    {
;;;645        struct RMP_List* Trav_Ptr;
;;;646        struct RMP_Thd* Trav_Thd;
;;;647        
;;;648        Trav_Ptr=(struct RMP_List*)RMP_Delay.Next;
000002  4d0b              LDR      r5,|L62.48|
;;;649        while(Trav_Ptr!=&(RMP_Delay))
;;;650        {
;;;651            Trav_Thd=RMP_DLY2THD(Trav_Ptr);
;;;652            if((Trav_Thd->Timeout-RMP_Tick)>Slices)
000004  f1a50420          SUB      r4,r5,#0x20
000008  686a              LDR      r2,[r5,#4]            ;648  ; RMP_Delay
00000a  f1a20308          SUB      r3,r2,#8              ;651
00000e  e004              B        |L62.26|
                  |L62.16|
000010  6a9e              LDR      r6,[r3,#0x28]
000012  6867              LDR      r7,[r4,#4]  ; RMP_Tick
000014  1bf6              SUBS     r6,r6,r7
000016  428e              CMP      r6,r1
000018  d801              BHI      |L62.30|
                  |L62.26|
00001a  42aa              CMP      r2,r5                 ;649
00001c  d1f8              BNE      |L62.16|
                  |L62.30|
;;;653                break;
;;;654        }
;;;655    
;;;656        /* Insert this into the list */
;;;657        Thread->Timeout=RMP_Tick+Slices;
00001e  6863              LDR      r3,[r4,#4]  ; RMP_Tick
000020  4419              ADD      r1,r1,r3
000022  6281              STR      r1,[r0,#0x28]
;;;658        RMP_List_Ins(&Thread->Dly_Head,Trav_Ptr->Prev,Trav_Ptr);
000024  6811              LDR      r1,[r2,#0]
000026  3008              ADDS     r0,r0,#8
000028  bcf0              POP      {r4-r7}
00002a  f7ffbffe          B.W      RMP_List_Ins
;;;659    }
;;;660    /* End Function:_RMP_Dly_Ins *************************************************/
                          ENDP

00002e  0000              DCW      0x0000
                  |L62.48|
                          DCD      ||.data||+0x20

                          AREA ||i._RMP_Get_High_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Get_High_Rdy PROC
;;;468    ******************************************************************************/
;;;469    void _RMP_Get_High_Rdy(void)
000000  b570              PUSH     {r4-r6,lr}
;;;470    {
;;;471        cnt_t Count;
;;;472        
;;;473        /* Write the SP value to thread structure */
;;;474        RMP_Cur_Thd->Stack=RMP_Cur_SP;
000002  4c1b              LDR      r4,|L63.112|
000004  69e0              LDR      r0,[r4,#0x1c]  ; RMP_Cur_SP
000006  69a1              LDR      r1,[r4,#0x18]  ; RMP_Cur_Thd
;;;475        
;;;476        /* Is the scheduler locked on other threads? If yes, we return without doing anything */
;;;477        if(RMP_Sched_Locked!=0)
000008  6348              STR      r0,[r1,#0x34]
00000a  68e0              LDR      r0,[r4,#0xc]  ; RMP_Sched_Locked
00000c  2800              CMP      r0,#0                 ;470
00000e  d12e              BNE      |L63.110|
;;;478            return;
;;;479        
;;;480        if(RMP_Timer_Pend==1)
000010  6960              LDR      r0,[r4,#0x14]  ; RMP_Timer_Pend
000012  2500              MOVS     r5,#0                 ;470
000014  2801              CMP      r0,#1
000016  d102              BNE      |L63.30|
;;;481        {
;;;482            RMP_Timer_Pend=0;
000018  6165              STR      r5,[r4,#0x14]  ; RMP_Timer_Pend
;;;483            _RMP_Timer_Proc();
00001a  f7fffffe          BL       _RMP_Timer_Proc
                  |L63.30|
;;;484        }
;;;485        
;;;486        RMP_Sched_Pend=0;
;;;487        /* See which one is ready, and pick it */
;;;488        for(Count=RMP_BITMAP_SIZE-1;Count>=0;Count--)
;;;489        {
;;;490            if(RMP_Bitmap[Count]==0)
00001e  4814              LDR      r0,|L63.112|
000020  6125              STR      r5,[r4,#0x10]         ;486  ; RMP_Sched_Pend
000022  6801              LDR      r1,[r0,#0]
000024  b301              CBZ      r1,|L63.104|
;;;491                continue;
;;;492            
;;;493            Count=RMP_MSB_Get(RMP_Bitmap[Count])+(Count<<RMP_WORD_ORDER);
000026  6800              LDR      r0,[r0,#0]
000028  f7fffffe          BL       RMP_MSB_Get
;;;494            
;;;495            /* See if the current thread and the next thread are the same. If yes, place the current at the end of the queue */
;;;496            if(RMP_Cur_Thd==(struct RMP_Thd*)(RMP_Run[Count].Next))
00002c  4a11              LDR      r2,|L63.116|
00002e  eb0203c0          ADD      r3,r2,r0,LSL #3
000032  6858              LDR      r0,[r3,#4]
000034  69a1              LDR      r1,[r4,#0x18]  ; RMP_Cur_Thd
000036  4288              CMP      r0,r1
000038  d110              BNE      |L63.92|
;;;497            {
;;;498                RMP_List_Del(RMP_Cur_Thd->Run_Head.Prev, RMP_Cur_Thd->Run_Head.Next);
00003a  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
00003c  69a1              LDR      r1,[r4,#0x18]  ; RMP_Cur_Thd
00003e  6800              LDR      r0,[r0,#0]
000040  6849              LDR      r1,[r1,#4]
000042  6008              STR      r0,[r1,#0]
000044  6041              STR      r1,[r0,#4]
;;;499                RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),
000046  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
000048  69a1              LDR      r1,[r4,#0x18]  ; RMP_Cur_Thd
00004a  6a40              LDR      r0,[r0,#0x24]
00004c  6a49              LDR      r1,[r1,#0x24]
00004e  f8521031          LDR      r1,[r2,r1,LSL #3]
000052  eb0202c0          ADD      r2,r2,r0,LSL #3
000056  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
000058  f7fffffe          BL       RMP_List_Ins
                  |L63.92|
;;;500                             RMP_Run[RMP_Cur_Thd->Prio].Prev,
;;;501                             &(RMP_Run[RMP_Cur_Thd->Prio]));
;;;502            }
;;;503            
;;;504            /* Replenish timeslices */
;;;505            RMP_Cur_Thd->Slices_Left=RMP_Cur_Thd->Slices;
00005c  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
00005e  69a1              LDR      r1,[r4,#0x18]  ; RMP_Cur_Thd
000060  69c0              LDR      r0,[r0,#0x1c]
;;;506            RMP_Cur_Thd=(struct RMP_Thd*)(RMP_Run[Count].Next);
000062  6208              STR      r0,[r1,#0x20]
000064  6858              LDR      r0,[r3,#4]
000066  61a0              STR      r0,[r4,#0x18]  ; RMP_Cur_Thd
                  |L63.104|
;;;507            break;
;;;508        }
;;;509        
;;;510        /* Load the SP value from thread structure */
;;;511        RMP_Cur_SP=RMP_Cur_Thd->Stack;
000068  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
00006a  6b40              LDR      r0,[r0,#0x34]
00006c  61e0              STR      r0,[r4,#0x1c]  ; RMP_Cur_SP
                  |L63.110|
;;;512    }
00006e  bd70              POP      {r4-r6,pc}
;;;513    /* End Function:_RMP_Get_High_Rdy ********************************************/
                          ENDP

                  |L63.112|
                          DCD      ||.data||
                  |L63.116|
                          DCD      ||.bss||

                          AREA ||i._RMP_Get_Near_Ticks||, CODE, READONLY, ALIGN=2

                  _RMP_Get_Near_Ticks PROC
;;;564    ******************************************************************************/
;;;565    ptr_t _RMP_Get_Near_Ticks(void)
000000  4909              LDR      r1,|L64.40|
;;;566    {
;;;567        ptr_t Value;
;;;568        struct RMP_Thd* Thread;
;;;569        
;;;570        /* What is the current thread's timeout value? */
;;;571        Value=RMP_Cur_Thd->Slices_Left;
000002  f1a10220          SUB      r2,r1,#0x20
000006  6990              LDR      r0,[r2,#0x18]  ; RMP_Cur_Thd
;;;572        
;;;573        /* What is the nearest timer timeout value? */
;;;574        if((&RMP_Delay)!=RMP_Delay.Next)
000008  684b              LDR      r3,[r1,#4]  ; RMP_Delay
00000a  428b              CMP      r3,r1
00000c  6a00              LDR      r0,[r0,#0x20]         ;571
00000e  d007              BEQ      |L64.32|
;;;575        {
;;;576            Thread=RMP_DLY2THD(RMP_Delay.Next);
000010  6849              LDR      r1,[r1,#4]  ; RMP_Delay
;;;577            /* See if it is nearer - don't worry about the situation that the timer
;;;578             * have overflown, because if that is to happen, it would have been 
;;;579             * already processed by the timeout processing routine just called above. */
;;;580            if((Thread->Timeout-RMP_Tick)<Value)
000012  6853              LDR      r3,[r2,#4]  ; RMP_Tick
000014  6a09              LDR      r1,[r1,#0x20]
000016  1acb              SUBS     r3,r1,r3
000018  4283              CMP      r3,r0
00001a  d201              BCS      |L64.32|
;;;581                Value=Thread->Timeout-RMP_Tick;
00001c  6850              LDR      r0,[r2,#4]  ; RMP_Tick
00001e  1a08              SUBS     r0,r1,r0
                  |L64.32|
;;;582        }
;;;583        
;;;584        /* The timer setting is at least 1 tick */
;;;585        if(Value==0)
000020  2800              CMP      r0,#0
000022  d100              BNE      |L64.38|
;;;586            Value=1;
000024  2001              MOVS     r0,#1
                  |L64.38|
;;;587        
;;;588        return Value;
;;;589    }
000026  4770              BX       lr
;;;590    /* End Function:_RMP_Get_Near_Ticks ******************************************/
                          ENDP

                  |L64.40|
                          DCD      ||.data||+0x20

                          AREA ||i._RMP_Mem_Block||, CODE, READONLY, ALIGN=1

                  _RMP_Mem_Block PROC
;;;1839   ******************************************************************************/
;;;1840   void _RMP_Mem_Block(volatile struct RMP_Mem_Head* Addr, ptr_t Size)
000000  2200              MOVS     r2,#0
;;;1841   {
;;;1842       volatile struct RMP_Mem_Head* Mem_Head;
;;;1843       
;;;1844       /* Get the big memory block's size and position */
;;;1845       Mem_Head=(struct RMP_Mem_Head*)Addr;
;;;1846       
;;;1847       /* Initialize the big memory block */
;;;1848       Mem_Head->State=RMP_MEM_FREE;
000002  6082              STR      r2,[r0,#8]
;;;1849       Mem_Head->Tail=(struct RMP_Mem_Tail*)(((ptr_t)Mem_Head)+Size-sizeof(struct RMP_Mem_Tail));
000004  4401              ADD      r1,r1,r0
000006  1f09              SUBS     r1,r1,#4              ;1848
000008  60c1              STR      r1,[r0,#0xc]
;;;1850       Mem_Head->Tail->Head=Mem_Head;
00000a  68c1              LDR      r1,[r0,#0xc]
00000c  6008              STR      r0,[r1,#0]
;;;1851   }
00000e  4770              BX       lr
;;;1852   /* End Function:_RMP_Mem_Block ***********************************************/
                          ENDP


                          AREA ||i._RMP_Mem_Del||, CODE, READONLY, ALIGN=1

                  _RMP_Mem_Del PROC
;;;1902   ******************************************************************************/
;;;1903   void _RMP_Mem_Del(volatile void* Pool, volatile struct RMP_Mem_Head* Mem_Head)
000000  b570              PUSH     {r4-r6,lr}
;;;1904   {
000002  4605              MOV      r5,r0
;;;1905       cnt_t FLI_Level;
;;;1906       cnt_t SLI_Level;
;;;1907       ptr_t Level;
;;;1908       ptr_t Size;
;;;1909       volatile struct RMP_Mem* Mem;
;;;1910       volatile struct RMP_List* Slot;    
;;;1911       
;;;1912       /* Get the memory pool and block size */
;;;1913       Mem=(volatile struct RMP_Mem*)Pool;
;;;1914       Size=(ptr_t)(Mem_Head->Tail)-((ptr_t)Mem_Head)-sizeof(struct RMP_Mem_Head);
000004  68c8              LDR      r0,[r1,#0xc]
000006  460c              MOV      r4,r1                 ;1904
000008  1b06              SUBS     r6,r0,r4
00000a  3e10              SUBS     r6,r6,#0x10
;;;1915       
;;;1916       /* Guarantee the Mem_Size is bigger than 64 or a failure will surely occur here */
;;;1917       FLI_Level=RMP_MSB_Get(Size)-6;
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       RMP_MSB_Get
;;;1918       /* Decide the SLI level directly from the FLI level */
;;;1919       SLI_Level=(Size>>(FLI_Level+3))&0x07;
000012  1ec1              SUBS     r1,r0,#3
;;;1920       Level=(FLI_Level<<3)+SLI_Level;
;;;1921       /* Get the slot */
;;;1922       Slot=&(Mem->Table[RMP_MEM_POS(FLI_Level,SLI_Level)]);
;;;1923      
;;;1924       RMP_List_Del(Mem_Head->Head.Prev,Mem_Head->Head.Next);
000014  6822              LDR      r2,[r4,#0]
000016  40ce              LSRS     r6,r6,r1              ;1919
000018  1f80              SUBS     r0,r0,#6              ;1919
00001a  f0060107          AND      r1,r6,#7              ;1919
00001e  eb0100c0          ADD      r0,r1,r0,LSL #3       ;1920
000022  eb0501c0          ADD      r1,r5,r0,LSL #3       ;1922
000026  6863              LDR      r3,[r4,#4]
000028  601a              STR      r2,[r3,#0]
00002a  6053              STR      r3,[r2,#4]
;;;1925   
;;;1926       /* See if there are any blocks in the level, equal means no. So
;;;1927        * what we deleted is the last block */
;;;1928       if(Slot==Slot->Next)
00002c  6aca              LDR      r2,[r1,#0x2c]
00002e  3128              ADDS     r1,r1,#0x28
000030  428a              CMP      r2,r1
000032  d109              BNE      |L66.72|
;;;1929       {
;;;1930           /* Clear the corresponding bit in the TLSF bitmap */
;;;1931           Mem->Bitmap[Level>>RMP_WORD_ORDER]&=~(1<<(Level&RMP_WORD_MASK));
000034  0941              LSRS     r1,r0,#5
000036  f000030f          AND      r3,r0,#0xf
00003a  eb050081          ADD      r0,r5,r1,LSL #2
00003e  2201              MOVS     r2,#1
000040  6941              LDR      r1,[r0,#0x14]
000042  409a              LSLS     r2,r2,r3
000044  4391              BICS     r1,r1,r2
000046  6141              STR      r1,[r0,#0x14]
                  |L66.72|
;;;1932       }
;;;1933   }
000048  bd70              POP      {r4-r6,pc}
;;;1934   /* End Function:_RMP_Mem_Del *************************************************/
                          ENDP


                          AREA ||i._RMP_Mem_Ins||, CODE, READONLY, ALIGN=1

                  _RMP_Mem_Ins PROC
;;;1861   ******************************************************************************/
;;;1862   void _RMP_Mem_Ins(volatile void* Pool, volatile struct RMP_Mem_Head* Mem_Head)
000000  b570              PUSH     {r4-r6,lr}
;;;1863   {
000002  4604              MOV      r4,r0
;;;1864       cnt_t FLI_Level;
;;;1865       cnt_t SLI_Level;
;;;1866       ptr_t Level;
;;;1867       ptr_t Size;
;;;1868       volatile struct RMP_Mem* Mem;
;;;1869       volatile struct RMP_List* Slot;
;;;1870       
;;;1871       /* Get the memory pool and block size */
;;;1872       Mem=(volatile struct RMP_Mem*)Pool;
;;;1873       Size=(ptr_t)(Mem_Head->Tail)-((ptr_t)Mem_Head)-sizeof(struct RMP_Mem_Head);
000004  68c8              LDR      r0,[r1,#0xc]
000006  460d              MOV      r5,r1                 ;1863
000008  1b46              SUBS     r6,r0,r5
00000a  3e10              SUBS     r6,r6,#0x10
;;;1874   
;;;1875       /* Guarantee the Mem_Size is bigger than 64 or a failure will surely occur here */
;;;1876       FLI_Level=RMP_MSB_Get(Size)-6;
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       RMP_MSB_Get
;;;1877       /* Decide the SLI level directly from the FLI level */
;;;1878       SLI_Level=(Size>>(FLI_Level+3))&0x07;
000012  1ec1              SUBS     r1,r0,#3
000014  40ce              LSRS     r6,r6,r1
000016  1f80              SUBS     r0,r0,#6
000018  f0060107          AND      r1,r6,#7
;;;1879       Level=(FLI_Level<<3)+SLI_Level;
00001c  eb0100c0          ADD      r0,r1,r0,LSL #3
;;;1880       /* Get the slot */
;;;1881       Slot=&(Mem->Table[RMP_MEM_POS(FLI_Level,SLI_Level)]);
000020  eb0401c0          ADD      r1,r4,r0,LSL #3
;;;1882   
;;;1883       /* See if there are any blocks in the level, equal means no. So what we inserted is the first block */
;;;1884       if(Slot==Slot->Next)
000024  6aca              LDR      r2,[r1,#0x2c]
000026  3128              ADDS     r1,r1,#0x28
000028  428a              CMP      r2,r1
00002a  d109              BNE      |L67.64|
;;;1885       {
;;;1886           /* Set the corresponding bit in the TLSF bitmap */
;;;1887           Mem->Bitmap[Level>>RMP_WORD_ORDER]|=1<<(Level&RMP_WORD_MASK);
00002c  0942              LSRS     r2,r0,#5
00002e  f000060f          AND      r6,r0,#0xf
000032  eb040082          ADD      r0,r4,r2,LSL #2
000036  2301              MOVS     r3,#1
000038  6942              LDR      r2,[r0,#0x14]
00003a  40b3              LSLS     r3,r3,r6
00003c  431a              ORRS     r2,r2,r3
00003e  6142              STR      r2,[r0,#0x14]
                  |L67.64|
;;;1888       }
;;;1889   
;;;1890       /* Insert the node now */
;;;1891       RMP_List_Ins(&(Mem_Head->Head), Slot, Slot->Next);
000040  684a              LDR      r2,[r1,#4]
000042  4628              MOV      r0,r5
000044  e8bd4070          POP      {r4-r6,lr}
000048  f7ffbffe          B.W      RMP_List_Ins
;;;1892   }
;;;1893   /* End Function:_RMP_Mem_Ins *************************************************/
                          ENDP


                          AREA ||i._RMP_Mem_Search||, CODE, READONLY, ALIGN=2

                  _RMP_Mem_Search PROC
;;;1944   ******************************************************************************/
;;;1945   ret_t _RMP_Mem_Search(volatile void* Pool, ptr_t Size, cnt_t* FLI_Level, cnt_t* SLI_Level)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1946   {
000004  461e              MOV      r6,r3
000006  4617              MOV      r7,r2
000008  4605              MOV      r5,r0
00000a  460c              MOV      r4,r1
;;;1947       cnt_t FLI_Level_Temp;
;;;1948       cnt_t SLI_Level_Temp;
;;;1949       cnt_t Level;
;;;1950       ptr_t LSB;
;;;1951       volatile struct RMP_Mem* Mem;
;;;1952   
;;;1953       /* Make sure that it is bigger than 64. 64=2^6 */
;;;1954       FLI_Level_Temp=RMP_MSB_Get(Size)-6;
00000c  4608              MOV      r0,r1
00000e  f7fffffe          BL       RMP_MSB_Get
;;;1955       
;;;1956       /* Decide the SLI level directly from the FLI level. We plus the number by one here
;;;1957        * so that we can avoid the list search. However, when the allocated memory is just
;;;1958        * an order of 2, then we do not need to jump to the next level and can fit directly */
;;;1959       if(((cnt_t)Size)==((1<<6)<<FLI_Level_Temp))
000012  2140              MOVS     r1,#0x40
000014  1f80              SUBS     r0,r0,#6
000016  4081              LSLS     r1,r1,r0
000018  42a1              CMP      r1,r4
;;;1960           SLI_Level_Temp=(Size>>(FLI_Level_Temp+3))&0x07;
;;;1961       else
;;;1962       {
;;;1963           SLI_Level_Temp=((Size>>(FLI_Level_Temp+3))&0x07)+1;
00001a  f1000103          ADD      r1,r0,#3
00001e  fa24f401          LSR      r4,r4,r1
000022  f0040107          AND      r1,r4,#7
000026  d004              BEQ      |L68.50|
000028  1c49              ADDS     r1,r1,#1              ;1959
;;;1964           
;;;1965           /* If the SLI level is the largest of the SLI level, then jump to the next FLI level */
;;;1966           if(SLI_Level_Temp==8)
00002a  2908              CMP      r1,#8
00002c  d101              BNE      |L68.50|
;;;1967           {
;;;1968               FLI_Level_Temp+=1;
;;;1969               SLI_Level_Temp=0;
00002e  2100              MOVS     r1,#0
000030  1c40              ADDS     r0,r0,#1
                  |L68.50|
;;;1970           }
;;;1971       }
;;;1972       
;;;1973       /* Check if the FLI level is over the boundary */
;;;1974       Mem=(volatile struct RMP_Mem*)Pool;
;;;1975       if((ptr_t)FLI_Level_Temp>=Mem->FLI_Num)
000032  68aa              LDR      r2,[r5,#8]
;;;1976           return -1;
000034  f04f39ff          MOV      r9,#0xffffffff
000038  4282              CMP      r2,r0                 ;1975
00003a  d931              BLS      |L68.160|
;;;1977       
;;;1978       /* Try to find one position on this processor word level */
;;;1979       Level=(FLI_Level_Temp<<3)+SLI_Level_Temp;
00003c  eb0104c0          ADD      r4,r1,r0,LSL #3
;;;1980       LSB=RMP_LSB_Get(Mem->Bitmap[Level>>RMP_WORD_ORDER]>>(Level&RMP_WORD_MASK));
000040  f004080f          AND      r8,r4,#0xf
000044  1160              ASRS     r0,r4,#5
000046  eb050080          ADD      r0,r5,r0,LSL #2
00004a  6940              LDR      r0,[r0,#0x14]
00004c  fa20f008          LSR      r0,r0,r8
000050  f7fffffe          BL       RMP_LSB_Get
;;;1981       /* If there's at least one block that matches the query, return the level */
;;;1982       if(LSB<32)
000054  2820              CMP      r0,#0x20
000056  d208              BCS      |L68.106|
;;;1983       {
;;;1984           Level=(Level&(~RMP_WORD_MASK))+LSB+(Level&RMP_WORD_MASK);
000058  f024010f          BIC      r1,r4,#0xf
00005c  4401              ADD      r1,r1,r0
00005e  eb010008          ADD      r0,r1,r8
;;;1985           *FLI_Level=Level>>3;
000062  10c1              ASRS     r1,r0,#3
;;;1986           *SLI_Level=Level&0x07;
000064  f0000007          AND      r0,r0,#7
;;;1987           return 0;
000068  e012              B        |L68.144|
                  |L68.106|
;;;1988       }
;;;1989       /* No one exactly fits */
;;;1990       else
;;;1991       {
;;;1992           /* From the next word, query one by one */
;;;1993           for(Level=(Level>>RMP_WORD_ORDER)+1;Level<5;Level++)
00006a  2001              MOVS     r0,#1
00006c  eb001464          ADD      r4,r0,r4,ASR #5
000070  e014              B        |L68.156|
;;;1994           {
;;;1995               /* if the level has blocks of one FLI level */
;;;1996               if(Mem->Bitmap[Level]!=0)
000072  bf00              NOP      
                  |L68.116|
000074  eb050084          ADD      r0,r5,r4,LSL #2
000078  6940              LDR      r0,[r0,#0x14]
00007a  b170              CBZ      r0,|L68.154|
;;;1997               {
;;;1998                   /* Find the actual level */ 
;;;1999                   LSB=RMP_LSB_Get(Mem->Bitmap[Level]);
00007c  eb050084          ADD      r0,r5,r4,LSL #2
000080  6940              LDR      r0,[r0,#0x14]
000082  f7fffffe          BL       RMP_LSB_Get
;;;2000                   *FLI_Level=((Level<<RMP_WORD_ORDER)+LSB)>>3;
000086  eb001144          ADD      r1,r0,r4,LSL #5
;;;2001                   *SLI_Level=LSB&0x07;
00008a  f0000007          AND      r0,r0,#7
00008e  08c9              LSRS     r1,r1,#3              ;2000
                  |L68.144|
000090  6039              STR      r1,[r7,#0]
;;;2002                   return 0;
000092  6030              STR      r0,[r6,#0]
000094  2000              MOVS     r0,#0
                  |L68.150|
;;;2003               }
;;;2004           }
;;;2005       }
;;;2006   
;;;2007       /* Search failed */
;;;2008       return -1;
;;;2009   }
000096  e8bd87f0          POP      {r4-r10,pc}
                  |L68.154|
00009a  1c64              ADDS     r4,r4,#1
                  |L68.156|
00009c  2c05              CMP      r4,#5                 ;1993
00009e  dbe9              BLT      |L68.116|
                  |L68.160|
0000a0  4648              MOV      r0,r9                 ;2008
0000a2  e7f8              B        |L68.150|
;;;2010   /* End Function:_RMP_Mem_Search **********************************************/
                          ENDP


                          AREA ||i._RMP_Set_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Set_Rdy PROC
;;;599    ******************************************************************************/
;;;600    void _RMP_Set_Rdy(volatile struct RMP_Thd* Thread)
000000  b510              PUSH     {r4,lr}
;;;601    {
;;;602        /* Insert this into the corresponding runqueue */
;;;603        RMP_List_Ins(&(Thread->Run_Head),RMP_Run[Thread->Prio].Prev,&(RMP_Run[Thread->Prio]));
000002  6a42              LDR      r2,[r0,#0x24]
000004  4603              MOV      r3,r0                 ;601
000006  6a41              LDR      r1,[r0,#0x24]
000008  480e              LDR      r0,|L69.68|
00000a  f8501031          LDR      r1,[r0,r1,LSL #3]
00000e  eb0002c2          ADD      r2,r0,r2,LSL #3
000012  4618              MOV      r0,r3
000014  f7fffffe          BL       RMP_List_Ins
;;;604        /* Set this runlevel as active */
;;;605        RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]|=((ptr_t)1)<<(Thread->Prio&RMP_WORD_MASK);
000018  6a58              LDR      r0,[r3,#0x24]
00001a  2101              MOVS     r1,#1
00001c  4a0a              LDR      r2,|L69.72|
00001e  0940              LSRS     r0,r0,#5
000020  eb020080          ADD      r0,r2,r0,LSL #2
000024  6802              LDR      r2,[r0,#0]
000026  6a5c              LDR      r4,[r3,#0x24]
000028  f004040f          AND      r4,r4,#0xf
00002c  fa01f404          LSL      r4,r1,r4
000030  4322              ORRS     r2,r2,r4
000032  6002              STR      r2,[r0,#0]
;;;606        
;;;607        /* Compare this with the current one to see if we need a context switch */
;;;608        if(Thread->Prio>RMP_Cur_Thd->Prio)
000034  4804              LDR      r0,|L69.72|
000036  6a5a              LDR      r2,[r3,#0x24]
000038  6983              LDR      r3,[r0,#0x18]  ; RMP_Cur_Thd
00003a  6a5b              LDR      r3,[r3,#0x24]
00003c  429a              CMP      r2,r3
00003e  d900              BLS      |L69.66|
;;;609            RMP_Sched_Pend=1;
000040  6101              STR      r1,[r0,#0x10]  ; RMP_Sched_Pend
                  |L69.66|
;;;610    }
000042  bd10              POP      {r4,pc}
;;;611    /* End Function:_RMP_Set_Rdy *************************************************/
                          ENDP

                  |L69.68|
                          DCD      ||.bss||
                  |L69.72|
                          DCD      ||.data||

                          AREA ||i._RMP_Tick_Handler||, CODE, READONLY, ALIGN=2

                  _RMP_Tick_Handler PROC
;;;520    ******************************************************************************/
;;;521    void _RMP_Tick_Handler(ptr_t Ticks)
000000  b510              PUSH     {r4,lr}
;;;522    {
;;;523        struct RMP_Thd* Thread;
;;;524        /* Increase the timestamp as always */
;;;525        RMP_Tick+=Ticks;
000002  4c17              LDR      r4,|L70.96|
000004  6861              LDR      r1,[r4,#4]  ; RMP_Tick
000006  4401              ADD      r1,r1,r0
000008  6061              STR      r1,[r4,#4]  ; RMP_Tick
;;;526    #if(RMP_USE_HOOKS==RMP_TRUE)
;;;527        RMP_Tick_Hook(Ticks);
;;;528    #endif
;;;529        /* See if the current thread expired. If yes, trigger a scheduler event */
;;;530        if(Ticks>=RMP_Cur_Thd->Slices_Left)
00000a  69a1              LDR      r1,[r4,#0x18]  ; RMP_Cur_Thd
;;;531            RMP_Sched_Pend=1;
00000c  2201              MOVS     r2,#1
00000e  6a09              LDR      r1,[r1,#0x20]         ;530
000010  4281              CMP      r1,r0                 ;530
000012  d801              BHI      |L70.24|
000014  6122              STR      r2,[r4,#0x10]  ; RMP_Sched_Pend
000016  e003              B        |L70.32|
                  |L70.24|
;;;532        else
;;;533            RMP_Cur_Thd->Slices_Left-=Ticks;
000018  69a1              LDR      r1,[r4,#0x18]  ; RMP_Cur_Thd
00001a  6a0b              LDR      r3,[r1,#0x20]
00001c  1a18              SUBS     r0,r3,r0
00001e  6208              STR      r0,[r1,#0x20]
                  |L70.32|
;;;534        
;;;535        /* Is the scheduler locked? If yes, we cannot process timer events here and will have to pend them */
;;;536        if((&RMP_Delay)!=RMP_Delay.Next)
000020  480f              LDR      r0,|L70.96|
000022  3020              ADDS     r0,r0,#0x20
000024  6841              LDR      r1,[r0,#4]  ; RMP_Delay
000026  4281              CMP      r1,r0
000028  d00c              BEQ      |L70.68|
;;;537        {
;;;538            Thread=RMP_DLY2THD(RMP_Delay.Next);
00002a  6840              LDR      r0,[r0,#4]  ; RMP_Delay
;;;539            /* If the value is less than this, then it means that the time have
;;;540             * already passed and we have to process this */
;;;541            if((RMP_Tick-Thread->Timeout)<=(RMP_ALLBITS>>1))
00002c  6861              LDR      r1,[r4,#4]  ; RMP_Tick
00002e  6a00              LDR      r0,[r0,#0x20]
000030  1a08              SUBS     r0,r1,r0
000032  f1b04f00          CMP      r0,#0x80000000
000036  d205              BCS      |L70.68|
;;;542            {
;;;543                /* If scheduler locked, we pend the processing until it is unlocked */
;;;544                if(RMP_Sched_Locked!=0)
000038  68e0              LDR      r0,[r4,#0xc]  ; RMP_Sched_Locked
00003a  b108              CBZ      r0,|L70.64|
;;;545                    RMP_Timer_Pend=1;
00003c  6162              STR      r2,[r4,#0x14]  ; RMP_Timer_Pend
00003e  e001              B        |L70.68|
                  |L70.64|
;;;546                else
;;;547                    _RMP_Timer_Proc();
000040  f7fffffe          BL       _RMP_Timer_Proc
                  |L70.68|
;;;548            }
;;;549        }
;;;550        
;;;551        if((RMP_Sched_Locked==0)&&(RMP_Sched_Pend!=0))
000044  68e0              LDR      r0,[r4,#0xc]  ; RMP_Sched_Locked
000046  2800              CMP      r0,#0
000048  d108              BNE      |L70.92|
00004a  6920              LDR      r0,[r4,#0x10]  ; RMP_Sched_Pend
00004c  2800              CMP      r0,#0
00004e  d005              BEQ      |L70.92|
;;;552        {
;;;553            RMP_Sched_Pend=0;
000050  2000              MOVS     r0,#0
000052  6120              STR      r0,[r4,#0x10]  ; RMP_Sched_Pend
;;;554            _RMP_Yield();
000054  e8bd4010          POP      {r4,lr}
000058  f7ffbffe          B.W      _RMP_Yield
                  |L70.92|
;;;555        }
;;;556    }
00005c  bd10              POP      {r4,pc}
;;;557    /* End Function:_RMP_Tick_Handler ********************************************/
                          ENDP

00005e  0000              DCW      0x0000
                  |L70.96|
                          DCD      ||.data||

                          AREA ||i._RMP_Timer_Proc||, CODE, READONLY, ALIGN=2

                  _RMP_Timer_Proc PROC
;;;409    ******************************************************************************/
;;;410    void _RMP_Timer_Proc(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;411    {
;;;412        struct RMP_Thd* Thread;
;;;413        
;;;414        /* Process the timer events, if there are any of them */
;;;415        while((&RMP_Delay)!=RMP_Delay.Next)
;;;416        {
;;;417            Thread=RMP_DLY2THD(RMP_Delay.Next);
000002  4c24              LDR      r4,|L71.148|
;;;418            /* If the value is more than this, then it means that the time have
;;;419             * already passed and we have to process this */
;;;420            if((RMP_Tick-Thread->Timeout)>(RMP_ALLBITS>>1))
;;;421                break;
;;;422            
;;;423            /* This thread should be processed */
;;;424            RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;425            switch(RMP_THD_STATE(Thread->State))
;;;426            {
;;;427                case RMP_THD_SNDDLY:
;;;428                case RMP_THD_SEMDLY:
;;;429                {
;;;430                    RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;431                    Thread->Retval=RMP_ERR_OPER;
;;;432                    break;
;;;433                }
;;;434                
;;;435                case RMP_THD_RCVDLY:
;;;436                {
;;;437                    Thread->Retval=RMP_ERR_OPER;
;;;438                    break;
;;;439                }
;;;440                
;;;441                case RMP_THD_DELAYED:break;
;;;442                /* Should not get here */
;;;443                default:break;
;;;444            }
;;;445    
;;;446            RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;447            /* Is it suspended? If yes, we can't directly set it running */
;;;448            if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;449            {
;;;450                /* Insert this into the corresponding runqueue */
;;;451                RMP_List_Ins(&(Thread->Run_Head),RMP_Run[Thread->Prio].Prev,&(RMP_Run[Thread->Prio]));
;;;452                /* Set this runlevel as active */
;;;453                RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]|=1<<(Thread->Prio&RMP_WORD_MASK);
000004  2601              MOVS     r6,#1
000006  f06f0704          MVN      r7,#4                 ;431
00000a  f1a40520          SUB      r5,r4,#0x20           ;420
00000e  e03d              B        |L71.140|
                  |L71.16|
000010  6863              LDR      r3,[r4,#4]            ;417  ; RMP_Delay
000012  6868              LDR      r0,[r5,#4]            ;420  ; RMP_Tick
000014  6a19              LDR      r1,[r3,#0x20]         ;420
000016  3b08              SUBS     r3,r3,#8              ;420
000018  1a40              SUBS     r0,r0,r1              ;420
00001a  f1b04f00          CMP      r0,#0x80000000        ;420
00001e  d238              BCS      |L71.146|
000020  e9d30102          LDRD     r0,r1,[r3,#8]         ;420
000024  6008              STR      r0,[r1,#0]            ;420
000026  6041              STR      r1,[r0,#4]            ;420
000028  7e18              LDRB     r0,[r3,#0x18]         ;425
00002a  2803              CMP      r0,#3                 ;425
00002c  d005              BEQ      |L71.58|
00002e  2805              CMP      r0,#5                 ;425
000030  d007              BEQ      |L71.66|
000032  2806              CMP      r0,#6                 ;425
000034  d006              BEQ      |L71.68|
000036  2808              CMP      r0,#8                 ;425
000038  d104              BNE      |L71.68|
                  |L71.58|
00003a  e9d30100          LDRD     r0,r1,[r3,#0]         ;425
00003e  6008              STR      r0,[r1,#0]            ;425
000040  6041              STR      r1,[r0,#4]            ;425
                  |L71.66|
000042  639f              STR      r7,[r3,#0x38]         ;437
                  |L71.68|
000044  6998              LDR      r0,[r3,#0x18]         ;446
000046  f02000ff          BIC      r0,r0,#0xff           ;446
00004a  1c40              ADDS     r0,r0,#1              ;446
00004c  6198              STR      r0,[r3,#0x18]         ;448
00004e  05c1              LSLS     r1,r0,#23             ;448
000050  d41c              BMI      |L71.140|
000052  4a11              LDR      r2,|L71.152|
000054  6a58              LDR      r0,[r3,#0x24]         ;451
000056  f8521030          LDR      r1,[r2,r0,LSL #3]     ;451
00005a  eb0202c0          ADD      r2,r2,r0,LSL #3       ;451
00005e  4618              MOV      r0,r3                 ;451
000060  f7fffffe          BL       RMP_List_Ins
000064  4a0b              LDR      r2,|L71.148|
000066  6a59              LDR      r1,[r3,#0x24]
000068  3a20              SUBS     r2,r2,#0x20
00006a  0948              LSRS     r0,r1,#5
00006c  f001010f          AND      r1,r1,#0xf
000070  f852c020          LDR      r12,[r2,r0,LSL #2]
000074  fa06fe01          LSL      lr,r6,r1
000078  ea4c0c0e          ORR      r12,r12,lr
00007c  f842c020          STR      r12,[r2,r0,LSL #2]
;;;454                /* See if we need to pend a scheduling event */
;;;455                if(Thread->Prio>RMP_Cur_Thd->Prio)
000080  69a8              LDR      r0,[r5,#0x18]  ; RMP_Cur_Thd
000082  6a59              LDR      r1,[r3,#0x24]
000084  6a40              LDR      r0,[r0,#0x24]
000086  4281              CMP      r1,r0
000088  d900              BLS      |L71.140|
;;;456                    RMP_Sched_Pend=1;
00008a  612e              STR      r6,[r5,#0x10]  ; RMP_Sched_Pend
                  |L71.140|
00008c  6860              LDR      r0,[r4,#4]            ;415  ; RMP_Delay
00008e  42a0              CMP      r0,r4                 ;415
000090  d1be              BNE      |L71.16|
                  |L71.146|
;;;457            }
;;;458        }
;;;459    }
000092  bdf0              POP      {r4-r7,pc}
;;;460    /* Begin Function:_RMP_Timer_Proc ********************************************/
                          ENDP

                  |L71.148|
                          DCD      ||.data||+0x20
                  |L71.152|
                          DCD      ||.bss||

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;1617   ******************************************************************************/
;;;1618   int main(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1619   {
;;;1620       ptr_t Count;
;;;1621       /* Initialize the kernel data structures first */
;;;1622       _RMP_Low_Level_Init();
000004  f7fffffe          BL       _RMP_Low_Level_Init
;;;1623       
;;;1624   #if(RMP_USE_HOOKS==RMP_TRUE)
;;;1625       RMP_Start_Hook();
;;;1626   #endif
;;;1627       
;;;1628       RMP_Tick=0;
000008  4c1d              LDR      r4,|L72.128|
00000a  2500              MOVS     r5,#0
00000c  6065              STR      r5,[r4,#4]  ; RMP_Tick
;;;1629       /* Now initialize the kernel data structures */
;;;1630       RMP_Sched_Lock_Cnt=0;
00000e  60a5              STR      r5,[r4,#8]  ; RMP_Sched_Lock_Cnt
;;;1631       RMP_Sched_Locked=0;
000010  60e5              STR      r5,[r4,#0xc]  ; RMP_Sched_Locked
;;;1632       RMP_Sched_Pend=0;
000012  6125              STR      r5,[r4,#0x10]  ; RMP_Sched_Pend
;;;1633       RMP_Timer_Pend=0;
000014  6165              STR      r5,[r4,#0x14]  ; RMP_Timer_Pend
;;;1634       
;;;1635       /* Linked lists */
;;;1636       RMP_List_Crt(&RMP_Delay);
000016  f1040020          ADD      r0,r4,#0x20
00001a  6000              STR      r0,[r0,#0]
00001c  6040              STR      r0,[r0,#4]
;;;1637       for(Count=0;Count<RMP_MAX_PREEMPT_PRIO;Count++)
00001e  ea4f0105          MOV.W    r1,r5
;;;1638           RMP_List_Crt(&RMP_Run[Count]);
000022  4f18              LDR      r7,|L72.132|
                  |L72.36|
000024  eb0700c1          ADD      r0,r7,r1,LSL #3
000028  6000              STR      r0,[r0,#0]
00002a  6040              STR      r0,[r0,#4]
00002c  1c49              ADDS     r1,r1,#1
00002e  2920              CMP      r1,#0x20              ;1637
000030  d3f8              BCC      |L72.36|
;;;1639       for(Count=0;Count<RMP_BITMAP_SIZE;Count++)
;;;1640           RMP_Bitmap[Count]=0;
000032  4e13              LDR      r6,|L72.128|
000034  6035              STR      r5,[r6,#0]
;;;1641           
;;;1642       /* Now boot into the first thread */
;;;1643       RMP_Clear(&RMP_Init_Thd,sizeof(struct RMP_Thd));
000036  213c              MOVS     r1,#0x3c
000038  4813              LDR      r0,|L72.136|
00003a  f7fffffe          BL       RMP_Clear
;;;1644       RMP_Init_Thd.Prio=0;
00003e  4b12              LDR      r3,|L72.136|
;;;1645       RMP_Init_Thd.Slices=10;
000040  200a              MOVS     r0,#0xa
;;;1646       RMP_Init_Thd.Slices_Left=10;
;;;1647       RMP_Init_Thd.State=RMP_THD_RUNNING;
000042  2201              MOVS     r2,#1
;;;1648       RMP_Init_Thd.Stack=RMP_INIT_STACK;
000044  f1a30144          SUB      r1,r3,#0x44
000048  625d              STR      r5,[r3,#0x24]         ;1644  ; RMP_Init_Thd
00004a  61d8              STR      r0,[r3,#0x1c]         ;1645  ; RMP_Init_Thd
00004c  6218              STR      r0,[r3,#0x20]         ;1646  ; RMP_Init_Thd
00004e  619a              STR      r2,[r3,#0x18]         ;1647  ; RMP_Init_Thd
000050  6359              STR      r1,[r3,#0x34]  ; RMP_Init_Thd
;;;1649       
;;;1650       /* Initialize sending list */
;;;1651       RMP_List_Crt(&(RMP_Init_Thd.Snd_List));
000052  f1010054          ADD      r0,r1,#0x54
000056  6000              STR      r0,[r0,#0]
000058  6040              STR      r0,[r0,#4]
;;;1652       
;;;1653       /* Insert this into the corresponding runqueue */
;;;1654       RMP_List_Ins(&(RMP_Init_Thd.Run_Head),RMP_Run[0].Prev,&(RMP_Run[0]));
00005a  6839              LDR      r1,[r7,#0]  ; RMP_Run
00005c  3810              SUBS     r0,r0,#0x10
00005e  4a09              LDR      r2,|L72.132|
000060  f7fffffe          BL       RMP_List_Ins
;;;1655       /* Set this runlevel as active - in fact it is always active */
;;;1656       RMP_Bitmap[0]|=1;
000064  6830              LDR      r0,[r6,#0]  ; RMP_Bitmap
000066  f0400001          ORR      r0,r0,#1
00006a  6030              STR      r0,[r6,#0]  ; RMP_Bitmap
;;;1657       
;;;1658       /* Set current thread and stack */
;;;1659       RMP_Cur_Thd=(struct RMP_Thd*)(&RMP_Init_Thd);
00006c  61a3              STR      r3,[r4,#0x18]  ; RMP_Cur_Thd
;;;1660       RMP_Cur_SP=RMP_Init_Thd.Stack;
00006e  6b58              LDR      r0,[r3,#0x34]  ; RMP_Init_Thd
000070  61e0              STR      r0,[r4,#0x1c]  ; RMP_Cur_SP
;;;1661       
;;;1662       /* Now jump to the user function and will never return. Initialization of stack is not needed */
;;;1663       _RMP_Start((ptr_t)RMP_Init, (ptr_t)RMP_Init_Thd.Stack);
000072  6b59              LDR      r1,[r3,#0x34]  ; RMP_Init_Thd
000074  4805              LDR      r0,|L72.140|
000076  f7fffffe          BL       _RMP_Start
;;;1664       
;;;1665       return 0;
00007a  2000              MOVS     r0,#0
;;;1666   }
00007c  e8bd81f0          POP      {r4-r8,pc}
;;;1667   /* End Function:main *********************************************************/
                          ENDP

                  |L72.128|
                          DCD      ||.data||
                  |L72.132|
                          DCD      ||.bss||
                  |L72.136|
                          DCD      ||.bss||+0x200
                  |L72.140|
                          DCD      RMP_Init

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  RMP_Run
                          %        256
                  RMP_Init_Stack
                          %        256
                  RMP_Init_Thd
                          %        60

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  RMP_RBIT_Table
000000  008040c0          DCB      0x00,0x80,0x40,0xc0
000004  20a060e0          DCB      0x20,0xa0,0x60,0xe0
000008  109050d0          DCB      0x10,0x90,0x50,0xd0
00000c  30b070f0          DCB      0x30,0xb0,0x70,0xf0
000010  088848c8          DCB      0x08,0x88,0x48,0xc8
000014  28a868e8          DCB      0x28,0xa8,0x68,0xe8
000018  189858d8          DCB      0x18,0x98,0x58,0xd8
00001c  38b878f8          DCB      0x38,0xb8,0x78,0xf8
000020  048444c4          DCB      0x04,0x84,0x44,0xc4
000024  24a464e4          DCB      0x24,0xa4,0x64,0xe4
000028  149454d4          DCB      0x14,0x94,0x54,0xd4
00002c  34b474f4          DCB      0x34,0xb4,0x74,0xf4
000030  0c8c4ccc          DCB      0x0c,0x8c,0x4c,0xcc
000034  2cac6cec          DCB      0x2c,0xac,0x6c,0xec
000038  1c9c5cdc          DCB      0x1c,0x9c,0x5c,0xdc
00003c  3cbc7cfc          DCB      0x3c,0xbc,0x7c,0xfc
000040  028242c2          DCB      0x02,0x82,0x42,0xc2
000044  22a262e2          DCB      0x22,0xa2,0x62,0xe2
000048  129252d2          DCB      0x12,0x92,0x52,0xd2
00004c  32b272f2          DCB      0x32,0xb2,0x72,0xf2
000050  0a8a4aca          DCB      0x0a,0x8a,0x4a,0xca
000054  2aaa6aea          DCB      0x2a,0xaa,0x6a,0xea
000058  1a9a5ada          DCB      0x1a,0x9a,0x5a,0xda
00005c  3aba7afa          DCB      0x3a,0xba,0x7a,0xfa
000060  068646c6          DCB      0x06,0x86,0x46,0xc6
000064  26a666e6          DCB      0x26,0xa6,0x66,0xe6
000068  169656d6          DCB      0x16,0x96,0x56,0xd6
00006c  36b676f6          DCB      0x36,0xb6,0x76,0xf6
000070  0e8e4ece          DCB      0x0e,0x8e,0x4e,0xce
000074  2eae6eee          DCB      0x2e,0xae,0x6e,0xee
000078  1e9e5ede          DCB      0x1e,0x9e,0x5e,0xde
00007c  3ebe7efe          DCB      0x3e,0xbe,0x7e,0xfe
000080  018141c1          DCB      0x01,0x81,0x41,0xc1
000084  21a161e1          DCB      0x21,0xa1,0x61,0xe1
000088  119151d1          DCB      0x11,0x91,0x51,0xd1
00008c  31b171f1          DCB      0x31,0xb1,0x71,0xf1
000090  098949c9          DCB      0x09,0x89,0x49,0xc9
000094  29a969e9          DCB      0x29,0xa9,0x69,0xe9
000098  199959d9          DCB      0x19,0x99,0x59,0xd9
00009c  39b979f9          DCB      0x39,0xb9,0x79,0xf9
0000a0  058545c5          DCB      0x05,0x85,0x45,0xc5
0000a4  25a565e5          DCB      0x25,0xa5,0x65,0xe5
0000a8  159555d5          DCB      0x15,0x95,0x55,0xd5
0000ac  35b575f5          DCB      0x35,0xb5,0x75,0xf5
0000b0  0d8d4dcd          DCB      0x0d,0x8d,0x4d,0xcd
0000b4  2dad6ded          DCB      0x2d,0xad,0x6d,0xed
0000b8  1d9d5ddd          DCB      0x1d,0x9d,0x5d,0xdd
0000bc  3dbd7dfd          DCB      0x3d,0xbd,0x7d,0xfd
0000c0  038343c3          DCB      0x03,0x83,0x43,0xc3
0000c4  23a363e3          DCB      0x23,0xa3,0x63,0xe3
0000c8  139353d3          DCB      0x13,0x93,0x53,0xd3
0000cc  33b373f3          DCB      0x33,0xb3,0x73,0xf3
0000d0  0b8b4bcb          DCB      0x0b,0x8b,0x4b,0xcb
0000d4  2bab6beb          DCB      0x2b,0xab,0x6b,0xeb
0000d8  1b9b5bdb          DCB      0x1b,0x9b,0x5b,0xdb
0000dc  3bbb7bfb          DCB      0x3b,0xbb,0x7b,0xfb
0000e0  078747c7          DCB      0x07,0x87,0x47,0xc7
0000e4  27a767e7          DCB      0x27,0xa7,0x67,0xe7
0000e8  179757d7          DCB      0x17,0x97,0x57,0xd7
0000ec  37b777f7          DCB      0x37,0xb7,0x77,0xf7
0000f0  0f8f4fcf          DCB      0x0f,0x8f,0x4f,0xcf
0000f4  2faf6fef          DCB      0x2f,0xaf,0x6f,0xef
0000f8  1f9f5fdf          DCB      0x1f,0x9f,0x5f,0xdf
0000fc  3fbf7fff          DCB      0x3f,0xbf,0x7f,0xff
                  CRC16_High
000100  00c18140          DCB      0x00,0xc1,0x81,0x40
000104  01c08041          DCB      0x01,0xc0,0x80,0x41
000108  01c08041          DCB      0x01,0xc0,0x80,0x41
00010c  00c18140          DCB      0x00,0xc1,0x81,0x40
000110  01c08041          DCB      0x01,0xc0,0x80,0x41
000114  00c18140          DCB      0x00,0xc1,0x81,0x40
000118  00c18140          DCB      0x00,0xc1,0x81,0x40
00011c  01c08041          DCB      0x01,0xc0,0x80,0x41
000120  01c08041          DCB      0x01,0xc0,0x80,0x41
000124  00c18140          DCB      0x00,0xc1,0x81,0x40
000128  00c18140          DCB      0x00,0xc1,0x81,0x40
00012c  01c08041          DCB      0x01,0xc0,0x80,0x41
000130  00c18140          DCB      0x00,0xc1,0x81,0x40
000134  01c08041          DCB      0x01,0xc0,0x80,0x41
000138  01c08041          DCB      0x01,0xc0,0x80,0x41
00013c  00c18140          DCB      0x00,0xc1,0x81,0x40
000140  01c08041          DCB      0x01,0xc0,0x80,0x41
000144  00c18140          DCB      0x00,0xc1,0x81,0x40
000148  00c18140          DCB      0x00,0xc1,0x81,0x40
00014c  01c08041          DCB      0x01,0xc0,0x80,0x41
000150  00c18140          DCB      0x00,0xc1,0x81,0x40
000154  01c08041          DCB      0x01,0xc0,0x80,0x41
000158  01c08041          DCB      0x01,0xc0,0x80,0x41
00015c  00c18140          DCB      0x00,0xc1,0x81,0x40
000160  00c18140          DCB      0x00,0xc1,0x81,0x40
000164  01c08041          DCB      0x01,0xc0,0x80,0x41
000168  01c08041          DCB      0x01,0xc0,0x80,0x41
00016c  00c18140          DCB      0x00,0xc1,0x81,0x40
000170  01c08041          DCB      0x01,0xc0,0x80,0x41
000174  00c18140          DCB      0x00,0xc1,0x81,0x40
000178  00c18140          DCB      0x00,0xc1,0x81,0x40
00017c  01c08041          DCB      0x01,0xc0,0x80,0x41
000180  01c08041          DCB      0x01,0xc0,0x80,0x41
000184  00c18140          DCB      0x00,0xc1,0x81,0x40
000188  00c18140          DCB      0x00,0xc1,0x81,0x40
00018c  01c08041          DCB      0x01,0xc0,0x80,0x41
000190  00c18140          DCB      0x00,0xc1,0x81,0x40
000194  01c08041          DCB      0x01,0xc0,0x80,0x41
000198  01c08041          DCB      0x01,0xc0,0x80,0x41
00019c  00c18140          DCB      0x00,0xc1,0x81,0x40
0001a0  00c18140          DCB      0x00,0xc1,0x81,0x40
0001a4  01c08041          DCB      0x01,0xc0,0x80,0x41
0001a8  01c08041          DCB      0x01,0xc0,0x80,0x41
0001ac  00c18140          DCB      0x00,0xc1,0x81,0x40
0001b0  01c08041          DCB      0x01,0xc0,0x80,0x41
0001b4  00c18140          DCB      0x00,0xc1,0x81,0x40
0001b8  00c18140          DCB      0x00,0xc1,0x81,0x40
0001bc  01c08041          DCB      0x01,0xc0,0x80,0x41
0001c0  00c18140          DCB      0x00,0xc1,0x81,0x40
0001c4  01c08041          DCB      0x01,0xc0,0x80,0x41
0001c8  01c08041          DCB      0x01,0xc0,0x80,0x41
0001cc  00c18140          DCB      0x00,0xc1,0x81,0x40
0001d0  01c08041          DCB      0x01,0xc0,0x80,0x41
0001d4  00c18140          DCB      0x00,0xc1,0x81,0x40
0001d8  00c18140          DCB      0x00,0xc1,0x81,0x40
0001dc  01c08041          DCB      0x01,0xc0,0x80,0x41
0001e0  01c08041          DCB      0x01,0xc0,0x80,0x41
0001e4  00c18140          DCB      0x00,0xc1,0x81,0x40
0001e8  00c18140          DCB      0x00,0xc1,0x81,0x40
0001ec  01c08041          DCB      0x01,0xc0,0x80,0x41
0001f0  00c18140          DCB      0x00,0xc1,0x81,0x40
0001f4  01c08041          DCB      0x01,0xc0,0x80,0x41
0001f8  01c08041          DCB      0x01,0xc0,0x80,0x41
0001fc  00c18140          DCB      0x00,0xc1,0x81,0x40
                  Arrow_B
000200  00101120          DCB      0x00,0x10,0x11,0x20
000204  22303340          DCB      0x22,0x30,0x33,0x40
000208  44505560          DCB      0x44,0x50,0x55,0x60
00020c  66707780          DCB      0x66,0x70,0x77,0x80
000210  88909596          DCB      0x88,0x90,0x95,0x96
000214  979899a0          DCB      0x97,0x98,0x99,0xa0
000218  a2a3a5b0          DCB      0xa2,0xa3,0xa5,0xb0
00021c  b1b3b6c0          DCB      0xb1,0xb3,0xb6,0xc0
000220  c1c4c6d0          DCB      0xc1,0xc4,0xc6,0xd0
000224  d4d7e5e7          DCB      0xd4,0xd7,0xe5,0xe7
000228  f5f6              DCB      0xf5,0xf6
                  Arrow_W
00022a  2131              DCB      0x21,0x31
00022c  32414243          DCB      0x32,0x41,0x42,0x43
000230  51525354          DCB      0x51,0x52,0x53,0x54
000234  61626364          DCB      0x61,0x62,0x63,0x64
000238  65717273          DCB      0x65,0x71,0x72,0x73
00023c  74757681          DCB      0x74,0x75,0x76,0x81
000240  82838485          DCB      0x82,0x83,0x84,0x85
000244  86879192          DCB      0x86,0x87,0x91,0x92
000248  9394a1a4          DCB      0x93,0x94,0xa1,0xa4
00024c  b4b5c5d5          DCB      0xb4,0xb5,0xc5,0xd5
000250  d6e6              DCB      0xd6,0xe6
                  Busy_B
000252  0a0b              DCB      0x0a,0x0b
000254  0c0d0e1a          DCB      0x0c,0x0d,0x0e,0x1a
000258  1b1d1e2a          DCB      0x1b,0x1d,0x1e,0x2a
00025c  2c2e3b3d          DCB      0x2c,0x2e,0x3b,0x3d
000260  4c5b5d6a          DCB      0x4c,0x5b,0x5d,0x6a
000264  6e7a7c7e          DCB      0x6e,0x7a,0x7c,0x7e
000268  8a8b8c8d          DCB      0x8a,0x8b,0x8c,0x8d
00026c  8e                DCB      0x8e
                  Busy_W
00026d  1c2b2d            DCB      0x1c,0x2b,0x2d
000270  3c5c6b6c          DCB      0x3c,0x5c,0x6b,0x6c
000274  6d7b7d            DCB      0x6d,0x7b,0x7d
                  Question
000277  0b                DCB      0x0b
000278  0c0d1a1b          DCB      0x0c,0x0d,0x1a,0x1b
00027c  1c1d1e29          DCB      0x1c,0x1d,0x1e,0x29
000280  2a2b2d2e          DCB      0x2a,0x2b,0x2d,0x2e
000284  2f393a3e          DCB      0x2f,0x39,0x3a,0x3e
000288  3f4a4d4e          DCB      0x3f,0x4a,0x4d,0x4e
00028c  4f5c5d5e          DCB      0x4f,0x5c,0x5d,0x5e
000290  6c6d8d8e          DCB      0x6c,0x6d,0x8d,0x8e
000294  9d9e              DCB      0x9d,0x9e
                  Hand_B
000296  0506              DCB      0x05,0x06
000298  14172427          DCB      0x14,0x17,0x24,0x27
00029c  34373944          DCB      0x34,0x37,0x39,0x44
0002a0  47484a4c          DCB      0x47,0x48,0x4a,0x4c
0002a4  51525457          DCB      0x51,0x52,0x54,0x57
0002a8  5a5b5d5e          DCB      0x5a,0x5b,0x5d,0x5e
0002ac  60636467          DCB      0x60,0x63,0x64,0x67
0002b0  6a6d6f70          DCB      0x6a,0x6d,0x6f,0x70
0002b4  74777a7d          DCB      0x74,0x77,0x7a,0x7d
0002b8  7f808f90          DCB      0x7f,0x80,0x8f,0x90
0002bc  9fa0afb0          DCB      0x9f,0xa0,0xaf,0xb0
0002c0  bfc1ced1          DCB      0xbf,0xc1,0xce,0xd1
0002c4  d2d3d4d5          DCB      0xd2,0xd3,0xd4,0xd5
0002c8  d6d7d8d9          DCB      0xd6,0xd7,0xd8,0xd9
0002cc  dadbdcdd          DCB      0xda,0xdb,0xdc,0xdd
0002d0  dee1eef2          DCB      0xde,0xe1,0xee,0xf2
0002d4  f3f4f5f6          DCB      0xf3,0xf4,0xf5,0xf6
0002d8  f7f8f9fa          DCB      0xf7,0xf8,0xf9,0xfa
0002dc  fbfcfd            DCB      0xfb,0xfc,0xfd
                  Hand_W
0002df  15                DCB      0x15
0002e0  16252635          DCB      0x16,0x25,0x26,0x35
0002e4  36454649          DCB      0x36,0x45,0x46,0x49
0002e8  55565859          DCB      0x55,0x56,0x58,0x59
0002ec  5c616265          DCB      0x5c,0x61,0x62,0x65
0002f0  6668696b          DCB      0x66,0x68,0x69,0x6b
0002f4  6c6e7172          DCB      0x6c,0x6e,0x71,0x72
0002f8  73757678          DCB      0x73,0x75,0x76,0x78
0002fc  797b7c7e          DCB      0x79,0x7b,0x7c,0x7e
000300  81828384          DCB      0x81,0x82,0x83,0x84
000304  85868788          DCB      0x85,0x86,0x87,0x88
000308  898a8b8c          DCB      0x89,0x8a,0x8b,0x8c
00030c  8d8e9192          DCB      0x8d,0x8e,0x91,0x92
000310  93949596          DCB      0x93,0x94,0x95,0x96
000314  9798999a          DCB      0x97,0x98,0x99,0x9a
000318  9b9c9d9e          DCB      0x9b,0x9c,0x9d,0x9e
00031c  a1a2a3a4          DCB      0xa1,0xa2,0xa3,0xa4
000320  a5a6a7a8          DCB      0xa5,0xa6,0xa7,0xa8
000324  a9aaabac          DCB      0xa9,0xaa,0xab,0xac
000328  adaeb1b2          DCB      0xad,0xae,0xb1,0xb2
00032c  b3b4b5b6          DCB      0xb3,0xb4,0xb5,0xb6
000330  b7b8b9ba          DCB      0xb7,0xb8,0xb9,0xba
000334  bbbcbdbe          DCB      0xbb,0xbc,0xbd,0xbe
000338  c2c3c4c5          DCB      0xc2,0xc3,0xc4,0xc5
00033c  c6c7c8c9          DCB      0xc6,0xc7,0xc8,0xc9
000340  cacbcccd          DCB      0xca,0xcb,0xcc,0xcd
000344  e2e3e4e5          DCB      0xe2,0xe3,0xe4,0xe5
000348  e6e7e8e9          DCB      0xe6,0xe7,0xe8,0xe9
00034c  eaebeced          DCB      0xea,0xeb,0xec,0xed
                  Text
000350  00010204          DCB      0x00,0x01,0x02,0x04
000354  05061323          DCB      0x05,0x06,0x13,0x23
000358  33435363          DCB      0x33,0x43,0x53,0x63
00035c  738393a3          DCB      0x73,0x83,0x93,0xa3
000360  b3c3d3e3          DCB      0xb3,0xc3,0xd3,0xe3
000364  f0f1f2f4          DCB      0xf0,0xf1,0xf2,0xf4
000368  f5f6              DCB      0xf5,0xf6
                  Stop_B
00036a  0506              DCB      0x05,0x06
00036c  07081314          DCB      0x07,0x08,0x13,0x14
000370  15161718          DCB      0x15,0x16,0x17,0x18
000374  191a2223          DCB      0x19,0x1a,0x22,0x23
000378  24292a2b          DCB      0x24,0x29,0x2a,0x2b
00037c  31323334          DCB      0x31,0x32,0x33,0x34
000380  3a3b3c41          DCB      0x3a,0x3b,0x3c,0x41
000384  42434445          DCB      0x42,0x43,0x44,0x45
000388  4b4c5051          DCB      0x4b,0x4c,0x50,0x51
00038c  5455565c          DCB      0x54,0x55,0x56,0x5c
000390  5d606165          DCB      0x5d,0x60,0x61,0x65
000394  66676c6d          DCB      0x66,0x67,0x6c,0x6d
000398  70717677          DCB      0x70,0x71,0x76,0x77
00039c  787c7d80          DCB      0x78,0x7c,0x7d,0x80
0003a0  81878889          DCB      0x81,0x87,0x88,0x89
0003a4  8c8d9192          DCB      0x8c,0x8d,0x91,0x92
0003a8  98999a9b          DCB      0x98,0x99,0x9a,0x9b
0003ac  9ca1a2a3          DCB      0x9c,0xa1,0xa2,0xa3
0003b0  a9aaabac          DCB      0xa9,0xaa,0xab,0xac
0003b4  b2b3b4b9          DCB      0xb2,0xb3,0xb4,0xb9
0003b8  babbc3c4          DCB      0xba,0xbb,0xc3,0xc4
0003bc  c5c6c7c8          DCB      0xc5,0xc6,0xc7,0xc8
0003c0  c9cad5d6          DCB      0xc9,0xca,0xd5,0xd6
0003c4  d7d8              DCB      0xd7,0xd8
                  Stop_W
0003c6  2526              DCB      0x25,0x26
0003c8  27283536          DCB      0x27,0x28,0x35,0x36
0003cc  37383946          DCB      0x37,0x38,0x39,0x46
0003d0  4748494a          DCB      0x47,0x48,0x49,0x4a
0003d4  52535758          DCB      0x52,0x53,0x57,0x58
0003d8  595a5b62          DCB      0x59,0x5a,0x5b,0x62
0003dc  63646869          DCB      0x63,0x64,0x68,0x69
0003e0  6a6b7273          DCB      0x6a,0x6b,0x72,0x73
0003e4  7475797a          DCB      0x74,0x75,0x79,0x7a
0003e8  7b828384          DCB      0x7b,0x82,0x83,0x84
0003ec  85868a8b          DCB      0x85,0x86,0x8a,0x8b
0003f0  93949596          DCB      0x93,0x94,0x95,0x96
0003f4  97a4a5a6          DCB      0x97,0xa4,0xa5,0xa6
0003f8  a7a8b5b6          DCB      0xa7,0xa8,0xb5,0xb6
0003fc  b7b8              DCB      0xb7,0xb8
                  Adj_ALL
0003fe  0716              DCB      0x07,0x16
000400  17182526          DCB      0x17,0x18,0x25,0x26
000404  27282937          DCB      0x27,0x28,0x29,0x37
000408  4752575c          DCB      0x47,0x52,0x57,0x5c
00040c  6162676c          DCB      0x61,0x62,0x67,0x6c
000410  6d707172          DCB      0x6d,0x70,0x71,0x72
000414  73747576          DCB      0x73,0x74,0x75,0x76
000418  7778797a          DCB      0x77,0x78,0x79,0x7a
00041c  7b7c7d7e          DCB      0x7b,0x7c,0x7d,0x7e
000420  8182878c          DCB      0x81,0x82,0x87,0x8c
000424  8d92979c          DCB      0x8d,0x92,0x97,0x9c
000428  a7b7c5c6          DCB      0xa7,0xb7,0xc5,0xc6
00042c  c7c8c9d6          DCB      0xc7,0xc8,0xc9,0xd6
000430  d7d8e7            DCB      0xd7,0xd8,0xe7
                  Adj_LR
000433  52                DCB      0x52
000434  5d61626d          DCB      0x5d,0x61,0x62,0x6d
000438  6e707172          DCB      0x6e,0x70,0x71,0x72
00043c  73747576          DCB      0x73,0x74,0x75,0x76
000440  7778797a          DCB      0x77,0x78,0x79,0x7a
000444  7b7c7d7e          DCB      0x7b,0x7c,0x7d,0x7e
000448  7f81828d          DCB      0x7f,0x81,0x82,0x8d
00044c  8e929d            DCB      0x8e,0x92,0x9d
                  Adj_UD
00044f  07                DCB      0x07
000450  16171825          DCB      0x16,0x17,0x18,0x25
000454  26272829          DCB      0x26,0x27,0x28,0x29
000458  37475767          DCB      0x37,0x47,0x57,0x67
00045c  778797a7          DCB      0x77,0x87,0x97,0xa7
000460  b7c7d5d6          DCB      0xb7,0xc7,0xd5,0xd6
000464  d7d8d9e6          DCB      0xd7,0xd8,0xd9,0xe6
000468  e7e8f7            DCB      0xe7,0xe8,0xf7
                  Adj_BRUL
00046b  00                DCB      0x00
00046c  01020304          DCB      0x01,0x02,0x03,0x04
000470  10111213          DCB      0x10,0x11,0x12,0x13
000474  20212230          DCB      0x20,0x21,0x22,0x30
000478  31334044          DCB      0x31,0x33,0x40,0x44
00047c  55667788          DCB      0x55,0x66,0x77,0x88
000480  99aabbbf          DCB      0x99,0xaa,0xbb,0xbf
000484  cccecfdd          DCB      0xcc,0xce,0xcf,0xdd
000488  dedfeced          DCB      0xde,0xdf,0xec,0xed
00048c  eeeffbfc          DCB      0xee,0xef,0xfb,0xfc
000490  fdfeff            DCB      0xfd,0xfe,0xff
                  Adj_BLUR
000493  0b                DCB      0x0b
000494  0c0d0e0f          DCB      0x0c,0x0d,0x0e,0x0f
000498  1c1d1e1f          DCB      0x1c,0x1d,0x1e,0x1f
00049c  2d2e2f3c          DCB      0x2d,0x2e,0x2f,0x3c
0004a0  3e3f4b4f          DCB      0x3e,0x3f,0x4b,0x4f
0004a4  5a697887          DCB      0x5a,0x69,0x78,0x87
0004a8  96a5b0b4          DCB      0x96,0xa5,0xb0,0xb4
0004ac  c0c1c3d0          DCB      0xc0,0xc1,0xc3,0xd0
0004b0  d1d2e0e1          DCB      0xd1,0xd2,0xe0,0xe1
0004b4  e2e3f0f1          DCB      0xe2,0xe3,0xf0,0xf1
0004b8  f2f3f4            DCB      0xf2,0xf3,0xf4
                  Cross
0004bb  07                DCB      0x07
0004bc  17273746          DCB      0x17,0x27,0x37,0x46
0004c0  47485557          DCB      0x47,0x48,0x55,0x57
0004c4  59646a70          DCB      0x59,0x64,0x6a,0x70
0004c8  71727374          DCB      0x71,0x72,0x73,0x74
0004cc  7577797a          DCB      0x75,0x77,0x79,0x7a
0004d0  7b7c7d7e          DCB      0x7b,0x7c,0x7d,0x7e
0004d4  848a9597          DCB      0x84,0x8a,0x95,0x97
0004d8  99a6a7a8          DCB      0x99,0xa6,0xa7,0xa8
0004dc  b7c7d7e7          DCB      0xb7,0xc7,0xd7,0xe7
0004e0  00c0c101          DCB      0x00,0xc0,0xc1,0x01
0004e4  c30302c2          DCB      0xc3,0x03,0x02,0xc2
0004e8  c60607c7          DCB      0xc6,0x06,0x07,0xc7
0004ec  05c5c404          DCB      0x05,0xc5,0xc4,0x04
0004f0  cc0c0dcd          DCB      0xcc,0x0c,0x0d,0xcd
0004f4  0fcfce0e          DCB      0x0f,0xcf,0xce,0x0e
0004f8  0acacb0b          DCB      0x0a,0xca,0xcb,0x0b
0004fc  c90908c8          DCB      0xc9,0x09,0x08,0xc8
000500  d81819d9          DCB      0xd8,0x18,0x19,0xd9
000504  1bdbda1a          DCB      0x1b,0xdb,0xda,0x1a
000508  1ededf1f          DCB      0x1e,0xde,0xdf,0x1f
00050c  dd1d1cdc          DCB      0xdd,0x1d,0x1c,0xdc
000510  14d4d515          DCB      0x14,0xd4,0xd5,0x15
000514  d71716d6          DCB      0xd7,0x17,0x16,0xd6
000518  d21213d3          DCB      0xd2,0x12,0x13,0xd3
00051c  11d1d010          DCB      0x11,0xd1,0xd0,0x10
000520  f03031f1          DCB      0xf0,0x30,0x31,0xf1
000524  33f3f232          DCB      0x33,0xf3,0xf2,0x32
000528  36f6f737          DCB      0x36,0xf6,0xf7,0x37
00052c  f53534f4          DCB      0xf5,0x35,0x34,0xf4
000530  3cfcfd3d          DCB      0x3c,0xfc,0xfd,0x3d
000534  ff3f3efe          DCB      0xff,0x3f,0x3e,0xfe
000538  fa3a3bfb          DCB      0xfa,0x3a,0x3b,0xfb
00053c  39f9f838          DCB      0x39,0xf9,0xf8,0x38
000540  28e8e929          DCB      0x28,0xe8,0xe9,0x29
000544  eb2b2aea          DCB      0xeb,0x2b,0x2a,0xea
000548  ee2e2fef          DCB      0xee,0x2e,0x2f,0xef
00054c  2dedec2c          DCB      0x2d,0xed,0xec,0x2c
000550  e42425e5          DCB      0xe4,0x24,0x25,0xe5
000554  27e7e626          DCB      0x27,0xe7,0xe6,0x26
000558  22e2e323          DCB      0x22,0xe2,0xe3,0x23
00055c  e12120e0          DCB      0xe1,0x21,0x20,0xe0
000560  a06061a1          DCB      0xa0,0x60,0x61,0xa1
000564  63a3a262          DCB      0x63,0xa3,0xa2,0x62
000568  66a6a767          DCB      0x66,0xa6,0xa7,0x67
00056c  a56564a4          DCB      0xa5,0x65,0x64,0xa4
000570  6cacad6d          DCB      0x6c,0xac,0xad,0x6d
000574  af6f6eae          DCB      0xaf,0x6f,0x6e,0xae
000578  aa6a6bab          DCB      0xaa,0x6a,0x6b,0xab
00057c  69a9a868          DCB      0x69,0xa9,0xa8,0x68
000580  78b8b979          DCB      0x78,0xb8,0xb9,0x79
000584  bb7b7aba          DCB      0xbb,0x7b,0x7a,0xba
000588  be7e7fbf          DCB      0xbe,0x7e,0x7f,0xbf
00058c  7dbdbc7c          DCB      0x7d,0xbd,0xbc,0x7c
000590  b47475b5          DCB      0xb4,0x74,0x75,0xb5
000594  77b7b676          DCB      0x77,0xb7,0xb6,0x76
000598  72b2b373          DCB      0x72,0xb2,0xb3,0x73
00059c  b17170b0          DCB      0xb1,0x71,0x70,0xb0
0005a0  50909151          DCB      0x50,0x90,0x91,0x51
0005a4  93535292          DCB      0x93,0x53,0x52,0x92
0005a8  96565797          DCB      0x96,0x56,0x57,0x97
0005ac  55959454          DCB      0x55,0x95,0x94,0x54
0005b0  9c5c5d9d          DCB      0x9c,0x5c,0x5d,0x9d
0005b4  5f9f9e5e          DCB      0x5f,0x9f,0x9e,0x5e
0005b8  5a9a9b5b          DCB      0x5a,0x9a,0x9b,0x5b
0005bc  99595898          DCB      0x99,0x59,0x58,0x98
0005c0  88484989          DCB      0x88,0x48,0x49,0x89
0005c4  4b8b8a4a          DCB      0x4b,0x8b,0x8a,0x4a
0005c8  4e8e8f4f          DCB      0x4e,0x8e,0x8f,0x4f
0005cc  8d4d4c8c          DCB      0x8d,0x4d,0x4c,0x8c
0005d0  44848545          DCB      0x44,0x84,0x85,0x45
0005d4  87474686          DCB      0x87,0x47,0x46,0x86
0005d8  82424383          DCB      0x82,0x42,0x43,0x83
0005dc  41818040          DCB      0x41,0x81,0x80,0x40

                          AREA ||.data||, DATA, ALIGN=2

                  RMP_Bitmap
                          DCD      0x00000000
                  RMP_Tick
                          DCD      0x00000000
                  RMP_Sched_Lock_Cnt
                          DCD      0x00000000
                  RMP_Sched_Locked
                          DCD      0x00000000
                  RMP_Sched_Pend
                          DCD      0x00000000
                  RMP_Timer_Pend
                          DCD      0x00000000
                  RMP_Cur_Thd
                          DCD      0x00000000
                  RMP_Cur_SP
                          DCD      0x00000000
                  RMP_Delay
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\..\\MProkaron\\Kernel\\kernel.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_kernel_c_346ad0e8____REV16|
#line 388 "..\\..\\..\\M0P0_Library\\STM32F7xx_HAL_Driver\\Core\\cmsis_armcc.h"
|__asm___8_kernel_c_346ad0e8____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_kernel_c_346ad0e8____REVSH|
#line 402
|__asm___8_kernel_c_346ad0e8____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___8_kernel_c_346ad0e8____RRX|
#line 587
|__asm___8_kernel_c_346ad0e8____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
