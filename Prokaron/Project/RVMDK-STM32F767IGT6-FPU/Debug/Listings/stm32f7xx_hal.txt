; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f7xx_hal.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f7xx_hal.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Core -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Inc -I.\Source -I.\Drivers -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6-FPU\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f7xx_hal.crf ..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal.c]
                          THUMB

                          AREA ||i.HAL_DBGMCU_DisableDBGSleepMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_DisableDBGSleepMode PROC
;;;485      */
;;;486    void HAL_DBGMCU_DisableDBGSleepMode(void)
000000  4802              LDR      r0,|L1.12|
;;;487    {
;;;488      CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
000002  6841              LDR      r1,[r0,#4]
000004  f0210101          BIC      r1,r1,#1
000008  6041              STR      r1,[r0,#4]
;;;489    }
00000a  4770              BX       lr
;;;490    
                          ENDP

                  |L1.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_DisableDBGStandbyMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_DisableDBGStandbyMode PROC
;;;521      */
;;;522    void HAL_DBGMCU_DisableDBGStandbyMode(void)
000000  4802              LDR      r0,|L2.12|
;;;523    {
;;;524      CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
000002  6841              LDR      r1,[r0,#4]
000004  f0210104          BIC      r1,r1,#4
000008  6041              STR      r1,[r0,#4]
;;;525    }
00000a  4770              BX       lr
;;;526    
                          ENDP

                  |L2.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_DisableDBGStopMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_DisableDBGStopMode PROC
;;;503      */
;;;504    void HAL_DBGMCU_DisableDBGStopMode(void)
000000  4802              LDR      r0,|L3.12|
;;;505    {
;;;506      CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
000002  6841              LDR      r1,[r0,#4]
000004  f0210102          BIC      r1,r1,#2
000008  6041              STR      r1,[r0,#4]
;;;507    }
00000a  4770              BX       lr
;;;508    
                          ENDP

                  |L3.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_EnableDBGSleepMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_EnableDBGSleepMode PROC
;;;476      */
;;;477    void HAL_DBGMCU_EnableDBGSleepMode(void)
000000  4802              LDR      r0,|L4.12|
;;;478    {
;;;479      SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
000002  6841              LDR      r1,[r0,#4]
000004  f0410101          ORR      r1,r1,#1
000008  6041              STR      r1,[r0,#4]
;;;480    }
00000a  4770              BX       lr
;;;481    
                          ENDP

                  |L4.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_EnableDBGStandbyMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_EnableDBGStandbyMode PROC
;;;512      */
;;;513    void HAL_DBGMCU_EnableDBGStandbyMode(void)
000000  4802              LDR      r0,|L5.12|
;;;514    {
;;;515      SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
000002  6841              LDR      r1,[r0,#4]
000004  f0410104          ORR      r1,r1,#4
000008  6041              STR      r1,[r0,#4]
;;;516    }
00000a  4770              BX       lr
;;;517    
                          ENDP

                  |L5.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_EnableDBGStopMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_EnableDBGStopMode PROC
;;;494      */
;;;495    void HAL_DBGMCU_EnableDBGStopMode(void)
000000  4802              LDR      r0,|L6.12|
;;;496    {
;;;497      SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
000002  6841              LDR      r1,[r0,#4]
000004  f0410102          ORR      r1,r1,#2
000008  6041              STR      r1,[r0,#4]
;;;498    }
00000a  4770              BX       lr
;;;499    
                          ENDP

                  |L6.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_DeInit PROC
;;;183      */
;;;184    HAL_StatusTypeDef HAL_DeInit(void)
000000  b570              PUSH     {r4-r6,lr}
;;;185    {
;;;186      /* Reset of all peripherals */
;;;187      __HAL_RCC_APB1_FORCE_RESET();
000002  4e0b              LDR      r6,|L7.48|
;;;188      __HAL_RCC_APB1_RELEASE_RESET();
000004  2100              MOVS     r1,#0
;;;189    
;;;190      __HAL_RCC_APB2_FORCE_RESET();
;;;191      __HAL_RCC_APB2_RELEASE_RESET();
;;;192    
;;;193      __HAL_RCC_AHB1_FORCE_RESET();
000006  4a0a              LDR      r2,|L7.48|
000008  f04f30ff          MOV      r0,#0xffffffff        ;187
00000c  1d35              ADDS     r5,r6,#4              ;190
00000e  3a10              SUBS     r2,r2,#0x10
;;;194      __HAL_RCC_AHB1_RELEASE_RESET();
;;;195    
;;;196      __HAL_RCC_AHB2_FORCE_RESET();
000010  1d14              ADDS     r4,r2,#4
000012  6030              STR      r0,[r6,#0]            ;187
;;;197      __HAL_RCC_AHB2_RELEASE_RESET();
;;;198    
;;;199      __HAL_RCC_AHB3_FORCE_RESET();
000014  1d23              ADDS     r3,r4,#4
000016  6031              STR      r1,[r6,#0]            ;188
000018  6028              STR      r0,[r5,#0]            ;190
00001a  6029              STR      r1,[r5,#0]            ;191
00001c  6010              STR      r0,[r2,#0]            ;193
00001e  6011              STR      r1,[r2,#0]            ;194
000020  6020              STR      r0,[r4,#0]            ;196
000022  6021              STR      r1,[r4,#0]            ;197
000024  6018              STR      r0,[r3,#0]
;;;200      __HAL_RCC_AHB3_RELEASE_RESET();
000026  6019              STR      r1,[r3,#0]
;;;201    
;;;202      /* De-Init the low level hardware */
;;;203      HAL_MspDeInit();
000028  f7fffffe          BL       HAL_MspDeInit
;;;204        
;;;205      /* Return function status */
;;;206      return HAL_OK;
00002c  2000              MOVS     r0,#0
;;;207    }
00002e  bd70              POP      {r4-r6,pc}
;;;208    
                          ENDP

                  |L7.48|
                          DCD      0x40023820

                          AREA ||i.HAL_Delay||, CODE, READONLY, ALIGN=2

                  HAL_Delay PROC
;;;370      */
;;;371    __weak void HAL_Delay(uint32_t Delay)
000000  b570              PUSH     {r4-r6,lr}
;;;372    {
000002  4604              MOV      r4,r0
;;;373      uint32_t tickstart = HAL_GetTick();
000004  f7fffffe          BL       HAL_GetTick
000008  4605              MOV      r5,r0
;;;374      uint32_t wait = Delay;
;;;375    
;;;376      /* Add a freq to guarantee minimum wait */
;;;377      if (wait < HAL_MAX_DELAY)
00000a  1c60              ADDS     r0,r4,#1
00000c  d002              BEQ      |L8.20|
;;;378      {
;;;379        wait += (uint32_t)(uwTickFreq);
00000e  4804              LDR      r0,|L8.32|
000010  6840              LDR      r0,[r0,#4]  ; uwTickFreq
000012  4404              ADD      r4,r4,r0
                  |L8.20|
;;;380      }
;;;381    
;;;382      while ((HAL_GetTick() - tickstart) < wait)
000014  f7fffffe          BL       HAL_GetTick
000018  1b40              SUBS     r0,r0,r5
00001a  42a0              CMP      r0,r4
00001c  d3fa              BCC      |L8.20|
;;;383      {
;;;384      }
;;;385    }
00001e  bd70              POP      {r4-r6,pc}
;;;386    
                          ENDP

                  |L8.32|
                          DCD      ||.data||

                          AREA ||i.HAL_DisableCompensationCell||, CODE, READONLY, ALIGN=2

                  HAL_DisableCompensationCell PROC
;;;543      */
;;;544    void HAL_DisableCompensationCell(void)
000000  4802              LDR      r0,|L9.12|
;;;545    {
;;;546      SYSCFG->CMPCR &= (uint32_t)~((uint32_t)SYSCFG_CMPCR_CMP_PD);
000002  6801              LDR      r1,[r0,#0]
000004  f0210101          BIC      r1,r1,#1
000008  6001              STR      r1,[r0,#0]
;;;547    }
00000a  4770              BX       lr
;;;548    
                          ENDP

                  |L9.12|
                          DCD      0x40013820

                          AREA ||i.HAL_DisableFMCMemorySwapping||, CODE, READONLY, ALIGN=2

                  HAL_DisableFMCMemorySwapping PROC
;;;569      */
;;;570    void HAL_DisableFMCMemorySwapping(void)
000000  4802              LDR      r0,|L10.12|
;;;571    {
;;;572    
;;;573      SYSCFG->MEMRMP &= (uint32_t)~((uint32_t)SYSCFG_MEMRMP_SWP_FMC);
000002  6801              LDR      r1,[r0,#0]
000004  f4216140          BIC      r1,r1,#0xc00
000008  6001              STR      r1,[r0,#0]
;;;574    }
00000a  4770              BX       lr
;;;575    
                          ENDP

                  |L10.12|
                          DCD      0x40013800

                          AREA ||i.HAL_DisableMemorySwappingBank||, CODE, READONLY, ALIGN=2

                  HAL_DisableMemorySwappingBank PROC
;;;601    */
;;;602    void HAL_DisableMemorySwappingBank(void)
000000  4802              LDR      r0,|L11.12|
;;;603    {
;;;604      CLEAR_BIT(SYSCFG->MEMRMP, SYSCFG_MEMRMP_SWP_FB);
000002  6801              LDR      r1,[r0,#0]
000004  f4217180          BIC      r1,r1,#0x100
000008  6001              STR      r1,[r0,#0]
;;;605    }
00000a  4770              BX       lr
;;;606    #endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
                          ENDP

                  |L11.12|
                          DCD      0x40013800

                          AREA ||i.HAL_EnableCompensationCell||, CODE, READONLY, ALIGN=2

                  HAL_EnableCompensationCell PROC
;;;532      */
;;;533    void HAL_EnableCompensationCell(void)
000000  4802              LDR      r0,|L12.12|
;;;534    {
;;;535      SYSCFG->CMPCR |= SYSCFG_CMPCR_CMP_PD;
000002  6801              LDR      r1,[r0,#0]
000004  f0410101          ORR      r1,r1,#1
000008  6001              STR      r1,[r0,#0]
;;;536    }
00000a  4770              BX       lr
;;;537    
                          ENDP

                  |L12.12|
                          DCD      0x40013820

                          AREA ||i.HAL_EnableFMCMemorySwapping||, CODE, READONLY, ALIGN=2

                  HAL_EnableFMCMemorySwapping PROC
;;;556      */
;;;557    void HAL_EnableFMCMemorySwapping(void)
000000  4802              LDR      r0,|L13.12|
;;;558    {
;;;559      SYSCFG->MEMRMP |= SYSCFG_MEMRMP_SWP_FMC_0;
000002  6801              LDR      r1,[r0,#0]
000004  f4416180          ORR      r1,r1,#0x400
000008  6001              STR      r1,[r0,#0]
;;;560    }
00000a  4770              BX       lr
;;;561    
                          ENDP

                  |L13.12|
                          DCD      0x40013800

                          AREA ||i.HAL_EnableMemorySwappingBank||, CODE, READONLY, ALIGN=2

                  HAL_EnableMemorySwappingBank PROC
;;;586    */
;;;587    void HAL_EnableMemorySwappingBank(void)
000000  4802              LDR      r0,|L14.12|
;;;588    {
;;;589      SET_BIT(SYSCFG->MEMRMP, SYSCFG_MEMRMP_SWP_FB);
000002  6801              LDR      r1,[r0,#0]
000004  f4417180          ORR      r1,r1,#0x100
000008  6001              STR      r1,[r0,#0]
;;;590    }
00000a  4770              BX       lr
;;;591    
                          ENDP

                  |L14.12|
                          DCD      0x40013800

                          AREA ||i.HAL_GetDEVID||, CODE, READONLY, ALIGN=2

                  HAL_GetDEVID PROC
;;;440      */
;;;441    uint32_t HAL_GetDEVID(void)
000000  4802              LDR      r0,|L15.12|
;;;442    {
;;;443       return((DBGMCU->IDCODE) & IDCODE_DEVID_MASK);
000002  6800              LDR      r0,[r0,#0]
000004  f3c0000b          UBFX     r0,r0,#0,#12
;;;444    }
000008  4770              BX       lr
;;;445    
                          ENDP

00000a  0000              DCW      0x0000
                  |L15.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_GetHalVersion||, CODE, READONLY, ALIGN=2

                  HAL_GetHalVersion PROC
;;;422      */
;;;423    uint32_t HAL_GetHalVersion(void)
000000  4800              LDR      r0,|L16.4|
;;;424    {
;;;425     return __STM32F7xx_HAL_VERSION;
;;;426    }
000002  4770              BX       lr
;;;427    
                          ENDP

                  |L16.4|
                          DCD      0x01020500

                          AREA ||i.HAL_GetREVID||, CODE, READONLY, ALIGN=2

                  HAL_GetREVID PROC
;;;431      */
;;;432    uint32_t HAL_GetREVID(void)
000000  4801              LDR      r0,|L17.8|
;;;433    {
;;;434       return((DBGMCU->IDCODE) >> 16U);
000002  6800              LDR      r0,[r0,#0]
000004  0c00              LSRS     r0,r0,#16
;;;435    }
000006  4770              BX       lr
;;;436    
                          ENDP

                  |L17.8|
                          DCD      0xe0042000

                          AREA ||i.HAL_GetTick||, CODE, READONLY, ALIGN=2

                  HAL_GetTick PROC
;;;316      */
;;;317    __weak uint32_t HAL_GetTick(void)
000000  4801              LDR      r0,|L18.8|
;;;318    {
;;;319      return uwTick;
000002  6880              LDR      r0,[r0,#8]  ; uwTick
;;;320    }
000004  4770              BX       lr
;;;321    
                          ENDP

000006  0000              DCW      0x0000
                  |L18.8|
                          DCD      ||.data||

                          AREA ||i.HAL_GetTickFreq||, CODE, READONLY, ALIGN=2

                  HAL_GetTickFreq PROC
;;;354      */
;;;355    HAL_TickFreqTypeDef HAL_GetTickFreq(void)
000000  4801              LDR      r0,|L19.8|
;;;356    {
;;;357      return uwTickFreq;
000002  6840              LDR      r0,[r0,#4]  ; uwTickFreq
;;;358    }
000004  4770              BX       lr
;;;359    
                          ENDP

000006  0000              DCW      0x0000
                  |L19.8|
                          DCD      ||.data||

                          AREA ||i.HAL_GetTickPrio||, CODE, READONLY, ALIGN=2

                  HAL_GetTickPrio PROC
;;;325      */
;;;326    uint32_t HAL_GetTickPrio(void)
000000  4801              LDR      r0,|L20.8|
;;;327    {
;;;328      return uwTickPrio;
000002  6800              LDR      r0,[r0,#0]  ; uwTickPrio
;;;329    }
000004  4770              BX       lr
;;;330    
                          ENDP

000006  0000              DCW      0x0000
                  |L20.8|
                          DCD      ||.data||

                          AREA ||i.HAL_GetUIDw0||, CODE, READONLY, ALIGN=2

                  HAL_GetUIDw0 PROC
;;;449      */
;;;450    uint32_t HAL_GetUIDw0(void)
000000  4801              LDR      r0,|L21.8|
;;;451    {
;;;452       return(READ_REG(*((uint32_t *)UID_BASE)));
000002  6800              LDR      r0,[r0,#0]
;;;453    }
000004  4770              BX       lr
;;;454    
                          ENDP

000006  0000              DCW      0x0000
                  |L21.8|
                          DCD      0x1ff0f420

                          AREA ||i.HAL_GetUIDw1||, CODE, READONLY, ALIGN=2

                  HAL_GetUIDw1 PROC
;;;458      */
;;;459    uint32_t HAL_GetUIDw1(void)
000000  4801              LDR      r0,|L22.8|
;;;460    {
;;;461       return(READ_REG(*((uint32_t *)(UID_BASE + 4U))));
000002  6800              LDR      r0,[r0,#0]
;;;462    }
000004  4770              BX       lr
;;;463    
                          ENDP

000006  0000              DCW      0x0000
                  |L22.8|
                          DCD      0x1ff0f424

                          AREA ||i.HAL_GetUIDw2||, CODE, READONLY, ALIGN=2

                  HAL_GetUIDw2 PROC
;;;467      */
;;;468    uint32_t HAL_GetUIDw2(void)
000000  4801              LDR      r0,|L23.8|
;;;469    {
;;;470       return(READ_REG(*((uint32_t *)(UID_BASE + 8U))));
000002  6800              LDR      r0,[r0,#0]
;;;471    }
000004  4770              BX       lr
;;;472    
                          ENDP

000006  0000              DCW      0x0000
                  |L23.8|
                          DCD      0x1ff0f428

                          AREA ||i.HAL_IncTick||, CODE, READONLY, ALIGN=2

                  HAL_IncTick PROC
;;;305      */
;;;306    __weak void HAL_IncTick(void)
000000  4802              LDR      r0,|L24.12|
;;;307    {
;;;308      uwTick += uwTickFreq;
000002  6881              LDR      r1,[r0,#8]  ; uwTick
000004  6842              LDR      r2,[r0,#4]  ; uwTickFreq
000006  4411              ADD      r1,r1,r2
000008  6081              STR      r1,[r0,#8]  ; uwTick
;;;309    }
00000a  4770              BX       lr
;;;310    
                          ENDP

                  |L24.12|
                          DCD      ||.data||

                          AREA ||i.HAL_Init||, CODE, READONLY, ALIGN=2

                  HAL_Init PROC
;;;153      */
;;;154    HAL_StatusTypeDef HAL_Init(void)
000000  4809              LDR      r0,|L25.40|
;;;155    {
000002  b510              PUSH     {r4,lr}
;;;156      /* Configure Instruction cache through ART accelerator */ 
;;;157    #if (ART_ACCLERATOR_ENABLE != 0)
;;;158       __HAL_FLASH_ART_ENABLE();
000004  6801              LDR      r1,[r0,#0]
000006  f4417100          ORR      r1,r1,#0x200
00000a  6001              STR      r1,[r0,#0]
;;;159    #endif /* ART_ACCLERATOR_ENABLE */
;;;160    
;;;161      /* Configure Flash prefetch */
;;;162    #if (PREFETCH_ENABLE != 0U)
;;;163      __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
00000c  6801              LDR      r1,[r0,#0]
00000e  f4417180          ORR      r1,r1,#0x100
000012  6001              STR      r1,[r0,#0]
;;;164    #endif /* PREFETCH_ENABLE */
;;;165    
;;;166      /* Set Interrupt Group Priority */
;;;167      HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
000014  2003              MOVS     r0,#3
000016  f7fffffe          BL       HAL_NVIC_SetPriorityGrouping
;;;168    
;;;169      /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
;;;170      HAL_InitTick(TICK_INT_PRIORITY);
00001a  200f              MOVS     r0,#0xf
00001c  f7fffffe          BL       HAL_InitTick
;;;171      
;;;172      /* Init the low level hardware */
;;;173      HAL_MspInit();
000020  f7fffffe          BL       HAL_MspInit
;;;174      
;;;175      /* Return function status */
;;;176      return HAL_OK;
000024  2000              MOVS     r0,#0
;;;177    }
000026  bd10              POP      {r4,pc}
;;;178    
                          ENDP

                  |L25.40|
                          DCD      0x40023c00

                          AREA ||i.HAL_InitTick||, CODE, READONLY, ALIGN=2

                  HAL_InitTick PROC
;;;246      */
;;;247    __weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
000000  b570              PUSH     {r4-r6,lr}
;;;248    {
;;;249      /* Configure the SysTick to have interrupt in 1ms time basis*/
;;;250      if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
000002  4d0d              LDR      r5,|L26.56|
000004  4604              MOV      r4,r0                 ;248
000006  f44f707a          MOV      r0,#0x3e8
00000a  4a0c              LDR      r2,|L26.60|
00000c  6869              LDR      r1,[r5,#4]  ; uwTickFreq
00000e  6812              LDR      r2,[r2,#0]  ; SystemCoreClock
000010  fbb0f0f1          UDIV     r0,r0,r1
000014  fbb2f0f0          UDIV     r0,r2,r0
000018  f7fffffe          BL       HAL_SYSTICK_Config
00001c  b948              CBNZ     r0,|L26.50|
;;;251      {
;;;252        return HAL_ERROR;
;;;253      }
;;;254    
;;;255      /* Configure the SysTick IRQ priority */
;;;256      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
00001e  2c10              CMP      r4,#0x10
000020  d207              BCS      |L26.50|
;;;257      {
;;;258        HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
000022  2200              MOVS     r2,#0
000024  4621              MOV      r1,r4
000026  1e50              SUBS     r0,r2,#1
000028  f7fffffe          BL       HAL_NVIC_SetPriority
;;;259        uwTickPrio = TickPriority;
;;;260      }
;;;261      else
;;;262      {
;;;263        return HAL_ERROR;
;;;264      }
;;;265    
;;;266      /* Return function status */
;;;267      return HAL_OK;
00002c  2000              MOVS     r0,#0
00002e  602c              STR      r4,[r5,#0]            ;259  ; uwTickPrio
;;;268    }
000030  bd70              POP      {r4-r6,pc}
                  |L26.50|
000032  2001              MOVS     r0,#1                 ;263
000034  bd70              POP      {r4-r6,pc}
;;;269    
                          ENDP

000036  0000              DCW      0x0000
                  |L26.56|
                          DCD      ||.data||
                  |L26.60|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_MspDeInit PROC
;;;223      */
;;;224    __weak void HAL_MspDeInit(void)
000000  4770              BX       lr
;;;225    {
;;;226      /* NOTE : This function should not be modified, when the callback is needed,
;;;227                the HAL_MspDeInit could be implemented in the user file
;;;228       */ 
;;;229    }
;;;230    
                          ENDP


                          AREA ||i.HAL_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_MspInit PROC
;;;212      */
;;;213    __weak void HAL_MspInit(void)
000000  4770              BX       lr
;;;214    {
;;;215      /* NOTE : This function should not be modified, when the callback is needed,
;;;216                the HAL_MspInit could be implemented in the user file
;;;217       */
;;;218    }
;;;219    
                          ENDP


                          AREA ||i.HAL_ResumeTick||, CODE, READONLY, ALIGN=1

                  HAL_ResumeTick PROC
;;;412      */
;;;413    __weak void HAL_ResumeTick(void)
000000  f04f20e0          MOV      r0,#0xe000e000
;;;414    {
;;;415      /* Enable SysTick Interrupt */
;;;416      SysTick->CTRL  |= SysTick_CTRL_TICKINT_Msk;
000004  6901              LDR      r1,[r0,#0x10]
000006  f0410102          ORR      r1,r1,#2
00000a  6101              STR      r1,[r0,#0x10]
;;;417    }
00000c  4770              BX       lr
;;;418    
                          ENDP


                          AREA ||i.HAL_SetTickFreq||, CODE, READONLY, ALIGN=2

                  HAL_SetTickFreq PROC
;;;334      */
;;;335    HAL_StatusTypeDef HAL_SetTickFreq(HAL_TickFreqTypeDef Freq)
000000  4a06              LDR      r2,|L30.28|
;;;336    {
;;;337      HAL_StatusTypeDef status  = HAL_OK;
000002  2100              MOVS     r1,#0
000004  b510              PUSH     {r4,lr}               ;336
;;;338      assert_param(IS_TICKFREQ(Freq));
;;;339    
;;;340      if (uwTickFreq != Freq)
000006  6853              LDR      r3,[r2,#4]  ; uwTickFreq
000008  4283              CMP      r3,r0
00000a  d004              BEQ      |L30.22|
;;;341      {
;;;342        uwTickFreq = Freq;
;;;343    
;;;344        /* Apply the new tick Freq  */
;;;345        status = HAL_InitTick(uwTickPrio);
00000c  6050              STR      r0,[r2,#4]  ; uwTickFreq
00000e  6810              LDR      r0,[r2,#0]  ; uwTickPrio
000010  f7fffffe          BL       HAL_InitTick
000014  4601              MOV      r1,r0
                  |L30.22|
;;;346      }
;;;347    
;;;348      return status;
000016  4608              MOV      r0,r1
;;;349    }
000018  bd10              POP      {r4,pc}
;;;350    
                          ENDP

00001a  0000              DCW      0x0000
                  |L30.28|
                          DCD      ||.data||

                          AREA ||i.HAL_SuspendTick||, CODE, READONLY, ALIGN=1

                  HAL_SuspendTick PROC
;;;396      */
;;;397    __weak void HAL_SuspendTick(void)
000000  f04f20e0          MOV      r0,#0xe000e000
;;;398    {
;;;399      /* Disable SysTick Interrupt */
;;;400      SysTick->CTRL &= ~SysTick_CTRL_TICKINT_Msk;
000004  6901              LDR      r1,[r0,#0x10]
000006  f0210102          BIC      r1,r1,#2
00000a  6101              STR      r1,[r0,#0x10]
;;;401    }
00000c  4770              BX       lr
;;;402    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  uwTickPrio
                          DCD      0x00000010
                  uwTickFreq
                          DCD      0x00000001
                  uwTick
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F7_V1.11.0\\Drivers\\STM32F7xx_HAL_Driver\\Src\\stm32f7xx_hal.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f7xx_hal_c_3da258af____REV16|
#line 468 "D:\\Program_Files_x86\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.3.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___15_stm32f7xx_hal_c_3da258af____REV16| PROC
#line 469

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f7xx_hal_c_3da258af____REVSH|
#line 483
|__asm___15_stm32f7xx_hal_c_3da258af____REVSH| PROC
#line 484

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f7xx_hal_c_3da258af____RRX|
#line 670
|__asm___15_stm32f7xx_hal_c_3da258af____RRX| PROC
#line 671

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
