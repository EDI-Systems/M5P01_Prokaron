; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\rmp_kernel.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\rmp_kernel.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Core -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Inc -I.\Source -I.\Drivers -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6-FPU\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\rmp_kernel.crf ..\..\MProkaron\Kernel\rmp_kernel.c]
                          THUMB

                          AREA ||i.RMP_CRC16||, CODE, READONLY, ALIGN=2

                  RMP_CRC16 PROC
;;;279    #ifdef __RMP_U16_T__
;;;280    rmp_ptr_t RMP_CRC16(const rmp_u8_t* Data, rmp_ptr_t Length)
000000  b5f0              PUSH     {r4-r7,lr}
;;;281    {
000002  b0c1              SUB      sp,sp,#0x104
000004  460c              MOV      r4,r1
;;;282        rmp_ptr_t Data_Cnt;
;;;283        rmp_u8_t Index;
;;;284        rmp_u8_t Temp_High;
;;;285        rmp_u8_t Temp_Low;
;;;286        
;;;287        /* CRC16 constants with X^16+X^15+X^2+1 */
;;;288        static const rmp_u8_t CRC16_High[256]=
;;;289        {
;;;290            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;291            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;292            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;293            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;294            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;295            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;296            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;297            0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;298            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;299            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;300            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;301            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;302            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;303            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;304            0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;305            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;306            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;307            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;308            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;309            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;310            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;311            0x00, 0xC1, 0x81, 0x40
;;;312        };
;;;313    
;;;314        const rmp_u8_t CRC16_Low[256]=
000006  490c              LDR      r1,|L1.56|
000008  f44f7280          MOV      r2,#0x100
00000c  4605              MOV      r5,r0                 ;281
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       __aeabi_memcpy4
;;;315        {
;;;316            0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7,
;;;317            0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E,
;;;318            0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9,
;;;319            0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC,
;;;320            0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
;;;321            0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32,
;;;322            0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D,
;;;323            0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38,
;;;324            0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF,
;;;325            0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
;;;326            0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1,
;;;327            0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4,
;;;328            0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB,
;;;329            0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA,
;;;330            0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
;;;331            0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0,
;;;332            0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97,
;;;333            0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E,
;;;334            0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89,
;;;335            0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
;;;336            0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83,
;;;337            0x41, 0x81, 0x80, 0x40
;;;338        };
;;;339    
;;;340        Temp_High=0xFF;
000014  20ff              MOVS     r0,#0xff
;;;341        Temp_Low=0xFF;
;;;342        for(Data_Cnt=0;Data_Cnt<Length;Data_Cnt++)
;;;343        {
;;;344            Index=Temp_Low^Data[Data_Cnt];
;;;345            Temp_Low=(rmp_u8_t)(Temp_High^CRC16_High[Index]);
000016  4f09              LDR      r7,|L1.60|
000018  2200              MOVS     r2,#0                 ;342
00001a  4603              MOV      r3,r0                 ;341
00001c  466e              MOV      r6,sp                 ;314
00001e  e005              B        |L1.44|
                  |L1.32|
000020  5ca9              LDRB     r1,[r5,r2]            ;344
000022  4059              EORS     r1,r1,r3              ;344
000024  5c7b              LDRB     r3,[r7,r1]
000026  4043              EORS     r3,r3,r0
;;;346            Temp_High=CRC16_Low[Index];
000028  5c70              LDRB     r0,[r6,r1]
00002a  1c52              ADDS     r2,r2,#1
                  |L1.44|
00002c  42a2              CMP      r2,r4                 ;342
00002e  d3f7              BCC      |L1.32|
;;;347        }
;;;348    
;;;349        return (rmp_u16_t)(((rmp_u16_t)Temp_High)<<8|Temp_Low);
;;;350    }
000030  b041              ADD      sp,sp,#0x104
000032  ea432000          ORR      r0,r3,r0,LSL #8       ;349
000036  bdf0              POP      {r4-r7,pc}
;;;351    #endif
                          ENDP

                  |L1.56|
                          DCD      ||.constdata||+0x200
                  |L1.60|
                          DCD      ||.constdata||+0x100

                          AREA ||i.RMP_Clear||, CODE, READONLY, ALIGN=1

                  RMP_Clear PROC
;;;66     ******************************************************************************/
;;;67     void RMP_Clear(volatile void* Addr, rmp_ptr_t Size)
000000  2300              MOVS     r3,#0
;;;68     {
;;;69         rmp_u8_t* Ptr;
;;;70         rmp_cnt_t Count;
;;;71        
;;;72         Ptr=(rmp_u8_t*)Addr;
;;;73         for(Count=0;Count<(rmp_cnt_t)Size;Count++)
000002  461a              MOV      r2,r3
000004  e001              B        |L2.10|
                  |L2.6|
;;;74             Ptr[Count]=0;
000006  5483              STRB     r3,[r0,r2]
000008  1c52              ADDS     r2,r2,#1
                  |L2.10|
00000a  428a              CMP      r2,r1                 ;73
00000c  dbfb              BLT      |L2.6|
;;;75     }
00000e  4770              BX       lr
;;;76     /* End Function:RMP_Clear ****************************************************/
                          ENDP


                          AREA ||i.RMP_Free||, CODE, READONLY, ALIGN=1

                  RMP_Free PROC
;;;2517   ******************************************************************************/
;;;2518   void RMP_Free(volatile void* Pool, void* Mem_Ptr)
000000  b570              PUSH     {r4-r6,lr}
;;;2519   {
000002  0005              MOVS     r5,r0
000004  d039              BEQ      |L3.122|
;;;2520       volatile struct RMP_Mem* Mem;
;;;2521       volatile struct RMP_Mem_Head* Mem_Head;
;;;2522       volatile struct RMP_Mem_Head* Left_Head;
;;;2523       volatile struct RMP_Mem_Head* Right_Head;
;;;2524       rmp_cnt_t Merge_Left;
;;;2525   
;;;2526       /* Check if pointer is null */
;;;2527       if((Pool==0)||(Mem_Ptr==0))
000006  2900              CMP      r1,#0
000008  d037              BEQ      |L3.122|
;;;2528       {
;;;2529           RMP_COVERAGE_MARKER();
;;;2530           return;
;;;2531       }
;;;2532       else
;;;2533           RMP_COVERAGE_MARKER();
;;;2534       
;;;2535       /* See if the address is within the allocatable address range. If not, abort directly. */
;;;2536       Mem=(volatile struct RMP_Mem*)Pool;
;;;2537       if((((rmp_ptr_t)Mem_Ptr)<=((rmp_ptr_t)Mem))||(((rmp_ptr_t)Mem_Ptr)>=(((rmp_ptr_t)Mem)+Mem->Size)))
00000a  42a9              CMP      r1,r5
00000c  d935              BLS      |L3.122|
00000e  6882              LDR      r2,[r0,#8]
000010  1950              ADDS     r0,r2,r5
000012  4288              CMP      r0,r1
000014  d931              BLS      |L3.122|
;;;2538       {
;;;2539           RMP_COVERAGE_MARKER();
;;;2540           return;
;;;2541       }
;;;2542       else
;;;2543           RMP_COVERAGE_MARKER();
;;;2544   
;;;2545       Mem_Head=(struct RMP_Mem_Head*)(((rmp_ptr_t)Mem_Ptr)-sizeof(struct RMP_Mem_Head));
000016  f1a10410          SUB      r4,r1,#0x10
;;;2546       /* See if the block can really be freed */
;;;2547       if(Mem_Head->State==RMP_MEM_FREE)
00001a  68a0              LDR      r0,[r4,#8]
00001c  2800              CMP      r0,#0
00001e  d02c              BEQ      |L3.122|
;;;2548       {
;;;2549           RMP_COVERAGE_MARKER();
;;;2550           return;
;;;2551       }
;;;2552       else
;;;2553           RMP_COVERAGE_MARKER();
;;;2554   
;;;2555       /* Mark it as free */
;;;2556       Mem_Head->State=RMP_MEM_FREE;
000020  2000              MOVS     r0,#0
000022  60a0              STR      r0,[r4,#8]
;;;2557       
;;;2558       /* Now check if we can merge it with the higher blocks */
;;;2559       Right_Head=(struct RMP_Mem_Head*)(((rmp_ptr_t)(Mem_Head->Tail))+sizeof(struct RMP_Mem_Tail));
000024  68e6              LDR      r6,[r4,#0xc]
;;;2560       if(((rmp_ptr_t)Right_Head)!=(((rmp_ptr_t)Mem)+Mem->Size))
000026  68a9              LDR      r1,[r5,#8]
000028  1d36              ADDS     r6,r6,#4
00002a  1948              ADDS     r0,r1,r5
00002c  42b0              CMP      r0,r6
00002e  d00b              BEQ      |L3.72|
;;;2561       {
;;;2562           RMP_COVERAGE_MARKER();
;;;2563           /* If this one is unoccupied */
;;;2564           if((Right_Head->State)==RMP_MEM_FREE)
000030  68b0              LDR      r0,[r6,#8]
000032  b948              CBNZ     r0,|L3.72|
;;;2565           {
;;;2566               RMP_COVERAGE_MARKER();
;;;2567               /* Delete, merge */
;;;2568               _RMP_Mem_Del(Pool,Right_Head);
000034  4631              MOV      r1,r6
000036  4628              MOV      r0,r5
000038  f7fffffe          BL       _RMP_Mem_Del
;;;2569               _RMP_Mem_Block(Mem_Head,
00003c  68f0              LDR      r0,[r6,#0xc]
00003e  1b01              SUBS     r1,r0,r4
000040  4620              MOV      r0,r4
000042  1d09              ADDS     r1,r1,#4
000044  f7fffffe          BL       _RMP_Mem_Block
                  |L3.72|
;;;2570                              ((rmp_ptr_t)(Right_Head->Tail))+sizeof(struct RMP_Mem_Tail)-(rmp_ptr_t)Mem_Head);
;;;2571           }
;;;2572           else
;;;2573               RMP_COVERAGE_MARKER();
;;;2574       }
;;;2575       else
;;;2576           RMP_COVERAGE_MARKER();
;;;2577   
;;;2578       /* Now check if we can merge it with the lower blocks */
;;;2579       Merge_Left=0;
;;;2580       if((rmp_ptr_t)Mem_Head!=Mem->Start)
000048  6868              LDR      r0,[r5,#4]
00004a  42a0              CMP      r0,r4
00004c  d003              BEQ      |L3.86|
;;;2581       {
;;;2582           RMP_COVERAGE_MARKER();
;;;2583           Left_Head=((struct RMP_Mem_Tail*)(((rmp_ptr_t)Mem_Head)-sizeof(struct RMP_Mem_Tail)))->Head;
00004e  f8546c04          LDR      r6,[r4,#-4]
;;;2584   
;;;2585           /* If this one is unoccupied */
;;;2586           if(Left_Head->State==RMP_MEM_FREE)
000052  68b0              LDR      r0,[r6,#8]
000054  b128              CBZ      r0,|L3.98|
                  |L3.86|
;;;2587           {
;;;2588               RMP_COVERAGE_MARKER();
;;;2589               /* Delete, merge */
;;;2590               _RMP_Mem_Del(Pool, Left_Head);
;;;2591               _RMP_Mem_Block(Left_Head,
;;;2592                              (rmp_ptr_t)((rmp_ptr_t)(Mem_Head->Tail)+sizeof(struct RMP_Mem_Tail)-(rmp_ptr_t)Left_Head));
;;;2593   
;;;2594               /* We have completed the merge here and the original block has destroyed.
;;;2595                * Thus there's no need to insert it into the list again */
;;;2596               Merge_Left=1;
;;;2597           }
;;;2598           else
;;;2599               RMP_COVERAGE_MARKER();
;;;2600       }
;;;2601       else
;;;2602           RMP_COVERAGE_MARKER();
;;;2603   
;;;2604       /* If we did not merge it with the left-side blocks, insert the original pointer's block 
;;;2605        * into the TLSF table(Merging with the right-side one won't disturb this) */
;;;2606       if(Merge_Left==0)
;;;2607       {
;;;2608           RMP_COVERAGE_MARKER();
;;;2609           _RMP_Mem_Ins(Pool, Mem_Head);
000056  4621              MOV      r1,r4
                  |L3.88|
000058  4628              MOV      r0,r5
00005a  e8bd4070          POP      {r4-r6,lr}
00005e  f7ffbffe          B.W      _RMP_Mem_Ins
                  |L3.98|
000062  4631              MOV      r1,r6                 ;2590
000064  4628              MOV      r0,r5                 ;2590
000066  f7fffffe          BL       _RMP_Mem_Del
00006a  68e0              LDR      r0,[r4,#0xc]          ;2591
00006c  1b81              SUBS     r1,r0,r6              ;2591
00006e  4630              MOV      r0,r6                 ;2591
000070  1d09              ADDS     r1,r1,#4              ;2591
000072  f7fffffe          BL       _RMP_Mem_Block
;;;2610       }
;;;2611       else
;;;2612       {
;;;2613           RMP_COVERAGE_MARKER();
;;;2614           _RMP_Mem_Ins(Pool, Left_Head);
000076  4631              MOV      r1,r6
000078  e7ee              B        |L3.88|
                  |L3.122|
;;;2615       }
;;;2616   }
00007a  bd70              POP      {r4-r6,pc}
;;;2617   /* End Function:RMP_Free *****************************************************/
                          ENDP


                          AREA ||i.RMP_Init||, CODE, READONLY, ALIGN=1

                  RMP_Init PROC
;;;1970   ******************************************************************************/
;;;1971   void RMP_Init(void)
000000  f7fffffe          BL       RMP_Lock_Sched
;;;1972   {
;;;1973       RMP_Lock_Sched();
;;;1974       
;;;1975       /* Platform will use this hook to do something */
;;;1976       _RMP_Plat_Hook();
000004  f7fffffe          BL       _RMP_Plat_Hook
;;;1977       /* Start the second thread here */
;;;1978       RMP_Init_Hook();
000008  f7fffffe          BL       RMP_Init_Hook
;;;1979       
;;;1980       RMP_Unlock_Sched();
00000c  f7fffffe          BL       RMP_Unlock_Sched
                  |L4.16|
;;;1981       
;;;1982       while(1)
;;;1983           RMP_Init_Idle();
000010  f7fffffe          BL       RMP_Init_Idle
000014  e7fc              B        |L4.16|
;;;1984   }
;;;1985   /* End Function:RMP_Init *****************************************************/
                          ENDP


                          AREA ||i.RMP_LSB_Get||, CODE, READONLY, ALIGN=1

                  RMP_LSB_Get PROC
;;;2118   ******************************************************************************/
;;;2119   rmp_ptr_t RMP_LSB_Get(rmp_ptr_t Val)
000000  b510              PUSH     {r4,lr}
;;;2120   {
;;;2121       return RMP_WORD_SIZE-1-RMP_MSB_Get(RMP_RBIT_Get(Val));
000002  f7fffffe          BL       RMP_RBIT_Get
000006  f7fffffe          BL       RMP_MSB_Get
00000a  f1c0001f          RSB      r0,r0,#0x1f
;;;2122   }
00000e  bd10              POP      {r4,pc}
;;;2123   /* End Function:RMP_LSB_Get **************************************************/
                          ENDP


                          AREA ||i.RMP_List_Crt||, CODE, READONLY, ALIGN=1

                  RMP_List_Crt PROC
;;;230    ******************************************************************************/
;;;231    void RMP_List_Crt(volatile struct RMP_List* Head)
000000  6000              STR      r0,[r0,#0]
;;;232    {
;;;233        Head->Prev=(struct RMP_List*)Head;
;;;234        Head->Next=(struct RMP_List*)Head;
000002  6040              STR      r0,[r0,#4]
;;;235    }
000004  4770              BX       lr
;;;236    /* End Function:RMP_List_Crt *************************************************/
                          ENDP


                          AREA ||i.RMP_List_Del||, CODE, READONLY, ALIGN=1

                  RMP_List_Del PROC
;;;244    ******************************************************************************/
;;;245    void RMP_List_Del(volatile struct RMP_List* Prev,volatile struct RMP_List* Next)
000000  6008              STR      r0,[r1,#0]
;;;246    {
;;;247        Next->Prev=(struct RMP_List*)Prev;
;;;248        Prev->Next=(struct RMP_List*)Next;
000002  6041              STR      r1,[r0,#4]
;;;249    }
000004  4770              BX       lr
;;;250    /* End Function:RMP_List_Del *************************************************/
                          ENDP


                          AREA ||i.RMP_List_Ins||, CODE, READONLY, ALIGN=1

                  RMP_List_Ins PROC
;;;259    ******************************************************************************/
;;;260    void RMP_List_Ins(volatile struct RMP_List* New,
000000  6010              STR      r0,[r2,#0]
;;;261                      volatile struct RMP_List* Prev,
;;;262                      volatile struct RMP_List* Next)
;;;263    {
;;;264        Next->Prev=(struct RMP_List*)New;
;;;265        New->Next=(struct RMP_List*)Next;
000002  6042              STR      r2,[r0,#4]
;;;266        New->Prev=(struct RMP_List*)Prev;
000004  6001              STR      r1,[r0,#0]
;;;267        Prev->Next=(struct RMP_List*)New;
000006  6048              STR      r0,[r1,#4]
;;;268    }
000008  4770              BX       lr
;;;269    /* End Function:RMP_List_Ins *************************************************/
                          ENDP


                          AREA ||i.RMP_Load_Ctx||, CODE, READONLY, ALIGN=1

                  RMP_Load_Ctx PROC
;;;1955   #if(RMP_USE_HOOKS==RMP_FALSE)
;;;1956   void RMP_Load_Ctx(void)
000000  4770              BX       lr
;;;1957   {
;;;1958       return;
;;;1959   }
;;;1960   #endif
                          ENDP


                          AREA ||i.RMP_Lock_Sched||, CODE, READONLY, ALIGN=2

                  RMP_Lock_Sched PROC
;;;360    ******************************************************************************/
;;;361    void RMP_Lock_Sched(void)
000000  20ff              MOVS     r0,#0xff
;;;362    {
000002  b510              PUSH     {r4,lr}
;;;363        RMP_MASK_INT();
000004  f7fffffe          BL       RMP_Mask_Int
;;;364        RMP_Sched_Locked=1;
000008  4803              LDR      r0,|L10.24|
00000a  2101              MOVS     r1,#1
00000c  6081              STR      r1,[r0,#8]  ; RMP_Sched_Locked
;;;365        RMP_Sched_Lock_Cnt++;
00000e  6841              LDR      r1,[r0,#4]  ; RMP_Sched_Lock_Cnt
000010  1c49              ADDS     r1,r1,#1
000012  6041              STR      r1,[r0,#4]  ; RMP_Sched_Lock_Cnt
;;;366    }
000014  bd10              POP      {r4,pc}
;;;367    /* End Function:RMP_Lock_Sched ***********************************************/
                          ENDP

000016  0000              DCW      0x0000
                  |L10.24|
                          DCD      ||.data||

                          AREA ||i.RMP_Malloc||, CODE, READONLY, ALIGN=1

                  RMP_Malloc PROC
;;;2444   ******************************************************************************/
;;;2445   void* RMP_Malloc(volatile void* Pool, rmp_ptr_t Size)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;2446   {    
000004  0006              MOVS     r6,r0
000006  d00c              BEQ      |L11.34|
;;;2447       rmp_cnt_t FLI_Level;
;;;2448       rmp_cnt_t SLI_Level;
;;;2449       volatile struct RMP_Mem* Mem;
;;;2450       rmp_ptr_t Old_Size;
;;;2451       volatile struct RMP_Mem_Head* Mem_Head;
;;;2452       rmp_ptr_t Rounded_Size;
;;;2453       volatile struct RMP_Mem_Head* New_Mem;
;;;2454       rmp_ptr_t New_Size;
;;;2455       
;;;2456       if((Pool==0)||(Size==0))
000008  b159              CBZ      r1,|L11.34|
00000a  1dc9              ADDS     r1,r1,#7
;;;2457       {
;;;2458           RMP_COVERAGE_MARKER();
;;;2459           return (void*)(0);
;;;2460       }
;;;2461       else
;;;2462           RMP_COVERAGE_MARKER();
;;;2463       
;;;2464       /* Round up the size:a multiple of 8 and bigger than 64B */
;;;2465       Rounded_Size=RMP_ROUND_UP(Size,3);
00000c  f0210407          BIC      r4,r1,#7
;;;2466       /* See if it is smaller than the smallest block */
;;;2467       Rounded_Size=(Rounded_Size>64)?Rounded_Size:64;
000010  2c40              CMP      r4,#0x40
000012  d800              BHI      |L11.22|
000014  2440              MOVS     r4,#0x40
                  |L11.22|
;;;2468   
;;;2469       /* See if such block exists, if not, abort */
;;;2470       if(_RMP_Mem_Search(Pool,Rounded_Size,&FLI_Level,&SLI_Level)!=0)
000016  466a              MOV      r2,sp
000018  ab01              ADD      r3,sp,#4
00001a  4621              MOV      r1,r4
00001c  f7fffffe          BL       _RMP_Mem_Search
000020  b110              CBZ      r0,|L11.40|
                  |L11.34|
;;;2471       {
;;;2472           RMP_COVERAGE_MARKER();
;;;2473           return (void*)(0);
000022  2000              MOVS     r0,#0
                  |L11.36|
;;;2474       }
;;;2475       else
;;;2476           RMP_COVERAGE_MARKER();
;;;2477       
;;;2478       Mem=(volatile struct RMP_Mem*)Pool;
;;;2479       
;;;2480       /* There is such block. Get it and delete it from the TLSF list. */
;;;2481       Mem_Head=(struct RMP_Mem_Head*)(Mem->Table[RMP_MEM_POS(FLI_Level,SLI_Level)].Next);
;;;2482       _RMP_Mem_Del(Pool, Mem_Head);
;;;2483   
;;;2484       /* Allocate and calculate if the space left could be big enough to be a new 
;;;2485        * block. If so, we will put the block back into the TLSF table */
;;;2486       New_Size=((rmp_ptr_t)(Mem_Head->Tail))-((rmp_ptr_t)Mem_Head)-sizeof(struct RMP_Mem_Head)-Rounded_Size;
;;;2487       if(New_Size>=(sizeof(struct RMP_Mem_Head)+64+sizeof(struct RMP_Mem_Tail)))
;;;2488       {
;;;2489           RMP_COVERAGE_MARKER();
;;;2490           Old_Size=sizeof(struct RMP_Mem_Head)+Rounded_Size+sizeof(struct RMP_Mem_Tail);
;;;2491           New_Mem=(volatile struct RMP_Mem_Head*)(((rmp_ptr_t)Mem_Head)+Old_Size);
;;;2492   
;;;2493           _RMP_Mem_Block(Mem_Head, Old_Size);
;;;2494           _RMP_Mem_Block(New_Mem, New_Size);
;;;2495   
;;;2496           /* Put the extra block back */
;;;2497           _RMP_Mem_Ins(Pool, New_Mem);
;;;2498       }
;;;2499       else
;;;2500           RMP_COVERAGE_MARKER();
;;;2501   
;;;2502       /* Mark the block as in use */
;;;2503       Mem_Head->State=RMP_MEM_USED;
;;;2504   
;;;2505       /* Finally, return the start address */
;;;2506       return (void*)(((rmp_ptr_t)Mem_Head)+sizeof(struct RMP_Mem_Head));
;;;2507   }
000024  e8bd81fc          POP      {r2-r8,pc}
                  |L11.40|
000028  68f0              LDR      r0,[r6,#0xc]          ;2481
00002a  e9dd2100          LDRD     r2,r1,[sp,#0]         ;2481
00002e  eb0101c2          ADD      r1,r1,r2,LSL #3       ;2481
000032  2204              MOVS     r2,#4                 ;2481
000034  eb0201c1          ADD      r1,r2,r1,LSL #3       ;2481
000038  5845              LDR      r5,[r0,r1]            ;2481
00003a  4630              MOV      r0,r6                 ;2482
00003c  4629              MOV      r1,r5                 ;2482
00003e  f7fffffe          BL       _RMP_Mem_Del
000042  68e8              LDR      r0,[r5,#0xc]          ;2486
000044  1b40              SUBS     r0,r0,r5              ;2486
000046  1b07              SUBS     r7,r0,r4              ;2486
000048  3f10              SUBS     r7,r7,#0x10           ;2486
00004a  2f54              CMP      r7,#0x54              ;2487
00004c  d30d              BCC      |L11.106|
00004e  f1040114          ADD      r1,r4,#0x14           ;2490
000052  4628              MOV      r0,r5                 ;2493
000054  186c              ADDS     r4,r5,r1              ;2491
000056  f7fffffe          BL       _RMP_Mem_Block
00005a  4639              MOV      r1,r7                 ;2494
00005c  4620              MOV      r0,r4                 ;2494
00005e  f7fffffe          BL       _RMP_Mem_Block
000062  4621              MOV      r1,r4                 ;2497
000064  4630              MOV      r0,r6                 ;2497
000066  f7fffffe          BL       _RMP_Mem_Ins
                  |L11.106|
00006a  2001              MOVS     r0,#1                 ;2503
00006c  60a8              STR      r0,[r5,#8]            ;2503
00006e  f1050010          ADD      r0,r5,#0x10           ;2506
000072  e7d7              B        |L11.36|
;;;2508   /* End Function:RMP_Malloc ***************************************************/
                          ENDP


                          AREA ||i.RMP_Mem_Init||, CODE, READONLY, ALIGN=2

                  RMP_Mem_Init PROC
;;;2160   ******************************************************************************/
;;;2161   rmp_ret_t RMP_Mem_Init(volatile void* Pool, rmp_ptr_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;2162   {
000002  0004              MOVS     r4,r0
000004  460d              MOV      r5,r1
;;;2163       rmp_cnt_t FLI_Cnt;
;;;2164       rmp_ptr_t Offset;
;;;2165       rmp_ptr_t Bitmap_Size;
;;;2166       volatile struct RMP_Mem* Mem;
;;;2167       
;;;2168       /* See if the memory pool is large enough to enable dynamic allocation - at
;;;2169        * least 1024 machine words or pool initialization will be refused */
;;;2170       if((Pool==0)||(Size<(1024*sizeof(rmp_ptr_t)))||((((rmp_ptr_t)Pool)+Size)<Size))
;;;2171       {
;;;2172           RMP_COVERAGE_MARKER();
;;;2173           return RMP_ERR_MEM;
000006  f06f0006          MVN      r0,#6
00000a  d06e              BEQ      |L12.234|
00000c  f5b55f80          CMP      r5,#0x1000            ;2170
000010  d36b              BCC      |L12.234|
000012  1961              ADDS     r1,r4,r5              ;2170
000014  42a9              CMP      r1,r5                 ;2170
000016  d368              BCC      |L12.234|
;;;2174       }
;;;2175       else
;;;2176           RMP_COVERAGE_MARKER();
;;;2177       
;;;2178       /* See if the address and size is word-aligned */
;;;2179       if(((((rmp_ptr_t)Pool)&RMP_ALIGN_MASK)!=0)||((Size&RMP_ALIGN_MASK)!=0))
000018  ea440105          ORR      r1,r4,r5
00001c  0789              LSLS     r1,r1,#30
00001e  d164              BNE      |L12.234|
;;;2180       {
;;;2181           RMP_COVERAGE_MARKER();
;;;2182           return RMP_ERR_MEM;
;;;2183       }
;;;2184       else
;;;2185           RMP_COVERAGE_MARKER();
;;;2186   
;;;2187       Mem=(volatile struct RMP_Mem*)Pool;
;;;2188       Mem->Size=Size;
000020  60a5              STR      r5,[r4,#8]
000022  f1a50014          SUB      r0,r5,#0x14
;;;2189       /* Calculate the FLI value needed for this - we always align to 64 byte */
;;;2190       Mem->FLI_Num=RMP_MSB_Get(Size-sizeof(struct RMP_Mem))-6+1;
000026  f7fffffe          BL       RMP_MSB_Get
;;;2191       
;;;2192       /* Decide the location of the bitmap */
;;;2193       Offset=sizeof(struct RMP_Mem);
00002a  2214              MOVS     r2,#0x14
00002c  1f40              SUBS     r0,r0,#5
00002e  6020              STR      r0,[r4,#0]            ;2190
;;;2194       Bitmap_Size=RMP_ROUND_UP(Mem->FLI_Num,RMP_ALIGN_ORDER);
000030  6821              LDR      r1,[r4,#0]
;;;2195       /* Initialize the bitmap */
;;;2196       for(FLI_Cnt=0;FLI_Cnt<(rmp_cnt_t)(Bitmap_Size>>RMP_ALIGN_ORDER);FLI_Cnt++)
000032  2000              MOVS     r0,#0
000034  4603              MOV      r3,r0
000036  1cc9              ADDS     r1,r1,#3
000038  f0210103          BIC      r1,r1,#3              ;2194
00003c  e004              B        |L12.72|
;;;2197           Mem->Bitmap[FLI_Cnt]=0;
00003e  bf00              NOP      
                  |L12.64|
000040  eb040680          ADD      r6,r4,r0,LSL #2
000044  6133              STR      r3,[r6,#0x10]
000046  1c40              ADDS     r0,r0,#1
                  |L12.72|
000048  ebb00f91          CMP      r0,r1,LSR #2          ;2196
00004c  dbf8              BLT      |L12.64|
;;;2198       
;;;2199       /* Decide the location of the allocation table - "-sizeof(rmp_ptr_t)" is
;;;2200        * because we defined the length=1 in our struct already */
;;;2201       Offset+=Bitmap_Size-sizeof(rmp_ptr_t);
00004e  440a              ADD      r2,r2,r1
;;;2202       Mem->Table=(struct RMP_List*)(((rmp_ptr_t)Mem)+Offset);
;;;2203       /* Initialize the allocation table */
;;;2204       for(FLI_Cnt=0;FLI_Cnt<(rmp_cnt_t)(Mem->FLI_Num);FLI_Cnt++)
000050  2000              MOVS     r0,#0
000052  1f12              SUBS     r2,r2,#4
000054  18a3              ADDS     r3,r4,r2              ;2202
000056  60e3              STR      r3,[r4,#0xc]          ;2202
000058  e036              B        |L12.200|
                  |L12.90|
;;;2205       {
;;;2206           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,0)]));
00005a  68e1              LDR      r1,[r4,#0xc]
00005c  eb011180          ADD      r1,r1,r0,LSL #6
000060  6009              STR      r1,[r1,#0]
000062  6049              STR      r1,[r1,#4]
;;;2207           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,1)]));
000064  2308              MOVS     r3,#8
000066  68e1              LDR      r1,[r4,#0xc]
000068  eb031380          ADD      r3,r3,r0,LSL #6
00006c  4419              ADD      r1,r1,r3
00006e  6009              STR      r1,[r1,#0]
000070  6049              STR      r1,[r1,#4]
;;;2208           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,2)]));
000072  68e1              LDR      r1,[r4,#0xc]
000074  2310              MOVS     r3,#0x10
000076  eb031380          ADD      r3,r3,r0,LSL #6
00007a  4419              ADD      r1,r1,r3
00007c  6009              STR      r1,[r1,#0]
00007e  6049              STR      r1,[r1,#4]
;;;2209           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,3)]));
000080  68e1              LDR      r1,[r4,#0xc]
000082  2318              MOVS     r3,#0x18
000084  eb031380          ADD      r3,r3,r0,LSL #6
000088  4419              ADD      r1,r1,r3
00008a  6009              STR      r1,[r1,#0]
00008c  6049              STR      r1,[r1,#4]
;;;2210           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,4)]));
00008e  68e1              LDR      r1,[r4,#0xc]
000090  2320              MOVS     r3,#0x20
000092  eb031380          ADD      r3,r3,r0,LSL #6
000096  4419              ADD      r1,r1,r3
000098  6009              STR      r1,[r1,#0]
00009a  6049              STR      r1,[r1,#4]
;;;2211           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,5)]));
00009c  68e1              LDR      r1,[r4,#0xc]
00009e  2328              MOVS     r3,#0x28
0000a0  eb031380          ADD      r3,r3,r0,LSL #6
0000a4  4419              ADD      r1,r1,r3
0000a6  6009              STR      r1,[r1,#0]
0000a8  6049              STR      r1,[r1,#4]
;;;2212           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,6)]));
0000aa  68e1              LDR      r1,[r4,#0xc]
0000ac  2330              MOVS     r3,#0x30
0000ae  eb031380          ADD      r3,r3,r0,LSL #6
0000b2  4419              ADD      r1,r1,r3
0000b4  6009              STR      r1,[r1,#0]
0000b6  6049              STR      r1,[r1,#4]
;;;2213           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,7)]));
0000b8  68e1              LDR      r1,[r4,#0xc]
0000ba  2338              MOVS     r3,#0x38
0000bc  eb031380          ADD      r3,r3,r0,LSL #6
0000c0  4419              ADD      r1,r1,r3
0000c2  6009              STR      r1,[r1,#0]
0000c4  6049              STR      r1,[r1,#4]
0000c6  1c40              ADDS     r0,r0,#1
                  |L12.200|
0000c8  6821              LDR      r1,[r4,#0]            ;2204
0000ca  4281              CMP      r1,r0                 ;2204
0000cc  dcc5              BGT      |L12.90|
;;;2214       }
;;;2215       
;;;2216       /* Calculate the offset of the actual allocatable memory - each FLI have
;;;2217        * 8 SLIs, and each SLI has a corresponding table header */
;;;2218       Offset+=sizeof(struct RMP_List)*8*Mem->FLI_Num;
0000ce  6820              LDR      r0,[r4,#0]
0000d0  eb021080          ADD      r0,r2,r0,LSL #6
;;;2219       Mem->Start=((rmp_ptr_t)Mem)+Offset;
0000d4  1822              ADDS     r2,r4,r0
0000d6  6062              STR      r2,[r4,#4]
;;;2220       
;;;2221       /* Initialize the first big block */
;;;2222       _RMP_Mem_Block((struct RMP_Mem_Head*)(Mem->Start),Size-Offset);
0000d8  1a29              SUBS     r1,r5,r0
0000da  6860              LDR      r0,[r4,#4]
0000dc  f7fffffe          BL       _RMP_Mem_Block
;;;2223       /* Insert the memory into the corresponding level */
;;;2224       _RMP_Mem_Ins(Pool,(struct RMP_Mem_Head*)(Mem->Start));
0000e0  6861              LDR      r1,[r4,#4]
0000e2  4620              MOV      r0,r4
0000e4  f7fffffe          BL       _RMP_Mem_Ins
;;;2225       
;;;2226       return 0;
0000e8  2000              MOVS     r0,#0
                  |L12.234|
;;;2227   }
0000ea  bd70              POP      {r4-r6,pc}
;;;2228   /* End Function:RMP_Mem_Init *************************************************/
                          ENDP


                          AREA ||i.RMP_Print_Int||, CODE, READONLY, ALIGN=2

                  RMP_Print_Int PROC
;;;84     ******************************************************************************/
;;;85     rmp_cnt_t RMP_Print_Int(rmp_cnt_t Int)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;86     {
;;;87         rmp_ptr_t Iter;
;;;88         rmp_cnt_t Count;
;;;89         rmp_cnt_t Num;
;;;90         rmp_ptr_t Div;
;;;91         
;;;92         /* how many digits are there? */
;;;93         if(Int==0)
000004  2800              CMP      r0,#0
;;;94         {
;;;95             RMP_Putchar('0');
;;;96             return 1;
;;;97         }
;;;98         else if(Int<0)
;;;99         {
;;;100            /* How many digits are there? */
;;;101            Count=0;
;;;102            Div=1;
;;;103            Iter=(rmp_ptr_t)(-Int);
;;;104            while(Iter!=0)
;;;105            {
;;;106                Iter/=10;
000006  f04f010a          MOV      r1,#0xa
00000a  d008              BEQ      |L13.30|
00000c  da2e              BGE      |L13.108|
00000e  f1c00000          RSB      r0,r0,#0              ;103
000012  f04f0500          MOV      r5,#0                 ;101
000016  4606              MOV      r6,r0                 ;103
000018  f04f0201          MOV      r2,#1                 ;102
00001c  e00c              B        |L13.56|
                  |L13.30|
00001e  f04f0030          MOV      r0,#0x30              ;95
000022  f7fffffe          BL       RMP_Putchar
000026  2001              MOVS     r0,#1                 ;96
                  |L13.40|
;;;107                Count++;
;;;108                Div*=10;
;;;109            }
;;;110            Div/=10;
;;;111            
;;;112            RMP_Putchar('-');
;;;113            Iter=-Int;
;;;114            Num=Count+1;
;;;115            
;;;116            while(Count>0)
;;;117            {
;;;118                Count--;
;;;119                RMP_Putchar(Iter/Div+'0');
;;;120                Iter=Iter%Div;
;;;121                Div/=10;
;;;122            }
;;;123        }
;;;124        else
;;;125        {
;;;126            /* How many digits are there? */
;;;127            Count=0;
;;;128            Div=1;
;;;129            Iter=Int;
;;;130            while(Iter!=0)
;;;131            {
;;;132                Iter/=10;
;;;133                Count++;
;;;134                Div*=10;
;;;135            }
;;;136            Div/=10;
;;;137            
;;;138            Iter=Int;
;;;139            Num=Count;
;;;140            
;;;141            while(Count>0)
;;;142            {
;;;143                Count--;
;;;144                RMP_Putchar(Iter/Div+'0');
;;;145                Iter=Iter%Div;
;;;146                Div/=10;
;;;147            }
;;;148        }
;;;149        
;;;150        return Num;
;;;151    }
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L13.44|
00002c  fbb0f0f1          UDIV     r0,r0,r1              ;106
000030  eb020282          ADD      r2,r2,r2,LSL #2       ;108
000034  0052              LSLS     r2,r2,#1              ;108
000036  1c6d              ADDS     r5,r5,#1              ;108
                  |L13.56|
000038  2800              CMP      r0,#0                 ;104
00003a  d1f7              BNE      |L13.44|
00003c  4688              MOV      r8,r1                 ;110
00003e  fbb2f4f8          UDIV     r4,r2,r8              ;110
000042  202d              MOVS     r0,#0x2d              ;112
000044  f7fffffe          BL       RMP_Putchar
000048  1c6f              ADDS     r7,r5,#1              ;114
00004a  e00c              B        |L13.102|
                  |L13.76|
00004c  fbb6f0f4          UDIV     r0,r6,r4              ;119
000050  1e6d              SUBS     r5,r5,#1              ;119
000052  3030              ADDS     r0,r0,#0x30           ;119
000054  b240              SXTB     r0,r0                 ;119
000056  f7fffffe          BL       RMP_Putchar
00005a  fbb6f1f4          UDIV     r1,r6,r4              ;120
00005e  fb046611          MLS      r6,r4,r1,r6           ;120
000062  fbb4f4f8          UDIV     r4,r4,r8              ;121
                  |L13.102|
000066  2d00              CMP      r5,#0                 ;116
000068  dcf0              BGT      |L13.76|
00006a  e020              B        |L13.174|
                  |L13.108|
00006c  2400              MOVS     r4,#0                 ;127
00006e  ea4f0200          MOV.W    r2,r0                 ;129
000072  2301              MOVS     r3,#1                 ;128
                  |L13.116|
000074  fbb2f2f1          UDIV     r2,r2,r1              ;132
000078  eb030383          ADD      r3,r3,r3,LSL #2       ;134
00007c  1c64              ADDS     r4,r4,#1              ;134
00007e  005b              LSLS     r3,r3,#1              ;134
000080  2a00              CMP      r2,#0                 ;134
000082  d1f7              BNE      |L13.116|
000084  4688              MOV      r8,r1                 ;106
000086  4605              MOV      r5,r0                 ;138
000088  fbb3f6f8          UDIV     r6,r3,r8              ;136
00008c  4627              MOV      r7,r4                 ;139
00008e  e00c              B        |L13.170|
                  |L13.144|
000090  fbb5f0f6          UDIV     r0,r5,r6              ;144
000094  1e64              SUBS     r4,r4,#1              ;144
000096  3030              ADDS     r0,r0,#0x30           ;144
000098  b240              SXTB     r0,r0                 ;144
00009a  f7fffffe          BL       RMP_Putchar
00009e  fbb5f1f6          UDIV     r1,r5,r6              ;145
0000a2  fb065511          MLS      r5,r6,r1,r5           ;145
0000a6  fbb6f6f8          UDIV     r6,r6,r8              ;146
                  |L13.170|
0000aa  2c00              CMP      r4,#0                 ;141
0000ac  dcf0              BGT      |L13.144|
                  |L13.174|
0000ae  4638              MOV      r0,r7                 ;150
0000b0  e7ba              B        |L13.40|
;;;152    /* End Function:RMP_Print_Int ************************************************/
                          ENDP


                          AREA ||i.RMP_Print_String||, CODE, READONLY, ALIGN=1

                  RMP_Print_String PROC
;;;207    ******************************************************************************/
;;;208    rmp_cnt_t RMP_Print_String(rmp_s8_t* String)
000000  b570              PUSH     {r4-r6,lr}
;;;209    {
;;;210        rmp_cnt_t Count;
;;;211        
;;;212        Count=0;
000002  2400              MOVS     r4,#0
000004  4605              MOV      r5,r0                 ;209
                  |L14.6|
;;;213        while(Count<RMP_KERNEL_DEBUG_MAX_STR)
;;;214        {
;;;215            if(String[Count]=='\0')
000006  5728              LDRSB    r0,[r5,r4]
000008  b120              CBZ      r0,|L14.20|
00000a  1c64              ADDS     r4,r4,#1
;;;216                break;
;;;217            
;;;218            RMP_Putchar(String[Count++]);
00000c  f7fffffe          BL       RMP_Putchar
000010  2cff              CMP      r4,#0xff              ;213
000012  dbf8              BLT      |L14.6|
                  |L14.20|
;;;219        }
;;;220        
;;;221        return Count;
000014  4620              MOV      r0,r4
;;;222    }
000016  bd70              POP      {r4-r6,pc}
;;;223    /* End Function:RMP_Print_String *********************************************/
                          ENDP


                          AREA ||i.RMP_Print_Uint||, CODE, READONLY, ALIGN=1

                  RMP_Print_Uint PROC
;;;160    ******************************************************************************/
;;;161    rmp_cnt_t RMP_Print_Uint(rmp_ptr_t Uint)
000000  b570              PUSH     {r4-r6,lr}
;;;162    {
000002  0004              MOVS     r4,r0
000004  d001              BEQ      |L15.10|
;;;163        rmp_ptr_t Iter;
;;;164        rmp_cnt_t Count;
;;;165        rmp_cnt_t Num;
;;;166        
;;;167        /* how many digits are there? */
;;;168        if(Uint==0)
;;;169        {
;;;170            RMP_Putchar('0');
;;;171            return 1;
;;;172        }
;;;173        else
;;;174        {
;;;175            /* Filter out all the zeroes */
;;;176            Count=0;
000006  2100              MOVS     r1,#0
;;;177            Iter=Uint;
;;;178            while((Iter>>((sizeof(rmp_ptr_t)*8)-4))==0)
000008  e006              B        |L15.24|
                  |L15.10|
00000a  2030              MOVS     r0,#0x30              ;170
00000c  f7fffffe          BL       RMP_Putchar
000010  2001              MOVS     r0,#1                 ;171
;;;179            {
;;;180                Iter<<=4;
;;;181                Count++;
;;;182            }
;;;183            /* Count is the number of pts to print */
;;;184            Count=sizeof(rmp_ptr_t)*2-Count;
;;;185            Num=Count;
;;;186            while(Count>0)
;;;187            {
;;;188                Count--;
;;;189                Iter=(Uint>>(Count*4))&0x0F;
;;;190                if(Iter<10)
;;;191                    RMP_Putchar('0'+Iter);
;;;192                else
;;;193                    RMP_Putchar('A'+Iter-10);
;;;194            }
;;;195        }
;;;196        
;;;197        return Num;
;;;198    }
000012  bd70              POP      {r4-r6,pc}
                  |L15.20|
000014  0100              LSLS     r0,r0,#4              ;180
000016  1c49              ADDS     r1,r1,#1              ;180
                  |L15.24|
000018  0f02              LSRS     r2,r0,#28             ;178
00001a  d0fb              BEQ      |L15.20|
00001c  f1c10508          RSB      r5,r1,#8              ;184
000020  462e              MOV      r6,r5                 ;185
000022  e00e              B        |L15.66|
                  |L15.36|
000024  4628              MOV      r0,r5                 ;188
000026  1e6d              SUBS     r5,r5,#1              ;188
000028  0081              LSLS     r1,r0,#2              ;188
00002a  1f09              SUBS     r1,r1,#4              ;188
00002c  fa24f001          LSR      r0,r4,r1              ;189
000030  f000000f          AND      r0,r0,#0xf            ;189
000034  280a              CMP      r0,#0xa               ;190
000036  d201              BCS      |L15.60|
000038  3030              ADDS     r0,r0,#0x30           ;190
00003a  e000              B        |L15.62|
                  |L15.60|
00003c  3037              ADDS     r0,r0,#0x37           ;191
                  |L15.62|
00003e  f7fffffe          BL       RMP_Putchar
                  |L15.66|
000042  2d00              CMP      r5,#0                 ;186
000044  dcee              BGT      |L15.36|
000046  4630              MOV      r0,r6                 ;197
000048  bd70              POP      {r4-r6,pc}
;;;199    /* End Function:RMP_Print_Uint ***********************************************/
                          ENDP


                          AREA ||i.RMP_RBIT_Get||, CODE, READONLY, ALIGN=2

                  RMP_RBIT_Get PROC
;;;2077   
;;;2078   rmp_ptr_t RMP_RBIT_Get(rmp_ptr_t Val)
000000  4a0a              LDR      r2,|L16.44|
;;;2079   {
000002  0e03              LSRS     r3,r0,#24
000004  b570              PUSH     {r4-r6,lr}
;;;2080       rmp_ptr_t Ret;
;;;2081       rmp_ptr_t Src;
;;;2082       rmp_u8_t* To;
;;;2083       rmp_u8_t* From;
;;;2084       
;;;2085       Src=Val;
;;;2086       To=(rmp_u8_t*)(&Ret);
;;;2087       From=(rmp_u8_t*)(&Src);
;;;2088       
;;;2089   #if(RMP_WORD_ORDER==4)
;;;2090       To[0]=RMP_RBIT_Table[From[1]];
;;;2091       To[1]=RMP_RBIT_Table[From[0]];
;;;2092   #elif(RMP_WORD_ORDER==5)
;;;2093       To[0]=RMP_RBIT_Table[From[3]];
000006  f3c04407          UBFX     r4,r0,#16,#8
00000a  f3c02507          UBFX     r5,r0,#8,#8
00000e  b2c6              UXTB     r6,r0
000010  5cd0              LDRB     r0,[r2,r3]
;;;2094       To[1]=RMP_RBIT_Table[From[2]];
000012  5d14              LDRB     r4,[r2,r4]
;;;2095       To[2]=RMP_RBIT_Table[From[1]];
000014  5d53              LDRB     r3,[r2,r5]
;;;2096       To[3]=RMP_RBIT_Table[From[0]];
000016  f3600107          BFI      r1,r0,#0,#8
00001a  5d92              LDRB     r2,[r2,r6]
00001c  4608              MOV      r0,r1
00001e  f364200f          BFI      r0,r4,#8,#8
000022  f3634017          BFI      r0,r3,#16,#8
000026  f362601f          BFI      r0,r2,#24,#8
;;;2097   #else
;;;2098       To[0]=RMP_RBIT_Table[From[7]];
;;;2099       To[1]=RMP_RBIT_Table[From[6]];
;;;2100       To[2]=RMP_RBIT_Table[From[5]];
;;;2101       To[3]=RMP_RBIT_Table[From[4]];
;;;2102       To[4]=RMP_RBIT_Table[From[3]];
;;;2103       To[5]=RMP_RBIT_Table[From[2]];
;;;2104       To[6]=RMP_RBIT_Table[From[1]];
;;;2105       To[7]=RMP_RBIT_Table[From[0]];
;;;2106   #endif
;;;2107   
;;;2108       return Ret;
;;;2109   }
00002a  bd70              POP      {r4-r6,pc}
;;;2110   /* End Function:RMP_RBIT_Get *************************************************/
                          ENDP

                  |L16.44|
                          DCD      ||.constdata||

                          AREA ||i.RMP_Realloc||, CODE, READONLY, ALIGN=2

                  RMP_Realloc PROC
;;;2629   ******************************************************************************/
;;;2630   void* RMP_Realloc(volatile void* Pool, void* Mem_Ptr, rmp_ptr_t Size)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;2631   {
000004  f1b00900          SUBS     r9,r0,#0
000008  460e              MOV      r6,r1
00000a  d05a              BEQ      |L17.194|
;;;2632       /* The size of the original memory block */
;;;2633       rmp_ptr_t Mem_Size;
;;;2634       /* The rounded size of the new memory request */
;;;2635       rmp_ptr_t Rounded_Size;
;;;2636       rmp_ptr_t Count;
;;;2637       /* The pointer to the pool */
;;;2638       volatile struct RMP_Mem* Mem;
;;;2639       /* The head of the old memory */
;;;2640       volatile struct RMP_Mem_Head* Mem_Head;
;;;2641       /* The right-side block head */
;;;2642       volatile struct RMP_Mem_Head* Right_Head;
;;;2643       /* The pointer to the residue memory head */
;;;2644       volatile struct RMP_Mem_Head* Res_Mem;
;;;2645       /* The new memory block */
;;;2646       void* New_Mem;
;;;2647       /* The size of the memory block including the header sizes */
;;;2648       rmp_ptr_t Old_Size;
;;;2649       /* The size of the residue memory block including the header sizes */
;;;2650       rmp_ptr_t Res_Size;
;;;2651       
;;;2652       /* Check if no pool present */
;;;2653       if(Pool==0)
;;;2654       {
;;;2655           RMP_COVERAGE_MARKER();
;;;2656           return 0;
;;;2657       }
;;;2658       else
;;;2659           RMP_COVERAGE_MARKER();
;;;2660       
;;;2661       /* Are we passing in a NULL pointer? */
;;;2662       if(Mem_Ptr==0)
00000c  b316              CBZ      r6,|L17.84|
;;;2663       {
;;;2664           RMP_COVERAGE_MARKER();
;;;2665           return RMP_Malloc(Pool,Size);
;;;2666       }
;;;2667       else
;;;2668           RMP_COVERAGE_MARKER();
;;;2669       
;;;2670       /* Is the size passed in zero? If yes, we free directly */
;;;2671       if(Size==0)
00000e  b332              CBZ      r2,|L17.94|
;;;2672       {
;;;2673           RMP_COVERAGE_MARKER();
;;;2674           RMP_Free(Pool,Mem_Ptr);
;;;2675           return 0;
;;;2676       }
;;;2677       else
;;;2678           RMP_COVERAGE_MARKER();
;;;2679       
;;;2680       /* See if the address is within the allocatable address range. If not, abort directly. */
;;;2681       Mem=(volatile struct RMP_Mem*)Pool;
;;;2682       if((((rmp_ptr_t)Mem_Ptr)<=((rmp_ptr_t)Mem))||(((rmp_ptr_t)Mem_Ptr)>=(((rmp_ptr_t)Mem)+Mem->Size)))
000010  4286              CMP      r6,r0
000012  d955              BLS      |L17.192|
000014  6881              LDR      r1,[r0,#8]
000016  4401              ADD      r1,r1,r0
000018  42b1              CMP      r1,r6
00001a  d951              BLS      |L17.192|
;;;2683       {
;;;2684           RMP_COVERAGE_MARKER();
;;;2685           return 0;
;;;2686       }
;;;2687       else
;;;2688           RMP_COVERAGE_MARKER();
;;;2689   
;;;2690       /* Yes, get the location of the header of the memory */
;;;2691       Mem_Head=(struct RMP_Mem_Head*)(((rmp_ptr_t)Mem_Ptr)-sizeof(struct RMP_Mem_Head));
00001c  f1a60510          SUB      r5,r6,#0x10
;;;2692       /* See if the block can really be realloced */
;;;2693       if(Mem_Head->State==RMP_MEM_FREE)
000020  68a9              LDR      r1,[r5,#8]
000022  b3d1              CBZ      r1,|L17.154|
000024  1dd2              ADDS     r2,r2,#7
;;;2694       {
;;;2695           RMP_COVERAGE_MARKER();
;;;2696           return 0;
;;;2697       }
;;;2698       else
;;;2699           RMP_COVERAGE_MARKER();
;;;2700       
;;;2701       /* Round up the size:a multiple of 8 and bigger than 64B */
;;;2702       Rounded_Size=RMP_ROUND_UP(Size,3);
000026  f0220407          BIC      r4,r2,#7
;;;2703       /* See if it is smaller than the smallest block */
;;;2704       Rounded_Size=(Rounded_Size>64)?Rounded_Size:64;
00002a  2c40              CMP      r4,#0x40
00002c  d800              BHI      |L17.48|
00002e  2440              MOVS     r4,#0x40
                  |L17.48|
;;;2705       
;;;2706       Mem_Size=((rmp_ptr_t)Mem_Head->Tail)-((rmp_ptr_t)Mem_Ptr);
000030  68e9              LDR      r1,[r5,#0xc]
;;;2707       /* Does the right-side head exist at all? */
;;;2708       Right_Head=(struct RMP_Mem_Head*)(((rmp_ptr_t)(Mem_Head->Tail))+sizeof(struct RMP_Mem_Tail));
000032  68ef              LDR      r7,[r5,#0xc]
;;;2709       if(((rmp_ptr_t)Right_Head)==(((rmp_ptr_t)Mem)+Mem->Size))
000034  6882              LDR      r2,[r0,#8]
000036  eba10806          SUB      r8,r1,r6              ;2706
00003a  1d3f              ADDS     r7,r7,#4              ;2706
00003c  444a              ADD      r2,r2,r9
00003e  42ba              CMP      r2,r7
000040  d100              BNE      |L17.68|
;;;2710       {
;;;2711           RMP_COVERAGE_MARKER();
;;;2712           Right_Head=0;
000042  2700              MOVS     r7,#0
                  |L17.68|
;;;2713       }
;;;2714       else
;;;2715           RMP_COVERAGE_MARKER();
;;;2716       
;;;2717       /* Are we gonna expand it? */
;;;2718       if(Mem_Size<Rounded_Size)
;;;2719       {
;;;2720           /* Expanding */
;;;2721           RMP_COVERAGE_MARKER();
;;;2722           /* Does the right side exist at all? */
;;;2723           if(Right_Head!=0)
;;;2724           {
;;;2725               RMP_COVERAGE_MARKER();
;;;2726               /* Is it allocated? */
;;;2727               if(Right_Head->State==RMP_MEM_FREE)
;;;2728               {
;;;2729                   RMP_COVERAGE_MARKER();
;;;2730                   /* Right-side exists and is free. How big is its usable size? Is it sufficient for our realloc? */
;;;2731                   if((((rmp_ptr_t)Right_Head->Tail)-((rmp_ptr_t)Mem_Ptr))>=Rounded_Size)
;;;2732                   {
;;;2733                       RMP_COVERAGE_MARKER();
;;;2734                       /* Remove the right-side from the free list so we can operate on it */
;;;2735                       _RMP_Mem_Del(Pool, Right_Head);   
;;;2736                       /* Allocate and calculate if the space left could be big enough to be a new 
;;;2737                        * block. If so, we will put the block back into the TLSF table */
;;;2738                       Res_Size=((rmp_ptr_t)(Right_Head->Tail))-((rmp_ptr_t)Mem_Ptr)-Rounded_Size;
;;;2739                       /* Is the residue big enough to be a block? */
;;;2740                       if(Res_Size>=(sizeof(struct RMP_Mem_Head)+64+sizeof(struct RMP_Mem_Tail)))
;;;2741                       {
;;;2742                           RMP_COVERAGE_MARKER();
;;;2743                           Old_Size=sizeof(struct RMP_Mem_Head)+Rounded_Size+sizeof(struct RMP_Mem_Tail);
;;;2744                           Res_Mem=(volatile struct RMP_Mem_Head*)(((rmp_ptr_t)Mem_Head)+Old_Size);
;;;2745   
;;;2746                           _RMP_Mem_Block(Mem_Head, Old_Size);
;;;2747                           _RMP_Mem_Block(Res_Mem, Res_Size);
;;;2748   
;;;2749                           /* Put the extra block back */
;;;2750                           _RMP_Mem_Ins(Pool, Res_Mem);
;;;2751                       }
;;;2752                       else
;;;2753                       {
;;;2754                           /* Residue too small. Merging the whole thing in is the only option */
;;;2755                           RMP_COVERAGE_MARKER();
;;;2756                           Old_Size=((rmp_ptr_t)(Right_Head->Tail))-((rmp_ptr_t)Mem_Head)+sizeof(struct RMP_Mem_Tail);
;;;2757                           _RMP_Mem_Block(Mem_Head, Old_Size);
;;;2758                       }
;;;2759                       
;;;2760                       /* Mark the block as in use (making new block clears this flag) */
;;;2761                       Mem_Head->State=RMP_MEM_USED;
000044  f04f0a01          MOV      r10,#1
000048  45a0              CMP      r8,r4                 ;2718
00004a  d24b              BCS      |L17.228|
00004c  b37f              CBZ      r7,|L17.174|
00004e  68b8              LDR      r0,[r7,#8]            ;2727
000050  b140              CBZ      r0,|L17.100|
000052  e02d              B        |L17.176|
                  |L17.84|
000054  e8bd47f0          POP      {r4-r10,lr}           ;2665
000058  4611              MOV      r1,r2                 ;2665
00005a  f7ffbffe          B.W      RMP_Malloc
                  |L17.94|
00005e  f7fffffe          BL       RMP_Free
000062  e02d              B        |L17.192|
                  |L17.100|
000064  68f8              LDR      r0,[r7,#0xc]          ;2731
000066  1b80              SUBS     r0,r0,r6              ;2731
000068  42a0              CMP      r0,r4                 ;2731
00006a  d321              BCC      |L17.176|
00006c  4639              MOV      r1,r7                 ;2735
00006e  4648              MOV      r0,r9                 ;2735
000070  f7fffffe          BL       _RMP_Mem_Del
000074  68f8              LDR      r0,[r7,#0xc]          ;2738
000076  1b80              SUBS     r0,r0,r6              ;2738
000078  eba00804          SUB      r8,r0,r4              ;2738
00007c  f1b80f54          CMP      r8,#0x54              ;2740
000080  d30c              BCC      |L17.156|
000082  f1040114          ADD      r1,r4,#0x14           ;2743
000086  4628              MOV      r0,r5                 ;2746
000088  186c              ADDS     r4,r5,r1              ;2744
00008a  f7fffffe          BL       _RMP_Mem_Block
00008e  4641              MOV      r1,r8                 ;2747
000090  4620              MOV      r0,r4                 ;2747
000092  f7fffffe          BL       _RMP_Mem_Block
000096  4621              MOV      r1,r4                 ;2750
000098  e04d              B        |L17.310|
                  |L17.154|
00009a  e011              B        |L17.192|
                  |L17.156|
00009c  68f8              LDR      r0,[r7,#0xc]          ;2756
00009e  1b41              SUBS     r1,r0,r5              ;2756
0000a0  4628              MOV      r0,r5                 ;2757
0000a2  1d09              ADDS     r1,r1,#4              ;2757
0000a4  f7fffffe          BL       _RMP_Mem_Block
                  |L17.168|
0000a8  f8c5a008          STR      r10,[r5,#8]
;;;2762                       /* Return the old pointer because we expanded it */
;;;2763                       return Mem_Ptr;
0000ac  e022              B        |L17.244|
                  |L17.174|
0000ae  e7ff              B        |L17.176|
                  |L17.176|
;;;2764                   }
;;;2765                   /* Right-side not large enough, have to go malloc then memcpy */
;;;2766                   else
;;;2767                       RMP_COVERAGE_MARKER();
;;;2768               }
;;;2769               /* It is allocated, have to go malloc then memcpy */
;;;2770               else
;;;2771                   RMP_COVERAGE_MARKER();
;;;2772           }
;;;2773           /* Right-side doesn't exist, have to go malloc then memcpy */
;;;2774           else
;;;2775               RMP_COVERAGE_MARKER();
;;;2776           
;;;2777           New_Mem=RMP_Malloc(Pool,Rounded_Size);
0000b0  4621              MOV      r1,r4
0000b2  4648              MOV      r0,r9
0000b4  f7fffffe          BL       RMP_Malloc
0000b8  0004              MOVS     r4,r0
;;;2778           /* See if we can allocate this much, if we can't at all, exit */
;;;2779           if(New_Mem==0)
0000ba  d001              BEQ      |L17.192|
;;;2780           {
;;;2781               RMP_COVERAGE_MARKER();
;;;2782               return 0;
;;;2783           }
;;;2784           else
;;;2785               RMP_COVERAGE_MARKER();
;;;2786           
;;;2787           /* Copy old memory to new memory - we know that this is always aligned, so this is fine */
;;;2788           for(Count=0;Count<(Mem_Size>>RMP_ALIGN_ORDER);Count++)
0000bc  2000              MOVS     r0,#0
0000be  e008              B        |L17.210|
                  |L17.192|
0000c0  2000              MOVS     r0,#0                 ;2782
                  |L17.194|
;;;2789               ((rmp_ptr_t*)New_Mem)[Count]=((rmp_ptr_t*)Mem_Ptr)[Count];
;;;2790           
;;;2791           /* Free old memory then return */
;;;2792           RMP_Free(Pool,Mem_Ptr);
;;;2793           return New_Mem;
;;;2794       }
;;;2795       /* Shrinking or keeping */
;;;2796       else
;;;2797           RMP_COVERAGE_MARKER();
;;;2798       
;;;2799       /* Are we keeping the size? */
;;;2800       if(Mem_Size==Rounded_Size)
;;;2801       {
;;;2802           RMP_COVERAGE_MARKER();
;;;2803           return Mem_Ptr;
;;;2804       }
;;;2805       else
;;;2806           RMP_COVERAGE_MARKER();
;;;2807       
;;;2808       /* Does the right side exist at all? */
;;;2809       if(Right_Head!=0)
;;;2810       {
;;;2811           RMP_COVERAGE_MARKER();
;;;2812           /* Is it allocated? */
;;;2813           if(Right_Head->State==RMP_MEM_FREE)
;;;2814           {
;;;2815               /* Right-side not allocated. Need to merge the block */
;;;2816               RMP_COVERAGE_MARKER();
;;;2817               /* Remove the right-side from the allocation list so we can operate on it */
;;;2818               _RMP_Mem_Del(Pool, Right_Head);
;;;2819               Res_Size=((rmp_ptr_t)(Right_Head->Tail))-((rmp_ptr_t)Mem_Ptr)-Rounded_Size;
;;;2820               Old_Size=sizeof(struct RMP_Mem_Head)+Rounded_Size+sizeof(struct RMP_Mem_Tail);
;;;2821               Res_Mem=(volatile struct RMP_Mem_Head*)(((rmp_ptr_t)Mem_Head)+Old_Size);
;;;2822   
;;;2823               _RMP_Mem_Block(Mem_Head, Old_Size);
;;;2824               _RMP_Mem_Block(Res_Mem, Res_Size);
;;;2825   
;;;2826               /* Put the extra block back */
;;;2827               _RMP_Mem_Ins(Pool, Res_Mem);
;;;2828               
;;;2829               /* Mark the block as in use (making new block clears this flag) */
;;;2830               Mem_Head->State=RMP_MEM_USED;
;;;2831               /* Return the old pointer because we shrinked it */
;;;2832               return Mem_Ptr;
;;;2833           }
;;;2834           /* Allocated. Need to see if the residue block itself is large enough to be inserted back */
;;;2835           else
;;;2836               RMP_COVERAGE_MARKER();
;;;2837       }
;;;2838       else
;;;2839           RMP_COVERAGE_MARKER();
;;;2840       
;;;2841       /* The right-side head either does not exist or is allocated. Calculate the resulting residue size */
;;;2842       Res_Size=Mem_Size-Rounded_Size;
;;;2843       if(Res_Size<(sizeof(struct RMP_Mem_Head)+64+sizeof(struct RMP_Mem_Tail)))
;;;2844       {
;;;2845           RMP_COVERAGE_MARKER();
;;;2846           /* The residue block wouldn't even count as a small one. Do nothing and quit */
;;;2847           return Mem_Ptr;
;;;2848       }
;;;2849       else
;;;2850           RMP_COVERAGE_MARKER();
;;;2851       
;;;2852       /* The residue will be big enough to become a standalone block. We need to place it back */ 
;;;2853       Old_Size=sizeof(struct RMP_Mem_Head)+Rounded_Size+sizeof(struct RMP_Mem_Tail);
;;;2854       Res_Mem=(volatile struct RMP_Mem_Head*)(((rmp_ptr_t)Mem_Head)+Old_Size);
;;;2855   
;;;2856       _RMP_Mem_Block(Mem_Head, Old_Size);
;;;2857       _RMP_Mem_Block(Res_Mem, Res_Size);
;;;2858   
;;;2859       /* Put the extra block back */
;;;2860       _RMP_Mem_Ins(Pool, Res_Mem);
;;;2861               
;;;2862       /* Mark the block as in use (making new block clears this flag) */
;;;2863       Mem_Head->State=RMP_MEM_USED;
;;;2864       /* Return the old pointer because we shrinked it */
;;;2865       return Mem_Ptr;
;;;2866   }
0000c2  e8bd87f0          POP      {r4-r10,pc}
0000c6  bf00              NOP                            ;2789
                  |L17.200|
0000c8  f8561020          LDR      r1,[r6,r0,LSL #2]     ;2789
0000cc  f8441020          STR      r1,[r4,r0,LSL #2]     ;2789
0000d0  1c40              ADDS     r0,r0,#1              ;2789
                  |L17.210|
0000d2  ebb00f98          CMP      r0,r8,LSR #2          ;2788
0000d6  d3f7              BCC      |L17.200|
0000d8  4631              MOV      r1,r6                 ;2792
0000da  4648              MOV      r0,r9                 ;2792
0000dc  f7fffffe          BL       RMP_Free
0000e0  4620              MOV      r0,r4                 ;2793
0000e2  e7ee              B        |L17.194|
                  |L17.228|
0000e4  d006              BEQ      |L17.244|
0000e6  b10f              CBZ      r7,|L17.236|
0000e8  68b8              LDR      r0,[r7,#8]            ;2813
0000ea  b128              CBZ      r0,|L17.248|
                  |L17.236|
0000ec  eba80704          SUB      r7,r8,r4              ;2842
0000f0  2f54              CMP      r7,#0x54              ;2843
0000f2  d214              BCS      |L17.286|
                  |L17.244|
0000f4  4630              MOV      r0,r6                 ;2847
0000f6  e7e4              B        |L17.194|
                  |L17.248|
0000f8  4639              MOV      r1,r7                 ;2818
0000fa  4648              MOV      r0,r9                 ;2818
0000fc  f7fffffe          BL       _RMP_Mem_Del
000100  68f8              LDR      r0,[r7,#0xc]          ;2819
000102  f1040114          ADD      r1,r4,#0x14           ;2820
000106  186f              ADDS     r7,r5,r1              ;2821
000108  1b80              SUBS     r0,r0,r6              ;2819
00010a  1b04              SUBS     r4,r0,r4              ;2819
00010c  4628              MOV      r0,r5                 ;2823
00010e  f7fffffe          BL       _RMP_Mem_Block
000112  4621              MOV      r1,r4                 ;2824
000114  4638              MOV      r0,r7                 ;2824
000116  f7fffffe          BL       _RMP_Mem_Block
00011a  4639              MOV      r1,r7                 ;2827
00011c  e00b              B        |L17.310|
                  |L17.286|
00011e  f1040114          ADD      r1,r4,#0x14           ;2853
000122  4628              MOV      r0,r5                 ;2856
000124  eb050801          ADD      r8,r5,r1              ;2854
000128  f7fffffe          BL       _RMP_Mem_Block
00012c  4639              MOV      r1,r7                 ;2857
00012e  4640              MOV      r0,r8                 ;2857
000130  f7fffffe          BL       _RMP_Mem_Block
000134  4641              MOV      r1,r8                 ;2860
                  |L17.310|
000136  4648              MOV      r0,r9                 ;2860
000138  f7fffffe          BL       _RMP_Mem_Ins
00013c  e7b4              B        |L17.168|
;;;2867   /* End Function:RMP_Realloc **************************************************/
                          ENDP


                          AREA ||i.RMP_Save_Ctx||, CODE, READONLY, ALIGN=1

                  RMP_Save_Ctx PROC
;;;1941   #if(RMP_USE_HOOKS==RMP_FALSE)
;;;1942   void RMP_Save_Ctx(void)
000000  4770              BX       lr
;;;1943   {
;;;1944       return;
;;;1945   }
;;;1946   #endif
                          ENDP


                          AREA ||i.RMP_Sem_Abort||, CODE, READONLY, ALIGN=1

                  RMP_Sem_Abort PROC
;;;1736   ******************************************************************************/
;;;1737   rmp_ret_t RMP_Sem_Abort(volatile struct RMP_Thd* Thread)
000000  b570              PUSH     {r4-r6,lr}
;;;1738   {
000002  0004              MOVS     r4,r0
;;;1739       /* Check if this thread structure could possibly be in use */
;;;1740       if(Thread==0)
;;;1741       {
;;;1742           RMP_COVERAGE_MARKER();
;;;1743           return RMP_ERR_THD;
000004  f04f35ff          MOV      r5,#0xffffffff
000008  d011              BEQ      |L19.46|
;;;1744       }
;;;1745       else
;;;1746           RMP_COVERAGE_MARKER();
;;;1747   
;;;1748       RMP_Lock_Sched();
00000a  f7fffffe          BL       RMP_Lock_Sched
;;;1749       
;;;1750       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
00000e  69a0              LDR      r0,[r4,#0x18]
000010  f0100fff          TST      r0,#0xff
000014  d00d              BEQ      |L19.50|
;;;1751       {
;;;1752           RMP_COVERAGE_MARKER();
;;;1753           RMP_Unlock_Sched();
;;;1754           return RMP_ERR_THD;
;;;1755       }
;;;1756       else
;;;1757           RMP_COVERAGE_MARKER();
;;;1758       
;;;1759       /* Is it waiting on a semaphore? If no, we abort and return an error code */
;;;1760       if((RMP_THD_STATE(Thread->State)!=RMP_THD_SEMBLK)&&
000016  69a0              LDR      r0,[r4,#0x18]
000018  b2c0              UXTB     r0,r0
00001a  2807              CMP      r0,#7
00001c  d00c              BEQ      |L19.56|
;;;1761          (RMP_THD_STATE(Thread->State)!=RMP_THD_SEMDLY))
00001e  69a0              LDR      r0,[r4,#0x18]
000020  b2c0              UXTB     r0,r0
000022  2808              CMP      r0,#8
000024  d008              BEQ      |L19.56|
;;;1762       {
;;;1763           RMP_COVERAGE_MARKER();
;;;1764           RMP_Unlock_Sched();
000026  f7fffffe          BL       RMP_Unlock_Sched
;;;1765           return RMP_ERR_STATE;
00002a  00a8              LSLS     r0,r5,#2
;;;1766       }
;;;1767       else
;;;1768           RMP_COVERAGE_MARKER();
;;;1769   
;;;1770       /* Waiting for a semaphore. We abort it and return */
;;;1771       RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1772       if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1773       {
;;;1774           RMP_COVERAGE_MARKER();
;;;1775           RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1776       }
;;;1777       else
;;;1778           RMP_COVERAGE_MARKER();
;;;1779       
;;;1780       RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1781       /* Set to running if not suspended */
;;;1782       _RMP_Set_Rdy(Thread);
;;;1783       
;;;1784       Thread->Retval=RMP_ERR_OPER;
;;;1785       RMP_Unlock_Sched();
;;;1786       return 0;
;;;1787   }
00002c  bd70              POP      {r4-r6,pc}
                  |L19.46|
00002e  4628              MOV      r0,r5                 ;1743
000030  bd70              POP      {r4-r6,pc}
                  |L19.50|
000032  f7fffffe          BL       RMP_Unlock_Sched
000036  e7fa              B        |L19.46|
                  |L19.56|
000038  6820              LDR      r0,[r4,#0]            ;1771
00003a  6861              LDR      r1,[r4,#4]            ;1771
00003c  6008              STR      r0,[r1,#0]            ;1771
00003e  6041              STR      r1,[r0,#4]            ;1771
000040  69a0              LDR      r0,[r4,#0x18]         ;1772
000042  b2c0              UXTB     r0,r0                 ;1772
000044  2808              CMP      r0,#8                 ;1772
000046  d103              BNE      |L19.80|
000048  68a1              LDR      r1,[r4,#8]            ;1775
00004a  68e0              LDR      r0,[r4,#0xc]          ;1775
00004c  6001              STR      r1,[r0,#0]            ;1775
00004e  6048              STR      r0,[r1,#4]            ;1775
                  |L19.80|
000050  69a0              LDR      r0,[r4,#0x18]         ;1780
000052  f02000ff          BIC      r0,r0,#0xff           ;1780
000056  1c40              ADDS     r0,r0,#1              ;1780
000058  61a0              STR      r0,[r4,#0x18]         ;1780
00005a  4620              MOV      r0,r4                 ;1782
00005c  f7fffffe          BL       _RMP_Set_Rdy
000060  f06f0004          MVN      r0,#4                 ;1784
000064  63a0              STR      r0,[r4,#0x38]         ;1784
000066  f7fffffe          BL       RMP_Unlock_Sched
00006a  2000              MOVS     r0,#0                 ;1786
00006c  bd70              POP      {r4-r6,pc}
;;;1788   /* End Function:RMP_Sem_Abort ************************************************/
                          ENDP


                          AREA ||i.RMP_Sem_Crt||, CODE, READONLY, ALIGN=1

                  RMP_Sem_Crt PROC
;;;1555   ******************************************************************************/
;;;1556   rmp_ret_t RMP_Sem_Crt(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Number)
000000  b570              PUSH     {r4-r6,lr}
;;;1557   {
000002  0004              MOVS     r4,r0
000004  460d              MOV      r5,r1
;;;1558       /* Check if this semaphore structure could possibly be in use */
;;;1559       if(Semaphore==0)
;;;1560       {
;;;1561           RMP_COVERAGE_MARKER();
;;;1562           return RMP_ERR_SEM;
000006  f06f0605          MVN      r6,#5
00000a  d005              BEQ      |L20.24|
;;;1563       }
;;;1564       else
;;;1565           RMP_COVERAGE_MARKER();
;;;1566       
;;;1567       RMP_Lock_Sched();
00000c  f7fffffe          BL       RMP_Lock_Sched
;;;1568       
;;;1569       if(Semaphore->State!=RMP_SEM_FREE)
000010  68a0              LDR      r0,[r4,#8]
000012  b118              CBZ      r0,|L20.28|
;;;1570       {
;;;1571           RMP_COVERAGE_MARKER();
;;;1572           RMP_Unlock_Sched();
000014  f7fffffe          BL       RMP_Unlock_Sched
                  |L20.24|
000018  4630              MOV      r0,r6                 ;1562
;;;1573           return RMP_ERR_SEM;
;;;1574       }
;;;1575       else
;;;1576           RMP_COVERAGE_MARKER();
;;;1577       
;;;1578       /* Is the number too great to initialize? */
;;;1579       if(Number>=RMP_SEM_MAX_NUM)
;;;1580       {
;;;1581           RMP_COVERAGE_MARKER();
;;;1582           RMP_Unlock_Sched();
;;;1583           return RMP_ERR_OPER;
;;;1584       }
;;;1585       else
;;;1586           RMP_COVERAGE_MARKER();
;;;1587   
;;;1588       /* Initialize contents */
;;;1589       Semaphore->Cur_Num=Number;
;;;1590       Semaphore->State=RMP_SEM_USED;
;;;1591       RMP_List_Crt(&(Semaphore->Wait_List));
;;;1592       
;;;1593       RMP_Unlock_Sched();
;;;1594       
;;;1595       return 0;
;;;1596   }
00001a  bd70              POP      {r4-r6,pc}
                  |L20.28|
00001c  f5b57f7a          CMP      r5,#0x3e8             ;1579
000020  d304              BCC      |L20.44|
000022  f7fffffe          BL       RMP_Unlock_Sched
000026  f06f0004          MVN      r0,#4                 ;1583
00002a  bd70              POP      {r4-r6,pc}
                  |L20.44|
00002c  2001              MOVS     r0,#1                 ;1590
00002e  60e5              STR      r5,[r4,#0xc]          ;1589
000030  60a0              STR      r0,[r4,#8]            ;1590
000032  6024              STR      r4,[r4,#0]            ;1590
000034  6064              STR      r4,[r4,#4]            ;1590
000036  f7fffffe          BL       RMP_Unlock_Sched
00003a  2000              MOVS     r0,#0                 ;1595
00003c  bd70              POP      {r4-r6,pc}
;;;1597   /* End Function:RMP_Sem_Crt **************************************************/
                          ENDP


                          AREA ||i.RMP_Sem_Del||, CODE, READONLY, ALIGN=1

                  RMP_Sem_Del PROC
;;;1604   ******************************************************************************/
;;;1605   rmp_ret_t RMP_Sem_Del(volatile struct RMP_Sem* Semaphore)
000000  b570              PUSH     {r4-r6,lr}
;;;1606   {
000002  0005              MOVS     r5,r0
;;;1607       struct RMP_Thd* Thread;
;;;1608       
;;;1609       /* Check if this semaphore structure could possibly be in use */
;;;1610       if(Semaphore==0)
;;;1611       {
;;;1612           RMP_COVERAGE_MARKER();
;;;1613           return RMP_ERR_SEM;
000004  f06f0405          MVN      r4,#5
000008  d006              BEQ      |L21.24|
;;;1614       }
;;;1615       else
;;;1616           RMP_COVERAGE_MARKER();
;;;1617       
;;;1618       RMP_Lock_Sched();
00000a  f7fffffe          BL       RMP_Lock_Sched
;;;1619       
;;;1620       if(Semaphore->State!=RMP_SEM_USED)
00000e  68a8              LDR      r0,[r5,#8]
000010  2801              CMP      r0,#1
000012  d019              BEQ      |L21.72|
;;;1621       {
;;;1622           RMP_COVERAGE_MARKER();
;;;1623           RMP_Unlock_Sched();
000014  f7fffffe          BL       RMP_Unlock_Sched
                  |L21.24|
000018  4620              MOV      r0,r4                 ;1613
;;;1624           return RMP_ERR_SEM;
;;;1625       }
;;;1626       else
;;;1627           RMP_COVERAGE_MARKER();
;;;1628   
;;;1629       /* Get rid of all guys waiting on it */
;;;1630       while(&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)
;;;1631       {
;;;1632           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
;;;1633           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1634           
;;;1635           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1636           {
;;;1637               RMP_COVERAGE_MARKER();
;;;1638               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1639           }
;;;1640           else
;;;1641               RMP_COVERAGE_MARKER();
;;;1642   
;;;1643           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1644           /* Set to running if not suspended */
;;;1645           _RMP_Set_Rdy(Thread);
;;;1646           Thread->Retval=RMP_ERR_OPER;
;;;1647       }
;;;1648       Semaphore->State=RMP_SEM_FREE;
;;;1649       
;;;1650       RMP_Unlock_Sched();
;;;1651   
;;;1652       return 0;
;;;1653   }
00001a  bd70              POP      {r4-r6,pc}
                  |L21.28|
00001c  686c              LDR      r4,[r5,#4]            ;1632
00001e  e9d40100          LDRD     r0,r1,[r4,#0]         ;1632
000022  6008              STR      r0,[r1,#0]            ;1632
000024  6041              STR      r1,[r0,#4]            ;1632
000026  7e20              LDRB     r0,[r4,#0x18]         ;1635
000028  2808              CMP      r0,#8                 ;1635
00002a  d103              BNE      |L21.52|
00002c  e9d40102          LDRD     r0,r1,[r4,#8]         ;1635
000030  6008              STR      r0,[r1,#0]            ;1635
000032  6041              STR      r1,[r0,#4]            ;1635
                  |L21.52|
000034  69a0              LDR      r0,[r4,#0x18]         ;1643
000036  f02000ff          BIC      r0,r0,#0xff           ;1643
00003a  1c40              ADDS     r0,r0,#1              ;1643
00003c  61a0              STR      r0,[r4,#0x18]         ;1645
00003e  4620              MOV      r0,r4                 ;1645
000040  f7fffffe          BL       _RMP_Set_Rdy
000044  63a6              STR      r6,[r4,#0x38]         ;1646
000046  e001              B        |L21.76|
                  |L21.72|
000048  f06f0604          MVN      r6,#4                 ;1646
                  |L21.76|
00004c  6868              LDR      r0,[r5,#4]            ;1630
00004e  42a8              CMP      r0,r5                 ;1630
000050  d1e4              BNE      |L21.28|
000052  2000              MOVS     r0,#0                 ;1648
000054  60a8              STR      r0,[r5,#8]            ;1648
000056  f7fffffe          BL       RMP_Unlock_Sched
00005a  2000              MOVS     r0,#0                 ;1652
00005c  bd70              POP      {r4-r6,pc}
;;;1654   /* End Function:RMP_Sem_Del **************************************************/
                          ENDP


                          AREA ||i.RMP_Sem_Pend||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Pend PROC
;;;1662   ******************************************************************************/
;;;1663   rmp_ret_t RMP_Sem_Pend(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Slices)
000000  b570              PUSH     {r4-r6,lr}
;;;1664   {
000002  0005              MOVS     r5,r0
000004  460e              MOV      r6,r1
;;;1665       /* Check if this semaphore structure could possibly be in use */
;;;1666       if(Semaphore==0)
;;;1667       {
;;;1668           RMP_COVERAGE_MARKER();
;;;1669           return RMP_ERR_SEM;
000006  f06f0405          MVN      r4,#5
00000a  d006              BEQ      |L22.26|
;;;1670       }
;;;1671       else
;;;1672           RMP_COVERAGE_MARKER();
;;;1673       
;;;1674       RMP_Lock_Sched();
00000c  f7fffffe          BL       RMP_Lock_Sched
;;;1675       
;;;1676       if(Semaphore->State!=RMP_SEM_USED)
000010  68a8              LDR      r0,[r5,#8]
000012  2801              CMP      r0,#1
000014  d003              BEQ      |L22.30|
;;;1677       {
;;;1678           RMP_COVERAGE_MARKER();
;;;1679           RMP_Unlock_Sched();
000016  f7fffffe          BL       RMP_Unlock_Sched
                  |L22.26|
00001a  4620              MOV      r0,r4                 ;1669
;;;1680           return RMP_ERR_SEM;
;;;1681       }
;;;1682       else
;;;1683           RMP_COVERAGE_MARKER();
;;;1684       
;;;1685       /* Check if we can get one immediately */
;;;1686       if(Semaphore->Cur_Num!=0)
;;;1687       {
;;;1688           RMP_COVERAGE_MARKER();
;;;1689           Semaphore->Cur_Num--;
;;;1690           RMP_Unlock_Sched();
;;;1691           return Semaphore->Cur_Num;
;;;1692       }
;;;1693       else
;;;1694       {
;;;1695           RMP_COVERAGE_MARKER();
;;;1696           /* Cannot get one, we need to block */
;;;1697           if(Slices==0)
;;;1698           {
;;;1699               RMP_COVERAGE_MARKER();
;;;1700               RMP_Unlock_Sched();
;;;1701               return RMP_ERR_OPER;
;;;1702           }
;;;1703           else
;;;1704               RMP_COVERAGE_MARKER();
;;;1705   
;;;1706           /* We must be running - place into waitlist now */
;;;1707           _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1708           RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),Semaphore->Wait_List.Prev,&(Semaphore->Wait_List));
;;;1709           
;;;1710           if(Slices<RMP_MAX_SLICES)
;;;1711           {
;;;1712               RMP_COVERAGE_MARKER();
;;;1713               _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1714               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SEMDLY);
;;;1715           }
;;;1716           else
;;;1717           {
;;;1718               RMP_COVERAGE_MARKER();
;;;1719               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SEMBLK);
;;;1720           }
;;;1721           
;;;1722           RMP_Cur_Thd->Retval=0;
;;;1723       }
;;;1724       
;;;1725       RMP_Unlock_Sched();
;;;1726   
;;;1727       return RMP_Cur_Thd->Retval;
;;;1728   }
00001c  bd70              POP      {r4-r6,pc}
                  |L22.30|
00001e  68e8              LDR      r0,[r5,#0xc]          ;1686
000020  b130              CBZ      r0,|L22.48|
000022  68e8              LDR      r0,[r5,#0xc]          ;1689
000024  1e40              SUBS     r0,r0,#1              ;1689
000026  60e8              STR      r0,[r5,#0xc]          ;1689
000028  f7fffffe          BL       RMP_Unlock_Sched
00002c  68e8              LDR      r0,[r5,#0xc]          ;1691
00002e  bd70              POP      {r4-r6,pc}
                  |L22.48|
000030  b1be              CBZ      r6,|L22.98|
000032  4c16              LDR      r4,|L22.140|
000034  69a0              LDR      r0,[r4,#0x18]         ;1707  ; RMP_Cur_Thd
000036  f7fffffe          BL       _RMP_Clr_Rdy
00003a  6829              LDR      r1,[r5,#0]            ;1708
00003c  462a              MOV      r2,r5                 ;1708
00003e  69a0              LDR      r0,[r4,#0x18]         ;1708  ; RMP_Cur_Thd
000040  f7fffffe          BL       RMP_List_Ins
000044  4812              LDR      r0,|L22.144|
000046  4286              CMP      r6,r0                 ;1710
000048  d210              BCS      |L22.108|
00004a  69a0              LDR      r0,[r4,#0x18]         ;1713  ; RMP_Cur_Thd
00004c  4631              MOV      r1,r6                 ;1713
00004e  f7fffffe          BL       _RMP_Dly_Ins
000052  69a0              LDR      r0,[r4,#0x18]         ;1714  ; RMP_Cur_Thd
000054  69a1              LDR      r1,[r4,#0x18]         ;1714  ; RMP_Cur_Thd
000056  6980              LDR      r0,[r0,#0x18]         ;1714
000058  f02000ff          BIC      r0,r0,#0xff           ;1714
00005c  f0400008          ORR      r0,r0,#8              ;1714
000060  e00a              B        |L22.120|
                  |L22.98|
000062  f7fffffe          BL       RMP_Unlock_Sched
000066  f06f0004          MVN      r0,#4                 ;1701
00006a  bd70              POP      {r4-r6,pc}
                  |L22.108|
00006c  69a0              LDR      r0,[r4,#0x18]         ;1719  ; RMP_Cur_Thd
00006e  69a1              LDR      r1,[r4,#0x18]         ;1719  ; RMP_Cur_Thd
000070  6980              LDR      r0,[r0,#0x18]         ;1719
000072  f02000ff          BIC      r0,r0,#0xff           ;1719
000076  1dc0              ADDS     r0,r0,#7              ;1719
                  |L22.120|
000078  6188              STR      r0,[r1,#0x18]         ;1722
00007a  69a1              LDR      r1,[r4,#0x18]         ;1722  ; RMP_Cur_Thd
00007c  2000              MOVS     r0,#0                 ;1722
00007e  6388              STR      r0,[r1,#0x38]         ;1725
000080  f7fffffe          BL       RMP_Unlock_Sched
000084  69a0              LDR      r0,[r4,#0x18]         ;1727  ; RMP_Cur_Thd
000086  6b80              LDR      r0,[r0,#0x38]         ;1727
000088  bd70              POP      {r4-r6,pc}
;;;1729   /* End Function:RMP_Sem_Pend *************************************************/
                          ENDP

00008a  0000              DCW      0x0000
                  |L22.140|
                          DCD      ||.data||
                  |L22.144|
                          DCD      0x000186a0

                          AREA ||i.RMP_Sem_Post||, CODE, READONLY, ALIGN=1

                  RMP_Sem_Post PROC
;;;1796   ******************************************************************************/
;;;1797   rmp_ret_t RMP_Sem_Post(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Number)
000000  b570              PUSH     {r4-r6,lr}
;;;1798   {
000002  0004              MOVS     r4,r0
000004  460d              MOV      r5,r1
;;;1799       struct RMP_Thd* Thread;
;;;1800       
;;;1801       /* Check if this semaphore structure could possibly be in use */
;;;1802       if((Semaphore==0)||(Number==0))
;;;1803       {
;;;1804           RMP_COVERAGE_MARKER();
;;;1805           return RMP_ERR_SEM;
000006  f06f0605          MVN      r6,#5
00000a  d007              BEQ      |L23.28|
00000c  b135              CBZ      r5,|L23.28|
;;;1806       }
;;;1807       else
;;;1808           RMP_COVERAGE_MARKER();
;;;1809       
;;;1810       RMP_Lock_Sched();
00000e  f7fffffe          BL       RMP_Lock_Sched
;;;1811       
;;;1812       if(Semaphore->State!=RMP_SEM_USED)
000012  68a0              LDR      r0,[r4,#8]
000014  2801              CMP      r0,#1
000016  d003              BEQ      |L23.32|
;;;1813       {
;;;1814           RMP_COVERAGE_MARKER();
;;;1815           RMP_Unlock_Sched();
000018  f7fffffe          BL       RMP_Unlock_Sched
                  |L23.28|
00001c  4630              MOV      r0,r6                 ;1805
;;;1816           return RMP_ERR_SEM;
;;;1817       }
;;;1818       else
;;;1819           RMP_COVERAGE_MARKER();
;;;1820       
;;;1821       /* Would the maximum value be exceeded if this is posted? */
;;;1822       if((Semaphore->Cur_Num+Number)>=RMP_SEM_MAX_NUM)
;;;1823       {
;;;1824           RMP_COVERAGE_MARKER();
;;;1825           RMP_Unlock_Sched();
;;;1826           return RMP_ERR_OPER;
;;;1827       }
;;;1828       else
;;;1829           RMP_COVERAGE_MARKER();
;;;1830       
;;;1831       Semaphore->Cur_Num+=Number;
;;;1832       /* Is there any thread waiting on it? If there are, clean them up*/
;;;1833       while((&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)&&(Semaphore->Cur_Num!=0))
;;;1834       {
;;;1835           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
;;;1836           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1837           
;;;1838           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1839           {
;;;1840               RMP_COVERAGE_MARKER();
;;;1841               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1842           }
;;;1843           else
;;;1844               RMP_COVERAGE_MARKER();
;;;1845           
;;;1846           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1847           /* Set to running if not suspended */
;;;1848           _RMP_Set_Rdy(Thread);
;;;1849   
;;;1850           /* Finally, return success */
;;;1851           Thread->Retval=0;
;;;1852           Semaphore->Cur_Num--;
;;;1853       }
;;;1854   
;;;1855       RMP_Unlock_Sched();
;;;1856       return 0;
;;;1857   }
00001e  bd70              POP      {r4-r6,pc}
                  |L23.32|
000020  68e0              LDR      r0,[r4,#0xc]          ;1822
000022  4428              ADD      r0,r0,r5              ;1822
000024  f5b07f7a          CMP      r0,#0x3e8             ;1822
000028  d304              BCC      |L23.52|
00002a  f7fffffe          BL       RMP_Unlock_Sched
00002e  f06f0004          MVN      r0,#4                 ;1826
000032  bd70              POP      {r4-r6,pc}
                  |L23.52|
000034  68e0              LDR      r0,[r4,#0xc]          ;1831
000036  4428              ADD      r0,r0,r5              ;1831
000038  e017              B        |L23.106|
                  |L23.58|
00003a  6865              LDR      r5,[r4,#4]            ;1835
00003c  e9d50100          LDRD     r0,r1,[r5,#0]         ;1835
000040  6008              STR      r0,[r1,#0]            ;1835
000042  6041              STR      r1,[r0,#4]            ;1835
000044  7e28              LDRB     r0,[r5,#0x18]         ;1838
000046  2808              CMP      r0,#8                 ;1838
000048  d103              BNE      |L23.82|
00004a  e9d50102          LDRD     r0,r1,[r5,#8]         ;1838
00004e  6008              STR      r0,[r1,#0]            ;1838
000050  6041              STR      r1,[r0,#4]            ;1838
                  |L23.82|
000052  69a8              LDR      r0,[r5,#0x18]         ;1846
000054  f02000ff          BIC      r0,r0,#0xff           ;1846
000058  1c40              ADDS     r0,r0,#1              ;1846
00005a  61a8              STR      r0,[r5,#0x18]         ;1848
00005c  4628              MOV      r0,r5                 ;1848
00005e  f7fffffe          BL       _RMP_Set_Rdy
000062  2000              MOVS     r0,#0                 ;1851
000064  63a8              STR      r0,[r5,#0x38]         ;1852
000066  68e0              LDR      r0,[r4,#0xc]          ;1852
000068  1e40              SUBS     r0,r0,#1              ;1852
                  |L23.106|
00006a  60e0              STR      r0,[r4,#0xc]          ;1831
00006c  6860              LDR      r0,[r4,#4]            ;1833
00006e  42a0              CMP      r0,r4                 ;1833
000070  d002              BEQ      |L23.120|
000072  68e0              LDR      r0,[r4,#0xc]          ;1833
000074  2800              CMP      r0,#0                 ;1833
000076  d1e0              BNE      |L23.58|
                  |L23.120|
000078  f7fffffe          BL       RMP_Unlock_Sched
00007c  2000              MOVS     r0,#0                 ;1856
00007e  bd70              POP      {r4-r6,pc}
;;;1858   /* End Function:RMP_Sem_Post *************************************************/
                          ENDP


                          AREA ||i.RMP_Sem_Post_ISR||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Post_ISR PROC
;;;1868   ******************************************************************************/
;;;1869   rmp_ret_t RMP_Sem_Post_ISR(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Number)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1870   {
000004  0004              MOVS     r4,r0
;;;1871       struct RMP_Thd* Thread;
;;;1872       /* Check if this semaphore structure could possibly be in use */
;;;1873       if((Semaphore==0)||(Number==0))
;;;1874       {
;;;1875           RMP_COVERAGE_MARKER();
;;;1876           return RMP_ERR_SEM;
000006  f06f0005          MVN      r0,#5
00000a  d00a              BEQ      |L24.34|
00000c  2900              CMP      r1,#0                 ;1873
00000e  d008              BEQ      |L24.34|
;;;1877       }
;;;1878       else
;;;1879           RMP_COVERAGE_MARKER();
;;;1880       
;;;1881       if(Semaphore->State!=RMP_SEM_USED)
000010  68a2              LDR      r2,[r4,#8]
000012  2a01              CMP      r2,#1
000014  d105              BNE      |L24.34|
;;;1882       {
;;;1883           RMP_COVERAGE_MARKER();
;;;1884           return RMP_ERR_SEM;
;;;1885       }
;;;1886       else
;;;1887           RMP_COVERAGE_MARKER();
;;;1888   
;;;1889       /* Would the maximum value be exceeded if this is posted? */
;;;1890       if((Semaphore->Cur_Num+Number)>=RMP_SEM_MAX_NUM)
000016  68e0              LDR      r0,[r4,#0xc]
000018  4408              ADD      r0,r0,r1
00001a  f5b07f7a          CMP      r0,#0x3e8
00001e  d302              BCC      |L24.38|
;;;1891       {
;;;1892           RMP_COVERAGE_MARKER();
;;;1893           return RMP_ERR_OPER;
000020  1f90              SUBS     r0,r2,#6
                  |L24.34|
;;;1894       }
;;;1895       else
;;;1896           RMP_COVERAGE_MARKER();
;;;1897       
;;;1898       Semaphore->Cur_Num+=Number;
;;;1899       /* Is there any thread waiting on it? If there are, clean them up*/
;;;1900       while((&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)&&(Semaphore->Cur_Num!=0))
;;;1901       {
;;;1902           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
;;;1903           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1904           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1905           {
;;;1906               RMP_COVERAGE_MARKER();
;;;1907               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1908           }
;;;1909           else
;;;1910               RMP_COVERAGE_MARKER();
;;;1911           
;;;1912           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1913           /* Set to running if not suspended */
;;;1914           _RMP_Set_Rdy(Thread);
;;;1915           
;;;1916           /* If schedule pending, trigger it now because we are in ISR */
;;;1917           if(RMP_Sched_Pend!=0)
;;;1918           {
;;;1919               RMP_COVERAGE_MARKER();
;;;1920               RMP_Sched_Pend=0;
;;;1921               _RMP_Yield();   
;;;1922           }
;;;1923           else
;;;1924               RMP_COVERAGE_MARKER();
;;;1925   
;;;1926           /* Finally, return success */
;;;1927           Thread->Retval=0;
;;;1928           Semaphore->Cur_Num--;
;;;1929       }
;;;1930   
;;;1931       return 0;
;;;1932   }
000022  e8bd81f0          POP      {r4-r8,pc}
                  |L24.38|
000026  68e0              LDR      r0,[r4,#0xc]          ;1898
000028  2700              MOVS     r7,#0                 ;1917
00002a  4e14              LDR      r6,|L24.124|
00002c  4408              ADD      r0,r0,r1              ;1898
00002e  e01b              B        |L24.104|
                  |L24.48|
000030  6865              LDR      r5,[r4,#4]            ;1902
000032  e9d50100          LDRD     r0,r1,[r5,#0]         ;1902
000036  6008              STR      r0,[r1,#0]            ;1902
000038  6041              STR      r1,[r0,#4]            ;1902
00003a  7e28              LDRB     r0,[r5,#0x18]         ;1904
00003c  2808              CMP      r0,#8                 ;1904
00003e  d103              BNE      |L24.72|
000040  e9d50102          LDRD     r0,r1,[r5,#8]         ;1904
000044  6008              STR      r0,[r1,#0]            ;1904
000046  6041              STR      r1,[r0,#4]            ;1904
                  |L24.72|
000048  69a8              LDR      r0,[r5,#0x18]         ;1912
00004a  f02000ff          BIC      r0,r0,#0xff           ;1912
00004e  1c40              ADDS     r0,r0,#1              ;1912
000050  61a8              STR      r0,[r5,#0x18]         ;1914
000052  4628              MOV      r0,r5                 ;1914
000054  f7fffffe          BL       _RMP_Set_Rdy
000058  68f0              LDR      r0,[r6,#0xc]          ;1917  ; RMP_Sched_Pend
00005a  b110              CBZ      r0,|L24.98|
00005c  60f7              STR      r7,[r6,#0xc]          ;1920  ; RMP_Sched_Pend
00005e  f7fffffe          BL       _RMP_Yield
                  |L24.98|
000062  63af              STR      r7,[r5,#0x38]         ;1928
000064  68e0              LDR      r0,[r4,#0xc]          ;1928
000066  1e40              SUBS     r0,r0,#1              ;1928
                  |L24.104|
000068  60e0              STR      r0,[r4,#0xc]          ;1898
00006a  6860              LDR      r0,[r4,#4]            ;1900
00006c  42a0              CMP      r0,r4                 ;1900
00006e  d002              BEQ      |L24.118|
000070  68e0              LDR      r0,[r4,#0xc]          ;1900
000072  2800              CMP      r0,#0                 ;1900
000074  d1dc              BNE      |L24.48|
                  |L24.118|
000076  2000              MOVS     r0,#0                 ;1931
000078  e7d3              B        |L24.34|
;;;1933   /* End Function:RMP_Sem_Post_ISR *********************************************/
                          ENDP

00007a  0000              DCW      0x0000
                  |L24.124|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Cancel||, CODE, READONLY, ALIGN=1

                  RMP_Thd_Cancel PROC
;;;1513   ******************************************************************************/
;;;1514   rmp_ret_t RMP_Thd_Cancel(volatile struct RMP_Thd* Thread)
000000  b510              PUSH     {r4,lr}
;;;1515   {
000002  0004              MOVS     r4,r0
000004  d00a              BEQ      |L25.28|
;;;1516       /* Check if this thread structure could possibly be in use */
;;;1517       if(Thread==0)
;;;1518       {
;;;1519           RMP_COVERAGE_MARKER();
;;;1520           return RMP_ERR_THD;
;;;1521       }
;;;1522       else
;;;1523           RMP_COVERAGE_MARKER();
;;;1524       
;;;1525       RMP_Lock_Sched();
000006  f7fffffe          BL       RMP_Lock_Sched
;;;1526       
;;;1527       /* Is it delayed? */
;;;1528       if(RMP_THD_STATE(Thread->State)!=RMP_THD_DELAYED)
00000a  69a0              LDR      r0,[r4,#0x18]
00000c  b2c0              UXTB     r0,r0
00000e  2806              CMP      r0,#6
000010  d007              BEQ      |L25.34|
;;;1529       {
;;;1530           RMP_COVERAGE_MARKER();
;;;1531           RMP_Unlock_Sched();
000012  f7fffffe          BL       RMP_Unlock_Sched
;;;1532           return RMP_ERR_STATE;
000016  f06f0003          MVN      r0,#3
;;;1533       }
;;;1534       else
;;;1535           RMP_COVERAGE_MARKER();
;;;1536   
;;;1537       /* Delete it from the delay list */
;;;1538       RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1539       RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1540       /* Set to running if not suspended */
;;;1541       _RMP_Set_Rdy(Thread);
;;;1542       
;;;1543       Thread->Retval=RMP_ERR_OPER;
;;;1544       RMP_Unlock_Sched();
;;;1545       return 0;
;;;1546   }
00001a  bd10              POP      {r4,pc}
                  |L25.28|
00001c  f04f30ff          MOV      r0,#0xffffffff        ;1520
000020  bd10              POP      {r4,pc}
                  |L25.34|
000022  68a0              LDR      r0,[r4,#8]            ;1538
000024  68e1              LDR      r1,[r4,#0xc]          ;1538
000026  6008              STR      r0,[r1,#0]            ;1538
000028  6041              STR      r1,[r0,#4]            ;1538
00002a  69a0              LDR      r0,[r4,#0x18]         ;1539
00002c  f02000ff          BIC      r0,r0,#0xff           ;1539
000030  1c40              ADDS     r0,r0,#1              ;1539
000032  61a0              STR      r0,[r4,#0x18]         ;1539
000034  4620              MOV      r0,r4                 ;1541
000036  f7fffffe          BL       _RMP_Set_Rdy
00003a  f06f0004          MVN      r0,#4                 ;1543
00003e  63a0              STR      r0,[r4,#0x38]         ;1543
000040  f7fffffe          BL       RMP_Unlock_Sched
000044  2000              MOVS     r0,#0                 ;1545
000046  bd10              POP      {r4,pc}
;;;1547   /* End Function:RMP_Thd_Cancel ***********************************************/
                          ENDP


                          AREA ||i.RMP_Thd_Crt||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Crt PROC
;;;765    ******************************************************************************/
;;;766    rmp_ret_t RMP_Thd_Crt(volatile struct RMP_Thd* Thread, void* Entry, void* Stack, void* Arg, rmp_ptr_t Prio, rmp_ptr_t Slices)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;767    {
000004  4699              MOV      r9,r3
000006  4690              MOV      r8,r2
000008  468a              MOV      r10,r1
00000a  4604              MOV      r4,r0
00000c  e9dd6508          LDRD     r6,r5,[sp,#0x20]
;;;768        /* Check if the priority and timeslice range is correct */
;;;769        if(Prio>=RMP_MAX_PREEMPT_PRIO)
000010  2e20              CMP      r6,#0x20
000012  d303              BCC      |L26.28|
;;;770        {
;;;771            RMP_COVERAGE_MARKER();
;;;772            return RMP_ERR_PRIO;
000014  f06f0001          MVN      r0,#1
                  |L26.24|
;;;773        }
;;;774        else
;;;775            RMP_COVERAGE_MARKER();
;;;776        
;;;777        if((Slices==0)||(Slices>=RMP_MAX_SLICES))
;;;778        {
;;;779            RMP_COVERAGE_MARKER();
;;;780            return RMP_ERR_SLICE;
;;;781        }
;;;782        else
;;;783            RMP_COVERAGE_MARKER();
;;;784        
;;;785        /* Check if this thread structure could possibly be in use */
;;;786        if(Thread==0)
;;;787        {
;;;788            RMP_COVERAGE_MARKER();
;;;789            return RMP_ERR_THD;
;;;790        }
;;;791        else
;;;792            RMP_COVERAGE_MARKER();
;;;793        
;;;794        RMP_Lock_Sched();
;;;795        
;;;796        if(RMP_THD_STATE(Thread->State)!=RMP_THD_FREE)
;;;797        {
;;;798            RMP_COVERAGE_MARKER();
;;;799            RMP_Unlock_Sched();
;;;800            return RMP_ERR_THD;
;;;801        }
;;;802        else
;;;803            RMP_COVERAGE_MARKER();
;;;804        
;;;805        /* Create the thread and insert it into the list */
;;;806        Thread->Prio=Prio;
;;;807        Thread->Slices=Slices;
;;;808        Thread->Slices_Left=Slices;
;;;809        Thread->Stack=(rmp_ptr_t)Stack;
;;;810        
;;;811        /* Initialize its stack and sending list */
;;;812        _RMP_Stack_Init((rmp_ptr_t)Entry, (rmp_ptr_t)Stack, (rmp_ptr_t)Arg);
;;;813        RMP_List_Crt(&(Thread->Snd_List));
;;;814        
;;;815        /* Notify the scheduler that we have created something new, also check locks */
;;;816        Thread->State=RMP_THD_RUNNING;
;;;817        _RMP_Set_Rdy(Thread);
;;;818        
;;;819        RMP_Unlock_Sched();
;;;820    
;;;821        return 0;
;;;822    }
000018  e8bd87f0          POP      {r4-r10,pc}
                  |L26.28|
00001c  b115              CBZ      r5,|L26.36|
00001e  4815              LDR      r0,|L26.116|
000020  4285              CMP      r5,r0                 ;777
000022  d302              BCC      |L26.42|
                  |L26.36|
000024  f06f0002          MVN      r0,#2                 ;780
000028  e7f6              B        |L26.24|
                  |L26.42|
00002a  f04f37ff          MOV      r7,#0xffffffff        ;789
00002e  b13c              CBZ      r4,|L26.64|
000030  f7fffffe          BL       RMP_Lock_Sched
000034  69a0              LDR      r0,[r4,#0x18]         ;796
000036  f0100fff          TST      r0,#0xff              ;796
00003a  d003              BEQ      |L26.68|
00003c  f7fffffe          BL       RMP_Unlock_Sched
                  |L26.64|
000040  4638              MOV      r0,r7                 ;789
000042  e7e9              B        |L26.24|
                  |L26.68|
000044  6266              STR      r6,[r4,#0x24]         ;806
000046  61e5              STR      r5,[r4,#0x1c]         ;807
000048  6225              STR      r5,[r4,#0x20]         ;808
00004a  f8c48034          STR      r8,[r4,#0x34]         ;809
00004e  464a              MOV      r2,r9                 ;812
000050  4641              MOV      r1,r8                 ;812
000052  4650              MOV      r0,r10                ;812
000054  f7fffffe          BL       _RMP_Stack_Init
000058  f1040010          ADD      r0,r4,#0x10           ;813
00005c  6120              STR      r0,[r4,#0x10]         ;813
00005e  6160              STR      r0,[r4,#0x14]         ;813
000060  2001              MOVS     r0,#1                 ;816
000062  61a0              STR      r0,[r4,#0x18]         ;816
000064  4620              MOV      r0,r4                 ;817
000066  f7fffffe          BL       _RMP_Set_Rdy
00006a  f7fffffe          BL       RMP_Unlock_Sched
00006e  2000              MOVS     r0,#0                 ;821
000070  e7d2              B        |L26.24|
;;;823    /* End Function:RMP_Thd_Crt **************************************************/
                          ENDP

000072  0000              DCW      0x0000
                  |L26.116|
                          DCD      0x000186a0

                          AREA ||i.RMP_Thd_Del||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Del PROC
;;;830    ******************************************************************************/
;;;831    rmp_ret_t RMP_Thd_Del(volatile struct RMP_Thd* Thread)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;832    {
000004  0004              MOVS     r4,r0
;;;833        struct RMP_Thd* Release;
;;;834        
;;;835        /* Check if this thread structure could possibly be in use */
;;;836        if(Thread==0)
;;;837        {
;;;838            RMP_COVERAGE_MARKER();
;;;839            return RMP_ERR_THD;
000006  f04f35ff          MOV      r5,#0xffffffff
00000a  d014              BEQ      |L27.54|
;;;840        }
;;;841        else
;;;842            RMP_COVERAGE_MARKER();
;;;843        
;;;844        RMP_Lock_Sched();
00000c  f7fffffe          BL       RMP_Lock_Sched
;;;845        
;;;846        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
000010  69a0              LDR      r0,[r4,#0x18]
;;;847        {
;;;848            RMP_COVERAGE_MARKER();
;;;849            RMP_Unlock_Sched();
;;;850            return RMP_ERR_THD;
;;;851        }
;;;852        else
;;;853            RMP_COVERAGE_MARKER();
;;;854        
;;;855        /* See if anyone waiting to send to this thread. If there is, release all these threads */
;;;856        while(&(Thread->Snd_List)!=Thread->Snd_List.Next)
;;;857        {
;;;858            Release=(struct RMP_Thd*)(Thread->Snd_List.Next);
;;;859            RMP_List_Del(Release->Run_Head.Prev,Release->Run_Head.Next);
;;;860            if(RMP_THD_STATE(Release->State)==RMP_THD_SNDDLY)
;;;861            {
;;;862                RMP_COVERAGE_MARKER();
;;;863                RMP_List_Del(Release->Dly_Head.Prev,Release->Dly_Head.Next);
;;;864            }
;;;865            else
;;;866                RMP_COVERAGE_MARKER();
;;;867            
;;;868            RMP_THD_STATE_SET(Release->State,RMP_THD_RUNNING);
;;;869            /* Set ready if not suspended */
;;;870            _RMP_Set_Rdy(Release);
;;;871            Release->Retval=RMP_ERR_OPER;
000012  1f2f              SUBS     r7,r5,#4
000014  f0100fff          TST      r0,#0xff              ;846
000018  d010              BEQ      |L27.60|
00001a  f1040610          ADD      r6,r4,#0x10           ;856
                  |L27.30|
00001e  6960              LDR      r0,[r4,#0x14]         ;856
000020  42b0              CMP      r0,r6                 ;856
000022  d01c              BEQ      |L27.94|
000024  6965              LDR      r5,[r4,#0x14]         ;858
000026  e9d50100          LDRD     r0,r1,[r5,#0]         ;858
00002a  6008              STR      r0,[r1,#0]            ;858
00002c  6041              STR      r1,[r0,#4]            ;858
00002e  7e28              LDRB     r0,[r5,#0x18]         ;860
000030  2803              CMP      r0,#3                 ;860
000032  d006              BEQ      |L27.66|
000034  e009              B        |L27.74|
                  |L27.54|
000036  4628              MOV      r0,r5                 ;839
                  |L27.56|
;;;872        }
;;;873        
;;;874        /* See what is its state */
;;;875        switch(RMP_THD_STATE(Thread->State))
;;;876        {
;;;877            case RMP_THD_RUNNING:
;;;878            {
;;;879                RMP_COVERAGE_MARKER();
;;;880                /* Clear ready if not suspended */
;;;881                _RMP_Clr_Rdy(Thread);
;;;882                break;
;;;883            }
;;;884            
;;;885            /* Do nothing if it is blocked on receive */
;;;886            case RMP_THD_RCVBLK:
;;;887            {
;;;888                RMP_COVERAGE_MARKER();
;;;889                break;
;;;890            }
;;;891            
;;;892            case RMP_THD_SNDBLK:RMP_COVERAGE_MARKER();
;;;893            case RMP_THD_SEMBLK:
;;;894            {
;;;895                RMP_COVERAGE_MARKER();
;;;896                RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;897                break;
;;;898            }
;;;899            
;;;900            case RMP_THD_SNDDLY:RMP_COVERAGE_MARKER();
;;;901            case RMP_THD_SEMDLY:
;;;902            {
;;;903                RMP_COVERAGE_MARKER();
;;;904                RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;905                /* Fall-through case */
;;;906            }
;;;907            case RMP_THD_RCVDLY:RMP_COVERAGE_MARKER();
;;;908            case RMP_THD_DELAYED:
;;;909            {
;;;910                RMP_COVERAGE_MARKER();
;;;911                RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;912                break;
;;;913            }
;;;914            /* Should not get here */
;;;915            default:while(1);
;;;916        }
;;;917        /* Set return value to failure anyway */
;;;918        Thread->Retval=RMP_ERR_OPER;
;;;919        Thread->State=RMP_THD_FREE;
;;;920        /* If we are deleting ourself, pend a yield */
;;;921        if(Thread==RMP_Cur_Thd)
;;;922        {
;;;923            RMP_COVERAGE_MARKER();
;;;924            RMP_Sched_Pend=1;
;;;925        }
;;;926        else
;;;927            RMP_COVERAGE_MARKER();
;;;928        
;;;929        RMP_Unlock_Sched();
;;;930        
;;;931        /* If we are deleting ourself, just stop the execution here */
;;;932        if(Thread==RMP_Cur_Thd)
;;;933            while(1);
;;;934        else
;;;935            RMP_COVERAGE_MARKER();
;;;936    
;;;937        return 0;
;;;938    }
000038  e8bd81f0          POP      {r4-r8,pc}
                  |L27.60|
00003c  f7fffffe          BL       RMP_Unlock_Sched
000040  e7f9              B        |L27.54|
                  |L27.66|
000042  e9d50102          LDRD     r0,r1,[r5,#8]         ;850
000046  6008              STR      r0,[r1,#0]            ;850
000048  6041              STR      r1,[r0,#4]            ;850
                  |L27.74|
00004a  69a8              LDR      r0,[r5,#0x18]         ;868
00004c  f02000ff          BIC      r0,r0,#0xff           ;868
000050  1c40              ADDS     r0,r0,#1              ;868
000052  61a8              STR      r0,[r5,#0x18]         ;870
000054  4628              MOV      r0,r5                 ;870
000056  f7fffffe          BL       _RMP_Set_Rdy
00005a  63af              STR      r7,[r5,#0x38]         ;871
00005c  e7df              B        |L27.30|
                  |L27.94|
00005e  69a0              LDR      r0,[r4,#0x18]         ;875
000060  b2c0              UXTB     r0,r0                 ;875
000062  2809              CMP      r0,#9                 ;875
000064  d224              BCS      |L27.176|
000066  e8dff000          TBB      [pc,r0]               ;875
00006a  2305              DCB      0x23,0x05
00006c  090c1410          DCB      0x09,0x0c,0x14,0x10
000070  10090c00          DCB      0x10,0x09,0x0c,0x00
000074  4620              MOV      r0,r4                 ;881
000076  f7fffffe          BL       _RMP_Clr_Rdy
00007a  e00a              B        |L27.146|
00007c  6820              LDR      r0,[r4,#0]            ;896
00007e  6861              LDR      r1,[r4,#4]            ;896
000080  e005              B        |L27.142|
000082  6821              LDR      r1,[r4,#0]            ;904
000084  6860              LDR      r0,[r4,#4]            ;904
000086  6001              STR      r1,[r0,#0]            ;904
000088  6048              STR      r0,[r1,#4]            ;904
00008a  68a0              LDR      r0,[r4,#8]            ;911
00008c  68e1              LDR      r1,[r4,#0xc]          ;911
                  |L27.142|
00008e  6008              STR      r0,[r1,#0]            ;911
000090  6041              STR      r1,[r0,#4]            ;911
                  |L27.146|
000092  2000              MOVS     r0,#0                 ;919
000094  63a7              STR      r7,[r4,#0x38]         ;918
000096  4d08              LDR      r5,|L27.184|
000098  61a0              STR      r0,[r4,#0x18]         ;919
00009a  69a8              LDR      r0,[r5,#0x18]         ;921  ; RMP_Cur_Thd
00009c  4284              CMP      r4,r0                 ;921
00009e  d101              BNE      |L27.164|
0000a0  2001              MOVS     r0,#1                 ;924
0000a2  60e8              STR      r0,[r5,#0xc]          ;924  ; RMP_Sched_Pend
                  |L27.164|
0000a4  f7fffffe          BL       RMP_Unlock_Sched
0000a8  69a8              LDR      r0,[r5,#0x18]         ;932  ; RMP_Cur_Thd
0000aa  4284              CMP      r4,r0                 ;932
0000ac  d101              BNE      |L27.178|
                  |L27.174|
0000ae  e7fe              B        |L27.174|
                  |L27.176|
0000b0  e7fe              B        |L27.176|
                  |L27.178|
0000b2  2000              MOVS     r0,#0                 ;937
0000b4  e7c0              B        |L27.56|
;;;939    /* End Function:RMP_Thd_Del **************************************************/
                          ENDP

0000b6  0000              DCW      0x0000
                  |L27.184|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Delay||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Delay PROC
;;;1483   ******************************************************************************/
;;;1484   rmp_ret_t RMP_Thd_Delay(rmp_ptr_t Slices)
000000  b570              PUSH     {r4-r6,lr}
;;;1485   {
000002  0005              MOVS     r5,r0
000004  d002              BEQ      |L28.12|
;;;1486       if((Slices==0)||(Slices>=RMP_MAX_SLICES))
000006  480f              LDR      r0,|L28.68|
000008  4285              CMP      r5,r0
00000a  d302              BCC      |L28.18|
                  |L28.12|
;;;1487       {
;;;1488           RMP_COVERAGE_MARKER();
;;;1489           return RMP_ERR_SLICE;
00000c  f06f0002          MVN      r0,#2
;;;1490       }
;;;1491       else
;;;1492           RMP_COVERAGE_MARKER();
;;;1493       
;;;1494       RMP_Lock_Sched();
;;;1495   
;;;1496       /* We must be running and not suspended so we will be out of running queue */
;;;1497       _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1498       RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_DELAYED);
;;;1499       _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1500   
;;;1501       RMP_Cur_Thd->Retval=0;
;;;1502       RMP_Unlock_Sched();
;;;1503       /* Need to return if successful or not */
;;;1504       return RMP_Cur_Thd->Retval;
;;;1505   }
000010  bd70              POP      {r4-r6,pc}
                  |L28.18|
000012  f7fffffe          BL       RMP_Lock_Sched
000016  4c0c              LDR      r4,|L28.72|
000018  69a0              LDR      r0,[r4,#0x18]         ;1497  ; RMP_Cur_Thd
00001a  f7fffffe          BL       _RMP_Clr_Rdy
00001e  69a0              LDR      r0,[r4,#0x18]         ;1498  ; RMP_Cur_Thd
000020  69a1              LDR      r1,[r4,#0x18]         ;1498  ; RMP_Cur_Thd
000022  6980              LDR      r0,[r0,#0x18]         ;1498
000024  f02000ff          BIC      r0,r0,#0xff           ;1498
000028  1d80              ADDS     r0,r0,#6              ;1498
00002a  6188              STR      r0,[r1,#0x18]         ;1499
00002c  69a0              LDR      r0,[r4,#0x18]         ;1499  ; RMP_Cur_Thd
00002e  4629              MOV      r1,r5                 ;1499
000030  f7fffffe          BL       _RMP_Dly_Ins
000034  69a1              LDR      r1,[r4,#0x18]         ;1501  ; RMP_Cur_Thd
000036  2000              MOVS     r0,#0                 ;1501
000038  6388              STR      r0,[r1,#0x38]         ;1502
00003a  f7fffffe          BL       RMP_Unlock_Sched
00003e  69a0              LDR      r0,[r4,#0x18]         ;1504  ; RMP_Cur_Thd
000040  6b80              LDR      r0,[r0,#0x38]         ;1504
000042  bd70              POP      {r4-r6,pc}
;;;1506   /* End Function:RMP_Thd_Delay ************************************************/
                          ENDP

                  |L28.68|
                          DCD      0x000186a0
                  |L28.72|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Rcv||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Rcv PROC
;;;1366   ******************************************************************************/
;;;1367   rmp_ret_t RMP_Thd_Rcv(rmp_ptr_t* Data, rmp_ptr_t Slices)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1368   {
000004  0006              MOVS     r6,r0
000006  460f              MOV      r7,r1
;;;1369       struct RMP_Thd* Sender;
;;;1370       
;;;1371       if(Data==0)
;;;1372       {
;;;1373           RMP_COVERAGE_MARKER();
;;;1374           return RMP_ERR_OPER;
000008  f06f0804          MVN      r8,#4
00000c  d015              BEQ      |L29.58|
;;;1375       }
;;;1376       else
;;;1377           RMP_COVERAGE_MARKER();
;;;1378       
;;;1379       RMP_Lock_Sched();
00000e  f7fffffe          BL       RMP_Lock_Sched
;;;1380       
;;;1381       /* Is there any other guy waiting on us? If there is, unblock it and set it running */
;;;1382       Sender=0;
;;;1383       if(&(RMP_Cur_Thd->Snd_List)!=RMP_Cur_Thd->Snd_List.Next)
000012  4d35              LDR      r5,|L29.232|
000014  2400              MOVS     r4,#0                 ;1382
000016  69a9              LDR      r1,[r5,#0x18]  ; RMP_Cur_Thd
000018  69a8              LDR      r0,[r5,#0x18]  ; RMP_Cur_Thd
00001a  3010              ADDS     r0,r0,#0x10
00001c  6949              LDR      r1,[r1,#0x14]
00001e  4281              CMP      r1,r0
000020  d01a              BEQ      |L29.88|
;;;1384       {
;;;1385           RMP_COVERAGE_MARKER();
;;;1386           /* Read the data */
;;;1387           Sender=(struct RMP_Thd*)(RMP_Cur_Thd->Snd_List.Next);
000022  69a8              LDR      r0,[r5,#0x18]  ; RMP_Cur_Thd
000024  6944              LDR      r4,[r0,#0x14]
000026  e9d40100          LDRD     r0,r1,[r4,#0]
00002a  6008              STR      r0,[r1,#0]
00002c  6041              STR      r1,[r0,#4]
;;;1388           RMP_List_Del(Sender->Run_Head.Prev,Sender->Run_Head.Next);
;;;1389           *Data=Sender->Data;
00002e  6b20              LDR      r0,[r4,#0x30]
;;;1390           /* Now we unblock it - what state is it in? */
;;;1391           if((RMP_THD_STATE(Sender->State)==RMP_THD_SNDDLY))
000030  6030              STR      r0,[r6,#0]
000032  7e20              LDRB     r0,[r4,#0x18]
000034  2803              CMP      r0,#3
000036  d003              BEQ      |L29.64|
000038  e006              B        |L29.72|
                  |L29.58|
00003a  4640              MOV      r0,r8                 ;1374
                  |L29.60|
;;;1392           {
;;;1393               RMP_COVERAGE_MARKER();
;;;1394               RMP_List_Del(Sender->Dly_Head.Prev,Sender->Dly_Head.Next);
;;;1395           }
;;;1396           else
;;;1397               RMP_COVERAGE_MARKER();
;;;1398           
;;;1399           RMP_THD_STATE_SET(Sender->State,RMP_THD_RUNNING);
;;;1400           /* Set to running if not suspended */
;;;1401           _RMP_Set_Rdy(Sender);
;;;1402       }
;;;1403   
;;;1404       /* Check if there is a value in our mailbox. If yes, we return with that value */
;;;1405       if((RMP_Cur_Thd->State&RMP_THD_MBOXFUL)!=0)
;;;1406       {
;;;1407           RMP_COVERAGE_MARKER();
;;;1408           /* Get the value from mailbox */
;;;1409           *Data=RMP_Cur_Thd->Mailbox;
;;;1410           /* See if we unblocked a sender. If yes, we place the new value into 
;;;1411            * our mailbox and it is still full */
;;;1412           if(Sender!=0)
;;;1413               RMP_Cur_Thd->Mailbox=Sender->Data;
;;;1414           else
;;;1415               RMP_Cur_Thd->State&=~RMP_THD_MBOXFUL;
;;;1416           
;;;1417           RMP_Unlock_Sched();
;;;1418           return 0;
;;;1419       }
;;;1420       else
;;;1421       {
;;;1422           RMP_COVERAGE_MARKER();
;;;1423           
;;;1424           /* Box empty. Do we have somebody waiting? */
;;;1425           if(Sender!=0)
;;;1426           {
;;;1427               RMP_COVERAGE_MARKER();
;;;1428               RMP_Cur_Thd->Mailbox=Sender->Data;
;;;1429               RMP_Unlock_Sched();
;;;1430               return 0;
;;;1431           }
;;;1432           /* No sender waiting on us and box empty, we need to block */
;;;1433           else
;;;1434           {
;;;1435               RMP_COVERAGE_MARKER();
;;;1436               
;;;1437               if(Slices==0)
;;;1438               {
;;;1439                   RMP_COVERAGE_MARKER();
;;;1440                   RMP_Unlock_Sched();
;;;1441                   return RMP_ERR_OPER;
;;;1442               }
;;;1443               else
;;;1444                   RMP_COVERAGE_MARKER();
;;;1445   
;;;1446               /* We must be running and not suspended so we will surely be deleted from queue */
;;;1447               _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1448   
;;;1449               if(Slices<RMP_MAX_SLICES)
;;;1450               {
;;;1451                   RMP_COVERAGE_MARKER();
;;;1452                   _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1453                   RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_RCVDLY);
;;;1454               }
;;;1455               else
;;;1456               {
;;;1457                   RMP_COVERAGE_MARKER();
;;;1458                   RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_RCVBLK);
;;;1459               }
;;;1460               RMP_Unlock_Sched();
;;;1461               
;;;1462               /* Dummy read - to separate the lock & unlock. If the compiler optimizes these two
;;;1463                * functions(inline them) on some architectures sometimes we never block. */
;;;1464               *Data=RMP_Cur_Thd->Mailbox;
;;;1465               
;;;1466               /* We've been unblocked. There must be something in our mbox, or we should have failed */
;;;1467               RMP_Lock_Sched();
;;;1468               *Data=RMP_Cur_Thd->Mailbox;
;;;1469               RMP_Cur_Thd->State&=~RMP_THD_MBOXFUL;
;;;1470           }
;;;1471       }
;;;1472       
;;;1473       RMP_Unlock_Sched();
;;;1474       return RMP_Cur_Thd->Retval;
;;;1475   }
00003c  e8bd81f0          POP      {r4-r8,pc}
                  |L29.64|
000040  e9d40102          LDRD     r0,r1,[r4,#8]
000044  6008              STR      r0,[r1,#0]
000046  6041              STR      r1,[r0,#4]
                  |L29.72|
000048  69a0              LDR      r0,[r4,#0x18]         ;1399
00004a  f02000ff          BIC      r0,r0,#0xff           ;1399
00004e  1c40              ADDS     r0,r0,#1              ;1399
000050  61a0              STR      r0,[r4,#0x18]         ;1401
000052  4620              MOV      r0,r4                 ;1401
000054  f7fffffe          BL       _RMP_Set_Rdy
                  |L29.88|
000058  69a8              LDR      r0,[r5,#0x18]         ;1405  ; RMP_Cur_Thd
00005a  8b00              LDRH     r0,[r0,#0x18]         ;1405
00005c  0580              LSLS     r0,r0,#22             ;1405
00005e  d50d              BPL      |L29.124|
000060  69a8              LDR      r0,[r5,#0x18]         ;1409  ; RMP_Cur_Thd
000062  6ac0              LDR      r0,[r0,#0x2c]         ;1409
000064  6030              STR      r0,[r6,#0]            ;1412
000066  b954              CBNZ     r4,|L29.126|
000068  69a8              LDR      r0,[r5,#0x18]         ;1415  ; RMP_Cur_Thd
00006a  6981              LDR      r1,[r0,#0x18]         ;1415
00006c  f4217100          BIC      r1,r1,#0x200          ;1415
000070  f8c01018          STR.W    r1,[r0,#0x18]         ;1415
                  |L29.116|
000074  f7fffffe          BL       RMP_Unlock_Sched
000078  2000              MOVS     r0,#0                 ;1418
00007a  e7df              B        |L29.60|
                  |L29.124|
00007c  b11c              CBZ      r4,|L29.134|
                  |L29.126|
00007e  69a8              LDR      r0,[r5,#0x18]         ;1428  ; RMP_Cur_Thd
000080  6b21              LDR      r1,[r4,#0x30]         ;1428
000082  62c1              STR      r1,[r0,#0x2c]         ;1430
000084  e7f6              B        |L29.116|
                  |L29.134|
000086  b187              CBZ      r7,|L29.170|
000088  69a8              LDR      r0,[r5,#0x18]         ;1447  ; RMP_Cur_Thd
00008a  f7fffffe          BL       _RMP_Clr_Rdy
00008e  4817              LDR      r0,|L29.236|
000090  4287              CMP      r7,r0                 ;1449
000092  d20d              BCS      |L29.176|
000094  69a8              LDR      r0,[r5,#0x18]         ;1452  ; RMP_Cur_Thd
000096  4639              MOV      r1,r7                 ;1452
000098  f7fffffe          BL       _RMP_Dly_Ins
00009c  69a8              LDR      r0,[r5,#0x18]         ;1453  ; RMP_Cur_Thd
00009e  69a9              LDR      r1,[r5,#0x18]         ;1453  ; RMP_Cur_Thd
0000a0  6980              LDR      r0,[r0,#0x18]         ;1453
0000a2  f02000ff          BIC      r0,r0,#0xff           ;1453
0000a6  1d40              ADDS     r0,r0,#5              ;1453
0000a8  e008              B        |L29.188|
                  |L29.170|
0000aa  f7fffffe          BL       RMP_Unlock_Sched
0000ae  e7c4              B        |L29.58|
                  |L29.176|
0000b0  69a8              LDR      r0,[r5,#0x18]         ;1458  ; RMP_Cur_Thd
0000b2  69a9              LDR      r1,[r5,#0x18]         ;1458  ; RMP_Cur_Thd
0000b4  6980              LDR      r0,[r0,#0x18]         ;1458
0000b6  f02000ff          BIC      r0,r0,#0xff           ;1458
0000ba  1d00              ADDS     r0,r0,#4              ;1458
                  |L29.188|
0000bc  6188              STR      r0,[r1,#0x18]         ;1460
0000be  f7fffffe          BL       RMP_Unlock_Sched
0000c2  69a8              LDR      r0,[r5,#0x18]         ;1464  ; RMP_Cur_Thd
0000c4  6ac0              LDR      r0,[r0,#0x2c]         ;1464
0000c6  6030              STR      r0,[r6,#0]            ;1467
0000c8  f7fffffe          BL       RMP_Lock_Sched
0000cc  69a8              LDR      r0,[r5,#0x18]         ;1468  ; RMP_Cur_Thd
0000ce  6ac0              LDR      r0,[r0,#0x2c]         ;1468
0000d0  6030              STR      r0,[r6,#0]            ;1469
0000d2  69a8              LDR      r0,[r5,#0x18]         ;1469  ; RMP_Cur_Thd
0000d4  6981              LDR      r1,[r0,#0x18]         ;1469
0000d6  f4217100          BIC      r1,r1,#0x200          ;1469
0000da  6181              STR      r1,[r0,#0x18]         ;1473
0000dc  f7fffffe          BL       RMP_Unlock_Sched
0000e0  69a8              LDR      r0,[r5,#0x18]         ;1474  ; RMP_Cur_Thd
0000e2  6b80              LDR      r0,[r0,#0x38]         ;1474
0000e4  e7aa              B        |L29.60|
;;;1476   /* End Function:RMP_Thd_Rcv **************************************************/
                          ENDP

0000e6  0000              DCW      0x0000
                  |L29.232|
                          DCD      ||.data||
                  |L29.236|
                          DCD      0x000186a0

                          AREA ||i.RMP_Thd_Resume||, CODE, READONLY, ALIGN=1

                  RMP_Thd_Resume PROC
;;;1110   ******************************************************************************/
;;;1111   rmp_ret_t RMP_Thd_Resume(volatile struct RMP_Thd* Thread)
000000  b570              PUSH     {r4-r6,lr}
;;;1112   {
000002  0004              MOVS     r4,r0
;;;1113       rmp_ret_t Retval;
;;;1114       
;;;1115       /* Check if this thread structure could possibly be in use */
;;;1116       if(Thread==0)
;;;1117       {
;;;1118           RMP_COVERAGE_MARKER();
;;;1119           return RMP_ERR_THD;
000004  f04f35ff          MOV      r5,#0xffffffff
000008  d011              BEQ      |L30.46|
;;;1120       }
;;;1121       else
;;;1122           RMP_COVERAGE_MARKER();
;;;1123   
;;;1124       RMP_Lock_Sched();
00000a  f7fffffe          BL       RMP_Lock_Sched
;;;1125       
;;;1126       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
00000e  69a0              LDR      r0,[r4,#0x18]
000010  f0100fff          TST      r0,#0xff
000014  d00d              BEQ      |L30.50|
;;;1127       {
;;;1128           RMP_COVERAGE_MARKER();
;;;1129           RMP_Unlock_Sched();
;;;1130           return RMP_ERR_THD;
;;;1131       }
;;;1132       else
;;;1133           RMP_COVERAGE_MARKER();
;;;1134       
;;;1135       /* Check if the thread is suspended, if not, then throw an error */
;;;1136       if((Thread->State&RMP_THD_SUSPENDED)!=0)
000016  69a0              LDR      r0,[r4,#0x18]
000018  05c0              LSLS     r0,r0,#23
00001a  d512              BPL      |L30.66|
;;;1137       {
;;;1138           RMP_COVERAGE_MARKER();
;;;1139           
;;;1140           /* Suspended */
;;;1141           Thread->State&=~RMP_THD_SUSPENDED;
00001c  69a0              LDR      r0,[r4,#0x18]
00001e  f4207080          BIC      r0,r0,#0x100
000022  61a0              STR      r0,[r4,#0x18]
;;;1142           /* Only when it is running will we put it back. It can't be suspended here, 
;;;1143            * so the set ready operation will surely put it back */
;;;1144           if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
000024  69a0              LDR      r0,[r4,#0x18]
000026  b2c0              UXTB     r0,r0
000028  2801              CMP      r0,#1
00002a  d005              BEQ      |L30.56|
00002c  e007              B        |L30.62|
                  |L30.46|
00002e  4628              MOV      r0,r5                 ;1119
;;;1145           {
;;;1146               RMP_COVERAGE_MARKER();
;;;1147               _RMP_Set_Rdy(Thread);
;;;1148           }
;;;1149           else
;;;1150               RMP_COVERAGE_MARKER();
;;;1151           
;;;1152           Retval=0;
;;;1153       }
;;;1154       else
;;;1155       {
;;;1156           RMP_COVERAGE_MARKER();
;;;1157           Retval=RMP_ERR_STATE;
;;;1158       }
;;;1159       
;;;1160       RMP_Unlock_Sched();
;;;1161   
;;;1162       return Retval;
;;;1163   }
000030  bd70              POP      {r4-r6,pc}
                  |L30.50|
000032  f7fffffe          BL       RMP_Unlock_Sched
000036  e7fa              B        |L30.46|
                  |L30.56|
000038  4620              MOV      r0,r4                 ;1147
00003a  f7fffffe          BL       _RMP_Set_Rdy
                  |L30.62|
00003e  2400              MOVS     r4,#0                 ;1152
000040  e001              B        |L30.70|
                  |L30.66|
000042  f06f0403          MVN      r4,#3                 ;1157
                  |L30.70|
000046  f7fffffe          BL       RMP_Unlock_Sched
00004a  4620              MOV      r0,r4                 ;1162
00004c  bd70              POP      {r4-r6,pc}
;;;1164   /* End Function:RMP_Thd_Resume ***********************************************/
                          ENDP


                          AREA ||i.RMP_Thd_Set||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Set PROC
;;;950    ******************************************************************************/
;;;951    rmp_ret_t RMP_Thd_Set(volatile struct RMP_Thd* Thread, rmp_ptr_t Prio, rmp_ptr_t Slices)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;952    {
000004  0015              MOVS     r5,r2
000006  460e              MOV      r6,r1
000008  4604              MOV      r4,r0
00000a  d018              BEQ      |L31.62|
;;;953        /* Check if the priority and timeslice range is correct */
;;;954        if(Slices==0)
;;;955        {
;;;956            RMP_COVERAGE_MARKER();
;;;957            return RMP_ERR_SLICE;
;;;958        }
;;;959        else
;;;960            RMP_COVERAGE_MARKER();
;;;961        
;;;962        /* Check if this thread structure could possibly be in use */
;;;963        if(Thread==0)
;;;964        {
;;;965            RMP_COVERAGE_MARKER();
;;;966            return RMP_ERR_THD;
00000c  f04f37ff          MOV      r7,#0xffffffff
000010  b1c4              CBZ      r4,|L31.68|
;;;967        }
;;;968        else
;;;969            RMP_COVERAGE_MARKER();
;;;970        
;;;971        RMP_Lock_Sched();
000012  f7fffffe          BL       RMP_Lock_Sched
;;;972        
;;;973        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
000016  69a0              LDR      r0,[r4,#0x18]
000018  f0100fff          TST      r0,#0xff
00001c  d014              BEQ      |L31.72|
;;;974        {
;;;975            RMP_COVERAGE_MARKER();
;;;976            RMP_Unlock_Sched();
;;;977            return RMP_ERR_THD;
;;;978        }
;;;979        else
;;;980            RMP_COVERAGE_MARKER();
;;;981        
;;;982        /* See if the thread is in running state */
;;;983        if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
00001e  69a0              LDR      r0,[r4,#0x18]
;;;984        {
;;;985            RMP_COVERAGE_MARKER();
;;;986            
;;;987            /* See if we are gonna change one of it or both */
;;;988            if(Prio<RMP_MAX_PREEMPT_PRIO)
;;;989            {
;;;990                RMP_COVERAGE_MARKER();
;;;991                if(Thread->Prio!=Prio)
;;;992                {
;;;993                    RMP_COVERAGE_MARKER();
;;;994                    /* It doesn't matter whether this is suspended or not. 
;;;995                     * If suspended, the operations will not be conducted. */
;;;996                    _RMP_Clr_Rdy(Thread);
;;;997                    Thread->Prio=Prio;
;;;998                    _RMP_Set_Rdy(Thread);
;;;999                }
;;;1000               else
;;;1001                   RMP_COVERAGE_MARKER();
;;;1002           }
;;;1003           else
;;;1004               RMP_COVERAGE_MARKER();
;;;1005           
;;;1006           if(Slices<RMP_MAX_SLICES)
000020  4f11              LDR      r7,|L31.104|
000022  b2c0              UXTB     r0,r0                 ;983
000024  2801              CMP      r0,#1                 ;983
000026  d012              BEQ      |L31.78|
;;;1007           {
;;;1008               RMP_COVERAGE_MARKER();
;;;1009               Thread->Slices=Slices;
;;;1010           }
;;;1011           else
;;;1012               RMP_COVERAGE_MARKER();
;;;1013       }
;;;1014       else
;;;1015       {
;;;1016           RMP_COVERAGE_MARKER();
;;;1017           
;;;1018           if(Prio<RMP_MAX_PREEMPT_PRIO)
000028  2e20              CMP      r6,#0x20
00002a  d200              BCS      |L31.46|
;;;1019           {
;;;1020               RMP_COVERAGE_MARKER();
;;;1021               Thread->Prio=Prio;
00002c  6266              STR      r6,[r4,#0x24]
                  |L31.46|
;;;1022           }
;;;1023           else
;;;1024               RMP_COVERAGE_MARKER();
;;;1025           
;;;1026           if(Slices<RMP_MAX_SLICES)
00002e  42bd              CMP      r5,r7
000030  d200              BCS      |L31.52|
;;;1027           {
;;;1028               RMP_COVERAGE_MARKER();
;;;1029               Thread->Slices=Slices;
000032  61e5              STR      r5,[r4,#0x1c]
                  |L31.52|
;;;1030           }
;;;1031           else
;;;1032               RMP_COVERAGE_MARKER();
;;;1033       }
;;;1034       
;;;1035       RMP_Unlock_Sched();
000034  f7fffffe          BL       RMP_Unlock_Sched
;;;1036       return 0;
000038  2000              MOVS     r0,#0
                  |L31.58|
;;;1037   }
00003a  e8bd81f0          POP      {r4-r8,pc}
                  |L31.62|
00003e  f06f0002          MVN      r0,#2                 ;957
000042  e7fa              B        |L31.58|
                  |L31.68|
000044  4638              MOV      r0,r7                 ;966
000046  e7f8              B        |L31.58|
                  |L31.72|
000048  f7fffffe          BL       RMP_Unlock_Sched
00004c  e7fa              B        |L31.68|
                  |L31.78|
00004e  2e20              CMP      r6,#0x20              ;988
000050  d2ed              BCS      |L31.46|
000052  6a60              LDR      r0,[r4,#0x24]         ;991
000054  42b0              CMP      r0,r6                 ;991
000056  d0ea              BEQ      |L31.46|
000058  4620              MOV      r0,r4                 ;996
00005a  f7fffffe          BL       _RMP_Clr_Rdy
00005e  6266              STR      r6,[r4,#0x24]         ;997
000060  4620              MOV      r0,r4                 ;998
000062  f7fffffe          BL       _RMP_Set_Rdy
000066  e7e2              B        |L31.46|
;;;1038   /* End Function:RMP_Thd_Set **************************************************/
                          ENDP

                  |L31.104|
                          DCD      0x000186a0

                          AREA ||i.RMP_Thd_Snd||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Snd PROC
;;;1174   ******************************************************************************/
;;;1175   rmp_ret_t RMP_Thd_Snd(volatile struct RMP_Thd* Thread, rmp_ptr_t Data, rmp_ptr_t Slices)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1176   {
000004  0004              MOVS     r4,r0
000006  4616              MOV      r6,r2
000008  460f              MOV      r7,r1
;;;1177       /* Check if this thread structure could possibly be in use */
;;;1178       if(Thread==0)
;;;1179       {
;;;1180           RMP_COVERAGE_MARKER();
;;;1181           return RMP_ERR_THD;
00000a  f04f35ff          MOV      r5,#0xffffffff
00000e  d029              BEQ      |L32.100|
;;;1182       }
;;;1183       else
;;;1184           RMP_COVERAGE_MARKER();
;;;1185       
;;;1186       RMP_Lock_Sched();
000010  f7fffffe          BL       RMP_Lock_Sched
;;;1187       
;;;1188       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
000014  69a0              LDR      r0,[r4,#0x18]
000016  f0100fff          TST      r0,#0xff
00001a  d026              BEQ      |L32.106|
;;;1189       {
;;;1190           RMP_COVERAGE_MARKER();
;;;1191           RMP_Unlock_Sched();
;;;1192           return RMP_ERR_THD;
;;;1193       }
;;;1194       else
;;;1195           RMP_COVERAGE_MARKER();
;;;1196       
;;;1197       /* Are we sending to ourself? This is not allowed */
;;;1198       if(RMP_Cur_Thd==Thread)
00001c  4d2c              LDR      r5,|L32.208|
;;;1199       {
;;;1200           RMP_COVERAGE_MARKER();
;;;1201           RMP_Unlock_Sched();
;;;1202           return RMP_ERR_OPER;
00001e  f06f0804          MVN      r8,#4
000022  69a8              LDR      r0,[r5,#0x18]         ;1198  ; RMP_Cur_Thd
000024  42a0              CMP      r0,r4                 ;1198
000026  d023              BEQ      |L32.112|
;;;1203       }
;;;1204       else
;;;1205           RMP_COVERAGE_MARKER();
;;;1206       
;;;1207       RMP_Cur_Thd->Retval=0;
000028  69a9              LDR      r1,[r5,#0x18]  ; RMP_Cur_Thd
00002a  2000              MOVS     r0,#0
;;;1208   
;;;1209       /* See if there is already a value in the mailbox, if yes, we block */
;;;1210       if((Thread->State&RMP_THD_MBOXFUL)!=0)
00002c  6388              STR      r0,[r1,#0x38]
00002e  69a0              LDR      r0,[r4,#0x18]
000030  0580              LSLS     r0,r0,#22
000032  d52b              BPL      |L32.140|
;;;1211       {
;;;1212           RMP_COVERAGE_MARKER();
;;;1213           
;;;1214           /* Mailbox full, we block, and put ourself into the queue */
;;;1215           if(Slices==0)
000034  b1e6              CBZ      r6,|L32.112|
;;;1216           {
;;;1217               RMP_COVERAGE_MARKER();
;;;1218               RMP_Unlock_Sched();
;;;1219               return RMP_ERR_OPER;
;;;1220           }
;;;1221           else
;;;1222               RMP_COVERAGE_MARKER();
;;;1223   
;;;1224           /* We must be running */
;;;1225           _RMP_Clr_Rdy(RMP_Cur_Thd);
000036  69a8              LDR      r0,[r5,#0x18]  ; RMP_Cur_Thd
000038  f7fffffe          BL       _RMP_Clr_Rdy
;;;1226           RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),Thread->Snd_List.Prev,&(Thread->Snd_List));
00003c  6921              LDR      r1,[r4,#0x10]
00003e  f1040210          ADD      r2,r4,#0x10
000042  69a8              LDR      r0,[r5,#0x18]  ; RMP_Cur_Thd
000044  f7fffffe          BL       RMP_List_Ins
;;;1227   
;;;1228           if(Slices<RMP_MAX_SLICES)
000048  4822              LDR      r0,|L32.212|
00004a  4286              CMP      r6,r0
00004c  d214              BCS      |L32.120|
;;;1229           {
;;;1230               RMP_COVERAGE_MARKER();
;;;1231               _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
00004e  69a8              LDR      r0,[r5,#0x18]  ; RMP_Cur_Thd
000050  4631              MOV      r1,r6
000052  f7fffffe          BL       _RMP_Dly_Ins
;;;1232               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SNDDLY);
000056  69a8              LDR      r0,[r5,#0x18]  ; RMP_Cur_Thd
000058  69a9              LDR      r1,[r5,#0x18]  ; RMP_Cur_Thd
00005a  6980              LDR      r0,[r0,#0x18]
00005c  f02000ff          BIC      r0,r0,#0xff
000060  1cc0              ADDS     r0,r0,#3
000062  e00f              B        |L32.132|
                  |L32.100|
000064  4628              MOV      r0,r5                 ;1181
                  |L32.102|
;;;1233           }
;;;1234           else
;;;1235           {
;;;1236               RMP_COVERAGE_MARKER();
;;;1237               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SNDBLK);
;;;1238           }
;;;1239   
;;;1240           RMP_Cur_Thd->Data=Data;
;;;1241       }
;;;1242       else
;;;1243       {
;;;1244           RMP_COVERAGE_MARKER();
;;;1245           
;;;1246           /* Mailbox not full. We need to check if the receiver is waiting for us */
;;;1247           if((RMP_THD_STATE(Thread->State)==RMP_THD_RCVBLK)||
;;;1248              (RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY))
;;;1249           {
;;;1250               RMP_COVERAGE_MARKER();
;;;1251               
;;;1252               /* The receiver is blocked, wake it up and return the value */
;;;1253               if(RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY)
;;;1254               {
;;;1255                   RMP_COVERAGE_MARKER();
;;;1256                   RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1257               }
;;;1258               else
;;;1259                   RMP_COVERAGE_MARKER();
;;;1260               
;;;1261               RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1262               /* Set to running if not suspended */
;;;1263               _RMP_Set_Rdy(Thread);
;;;1264           }
;;;1265           else
;;;1266               RMP_COVERAGE_MARKER();
;;;1267           
;;;1268           /* Set the mailbox */
;;;1269           Thread->Mailbox=Data;
;;;1270           Thread->State|=RMP_THD_MBOXFUL;
;;;1271       }
;;;1272       
;;;1273       RMP_Unlock_Sched();
;;;1274   
;;;1275       return RMP_Cur_Thd->Retval;
;;;1276   }
000066  e8bd81f0          POP      {r4-r8,pc}
                  |L32.106|
00006a  f7fffffe          BL       RMP_Unlock_Sched
00006e  e7f9              B        |L32.100|
                  |L32.112|
000070  f7fffffe          BL       RMP_Unlock_Sched
000074  4640              MOV      r0,r8                 ;1219
000076  e7f6              B        |L32.102|
                  |L32.120|
000078  69a8              LDR      r0,[r5,#0x18]         ;1237  ; RMP_Cur_Thd
00007a  69a9              LDR      r1,[r5,#0x18]         ;1237  ; RMP_Cur_Thd
00007c  6980              LDR      r0,[r0,#0x18]         ;1237
00007e  f02000ff          BIC      r0,r0,#0xff           ;1237
000082  1c80              ADDS     r0,r0,#2              ;1237
                  |L32.132|
000084  6188              STR      r0,[r1,#0x18]         ;1240
000086  69a8              LDR      r0,[r5,#0x18]         ;1240  ; RMP_Cur_Thd
000088  6307              STR      r7,[r0,#0x30]         ;1240
00008a  e01c              B        |L32.198|
                  |L32.140|
00008c  69a0              LDR      r0,[r4,#0x18]         ;1247
00008e  b2c0              UXTB     r0,r0                 ;1247
000090  2804              CMP      r0,#4                 ;1247
000092  d003              BEQ      |L32.156|
000094  69a0              LDR      r0,[r4,#0x18]         ;1248
000096  b2c0              UXTB     r0,r0                 ;1248
000098  2805              CMP      r0,#5                 ;1248
00009a  d10f              BNE      |L32.188|
                  |L32.156|
00009c  69a0              LDR      r0,[r4,#0x18]         ;1253
00009e  b2c0              UXTB     r0,r0                 ;1253
0000a0  2805              CMP      r0,#5                 ;1253
0000a2  d103              BNE      |L32.172|
0000a4  68a0              LDR      r0,[r4,#8]            ;1256
0000a6  68e1              LDR      r1,[r4,#0xc]          ;1256
0000a8  6008              STR      r0,[r1,#0]            ;1256
0000aa  6041              STR      r1,[r0,#4]            ;1256
                  |L32.172|
0000ac  69a0              LDR      r0,[r4,#0x18]         ;1261
0000ae  f02000ff          BIC      r0,r0,#0xff           ;1261
0000b2  1c40              ADDS     r0,r0,#1              ;1261
0000b4  61a0              STR      r0,[r4,#0x18]         ;1261
0000b6  4620              MOV      r0,r4                 ;1263
0000b8  f7fffffe          BL       _RMP_Set_Rdy
                  |L32.188|
0000bc  62e7              STR      r7,[r4,#0x2c]         ;1269
0000be  69a0              LDR      r0,[r4,#0x18]         ;1270
0000c0  f4407000          ORR      r0,r0,#0x200          ;1270
0000c4  61a0              STR      r0,[r4,#0x18]         ;1270
                  |L32.198|
0000c6  f7fffffe          BL       RMP_Unlock_Sched
0000ca  69a8              LDR      r0,[r5,#0x18]         ;1275  ; RMP_Cur_Thd
0000cc  6b80              LDR      r0,[r0,#0x38]         ;1275
0000ce  e7ca              B        |L32.102|
;;;1277   /* End Function:RMP_Thd_Snd **************************************************/
                          ENDP

                  |L32.208|
                          DCD      ||.data||
                  |L32.212|
                          DCD      0x000186a0

                          AREA ||i.RMP_Thd_Snd_ISR||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Snd_ISR PROC
;;;1289   ******************************************************************************/
;;;1290   rmp_ret_t RMP_Thd_Snd_ISR(volatile struct RMP_Thd* Thread, rmp_ptr_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;1291   {
000002  0004              MOVS     r4,r0
000004  460d              MOV      r5,r1
;;;1292       /* Check if this thread structure could possibly be in use */
;;;1293       if(Thread==0)
;;;1294       {
;;;1295           RMP_COVERAGE_MARKER();
;;;1296           return RMP_ERR_THD;
000006  f04f30ff          MOV      r0,#0xffffffff
00000a  d008              BEQ      |L33.30|
;;;1297       }
;;;1298       else
;;;1299           RMP_COVERAGE_MARKER();
;;;1300       
;;;1301       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
00000c  69a1              LDR      r1,[r4,#0x18]
00000e  f0110fff          TST      r1,#0xff
000012  d004              BEQ      |L33.30|
;;;1302       {
;;;1303           RMP_COVERAGE_MARKER();
;;;1304           return RMP_ERR_THD;
;;;1305       }
;;;1306       else
;;;1307           RMP_COVERAGE_MARKER();
;;;1308   
;;;1309       /* See if there is already a value in the mailbox, if yes, we abort */
;;;1310       if((Thread->State&RMP_THD_MBOXFUL)!=0)
000014  69a0              LDR      r0,[r4,#0x18]
000016  0580              LSLS     r0,r0,#22
000018  d502              BPL      |L33.32|
;;;1311       {
;;;1312           RMP_COVERAGE_MARKER();
;;;1313           return RMP_ERR_OPER;
00001a  f06f0004          MVN      r0,#4
                  |L33.30|
;;;1314       }
;;;1315       else
;;;1316       {
;;;1317           RMP_COVERAGE_MARKER();
;;;1318           
;;;1319           /* Mailbox not full. We need to check if the receiver is waiting for us */
;;;1320           if((RMP_THD_STATE(Thread->State)==RMP_THD_RCVBLK)||
;;;1321              (RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY))
;;;1322           {
;;;1323               RMP_COVERAGE_MARKER();
;;;1324   
;;;1325               /* The receiver is blocked, wake it up and return the value */
;;;1326               if(RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY)
;;;1327               {
;;;1328                   RMP_COVERAGE_MARKER();
;;;1329                   RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1330               }
;;;1331               else
;;;1332                   RMP_COVERAGE_MARKER();
;;;1333               
;;;1334               RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1335   
;;;1336               /* Set to running if not suspended */
;;;1337               _RMP_Set_Rdy(Thread);
;;;1338   
;;;1339               /* If schedule pending, trigger it now because we are in ISR */
;;;1340               if(RMP_Sched_Pend!=0)
;;;1341               {
;;;1342                   RMP_COVERAGE_MARKER();
;;;1343                   RMP_Sched_Pend=0;
;;;1344                   _RMP_Yield();
;;;1345               }
;;;1346               else
;;;1347                   RMP_COVERAGE_MARKER();
;;;1348           }
;;;1349           else
;;;1350               RMP_COVERAGE_MARKER();
;;;1351           
;;;1352           /* Set the mailbox */
;;;1353           Thread->Mailbox=Data;
;;;1354           Thread->State|=RMP_THD_MBOXFUL;
;;;1355       }
;;;1356   
;;;1357       return 0;
;;;1358   }
00001e  bd70              POP      {r4-r6,pc}
                  |L33.32|
000020  69a0              LDR      r0,[r4,#0x18]         ;1320
000022  b2c0              UXTB     r0,r0                 ;1320
000024  2804              CMP      r0,#4                 ;1320
000026  d003              BEQ      |L33.48|
000028  69a0              LDR      r0,[r4,#0x18]         ;1321
00002a  b2c0              UXTB     r0,r0                 ;1321
00002c  2805              CMP      r0,#5                 ;1321
00002e  d116              BNE      |L33.94|
                  |L33.48|
000030  69a0              LDR      r0,[r4,#0x18]         ;1326
000032  b2c0              UXTB     r0,r0                 ;1326
000034  2805              CMP      r0,#5                 ;1326
000036  d103              BNE      |L33.64|
000038  68a2              LDR      r2,[r4,#8]            ;1329
00003a  68e0              LDR      r0,[r4,#0xc]          ;1329
00003c  6002              STR      r2,[r0,#0]            ;1329
00003e  6050              STR      r0,[r2,#4]            ;1329
                  |L33.64|
000040  69a0              LDR      r0,[r4,#0x18]         ;1334
000042  f02000ff          BIC      r0,r0,#0xff           ;1334
000046  1c40              ADDS     r0,r0,#1              ;1334
000048  61a0              STR      r0,[r4,#0x18]         ;1334
00004a  4620              MOV      r0,r4                 ;1337
00004c  f7fffffe          BL       _RMP_Set_Rdy
000050  4806              LDR      r0,|L33.108|
000052  68c1              LDR      r1,[r0,#0xc]          ;1340  ; RMP_Sched_Pend
000054  b119              CBZ      r1,|L33.94|
000056  2100              MOVS     r1,#0                 ;1343
000058  60c1              STR      r1,[r0,#0xc]          ;1343  ; RMP_Sched_Pend
00005a  f7fffffe          BL       _RMP_Yield
                  |L33.94|
00005e  62e5              STR      r5,[r4,#0x2c]         ;1353
000060  69a0              LDR      r0,[r4,#0x18]         ;1354
000062  f4407000          ORR      r0,r0,#0x200          ;1354
000066  61a0              STR      r0,[r4,#0x18]         ;1354
000068  2000              MOVS     r0,#0                 ;1357
00006a  bd70              POP      {r4-r6,pc}
;;;1359   /* End Function:RMP_Thd_Snd_ISR **********************************************/
                          ENDP

                  |L33.108|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Suspend||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Suspend PROC
;;;1045   ******************************************************************************/
;;;1046   rmp_ret_t RMP_Thd_Suspend(volatile struct RMP_Thd* Thread)
000000  b570              PUSH     {r4-r6,lr}
;;;1047   {
000002  0004              MOVS     r4,r0
;;;1048       /* Check if this thread structure could possibly be in use */
;;;1049       if(Thread==0)
;;;1050       {
;;;1051           RMP_COVERAGE_MARKER();
;;;1052           return RMP_ERR_THD;
000004  f04f35ff          MOV      r5,#0xffffffff
000008  d00c              BEQ      |L34.36|
;;;1053       }
;;;1054       else
;;;1055           RMP_COVERAGE_MARKER();
;;;1056       
;;;1057       RMP_Lock_Sched();
00000a  f7fffffe          BL       RMP_Lock_Sched
;;;1058       
;;;1059       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
00000e  69a0              LDR      r0,[r4,#0x18]
000010  f0100fff          TST      r0,#0xff
000014  d008              BEQ      |L34.40|
;;;1060       {
;;;1061           RMP_COVERAGE_MARKER();
;;;1062           RMP_Unlock_Sched();
;;;1063           return RMP_ERR_THD;
;;;1064       }
;;;1065       else
;;;1066           RMP_COVERAGE_MARKER();
;;;1067       
;;;1068       /* Suspend it */
;;;1069       if((Thread->State&RMP_THD_SUSPENDED)!=0)
000016  69a0              LDR      r0,[r4,#0x18]
000018  05c0              LSLS     r0,r0,#23
00001a  d508              BPL      |L34.46|
;;;1070       {
;;;1071           RMP_COVERAGE_MARKER();
;;;1072           RMP_Unlock_Sched();
00001c  f7fffffe          BL       RMP_Unlock_Sched
;;;1073           return RMP_ERR_STATE;
000020  00a8              LSLS     r0,r5,#2
;;;1074       }
;;;1075       else
;;;1076           RMP_COVERAGE_MARKER();
;;;1077       
;;;1078       /* Only when it is running do we clear this. If we are clearing this, it is not
;;;1079        * suspended, so the running queue removal is guaranteed to succceed */
;;;1080       if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
;;;1081       {
;;;1082           RMP_COVERAGE_MARKER();
;;;1083           _RMP_Clr_Rdy(Thread);
;;;1084       }
;;;1085       else
;;;1086           RMP_COVERAGE_MARKER();
;;;1087       
;;;1088       /* Mark this as suspended */
;;;1089       Thread->State|=RMP_THD_SUSPENDED;
;;;1090       
;;;1091       /* If we are suspending ourself, pend a yield */
;;;1092       if(Thread==RMP_Cur_Thd)
;;;1093       {
;;;1094           RMP_COVERAGE_MARKER();
;;;1095           RMP_Sched_Pend=1;
;;;1096       }
;;;1097       else
;;;1098           RMP_COVERAGE_MARKER();
;;;1099       
;;;1100       RMP_Unlock_Sched();
;;;1101       return 0;
;;;1102   }
000022  bd70              POP      {r4-r6,pc}
                  |L34.36|
000024  4628              MOV      r0,r5                 ;1052
000026  bd70              POP      {r4-r6,pc}
                  |L34.40|
000028  f7fffffe          BL       RMP_Unlock_Sched
00002c  e7fa              B        |L34.36|
                  |L34.46|
00002e  69a0              LDR      r0,[r4,#0x18]         ;1080
000030  b2c0              UXTB     r0,r0                 ;1080
000032  2801              CMP      r0,#1                 ;1080
000034  d102              BNE      |L34.60|
000036  4620              MOV      r0,r4                 ;1083
000038  f7fffffe          BL       _RMP_Clr_Rdy
                  |L34.60|
00003c  69a1              LDR      r1,[r4,#0x18]         ;1089
00003e  4806              LDR      r0,|L34.88|
000040  f4417180          ORR      r1,r1,#0x100          ;1089
000044  61a1              STR      r1,[r4,#0x18]         ;1089
000046  6981              LDR      r1,[r0,#0x18]         ;1092  ; RMP_Cur_Thd
000048  428c              CMP      r4,r1                 ;1092
00004a  d101              BNE      |L34.80|
00004c  2101              MOVS     r1,#1                 ;1095
00004e  60c1              STR      r1,[r0,#0xc]          ;1095  ; RMP_Sched_Pend
                  |L34.80|
000050  f7fffffe          BL       RMP_Unlock_Sched
000054  2000              MOVS     r0,#0                 ;1101
000056  bd70              POP      {r4-r6,pc}
;;;1103   /* End Function:RMP_Thd_Suspend **********************************************/
                          ENDP

                  |L34.88|
                          DCD      ||.data||

                          AREA ||i.RMP_Unlock_Sched||, CODE, READONLY, ALIGN=2

                  RMP_Unlock_Sched PROC
;;;374    ******************************************************************************/
;;;375    void RMP_Unlock_Sched(void)
000000  490c              LDR      r1,|L35.52|
;;;376    {
000002  b510              PUSH     {r4,lr}
;;;377        if(RMP_Sched_Lock_Cnt==1)
000004  6848              LDR      r0,[r1,#4]  ; RMP_Sched_Lock_Cnt
000006  2801              CMP      r0,#1
000008  d006              BEQ      |L35.24|
;;;378        {
;;;379            RMP_COVERAGE_MARKER();
;;;380            /* Clear the count before enabling */
;;;381            RMP_Sched_Lock_Cnt=0;
;;;382            RMP_Sched_Locked=0;
;;;383            /* Now see if the scheduler scheduling action is pended in the lock-unlock 
;;;384             * period. If yes, perform a schedule now */
;;;385            if(RMP_Sched_Pend!=0)
;;;386            {
;;;387                RMP_COVERAGE_MARKER();
;;;388                /* Reset the count and trigger the context switch */
;;;389                RMP_Sched_Pend=0;
;;;390                _RMP_Yield();
;;;391            }
;;;392            else
;;;393                RMP_COVERAGE_MARKER();
;;;394            
;;;395            RMP_UNMASK_INT();
;;;396        }
;;;397        else if(RMP_Sched_Lock_Cnt>1)
00000a  6848              LDR      r0,[r1,#4]  ; RMP_Sched_Lock_Cnt
00000c  2801              CMP      r0,#1
00000e  d910              BLS      |L35.50|
;;;398        {
;;;399            RMP_COVERAGE_MARKER();
;;;400            RMP_Sched_Lock_Cnt--;
000010  6848              LDR      r0,[r1,#4]  ; RMP_Sched_Lock_Cnt
000012  1e40              SUBS     r0,r0,#1
000014  6048              STR      r0,[r1,#4]  ; RMP_Sched_Lock_Cnt
;;;401        }
;;;402        /* Trying to unlock a scheduler that is not locked - should never happen */
;;;403        else
;;;404            while(1);
;;;405    }
000016  bd10              POP      {r4,pc}
                  |L35.24|
000018  2000              MOVS     r0,#0                 ;381
00001a  6048              STR      r0,[r1,#4]            ;381  ; RMP_Sched_Lock_Cnt
00001c  6088              STR      r0,[r1,#8]            ;382  ; RMP_Sched_Locked
00001e  68ca              LDR      r2,[r1,#0xc]          ;385  ; RMP_Sched_Pend
000020  b112              CBZ      r2,|L35.40|
000022  60c8              STR      r0,[r1,#0xc]          ;389  ; RMP_Sched_Pend
000024  f7fffffe          BL       _RMP_Yield
                  |L35.40|
000028  e8bd4010          POP      {r4,lr}               ;395
00002c  2000              MOVS     r0,#0                 ;395
00002e  f7ffbffe          B.W      RMP_Mask_Int
                  |L35.50|
000032  e7fe              B        |L35.50|
;;;406    /* End Function:RMP_Unlock_Sched *********************************************/
                          ENDP

                  |L35.52|
                          DCD      ||.data||

                          AREA ||i.RMP_Yield||, CODE, READONLY, ALIGN=2

                  RMP_Yield PROC
;;;413    ******************************************************************************/
;;;414    void RMP_Yield(void)
000000  4803              LDR      r0,|L36.16|
;;;415    {
;;;416        if(RMP_Sched_Locked==0)
000002  6881              LDR      r1,[r0,#8]  ; RMP_Sched_Locked
000004  b111              CBZ      r1,|L36.12|
;;;417        {
;;;418            RMP_COVERAGE_MARKER();
;;;419            /* Now see if the scheduler scheduling action is pended in the lock-unlock 
;;;420             * period. If yes, perform a schedule now */
;;;421            _RMP_Yield();
;;;422        }
;;;423        else
;;;424        {
;;;425            RMP_COVERAGE_MARKER();
;;;426            RMP_Sched_Pend=1;
000006  2101              MOVS     r1,#1
000008  60c1              STR      r1,[r0,#0xc]  ; RMP_Sched_Pend
;;;427        }
;;;428    }
00000a  4770              BX       lr
                  |L36.12|
00000c  f7ffbffe          B.W      _RMP_Yield
;;;429    /* End Function:RMP_Yield ****************************************************/
                          ENDP

                  |L36.16|
                          DCD      ||.data||

                          AREA ||i._RMP_Clr_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Clr_Rdy PROC
;;;685    ******************************************************************************/
;;;686    void _RMP_Clr_Rdy(volatile struct RMP_Thd* Thread)
000000  b510              PUSH     {r4,lr}
;;;687    {
;;;688        /* Is it suspended? If yes, no need to delete again */
;;;689        if((Thread->State&RMP_THD_SUSPENDED)==0)
000002  6981              LDR      r1,[r0,#0x18]
000004  05c9              LSLS     r1,r1,#23
000006  d41a              BMI      |L37.62|
;;;690        {
;;;691            RMP_COVERAGE_MARKER();
;;;692            /* See if it is the last thread on the priority level */
;;;693            if(Thread->Run_Head.Prev==Thread->Run_Head.Next)
000008  6801              LDR      r1,[r0,#0]
00000a  6842              LDR      r2,[r0,#4]
;;;694            {
;;;695                RMP_COVERAGE_MARKER();
;;;696                RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]&=~(((rmp_ptr_t)1)<<(Thread->Prio&RMP_WORD_MASK));
00000c  2301              MOVS     r3,#1
00000e  4291              CMP      r1,r2                 ;693
000010  d10c              BNE      |L37.44|
000012  6a41              LDR      r1,[r0,#0x24]
000014  4a0a              LDR      r2,|L37.64|
000016  0949              LSRS     r1,r1,#5
000018  eb020181          ADD      r1,r2,r1,LSL #2
00001c  680a              LDR      r2,[r1,#0]
00001e  6a44              LDR      r4,[r0,#0x24]
000020  f004041f          AND      r4,r4,#0x1f
000024  fa03f404          LSL      r4,r3,r4
000028  43a2              BICS     r2,r2,r4
00002a  600a              STR      r2,[r1,#0]
                  |L37.44|
;;;697            }
;;;698            else
;;;699                RMP_COVERAGE_MARKER();
;;;700            
;;;701            /* Delete this from the corresponding runqueue */
;;;702            RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
00002c  6801              LDR      r1,[r0,#0]
00002e  6842              LDR      r2,[r0,#4]
000030  6011              STR      r1,[r2,#0]
000032  604a              STR      r2,[r1,#4]
;;;703            
;;;704            /* If it is the current thread, request a context switch */
;;;705            if(Thread==RMP_Cur_Thd)
000034  4902              LDR      r1,|L37.64|
000036  698a              LDR      r2,[r1,#0x18]  ; RMP_Cur_Thd
000038  4290              CMP      r0,r2
00003a  d100              BNE      |L37.62|
;;;706            {
;;;707                RMP_COVERAGE_MARKER();
;;;708                RMP_Sched_Pend=1;
00003c  60cb              STR      r3,[r1,#0xc]  ; RMP_Sched_Pend
                  |L37.62|
;;;709            }
;;;710            else
;;;711                RMP_COVERAGE_MARKER();
;;;712        }
;;;713        else
;;;714            RMP_COVERAGE_MARKER();
;;;715    }
00003e  bd10              POP      {r4,pc}
;;;716    /* End Function:_RMP_Clr_Rdy *************************************************/
                          ENDP

                  |L37.64|
                          DCD      ||.data||

                          AREA ||i._RMP_Dly_Ins||, CODE, READONLY, ALIGN=2

                  _RMP_Dly_Ins PROC
;;;725    ******************************************************************************/
;;;726    void _RMP_Dly_Ins(volatile struct RMP_Thd* Thread, rmp_ptr_t Slices)
000000  b470              PUSH     {r4-r6}
;;;727    {
;;;728        struct RMP_List* Trav_Ptr;
;;;729        struct RMP_Thd* Trav_Thd;
;;;730        
;;;731        /* Find a place to insert this timer */
;;;732        Trav_Ptr=(struct RMP_List*)RMP_Delay.Next;
000002  4c0a              LDR      r4,|L38.44|
;;;733        while(Trav_Ptr!=&(RMP_Delay))
;;;734        {
;;;735            Trav_Thd=RMP_DLY2THD(Trav_Ptr);
;;;736            if((Trav_Thd->Timeout-RMP_Tick)>Slices)
000004  f1a40520          SUB      r5,r4,#0x20
000008  6862              LDR      r2,[r4,#4]            ;732  ; RMP_Delay
00000a  e005              B        |L38.24|
                  |L38.12|
00000c  696e              LDR      r6,[r5,#0x14]  ; RMP_Tick
00000e  6a13              LDR      r3,[r2,#0x20]
000010  1b9b              SUBS     r3,r3,r6
000012  428b              CMP      r3,r1
000014  d802              BHI      |L38.28|
;;;737            {
;;;738                RMP_COVERAGE_MARKER();
;;;739                break;
;;;740            }
;;;741            else
;;;742                RMP_COVERAGE_MARKER();
;;;743            
;;;744            Trav_Ptr=(struct RMP_List*)(Trav_Ptr->Next);
000016  6852              LDR      r2,[r2,#4]
                  |L38.24|
000018  42a2              CMP      r2,r4                 ;733
00001a  d1f7              BNE      |L38.12|
                  |L38.28|
;;;745        }
;;;746    
;;;747        /* Insert this into the list */
;;;748        Thread->Timeout=RMP_Tick+Slices;
00001c  696b              LDR      r3,[r5,#0x14]  ; RMP_Tick
00001e  4419              ADD      r1,r1,r3
000020  6281              STR      r1,[r0,#0x28]
;;;749        RMP_List_Ins(&Thread->Dly_Head,Trav_Ptr->Prev,Trav_Ptr);
000022  6811              LDR      r1,[r2,#0]
000024  3008              ADDS     r0,r0,#8
000026  bc70              POP      {r4-r6}
000028  f7ffbffe          B.W      RMP_List_Ins
;;;750    }
;;;751    /* End Function:_RMP_Dly_Ins *************************************************/
                          ENDP

                  |L38.44|
                          DCD      ||.data||+0x20

                          AREA ||i._RMP_Get_High_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Get_High_Rdy PROC
;;;493    ******************************************************************************/
;;;494    void _RMP_Get_High_Rdy(void)
000000  b510              PUSH     {r4,lr}
;;;495    {
;;;496        rmp_cnt_t Count;
;;;497        
;;;498        /* Write the SP value to thread structure */
;;;499        RMP_Cur_Thd->Stack=RMP_Cur_SP;
000002  4c17              LDR      r4,|L39.96|
;;;500        
;;;501        /* No need to detect scheduler locks - if this interrupt can be entered, the scheduler is not locked */
;;;502        RMP_Sched_Pend=0;
000004  2100              MOVS     r1,#0
000006  69e2              LDR      r2,[r4,#0x1c]         ;499  ; RMP_Cur_SP
000008  69a3              LDR      r3,[r4,#0x18]         ;499  ; RMP_Cur_Thd
;;;503        /* See which one is ready, and pick it */
;;;504        for(Count=RMP_BITMAP_SIZE-1;Count>=0;Count--)
;;;505        {
;;;506            if(RMP_Bitmap[Count]==0)
00000a  4620              MOV      r0,r4
00000c  635a              STR      r2,[r3,#0x34]         ;502
00000e  60e1              STR      r1,[r4,#0xc]          ;502  ; RMP_Sched_Pend
000010  6801              LDR      r1,[r0,#0]
000012  b301              CBZ      r1,|L39.86|
;;;507            {
;;;508                RMP_COVERAGE_MARKER();
;;;509                continue;
;;;510            }
;;;511            else
;;;512                RMP_COVERAGE_MARKER();
;;;513            
;;;514            Count=RMP_MSB_Get(RMP_Bitmap[Count])+(Count<<RMP_WORD_ORDER);
000014  6800              LDR      r0,[r0,#0]
000016  f7fffffe          BL       RMP_MSB_Get
;;;515            
;;;516            /* See if the current thread and the next thread are the same. If yes, place the current at the end of the queue */
;;;517            if(RMP_Cur_Thd==(struct RMP_Thd*)(RMP_Run[Count].Next))
00001a  4a12              LDR      r2,|L39.100|
00001c  eb0203c0          ADD      r3,r2,r0,LSL #3
000020  6858              LDR      r0,[r3,#4]
000022  69a1              LDR      r1,[r4,#0x18]  ; RMP_Cur_Thd
000024  4288              CMP      r0,r1
000026  d110              BNE      |L39.74|
;;;518            {
;;;519                RMP_COVERAGE_MARKER();
;;;520                RMP_List_Del(RMP_Cur_Thd->Run_Head.Prev, RMP_Cur_Thd->Run_Head.Next);
000028  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
00002a  69a1              LDR      r1,[r4,#0x18]  ; RMP_Cur_Thd
00002c  6800              LDR      r0,[r0,#0]
00002e  6849              LDR      r1,[r1,#4]
000030  6008              STR      r0,[r1,#0]
000032  6041              STR      r1,[r0,#4]
;;;521                RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),
000034  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
000036  69a1              LDR      r1,[r4,#0x18]  ; RMP_Cur_Thd
000038  6a40              LDR      r0,[r0,#0x24]
00003a  6a49              LDR      r1,[r1,#0x24]
00003c  f8521031          LDR      r1,[r2,r1,LSL #3]
000040  eb0202c0          ADD      r2,r2,r0,LSL #3
000044  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
000046  f7fffffe          BL       RMP_List_Ins
                  |L39.74|
;;;522                             RMP_Run[RMP_Cur_Thd->Prio].Prev,
;;;523                             &(RMP_Run[RMP_Cur_Thd->Prio]));
;;;524            }
;;;525            else
;;;526                RMP_COVERAGE_MARKER();
;;;527            
;;;528            /* Replenish timeslices */
;;;529            RMP_Cur_Thd->Slices_Left=RMP_Cur_Thd->Slices;
00004a  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
00004c  69a1              LDR      r1,[r4,#0x18]  ; RMP_Cur_Thd
00004e  69c0              LDR      r0,[r0,#0x1c]
;;;530            RMP_Cur_Thd=(struct RMP_Thd*)(RMP_Run[Count].Next);
000050  6208              STR      r0,[r1,#0x20]
000052  6858              LDR      r0,[r3,#4]
000054  61a0              STR      r0,[r4,#0x18]  ; RMP_Cur_Thd
                  |L39.86|
;;;531            break;
;;;532        }
;;;533        
;;;534        /* Load the SP value from thread structure */
;;;535        RMP_Cur_SP=RMP_Cur_Thd->Stack;
000056  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
000058  6b40              LDR      r0,[r0,#0x34]
00005a  61e0              STR      r0,[r4,#0x1c]  ; RMP_Cur_SP
;;;536        
;;;537    #if(RMP_USE_HOOKS==RMP_TRUE)
;;;538        RMP_Sched_Hook();
;;;539    #endif
;;;540    }
00005c  bd10              POP      {r4,pc}
;;;541    /* End Function:_RMP_Get_High_Rdy ********************************************/
                          ENDP

00005e  0000              DCW      0x0000
                  |L39.96|
                          DCD      ||.data||
                  |L39.100|
                          DCD      ||.bss||

                          AREA ||i._RMP_Get_Near_Ticks||, CODE, READONLY, ALIGN=2

                  _RMP_Get_Near_Ticks PROC
;;;611    ******************************************************************************/
;;;612    rmp_ptr_t _RMP_Get_Near_Ticks(void)
000000  4908              LDR      r1,|L40.36|
;;;613    {
;;;614        rmp_ptr_t Value;
;;;615        struct RMP_Thd* Thread;
;;;616        
;;;617        /* What is the current thread's timeout value? */
;;;618        Value=RMP_Cur_Thd->Slices_Left;
000002  f1a10220          SUB      r2,r1,#0x20
000006  6990              LDR      r0,[r2,#0x18]  ; RMP_Cur_Thd
;;;619        
;;;620        /* What is the nearest timer timeout value? */
;;;621        if((&RMP_Delay)!=RMP_Delay.Next)
000008  684b              LDR      r3,[r1,#4]  ; RMP_Delay
00000a  428b              CMP      r3,r1
00000c  6a00              LDR      r0,[r0,#0x20]         ;618
00000e  d007              BEQ      |L40.32|
;;;622        {
;;;623            RMP_COVERAGE_MARKER();
;;;624            Thread=RMP_DLY2THD(RMP_Delay.Next);
000010  6849              LDR      r1,[r1,#4]  ; RMP_Delay
;;;625            /* See if it is nearer - don't worry about the situation that the timer
;;;626             * have overflown, because if that is to happen, it would have been 
;;;627             * already processed by the timeout processing routine just before. */
;;;628            if((Thread->Timeout-RMP_Tick)<Value)
000012  6953              LDR      r3,[r2,#0x14]  ; RMP_Tick
000014  6a09              LDR      r1,[r1,#0x20]
000016  1acb              SUBS     r3,r1,r3
000018  4283              CMP      r3,r0
00001a  d201              BCS      |L40.32|
;;;629            {
;;;630                RMP_COVERAGE_MARKER();
;;;631                Value=Thread->Timeout-RMP_Tick;
00001c  6950              LDR      r0,[r2,#0x14]  ; RMP_Tick
00001e  1a08              SUBS     r0,r1,r0
                  |L40.32|
;;;632            }
;;;633            else
;;;634                RMP_COVERAGE_MARKER();
;;;635        }
;;;636        else
;;;637            RMP_COVERAGE_MARKER();
;;;638        
;;;639        return Value;
;;;640    }
000020  4770              BX       lr
;;;641    /* End Function:_RMP_Get_Near_Ticks ******************************************/
                          ENDP

000022  0000              DCW      0x0000
                  |L40.36|
                          DCD      ||.data||+0x20

                          AREA ||i._RMP_Mem_Block||, CODE, READONLY, ALIGN=1

                  _RMP_Mem_Block PROC
;;;2238   ******************************************************************************/
;;;2239   void _RMP_Mem_Block(volatile struct RMP_Mem_Head* Addr, rmp_ptr_t Size)
000000  2200              MOVS     r2,#0
;;;2240   {
;;;2241       volatile struct RMP_Mem_Head* Mem_Head;
;;;2242       
;;;2243       /* Get the big memory block's size and position */
;;;2244       Mem_Head=(struct RMP_Mem_Head*)Addr;
;;;2245       
;;;2246       /* Initialize the big memory block */
;;;2247       Mem_Head->State=RMP_MEM_FREE;
000002  6082              STR      r2,[r0,#8]
;;;2248       Mem_Head->Tail=(struct RMP_Mem_Tail*)(((rmp_ptr_t)Mem_Head)+Size-sizeof(struct RMP_Mem_Tail));
000004  4401              ADD      r1,r1,r0
000006  1f09              SUBS     r1,r1,#4              ;2247
000008  60c1              STR      r1,[r0,#0xc]
;;;2249       Mem_Head->Tail->Head=Mem_Head;
00000a  68c1              LDR      r1,[r0,#0xc]
00000c  6008              STR      r0,[r1,#0]
;;;2250   }
00000e  4770              BX       lr
;;;2251   /* End Function:_RMP_Mem_Block ***********************************************/
                          ENDP


                          AREA ||i._RMP_Mem_Del||, CODE, READONLY, ALIGN=1

                  _RMP_Mem_Del PROC
;;;2305   ******************************************************************************/
;;;2306   void _RMP_Mem_Del(volatile void* Pool, volatile struct RMP_Mem_Head* Mem_Head)
000000  b570              PUSH     {r4-r6,lr}
;;;2307   {
000002  4605              MOV      r5,r0
;;;2308       rmp_ptr_t FLI_Level;
;;;2309       rmp_ptr_t SLI_Level;
;;;2310       rmp_ptr_t Level;
;;;2311       rmp_ptr_t Size;
;;;2312       volatile struct RMP_Mem* Mem;
;;;2313       volatile struct RMP_List* Slot;    
;;;2314       
;;;2315       /* Get the memory pool and block size */
;;;2316       Mem=(volatile struct RMP_Mem*)Pool;
;;;2317       Size=(rmp_ptr_t)(Mem_Head->Tail)-((rmp_ptr_t)Mem_Head)-sizeof(struct RMP_Mem_Head);
000004  68c8              LDR      r0,[r1,#0xc]
000006  460c              MOV      r4,r1                 ;2307
000008  1b06              SUBS     r6,r0,r4
00000a  3e10              SUBS     r6,r6,#0x10
;;;2318       
;;;2319       /* Guarantee the Mem_Size is bigger than 64 or a failure will surely occur here */
;;;2320       FLI_Level=RMP_MSB_Get(Size)-6;
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       RMP_MSB_Get
;;;2321       /* Decide the SLI level directly from the FLI level */
;;;2322       SLI_Level=(Size>>(FLI_Level+3))&0x07;
000012  1ec1              SUBS     r1,r0,#3
;;;2323       /* Calculate the bit position */
;;;2324       Level=RMP_MEM_POS(FLI_Level,SLI_Level);
;;;2325       /* Get the slot */
;;;2326       Slot=&(Mem->Table[Level]);
000014  68ea              LDR      r2,[r5,#0xc]
000016  40ce              LSRS     r6,r6,r1              ;2322
000018  1f80              SUBS     r0,r0,#6              ;2322
00001a  f0060107          AND      r1,r6,#7              ;2322
00001e  eb0100c0          ADD      r0,r1,r0,LSL #3       ;2324
;;;2327   
;;;2328       /* Delete the node now */
;;;2329       RMP_List_Del(Mem_Head->Head.Prev,Mem_Head->Head.Next);
000022  6821              LDR      r1,[r4,#0]
000024  eb0202c0          ADD      r2,r2,r0,LSL #3       ;2326
000028  6863              LDR      r3,[r4,#4]
00002a  6019              STR      r1,[r3,#0]
00002c  604b              STR      r3,[r1,#4]
;;;2330   
;;;2331       /* See if there are any blocks in the level, equal means no. So
;;;2332        * what we deleted is the last blockm need to clear the flag */
;;;2333       if(Slot==Slot->Next)
00002e  6851              LDR      r1,[r2,#4]
000030  4291              CMP      r1,r2
000032  d109              BNE      |L42.72|
;;;2334       {
;;;2335           RMP_COVERAGE_MARKER();
;;;2336           /* Clear the corresponding bit in the TLSF bitmap */
;;;2337           Mem->Bitmap[Level>>RMP_WORD_ORDER]&=~RMP_POW2(Level&RMP_WORD_MASK);
000034  0941              LSRS     r1,r0,#5
000036  f000031f          AND      r3,r0,#0x1f
00003a  eb050081          ADD      r0,r5,r1,LSL #2
00003e  2101              MOVS     r1,#1
000040  6902              LDR      r2,[r0,#0x10]
000042  4099              LSLS     r1,r1,r3
000044  438a              BICS     r2,r2,r1
000046  6102              STR      r2,[r0,#0x10]
                  |L42.72|
;;;2338       }
;;;2339       else
;;;2340           RMP_COVERAGE_MARKER();
;;;2341   }
000048  bd70              POP      {r4-r6,pc}
;;;2342   /* End Function:_RMP_Mem_Del *************************************************/
                          ENDP


                          AREA ||i._RMP_Mem_Ins||, CODE, READONLY, ALIGN=1

                  _RMP_Mem_Ins PROC
;;;2260   ******************************************************************************/
;;;2261   void _RMP_Mem_Ins(volatile void* Pool, volatile struct RMP_Mem_Head* Mem_Head)
000000  b570              PUSH     {r4-r6,lr}
;;;2262   {
000002  4604              MOV      r4,r0
;;;2263       rmp_ptr_t FLI_Level;
;;;2264       rmp_ptr_t SLI_Level;
;;;2265       rmp_ptr_t Level;
;;;2266       rmp_ptr_t Size;
;;;2267       volatile struct RMP_Mem* Mem;
;;;2268       volatile struct RMP_List* Slot;
;;;2269       
;;;2270       /* Get the memory pool and block size */
;;;2271       Mem=(volatile struct RMP_Mem*)Pool;
;;;2272       Size=(rmp_ptr_t)(Mem_Head->Tail)-((rmp_ptr_t)Mem_Head)-sizeof(struct RMP_Mem_Head);
000004  68c8              LDR      r0,[r1,#0xc]
000006  460e              MOV      r6,r1                 ;2262
000008  1b85              SUBS     r5,r0,r6
00000a  3d10              SUBS     r5,r5,#0x10
;;;2273   
;;;2274       /* Guarantee the Mem_Size is bigger than 64 or a failure will surely occur here */
;;;2275       FLI_Level=RMP_MSB_Get(Size)-6;
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       RMP_MSB_Get
;;;2276       /* Decide the SLI level directly from the FLI level */
;;;2277       SLI_Level=(Size>>(FLI_Level+3))&0x07;
;;;2278       /* Calculate the bit position */
;;;2279       Level=RMP_MEM_POS(FLI_Level,SLI_Level);
;;;2280       /* Get the slot */
;;;2281       Slot=&(Mem->Table[Level]);
000012  68e2              LDR      r2,[r4,#0xc]
000014  1ec1              SUBS     r1,r0,#3              ;2277
000016  40cd              LSRS     r5,r5,r1              ;2277
000018  1f80              SUBS     r0,r0,#6              ;2277
00001a  f0050107          AND      r1,r5,#7              ;2277
00001e  eb0100c0          ADD      r0,r1,r0,LSL #3       ;2279
000022  eb0201c0          ADD      r1,r2,r0,LSL #3
;;;2282   
;;;2283       /* See if there are any blocks in the level, equal means no. So what we inserted is the first block */
;;;2284       if(Slot==Slot->Next)
000026  684a              LDR      r2,[r1,#4]
000028  428a              CMP      r2,r1
00002a  d109              BNE      |L43.64|
;;;2285       {
;;;2286           RMP_COVERAGE_MARKER();
;;;2287           /* Set the corresponding bit in the TLSF bitmap */
;;;2288           Mem->Bitmap[Level>>RMP_WORD_ORDER]|=RMP_POW2(Level&RMP_WORD_MASK);
00002c  0942              LSRS     r2,r0,#5
00002e  f000051f          AND      r5,r0,#0x1f
000032  eb040082          ADD      r0,r4,r2,LSL #2
000036  2201              MOVS     r2,#1
000038  6903              LDR      r3,[r0,#0x10]
00003a  40aa              LSLS     r2,r2,r5
00003c  4313              ORRS     r3,r3,r2
00003e  6103              STR      r3,[r0,#0x10]
                  |L43.64|
;;;2289       }
;;;2290       else
;;;2291           RMP_COVERAGE_MARKER();
;;;2292   
;;;2293       /* Insert the node now */
;;;2294       RMP_List_Ins(&(Mem_Head->Head), Slot, Slot->Next);
000040  684a              LDR      r2,[r1,#4]
000042  4630              MOV      r0,r6
000044  e8bd4070          POP      {r4-r6,lr}
000048  f7ffbffe          B.W      RMP_List_Ins
;;;2295   }
;;;2296   /* End Function:_RMP_Mem_Ins *************************************************/
                          ENDP


                          AREA ||i._RMP_Mem_Search||, CODE, READONLY, ALIGN=1

                  _RMP_Mem_Search PROC
;;;2352   ******************************************************************************/
;;;2353   rmp_ret_t _RMP_Mem_Search(volatile void* Pool, rmp_ptr_t Size, rmp_cnt_t* FLI_Level, rmp_cnt_t* SLI_Level)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;2354   {
000004  461e              MOV      r6,r3
000006  4617              MOV      r7,r2
000008  4604              MOV      r4,r0
00000a  460d              MOV      r5,r1
;;;2355       rmp_ptr_t FLI_Level_Temp;
;;;2356       rmp_ptr_t SLI_Level_Temp;
;;;2357       rmp_cnt_t Level;
;;;2358       rmp_cnt_t Word;
;;;2359       rmp_cnt_t Limit;
;;;2360       rmp_ptr_t LSB;
;;;2361       volatile struct RMP_Mem* Mem;
;;;2362   
;;;2363       /* Make sure that it is bigger than 64. 64=2^6 */
;;;2364       FLI_Level_Temp=RMP_MSB_Get(Size)-6;
00000c  4608              MOV      r0,r1
00000e  f7fffffe          BL       RMP_MSB_Get
;;;2365       
;;;2366       /* Decide the SLI level directly from the FLI level. We plus the number by one here
;;;2367        * so that we can avoid the list search. However, when the allocated memory is just
;;;2368        * one of the levels, then we don't need to jump to the next level and can fit directly */
;;;2369       SLI_Level_Temp=(Size>>(FLI_Level_Temp+3))&0x07;
000012  1ec2              SUBS     r2,r0,#3
000014  fa25f102          LSR      r1,r5,r2
000018  f0010107          AND      r1,r1,#7
;;;2370       if(Size!=(RMP_POW2(FLI_Level_Temp+3)*(SLI_Level_Temp+8)))
00001c  f1010308          ADD      r3,r1,#8
000020  4093              LSLS     r3,r3,r2
000022  1f80              SUBS     r0,r0,#6
000024  42ab              CMP      r3,r5
000026  d004              BEQ      |L44.50|
000028  1c49              ADDS     r1,r1,#1
;;;2371       {
;;;2372           RMP_COVERAGE_MARKER();
;;;2373           SLI_Level_Temp++;
;;;2374           
;;;2375           /* If the SLI level is the largest of the SLI level, then jump to the next FLI level */
;;;2376           if(SLI_Level_Temp==8)
00002a  2908              CMP      r1,#8
00002c  d101              BNE      |L44.50|
;;;2377           {
;;;2378               RMP_COVERAGE_MARKER();
;;;2379               FLI_Level_Temp+=1;
;;;2380               SLI_Level_Temp=0;
00002e  2100              MOVS     r1,#0
000030  1c40              ADDS     r0,r0,#1
                  |L44.50|
;;;2381           }
;;;2382           else
;;;2383               RMP_COVERAGE_MARKER();
;;;2384       }
;;;2385       else
;;;2386           RMP_COVERAGE_MARKER();
;;;2387       
;;;2388       /* Check if the FLI level is over the boundary */
;;;2389       Mem=(volatile struct RMP_Mem*)Pool;
;;;2390       if(FLI_Level_Temp>=Mem->FLI_Num)
000032  6822              LDR      r2,[r4,#0]
;;;2391       {
;;;2392           RMP_COVERAGE_MARKER();
;;;2393           return -1;
000034  f04f39ff          MOV      r9,#0xffffffff
000038  4282              CMP      r2,r0                 ;2390
00003a  d933              BLS      |L44.164|
;;;2394       }
;;;2395       else
;;;2396           RMP_COVERAGE_MARKER();
;;;2397       
;;;2398       /* Try to find one position on this processor word level */
;;;2399       Level=RMP_MEM_POS(FLI_Level_Temp,SLI_Level_Temp);
00003c  eb0105c0          ADD      r5,r1,r0,LSL #3
;;;2400       LSB=RMP_LSB_Get(Mem->Bitmap[Level>>RMP_WORD_ORDER]>>(Level&RMP_WORD_MASK));
000040  f005081f          AND      r8,r5,#0x1f
000044  1168              ASRS     r0,r5,#5
000046  eb040080          ADD      r0,r4,r0,LSL #2
00004a  6900              LDR      r0,[r0,#0x10]
00004c  fa20f008          LSR      r0,r0,r8
000050  f7fffffe          BL       RMP_LSB_Get
;;;2401       /* If there's at least one block that matches the query, return the level */
;;;2402       if(LSB<RMP_WORD_SIZE)
000054  2820              CMP      r0,#0x20
000056  d208              BCS      |L44.106|
;;;2403       {
;;;2404           RMP_COVERAGE_MARKER();
;;;2405           Level=(Level&(~RMP_WORD_MASK))+LSB+(Level&RMP_WORD_MASK);
000058  f025011f          BIC      r1,r5,#0x1f
00005c  4401              ADD      r1,r1,r0
00005e  eb010008          ADD      r0,r1,r8
;;;2406           *FLI_Level=Level>>3;
000062  10c1              ASRS     r1,r0,#3
;;;2407           *SLI_Level=Level&0x07;
000064  f0000007          AND      r0,r0,#7
;;;2408           return 0;
000068  e014              B        |L44.148|
                  |L44.106|
;;;2409       }
;;;2410       /* No one exactly fits */
;;;2411       else
;;;2412       {
;;;2413           RMP_COVERAGE_MARKER();
;;;2414           Limit=RMP_ROUND_UP(Mem->FLI_Num,RMP_ALIGN_ORDER)>>RMP_ALIGN_ORDER;
00006a  6820              LDR      r0,[r4,#0]
;;;2415           /* From the next word, query one by one */
;;;2416           for(Word=(Level>>RMP_WORD_ORDER)+1;Word<Limit;Word++)
00006c  2101              MOVS     r1,#1
00006e  eb011565          ADD      r5,r1,r5,ASR #5
000072  1cc0              ADDS     r0,r0,#3
000074  0880              LSRS     r0,r0,#2              ;2414
000076  e013              B        |L44.160|
                  |L44.120|
;;;2417           {
;;;2418               /* If the level has blocks of one FLI level */
;;;2419               if(Mem->Bitmap[Word]!=0)
000078  eb040185          ADD      r1,r4,r5,LSL #2
00007c  6909              LDR      r1,[r1,#0x10]
00007e  b171              CBZ      r1,|L44.158|
;;;2420               {
;;;2421                   RMP_COVERAGE_MARKER();
;;;2422                   /* Find the actual level */ 
;;;2423                   LSB=RMP_LSB_Get(Mem->Bitmap[Word]);
000080  eb040085          ADD      r0,r4,r5,LSL #2
000084  6900              LDR      r0,[r0,#0x10]
000086  f7fffffe          BL       RMP_LSB_Get
;;;2424                   *FLI_Level=((Word<<RMP_WORD_ORDER)+LSB)>>3;
00008a  eb001145          ADD      r1,r0,r5,LSL #5
;;;2425                   *SLI_Level=LSB&0x07;
00008e  f0000007          AND      r0,r0,#7
000092  08c9              LSRS     r1,r1,#3              ;2424
                  |L44.148|
000094  6039              STR      r1,[r7,#0]
;;;2426                   return 0;
000096  6030              STR      r0,[r6,#0]
000098  2000              MOVS     r0,#0
                  |L44.154|
;;;2427               }
;;;2428               else
;;;2429                   RMP_COVERAGE_MARKER();
;;;2430           }
;;;2431       }
;;;2432   
;;;2433       /* Search failed */
;;;2434       return -1;
;;;2435   }
00009a  e8bd87f0          POP      {r4-r10,pc}
                  |L44.158|
00009e  1c6d              ADDS     r5,r5,#1
                  |L44.160|
0000a0  4285              CMP      r5,r0                 ;2416
0000a2  dbe9              BLT      |L44.120|
                  |L44.164|
0000a4  4648              MOV      r0,r9                 ;2434
0000a6  e7f8              B        |L44.154|
;;;2436   /* End Function:_RMP_Mem_Search **********************************************/
                          ENDP


                          AREA ||i._RMP_Set_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Set_Rdy PROC
;;;652    ******************************************************************************/
;;;653    void _RMP_Set_Rdy(volatile struct RMP_Thd* Thread)
000000  b510              PUSH     {r4,lr}
;;;654    {        
000002  4603              MOV      r3,r0
;;;655        /* Is it suspended? If yes, we can't directly set it running */
;;;656        if((Thread->State&RMP_THD_SUSPENDED)==0)
000004  6980              LDR      r0,[r0,#0x18]
000006  05c0              LSLS     r0,r0,#23
000008  d41e              BMI      |L45.72|
;;;657        {
;;;658            RMP_COVERAGE_MARKER();
;;;659            /* Insert this into the corresponding runqueue */
;;;660            RMP_List_Ins(&(Thread->Run_Head),RMP_Run[Thread->Prio].Prev,&(RMP_Run[Thread->Prio]));
00000a  6a5a              LDR      r2,[r3,#0x24]
00000c  6a59              LDR      r1,[r3,#0x24]
00000e  480f              LDR      r0,|L45.76|
000010  f8501031          LDR      r1,[r0,r1,LSL #3]
000014  eb0002c2          ADD      r2,r0,r2,LSL #3
000018  4618              MOV      r0,r3
00001a  f7fffffe          BL       RMP_List_Ins
;;;661            /* Set this runlevel as active */
;;;662            RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]|=((rmp_ptr_t)1)<<(Thread->Prio&RMP_WORD_MASK);
00001e  6a58              LDR      r0,[r3,#0x24]
000020  2101              MOVS     r1,#1
000022  4a0b              LDR      r2,|L45.80|
000024  0940              LSRS     r0,r0,#5
000026  eb020080          ADD      r0,r2,r0,LSL #2
00002a  6802              LDR      r2,[r0,#0]
00002c  6a5c              LDR      r4,[r3,#0x24]
00002e  f004041f          AND      r4,r4,#0x1f
000032  fa01f404          LSL      r4,r1,r4
000036  4322              ORRS     r2,r2,r4
000038  6002              STR      r2,[r0,#0]
;;;663            
;;;664            /* Compare this with the current one to see if we need a context switch */
;;;665            if(Thread->Prio>RMP_Cur_Thd->Prio)
00003a  4805              LDR      r0,|L45.80|
00003c  6a5a              LDR      r2,[r3,#0x24]
00003e  6983              LDR      r3,[r0,#0x18]  ; RMP_Cur_Thd
000040  6a5b              LDR      r3,[r3,#0x24]
000042  429a              CMP      r2,r3
000044  d900              BLS      |L45.72|
;;;666            {
;;;667                RMP_COVERAGE_MARKER();
;;;668                RMP_Sched_Pend=1;
000046  60c1              STR      r1,[r0,#0xc]  ; RMP_Sched_Pend
                  |L45.72|
;;;669            }
;;;670            else
;;;671                RMP_COVERAGE_MARKER();
;;;672        }
;;;673        else
;;;674            RMP_COVERAGE_MARKER();
;;;675    }
000048  bd10              POP      {r4,pc}
;;;676    /* End Function:_RMP_Set_Rdy *************************************************/
                          ENDP

00004a  0000              DCW      0x0000
                  |L45.76|
                          DCD      ||.bss||
                  |L45.80|
                          DCD      ||.data||

                          AREA ||i._RMP_Tick_Handler||, CODE, READONLY, ALIGN=2

                  _RMP_Tick_Handler PROC
;;;548    ******************************************************************************/
;;;549    void _RMP_Tick_Handler(rmp_ptr_t Ticks)
000000  b510              PUSH     {r4,lr}
;;;550    {
;;;551        struct RMP_Thd* Thread;
;;;552        /* Increase the timestamp as always */
;;;553        RMP_Tick+=Ticks;
000002  4c13              LDR      r4,|L46.80|
000004  6961              LDR      r1,[r4,#0x14]  ; RMP_Tick
000006  4401              ADD      r1,r1,r0
000008  6161              STR      r1,[r4,#0x14]  ; RMP_Tick
;;;554        
;;;555        /* See if the current thread expired. If yes, trigger a scheduler event */
;;;556        if(Ticks>RMP_Cur_Thd->Slices_Left)
00000a  69a1              LDR      r1,[r4,#0x18]  ; RMP_Cur_Thd
00000c  6a09              LDR      r1,[r1,#0x20]
00000e  4281              CMP      r1,r0
000010  d202              BCS      |L46.24|
;;;557        {
;;;558            RMP_COVERAGE_MARKER();
;;;559            RMP_Sched_Pend=1;
000012  2001              MOVS     r0,#1
000014  60e0              STR      r0,[r4,#0xc]  ; RMP_Sched_Pend
000016  e003              B        |L46.32|
                  |L46.24|
;;;560        }
;;;561        else
;;;562        {
;;;563            RMP_COVERAGE_MARKER();
;;;564            RMP_Cur_Thd->Slices_Left-=Ticks;
000018  69a1              LDR      r1,[r4,#0x18]  ; RMP_Cur_Thd
00001a  6a0a              LDR      r2,[r1,#0x20]
00001c  1a10              SUBS     r0,r2,r0
00001e  6208              STR      r0,[r1,#0x20]
                  |L46.32|
;;;565        }
;;;566        
;;;567        /* Check if there are any timer events */
;;;568        if((&RMP_Delay)!=RMP_Delay.Next)
000020  480b              LDR      r0,|L46.80|
000022  3020              ADDS     r0,r0,#0x20
000024  6841              LDR      r1,[r0,#4]  ; RMP_Delay
000026  4281              CMP      r1,r0
000028  d008              BEQ      |L46.60|
;;;569        {
;;;570            RMP_COVERAGE_MARKER();
;;;571            Thread=RMP_DLY2THD(RMP_Delay.Next);
00002a  6840              LDR      r0,[r0,#4]  ; RMP_Delay
;;;572            /* If the value is less than this, then it means that the time have
;;;573             * already passed and we have to process this */
;;;574            if((RMP_Tick-Thread->Timeout)<=(RMP_ALLBITS>>1))
00002c  6961              LDR      r1,[r4,#0x14]  ; RMP_Tick
00002e  6a00              LDR      r0,[r0,#0x20]
000030  1a08              SUBS     r0,r1,r0
000032  f1b04f00          CMP      r0,#0x80000000
000036  d201              BCS      |L46.60|
;;;575            {
;;;576                RMP_COVERAGE_MARKER();
;;;577                /* No need to care about scheduler locks if this interrupt can be entered
;;;578                 * - we have disabled timer and scheduler interrupts in scheduler lock */
;;;579                _RMP_Timer_Proc();
000038  f7fffffe          BL       _RMP_Timer_Proc
                  |L46.60|
;;;580            }
;;;581            else
;;;582                RMP_COVERAGE_MARKER();
;;;583        }
;;;584        else
;;;585            RMP_COVERAGE_MARKER();
;;;586        
;;;587        if(RMP_Sched_Pend!=0)
00003c  68e0              LDR      r0,[r4,#0xc]  ; RMP_Sched_Pend
00003e  2800              CMP      r0,#0
000040  d005              BEQ      |L46.78|
;;;588        {
;;;589            RMP_COVERAGE_MARKER();
;;;590            RMP_Sched_Pend=0;
000042  2000              MOVS     r0,#0
000044  60e0              STR      r0,[r4,#0xc]  ; RMP_Sched_Pend
;;;591            _RMP_Yield();
000046  e8bd4010          POP      {r4,lr}
00004a  f7ffbffe          B.W      _RMP_Yield
                  |L46.78|
;;;592        }
;;;593        else
;;;594            RMP_COVERAGE_MARKER();
;;;595        
;;;596    #if(RMP_USE_HOOKS==RMP_TRUE)
;;;597        RMP_Tick_Hook(Ticks);
;;;598    #endif
;;;599    }
00004e  bd10              POP      {r4,pc}
;;;600    /* End Function:_RMP_Tick_Handler ********************************************/
                          ENDP

                  |L46.80|
                          DCD      ||.data||

                          AREA ||i._RMP_Timer_Proc||, CODE, READONLY, ALIGN=2

                  _RMP_Timer_Proc PROC
;;;436    ******************************************************************************/
;;;437    void _RMP_Timer_Proc(void)
000000  b570              PUSH     {r4-r6,lr}
;;;438    {
;;;439        struct RMP_Thd* Thread;
;;;440        
;;;441        /* Process the timer events, if there are any of them */
;;;442        while((&RMP_Delay)!=RMP_Delay.Next)
;;;443        {
;;;444            Thread=RMP_DLY2THD(RMP_Delay.Next);
000002  4c16              LDR      r4,|L47.92|
;;;445            /* If the value is more than this, then it means that the time have
;;;446             * already passed and we have to process this */
;;;447            if((RMP_Tick-Thread->Timeout)>(RMP_ALLBITS>>1))
;;;448            {
;;;449                RMP_COVERAGE_MARKER();
;;;450                break;
;;;451            }
;;;452            else
;;;453                RMP_COVERAGE_MARKER();
;;;454            
;;;455            /* This thread should be processed */
;;;456            RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;457            switch(RMP_THD_STATE(Thread->State))
;;;458            {
;;;459                case RMP_THD_SNDDLY:RMP_COVERAGE_MARKER();
;;;460                case RMP_THD_SEMDLY:
;;;461                {
;;;462                    RMP_COVERAGE_MARKER();
;;;463                    RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;464                    Thread->Retval=RMP_ERR_OPER;
000004  f06f0504          MVN      r5,#4
000008  e023              B        |L47.82|
                  |L47.10|
00000a  6860              LDR      r0,[r4,#4]            ;444  ; RMP_Delay
00000c  4913              LDR      r1,|L47.92|
00000e  3920              SUBS     r1,r1,#0x20           ;447
000010  6949              LDR      r1,[r1,#0x14]         ;447  ; RMP_Tick
000012  6a02              LDR      r2,[r0,#0x20]         ;447
000014  3808              SUBS     r0,r0,#8              ;447
000016  1a89              SUBS     r1,r1,r2              ;447
000018  f1b14f00          CMP      r1,#0x80000000        ;447
00001c  d21c              BCS      |L47.88|
00001e  e9d01202          LDRD     r1,r2,[r0,#8]         ;447
000022  6011              STR      r1,[r2,#0]            ;447
000024  604a              STR      r2,[r1,#4]            ;447
000026  7e01              LDRB     r1,[r0,#0x18]         ;457
000028  2903              CMP      r1,#3                 ;457
00002a  d006              BEQ      |L47.58|
00002c  2905              CMP      r1,#5                 ;457
00002e  d008              BEQ      |L47.66|
000030  2906              CMP      r1,#6                 ;457
000032  d007              BEQ      |L47.68|
000034  2908              CMP      r1,#8                 ;457
000036  d000              BEQ      |L47.58|
                  |L47.56|
;;;465                    break;
;;;466                }
;;;467                
;;;468                case RMP_THD_RCVDLY:
;;;469                {
;;;470                    RMP_COVERAGE_MARKER();
;;;471                    Thread->Retval=RMP_ERR_OPER;
;;;472                    break;
;;;473                }
;;;474                
;;;475                case RMP_THD_DELAYED:RMP_COVERAGE_MARKER();break;
;;;476                /* Should not get here */
;;;477                default:while(1);
000038  e7fe              B        |L47.56|
                  |L47.58|
00003a  e9d01200          LDRD     r1,r2,[r0,#0]
00003e  6011              STR      r1,[r2,#0]
000040  604a              STR      r2,[r1,#4]
                  |L47.66|
000042  6385              STR      r5,[r0,#0x38]         ;471
                  |L47.68|
;;;478            }
;;;479    
;;;480            RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
000044  6981              LDR      r1,[r0,#0x18]
000046  f02101ff          BIC      r1,r1,#0xff
00004a  1c49              ADDS     r1,r1,#1
;;;481            /* Set to ready if not suspended */
;;;482            _RMP_Set_Rdy(Thread);
00004c  6181              STR      r1,[r0,#0x18]
00004e  f7fffffe          BL       _RMP_Set_Rdy
                  |L47.82|
000052  6860              LDR      r0,[r4,#4]            ;442  ; RMP_Delay
000054  42a0              CMP      r0,r4                 ;442
000056  d1d8              BNE      |L47.10|
                  |L47.88|
;;;483        }
;;;484    }
000058  bd70              POP      {r4-r6,pc}
;;;485    /* Begin Function:_RMP_Timer_Proc ********************************************/
                          ENDP

00005a  0000              DCW      0x0000
                  |L47.92|
                          DCD      ||.data||+0x20

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;1993   ******************************************************************************/
;;;1994   int main(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1995   {
;;;1996       rmp_ptr_t Count;
;;;1997       
;;;1998   #ifdef RMP_COVERAGE
;;;1999       /* Initialize coverage markers if coverage enabled */
;;;2000       for(Count=0;Count<RMP_COVERAGE_LINES;Count++)
;;;2001           RMP_Coverage[Count]=0;
;;;2002   #endif
;;;2003       
;;;2004       /* Initialize the kernel data structures first */
;;;2005       _RMP_Low_Level_Init();
000004  f7fffffe          BL       _RMP_Low_Level_Init
;;;2006       
;;;2007   #if(RMP_USE_HOOKS==RMP_TRUE)
;;;2008       RMP_Start_Hook();
;;;2009   #endif
;;;2010       
;;;2011       RMP_Tick=0;
000008  4c1d              LDR      r4,|L48.128|
00000a  2500              MOVS     r5,#0
00000c  6165              STR      r5,[r4,#0x14]  ; RMP_Tick
;;;2012       /* Now initialize the kernel data structures */
;;;2013       RMP_Sched_Lock_Cnt=0;
00000e  6065              STR      r5,[r4,#4]  ; RMP_Sched_Lock_Cnt
;;;2014       RMP_Sched_Locked=0;
000010  60a5              STR      r5,[r4,#8]  ; RMP_Sched_Locked
;;;2015       RMP_Sched_Pend=0;
000012  60e5              STR      r5,[r4,#0xc]  ; RMP_Sched_Pend
;;;2016       RMP_Timer_Pend=0;
000014  6125              STR      r5,[r4,#0x10]  ; RMP_Timer_Pend
;;;2017       
;;;2018       /* Linked lists */
;;;2019       RMP_List_Crt(&RMP_Delay);
000016  f1040020          ADD      r0,r4,#0x20
00001a  6000              STR      r0,[r0,#0]
00001c  6040              STR      r0,[r0,#4]
;;;2020       for(Count=0;Count<RMP_MAX_PREEMPT_PRIO;Count++)
00001e  ea4f0105          MOV.W    r1,r5
;;;2021           RMP_List_Crt(&RMP_Run[Count]);
000022  4f18              LDR      r7,|L48.132|
                  |L48.36|
000024  eb0700c1          ADD      r0,r7,r1,LSL #3
000028  6000              STR      r0,[r0,#0]
00002a  6040              STR      r0,[r0,#4]
00002c  1c49              ADDS     r1,r1,#1
00002e  2920              CMP      r1,#0x20              ;2020
000030  d3f8              BCC      |L48.36|
;;;2022       for(Count=0;Count<RMP_BITMAP_SIZE;Count++)
;;;2023           RMP_Bitmap[Count]=0;
000032  4e13              LDR      r6,|L48.128|
000034  6035              STR      r5,[r6,#0]
;;;2024           
;;;2025       /* Now boot into the first thread */
;;;2026       RMP_Clear(&RMP_Init_Thd,sizeof(struct RMP_Thd));
000036  213c              MOVS     r1,#0x3c
000038  4813              LDR      r0,|L48.136|
00003a  f7fffffe          BL       RMP_Clear
;;;2027       RMP_Init_Thd.Prio=0;
00003e  4b12              LDR      r3,|L48.136|
;;;2028       RMP_Init_Thd.Slices=10;
000040  200a              MOVS     r0,#0xa
;;;2029       RMP_Init_Thd.Slices_Left=10;
;;;2030       RMP_Init_Thd.State=RMP_THD_RUNNING;
000042  2201              MOVS     r2,#1
;;;2031       RMP_Init_Thd.Stack=RMP_INIT_STACK;
000044  f1a30144          SUB      r1,r3,#0x44
000048  625d              STR      r5,[r3,#0x24]         ;2027  ; RMP_Init_Thd
00004a  61d8              STR      r0,[r3,#0x1c]         ;2028  ; RMP_Init_Thd
00004c  6218              STR      r0,[r3,#0x20]         ;2029  ; RMP_Init_Thd
00004e  619a              STR      r2,[r3,#0x18]         ;2030  ; RMP_Init_Thd
000050  6359              STR      r1,[r3,#0x34]  ; RMP_Init_Thd
;;;2032       
;;;2033       /* Initialize sending list */
;;;2034       RMP_List_Crt(&(RMP_Init_Thd.Snd_List));
000052  f1010054          ADD      r0,r1,#0x54
000056  6000              STR      r0,[r0,#0]
000058  6040              STR      r0,[r0,#4]
;;;2035       
;;;2036       /* Insert this into the corresponding runqueue */
;;;2037       RMP_List_Ins(&(RMP_Init_Thd.Run_Head),RMP_Run[0].Prev,&(RMP_Run[0]));
00005a  6839              LDR      r1,[r7,#0]  ; RMP_Run
00005c  3810              SUBS     r0,r0,#0x10
00005e  4a09              LDR      r2,|L48.132|
000060  f7fffffe          BL       RMP_List_Ins
;;;2038       /* Set this runlevel as active - in fact it is always active */
;;;2039       RMP_Bitmap[0]|=1;
000064  6830              LDR      r0,[r6,#0]  ; RMP_Bitmap
000066  f0400001          ORR      r0,r0,#1
00006a  6030              STR      r0,[r6,#0]  ; RMP_Bitmap
;;;2040       
;;;2041       /* Set current thread and stack */
;;;2042       RMP_Cur_Thd=(struct RMP_Thd*)(&RMP_Init_Thd);
00006c  61a3              STR      r3,[r4,#0x18]  ; RMP_Cur_Thd
;;;2043       RMP_Cur_SP=RMP_Init_Thd.Stack;
00006e  6b58              LDR      r0,[r3,#0x34]  ; RMP_Init_Thd
000070  61e0              STR      r0,[r4,#0x1c]  ; RMP_Cur_SP
;;;2044       
;;;2045       /* Now jump to the user function and will never return. Initialization of stack is not needed */
;;;2046       _RMP_Start((rmp_ptr_t)RMP_Init, (rmp_ptr_t)RMP_Init_Thd.Stack);
000072  6b59              LDR      r1,[r3,#0x34]  ; RMP_Init_Thd
000074  4805              LDR      r0,|L48.140|
000076  f7fffffe          BL       _RMP_Start
;;;2047       
;;;2048       return 0;
00007a  2000              MOVS     r0,#0
;;;2049   }
00007c  e8bd81f0          POP      {r4-r8,pc}
;;;2050   /* End Function:main *********************************************************/
                          ENDP

                  |L48.128|
                          DCD      ||.data||
                  |L48.132|
                          DCD      ||.bss||
                  |L48.136|
                          DCD      ||.bss||+0x200
                  |L48.140|
                          DCD      RMP_Init

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  RMP_Run
                          %        256
                  RMP_Init_Stack
                          %        256
                  RMP_Init_Thd
                          %        60

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  RMP_RBIT_Table
000000  008040c0          DCB      0x00,0x80,0x40,0xc0
000004  20a060e0          DCB      0x20,0xa0,0x60,0xe0
000008  109050d0          DCB      0x10,0x90,0x50,0xd0
00000c  30b070f0          DCB      0x30,0xb0,0x70,0xf0
000010  088848c8          DCB      0x08,0x88,0x48,0xc8
000014  28a868e8          DCB      0x28,0xa8,0x68,0xe8
000018  189858d8          DCB      0x18,0x98,0x58,0xd8
00001c  38b878f8          DCB      0x38,0xb8,0x78,0xf8
000020  048444c4          DCB      0x04,0x84,0x44,0xc4
000024  24a464e4          DCB      0x24,0xa4,0x64,0xe4
000028  149454d4          DCB      0x14,0x94,0x54,0xd4
00002c  34b474f4          DCB      0x34,0xb4,0x74,0xf4
000030  0c8c4ccc          DCB      0x0c,0x8c,0x4c,0xcc
000034  2cac6cec          DCB      0x2c,0xac,0x6c,0xec
000038  1c9c5cdc          DCB      0x1c,0x9c,0x5c,0xdc
00003c  3cbc7cfc          DCB      0x3c,0xbc,0x7c,0xfc
000040  028242c2          DCB      0x02,0x82,0x42,0xc2
000044  22a262e2          DCB      0x22,0xa2,0x62,0xe2
000048  129252d2          DCB      0x12,0x92,0x52,0xd2
00004c  32b272f2          DCB      0x32,0xb2,0x72,0xf2
000050  0a8a4aca          DCB      0x0a,0x8a,0x4a,0xca
000054  2aaa6aea          DCB      0x2a,0xaa,0x6a,0xea
000058  1a9a5ada          DCB      0x1a,0x9a,0x5a,0xda
00005c  3aba7afa          DCB      0x3a,0xba,0x7a,0xfa
000060  068646c6          DCB      0x06,0x86,0x46,0xc6
000064  26a666e6          DCB      0x26,0xa6,0x66,0xe6
000068  169656d6          DCB      0x16,0x96,0x56,0xd6
00006c  36b676f6          DCB      0x36,0xb6,0x76,0xf6
000070  0e8e4ece          DCB      0x0e,0x8e,0x4e,0xce
000074  2eae6eee          DCB      0x2e,0xae,0x6e,0xee
000078  1e9e5ede          DCB      0x1e,0x9e,0x5e,0xde
00007c  3ebe7efe          DCB      0x3e,0xbe,0x7e,0xfe
000080  018141c1          DCB      0x01,0x81,0x41,0xc1
000084  21a161e1          DCB      0x21,0xa1,0x61,0xe1
000088  119151d1          DCB      0x11,0x91,0x51,0xd1
00008c  31b171f1          DCB      0x31,0xb1,0x71,0xf1
000090  098949c9          DCB      0x09,0x89,0x49,0xc9
000094  29a969e9          DCB      0x29,0xa9,0x69,0xe9
000098  199959d9          DCB      0x19,0x99,0x59,0xd9
00009c  39b979f9          DCB      0x39,0xb9,0x79,0xf9
0000a0  058545c5          DCB      0x05,0x85,0x45,0xc5
0000a4  25a565e5          DCB      0x25,0xa5,0x65,0xe5
0000a8  159555d5          DCB      0x15,0x95,0x55,0xd5
0000ac  35b575f5          DCB      0x35,0xb5,0x75,0xf5
0000b0  0d8d4dcd          DCB      0x0d,0x8d,0x4d,0xcd
0000b4  2dad6ded          DCB      0x2d,0xad,0x6d,0xed
0000b8  1d9d5ddd          DCB      0x1d,0x9d,0x5d,0xdd
0000bc  3dbd7dfd          DCB      0x3d,0xbd,0x7d,0xfd
0000c0  038343c3          DCB      0x03,0x83,0x43,0xc3
0000c4  23a363e3          DCB      0x23,0xa3,0x63,0xe3
0000c8  139353d3          DCB      0x13,0x93,0x53,0xd3
0000cc  33b373f3          DCB      0x33,0xb3,0x73,0xf3
0000d0  0b8b4bcb          DCB      0x0b,0x8b,0x4b,0xcb
0000d4  2bab6beb          DCB      0x2b,0xab,0x6b,0xeb
0000d8  1b9b5bdb          DCB      0x1b,0x9b,0x5b,0xdb
0000dc  3bbb7bfb          DCB      0x3b,0xbb,0x7b,0xfb
0000e0  078747c7          DCB      0x07,0x87,0x47,0xc7
0000e4  27a767e7          DCB      0x27,0xa7,0x67,0xe7
0000e8  179757d7          DCB      0x17,0x97,0x57,0xd7
0000ec  37b777f7          DCB      0x37,0xb7,0x77,0xf7
0000f0  0f8f4fcf          DCB      0x0f,0x8f,0x4f,0xcf
0000f4  2faf6fef          DCB      0x2f,0xaf,0x6f,0xef
0000f8  1f9f5fdf          DCB      0x1f,0x9f,0x5f,0xdf
0000fc  3fbf7fff          DCB      0x3f,0xbf,0x7f,0xff
                  CRC16_High
000100  00c18140          DCB      0x00,0xc1,0x81,0x40
000104  01c08041          DCB      0x01,0xc0,0x80,0x41
000108  01c08041          DCB      0x01,0xc0,0x80,0x41
00010c  00c18140          DCB      0x00,0xc1,0x81,0x40
000110  01c08041          DCB      0x01,0xc0,0x80,0x41
000114  00c18140          DCB      0x00,0xc1,0x81,0x40
000118  00c18140          DCB      0x00,0xc1,0x81,0x40
00011c  01c08041          DCB      0x01,0xc0,0x80,0x41
000120  01c08041          DCB      0x01,0xc0,0x80,0x41
000124  00c18140          DCB      0x00,0xc1,0x81,0x40
000128  00c18140          DCB      0x00,0xc1,0x81,0x40
00012c  01c08041          DCB      0x01,0xc0,0x80,0x41
000130  00c18140          DCB      0x00,0xc1,0x81,0x40
000134  01c08041          DCB      0x01,0xc0,0x80,0x41
000138  01c08041          DCB      0x01,0xc0,0x80,0x41
00013c  00c18140          DCB      0x00,0xc1,0x81,0x40
000140  01c08041          DCB      0x01,0xc0,0x80,0x41
000144  00c18140          DCB      0x00,0xc1,0x81,0x40
000148  00c18140          DCB      0x00,0xc1,0x81,0x40
00014c  01c08041          DCB      0x01,0xc0,0x80,0x41
000150  00c18140          DCB      0x00,0xc1,0x81,0x40
000154  01c08041          DCB      0x01,0xc0,0x80,0x41
000158  01c08041          DCB      0x01,0xc0,0x80,0x41
00015c  00c18140          DCB      0x00,0xc1,0x81,0x40
000160  00c18140          DCB      0x00,0xc1,0x81,0x40
000164  01c08041          DCB      0x01,0xc0,0x80,0x41
000168  01c08041          DCB      0x01,0xc0,0x80,0x41
00016c  00c18140          DCB      0x00,0xc1,0x81,0x40
000170  01c08041          DCB      0x01,0xc0,0x80,0x41
000174  00c18140          DCB      0x00,0xc1,0x81,0x40
000178  00c18140          DCB      0x00,0xc1,0x81,0x40
00017c  01c08041          DCB      0x01,0xc0,0x80,0x41
000180  01c08041          DCB      0x01,0xc0,0x80,0x41
000184  00c18140          DCB      0x00,0xc1,0x81,0x40
000188  00c18140          DCB      0x00,0xc1,0x81,0x40
00018c  01c08041          DCB      0x01,0xc0,0x80,0x41
000190  00c18140          DCB      0x00,0xc1,0x81,0x40
000194  01c08041          DCB      0x01,0xc0,0x80,0x41
000198  01c08041          DCB      0x01,0xc0,0x80,0x41
00019c  00c18140          DCB      0x00,0xc1,0x81,0x40
0001a0  00c18140          DCB      0x00,0xc1,0x81,0x40
0001a4  01c08041          DCB      0x01,0xc0,0x80,0x41
0001a8  01c08041          DCB      0x01,0xc0,0x80,0x41
0001ac  00c18140          DCB      0x00,0xc1,0x81,0x40
0001b0  01c08041          DCB      0x01,0xc0,0x80,0x41
0001b4  00c18140          DCB      0x00,0xc1,0x81,0x40
0001b8  00c18140          DCB      0x00,0xc1,0x81,0x40
0001bc  01c08041          DCB      0x01,0xc0,0x80,0x41
0001c0  00c18140          DCB      0x00,0xc1,0x81,0x40
0001c4  01c08041          DCB      0x01,0xc0,0x80,0x41
0001c8  01c08041          DCB      0x01,0xc0,0x80,0x41
0001cc  00c18140          DCB      0x00,0xc1,0x81,0x40
0001d0  01c08041          DCB      0x01,0xc0,0x80,0x41
0001d4  00c18140          DCB      0x00,0xc1,0x81,0x40
0001d8  00c18140          DCB      0x00,0xc1,0x81,0x40
0001dc  01c08041          DCB      0x01,0xc0,0x80,0x41
0001e0  01c08041          DCB      0x01,0xc0,0x80,0x41
0001e4  00c18140          DCB      0x00,0xc1,0x81,0x40
0001e8  00c18140          DCB      0x00,0xc1,0x81,0x40
0001ec  01c08041          DCB      0x01,0xc0,0x80,0x41
0001f0  00c18140          DCB      0x00,0xc1,0x81,0x40
0001f4  01c08041          DCB      0x01,0xc0,0x80,0x41
0001f8  01c08041          DCB      0x01,0xc0,0x80,0x41
0001fc  00c18140          DCB      0x00,0xc1,0x81,0x40
000200  00c0c101          DCB      0x00,0xc0,0xc1,0x01
000204  c30302c2          DCB      0xc3,0x03,0x02,0xc2
000208  c60607c7          DCB      0xc6,0x06,0x07,0xc7
00020c  05c5c404          DCB      0x05,0xc5,0xc4,0x04
000210  cc0c0dcd          DCB      0xcc,0x0c,0x0d,0xcd
000214  0fcfce0e          DCB      0x0f,0xcf,0xce,0x0e
000218  0acacb0b          DCB      0x0a,0xca,0xcb,0x0b
00021c  c90908c8          DCB      0xc9,0x09,0x08,0xc8
000220  d81819d9          DCB      0xd8,0x18,0x19,0xd9
000224  1bdbda1a          DCB      0x1b,0xdb,0xda,0x1a
000228  1ededf1f          DCB      0x1e,0xde,0xdf,0x1f
00022c  dd1d1cdc          DCB      0xdd,0x1d,0x1c,0xdc
000230  14d4d515          DCB      0x14,0xd4,0xd5,0x15
000234  d71716d6          DCB      0xd7,0x17,0x16,0xd6
000238  d21213d3          DCB      0xd2,0x12,0x13,0xd3
00023c  11d1d010          DCB      0x11,0xd1,0xd0,0x10
000240  f03031f1          DCB      0xf0,0x30,0x31,0xf1
000244  33f3f232          DCB      0x33,0xf3,0xf2,0x32
000248  36f6f737          DCB      0x36,0xf6,0xf7,0x37
00024c  f53534f4          DCB      0xf5,0x35,0x34,0xf4
000250  3cfcfd3d          DCB      0x3c,0xfc,0xfd,0x3d
000254  ff3f3efe          DCB      0xff,0x3f,0x3e,0xfe
000258  fa3a3bfb          DCB      0xfa,0x3a,0x3b,0xfb
00025c  39f9f838          DCB      0x39,0xf9,0xf8,0x38
000260  28e8e929          DCB      0x28,0xe8,0xe9,0x29
000264  eb2b2aea          DCB      0xeb,0x2b,0x2a,0xea
000268  ee2e2fef          DCB      0xee,0x2e,0x2f,0xef
00026c  2dedec2c          DCB      0x2d,0xed,0xec,0x2c
000270  e42425e5          DCB      0xe4,0x24,0x25,0xe5
000274  27e7e626          DCB      0x27,0xe7,0xe6,0x26
000278  22e2e323          DCB      0x22,0xe2,0xe3,0x23
00027c  e12120e0          DCB      0xe1,0x21,0x20,0xe0
000280  a06061a1          DCB      0xa0,0x60,0x61,0xa1
000284  63a3a262          DCB      0x63,0xa3,0xa2,0x62
000288  66a6a767          DCB      0x66,0xa6,0xa7,0x67
00028c  a56564a4          DCB      0xa5,0x65,0x64,0xa4
000290  6cacad6d          DCB      0x6c,0xac,0xad,0x6d
000294  af6f6eae          DCB      0xaf,0x6f,0x6e,0xae
000298  aa6a6bab          DCB      0xaa,0x6a,0x6b,0xab
00029c  69a9a868          DCB      0x69,0xa9,0xa8,0x68
0002a0  78b8b979          DCB      0x78,0xb8,0xb9,0x79
0002a4  bb7b7aba          DCB      0xbb,0x7b,0x7a,0xba
0002a8  be7e7fbf          DCB      0xbe,0x7e,0x7f,0xbf
0002ac  7dbdbc7c          DCB      0x7d,0xbd,0xbc,0x7c
0002b0  b47475b5          DCB      0xb4,0x74,0x75,0xb5
0002b4  77b7b676          DCB      0x77,0xb7,0xb6,0x76
0002b8  72b2b373          DCB      0x72,0xb2,0xb3,0x73
0002bc  b17170b0          DCB      0xb1,0x71,0x70,0xb0
0002c0  50909151          DCB      0x50,0x90,0x91,0x51
0002c4  93535292          DCB      0x93,0x53,0x52,0x92
0002c8  96565797          DCB      0x96,0x56,0x57,0x97
0002cc  55959454          DCB      0x55,0x95,0x94,0x54
0002d0  9c5c5d9d          DCB      0x9c,0x5c,0x5d,0x9d
0002d4  5f9f9e5e          DCB      0x5f,0x9f,0x9e,0x5e
0002d8  5a9a9b5b          DCB      0x5a,0x9a,0x9b,0x5b
0002dc  99595898          DCB      0x99,0x59,0x58,0x98
0002e0  88484989          DCB      0x88,0x48,0x49,0x89
0002e4  4b8b8a4a          DCB      0x4b,0x8b,0x8a,0x4a
0002e8  4e8e8f4f          DCB      0x4e,0x8e,0x8f,0x4f
0002ec  8d4d4c8c          DCB      0x8d,0x4d,0x4c,0x8c
0002f0  44848545          DCB      0x44,0x84,0x85,0x45
0002f4  87474686          DCB      0x87,0x47,0x46,0x86
0002f8  82424383          DCB      0x82,0x42,0x43,0x83
0002fc  41818040          DCB      0x41,0x81,0x80,0x40

                          AREA ||.data||, DATA, ALIGN=2

                  RMP_Bitmap
                          DCD      0x00000000
                  RMP_Sched_Lock_Cnt
                          DCD      0x00000000
                  RMP_Sched_Locked
                          DCD      0x00000000
                  RMP_Sched_Pend
                          DCD      0x00000000
                  RMP_Timer_Pend
                          DCD      0x00000000
                  RMP_Tick
                          DCD      0x00000000
                  RMP_Cur_Thd
                          DCD      0x00000000
                  RMP_Cur_SP
                          DCD      0x00000000
                  RMP_Delay
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\..\\MProkaron\\Kernel\\rmp_kernel.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_rmp_kernel_c_346ad0e8____REV16|
#line 468 "D:\\Program_Files_x86\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.3.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___12_rmp_kernel_c_346ad0e8____REV16| PROC
#line 469

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_rmp_kernel_c_346ad0e8____REVSH|
#line 483
|__asm___12_rmp_kernel_c_346ad0e8____REVSH| PROC
#line 484

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___12_rmp_kernel_c_346ad0e8____RRX|
#line 670
|__asm___12_rmp_kernel_c_346ad0e8____RRX| PROC
#line 671

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
