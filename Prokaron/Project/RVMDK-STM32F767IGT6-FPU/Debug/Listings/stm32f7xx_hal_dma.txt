; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f7xx_hal_dma.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f7xx_hal_dma.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Core -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Inc -I.\Source -I.\Drivers -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6-FPU\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f7xx_hal_dma.crf ..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_dma.c]
                          THUMB

                          AREA ||i.DMA_CalcBaseAndBitshift||, CODE, READONLY, ALIGN=2

                  DMA_CalcBaseAndBitshift PROC
;;;1201     */
;;;1202   static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
000000  6801              LDR      r1,[r0,#0]
;;;1203   {
;;;1204     uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
000002  2318              MOVS     r3,#0x18
000004  b2ca              UXTB     r2,r1
;;;1205     
;;;1206     /* lookup table for necessary bitshift of flags within status registers */
;;;1207     static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
;;;1208     hdma->StreamIndex = flagBitshiftOffset[stream_number];
;;;1209     
;;;1210     if (stream_number > 3U)
;;;1211     {
;;;1212       /* return pointer to HISR and HIFCR */
;;;1213       hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
000006  3a10              SUBS     r2,r2,#0x10
000008  fbb2f2f3          UDIV     r2,r2,r3              ;1204
00000c  4b05              LDR      r3,|L1.36|
00000e  f36f0109          BFC      r1,#0,#10
000012  2a03              CMP      r2,#3                 ;1210
000014  5c9b              LDRB     r3,[r3,r2]            ;1208
000016  6603              STR      r3,[r0,#0x60]         ;1203
000018  d900              BLS      |L1.28|
00001a  1d09              ADDS     r1,r1,#4              ;1203
                  |L1.28|
;;;1214     }
;;;1215     else
;;;1216     {
;;;1217       /* return pointer to LISR and LIFCR */
;;;1218       hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU));
;;;1219     }
;;;1220     
;;;1221     return hdma->StreamBaseAddress;
00001c  65c1              STR      r1,[r0,#0x5c]
00001e  4608              MOV      r0,r1
;;;1222   }
000020  4770              BX       lr
;;;1223   
                          ENDP

000022  0000              DCW      0x0000
                  |L1.36|
                          DCD      ||.constdata||

                          AREA ||i.DMA_CheckFifoParam||, CODE, READONLY, ALIGN=1

                  DMA_CheckFifoParam PROC
;;;1229     */
;;;1230   static HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1231   {
;;;1232     HAL_StatusTypeDef status = HAL_OK;
000002  6983              LDR      r3,[r0,#0x18]
;;;1233     uint32_t tmp = hdma->Init.FIFOThreshold;
;;;1234     
;;;1235     /* Memory Data size equal to Byte */
;;;1236     if(hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
;;;1237     {
;;;1238       switch (tmp)
;;;1239       {
;;;1240       case DMA_FIFO_THRESHOLD_1QUARTERFULL:
;;;1241       case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
;;;1242         if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
;;;1243         {
;;;1244           status = HAL_ERROR;
;;;1245         }
;;;1246         break;
;;;1247       case DMA_FIFO_THRESHOLD_HALFFULL:
;;;1248         if (hdma->Init.MemBurst == DMA_MBURST_INC16)
000004  f04f74c0          MOV      r4,#0x1800000
000008  6a82              LDR      r2,[r0,#0x28]         ;1232
00000a  4601              MOV      r1,r0                 ;1231
00000c  2000              MOVS     r0,#0                 ;1232
00000e  b153              CBZ      r3,|L2.38|
;;;1249         {
;;;1250           status = HAL_ERROR;
;;;1251         }
;;;1252         break;
;;;1253       case DMA_FIFO_THRESHOLD_FULL:
;;;1254         break;
;;;1255       default:
;;;1256         break;
;;;1257       }
;;;1258     }
;;;1259     
;;;1260     /* Memory Data size equal to Half-Word */
;;;1261     else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
000010  f5b35f00          CMP      r3,#0x2000
000014  d015              BEQ      |L2.66|
;;;1262     {
;;;1263       switch (tmp)
;;;1264       {
;;;1265       case DMA_FIFO_THRESHOLD_1QUARTERFULL:
;;;1266       case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
;;;1267         status = HAL_ERROR;
;;;1268         break;
;;;1269       case DMA_FIFO_THRESHOLD_HALFFULL:
;;;1270         if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
;;;1271         {
;;;1272           status = HAL_ERROR;
;;;1273         }
;;;1274         break;
;;;1275       case DMA_FIFO_THRESHOLD_FULL:
;;;1276         if (hdma->Init.MemBurst == DMA_MBURST_INC16)
;;;1277         {
;;;1278           status = HAL_ERROR;
;;;1279         }
;;;1280         break;   
;;;1281       default:
;;;1282         break;
;;;1283       }
;;;1284     }
;;;1285     
;;;1286     /* Memory Data size equal to Word */
;;;1287     else
;;;1288     {
;;;1289       switch (tmp)
000016  b172              CBZ      r2,|L2.54|
000018  2a01              CMP      r2,#1
00001a  d00c              BEQ      |L2.54|
00001c  2a02              CMP      r2,#2
00001e  d00a              BEQ      |L2.54|
000020  2a03              CMP      r2,#3
000022  d109              BNE      |L2.56|
000024  e004              B        |L2.48|
                  |L2.38|
000026  b11a              CBZ      r2,|L2.48|
000028  2a01              CMP      r2,#1                 ;1238
00002a  d006              BEQ      |L2.58|
00002c  2a02              CMP      r2,#2                 ;1238
00002e  d103              BNE      |L2.56|
                  |L2.48|
000030  6ac9              LDR      r1,[r1,#0x2c]         ;1242
000032  01c9              LSLS     r1,r1,#7              ;1242
000034  d500              BPL      |L2.56|
                  |L2.54|
000036  2001              MOVS     r0,#1                 ;1244
                  |L2.56|
;;;1290       {
;;;1291       case DMA_FIFO_THRESHOLD_1QUARTERFULL:
;;;1292       case DMA_FIFO_THRESHOLD_HALFFULL:
;;;1293       case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
;;;1294         status = HAL_ERROR;
;;;1295         break;
;;;1296       case DMA_FIFO_THRESHOLD_FULL:
;;;1297         if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
;;;1298         {
;;;1299           status = HAL_ERROR;
;;;1300         }
;;;1301         break;
;;;1302       default:
;;;1303         break;
;;;1304       }
;;;1305     } 
;;;1306     
;;;1307     return status; 
;;;1308   }
000038  bd10              POP      {r4,pc}
                  |L2.58|
00003a  6ac9              LDR      r1,[r1,#0x2c]         ;1248
00003c  42a1              CMP      r1,r4                 ;1248
00003e  d0fa              BEQ      |L2.54|
000040  bd10              POP      {r4,pc}
                  |L2.66|
000042  2a00              CMP      r2,#0                 ;1263
000044  d0f7              BEQ      |L2.54|
000046  2a01              CMP      r2,#1                 ;1263
000048  d0f2              BEQ      |L2.48|
00004a  2a02              CMP      r2,#2                 ;1263
00004c  d0f3              BEQ      |L2.54|
00004e  2a03              CMP      r2,#3                 ;1263
000050  d0f3              BEQ      |L2.58|
000052  bd10              POP      {r4,pc}
;;;1309   
                          ENDP


                          AREA ||i.DMA_SetConfig||, CODE, READONLY, ALIGN=1

                  DMA_SetConfig PROC
;;;1167     */
;;;1168   static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
000000  b530              PUSH     {r4,r5,lr}
;;;1169   {
;;;1170     /* Clear DBM bit */
;;;1171     hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
000002  6804              LDR      r4,[r0,#0]
000004  6825              LDR      r5,[r4,#0]
000006  f4252580          BIC      r5,r5,#0x40000
00000a  6025              STR      r5,[r4,#0]
;;;1172   
;;;1173     /* Configure DMA Stream data length */
;;;1174     hdma->Instance->NDTR = DataLength;
00000c  6804              LDR      r4,[r0,#0]
00000e  6063              STR      r3,[r4,#4]
;;;1175   
;;;1176     /* Memory to Peripheral */
;;;1177     if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
000010  6883              LDR      r3,[r0,#8]
000012  2b40              CMP      r3,#0x40
000014  6803              LDR      r3,[r0,#0]            ;1169
000016  d003              BEQ      |L3.32|
;;;1178     {
;;;1179       /* Configure DMA Stream destination address */
;;;1180       hdma->Instance->PAR = DstAddress;
;;;1181   
;;;1182       /* Configure DMA Stream source address */
;;;1183       hdma->Instance->M0AR = SrcAddress;
;;;1184     }
;;;1185     /* Peripheral to Memory */
;;;1186     else
;;;1187     {
;;;1188       /* Configure DMA Stream source address */
;;;1189       hdma->Instance->PAR = SrcAddress;
000018  6099              STR      r1,[r3,#8]
;;;1190   
;;;1191       /* Configure DMA Stream destination address */
;;;1192       hdma->Instance->M0AR = DstAddress;
00001a  6800              LDR      r0,[r0,#0]
00001c  60c2              STR      r2,[r0,#0xc]
;;;1193     }
;;;1194   }
00001e  bd30              POP      {r4,r5,pc}
                  |L3.32|
000020  609a              STR      r2,[r3,#8]            ;1180
000022  6800              LDR      r0,[r0,#0]            ;1183
000024  60c1              STR      r1,[r0,#0xc]          ;1183
000026  bd30              POP      {r4,r5,pc}
;;;1195   
                          ENDP


                          AREA ||i.HAL_DMA_Abort||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Abort PROC
;;;531      */
;;;532    HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;533    {
;;;534      /* calculate DMA base and stream number */
;;;535      DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
;;;536      
;;;537      uint32_t tickstart = HAL_GetTick();
000004  6dc7              LDR      r7,[r0,#0x5c]
000006  4604              MOV      r4,r0                 ;533
000008  f7fffffe          BL       HAL_GetTick
00000c  4606              MOV      r6,r0
;;;538      
;;;539      if(hdma->State != HAL_DMA_STATE_BUSY)
00000e  6ba0              LDR      r0,[r4,#0x38]
000010  2500              MOVS     r5,#0
000012  2802              CMP      r0,#2
000014  d005              BEQ      |L4.34|
;;;540      {
;;;541        hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
000016  2080              MOVS     r0,#0x80
000018  65a0              STR      r0,[r4,#0x58]
;;;542        
;;;543        /* Process Unlocked */
;;;544        __HAL_UNLOCK(hdma);
;;;545        
;;;546        return HAL_ERROR;
00001a  2001              MOVS     r0,#1
00001c  6365              STR      r5,[r4,#0x34]
                  |L4.30|
;;;547      }
;;;548      else
;;;549      {
;;;550        /* Disable all the transfer interrupts */
;;;551        hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
;;;552        hdma->Instance->FCR &= ~(DMA_IT_FE);
;;;553        
;;;554        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
;;;555        {
;;;556          hdma->Instance->CR  &= ~(DMA_IT_HT);
;;;557        }
;;;558        
;;;559        /* Disable the stream */
;;;560        __HAL_DMA_DISABLE(hdma);
;;;561        
;;;562        /* Check if the DMA Stream is effectively disabled */
;;;563        while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
;;;564        {
;;;565          /* Check for the Timeout */
;;;566          if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
;;;567          {
;;;568            /* Update error code */
;;;569            hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
;;;570            
;;;571            /* Process Unlocked */
;;;572            __HAL_UNLOCK(hdma);
;;;573            
;;;574            /* Change the DMA state */
;;;575            hdma->State = HAL_DMA_STATE_TIMEOUT;
;;;576            
;;;577            return HAL_TIMEOUT;
;;;578          }
;;;579        }
;;;580        
;;;581        /* Clear all interrupt flags at correct offset within the register */
;;;582        regs->IFCR = 0x3FU << hdma->StreamIndex;
;;;583        
;;;584        /* Process Unlocked */
;;;585        __HAL_UNLOCK(hdma);
;;;586        
;;;587        /* Change the DMA state*/
;;;588        hdma->State = HAL_DMA_STATE_READY;
;;;589      }
;;;590      return HAL_OK;
;;;591    }
00001e  e8bd81f0          POP      {r4-r8,pc}
                  |L4.34|
000022  6820              LDR      r0,[r4,#0]            ;551
000024  6801              LDR      r1,[r0,#0]            ;551
000026  f0210116          BIC      r1,r1,#0x16           ;551
00002a  6001              STR      r1,[r0,#0]            ;551
00002c  6820              LDR      r0,[r4,#0]            ;552
00002e  6941              LDR      r1,[r0,#0x14]         ;552
000030  f0210180          BIC      r1,r1,#0x80           ;552
000034  6141              STR      r1,[r0,#0x14]         ;552
000036  6c60              LDR      r0,[r4,#0x44]         ;554
000038  b908              CBNZ     r0,|L4.62|
00003a  6ce0              LDR      r0,[r4,#0x4c]         ;554
00003c  b120              CBZ      r0,|L4.72|
                  |L4.62|
00003e  6820              LDR      r0,[r4,#0]            ;556
000040  6801              LDR      r1,[r0,#0]            ;556
000042  f0210108          BIC      r1,r1,#8              ;556
000046  6001              STR      r1,[r0,#0]            ;556
                  |L4.72|
000048  6820              LDR      r0,[r4,#0]            ;560
00004a  6801              LDR      r1,[r0,#0]            ;560
00004c  f0210101          BIC      r1,r1,#1              ;560
000050  6001              STR      r1,[r0,#0]            ;560
000052  e00a              B        |L4.106|
                  |L4.84|
000054  f7fffffe          BL       HAL_GetTick
000058  1b80              SUBS     r0,r0,r6              ;566
00005a  2805              CMP      r0,#5                 ;566
00005c  d905              BLS      |L4.106|
00005e  2120              MOVS     r1,#0x20              ;569
000060  65a1              STR      r1,[r4,#0x58]         ;569
000062  2003              MOVS     r0,#3                 ;575
000064  e9c4500d          STRD     r5,r0,[r4,#0x34]      ;575
000068  e7d9              B        |L4.30|
                  |L4.106|
00006a  6820              LDR      r0,[r4,#0]            ;563
00006c  6800              LDR      r0,[r0,#0]            ;563
00006e  07c0              LSLS     r0,r0,#31             ;563
000070  d1f0              BNE      |L4.84|
000072  f8942060          LDRB     r2,[r4,#0x60]         ;582
000076  203f              MOVS     r0,#0x3f              ;582
000078  2101              MOVS     r1,#1                 ;588
00007a  4090              LSLS     r0,r0,r2              ;582
00007c  60b8              STR      r0,[r7,#8]            ;582
00007e  e9c4510d          STRD     r5,r1,[r4,#0x34]      ;588
000082  2000              MOVS     r0,#0                 ;590
000084  e7cb              B        |L4.30|
;;;592    
                          ENDP


                          AREA ||i.HAL_DMA_Abort_IT||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Abort_IT PROC
;;;598      */
;;;599    HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
000000  6b81              LDR      r1,[r0,#0x38]
;;;600    {
;;;601      if(hdma->State != HAL_DMA_STATE_BUSY)
000002  2902              CMP      r1,#2
000004  d003              BEQ      |L5.14|
;;;602      {
;;;603        hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
000006  2180              MOVS     r1,#0x80
000008  6581              STR      r1,[r0,#0x58]
;;;604        return HAL_ERROR;
00000a  2001              MOVS     r0,#1
;;;605      }
;;;606      else
;;;607      {
;;;608        /* Set Abort State  */
;;;609        hdma->State = HAL_DMA_STATE_ABORT;
;;;610        
;;;611        /* Disable the stream */
;;;612        __HAL_DMA_DISABLE(hdma);
;;;613      }
;;;614    
;;;615      return HAL_OK;
;;;616    }
00000c  4770              BX       lr
                  |L5.14|
00000e  2105              MOVS     r1,#5                 ;609
000010  6381              STR      r1,[r0,#0x38]         ;609
000012  6800              LDR      r0,[r0,#0]            ;612
000014  6801              LDR      r1,[r0,#0]            ;612
000016  f0210101          BIC      r1,r1,#1              ;612
00001a  6001              STR      r1,[r0,#0]            ;612
00001c  2000              MOVS     r0,#0                 ;615
00001e  4770              BX       lr
;;;617    
                          ENDP


                          AREA ||i.HAL_DMA_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_DMA_DeInit PROC
;;;326      */
;;;327    HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;328    {
000002  0004              MOVS     r4,r0
000004  d028              BEQ      |L6.88|
;;;329      DMA_Base_Registers *regs;
;;;330    
;;;331      /* Check the DMA peripheral state */
;;;332      if(hdma == NULL)
;;;333      {
;;;334        return HAL_ERROR;
;;;335      }
;;;336      
;;;337      /* Check the DMA peripheral state */
;;;338      if(hdma->State == HAL_DMA_STATE_BUSY)
000006  6ba0              LDR      r0,[r4,#0x38]
000008  2802              CMP      r0,#2
00000a  d024              BEQ      |L6.86|
;;;339      {
;;;340        /* Return error status */
;;;341        return HAL_BUSY;
;;;342      }
;;;343    
;;;344      /* Check the parameters */
;;;345      assert_param(IS_DMA_STREAM_ALL_INSTANCE(hdma->Instance));
;;;346    
;;;347      /* Disable the selected DMA Streamx */
;;;348      __HAL_DMA_DISABLE(hdma);
00000c  6820              LDR      r0,[r4,#0]
;;;349    
;;;350      /* Reset DMA Streamx control register */
;;;351      hdma->Instance->CR   = 0U;
00000e  2500              MOVS     r5,#0
;;;352    
;;;353      /* Reset DMA Streamx number of data to transfer register */
;;;354      hdma->Instance->NDTR = 0U;
;;;355    
;;;356      /* Reset DMA Streamx peripheral address register */
;;;357      hdma->Instance->PAR  = 0U;
;;;358    
;;;359      /* Reset DMA Streamx memory 0 address register */
;;;360      hdma->Instance->M0AR = 0U;
;;;361      
;;;362      /* Reset DMA Streamx memory 1 address register */
;;;363      hdma->Instance->M1AR = 0U;
;;;364      
;;;365      /* Reset DMA Streamx FIFO control register */
;;;366      hdma->Instance->FCR  = (uint32_t)0x00000021U;
000010  2221              MOVS     r2,#0x21
000012  6801              LDR      r1,[r0,#0]            ;348
000014  f0210101          BIC      r1,r1,#1              ;348
000018  6001              STR      r1,[r0,#0]            ;348
00001a  6820              LDR      r0,[r4,#0]            ;351
00001c  6005              STR      r5,[r0,#0]            ;351
00001e  6820              LDR      r0,[r4,#0]            ;354
000020  6045              STR      r5,[r0,#4]            ;354
000022  6820              LDR      r0,[r4,#0]            ;357
000024  6085              STR      r5,[r0,#8]            ;357
000026  6820              LDR      r0,[r4,#0]            ;360
000028  60c5              STR      r5,[r0,#0xc]          ;360
00002a  6820              LDR      r0,[r4,#0]            ;363
00002c  6105              STR      r5,[r0,#0x10]         ;363
00002e  6820              LDR      r0,[r4,#0]
000030  6142              STR      r2,[r0,#0x14]
;;;367      
;;;368      /* Get DMA steam Base Address */  
;;;369      regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       DMA_CalcBaseAndBitshift
;;;370      
;;;371      /* Clear all interrupt flags at correct offset within the register */
;;;372      regs->IFCR = 0x3FU << hdma->StreamIndex;
000038  f8942060          LDRB     r2,[r4,#0x60]
00003c  213f              MOVS     r1,#0x3f
00003e  4091              LSLS     r1,r1,r2
000040  6081              STR      r1,[r0,#8]
;;;373      
;;;374      /* Clean all callbacks */
;;;375      hdma->XferCpltCallback = NULL;
;;;376      hdma->XferHalfCpltCallback = NULL;
000042  6425              STR      r5,[r4,#0x40]
;;;377      hdma->XferM1CpltCallback = NULL;
000044  6465              STR      r5,[r4,#0x44]
;;;378      hdma->XferM1HalfCpltCallback = NULL;
000046  64a5              STR      r5,[r4,#0x48]
;;;379      hdma->XferErrorCallback = NULL;
000048  64e5              STR      r5,[r4,#0x4c]
;;;380      hdma->XferAbortCallback = NULL;  
00004a  6525              STR      r5,[r4,#0x50]
;;;381    
;;;382      /* Reset the error code */
;;;383      hdma->ErrorCode = HAL_DMA_ERROR_NONE;
00004c  6565              STR      r5,[r4,#0x54]
00004e  65a5              STR      r5,[r4,#0x58]
;;;384    
;;;385      /* Reset the DMA state */
;;;386      hdma->State = HAL_DMA_STATE_RESET;
000050  63a5              STR      r5,[r4,#0x38]
;;;387    
;;;388      /* Release Lock */
;;;389      __HAL_UNLOCK(hdma);
;;;390    
;;;391      return HAL_OK;
000052  2000              MOVS     r0,#0
000054  6365              STR      r5,[r4,#0x34]
                  |L6.86|
;;;392    }
000056  bd70              POP      {r4-r6,pc}
                  |L6.88|
000058  2001              MOVS     r0,#1                 ;334
00005a  bd70              POP      {r4-r6,pc}
;;;393    
                          ENDP


                          AREA ||i.HAL_DMA_GetError||, CODE, READONLY, ALIGN=1

                  HAL_DMA_GetError PROC
;;;1141     */
;;;1142   uint32_t HAL_DMA_GetError(DMA_HandleTypeDef *hdma)
000000  6d80              LDR      r0,[r0,#0x58]
;;;1143   {
;;;1144     return hdma->ErrorCode;
;;;1145   }
000002  4770              BX       lr
;;;1146   
                          ENDP


                          AREA ||i.HAL_DMA_GetState||, CODE, READONLY, ALIGN=1

                  HAL_DMA_GetState PROC
;;;1130     */
;;;1131   HAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef *hdma)
000000  6b80              LDR      r0,[r0,#0x38]
;;;1132   {
;;;1133     return hdma->State;
;;;1134   }
000002  4770              BX       lr
;;;1135   
                          ENDP


                          AREA ||i.HAL_DMA_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_DMA_IRQHandler PROC
;;;764      */
;;;765    void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;766    {
000004  4604              MOV      r4,r0
;;;767      uint32_t tmpisr;
;;;768      __IO uint32_t count = 0;
000006  f04f0900          MOV      r9,#0
;;;769      uint32_t timeout = SystemCoreClock / 9600;
00000a  4b60              LDR      r3,|L9.396|
;;;770    
;;;771      /* calculate DMA base and stream number */
;;;772      DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
;;;773    
;;;774      tmpisr = regs->ISR;
;;;775    
;;;776      /* Transfer Error Interrupt management ***************************************/
;;;777      if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
00000c  2008              MOVS     r0,#8
00000e  f8cd9000          STR      r9,[sp,#0]            ;772
000012  f44f5216          MOV      r2,#0x2580            ;769
000016  6de5              LDR      r5,[r4,#0x5c]         ;769
000018  f8941060          LDRB     r1,[r4,#0x60]
00001c  681b              LDR      r3,[r3,#0]            ;769  ; SystemCoreClock
00001e  682e              LDR      r6,[r5,#0]            ;774
000020  fbb3f7f2          UDIV     r7,r3,r2              ;769
000024  fa00f101          LSL      r1,r0,r1
000028  4231              TST      r1,r6
00002a  d00f              BEQ      |L9.76|
;;;778      {
;;;779        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
00002c  6821              LDR      r1,[r4,#0]
00002e  680a              LDR      r2,[r1,#0]
000030  0752              LSLS     r2,r2,#29
000032  d50b              BPL      |L9.76|
;;;780        {
;;;781          /* Disable the transfer error interrupt */
;;;782          hdma->Instance->CR  &= ~(DMA_IT_TE);
000034  680a              LDR      r2,[r1,#0]
000036  f0220204          BIC      r2,r2,#4
00003a  600a              STR      r2,[r1,#0]
;;;783          
;;;784          /* Clear the transfer error flag */
;;;785          regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
00003c  f8941060          LDRB     r1,[r4,#0x60]
000040  4088              LSLS     r0,r0,r1
000042  60a8              STR      r0,[r5,#8]
;;;786          
;;;787          /* Update error code */
;;;788          hdma->ErrorCode |= HAL_DMA_ERROR_TE;
000044  6da0              LDR      r0,[r4,#0x58]
000046  f0400001          ORR      r0,r0,#1
00004a  65a0              STR      r0,[r4,#0x58]
                  |L9.76|
;;;789        }
;;;790      }
;;;791      /* FIFO Error Interrupt management ******************************************/
;;;792      if ((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
00004c  f8941060          LDRB     r1,[r4,#0x60]
000050  f04f0801          MOV      r8,#1
000054  fa08f001          LSL      r0,r8,r1
000058  4230              TST      r0,r6
00005a  d008              BEQ      |L9.110|
;;;793      {
;;;794        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
00005c  6821              LDR      r1,[r4,#0]
00005e  6949              LDR      r1,[r1,#0x14]
000060  0609              LSLS     r1,r1,#24
000062  d504              BPL      |L9.110|
;;;795        {
;;;796          /* Clear the FIFO error flag */
;;;797          regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
000064  60a8              STR      r0,[r5,#8]
;;;798    
;;;799          /* Update error code */
;;;800          hdma->ErrorCode |= HAL_DMA_ERROR_FE;
000066  6da0              LDR      r0,[r4,#0x58]
000068  f0400002          ORR      r0,r0,#2
00006c  65a0              STR      r0,[r4,#0x58]
                  |L9.110|
;;;801        }
;;;802      }
;;;803      /* Direct Mode Error Interrupt management ***********************************/
;;;804      if ((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
00006e  f8941060          LDRB     r1,[r4,#0x60]
000072  2004              MOVS     r0,#4
000074  4088              LSLS     r0,r0,r1
000076  4230              TST      r0,r6
000078  d008              BEQ      |L9.140|
;;;805      {
;;;806        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
00007a  6821              LDR      r1,[r4,#0]
00007c  6809              LDR      r1,[r1,#0]
00007e  0789              LSLS     r1,r1,#30
000080  d504              BPL      |L9.140|
;;;807        {
;;;808          /* Clear the direct mode error flag */
;;;809          regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
000082  60a8              STR      r0,[r5,#8]
;;;810    
;;;811          /* Update error code */
;;;812          hdma->ErrorCode |= HAL_DMA_ERROR_DME;
000084  6da0              LDR      r0,[r4,#0x58]
000086  f0400004          ORR      r0,r0,#4
00008a  65a0              STR      r0,[r4,#0x58]
                  |L9.140|
;;;813        }
;;;814      }
;;;815      /* Half Transfer Complete Interrupt management ******************************/
;;;816      if ((tmpisr & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)
00008c  f8941060          LDRB     r1,[r4,#0x60]
000090  2010              MOVS     r0,#0x10
000092  4088              LSLS     r0,r0,r1
000094  4230              TST      r0,r6
000096  d018              BEQ      |L9.202|
;;;817      {
;;;818        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
000098  6821              LDR      r1,[r4,#0]
00009a  6809              LDR      r1,[r1,#0]
00009c  0709              LSLS     r1,r1,#28
00009e  d514              BPL      |L9.202|
;;;819        {
;;;820          /* Clear the half transfer complete flag */
;;;821          regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
0000a0  60a8              STR      r0,[r5,#8]
;;;822          
;;;823          /* Multi_Buffering mode enabled */
;;;824          if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
0000a2  6820              LDR      r0,[r4,#0]
0000a4  6801              LDR      r1,[r0,#0]
0000a6  0349              LSLS     r1,r1,#13
0000a8  d504              BPL      |L9.180|
;;;825          {
;;;826            /* Current memory buffer used is Memory 0 */
;;;827            if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
0000aa  6800              LDR      r0,[r0,#0]
0000ac  0300              LSLS     r0,r0,#12
0000ae  d508              BPL      |L9.194|
;;;828            {
;;;829              if(hdma->XferHalfCpltCallback != NULL)
;;;830              {
;;;831                /* Half transfer callback */
;;;832                hdma->XferHalfCpltCallback(hdma);
;;;833              }
;;;834            }
;;;835            /* Current memory buffer used is Memory 1 */
;;;836            else
;;;837            {
;;;838              if(hdma->XferM1HalfCpltCallback != NULL)
0000b0  6ce1              LDR      r1,[r4,#0x4c]
0000b2  e007              B        |L9.196|
                  |L9.180|
;;;839              {
;;;840                /* Half transfer callback */
;;;841                hdma->XferM1HalfCpltCallback(hdma);
;;;842              }
;;;843            }
;;;844          }
;;;845          else
;;;846          {
;;;847            /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
;;;848            if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
0000b4  6801              LDR      r1,[r0,#0]
0000b6  05c9              LSLS     r1,r1,#23
0000b8  d403              BMI      |L9.194|
;;;849            {
;;;850              /* Disable the half transfer interrupt */
;;;851              hdma->Instance->CR  &= ~(DMA_IT_HT);
0000ba  6801              LDR      r1,[r0,#0]
0000bc  f0210108          BIC      r1,r1,#8
0000c0  6001              STR      r1,[r0,#0]
                  |L9.194|
;;;852            }
;;;853            
;;;854            if(hdma->XferHalfCpltCallback != NULL)
0000c2  6c61              LDR      r1,[r4,#0x44]
                  |L9.196|
0000c4  b109              CBZ      r1,|L9.202|
;;;855            {
;;;856              /* Half transfer callback */
;;;857              hdma->XferHalfCpltCallback(hdma);
0000c6  4620              MOV      r0,r4
0000c8  4788              BLX      r1
                  |L9.202|
;;;858            }
;;;859          }
;;;860        }
;;;861      }
;;;862      /* Transfer Complete Interrupt management ***********************************/
;;;863      if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
0000ca  f8941060          LDRB     r1,[r4,#0x60]
0000ce  2020              MOVS     r0,#0x20
0000d0  4088              LSLS     r0,r0,r1
0000d2  4230              TST      r0,r6
0000d4  d02e              BEQ      |L9.308|
;;;864      {
;;;865        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
0000d6  6821              LDR      r1,[r4,#0]
0000d8  6809              LDR      r1,[r1,#0]
0000da  06c9              LSLS     r1,r1,#27
0000dc  d52a              BPL      |L9.308|
;;;866        {
;;;867          /* Clear the transfer complete flag */
;;;868          regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
0000de  60a8              STR      r0,[r5,#8]
;;;869          
;;;870          if(HAL_DMA_STATE_ABORT == hdma->State)
0000e0  6ba0              LDR      r0,[r4,#0x38]
0000e2  2805              CMP      r0,#5
;;;871          {
;;;872            /* Disable all the transfer interrupts */
;;;873            hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
;;;874            hdma->Instance->FCR &= ~(DMA_IT_FE);
;;;875            
;;;876            if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
;;;877            {
;;;878              hdma->Instance->CR  &= ~(DMA_IT_HT);
;;;879            }
;;;880    
;;;881            /* Clear all interrupt flags at correct offset within the register */
;;;882            regs->IFCR = 0x3FU << hdma->StreamIndex;
;;;883    
;;;884            /* Process Unlocked */
;;;885            __HAL_UNLOCK(hdma);
;;;886    
;;;887            /* Change the DMA state */
;;;888            hdma->State = HAL_DMA_STATE_READY;
;;;889    
;;;890            if(hdma->XferAbortCallback != NULL)
;;;891            {
;;;892              hdma->XferAbortCallback(hdma);
;;;893            }
;;;894            return;
;;;895          }
;;;896    
;;;897          if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
0000e4  6820              LDR      r0,[r4,#0]
0000e6  6801              LDR      r1,[r0,#0]
0000e8  d006              BEQ      |L9.248|
0000ea  0349              LSLS     r1,r1,#13
0000ec  d542              BPL      |L9.372|
;;;898          {
;;;899            /* Current memory buffer used is Memory 0 */
;;;900            if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
0000ee  6800              LDR      r0,[r0,#0]
0000f0  0300              LSLS     r0,r0,#12
0000f2  d41b              BMI      |L9.300|
;;;901            {
;;;902              if(hdma->XferM1CpltCallback != NULL)
0000f4  6ca1              LDR      r1,[r4,#0x48]
0000f6  e01a              B        |L9.302|
                  |L9.248|
0000f8  f0210116          BIC      r1,r1,#0x16           ;873
0000fc  6001              STR      r1,[r0,#0]            ;873
0000fe  6820              LDR      r0,[r4,#0]            ;874
000100  6941              LDR      r1,[r0,#0x14]         ;874
000102  f0210180          BIC      r1,r1,#0x80           ;874
000106  6141              STR      r1,[r0,#0x14]         ;874
000108  6c60              LDR      r0,[r4,#0x44]         ;876
00010a  b908              CBNZ     r0,|L9.272|
00010c  6ce0              LDR      r0,[r4,#0x4c]         ;876
00010e  b120              CBZ      r0,|L9.282|
                  |L9.272|
000110  6820              LDR      r0,[r4,#0]            ;878
000112  6801              LDR      r1,[r0,#0]            ;878
000114  f0210108          BIC      r1,r1,#8              ;878
000118  6001              STR      r1,[r0,#0]            ;878
                  |L9.282|
00011a  f8943060          LDRB     r3,[r4,#0x60]         ;882
00011e  223f              MOVS     r2,#0x3f              ;882
000120  409a              LSLS     r2,r2,r3              ;882
000122  60aa              STR      r2,[r5,#8]            ;882
000124  e9c4980d          STRD     r9,r8,[r4,#0x34]      ;888
000128  6d61              LDR      r1,[r4,#0x54]         ;890
00012a  e01c              B        |L9.358|
                  |L9.300|
;;;903              {
;;;904                /* Transfer complete Callback for memory1 */
;;;905                hdma->XferM1CpltCallback(hdma);
;;;906              }
;;;907            }
;;;908            /* Current memory buffer used is Memory 1 */
;;;909            else
;;;910            {
;;;911              if(hdma->XferCpltCallback != NULL)
00012c  6c21              LDR      r1,[r4,#0x40]
                  |L9.302|
00012e  b109              CBZ      r1,|L9.308|
;;;912              {
;;;913                /* Transfer complete Callback for memory0 */
;;;914                hdma->XferCpltCallback(hdma);
;;;915              }
;;;916            }
;;;917          }
;;;918          /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */
;;;919          else
;;;920          {
;;;921            if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
;;;922            {
;;;923              /* Disable the transfer complete interrupt */
;;;924              hdma->Instance->CR  &= ~(DMA_IT_TC);
;;;925    
;;;926              /* Process Unlocked */
;;;927              __HAL_UNLOCK(hdma);
;;;928    
;;;929              /* Change the DMA state */
;;;930              hdma->State = HAL_DMA_STATE_READY;
;;;931            }
;;;932    
;;;933            if(hdma->XferCpltCallback != NULL)
;;;934            {
;;;935              /* Transfer complete callback */
;;;936              hdma->XferCpltCallback(hdma);
000130  4620              MOV      r0,r4
000132  4788              BLX      r1
                  |L9.308|
;;;937            }
;;;938          }
;;;939        }
;;;940      }
;;;941      
;;;942      /* manage error case */
;;;943      if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
000134  6da0              LDR      r0,[r4,#0x58]
000136  2800              CMP      r0,#0
000138  d026              BEQ      |L9.392|
;;;944      {
;;;945        if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
00013a  6da0              LDR      r0,[r4,#0x58]
00013c  07c0              LSLS     r0,r0,#31
00013e  d011              BEQ      |L9.356|
;;;946        {
;;;947          hdma->State = HAL_DMA_STATE_ABORT;
000140  2005              MOVS     r0,#5
000142  63a0              STR      r0,[r4,#0x38]
;;;948    
;;;949          /* Disable the stream */
;;;950          __HAL_DMA_DISABLE(hdma);
000144  6820              LDR      r0,[r4,#0]
000146  6801              LDR      r1,[r0,#0]
000148  f0210101          BIC      r1,r1,#1
00014c  6001              STR      r1,[r0,#0]
                  |L9.334|
;;;951    
;;;952          do
;;;953          {
;;;954            if (++count > timeout)
00014e  9800              LDR      r0,[sp,#0]
000150  1c40              ADDS     r0,r0,#1
000152  9000              STR      r0,[sp,#0]
000154  42b8              CMP      r0,r7
000156  d803              BHI      |L9.352|
;;;955            {
;;;956              break;
;;;957            }
;;;958          }
;;;959          while((hdma->Instance->CR & DMA_SxCR_EN) != RESET);
000158  6820              LDR      r0,[r4,#0]
00015a  6800              LDR      r0,[r0,#0]
00015c  07c0              LSLS     r0,r0,#31
00015e  d1f6              BNE      |L9.334|
                  |L9.352|
;;;960    
;;;961          /* Process Unlocked */
;;;962          __HAL_UNLOCK(hdma);
;;;963    
;;;964          /* Change the DMA state */
;;;965          hdma->State = HAL_DMA_STATE_READY;
000160  e9c4980d          STRD     r9,r8,[r4,#0x34]
                  |L9.356|
;;;966        }
;;;967    
;;;968        if(hdma->XferErrorCallback != NULL)
000164  6d21              LDR      r1,[r4,#0x50]
                  |L9.358|
000166  2900              CMP      r1,#0
000168  d00e              BEQ      |L9.392|
;;;969        {
;;;970          /* Transfer error callback */
;;;971          hdma->XferErrorCallback(hdma);
00016a  b001              ADD      sp,sp,#4
00016c  4620              MOV      r0,r4
00016e  e8bd43f0          POP      {r4-r9,lr}
000172  4708              BX       r1
                  |L9.372|
000174  6801              LDR      r1,[r0,#0]            ;921
000176  05c9              LSLS     r1,r1,#23             ;921
000178  d4d8              BMI      |L9.300|
00017a  6803              LDR      r3,[r0,#0]            ;924
00017c  f0230310          BIC      r3,r3,#0x10           ;924
000180  6003              STR      r3,[r0,#0]            ;924
000182  e9c4980d          STRD     r9,r8,[r4,#0x34]      ;930
000186  e7d1              B        |L9.300|
                  |L9.392|
;;;972        }
;;;973      }
;;;974    }
000188  e8bd83f8          POP      {r3-r9,pc}
;;;975    
                          ENDP

                  |L9.396|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_DMA_Init||, CODE, READONLY, ALIGN=2

                  HAL_DMA_Init PROC
;;;187      */
;;;188    HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;189    {
000004  4604              MOV      r4,r0
;;;190      uint32_t tmp = 0U;
;;;191      uint32_t tickstart = HAL_GetTick();
000006  f7fffffe          BL       HAL_GetTick
00000a  4605              MOV      r5,r0
;;;192      DMA_Base_Registers *regs;
;;;193    
;;;194      /* Check the DMA peripheral state */
;;;195      if(hdma == NULL)
00000c  b154              CBZ      r4,|L10.36|
;;;196      {
;;;197        return HAL_ERROR;
;;;198      }
;;;199    
;;;200      /* Check the parameters */
;;;201      assert_param(IS_DMA_STREAM_ALL_INSTANCE(hdma->Instance));
;;;202      assert_param(IS_DMA_CHANNEL(hdma->Init.Channel));
;;;203      assert_param(IS_DMA_DIRECTION(hdma->Init.Direction));
;;;204      assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));
;;;205      assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));
;;;206      assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
;;;207      assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
;;;208      assert_param(IS_DMA_MODE(hdma->Init.Mode));
;;;209      assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
;;;210      assert_param(IS_DMA_FIFO_MODE_STATE(hdma->Init.FIFOMode));
;;;211      /* Check the memory burst, peripheral burst and FIFO threshold parameters only
;;;212         when FIFO mode is enabled */
;;;213      if(hdma->Init.FIFOMode != DMA_FIFOMODE_DISABLE)
;;;214      {
;;;215        assert_param(IS_DMA_FIFO_THRESHOLD(hdma->Init.FIFOThreshold));
;;;216        assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
;;;217        assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
;;;218      }
;;;219      
;;;220      /* Allocate lock resource */
;;;221      __HAL_UNLOCK(hdma);
;;;222    
;;;223      /* Change DMA peripheral state */
;;;224      hdma->State = HAL_DMA_STATE_BUSY;
00000e  2102              MOVS     r1,#2
000010  f04f0900          MOV      r9,#0                 ;221
000014  e9c4910d          STRD     r9,r1,[r4,#0x34]
;;;225      
;;;226      /* Disable the peripheral */
;;;227      __HAL_DMA_DISABLE(hdma);
000018  6820              LDR      r0,[r4,#0]
00001a  6801              LDR      r1,[r0,#0]
00001c  f0210101          BIC      r1,r1,#1
000020  6001              STR      r1,[r0,#0]
000022  e00d              B        |L10.64|
                  |L10.36|
000024  2001              MOVS     r0,#1                 ;197
                  |L10.38|
;;;228      
;;;229      /* Check if the DMA Stream is effectively disabled */
;;;230      while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
;;;231      {
;;;232        /* Check for the Timeout */
;;;233        if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
;;;234        {
;;;235          /* Update error code */
;;;236          hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
;;;237          
;;;238          /* Change the DMA state */
;;;239          hdma->State = HAL_DMA_STATE_TIMEOUT;
;;;240          
;;;241          return HAL_TIMEOUT;
;;;242        }
;;;243      }
;;;244      
;;;245      /* Get the CR register value */
;;;246      tmp = hdma->Instance->CR;
;;;247    
;;;248      /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */
;;;249      tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
;;;250                          DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
;;;251                          DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
;;;252                          DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));
;;;253    
;;;254      /* Prepare the DMA Stream configuration */
;;;255      tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
;;;256              hdma->Init.PeriphInc           | hdma->Init.MemInc           |
;;;257              hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
;;;258              hdma->Init.Mode                | hdma->Init.Priority;
;;;259    
;;;260      /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
;;;261      if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
;;;262      {
;;;263        /* Get memory burst and peripheral burst */
;;;264        tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
;;;265      }
;;;266      
;;;267      /* Write to DMA Stream CR register */
;;;268      hdma->Instance->CR = tmp;  
;;;269    
;;;270      /* Get the FCR register value */
;;;271      tmp = hdma->Instance->FCR;
;;;272    
;;;273      /* Clear Direct mode and FIFO threshold bits */
;;;274      tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
;;;275    
;;;276      /* Prepare the DMA Stream FIFO configuration */
;;;277      tmp |= hdma->Init.FIFOMode;
;;;278    
;;;279      /* The FIFO threshold is not used when the FIFO mode is disabled */
;;;280      if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
;;;281      {
;;;282        /* Get the FIFO threshold */
;;;283        tmp |= hdma->Init.FIFOThreshold;
;;;284        
;;;285        /* Check compatibility between FIFO threshold level and size of the memory burst */
;;;286        /* for INCR4, INCR8, INCR16 bursts */
;;;287        if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
;;;288        {
;;;289          if (DMA_CheckFifoParam(hdma) != HAL_OK)
;;;290          {
;;;291            /* Update error code */
;;;292            hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
;;;293            
;;;294            /* Change the DMA state */
;;;295            hdma->State = HAL_DMA_STATE_READY;
;;;296            
;;;297            return HAL_ERROR; 
;;;298          }
;;;299        }
;;;300      }
;;;301      
;;;302      /* Write to DMA Stream FCR */
;;;303      hdma->Instance->FCR = tmp;
;;;304    
;;;305      /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
;;;306         DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
;;;307      regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
;;;308      
;;;309      /* Clear all interrupt flags */
;;;310      regs->IFCR = 0x3FU << hdma->StreamIndex;
;;;311    
;;;312      /* Initialize the error code */
;;;313      hdma->ErrorCode = HAL_DMA_ERROR_NONE;
;;;314                                                                                         
;;;315      /* Initialize the DMA state */
;;;316      hdma->State = HAL_DMA_STATE_READY;
;;;317    
;;;318      return HAL_OK;
;;;319    }
000026  e8bd87f0          POP      {r4-r10,pc}
00002a  bf00              NOP                            ;233
                  |L10.44|
00002c  f7fffffe          BL       HAL_GetTick
000030  1b40              SUBS     r0,r0,r5              ;233
000032  2805              CMP      r0,#5                 ;233
000034  d904              BLS      |L10.64|
000036  2120              MOVS     r1,#0x20              ;236
000038  65a1              STR      r1,[r4,#0x58]         ;236
00003a  2003              MOVS     r0,#3                 ;239
00003c  63a0              STR      r0,[r4,#0x38]         ;239
00003e  e7f2              B        |L10.38|
                  |L10.64|
000040  6820              LDR      r0,[r4,#0]            ;230
000042  6800              LDR      r0,[r0,#0]            ;230
000044  07c0              LSLS     r0,r0,#31             ;230
000046  d1f1              BNE      |L10.44|
000048  e9d42000          LDRD     r2,r0,[r4,#0]         ;230
00004c  e9d45102          LDRD     r5,r1,[r4,#8]         ;230
000050  e9d43c04          LDRD     r3,r12,[r4,#0x10]     ;255
000054  4328              ORRS     r0,r0,r5              ;255
000056  f1040518          ADD      r5,r4,#0x18           ;255
00005a  4319              ORRS     r1,r1,r3              ;255
00005c  4308              ORRS     r0,r0,r1              ;255
00005e  6811              LDR      r1,[r2,#0]            ;246
000060  e89501e0          LDM      r5,{r5-r8}            ;255
000064  ea40000c          ORR      r0,r0,r12             ;255
000068  4b1a              LDR      r3,|L10.212|
00006a  4328              ORRS     r0,r0,r5              ;255
00006c  4019              ANDS     r1,r1,r3              ;249
00006e  ea400006          ORR      r0,r0,r6              ;255
000072  ea400007          ORR      r0,r0,r7              ;255
000076  f1b80f04          CMP      r8,#4                 ;261
00007a  ea400001          ORR      r0,r0,r1              ;255
00007e  d103              BNE      |L10.136|
000080  e9d4130b          LDRD     r1,r3,[r4,#0x2c]      ;261
000084  4319              ORRS     r1,r1,r3              ;264
000086  4308              ORRS     r0,r0,r1              ;264
                  |L10.136|
000088  6010              STR      r0,[r2,#0]            ;268
00008a  6820              LDR      r0,[r4,#0]            ;271
00008c  2601              MOVS     r6,#1                 ;197
00008e  6a65              LDR      r5,[r4,#0x24]         ;277
000090  6940              LDR      r0,[r0,#0x14]         ;271
000092  2d04              CMP      r5,#4                 ;280
000094  f0200007          BIC      r0,r0,#7              ;274
000098  ea450500          ORR      r5,r5,r0              ;277
00009c  d10b              BNE      |L10.182|
00009e  e9d4010a          LDRD     r0,r1,[r4,#0x28]      ;280
0000a2  4305              ORRS     r5,r5,r0              ;283
0000a4  b139              CBZ      r1,|L10.182|
0000a6  4620              MOV      r0,r4                 ;289
0000a8  f7fffffe          BL       DMA_CheckFifoParam
0000ac  b118              CBZ      r0,|L10.182|
0000ae  2040              MOVS     r0,#0x40              ;292
0000b0  65a0              STR      r0,[r4,#0x58]         ;292
0000b2  63a6              STR      r6,[r4,#0x38]         ;295
0000b4  e7b6              B        |L10.36|
                  |L10.182|
0000b6  6820              LDR      r0,[r4,#0]            ;303
0000b8  6145              STR      r5,[r0,#0x14]         ;303
0000ba  4620              MOV      r0,r4                 ;307
0000bc  f7fffffe          BL       DMA_CalcBaseAndBitshift
0000c0  f8943060          LDRB     r3,[r4,#0x60]         ;310
0000c4  223f              MOVS     r2,#0x3f              ;310
0000c6  409a              LSLS     r2,r2,r3              ;310
0000c8  6082              STR      r2,[r0,#8]            ;310
0000ca  f8c49058          STR      r9,[r4,#0x58]         ;313
0000ce  63a6              STR      r6,[r4,#0x38]         ;316
0000d0  2000              MOVS     r0,#0                 ;318
0000d2  e7a8              B        |L10.38|
;;;320    
                          ENDP

                  |L10.212|
                          DCD      0xe010803f

                          AREA ||i.HAL_DMA_PollForTransfer||, CODE, READONLY, ALIGN=2

                  HAL_DMA_PollForTransfer PROC
;;;628      */
;;;629    HAL_StatusTypeDef HAL_DMA_PollForTransfer(DMA_HandleTypeDef *hdma, HAL_DMA_LevelCompleteTypeDef CompleteLevel, uint32_t Timeout)
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;630    {
000004  b082              SUB      sp,sp,#8
000006  4604              MOV      r4,r0
;;;631      HAL_StatusTypeDef status = HAL_OK; 
000008  2000              MOVS     r0,#0
00000a  4689              MOV      r9,r1                 ;630
;;;632      uint32_t mask_cpltlevel;
;;;633      uint32_t tickstart = HAL_GetTick(); 
00000c  9001              STR      r0,[sp,#4]
00000e  f7fffffe          BL       HAL_GetTick
;;;634      uint32_t tmpisr;
;;;635      
;;;636      /* calculate DMA base and stream number */
;;;637      DMA_Base_Registers *regs;
;;;638    
;;;639      if(HAL_DMA_STATE_BUSY != hdma->State)
000012  9000              STR      r0,[sp,#0]
000014  6ba0              LDR      r0,[r4,#0x38]
000016  2700              MOVS     r7,#0
000018  2802              CMP      r0,#2
00001a  d003              BEQ      |L11.36|
;;;640      {
;;;641        /* No transfer ongoing */
;;;642        hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
00001c  2080              MOVS     r0,#0x80
00001e  65a0              STR      r0,[r4,#0x58]
;;;643        __HAL_UNLOCK(hdma);
;;;644        return HAL_ERROR;
000020  6367              STR      r7,[r4,#0x34]
000022  e066              B        |L11.242|
                  |L11.36|
;;;645      }
;;;646    
;;;647      /* Polling mode not supported in circular mode and double buffering mode */
;;;648      if ((hdma->Instance->CR & DMA_SxCR_CIRC) != RESET)
000024  6820              LDR      r0,[r4,#0]
000026  6800              LDR      r0,[r0,#0]
000028  05c0              LSLS     r0,r0,#23
00002a  d503              BPL      |L11.52|
;;;649      {
;;;650        hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
00002c  f44f7080          MOV      r0,#0x100
000030  65a0              STR      r0,[r4,#0x58]
;;;651        return HAL_ERROR;
000032  e05e              B        |L11.242|
                  |L11.52|
;;;652      }
;;;653      
;;;654      /* Get the level transfer complete flag */
;;;655      if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
;;;656      {
;;;657        /* Transfer Complete flag */
;;;658        mask_cpltlevel = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
;;;659      }
;;;660      else
;;;661      {
;;;662        /* Half Transfer Complete flag */
;;;663        mask_cpltlevel = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
000034  f8940060          LDRB     r0,[r4,#0x60]
000038  f1b90f00          CMP      r9,#0                 ;655
00003c  f04f0b20          MOV      r11,#0x20             ;658
000040  f04f0a10          MOV      r10,#0x10
000044  d007              BEQ      |L11.86|
000046  fa0af600          LSL      r6,r10,r0
00004a  bf00              NOP                            ;644
                  |L11.76|
;;;664      }
;;;665      
;;;666      regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
;;;667      tmpisr = regs->ISR;
00004c  6de5              LDR      r5,[r4,#0x5c]
00004e  f04f0801          MOV      r8,#1                 ;644
000052  6828              LDR      r0,[r5,#0]
;;;668      
;;;669      while(((tmpisr & mask_cpltlevel) == RESET) && ((hdma->ErrorCode & HAL_DMA_ERROR_TE) == RESET))
000054  e039              B        |L11.202|
                  |L11.86|
000056  fa0bf600          LSL      r6,r11,r0             ;658
00005a  e7f7              B        |L11.76|
                  |L11.92|
;;;670      {
;;;671        /* Check for the Timeout (Not applicable in circular mode)*/
;;;672        if(Timeout != HAL_MAX_DELAY)
00005c  9804              LDR      r0,[sp,#0x10]
00005e  1c40              ADDS     r0,r0,#1
000060  d010              BEQ      |L11.132|
;;;673        {
;;;674          if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
000062  9804              LDR      r0,[sp,#0x10]
000064  b130              CBZ      r0,|L11.116|
000066  f7fffffe          BL       HAL_GetTick
00006a  9900              LDR      r1,[sp,#0]
00006c  1a41              SUBS     r1,r0,r1
00006e  9804              LDR      r0,[sp,#0x10]
000070  4281              CMP      r1,r0
000072  d907              BLS      |L11.132|
                  |L11.116|
;;;675          {
;;;676            /* Update error code */
;;;677            hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
000074  f8c4b058          STR      r11,[r4,#0x58]
;;;678    
;;;679            /* Process Unlocked */
;;;680            __HAL_UNLOCK(hdma);
;;;681            
;;;682            /* Change the DMA state */
;;;683            hdma->State = HAL_DMA_STATE_READY;
000078  e9c4780d          STRD     r7,r8,[r4,#0x34]
;;;684            
;;;685            return HAL_TIMEOUT;
00007c  2003              MOVS     r0,#3
                  |L11.126|
;;;686          }
;;;687        }
;;;688    
;;;689        /* Get the ISR register value */
;;;690        tmpisr = regs->ISR;
;;;691    
;;;692        if((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
;;;693        {
;;;694          /* Update error code */
;;;695          hdma->ErrorCode |= HAL_DMA_ERROR_TE;
;;;696          
;;;697          /* Clear the transfer error flag */
;;;698          regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
;;;699        }
;;;700        
;;;701        if((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
;;;702        {
;;;703          /* Update error code */
;;;704          hdma->ErrorCode |= HAL_DMA_ERROR_FE;
;;;705          
;;;706          /* Clear the FIFO error flag */
;;;707          regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
;;;708        }
;;;709        
;;;710        if((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
;;;711        {
;;;712          /* Update error code */
;;;713          hdma->ErrorCode |= HAL_DMA_ERROR_DME;
;;;714          
;;;715          /* Clear the Direct Mode error flag */
;;;716          regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
;;;717        }
;;;718      }
;;;719      
;;;720      if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
;;;721      {
;;;722        if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
;;;723        {
;;;724          HAL_DMA_Abort(hdma);
;;;725        
;;;726          /* Clear the half transfer and transfer complete flags */
;;;727          regs->IFCR = (DMA_FLAG_HTIF0_4 | DMA_FLAG_TCIF0_4) << hdma->StreamIndex;
;;;728        
;;;729          /* Process Unlocked */
;;;730          __HAL_UNLOCK(hdma);
;;;731    
;;;732          /* Change the DMA state */
;;;733          hdma->State= HAL_DMA_STATE_READY;
;;;734    
;;;735          return HAL_ERROR;
;;;736       }
;;;737      }
;;;738      
;;;739      /* Get the level transfer complete flag */
;;;740      if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
;;;741      {
;;;742        /* Clear the half transfer and transfer complete flags */
;;;743        regs->IFCR = (DMA_FLAG_HTIF0_4 | DMA_FLAG_TCIF0_4) << hdma->StreamIndex;
;;;744        
;;;745        /* Process Unlocked */
;;;746        __HAL_UNLOCK(hdma);
;;;747    
;;;748        hdma->State = HAL_DMA_STATE_READY;
;;;749      }
;;;750      else
;;;751      {
;;;752        /* Clear the half transfer flag */
;;;753        regs->IFCR = (DMA_FLAG_HTIF0_4) << hdma->StreamIndex;
;;;754      }
;;;755      
;;;756      return status;
;;;757    }
00007e  b005              ADD      sp,sp,#0x14
000080  e8bd8ff0          POP      {r4-r11,pc}
                  |L11.132|
000084  f8942060          LDRB     r2,[r4,#0x60]         ;692
000088  2108              MOVS     r1,#8                 ;692
00008a  6828              LDR      r0,[r5,#0]            ;690
00008c  fa01f202          LSL      r2,r1,r2              ;692
000090  4202              TST      r2,r0                 ;692
000092  d004              BEQ      |L11.158|
000094  6da1              LDR      r1,[r4,#0x58]         ;695
000096  f0410101          ORR      r1,r1,#1              ;695
00009a  65a1              STR      r1,[r4,#0x58]         ;695
00009c  60aa              STR      r2,[r5,#8]            ;698
                  |L11.158|
00009e  f8942060          LDRB     r2,[r4,#0x60]         ;701
0000a2  fa08f202          LSL      r2,r8,r2              ;701
0000a6  4202              TST      r2,r0                 ;701
0000a8  d004              BEQ      |L11.180|
0000aa  6da1              LDR      r1,[r4,#0x58]         ;704
0000ac  f0410102          ORR      r1,r1,#2              ;704
0000b0  65a1              STR      r1,[r4,#0x58]         ;704
0000b2  60aa              STR      r2,[r5,#8]            ;707
                  |L11.180|
0000b4  2104              MOVS     r1,#4                 ;710
0000b6  f8942060          LDRB     r2,[r4,#0x60]         ;710
0000ba  4091              LSLS     r1,r1,r2              ;710
0000bc  4201              TST      r1,r0                 ;710
0000be  d004              BEQ      |L11.202|
0000c0  6da2              LDR      r2,[r4,#0x58]         ;713
0000c2  f0420204          ORR      r2,r2,#4              ;713
0000c6  65a2              STR      r2,[r4,#0x58]         ;713
0000c8  60a9              STR      r1,[r5,#8]            ;716
                  |L11.202|
0000ca  4230              TST      r0,r6                 ;669
0000cc  d102              BNE      |L11.212|
0000ce  6da0              LDR      r0,[r4,#0x58]         ;669
0000d0  07c0              LSLS     r0,r0,#31             ;669
0000d2  d0c3              BEQ      |L11.92|
                  |L11.212|
0000d4  6da0              LDR      r0,[r4,#0x58]         ;720
0000d6  2630              MOVS     r6,#0x30              ;727
0000d8  b168              CBZ      r0,|L11.246|
0000da  6da0              LDR      r0,[r4,#0x58]         ;722
0000dc  07c0              LSLS     r0,r0,#31             ;722
0000de  d00a              BEQ      |L11.246|
0000e0  4620              MOV      r0,r4                 ;724
0000e2  f7fffffe          BL       HAL_DMA_Abort
0000e6  f8941060          LDRB     r1,[r4,#0x60]         ;727
0000ea  408e              LSLS     r6,r6,r1              ;727
0000ec  60ae              STR      r6,[r5,#8]            ;727
0000ee  e9c4780d          STRD     r7,r8,[r4,#0x34]      ;733
                  |L11.242|
0000f2  2001              MOVS     r0,#1                 ;735
0000f4  e7c3              B        |L11.126|
                  |L11.246|
0000f6  f8941060          LDRB     r1,[r4,#0x60]         ;753
0000fa  f1b90f00          CMP      r9,#0                 ;740
0000fe  d004              BEQ      |L11.266|
000100  fa0af001          LSL      r0,r10,r1             ;753
000104  60a8              STR      r0,[r5,#8]            ;753
                  |L11.262|
000106  9801              LDR      r0,[sp,#4]            ;756
000108  e7b9              B        |L11.126|
                  |L11.266|
00010a  408e              LSLS     r6,r6,r1              ;743
00010c  60ae              STR      r6,[r5,#8]            ;743
00010e  e9c4780d          STRD     r7,r8,[r4,#0x34]      ;748
000112  e7f8              B        |L11.262|
;;;758    
                          ENDP


                          AREA ||i.HAL_DMA_RegisterCallback||, CODE, READONLY, ALIGN=1

                  HAL_DMA_RegisterCallback PROC
;;;985      */                      
;;;986    HAL_StatusTypeDef HAL_DMA_RegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID, void (* pCallback)(DMA_HandleTypeDef *_hdma))
000000  b530              PUSH     {r4,r5,lr}
;;;987    {
;;;988    
;;;989      HAL_StatusTypeDef status = HAL_OK;
;;;990    
;;;991      /* Process locked */
;;;992      __HAL_LOCK(hdma);
000002  6b44              LDR      r4,[r0,#0x34]
000004  2300              MOVS     r3,#0                 ;989
000006  2c01              CMP      r4,#1
000008  d009              BEQ      |L12.30|
;;;993    
;;;994      if(HAL_DMA_STATE_READY == hdma->State)
00000a  6b85              LDR      r5,[r0,#0x38]
00000c  2401              MOVS     r4,#1                 ;992
00000e  6344              STR      r4,[r0,#0x34]
000010  2d01              CMP      r5,#1
000012  d006              BEQ      |L12.34|
;;;995      {
;;;996        switch (CallbackID)
;;;997        {
;;;998        case  HAL_DMA_XFER_CPLT_CB_ID:
;;;999          hdma->XferCpltCallback = pCallback;
;;;1000         break;
;;;1001   
;;;1002       case  HAL_DMA_XFER_HALFCPLT_CB_ID:
;;;1003         hdma->XferHalfCpltCallback = pCallback;
;;;1004         break;
;;;1005   
;;;1006       case  HAL_DMA_XFER_M1CPLT_CB_ID:
;;;1007         hdma->XferM1CpltCallback = pCallback;
;;;1008         break;
;;;1009   
;;;1010       case  HAL_DMA_XFER_M1HALFCPLT_CB_ID:
;;;1011         hdma->XferM1HalfCpltCallback = pCallback;
;;;1012         break;
;;;1013   
;;;1014       case  HAL_DMA_XFER_ERROR_CB_ID:
;;;1015         hdma->XferErrorCallback = pCallback;
;;;1016         break;
;;;1017   
;;;1018       case  HAL_DMA_XFER_ABORT_CB_ID:
;;;1019         hdma->XferAbortCallback = pCallback;
;;;1020         break;
;;;1021   
;;;1022       default:
;;;1023         break;
;;;1024       }
;;;1025     }
;;;1026     else
;;;1027     {
;;;1028       /* Return error status */
;;;1029       status =  HAL_ERROR;
000014  2301              MOVS     r3,#1
                  |L12.22|
;;;1030     }
;;;1031   
;;;1032     /* Release Lock */
;;;1033     __HAL_UNLOCK(hdma);
000016  2100              MOVS     r1,#0
;;;1034     
;;;1035     return status;
000018  6341              STR      r1,[r0,#0x34]
00001a  4618              MOV      r0,r3
;;;1036   }
00001c  bd30              POP      {r4,r5,pc}
                  |L12.30|
00001e  2002              MOVS     r0,#2                 ;992
000020  bd30              POP      {r4,r5,pc}
                  |L12.34|
000022  2906              CMP      r1,#6                 ;996
000024  d2f7              BCS      |L12.22|
000026  e8dff001          TBB      [pc,r1]               ;996
00002a  0305              DCB      0x03,0x05
00002c  07090b0d          DCB      0x07,0x09,0x0b,0x0d
000030  6402              STR      r2,[r0,#0x40]         ;1000
000032  e7f0              B        |L12.22|
000034  6442              STR      r2,[r0,#0x44]         ;1004
000036  e7ee              B        |L12.22|
000038  6482              STR      r2,[r0,#0x48]         ;1008
00003a  e7ec              B        |L12.22|
00003c  64c2              STR      r2,[r0,#0x4c]         ;1012
00003e  e7ea              B        |L12.22|
000040  6502              STR      r2,[r0,#0x50]         ;1016
000042  e7e8              B        |L12.22|
000044  6542              STR      r2,[r0,#0x54]         ;1020
000046  e7e6              B        |L12.22|
;;;1037   
                          ENDP


                          AREA ||i.HAL_DMA_Start||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Start PROC
;;;424      */
;;;425    HAL_StatusTypeDef HAL_DMA_Start(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;426    {
000004  4604              MOV      r4,r0
;;;427      HAL_StatusTypeDef status = HAL_OK;
;;;428      
;;;429      /* Check the parameters */
;;;430      assert_param(IS_DMA_BUFFER_SIZE(DataLength));
;;;431    
;;;432      /* Process locked */
;;;433      __HAL_LOCK(hdma);
000006  6b40              LDR      r0,[r0,#0x34]
000008  2500              MOVS     r5,#0                 ;427
00000a  2801              CMP      r0,#1
00000c  d00a              BEQ      |L13.36|
;;;434    
;;;435      if(HAL_DMA_STATE_READY == hdma->State)
00000e  6ba7              LDR      r7,[r4,#0x38]
000010  2601              MOVS     r6,#1                 ;433
000012  2000              MOVS     r0,#0                 ;433
000014  6366              STR      r6,[r4,#0x34]
000016  2f01              CMP      r7,#1
000018  d006              BEQ      |L13.40|
;;;436      {
;;;437        /* Change DMA peripheral state */
;;;438        hdma->State = HAL_DMA_STATE_BUSY;
;;;439        
;;;440        /* Initialize the error code */
;;;441        hdma->ErrorCode = HAL_DMA_ERROR_NONE;
;;;442        
;;;443        /* Configure the source, destination address and the data length */
;;;444        DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
;;;445    
;;;446        /* Enable the Peripheral */
;;;447        __HAL_DMA_ENABLE(hdma);
;;;448      }
;;;449      else
;;;450      {
;;;451        /* Process unlocked */
;;;452        __HAL_UNLOCK(hdma);
;;;453        
;;;454        /* Return error status */
;;;455        status = HAL_BUSY;
00001a  2502              MOVS     r5,#2
00001c  6360              STR      r0,[r4,#0x34]         ;452
                  |L13.30|
;;;456      } 
;;;457      return status; 
00001e  4628              MOV      r0,r5
                  |L13.32|
;;;458    }
000020  e8bd81f0          POP      {r4-r8,pc}
                  |L13.36|
000024  2002              MOVS     r0,#2                 ;433
000026  e7fb              B        |L13.32|
                  |L13.40|
000028  2602              MOVS     r6,#2                 ;438
00002a  63a6              STR      r6,[r4,#0x38]         ;438
00002c  65a0              STR      r0,[r4,#0x58]         ;441
00002e  4620              MOV      r0,r4                 ;444
000030  f7fffffe          BL       DMA_SetConfig
000034  6820              LDR      r0,[r4,#0]            ;447
000036  6801              LDR      r1,[r0,#0]            ;447
000038  f0410101          ORR      r1,r1,#1              ;447
00003c  6001              STR      r1,[r0,#0]            ;447
00003e  e7ee              B        |L13.30|
;;;459    
                          ENDP


                          AREA ||i.HAL_DMA_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Start_IT PROC
;;;468      */
;;;469    HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;470    {
000004  4604              MOV      r4,r0
;;;471      HAL_StatusTypeDef status = HAL_OK;
;;;472    
;;;473      /* calculate DMA base and stream number */
;;;474      DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
;;;475      
;;;476      /* Check the parameters */
;;;477      assert_param(IS_DMA_BUFFER_SIZE(DataLength));
;;;478     
;;;479      /* Process locked */
;;;480      __HAL_LOCK(hdma);
000006  6b40              LDR      r0,[r0,#0x34]
000008  2500              MOVS     r5,#0                 ;471
00000a  2801              CMP      r0,#1
00000c  6de6              LDR      r6,[r4,#0x5c]         ;470
00000e  d00c              BEQ      |L14.42|
;;;481      
;;;482      if(HAL_DMA_STATE_READY == hdma->State)
000010  f8d4c038          LDR      r12,[r4,#0x38]
000014  2701              MOVS     r7,#1                 ;480
000016  2000              MOVS     r0,#0                 ;480
000018  6367              STR      r7,[r4,#0x34]
00001a  f1bc0f01          CMP      r12,#1
00001e  d006              BEQ      |L14.46|
;;;483      {
;;;484        /* Change DMA peripheral state */
;;;485        hdma->State = HAL_DMA_STATE_BUSY;
;;;486        
;;;487        /* Initialize the error code */
;;;488        hdma->ErrorCode = HAL_DMA_ERROR_NONE;
;;;489        
;;;490        /* Configure the source, destination address and the data length */
;;;491        DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
;;;492        
;;;493        /* Clear all interrupt flags at correct offset within the register */
;;;494        regs->IFCR = 0x3FU << hdma->StreamIndex;
;;;495        
;;;496        /* Enable Common interrupts*/
;;;497        hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
;;;498        hdma->Instance->FCR |= DMA_IT_FE;
;;;499        
;;;500        if(hdma->XferHalfCpltCallback != NULL)
;;;501        {
;;;502          hdma->Instance->CR  |= DMA_IT_HT;
;;;503        }
;;;504        
;;;505        /* Enable the Peripheral */
;;;506        __HAL_DMA_ENABLE(hdma);
;;;507      }
;;;508      else
;;;509      {
;;;510        /* Process unlocked */
;;;511        __HAL_UNLOCK(hdma);	  
;;;512        
;;;513        /* Return error status */
;;;514        status = HAL_BUSY;
000020  2502              MOVS     r5,#2
000022  6360              STR      r0,[r4,#0x34]         ;511
                  |L14.36|
;;;515      }
;;;516      
;;;517      return status;
000024  4628              MOV      r0,r5
                  |L14.38|
;;;518    }
000026  e8bd81f0          POP      {r4-r8,pc}
                  |L14.42|
00002a  2002              MOVS     r0,#2                 ;480
00002c  e7fb              B        |L14.38|
                  |L14.46|
00002e  2702              MOVS     r7,#2                 ;485
000030  63a7              STR      r7,[r4,#0x38]         ;485
000032  65a0              STR      r0,[r4,#0x58]         ;488
000034  4620              MOV      r0,r4                 ;491
000036  f7fffffe          BL       DMA_SetConfig
00003a  f8941060          LDRB     r1,[r4,#0x60]         ;494
00003e  203f              MOVS     r0,#0x3f              ;494
000040  4088              LSLS     r0,r0,r1              ;494
000042  60b0              STR      r0,[r6,#8]            ;494
000044  6820              LDR      r0,[r4,#0]            ;497
000046  6801              LDR      r1,[r0,#0]            ;497
000048  f0410116          ORR      r1,r1,#0x16           ;497
00004c  6001              STR      r1,[r0,#0]            ;497
00004e  6820              LDR      r0,[r4,#0]            ;498
000050  6941              LDR      r1,[r0,#0x14]         ;498
000052  f0410180          ORR      r1,r1,#0x80           ;498
000056  6141              STR      r1,[r0,#0x14]         ;498
000058  6c60              LDR      r0,[r4,#0x44]         ;500
00005a  b120              CBZ      r0,|L14.102|
00005c  6820              LDR      r0,[r4,#0]            ;502
00005e  6801              LDR      r1,[r0,#0]            ;502
000060  f0410108          ORR      r1,r1,#8              ;502
000064  6001              STR      r1,[r0,#0]            ;502
                  |L14.102|
000066  6820              LDR      r0,[r4,#0]            ;506
000068  6801              LDR      r1,[r0,#0]            ;506
00006a  f0410101          ORR      r1,r1,#1              ;506
00006e  6001              STR      r1,[r0,#0]            ;506
000070  e7d8              B        |L14.36|
;;;519    
                          ENDP


                          AREA ||i.HAL_DMA_UnRegisterCallback||, CODE, READONLY, ALIGN=1

                  HAL_DMA_UnRegisterCallback PROC
;;;1045     */              
;;;1046   HAL_StatusTypeDef HAL_DMA_UnRegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID)
000000  b530              PUSH     {r4,r5,lr}
;;;1047   {
;;;1048     HAL_StatusTypeDef status = HAL_OK;
;;;1049     
;;;1050     /* Process locked */
;;;1051     __HAL_LOCK(hdma);
000002  6b42              LDR      r2,[r0,#0x34]
000004  2300              MOVS     r3,#0                 ;1048
000006  2a01              CMP      r2,#1
000008  d006              BEQ      |L15.24|
;;;1052     
;;;1053     if(HAL_DMA_STATE_READY == hdma->State)
00000a  6b85              LDR      r5,[r0,#0x38]
00000c  2401              MOVS     r4,#1                 ;1051
00000e  2200              MOVS     r2,#0                 ;1051
000010  6344              STR      r4,[r0,#0x34]
000012  2d01              CMP      r5,#1
000014  d002              BEQ      |L15.28|
000016  e01b              B        |L15.80|
                  |L15.24|
000018  2002              MOVS     r0,#2                 ;1051
;;;1054     {
;;;1055       switch (CallbackID)
;;;1056       {
;;;1057       case  HAL_DMA_XFER_CPLT_CB_ID:
;;;1058         hdma->XferCpltCallback = NULL;
;;;1059         break;
;;;1060         
;;;1061       case  HAL_DMA_XFER_HALFCPLT_CB_ID:
;;;1062         hdma->XferHalfCpltCallback = NULL;
;;;1063         break;
;;;1064         
;;;1065       case  HAL_DMA_XFER_M1CPLT_CB_ID:
;;;1066         hdma->XferM1CpltCallback = NULL;
;;;1067         break;
;;;1068         
;;;1069       case  HAL_DMA_XFER_M1HALFCPLT_CB_ID:
;;;1070         hdma->XferM1HalfCpltCallback = NULL;
;;;1071         break;
;;;1072         
;;;1073       case  HAL_DMA_XFER_ERROR_CB_ID:
;;;1074         hdma->XferErrorCallback = NULL;
;;;1075         break;
;;;1076         
;;;1077       case  HAL_DMA_XFER_ABORT_CB_ID:
;;;1078         hdma->XferAbortCallback = NULL;
;;;1079         break; 
;;;1080         
;;;1081       case   HAL_DMA_XFER_ALL_CB_ID:
;;;1082         hdma->XferCpltCallback = NULL;
;;;1083         hdma->XferHalfCpltCallback = NULL;
;;;1084         hdma->XferM1CpltCallback = NULL;
;;;1085         hdma->XferM1HalfCpltCallback = NULL;
;;;1086         hdma->XferErrorCallback = NULL;
;;;1087         hdma->XferAbortCallback = NULL;
;;;1088         break; 
;;;1089         
;;;1090       default:
;;;1091         status = HAL_ERROR;
;;;1092         break;
;;;1093       }
;;;1094     }
;;;1095     else
;;;1096     {
;;;1097       status = HAL_ERROR;
;;;1098     }
;;;1099     
;;;1100     /* Release Lock */
;;;1101     __HAL_UNLOCK(hdma);
;;;1102     
;;;1103     return status;
;;;1104   }
00001a  bd30              POP      {r4,r5,pc}
                  |L15.28|
00001c  2907              CMP      r1,#7                 ;1055
00001e  d217              BCS      |L15.80|
000020  e8dff001          TBB      [pc,r1]               ;1055
000024  0406080a          DCB      0x04,0x06,0x08,0x0a
000028  0c0e1000          DCB      0x0c,0x0e,0x10,0x00
00002c  6402              STR      r2,[r0,#0x40]         ;1059
00002e  e010              B        |L15.82|
000030  6442              STR      r2,[r0,#0x44]         ;1063
000032  e00e              B        |L15.82|
000034  6482              STR      r2,[r0,#0x48]         ;1067
000036  e00c              B        |L15.82|
000038  64c2              STR      r2,[r0,#0x4c]         ;1071
00003a  e00a              B        |L15.82|
00003c  6502              STR      r2,[r0,#0x50]         ;1075
00003e  e008              B        |L15.82|
                  |L15.64|
000040  6542              STR      r2,[r0,#0x54]         ;1079
000042  e006              B        |L15.82|
000044  6402              STR      r2,[r0,#0x40]         ;1083
000046  6442              STR      r2,[r0,#0x44]         ;1084
000048  6482              STR      r2,[r0,#0x48]         ;1085
00004a  64c2              STR      r2,[r0,#0x4c]         ;1086
00004c  6502              STR      r2,[r0,#0x50]         ;1088
00004e  e7f7              B        |L15.64|
                  |L15.80|
000050  2301              MOVS     r3,#1                 ;1091
                  |L15.82|
000052  6342              STR      r2,[r0,#0x34]         ;1103
000054  4618              MOV      r0,r3                 ;1103
000056  bd30              POP      {r4,r5,pc}
;;;1105   
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  flagBitshiftOffset
000000  00061016          DCB      0x00,0x06,0x10,0x16
000004  00061016          DCB      0x00,0x06,0x10,0x16

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F7_V1.11.0\\Drivers\\STM32F7xx_HAL_Driver\\Src\\stm32f7xx_hal_dma.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f7xx_hal_dma_c_c25f65ec____REV16|
#line 468 "D:\\Program_Files_x86\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.3.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___19_stm32f7xx_hal_dma_c_c25f65ec____REV16| PROC
#line 469

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f7xx_hal_dma_c_c25f65ec____REVSH|
#line 483
|__asm___19_stm32f7xx_hal_dma_c_c25f65ec____REVSH| PROC
#line 484

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f7xx_hal_dma_c_c25f65ec____RRX|
#line 670
|__asm___19_stm32f7xx_hal_dma_c_c25f65ec____RRX| PROC
#line 671

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
