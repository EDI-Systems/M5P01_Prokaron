; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f7xx_hal_cortex.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f7xx_hal_cortex.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Core -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Inc -I.\Source -I.\Drivers -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6-FPU\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f7xx_hal_cortex.crf ..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_cortex.c]
                          THUMB

                          AREA ||i.HAL_MPU_ConfigRegion||, CODE, READONLY, ALIGN=2

                  HAL_MPU_ConfigRegion PROC
;;;315      */
;;;316    void HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init)
000000  b5f0              PUSH     {r4-r7,lr}
;;;317    {
;;;318      /* Check the parameters */
;;;319      assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
;;;320      assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));
;;;321    
;;;322      /* Set the Region number */
;;;323      MPU->RNR = MPU_Init->Number;
000002  4c15              LDR      r4,|L1.88|
000004  7843              LDRB     r3,[r0,#1]
;;;324    
;;;325      if ((MPU_Init->Enable) != RESET)
;;;326      {
;;;327        /* Check the parameters */
;;;328        assert_param(IS_MPU_INSTRUCTION_ACCESS(MPU_Init->DisableExec));
;;;329        assert_param(IS_MPU_REGION_PERMISSION_ATTRIBUTE(MPU_Init->AccessPermission));
;;;330        assert_param(IS_MPU_TEX_LEVEL(MPU_Init->TypeExtField));
;;;331        assert_param(IS_MPU_ACCESS_SHAREABLE(MPU_Init->IsShareable));
;;;332        assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
;;;333        assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
;;;334        assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
;;;335        assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
;;;336        
;;;337        MPU->RBAR = MPU_Init->BaseAddress;
000006  1d21              ADDS     r1,r4,#4
;;;338        MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
000008  1d0a              ADDS     r2,r1,#4
00000a  6023              STR      r3,[r4,#0]            ;323
00000c  7803              LDRB     r3,[r0,#0]            ;325
00000e  b1f3              CBZ      r3,|L1.78|
000010  6843              LDR      r3,[r0,#4]            ;337
000012  600b              STR      r3,[r1,#0]            ;337
000014  7b05              LDRB     r5,[r0,#0xc]
000016  7ac6              LDRB     r6,[r0,#0xb]
000018  7a81              LDRB     r1,[r0,#0xa]
00001a  7b43              LDRB     r3,[r0,#0xd]
00001c  072d              LSLS     r5,r5,#28
00001e  7b84              LDRB     r4,[r0,#0xe]
000020  ea456506          ORR      r5,r5,r6,LSL #24
000024  7bc7              LDRB     r7,[r0,#0xf]
000026  f890c009          LDRB     r12,[r0,#9]
00002a  7a06              LDRB     r6,[r0,#8]
00002c  f890e000          LDRB     lr,[r0,#0]
000030  ea4540c1          ORR      r0,r5,r1,LSL #19
000034  ea404083          ORR      r0,r0,r3,LSL #18
000038  ea404044          ORR      r0,r0,r4,LSL #17
00003c  ea404007          ORR      r0,r0,r7,LSL #16
000040  ea40200c          ORR      r0,r0,r12,LSL #8
000044  ea400046          ORR      r0,r0,r6,LSL #1
000048  ea40000e          ORR      r0,r0,lr
00004c  e001              B        |L1.82|
                  |L1.78|
;;;339                    ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
;;;340                    ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
;;;341                    ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
;;;342                    ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
;;;343                    ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
;;;344                    ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
;;;345                    ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
;;;346                    ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);
;;;347      }
;;;348      else
;;;349      {
;;;350        MPU->RBAR = 0x00;
00004e  2000              MOVS     r0,#0
000050  6008              STR      r0,[r1,#0]
                  |L1.82|
000052  6010              STR      r0,[r2,#0]            ;338
;;;351        MPU->RASR = 0x00;
;;;352      }
;;;353    }
000054  bdf0              POP      {r4-r7,pc}
;;;354    #endif /* __MPU_PRESENT */
                          ENDP

000056  0000              DCW      0x0000
                  |L1.88|
                          DCD      0xe000ed98

                          AREA ||i.HAL_MPU_Disable||, CODE, READONLY, ALIGN=2

                  HAL_MPU_Disable PROC
;;;273      */
;;;274    void HAL_MPU_Disable(void)
000000  f3bf8f5f          DMB      
;;;275    {
;;;276      /* Make sure outstanding transfers are done */
;;;277      __DMB();
;;;278    
;;;279      /* Disable fault exceptions */
;;;280      SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
000004  4804              LDR      r0,|L2.24|
;;;281      
;;;282      /* Disable the MPU and clear the control register*/
;;;283      MPU->CTRL = 0;
000006  2100              MOVS     r1,#0
000008  6803              LDR      r3,[r0,#0]            ;280
00000a  4a03              LDR      r2,|L2.24|
00000c  f4233380          BIC      r3,r3,#0x10000        ;280
000010  6003              STR      r3,[r0,#0]            ;280
000012  3270              ADDS     r2,r2,#0x70
000014  6011              STR      r1,[r2,#0]
;;;284    }
000016  4770              BX       lr
;;;285    
                          ENDP

                  |L2.24|
                          DCD      0xe000ed24

                          AREA ||i.HAL_MPU_Enable||, CODE, READONLY, ALIGN=2

                  HAL_MPU_Enable PROC
;;;296      */
;;;297    void HAL_MPU_Enable(uint32_t MPU_Control)
000000  4a07              LDR      r2,|L3.32|
;;;298    {
;;;299      /* Enable the MPU */
;;;300      MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
000002  f0400001          ORR      r0,r0,#1
;;;301      
;;;302      /* Enable fault exceptions */
;;;303      SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
000006  4906              LDR      r1,|L3.32|
000008  3270              ADDS     r2,r2,#0x70           ;300
00000a  6010              STR      r0,[r2,#0]            ;300
00000c  6808              LDR      r0,[r1,#0]
00000e  f4403080          ORR      r0,r0,#0x10000
000012  6008              STR      r0,[r1,#0]
;;;304      
;;;305      /* Ensure MPU setting take effects */
;;;306      __DSB();
000014  f3bf8f4f          DSB      
;;;307      __ISB();
000018  f3bf8f6f          ISB      
;;;308    }
00001c  4770              BX       lr
;;;309    
                          ENDP

00001e  0000              DCW      0x0000
                  |L3.32|
                          DCD      0xe000ed24

                          AREA ||i.HAL_NVIC_ClearPendingIRQ||, CODE, READONLY, ALIGN=1

                  HAL_NVIC_ClearPendingIRQ PROC
;;;435      */
;;;436    void HAL_NVIC_ClearPendingIRQ(IRQn_Type IRQn)
000000  2800              CMP      r0,#0
;;;437    {
000002  db09              BLT      |L4.24|
000004  0941              LSRS     r1,r0,#5
000006  f000021f          AND      r2,r0,#0x1f
00000a  0089              LSLS     r1,r1,#2
00000c  2001              MOVS     r0,#1
00000e  f10121e0          ADD      r1,r1,#0xe000e000
000012  4090              LSLS     r0,r0,r2
000014  f8c10280          STR      r0,[r1,#0x280]
                  |L4.24|
;;;438      /* Check the parameters */
;;;439      assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
;;;440      
;;;441      /* Clear pending interrupt */
;;;442      NVIC_ClearPendingIRQ(IRQn);
;;;443    }
000018  4770              BX       lr
;;;444    
                          ENDP


                          AREA ||i.HAL_NVIC_DisableIRQ||, CODE, READONLY, ALIGN=1

                  HAL_NVIC_DisableIRQ PROC
;;;218      */
;;;219    void HAL_NVIC_DisableIRQ(IRQn_Type IRQn)
000000  2800              CMP      r0,#0
;;;220    {
000002  db0d              BLT      |L5.32|
000004  0941              LSRS     r1,r0,#5
000006  f000021f          AND      r2,r0,#0x1f
00000a  0089              LSLS     r1,r1,#2
00000c  2001              MOVS     r0,#1
00000e  f10121e0          ADD      r1,r1,#0xe000e000
000012  4090              LSLS     r0,r0,r2
000014  f8c10180          STR      r0,[r1,#0x180]
000018  f3bf8f4f          DSB      
00001c  f3bf8f6f          ISB      
                  |L5.32|
;;;221      /* Check the parameters */
;;;222      assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
;;;223      
;;;224      /* Disable interrupt */
;;;225      NVIC_DisableIRQ(IRQn);
;;;226    }
000020  4770              BX       lr
;;;227    
                          ENDP


                          AREA ||i.HAL_NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  HAL_NVIC_EnableIRQ PROC
;;;202      */
;;;203    void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
000000  2800              CMP      r0,#0
;;;204    {
000002  db09              BLT      |L6.24|
000004  0941              LSRS     r1,r0,#5
000006  f000021f          AND      r2,r0,#0x1f
00000a  0089              LSLS     r1,r1,#2
00000c  2001              MOVS     r0,#1
00000e  f10121e0          ADD      r1,r1,#0xe000e000
000012  4090              LSLS     r0,r0,r2
000014  f8c10100          STR      r0,[r1,#0x100]
                  |L6.24|
;;;205      /* Check the parameters */
;;;206      assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
;;;207      
;;;208      /* Enable interrupt */
;;;209      NVIC_EnableIRQ(IRQn);
;;;210    }
000018  4770              BX       lr
;;;211    
                          ENDP


                          AREA ||i.HAL_NVIC_GetActive||, CODE, READONLY, ALIGN=1

                  HAL_NVIC_GetActive PROC
;;;452      */
;;;453    uint32_t HAL_NVIC_GetActive(IRQn_Type IRQn)
000000  2800              CMP      r0,#0
;;;454    {
000002  db0d              BLT      |L7.32|
000004  0941              LSRS     r1,r0,#5
000006  f000021f          AND      r2,r0,#0x1f
00000a  0089              LSLS     r1,r1,#2
00000c  f10121e0          ADD      r1,r1,#0xe000e000
000010  2001              MOVS     r0,#1
000012  f8d11300          LDR      r1,[r1,#0x300]
000016  4090              LSLS     r0,r0,r2
000018  4201              TST      r1,r0
00001a  d001              BEQ      |L7.32|
00001c  2001              MOVS     r0,#1
;;;455      /* Check the parameters */
;;;456      assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
;;;457      
;;;458      /* Return 1 if active else 0 */
;;;459      return NVIC_GetActive(IRQn);
;;;460    }
00001e  4770              BX       lr
                  |L7.32|
000020  2000              MOVS     r0,#0
000022  4770              BX       lr
;;;461    
                          ENDP


                          AREA ||i.HAL_NVIC_GetPendingIRQ||, CODE, READONLY, ALIGN=1

                  HAL_NVIC_GetPendingIRQ PROC
;;;419      */
;;;420    uint32_t HAL_NVIC_GetPendingIRQ(IRQn_Type IRQn)
000000  2800              CMP      r0,#0
;;;421    {
000002  db0d              BLT      |L8.32|
000004  0941              LSRS     r1,r0,#5
000006  f000021f          AND      r2,r0,#0x1f
00000a  0089              LSLS     r1,r1,#2
00000c  f10121e0          ADD      r1,r1,#0xe000e000
000010  2001              MOVS     r0,#1
000012  f8d11200          LDR      r1,[r1,#0x200]
000016  4090              LSLS     r0,r0,r2
000018  4201              TST      r1,r0
00001a  d001              BEQ      |L8.32|
00001c  2001              MOVS     r0,#1
;;;422      /* Check the parameters */
;;;423      assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
;;;424      
;;;425      /* Return 1 if pending else 0 */
;;;426      return NVIC_GetPendingIRQ(IRQn);
;;;427    }
00001e  4770              BX       lr
                  |L8.32|
000020  2000              MOVS     r0,#0
000022  4770              BX       lr
;;;428    
                          ENDP


                          AREA ||i.HAL_NVIC_GetPriority||, CODE, READONLY, ALIGN=1

                  HAL_NVIC_GetPriority PROC
;;;386      */
;;;387    void HAL_NVIC_GetPriority(IRQn_Type IRQn, uint32_t PriorityGroup, uint32_t *pPreemptPriority, uint32_t *pSubPriority)
000000  b570              PUSH     {r4-r6,lr}
000002  2800              CMP      r0,#0
;;;388    {
000004  db04              BLT      |L9.16|
000006  f10020e0          ADD      r0,r0,#0xe000e000
00000a  f8900400          LDRB     r0,[r0,#0x400]
00000e  e005              B        |L9.28|
                  |L9.16|
000010  f000000f          AND      r0,r0,#0xf
000014  f10020e0          ADD      r0,r0,#0xe000e000
000018  f8900d14          LDRB     r0,[r0,#0xd14]
                  |L9.28|
00001c  f0010407          AND      r4,r1,#7
000020  f1c40507          RSB      r5,r4,#7
000024  0900              LSRS     r0,r0,#4
000026  2d04              CMP      r5,#4
000028  d900              BLS      |L9.44|
00002a  2504              MOVS     r5,#4
                  |L9.44|
00002c  1d21              ADDS     r1,r4,#4
00002e  2907              CMP      r1,#7
000030  d201              BCS      |L9.54|
000032  2400              MOVS     r4,#0
000034  e000              B        |L9.56|
                  |L9.54|
000036  1ee4              SUBS     r4,r4,#3
                  |L9.56|
000038  2101              MOVS     r1,#1
00003a  fa20f604          LSR      r6,r0,r4
00003e  fa01f505          LSL      r5,r1,r5
000042  40a1              LSLS     r1,r1,r4
000044  1e6d              SUBS     r5,r5,#1
000046  402e              ANDS     r6,r6,r5
000048  6016              STR      r6,[r2,#0]
00004a  1e49              SUBS     r1,r1,#1
00004c  4001              ANDS     r1,r1,r0
00004e  6019              STR      r1,[r3,#0]
;;;389      /* Check the parameters */
;;;390      assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
;;;391     /* Get priority for Cortex-M system or device specific interrupts */
;;;392      NVIC_DecodePriority(NVIC_GetPriority(IRQn), PriorityGroup, pPreemptPriority, pSubPriority);
;;;393    }
000050  bd70              POP      {r4-r6,pc}
;;;394    
                          ENDP


                          AREA ||i.HAL_NVIC_GetPriorityGrouping||, CODE, READONLY, ALIGN=2

                  HAL_NVIC_GetPriorityGrouping PROC
;;;359      */
;;;360    uint32_t HAL_NVIC_GetPriorityGrouping(void)
000000  4802              LDR      r0,|L10.12|
;;;361    {
;;;362      /* Get the PRIGROUP[10:8] field value */
;;;363      return NVIC_GetPriorityGrouping();
000002  6800              LDR      r0,[r0,#0]
000004  f3c02002          UBFX     r0,r0,#8,#3
;;;364    }
000008  4770              BX       lr
;;;365    
                          ENDP

00000a  0000              DCW      0x0000
                  |L10.12|
                          DCD      0xe000ed0c

                          AREA ||i.HAL_NVIC_SetPendingIRQ||, CODE, READONLY, ALIGN=1

                  HAL_NVIC_SetPendingIRQ PROC
;;;401      */
;;;402    void HAL_NVIC_SetPendingIRQ(IRQn_Type IRQn)
000000  2800              CMP      r0,#0
;;;403    {
000002  db09              BLT      |L11.24|
000004  0941              LSRS     r1,r0,#5
000006  f000021f          AND      r2,r0,#0x1f
00000a  0089              LSLS     r1,r1,#2
00000c  2001              MOVS     r0,#1
00000e  f10121e0          ADD      r1,r1,#0xe000e000
000012  4090              LSLS     r0,r0,r2
000014  f8c10200          STR      r0,[r1,#0x200]
                  |L11.24|
;;;404      /* Check the parameters */
;;;405      assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
;;;406      
;;;407      /* Set interrupt pending */
;;;408      NVIC_SetPendingIRQ(IRQn);
;;;409    }
000018  4770              BX       lr
;;;410    
                          ENDP


                          AREA ||i.HAL_NVIC_SetPriority||, CODE, READONLY, ALIGN=2

                  HAL_NVIC_SetPriority PROC
;;;180      */
;;;181    void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
000000  4b0e              LDR      r3,|L12.60|
;;;182    { 
000002  b4f0              PUSH     {r4-r7}
000004  681b              LDR      r3,[r3,#0]
;;;183      uint32_t prioritygroup = 0x00;
;;;184      
;;;185      /* Check the parameters */
;;;186      assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
;;;187      assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
;;;188      
;;;189      prioritygroup = NVIC_GetPriorityGrouping();
;;;190      
;;;191      NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
000006  460d              MOV      r5,r1
000008  f3c32302          UBFX     r3,r3,#8,#3
00000c  f1c30607          RSB      r6,r3,#7
000010  2e04              CMP      r6,#4
000012  d900              BLS      |L12.22|
000014  2604              MOVS     r6,#4                 ;182
                  |L12.22|
000016  1d19              ADDS     r1,r3,#4              ;182
000018  2907              CMP      r1,#7                 ;182
00001a  d201              BCS      |L12.32|
00001c  2300              MOVS     r3,#0                 ;182
00001e  e000              B        |L12.34|
                  |L12.32|
000020  1edb              SUBS     r3,r3,#3              ;182
                  |L12.34|
000022  2401              MOVS     r4,#1                 ;182
000024  fa04f106          LSL      r1,r4,r6              ;182
000028  409c              LSLS     r4,r4,r3              ;182
00002a  1e49              SUBS     r1,r1,#1              ;182
00002c  4029              ANDS     r1,r1,r5              ;182
00002e  1e64              SUBS     r4,r4,#1              ;182
000030  4099              LSLS     r1,r1,r3              ;182
000032  4014              ANDS     r4,r4,r2              ;182
000034  4321              ORRS     r1,r1,r4              ;182
000036  bcf0              POP      {r4-r7}
000038  f7ffbffe          B.W      __NVIC_SetPriority
;;;192    }
;;;193    
                          ENDP

                  |L12.60|
                          DCD      0xe000ed0c

                          AREA ||i.HAL_NVIC_SetPriorityGrouping||, CODE, READONLY, ALIGN=2

                  HAL_NVIC_SetPriorityGrouping PROC
;;;158      */
;;;159    void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
000000  4906              LDR      r1,|L13.28|
000002  f0000207          AND      r2,r0,#7
;;;160    {
000006  b510              PUSH     {r4,lr}
000008  f64f04ff          MOV      r4,#0xf8ff
00000c  6808              LDR      r0,[r1,#0]
00000e  4b04              LDR      r3,|L13.32|
000010  4020              ANDS     r0,r0,r4
000012  ea402002          ORR      r0,r0,r2,LSL #8
000016  4318              ORRS     r0,r0,r3
000018  6008              STR      r0,[r1,#0]
;;;161      /* Check the parameters */
;;;162      assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
;;;163      
;;;164      /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
;;;165      NVIC_SetPriorityGrouping(PriorityGroup);
;;;166    }
00001a  bd10              POP      {r4,pc}
;;;167    
                          ENDP

                  |L13.28|
                          DCD      0xe000ed0c
                  |L13.32|
                          DCD      0x05fa0000

                          AREA ||i.HAL_NVIC_SystemReset||, CODE, READONLY, ALIGN=2

                  HAL_NVIC_SystemReset PROC
;;;231      */
;;;232    void HAL_NVIC_SystemReset(void)
000000  f3bf8f4f          DSB      
000004  4805              LDR      r0,|L14.28|
000006  4a06              LDR      r2,|L14.32|
000008  6801              LDR      r1,[r0,#0]
00000a  f40161e0          AND      r1,r1,#0x700
00000e  4311              ORRS     r1,r1,r2
000010  6001              STR      r1,[r0,#0]
000012  f3bf8f4f          DSB      
                  |L14.22|
000016  bf00              NOP      
000018  e7fd              B        |L14.22|
;;;233    {
;;;234      /* System Reset */
;;;235      NVIC_SystemReset();
;;;236    }
;;;237    
                          ENDP

00001a  0000              DCW      0x0000
                  |L14.28|
                          DCD      0xe000ed0c
                  |L14.32|
                          DCD      0x05fa0004

                          AREA ||i.HAL_SYSTICK_CLKSourceConfig||, CODE, READONLY, ALIGN=1

                  HAL_SYSTICK_CLKSourceConfig PROC
;;;469      */
;;;470    void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
000000  2804              CMP      r0,#4
;;;471    {
;;;472      /* Check the parameters */
;;;473      assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
;;;474      if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
;;;475      {
;;;476        SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
000002  f04f20e0          MOV      r0,#0xe000e000
;;;477      }
;;;478      else
;;;479      {
;;;480        SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
000006  6901              LDR      r1,[r0,#0x10]
000008  d003              BEQ      |L15.18|
00000a  f0210104          BIC      r1,r1,#4
                  |L15.14|
00000e  6101              STR      r1,[r0,#0x10]         ;476
;;;481      }
;;;482    }
000010  4770              BX       lr
                  |L15.18|
000012  f0410104          ORR      r1,r1,#4              ;476
000016  e7fa              B        |L15.14|
;;;483    
                          ENDP


                          AREA ||i.HAL_SYSTICK_Callback||, CODE, READONLY, ALIGN=1

                  HAL_SYSTICK_Callback PROC
;;;496      */
;;;497    __weak void HAL_SYSTICK_Callback(void)
000000  4770              BX       lr
;;;498    {
;;;499      /* NOTE : This function Should not be modified, when the callback is needed,
;;;500                the HAL_SYSTICK_Callback could be implemented in the user file
;;;501       */
;;;502    }
;;;503    
                          ENDP


                          AREA ||i.HAL_SYSTICK_Config||, CODE, READONLY, ALIGN=1

                  HAL_SYSTICK_Config PROC
;;;244      */
;;;245    uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
000000  1e40              SUBS     r0,r0,#1
000002  f1b07f80          CMP      r0,#0x1000000
;;;246    {
000006  b510              PUSH     {r4,lr}
000008  d301              BCC      |L17.14|
00000a  2001              MOVS     r0,#1
;;;247       return SysTick_Config(TicksNumb);
;;;248    }
00000c  bd10              POP      {r4,pc}
                  |L17.14|
00000e  f04f24e0          MOV      r4,#0xe000e000
000012  6160              STR      r0,[r4,#0x14]
000014  210f              MOVS     r1,#0xf
000016  1760              ASRS     r0,r4,#29
000018  f7fffffe          BL       __NVIC_SetPriority
00001c  2000              MOVS     r0,#0
00001e  61a0              STR      r0,[r4,#0x18]
000020  2107              MOVS     r1,#7
000022  6121              STR      r1,[r4,#0x10]
000024  bd10              POP      {r4,pc}
;;;249    /**
                          ENDP


                          AREA ||i.HAL_SYSTICK_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_SYSTICK_IRQHandler PROC
;;;487      */
;;;488    void HAL_SYSTICK_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;489    {
;;;490      HAL_SYSTICK_Callback();
000002  f7fffffe          BL       HAL_SYSTICK_Callback
;;;491    }
000006  bd10              POP      {r4,pc}
;;;492    
                          ENDP


                          AREA ||i.__NVIC_SetPriority||, CODE, READONLY, ALIGN=1

                  __NVIC_SetPriority PROC
;;;2012    */
;;;2013   __STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
000000  0709              LSLS     r1,r1,#28
;;;2014   {
;;;2015     if ((int32_t)(IRQn) >= 0)
000002  2800              CMP      r0,#0
;;;2016     {
;;;2017       NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
000004  ea4f6111          LSR      r1,r1,#24
000008  db04              BLT      |L19.20|
00000a  f10020e0          ADD      r0,r0,#0xe000e000     ;2014
00000e  f8801400          STRB     r1,[r0,#0x400]
;;;2018     }
;;;2019     else
;;;2020     {
;;;2021       SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
;;;2022     }
;;;2023   }
000012  4770              BX       lr
                  |L19.20|
000014  f000000f          AND      r0,r0,#0xf            ;2021
000018  f10020e0          ADD      r0,r0,#0xe000e000     ;2021
00001c  f8801d14          STRB     r1,[r0,#0xd14]        ;2021
000020  4770              BX       lr
;;;2024   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F7_V1.11.0\\Drivers\\STM32F7xx_HAL_Driver\\Src\\stm32f7xx_hal_cortex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f7xx_hal_cortex_c_2992dbc0____REV16|
#line 468 "D:\\Program_Files_x86\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.3.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___22_stm32f7xx_hal_cortex_c_2992dbc0____REV16| PROC
#line 469

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f7xx_hal_cortex_c_2992dbc0____REVSH|
#line 483
|__asm___22_stm32f7xx_hal_cortex_c_2992dbc0____REVSH| PROC
#line 484

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f7xx_hal_cortex_c_2992dbc0____RRX|
#line 670
|__asm___22_stm32f7xx_hal_cortex_c_2992dbc0____RRX| PROC
#line 671

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
