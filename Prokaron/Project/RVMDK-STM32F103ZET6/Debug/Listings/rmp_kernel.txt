; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\rmp_kernel.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\rmp_kernel.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F1_V1.6.0\Drivers\STM32F1xx_HAL_Driver\Inc -I..\..\..\M0P0_Library\STM32Cube_FW_F1_V1.6.0\Drivers\CMSIS\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F1_V1.6.0\Drivers\CMSIS\Device\ST\STM32F1xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F1_V1.6.0\Drivers\STM32F1xx_HAL_Driver\Inc\Conf -I..\RVMDK-STM32F103ZET6 -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F103ZET6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F10X_HD -DUSE_HAL_DRIVER -DSTM32F103xE -W --enum_is_int --signed_chars --omf_browse=.\debug\output\rmp_kernel.crf ..\..\MProkaron\Kernel\rmp_kernel.c]
                          THUMB

                          AREA ||i.RMP_CRC16||, CODE, READONLY, ALIGN=2

                  RMP_CRC16 PROC
;;;280    #ifdef __RMP_U16_T__
;;;281    rmp_ptr_t RMP_CRC16(const rmp_u8_t* Data, rmp_ptr_t Length)
000000  b530              PUSH     {r4,r5,lr}
;;;282    {
000002  b0c1              SUB      sp,sp,#0x104
000004  460d              MOV      r5,r1
000006  4604              MOV      r4,r0
;;;283        rmp_ptr_t Data_Cnt;
;;;284        rmp_u8_t Index;
;;;285        rmp_u8_t Temp_High;
;;;286        rmp_u8_t Temp_Low;
;;;287        
;;;288        /* CRC16 constants with X^16+X^15+X^2+1 */
;;;289        static const rmp_u8_t CRC16_High[256]=
;;;290        {
;;;291            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;292            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;293            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;294            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;295            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;296            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;297            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;298            0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;299            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;300            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;301            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;302            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;303            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;304            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;305            0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;306            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;307            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;308            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;309            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;310            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;311            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;312            0x00, 0xC1, 0x81, 0x40
;;;313        };
;;;314    
;;;315        const rmp_u8_t CRC16_Low[256]=
000008  f44f7280          MOV      r2,#0x100
00000c  490c              LDR      r1,|L1.64|
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       __aeabi_memcpy4
;;;316        {
;;;317            0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7,
;;;318            0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E,
;;;319            0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9,
;;;320            0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC,
;;;321            0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
;;;322            0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32,
;;;323            0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D,
;;;324            0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38,
;;;325            0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF,
;;;326            0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
;;;327            0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1,
;;;328            0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4,
;;;329            0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB,
;;;330            0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA,
;;;331            0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
;;;332            0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0,
;;;333            0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97,
;;;334            0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E,
;;;335            0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89,
;;;336            0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
;;;337            0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83,
;;;338            0x41, 0x81, 0x80, 0x40
;;;339        };
;;;340    
;;;341        Temp_High=0xFF;
000014  23ff              MOVS     r3,#0xff
;;;342        Temp_Low=0xFF;
000016  461a              MOV      r2,r3
;;;343        for(Data_Cnt=0;Data_Cnt<Length;Data_Cnt++)
000018  2d00              CMP      r5,#0
00001a  bf1c              ITT      NE                    ;315
00001c  46ec              MOVNE    r12,sp                ;315
;;;344        {
;;;345            Index=Temp_Low^Data[Data_Cnt];
;;;346            Temp_Low=(rmp_u8_t)(Temp_High^CRC16_High[Index]);
00001e  4909              LDRNE    r1,|L1.68|
000020  d009              BEQ      |L1.54|
000022  bf00              NOP                            ;345
                  |L1.36|
000024  f8140b01          LDRB     r0,[r4],#1            ;345
000028  4050              EORS     r0,r0,r2              ;345
00002a  5c0a              LDRB     r2,[r1,r0]
00002c  405a              EORS     r2,r2,r3
;;;347            Temp_High=CRC16_Low[Index];
00002e  f81c3000          LDRB     r3,[r12,r0]
000032  1e6d              SUBS     r5,r5,#1
000034  d1f6              BNE      |L1.36|
                  |L1.54|
;;;348        }
;;;349    
;;;350        return (rmp_u16_t)(((rmp_u16_t)Temp_High)<<8|Temp_Low);
;;;351    }
000036  b041              ADD      sp,sp,#0x104
000038  ea422003          ORR      r0,r2,r3,LSL #8       ;350
00003c  bd30              POP      {r4,r5,pc}
;;;352    #endif
                          ENDP

00003e  0000              DCW      0x0000
                  |L1.64|
                          DCD      ||.constdata||+0x200
                  |L1.68|
                          DCD      ||.constdata||+0x100

                          AREA ||i.RMP_Clear||, CODE, READONLY, ALIGN=1

                  RMP_Clear PROC
;;;67     ******************************************************************************/
;;;68     void RMP_Clear(volatile void* Addr, rmp_ptr_t Size)
000000  2900              CMP      r1,#0
;;;69     {
;;;70         rmp_u8_t* Ptr;
;;;71         rmp_cnt_t Count;
;;;72        
;;;73         Ptr=(rmp_u8_t*)Addr;
;;;74         for(Count=0;Count<(rmp_cnt_t)Size;Count++)
;;;75             Ptr[Count]=0;
;;;76     }
000002  bfd8              IT       LE
000004  4770              BXLE     lr
000006  f0110f01          TST      r1,#1
00000a  f04f0200          MOV      r2,#0
00000e  f1a00001          SUB      r0,r0,#1
000012  bf18              IT       NE                    ;75
000014  f8002f01          STRBNE   r2,[r0,#1]!           ;75
000018  1049              ASRS     r1,r1,#1              ;74
00001a  bf08              IT       EQ
00001c  4770              BXEQ     lr
                  |L2.30|
00001e  7042              STRB     r2,[r0,#1]            ;75
000020  f8002f02          STRB     r2,[r0,#2]!           ;75
000024  1e49              SUBS     r1,r1,#1              ;75
000026  d1fa              BNE      |L2.30|
000028  4770              BX       lr
;;;77     /* End Function:RMP_Clear ****************************************************/
                          ENDP


                          AREA ||i.RMP_Free||, CODE, READONLY, ALIGN=1

                  RMP_Free PROC
;;;2518   ******************************************************************************/
;;;2519   void RMP_Free(volatile void* Pool, void* Mem_Ptr)
000000  2800              CMP      r0,#0
;;;2520   {
;;;2521       volatile struct RMP_Mem* Mem; 
;;;2522       volatile struct RMP_Mem_Head* Mem_Head;
;;;2523       volatile struct RMP_Mem_Head* Left_Head;
;;;2524       volatile struct RMP_Mem_Head* Right_Head;
;;;2525       rmp_cnt_t Merge_Left;
;;;2526   
;;;2527       /* Check if pointer is null */
;;;2528       if((Pool==0)||(Mem_Ptr==0))
000002  bf1c              ITT      NE
000004  2900              CMPNE    r1,#0
;;;2529       {
;;;2530           RMP_COVERAGE_MARKER();
;;;2531           return;
;;;2532       }
;;;2533       else
;;;2534           RMP_COVERAGE_MARKER();
;;;2535       
;;;2536       /* See if the address is within the allocatable address range. If not, abort directly. */
;;;2537       Mem=(volatile struct RMP_Mem*)Pool;
;;;2538       if((((rmp_ptr_t)Mem_Ptr)<=((rmp_ptr_t)Mem))||(((rmp_ptr_t)Mem_Ptr)>=(((rmp_ptr_t)Mem)+Mem->Size)))
000006  4281              CMPNE    r1,r0
;;;2539       {
;;;2540           RMP_COVERAGE_MARKER();
;;;2541           return;
;;;2542       }
;;;2543       else
;;;2544           RMP_COVERAGE_MARKER();
;;;2545   
;;;2546       Mem_Head=(struct RMP_Mem_Head*)(((rmp_ptr_t)Mem_Ptr)-sizeof(struct RMP_Mem_Head));
;;;2547       /* See if the block can really be freed */
;;;2548       if(Mem_Head->State==RMP_MEM_FREE)
;;;2549       {
;;;2550           RMP_COVERAGE_MARKER();
;;;2551           return;
;;;2552       }
;;;2553       else
;;;2554           RMP_COVERAGE_MARKER();
;;;2555   
;;;2556       /* Mark it as free */
;;;2557       Mem_Head->State=RMP_MEM_FREE;
;;;2558       
;;;2559       /* Now check if we can merge it with the higher blocks */
;;;2560       Right_Head=(struct RMP_Mem_Head*)(((rmp_ptr_t)(Mem_Head->Tail))+sizeof(struct RMP_Mem_Tail));
;;;2561       if(((rmp_ptr_t)Right_Head)!=(((rmp_ptr_t)Mem)+Mem->Size))
;;;2562       {
;;;2563           RMP_COVERAGE_MARKER();
;;;2564           /* If this one is unoccupied */
;;;2565           if((Right_Head->State)==RMP_MEM_FREE)
;;;2566           {
;;;2567               RMP_COVERAGE_MARKER();
;;;2568               /* Delete, merge */
;;;2569               _RMP_Mem_Del(Pool,Right_Head);
;;;2570               _RMP_Mem_Block(Mem_Head,
;;;2571                              ((rmp_ptr_t)(Right_Head->Tail))+sizeof(struct RMP_Mem_Tail)-(rmp_ptr_t)Mem_Head);
;;;2572           }
;;;2573           else
;;;2574               RMP_COVERAGE_MARKER();
;;;2575       }
;;;2576       else
;;;2577           RMP_COVERAGE_MARKER();
;;;2578   
;;;2579       /* Now check if we can merge it with the lower blocks */
;;;2580       Merge_Left=0;
;;;2581       if((rmp_ptr_t)Mem_Head!=Mem->Start)
;;;2582       {
;;;2583           RMP_COVERAGE_MARKER();
;;;2584           Left_Head=((struct RMP_Mem_Tail*)(((rmp_ptr_t)Mem_Head)-sizeof(struct RMP_Mem_Tail)))->Head;
;;;2585   
;;;2586           /* If this one is unoccupied */
;;;2587           if(Left_Head->State==RMP_MEM_FREE)
;;;2588           {
;;;2589               RMP_COVERAGE_MARKER();
;;;2590               /* Delete, merge */
;;;2591               _RMP_Mem_Del(Pool, Left_Head);
;;;2592               _RMP_Mem_Block(Left_Head,
;;;2593                              (rmp_ptr_t)((rmp_ptr_t)(Mem_Head->Tail)+sizeof(struct RMP_Mem_Tail)-(rmp_ptr_t)Left_Head));
;;;2594   
;;;2595               /* We have completed the merge here and the original block has destroyed.
;;;2596                * Thus there's no need to insert it into the list again */
;;;2597               Merge_Left=1;
;;;2598           }
;;;2599           else
;;;2600               RMP_COVERAGE_MARKER();
;;;2601       }
;;;2602       else
;;;2603           RMP_COVERAGE_MARKER();
;;;2604   
;;;2605       /* If we did not merge it with the left-side blocks, insert the original pointer's block 
;;;2606        * into the TLSF table(Merging with the right-side one won't disturb this) */
;;;2607       if(Merge_Left==0)
;;;2608       {
;;;2609           RMP_COVERAGE_MARKER();
;;;2610           _RMP_Mem_Ins(Pool, Mem_Head);
;;;2611       }
;;;2612       else
;;;2613       {
;;;2614           RMP_COVERAGE_MARKER();
;;;2615           _RMP_Mem_Ins(Pool, Left_Head);
;;;2616       }
;;;2617   }
000008  bf98              IT       LS
00000a  4770              BXLS     lr
00000c  e92d47f0          PUSH     {r4-r10,lr}           ;2520
000010  6882              LDR      r2,[r0,#8]            ;2538
000012  4604              MOV      r4,r0                 ;2520
000014  1910              ADDS     r0,r2,r4              ;2538
000016  4288              CMP      r0,r1                 ;2538
000018  bf98              IT       LS
00001a  e8bd87f0          POPLS    {r4-r10,pc}
00001e  f1a10610          SUB      r6,r1,#0x10           ;2546
000022  f8510c08          LDR      r0,[r1,#-8]           ;2548
000026  2800              CMP      r0,#0                 ;2548
000028  bf08              IT       EQ
00002a  e8bd87f0          POPEQ    {r4-r10,pc}
00002e  f04f0800          MOV      r8,#0                 ;2557
000032  f8c68008          STR      r8,[r6,#8]            ;2557
000036  68f0              LDR      r0,[r6,#0xc]          ;2560
000038  68a1              LDR      r1,[r4,#8]            ;2561
00003a  1d05              ADDS     r5,r0,#4              ;2560
00003c  1908              ADDS     r0,r1,r4              ;2561
00003e  2701              MOVS     r7,#1                 ;2561
000040  42a8              CMP      r0,r5                 ;2561
000042  d031              BEQ      |L3.168|
000044  68a8              LDR      r0,[r5,#8]            ;2565
000046  bb78              CBNZ     r0,|L3.168|
000048  68e8              LDR      r0,[r5,#0xc]          ;2565
00004a  46a2              MOV      r10,r4                ;2569
00004c  1b40              SUBS     r0,r0,r5              ;2569
00004e  f1a00910          SUB      r9,r0,#0x10           ;2569
000052  4648              MOV      r0,r9                 ;2569
000054  f7fffffe          BL       RMP_MSB_Get
000058  1ec1              SUBS     r1,r0,#3              ;2569
00005a  fa29f101          LSR      r1,r9,r1              ;2569
00005e  f0010107          AND      r1,r1,#7              ;2569
000062  1f80              SUBS     r0,r0,#6              ;2569
000064  eb0100c0          ADD      r0,r1,r0,LSL #3       ;2569
000068  f8da100c          LDR      r1,[r10,#0xc]         ;2569
00006c  682a              LDR      r2,[r5,#0]            ;2569
00006e  eb0101c0          ADD      r1,r1,r0,LSL #3       ;2569
000072  686b              LDR      r3,[r5,#4]            ;2569
000074  601a              STR      r2,[r3,#0]            ;2569
000076  6053              STR      r3,[r2,#4]            ;2569
000078  684a              LDR      r2,[r1,#4]            ;2569
00007a  428a              CMP      r2,r1                 ;2569
00007c  d10a              BNE      |L3.148|
00007e  0941              LSRS     r1,r0,#5              ;2569
000080  eb0a0181          ADD      r1,r10,r1,LSL #2      ;2569
000084  690a              LDR      r2,[r1,#0x10]         ;2569
000086  f000001f          AND      r0,r0,#0x1f           ;2569
00008a  fa07f000          LSL      r0,r7,r0              ;2569
00008e  ea220000          BIC      r0,r2,r0              ;2569
000092  6108              STR      r0,[r1,#0x10]         ;2569
                  |L3.148|
000094  68e8              LDR      r0,[r5,#0xc]          ;2570
000096  f8c68008          STR      r8,[r6,#8]            ;2570
00009a  1b80              SUBS     r0,r0,r6              ;2570
00009c  1d00              ADDS     r0,r0,#4              ;2570
00009e  4430              ADD      r0,r0,r6              ;2570
0000a0  1f00              SUBS     r0,r0,#4              ;2570
0000a2  60f0              STR      r0,[r6,#0xc]          ;2570
0000a4  68f0              LDR      r0,[r6,#0xc]          ;2570
0000a6  6006              STR      r6,[r0,#0]            ;2570
                  |L3.168|
0000a8  6860              LDR      r0,[r4,#4]            ;2581
0000aa  42b0              CMP      r0,r6                 ;2581
0000ac  d003              BEQ      |L3.182|
0000ae  f8565c04          LDR      r5,[r6,#-4]           ;2584
0000b2  68a8              LDR      r0,[r5,#8]            ;2587
0000b4  b328              CBZ      r0,|L3.258|
                  |L3.182|
0000b6  68f0              LDR      r0,[r6,#0xc]          ;2587
0000b8  1b80              SUBS     r0,r0,r6              ;2587
0000ba  f1a00510          SUB      r5,r0,#0x10           ;2587
0000be  4628              MOV      r0,r5                 ;2587
0000c0  f7fffffe          BL       RMP_MSB_Get
0000c4  1ec1              SUBS     r1,r0,#3              ;2587
0000c6  fa25f101          LSR      r1,r5,r1              ;2587
0000ca  f0010107          AND      r1,r1,#7              ;2587
0000ce  1f80              SUBS     r0,r0,#6              ;2587
0000d0  eb0101c0          ADD      r1,r1,r0,LSL #3       ;2587
0000d4  68e0              LDR      r0,[r4,#0xc]          ;2587
0000d6  eb0000c1          ADD      r0,r0,r1,LSL #3       ;2587
0000da  6842              LDR      r2,[r0,#4]            ;2587
0000dc  4282              CMP      r2,r0                 ;2587
0000de  d109              BNE      |L3.244|
0000e0  094a              LSRS     r2,r1,#5              ;2587
0000e2  eb040282          ADD      r2,r4,r2,LSL #2       ;2587
0000e6  6913              LDR      r3,[r2,#0x10]         ;2587
0000e8  f001011f          AND      r1,r1,#0x1f           ;2587
0000ec  fa07f101          LSL      r1,r7,r1              ;2587
0000f0  4319              ORRS     r1,r1,r3              ;2587
0000f2  6111              STR      r1,[r2,#0x10]         ;2587
                  |L3.244|
0000f4  6841              LDR      r1,[r0,#4]            ;2587
0000f6  600e              STR      r6,[r1,#0]            ;2587
0000f8  6071              STR      r1,[r6,#4]            ;2587
0000fa  6030              STR      r0,[r6,#0]            ;2587
0000fc  6046              STR      r6,[r0,#4]            ;2587
0000fe  e8bd87f0          POP      {r4-r10,pc}
                  |L3.258|
000102  68e8              LDR      r0,[r5,#0xc]
000104  1b40              SUBS     r0,r0,r5
000106  f1a00910          SUB      r9,r0,#0x10
00010a  4648              MOV      r0,r9
00010c  f7fffffe          BL       RMP_MSB_Get
000110  1ec1              SUBS     r1,r0,#3
000112  fa29f101          LSR      r1,r9,r1
000116  f0010107          AND      r1,r1,#7
00011a  1f80              SUBS     r0,r0,#6
00011c  eb0100c0          ADD      r0,r1,r0,LSL #3
000120  68e1              LDR      r1,[r4,#0xc]
000122  682a              LDR      r2,[r5,#0]
000124  eb0101c0          ADD      r1,r1,r0,LSL #3
000128  686b              LDR      r3,[r5,#4]
00012a  601a              STR      r2,[r3,#0]
00012c  6053              STR      r3,[r2,#4]
00012e  684a              LDR      r2,[r1,#4]
000130  428a              CMP      r2,r1
000132  d10a              BNE      |L3.330|
000134  0942              LSRS     r2,r0,#5
000136  eb040182          ADD      r1,r4,r2,LSL #2
00013a  690a              LDR      r2,[r1,#0x10]
00013c  f000001f          AND      r0,r0,#0x1f
000140  fa07f000          LSL      r0,r7,r0
000144  ea220000          BIC      r0,r2,r0
000148  6108              STR      r0,[r1,#0x10]
                  |L3.330|
00014a  68f0              LDR      r0,[r6,#0xc]          ;2592
00014c  f8c58008          STR      r8,[r5,#8]            ;2592
000150  1b40              SUBS     r0,r0,r5              ;2592
000152  1d00              ADDS     r0,r0,#4              ;2592
000154  4428              ADD      r0,r0,r5              ;2592
000156  1f00              SUBS     r0,r0,#4              ;2592
000158  60e8              STR      r0,[r5,#0xc]          ;2592
00015a  68e8              LDR      r0,[r5,#0xc]          ;2592
00015c  6005              STR      r5,[r0,#0]            ;2592
00015e  68e8              LDR      r0,[r5,#0xc]          ;2592
000160  1b40              SUBS     r0,r0,r5              ;2592
000162  f1a00610          SUB      r6,r0,#0x10           ;2592
000166  4630              MOV      r0,r6                 ;2592
000168  f7fffffe          BL       RMP_MSB_Get
00016c  1ec1              SUBS     r1,r0,#3              ;2592
00016e  fa26f101          LSR      r1,r6,r1              ;2592
000172  f0010107          AND      r1,r1,#7              ;2592
000176  1f80              SUBS     r0,r0,#6              ;2592
000178  eb0101c0          ADD      r1,r1,r0,LSL #3       ;2592
00017c  68e0              LDR      r0,[r4,#0xc]          ;2592
00017e  eb0000c1          ADD      r0,r0,r1,LSL #3       ;2592
000182  6842              LDR      r2,[r0,#4]            ;2592
000184  4282              CMP      r2,r0                 ;2592
000186  d109              BNE      |L3.412|
000188  094a              LSRS     r2,r1,#5              ;2597
00018a  eb040282          ADD      r2,r4,r2,LSL #2       ;2597
00018e  6913              LDR      r3,[r2,#0x10]         ;2597
000190  f001011f          AND      r1,r1,#0x1f           ;2597
000194  fa07f101          LSL      r1,r7,r1              ;2597
000198  4319              ORRS     r1,r1,r3              ;2597
00019a  6111              STR      r1,[r2,#0x10]         ;2597
                  |L3.412|
00019c  6841              LDR      r1,[r0,#4]            ;2597
00019e  600d              STR      r5,[r1,#0]            ;2597
0001a0  6069              STR      r1,[r5,#4]            ;2597
0001a2  6028              STR      r0,[r5,#0]            ;2597
0001a4  6045              STR      r5,[r0,#4]            ;2597
0001a6  e8bd87f0          POP      {r4-r10,pc}
;;;2618   /* End Function:RMP_Free *****************************************************/
                          ENDP


                          AREA ||i.RMP_Init||, CODE, READONLY, ALIGN=2

                  RMP_Init PROC
;;;1971   ******************************************************************************/
;;;1972   void RMP_Init(void)
000000  20ff              MOVS     r0,#0xff
000002  f7fffffe          BL       RMP_Mask_Int
000006  4808              LDR      r0,|L4.40|
000008  2101              MOVS     r1,#1
00000a  6081              STR      r1,[r0,#8]  ; RMP_Sched_Locked
00000c  6841              LDR      r1,[r0,#4]  ; RMP_Sched_Lock_Cnt
00000e  1c49              ADDS     r1,r1,#1
000010  6041              STR      r1,[r0,#4]  ; RMP_Sched_Lock_Cnt
;;;1973   {
;;;1974       RMP_Lock_Sched();
;;;1975       
;;;1976       /* Platform will use this hook to do something */
;;;1977       _RMP_Plat_Hook();
000012  f7fffffe          BL       _RMP_Plat_Hook
;;;1978       /* Start the second thread here */
;;;1979       RMP_Init_Hook();
000016  f7fffffe          BL       RMP_Init_Hook
;;;1980       
;;;1981       RMP_Unlock_Sched();
00001a  f7fffffe          BL       RMP_Unlock_Sched
;;;1982       
;;;1983       while(1)
;;;1984           RMP_Init_Idle();
00001e  bf00              NOP      
                  |L4.32|
000020  f7fffffe          BL       RMP_Init_Idle
000024  e7fc              B        |L4.32|
;;;1985   }
;;;1986   /* End Function:RMP_Init *****************************************************/
                          ENDP

000026  0000              DCW      0x0000
                  |L4.40|
                          DCD      ||.data||

                          AREA ||i.RMP_LSB_Get||, CODE, READONLY, ALIGN=2

                  RMP_LSB_Get PROC
;;;2119   ******************************************************************************/
;;;2120   rmp_ptr_t RMP_LSB_Get(rmp_ptr_t Val)
000000  4a0c              LDR      r2,|L5.52|
;;;2121   {
000002  b510              PUSH     {r4,lr}
000004  0e03              LSRS     r3,r0,#24
000006  4601              MOV      r1,r0
000008  5cd3              LDRB     r3,[r2,r3]
00000a  f3630007          BFI      r0,r3,#0,#8
00000e  f3c14307          UBFX     r3,r1,#16,#8
000012  5cd3              LDRB     r3,[r2,r3]
000014  f363200f          BFI      r0,r3,#8,#8
000018  f3c12307          UBFX     r3,r1,#8,#8
00001c  b2c9              UXTB     r1,r1
00001e  5cd3              LDRB     r3,[r2,r3]
000020  5c51              LDRB     r1,[r2,r1]
000022  f3634017          BFI      r0,r3,#16,#8
000026  f361601f          BFI      r0,r1,#24,#8
;;;2122       return RMP_WORD_SIZE-1-RMP_MSB_Get(RMP_RBIT_Get(Val));
00002a  f7fffffe          BL       RMP_MSB_Get
00002e  f1c0001f          RSB      r0,r0,#0x1f
;;;2123   }
000032  bd10              POP      {r4,pc}
;;;2124   /* End Function:RMP_LSB_Get **************************************************/
                          ENDP

                  |L5.52|
                          DCD      ||.constdata||

                          AREA ||i.RMP_List_Crt||, CODE, READONLY, ALIGN=1

                  RMP_List_Crt PROC
;;;231    ******************************************************************************/
;;;232    void RMP_List_Crt(volatile struct RMP_List* Head)
000000  6000              STR      r0,[r0,#0]
;;;233    {
;;;234        Head->Prev=(struct RMP_List*)Head;
;;;235        Head->Next=(struct RMP_List*)Head;
000002  6040              STR      r0,[r0,#4]
;;;236    }
000004  4770              BX       lr
;;;237    /* End Function:RMP_List_Crt *************************************************/
                          ENDP


                          AREA ||i.RMP_List_Del||, CODE, READONLY, ALIGN=1

                  RMP_List_Del PROC
;;;245    ******************************************************************************/
;;;246    void RMP_List_Del(volatile struct RMP_List* Prev,volatile struct RMP_List* Next)
000000  6008              STR      r0,[r1,#0]
;;;247    {
;;;248        Next->Prev=(struct RMP_List*)Prev;
;;;249        Prev->Next=(struct RMP_List*)Next;
000002  6041              STR      r1,[r0,#4]
;;;250    }
000004  4770              BX       lr
;;;251    /* End Function:RMP_List_Del *************************************************/
                          ENDP


                          AREA ||i.RMP_List_Ins||, CODE, READONLY, ALIGN=1

                  RMP_List_Ins PROC
;;;260    ******************************************************************************/
;;;261    void RMP_List_Ins(volatile struct RMP_List* New,
000000  6010              STR      r0,[r2,#0]
;;;262                      volatile struct RMP_List* Prev,
;;;263                      volatile struct RMP_List* Next)
;;;264    {
;;;265        Next->Prev=(struct RMP_List*)New;
;;;266        New->Next=(struct RMP_List*)Next;
000002  6042              STR      r2,[r0,#4]
;;;267        New->Prev=(struct RMP_List*)Prev;
000004  6001              STR      r1,[r0,#0]
;;;268        Prev->Next=(struct RMP_List*)New;
000006  6048              STR      r0,[r1,#4]
;;;269    }
000008  4770              BX       lr
;;;270    /* End Function:RMP_List_Ins *************************************************/
                          ENDP


                          AREA ||i.RMP_Load_Ctx||, CODE, READONLY, ALIGN=1

                  RMP_Load_Ctx PROC
;;;1956   #if(RMP_USE_HOOKS==RMP_FALSE)
;;;1957   void RMP_Load_Ctx(void)
000000  4770              BX       lr
;;;1958   {
;;;1959       return;
;;;1960   }
;;;1961   #endif
                          ENDP


                          AREA ||i.RMP_Lock_Sched||, CODE, READONLY, ALIGN=2

                  RMP_Lock_Sched PROC
;;;361    ******************************************************************************/
;;;362    void RMP_Lock_Sched(void)
000000  b510              PUSH     {r4,lr}
;;;363    {
;;;364        RMP_MASK_INT();
000002  20ff              MOVS     r0,#0xff
000004  f7fffffe          BL       RMP_Mask_Int
;;;365        RMP_Sched_Locked=1;
000008  4803              LDR      r0,|L10.24|
00000a  2101              MOVS     r1,#1
00000c  6081              STR      r1,[r0,#8]  ; RMP_Sched_Locked
;;;366        RMP_Sched_Lock_Cnt++;
00000e  6841              LDR      r1,[r0,#4]  ; RMP_Sched_Lock_Cnt
000010  1c49              ADDS     r1,r1,#1
000012  6041              STR      r1,[r0,#4]  ; RMP_Sched_Lock_Cnt
;;;367    }
000014  bd10              POP      {r4,pc}
;;;368    /* End Function:RMP_Lock_Sched ***********************************************/
                          ENDP

000016  0000              DCW      0x0000
                  |L10.24|
                          DCD      ||.data||

                          AREA ||i.RMP_Malloc||, CODE, READONLY, ALIGN=2

                  RMP_Malloc PROC
;;;2445   ******************************************************************************/
;;;2446   void* RMP_Malloc(volatile void* Pool, rmp_ptr_t Size)                                                       
000000  2800              CMP      r0,#0
;;;2447   {    
;;;2448       rmp_cnt_t FLI_Level;
;;;2449       rmp_cnt_t SLI_Level;
;;;2450       volatile struct RMP_Mem* Mem;
;;;2451       rmp_ptr_t Old_Size;
;;;2452       volatile struct RMP_Mem_Head* Mem_Head;
;;;2453       rmp_ptr_t Rounded_Size;
;;;2454       volatile struct RMP_Mem_Head* New_Mem;
;;;2455       rmp_ptr_t New_Size;
;;;2456       
;;;2457       if((Pool==0)||(Size==0))
000002  bf12              ITEE     NE
000004  2900              CMPNE    r1,#0
;;;2458       {
;;;2459           RMP_COVERAGE_MARKER();
;;;2460           return (void*)(0);
000006  2000              MOVEQ    r0,#0
;;;2461       }
;;;2462       else
;;;2463           RMP_COVERAGE_MARKER();
;;;2464       
;;;2465       /* Round up the size:a multiple of 8 and bigger than 64B */
;;;2466       Rounded_Size=RMP_ROUND_UP(Size,3);
;;;2467       /* See if it is smaller than the smallest block */
;;;2468       Rounded_Size=(Rounded_Size>64)?Rounded_Size:64;
;;;2469   
;;;2470       /* See if such block exists, if not, abort */
;;;2471       if(_RMP_Mem_Search(Pool,Rounded_Size,&FLI_Level,&SLI_Level)!=0)
;;;2472       {
;;;2473           RMP_COVERAGE_MARKER();
;;;2474           return (void*)(0);
;;;2475       }
;;;2476       else
;;;2477           RMP_COVERAGE_MARKER();
;;;2478       
;;;2479       Mem=(volatile struct RMP_Mem*)Pool;
;;;2480       
;;;2481       /* There is such block. Get it and delete it from the TLSF list. */
;;;2482       Mem_Head=(struct RMP_Mem_Head*)(Mem->Table[RMP_MEM_POS(FLI_Level,SLI_Level)].Next);
;;;2483       _RMP_Mem_Del(Pool, Mem_Head);
;;;2484   
;;;2485       /* Allocate and calculate if the space left could be big enough to be a new 
;;;2486        * block. If so, we will put the block back into the TLSF table */
;;;2487       New_Size=((rmp_ptr_t)(Mem_Head->Tail))-((rmp_ptr_t)Mem_Head)-sizeof(struct RMP_Mem_Head)-Rounded_Size;
;;;2488       if(New_Size>=(sizeof(struct RMP_Mem_Head)+64+sizeof(struct RMP_Mem_Tail)))
;;;2489       {
;;;2490           RMP_COVERAGE_MARKER();
;;;2491           Old_Size=sizeof(struct RMP_Mem_Head)+Rounded_Size+sizeof(struct RMP_Mem_Tail);
;;;2492           New_Mem=(volatile struct RMP_Mem_Head*)(((rmp_ptr_t)Mem_Head)+Old_Size);
;;;2493   
;;;2494           _RMP_Mem_Block(Mem_Head, Old_Size);
;;;2495           _RMP_Mem_Block(New_Mem, New_Size);
;;;2496   
;;;2497           /* Put the extra block back */
;;;2498           _RMP_Mem_Ins(Pool, New_Mem);
;;;2499       }
;;;2500       else
;;;2501           RMP_COVERAGE_MARKER();
;;;2502   
;;;2503       /* Mark the block as in use */
;;;2504       Mem_Head->State=RMP_MEM_USED;
;;;2505   
;;;2506       /* Finally, return the start address */
;;;2507       return (void*)(((rmp_ptr_t)Mem_Head)+sizeof(struct RMP_Mem_Head));
;;;2508   }
000008  4770              BXEQ     lr
00000a  e92d5ff0          PUSH     {r4-r12,lr}           ;2447
00000e  4604              MOV      r4,r0                 ;2447
000010  1dc8              ADDS     r0,r1,#7              ;2466
000012  f0200707          BIC      r7,r0,#7              ;2466
000016  2f40              CMP      r7,#0x40              ;2468
000018  bf98              IT       LS                    ;2468
00001a  2740              MOVLS    r7,#0x40              ;2468
00001c  4638              MOV      r0,r7                 ;2468
00001e  f7fffffe          BL       RMP_MSB_Get
000022  1f81              SUBS     r1,r0,#6              ;2468
000024  1ec2              SUBS     r2,r0,#3              ;2468
000026  fa27f002          LSR      r0,r7,r2              ;2468
00002a  f0000007          AND      r0,r0,#7              ;2468
00002e  f1000308          ADD      r3,r0,#8              ;2468
000032  fa03f202          LSL      r2,r3,r2              ;2468
000036  42ba              CMP      r2,r7                 ;2468
000038  d004              BEQ      |L11.68|
00003a  1c40              ADDS     r0,r0,#1              ;2468
00003c  2808              CMP      r0,#8                 ;2468
00003e  bf04              ITT      EQ                    ;2468
000040  2000              MOVEQ    r0,#0                 ;2468
000042  1c49              ADDEQ    r1,r1,#1              ;2468
                  |L11.68|
000044  4625              MOV      r5,r4                 ;2468
000046  6822              LDR      r2,[r4,#0]            ;2468
000048  4291              CMP      r1,r2                 ;2468
00004a  f08080d2          BCS.W    |L11.498|
00004e  eb0006c1          ADD      r6,r0,r1,LSL #3       ;2468
000052  1170              ASRS     r0,r6,#5              ;2468
000054  eb050080          ADD      r0,r5,r0,LSL #2       ;2468
000058  6900              LDR      r0,[r0,#0x10]         ;2468
00005a  f0060b1f          AND      r11,r6,#0x1f          ;2468
00005e  fa20f10b          LSR      r1,r0,r11             ;2468
000062  f8dfa194          LDR      r10,|L11.504|
000066  0e0a              LSRS     r2,r1,#24             ;2468
000068  f81a2002          LDRB     r2,[r10,r2]           ;2468
00006c  f3620007          BFI      r0,r2,#0,#8           ;2468
000070  f3c14207          UBFX     r2,r1,#16,#8          ;2468
000074  f81a2002          LDRB     r2,[r10,r2]           ;2468
000078  f362200f          BFI      r0,r2,#8,#8           ;2468
00007c  f3c12207          UBFX     r2,r1,#8,#8           ;2468
000080  b2c9              UXTB     r1,r1                 ;2468
000082  f81a2002          LDRB     r2,[r10,r2]           ;2468
000086  f81a1001          LDRB     r1,[r10,r1]           ;2468
00008a  f3624017          BFI      r0,r2,#16,#8          ;2468
00008e  f361601f          BFI      r0,r1,#24,#8          ;2468
000092  f7fffffe          BL       RMP_MSB_Get
000096  f1c0001f          RSB      r0,r0,#0x1f           ;2468
00009a  f04f0900          MOV      r9,#0                 ;2468
00009e  f04f0801          MOV      r8,#1                 ;2468
0000a2  2820              CMP      r0,#0x20              ;2468
0000a4  d205              BCS      |L11.178|
0000a6  f026011f          BIC      r1,r6,#0x1f           ;2468
0000aa  4408              ADD      r0,r0,r1              ;2468
0000ac  4458              ADD      r0,r0,r11             ;2468
0000ae  10c1              ASRS     r1,r0,#3              ;2468
0000b0  e02b              B        |L11.266|
                  |L11.178|
0000b2  6828              LDR      r0,[r5,#0]            ;2468
0000b4  eb081666          ADD      r6,r8,r6,ASR #5       ;2468
0000b8  1cc0              ADDS     r0,r0,#3              ;2468
0000ba  0880              LSRS     r0,r0,#2              ;2468
0000bc  4286              CMP      r6,r0                 ;2468
0000be  da7d              BGE      |L11.444|
                  |L11.192|
0000c0  eb050186          ADD      r1,r5,r6,LSL #2       ;2468
0000c4  6909              LDR      r1,[r1,#0x10]         ;2468
0000c6  2900              CMP      r1,#0                 ;2468
0000c8  d079              BEQ      |L11.446|
0000ca  eb050086          ADD      r0,r5,r6,LSL #2       ;2468
0000ce  6901              LDR      r1,[r0,#0x10]         ;2468
0000d0  0e0a              LSRS     r2,r1,#24             ;2468
0000d2  f81a2002          LDRB     r2,[r10,r2]           ;2468
0000d6  f3620007          BFI      r0,r2,#0,#8           ;2468
0000da  f3c14207          UBFX     r2,r1,#16,#8          ;2468
0000de  f81a2002          LDRB     r2,[r10,r2]           ;2468
0000e2  f362200f          BFI      r0,r2,#8,#8           ;2468
0000e6  f3c12207          UBFX     r2,r1,#8,#8           ;2468
0000ea  b2c9              UXTB     r1,r1                 ;2468
0000ec  f81a2002          LDRB     r2,[r10,r2]           ;2468
0000f0  f81a1001          LDRB     r1,[r10,r1]           ;2468
0000f4  f3624017          BFI      r0,r2,#16,#8          ;2468
0000f8  f361601f          BFI      r0,r1,#24,#8          ;2468
0000fc  f7fffffe          BL       RMP_MSB_Get
000100  f1c0001f          RSB      r0,r0,#0x1f           ;2468
000104  eb001146          ADD      r1,r0,r6,LSL #5       ;2468
000108  08c9              LSRS     r1,r1,#3              ;2468
                  |L11.266|
00010a  68e2              LDR      r2,[r4,#0xc]          ;2482
00010c  f0000007          AND      r0,r0,#7              ;2482
000110  eb0000c1          ADD      r0,r0,r1,LSL #3       ;2482
000114  2104              MOVS     r1,#4                 ;2482
000116  eb0100c0          ADD      r0,r1,r0,LSL #3       ;2482
00011a  5815              LDR      r5,[r2,r0]            ;2482
00011c  68e8              LDR      r0,[r5,#0xc]          ;2482
00011e  1b40              SUBS     r0,r0,r5              ;2482
000120  f1a00610          SUB      r6,r0,#0x10           ;2482
000124  4630              MOV      r0,r6                 ;2482
000126  f7fffffe          BL       RMP_MSB_Get
00012a  1ec1              SUBS     r1,r0,#3              ;2482
00012c  fa26f101          LSR      r1,r6,r1              ;2482
000130  f0010107          AND      r1,r1,#7              ;2482
000134  1f80              SUBS     r0,r0,#6              ;2482
000136  eb0100c0          ADD      r0,r1,r0,LSL #3       ;2482
00013a  68e1              LDR      r1,[r4,#0xc]          ;2482
00013c  682a              LDR      r2,[r5,#0]            ;2482
00013e  eb0101c0          ADD      r1,r1,r0,LSL #3       ;2482
000142  686b              LDR      r3,[r5,#4]            ;2482
000144  601a              STR      r2,[r3,#0]            ;2482
000146  6053              STR      r3,[r2,#4]            ;2482
000148  684a              LDR      r2,[r1,#4]            ;2482
00014a  428a              CMP      r2,r1                 ;2482
00014c  d10a              BNE      |L11.356|
00014e  0942              LSRS     r2,r0,#5              ;2482
000150  eb040182          ADD      r1,r4,r2,LSL #2       ;2482
000154  690a              LDR      r2,[r1,#0x10]         ;2482
000156  f000001f          AND      r0,r0,#0x1f           ;2482
00015a  fa08f000          LSL      r0,r8,r0              ;2482
00015e  ea220000          BIC      r0,r2,r0              ;2482
000162  6108              STR      r0,[r1,#0x10]         ;2482
                  |L11.356|
000164  68e8              LDR      r0,[r5,#0xc]          ;2487
000166  1b40              SUBS     r0,r0,r5              ;2487
000168  1bc0              SUBS     r0,r0,r7              ;2487
00016a  3810              SUBS     r0,r0,#0x10           ;2487
00016c  2854              CMP      r0,#0x54              ;2488
00016e  d336              BCC      |L11.478|
000170  f1070114          ADD      r1,r7,#0x14           ;2491
000174  186e              ADDS     r6,r5,r1              ;2492
000176  f8c59008          STR      r9,[r5,#8]            ;2492
00017a  1f31              SUBS     r1,r6,#4              ;2492
00017c  60e9              STR      r1,[r5,#0xc]          ;2492
00017e  68e9              LDR      r1,[r5,#0xc]          ;2492
000180  600d              STR      r5,[r1,#0]            ;2492
000182  f8c69008          STR      r9,[r6,#8]            ;2492
000186  4430              ADD      r0,r0,r6              ;2492
000188  1f00              SUBS     r0,r0,#4              ;2492
00018a  60f0              STR      r0,[r6,#0xc]          ;2492
00018c  68f0              LDR      r0,[r6,#0xc]          ;2492
00018e  6006              STR      r6,[r0,#0]            ;2492
000190  68f0              LDR      r0,[r6,#0xc]          ;2492
000192  1b80              SUBS     r0,r0,r6              ;2492
000194  f1a00710          SUB      r7,r0,#0x10           ;2492
000198  4638              MOV      r0,r7                 ;2492
00019a  f7fffffe          BL       RMP_MSB_Get
00019e  1ec1              SUBS     r1,r0,#3              ;2492
0001a0  fa27f101          LSR      r1,r7,r1              ;2492
0001a4  f0010107          AND      r1,r1,#7              ;2492
0001a8  1f80              SUBS     r0,r0,#6              ;2492
0001aa  eb0101c0          ADD      r1,r1,r0,LSL #3       ;2492
0001ae  68e0              LDR      r0,[r4,#0xc]          ;2492
0001b0  eb0000c1          ADD      r0,r0,r1,LSL #3       ;2492
0001b4  6842              LDR      r2,[r0,#4]            ;2492
0001b6  4282              CMP      r2,r0                 ;2492
0001b8  d10c              BNE      |L11.468|
0001ba  e001              B        |L11.448|
                  |L11.444|
0001bc  e019              B        |L11.498|
                  |L11.446|
0001be  e014              B        |L11.490|
                  |L11.448|
0001c0  094a              LSRS     r2,r1,#5              ;2492
0001c2  eb040282          ADD      r2,r4,r2,LSL #2       ;2492
0001c6  6913              LDR      r3,[r2,#0x10]         ;2492
0001c8  f001011f          AND      r1,r1,#0x1f           ;2492
0001cc  fa08f101          LSL      r1,r8,r1              ;2492
0001d0  4319              ORRS     r1,r1,r3              ;2492
0001d2  6111              STR      r1,[r2,#0x10]         ;2492
                  |L11.468|
0001d4  6841              LDR      r1,[r0,#4]            ;2492
0001d6  600e              STR      r6,[r1,#0]            ;2492
0001d8  6071              STR      r1,[r6,#4]            ;2492
0001da  6030              STR      r0,[r6,#0]            ;2492
0001dc  6046              STR      r6,[r0,#4]            ;2492
                  |L11.478|
0001de  f8c58008          STR      r8,[r5,#8]            ;2504
0001e2  f1050010          ADD      r0,r5,#0x10           ;2507
0001e6  e8bd9ff0          POP      {r4-r12,pc}
                  |L11.490|
0001ea  1c76              ADDS     r6,r6,#1
0001ec  4286              CMP      r6,r0
0001ee  f6ffaf67          BLT      |L11.192|
                  |L11.498|
0001f2  2000              MOVS     r0,#0                 ;2474
0001f4  e8bd9ff0          POP      {r4-r12,pc}
;;;2509   /* End Function:RMP_Malloc ***************************************************/
                          ENDP

                  |L11.504|
                          DCD      ||.constdata||

                          AREA ||i.RMP_Mem_Init||, CODE, READONLY, ALIGN=2

                  RMP_Mem_Init PROC
;;;2161   ******************************************************************************/
;;;2162   rmp_ret_t RMP_Mem_Init(volatile void* Pool, rmp_ptr_t Size)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;2163   {
000004  460d              MOV      r5,r1
000006  0004              MOVS     r4,r0
000008  d009              BEQ      |L12.30|
;;;2164       rmp_cnt_t FLI_Cnt;
;;;2165       rmp_ptr_t Offset;
;;;2166       rmp_ptr_t Bitmap_Size;
;;;2167       volatile struct RMP_Mem* Mem;
;;;2168       
;;;2169       /* See if the memory pool is large enough to enable dynamic allocation - at
;;;2170        * least 1024 machine words or pool initialization will be refused */
;;;2171       if((Pool==0)||(Size<(1024*sizeof(rmp_ptr_t)))||((((rmp_ptr_t)Pool)+Size)<Size))
00000a  f5b55f80          CMP      r5,#0x1000
00000e  bf21              ITTTT    CS
000010  1960              ADDCS    r0,r4,r5
000012  42a8              CMPCS    r0,r5
;;;2172       {
;;;2173           RMP_COVERAGE_MARKER();
;;;2174           return RMP_ERR_MEM;
;;;2175       }
;;;2176       else
;;;2177           RMP_COVERAGE_MARKER();
;;;2178       
;;;2179       /* See if the address and size is word-aligned */
;;;2180       if(((((rmp_ptr_t)Pool)&RMP_ALIGN_MASK)!=0)||((Size&RMP_ALIGN_MASK)!=0))
000014  ea440005          ORRCS    r0,r4,r5
000018  f0100f03          TSTCS    r0,#3
00001c  d003              BEQ      |L12.38|
                  |L12.30|
;;;2181       {
;;;2182           RMP_COVERAGE_MARKER();
;;;2183           return RMP_ERR_MEM;
00001e  f06f0006          MVN      r0,#6
;;;2184       }
;;;2185       else
;;;2186           RMP_COVERAGE_MARKER();
;;;2187   
;;;2188       Mem=(volatile struct RMP_Mem*)Pool;
;;;2189       Mem->Size=Size;
;;;2190       /* Calculate the FLI value needed for this - we always align to 64 byte */
;;;2191       Mem->FLI_Num=RMP_MSB_Get(Size-sizeof(struct RMP_Mem))-6+1;
;;;2192       
;;;2193       /* Decide the location of the bitmap */
;;;2194       Offset=sizeof(struct RMP_Mem);
;;;2195       Bitmap_Size=RMP_ROUND_UP(Mem->FLI_Num,RMP_ALIGN_ORDER);
;;;2196       /* Initialize the bitmap */
;;;2197       for(FLI_Cnt=0;FLI_Cnt<(rmp_cnt_t)(Bitmap_Size>>RMP_ALIGN_ORDER);FLI_Cnt++)
;;;2198           Mem->Bitmap[FLI_Cnt]=0;
;;;2199       
;;;2200       /* Decide the location of the allocation table - "-sizeof(rmp_ptr_t)" is
;;;2201        * because we defined the length=1 in our struct already */
;;;2202       Offset+=Bitmap_Size-sizeof(rmp_ptr_t);
;;;2203       Mem->Table=(struct RMP_List*)(((rmp_ptr_t)Mem)+Offset);
;;;2204       /* Initialize the allocation table */
;;;2205       for(FLI_Cnt=0;FLI_Cnt<(rmp_cnt_t)(Mem->FLI_Num);FLI_Cnt++)
;;;2206       {
;;;2207           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,0)]));
;;;2208           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,1)]));
;;;2209           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,2)]));
;;;2210           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,3)]));
;;;2211           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,4)]));
;;;2212           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,5)]));
;;;2213           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,6)]));
;;;2214           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,7)]));
;;;2215       }
;;;2216       
;;;2217       /* Calculate the offset of the actual allocatable memory - each FLI have
;;;2218        * 8 SLIs, and each SLI has a corresponding table header */
;;;2219       Offset+=sizeof(struct RMP_List)*8*Mem->FLI_Num;
;;;2220       Mem->Start=((rmp_ptr_t)Mem)+Offset;
;;;2221       
;;;2222       /* Initialize the first big block */
;;;2223       _RMP_Mem_Block((struct RMP_Mem_Head*)(Mem->Start),Size-Offset);
;;;2224       /* Insert the memory into the corresponding level */
;;;2225       _RMP_Mem_Ins(Pool,(struct RMP_Mem_Head*)(Mem->Start));
;;;2226       
;;;2227       return 0;
;;;2228   }
000022  e8bd9ff0          POP      {r4-r12,pc}
                  |L12.38|
000026  60a5              STR      r5,[r4,#8]            ;2189
000028  f1a50014          SUB      r0,r5,#0x14           ;2191
00002c  f7fffffe          BL       RMP_MSB_Get
000030  1f40              SUBS     r0,r0,#5              ;2191
000032  6020              STR      r0,[r4,#0]            ;2191
000034  6820              LDR      r0,[r4,#0]            ;2195
000036  f04f0e00          MOV      lr,#0                 ;2198
00003a  1cc0              ADDS     r0,r0,#3              ;2195
00003c  f0200103          BIC      r1,r0,#3              ;2195
000040  0888              LSRS     r0,r1,#2              ;2198
000042  bf1f              ITTTT    NE                    ;2198
000044  f3c10080          UBFXNE   r0,r1,#2,#1           ;2198
000048  2800              CMPNE    r0,#0                 ;2197
00004a  4622              MOVNE    r2,r4                 ;2198
00004c  f8c4e010          STRNE    lr,[r4,#0x10]         ;2198
000050  ebb00f91          CMP      r0,r1,LSR #2          ;2197
000054  da0a              BGE      |L12.108|
000056  bf00              NOP                            ;2198
                  |L12.88|
000058  eb040280          ADD      r2,r4,r0,LSL #2       ;2198
00005c  f8c2e010          STR      lr,[r2,#0x10]         ;2198
000060  f8c2e014          STR      lr,[r2,#0x14]         ;2198
000064  1c80              ADDS     r0,r0,#2              ;2198
000066  ebb00f91          CMP      r0,r1,LSR #2          ;2198
00006a  dbf5              BLT      |L12.88|
                  |L12.108|
00006c  f1010310          ADD      r3,r1,#0x10           ;2202
000070  18e1              ADDS     r1,r4,r3              ;2203
000072  60e1              STR      r1,[r4,#0xc]          ;2203
000074  6820              LDR      r0,[r4,#0]            ;2205
000076  2200              MOVS     r2,#0                 ;2205
000078  4290              CMP      r0,r2                 ;2205
00007a  dd3d              BLE      |L12.248|
00007c  2008              MOVS     r0,#8                 ;2208
00007e  2618              MOVS     r6,#0x18              ;2210
000080  f04f0c10          MOV      r12,#0x10             ;2209
000084  2720              MOVS     r7,#0x20              ;2211
000086  f04f0828          MOV      r8,#0x28              ;2212
00008a  f04f0930          MOV      r9,#0x30              ;2213
00008e  f04f0a38          MOV      r10,#0x38             ;2214
                  |L12.146|
000092  68e1              LDR      r1,[r4,#0xc]          ;2207
000094  eb011182          ADD      r1,r1,r2,LSL #6       ;2207
000098  6009              STR      r1,[r1,#0]            ;2207
00009a  6049              STR      r1,[r1,#4]            ;2207
00009c  68e1              LDR      r1,[r4,#0xc]          ;2208
00009e  eb001b82          ADD      r11,r0,r2,LSL #6      ;2208
0000a2  4459              ADD      r1,r1,r11             ;2208
0000a4  6009              STR      r1,[r1,#0]            ;2208
0000a6  6049              STR      r1,[r1,#4]            ;2208
0000a8  68e1              LDR      r1,[r4,#0xc]          ;2209
0000aa  eb0c1b82          ADD      r11,r12,r2,LSL #6     ;2209
0000ae  4459              ADD      r1,r1,r11             ;2209
0000b0  6009              STR      r1,[r1,#0]            ;2209
0000b2  6049              STR      r1,[r1,#4]            ;2209
0000b4  68e1              LDR      r1,[r4,#0xc]          ;2210
0000b6  eb061b82          ADD      r11,r6,r2,LSL #6      ;2210
0000ba  4459              ADD      r1,r1,r11             ;2210
0000bc  6009              STR      r1,[r1,#0]            ;2210
0000be  6049              STR      r1,[r1,#4]            ;2210
0000c0  68e1              LDR      r1,[r4,#0xc]          ;2211
0000c2  eb071b82          ADD      r11,r7,r2,LSL #6      ;2211
0000c6  4459              ADD      r1,r1,r11             ;2211
0000c8  6009              STR      r1,[r1,#0]            ;2211
0000ca  6049              STR      r1,[r1,#4]            ;2211
0000cc  68e1              LDR      r1,[r4,#0xc]          ;2212
0000ce  eb081b82          ADD      r11,r8,r2,LSL #6      ;2212
0000d2  4459              ADD      r1,r1,r11             ;2212
0000d4  6009              STR      r1,[r1,#0]            ;2212
0000d6  6049              STR      r1,[r1,#4]            ;2212
0000d8  68e1              LDR      r1,[r4,#0xc]          ;2213
0000da  eb091b82          ADD      r11,r9,r2,LSL #6      ;2213
0000de  4459              ADD      r1,r1,r11             ;2213
0000e0  6009              STR      r1,[r1,#0]            ;2213
0000e2  6049              STR      r1,[r1,#4]            ;2213
0000e4  68e1              LDR      r1,[r4,#0xc]          ;2214
0000e6  eb0a1b82          ADD      r11,r10,r2,LSL #6     ;2214
0000ea  4459              ADD      r1,r1,r11             ;2214
0000ec  6009              STR      r1,[r1,#0]            ;2214
0000ee  6049              STR      r1,[r1,#4]            ;2214
0000f0  6821              LDR      r1,[r4,#0]            ;2214
0000f2  1c52              ADDS     r2,r2,#1              ;2214
0000f4  4291              CMP      r1,r2                 ;2214
0000f6  dccc              BGT      |L12.146|
                  |L12.248|
0000f8  6820              LDR      r0,[r4,#0]            ;2219
0000fa  eb031180          ADD      r1,r3,r0,LSL #6       ;2219
0000fe  1862              ADDS     r2,r4,r1              ;2220
000100  6062              STR      r2,[r4,#4]            ;2220
000102  6860              LDR      r0,[r4,#4]            ;2223
000104  1a69              SUBS     r1,r5,r1              ;2223
000106  f8c0e008          STR      lr,[r0,#8]            ;2223
00010a  4401              ADD      r1,r1,r0              ;2223
00010c  1f09              SUBS     r1,r1,#4              ;2223
00010e  60c1              STR      r1,[r0,#0xc]          ;2223
000110  68c1              LDR      r1,[r0,#0xc]          ;2223
000112  6008              STR      r0,[r1,#0]            ;2223
000114  4625              MOV      r5,r4                 ;2225
000116  6864              LDR      r4,[r4,#4]            ;2225
000118  68e0              LDR      r0,[r4,#0xc]          ;2225
00011a  1b00              SUBS     r0,r0,r4              ;2225
00011c  f1a00610          SUB      r6,r0,#0x10           ;2225
000120  4630              MOV      r0,r6                 ;2225
000122  f7fffffe          BL       RMP_MSB_Get
000126  1ec1              SUBS     r1,r0,#3              ;2225
000128  fa26f101          LSR      r1,r6,r1              ;2225
00012c  f0010107          AND      r1,r1,#7              ;2225
000130  1f80              SUBS     r0,r0,#6              ;2225
000132  eb0101c0          ADD      r1,r1,r0,LSL #3       ;2225
000136  68e8              LDR      r0,[r5,#0xc]          ;2225
000138  eb0000c1          ADD      r0,r0,r1,LSL #3       ;2225
00013c  6842              LDR      r2,[r0,#4]            ;2225
00013e  4282              CMP      r2,r0                 ;2225
000140  d10b              BNE      |L12.346|
000142  094a              LSRS     r2,r1,#5              ;2225
000144  eb050282          ADD      r2,r5,r2,LSL #2       ;2225
000148  6913              LDR      r3,[r2,#0x10]         ;2225
00014a  f001011f          AND      r1,r1,#0x1f           ;2225
00014e  f04f0c01          MOV      r12,#1                ;2225
000152  fa0cf101          LSL      r1,r12,r1             ;2225
000156  4319              ORRS     r1,r1,r3              ;2225
000158  6111              STR      r1,[r2,#0x10]         ;2225
                  |L12.346|
00015a  6841              LDR      r1,[r0,#4]            ;2225
00015c  600c              STR      r4,[r1,#0]            ;2225
00015e  6061              STR      r1,[r4,#4]            ;2225
000160  6020              STR      r0,[r4,#0]            ;2225
000162  6044              STR      r4,[r0,#4]            ;2225
000164  2000              MOVS     r0,#0                 ;2227
000166  e8bd9ff0          POP      {r4-r12,pc}
;;;2229   /* End Function:RMP_Mem_Init *************************************************/
                          ENDP


                          AREA ||i.RMP_Print_Int||, CODE, READONLY, ALIGN=2

                  RMP_Print_Int PROC
;;;85     ******************************************************************************/
;;;86     rmp_cnt_t RMP_Print_Int(rmp_cnt_t Int)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;87     {
;;;88         rmp_ptr_t Iter;
;;;89         rmp_cnt_t Count;
;;;90         rmp_cnt_t Num;
;;;91         rmp_ptr_t Div;
;;;92         
;;;93         /* how many digits are there? */
;;;94         if(Int==0)
;;;95         {
;;;96             RMP_Putchar('0');
;;;97             return 1;
;;;98         }
;;;99         else if(Int<0)
;;;100        {
;;;101            /* How many digits are there? */
;;;102            Count=0;
;;;103            Div=1;
;;;104            Iter=(rmp_ptr_t)(-Int);
;;;105            while(Iter!=0)
;;;106            {
;;;107                Iter/=10;
000004  f8df80b8          LDR      r8,|L13.192|
000008  1e05              SUBS     r5,r0,#0              ;87
;;;108                Count++;
;;;109                Div*=10;
;;;110            }
;;;111            Div/=10;
;;;112            
;;;113            RMP_Putchar('-');
;;;114            Iter=-Int;
;;;115            Num=Count+1;
;;;116            
;;;117            while(Count>0)
;;;118            {
;;;119                Count--;
;;;120                RMP_Putchar(Iter/Div+'0');
;;;121                Iter=Iter%Div;
;;;122                Div/=10;
;;;123            }
;;;124        }
;;;125        else
;;;126        {
;;;127            /* How many digits are there? */
;;;128            Count=0;
00000a  bfc4              ITT      GT
00000c  2400              MOVGT    r4,#0
;;;129            Div=1;
00000e  2101              MOVGT    r1,#1
000010  d02b              BEQ      |L13.106|
000012  da30              BGE      |L13.118|
000014  2600              MOVS     r6,#0                 ;102
000016  2101              MOVS     r1,#1                 ;103
000018  4244              RSBS     r4,r0,#0              ;104
00001a  4625              MOV      r5,r4                 ;104
00001c  d00a              BEQ      |L13.52|
00001e  bf00              NOP                            ;107
                  |L13.32|
000020  fba82004          UMULL    r2,r0,r8,r4           ;107
000024  08c4              LSRS     r4,r0,#3              ;107
000026  eb010081          ADD      r0,r1,r1,LSL #2       ;109
00002a  ea4f0140          LSL      r1,r0,#1              ;109
00002e  f1060601          ADD      r6,r6,#1              ;109
000032  d1f5              BNE      |L13.32|
                  |L13.52|
000034  fba81001          UMULL    r1,r0,r8,r1           ;111
000038  08c7              LSRS     r7,r0,#3              ;111
00003a  202d              MOVS     r0,#0x2d              ;113
00003c  f7fffffe          BL       RMP_Putchar
000040  f1060901          ADD      r9,r6,#1              ;115
000044  2e00              CMP      r6,#0                 ;117
000046  dd37              BLE      |L13.184|
                  |L13.72|
000048  fbb5f0f7          UDIV     r0,r5,r7              ;120
00004c  3030              ADDS     r0,r0,#0x30           ;120
00004e  b240              SXTB     r0,r0                 ;120
000050  1e76              SUBS     r6,r6,#1              ;120
000052  f7fffffe          BL       RMP_Putchar
000056  fbb5f0f7          UDIV     r0,r5,r7              ;121
00005a  fb075510          MLS      r5,r7,r0,r5           ;121
00005e  fba81007          UMULL    r1,r0,r8,r7           ;122
000062  08c7              LSRS     r7,r0,#3              ;122
000064  2e00              CMP      r6,#0                 ;117
000066  dcef              BGT      |L13.72|
000068  e026              B        |L13.184|
                  |L13.106|
00006a  2030              MOVS     r0,#0x30              ;96
00006c  f7fffffe          BL       RMP_Putchar
000070  2001              MOVS     r0,#1                 ;97
;;;130            Iter=Int;
;;;131            while(Iter!=0)
;;;132            {
;;;133                Iter/=10;
;;;134                Count++;
;;;135                Div*=10;
;;;136            }
;;;137            Div/=10;
;;;138            
;;;139            Iter=Int;
;;;140            Num=Count;
;;;141            
;;;142            while(Count>0)
;;;143            {
;;;144                Count--;
;;;145                RMP_Putchar(Iter/Div+'0');
;;;146                Iter=Iter%Div;
;;;147                Div/=10;
;;;148            }
;;;149        }
;;;150        
;;;151        return Num;
;;;152    }
000072  e8bd87f0          POP      {r4-r10,pc}
                  |L13.118|
000076  fba82000          UMULL    r2,r0,r8,r0           ;133
00007a  eb010181          ADD      r1,r1,r1,LSL #2       ;135
00007e  08c0              LSRS     r0,r0,#3              ;133
000080  ea4f0141          LSL      r1,r1,#1              ;135
000084  f1040401          ADD      r4,r4,#1              ;135
000088  d1f5              BNE      |L13.118|
00008a  fba81001          UMULL    r1,r0,r8,r1           ;137
00008e  08c6              LSRS     r6,r0,#3              ;137
000090  f1b40900          SUBS     r9,r4,#0              ;140
000094  dd10              BLE      |L13.184|
000096  bf00              NOP                            ;145
                  |L13.152|
000098  fbb5f0f6          UDIV     r0,r5,r6              ;145
00009c  3030              ADDS     r0,r0,#0x30           ;145
00009e  b240              SXTB     r0,r0                 ;145
0000a0  1e64              SUBS     r4,r4,#1              ;145
0000a2  f7fffffe          BL       RMP_Putchar
0000a6  fbb5f0f6          UDIV     r0,r5,r6              ;146
0000aa  fb065510          MLS      r5,r6,r0,r5           ;146
0000ae  fba81006          UMULL    r1,r0,r8,r6           ;147
0000b2  08c6              LSRS     r6,r0,#3              ;147
0000b4  2c00              CMP      r4,#0                 ;142
0000b6  dcef              BGT      |L13.152|
                  |L13.184|
0000b8  4648              MOV      r0,r9                 ;151
0000ba  e8bd87f0          POP      {r4-r10,pc}
;;;153    /* End Function:RMP_Print_Int ************************************************/
                          ENDP

0000be  0000              DCW      0x0000
                  |L13.192|
                          DCD      0xcccccccd

                          AREA ||i.RMP_Print_String||, CODE, READONLY, ALIGN=1

                  RMP_Print_String PROC
;;;208    ******************************************************************************/
;;;209    rmp_cnt_t RMP_Print_String(rmp_s8_t* String)
000000  b570              PUSH     {r4-r6,lr}
;;;210    {
000002  4605              MOV      r5,r0
;;;211        rmp_cnt_t Count;
;;;212        
;;;213        Count=0;
000004  2400              MOVS     r4,#0
                  |L14.6|
;;;214        while(Count<RMP_KERNEL_DEBUG_MAX_STR)
;;;215        {
;;;216            if(String[Count]=='\0')
000006  5728              LDRSB    r0,[r5,r4]
000008  b120              CBZ      r0,|L14.20|
00000a  1c64              ADDS     r4,r4,#1
;;;217                break;
;;;218            
;;;219            RMP_Putchar(String[Count++]);
00000c  f7fffffe          BL       RMP_Putchar
000010  2cff              CMP      r4,#0xff              ;214
000012  dbf8              BLT      |L14.6|
                  |L14.20|
;;;220        }
;;;221        
;;;222        return Count;
000014  4620              MOV      r0,r4
;;;223    }
000016  bd70              POP      {r4-r6,pc}
;;;224    /* End Function:RMP_Print_String *********************************************/
                          ENDP


                          AREA ||i.RMP_Print_Uint||, CODE, READONLY, ALIGN=1

                  RMP_Print_Uint PROC
;;;161    ******************************************************************************/
;;;162    rmp_cnt_t RMP_Print_Uint(rmp_ptr_t Uint)
000000  b570              PUSH     {r4-r6,lr}
;;;163    {
000002  0005              MOVS     r5,r0
000004  d003              BEQ      |L15.14|
;;;164        rmp_ptr_t Iter;
;;;165        rmp_cnt_t Count;
;;;166        rmp_cnt_t Num;
;;;167        
;;;168        /* how many digits are there? */
;;;169        if(Uint==0)
;;;170        {
;;;171            RMP_Putchar('0');
;;;172            return 1;
;;;173        }
;;;174        else
;;;175        {
;;;176            /* Filter out all the zeroes */
;;;177            Count=0;
000006  2100              MOVS     r1,#0
;;;178            Iter=Uint;
;;;179            while((Iter>>((sizeof(rmp_ptr_t)*8)-4))==0)
000008  0f02              LSRS     r2,r0,#28
00000a  d005              BEQ      |L15.24|
00000c  e008              B        |L15.32|
                  |L15.14|
00000e  2030              MOVS     r0,#0x30              ;171
000010  f7fffffe          BL       RMP_Putchar
000014  2001              MOVS     r0,#1                 ;172
;;;180            {
;;;181                Iter<<=4;
;;;182                Count++;
;;;183            }
;;;184            /* Count is the number of pts to print */
;;;185            Count=sizeof(rmp_ptr_t)*2-Count;
;;;186            Num=Count;
;;;187            while(Count>0)
;;;188            {
;;;189                Count--;
;;;190                Iter=(Uint>>(Count*4))&0x0F;
;;;191                if(Iter<10)
;;;192                    RMP_Putchar('0'+Iter);
;;;193                else
;;;194                    RMP_Putchar('A'+Iter-10);
;;;195            }
;;;196        }
;;;197        
;;;198        return Num;
;;;199    }
000016  bd70              POP      {r4-r6,pc}
                  |L15.24|
000018  0100              LSLS     r0,r0,#4              ;181
00001a  1c49              ADDS     r1,r1,#1              ;181
00001c  0f02              LSRS     r2,r0,#28             ;179
00001e  d0fb              BEQ      |L15.24|
                  |L15.32|
000020  f1c10408          RSB      r4,r1,#8              ;185
000024  1e26              SUBS     r6,r4,#0              ;186
000026  dd0f              BLE      |L15.72|
                  |L15.40|
000028  4620              MOV      r0,r4                 ;189
00002a  1e64              SUBS     r4,r4,#1              ;189
00002c  0080              LSLS     r0,r0,#2
00002e  1f00              SUBS     r0,r0,#4
000030  fa25f000          LSR      r0,r5,r0              ;190
000034  f000000f          AND      r0,r0,#0xf            ;190
000038  280a              CMP      r0,#0xa               ;191
00003a  bf34              ITE      CC                    ;191
00003c  3030              ADDCC    r0,r0,#0x30           ;191
00003e  3037              ADDCS    r0,r0,#0x37           ;191
000040  f7fffffe          BL       RMP_Putchar
000044  2c00              CMP      r4,#0                 ;187
000046  dcef              BGT      |L15.40|
                  |L15.72|
000048  4630              MOV      r0,r6                 ;198
00004a  bd70              POP      {r4-r6,pc}
;;;200    /* End Function:RMP_Print_Uint ***********************************************/
                          ENDP


                          AREA ||i.RMP_RBIT_Get||, CODE, READONLY, ALIGN=2

                  RMP_RBIT_Get PROC
;;;2078   
;;;2079   rmp_ptr_t RMP_RBIT_Get(rmp_ptr_t Val)
000000  4a0a              LDR      r2,|L16.44|
;;;2080   {
000002  0e03              LSRS     r3,r0,#24
000004  4601              MOV      r1,r0
;;;2081       rmp_ptr_t Ret;
;;;2082       rmp_ptr_t Src;
;;;2083       rmp_u8_t* To;
;;;2084       rmp_u8_t* From;
;;;2085       
;;;2086       Src=Val;
;;;2087       To=(rmp_u8_t*)(&Ret);
;;;2088       From=(rmp_u8_t*)(&Src);
;;;2089       
;;;2090   #if(RMP_WORD_ORDER==4)
;;;2091       To[0]=RMP_RBIT_Table[From[1]];
;;;2092       To[1]=RMP_RBIT_Table[From[0]];
;;;2093   #elif(RMP_WORD_ORDER==5)
;;;2094       To[0]=RMP_RBIT_Table[From[3]];
000006  5cd3              LDRB     r3,[r2,r3]
000008  f3630007          BFI      r0,r3,#0,#8
00000c  f3c14307          UBFX     r3,r1,#16,#8
;;;2095       To[1]=RMP_RBIT_Table[From[2]];
000010  5cd3              LDRB     r3,[r2,r3]
000012  f363200f          BFI      r0,r3,#8,#8
000016  f3c12307          UBFX     r3,r1,#8,#8
;;;2096       To[2]=RMP_RBIT_Table[From[1]];
00001a  b2c9              UXTB     r1,r1
00001c  5cd3              LDRB     r3,[r2,r3]
;;;2097       To[3]=RMP_RBIT_Table[From[0]];
00001e  5c51              LDRB     r1,[r2,r1]
000020  f3634017          BFI      r0,r3,#16,#8          ;2096
000024  f361601f          BFI      r0,r1,#24,#8
;;;2098   #else
;;;2099       To[0]=RMP_RBIT_Table[From[7]];
;;;2100       To[1]=RMP_RBIT_Table[From[6]];
;;;2101       To[2]=RMP_RBIT_Table[From[5]];
;;;2102       To[3]=RMP_RBIT_Table[From[4]];
;;;2103       To[4]=RMP_RBIT_Table[From[3]];
;;;2104       To[5]=RMP_RBIT_Table[From[2]];
;;;2105       To[6]=RMP_RBIT_Table[From[1]];
;;;2106       To[7]=RMP_RBIT_Table[From[0]];
;;;2107   #endif
;;;2108   
;;;2109       return Ret;
;;;2110   }
000028  4770              BX       lr
;;;2111   /* End Function:RMP_RBIT_Get *************************************************/
                          ENDP

00002a  0000              DCW      0x0000
                  |L16.44|
                          DCD      ||.constdata||

                          AREA ||i.RMP_Save_Ctx||, CODE, READONLY, ALIGN=1

                  RMP_Save_Ctx PROC
;;;1942   #if(RMP_USE_HOOKS==RMP_FALSE)
;;;1943   void RMP_Save_Ctx(void)
000000  4770              BX       lr
;;;1944   {
;;;1945       return;
;;;1946   }
;;;1947   #endif
                          ENDP


                          AREA ||i.RMP_Sem_Abort||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Abort PROC
;;;1737   ******************************************************************************/
;;;1738   rmp_ret_t RMP_Sem_Abort(volatile struct RMP_Thd* Thread)
000000  2800              CMP      r0,#0
;;;1739   {
;;;1740       /* Check if this thread structure could possibly be in use */
;;;1741       if(Thread==0)
;;;1742       {
;;;1743           RMP_COVERAGE_MARKER();
;;;1744           return RMP_ERR_THD;
000002  bf04              ITT      EQ
000004  f04f30ff          MOVEQ    r0,#0xffffffff
;;;1745       }
;;;1746       else
;;;1747           RMP_COVERAGE_MARKER();
;;;1748   
;;;1749       RMP_Lock_Sched();
;;;1750       
;;;1751       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;1752       {
;;;1753           RMP_COVERAGE_MARKER();
;;;1754           RMP_Unlock_Sched();
;;;1755           return RMP_ERR_THD;
;;;1756       }
;;;1757       else
;;;1758           RMP_COVERAGE_MARKER();
;;;1759       
;;;1760       /* Is it waiting on a semaphore? If no, we abort and return an error code */
;;;1761       if((RMP_THD_STATE(Thread->State)!=RMP_THD_SEMBLK)&&
;;;1762          (RMP_THD_STATE(Thread->State)!=RMP_THD_SEMDLY))
;;;1763       {
;;;1764           RMP_COVERAGE_MARKER();
;;;1765           RMP_Unlock_Sched();
;;;1766           return RMP_ERR_STATE;
;;;1767       }
;;;1768       else
;;;1769           RMP_COVERAGE_MARKER();
;;;1770   
;;;1771       /* Waiting for a semaphore. We abort it and return */
;;;1772       RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1773       if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1774       {
;;;1775           RMP_COVERAGE_MARKER();
;;;1776           RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1777       }
;;;1778       else
;;;1779           RMP_COVERAGE_MARKER();
;;;1780       
;;;1781       RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1782       /* Set to running if not suspended */
;;;1783       _RMP_Set_Rdy(Thread);
;;;1784       
;;;1785       Thread->Retval=RMP_ERR_OPER;
;;;1786       RMP_Unlock_Sched();
;;;1787       return 0;
;;;1788   }
000008  4770              BXEQ     lr
00000a  b510              PUSH     {r4,lr}               ;1739
00000c  4604              MOV      r4,r0                 ;1739
00000e  20ff              MOVS     r0,#0xff              ;1739
000010  f7fffffe          BL       RMP_Mask_Int
000014  481b              LDR      r0,|L18.132|
000016  2101              MOVS     r1,#1                 ;1739
000018  6081              STR      r1,[r0,#8]            ;1739  ; RMP_Sched_Locked
00001a  6841              LDR      r1,[r0,#4]            ;1739  ; RMP_Sched_Lock_Cnt
00001c  1c49              ADDS     r1,r1,#1              ;1739
00001e  6041              STR      r1,[r0,#4]            ;1739  ; RMP_Sched_Lock_Cnt
000020  69a0              LDR      r0,[r4,#0x18]         ;1751
000022  f0100fff          TST      r0,#0xff              ;1751
000026  d00c              BEQ      |L18.66|
000028  69a0              LDR      r0,[r4,#0x18]         ;1761
00002a  b2c0              UXTB     r0,r0                 ;1761
00002c  2807              CMP      r0,#7                 ;1761
00002e  d00d              BEQ      |L18.76|
000030  69a0              LDR      r0,[r4,#0x18]         ;1761
000032  b2c0              UXTB     r0,r0                 ;1761
000034  2808              CMP      r0,#8                 ;1761
000036  d009              BEQ      |L18.76|
000038  f7fffffe          BL       RMP_Unlock_Sched
00003c  f06f0003          MVN      r0,#3                 ;1766
000040  bd10              POP      {r4,pc}
                  |L18.66|
000042  f7fffffe          BL       RMP_Unlock_Sched
000046  f04f30ff          MOV      r0,#0xffffffff        ;1755
00004a  bd10              POP      {r4,pc}
                  |L18.76|
00004c  6820              LDR      r0,[r4,#0]            ;1772
00004e  6861              LDR      r1,[r4,#4]            ;1772
000050  6008              STR      r0,[r1,#0]            ;1772
000052  6041              STR      r1,[r0,#4]            ;1772
000054  69a0              LDR      r0,[r4,#0x18]         ;1773
000056  b2c0              UXTB     r0,r0                 ;1773
000058  2808              CMP      r0,#8                 ;1773
00005a  d103              BNE      |L18.100|
00005c  68a1              LDR      r1,[r4,#8]            ;1776
00005e  68e0              LDR      r0,[r4,#0xc]          ;1776
000060  6001              STR      r1,[r0,#0]            ;1776
000062  6048              STR      r0,[r1,#4]            ;1776
                  |L18.100|
000064  69a0              LDR      r0,[r4,#0x18]         ;1781
000066  f02000ff          BIC      r0,r0,#0xff           ;1781
00006a  f0400001          ORR      r0,r0,#1              ;1781
00006e  61a0              STR      r0,[r4,#0x18]         ;1781
000070  4620              MOV      r0,r4                 ;1783
000072  f7fffffe          BL       _RMP_Set_Rdy
000076  f06f0004          MVN      r0,#4                 ;1785
00007a  63a0              STR      r0,[r4,#0x38]         ;1785
00007c  f7fffffe          BL       RMP_Unlock_Sched
000080  2000              MOVS     r0,#0                 ;1787
000082  bd10              POP      {r4,pc}
;;;1789   /* End Function:RMP_Sem_Abort ************************************************/
                          ENDP

                  |L18.132|
                          DCD      ||.data||

                          AREA ||i.RMP_Sem_Crt||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Crt PROC
;;;1556   ******************************************************************************/
;;;1557   rmp_ret_t RMP_Sem_Crt(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Number)
000000  2800              CMP      r0,#0
;;;1558   {
;;;1559       /* Check if this semaphore structure could possibly be in use */
;;;1560       if(Semaphore==0)
;;;1561       {
;;;1562           RMP_COVERAGE_MARKER();
;;;1563           return RMP_ERR_SEM;
000002  bf04              ITT      EQ
000004  f06f0005          MVNEQ    r0,#5
;;;1564       }
;;;1565       else
;;;1566           RMP_COVERAGE_MARKER();
;;;1567       
;;;1568       RMP_Lock_Sched();
;;;1569       
;;;1570       if(Semaphore->State!=RMP_SEM_FREE)
;;;1571       {
;;;1572           RMP_COVERAGE_MARKER();
;;;1573           RMP_Unlock_Sched();
;;;1574           return RMP_ERR_SEM;
;;;1575       }
;;;1576       else
;;;1577           RMP_COVERAGE_MARKER();
;;;1578       
;;;1579       /* Is the number too great to initialize? */
;;;1580       if(Number>=RMP_SEM_MAX_NUM)
;;;1581       {
;;;1582           RMP_COVERAGE_MARKER();
;;;1583           RMP_Unlock_Sched();
;;;1584           return RMP_ERR_OPER;
;;;1585       }
;;;1586       else
;;;1587           RMP_COVERAGE_MARKER();
;;;1588   
;;;1589       /* Initialize contents */
;;;1590       Semaphore->Cur_Num=Number;
;;;1591       Semaphore->State=RMP_SEM_USED;
;;;1592       RMP_List_Crt(&(Semaphore->Wait_List));
;;;1593       
;;;1594       RMP_Unlock_Sched();
;;;1595       
;;;1596       return 0;
;;;1597   }
000008  4770              BXEQ     lr
00000a  b570              PUSH     {r4-r6,lr}            ;1558
00000c  4604              MOV      r4,r0                 ;1558
00000e  460d              MOV      r5,r1                 ;1558
000010  20ff              MOVS     r0,#0xff              ;1558
000012  f7fffffe          BL       RMP_Mask_Int
000016  480e              LDR      r0,|L19.80|
000018  2101              MOVS     r1,#1                 ;1558
00001a  6081              STR      r1,[r0,#8]            ;1558  ; RMP_Sched_Locked
00001c  6842              LDR      r2,[r0,#4]            ;1558  ; RMP_Sched_Lock_Cnt
00001e  1c52              ADDS     r2,r2,#1              ;1558
000020  6042              STR      r2,[r0,#4]            ;1558  ; RMP_Sched_Lock_Cnt
000022  68a0              LDR      r0,[r4,#8]            ;1570
000024  b120              CBZ      r0,|L19.48|
000026  f7fffffe          BL       RMP_Unlock_Sched
00002a  f06f0005          MVN      r0,#5                 ;1574
00002e  bd70              POP      {r4-r6,pc}
                  |L19.48|
000030  f5b57f7a          CMP      r5,#0x3e8             ;1580
000034  d304              BCC      |L19.64|
000036  f7fffffe          BL       RMP_Unlock_Sched
00003a  f06f0004          MVN      r0,#4                 ;1584
00003e  bd70              POP      {r4-r6,pc}
                  |L19.64|
000040  60e5              STR      r5,[r4,#0xc]          ;1590
000042  60a1              STR      r1,[r4,#8]            ;1591
000044  6024              STR      r4,[r4,#0]            ;1591
000046  6064              STR      r4,[r4,#4]            ;1591
000048  f7fffffe          BL       RMP_Unlock_Sched
00004c  2000              MOVS     r0,#0                 ;1596
00004e  bd70              POP      {r4-r6,pc}
;;;1598   /* End Function:RMP_Sem_Crt **************************************************/
                          ENDP

                  |L19.80|
                          DCD      ||.data||

                          AREA ||i.RMP_Sem_Del||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Del PROC
;;;1605   ******************************************************************************/
;;;1606   rmp_ret_t RMP_Sem_Del(volatile struct RMP_Sem* Semaphore)
000000  2800              CMP      r0,#0
;;;1607   {
;;;1608       struct RMP_Thd* Thread;
;;;1609       
;;;1610       /* Check if this semaphore structure could possibly be in use */
;;;1611       if(Semaphore==0)
;;;1612       {
;;;1613           RMP_COVERAGE_MARKER();
;;;1614           return RMP_ERR_SEM;
000002  bf04              ITT      EQ
000004  f06f0005          MVNEQ    r0,#5
;;;1615       }
;;;1616       else
;;;1617           RMP_COVERAGE_MARKER();
;;;1618       
;;;1619       RMP_Lock_Sched();
;;;1620       
;;;1621       if(Semaphore->State!=RMP_SEM_USED)
;;;1622       {
;;;1623           RMP_COVERAGE_MARKER();
;;;1624           RMP_Unlock_Sched();
;;;1625           return RMP_ERR_SEM;
;;;1626       }
;;;1627       else
;;;1628           RMP_COVERAGE_MARKER();
;;;1629   
;;;1630       /* Get rid of all guys waiting on it */
;;;1631       while(&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)
;;;1632       {
;;;1633           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
;;;1634           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1635           
;;;1636           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1637           {
;;;1638               RMP_COVERAGE_MARKER();
;;;1639               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1640           }
;;;1641           else
;;;1642               RMP_COVERAGE_MARKER();
;;;1643   
;;;1644           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1645           /* Set to running if not suspended */
;;;1646           _RMP_Set_Rdy(Thread);
;;;1647           Thread->Retval=RMP_ERR_OPER;
;;;1648       }
;;;1649       Semaphore->State=RMP_SEM_FREE;
;;;1650       
;;;1651       RMP_Unlock_Sched();
;;;1652   
;;;1653       return 0;
;;;1654   }
000008  4770              BXEQ     lr
00000a  b570              PUSH     {r4-r6,lr}            ;1607
00000c  4605              MOV      r5,r0                 ;1607
00000e  20ff              MOVS     r0,#0xff              ;1607
000010  f7fffffe          BL       RMP_Mask_Int
000014  4819              LDR      r0,|L20.124|
000016  2101              MOVS     r1,#1                 ;1607
000018  6081              STR      r1,[r0,#8]            ;1607  ; RMP_Sched_Locked
00001a  6841              LDR      r1,[r0,#4]            ;1607  ; RMP_Sched_Lock_Cnt
00001c  1c49              ADDS     r1,r1,#1              ;1607
00001e  6041              STR      r1,[r0,#4]            ;1607  ; RMP_Sched_Lock_Cnt
000020  68a8              LDR      r0,[r5,#8]            ;1621
000022  2801              CMP      r0,#1                 ;1621
000024  d004              BEQ      |L20.48|
000026  f7fffffe          BL       RMP_Unlock_Sched
00002a  f06f0005          MVN      r0,#5                 ;1625
00002e  bd70              POP      {r4-r6,pc}
                  |L20.48|
000030  6868              LDR      r0,[r5,#4]            ;1631
000032  42a8              CMP      r0,r5                 ;1631
000034  bf18              IT       NE                    ;1647
000036  f06f0604          MVNNE    r6,#4                 ;1647
00003a  d018              BEQ      |L20.110|
                  |L20.60|
00003c  686c              LDR      r4,[r5,#4]            ;1633
00003e  e9d40100          LDRD     r0,r1,[r4,#0]         ;1633
000042  6008              STR      r0,[r1,#0]            ;1633
000044  6041              STR      r1,[r0,#4]            ;1633
000046  7e20              LDRB     r0,[r4,#0x18]         ;1636
000048  2808              CMP      r0,#8                 ;1636
00004a  d103              BNE      |L20.84|
00004c  e9d40102          LDRD     r0,r1,[r4,#8]         ;1636
000050  6008              STR      r0,[r1,#0]            ;1636
000052  6041              STR      r1,[r0,#4]            ;1636
                  |L20.84|
000054  69a0              LDR      r0,[r4,#0x18]         ;1644
000056  f02000ff          BIC      r0,r0,#0xff           ;1644
00005a  f0400001          ORR      r0,r0,#1              ;1644
00005e  61a0              STR      r0,[r4,#0x18]         ;1646
000060  4620              MOV      r0,r4                 ;1646
000062  f7fffffe          BL       _RMP_Set_Rdy
000066  63a6              STR      r6,[r4,#0x38]         ;1647
000068  6868              LDR      r0,[r5,#4]            ;1647
00006a  42a8              CMP      r0,r5                 ;1647
00006c  d1e6              BNE      |L20.60|
                  |L20.110|
00006e  2000              MOVS     r0,#0                 ;1649
000070  60a8              STR      r0,[r5,#8]            ;1649
000072  f7fffffe          BL       RMP_Unlock_Sched
000076  2000              MOVS     r0,#0                 ;1653
000078  bd70              POP      {r4-r6,pc}
;;;1655   /* End Function:RMP_Sem_Del **************************************************/
                          ENDP

00007a  0000              DCW      0x0000
                  |L20.124|
                          DCD      ||.data||

                          AREA ||i.RMP_Sem_Pend||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Pend PROC
;;;1663   ******************************************************************************/
;;;1664   rmp_ret_t RMP_Sem_Pend(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Slices)
000000  2800              CMP      r0,#0
;;;1665   {
;;;1666       /* Check if this semaphore structure could possibly be in use */
;;;1667       if(Semaphore==0)
;;;1668       {
;;;1669           RMP_COVERAGE_MARKER();
;;;1670           return RMP_ERR_SEM;
000002  bf04              ITT      EQ
000004  f06f0005          MVNEQ    r0,#5
;;;1671       }
;;;1672       else
;;;1673           RMP_COVERAGE_MARKER();
;;;1674       
;;;1675       RMP_Lock_Sched();
;;;1676       
;;;1677       if(Semaphore->State!=RMP_SEM_USED)
;;;1678       {
;;;1679           RMP_COVERAGE_MARKER();
;;;1680           RMP_Unlock_Sched();
;;;1681           return RMP_ERR_SEM;
;;;1682       }
;;;1683       else
;;;1684           RMP_COVERAGE_MARKER();
;;;1685       
;;;1686       /* Check if we can get one immediately */
;;;1687       if(Semaphore->Cur_Num!=0)
;;;1688       {
;;;1689           RMP_COVERAGE_MARKER();
;;;1690           Semaphore->Cur_Num--;
;;;1691           RMP_Unlock_Sched();
;;;1692           return Semaphore->Cur_Num;
;;;1693       }
;;;1694       else
;;;1695       {
;;;1696           RMP_COVERAGE_MARKER();
;;;1697           /* Cannot get one, we need to block */
;;;1698           if(Slices==0)
;;;1699           {
;;;1700               RMP_COVERAGE_MARKER();
;;;1701               RMP_Unlock_Sched();
;;;1702               return RMP_ERR_OPER;
;;;1703           }
;;;1704           else
;;;1705               RMP_COVERAGE_MARKER();
;;;1706   
;;;1707           /* We must be running - place into waitlist now */
;;;1708           _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1709           RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),Semaphore->Wait_List.Prev,&(Semaphore->Wait_List));
;;;1710           
;;;1711           if(Slices<RMP_MAX_SLICES)
;;;1712           {
;;;1713               RMP_COVERAGE_MARKER();
;;;1714               _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1715               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SEMDLY);
;;;1716           }
;;;1717           else
;;;1718           {
;;;1719               RMP_COVERAGE_MARKER();
;;;1720               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SEMBLK);
;;;1721           }
;;;1722           
;;;1723           RMP_Cur_Thd->Retval=0;
;;;1724       }
;;;1725       
;;;1726       RMP_Unlock_Sched();
;;;1727   
;;;1728       return RMP_Cur_Thd->Retval;
;;;1729   }
000008  4770              BXEQ     lr
00000a  b570              PUSH     {r4-r6,lr}            ;1665
00000c  4605              MOV      r5,r0                 ;1665
00000e  460e              MOV      r6,r1                 ;1665
000010  20ff              MOVS     r0,#0xff              ;1665
000012  f7fffffe          BL       RMP_Mask_Int
000016  4c2d              LDR      r4,|L21.204|
000018  2001              MOVS     r0,#1                 ;1665
00001a  60a0              STR      r0,[r4,#8]            ;1665  ; RMP_Sched_Locked
00001c  6860              LDR      r0,[r4,#4]            ;1665  ; RMP_Sched_Lock_Cnt
00001e  1c40              ADDS     r0,r0,#1              ;1665
000020  6060              STR      r0,[r4,#4]            ;1665  ; RMP_Sched_Lock_Cnt
000022  68a8              LDR      r0,[r5,#8]            ;1677
000024  2801              CMP      r0,#1                 ;1677
000026  d004              BEQ      |L21.50|
000028  f7fffffe          BL       RMP_Unlock_Sched
00002c  f06f0005          MVN      r0,#5                 ;1681
000030  bd70              POP      {r4-r6,pc}
                  |L21.50|
000032  68e8              LDR      r0,[r5,#0xc]          ;1687
000034  b130              CBZ      r0,|L21.68|
000036  68e8              LDR      r0,[r5,#0xc]          ;1690
000038  1e40              SUBS     r0,r0,#1              ;1690
00003a  60e8              STR      r0,[r5,#0xc]          ;1690
00003c  f7fffffe          BL       RMP_Unlock_Sched
000040  68e8              LDR      r0,[r5,#0xc]          ;1692
000042  bd70              POP      {r4-r6,pc}
                  |L21.68|
000044  b36e              CBZ      r6,|L21.162|
000046  69a0              LDR      r0,[r4,#0x18]         ;1708  ; RMP_Cur_Thd
000048  f7fffffe          BL       _RMP_Clr_Rdy
00004c  69a0              LDR      r0,[r4,#0x18]         ;1709  ; RMP_Cur_Thd
00004e  682a              LDR      r2,[r5,#0]            ;1709
000050  6028              STR      r0,[r5,#0]            ;1709
000052  6045              STR      r5,[r0,#4]            ;1709
000054  6002              STR      r2,[r0,#0]            ;1709
000056  6050              STR      r0,[r2,#4]            ;1709
000058  481d              LDR      r0,|L21.208|
00005a  4286              CMP      r6,r0                 ;1711
00005c  d226              BCS      |L21.172|
00005e  69a2              LDR      r2,[r4,#0x18]         ;1714  ; RMP_Cur_Thd
000060  4b1c              LDR      r3,|L21.212|
000062  6858              LDR      r0,[r3,#4]            ;1714  ; RMP_Delay
000064  4298              CMP      r0,r3                 ;1714
000066  d009              BEQ      |L21.124|
                  |L21.104|
000068  6a01              LDR      r1,[r0,#0x20]         ;1714
00006a  f8d4c014          LDR      r12,[r4,#0x14]        ;1714  ; RMP_Tick
00006e  eba1010c          SUB      r1,r1,r12             ;1714
000072  42b1              CMP      r1,r6                 ;1714
000074  d802              BHI      |L21.124|
000076  6840              LDR      r0,[r0,#4]            ;1714
000078  4298              CMP      r0,r3                 ;1714
00007a  d1f5              BNE      |L21.104|
                  |L21.124|
00007c  6961              LDR      r1,[r4,#0x14]         ;1714  ; RMP_Tick
00007e  4431              ADD      r1,r1,r6              ;1714
000080  6291              STR      r1,[r2,#0x28]         ;1714
000082  f1020108          ADD      r1,r2,#8              ;1714
000086  6802              LDR      r2,[r0,#0]            ;1714
000088  6001              STR      r1,[r0,#0]            ;1714
00008a  6048              STR      r0,[r1,#4]            ;1714
00008c  600a              STR      r2,[r1,#0]            ;1714
00008e  6051              STR      r1,[r2,#4]            ;1714
000090  69a0              LDR      r0,[r4,#0x18]         ;1715  ; RMP_Cur_Thd
000092  69a1              LDR      r1,[r4,#0x18]         ;1715  ; RMP_Cur_Thd
000094  6980              LDR      r0,[r0,#0x18]         ;1715
000096  f02000ff          BIC      r0,r0,#0xff           ;1715
00009a  f0400008          ORR      r0,r0,#8              ;1715
00009e  6188              STR      r0,[r1,#0x18]         ;1715
0000a0  e00c              B        |L21.188|
                  |L21.162|
0000a2  f7fffffe          BL       RMP_Unlock_Sched
0000a6  f06f0004          MVN      r0,#4                 ;1702
0000aa  bd70              POP      {r4-r6,pc}
                  |L21.172|
0000ac  69a0              LDR      r0,[r4,#0x18]         ;1720  ; RMP_Cur_Thd
0000ae  69a1              LDR      r1,[r4,#0x18]         ;1720  ; RMP_Cur_Thd
0000b0  6980              LDR      r0,[r0,#0x18]         ;1720
0000b2  f02000ff          BIC      r0,r0,#0xff           ;1720
0000b6  f0400007          ORR      r0,r0,#7              ;1720
0000ba  6188              STR      r0,[r1,#0x18]         ;1720
                  |L21.188|
0000bc  69a1              LDR      r1,[r4,#0x18]         ;1723  ; RMP_Cur_Thd
0000be  2000              MOVS     r0,#0                 ;1723
0000c0  6388              STR      r0,[r1,#0x38]         ;1726
0000c2  f7fffffe          BL       RMP_Unlock_Sched
0000c6  69a0              LDR      r0,[r4,#0x18]         ;1728  ; RMP_Cur_Thd
0000c8  6b80              LDR      r0,[r0,#0x38]         ;1728
0000ca  bd70              POP      {r4-r6,pc}
;;;1730   /* End Function:RMP_Sem_Pend *************************************************/
                          ENDP

                  |L21.204|
                          DCD      ||.data||
                  |L21.208|
                          DCD      0x000186a0
                  |L21.212|
                          DCD      ||.data||+0x20

                          AREA ||i.RMP_Sem_Post||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Post PROC
;;;1797   ******************************************************************************/
;;;1798   rmp_ret_t RMP_Sem_Post(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Number)
000000  2800              CMP      r0,#0
;;;1799   {
;;;1800       struct RMP_Thd* Thread;
;;;1801       
;;;1802       /* Check if this semaphore structure could possibly be in use */
;;;1803       if((Semaphore==0)||(Number==0))
000002  bf12              ITEE     NE
000004  2900              CMPNE    r1,#0
;;;1804       {
;;;1805           RMP_COVERAGE_MARKER();
;;;1806           return RMP_ERR_SEM;
000006  f06f0005          MVNEQ    r0,#5
;;;1807       }
;;;1808       else
;;;1809           RMP_COVERAGE_MARKER();
;;;1810       
;;;1811       RMP_Lock_Sched();
;;;1812       
;;;1813       if(Semaphore->State!=RMP_SEM_USED)
;;;1814       {
;;;1815           RMP_COVERAGE_MARKER();
;;;1816           RMP_Unlock_Sched();
;;;1817           return RMP_ERR_SEM;
;;;1818       }
;;;1819       else
;;;1820           RMP_COVERAGE_MARKER();
;;;1821       
;;;1822       /* Would the maximum value be exceeded if this is posted? */
;;;1823       if((Semaphore->Cur_Num+Number)>=RMP_SEM_MAX_NUM)
;;;1824       {
;;;1825           RMP_COVERAGE_MARKER();
;;;1826           RMP_Unlock_Sched();
;;;1827           return RMP_ERR_OPER;
;;;1828       }
;;;1829       else
;;;1830           RMP_COVERAGE_MARKER();
;;;1831       
;;;1832       Semaphore->Cur_Num+=Number;
;;;1833       /* Is there any thread waiting on it? If there are, clean them up*/
;;;1834       while((&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)&&(Semaphore->Cur_Num!=0))
;;;1835       {
;;;1836           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
;;;1837           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1838           
;;;1839           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1840           {
;;;1841               RMP_COVERAGE_MARKER();
;;;1842               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1843           }
;;;1844           else
;;;1845               RMP_COVERAGE_MARKER();
;;;1846           
;;;1847           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1848           /* Set to running if not suspended */
;;;1849           _RMP_Set_Rdy(Thread);
;;;1850   
;;;1851           /* Finally, return success */
;;;1852           Thread->Retval=0;
;;;1853           Semaphore->Cur_Num--;
;;;1854       }
;;;1855   
;;;1856       RMP_Unlock_Sched();
;;;1857       return 0;
;;;1858   }
00000a  4770              BXEQ     lr
00000c  b570              PUSH     {r4-r6,lr}            ;1799
00000e  4604              MOV      r4,r0                 ;1799
000010  460d              MOV      r5,r1                 ;1799
000012  20ff              MOVS     r0,#0xff              ;1799
000014  f7fffffe          BL       RMP_Mask_Int
000018  481f              LDR      r0,|L22.152|
00001a  2101              MOVS     r1,#1                 ;1799
00001c  6081              STR      r1,[r0,#8]            ;1799  ; RMP_Sched_Locked
00001e  6841              LDR      r1,[r0,#4]            ;1799  ; RMP_Sched_Lock_Cnt
000020  1c49              ADDS     r1,r1,#1              ;1799
000022  6041              STR      r1,[r0,#4]            ;1799  ; RMP_Sched_Lock_Cnt
000024  68a0              LDR      r0,[r4,#8]            ;1813
000026  2801              CMP      r0,#1                 ;1813
000028  d004              BEQ      |L22.52|
00002a  f7fffffe          BL       RMP_Unlock_Sched
00002e  f06f0005          MVN      r0,#5                 ;1817
000032  bd70              POP      {r4-r6,pc}
                  |L22.52|
000034  68e0              LDR      r0,[r4,#0xc]          ;1823
000036  4428              ADD      r0,r0,r5              ;1823
000038  f5b07f7a          CMP      r0,#0x3e8             ;1823
00003c  d304              BCC      |L22.72|
00003e  f7fffffe          BL       RMP_Unlock_Sched
000042  f06f0004          MVN      r0,#4                 ;1827
000046  bd70              POP      {r4-r6,pc}
                  |L22.72|
000048  68e0              LDR      r0,[r4,#0xc]          ;1832
00004a  4428              ADD      r0,r0,r5              ;1832
00004c  60e0              STR      r0,[r4,#0xc]          ;1832
00004e  2600              MOVS     r6,#0                 ;1832
000050  e018              B        |L22.132|
                  |L22.82|
000052  6865              LDR      r5,[r4,#4]            ;1836
000054  e9d50100          LDRD     r0,r1,[r5,#0]         ;1836
000058  6008              STR      r0,[r1,#0]            ;1836
00005a  6041              STR      r1,[r0,#4]            ;1836
00005c  7e28              LDRB     r0,[r5,#0x18]         ;1839
00005e  2808              CMP      r0,#8                 ;1839
000060  d103              BNE      |L22.106|
000062  e9d50102          LDRD     r0,r1,[r5,#8]         ;1839
000066  6008              STR      r0,[r1,#0]            ;1839
000068  6041              STR      r1,[r0,#4]            ;1839
                  |L22.106|
00006a  69a8              LDR      r0,[r5,#0x18]         ;1847
00006c  f02000ff          BIC      r0,r0,#0xff           ;1847
000070  f0400001          ORR      r0,r0,#1              ;1847
000074  61a8              STR      r0,[r5,#0x18]         ;1849
000076  4628              MOV      r0,r5                 ;1849
000078  f7fffffe          BL       _RMP_Set_Rdy
00007c  63ae              STR      r6,[r5,#0x38]         ;1853
00007e  68e0              LDR      r0,[r4,#0xc]          ;1853
000080  1e40              SUBS     r0,r0,#1              ;1853
000082  60e0              STR      r0,[r4,#0xc]          ;1853
                  |L22.132|
000084  6860              LDR      r0,[r4,#4]            ;1853
000086  42a0              CMP      r0,r4                 ;1853
000088  bf1c              ITT      NE                    ;1853
00008a  68e0              LDRNE    r0,[r4,#0xc]          ;1853
00008c  2800              CMPNE    r0,#0                 ;1853
00008e  d1e0              BNE      |L22.82|
000090  f7fffffe          BL       RMP_Unlock_Sched
000094  2000              MOVS     r0,#0                 ;1857
000096  bd70              POP      {r4-r6,pc}
;;;1859   /* End Function:RMP_Sem_Post *************************************************/
                          ENDP

                  |L22.152|
                          DCD      ||.data||

                          AREA ||i.RMP_Sem_Post_ISR||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Post_ISR PROC
;;;1869   ******************************************************************************/
;;;1870   rmp_ret_t RMP_Sem_Post_ISR(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Number)
000000  2800              CMP      r0,#0
;;;1871   {
;;;1872       struct RMP_Thd* Thread;
;;;1873       /* Check if this semaphore structure could possibly be in use */
;;;1874       if((Semaphore==0)||(Number==0))
000002  bf12              ITEE     NE
000004  2900              CMPNE    r1,#0
;;;1875       {
;;;1876           RMP_COVERAGE_MARKER();
;;;1877           return RMP_ERR_SEM;
000006  f06f0005          MVNEQ    r0,#5
;;;1878       }
;;;1879       else
;;;1880           RMP_COVERAGE_MARKER();
;;;1881       
;;;1882       if(Semaphore->State!=RMP_SEM_USED)
;;;1883       {
;;;1884           RMP_COVERAGE_MARKER();
;;;1885           return RMP_ERR_SEM;
;;;1886       }
;;;1887       else
;;;1888           RMP_COVERAGE_MARKER();
;;;1889   
;;;1890       /* Would the maximum value be exceeded if this is posted? */
;;;1891       if((Semaphore->Cur_Num+Number)>=RMP_SEM_MAX_NUM)
;;;1892       {
;;;1893           RMP_COVERAGE_MARKER();
;;;1894           return RMP_ERR_OPER;
;;;1895       }
;;;1896       else
;;;1897           RMP_COVERAGE_MARKER();
;;;1898       
;;;1899       Semaphore->Cur_Num+=Number;
;;;1900       /* Is there any thread waiting on it? If there are, clean them up*/
;;;1901       while((&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)&&(Semaphore->Cur_Num!=0))
;;;1902       {
;;;1903           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
;;;1904           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1905           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1906           {
;;;1907               RMP_COVERAGE_MARKER();
;;;1908               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1909           }
;;;1910           else
;;;1911               RMP_COVERAGE_MARKER();
;;;1912           
;;;1913           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1914           /* Set to running if not suspended */
;;;1915           _RMP_Set_Rdy(Thread);
;;;1916           
;;;1917           /* If schedule pending, trigger it now because we are in ISR */
;;;1918           if(RMP_Sched_Pend!=0)
;;;1919           {
;;;1920               RMP_COVERAGE_MARKER();
;;;1921               RMP_Sched_Pend=0;
;;;1922               _RMP_Yield();   
;;;1923           }
;;;1924           else
;;;1925               RMP_COVERAGE_MARKER();
;;;1926   
;;;1927           /* Finally, return success */
;;;1928           Thread->Retval=0;
;;;1929           Semaphore->Cur_Num--;
;;;1930       }
;;;1931   
;;;1932       return 0;
;;;1933   }
00000a  4770              BXEQ     lr
00000c  e92d41f0          PUSH     {r4-r8,lr}            ;1871
000010  4604              MOV      r4,r0                 ;1871
000012  6880              LDR      r0,[r0,#8]            ;1882
000014  2801              CMP      r0,#1                 ;1882
000016  bf1c              ITT      NE                    ;1885
000018  f06f0005          MVNNE    r0,#5                 ;1885
00001c  e8bd81f0          POPNE    {r4-r8,pc}
000020  68e0              LDR      r0,[r4,#0xc]          ;1891
000022  4408              ADD      r0,r0,r1              ;1891
000024  f5b07f7a          CMP      r0,#0x3e8             ;1891
000028  bf24              ITT      CS                    ;1894
00002a  f06f0004          MVNCS    r0,#4                 ;1894
00002e  e8bd81f0          POPCS    {r4-r8,pc}
000032  68e0              LDR      r0,[r4,#0xc]          ;1899
000034  4408              ADD      r0,r0,r1              ;1899
000036  60e0              STR      r0,[r4,#0xc]          ;1899
000038  4f15              LDR      r7,|L23.144|
00003a  2600              MOVS     r6,#0                 ;1918
00003c  e01e              B        |L23.124|
                  |L23.62|
00003e  6865              LDR      r5,[r4,#4]            ;1903
000040  e9d50100          LDRD     r0,r1,[r5,#0]         ;1903
000044  6008              STR      r0,[r1,#0]            ;1903
000046  6041              STR      r1,[r0,#4]            ;1903
000048  7e28              LDRB     r0,[r5,#0x18]         ;1905
00004a  2808              CMP      r0,#8                 ;1905
00004c  d103              BNE      |L23.86|
00004e  e9d50102          LDRD     r0,r1,[r5,#8]         ;1905
000052  6008              STR      r0,[r1,#0]            ;1905
000054  6041              STR      r1,[r0,#4]            ;1905
                  |L23.86|
000056  69a8              LDR      r0,[r5,#0x18]         ;1913
000058  f02000ff          BIC      r0,r0,#0xff           ;1913
00005c  f0400001          ORR      r0,r0,#1              ;1913
000060  61a8              STR      r0,[r5,#0x18]         ;1915
000062  4628              MOV      r0,r5                 ;1915
000064  f7fffffe          BL       _RMP_Set_Rdy
000068  68f8              LDR      r0,[r7,#0xc]          ;1918  ; RMP_Sched_Pend
00006a  2800              CMP      r0,#0                 ;1918
00006c  bf1c              ITT      NE                    ;1921
00006e  60fe              STRNE    r6,[r7,#0xc]          ;1921  ; RMP_Sched_Pend
000070  f7fffffe          BLNE     _RMP_Yield
000074  63ae              STR      r6,[r5,#0x38]         ;1929
000076  68e0              LDR      r0,[r4,#0xc]          ;1929
000078  1e40              SUBS     r0,r0,#1              ;1929
00007a  60e0              STR      r0,[r4,#0xc]          ;1929
                  |L23.124|
00007c  6860              LDR      r0,[r4,#4]            ;1929
00007e  42a0              CMP      r0,r4                 ;1929
000080  bf1c              ITT      NE                    ;1929
000082  68e0              LDRNE    r0,[r4,#0xc]          ;1929
000084  2800              CMPNE    r0,#0                 ;1929
000086  d1da              BNE      |L23.62|
000088  2000              MOVS     r0,#0                 ;1932
00008a  e8bd81f0          POP      {r4-r8,pc}
;;;1934   /* End Function:RMP_Sem_Post_ISR *********************************************/
                          ENDP

00008e  0000              DCW      0x0000
                  |L23.144|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Cancel||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Cancel PROC
;;;1514   ******************************************************************************/
;;;1515   rmp_ret_t RMP_Thd_Cancel(volatile struct RMP_Thd* Thread)
000000  2800              CMP      r0,#0
;;;1516   {
;;;1517       /* Check if this thread structure could possibly be in use */
;;;1518       if(Thread==0)
;;;1519       {
;;;1520           RMP_COVERAGE_MARKER();
;;;1521           return RMP_ERR_THD;
000002  bf04              ITT      EQ
000004  f04f30ff          MOVEQ    r0,#0xffffffff
;;;1522       }
;;;1523       else
;;;1524           RMP_COVERAGE_MARKER();
;;;1525       
;;;1526       RMP_Lock_Sched();
;;;1527       
;;;1528       /* Is it delayed? */
;;;1529       if(RMP_THD_STATE(Thread->State)!=RMP_THD_DELAYED)
;;;1530       {
;;;1531           RMP_COVERAGE_MARKER();
;;;1532           RMP_Unlock_Sched();
;;;1533           return RMP_ERR_STATE;
;;;1534       }
;;;1535       else
;;;1536           RMP_COVERAGE_MARKER();
;;;1537   
;;;1538       /* Delete it from the delay list */
;;;1539       RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1540       RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1541       /* Set to running if not suspended */
;;;1542       _RMP_Set_Rdy(Thread);
;;;1543       
;;;1544       Thread->Retval=RMP_ERR_OPER;
;;;1545       RMP_Unlock_Sched();
;;;1546       return 0;
;;;1547   }
000008  4770              BXEQ     lr
00000a  b510              PUSH     {r4,lr}               ;1516
00000c  4604              MOV      r4,r0                 ;1516
00000e  20ff              MOVS     r0,#0xff              ;1516
000010  f7fffffe          BL       RMP_Mask_Int
000014  4811              LDR      r0,|L24.92|
000016  2101              MOVS     r1,#1                 ;1516
000018  6081              STR      r1,[r0,#8]            ;1516  ; RMP_Sched_Locked
00001a  6841              LDR      r1,[r0,#4]            ;1516  ; RMP_Sched_Lock_Cnt
00001c  1c49              ADDS     r1,r1,#1              ;1516
00001e  6041              STR      r1,[r0,#4]            ;1516  ; RMP_Sched_Lock_Cnt
000020  69a0              LDR      r0,[r4,#0x18]         ;1529
000022  b2c0              UXTB     r0,r0                 ;1529
000024  2806              CMP      r0,#6                 ;1529
000026  d004              BEQ      |L24.50|
000028  f7fffffe          BL       RMP_Unlock_Sched
00002c  f06f0003          MVN      r0,#3                 ;1533
000030  bd10              POP      {r4,pc}
                  |L24.50|
000032  68a0              LDR      r0,[r4,#8]            ;1539
000034  68e1              LDR      r1,[r4,#0xc]          ;1539
000036  6008              STR      r0,[r1,#0]            ;1539
000038  6041              STR      r1,[r0,#4]            ;1539
00003a  69a0              LDR      r0,[r4,#0x18]         ;1540
00003c  f02000ff          BIC      r0,r0,#0xff           ;1540
000040  f0400001          ORR      r0,r0,#1              ;1540
000044  61a0              STR      r0,[r4,#0x18]         ;1540
000046  4620              MOV      r0,r4                 ;1542
000048  f7fffffe          BL       _RMP_Set_Rdy
00004c  f06f0004          MVN      r0,#4                 ;1544
000050  63a0              STR      r0,[r4,#0x38]         ;1544
000052  f7fffffe          BL       RMP_Unlock_Sched
000056  2000              MOVS     r0,#0                 ;1546
000058  bd10              POP      {r4,pc}
;;;1548   /* End Function:RMP_Thd_Cancel ***********************************************/
                          ENDP

00005a  0000              DCW      0x0000
                  |L24.92|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Crt||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Crt PROC
;;;766    ******************************************************************************/
;;;767    rmp_ret_t RMP_Thd_Crt(volatile struct RMP_Thd* Thread, void* Entry, void* Stack, void* Arg, rmp_ptr_t Prio, rmp_ptr_t Slices)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;768    {
000004  4699              MOV      r9,r3
000006  e9dd8508          LDRD     r8,r5,[sp,#0x20]
00000a  4616              MOV      r6,r2
00000c  468a              MOV      r10,r1
00000e  4604              MOV      r4,r0
;;;769        /* Check if the priority and timeslice range is correct */
;;;770        if(Prio>=RMP_MAX_PREEMPT_PRIO)
000010  f1b80f20          CMP      r8,#0x20
;;;771        {
;;;772            RMP_COVERAGE_MARKER();
;;;773            return RMP_ERR_PRIO;
000014  bf24              ITT      CS
000016  f06f0001          MVNCS    r0,#1
;;;774        }
;;;775        else
;;;776            RMP_COVERAGE_MARKER();
;;;777        
;;;778        if((Slices==0)||(Slices>=RMP_MAX_SLICES))
;;;779        {
;;;780            RMP_COVERAGE_MARKER();
;;;781            return RMP_ERR_SLICE;
;;;782        }
;;;783        else
;;;784            RMP_COVERAGE_MARKER();
;;;785        
;;;786        /* Check if this thread structure could possibly be in use */
;;;787        if(Thread==0)
;;;788        {
;;;789            RMP_COVERAGE_MARKER();
;;;790            return RMP_ERR_THD;
;;;791        }
;;;792        else
;;;793            RMP_COVERAGE_MARKER();
;;;794        
;;;795        RMP_Lock_Sched();
;;;796        
;;;797        if(RMP_THD_STATE(Thread->State)!=RMP_THD_FREE)
;;;798        {
;;;799            RMP_COVERAGE_MARKER();
;;;800            RMP_Unlock_Sched();
;;;801            return RMP_ERR_THD;
;;;802        }
;;;803        else
;;;804            RMP_COVERAGE_MARKER();
;;;805        
;;;806        /* Create the thread and insert it into the list */
;;;807        Thread->Prio=Prio;
;;;808        Thread->Slices=Slices;
;;;809        Thread->Slices_Left=Slices;
;;;810        Thread->Stack=(rmp_ptr_t)Stack;
;;;811        
;;;812        /* Initialize its stack and sending list */
;;;813        _RMP_Stack_Init((rmp_ptr_t)Entry, (rmp_ptr_t)Stack, (rmp_ptr_t)Arg);
;;;814        RMP_List_Crt(&(Thread->Snd_List));
;;;815        
;;;816        /* Notify the scheduler that we have created something new, also check locks */
;;;817        Thread->State=RMP_THD_RUNNING;
;;;818        _RMP_Set_Rdy(Thread);
;;;819        
;;;820        RMP_Unlock_Sched();
;;;821    
;;;822        return 0;
;;;823    }
00001a  e8bd87f0          POPCS    {r4-r10,pc}
00001e  2d00              CMP      r5,#0                 ;778
000020  bf1c              ITT      NE                    ;778
000022  481b              LDRNE    r0,|L25.144|
000024  4285              CMPNE    r5,r0                 ;778
000026  bf24              ITT      CS                    ;781
000028  f06f0002          MVNCS    r0,#2                 ;781
00002c  e8bd87f0          POPCS    {r4-r10,pc}
000030  2c00              CMP      r4,#0                 ;787
000032  bf04              ITT      EQ                    ;790
000034  f04f30ff          MOVEQ    r0,#0xffffffff        ;790
000038  e8bd87f0          POPEQ    {r4-r10,pc}
00003c  20ff              MOVS     r0,#0xff
00003e  f7fffffe          BL       RMP_Mask_Int
000042  4814              LDR      r0,|L25.148|
000044  2701              MOVS     r7,#1
000046  6087              STR      r7,[r0,#8]  ; RMP_Sched_Locked
000048  6841              LDR      r1,[r0,#4]  ; RMP_Sched_Lock_Cnt
00004a  1c49              ADDS     r1,r1,#1
00004c  6041              STR      r1,[r0,#4]  ; RMP_Sched_Lock_Cnt
00004e  69a0              LDR      r0,[r4,#0x18]         ;797
000050  f0100fff          TST      r0,#0xff              ;797
000054  d004              BEQ      |L25.96|
000056  f7fffffe          BL       RMP_Unlock_Sched
00005a  1eb8              SUBS     r0,r7,#2              ;801
00005c  e8bd87f0          POP      {r4-r10,pc}
                  |L25.96|
000060  f8c48024          STR      r8,[r4,#0x24]         ;807
000064  61e5              STR      r5,[r4,#0x1c]         ;808
000066  6225              STR      r5,[r4,#0x20]         ;809
000068  6366              STR      r6,[r4,#0x34]         ;810
00006a  464a              MOV      r2,r9                 ;813
00006c  4631              MOV      r1,r6                 ;813
00006e  4650              MOV      r0,r10                ;813
000070  f7fffffe          BL       _RMP_Stack_Init
000074  f1040010          ADD      r0,r4,#0x10           ;814
000078  6120              STR      r0,[r4,#0x10]         ;814
00007a  6160              STR      r0,[r4,#0x14]         ;814
00007c  61a7              STR      r7,[r4,#0x18]         ;817
00007e  4620              MOV      r0,r4                 ;818
000080  f7fffffe          BL       _RMP_Set_Rdy
000084  f7fffffe          BL       RMP_Unlock_Sched
000088  2000              MOVS     r0,#0                 ;822
00008a  e8bd87f0          POP      {r4-r10,pc}
;;;824    /* End Function:RMP_Thd_Crt **************************************************/
                          ENDP

00008e  0000              DCW      0x0000
                  |L25.144|
                          DCD      0x000186a0
                  |L25.148|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Del||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Del PROC
;;;831    ******************************************************************************/
;;;832    rmp_ret_t RMP_Thd_Del(volatile struct RMP_Thd* Thread)
000000  2800              CMP      r0,#0
;;;833    {
;;;834        struct RMP_Thd* Release;
;;;835        
;;;836        /* Check if this thread structure could possibly be in use */
;;;837        if(Thread==0)
;;;838        {
;;;839            RMP_COVERAGE_MARKER();
;;;840            return RMP_ERR_THD;
000002  bf04              ITT      EQ
000004  f04f30ff          MOVEQ    r0,#0xffffffff
;;;841        }
;;;842        else
;;;843            RMP_COVERAGE_MARKER();
;;;844        
;;;845        RMP_Lock_Sched();
;;;846        
;;;847        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;848        {
;;;849            RMP_COVERAGE_MARKER();
;;;850            RMP_Unlock_Sched();
;;;851            return RMP_ERR_THD;
;;;852        }
;;;853        else
;;;854            RMP_COVERAGE_MARKER();
;;;855        
;;;856        /* See if anyone waiting to send to this thread. If there is, release all these threads */
;;;857        while(&(Thread->Snd_List)!=Thread->Snd_List.Next)
;;;858        {
;;;859            Release=(struct RMP_Thd*)(Thread->Snd_List.Next);
;;;860            RMP_List_Del(Release->Run_Head.Prev,Release->Run_Head.Next);
;;;861            if(RMP_THD_STATE(Release->State)==RMP_THD_SNDDLY)
;;;862            {
;;;863                RMP_COVERAGE_MARKER();
;;;864                RMP_List_Del(Release->Dly_Head.Prev,Release->Dly_Head.Next);
;;;865            }
;;;866            else
;;;867                RMP_COVERAGE_MARKER();
;;;868            
;;;869            RMP_THD_STATE_SET(Release->State,RMP_THD_RUNNING);
;;;870            /* Set ready if not suspended */
;;;871            _RMP_Set_Rdy(Release);
;;;872            Release->Retval=RMP_ERR_OPER;
;;;873        }
;;;874        
;;;875        /* See what is its state */
;;;876        switch(RMP_THD_STATE(Thread->State))
;;;877        {
;;;878            case RMP_THD_RUNNING:
;;;879            {
;;;880                RMP_COVERAGE_MARKER();
;;;881                /* Clear ready if not suspended */
;;;882                _RMP_Clr_Rdy(Thread);
;;;883                break;
;;;884            }
;;;885            
;;;886            /* Do nothing if it is blocked on receive */
;;;887            case RMP_THD_RCVBLK:
;;;888            {
;;;889                RMP_COVERAGE_MARKER();
;;;890                break;
;;;891            }
;;;892            
;;;893            case RMP_THD_SNDBLK:RMP_COVERAGE_MARKER();
;;;894            case RMP_THD_SEMBLK:
;;;895            {
;;;896                RMP_COVERAGE_MARKER();
;;;897                RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;898                break;
;;;899            }
;;;900            
;;;901            case RMP_THD_SNDDLY:RMP_COVERAGE_MARKER();
;;;902            case RMP_THD_SEMDLY:
;;;903            {
;;;904                RMP_COVERAGE_MARKER();
;;;905                RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;906                /* Fall-through case */
;;;907            }
;;;908            case RMP_THD_RCVDLY:RMP_COVERAGE_MARKER();
;;;909            case RMP_THD_DELAYED:
;;;910            {
;;;911                RMP_COVERAGE_MARKER();
;;;912                RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;913                break;
;;;914            }
;;;915            /* Should not get here */
;;;916            default:while(1);
;;;917        }
;;;918        /* Set return value to failure anyway */
;;;919        Thread->Retval=RMP_ERR_OPER;
;;;920        Thread->State=RMP_THD_FREE;
;;;921        /* If we are deleting ourself, pend a yield */
;;;922        if(Thread==RMP_Cur_Thd)
;;;923        {
;;;924            RMP_COVERAGE_MARKER();
;;;925            RMP_Sched_Pend=1;
;;;926        }
;;;927        else
;;;928            RMP_COVERAGE_MARKER();
;;;929        
;;;930        RMP_Unlock_Sched();
;;;931        
;;;932        /* If we are deleting ourself, just stop the execution here */
;;;933        if(Thread==RMP_Cur_Thd)
;;;934            while(1);
;;;935        else
;;;936            RMP_COVERAGE_MARKER();
;;;937    
;;;938        return 0;
;;;939    }
000008  4770              BXEQ     lr
00000a  e92d47f0          PUSH     {r4-r10,lr}           ;833
00000e  4604              MOV      r4,r0                 ;833
000010  20ff              MOVS     r0,#0xff              ;833
000012  f7fffffe          BL       RMP_Mask_Int
000016  4e30              LDR      r6,|L26.216|
000018  f04f0901          MOV      r9,#1                 ;833
00001c  f8c69008          STR      r9,[r6,#8]            ;833  ; RMP_Sched_Locked
000020  6870              LDR      r0,[r6,#4]            ;833  ; RMP_Sched_Lock_Cnt
000022  1c40              ADDS     r0,r0,#1              ;833
000024  6070              STR      r0,[r6,#4]            ;833  ; RMP_Sched_Lock_Cnt
000026  69a0              LDR      r0,[r4,#0x18]         ;847
000028  f0100fff          TST      r0,#0xff              ;847
00002c  d00f              BEQ      |L26.78|
00002e  6960              LDR      r0,[r4,#0x14]         ;857
000030  f1040810          ADD      r8,r4,#0x10           ;857
000034  f06f0704          MVN      r7,#4                 ;872
000038  4540              CMP      r0,r8                 ;857
00003a  d01f              BEQ      |L26.124|
                  |L26.60|
00003c  6965              LDR      r5,[r4,#0x14]         ;859
00003e  e9d50100          LDRD     r0,r1,[r5,#0]         ;859
000042  6008              STR      r0,[r1,#0]            ;859
000044  6041              STR      r1,[r0,#4]            ;859
000046  7e28              LDRB     r0,[r5,#0x18]         ;861
000048  2803              CMP      r0,#3                 ;861
00004a  d10a              BNE      |L26.98|
00004c  e005              B        |L26.90|
                  |L26.78|
00004e  f7fffffe          BL       RMP_Unlock_Sched
000052  f04f30ff          MOV      r0,#0xffffffff        ;851
000056  e8bd87f0          POP      {r4-r10,pc}
                  |L26.90|
00005a  e9d50102          LDRD     r0,r1,[r5,#8]
00005e  6008              STR      r0,[r1,#0]
000060  6041              STR      r1,[r0,#4]
                  |L26.98|
000062  69a8              LDR      r0,[r5,#0x18]         ;869
000064  f02000ff          BIC      r0,r0,#0xff           ;869
000068  f0400001          ORR      r0,r0,#1              ;869
00006c  61a8              STR      r0,[r5,#0x18]         ;871
00006e  4628              MOV      r0,r5                 ;871
000070  f7fffffe          BL       _RMP_Set_Rdy
000074  63af              STR      r7,[r5,#0x38]         ;872
000076  6960              LDR      r0,[r4,#0x14]         ;872
000078  4540              CMP      r0,r8                 ;872
00007a  d1df              BNE      |L26.60|
                  |L26.124|
00007c  69a0              LDR      r0,[r4,#0x18]         ;876
00007e  b2c0              UXTB     r0,r0                 ;876
000080  2809              CMP      r0,#9                 ;876
000082  d228              BCS      |L26.214|
000084  e8dff000          TBB      [pc,r0]               ;876
000088  2705090e          DCB      0x27,0x05,0x09,0x0e
00008c  16121209          DCB      0x16,0x12,0x12,0x09
000090  0e00              DCB      0x0e,0x00
000092  4620              MOV      r0,r4                 ;882
000094  f7fffffe          BL       _RMP_Clr_Rdy
000098  e00c              B        |L26.180|
00009a  6821              LDR      r1,[r4,#0]            ;897
00009c  6860              LDR      r0,[r4,#4]            ;897
00009e  6001              STR      r1,[r0,#0]            ;897
0000a0  6048              STR      r0,[r1,#4]            ;897
0000a2  e007              B        |L26.180|
0000a4  6820              LDR      r0,[r4,#0]            ;905
0000a6  6861              LDR      r1,[r4,#4]            ;905
0000a8  6008              STR      r0,[r1,#0]            ;905
0000aa  6041              STR      r1,[r0,#4]            ;905
0000ac  68a1              LDR      r1,[r4,#8]            ;912
0000ae  68e0              LDR      r0,[r4,#0xc]          ;912
0000b0  6001              STR      r1,[r0,#0]            ;912
0000b2  6048              STR      r0,[r1,#4]            ;912
                  |L26.180|
0000b4  63a7              STR      r7,[r4,#0x38]         ;919
0000b6  2000              MOVS     r0,#0                 ;920
0000b8  61a0              STR      r0,[r4,#0x18]         ;920
0000ba  69b0              LDR      r0,[r6,#0x18]         ;922  ; RMP_Cur_Thd
0000bc  4284              CMP      r4,r0                 ;922
0000be  bf08              IT       EQ                    ;925
0000c0  f8c6900c          STREQ    r9,[r6,#0xc]          ;925  ; RMP_Sched_Pend
0000c4  f7fffffe          BL       RMP_Unlock_Sched
0000c8  69b0              LDR      r0,[r6,#0x18]         ;933  ; RMP_Cur_Thd
0000ca  4284              CMP      r4,r0                 ;933
0000cc  bf1c              ITT      NE                    ;938
0000ce  2000              MOVNE    r0,#0                 ;938
0000d0  e8bd87f0          POPNE    {r4-r10,pc}
                  |L26.212|
0000d4  e7fe              B        |L26.212|
                  |L26.214|
0000d6  e7fe              B        |L26.214|
;;;940    /* End Function:RMP_Thd_Del **************************************************/
                          ENDP

                  |L26.216|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Delay||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Delay PROC
;;;1484   ******************************************************************************/
;;;1485   rmp_ret_t RMP_Thd_Delay(rmp_ptr_t Slices)
000000  b570              PUSH     {r4-r6,lr}
;;;1486   {
000002  0005              MOVS     r5,r0
;;;1487       if((Slices==0)||(Slices>=RMP_MAX_SLICES))
000004  bf1c              ITT      NE
000006  481f              LDRNE    r0,|L27.132|
000008  42a8              CMPNE    r0,r5
;;;1488       {
;;;1489           RMP_COVERAGE_MARKER();
;;;1490           return RMP_ERR_SLICE;
00000a  bf9c              ITT      LS
00000c  f06f0002          MVNLS    r0,#2
;;;1491       }
;;;1492       else
;;;1493           RMP_COVERAGE_MARKER();
;;;1494       
;;;1495       RMP_Lock_Sched();
;;;1496   
;;;1497       /* We must be running and not suspended so we will be out of running queue */
;;;1498       _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1499       RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_DELAYED);
;;;1500       _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1501   
;;;1502       RMP_Cur_Thd->Retval=0;
;;;1503       RMP_Unlock_Sched();
;;;1504       /* Need to return if successful or not */
;;;1505       return RMP_Cur_Thd->Retval;
;;;1506   }
000010  bd70              POPLS    {r4-r6,pc}
000012  20ff              MOVS     r0,#0xff
000014  f7fffffe          BL       RMP_Mask_Int
000018  4c1b              LDR      r4,|L27.136|
00001a  2001              MOVS     r0,#1
00001c  60a0              STR      r0,[r4,#8]  ; RMP_Sched_Locked
00001e  6860              LDR      r0,[r4,#4]  ; RMP_Sched_Lock_Cnt
000020  1c40              ADDS     r0,r0,#1
000022  6060              STR      r0,[r4,#4]  ; RMP_Sched_Lock_Cnt
000024  69a0              LDR      r0,[r4,#0x18]         ;1498  ; RMP_Cur_Thd
000026  f7fffffe          BL       _RMP_Clr_Rdy
00002a  69a0              LDR      r0,[r4,#0x18]         ;1499  ; RMP_Cur_Thd
00002c  69a1              LDR      r1,[r4,#0x18]         ;1499  ; RMP_Cur_Thd
00002e  6980              LDR      r0,[r0,#0x18]         ;1499
000030  f02000ff          BIC      r0,r0,#0xff           ;1499
000034  f0400006          ORR      r0,r0,#6              ;1499
000038  6188              STR      r0,[r1,#0x18]         ;1500
00003a  f8d4c018          LDR      r12,[r4,#0x18]        ;1500  ; RMP_Cur_Thd
00003e  f1040320          ADD      r3,r4,#0x20           ;1500
000042  6859              LDR      r1,[r3,#4]            ;1500  ; RMP_Delay
000044  4299              CMP      r1,r3                 ;1500
000046  d007              BEQ      |L27.88|
                  |L27.72|
000048  6a08              LDR      r0,[r1,#0x20]         ;1500
00004a  6962              LDR      r2,[r4,#0x14]         ;1500  ; RMP_Tick
00004c  1a80              SUBS     r0,r0,r2              ;1500
00004e  42a8              CMP      r0,r5                 ;1500
000050  d802              BHI      |L27.88|
000052  6849              LDR      r1,[r1,#4]            ;1500
000054  4299              CMP      r1,r3                 ;1500
000056  d1f7              BNE      |L27.72|
                  |L27.88|
000058  6960              LDR      r0,[r4,#0x14]         ;1500  ; RMP_Tick
00005a  4428              ADD      r0,r0,r5              ;1500
00005c  f8cc0028          STR      r0,[r12,#0x28]        ;1500
000060  f10c0008          ADD      r0,r12,#8             ;1500
000064  680a              LDR      r2,[r1,#0]            ;1500
000066  6008              STR      r0,[r1,#0]            ;1500
000068  f8cc100c          STR      r1,[r12,#0xc]         ;1500
00006c  f8cc2008          STR      r2,[r12,#8]           ;1500
000070  6050              STR      r0,[r2,#4]            ;1500
000072  69a1              LDR      r1,[r4,#0x18]         ;1502  ; RMP_Cur_Thd
000074  2000              MOVS     r0,#0                 ;1502
000076  6388              STR      r0,[r1,#0x38]         ;1503
000078  f7fffffe          BL       RMP_Unlock_Sched
00007c  69a0              LDR      r0,[r4,#0x18]         ;1505  ; RMP_Cur_Thd
00007e  6b80              LDR      r0,[r0,#0x38]         ;1505
000080  bd70              POP      {r4-r6,pc}
;;;1507   /* End Function:RMP_Thd_Delay ************************************************/
                          ENDP

000082  0000              DCW      0x0000
                  |L27.132|
                          DCD      0x000186a0
                  |L27.136|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Rcv||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Rcv PROC
;;;1367   ******************************************************************************/
;;;1368   rmp_ret_t RMP_Thd_Rcv(rmp_ptr_t* Data, rmp_ptr_t Slices)
000000  2800              CMP      r0,#0
;;;1369   {
;;;1370       struct RMP_Thd* Sender;
;;;1371       
;;;1372       if(Data==0)
;;;1373       {
;;;1374           RMP_COVERAGE_MARKER();
;;;1375           return RMP_ERR_OPER;
000002  bf04              ITT      EQ
000004  f06f0004          MVNEQ    r0,#4
;;;1376       }
;;;1377       else
;;;1378           RMP_COVERAGE_MARKER();
;;;1379       
;;;1380       RMP_Lock_Sched();
;;;1381       
;;;1382       /* Is there any other guy waiting on us? If there is, unblock it and set it running */
;;;1383       Sender=0;
;;;1384       if(&(RMP_Cur_Thd->Snd_List)!=RMP_Cur_Thd->Snd_List.Next)
;;;1385       {
;;;1386           RMP_COVERAGE_MARKER();
;;;1387           /* Read the data */
;;;1388           Sender=(struct RMP_Thd*)(RMP_Cur_Thd->Snd_List.Next);
;;;1389           RMP_List_Del(Sender->Run_Head.Prev,Sender->Run_Head.Next);
;;;1390           *Data=Sender->Data;
;;;1391           /* Now we unblock it - what state is it in? */
;;;1392           if((RMP_THD_STATE(Sender->State)==RMP_THD_SNDDLY))
;;;1393           {
;;;1394               RMP_COVERAGE_MARKER();
;;;1395               RMP_List_Del(Sender->Dly_Head.Prev,Sender->Dly_Head.Next);
;;;1396           }
;;;1397           else
;;;1398               RMP_COVERAGE_MARKER();
;;;1399           
;;;1400           RMP_THD_STATE_SET(Sender->State,RMP_THD_RUNNING);
;;;1401           /* Set to running if not suspended */
;;;1402           _RMP_Set_Rdy(Sender);
;;;1403       }
;;;1404   
;;;1405       /* Check if there is a value in our mailbox. If yes, we return with that value */
;;;1406       if((RMP_Cur_Thd->State&RMP_THD_MBOXFUL)!=0)
;;;1407       {
;;;1408           RMP_COVERAGE_MARKER();
;;;1409           /* Get the value from mailbox */
;;;1410           *Data=RMP_Cur_Thd->Mailbox;
;;;1411           /* See if we unblocked a sender. If yes, we place the new value into 
;;;1412            * our mailbox and it is still full */
;;;1413           if(Sender!=0)
;;;1414               RMP_Cur_Thd->Mailbox=Sender->Data;
;;;1415           else
;;;1416               RMP_Cur_Thd->State&=~RMP_THD_MBOXFUL;
;;;1417           
;;;1418           RMP_Unlock_Sched();
;;;1419           return 0;
;;;1420       }
;;;1421       else
;;;1422       {
;;;1423           RMP_COVERAGE_MARKER();
;;;1424           
;;;1425           /* Box empty. Do we have somebody waiting? */
;;;1426           if(Sender!=0)
;;;1427           {
;;;1428               RMP_COVERAGE_MARKER();
;;;1429               RMP_Cur_Thd->Mailbox=Sender->Data;
;;;1430               RMP_Unlock_Sched();
;;;1431               return 0;
;;;1432           }
;;;1433           /* No sender waiting on us and box empty, we need to block */
;;;1434           else
;;;1435           {
;;;1436               RMP_COVERAGE_MARKER();
;;;1437               
;;;1438               if(Slices==0)
;;;1439               {
;;;1440                   RMP_COVERAGE_MARKER();
;;;1441                   RMP_Unlock_Sched();
;;;1442                   return RMP_ERR_OPER;
;;;1443               }
;;;1444               else
;;;1445                   RMP_COVERAGE_MARKER();
;;;1446   
;;;1447               /* We must be running and not suspended so we will surely be deleted from queue */
;;;1448               _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1449   
;;;1450               if(Slices<RMP_MAX_SLICES)
;;;1451               {
;;;1452                   RMP_COVERAGE_MARKER();
;;;1453                   _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1454                   RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_RCVDLY);
;;;1455               }
;;;1456               else
;;;1457               {
;;;1458                   RMP_COVERAGE_MARKER();
;;;1459                   RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_RCVBLK);
;;;1460               }
;;;1461               RMP_Unlock_Sched();
;;;1462               
;;;1463               /* Dummy read - to separate the lock & unlock. If the compiler optimizes these two
;;;1464                * functions(inline them) on some architectures sometimes we never block. */
;;;1465               *Data=RMP_Cur_Thd->Mailbox;
;;;1466               
;;;1467               /* We've been unblocked. There must be something in our mbox, or we should have failed */
;;;1468               RMP_Lock_Sched();
;;;1469               *Data=RMP_Cur_Thd->Mailbox;
;;;1470               RMP_Cur_Thd->State&=~RMP_THD_MBOXFUL;
;;;1471           }
;;;1472       }
;;;1473       
;;;1474       RMP_Unlock_Sched();
;;;1475       return RMP_Cur_Thd->Retval;
;;;1476   }
000008  4770              BXEQ     lr
00000a  e92d41f0          PUSH     {r4-r8,lr}            ;1369
00000e  4607              MOV      r7,r0                 ;1369
000010  460e              MOV      r6,r1                 ;1369
000012  20ff              MOVS     r0,#0xff              ;1369
000014  f7fffffe          BL       RMP_Mask_Int
000018  4c4c              LDR      r4,|L28.332|
00001a  f04f0801          MOV      r8,#1                 ;1369
00001e  f8c48008          STR      r8,[r4,#8]            ;1369  ; RMP_Sched_Locked
000022  6860              LDR      r0,[r4,#4]            ;1369  ; RMP_Sched_Lock_Cnt
000024  1c40              ADDS     r0,r0,#1              ;1369
000026  6060              STR      r0,[r4,#4]            ;1369  ; RMP_Sched_Lock_Cnt
000028  69a0              LDR      r0,[r4,#0x18]         ;1384  ; RMP_Cur_Thd
00002a  2500              MOVS     r5,#0                 ;1383
00002c  69a1              LDR      r1,[r4,#0x18]         ;1384  ; RMP_Cur_Thd
00002e  6940              LDR      r0,[r0,#0x14]         ;1384
000030  3110              ADDS     r1,r1,#0x10           ;1384
000032  4288              CMP      r0,r1                 ;1384
000034  d017              BEQ      |L28.102|
000036  69a0              LDR      r0,[r4,#0x18]         ;1388  ; RMP_Cur_Thd
000038  6945              LDR      r5,[r0,#0x14]         ;1388
00003a  e9d50100          LDRD     r0,r1,[r5,#0]         ;1388
00003e  6008              STR      r0,[r1,#0]            ;1388
000040  6041              STR      r1,[r0,#4]            ;1388
000042  6b28              LDR      r0,[r5,#0x30]         ;1390
000044  6038              STR      r0,[r7,#0]            ;1392
000046  7e28              LDRB     r0,[r5,#0x18]         ;1392
000048  2803              CMP      r0,#3                 ;1392
00004a  d103              BNE      |L28.84|
00004c  e9d50102          LDRD     r0,r1,[r5,#8]         ;1392
000050  6008              STR      r0,[r1,#0]            ;1392
000052  6041              STR      r1,[r0,#4]            ;1392
                  |L28.84|
000054  69a8              LDR      r0,[r5,#0x18]         ;1400
000056  f02000ff          BIC      r0,r0,#0xff           ;1400
00005a  f0400001          ORR      r0,r0,#1              ;1400
00005e  61a8              STR      r0,[r5,#0x18]         ;1402
000060  4628              MOV      r0,r5                 ;1402
000062  f7fffffe          BL       _RMP_Set_Rdy
                  |L28.102|
000066  69a0              LDR      r0,[r4,#0x18]         ;1406  ; RMP_Cur_Thd
000068  8b00              LDRH     r0,[r0,#0x18]         ;1406
00006a  f4107f00          TST      r0,#0x200             ;1406
00006e  d012              BEQ      |L28.150|
000070  69a0              LDR      r0,[r4,#0x18]         ;1410  ; RMP_Cur_Thd
000072  2d00              CMP      r5,#0                 ;1413
000074  6ac0              LDR      r0,[r0,#0x2c]         ;1410
000076  6038              STR      r0,[r7,#0]            ;1413
000078  bf01              ITTTT    EQ                    ;1416
00007a  69a0              LDREQ    r0,[r4,#0x18]         ;1416  ; RMP_Cur_Thd
00007c  6981              LDREQ    r1,[r0,#0x18]         ;1416
00007e  f4217100          BICEQ    r1,r1,#0x200          ;1416
000082  6181              STREQ    r1,[r0,#0x18]         ;1416
000084  bf1e              ITTT     NE                    ;1414
000086  6b28              LDRNE    r0,[r5,#0x30]         ;1414
000088  69a1              LDRNE    r1,[r4,#0x18]         ;1414  ; RMP_Cur_Thd
00008a  62c8              STRNE    r0,[r1,#0x2c]         ;1414
00008c  f7fffffe          BL       RMP_Unlock_Sched
000090  2000              MOVS     r0,#0                 ;1419
000092  e8bd81f0          POP      {r4-r8,pc}
                  |L28.150|
000096  b13d              CBZ      r5,|L28.168|
000098  6b28              LDR      r0,[r5,#0x30]         ;1429
00009a  69a1              LDR      r1,[r4,#0x18]         ;1429  ; RMP_Cur_Thd
00009c  62c8              STR      r0,[r1,#0x2c]         ;1430
00009e  f7fffffe          BL       RMP_Unlock_Sched
0000a2  2000              MOVS     r0,#0                 ;1431
0000a4  e8bd81f0          POP      {r4-r8,pc}
                  |L28.168|
0000a8  b33e              CBZ      r6,|L28.250|
0000aa  69a0              LDR      r0,[r4,#0x18]         ;1448  ; RMP_Cur_Thd
0000ac  f7fffffe          BL       _RMP_Clr_Rdy
0000b0  4827              LDR      r0,|L28.336|
0000b2  4286              CMP      r6,r0                 ;1450
0000b4  d227              BCS      |L28.262|
0000b6  69a2              LDR      r2,[r4,#0x18]         ;1453  ; RMP_Cur_Thd
0000b8  4b26              LDR      r3,|L28.340|
0000ba  6858              LDR      r0,[r3,#4]            ;1453  ; RMP_Delay
0000bc  4298              CMP      r0,r3                 ;1453
0000be  d009              BEQ      |L28.212|
                  |L28.192|
0000c0  6a01              LDR      r1,[r0,#0x20]         ;1453
0000c2  f8d4c014          LDR      r12,[r4,#0x14]        ;1453  ; RMP_Tick
0000c6  eba1010c          SUB      r1,r1,r12             ;1453
0000ca  42b1              CMP      r1,r6                 ;1453
0000cc  d802              BHI      |L28.212|
0000ce  6840              LDR      r0,[r0,#4]            ;1453
0000d0  4298              CMP      r0,r3                 ;1453
0000d2  d1f5              BNE      |L28.192|
                  |L28.212|
0000d4  6961              LDR      r1,[r4,#0x14]         ;1453  ; RMP_Tick
0000d6  4431              ADD      r1,r1,r6              ;1453
0000d8  6291              STR      r1,[r2,#0x28]         ;1453
0000da  f1020108          ADD      r1,r2,#8              ;1453
0000de  6802              LDR      r2,[r0,#0]            ;1453
0000e0  6001              STR      r1,[r0,#0]            ;1453
0000e2  6048              STR      r0,[r1,#4]            ;1453
0000e4  600a              STR      r2,[r1,#0]            ;1453
0000e6  6051              STR      r1,[r2,#4]            ;1453
0000e8  69a0              LDR      r0,[r4,#0x18]         ;1454  ; RMP_Cur_Thd
0000ea  69a1              LDR      r1,[r4,#0x18]         ;1454  ; RMP_Cur_Thd
0000ec  6980              LDR      r0,[r0,#0x18]         ;1454
0000ee  f02000ff          BIC      r0,r0,#0xff           ;1454
0000f2  f0400005          ORR      r0,r0,#5              ;1454
0000f6  6188              STR      r0,[r1,#0x18]         ;1454
0000f8  e00d              B        |L28.278|
                  |L28.250|
0000fa  f7fffffe          BL       RMP_Unlock_Sched
0000fe  f06f0004          MVN      r0,#4                 ;1442
000102  e8bd81f0          POP      {r4-r8,pc}
                  |L28.262|
000106  69a0              LDR      r0,[r4,#0x18]         ;1459  ; RMP_Cur_Thd
000108  69a1              LDR      r1,[r4,#0x18]         ;1459  ; RMP_Cur_Thd
00010a  6980              LDR      r0,[r0,#0x18]         ;1459
00010c  f02000ff          BIC      r0,r0,#0xff           ;1459
000110  f0400004          ORR      r0,r0,#4              ;1459
000114  6188              STR      r0,[r1,#0x18]         ;1459
                  |L28.278|
000116  f7fffffe          BL       RMP_Unlock_Sched
00011a  69a0              LDR      r0,[r4,#0x18]         ;1465  ; RMP_Cur_Thd
00011c  6ac0              LDR      r0,[r0,#0x2c]         ;1465
00011e  6038              STR      r0,[r7,#0]            ;1465
000120  20ff              MOVS     r0,#0xff              ;1465
000122  f7fffffe          BL       RMP_Mask_Int
000126  f8c48008          STR      r8,[r4,#8]            ;1465  ; RMP_Sched_Locked
00012a  6860              LDR      r0,[r4,#4]            ;1465  ; RMP_Sched_Lock_Cnt
00012c  1c40              ADDS     r0,r0,#1              ;1465
00012e  6060              STR      r0,[r4,#4]            ;1465  ; RMP_Sched_Lock_Cnt
000130  69a0              LDR      r0,[r4,#0x18]         ;1469  ; RMP_Cur_Thd
000132  6ac0              LDR      r0,[r0,#0x2c]         ;1469
000134  6038              STR      r0,[r7,#0]            ;1470
000136  69a0              LDR      r0,[r4,#0x18]         ;1470  ; RMP_Cur_Thd
000138  6981              LDR      r1,[r0,#0x18]         ;1470
00013a  f4217100          BIC      r1,r1,#0x200          ;1470
00013e  6181              STR      r1,[r0,#0x18]         ;1474
000140  f7fffffe          BL       RMP_Unlock_Sched
000144  69a0              LDR      r0,[r4,#0x18]         ;1475  ; RMP_Cur_Thd
000146  6b80              LDR      r0,[r0,#0x38]         ;1475
000148  e8bd81f0          POP      {r4-r8,pc}
;;;1477   /* End Function:RMP_Thd_Rcv **************************************************/
                          ENDP

                  |L28.332|
                          DCD      ||.data||
                  |L28.336|
                          DCD      0x000186a0
                  |L28.340|
                          DCD      ||.data||+0x20

                          AREA ||i.RMP_Thd_Resume||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Resume PROC
;;;1111   ******************************************************************************/
;;;1112   rmp_ret_t RMP_Thd_Resume(volatile struct RMP_Thd* Thread)
000000  2800              CMP      r0,#0
;;;1113   {
;;;1114       rmp_ret_t Retval;
;;;1115       
;;;1116       /* Check if this thread structure could possibly be in use */
;;;1117       if(Thread==0)
;;;1118       {
;;;1119           RMP_COVERAGE_MARKER();
;;;1120           return RMP_ERR_THD;
000002  bf04              ITT      EQ
000004  f04f30ff          MOVEQ    r0,#0xffffffff
;;;1121       }
;;;1122       else
;;;1123           RMP_COVERAGE_MARKER();
;;;1124   
;;;1125       RMP_Lock_Sched();
;;;1126       
;;;1127       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;1128       {
;;;1129           RMP_COVERAGE_MARKER();
;;;1130           RMP_Unlock_Sched();
;;;1131           return RMP_ERR_THD;
;;;1132       }
;;;1133       else
;;;1134           RMP_COVERAGE_MARKER();
;;;1135       
;;;1136       /* Check if the thread is suspended, if not, then throw an error */
;;;1137       if((Thread->State&RMP_THD_SUSPENDED)!=0)
;;;1138       {
;;;1139           RMP_COVERAGE_MARKER();
;;;1140           
;;;1141           /* Suspended */
;;;1142           Thread->State&=~RMP_THD_SUSPENDED;
;;;1143           /* Only when it is running will we put it back. It can't be suspended here, 
;;;1144            * so the set ready operation will surely put it back */
;;;1145           if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
;;;1146           {
;;;1147               RMP_COVERAGE_MARKER();
;;;1148               _RMP_Set_Rdy(Thread);
;;;1149           }
;;;1150           else
;;;1151               RMP_COVERAGE_MARKER();
;;;1152           
;;;1153           Retval=0;
;;;1154       }
;;;1155       else
;;;1156       {
;;;1157           RMP_COVERAGE_MARKER();
;;;1158           Retval=RMP_ERR_STATE;
;;;1159       }
;;;1160       
;;;1161       RMP_Unlock_Sched();
;;;1162   
;;;1163       return Retval;
;;;1164   }
000008  4770              BXEQ     lr
00000a  b510              PUSH     {r4,lr}               ;1113
00000c  4604              MOV      r4,r0                 ;1113
00000e  20ff              MOVS     r0,#0xff              ;1113
000010  f7fffffe          BL       RMP_Mask_Int
000014  4812              LDR      r0,|L29.96|
000016  2101              MOVS     r1,#1                 ;1113
000018  6081              STR      r1,[r0,#8]            ;1113  ; RMP_Sched_Locked
00001a  6841              LDR      r1,[r0,#4]            ;1113  ; RMP_Sched_Lock_Cnt
00001c  1c49              ADDS     r1,r1,#1              ;1113
00001e  6041              STR      r1,[r0,#4]            ;1113  ; RMP_Sched_Lock_Cnt
000020  69a0              LDR      r0,[r4,#0x18]         ;1127
000022  f0100fff          TST      r0,#0xff              ;1127
000026  d016              BEQ      |L29.86|
000028  69a0              LDR      r0,[r4,#0x18]         ;1137
00002a  f4107f80          TST      r0,#0x100             ;1137
00002e  bf08              IT       EQ                    ;1158
000030  f06f0403          MVNEQ    r4,#3                 ;1158
000034  d00b              BEQ      |L29.78|
000036  69a0              LDR      r0,[r4,#0x18]         ;1142
000038  f4207080          BIC      r0,r0,#0x100          ;1142
00003c  61a0              STR      r0,[r4,#0x18]         ;1142
00003e  69a0              LDR      r0,[r4,#0x18]         ;1145
000040  b2c0              UXTB     r0,r0                 ;1145
000042  2801              CMP      r0,#1                 ;1145
000044  bf04              ITT      EQ                    ;1148
000046  4620              MOVEQ    r0,r4                 ;1148
000048  f7fffffe          BLEQ     _RMP_Set_Rdy
00004c  2400              MOVS     r4,#0                 ;1153
                  |L29.78|
00004e  f7fffffe          BL       RMP_Unlock_Sched
000052  4620              MOV      r0,r4                 ;1163
000054  bd10              POP      {r4,pc}
                  |L29.86|
000056  f7fffffe          BL       RMP_Unlock_Sched
00005a  f04f30ff          MOV      r0,#0xffffffff        ;1131
00005e  bd10              POP      {r4,pc}
;;;1165   /* End Function:RMP_Thd_Resume ***********************************************/
                          ENDP

                  |L29.96|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Set||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Set PROC
;;;951    ******************************************************************************/
;;;952    rmp_ret_t RMP_Thd_Set(volatile struct RMP_Thd* Thread, rmp_ptr_t Prio, rmp_ptr_t Slices)
000000  2a00              CMP      r2,#0
;;;953    {
;;;954        /* Check if the priority and timeslice range is correct */
;;;955        if(Slices==0)
;;;956        {
;;;957            RMP_COVERAGE_MARKER();
;;;958            return RMP_ERR_SLICE;
000002  bf04              ITT      EQ
000004  f06f0002          MVNEQ    r0,#2
;;;959        }
;;;960        else
;;;961            RMP_COVERAGE_MARKER();
;;;962        
;;;963        /* Check if this thread structure could possibly be in use */
;;;964        if(Thread==0)
;;;965        {
;;;966            RMP_COVERAGE_MARKER();
;;;967            return RMP_ERR_THD;
;;;968        }
;;;969        else
;;;970            RMP_COVERAGE_MARKER();
;;;971        
;;;972        RMP_Lock_Sched();
;;;973        
;;;974        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;975        {
;;;976            RMP_COVERAGE_MARKER();
;;;977            RMP_Unlock_Sched();
;;;978            return RMP_ERR_THD;
;;;979        }
;;;980        else
;;;981            RMP_COVERAGE_MARKER();
;;;982        
;;;983        /* See if the thread is in running state */
;;;984        if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
;;;985        {
;;;986            RMP_COVERAGE_MARKER();
;;;987            
;;;988            /* See if we are gonna change one of it or both */
;;;989            if(Prio<RMP_MAX_PREEMPT_PRIO)
;;;990            {
;;;991                RMP_COVERAGE_MARKER();
;;;992                if(Thread->Prio!=Prio)
;;;993                {
;;;994                    RMP_COVERAGE_MARKER();
;;;995                    /* It doesn't matter whether this is suspended or not. 
;;;996                     * If suspended, the operations will not be conducted. */
;;;997                    _RMP_Clr_Rdy(Thread);
;;;998                    Thread->Prio=Prio;
;;;999                    _RMP_Set_Rdy(Thread);
;;;1000               }
;;;1001               else
;;;1002                   RMP_COVERAGE_MARKER();
;;;1003           }
;;;1004           else
;;;1005               RMP_COVERAGE_MARKER();
;;;1006           
;;;1007           if(Slices<RMP_MAX_SLICES)
;;;1008           {
;;;1009               RMP_COVERAGE_MARKER();
;;;1010               Thread->Slices=Slices;
;;;1011           }
;;;1012           else
;;;1013               RMP_COVERAGE_MARKER();
;;;1014       }
;;;1015       else
;;;1016       {
;;;1017           RMP_COVERAGE_MARKER();
;;;1018           
;;;1019           if(Prio<RMP_MAX_PREEMPT_PRIO)
;;;1020           {
;;;1021               RMP_COVERAGE_MARKER();
;;;1022               Thread->Prio=Prio;
;;;1023           }
;;;1024           else
;;;1025               RMP_COVERAGE_MARKER();
;;;1026           
;;;1027           if(Slices<RMP_MAX_SLICES)
;;;1028           {
;;;1029               RMP_COVERAGE_MARKER();
;;;1030               Thread->Slices=Slices;
;;;1031           }
;;;1032           else
;;;1033               RMP_COVERAGE_MARKER();
;;;1034       }
;;;1035       
;;;1036       RMP_Unlock_Sched();
;;;1037       return 0;
;;;1038   }
000008  4770              BXEQ     lr
00000a  2800              CMP      r0,#0                 ;964
00000c  bf04              ITT      EQ                    ;967
00000e  f04f30ff          MOVEQ    r0,#0xffffffff        ;967
000012  4770              BXEQ     lr
000014  e92d41f0          PUSH     {r4-r8,lr}            ;953
000018  4604              MOV      r4,r0                 ;953
00001a  4615              MOV      r5,r2                 ;953
00001c  460e              MOV      r6,r1                 ;953
00001e  20ff              MOVS     r0,#0xff              ;953
000020  f7fffffe          BL       RMP_Mask_Int
000024  4817              LDR      r0,|L30.132|
000026  2101              MOVS     r1,#1                 ;953
000028  6081              STR      r1,[r0,#8]            ;953  ; RMP_Sched_Locked
00002a  6841              LDR      r1,[r0,#4]            ;953  ; RMP_Sched_Lock_Cnt
00002c  1c49              ADDS     r1,r1,#1              ;953
00002e  6041              STR      r1,[r0,#4]            ;953  ; RMP_Sched_Lock_Cnt
000030  69a0              LDR      r0,[r4,#0x18]         ;974
000032  f0100fff          TST      r0,#0xff              ;974
000036  d00f              BEQ      |L30.88|
000038  69a0              LDR      r0,[r4,#0x18]         ;984
00003a  4f13              LDR      r7,|L30.136|
00003c  b2c0              UXTB     r0,r0                 ;984
00003e  2801              CMP      r0,#1                 ;984
000040  d010              BEQ      |L30.100|
000042  2e20              CMP      r6,#0x20              ;1019
000044  bf38              IT       CC                    ;1022
000046  6266              STRCC    r6,[r4,#0x24]         ;1022
000048  42bd              CMP      r5,r7                 ;1027
00004a  d200              BCS      |L30.78|
                  |L30.76|
00004c  61e5              STR      r5,[r4,#0x1c]         ;1030
                  |L30.78|
00004e  f7fffffe          BL       RMP_Unlock_Sched
000052  2000              MOVS     r0,#0                 ;1037
000054  e8bd81f0          POP      {r4-r8,pc}
                  |L30.88|
000058  f7fffffe          BL       RMP_Unlock_Sched
00005c  f04f30ff          MOV      r0,#0xffffffff        ;978
000060  e8bd81f0          POP      {r4-r8,pc}
                  |L30.100|
000064  2e20              CMP      r6,#0x20              ;989
000066  d209              BCS      |L30.124|
000068  6a60              LDR      r0,[r4,#0x24]         ;992
00006a  42b0              CMP      r0,r6                 ;992
00006c  d006              BEQ      |L30.124|
00006e  4620              MOV      r0,r4                 ;997
000070  f7fffffe          BL       _RMP_Clr_Rdy
000074  6266              STR      r6,[r4,#0x24]         ;998
000076  4620              MOV      r0,r4                 ;999
000078  f7fffffe          BL       _RMP_Set_Rdy
                  |L30.124|
00007c  42bd              CMP      r5,r7                 ;1007
00007e  d2e6              BCS      |L30.78|
000080  e7e4              B        |L30.76|
;;;1039   /* End Function:RMP_Thd_Set **************************************************/
                          ENDP

000082  0000              DCW      0x0000
                  |L30.132|
                          DCD      ||.data||
                  |L30.136|
                          DCD      0x000186a0

                          AREA ||i.RMP_Thd_Snd||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Snd PROC
;;;1175   ******************************************************************************/
;;;1176   rmp_ret_t RMP_Thd_Snd(volatile struct RMP_Thd* Thread, rmp_ptr_t Data, rmp_ptr_t Slices)
000000  2800              CMP      r0,#0
;;;1177   {
;;;1178       /* Check if this thread structure could possibly be in use */
;;;1179       if(Thread==0)
;;;1180       {
;;;1181           RMP_COVERAGE_MARKER();
;;;1182           return RMP_ERR_THD;
000002  bf04              ITT      EQ
000004  f04f30ff          MOVEQ    r0,#0xffffffff
;;;1183       }
;;;1184       else
;;;1185           RMP_COVERAGE_MARKER();
;;;1186       
;;;1187       RMP_Lock_Sched();
;;;1188       
;;;1189       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;1190       {
;;;1191           RMP_COVERAGE_MARKER();
;;;1192           RMP_Unlock_Sched();
;;;1193           return RMP_ERR_THD;
;;;1194       }
;;;1195       else
;;;1196           RMP_COVERAGE_MARKER();
;;;1197       
;;;1198       /* Are we sending to ourself? This is not allowed */
;;;1199       if(RMP_Cur_Thd==Thread)
;;;1200       {
;;;1201           RMP_COVERAGE_MARKER();
;;;1202           RMP_Unlock_Sched();
;;;1203           return RMP_ERR_OPER;
;;;1204       }
;;;1205       else
;;;1206           RMP_COVERAGE_MARKER();
;;;1207       
;;;1208       RMP_Cur_Thd->Retval=0;
;;;1209   
;;;1210       /* See if there is already a value in the mailbox, if yes, we block */
;;;1211       if((Thread->State&RMP_THD_MBOXFUL)!=0)
;;;1212       {
;;;1213           RMP_COVERAGE_MARKER();
;;;1214           
;;;1215           /* Mailbox full, we block, and put ourself into the queue */
;;;1216           if(Slices==0)
;;;1217           {
;;;1218               RMP_COVERAGE_MARKER();
;;;1219               RMP_Unlock_Sched();
;;;1220               return RMP_ERR_OPER;
;;;1221           }
;;;1222           else
;;;1223               RMP_COVERAGE_MARKER();
;;;1224   
;;;1225           /* We must be running */
;;;1226           _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1227           RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),Thread->Snd_List.Prev,&(Thread->Snd_List));
;;;1228   
;;;1229           if(Slices<RMP_MAX_SLICES)
;;;1230           {
;;;1231               RMP_COVERAGE_MARKER();
;;;1232               _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1233               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SNDDLY);
;;;1234           }
;;;1235           else
;;;1236           {
;;;1237               RMP_COVERAGE_MARKER();
;;;1238               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SNDBLK);
;;;1239           }
;;;1240   
;;;1241           RMP_Cur_Thd->Data=Data;
;;;1242       }
;;;1243       else
;;;1244       {
;;;1245           RMP_COVERAGE_MARKER();
;;;1246           
;;;1247           /* Mailbox not full. We need to check if the receiver is waiting for us */
;;;1248           if((RMP_THD_STATE(Thread->State)==RMP_THD_RCVBLK)||
;;;1249              (RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY))
;;;1250           {
;;;1251               RMP_COVERAGE_MARKER();
;;;1252               
;;;1253               /* The receiver is blocked, wake it up and return the value */
;;;1254               if(RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY)
;;;1255               {
;;;1256                   RMP_COVERAGE_MARKER();
;;;1257                   RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1258               }
;;;1259               else
;;;1260                   RMP_COVERAGE_MARKER();
;;;1261               
;;;1262               RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1263               /* Set to running if not suspended */
;;;1264               _RMP_Set_Rdy(Thread);
;;;1265           }
;;;1266           else
;;;1267               RMP_COVERAGE_MARKER();
;;;1268           
;;;1269           /* Set the mailbox */
;;;1270           Thread->Mailbox=Data;
;;;1271           Thread->State|=RMP_THD_MBOXFUL;
;;;1272       }
;;;1273       
;;;1274       RMP_Unlock_Sched();
;;;1275   
;;;1276       return RMP_Cur_Thd->Retval;
;;;1277   }
000008  4770              BXEQ     lr
00000a  e92d41f0          PUSH     {r4-r8,lr}            ;1177
00000e  4605              MOV      r5,r0                 ;1177
000010  4616              MOV      r6,r2                 ;1177
000012  460f              MOV      r7,r1                 ;1177
000014  20ff              MOVS     r0,#0xff              ;1177
000016  f7fffffe          BL       RMP_Mask_Int
00001a  4c40              LDR      r4,|L31.284|
00001c  2001              MOVS     r0,#1                 ;1177
00001e  60a0              STR      r0,[r4,#8]            ;1177  ; RMP_Sched_Locked
000020  6860              LDR      r0,[r4,#4]            ;1177  ; RMP_Sched_Lock_Cnt
000022  1c40              ADDS     r0,r0,#1              ;1177
000024  6060              STR      r0,[r4,#4]            ;1177  ; RMP_Sched_Lock_Cnt
000026  69a8              LDR      r0,[r5,#0x18]         ;1189
000028  f0100fff          TST      r0,#0xff              ;1189
00002c  d03b              BEQ      |L31.166|
00002e  69a0              LDR      r0,[r4,#0x18]         ;1199  ; RMP_Cur_Thd
000030  42a8              CMP      r0,r5                 ;1199
000032  d03e              BEQ      |L31.178|
000034  69a1              LDR      r1,[r4,#0x18]         ;1208  ; RMP_Cur_Thd
000036  2000              MOVS     r0,#0                 ;1208
000038  6388              STR      r0,[r1,#0x38]         ;1211
00003a  69a8              LDR      r0,[r5,#0x18]         ;1211
00003c  f4107f00          TST      r0,#0x200             ;1211
000040  d048              BEQ      |L31.212|
000042  2e00              CMP      r6,#0                 ;1216
000044  d035              BEQ      |L31.178|
000046  69a0              LDR      r0,[r4,#0x18]         ;1226  ; RMP_Cur_Thd
000048  f7fffffe          BL       _RMP_Clr_Rdy
00004c  69a0              LDR      r0,[r4,#0x18]         ;1227  ; RMP_Cur_Thd
00004e  f8551f10          LDR      r1,[r5,#0x10]!        ;1227
000052  6028              STR      r0,[r5,#0]            ;1227
000054  6045              STR      r5,[r0,#4]            ;1227
000056  6001              STR      r1,[r0,#0]            ;1227
000058  6048              STR      r0,[r1,#4]            ;1227
00005a  4831              LDR      r0,|L31.288|
00005c  4286              CMP      r6,r0                 ;1229
00005e  d22e              BCS      |L31.190|
000060  69a3              LDR      r3,[r4,#0x18]         ;1232  ; RMP_Cur_Thd
000062  f1040220          ADD      r2,r4,#0x20           ;1232
000066  6850              LDR      r0,[r2,#4]            ;1232  ; RMP_Delay
000068  4290              CMP      r0,r2                 ;1232
00006a  d009              BEQ      |L31.128|
                  |L31.108|
00006c  6a01              LDR      r1,[r0,#0x20]         ;1232
00006e  f8d4c014          LDR      r12,[r4,#0x14]        ;1232  ; RMP_Tick
000072  eba1010c          SUB      r1,r1,r12             ;1232
000076  42b1              CMP      r1,r6                 ;1232
000078  d802              BHI      |L31.128|
00007a  6840              LDR      r0,[r0,#4]            ;1232
00007c  4290              CMP      r0,r2                 ;1232
00007e  d1f5              BNE      |L31.108|
                  |L31.128|
000080  6961              LDR      r1,[r4,#0x14]         ;1232  ; RMP_Tick
000082  4431              ADD      r1,r1,r6              ;1232
000084  6299              STR      r1,[r3,#0x28]         ;1232
000086  f1030208          ADD      r2,r3,#8              ;1232
00008a  6801              LDR      r1,[r0,#0]            ;1232
00008c  6002              STR      r2,[r0,#0]            ;1232
00008e  60d8              STR      r0,[r3,#0xc]          ;1232
000090  6099              STR      r1,[r3,#8]            ;1232
000092  604a              STR      r2,[r1,#4]            ;1232
000094  69a0              LDR      r0,[r4,#0x18]         ;1233  ; RMP_Cur_Thd
000096  69a1              LDR      r1,[r4,#0x18]         ;1233  ; RMP_Cur_Thd
000098  6980              LDR      r0,[r0,#0x18]         ;1233
00009a  f02000ff          BIC      r0,r0,#0xff           ;1233
00009e  f0400003          ORR      r0,r0,#3              ;1233
0000a2  6188              STR      r0,[r1,#0x18]         ;1233
0000a4  e013              B        |L31.206|
                  |L31.166|
0000a6  f7fffffe          BL       RMP_Unlock_Sched
0000aa  f04f30ff          MOV      r0,#0xffffffff        ;1193
0000ae  e8bd81f0          POP      {r4-r8,pc}
                  |L31.178|
0000b2  f7fffffe          BL       RMP_Unlock_Sched
0000b6  f06f0004          MVN      r0,#4                 ;1220
0000ba  e8bd81f0          POP      {r4-r8,pc}
                  |L31.190|
0000be  69a0              LDR      r0,[r4,#0x18]         ;1238  ; RMP_Cur_Thd
0000c0  69a1              LDR      r1,[r4,#0x18]         ;1238  ; RMP_Cur_Thd
0000c2  6980              LDR      r0,[r0,#0x18]         ;1238
0000c4  f02000ff          BIC      r0,r0,#0xff           ;1238
0000c8  f0400002          ORR      r0,r0,#2              ;1238
0000cc  6188              STR      r0,[r1,#0x18]         ;1238
                  |L31.206|
0000ce  69a0              LDR      r0,[r4,#0x18]         ;1241  ; RMP_Cur_Thd
0000d0  6307              STR      r7,[r0,#0x30]         ;1241
0000d2  e01d              B        |L31.272|
                  |L31.212|
0000d4  69a8              LDR      r0,[r5,#0x18]         ;1248
0000d6  b2c0              UXTB     r0,r0                 ;1248
0000d8  2804              CMP      r0,#4                 ;1248
0000da  d003              BEQ      |L31.228|
0000dc  69a8              LDR      r0,[r5,#0x18]         ;1248
0000de  b2c0              UXTB     r0,r0                 ;1248
0000e0  2805              CMP      r0,#5                 ;1248
0000e2  d110              BNE      |L31.262|
                  |L31.228|
0000e4  69a8              LDR      r0,[r5,#0x18]         ;1254
0000e6  b2c0              UXTB     r0,r0                 ;1254
0000e8  2805              CMP      r0,#5                 ;1254
0000ea  d103              BNE      |L31.244|
0000ec  68a8              LDR      r0,[r5,#8]            ;1257
0000ee  68e9              LDR      r1,[r5,#0xc]          ;1257
0000f0  6008              STR      r0,[r1,#0]            ;1257
0000f2  6041              STR      r1,[r0,#4]            ;1257
                  |L31.244|
0000f4  69a8              LDR      r0,[r5,#0x18]         ;1262
0000f6  f02000ff          BIC      r0,r0,#0xff           ;1262
0000fa  f0400001          ORR      r0,r0,#1              ;1262
0000fe  61a8              STR      r0,[r5,#0x18]         ;1262
000100  4628              MOV      r0,r5                 ;1264
000102  f7fffffe          BL       _RMP_Set_Rdy
                  |L31.262|
000106  62ef              STR      r7,[r5,#0x2c]         ;1270
000108  69a8              LDR      r0,[r5,#0x18]         ;1271
00010a  f4407000          ORR      r0,r0,#0x200          ;1271
00010e  61a8              STR      r0,[r5,#0x18]         ;1271
                  |L31.272|
000110  f7fffffe          BL       RMP_Unlock_Sched
000114  69a0              LDR      r0,[r4,#0x18]         ;1276  ; RMP_Cur_Thd
000116  6b80              LDR      r0,[r0,#0x38]         ;1276
000118  e8bd81f0          POP      {r4-r8,pc}
;;;1278   /* End Function:RMP_Thd_Snd **************************************************/
                          ENDP

                  |L31.284|
                          DCD      ||.data||
                  |L31.288|
                          DCD      0x000186a0

                          AREA ||i.RMP_Thd_Snd_ISR||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Snd_ISR PROC
;;;1290   ******************************************************************************/
;;;1291   rmp_ret_t RMP_Thd_Snd_ISR(volatile struct RMP_Thd* Thread, rmp_ptr_t Data)
000000  2800              CMP      r0,#0
;;;1292   {
;;;1293       /* Check if this thread structure could possibly be in use */
;;;1294       if(Thread==0)
;;;1295       {
;;;1296           RMP_COVERAGE_MARKER();
;;;1297           return RMP_ERR_THD;
000002  bf04              ITT      EQ
000004  f04f30ff          MOVEQ    r0,#0xffffffff
;;;1298       }
;;;1299       else
;;;1300           RMP_COVERAGE_MARKER();
;;;1301       
;;;1302       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;1303       {
;;;1304           RMP_COVERAGE_MARKER();
;;;1305           return RMP_ERR_THD;
;;;1306       }
;;;1307       else
;;;1308           RMP_COVERAGE_MARKER();
;;;1309   
;;;1310       /* See if there is already a value in the mailbox, if yes, we abort */
;;;1311       if((Thread->State&RMP_THD_MBOXFUL)!=0)
;;;1312       {
;;;1313           RMP_COVERAGE_MARKER();
;;;1314           return RMP_ERR_OPER;
;;;1315       }
;;;1316       else
;;;1317       {
;;;1318           RMP_COVERAGE_MARKER();
;;;1319           
;;;1320           /* Mailbox not full. We need to check if the receiver is waiting for us */
;;;1321           if((RMP_THD_STATE(Thread->State)==RMP_THD_RCVBLK)||
;;;1322              (RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY))
;;;1323           {
;;;1324               RMP_COVERAGE_MARKER();
;;;1325   
;;;1326               /* The receiver is blocked, wake it up and return the value */
;;;1327               if(RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY)
;;;1328               {
;;;1329                   RMP_COVERAGE_MARKER();
;;;1330                   RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1331               }
;;;1332               else
;;;1333                   RMP_COVERAGE_MARKER();
;;;1334               
;;;1335               RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1336   
;;;1337               /* Set to running if not suspended */
;;;1338               _RMP_Set_Rdy(Thread);
;;;1339   
;;;1340               /* If schedule pending, trigger it now because we are in ISR */
;;;1341               if(RMP_Sched_Pend!=0)
;;;1342               {
;;;1343                   RMP_COVERAGE_MARKER();
;;;1344                   RMP_Sched_Pend=0;
;;;1345                   _RMP_Yield();
;;;1346               }
;;;1347               else
;;;1348                   RMP_COVERAGE_MARKER();
;;;1349           }
;;;1350           else
;;;1351               RMP_COVERAGE_MARKER();
;;;1352           
;;;1353           /* Set the mailbox */
;;;1354           Thread->Mailbox=Data;
;;;1355           Thread->State|=RMP_THD_MBOXFUL;
;;;1356       }
;;;1357   
;;;1358       return 0;
;;;1359   }
000008  4770              BXEQ     lr
00000a  b570              PUSH     {r4-r6,lr}            ;1292
00000c  4604              MOV      r4,r0                 ;1292
00000e  6980              LDR      r0,[r0,#0x18]         ;1302
000010  460d              MOV      r5,r1                 ;1292
000012  f0100fff          TST      r0,#0xff              ;1302
000016  bf04              ITT      EQ                    ;1305
000018  f04f30ff          MOVEQ    r0,#0xffffffff        ;1305
00001c  bd70              POPEQ    {r4-r6,pc}
00001e  69a0              LDR      r0,[r4,#0x18]         ;1311
000020  f4107f00          TST      r0,#0x200             ;1311
000024  bf1c              ITT      NE                    ;1314
000026  f06f0004          MVNNE    r0,#4                 ;1314
00002a  bd70              POPNE    {r4-r6,pc}
00002c  69a0              LDR      r0,[r4,#0x18]         ;1321
00002e  b2c0              UXTB     r0,r0                 ;1321
000030  2804              CMP      r0,#4                 ;1321
000032  d003              BEQ      |L32.60|
000034  69a0              LDR      r0,[r4,#0x18]         ;1321
000036  b2c0              UXTB     r0,r0                 ;1321
000038  2805              CMP      r0,#5                 ;1321
00003a  d117              BNE      |L32.108|
                  |L32.60|
00003c  69a0              LDR      r0,[r4,#0x18]         ;1327
00003e  b2c0              UXTB     r0,r0                 ;1327
000040  2805              CMP      r0,#5                 ;1327
000042  d103              BNE      |L32.76|
000044  68a0              LDR      r0,[r4,#8]            ;1330
000046  68e2              LDR      r2,[r4,#0xc]          ;1330
000048  6010              STR      r0,[r2,#0]            ;1330
00004a  6042              STR      r2,[r0,#4]            ;1330
                  |L32.76|
00004c  69a0              LDR      r0,[r4,#0x18]         ;1335
00004e  f02000ff          BIC      r0,r0,#0xff           ;1335
000052  f0400001          ORR      r0,r0,#1              ;1335
000056  61a0              STR      r0,[r4,#0x18]         ;1335
000058  4620              MOV      r0,r4                 ;1338
00005a  f7fffffe          BL       _RMP_Set_Rdy
00005e  4807              LDR      r0,|L32.124|
000060  68c1              LDR      r1,[r0,#0xc]          ;1341  ; RMP_Sched_Pend
000062  b119              CBZ      r1,|L32.108|
000064  2100              MOVS     r1,#0                 ;1344
000066  60c1              STR      r1,[r0,#0xc]          ;1344  ; RMP_Sched_Pend
000068  f7fffffe          BL       _RMP_Yield
                  |L32.108|
00006c  62e5              STR      r5,[r4,#0x2c]         ;1354
00006e  69a0              LDR      r0,[r4,#0x18]         ;1355
000070  f4407000          ORR      r0,r0,#0x200          ;1355
000074  61a0              STR      r0,[r4,#0x18]         ;1355
000076  2000              MOVS     r0,#0                 ;1358
000078  bd70              POP      {r4-r6,pc}
;;;1360   /* End Function:RMP_Thd_Snd_ISR **********************************************/
                          ENDP

00007a  0000              DCW      0x0000
                  |L32.124|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Suspend||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Suspend PROC
;;;1046   ******************************************************************************/
;;;1047   rmp_ret_t RMP_Thd_Suspend(volatile struct RMP_Thd* Thread)
000000  2800              CMP      r0,#0
;;;1048   {
;;;1049       /* Check if this thread structure could possibly be in use */
;;;1050       if(Thread==0)
;;;1051       {
;;;1052           RMP_COVERAGE_MARKER();
;;;1053           return RMP_ERR_THD;
000002  bf04              ITT      EQ
000004  f04f30ff          MOVEQ    r0,#0xffffffff
;;;1054       }
;;;1055       else
;;;1056           RMP_COVERAGE_MARKER();
;;;1057       
;;;1058       RMP_Lock_Sched();
;;;1059       
;;;1060       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;1061       {
;;;1062           RMP_COVERAGE_MARKER();
;;;1063           RMP_Unlock_Sched();
;;;1064           return RMP_ERR_THD;
;;;1065       }
;;;1066       else
;;;1067           RMP_COVERAGE_MARKER();
;;;1068       
;;;1069       /* Suspend it */
;;;1070       if((Thread->State&RMP_THD_SUSPENDED)!=0)
;;;1071       {
;;;1072           RMP_COVERAGE_MARKER();
;;;1073           RMP_Unlock_Sched();
;;;1074           return RMP_ERR_STATE;
;;;1075       }
;;;1076       else
;;;1077           RMP_COVERAGE_MARKER();
;;;1078       
;;;1079       /* Only when it is running do we clear this. If we are clearing this, it is not
;;;1080        * suspended, so trhe running queue removal is guaranteed to succceed */
;;;1081       if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
;;;1082       {
;;;1083           RMP_COVERAGE_MARKER();
;;;1084           _RMP_Clr_Rdy(Thread);
;;;1085       }
;;;1086       else
;;;1087           RMP_COVERAGE_MARKER();
;;;1088       
;;;1089       /* Mark this as suspended */
;;;1090       Thread->State|=RMP_THD_SUSPENDED;
;;;1091       
;;;1092       /* If we are suspending ourself, pend a yield */
;;;1093       if(Thread==RMP_Cur_Thd)
;;;1094       {
;;;1095           RMP_COVERAGE_MARKER();
;;;1096           RMP_Sched_Pend=1;
;;;1097       }
;;;1098       else
;;;1099           RMP_COVERAGE_MARKER();
;;;1100       
;;;1101       RMP_Unlock_Sched();
;;;1102       return 0;
;;;1103   }
000008  4770              BXEQ     lr
00000a  b570              PUSH     {r4-r6,lr}            ;1048
00000c  4604              MOV      r4,r0                 ;1048
00000e  20ff              MOVS     r0,#0xff              ;1048
000010  f7fffffe          BL       RMP_Mask_Int
000014  4d14              LDR      r5,|L33.104|
000016  2601              MOVS     r6,#1                 ;1048
000018  60ae              STR      r6,[r5,#8]            ;1048  ; RMP_Sched_Locked
00001a  6868              LDR      r0,[r5,#4]            ;1048  ; RMP_Sched_Lock_Cnt
00001c  1c40              ADDS     r0,r0,#1              ;1048
00001e  6068              STR      r0,[r5,#4]            ;1048  ; RMP_Sched_Lock_Cnt
000020  69a0              LDR      r0,[r4,#0x18]         ;1060
000022  f0100fff          TST      r0,#0xff              ;1060
000026  d007              BEQ      |L33.56|
000028  69a0              LDR      r0,[r4,#0x18]         ;1070
00002a  f4107f80          TST      r0,#0x100             ;1070
00002e  d008              BEQ      |L33.66|
000030  f7fffffe          BL       RMP_Unlock_Sched
000034  1f70              SUBS     r0,r6,#5              ;1074
000036  bd70              POP      {r4-r6,pc}
                  |L33.56|
000038  f7fffffe          BL       RMP_Unlock_Sched
00003c  f04f30ff          MOV      r0,#0xffffffff        ;1064
000040  bd70              POP      {r4-r6,pc}
                  |L33.66|
000042  69a0              LDR      r0,[r4,#0x18]         ;1081
000044  b2c0              UXTB     r0,r0                 ;1081
000046  2801              CMP      r0,#1                 ;1081
000048  bf04              ITT      EQ                    ;1084
00004a  4620              MOVEQ    r0,r4                 ;1084
00004c  f7fffffe          BLEQ     _RMP_Clr_Rdy
000050  69a0              LDR      r0,[r4,#0x18]         ;1090
000052  f4407080          ORR      r0,r0,#0x100          ;1090
000056  61a0              STR      r0,[r4,#0x18]         ;1090
000058  69a8              LDR      r0,[r5,#0x18]         ;1093  ; RMP_Cur_Thd
00005a  4284              CMP      r4,r0                 ;1093
00005c  bf08              IT       EQ                    ;1096
00005e  60ee              STREQ    r6,[r5,#0xc]          ;1096  ; RMP_Sched_Pend
000060  f7fffffe          BL       RMP_Unlock_Sched
000064  2000              MOVS     r0,#0                 ;1102
000066  bd70              POP      {r4-r6,pc}
;;;1104   /* End Function:RMP_Thd_Suspend **********************************************/
                          ENDP

                  |L33.104|
                          DCD      ||.data||

                          AREA ||i.RMP_Unlock_Sched||, CODE, READONLY, ALIGN=2

                  RMP_Unlock_Sched PROC
;;;375    ******************************************************************************/
;;;376    void RMP_Unlock_Sched(void)
000000  480d              LDR      r0,|L34.56|
;;;377    {
000002  b510              PUSH     {r4,lr}
;;;378        if(RMP_Sched_Lock_Cnt==1)
000004  6841              LDR      r1,[r0,#4]  ; RMP_Sched_Lock_Cnt
000006  2901              CMP      r1,#1
000008  d006              BEQ      |L34.24|
;;;379        {
;;;380            RMP_COVERAGE_MARKER();
;;;381            /* Clear the count before enabling */
;;;382            RMP_Sched_Lock_Cnt=0;
;;;383            RMP_Sched_Locked=0;
;;;384            /* Now see if the scheduler scheduling action is pended in the lock-unlock 
;;;385             * period. If yes, perform a schedule now */
;;;386            if(RMP_Sched_Pend!=0)
;;;387            {
;;;388                RMP_COVERAGE_MARKER();
;;;389                /* Reset the count and trigger the context switch */
;;;390                RMP_Sched_Pend=0;
;;;391                _RMP_Yield();
;;;392            }
;;;393            else
;;;394                RMP_COVERAGE_MARKER();
;;;395            
;;;396            RMP_UNMASK_INT();
;;;397        }
;;;398        else if(RMP_Sched_Lock_Cnt>1)
00000a  6841              LDR      r1,[r0,#4]  ; RMP_Sched_Lock_Cnt
00000c  2901              CMP      r1,#1
00000e  d911              BLS      |L34.52|
;;;399        {
;;;400            RMP_COVERAGE_MARKER();
;;;401            RMP_Sched_Lock_Cnt--;
000010  6841              LDR      r1,[r0,#4]  ; RMP_Sched_Lock_Cnt
000012  1e49              SUBS     r1,r1,#1
000014  6041              STR      r1,[r0,#4]  ; RMP_Sched_Lock_Cnt
;;;402        }
;;;403        /* Trying to unlock a scheduler that is not locked - should never happen */
;;;404        else
;;;405            while(1);
;;;406    }
000016  bd10              POP      {r4,pc}
                  |L34.24|
000018  2100              MOVS     r1,#0                 ;382
00001a  6041              STR      r1,[r0,#4]            ;382  ; RMP_Sched_Lock_Cnt
00001c  6081              STR      r1,[r0,#8]            ;383  ; RMP_Sched_Locked
00001e  68c2              LDR      r2,[r0,#0xc]          ;386  ; RMP_Sched_Pend
000020  2a00              CMP      r2,#0                 ;386
000022  bf1c              ITT      NE                    ;390
000024  60c1              STRNE    r1,[r0,#0xc]          ;390  ; RMP_Sched_Pend
000026  f7fffffe          BLNE     _RMP_Yield
00002a  2000              MOVS     r0,#0                 ;396
00002c  e8bd4010          POP      {r4,lr}               ;396
000030  f7ffbffe          B.W      RMP_Mask_Int
                  |L34.52|
000034  e7fe              B        |L34.52|
;;;407    /* End Function:RMP_Unlock_Sched *********************************************/
                          ENDP

000036  0000              DCW      0x0000
                  |L34.56|
                          DCD      ||.data||

                          AREA ||i.RMP_Yield||, CODE, READONLY, ALIGN=2

                  RMP_Yield PROC
;;;414    ******************************************************************************/
;;;415    void RMP_Yield(void)
000000  4804              LDR      r0,|L35.20|
;;;416    {
;;;417        if(RMP_Sched_Locked==0)
000002  6881              LDR      r1,[r0,#8]  ; RMP_Sched_Locked
000004  2900              CMP      r1,#0
;;;418        {
;;;419            RMP_COVERAGE_MARKER();
;;;420            /* Now see if the scheduler scheduling action is pended in the lock-unlock 
;;;421             * period. If yes, perform a schedule now */
;;;422            _RMP_Yield();
;;;423        }
;;;424        else
;;;425        {
;;;426            RMP_COVERAGE_MARKER();
;;;427            RMP_Sched_Pend=1;
000006  bf1e              ITTT     NE
000008  2101              MOVNE    r1,#1
00000a  60c1              STRNE    r1,[r0,#0xc]  ; RMP_Sched_Pend
;;;428        }
;;;429    }
00000c  4770              BXNE     lr
00000e  f7ffbffe          B.W      _RMP_Yield
;;;430    /* End Function:RMP_Yield ****************************************************/
                          ENDP

000012  0000              DCW      0x0000
                  |L35.20|
                          DCD      ||.data||

                          AREA ||i._RMP_Clr_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Clr_Rdy PROC
;;;686    ******************************************************************************/
;;;687    void _RMP_Clr_Rdy(volatile struct RMP_Thd* Thread)
000000  6981              LDR      r1,[r0,#0x18]
;;;688    {
;;;689        /* Is it suspended? If yes, no need to delete again */
;;;690        if((Thread->State&RMP_THD_SUSPENDED)==0)
000002  f4117f80          TST      r1,#0x100
;;;691        {
;;;692            RMP_COVERAGE_MARKER();
;;;693            /* See if it is the last thread on the priority level */
;;;694            if(Thread->Run_Head.Prev==Thread->Run_Head.Next)
;;;695            {
;;;696                RMP_COVERAGE_MARKER();
;;;697                RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]&=~(((rmp_ptr_t)1)<<(Thread->Prio&RMP_WORD_MASK));
;;;698            }
;;;699            else
;;;700                RMP_COVERAGE_MARKER();
;;;701            
;;;702            /* Delete this from the corresponding runqueue */
;;;703            RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;704            
;;;705            /* If it is the current thread, request a context switch */
;;;706            if(Thread==RMP_Cur_Thd)
;;;707            {
;;;708                RMP_COVERAGE_MARKER();
;;;709                RMP_Sched_Pend=1;
;;;710            }
;;;711            else
;;;712                RMP_COVERAGE_MARKER();
;;;713        }
;;;714        else
;;;715            RMP_COVERAGE_MARKER();
;;;716    }
000006  bf18              IT       NE
000008  4770              BXNE     lr
00000a  6801              LDR      r1,[r0,#0]            ;694
00000c  6842              LDR      r2,[r0,#4]            ;694
00000e  2301              MOVS     r3,#1                 ;697
000010  4291              CMP      r1,r2                 ;694
000012  d10e              BNE      |L36.50|
000014  6a41              LDR      r1,[r0,#0x24]         ;697
000016  4a0c              LDR      r2,|L36.72|
000018  0949              LSRS     r1,r1,#5              ;697
00001a  eb020181          ADD      r1,r2,r1,LSL #2       ;697
00001e  680a              LDR      r2,[r1,#0]            ;697
000020  f8d0c024          LDR      r12,[r0,#0x24]        ;697
000024  f00c0c1f          AND      r12,r12,#0x1f         ;697
000028  fa03fc0c          LSL      r12,r3,r12            ;697
00002c  ea22020c          BIC      r2,r2,r12             ;697
000030  600a              STR      r2,[r1,#0]            ;697
                  |L36.50|
000032  6801              LDR      r1,[r0,#0]            ;703
000034  6842              LDR      r2,[r0,#4]            ;703
000036  6011              STR      r1,[r2,#0]            ;703
000038  604a              STR      r2,[r1,#4]            ;703
00003a  4903              LDR      r1,|L36.72|
00003c  698a              LDR      r2,[r1,#0x18]         ;706  ; RMP_Cur_Thd
00003e  4290              CMP      r0,r2                 ;706
000040  bf08              IT       EQ                    ;709
000042  60cb              STREQ    r3,[r1,#0xc]          ;709  ; RMP_Sched_Pend
000044  4770              BX       lr
;;;717    /* End Function:_RMP_Clr_Rdy *************************************************/
                          ENDP

000046  0000              DCW      0x0000
                  |L36.72|
                          DCD      ||.data||

                          AREA ||i._RMP_Get_High_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Get_High_Rdy PROC
;;;494    ******************************************************************************/
;;;495    void _RMP_Get_High_Rdy(void)
000000  b510              PUSH     {r4,lr}
;;;496    {
;;;497        rmp_cnt_t Count;
;;;498        
;;;499        /* Write the SP value to thread structure */
;;;500        RMP_Cur_Thd->Stack=RMP_Cur_SP;
000002  4c19              LDR      r4,|L37.104|
000004  69e0              LDR      r0,[r4,#0x1c]  ; RMP_Cur_SP
000006  69a1              LDR      r1,[r4,#0x18]  ; RMP_Cur_Thd
;;;501        
;;;502        /* No need to detect scheduler locks - if this interrupt can be entered, the scheduler is not locked */
;;;503        RMP_Sched_Pend=0;
000008  6348              STR      r0,[r1,#0x34]
00000a  2000              MOVS     r0,#0
00000c  60e0              STR      r0,[r4,#0xc]  ; RMP_Sched_Pend
;;;504        /* See which one is ready, and pick it */
;;;505        for(Count=RMP_BITMAP_SIZE-1;Count>=0;Count--)
;;;506        {
;;;507            if(RMP_Bitmap[Count]==0)
00000e  4620              MOV      r0,r4
000010  6801              LDR      r1,[r0,#0]
000012  b321              CBZ      r1,|L37.94|
;;;508            {
;;;509                RMP_COVERAGE_MARKER();
;;;510                continue;
;;;511            }
;;;512            else
;;;513                RMP_COVERAGE_MARKER();
;;;514            
;;;515            Count=RMP_MSB_Get(RMP_Bitmap[Count])+(Count<<RMP_WORD_ORDER);
000014  6800              LDR      r0,[r0,#0]
000016  f7fffffe          BL       RMP_MSB_Get
;;;516            
;;;517            /* See if the current thread and the next thread are the same. If yes, place the current at the end of the queue */
;;;518            if(RMP_Cur_Thd==(struct RMP_Thd*)(RMP_Run[Count].Next))
00001a  4914              LDR      r1,|L37.108|
00001c  eb0103c0          ADD      r3,r1,r0,LSL #3
000020  6858              LDR      r0,[r3,#4]
000022  69a2              LDR      r2,[r4,#0x18]  ; RMP_Cur_Thd
000024  4290              CMP      r0,r2
000026  d114              BNE      |L37.82|
;;;519            {
;;;520                RMP_COVERAGE_MARKER();
;;;521                RMP_List_Del(RMP_Cur_Thd->Run_Head.Prev, RMP_Cur_Thd->Run_Head.Next);
000028  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
00002a  69a2              LDR      r2,[r4,#0x18]  ; RMP_Cur_Thd
00002c  6800              LDR      r0,[r0,#0]
00002e  6852              LDR      r2,[r2,#4]
000030  6010              STR      r0,[r2,#0]
000032  6042              STR      r2,[r0,#4]
;;;522                RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),
000034  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
000036  69a2              LDR      r2,[r4,#0x18]  ; RMP_Cur_Thd
000038  6a52              LDR      r2,[r2,#0x24]
00003a  f8512032          LDR      r2,[r1,r2,LSL #3]
00003e  f8d4c018          LDR      r12,[r4,#0x18]  ; RMP_Cur_Thd
000042  f8dcc024          LDR      r12,[r12,#0x24]
000046  eb0101cc          ADD      r1,r1,r12,LSL #3
00004a  6008              STR      r0,[r1,#0]
00004c  6041              STR      r1,[r0,#4]
00004e  6002              STR      r2,[r0,#0]
000050  6050              STR      r0,[r2,#4]
                  |L37.82|
;;;523                             RMP_Run[RMP_Cur_Thd->Prio].Prev,
;;;524                             &(RMP_Run[RMP_Cur_Thd->Prio]));
;;;525            }
;;;526            else
;;;527                RMP_COVERAGE_MARKER();
;;;528            
;;;529            /* Replenish timeslices */
;;;530            RMP_Cur_Thd->Slices_Left=RMP_Cur_Thd->Slices;
000052  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
000054  69a1              LDR      r1,[r4,#0x18]  ; RMP_Cur_Thd
000056  69c0              LDR      r0,[r0,#0x1c]
;;;531            RMP_Cur_Thd=(struct RMP_Thd*)(RMP_Run[Count].Next);
000058  6208              STR      r0,[r1,#0x20]
00005a  6858              LDR      r0,[r3,#4]
00005c  61a0              STR      r0,[r4,#0x18]  ; RMP_Cur_Thd
                  |L37.94|
;;;532            break;
;;;533        }
;;;534        
;;;535        /* Load the SP value from thread structure */
;;;536        RMP_Cur_SP=RMP_Cur_Thd->Stack;
00005e  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
000060  6b40              LDR      r0,[r0,#0x34]
000062  61e0              STR      r0,[r4,#0x1c]  ; RMP_Cur_SP
;;;537        
;;;538    #if(RMP_USE_HOOKS==RMP_TRUE)
;;;539        RMP_Sched_Hook();
;;;540    #endif
;;;541    }
000064  bd10              POP      {r4,pc}
;;;542    /* End Function:_RMP_Get_High_Rdy ********************************************/
                          ENDP

000066  0000              DCW      0x0000
                  |L37.104|
                          DCD      ||.data||
                  |L37.108|
                          DCD      ||.bss||

                          AREA ||i._RMP_Get_Near_Ticks||, CODE, READONLY, ALIGN=2

                  _RMP_Get_Near_Ticks PROC
;;;612    ******************************************************************************/
;;;613    rmp_ptr_t _RMP_Get_Near_Ticks(void)
000000  4a08              LDR      r2,|L38.36|
;;;614    {
;;;615        rmp_ptr_t Value;
;;;616        struct RMP_Thd* Thread;
;;;617        
;;;618        /* What is the current thread's timeout value? */
;;;619        Value=RMP_Cur_Thd->Slices_Left;
000002  6990              LDR      r0,[r2,#0x18]  ; RMP_Cur_Thd
;;;620        
;;;621        /* What is the nearest timer timeout value? */
;;;622        if((&RMP_Delay)!=RMP_Delay.Next)
000004  f1020120          ADD      r1,r2,#0x20
000008  6a00              LDR      r0,[r0,#0x20]         ;619
00000a  684b              LDR      r3,[r1,#4]  ; RMP_Delay
00000c  428b              CMP      r3,r1
;;;623        {
;;;624            RMP_COVERAGE_MARKER();
;;;625            Thread=RMP_DLY2THD(RMP_Delay.Next);
;;;626            /* See if it is nearer - don't worry about the situation that the timer
;;;627             * have overflown, because if that is to happen, it would have been 
;;;628             * already processed by the timeout processing routine just before. */
;;;629            if((Thread->Timeout-RMP_Tick)<Value)
;;;630            {
;;;631                RMP_COVERAGE_MARKER();
;;;632                Value=Thread->Timeout-RMP_Tick;
;;;633            }
;;;634            else
;;;635                RMP_COVERAGE_MARKER();
;;;636        }
;;;637        else
;;;638            RMP_COVERAGE_MARKER();
;;;639        
;;;640        return Value;
;;;641    }
00000e  bf08              IT       EQ
000010  4770              BXEQ     lr
000012  6849              LDR      r1,[r1,#4]            ;625  ; RMP_Delay
000014  6953              LDR      r3,[r2,#0x14]         ;629  ; RMP_Tick
000016  6a09              LDR      r1,[r1,#0x20]         ;629
000018  1acb              SUBS     r3,r1,r3              ;629
00001a  4283              CMP      r3,r0                 ;629
00001c  bf3c              ITT      CC                    ;632
00001e  6950              LDRCC    r0,[r2,#0x14]         ;632  ; RMP_Tick
000020  1a08              SUBCC    r0,r1,r0              ;632
000022  4770              BX       lr
;;;642    /* End Function:_RMP_Get_Near_Ticks ******************************************/
                          ENDP

                  |L38.36|
                          DCD      ||.data||

                          AREA ||i._RMP_Set_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Set_Rdy PROC
;;;653    ******************************************************************************/
;;;654    void _RMP_Set_Rdy(volatile struct RMP_Thd* Thread)
000000  6981              LDR      r1,[r0,#0x18]
;;;655    {        
;;;656        /* Is it suspended? If yes, we can't directly set it running */
;;;657        if((Thread->State&RMP_THD_SUSPENDED)==0)
000002  f4117f80          TST      r1,#0x100
;;;658        {
;;;659            RMP_COVERAGE_MARKER();
;;;660            /* Insert this into the corresponding runqueue */
;;;661            RMP_List_Ins(&(Thread->Run_Head),RMP_Run[Thread->Prio].Prev,&(RMP_Run[Thread->Prio]));
;;;662            /* Set this runlevel as active */
;;;663            RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]|=((rmp_ptr_t)1)<<(Thread->Prio&RMP_WORD_MASK);
;;;664            
;;;665            /* Compare this with the current one to see if we need a context switch */
;;;666            if(Thread->Prio>RMP_Cur_Thd->Prio)
;;;667            {
;;;668                RMP_COVERAGE_MARKER();
;;;669                RMP_Sched_Pend=1;
;;;670            }
;;;671            else
;;;672                RMP_COVERAGE_MARKER();
;;;673        }
;;;674        else
;;;675            RMP_COVERAGE_MARKER();
;;;676    }
000006  bf18              IT       NE
000008  4770              BXNE     lr
00000a  6a41              LDR      r1,[r0,#0x24]         ;661
00000c  4a10              LDR      r2,|L39.80|
00000e  f8521031          LDR      r1,[r2,r1,LSL #3]     ;661
000012  6a43              LDR      r3,[r0,#0x24]         ;661
000014  eb0202c3          ADD      r2,r2,r3,LSL #3       ;661
000018  6010              STR      r0,[r2,#0]            ;661
00001a  6042              STR      r2,[r0,#4]            ;661
00001c  6001              STR      r1,[r0,#0]            ;661
00001e  6048              STR      r0,[r1,#4]            ;661
000020  6a41              LDR      r1,[r0,#0x24]         ;663
000022  4a0c              LDR      r2,|L39.84|
000024  0949              LSRS     r1,r1,#5              ;663
000026  eb020181          ADD      r1,r2,r1,LSL #2       ;663
00002a  680b              LDR      r3,[r1,#0]            ;663
00002c  6a42              LDR      r2,[r0,#0x24]         ;663
00002e  f0020c1f          AND      r12,r2,#0x1f          ;663
000032  2201              MOVS     r2,#1                 ;663
000034  fa02fc0c          LSL      r12,r2,r12            ;663
000038  ea43030c          ORR      r3,r3,r12             ;663
00003c  600b              STR      r3,[r1,#0]            ;663
00003e  6a41              LDR      r1,[r0,#0x24]         ;666
000040  4804              LDR      r0,|L39.84|
000042  6983              LDR      r3,[r0,#0x18]         ;666  ; RMP_Cur_Thd
000044  6a5b              LDR      r3,[r3,#0x24]         ;666
000046  4299              CMP      r1,r3                 ;666
000048  bf88              IT       HI                    ;669
00004a  60c2              STRHI    r2,[r0,#0xc]          ;669  ; RMP_Sched_Pend
00004c  4770              BX       lr
;;;677    /* End Function:_RMP_Set_Rdy *************************************************/
                          ENDP

00004e  0000              DCW      0x0000
                  |L39.80|
                          DCD      ||.bss||
                  |L39.84|
                          DCD      ||.data||

                          AREA ||i._RMP_Tick_Handler||, CODE, READONLY, ALIGN=2

                  _RMP_Tick_Handler PROC
;;;549    ******************************************************************************/
;;;550    void _RMP_Tick_Handler(rmp_ptr_t Ticks)
000000  b570              PUSH     {r4-r6,lr}
;;;551    {
;;;552        struct RMP_Thd* Thread;
;;;553        /* Increase the timestamp as always */
;;;554        RMP_Tick+=Ticks;
000002  4d28              LDR      r5,|L40.164|
000004  6969              LDR      r1,[r5,#0x14]  ; RMP_Tick
000006  4401              ADD      r1,r1,r0
000008  6169              STR      r1,[r5,#0x14]  ; RMP_Tick
;;;555        
;;;556        /* See if the current thread expired. If yes, trigger a scheduler event */
;;;557        if(Ticks>RMP_Cur_Thd->Slices_Left)
00000a  69a9              LDR      r1,[r5,#0x18]  ; RMP_Cur_Thd
00000c  6a09              LDR      r1,[r1,#0x20]
00000e  4281              CMP      r1,r0
;;;558        {
;;;559            RMP_COVERAGE_MARKER();
;;;560            RMP_Sched_Pend=1;
000010  bf3c              ITT      CC
000012  2001              MOVCC    r0,#1
000014  60e8              STRCC    r0,[r5,#0xc]  ; RMP_Sched_Pend
000016  d303              BCC      |L40.32|
;;;561        }
;;;562        else
;;;563        {
;;;564            RMP_COVERAGE_MARKER();
;;;565            RMP_Cur_Thd->Slices_Left-=Ticks;
000018  69a9              LDR      r1,[r5,#0x18]  ; RMP_Cur_Thd
00001a  6a0a              LDR      r2,[r1,#0x20]
00001c  1a10              SUBS     r0,r2,r0
00001e  6208              STR      r0,[r1,#0x20]
                  |L40.32|
;;;566        }
;;;567        
;;;568        /* Check if there are any timer events */
;;;569        if((&RMP_Delay)!=RMP_Delay.Next)
000020  4c21              LDR      r4,|L40.168|
000022  6860              LDR      r0,[r4,#4]  ; RMP_Delay
000024  42a0              CMP      r0,r4
000026  d033              BEQ      |L40.144|
;;;570        {
;;;571            RMP_COVERAGE_MARKER();
;;;572            Thread=RMP_DLY2THD(RMP_Delay.Next);
000028  6860              LDR      r0,[r4,#4]  ; RMP_Delay
;;;573            /* If the value is less than this, then it means that the time have
;;;574             * already passed and we have to process this */
;;;575            if((RMP_Tick-Thread->Timeout)<=(RMP_ALLBITS>>1))
00002a  6969              LDR      r1,[r5,#0x14]  ; RMP_Tick
00002c  6a00              LDR      r0,[r0,#0x20]
00002e  1a08              SUBS     r0,r1,r0
000030  f1b04f00          CMP      r0,#0x80000000
000034  d22c              BCS      |L40.144|
000036  6860              LDR      r0,[r4,#4]  ; RMP_Delay
000038  42a0              CMP      r0,r4
00003a  bf18              IT       NE
00003c  f06f0604          MVNNE    r6,#4
000040  d026              BEQ      |L40.144|
                  |L40.66|
000042  6860              LDR      r0,[r4,#4]  ; RMP_Delay
000044  6969              LDR      r1,[r5,#0x14]  ; RMP_Tick
000046  6a02              LDR      r2,[r0,#0x20]
000048  3808              SUBS     r0,r0,#8
00004a  1a89              SUBS     r1,r1,r2
00004c  f1b14f00          CMP      r1,#0x80000000
000050  d21e              BCS      |L40.144|
000052  e9d01202          LDRD     r1,r2,[r0,#8]
000056  6011              STR      r1,[r2,#0]
000058  604a              STR      r2,[r1,#4]
00005a  7e01              LDRB     r1,[r0,#0x18]
00005c  2903              CMP      r1,#3
00005e  d007              BEQ      |L40.112|
000060  2905              CMP      r1,#5
000062  bf0c              ITE      EQ
000064  6386              STREQ    r6,[r0,#0x38]
000066  2906              CMPNE    r1,#6
000068  d007              BEQ      |L40.122|
00006a  2908              CMP      r1,#8
00006c  d000              BEQ      |L40.112|
                  |L40.110|
00006e  e7fe              B        |L40.110|
                  |L40.112|
000070  e9d01200          LDRD     r1,r2,[r0,#0]
000074  6011              STR      r1,[r2,#0]
000076  604a              STR      r2,[r1,#4]
000078  6386              STR      r6,[r0,#0x38]
                  |L40.122|
00007a  6981              LDR      r1,[r0,#0x18]
00007c  f02101ff          BIC      r1,r1,#0xff
000080  f0410101          ORR      r1,r1,#1
000084  6181              STR      r1,[r0,#0x18]
000086  f7fffffe          BL       _RMP_Set_Rdy
00008a  6860              LDR      r0,[r4,#4]  ; RMP_Delay
00008c  42a0              CMP      r0,r4
00008e  d1d8              BNE      |L40.66|
                  |L40.144|
;;;576            {
;;;577                RMP_COVERAGE_MARKER();
;;;578                /* No need to care about scheduler locks if this interrupt can be entered
;;;579                 * - we have disabled timer and scheduler interrupts in scheduler lock */
;;;580                _RMP_Timer_Proc();
;;;581            }
;;;582            else
;;;583                RMP_COVERAGE_MARKER();
;;;584        }
;;;585        else
;;;586            RMP_COVERAGE_MARKER();
;;;587        
;;;588        if(RMP_Sched_Pend!=0)
000090  68e8              LDR      r0,[r5,#0xc]  ; RMP_Sched_Pend
000092  2800              CMP      r0,#0
;;;589        {
;;;590            RMP_COVERAGE_MARKER();
;;;591            RMP_Sched_Pend=0;
;;;592            _RMP_Yield();
;;;593        }
;;;594        else
;;;595            RMP_COVERAGE_MARKER();
;;;596        
;;;597    #if(RMP_USE_HOOKS==RMP_TRUE)
;;;598        RMP_Tick_Hook(Ticks);
;;;599    #endif
;;;600    }
000094  bf08              IT       EQ
000096  bd70              POPEQ    {r4-r6,pc}
000098  2000              MOVS     r0,#0                 ;591
00009a  60e8              STR      r0,[r5,#0xc]          ;591  ; RMP_Sched_Pend
00009c  e8bd4070          POP      {r4-r6,lr}            ;592
0000a0  f7ffbffe          B.W      _RMP_Yield
;;;601    /* End Function:_RMP_Tick_Handler ********************************************/
                          ENDP

                  |L40.164|
                          DCD      ||.data||
                  |L40.168|
                          DCD      ||.data||+0x20

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;1994   ******************************************************************************/
;;;1995   int main(void)
000000  b510              PUSH     {r4,lr}
;;;1996   {
;;;1997       rmp_ptr_t Count;
;;;1998       
;;;1999   #ifdef RMP_COVERAGE
;;;2000       /* Initialize coverage markers if coverage enabled */
;;;2001       for(Count=0;Count<RMP_COVERAGE_LINES;Count++)
;;;2002           RMP_Coverage[Count]=0;
;;;2003   #endif
;;;2004       
;;;2005       /* Initialize the kernel data structures first */
;;;2006       _RMP_Low_Level_Init();
000002  f7fffffe          BL       _RMP_Low_Level_Init
;;;2007       
;;;2008   #if(RMP_USE_HOOKS==RMP_TRUE)
;;;2009       RMP_Start_Hook();
;;;2010   #endif
;;;2011       
;;;2012       RMP_Tick=0;
000006  4b22              LDR      r3,|L41.144|
000008  2000              MOVS     r0,#0
00000a  6158              STR      r0,[r3,#0x14]  ; RMP_Tick
;;;2013       /* Now initialize the kernel data structures */
;;;2014       RMP_Sched_Lock_Cnt=0;
00000c  6058              STR      r0,[r3,#4]  ; RMP_Sched_Lock_Cnt
;;;2015       RMP_Sched_Locked=0;
00000e  6098              STR      r0,[r3,#8]  ; RMP_Sched_Locked
;;;2016       RMP_Sched_Pend=0;
000010  60d8              STR      r0,[r3,#0xc]  ; RMP_Sched_Pend
;;;2017       RMP_Timer_Pend=0;
000012  6118              STR      r0,[r3,#0x10]  ; RMP_Timer_Pend
;;;2018       
;;;2019       /* Linked lists */
;;;2020       RMP_List_Crt(&RMP_Delay);
000014  f1030120          ADD      r1,r3,#0x20
000018  6009              STR      r1,[r1,#0]
00001a  6049              STR      r1,[r1,#4]
;;;2021       for(Count=0;Count<RMP_MAX_PREEMPT_PRIO;Count++)
;;;2022           RMP_List_Crt(&RMP_Run[Count]);
00001c  f8dfc074          LDR      r12,|L41.148|
000020  4601              MOV      r1,r0                 ;2021
000022  bf00              NOP      
                  |L41.36|
000024  eb0c02c1          ADD      r2,r12,r1,LSL #3
000028  6012              STR      r2,[r2,#0]
00002a  6052              STR      r2,[r2,#4]
00002c  1c49              ADDS     r1,r1,#1
00002e  2920              CMP      r1,#0x20
000030  d3f8              BCC      |L41.36|
;;;2023       for(Count=0;Count<RMP_BITMAP_SIZE;Count++)
;;;2024           RMP_Bitmap[Count]=0;
000032  4c17              LDR      r4,|L41.144|
000034  6020              STR      r0,[r4,#0]  ; RMP_Bitmap
;;;2025           
;;;2026       /* Now boot into the first thread */
;;;2027       RMP_Clear(&RMP_Init_Thd,sizeof(struct RMP_Thd));
000036  4a18              LDR      r2,|L41.152|
000038  211e              MOVS     r1,#0x1e
                  |L41.58|
00003a  1e49              SUBS     r1,r1,#1
00003c  7050              STRB     r0,[r2,#1]
00003e  f8020f02          STRB     r0,[r2,#2]!
000042  d1fa              BNE      |L41.58|
;;;2028       RMP_Init_Thd.Prio=0;
000044  4915              LDR      r1,|L41.156|
000046  6248              STR      r0,[r1,#0x24]  ; RMP_Init_Thd
;;;2029       RMP_Init_Thd.Slices=10;
000048  200a              MOVS     r0,#0xa
00004a  61c8              STR      r0,[r1,#0x1c]  ; RMP_Init_Thd
;;;2030       RMP_Init_Thd.Slices_Left=10;
00004c  6208              STR      r0,[r1,#0x20]  ; RMP_Init_Thd
;;;2031       RMP_Init_Thd.State=RMP_THD_RUNNING;
00004e  2001              MOVS     r0,#1
000050  6188              STR      r0,[r1,#0x18]  ; RMP_Init_Thd
;;;2032       RMP_Init_Thd.Stack=RMP_INIT_STACK;
000052  f1a10044          SUB      r0,r1,#0x44
000056  6348              STR      r0,[r1,#0x34]  ; RMP_Init_Thd
;;;2033       
;;;2034       /* Initialize sending list */
;;;2035       RMP_List_Crt(&(RMP_Init_Thd.Snd_List));
000058  f1010010          ADD      r0,r1,#0x10
00005c  6108              STR      r0,[r1,#0x10]
00005e  6148              STR      r0,[r1,#0x14]
;;;2036       
;;;2037       /* Insert this into the corresponding runqueue */
;;;2038       RMP_List_Ins(&(RMP_Init_Thd.Run_Head),RMP_Run[0].Prev,&(RMP_Run[0]));
000060  f8dc2000          LDR      r2,[r12,#0]  ; RMP_Run
000064  4608              MOV      r0,r1
000066  f5a07c00          SUB      r12,r0,#0x200
00006a  f8cc0000          STR      r0,[r12,#0]
00006e  f8c0c004          STR      r12,[r0,#4]
000072  6002              STR      r2,[r0,#0]
000074  6050              STR      r0,[r2,#4]
;;;2039       /* Set this runlevel as active - in fact it is always active */
;;;2040       RMP_Bitmap[0]|=1;
000076  6820              LDR      r0,[r4,#0]  ; RMP_Bitmap
000078  f0400001          ORR      r0,r0,#1
00007c  6020              STR      r0,[r4,#0]  ; RMP_Bitmap
;;;2041       
;;;2042       /* Set current thread and stack */
;;;2043       RMP_Cur_Thd=(struct RMP_Thd*)(&RMP_Init_Thd);
00007e  6199              STR      r1,[r3,#0x18]  ; RMP_Cur_Thd
;;;2044       RMP_Cur_SP=RMP_Init_Thd.Stack;
000080  6b48              LDR      r0,[r1,#0x34]  ; RMP_Init_Thd
000082  61d8              STR      r0,[r3,#0x1c]  ; RMP_Cur_SP
;;;2045       
;;;2046       /* Now jump to the user function and will never return. Initialization of stack is not needed */
;;;2047       _RMP_Start((rmp_ptr_t)RMP_Init, (rmp_ptr_t)RMP_Init_Thd.Stack);
000084  6b49              LDR      r1,[r1,#0x34]  ; RMP_Init_Thd
000086  4806              LDR      r0,|L41.160|
000088  f7fffffe          BL       _RMP_Start
;;;2048       
;;;2049       return 0;
00008c  2000              MOVS     r0,#0
;;;2050   }
00008e  bd10              POP      {r4,pc}
;;;2051   /* End Function:main *********************************************************/
                          ENDP

                  |L41.144|
                          DCD      ||.data||
                  |L41.148|
                          DCD      ||.bss||
                  |L41.152|
                          DCD      ||.bss||+0x1ff
                  |L41.156|
                          DCD      ||.bss||+0x200
                  |L41.160|
                          DCD      RMP_Init

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  RMP_Run
                          %        256
                  RMP_Init_Stack
                          %        256
                  RMP_Init_Thd
                          %        60

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  RMP_RBIT_Table
000000  008040c0          DCB      0x00,0x80,0x40,0xc0
000004  20a060e0          DCB      0x20,0xa0,0x60,0xe0
000008  109050d0          DCB      0x10,0x90,0x50,0xd0
00000c  30b070f0          DCB      0x30,0xb0,0x70,0xf0
000010  088848c8          DCB      0x08,0x88,0x48,0xc8
000014  28a868e8          DCB      0x28,0xa8,0x68,0xe8
000018  189858d8          DCB      0x18,0x98,0x58,0xd8
00001c  38b878f8          DCB      0x38,0xb8,0x78,0xf8
000020  048444c4          DCB      0x04,0x84,0x44,0xc4
000024  24a464e4          DCB      0x24,0xa4,0x64,0xe4
000028  149454d4          DCB      0x14,0x94,0x54,0xd4
00002c  34b474f4          DCB      0x34,0xb4,0x74,0xf4
000030  0c8c4ccc          DCB      0x0c,0x8c,0x4c,0xcc
000034  2cac6cec          DCB      0x2c,0xac,0x6c,0xec
000038  1c9c5cdc          DCB      0x1c,0x9c,0x5c,0xdc
00003c  3cbc7cfc          DCB      0x3c,0xbc,0x7c,0xfc
000040  028242c2          DCB      0x02,0x82,0x42,0xc2
000044  22a262e2          DCB      0x22,0xa2,0x62,0xe2
000048  129252d2          DCB      0x12,0x92,0x52,0xd2
00004c  32b272f2          DCB      0x32,0xb2,0x72,0xf2
000050  0a8a4aca          DCB      0x0a,0x8a,0x4a,0xca
000054  2aaa6aea          DCB      0x2a,0xaa,0x6a,0xea
000058  1a9a5ada          DCB      0x1a,0x9a,0x5a,0xda
00005c  3aba7afa          DCB      0x3a,0xba,0x7a,0xfa
000060  068646c6          DCB      0x06,0x86,0x46,0xc6
000064  26a666e6          DCB      0x26,0xa6,0x66,0xe6
000068  169656d6          DCB      0x16,0x96,0x56,0xd6
00006c  36b676f6          DCB      0x36,0xb6,0x76,0xf6
000070  0e8e4ece          DCB      0x0e,0x8e,0x4e,0xce
000074  2eae6eee          DCB      0x2e,0xae,0x6e,0xee
000078  1e9e5ede          DCB      0x1e,0x9e,0x5e,0xde
00007c  3ebe7efe          DCB      0x3e,0xbe,0x7e,0xfe
000080  018141c1          DCB      0x01,0x81,0x41,0xc1
000084  21a161e1          DCB      0x21,0xa1,0x61,0xe1
000088  119151d1          DCB      0x11,0x91,0x51,0xd1
00008c  31b171f1          DCB      0x31,0xb1,0x71,0xf1
000090  098949c9          DCB      0x09,0x89,0x49,0xc9
000094  29a969e9          DCB      0x29,0xa9,0x69,0xe9
000098  199959d9          DCB      0x19,0x99,0x59,0xd9
00009c  39b979f9          DCB      0x39,0xb9,0x79,0xf9
0000a0  058545c5          DCB      0x05,0x85,0x45,0xc5
0000a4  25a565e5          DCB      0x25,0xa5,0x65,0xe5
0000a8  159555d5          DCB      0x15,0x95,0x55,0xd5
0000ac  35b575f5          DCB      0x35,0xb5,0x75,0xf5
0000b0  0d8d4dcd          DCB      0x0d,0x8d,0x4d,0xcd
0000b4  2dad6ded          DCB      0x2d,0xad,0x6d,0xed
0000b8  1d9d5ddd          DCB      0x1d,0x9d,0x5d,0xdd
0000bc  3dbd7dfd          DCB      0x3d,0xbd,0x7d,0xfd
0000c0  038343c3          DCB      0x03,0x83,0x43,0xc3
0000c4  23a363e3          DCB      0x23,0xa3,0x63,0xe3
0000c8  139353d3          DCB      0x13,0x93,0x53,0xd3
0000cc  33b373f3          DCB      0x33,0xb3,0x73,0xf3
0000d0  0b8b4bcb          DCB      0x0b,0x8b,0x4b,0xcb
0000d4  2bab6beb          DCB      0x2b,0xab,0x6b,0xeb
0000d8  1b9b5bdb          DCB      0x1b,0x9b,0x5b,0xdb
0000dc  3bbb7bfb          DCB      0x3b,0xbb,0x7b,0xfb
0000e0  078747c7          DCB      0x07,0x87,0x47,0xc7
0000e4  27a767e7          DCB      0x27,0xa7,0x67,0xe7
0000e8  179757d7          DCB      0x17,0x97,0x57,0xd7
0000ec  37b777f7          DCB      0x37,0xb7,0x77,0xf7
0000f0  0f8f4fcf          DCB      0x0f,0x8f,0x4f,0xcf
0000f4  2faf6fef          DCB      0x2f,0xaf,0x6f,0xef
0000f8  1f9f5fdf          DCB      0x1f,0x9f,0x5f,0xdf
0000fc  3fbf7fff          DCB      0x3f,0xbf,0x7f,0xff
                  CRC16_High
000100  00c18140          DCB      0x00,0xc1,0x81,0x40
000104  01c08041          DCB      0x01,0xc0,0x80,0x41
000108  01c08041          DCB      0x01,0xc0,0x80,0x41
00010c  00c18140          DCB      0x00,0xc1,0x81,0x40
000110  01c08041          DCB      0x01,0xc0,0x80,0x41
000114  00c18140          DCB      0x00,0xc1,0x81,0x40
000118  00c18140          DCB      0x00,0xc1,0x81,0x40
00011c  01c08041          DCB      0x01,0xc0,0x80,0x41
000120  01c08041          DCB      0x01,0xc0,0x80,0x41
000124  00c18140          DCB      0x00,0xc1,0x81,0x40
000128  00c18140          DCB      0x00,0xc1,0x81,0x40
00012c  01c08041          DCB      0x01,0xc0,0x80,0x41
000130  00c18140          DCB      0x00,0xc1,0x81,0x40
000134  01c08041          DCB      0x01,0xc0,0x80,0x41
000138  01c08041          DCB      0x01,0xc0,0x80,0x41
00013c  00c18140          DCB      0x00,0xc1,0x81,0x40
000140  01c08041          DCB      0x01,0xc0,0x80,0x41
000144  00c18140          DCB      0x00,0xc1,0x81,0x40
000148  00c18140          DCB      0x00,0xc1,0x81,0x40
00014c  01c08041          DCB      0x01,0xc0,0x80,0x41
000150  00c18140          DCB      0x00,0xc1,0x81,0x40
000154  01c08041          DCB      0x01,0xc0,0x80,0x41
000158  01c08041          DCB      0x01,0xc0,0x80,0x41
00015c  00c18140          DCB      0x00,0xc1,0x81,0x40
000160  00c18140          DCB      0x00,0xc1,0x81,0x40
000164  01c08041          DCB      0x01,0xc0,0x80,0x41
000168  01c08041          DCB      0x01,0xc0,0x80,0x41
00016c  00c18140          DCB      0x00,0xc1,0x81,0x40
000170  01c08041          DCB      0x01,0xc0,0x80,0x41
000174  00c18140          DCB      0x00,0xc1,0x81,0x40
000178  00c18140          DCB      0x00,0xc1,0x81,0x40
00017c  01c08041          DCB      0x01,0xc0,0x80,0x41
000180  01c08041          DCB      0x01,0xc0,0x80,0x41
000184  00c18140          DCB      0x00,0xc1,0x81,0x40
000188  00c18140          DCB      0x00,0xc1,0x81,0x40
00018c  01c08041          DCB      0x01,0xc0,0x80,0x41
000190  00c18140          DCB      0x00,0xc1,0x81,0x40
000194  01c08041          DCB      0x01,0xc0,0x80,0x41
000198  01c08041          DCB      0x01,0xc0,0x80,0x41
00019c  00c18140          DCB      0x00,0xc1,0x81,0x40
0001a0  00c18140          DCB      0x00,0xc1,0x81,0x40
0001a4  01c08041          DCB      0x01,0xc0,0x80,0x41
0001a8  01c08041          DCB      0x01,0xc0,0x80,0x41
0001ac  00c18140          DCB      0x00,0xc1,0x81,0x40
0001b0  01c08041          DCB      0x01,0xc0,0x80,0x41
0001b4  00c18140          DCB      0x00,0xc1,0x81,0x40
0001b8  00c18140          DCB      0x00,0xc1,0x81,0x40
0001bc  01c08041          DCB      0x01,0xc0,0x80,0x41
0001c0  00c18140          DCB      0x00,0xc1,0x81,0x40
0001c4  01c08041          DCB      0x01,0xc0,0x80,0x41
0001c8  01c08041          DCB      0x01,0xc0,0x80,0x41
0001cc  00c18140          DCB      0x00,0xc1,0x81,0x40
0001d0  01c08041          DCB      0x01,0xc0,0x80,0x41
0001d4  00c18140          DCB      0x00,0xc1,0x81,0x40
0001d8  00c18140          DCB      0x00,0xc1,0x81,0x40
0001dc  01c08041          DCB      0x01,0xc0,0x80,0x41
0001e0  01c08041          DCB      0x01,0xc0,0x80,0x41
0001e4  00c18140          DCB      0x00,0xc1,0x81,0x40
0001e8  00c18140          DCB      0x00,0xc1,0x81,0x40
0001ec  01c08041          DCB      0x01,0xc0,0x80,0x41
0001f0  00c18140          DCB      0x00,0xc1,0x81,0x40
0001f4  01c08041          DCB      0x01,0xc0,0x80,0x41
0001f8  01c08041          DCB      0x01,0xc0,0x80,0x41
0001fc  00c18140          DCB      0x00,0xc1,0x81,0x40
000200  00c0c101          DCB      0x00,0xc0,0xc1,0x01
000204  c30302c2          DCB      0xc3,0x03,0x02,0xc2
000208  c60607c7          DCB      0xc6,0x06,0x07,0xc7
00020c  05c5c404          DCB      0x05,0xc5,0xc4,0x04
000210  cc0c0dcd          DCB      0xcc,0x0c,0x0d,0xcd
000214  0fcfce0e          DCB      0x0f,0xcf,0xce,0x0e
000218  0acacb0b          DCB      0x0a,0xca,0xcb,0x0b
00021c  c90908c8          DCB      0xc9,0x09,0x08,0xc8
000220  d81819d9          DCB      0xd8,0x18,0x19,0xd9
000224  1bdbda1a          DCB      0x1b,0xdb,0xda,0x1a
000228  1ededf1f          DCB      0x1e,0xde,0xdf,0x1f
00022c  dd1d1cdc          DCB      0xdd,0x1d,0x1c,0xdc
000230  14d4d515          DCB      0x14,0xd4,0xd5,0x15
000234  d71716d6          DCB      0xd7,0x17,0x16,0xd6
000238  d21213d3          DCB      0xd2,0x12,0x13,0xd3
00023c  11d1d010          DCB      0x11,0xd1,0xd0,0x10
000240  f03031f1          DCB      0xf0,0x30,0x31,0xf1
000244  33f3f232          DCB      0x33,0xf3,0xf2,0x32
000248  36f6f737          DCB      0x36,0xf6,0xf7,0x37
00024c  f53534f4          DCB      0xf5,0x35,0x34,0xf4
000250  3cfcfd3d          DCB      0x3c,0xfc,0xfd,0x3d
000254  ff3f3efe          DCB      0xff,0x3f,0x3e,0xfe
000258  fa3a3bfb          DCB      0xfa,0x3a,0x3b,0xfb
00025c  39f9f838          DCB      0x39,0xf9,0xf8,0x38
000260  28e8e929          DCB      0x28,0xe8,0xe9,0x29
000264  eb2b2aea          DCB      0xeb,0x2b,0x2a,0xea
000268  ee2e2fef          DCB      0xee,0x2e,0x2f,0xef
00026c  2dedec2c          DCB      0x2d,0xed,0xec,0x2c
000270  e42425e5          DCB      0xe4,0x24,0x25,0xe5
000274  27e7e626          DCB      0x27,0xe7,0xe6,0x26
000278  22e2e323          DCB      0x22,0xe2,0xe3,0x23
00027c  e12120e0          DCB      0xe1,0x21,0x20,0xe0
000280  a06061a1          DCB      0xa0,0x60,0x61,0xa1
000284  63a3a262          DCB      0x63,0xa3,0xa2,0x62
000288  66a6a767          DCB      0x66,0xa6,0xa7,0x67
00028c  a56564a4          DCB      0xa5,0x65,0x64,0xa4
000290  6cacad6d          DCB      0x6c,0xac,0xad,0x6d
000294  af6f6eae          DCB      0xaf,0x6f,0x6e,0xae
000298  aa6a6bab          DCB      0xaa,0x6a,0x6b,0xab
00029c  69a9a868          DCB      0x69,0xa9,0xa8,0x68
0002a0  78b8b979          DCB      0x78,0xb8,0xb9,0x79
0002a4  bb7b7aba          DCB      0xbb,0x7b,0x7a,0xba
0002a8  be7e7fbf          DCB      0xbe,0x7e,0x7f,0xbf
0002ac  7dbdbc7c          DCB      0x7d,0xbd,0xbc,0x7c
0002b0  b47475b5          DCB      0xb4,0x74,0x75,0xb5
0002b4  77b7b676          DCB      0x77,0xb7,0xb6,0x76
0002b8  72b2b373          DCB      0x72,0xb2,0xb3,0x73
0002bc  b17170b0          DCB      0xb1,0x71,0x70,0xb0
0002c0  50909151          DCB      0x50,0x90,0x91,0x51
0002c4  93535292          DCB      0x93,0x53,0x52,0x92
0002c8  96565797          DCB      0x96,0x56,0x57,0x97
0002cc  55959454          DCB      0x55,0x95,0x94,0x54
0002d0  9c5c5d9d          DCB      0x9c,0x5c,0x5d,0x9d
0002d4  5f9f9e5e          DCB      0x5f,0x9f,0x9e,0x5e
0002d8  5a9a9b5b          DCB      0x5a,0x9a,0x9b,0x5b
0002dc  99595898          DCB      0x99,0x59,0x58,0x98
0002e0  88484989          DCB      0x88,0x48,0x49,0x89
0002e4  4b8b8a4a          DCB      0x4b,0x8b,0x8a,0x4a
0002e8  4e8e8f4f          DCB      0x4e,0x8e,0x8f,0x4f
0002ec  8d4d4c8c          DCB      0x8d,0x4d,0x4c,0x8c
0002f0  44848545          DCB      0x44,0x84,0x85,0x45
0002f4  87474686          DCB      0x87,0x47,0x46,0x86
0002f8  82424383          DCB      0x82,0x42,0x43,0x83
0002fc  41818040          DCB      0x41,0x81,0x80,0x40

                          AREA ||.data||, DATA, ALIGN=2

                  RMP_Bitmap
                          DCD      0x00000000
                  RMP_Sched_Lock_Cnt
                          DCD      0x00000000
                  RMP_Sched_Locked
                          DCD      0x00000000
                  RMP_Sched_Pend
                          DCD      0x00000000
                  RMP_Timer_Pend
                          DCD      0x00000000
                  RMP_Tick
                          DCD      0x00000000
                  RMP_Cur_Thd
                          DCD      0x00000000
                  RMP_Cur_SP
                          DCD      0x00000000
                  RMP_Delay
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\..\\MProkaron\\Kernel\\rmp_kernel.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_rmp_kernel_c_346ad0e8____REV16|
#line 388 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F1_V1.6.0\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___12_rmp_kernel_c_346ad0e8____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_rmp_kernel_c_346ad0e8____REVSH|
#line 402
|__asm___12_rmp_kernel_c_346ad0e8____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___12_rmp_kernel_c_346ad0e8____RRX|
#line 587
|__asm___12_rmp_kernel_c_346ad0e8____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
