; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f1xx_hal_rcc.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f1xx_hal_rcc.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F1_V1.6.0\Drivers\STM32F1xx_HAL_Driver\Inc -I..\..\..\M0P0_Library\STM32Cube_FW_F1_V1.6.0\Drivers\CMSIS\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F1_V1.6.0\Drivers\CMSIS\Device\ST\STM32F1xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F1_V1.6.0\Drivers\STM32F1xx_HAL_Driver\Inc\Conf -I..\RVMDK-STM32F103ZET6 -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F103ZET6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F10X_HD -DUSE_HAL_DRIVER -DSTM32F103xE -W --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f1xx_hal_rcc.crf ..\..\..\M0P0_Library\STM32Cube_FW_F1_V1.6.0\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_rcc.c]
                          THUMB

                          AREA ||i.HAL_RCC_CSSCallback||, CODE, READONLY, ALIGN=1

                  HAL_RCC_CSSCallback PROC
;;;1278     */
;;;1279   __weak void HAL_RCC_CSSCallback(void)
000000  4770              BX       lr
;;;1280   {
;;;1281     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1282       the HAL_RCC_CSSCallback could be implemented in the user file
;;;1283       */ 
;;;1284   }
;;;1285   
                          ENDP


                          AREA ||i.HAL_RCC_ClockConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_ClockConfig PROC
;;;708      */
;;;709    HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;710    {
;;;711      uint32_t tickstart = 0U;
;;;712      
;;;713      /* Check the parameters */
;;;714      assert_param(RCC_ClkInitStruct != NULL);
;;;715      assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
;;;716      assert_param(IS_FLASH_LATENCY(FLatency));
;;;717    
;;;718      /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
;;;719      must be correctly programmed according to the frequency of the CPU clock 
;;;720        (HCLK) of the device. */
;;;721    
;;;722    #if defined(FLASH_ACR_LATENCY)
;;;723      /* Increasing the number of wait states because of higher CPU frequency */
;;;724      if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
000004  4e6e              LDR      r6,|L2.448|
000006  4604              MOV      r4,r0                 ;710
000008  b085              SUB      sp,sp,#0x14           ;710
00000a  6830              LDR      r0,[r6,#0]
00000c  460f              MOV      r7,r1                 ;710
00000e  f0000007          AND      r0,r0,#7
000012  42b8              CMP      r0,r7
000014  d209              BCS      |L2.42|
;;;725      {    
;;;726        /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
;;;727        __HAL_FLASH_SET_LATENCY(FLatency);
000016  6830              LDR      r0,[r6,#0]
000018  f0200007          BIC      r0,r0,#7
00001c  4338              ORRS     r0,r0,r7
00001e  6030              STR      r0,[r6,#0]
;;;728        
;;;729        /* Check that the new number of wait states is taken into account to access the Flash
;;;730        memory by reading the FLASH_ACR register */
;;;731        if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
000020  6830              LDR      r0,[r6,#0]
000022  f0000007          AND      r0,r0,#7
000026  42b8              CMP      r0,r7
000028  d17a              BNE      |L2.288|
                  |L2.42|
;;;732        {
;;;733          return HAL_ERROR;
;;;734        }
;;;735      }
;;;736    
;;;737    #endif /* FLASH_ACR_LATENCY */
;;;738      /*-------------------------- HCLK Configuration --------------------------*/
;;;739      if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
00002a  7820              LDRB     r0,[r4,#0]
;;;740      {
;;;741        assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
;;;742        MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
00002c  f8df8194          LDR      r8,|L2.452|
000030  f0100f02          TST      r0,#2                 ;739
000034  d007              BEQ      |L2.70|
000036  f8d80004          LDR      r0,[r8,#4]
00003a  68a1              LDR      r1,[r4,#8]
00003c  f02000f0          BIC      r0,r0,#0xf0
000040  4308              ORRS     r0,r0,r1
000042  f8c80004          STR      r0,[r8,#4]
                  |L2.70|
;;;743      }
;;;744    
;;;745      /*------------------------- SYSCLK Configuration ---------------------------*/ 
;;;746      if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
000046  7820              LDRB     r0,[r4,#0]
000048  f0100f01          TST      r0,#1
00004c  d059              BEQ      |L2.258|
;;;747      {    
;;;748        assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
;;;749        
;;;750        /* HSE is selected as System Clock Source */
;;;751        if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
00004e  6860              LDR      r0,[r4,#4]
000050  2801              CMP      r0,#1
000052  d026              BEQ      |L2.162|
;;;752        {
;;;753          /* Check the HSE ready flag */  
;;;754          if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
;;;755          {
;;;756            return HAL_ERROR;
;;;757          }
;;;758        }
;;;759        /* PLL is selected as System Clock Source */
;;;760        else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
;;;761        {
;;;762          /* Check the PLL ready flag */  
;;;763          if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
;;;764          {
;;;765            return HAL_ERROR;
;;;766          }
;;;767        }
;;;768        /* HSI is selected as System Clock Source */
;;;769        else
;;;770        {
;;;771          /* Check the HSI ready flag */  
;;;772          if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
000054  f8d81000          LDR      r1,[r8,#0]
000058  2802              CMP      r0,#2                 ;760
00005a  d028              BEQ      |L2.174|
00005c  f0110f02          TST      r1,#2
000060  d05e              BEQ      |L2.288|
;;;773          {
;;;774            return HAL_ERROR;
;;;775          }
;;;776        }
;;;777        __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
000062  bf00              NOP      
                  |L2.100|
000064  f8d81004          LDR      r1,[r8,#4]
000068  f0210103          BIC      r1,r1,#3
00006c  4308              ORRS     r0,r0,r1
00006e  f8c80004          STR      r0,[r8,#4]
;;;778    
;;;779        /* Get Start Tick */
;;;780        tickstart = HAL_GetTick();
000072  f7fffffe          BL       HAL_GetTick
000076  4605              MOV      r5,r0
;;;781        
;;;782        if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
000078  6860              LDR      r0,[r4,#4]
;;;783        {
;;;784          while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
;;;785          {
;;;786            if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
00007a  f2413988          MOV      r9,#0x1388
00007e  2801              CMP      r0,#1                 ;782
000080  d019              BEQ      |L2.182|
;;;787            {
;;;788              return HAL_TIMEOUT;
;;;789            }
;;;790          }
;;;791        }
;;;792        else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
000082  2802              CMP      r0,#2
;;;793        {
;;;794          while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
;;;795          {
;;;796            if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
;;;797            {
;;;798              return HAL_TIMEOUT;
;;;799            }
;;;800          }
;;;801        }
;;;802        else
;;;803        {
;;;804          while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
000084  f8d80004          LDR      r0,[r8,#4]
000088  f000000c          AND      r0,r0,#0xc
00008c  d026              BEQ      |L2.220|
00008e  b320              CBZ      r0,|L2.218|
                  |L2.144|
;;;805          {
;;;806            if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
000090  f7fffffe          BL       HAL_GetTick
000094  1b40              SUBS     r0,r0,r5
000096  4548              CMP      r0,r9
000098  d92e              BLS      |L2.248|
                  |L2.154|
;;;807            {
;;;808              return HAL_TIMEOUT;
;;;809            }
;;;810          }
;;;811        }      
;;;812      }    
;;;813    #if defined(FLASH_ACR_LATENCY)
;;;814      /* Decreasing the number of wait states because of lower CPU frequency */
;;;815      if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
;;;816      {    
;;;817        /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
;;;818        __HAL_FLASH_SET_LATENCY(FLatency);
;;;819        
;;;820        /* Check that the new number of wait states is taken into account to access the Flash
;;;821        memory by reading the FLASH_ACR register */
;;;822        if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
;;;823        {
;;;824          return HAL_ERROR;
;;;825        }
;;;826      }    
;;;827    #endif /* FLASH_ACR_LATENCY */
;;;828    
;;;829      /*-------------------------- PCLK1 Configuration ---------------------------*/ 
;;;830      if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
;;;831      {
;;;832        assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
;;;833        MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
;;;834      }
;;;835      
;;;836      /*-------------------------- PCLK2 Configuration ---------------------------*/ 
;;;837      if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
;;;838      {
;;;839        assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
;;;840        MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
;;;841      }
;;;842     
;;;843      /* Update the SystemCoreClock global variable */
;;;844      SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
;;;845    
;;;846      /* Configure the source of time base considering new system clocks settings*/
;;;847      HAL_InitTick (TICK_INT_PRIORITY);
;;;848      
;;;849      return HAL_OK;
;;;850    }
00009a  b005              ADD      sp,sp,#0x14
00009c  2003              MOVS     r0,#3                 ;808
00009e  e8bd83f0          POP      {r4-r9,pc}
                  |L2.162|
0000a2  f8d81000          LDR      r1,[r8,#0]            ;754
0000a6  f4113f00          TST      r1,#0x20000           ;754
0000aa  d1db              BNE      |L2.100|
0000ac  e038              B        |L2.288|
                  |L2.174|
0000ae  f0117f00          TST      r1,#0x2000000         ;763
0000b2  d1d7              BNE      |L2.100|
0000b4  e034              B        |L2.288|
                  |L2.182|
0000b6  f8d80004          LDR      r0,[r8,#4]            ;784
0000ba  f000000c          AND      r0,r0,#0xc            ;784
0000be  2804              CMP      r0,#4                 ;784
0000c0  d01f              BEQ      |L2.258|
0000c2  bf00              NOP                            ;786
                  |L2.196|
0000c4  f7fffffe          BL       HAL_GetTick
0000c8  1b40              SUBS     r0,r0,r5              ;786
0000ca  4548              CMP      r0,r9                 ;786
0000cc  d8e5              BHI      |L2.154|
0000ce  f8d80004          LDR      r0,[r8,#4]            ;784
0000d2  f000000c          AND      r0,r0,#0xc            ;784
0000d6  2804              CMP      r0,#4                 ;784
0000d8  d1f4              BNE      |L2.196|
                  |L2.218|
0000da  e012              B        |L2.258|
                  |L2.220|
0000dc  2808              CMP      r0,#8                 ;794
0000de  d010              BEQ      |L2.258|
                  |L2.224|
0000e0  f7fffffe          BL       HAL_GetTick
0000e4  1b40              SUBS     r0,r0,r5              ;796
0000e6  4548              CMP      r0,r9                 ;796
0000e8  d8d7              BHI      |L2.154|
0000ea  f8d80004          LDR      r0,[r8,#4]            ;794
0000ee  f000000c          AND      r0,r0,#0xc            ;794
0000f2  2808              CMP      r0,#8                 ;794
0000f4  d1f4              BNE      |L2.224|
0000f6  e004              B        |L2.258|
                  |L2.248|
0000f8  f8d80004          LDR      r0,[r8,#4]            ;804
0000fc  f0100f0c          TST      r0,#0xc               ;804
000100  d1c6              BNE      |L2.144|
                  |L2.258|
000102  6830              LDR      r0,[r6,#0]            ;815
000104  f0000007          AND      r0,r0,#7              ;815
000108  42b8              CMP      r0,r7                 ;815
00010a  d90d              BLS      |L2.296|
00010c  6830              LDR      r0,[r6,#0]            ;818
00010e  f0200007          BIC      r0,r0,#7              ;818
000112  4338              ORRS     r0,r0,r7              ;818
000114  6030              STR      r0,[r6,#0]            ;818
000116  6830              LDR      r0,[r6,#0]            ;822
000118  f0000007          AND      r0,r0,#7              ;822
00011c  42b8              CMP      r0,r7                 ;822
00011e  d003              BEQ      |L2.296|
                  |L2.288|
000120  b005              ADD      sp,sp,#0x14
000122  2001              MOVS     r0,#1                 ;824
000124  e8bd83f0          POP      {r4-r9,pc}
                  |L2.296|
000128  7820              LDRB     r0,[r4,#0]            ;830
00012a  f0100f04          TST      r0,#4                 ;830
00012e  d007              BEQ      |L2.320|
000130  f8d80004          LDR      r0,[r8,#4]            ;833
000134  68e1              LDR      r1,[r4,#0xc]          ;833
000136  f42060e0          BIC      r0,r0,#0x700          ;833
00013a  4308              ORRS     r0,r0,r1              ;833
00013c  f8c80004          STR      r0,[r8,#4]            ;833
                  |L2.320|
000140  7820              LDRB     r0,[r4,#0]            ;837
000142  f0100f08          TST      r0,#8                 ;837
000146  d008              BEQ      |L2.346|
000148  f8d80004          LDR      r0,[r8,#4]            ;840
00014c  6921              LDR      r1,[r4,#0x10]         ;840
00014e  f4205060          BIC      r0,r0,#0x3800         ;840
000152  ea4000c1          ORR      r0,r0,r1,LSL #3       ;840
000156  f8c80004          STR      r0,[r8,#4]            ;840
                  |L2.346|
00015a  4b1b              LDR      r3,|L2.456|
00015c  cb0f              LDM      r3,{r0-r3}            ;840
00015e  e88d000f          STM      sp,{r0-r3}            ;840
000162  481a              LDR      r0,|L2.460|
000164  6800              LDR      r0,[r0,#0]            ;840
000166  9004              STR      r0,[sp,#0x10]         ;840
000168  f8d81004          LDR      r1,[r8,#4]            ;840
00016c  4818              LDR      r0,|L2.464|
00016e  f001020c          AND      r2,r1,#0xc            ;840
000172  2a04              CMP      r2,#4                 ;840
000174  d014              BEQ      |L2.416|
000176  2a08              CMP      r2,#8                 ;840
000178  d112              BNE      |L2.416|
00017a  f3c14383          UBFX     r3,r1,#18,#4          ;840
00017e  f4113f80          TST      r1,#0x10000           ;840
000182  f81d2003          LDRB     r2,[sp,r3]            ;840
000186  bf04              ITT      EQ                    ;840
000188  4812              LDREQ    r0,|L2.468|
00018a  4350              MULEQ    r0,r2,r0              ;840
00018c  d008              BEQ      |L2.416|
00018e  f8d81004          LDR      r1,[r8,#4]            ;840
000192  ab04              ADD      r3,sp,#0x10           ;840
000194  f3c14140          UBFX     r1,r1,#17,#1          ;840
000198  5c59              LDRB     r1,[r3,r1]            ;840
00019a  fbb0f0f1          UDIV     r0,r0,r1              ;840
00019e  4350              MULS     r0,r2,r0              ;840
                  |L2.416|
0001a0  f8d81004          LDR      r1,[r8,#4]            ;844
0001a4  4a0c              LDR      r2,|L2.472|
0001a6  f3c11103          UBFX     r1,r1,#4,#4           ;844
0001aa  5c51              LDRB     r1,[r2,r1]            ;844
0001ac  40c8              LSRS     r0,r0,r1              ;844
0001ae  490b              LDR      r1,|L2.476|
0001b0  6008              STR      r0,[r1,#0]            ;847  ; SystemCoreClock
0001b2  200f              MOVS     r0,#0xf               ;847
0001b4  f7fffffe          BL       HAL_InitTick
0001b8  b005              ADD      sp,sp,#0x14
0001ba  2000              MOVS     r0,#0                 ;849
0001bc  e8bd83f0          POP      {r4-r9,pc}
;;;851    
                          ENDP

                  |L2.448|
                          DCD      0x40022000
                  |L2.452|
                          DCD      0x40021000
                  |L2.456|
                          DCD      ||i.HAL_RCC_GetSysClockFreq||+0x54
                  |L2.460|
                          DCD      ||i.HAL_RCC_GetSysClockFreq||+0x64
                  |L2.464|
                          DCD      0x007a1200
                  |L2.468|
                          DCD      0x003d0900
                  |L2.472|
                          DCD      AHBPrescTable
                  |L2.476|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_RCC_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_RCC_DeInit PROC
;;;218      */
;;;219    void HAL_RCC_DeInit(void)
000000  480d              LDR      r0,|L3.56|
;;;220    {
;;;221      /* Switch SYSCLK to HSI */
;;;222      CLEAR_BIT(RCC->CFGR, RCC_CFGR_SW);
000002  6841              LDR      r1,[r0,#4]
000004  f0210103          BIC      r1,r1,#3
000008  6041              STR      r1,[r0,#4]
;;;223    
;;;224      /* Reset HSEON, CSSON, & PLLON bits */
;;;225      CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_CSSON | RCC_CR_PLLON);
00000a  6801              LDR      r1,[r0,#0]
00000c  f4212110          BIC      r1,r1,#0x90000
000010  f0217180          BIC      r1,r1,#0x1000000
000014  6001              STR      r1,[r0,#0]
;;;226      
;;;227      /* Reset HSEBYP bit */
;;;228      CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
000016  6801              LDR      r1,[r0,#0]
000018  f4212180          BIC      r1,r1,#0x40000
00001c  6001              STR      r1,[r0,#0]
;;;229      
;;;230      /* Reset CFGR register */
;;;231      CLEAR_REG(RCC->CFGR);
00001e  2100              MOVS     r1,#0
000020  6041              STR      r1,[r0,#4]
;;;232      
;;;233      /* Set HSITRIM bits to the reset value */
;;;234      MODIFY_REG(RCC->CR, RCC_CR_HSITRIM, (0x10U << RCC_CR_HSITRIM_Pos));
000022  6802              LDR      r2,[r0,#0]
000024  f02202f8          BIC      r2,r2,#0xf8
000028  f0420280          ORR      r2,r2,#0x80
00002c  6002              STR      r2,[r0,#0]
;;;235      
;;;236    #if defined(RCC_CFGR2_SUPPORT)
;;;237      /* Reset CFGR2 register */
;;;238      CLEAR_REG(RCC->CFGR2);
;;;239    
;;;240    #endif /* RCC_CFGR2_SUPPORT */
;;;241      /* Disable all interrupts */
;;;242      CLEAR_REG(RCC->CIR);
00002e  6081              STR      r1,[r0,#8]
;;;243    
;;;244      /* Update the SystemCoreClock global variable */
;;;245      SystemCoreClock = HSI_VALUE;
000030  4903              LDR      r1,|L3.64|
000032  4802              LDR      r0,|L3.60|
000034  6008              STR      r0,[r1,#0]  ; SystemCoreClock
;;;246    }
000036  4770              BX       lr
;;;247    
                          ENDP

                  |L3.56|
                          DCD      0x40021000
                  |L3.60|
                          DCD      0x007a1200
                  |L3.64|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_RCC_DisableCSS||, CODE, READONLY, ALIGN=2

                  HAL_RCC_DisableCSS PROC
;;;947      */
;;;948    void HAL_RCC_DisableCSS(void)
000000  4901              LDR      r1,|L4.8|
;;;949    {
;;;950      *(__IO uint32_t *) RCC_CR_CSSON_BB = (uint32_t)DISABLE;
000002  2000              MOVS     r0,#0
000004  64c8              STR      r0,[r1,#0x4c]
;;;951    }
000006  4770              BX       lr
;;;952    
                          ENDP

                  |L4.8|
                          DCD      0x42420000

                          AREA ||i.HAL_RCC_EnableCSS||, CODE, READONLY, ALIGN=2

                  HAL_RCC_EnableCSS PROC
;;;938      */
;;;939    void HAL_RCC_EnableCSS(void)
000000  4901              LDR      r1,|L5.8|
;;;940    {
;;;941      *(__IO uint32_t *) RCC_CR_CSSON_BB = (uint32_t)ENABLE;
000002  2001              MOVS     r0,#1
000004  64c8              STR      r0,[r1,#0x4c]
;;;942    }
000006  4770              BX       lr
;;;943    
                          ENDP

                  |L5.8|
                          DCD      0x42420000

                          AREA ||i.HAL_RCC_GetClockConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetClockConfig PROC
;;;1211     */
;;;1212   void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
000000  220f              MOVS     r2,#0xf
;;;1213   {
;;;1214     /* Check the parameters */
;;;1215     assert_param(RCC_ClkInitStruct != NULL);
;;;1216     assert_param(pFLatency != NULL);
;;;1217   
;;;1218     /* Set all possible values for the Clock type parameter --------------------*/
;;;1219     RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
;;;1220     
;;;1221     /* Get the SYSCLK configuration --------------------------------------------*/ 
;;;1222     RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
000002  6002              STR      r2,[r0,#0]
000004  4a0c              LDR      r2,|L6.56|
000006  6853              LDR      r3,[r2,#4]
000008  f0030303          AND      r3,r3,#3
;;;1223     
;;;1224     /* Get the HCLK configuration ----------------------------------------------*/ 
;;;1225     RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE); 
00000c  6043              STR      r3,[r0,#4]
00000e  6853              LDR      r3,[r2,#4]
000010  f00303f0          AND      r3,r3,#0xf0
;;;1226     
;;;1227     /* Get the APB1 configuration ----------------------------------------------*/ 
;;;1228     RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);   
000014  6083              STR      r3,[r0,#8]
000016  6853              LDR      r3,[r2,#4]
000018  f40363e0          AND      r3,r3,#0x700
;;;1229     
;;;1230     /* Get the APB2 configuration ----------------------------------------------*/ 
;;;1231     RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);
00001c  60c3              STR      r3,[r0,#0xc]
00001e  6852              LDR      r2,[r2,#4]
;;;1232     
;;;1233   #if   defined(FLASH_ACR_LATENCY)
;;;1234     /* Get the Flash Wait State (Latency) configuration ------------------------*/   
;;;1235     *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY); 
;;;1236   #else
;;;1237     /* For VALUE lines devices, only LATENCY_0 can be set*/
;;;1238     *pFLatency = (uint32_t)FLASH_LATENCY_0; 
;;;1239   #endif
;;;1240   }
000020  f44f63e0          MOV      r3,#0x700
000024  ea0302d2          AND      r2,r3,r2,LSR #3
000028  6102              STR      r2,[r0,#0x10]         ;1235
00002a  4804              LDR      r0,|L6.60|
00002c  6800              LDR      r0,[r0,#0]            ;1235
00002e  f0000007          AND      r0,r0,#7              ;1235
000032  6008              STR      r0,[r1,#0]            ;1235
000034  4770              BX       lr
;;;1241   
                          ENDP

000036  0000              DCW      0x0000
                  |L6.56|
                          DCD      0x40021000
                  |L6.60|
                          DCD      0x40022000

                          AREA ||i.HAL_RCC_GetHCLKFreq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetHCLKFreq PROC
;;;1075     */
;;;1076   uint32_t HAL_RCC_GetHCLKFreq(void)
000000  4801              LDR      r0,|L7.8|
;;;1077   {
;;;1078     return SystemCoreClock;
000002  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;1079   }
000004  4770              BX       lr
;;;1080   
                          ENDP

000006  0000              DCW      0x0000
                  |L7.8|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_RCC_GetOscConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetOscConfig PROC
;;;1111     */
;;;1112   void HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
000000  210f              MOVS     r1,#0xf
;;;1113   {
;;;1114     /* Check the parameters */
;;;1115     assert_param(RCC_OscInitStruct != NULL);
;;;1116   
;;;1117     /* Set all possible values for the Oscillator type parameter ---------------*/
;;;1118     RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI  \
;;;1119                     | RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_LSI;
;;;1120   
;;;1121   #if defined(RCC_CFGR2_PREDIV1SRC)
;;;1122     /* Get the Prediv1 source --------------------------------------------------*/
;;;1123     RCC_OscInitStruct->Prediv1Source = READ_BIT(RCC->CFGR2,RCC_CFGR2_PREDIV1SRC);
;;;1124   #endif /* RCC_CFGR2_PREDIV1SRC */
;;;1125   
;;;1126     /* Get the HSE configuration -----------------------------------------------*/
;;;1127     if((RCC->CR &RCC_CR_HSEBYP) == RCC_CR_HSEBYP)
000002  6001              STR      r1,[r0,#0]
000004  4927              LDR      r1,|L8.164|
000006  680a              LDR      r2,[r1,#0]
000008  f4122f80          TST      r2,#0x40000
00000c  f04f0200          MOV      r2,#0
;;;1128     {
;;;1129       RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;
000010  bf18              IT       NE
000012  f44f23a0          MOVNE    r3,#0x50000
000016  d034              BEQ      |L8.130|
                  |L8.24|
;;;1130     }
;;;1131     else if((RCC->CR &RCC_CR_HSEON) == RCC_CR_HSEON)
;;;1132     {
;;;1133       RCC_OscInitStruct->HSEState = RCC_HSE_ON;
000018  6043              STR      r3,[r0,#4]
                  |L8.26|
;;;1134     }
;;;1135     else
;;;1136     {
;;;1137       RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
;;;1138     }
;;;1139     RCC_OscInitStruct->HSEPredivValue = __HAL_RCC_HSE_GET_PREDIV();
00001a  684b              LDR      r3,[r1,#4]
00001c  f4033300          AND      r3,r3,#0x20000
;;;1140   
;;;1141     /* Get the HSI configuration -----------------------------------------------*/
;;;1142     if((RCC->CR &RCC_CR_HSION) == RCC_CR_HSION)
000020  6083              STR      r3,[r0,#8]
000022  680b              LDR      r3,[r1,#0]
000024  f0130f01          TST      r3,#1
;;;1143     {
;;;1144       RCC_OscInitStruct->HSIState = RCC_HSI_ON;
000028  f04f0301          MOV      r3,#1
00002c  bf14              ITE      NE
00002e  6103              STRNE    r3,[r0,#0x10]
;;;1145     }
;;;1146     else
;;;1147     {
;;;1148       RCC_OscInitStruct->HSIState = RCC_HSI_OFF;
000030  6102              STREQ    r2,[r0,#0x10]
;;;1149     }
;;;1150     
;;;1151     RCC_OscInitStruct->HSICalibrationValue = (uint32_t)((RCC->CR & RCC_CR_HSITRIM) >> RCC_CR_HSITRIM_Pos);
000032  f8d1c000          LDR      r12,[r1,#0]
000036  f3cc0cc4          UBFX     r12,r12,#3,#5
;;;1152     
;;;1153     /* Get the LSE configuration -----------------------------------------------*/
;;;1154     if((RCC->BDCR &RCC_BDCR_LSEBYP) == RCC_BDCR_LSEBYP)
00003a  f8c0c014          STR      r12,[r0,#0x14]
00003e  f8d1c020          LDR      r12,[r1,#0x20]
000042  f01c0f04          TST      r12,#4
;;;1155     {
;;;1156       RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;
000046  bf1c              ITT      NE
000048  f04f0c05          MOVNE    r12,#5
00004c  f8c0c00c          STRNE    r12,[r0,#0xc]
000050  d020              BEQ      |L8.148|
;;;1157     }
;;;1158     else if((RCC->BDCR &RCC_BDCR_LSEON) == RCC_BDCR_LSEON)
;;;1159     {
;;;1160       RCC_OscInitStruct->LSEState = RCC_LSE_ON;
;;;1161     }
;;;1162     else
;;;1163     {
;;;1164       RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
;;;1165     }
;;;1166     
;;;1167     /* Get the LSI configuration -----------------------------------------------*/
;;;1168     if((RCC->CSR &RCC_CSR_LSION) == RCC_CSR_LSION)
000052  bf00              NOP      
                  |L8.84|
000054  f8d1c024          LDR      r12,[r1,#0x24]
000058  f01c0f01          TST      r12,#1
;;;1169     {
;;;1170       RCC_OscInitStruct->LSIState = RCC_LSI_ON;
00005c  bf14              ITE      NE
00005e  6183              STRNE    r3,[r0,#0x18]
;;;1171     }
;;;1172     else
;;;1173     {
;;;1174       RCC_OscInitStruct->LSIState = RCC_LSI_OFF;
000060  6182              STREQ    r2,[r0,#0x18]
;;;1175     }
;;;1176     
;;;1177   
;;;1178     /* Get the PLL configuration -----------------------------------------------*/
;;;1179     if((RCC->CR &RCC_CR_PLLON) == RCC_CR_PLLON)
000062  680a              LDR      r2,[r1,#0]
000064  f0127f80          TST      r2,#0x1000000
;;;1180     {
;;;1181       RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;
000068  bf1a              ITTE     NE
00006a  2202              MOVNE    r2,#2
00006c  61c2              STRNE    r2,[r0,#0x1c]
;;;1182     }
;;;1183     else
;;;1184     {
;;;1185       RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;
00006e  61c3              STREQ    r3,[r0,#0x1c]
;;;1186     }
;;;1187     RCC_OscInitStruct->PLL.PLLSource = (uint32_t)(RCC->CFGR & RCC_CFGR_PLLSRC);
000070  684a              LDR      r2,[r1,#4]
000072  f4023280          AND      r2,r2,#0x10000
;;;1188     RCC_OscInitStruct->PLL.PLLMUL = (uint32_t)(RCC->CFGR & RCC_CFGR_PLLMULL);
000076  6202              STR      r2,[r0,#0x20]
000078  6849              LDR      r1,[r1,#4]
00007a  f4011170          AND      r1,r1,#0x3c0000
00007e  6241              STR      r1,[r0,#0x24]         ;1168
;;;1189   #if defined(RCC_CR_PLL2ON)
;;;1190     /* Get the PLL2 configuration -----------------------------------------------*/
;;;1191     if((RCC->CR &RCC_CR_PLL2ON) == RCC_CR_PLL2ON)
;;;1192     {
;;;1193       RCC_OscInitStruct->PLL2.PLL2State = RCC_PLL2_ON;
;;;1194     }
;;;1195     else
;;;1196     {
;;;1197       RCC_OscInitStruct->PLL2.PLL2State = RCC_PLL2_OFF;
;;;1198     }
;;;1199     RCC_OscInitStruct->PLL2.HSEPrediv2Value = __HAL_RCC_HSE_GET_PREDIV2();
;;;1200     RCC_OscInitStruct->PLL2.PLL2MUL = (uint32_t)(RCC->CFGR2 & RCC_CFGR2_PLL2MUL);
;;;1201   #endif /* RCC_CR_PLL2ON */
;;;1202   }
000080  4770              BX       lr
                  |L8.130|
000082  680b              LDR      r3,[r1,#0]            ;1131
000084  f4133f80          TST      r3,#0x10000           ;1131
000088  bf14              ITE      NE                    ;1133
00008a  f44f3380          MOVNE    r3,#0x10000           ;1133
00008e  6042              STREQ    r2,[r0,#4]            ;1137
000090  d1c2              BNE      |L8.24|
000092  e7c2              B        |L8.26|
                  |L8.148|
000094  f8d1c020          LDR      r12,[r1,#0x20]        ;1158
000098  f01c0f01          TST      r12,#1                ;1158
00009c  bf14              ITE      NE                    ;1160
00009e  60c3              STRNE    r3,[r0,#0xc]          ;1160
0000a0  60c2              STREQ    r2,[r0,#0xc]          ;1164
0000a2  e7d7              B        |L8.84|
;;;1203   
                          ENDP

                  |L8.164|
                          DCD      0x40021000

                          AREA ||i.HAL_RCC_GetPCLK1Freq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetPCLK1Freq PROC
;;;1086     */
;;;1087   uint32_t HAL_RCC_GetPCLK1Freq(void)
000000  4804              LDR      r0,|L9.20|
;;;1088   {
;;;1089     /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
;;;1090     return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
000002  4905              LDR      r1,|L9.24|
000004  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000006  6849              LDR      r1,[r1,#4]
000008  4a04              LDR      r2,|L9.28|
00000a  f3c12102          UBFX     r1,r1,#8,#3
00000e  5c51              LDRB     r1,[r2,r1]
000010  40c8              LSRS     r0,r0,r1
;;;1091   }    
000012  4770              BX       lr
;;;1092   
                          ENDP

                  |L9.20|
                          DCD      SystemCoreClock
                  |L9.24|
                          DCD      0x40021000
                  |L9.28|
                          DCD      APBPrescTable

                          AREA ||i.HAL_RCC_GetPCLK2Freq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetPCLK2Freq PROC
;;;1098     */
;;;1099   uint32_t HAL_RCC_GetPCLK2Freq(void)
000000  4804              LDR      r0,|L10.20|
;;;1100   {
;;;1101     /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
;;;1102     return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
000002  4905              LDR      r1,|L10.24|
000004  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000006  6849              LDR      r1,[r1,#4]
000008  4a04              LDR      r2,|L10.28|
00000a  f3c121c2          UBFX     r1,r1,#11,#3
00000e  5c51              LDRB     r1,[r2,r1]
000010  40c8              LSRS     r0,r0,r1
;;;1103   } 
000012  4770              BX       lr
;;;1104   
                          ENDP

                  |L10.20|
                          DCD      SystemCoreClock
                  |L10.24|
                          DCD      0x40021000
                  |L10.28|
                          DCD      APBPrescTable

                          AREA ||i.HAL_RCC_GetSysClockFreq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetSysClockFreq PROC
;;;981      */
;;;982    uint32_t HAL_RCC_GetSysClockFreq(void)
000000  a314              ADR      r3,|L11.84|
;;;983    {
000002  b086              SUB      sp,sp,#0x18
;;;984    #if defined(RCC_CFGR2_PREDIV1SRC)
;;;985      const uint8_t aPLLMULFactorTable[14] = {0, 0, 4, 5, 6, 7, 8, 9, 0, 0, 0, 0, 0, 13};
;;;986      const uint8_t aPredivFactorTable[16] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};
;;;987    #else
;;;988      const uint8_t aPLLMULFactorTable[16] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 16};
000004  cb0f              LDM      r3,{r0-r3}
000006  e88d000f          STM      sp,{r0-r3}
;;;989    #if defined(RCC_CFGR2_PREDIV1)
;;;990      const uint8_t aPredivFactorTable[16] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};
;;;991    #else
;;;992      const uint8_t aPredivFactorTable[2] = {1, 2};
00000a  a016              ADR      r0,|L11.100|
;;;993    #endif /*RCC_CFGR2_PREDIV1*/
;;;994    
;;;995    #endif
;;;996      uint32_t tmpreg = 0U, prediv = 0U, pllclk = 0U, pllmul = 0U;
;;;997      uint32_t sysclockfreq = 0U;
;;;998    #if defined(RCC_CFGR2_PREDIV1SRC)
;;;999      uint32_t prediv2 = 0U, pll2mul = 0U;
;;;1000   #endif /*RCC_CFGR2_PREDIV1SRC*/
;;;1001     
;;;1002     tmpreg = RCC->CFGR;
00000c  4b16              LDR      r3,|L11.104|
00000e  6800              LDR      r0,[r0,#0]            ;992
000010  9004              STR      r0,[sp,#0x10]
000012  6859              LDR      r1,[r3,#4]
;;;1003     
;;;1004     /* Get SYSCLK source -------------------------------------------------------*/
;;;1005     switch (tmpreg & RCC_CFGR_SWS)
;;;1006     {
;;;1007       case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock */
;;;1008       {
;;;1009         sysclockfreq = HSE_VALUE;
000014  4815              LDR      r0,|L11.108|
000016  f001020c          AND      r2,r1,#0xc            ;1005
00001a  2a04              CMP      r2,#4                 ;1005
;;;1010         break;
;;;1011       }
;;;1012       case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock */
;;;1013       {
;;;1014         pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMULL) >> RCC_CFGR_PLLMULL_Pos];
;;;1015         if ((tmpreg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
;;;1016         {
;;;1017   #if defined(RCC_CFGR2_PREDIV1)
;;;1018           prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV1) >> RCC_CFGR2_PREDIV1_Pos];
;;;1019   #else
;;;1020           prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR & RCC_CFGR_PLLXTPRE) >> RCC_CFGR_PLLXTPRE_Pos];
;;;1021   #endif /*RCC_CFGR2_PREDIV1*/
;;;1022   #if defined(RCC_CFGR2_PREDIV1SRC)
;;;1023   
;;;1024           if(HAL_IS_BIT_SET(RCC->CFGR2, RCC_CFGR2_PREDIV1SRC))
;;;1025           {
;;;1026             /* PLL2 selected as Prediv1 source */
;;;1027             /* PLLCLK = PLL2CLK / PREDIV1 * PLLMUL with PLL2CLK = HSE/PREDIV2 * PLL2MUL */
;;;1028             prediv2 = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> RCC_CFGR2_PREDIV2_Pos) + 1;
;;;1029             pll2mul = ((RCC->CFGR2 & RCC_CFGR2_PLL2MUL) >> RCC_CFGR2_PLL2MUL_Pos) + 2;
;;;1030             pllclk = (uint32_t)((((HSE_VALUE / prediv2) * pll2mul) / prediv) * pllmul);
;;;1031           }
;;;1032           else
;;;1033           {
;;;1034             /* HSE used as PLL clock source : PLLCLK = HSE/PREDIV1 * PLLMUL */
;;;1035             pllclk = (uint32_t)((HSE_VALUE / prediv) * pllmul);
;;;1036           }
;;;1037           
;;;1038           /* If PLLMUL was set to 13 means that it was to cover the case PLLMUL 6.5 (avoid using float) */
;;;1039           /* In this case need to divide pllclk by 2 */
;;;1040           if (pllmul == aPLLMULFactorTable[(uint32_t)(RCC_CFGR_PLLMULL6_5) >> RCC_CFGR_PLLMULL_Pos])
;;;1041           {
;;;1042               pllclk = pllclk / 2;
;;;1043           }
;;;1044   #else
;;;1045           /* HSE used as PLL clock source : PLLCLK = HSE/PREDIV1 * PLLMUL */
;;;1046           pllclk = (uint32_t)((HSE_VALUE / prediv) * pllmul);
;;;1047   #endif /*RCC_CFGR2_PREDIV1SRC*/
;;;1048         }
;;;1049         else
;;;1050         {
;;;1051           /* HSI used as PLL clock source : PLLCLK = HSI/2 * PLLMUL */
;;;1052           pllclk = (uint32_t)((HSI_VALUE >> 1) * pllmul);
;;;1053         }
;;;1054         sysclockfreq = pllclk;
;;;1055         break;
;;;1056       }
;;;1057       case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
;;;1058       default: /* HSI used as system clock */
;;;1059       {
;;;1060         sysclockfreq = HSI_VALUE;
;;;1061         break;
;;;1062       }
;;;1063     }
;;;1064     return sysclockfreq;
;;;1065   }
00001c  bf04              ITT      EQ
00001e  b006              ADDEQ    sp,sp,#0x18
000020  4770              BXEQ     lr
000022  2a08              CMP      r2,#8                 ;1005
000024  bf1c              ITT      NE
000026  b006              ADDNE    sp,sp,#0x18
000028  4770              BXNE     lr
00002a  f3c14c83          UBFX     r12,r1,#18,#4         ;1014
00002e  f4113f80          TST      r1,#0x10000           ;1015
000032  f81d200c          LDRB     r2,[sp,r12]           ;1014
000036  bf01              ITTTT    EQ                    ;1052
000038  480d              LDREQ    r0,|L11.112|
00003a  4350              MULEQ    r0,r2,r0              ;1052
00003c  b006              ADDEQ    sp,sp,#0x18
00003e  4770              BXEQ     lr
000040  6859              LDR      r1,[r3,#4]            ;1020
000042  ab04              ADD      r3,sp,#0x10           ;1020
000044  f3c14140          UBFX     r1,r1,#17,#1          ;1020
000048  5c59              LDRB     r1,[r3,r1]            ;1020
00004a  b006              ADD      sp,sp,#0x18
00004c  fbb0f0f1          UDIV     r0,r0,r1              ;1046
000050  4350              MULS     r0,r2,r0              ;1046
000052  4770              BX       lr
;;;1066   
                          ENDP

                  |L11.84|
000054  02030405          DCB      2,3,4,5,6,"\a\b\t\n\v\f\r",14,15,16,16
000058  06070809
00005c  0a0b0c0d
000060  0e0f1010
                  |L11.100|
000064  010200            DCB      1,2,0
000067  00                DCB      0
                  |L11.104|
                          DCD      0x40021000
                  |L11.108|
                          DCD      0x007a1200
                  |L11.112|
                          DCD      0x003d0900

                          AREA ||i.HAL_RCC_MCOConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_MCOConfig PROC
;;;901      */
;;;902    void HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
000000  b530              PUSH     {r4,r5,lr}
;;;903    {
000002  b085              SUB      sp,sp,#0x14
;;;904      GPIO_InitTypeDef gpio = {0U};
000004  2000              MOVS     r0,#0
;;;905    
;;;906      /* Check the parameters */
;;;907      assert_param(IS_RCC_MCO(RCC_MCOx));
;;;908      assert_param(IS_RCC_MCODIV(RCC_MCODiv));
;;;909      assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));
;;;910    
;;;911      /* Prevent unused argument(s) compilation warning */
;;;912      UNUSED(RCC_MCOx);
;;;913      UNUSED(RCC_MCODiv);
;;;914    
;;;915      /* Configure the MCO1 pin in alternate function mode */
;;;916      gpio.Mode      = GPIO_MODE_AF_PP;
000006  9002              STR      r0,[sp,#8]
000008  2002              MOVS     r0,#2
;;;917      gpio.Speed     = GPIO_SPEED_FREQ_HIGH;
00000a  9001              STR      r0,[sp,#4]
00000c  2003              MOVS     r0,#3
;;;918      gpio.Pull      = GPIO_NOPULL;
;;;919      gpio.Pin       = MCO1_PIN;
00000e  9003              STR      r0,[sp,#0xc]
;;;920    
;;;921      /* MCO1 Clock Enable */
;;;922      MCO1_CLK_ENABLE();
000010  4c0b              LDR      r4,|L12.64|
000012  f44f7080          MOV      r0,#0x100             ;919
000016  9000              STR      r0,[sp,#0]
000018  69a0              LDR      r0,[r4,#0x18]
00001a  460d              MOV      r5,r1                 ;903
00001c  f0400004          ORR      r0,r0,#4
000020  61a0              STR      r0,[r4,#0x18]
000022  69a0              LDR      r0,[r4,#0x18]
;;;923    
;;;924      HAL_GPIO_Init(MCO1_GPIO_PORT, &gpio);
000024  4669              MOV      r1,sp
000026  f0000004          AND      r0,r0,#4              ;922
00002a  9004              STR      r0,[sp,#0x10]
00002c  4805              LDR      r0,|L12.68|
00002e  f7fffffe          BL       HAL_GPIO_Init
;;;925    
;;;926      /* Configure the MCO clock source */
;;;927      __HAL_RCC_MCO1_CONFIG(RCC_MCOSource, RCC_MCODiv);
000032  6860              LDR      r0,[r4,#4]
000034  f02060e0          BIC      r0,r0,#0x7000000
000038  4328              ORRS     r0,r0,r5
00003a  6060              STR      r0,[r4,#4]
;;;928    }
00003c  b005              ADD      sp,sp,#0x14
00003e  bd30              POP      {r4,r5,pc}
;;;929    
                          ENDP

                  |L12.64|
                          DCD      0x40021000
                  |L12.68|
                          DCD      0x40010800

                          AREA ||i.HAL_RCC_NMI_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_RCC_NMI_IRQHandler PROC
;;;1246     */
;;;1247   void HAL_RCC_NMI_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1248   {
;;;1249     /* Check RCC CSSF flag  */
;;;1250     if(__HAL_RCC_GET_IT(RCC_IT_CSS))
000002  4c05              LDR      r4,|L13.24|
000004  68a0              LDR      r0,[r4,#8]
000006  f0100f80          TST      r0,#0x80
;;;1251     {
;;;1252       /* RCC Clock Security System interrupt user callback */
;;;1253       HAL_RCC_CSSCallback();
;;;1254       
;;;1255       /* Clear RCC CSS pending bit */
;;;1256       __HAL_RCC_CLEAR_IT(RCC_IT_CSS);
;;;1257     }
;;;1258   }
00000a  bf08              IT       EQ
00000c  bd10              POPEQ    {r4,pc}
00000e  f7fffffe          BL       HAL_RCC_CSSCallback
000012  2080              MOVS     r0,#0x80              ;1256
000014  72a0              STRB     r0,[r4,#0xa]          ;1256
000016  bd10              POP      {r4,pc}
;;;1259   
                          ENDP

                  |L13.24|
                          DCD      0x40021000

                          AREA ||i.HAL_RCC_OscConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_OscConfig PROC
;;;262      */
;;;263    HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;264    {
000004  4604              MOV      r4,r0
;;;265       uint32_t tickstart = 0U;
;;;266      
;;;267      /* Check the parameters */
;;;268      assert_param(RCC_OscInitStruct != NULL);
;;;269      assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
;;;270      
;;;271      /*------------------------------- HSE Configuration ------------------------*/ 
;;;272      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
000006  7800              LDRB     r0,[r0,#0]
;;;273      {
;;;274        /* Check the parameters */
;;;275        assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
;;;276            
;;;277        /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
;;;278        if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
000008  4de0              LDR      r5,|L14.908|
00000a  f0100f01          TST      r0,#1                 ;272
00000e  d059              BEQ      |L14.196|
000010  6868              LDR      r0,[r5,#4]
000012  f000000c          AND      r0,r0,#0xc
000016  2804              CMP      r0,#4
000018  d008              BEQ      |L14.44|
00001a  6868              LDR      r0,[r5,#4]
00001c  f000000c          AND      r0,r0,#0xc
000020  2808              CMP      r0,#8
000022  d10c              BNE      |L14.62|
000024  6868              LDR      r0,[r5,#4]
000026  f4103f80          TST      r0,#0x10000
00002a  d008              BEQ      |L14.62|
                  |L14.44|
;;;279           || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
;;;280        {
;;;281          if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
00002c  6828              LDR      r0,[r5,#0]
00002e  f4103f00          TST      r0,#0x20000
000032  d047              BEQ      |L14.196|
000034  6860              LDR      r0,[r4,#4]
000036  2800              CMP      r0,#0
000038  f00081a5          BEQ.W    |L14.902|
00003c  e042              B        |L14.196|
                  |L14.62|
;;;282          {
;;;283            return HAL_ERROR;
;;;284          }
;;;285        }
;;;286        else
;;;287        {
;;;288          /* Set the new HSE configuration ---------------------------------------*/
;;;289          __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
00003e  6860              LDR      r0,[r4,#4]
000040  f5b03f80          CMP      r0,#0x10000
000044  bf04              ITT      EQ
000046  6828              LDREQ    r0,[r5,#0]
000048  f4403080          ORREQ    r0,r0,#0x10000
00004c  d00a              BEQ      |L14.100|
00004e  b110              CBZ      r0,|L14.86|
000050  f5b02fa0          CMP      r0,#0x50000
000054  d011              BEQ      |L14.122|
                  |L14.86|
000056  6828              LDR      r0,[r5,#0]
000058  f4203080          BIC      r0,r0,#0x10000
00005c  6028              STR      r0,[r5,#0]
00005e  6828              LDR      r0,[r5,#0]
000060  f4202080          BIC      r0,r0,#0x40000
                  |L14.100|
000064  6028              STR      r0,[r5,#0]
;;;290          
;;;291    
;;;292           /* Check the HSE State */
;;;293          if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
000066  6860              LDR      r0,[r4,#4]
000068  b1d0              CBZ      r0,|L14.160|
;;;294          {
;;;295            /* Get Start Tick */
;;;296            tickstart = HAL_GetTick();
00006a  f7fffffe          BL       HAL_GetTick
00006e  4606              MOV      r6,r0
;;;297            
;;;298            /* Wait till HSE is ready */
;;;299            while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
000070  6828              LDR      r0,[r5,#0]
000072  f4103f00          TST      r0,#0x20000
000076  d008              BEQ      |L14.138|
000078  e024              B        |L14.196|
                  |L14.122|
00007a  6828              LDR      r0,[r5,#0]            ;289
00007c  f4402080          ORR      r0,r0,#0x40000        ;289
000080  6028              STR      r0,[r5,#0]            ;289
000082  6828              LDR      r0,[r5,#0]            ;289
000084  f4403080          ORR      r0,r0,#0x10000        ;289
000088  e7ec              B        |L14.100|
                  |L14.138|
;;;300            {
;;;301              if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
00008a  f7fffffe          BL       HAL_GetTick
00008e  1b80              SUBS     r0,r0,r6
000090  2864              CMP      r0,#0x64
000092  f2008136          BHI.W    |L14.770|
;;;302              {
;;;303                return HAL_TIMEOUT;
000096  6828              LDR      r0,[r5,#0]
000098  f4103f00          TST      r0,#0x20000
00009c  d0f5              BEQ      |L14.138|
00009e  e011              B        |L14.196|
                  |L14.160|
;;;304              }
;;;305            }
;;;306          }
;;;307          else
;;;308          {
;;;309            /* Get Start Tick */
;;;310            tickstart = HAL_GetTick();
0000a0  f7fffffe          BL       HAL_GetTick
0000a4  4606              MOV      r6,r0
;;;311            
;;;312            /* Wait till HSE is disabled */
;;;313            while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
0000a6  6828              LDR      r0,[r5,#0]
0000a8  f4103f00          TST      r0,#0x20000
0000ac  d00a              BEQ      |L14.196|
;;;314            {
;;;315               if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
0000ae  bf00              NOP      
                  |L14.176|
0000b0  f7fffffe          BL       HAL_GetTick
0000b4  1b80              SUBS     r0,r0,r6
0000b6  2864              CMP      r0,#0x64
0000b8  f2008123          BHI.W    |L14.770|
;;;316              {
;;;317                return HAL_TIMEOUT;
0000bc  6828              LDR      r0,[r5,#0]
0000be  f4103f00          TST      r0,#0x20000
0000c2  d1f5              BNE      |L14.176|
                  |L14.196|
;;;318              }
;;;319            }
;;;320          }
;;;321        }
;;;322      }
;;;323      /*----------------------------- HSI Configuration --------------------------*/ 
;;;324      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
0000c4  7820              LDRB     r0,[r4,#0]
;;;325      {
;;;326        /* Check the parameters */
;;;327        assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
;;;328        assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
;;;329        
;;;330        /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
;;;331        if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
;;;332           || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI_DIV2)))
;;;333        {
;;;334          /* When HSI is used as system clock it will not disabled */
;;;335          if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
;;;336          {
;;;337            return HAL_ERROR;
;;;338          }
;;;339          /* Otherwise, just the calibration is allowed */
;;;340          else
;;;341          {
;;;342            /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
;;;343            __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
;;;344          }
;;;345        }
;;;346        else
;;;347        {
;;;348          /* Check the HSI State */
;;;349          if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
;;;350          {
;;;351           /* Enable the Internal High Speed oscillator (HSI). */
;;;352            __HAL_RCC_HSI_ENABLE();
0000c6  4eb2              LDR      r6,|L14.912|
0000c8  f0100f02          TST      r0,#2                 ;324
0000cc  f04f0b01          MOV      r11,#1                ;283
0000d0  f04f0800          MOV      r8,#0                 ;283
0000d4  d045              BEQ      |L14.354|
0000d6  6868              LDR      r0,[r5,#4]            ;331
0000d8  f0100f0c          TST      r0,#0xc               ;331
0000dc  d014              BEQ      |L14.264|
0000de  6868              LDR      r0,[r5,#4]            ;331
0000e0  f000000c          AND      r0,r0,#0xc            ;331
0000e4  2808              CMP      r0,#8                 ;331
0000e6  bf04              ITT      EQ                    ;331
0000e8  6868              LDREQ    r0,[r5,#4]            ;331
0000ea  f4103f80          TSTEQ    r0,#0x10000           ;331
0000ee  d00b              BEQ      |L14.264|
0000f0  6920              LDR      r0,[r4,#0x10]         ;349
0000f2  b318              CBZ      r0,|L14.316|
0000f4  f8c6b000          STR      r11,[r6,#0]
;;;353            
;;;354            /* Get Start Tick */
;;;355            tickstart = HAL_GetTick();
0000f8  f7fffffe          BL       HAL_GetTick
0000fc  4607              MOV      r7,r0
;;;356            
;;;357            /* Wait till HSI is ready */
;;;358            while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
0000fe  6828              LDR      r0,[r5,#0]
000100  f0100f02          TST      r0,#2
000104  d009              BEQ      |L14.282|
000106  e011              B        |L14.300|
                  |L14.264|
000108  6828              LDR      r0,[r5,#0]            ;335
00010a  f0100f02          TST      r0,#2                 ;335
00010e  bf1c              ITT      NE                    ;335
000110  6920              LDRNE    r0,[r4,#0x10]         ;335
000112  2801              CMPNE    r0,#1                 ;335
000114  d00a              BEQ      |L14.300|
000116  f000b936          B.W      |L14.902|
                  |L14.282|
;;;359            {
;;;360              if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
00011a  f7fffffe          BL       HAL_GetTick
00011e  1bc0              SUBS     r0,r0,r7
000120  2802              CMP      r0,#2
000122  d87d              BHI      |L14.544|
;;;361              {
;;;362                return HAL_TIMEOUT;
000124  6828              LDR      r0,[r5,#0]
000126  f0100f02          TST      r0,#2
00012a  d0f6              BEQ      |L14.282|
                  |L14.300|
;;;363              }
;;;364            }
;;;365                    
;;;366            /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
;;;367            __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
00012c  6828              LDR      r0,[r5,#0]
00012e  6961              LDR      r1,[r4,#0x14]
000130  f02000f8          BIC      r0,r0,#0xf8
000134  ea4000c1          ORR      r0,r0,r1,LSL #3
000138  6028              STR      r0,[r5,#0]
00013a  e012              B        |L14.354|
                  |L14.316|
;;;368          }
;;;369          else
;;;370          {
;;;371            /* Disable the Internal High Speed oscillator (HSI). */
;;;372            __HAL_RCC_HSI_DISABLE();
00013c  f8c68000          STR      r8,[r6,#0]
;;;373            
;;;374            /* Get Start Tick */
;;;375            tickstart = HAL_GetTick();
000140  f7fffffe          BL       HAL_GetTick
000144  4607              MOV      r7,r0
;;;376            
;;;377            /* Wait till HSI is disabled */
;;;378            while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
000146  6828              LDR      r0,[r5,#0]
000148  f0100f02          TST      r0,#2
00014c  d009              BEQ      |L14.354|
;;;379            {
;;;380              if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
00014e  bf00              NOP      
                  |L14.336|
000150  f7fffffe          BL       HAL_GetTick
000154  1bc0              SUBS     r0,r0,r7
000156  2802              CMP      r0,#2
000158  d862              BHI      |L14.544|
;;;381              {
;;;382                return HAL_TIMEOUT;
00015a  6828              LDR      r0,[r5,#0]
00015c  f0100f02          TST      r0,#2
000160  d1f6              BNE      |L14.336|
                  |L14.354|
;;;383              }
;;;384            }
;;;385          }
;;;386        }
;;;387      }
;;;388      /*------------------------------ LSI Configuration -------------------------*/ 
;;;389      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
000162  7820              LDRB     r0,[r4,#0]
000164  f0100f08          TST      r0,#8
000168  d035              BEQ      |L14.470|
;;;390      {
;;;391        /* Check the parameters */
;;;392        assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
;;;393        
;;;394        /* Check the LSI State */
;;;395        if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
;;;396        {
;;;397          /* Enable the Internal Low Speed oscillator (LSI). */
;;;398          __HAL_RCC_LSI_ENABLE();
00016a  488a              LDR      r0,|L14.916|
00016c  69a1              LDR      r1,[r4,#0x18]         ;395
00016e  b1f9              CBZ      r1,|L14.432|
000170  f8c0b000          STR      r11,[r0,#0]
;;;399          
;;;400          /* Get Start Tick */
;;;401          tickstart = HAL_GetTick();
000174  f7fffffe          BL       HAL_GetTick
000178  4607              MOV      r7,r0
;;;402          
;;;403          /* Wait till LSI is ready */  
;;;404          while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
00017a  6a68              LDR      r0,[r5,#0x24]
00017c  f0100f02          TST      r0,#2
000180  d109              BNE      |L14.406|
;;;405          {
;;;406            if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
000182  bf00              NOP      
                  |L14.388|
000184  f7fffffe          BL       HAL_GetTick
000188  1bc0              SUBS     r0,r0,r7
00018a  2802              CMP      r0,#2
00018c  d848              BHI      |L14.544|
;;;407            {
;;;408              return HAL_TIMEOUT;
00018e  6a68              LDR      r0,[r5,#0x24]
000190  f0100f02          TST      r0,#2
000194  d0f6              BEQ      |L14.388|
                  |L14.406|
000196  4880              LDR      r0,|L14.920|
000198  f44f51fa          MOV      r1,#0x1f40
00019c  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00019e  fbb0f0f1          UDIV     r0,r0,r1
0001a2  9000              STR      r0,[sp,#0]
                  |L14.420|
0001a4  bf00              NOP      
0001a6  9800              LDR      r0,[sp,#0]
0001a8  1e41              SUBS     r1,r0,#1
0001aa  9100              STR      r1,[sp,#0]
0001ac  d2fa              BCS      |L14.420|
0001ae  e012              B        |L14.470|
                  |L14.432|
;;;409            }
;;;410          }
;;;411          /*  To have a fully stabilized clock in the specified range, a software delay of 1ms 
;;;412              should be added.*/
;;;413          RCC_Delay(1);
;;;414        }
;;;415        else
;;;416        {
;;;417          /* Disable the Internal Low Speed oscillator (LSI). */
;;;418          __HAL_RCC_LSI_DISABLE();
0001b0  f8c08000          STR      r8,[r0,#0]
;;;419          
;;;420          /* Get Start Tick */
;;;421          tickstart = HAL_GetTick();
0001b4  f7fffffe          BL       HAL_GetTick
0001b8  4607              MOV      r7,r0
;;;422          
;;;423          /* Wait till LSI is disabled */  
;;;424          while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
0001ba  6a68              LDR      r0,[r5,#0x24]
0001bc  f0100f02          TST      r0,#2
0001c0  d009              BEQ      |L14.470|
;;;425          {
;;;426            if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
0001c2  bf00              NOP      
                  |L14.452|
0001c4  f7fffffe          BL       HAL_GetTick
0001c8  1bc0              SUBS     r0,r0,r7
0001ca  2802              CMP      r0,#2
0001cc  d828              BHI      |L14.544|
;;;427            {
;;;428              return HAL_TIMEOUT;
0001ce  6a68              LDR      r0,[r5,#0x24]
0001d0  f0100f02          TST      r0,#2
0001d4  d1f6              BNE      |L14.452|
                  |L14.470|
;;;429            }
;;;430          }
;;;431        }
;;;432      }
;;;433      /*------------------------------ LSE Configuration -------------------------*/ 
;;;434      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
0001d6  7820              LDRB     r0,[r4,#0]
0001d8  f0100f04          TST      r0,#4
0001dc  d079              BEQ      |L14.722|
;;;435      {
;;;436        FlagStatus       pwrclkchanged = RESET;
;;;437        
;;;438        /* Check the parameters */
;;;439        assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
;;;440    
;;;441        /* Update LSE configuration in Backup Domain control register    */
;;;442        /* Requires to enable write access to Backup Domain of necessary */
;;;443        if(__HAL_RCC_PWR_IS_CLK_DISABLED())
0001de  69e8              LDR      r0,[r5,#0x1c]
0001e0  f04f0a00          MOV      r10,#0                ;436
0001e4  f0105f80          TST      r0,#0x10000000
0001e8  d109              BNE      |L14.510|
;;;444        {
;;;445          __HAL_RCC_PWR_CLK_ENABLE();
0001ea  69e8              LDR      r0,[r5,#0x1c]
0001ec  f0405080          ORR      r0,r0,#0x10000000
0001f0  61e8              STR      r0,[r5,#0x1c]
0001f2  69e8              LDR      r0,[r5,#0x1c]
;;;446          pwrclkchanged = SET;
0001f4  f04f0a01          MOV      r10,#1
0001f8  f0005080          AND      r0,r0,#0x10000000     ;445
0001fc  9000              STR      r0,[sp,#0]
                  |L14.510|
;;;447        }
;;;448        
;;;449        if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
0001fe  f8df919c          LDR      r9,|L14.924|
000202  f8d90000          LDR      r0,[r9,#0]
000206  f4107f80          TST      r0,#0x100
00020a  d119              BNE      |L14.576|
;;;450        {
;;;451          /* Enable write access to Backup domain */
;;;452          SET_BIT(PWR->CR, PWR_CR_DBP);
00020c  f8d90000          LDR      r0,[r9,#0]
000210  f4407080          ORR      r0,r0,#0x100
000214  f8c90000          STR      r0,[r9,#0]
;;;453          
;;;454          /* Wait for Backup domain Write protection disable */
;;;455          tickstart = HAL_GetTick();
000218  f7fffffe          BL       HAL_GetTick
00021c  4607              MOV      r7,r0
;;;456    
;;;457          while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
00021e  e000              B        |L14.546|
                  |L14.544|
000220  e06f              B        |L14.770|
                  |L14.546|
000222  f8d90000          LDR      r0,[r9,#0]
000226  f4107f80          TST      r0,#0x100
00022a  d109              BNE      |L14.576|
                  |L14.556|
;;;458          {
;;;459            if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
00022c  f7fffffe          BL       HAL_GetTick
000230  1bc0              SUBS     r0,r0,r7
000232  2864              CMP      r0,#0x64
000234  d865              BHI      |L14.770|
;;;460            {
;;;461              return HAL_TIMEOUT;
000236  f8d90000          LDR      r0,[r9,#0]
00023a  f4107f80          TST      r0,#0x100
00023e  d0f5              BEQ      |L14.556|
                  |L14.576|
;;;462            }
;;;463          }
;;;464        }
;;;465    
;;;466        /* Set the new LSE configuration -----------------------------------------*/
;;;467        __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
000240  68e0              LDR      r0,[r4,#0xc]
000242  2801              CMP      r0,#1
000244  bf04              ITT      EQ
000246  6a28              LDREQ    r0,[r5,#0x20]
000248  f0400001          ORREQ    r0,r0,#1
00024c  d009              BEQ      |L14.610|
00024e  b108              CBZ      r0,|L14.596|
000250  2805              CMP      r0,#5
000252  d013              BEQ      |L14.636|
                  |L14.596|
000254  6a28              LDR      r0,[r5,#0x20]
000256  f0200001          BIC      r0,r0,#1
00025a  6228              STR      r0,[r5,#0x20]
00025c  6a28              LDR      r0,[r5,#0x20]
00025e  f0200004          BIC      r0,r0,#4
                  |L14.610|
000262  6228              STR      r0,[r5,#0x20]
;;;468        /* Check the LSE State */
;;;469        if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
;;;470        {
;;;471          /* Get Start Tick */
;;;472          tickstart = HAL_GetTick();
;;;473          
;;;474          /* Wait till LSE is ready */  
;;;475          while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
;;;476          {
;;;477            if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
000264  68e0              LDR      r0,[r4,#0xc]
000266  f2413788          MOV      r7,#0x1388
00026a  b1d0              CBZ      r0,|L14.674|
00026c  f7fffffe          BL       HAL_GetTick
000270  4681              MOV      r9,r0                 ;472
000272  6a28              LDR      r0,[r5,#0x20]         ;475
000274  f0100f02          TST      r0,#2                 ;475
000278  d008              BEQ      |L14.652|
00027a  e023              B        |L14.708|
                  |L14.636|
00027c  6a28              LDR      r0,[r5,#0x20]         ;467
00027e  f0400004          ORR      r0,r0,#4              ;467
000282  6228              STR      r0,[r5,#0x20]         ;467
000284  6a28              LDR      r0,[r5,#0x20]         ;467
000286  f0400001          ORR      r0,r0,#1              ;467
00028a  e7ea              B        |L14.610|
                  |L14.652|
00028c  f7fffffe          BL       HAL_GetTick
000290  eba00009          SUB      r0,r0,r9
000294  42b8              CMP      r0,r7
000296  d834              BHI      |L14.770|
;;;478            {
;;;479              return HAL_TIMEOUT;
000298  6a28              LDR      r0,[r5,#0x20]
00029a  f0100f02          TST      r0,#2
00029e  d0f5              BEQ      |L14.652|
0002a0  e010              B        |L14.708|
                  |L14.674|
;;;480            }
;;;481          }
;;;482        }
;;;483        else
;;;484        {
;;;485          /* Get Start Tick */
;;;486          tickstart = HAL_GetTick();
0002a2  f7fffffe          BL       HAL_GetTick
0002a6  4681              MOV      r9,r0
;;;487          
;;;488          /* Wait till LSE is disabled */  
;;;489          while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
0002a8  6a28              LDR      r0,[r5,#0x20]
0002aa  f0100f02          TST      r0,#2
0002ae  d009              BEQ      |L14.708|
                  |L14.688|
;;;490          {
;;;491            if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
0002b0  f7fffffe          BL       HAL_GetTick
0002b4  eba00009          SUB      r0,r0,r9
0002b8  42b8              CMP      r0,r7
0002ba  d822              BHI      |L14.770|
;;;492            {
;;;493              return HAL_TIMEOUT;
0002bc  6a28              LDR      r0,[r5,#0x20]
0002be  f0100f02          TST      r0,#2
0002c2  d1f5              BNE      |L14.688|
                  |L14.708|
;;;494            }
;;;495          }
;;;496        }
;;;497    
;;;498        /* Require to disable power clock if necessary */
;;;499        if(pwrclkchanged == SET)
0002c4  f1ba0f00          CMP      r10,#0
0002c8  d003              BEQ      |L14.722|
;;;500        {
;;;501          __HAL_RCC_PWR_CLK_DISABLE();
0002ca  69e8              LDR      r0,[r5,#0x1c]
0002cc  f0205080          BIC      r0,r0,#0x10000000
0002d0  61e8              STR      r0,[r5,#0x1c]
                  |L14.722|
;;;502        }
;;;503      }
;;;504    
;;;505    #if defined(RCC_CR_PLL2ON)
;;;506      /*-------------------------------- PLL2 Configuration -----------------------*/
;;;507      /* Check the parameters */
;;;508      assert_param(IS_RCC_PLL2(RCC_OscInitStruct->PLL2.PLL2State));
;;;509      if ((RCC_OscInitStruct->PLL2.PLL2State) != RCC_PLL2_NONE)
;;;510      {
;;;511        /* This bit can not be cleared if the PLL2 clock is used indirectly as system 
;;;512          clock (i.e. it is used as PLL clock entry that is used as system clock). */
;;;513        if((__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE) && \
;;;514            (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && \
;;;515            ((READ_BIT(RCC->CFGR2,RCC_CFGR2_PREDIV1SRC)) == RCC_CFGR2_PREDIV1SRC_PLL2))
;;;516        {
;;;517          return HAL_ERROR;
;;;518        }
;;;519        else
;;;520        {
;;;521          if((RCC_OscInitStruct->PLL2.PLL2State) == RCC_PLL2_ON)
;;;522          {
;;;523            /* Check the parameters */
;;;524            assert_param(IS_RCC_PLL2_MUL(RCC_OscInitStruct->PLL2.PLL2MUL));
;;;525            assert_param(IS_RCC_HSE_PREDIV2(RCC_OscInitStruct->PLL2.HSEPrediv2Value));
;;;526    
;;;527            /* Prediv2 can be written only when the PLLI2S is disabled. */
;;;528            /* Return an error only if new value is different from the programmed value */
;;;529            if (HAL_IS_BIT_SET(RCC->CR,RCC_CR_PLL3ON) && \
;;;530              (__HAL_RCC_HSE_GET_PREDIV2() != RCC_OscInitStruct->PLL2.HSEPrediv2Value))
;;;531            {
;;;532              return HAL_ERROR;
;;;533            }
;;;534            
;;;535            /* Disable the main PLL2. */
;;;536            __HAL_RCC_PLL2_DISABLE();
;;;537            
;;;538            /* Get Start Tick */
;;;539            tickstart = HAL_GetTick();
;;;540            
;;;541            /* Wait till PLL2 is disabled */
;;;542            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != RESET)
;;;543            {
;;;544              if((HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
;;;545              {
;;;546                return HAL_TIMEOUT;
;;;547              }
;;;548            }
;;;549            
;;;550            /* Configure the HSE prediv2 factor --------------------------------*/
;;;551            __HAL_RCC_HSE_PREDIV2_CONFIG(RCC_OscInitStruct->PLL2.HSEPrediv2Value);
;;;552    
;;;553            /* Configure the main PLL2 multiplication factors. */
;;;554            __HAL_RCC_PLL2_CONFIG(RCC_OscInitStruct->PLL2.PLL2MUL);
;;;555            
;;;556            /* Enable the main PLL2. */
;;;557            __HAL_RCC_PLL2_ENABLE();
;;;558            
;;;559            /* Get Start Tick */
;;;560            tickstart = HAL_GetTick();
;;;561            
;;;562            /* Wait till PLL2 is ready */
;;;563            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY)  == RESET)
;;;564            {
;;;565              if((HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
;;;566              {
;;;567                return HAL_TIMEOUT;
;;;568              }
;;;569            }
;;;570          }
;;;571          else
;;;572          {
;;;573           /* Set PREDIV1 source to HSE */
;;;574            CLEAR_BIT(RCC->CFGR2, RCC_CFGR2_PREDIV1SRC);
;;;575    
;;;576            /* Disable the main PLL2. */
;;;577            __HAL_RCC_PLL2_DISABLE();
;;;578     
;;;579            /* Get Start Tick */
;;;580            tickstart = HAL_GetTick();
;;;581            
;;;582            /* Wait till PLL2 is disabled */  
;;;583            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY)  != RESET)
;;;584            {
;;;585              if((HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
;;;586              {
;;;587                return HAL_TIMEOUT;
;;;588              }
;;;589            }
;;;590          }
;;;591        }
;;;592      }
;;;593    
;;;594    #endif /* RCC_CR_PLL2ON */
;;;595      /*-------------------------------- PLL Configuration -----------------------*/
;;;596      /* Check the parameters */
;;;597      assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
;;;598      if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
0002d2  69e0              LDR      r0,[r4,#0x1c]
0002d4  b3f0              CBZ      r0,|L14.852|
;;;599      {
;;;600        /* Check if the PLL is used as system clock or not */
;;;601        if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
0002d6  6869              LDR      r1,[r5,#4]
0002d8  f001010c          AND      r1,r1,#0xc
0002dc  2908              CMP      r1,#8
0002de  d052              BEQ      |L14.902|
;;;602        { 
;;;603          if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
0002e0  2802              CMP      r0,#2
;;;604          {
;;;605            /* Check the parameters */
;;;606            assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
;;;607            assert_param(IS_RCC_PLL_MUL(RCC_OscInitStruct->PLL.PLLMUL));
;;;608      
;;;609            /* Disable the main PLL. */
;;;610            __HAL_RCC_PLL_DISABLE();
;;;611            
;;;612            /* Get Start Tick */
;;;613            tickstart = HAL_GetTick();
;;;614            
;;;615            /* Wait till PLL is disabled */
;;;616            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
;;;617            {
;;;618              if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
;;;619              {
;;;620                return HAL_TIMEOUT;
;;;621              }
;;;622            }
;;;623    
;;;624            /* Configure the HSE prediv factor --------------------------------*/
;;;625            /* It can be written only when the PLL is disabled. Not used in PLL source is different than HSE */
;;;626            if(RCC_OscInitStruct->PLL.PLLSource == RCC_PLLSOURCE_HSE)
;;;627            {
;;;628              /* Check the parameter */
;;;629              assert_param(IS_RCC_HSE_PREDIV(RCC_OscInitStruct->HSEPredivValue));
;;;630    #if defined(RCC_CFGR2_PREDIV1SRC)
;;;631              assert_param(IS_RCC_PREDIV1_SOURCE(RCC_OscInitStruct->Prediv1Source));
;;;632              
;;;633              /* Set PREDIV1 source */
;;;634              SET_BIT(RCC->CFGR2, RCC_OscInitStruct->Prediv1Source);
;;;635    #endif /* RCC_CFGR2_PREDIV1SRC */
;;;636    
;;;637              /* Set PREDIV1 Value */
;;;638              __HAL_RCC_HSE_PREDIV_CONFIG(RCC_OscInitStruct->HSEPredivValue);
;;;639            }
;;;640    
;;;641            /* Configure the main PLL clock source and multiplication factors. */
;;;642            __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
;;;643                                 RCC_OscInitStruct->PLL.PLLMUL);
;;;644            /* Enable the main PLL. */
;;;645            __HAL_RCC_PLL_ENABLE();
;;;646            
;;;647            /* Get Start Tick */
;;;648            tickstart = HAL_GetTick();
;;;649            
;;;650            /* Wait till PLL is ready */
;;;651            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
;;;652            {
;;;653              if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
;;;654              {
;;;655                return HAL_TIMEOUT;
;;;656              }
;;;657            }
;;;658          }
;;;659          else
;;;660          {
;;;661            /* Disable the main PLL. */
;;;662            __HAL_RCC_PLL_DISABLE();
0002e2  f8c68060          STR      r8,[r6,#0x60]
0002e6  d00f              BEQ      |L14.776|
;;;663     
;;;664            /* Get Start Tick */
;;;665            tickstart = HAL_GetTick();
0002e8  f7fffffe          BL       HAL_GetTick
0002ec  4604              MOV      r4,r0
;;;666            
;;;667            /* Wait till PLL is disabled */  
;;;668            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
0002ee  6828              LDR      r0,[r5,#0]
0002f0  f0107f00          TST      r0,#0x2000000
0002f4  d044              BEQ      |L14.896|
;;;669            {
;;;670              if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
0002f6  bf00              NOP      
                  |L14.760|
0002f8  f7fffffe          BL       HAL_GetTick
0002fc  1b00              SUBS     r0,r0,r4
0002fe  2802              CMP      r0,#2
000300  d93a              BLS      |L14.888|
                  |L14.770|
;;;671              {
;;;672                return HAL_TIMEOUT;
000302  2003              MOVS     r0,#3
;;;673              }
;;;674            }
;;;675          }
;;;676        }
;;;677        else
;;;678        {
;;;679          return HAL_ERROR;
;;;680        }
;;;681      }
;;;682      
;;;683      return HAL_OK;
;;;684    }
000304  e8bd8ff8          POP      {r3-r11,pc}
                  |L14.776|
000308  f7fffffe          BL       HAL_GetTick
00030c  4607              MOV      r7,r0                 ;613
00030e  6828              LDR      r0,[r5,#0]            ;616
000310  f0107f00          TST      r0,#0x2000000         ;616
000314  d009              BEQ      |L14.810|
000316  bf00              NOP                            ;618
                  |L14.792|
000318  f7fffffe          BL       HAL_GetTick
00031c  1bc0              SUBS     r0,r0,r7              ;618
00031e  2802              CMP      r0,#2                 ;618
000320  d8ef              BHI      |L14.770|
000322  6828              LDR      r0,[r5,#0]            ;620
000324  f0107f00          TST      r0,#0x2000000         ;620
000328  d1f6              BNE      |L14.792|
                  |L14.810|
00032a  6a20              LDR      r0,[r4,#0x20]         ;626
00032c  f5b03f80          CMP      r0,#0x10000           ;626
000330  d105              BNE      |L14.830|
000332  6868              LDR      r0,[r5,#4]            ;638
000334  68a1              LDR      r1,[r4,#8]            ;638
000336  f4203000          BIC      r0,r0,#0x20000        ;638
00033a  4308              ORRS     r0,r0,r1              ;638
00033c  6068              STR      r0,[r5,#4]            ;638
                  |L14.830|
00033e  e9d40108          LDRD     r0,r1,[r4,#0x20]      ;638
000342  4308              ORRS     r0,r0,r1              ;642
000344  6869              LDR      r1,[r5,#4]            ;642
000346  f4211174          BIC      r1,r1,#0x3d0000       ;642
00034a  4308              ORRS     r0,r0,r1              ;642
00034c  6068              STR      r0,[r5,#4]            ;642
00034e  f8c6b060          STR      r11,[r6,#0x60]        ;645
000352  e000              B        |L14.854|
                  |L14.852|
000354  e014              B        |L14.896|
                  |L14.854|
000356  f7fffffe          BL       HAL_GetTick
00035a  4604              MOV      r4,r0                 ;648
00035c  6828              LDR      r0,[r5,#0]            ;651
00035e  f0107f00          TST      r0,#0x2000000         ;651
000362  d10d              BNE      |L14.896|
                  |L14.868|
000364  f7fffffe          BL       HAL_GetTick
000368  1b00              SUBS     r0,r0,r4              ;653
00036a  2802              CMP      r0,#2                 ;653
00036c  d8c9              BHI      |L14.770|
00036e  6828              LDR      r0,[r5,#0]            ;655
000370  f0107f00          TST      r0,#0x2000000         ;655
000374  d0f6              BEQ      |L14.868|
000376  e003              B        |L14.896|
                  |L14.888|
000378  6828              LDR      r0,[r5,#0]            ;672
00037a  f0107f00          TST      r0,#0x2000000         ;672
00037e  d1bb              BNE      |L14.760|
                  |L14.896|
000380  2000              MOVS     r0,#0                 ;683
000382  e8bd8ff8          POP      {r3-r11,pc}
                  |L14.902|
000386  2001              MOVS     r0,#1                 ;679
000388  e8bd8ff8          POP      {r3-r11,pc}
;;;685    
                          ENDP

                  |L14.908|
                          DCD      0x40021000
                  |L14.912|
                          DCD      0x42420000
                  |L14.916|
                          DCD      0x42420480
                  |L14.920|
                          DCD      SystemCoreClock
                  |L14.924|
                          DCD      0x40007000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F1_V1.6.0\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_rcc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_rcc_c_b7071a4b____REV16|
#line 388 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F1_V1.6.0\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___19_stm32f1xx_hal_rcc_c_b7071a4b____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_rcc_c_b7071a4b____REVSH|
#line 402
|__asm___19_stm32f1xx_hal_rcc_c_b7071a4b____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_rcc_c_b7071a4b____RRX|
#line 587
|__asm___19_stm32f1xx_hal_rcc_c_b7071a4b____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
