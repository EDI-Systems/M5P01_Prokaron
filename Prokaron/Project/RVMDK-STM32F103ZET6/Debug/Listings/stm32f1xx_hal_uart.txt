; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f1xx_hal_uart.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f1xx_hal_uart.d --cpu=Cortex-M3 --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F1_V1.6.0\Drivers\STM32F1xx_HAL_Driver\Inc -I..\..\..\M0P0_Library\STM32Cube_FW_F1_V1.6.0\Drivers\CMSIS\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F1_V1.6.0\Drivers\CMSIS\Device\ST\STM32F1xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F1_V1.6.0\Drivers\STM32F1xx_HAL_Driver\Inc\Conf -I..\RVMDK-STM32F103ZET6 -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F103ZET6\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F10X_HD -DUSE_HAL_DRIVER -DSTM32F103xE -W --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f1xx_hal_uart.crf ..\..\..\M0P0_Library\STM32Cube_FW_F1_V1.6.0\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_uart.c]
                          THUMB

                          AREA ||i.HAL_HalfDuplex_EnableReceiver||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableReceiver PROC
;;;1941     */
;;;1942   HAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver(UART_HandleTypeDef *huart)
000000  6b81              LDR      r1,[r0,#0x38]
;;;1943   {
;;;1944     uint32_t tmpreg = 0x00U;
;;;1945   
;;;1946     /* Process Locked */
;;;1947     __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;1948   
;;;1949     huart->gState = HAL_UART_STATE_BUSY;
;;;1950   
;;;1951     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;1952     tmpreg = huart->Instance->CR1;
;;;1953   
;;;1954     /* Clear TE and RE bits */
;;;1955     tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_TE | USART_CR1_RE));
;;;1956   
;;;1957     /* Enable the USART's receive interface by setting the RE bit in the USART CR1 register */
;;;1958     tmpreg |= (uint32_t)USART_CR1_RE;
;;;1959   
;;;1960     /* Write to USART CR1 */
;;;1961     WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
;;;1962   
;;;1963     huart->gState = HAL_UART_STATE_READY;
;;;1964   
;;;1965     /* Process Unlocked */
;;;1966     __HAL_UNLOCK(huart);
;;;1967     
;;;1968     return HAL_OK; 
;;;1969   }
000008  4770              BXEQ     lr
00000a  2101              MOVS     r1,#1                 ;1947
00000c  6381              STR      r1,[r0,#0x38]         ;1949
00000e  2124              MOVS     r1,#0x24              ;1949
000010  63c1              STR      r1,[r0,#0x3c]         ;1949
000012  6801              LDR      r1,[r0,#0]            ;1952
000014  68ca              LDR      r2,[r1,#0xc]          ;1952
000016  f022020c          BIC      r2,r2,#0xc            ;1955
00001a  f0420204          ORR      r2,r2,#4              ;1958
00001e  60ca              STR      r2,[r1,#0xc]          ;1961
000020  2120              MOVS     r1,#0x20              ;1963
000022  63c1              STR      r1,[r0,#0x3c]         ;1963
000024  2100              MOVS     r1,#0                 ;1966
000026  6381              STR      r1,[r0,#0x38]         ;1968
000028  4608              MOV      r0,r1                 ;1968
00002a  4770              BX       lr
;;;1970   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_EnableTransmitter||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableTransmitter PROC
;;;1906     */
;;;1907   HAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(UART_HandleTypeDef *huart)
000000  6b81              LDR      r1,[r0,#0x38]
;;;1908   {
;;;1909     uint32_t tmpreg = 0x00U;
;;;1910   
;;;1911     /* Process Locked */
;;;1912     __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;1913     
;;;1914     huart->gState = HAL_UART_STATE_BUSY;
;;;1915   
;;;1916     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;1917     tmpreg = huart->Instance->CR1;
;;;1918   
;;;1919     /* Clear TE and RE bits */
;;;1920     tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_TE | USART_CR1_RE));
;;;1921   
;;;1922     /* Enable the USART's transmit interface by setting the TE bit in the USART CR1 register */
;;;1923     tmpreg |= (uint32_t)USART_CR1_TE;
;;;1924   
;;;1925     /* Write to USART CR1 */
;;;1926     WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
;;;1927   
;;;1928     huart->gState = HAL_UART_STATE_READY;
;;;1929     
;;;1930     /* Process Unlocked */
;;;1931     __HAL_UNLOCK(huart);
;;;1932     
;;;1933     return HAL_OK; 
;;;1934   }
000008  4770              BXEQ     lr
00000a  2101              MOVS     r1,#1                 ;1912
00000c  6381              STR      r1,[r0,#0x38]         ;1914
00000e  2124              MOVS     r1,#0x24              ;1914
000010  63c1              STR      r1,[r0,#0x3c]         ;1914
000012  6801              LDR      r1,[r0,#0]            ;1917
000014  68ca              LDR      r2,[r1,#0xc]          ;1917
000016  f022020c          BIC      r2,r2,#0xc            ;1920
00001a  f0420208          ORR      r2,r2,#8              ;1923
00001e  60ca              STR      r2,[r1,#0xc]          ;1926
000020  2120              MOVS     r1,#0x20              ;1928
000022  63c1              STR      r1,[r0,#0x3c]         ;1928
000024  2100              MOVS     r1,#0                 ;1931
000026  6381              STR      r1,[r0,#0x38]         ;1933
000028  4608              MOV      r0,r1                 ;1933
00002a  4770              BX       lr
;;;1935   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_Init||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_Init PROC
;;;325      */
;;;326    HAL_StatusTypeDef HAL_HalfDuplex_Init(UART_HandleTypeDef *huart)
000000  2800              CMP      r0,#0
;;;327    {
;;;328      /* Check the UART handle allocation */
;;;329      if(huart == NULL)
;;;330      {
;;;331        return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;332      }
;;;333     
;;;334      /* Check the parameters */ 
;;;335      assert_param(IS_UART_HALFDUPLEX_INSTANCE(huart->Instance));
;;;336      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;337    #if defined(USART_CR1_OVER8)
;;;338      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;339    #endif /* USART_CR1_OVER8 */
;;;340      if(huart->gState == HAL_UART_STATE_RESET)
;;;341      {
;;;342        /* Allocate lock resource and initialize it */
;;;343        huart->Lock = HAL_UNLOCKED;
;;;344        /* Init the low level hardware */
;;;345        HAL_UART_MspInit(huart);
;;;346      }
;;;347    
;;;348      huart->gState = HAL_UART_STATE_BUSY;
;;;349    
;;;350      /* Disable the peripheral */
;;;351      __HAL_UART_DISABLE(huart);
;;;352      
;;;353      /* Set the UART Communication parameters */
;;;354      UART_SetConfig(huart);
;;;355      
;;;356      /* In half-duplex mode, the following bits must be kept cleared:
;;;357         - LINEN and CLKEN bits in the USART_CR2 register,
;;;358         - SCEN and IREN bits in the USART_CR3 register.*/
;;;359      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;360      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_IREN | USART_CR3_SCEN));
;;;361      
;;;362      /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;363      SET_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
;;;364     
;;;365      /* Enable the peripheral */
;;;366      __HAL_UART_ENABLE(huart);
;;;367      
;;;368      /* Initialize the UART state*/
;;;369      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;370      huart->gState= HAL_UART_STATE_READY;
;;;371      huart->RxState= HAL_UART_STATE_READY;
;;;372      
;;;373      return HAL_OK;
;;;374    }
000006  4770              BXEQ     lr
000008  b570              PUSH     {r4-r6,lr}            ;327
00000a  4604              MOV      r4,r0                 ;327
00000c  6bc0              LDR      r0,[r0,#0x3c]         ;340
00000e  2500              MOVS     r5,#0                 ;340
000010  b918              CBNZ     r0,|L3.26|
000012  4620              MOV      r0,r4                 ;345
000014  63a5              STR      r5,[r4,#0x38]         ;345
000016  f7fffffe          BL       HAL_UART_MspInit
                  |L3.26|
00001a  2024              MOVS     r0,#0x24              ;348
00001c  63e0              STR      r0,[r4,#0x3c]         ;348
00001e  6820              LDR      r0,[r4,#0]            ;351
000020  68c1              LDR      r1,[r0,#0xc]          ;351
000022  f4215100          BIC      r1,r1,#0x2000         ;351
000026  60c1              STR      r1,[r0,#0xc]          ;351
000028  4620              MOV      r0,r4                 ;354
00002a  f7fffffe          BL       UART_SetConfig
00002e  6820              LDR      r0,[r4,#0]            ;359
000030  6901              LDR      r1,[r0,#0x10]         ;359
000032  f4214190          BIC      r1,r1,#0x4800         ;359
000036  6101              STR      r1,[r0,#0x10]         ;359
000038  6820              LDR      r0,[r4,#0]            ;360
00003a  6941              LDR      r1,[r0,#0x14]         ;360
00003c  f0210122          BIC      r1,r1,#0x22           ;360
000040  6141              STR      r1,[r0,#0x14]         ;360
000042  6820              LDR      r0,[r4,#0]            ;363
000044  6941              LDR      r1,[r0,#0x14]         ;363
000046  f0410108          ORR      r1,r1,#8              ;363
00004a  6141              STR      r1,[r0,#0x14]         ;363
00004c  6820              LDR      r0,[r4,#0]            ;366
00004e  68c1              LDR      r1,[r0,#0xc]          ;366
000050  f4415100          ORR      r1,r1,#0x2000         ;366
000054  60c1              STR      r1,[r0,#0xc]          ;366
000056  6465              STR      r5,[r4,#0x44]         ;369
000058  2020              MOVS     r0,#0x20              ;370
00005a  63e0              STR      r0,[r4,#0x3c]         ;370
00005c  6420              STR      r0,[r4,#0x40]         ;371
00005e  2000              MOVS     r0,#0                 ;373
000060  bd70              POP      {r4-r6,pc}
;;;375    
                          ENDP


                          AREA ||i.HAL_LIN_Init||, CODE, READONLY, ALIGN=1

                  HAL_LIN_Init PROC
;;;386      */
;;;387    HAL_StatusTypeDef HAL_LIN_Init(UART_HandleTypeDef *huart, uint32_t BreakDetectLength)
000000  2800              CMP      r0,#0
;;;388    {
;;;389      /* Check the UART handle allocation */
;;;390      if(huart == NULL)
;;;391      {
;;;392        return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;393      }
;;;394      
;;;395      /* Check the LIN UART instance */  
;;;396      assert_param(IS_UART_LIN_INSTANCE(huart->Instance));
;;;397      /* Check the Break detection length parameter */
;;;398      assert_param(IS_UART_LIN_BREAK_DETECT_LENGTH(BreakDetectLength));
;;;399      assert_param(IS_UART_LIN_WORD_LENGTH(huart->Init.WordLength));
;;;400    #if defined(USART_CR1_OVER8)
;;;401      assert_param(IS_UART_LIN_OVERSAMPLING(huart->Init.OverSampling));
;;;402    #endif /* USART_CR1_OVER8 */
;;;403      
;;;404      if(huart->gState == HAL_UART_STATE_RESET)
;;;405      {
;;;406        /* Allocate lock resource and initialize it */
;;;407        huart->Lock = HAL_UNLOCKED;
;;;408        /* Init the low level hardware */
;;;409        HAL_UART_MspInit(huart);
;;;410      }
;;;411    
;;;412      huart->gState = HAL_UART_STATE_BUSY;
;;;413    
;;;414      /* Disable the peripheral */
;;;415      __HAL_UART_DISABLE(huart);
;;;416      
;;;417      /* Set the UART Communication parameters */
;;;418      UART_SetConfig(huart);
;;;419      
;;;420      /* In LIN mode, the following bits must be kept cleared: 
;;;421         - CLKEN bits in the USART_CR2 register,
;;;422         - SCEN and IREN bits in the USART_CR3 register.*/
;;;423      CLEAR_BIT(huart->Instance->CR2, USART_CR2_CLKEN);
;;;424      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_HDSEL | USART_CR3_IREN | USART_CR3_SCEN));
;;;425      
;;;426      /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;427      SET_BIT(huart->Instance->CR2, USART_CR2_LINEN);
;;;428      
;;;429      /* Set the USART LIN Break detection length. */
;;;430      MODIFY_REG(huart->Instance->CR2, USART_CR2_LBDL, BreakDetectLength);
;;;431      
;;;432      /* Enable the peripheral */
;;;433      __HAL_UART_ENABLE(huart);
;;;434      
;;;435      /* Initialize the UART state*/
;;;436      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;437      huart->gState= HAL_UART_STATE_READY;
;;;438      huart->RxState= HAL_UART_STATE_READY;
;;;439      
;;;440      return HAL_OK;
;;;441    }
000006  4770              BXEQ     lr
000008  b570              PUSH     {r4-r6,lr}            ;388
00000a  4604              MOV      r4,r0                 ;388
00000c  6bc0              LDR      r0,[r0,#0x3c]         ;404
00000e  460e              MOV      r6,r1                 ;388
000010  2500              MOVS     r5,#0                 ;404
000012  b918              CBNZ     r0,|L4.28|
000014  4620              MOV      r0,r4                 ;409
000016  63a5              STR      r5,[r4,#0x38]         ;409
000018  f7fffffe          BL       HAL_UART_MspInit
                  |L4.28|
00001c  2024              MOVS     r0,#0x24              ;412
00001e  63e0              STR      r0,[r4,#0x3c]         ;412
000020  6820              LDR      r0,[r4,#0]            ;415
000022  68c1              LDR      r1,[r0,#0xc]          ;415
000024  f4215100          BIC      r1,r1,#0x2000         ;415
000028  60c1              STR      r1,[r0,#0xc]          ;415
00002a  4620              MOV      r0,r4                 ;418
00002c  f7fffffe          BL       UART_SetConfig
000030  6820              LDR      r0,[r4,#0]            ;423
000032  6901              LDR      r1,[r0,#0x10]         ;423
000034  f4216100          BIC      r1,r1,#0x800          ;423
000038  6101              STR      r1,[r0,#0x10]         ;423
00003a  6820              LDR      r0,[r4,#0]            ;424
00003c  6941              LDR      r1,[r0,#0x14]         ;424
00003e  f021012a          BIC      r1,r1,#0x2a           ;424
000042  6141              STR      r1,[r0,#0x14]         ;424
000044  6820              LDR      r0,[r4,#0]            ;427
000046  6901              LDR      r1,[r0,#0x10]         ;427
000048  f4414180          ORR      r1,r1,#0x4000         ;427
00004c  6101              STR      r1,[r0,#0x10]         ;427
00004e  6820              LDR      r0,[r4,#0]            ;430
000050  6901              LDR      r1,[r0,#0x10]         ;430
000052  f0210120          BIC      r1,r1,#0x20           ;430
000056  4331              ORRS     r1,r1,r6              ;430
000058  6101              STR      r1,[r0,#0x10]         ;430
00005a  6820              LDR      r0,[r4,#0]            ;433
00005c  68c1              LDR      r1,[r0,#0xc]          ;433
00005e  f4415100          ORR      r1,r1,#0x2000         ;433
000062  60c1              STR      r1,[r0,#0xc]          ;433
000064  6465              STR      r5,[r4,#0x44]         ;436
000066  2020              MOVS     r0,#0x20              ;437
000068  63e0              STR      r0,[r4,#0x3c]         ;437
00006a  6420              STR      r0,[r4,#0x40]         ;438
00006c  2000              MOVS     r0,#0                 ;440
00006e  bd70              POP      {r4-r6,pc}
;;;442    
                          ENDP


                          AREA ||i.HAL_LIN_SendBreak||, CODE, READONLY, ALIGN=1

                  HAL_LIN_SendBreak PROC
;;;1825     */
;;;1826   HAL_StatusTypeDef HAL_LIN_SendBreak(UART_HandleTypeDef *huart)
000000  6b81              LDR      r1,[r0,#0x38]
;;;1827   {
;;;1828     /* Check the parameters */
;;;1829     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;1830     
;;;1831     /* Process Locked */
;;;1832     __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;1833     
;;;1834     huart->gState = HAL_UART_STATE_BUSY;
;;;1835     
;;;1836     /* Send break characters */
;;;1837     SET_BIT(huart->Instance->CR1, USART_CR1_SBK);
;;;1838    
;;;1839     huart->gState = HAL_UART_STATE_READY;
;;;1840     
;;;1841     /* Process Unlocked */
;;;1842     __HAL_UNLOCK(huart);
;;;1843     
;;;1844     return HAL_OK; 
;;;1845   }
000008  4770              BXEQ     lr
00000a  2101              MOVS     r1,#1                 ;1832
00000c  6381              STR      r1,[r0,#0x38]         ;1834
00000e  2124              MOVS     r1,#0x24              ;1834
000010  63c1              STR      r1,[r0,#0x3c]         ;1834
000012  6801              LDR      r1,[r0,#0]            ;1837
000014  68ca              LDR      r2,[r1,#0xc]          ;1837
000016  f0420201          ORR      r2,r2,#1              ;1837
00001a  60ca              STR      r2,[r1,#0xc]          ;1837
00001c  2120              MOVS     r1,#0x20              ;1839
00001e  63c1              STR      r1,[r0,#0x3c]         ;1839
000020  2100              MOVS     r1,#0                 ;1842
000022  6381              STR      r1,[r0,#0x38]         ;1844
000024  4608              MOV      r0,r1                 ;1844
000026  4770              BX       lr
;;;1846   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_EnterMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_EnterMuteMode PROC
;;;1852     */
;;;1853   HAL_StatusTypeDef HAL_MultiProcessor_EnterMuteMode(UART_HandleTypeDef *huart)
000000  6b81              LDR      r1,[r0,#0x38]
;;;1854   {
;;;1855     /* Check the parameters */
;;;1856     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;1857     
;;;1858     /* Process Locked */
;;;1859     __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;1860     
;;;1861     huart->gState = HAL_UART_STATE_BUSY;
;;;1862     
;;;1863     /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
;;;1864     SET_BIT(huart->Instance->CR1, USART_CR1_RWU);
;;;1865     
;;;1866     huart->gState = HAL_UART_STATE_READY;
;;;1867     
;;;1868     /* Process Unlocked */
;;;1869     __HAL_UNLOCK(huart);
;;;1870     
;;;1871     return HAL_OK; 
;;;1872   }
000008  4770              BXEQ     lr
00000a  2101              MOVS     r1,#1                 ;1859
00000c  6381              STR      r1,[r0,#0x38]         ;1861
00000e  2124              MOVS     r1,#0x24              ;1861
000010  63c1              STR      r1,[r0,#0x3c]         ;1861
000012  6801              LDR      r1,[r0,#0]            ;1864
000014  68ca              LDR      r2,[r1,#0xc]          ;1864
000016  f0420202          ORR      r2,r2,#2              ;1864
00001a  60ca              STR      r2,[r1,#0xc]          ;1864
00001c  2120              MOVS     r1,#0x20              ;1866
00001e  63c1              STR      r1,[r0,#0x3c]         ;1866
000020  2100              MOVS     r1,#0                 ;1869
000022  6381              STR      r1,[r0,#0x38]         ;1871
000024  4608              MOV      r0,r1                 ;1871
000026  4770              BX       lr
;;;1873   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_ExitMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_ExitMuteMode PROC
;;;1879     */
;;;1880   HAL_StatusTypeDef HAL_MultiProcessor_ExitMuteMode(UART_HandleTypeDef *huart)
000000  6b81              LDR      r1,[r0,#0x38]
;;;1881   {
;;;1882     /* Check the parameters */
;;;1883     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;1884     
;;;1885     /* Process Locked */
;;;1886     __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;1887     
;;;1888     huart->gState = HAL_UART_STATE_BUSY;
;;;1889     
;;;1890     /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
;;;1891     CLEAR_BIT(huart->Instance->CR1, USART_CR1_RWU);
;;;1892     
;;;1893     huart->gState = HAL_UART_STATE_READY;
;;;1894     
;;;1895     /* Process Unlocked */
;;;1896     __HAL_UNLOCK(huart);
;;;1897     
;;;1898     return HAL_OK; 
;;;1899   }
000008  4770              BXEQ     lr
00000a  2101              MOVS     r1,#1                 ;1886
00000c  6381              STR      r1,[r0,#0x38]         ;1888
00000e  2124              MOVS     r1,#0x24              ;1888
000010  63c1              STR      r1,[r0,#0x3c]         ;1888
000012  6801              LDR      r1,[r0,#0]            ;1891
000014  68ca              LDR      r2,[r1,#0xc]          ;1891
000016  f0220202          BIC      r2,r2,#2              ;1891
00001a  60ca              STR      r2,[r1,#0xc]          ;1891
00001c  2120              MOVS     r1,#0x20              ;1893
00001e  63c1              STR      r1,[r0,#0x3c]         ;1893
000020  2100              MOVS     r1,#0                 ;1896
000022  6381              STR      r1,[r0,#0x38]         ;1898
000024  4608              MOV      r0,r1                 ;1898
000026  4770              BX       lr
;;;1900   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_Init||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_Init PROC
;;;454      */
;;;455    HAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod)
000000  2800              CMP      r0,#0
;;;456    {
;;;457      /* Check the UART handle allocation */
;;;458      if(huart == NULL)
;;;459      {
;;;460        return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;461      }
;;;462    
;;;463      /* Check UART instance capabilities */  
;;;464      assert_param(IS_UART_MULTIPROCESSOR_INSTANCE(huart->Instance));
;;;465    
;;;466      /* Check the Address & wake up method parameters */
;;;467      assert_param(IS_UART_WAKEUPMETHOD(WakeUpMethod));
;;;468      assert_param(IS_UART_ADDRESS(Address));
;;;469      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;470    #if defined(USART_CR1_OVER8)
;;;471      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;472    #endif /* USART_CR1_OVER8 */
;;;473    
;;;474      if(huart->gState == HAL_UART_STATE_RESET)
;;;475      {
;;;476        /* Allocate lock resource and initialize it */
;;;477        huart->Lock = HAL_UNLOCKED;
;;;478        /* Init the low level hardware */
;;;479        HAL_UART_MspInit(huart);
;;;480      }
;;;481    
;;;482      huart->gState = HAL_UART_STATE_BUSY;
;;;483    
;;;484      /* Disable the peripheral */
;;;485      __HAL_UART_DISABLE(huart);
;;;486      
;;;487      /* Set the UART Communication parameters */
;;;488      UART_SetConfig(huart);
;;;489      
;;;490      /* In Multi-Processor mode, the following bits must be kept cleared: 
;;;491         - LINEN and CLKEN bits in the USART_CR2 register,
;;;492         - SCEN, HDSEL and IREN  bits in the USART_CR3 register */
;;;493      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;494      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;495      
;;;496      /* Set the USART address node */
;;;497      MODIFY_REG(huart->Instance->CR2, USART_CR2_ADD, Address);
;;;498      
;;;499      /* Set the wake up method by setting the WAKE bit in the CR1 register */
;;;500      MODIFY_REG(huart->Instance->CR1, USART_CR1_WAKE, WakeUpMethod);
;;;501      
;;;502      /* Enable the peripheral */
;;;503      __HAL_UART_ENABLE(huart);
;;;504      
;;;505      /* Initialize the UART state */
;;;506      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;507      huart->gState = HAL_UART_STATE_READY;
;;;508      huart->RxState = HAL_UART_STATE_READY;
;;;509      
;;;510      return HAL_OK;
;;;511    }
000006  4770              BXEQ     lr
000008  e92d41f0          PUSH     {r4-r8,lr}            ;456
00000c  4604              MOV      r4,r0                 ;456
00000e  6bc0              LDR      r0,[r0,#0x3c]         ;474
000010  4616              MOV      r6,r2                 ;456
000012  460f              MOV      r7,r1                 ;456
000014  2500              MOVS     r5,#0                 ;474
000016  b918              CBNZ     r0,|L8.32|
000018  4620              MOV      r0,r4                 ;479
00001a  63a5              STR      r5,[r4,#0x38]         ;479
00001c  f7fffffe          BL       HAL_UART_MspInit
                  |L8.32|
000020  2024              MOVS     r0,#0x24              ;482
000022  63e0              STR      r0,[r4,#0x3c]         ;482
000024  6820              LDR      r0,[r4,#0]            ;485
000026  68c1              LDR      r1,[r0,#0xc]          ;485
000028  f4215100          BIC      r1,r1,#0x2000         ;485
00002c  60c1              STR      r1,[r0,#0xc]          ;485
00002e  4620              MOV      r0,r4                 ;488
000030  f7fffffe          BL       UART_SetConfig
000034  6820              LDR      r0,[r4,#0]            ;493
000036  6901              LDR      r1,[r0,#0x10]         ;493
000038  f4214190          BIC      r1,r1,#0x4800         ;493
00003c  6101              STR      r1,[r0,#0x10]         ;493
00003e  6820              LDR      r0,[r4,#0]            ;494
000040  6941              LDR      r1,[r0,#0x14]         ;494
000042  f021012a          BIC      r1,r1,#0x2a           ;494
000046  6141              STR      r1,[r0,#0x14]         ;494
000048  6820              LDR      r0,[r4,#0]            ;497
00004a  6901              LDR      r1,[r0,#0x10]         ;497
00004c  f021010f          BIC      r1,r1,#0xf            ;497
000050  4339              ORRS     r1,r1,r7              ;497
000052  6101              STR      r1,[r0,#0x10]         ;497
000054  6820              LDR      r0,[r4,#0]            ;500
000056  68c1              LDR      r1,[r0,#0xc]          ;500
000058  f4216100          BIC      r1,r1,#0x800          ;500
00005c  4331              ORRS     r1,r1,r6              ;500
00005e  60c1              STR      r1,[r0,#0xc]          ;500
000060  6820              LDR      r0,[r4,#0]            ;503
000062  68c1              LDR      r1,[r0,#0xc]          ;503
000064  f4415100          ORR      r1,r1,#0x2000         ;503
000068  60c1              STR      r1,[r0,#0xc]          ;503
00006a  6465              STR      r5,[r4,#0x44]         ;506
00006c  2020              MOVS     r0,#0x20              ;507
00006e  63e0              STR      r0,[r4,#0x3c]         ;507
000070  6420              STR      r0,[r4,#0x40]         ;508
000072  2000              MOVS     r0,#0                 ;510
000074  e8bd81f0          POP      {r4-r8,pc}
;;;512    
                          ENDP


                          AREA ||i.HAL_UART_Abort||, CODE, READONLY, ALIGN=1

                  HAL_UART_Abort PROC
;;;1160   */
;;;1161   HAL_StatusTypeDef HAL_UART_Abort(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1162   {
000002  4604              MOV      r4,r0
;;;1163     /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1164     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6800              LDR      r0,[r0,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f42171f0          BIC      r1,r1,#0x1e0
00000c  60c1              STR      r1,[r0,#0xc]
;;;1165     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00000e  6820              LDR      r0,[r4,#0]
000010  6941              LDR      r1,[r0,#0x14]
000012  f0210101          BIC      r1,r1,#1
000016  6141              STR      r1,[r0,#0x14]
;;;1166     
;;;1167     /* Disable the UART DMA Tx request if enabled */
;;;1168     if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000018  6820              LDR      r0,[r4,#0]
00001a  6941              LDR      r1,[r0,#0x14]
00001c  f04f0500          MOV      r5,#0
000020  f0110f80          TST      r1,#0x80
000024  d009              BEQ      |L9.58|
;;;1169     {
;;;1170       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000026  6941              LDR      r1,[r0,#0x14]
000028  f0210180          BIC      r1,r1,#0x80
00002c  6141              STR      r1,[r0,#0x14]
;;;1171   
;;;1172       /* Abort the UART DMA Tx channel: use blocking DMA Abort API (no callback) */
;;;1173       if(huart->hdmatx != NULL)
00002e  6b20              LDR      r0,[r4,#0x30]
000030  b118              CBZ      r0,|L9.58|
;;;1174       {
;;;1175         /* Set the UART DMA Abort callback to Null. 
;;;1176            No call back execution at end of DMA abort procedure */
;;;1177         huart->hdmatx->XferAbortCallback = NULL;
;;;1178   
;;;1179         HAL_DMA_Abort(huart->hdmatx);
000032  6385              STR      r5,[r0,#0x38]
000034  6b20              LDR      r0,[r4,#0x30]
000036  f7fffffe          BL       HAL_DMA_Abort
                  |L9.58|
;;;1180       }
;;;1181     }
;;;1182   
;;;1183     /* Disable the UART DMA Rx request if enabled */
;;;1184     if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
00003a  6820              LDR      r0,[r4,#0]
00003c  6941              LDR      r1,[r0,#0x14]
00003e  f0110f40          TST      r1,#0x40
000042  d009              BEQ      |L9.88|
;;;1185     {
;;;1186       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000044  6941              LDR      r1,[r0,#0x14]
000046  f0210140          BIC      r1,r1,#0x40
00004a  6141              STR      r1,[r0,#0x14]
;;;1187   
;;;1188       /* Abort the UART DMA Rx channel: use blocking DMA Abort API (no callback) */
;;;1189       if(huart->hdmarx != NULL)
00004c  6b60              LDR      r0,[r4,#0x34]
00004e  b118              CBZ      r0,|L9.88|
;;;1190       {
;;;1191         /* Set the UART DMA Abort callback to Null. 
;;;1192            No call back execution at end of DMA abort procedure */
;;;1193         huart->hdmarx->XferAbortCallback = NULL;
;;;1194   
;;;1195         HAL_DMA_Abort(huart->hdmarx);
000050  6385              STR      r5,[r0,#0x38]
000052  6b60              LDR      r0,[r4,#0x34]
000054  f7fffffe          BL       HAL_DMA_Abort
                  |L9.88|
;;;1196       }
;;;1197     }
;;;1198   
;;;1199     /* Reset Tx and Rx transfer counters */
;;;1200     huart->TxXferCount = 0x00U;
000058  84e5              STRH     r5,[r4,#0x26]
;;;1201     huart->RxXferCount = 0x00U;
00005a  85e5              STRH     r5,[r4,#0x2e]
;;;1202   
;;;1203     /* Reset ErrorCode */
;;;1204     huart->ErrorCode = HAL_UART_ERROR_NONE;
00005c  6465              STR      r5,[r4,#0x44]
;;;1205   
;;;1206     /* Restore huart->RxState and huart->gState to Ready */
;;;1207     huart->RxState = HAL_UART_STATE_READY;
00005e  2020              MOVS     r0,#0x20
000060  6420              STR      r0,[r4,#0x40]
;;;1208     huart->gState = HAL_UART_STATE_READY;
000062  63e0              STR      r0,[r4,#0x3c]
;;;1209   
;;;1210     return HAL_OK;
000064  2000              MOVS     r0,#0
;;;1211   }
000066  bd70              POP      {r4-r6,pc}
;;;1212   
                          ENDP


                          AREA ||i.HAL_UART_AbortCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortCpltCallback PROC
;;;1757     */
;;;1758   __weak void HAL_UART_AbortCpltCallback (UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1759   {
;;;1760     /* Prevent unused argument(s) compilation warning */
;;;1761     UNUSED(huart);
;;;1762   
;;;1763     /* NOTE : This function should not be modified, when the callback is needed,
;;;1764               the HAL_UART_AbortCpltCallback can be implemented in the user file.
;;;1765      */
;;;1766   }
;;;1767   /**
                          ENDP


                          AREA ||i.HAL_UART_AbortReceive||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortReceive PROC
;;;1266   */
;;;1267   HAL_StatusTypeDef HAL_UART_AbortReceive(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1268   {
000002  4604              MOV      r4,r0
;;;1269     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1270     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000004  6800              LDR      r0,[r0,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f4217190          BIC      r1,r1,#0x120
00000c  60c1              STR      r1,[r0,#0xc]
;;;1271     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00000e  6820              LDR      r0,[r4,#0]
000010  6941              LDR      r1,[r0,#0x14]
000012  f0210101          BIC      r1,r1,#1
000016  6141              STR      r1,[r0,#0x14]
;;;1272   
;;;1273     /* Disable the UART DMA Rx request if enabled */
;;;1274     if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000018  6820              LDR      r0,[r4,#0]
00001a  6941              LDR      r1,[r0,#0x14]
00001c  f04f0500          MOV      r5,#0
000020  f0110f40          TST      r1,#0x40
000024  d009              BEQ      |L11.58|
;;;1275     {
;;;1276       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000026  6941              LDR      r1,[r0,#0x14]
000028  f0210140          BIC      r1,r1,#0x40
00002c  6141              STR      r1,[r0,#0x14]
;;;1277   
;;;1278       /* Abort the UART DMA Rx channel : use blocking DMA Abort API (no callback) */
;;;1279       if(huart->hdmarx != NULL)
00002e  6b60              LDR      r0,[r4,#0x34]
000030  b118              CBZ      r0,|L11.58|
;;;1280       {
;;;1281         /* Set the UART DMA Abort callback to Null. 
;;;1282            No call back execution at end of DMA abort procedure */
;;;1283         huart->hdmarx->XferAbortCallback = NULL;
;;;1284   
;;;1285         HAL_DMA_Abort(huart->hdmarx);
000032  6385              STR      r5,[r0,#0x38]
000034  6b60              LDR      r0,[r4,#0x34]
000036  f7fffffe          BL       HAL_DMA_Abort
                  |L11.58|
;;;1286       }
;;;1287     }
;;;1288   
;;;1289     /* Reset Rx transfer counter */
;;;1290     huart->RxXferCount = 0x00U;
00003a  85e5              STRH     r5,[r4,#0x2e]
;;;1291   
;;;1292     /* Restore huart->RxState to Ready */
;;;1293     huart->RxState = HAL_UART_STATE_READY;
00003c  2020              MOVS     r0,#0x20
00003e  6420              STR      r0,[r4,#0x40]
;;;1294   
;;;1295     return HAL_OK;
000040  2000              MOVS     r0,#0
;;;1296   }
000042  bd70              POP      {r4-r6,pc}
;;;1297   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceiveCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortReceiveCpltCallback PROC
;;;1786     */
;;;1787   __weak void HAL_UART_AbortReceiveCpltCallback (UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1788   {
;;;1789     /* Prevent unused argument(s) compilation warning */
;;;1790     UNUSED(huart);
;;;1791   
;;;1792     /* NOTE : This function should not be modified, when the callback is needed,
;;;1793               the HAL_UART_AbortReceiveCpltCallback can be implemented in the user file.
;;;1794      */
;;;1795   }
;;;1796   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceive_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_AbortReceive_IT PROC
;;;1498   */
;;;1499   HAL_StatusTypeDef HAL_UART_AbortReceive_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1500   {
000002  4604              MOV      r4,r0
;;;1501     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1502     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000004  6800              LDR      r0,[r0,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f4217190          BIC      r1,r1,#0x120
00000c  60c1              STR      r1,[r0,#0xc]
;;;1503     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00000e  6820              LDR      r0,[r4,#0]
000010  6941              LDR      r1,[r0,#0x14]
000012  f0210101          BIC      r1,r1,#1
000016  6141              STR      r1,[r0,#0x14]
;;;1504   
;;;1505     /* Disable the UART DMA Rx request if enabled */
;;;1506     if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000018  6820              LDR      r0,[r4,#0]
00001a  6941              LDR      r1,[r0,#0x14]
;;;1507     {
;;;1508       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1509   
;;;1510       /* Abort the UART DMA Rx channel : use blocking DMA Abort API (no callback) */
;;;1511       if(huart->hdmarx != NULL)
;;;1512       {
;;;1513         /* Set the UART DMA Abort callback : 
;;;1514            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1515         huart->hdmarx->XferAbortCallback = UART_DMARxOnlyAbortCallback;
;;;1516   
;;;1517         /* Abort DMA RX */
;;;1518         if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
;;;1519         {
;;;1520           /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */
;;;1521           huart->hdmarx->XferAbortCallback(huart->hdmarx);
;;;1522         }
;;;1523       }
;;;1524       else
;;;1525       {
;;;1526         /* Reset Rx transfer counter */
;;;1527         huart->RxXferCount = 0x00U;
;;;1528   
;;;1529         /* Restore huart->RxState to Ready */
;;;1530         huart->RxState = HAL_UART_STATE_READY;
00001c  f04f0220          MOV      r2,#0x20
000020  f0110f40          TST      r1,#0x40              ;1506
000024  f04f0100          MOV      r1,#0                 ;1506
000028  d00f              BEQ      |L13.74|
00002a  6943              LDR      r3,[r0,#0x14]         ;1508
00002c  f0230340          BIC      r3,r3,#0x40           ;1508
000030  6143              STR      r3,[r0,#0x14]         ;1508
000032  6b60              LDR      r0,[r4,#0x34]         ;1511
000034  b148              CBZ      r0,|L13.74|
000036  4908              LDR      r1,|L13.88|
000038  6381              STR      r1,[r0,#0x38]         ;1518
00003a  6b60              LDR      r0,[r4,#0x34]         ;1518
00003c  f7fffffe          BL       HAL_DMA_Abort_IT
000040  b140              CBZ      r0,|L13.84|
000042  6b60              LDR      r0,[r4,#0x34]         ;1521
000044  6b81              LDR      r1,[r0,#0x38]         ;1521
000046  4788              BLX      r1                    ;1521
000048  e004              B        |L13.84|
                  |L13.74|
00004a  85e1              STRH     r1,[r4,#0x2e]         ;1527
00004c  6422              STR      r2,[r4,#0x40]
;;;1531   
;;;1532         /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1533         HAL_UART_AbortReceiveCpltCallback(huart);
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       HAL_UART_AbortReceiveCpltCallback
                  |L13.84|
;;;1534       }
;;;1535     }
;;;1536     else
;;;1537     {
;;;1538       /* Reset Rx transfer counter */
;;;1539       huart->RxXferCount = 0x00U;
;;;1540   
;;;1541       /* Restore huart->RxState to Ready */
;;;1542       huart->RxState = HAL_UART_STATE_READY;
;;;1543   
;;;1544       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1545       HAL_UART_AbortReceiveCpltCallback(huart);
;;;1546     }
;;;1547   
;;;1548     return HAL_OK;
000054  2000              MOVS     r0,#0
;;;1549   }
000056  bd10              POP      {r4,pc}
;;;1550   
                          ENDP

                  |L13.88|
                          DCD      UART_DMARxOnlyAbortCallback

                          AREA ||i.HAL_UART_AbortTransmit||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortTransmit PROC
;;;1224   */
;;;1225   HAL_StatusTypeDef HAL_UART_AbortTransmit(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1226   {
000002  4604              MOV      r4,r0
;;;1227     /* Disable TXEIE and TCIE interrupts */
;;;1228     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6800              LDR      r0,[r0,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f02101c0          BIC      r1,r1,#0xc0
00000c  60c1              STR      r1,[r0,#0xc]
;;;1229   
;;;1230     /* Disable the UART DMA Tx request if enabled */
;;;1231     if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
00000e  6820              LDR      r0,[r4,#0]
000010  6941              LDR      r1,[r0,#0x14]
000012  f04f0500          MOV      r5,#0
000016  f0110f80          TST      r1,#0x80
00001a  d009              BEQ      |L14.48|
;;;1232     {
;;;1233       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
00001c  6941              LDR      r1,[r0,#0x14]
00001e  f0210180          BIC      r1,r1,#0x80
000022  6141              STR      r1,[r0,#0x14]
;;;1234   
;;;1235       /* Abort the UART DMA Tx channel : use blocking DMA Abort API (no callback) */
;;;1236       if(huart->hdmatx != NULL)
000024  6b20              LDR      r0,[r4,#0x30]
000026  b118              CBZ      r0,|L14.48|
;;;1237       {
;;;1238         /* Set the UART DMA Abort callback to Null. 
;;;1239            No call back execution at end of DMA abort procedure */
;;;1240         huart->hdmatx->XferAbortCallback = NULL;
;;;1241   
;;;1242         HAL_DMA_Abort(huart->hdmatx);
000028  6385              STR      r5,[r0,#0x38]
00002a  6b20              LDR      r0,[r4,#0x30]
00002c  f7fffffe          BL       HAL_DMA_Abort
                  |L14.48|
;;;1243       }
;;;1244     }
;;;1245   
;;;1246     /* Reset Tx transfer counter */
;;;1247     huart->TxXferCount = 0x00U;
000030  84e5              STRH     r5,[r4,#0x26]
;;;1248   
;;;1249     /* Restore huart->gState to Ready */
;;;1250     huart->gState = HAL_UART_STATE_READY;
000032  2020              MOVS     r0,#0x20
000034  63e0              STR      r0,[r4,#0x3c]
;;;1251   
;;;1252     return HAL_OK;
000036  2000              MOVS     r0,#0
;;;1253   }
000038  bd70              POP      {r4-r6,pc}
;;;1254   
                          ENDP


                          AREA ||i.HAL_UART_AbortTransmitCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortTransmitCpltCallback PROC
;;;1771     */
;;;1772   __weak void HAL_UART_AbortTransmitCpltCallback (UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1773   {
;;;1774     /* Prevent unused argument(s) compilation warning */
;;;1775     UNUSED(huart);
;;;1776   
;;;1777     /* NOTE : This function should not be modified, when the callback is needed,
;;;1778               the HAL_UART_AbortTransmitCpltCallback can be implemented in the user file.
;;;1779      */
;;;1780   }
;;;1781   
                          ENDP


                          AREA ||i.HAL_UART_AbortTransmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_AbortTransmit_IT PROC
;;;1433   */
;;;1434   HAL_StatusTypeDef HAL_UART_AbortTransmit_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1435   {
000002  4604              MOV      r4,r0
;;;1436     /* Disable TXEIE and TCIE interrupts */
;;;1437     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6800              LDR      r0,[r0,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f02101c0          BIC      r1,r1,#0xc0
00000c  60c1              STR      r1,[r0,#0xc]
;;;1438   
;;;1439     /* Disable the UART DMA Tx request if enabled */
;;;1440     if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
00000e  6820              LDR      r0,[r4,#0]
000010  6941              LDR      r1,[r0,#0x14]
;;;1441     {
;;;1442       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1443   
;;;1444       /* Abort the UART DMA Tx channel : use blocking DMA Abort API (no callback) */
;;;1445       if(huart->hdmatx != NULL)
;;;1446       {
;;;1447         /* Set the UART DMA Abort callback : 
;;;1448            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1449         huart->hdmatx->XferAbortCallback = UART_DMATxOnlyAbortCallback;
;;;1450   
;;;1451         /* Abort DMA TX */
;;;1452         if(HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
;;;1453         {
;;;1454           /* Call Directly huart->hdmatx->XferAbortCallback function in case of error */
;;;1455           huart->hdmatx->XferAbortCallback(huart->hdmatx);
;;;1456         }
;;;1457       }
;;;1458       else
;;;1459       {
;;;1460         /* Reset Tx transfer counter */
;;;1461         huart->TxXferCount = 0x00U;
;;;1462   
;;;1463         /* Restore huart->gState to Ready */
;;;1464         huart->gState = HAL_UART_STATE_READY;
000012  f04f0220          MOV      r2,#0x20
000016  f0110f80          TST      r1,#0x80              ;1440
00001a  f04f0100          MOV      r1,#0                 ;1440
00001e  d00f              BEQ      |L16.64|
000020  6943              LDR      r3,[r0,#0x14]         ;1442
000022  f0230380          BIC      r3,r3,#0x80           ;1442
000026  6143              STR      r3,[r0,#0x14]         ;1442
000028  6b20              LDR      r0,[r4,#0x30]         ;1445
00002a  b148              CBZ      r0,|L16.64|
00002c  4908              LDR      r1,|L16.80|
00002e  6381              STR      r1,[r0,#0x38]         ;1452
000030  6b20              LDR      r0,[r4,#0x30]         ;1452
000032  f7fffffe          BL       HAL_DMA_Abort_IT
000036  b140              CBZ      r0,|L16.74|
000038  6b20              LDR      r0,[r4,#0x30]         ;1455
00003a  6b81              LDR      r1,[r0,#0x38]         ;1455
00003c  4788              BLX      r1                    ;1455
00003e  e004              B        |L16.74|
                  |L16.64|
000040  84e1              STRH     r1,[r4,#0x26]         ;1461
000042  63e2              STR      r2,[r4,#0x3c]
;;;1465   
;;;1466         /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1467         HAL_UART_AbortTransmitCpltCallback(huart);
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       HAL_UART_AbortTransmitCpltCallback
                  |L16.74|
;;;1468       }
;;;1469     }
;;;1470     else
;;;1471     {
;;;1472       /* Reset Tx transfer counter */
;;;1473       huart->TxXferCount = 0x00U;
;;;1474   
;;;1475       /* Restore huart->gState to Ready */
;;;1476       huart->gState = HAL_UART_STATE_READY;
;;;1477   
;;;1478       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1479       HAL_UART_AbortTransmitCpltCallback(huart);
;;;1480     }
;;;1481   
;;;1482     return HAL_OK;
00004a  2000              MOVS     r0,#0
;;;1483   }
00004c  bd10              POP      {r4,pc}
;;;1484   
                          ENDP

00004e  0000              DCW      0x0000
                  |L16.80|
                          DCD      UART_DMATxOnlyAbortCallback

                          AREA ||i.HAL_UART_Abort_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_Abort_IT PROC
;;;1311   */
;;;1312   HAL_StatusTypeDef HAL_UART_Abort_IT(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1313   {
000002  4604              MOV      r4,r0
;;;1314     uint32_t AbortCplt = 0x01U;
;;;1315   
;;;1316     /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1317     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6800              LDR      r0,[r0,#0]
000006  2601              MOVS     r6,#1                 ;1314
000008  68c1              LDR      r1,[r0,#0xc]
00000a  f42171f0          BIC      r1,r1,#0x1e0
00000e  60c1              STR      r1,[r0,#0xc]
;;;1318     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000010  6820              LDR      r0,[r4,#0]
000012  6941              LDR      r1,[r0,#0x14]
000014  f0210101          BIC      r1,r1,#1
000018  6141              STR      r1,[r0,#0x14]
00001a  6b20              LDR      r0,[r4,#0x30]         ;1313
;;;1319   
;;;1320     /* If DMA Tx and/or DMA Rx Handles are associated to UART Handle, DMA Abort complete callbacks should be initialised
;;;1321        before any call to DMA Abort functions */
;;;1322     /* DMA Tx Handle is valid */
;;;1323     if(huart->hdmatx != NULL)
00001c  2500              MOVS     r5,#0
00001e  b138              CBZ      r0,|L17.48|
;;;1324     {
;;;1325       /* Set DMA Abort Complete callback if UART DMA Tx request if enabled.
;;;1326          Otherwise, set it to NULL */
;;;1327       if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000020  6821              LDR      r1,[r4,#0]
000022  6949              LDR      r1,[r1,#0x14]
000024  f0110f80          TST      r1,#0x80
;;;1328       {
;;;1329         huart->hdmatx->XferAbortCallback = UART_DMATxAbortCallback;
;;;1330       }
;;;1331       else
;;;1332       {
;;;1333         huart->hdmatx->XferAbortCallback = NULL;
000028  bf0e              ITEE     EQ
00002a  6385              STREQ    r5,[r0,#0x38]
00002c  491e              LDRNE    r1,|L17.168|
00002e  6381              STRNE    r1,[r0,#0x38]         ;1329
                  |L17.48|
;;;1334       }
;;;1335     }
;;;1336     /* DMA Rx Handle is valid */
;;;1337     if(huart->hdmarx != NULL)
000030  6b60              LDR      r0,[r4,#0x34]
000032  b138              CBZ      r0,|L17.68|
;;;1338     {
;;;1339       /* Set DMA Abort Complete callback if UART DMA Rx request if enabled.
;;;1340          Otherwise, set it to NULL */
;;;1341       if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000034  6821              LDR      r1,[r4,#0]
000036  6949              LDR      r1,[r1,#0x14]
000038  f0110f40          TST      r1,#0x40
;;;1342       {
;;;1343         huart->hdmarx->XferAbortCallback = UART_DMARxAbortCallback;
;;;1344       }
;;;1345       else
;;;1346       {
;;;1347         huart->hdmarx->XferAbortCallback = NULL;
00003c  bf0e              ITEE     EQ
00003e  6385              STREQ    r5,[r0,#0x38]
000040  491a              LDRNE    r1,|L17.172|
000042  6381              STRNE    r1,[r0,#0x38]         ;1343
                  |L17.68|
;;;1348       }
;;;1349     }
;;;1350   
;;;1351     /* Disable the UART DMA Tx request if enabled */
;;;1352     if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000044  6820              LDR      r0,[r4,#0]
000046  6941              LDR      r1,[r0,#0x14]
000048  f0110f80          TST      r1,#0x80
00004c  d00c              BEQ      |L17.104|
;;;1353     {
;;;1354       /* Disable DMA Tx at UART level */
;;;1355       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
00004e  6941              LDR      r1,[r0,#0x14]
000050  f0210180          BIC      r1,r1,#0x80
000054  6141              STR      r1,[r0,#0x14]
;;;1356   
;;;1357       /* Abort the UART DMA Tx channel : use non blocking DMA Abort API (callback) */
;;;1358       if(huart->hdmatx != NULL)
000056  6b20              LDR      r0,[r4,#0x30]
000058  b130              CBZ      r0,|L17.104|
;;;1359       {
;;;1360         /* UART Tx DMA Abort callback has already been initialised : 
;;;1361            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1362   
;;;1363         /* Abort DMA TX */
;;;1364         if(HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
00005a  f7fffffe          BL       HAL_DMA_Abort_IT
00005e  2800              CMP      r0,#0
;;;1365         {
;;;1366           huart->hdmatx->XferAbortCallback = NULL;
;;;1367         }
;;;1368         else
;;;1369         {
;;;1370           AbortCplt = 0x00U;
000060  bf0e              ITEE     EQ
000062  2600              MOVEQ    r6,#0
000064  6b20              LDRNE    r0,[r4,#0x30]         ;1366
000066  6385              STRNE    r5,[r0,#0x38]         ;1366
                  |L17.104|
;;;1371         }
;;;1372       }
;;;1373     }
;;;1374   
;;;1375     /* Disable the UART DMA Rx request if enabled */
;;;1376     if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000068  6820              LDR      r0,[r4,#0]
00006a  6941              LDR      r1,[r0,#0x14]
00006c  f0110f40          TST      r1,#0x40
000070  d00d              BEQ      |L17.142|
;;;1377     {
;;;1378       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000072  6941              LDR      r1,[r0,#0x14]
000074  f0210140          BIC      r1,r1,#0x40
000078  6141              STR      r1,[r0,#0x14]
;;;1379   
;;;1380       /* Abort the UART DMA Rx channel : use non blocking DMA Abort API (callback) */
;;;1381       if(huart->hdmarx != NULL)
00007a  6b60              LDR      r0,[r4,#0x34]
00007c  b138              CBZ      r0,|L17.142|
;;;1382       {
;;;1383         /* UART Rx DMA Abort callback has already been initialised : 
;;;1384            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1385   
;;;1386         /* Abort DMA RX */
;;;1387         if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
00007e  f7fffffe          BL       HAL_DMA_Abort_IT
000082  2800              CMP      r0,#0
;;;1388         {
;;;1389           huart->hdmarx->XferAbortCallback = NULL;
000084  bf1c              ITT      NE
000086  6b60              LDRNE    r0,[r4,#0x34]
000088  6385              STRNE    r5,[r0,#0x38]
00008a  d00a              BEQ      |L17.162|
00008c  e000              B        |L17.144|
                  |L17.142|
;;;1390           AbortCplt = 0x01U;
;;;1391         }
;;;1392         else
;;;1393         {
;;;1394           AbortCplt = 0x00U;
;;;1395         }
;;;1396       }
;;;1397     }
;;;1398   
;;;1399     /* if no DMA abort complete callback execution is required => call user Abort Complete callback */
;;;1400     if(AbortCplt == 0x01U)
00008e  b146              CBZ      r6,|L17.162|
                  |L17.144|
;;;1401     {
;;;1402       /* Reset Tx and Rx transfer counters */
;;;1403       huart->TxXferCount = 0x00U; 
000090  84e5              STRH     r5,[r4,#0x26]
;;;1404       huart->RxXferCount = 0x00U;
000092  85e5              STRH     r5,[r4,#0x2e]
;;;1405   
;;;1406       /* Reset ErrorCode */
;;;1407       huart->ErrorCode = HAL_UART_ERROR_NONE;
000094  6465              STR      r5,[r4,#0x44]
;;;1408   
;;;1409       /* Restore huart->gState and huart->RxState to Ready */
;;;1410       huart->gState  = HAL_UART_STATE_READY;
000096  2020              MOVS     r0,#0x20
000098  63e0              STR      r0,[r4,#0x3c]
;;;1411       huart->RxState = HAL_UART_STATE_READY;
00009a  6420              STR      r0,[r4,#0x40]
;;;1412   
;;;1413       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1414       HAL_UART_AbortCpltCallback(huart);
00009c  4620              MOV      r0,r4
00009e  f7fffffe          BL       HAL_UART_AbortCpltCallback
                  |L17.162|
;;;1415     }
;;;1416   
;;;1417     return HAL_OK;
0000a2  2000              MOVS     r0,#0
;;;1418   }
0000a4  bd70              POP      {r4-r6,pc}
;;;1419   
                          ENDP

0000a6  0000              DCW      0x0000
                  |L17.168|
                          DCD      UART_DMATxAbortCallback
                  |L17.172|
                          DCD      UART_DMARxAbortCallback

                          AREA ||i.HAL_UART_DMAPause||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAPause PROC
;;;1035     */
;;;1036   HAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart)
000000  6b81              LDR      r1,[r0,#0x38]
;;;1037   {
;;;1038     uint32_t dmarequest = 0x00U;
;;;1039   
;;;1040     /* Process Locked */
;;;1041     __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  bf04              ITT      EQ
000006  2002              MOVEQ    r0,#2
;;;1042   
;;;1043     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
;;;1044     if((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
;;;1045     {
;;;1046       /* Disable the UART DMA Tx request */
;;;1047       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1048     }
;;;1049   
;;;1050     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
;;;1051     if((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
;;;1052     {
;;;1053       /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1054       CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1055       CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1056   
;;;1057       /* Disable the UART DMA Rx request */
;;;1058       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1059     }
;;;1060   
;;;1061     /* Process Unlocked */
;;;1062     __HAL_UNLOCK(huart);
;;;1063     
;;;1064     return HAL_OK;
;;;1065   }
000008  4770              BXEQ     lr
00000a  2101              MOVS     r1,#1                 ;1041
00000c  6381              STR      r1,[r0,#0x38]         ;1043
00000e  6801              LDR      r1,[r0,#0]            ;1043
000010  694a              LDR      r2,[r1,#0x14]         ;1043
000012  6bc3              LDR      r3,[r0,#0x3c]         ;1044
000014  f3c212c0          UBFX     r2,r2,#7,#1           ;1043
000018  2b21              CMP      r3,#0x21              ;1044
00001a  d104              BNE      |L18.38|
00001c  b11a              CBZ      r2,|L18.38|
00001e  694a              LDR      r2,[r1,#0x14]         ;1047
000020  f0220280          BIC      r2,r2,#0x80           ;1047
000024  614a              STR      r2,[r1,#0x14]         ;1047
                  |L18.38|
000026  6801              LDR      r1,[r0,#0]            ;1050
000028  694a              LDR      r2,[r1,#0x14]         ;1050
00002a  6c03              LDR      r3,[r0,#0x40]         ;1051
00002c  f3c21280          UBFX     r2,r2,#6,#1           ;1050
000030  2b22              CMP      r3,#0x22              ;1051
000032  d10e              BNE      |L18.82|
000034  b16a              CBZ      r2,|L18.82|
000036  68ca              LDR      r2,[r1,#0xc]          ;1054
000038  f4227280          BIC      r2,r2,#0x100          ;1054
00003c  60ca              STR      r2,[r1,#0xc]          ;1054
00003e  6801              LDR      r1,[r0,#0]            ;1055
000040  694a              LDR      r2,[r1,#0x14]         ;1055
000042  f0220201          BIC      r2,r2,#1              ;1055
000046  614a              STR      r2,[r1,#0x14]         ;1055
000048  6801              LDR      r1,[r0,#0]            ;1058
00004a  694a              LDR      r2,[r1,#0x14]         ;1058
00004c  f0220240          BIC      r2,r2,#0x40           ;1058
000050  614a              STR      r2,[r1,#0x14]         ;1058
                  |L18.82|
000052  2100              MOVS     r1,#0                 ;1062
000054  6381              STR      r1,[r0,#0x38]         ;1064
000056  4608              MOV      r0,r1                 ;1064
000058  4770              BX       lr
;;;1066   
                          ENDP


                          AREA ||i.HAL_UART_DMAResume||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAResume PROC
;;;1072     */
;;;1073   HAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart)
000000  6b81              LDR      r1,[r0,#0x38]
;;;1074   {
000002  b081              SUB      sp,sp,#4
;;;1075     /* Process Locked */
;;;1076     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  bf02              ITTT     EQ
000008  2002              MOVEQ    r0,#2
;;;1077     
;;;1078     if(huart->gState == HAL_UART_STATE_BUSY_TX)
;;;1079     {
;;;1080       /* Enable the UART DMA Tx request */
;;;1081       SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1082     }
;;;1083   
;;;1084     if(huart->RxState == HAL_UART_STATE_BUSY_RX)
;;;1085     {
;;;1086       /* Clear the Overrun flag before resuming the Rx transfer*/
;;;1087       __HAL_UART_CLEAR_OREFLAG(huart);
;;;1088       
;;;1089       /* Reenable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1090       SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1091       SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1092       
;;;1093       /* Enable the UART DMA Rx request */
;;;1094       SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1095     }
;;;1096   
;;;1097     /* Process Unlocked */
;;;1098     __HAL_UNLOCK(huart);
;;;1099     
;;;1100     return HAL_OK;
;;;1101   }
00000a  b001              ADDEQ    sp,sp,#4
00000c  4770              BXEQ     lr
00000e  2101              MOVS     r1,#1                 ;1076
000010  6381              STR      r1,[r0,#0x38]         ;1078
000012  6bc1              LDR      r1,[r0,#0x3c]         ;1078
000014  2921              CMP      r1,#0x21              ;1078
000016  d104              BNE      |L19.34|
000018  6801              LDR      r1,[r0,#0]            ;1081
00001a  694a              LDR      r2,[r1,#0x14]         ;1081
00001c  f0420280          ORR      r2,r2,#0x80           ;1081
000020  614a              STR      r2,[r1,#0x14]         ;1081
                  |L19.34|
000022  6c01              LDR      r1,[r0,#0x40]         ;1084
000024  2200              MOVS     r2,#0                 ;1084
000026  2922              CMP      r1,#0x22              ;1084
000028  d111              BNE      |L19.78|
00002a  6801              LDR      r1,[r0,#0]            ;1087
00002c  680b              LDR      r3,[r1,#0]            ;1087
00002e  684b              LDR      r3,[r1,#4]            ;1087
000030  9300              STR      r3,[sp,#0]            ;1090
000032  68cb              LDR      r3,[r1,#0xc]          ;1090
000034  f4437380          ORR      r3,r3,#0x100          ;1090
000038  60cb              STR      r3,[r1,#0xc]          ;1090
00003a  6801              LDR      r1,[r0,#0]            ;1091
00003c  694b              LDR      r3,[r1,#0x14]         ;1091
00003e  f0430301          ORR      r3,r3,#1              ;1091
000042  614b              STR      r3,[r1,#0x14]         ;1091
000044  6801              LDR      r1,[r0,#0]            ;1094
000046  694b              LDR      r3,[r1,#0x14]         ;1094
000048  f0430340          ORR      r3,r3,#0x40           ;1094
00004c  614b              STR      r3,[r1,#0x14]         ;1094
                  |L19.78|
00004e  6382              STR      r2,[r0,#0x38]         ;1100
000050  2000              MOVS     r0,#0                 ;1100
000052  b001              ADD      sp,sp,#4
000054  4770              BX       lr
;;;1102   
                          ENDP


                          AREA ||i.HAL_UART_DMAStop||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAStop PROC
;;;1108     */
;;;1109   HAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1110   {
000002  4604              MOV      r4,r0
;;;1111     uint32_t dmarequest = 0x00U;
;;;1112     /* The Lock is not implemented on this API to allow the user application
;;;1113        to call the HAL UART API under callbacks HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback():
;;;1114        when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
;;;1115        and the correspond call back is executed HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback()
;;;1116        */
;;;1117   
;;;1118     /* Stop UART DMA Tx request if ongoing */
;;;1119     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
000004  6800              LDR      r0,[r0,#0]
000006  6941              LDR      r1,[r0,#0x14]
;;;1120     if((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
000008  6be2              LDR      r2,[r4,#0x3c]
00000a  f3c111c0          UBFX     r1,r1,#7,#1           ;1119
00000e  2520              MOVS     r5,#0x20              ;1119
000010  2a21              CMP      r2,#0x21
000012  d10f              BNE      |L20.52|
000014  b171              CBZ      r1,|L20.52|
;;;1121     {
;;;1122       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000016  6941              LDR      r1,[r0,#0x14]
000018  f0210180          BIC      r1,r1,#0x80
00001c  6141              STR      r1,[r0,#0x14]
;;;1123   
;;;1124       /* Abort the UART DMA Tx channel */
;;;1125       if(huart->hdmatx != NULL)
00001e  6b20              LDR      r0,[r4,#0x30]
000020  2800              CMP      r0,#0
;;;1126       {
;;;1127         HAL_DMA_Abort(huart->hdmatx);
000022  bf18              IT       NE
000024  f7fffffe          BLNE     HAL_DMA_Abort
000028  6820              LDR      r0,[r4,#0]
00002a  68c1              LDR      r1,[r0,#0xc]
00002c  f02101c0          BIC      r1,r1,#0xc0
000030  60c1              STR      r1,[r0,#0xc]
000032  63e5              STR      r5,[r4,#0x3c]
                  |L20.52|
;;;1128       }
;;;1129       UART_EndTxTransfer(huart);
;;;1130     }
;;;1131   
;;;1132     /* Stop UART DMA Rx request if ongoing */
;;;1133     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
000034  6820              LDR      r0,[r4,#0]
000036  6941              LDR      r1,[r0,#0x14]
;;;1134     if((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
000038  6c22              LDR      r2,[r4,#0x40]
00003a  f3c11180          UBFX     r1,r1,#6,#1           ;1133
00003e  2a22              CMP      r2,#0x22
000040  d114              BNE      |L20.108|
000042  b199              CBZ      r1,|L20.108|
;;;1135     {
;;;1136       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000044  6941              LDR      r1,[r0,#0x14]
000046  f0210140          BIC      r1,r1,#0x40
00004a  6141              STR      r1,[r0,#0x14]
;;;1137   
;;;1138       /* Abort the UART DMA Rx channel */
;;;1139       if(huart->hdmarx != NULL)
00004c  6b60              LDR      r0,[r4,#0x34]
00004e  2800              CMP      r0,#0
;;;1140       {
;;;1141         HAL_DMA_Abort(huart->hdmarx);
000050  bf18              IT       NE
000052  f7fffffe          BLNE     HAL_DMA_Abort
000056  6820              LDR      r0,[r4,#0]
000058  68c1              LDR      r1,[r0,#0xc]
00005a  f4217190          BIC      r1,r1,#0x120
00005e  60c1              STR      r1,[r0,#0xc]
000060  6820              LDR      r0,[r4,#0]
000062  6941              LDR      r1,[r0,#0x14]
000064  f0210101          BIC      r1,r1,#1
000068  6141              STR      r1,[r0,#0x14]
00006a  6425              STR      r5,[r4,#0x40]
                  |L20.108|
;;;1142       }
;;;1143       UART_EndRxTransfer(huart);
;;;1144     }
;;;1145   
;;;1146     return HAL_OK;
00006c  2000              MOVS     r0,#0
;;;1147   }
00006e  bd70              POP      {r4-r6,pc}
;;;1148   
                          ENDP


                          AREA ||i.HAL_UART_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_DeInit PROC
;;;518      */
;;;519    HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
000000  2800              CMP      r0,#0
;;;520    {
;;;521      /* Check the UART handle allocation */
;;;522      if(huart == NULL)
;;;523      {
;;;524        return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;525      }
;;;526    
;;;527      /* Check the parameters */
;;;528      assert_param(IS_UART_INSTANCE(huart->Instance));
;;;529    
;;;530      huart->gState = HAL_UART_STATE_BUSY;
;;;531    
;;;532      /* DeInit the low level hardware */
;;;533      HAL_UART_MspDeInit(huart);
;;;534    
;;;535      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;536      huart->gState = HAL_UART_STATE_RESET;
;;;537      huart->RxState = HAL_UART_STATE_RESET;
;;;538    
;;;539      /* Process Unlock */
;;;540      __HAL_UNLOCK(huart);
;;;541    
;;;542      return HAL_OK;
;;;543    }
000006  4770              BXEQ     lr
000008  b510              PUSH     {r4,lr}               ;520
00000a  4604              MOV      r4,r0                 ;520
00000c  2024              MOVS     r0,#0x24              ;530
00000e  63e0              STR      r0,[r4,#0x3c]         ;530
000010  4620              MOV      r0,r4                 ;533
000012  f7fffffe          BL       HAL_UART_MspDeInit
000016  2000              MOVS     r0,#0                 ;535
000018  6460              STR      r0,[r4,#0x44]         ;535
00001a  63e0              STR      r0,[r4,#0x3c]         ;536
00001c  6420              STR      r0,[r4,#0x40]         ;537
00001e  63a0              STR      r0,[r4,#0x38]         ;540
000020  bd10              POP      {r4,pc}
;;;544    
                          ENDP


                          AREA ||i.HAL_UART_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_ErrorCallback PROC
;;;1743     */
;;;1744    __weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1745   {
;;;1746     /* Prevent unused argument(s) compilation warning */
;;;1747     UNUSED(huart); 
;;;1748     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1749              the HAL_UART_ErrorCallback could be implemented in the user file
;;;1750      */ 
;;;1751   }
;;;1752   
                          ENDP


                          AREA ||i.HAL_UART_GetError||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetError PROC
;;;2013     */
;;;2014   uint32_t HAL_UART_GetError(UART_HandleTypeDef *huart)
000000  6c40              LDR      r0,[r0,#0x44]
;;;2015   {
;;;2016     return huart->ErrorCode;
;;;2017   }
000002  4770              BX       lr
;;;2018   
                          ENDP


                          AREA ||i.HAL_UART_GetState||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetState PROC
;;;1998     */
;;;1999   HAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart)
000000  6bc1              LDR      r1,[r0,#0x3c]
;;;2000   {
;;;2001     uint32_t temp1= 0x00U, temp2 = 0x00U;
;;;2002     temp1 = huart->gState;
;;;2003     temp2 = huart->RxState;
000002  6c00              LDR      r0,[r0,#0x40]
;;;2004     
;;;2005     return (HAL_UART_StateTypeDef)(temp1 | temp2);
000004  4308              ORRS     r0,r0,r1
;;;2006   }
000006  4770              BX       lr
;;;2007   
                          ENDP


                          AREA ||i.HAL_UART_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_UART_IRQHandler PROC
;;;1556     */
;;;1557   void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1558   {
;;;1559      uint32_t isrflags   = READ_REG(huart->Instance->SR);
000002  6801              LDR      r1,[r0,#0]
000004  4604              MOV      r4,r0                 ;1558
000006  6808              LDR      r0,[r1,#0]
;;;1560      uint32_t cr1its     = READ_REG(huart->Instance->CR1);
000008  68ca              LDR      r2,[r1,#0xc]
;;;1561      uint32_t cr3its     = READ_REG(huart->Instance->CR3);
00000a  694b              LDR      r3,[r1,#0x14]
;;;1562      uint32_t errorflags = 0x00U;
;;;1563      uint32_t dmarequest = 0x00U;
;;;1564   
;;;1565     /* If no error occurs */
;;;1566     errorflags = (isrflags & (uint32_t)(USART_SR_PE | USART_SR_FE | USART_SR_ORE | USART_SR_NE));
00000c  f0100f0f          TST      r0,#0xf
000010  f04f0520          MOV      r5,#0x20
000014  d044              BEQ      |L25.160|
;;;1567     if(errorflags == RESET)
;;;1568     {
;;;1569       /* UART in mode Receiver -------------------------------------------------*/
;;;1570       if(((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
;;;1571       {
;;;1572         UART_Receive_IT(huart);
;;;1573         return;
;;;1574       }
;;;1575     }
;;;1576   
;;;1577     /* If some errors occur */
;;;1578     if((errorflags != RESET) && (((cr3its & USART_CR3_EIE) != RESET) || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)))
000016  f0030c01          AND      r12,r3,#1
00001a  f4027690          AND      r6,r2,#0x120
00001e  ea5c0c06          ORRS     r12,r12,r6
000022  f00080f7          BEQ.W    |L25.532|
;;;1579     {
;;;1580       /* UART parity error interrupt occurred ----------------------------------*/
;;;1581       if(((isrflags & USART_SR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
000026  f0100f01          TST      r0,#1
00002a  bf18              IT       NE
00002c  f4127f80          TSTNE    r2,#0x100
000030  d005              BEQ      |L25.62|
;;;1582       {
;;;1583         huart->ErrorCode |= HAL_UART_ERROR_PE;
000032  f8d4c044          LDR      r12,[r4,#0x44]
000036  f04c0c01          ORR      r12,r12,#1
00003a  f8c4c044          STR      r12,[r4,#0x44]
                  |L25.62|
;;;1584       }
;;;1585   
;;;1586       /* UART noise error interrupt occurred -----------------------------------*/
;;;1587       if(((isrflags & USART_SR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
00003e  f0100f04          TST      r0,#4
000042  bf18              IT       NE
000044  f0130f01          TSTNE    r3,#1
000048  d005              BEQ      |L25.86|
;;;1588       {
;;;1589         huart->ErrorCode |= HAL_UART_ERROR_NE;
00004a  f8d4c044          LDR      r12,[r4,#0x44]
00004e  f04c0c02          ORR      r12,r12,#2
000052  f8c4c044          STR      r12,[r4,#0x44]
                  |L25.86|
;;;1590       }
;;;1591   
;;;1592       /* UART frame error interrupt occurred -----------------------------------*/
;;;1593       if(((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
000056  f0100f02          TST      r0,#2
00005a  bf18              IT       NE
00005c  f0130f01          TSTNE    r3,#1
000060  d005              BEQ      |L25.110|
;;;1594       {
;;;1595         huart->ErrorCode |= HAL_UART_ERROR_FE;
000062  f8d4c044          LDR      r12,[r4,#0x44]
000066  f04c0c04          ORR      r12,r12,#4
00006a  f8c4c044          STR      r12,[r4,#0x44]
                  |L25.110|
;;;1596       }
;;;1597   
;;;1598       /* UART Over-Run interrupt occurred --------------------------------------*/
;;;1599       if(((isrflags & USART_SR_ORE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
00006e  f0100f08          TST      r0,#8
000072  bf18              IT       NE
000074  f0130f01          TSTNE    r3,#1
000078  d003              BEQ      |L25.130|
;;;1600       { 
;;;1601         huart->ErrorCode |= HAL_UART_ERROR_ORE;
00007a  6c63              LDR      r3,[r4,#0x44]
00007c  f0430308          ORR      r3,r3,#8
000080  6463              STR      r3,[r4,#0x44]
                  |L25.130|
;;;1602       }
;;;1603   
;;;1604       /* Call UART Error Call back function if need be --------------------------*/
;;;1605       if(huart->ErrorCode != HAL_UART_ERROR_NONE)
000082  6c63              LDR      r3,[r4,#0x44]
000084  2b00              CMP      r3,#0
;;;1606       {
;;;1607         /* UART in mode Receiver -----------------------------------------------*/
;;;1608         if(((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
;;;1609         {
;;;1610           UART_Receive_IT(huart);
;;;1611         }
;;;1612   
;;;1613         /* If Overrun error occurs, or if any error occurs in DMA mode reception,
;;;1614            consider error as blocking */
;;;1615         dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
;;;1616         if(((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
;;;1617         {
;;;1618           /* Blocking error : transfer is aborted
;;;1619              Set the UART state ready to be able to start again the process,
;;;1620              Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
;;;1621           UART_EndRxTransfer(huart);
;;;1622   
;;;1623           /* Disable the UART DMA Rx request if enabled */
;;;1624           if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
;;;1625           {
;;;1626             CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1627   
;;;1628             /* Abort the UART DMA Rx channel */
;;;1629             if(huart->hdmarx != NULL)
;;;1630             {
;;;1631               /* Set the UART DMA Abort callback : 
;;;1632                  will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
;;;1633               huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
;;;1634               if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
;;;1635               {
;;;1636                 /* Call Directly XferAbortCallback function in case of error */
;;;1637                 huart->hdmarx->XferAbortCallback(huart->hdmarx);
;;;1638               }
;;;1639             }
;;;1640             else
;;;1641             {
;;;1642               /* Call user error callback */
;;;1643               HAL_UART_ErrorCallback(huart);
;;;1644             }
;;;1645           }
;;;1646           else
;;;1647           {
;;;1648             /* Call user error callback */
;;;1649             HAL_UART_ErrorCallback(huart);
;;;1650           }
;;;1651         }
;;;1652         else
;;;1653         {
;;;1654           /* Non Blocking error : transfer could go on. 
;;;1655              Error is notified to user through user error callback */
;;;1656           HAL_UART_ErrorCallback(huart);
;;;1657           huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1658         }
;;;1659       }
;;;1660       return;
;;;1661     } /* End if some error occurs */
;;;1662   
;;;1663     /* UART in mode Transmitter ------------------------------------------------*/
;;;1664     if(((isrflags & USART_SR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
;;;1665     {
;;;1666       UART_Transmit_IT(huart);
;;;1667       return;
;;;1668     }
;;;1669     
;;;1670     /* UART in mode Transmitter end --------------------------------------------*/
;;;1671     if(((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
;;;1672     {
;;;1673       UART_EndTransmit_IT(huart);
;;;1674       return;
;;;1675     }
;;;1676   }
000086  bf08              IT       EQ
000088  bd70              POPEQ    {r4-r6,pc}
00008a  f0100f20          TST      r0,#0x20              ;1608
00008e  bf18              IT       NE                    ;1608
000090  f0120f20          TSTNE    r2,#0x20              ;1608
000094  d070              BEQ      |L25.376|
000096  6c22              LDR      r2,[r4,#0x40]         ;1608
000098  4620              MOV      r0,r4                 ;1610
00009a  2a22              CMP      r2,#0x22              ;1610
00009c  d049              BEQ      |L25.306|
00009e  e084              B        |L25.426|
                  |L25.160|
0000a0  f0100f20          TST      r0,#0x20              ;1570
0000a4  bf18              IT       NE                    ;1570
0000a6  f0120f20          TSTNE    r2,#0x20              ;1570
0000aa  f00080b3          BEQ.W    |L25.532|
0000ae  6c22              LDR      r2,[r4,#0x40]         ;1570
0000b0  4620              MOV      r0,r4                 ;1572
0000b2  2a22              CMP      r2,#0x22              ;1572
0000b4  bf18              IT       NE
0000b6  bd70              POPNE    {r4-r6,pc}
0000b8  6882              LDR      r2,[r0,#8]
0000ba  f5b25f80          CMP      r2,#0x1000
0000be  d022              BEQ      |L25.262|
0000c0  6902              LDR      r2,[r0,#0x10]
0000c2  b37a              CBZ      r2,|L25.292|
0000c4  6849              LDR      r1,[r1,#4]
0000c6  f001027f          AND      r2,r1,#0x7f
0000ca  6a81              LDR      r1,[r0,#0x28]
0000cc  1c4b              ADDS     r3,r1,#1
0000ce  6283              STR      r3,[r0,#0x28]
0000d0  700a              STRB     r2,[r1,#0]
                  |L25.210|
0000d2  8dc1              LDRH     r1,[r0,#0x2e]
0000d4  1e49              SUBS     r1,r1,#1
0000d6  0409              LSLS     r1,r1,#16
0000d8  0c09              LSRS     r1,r1,#16
0000da  85c1              STRH     r1,[r0,#0x2e]
0000dc  bf18              IT       NE
0000de  bd70              POPNE    {r4-r6,pc}
0000e0  6801              LDR      r1,[r0,#0]
0000e2  68ca              LDR      r2,[r1,#0xc]
0000e4  f0220220          BIC      r2,r2,#0x20
0000e8  60ca              STR      r2,[r1,#0xc]
0000ea  6801              LDR      r1,[r0,#0]
0000ec  68ca              LDR      r2,[r1,#0xc]
0000ee  f4227280          BIC      r2,r2,#0x100
0000f2  60ca              STR      r2,[r1,#0xc]
0000f4  6801              LDR      r1,[r0,#0]
0000f6  694a              LDR      r2,[r1,#0x14]
0000f8  f0220201          BIC      r2,r2,#1
0000fc  614a              STR      r2,[r1,#0x14]
0000fe  6405              STR      r5,[r0,#0x40]
000100  f7fffffe          BL       HAL_UART_RxCpltCallback
000104  bd70              POP      {r4-r6,pc}
                  |L25.262|
000106  6903              LDR      r3,[r0,#0x10]
000108  6a82              LDR      r2,[r0,#0x28]
00010a  6849              LDR      r1,[r1,#4]
00010c  2b00              CMP      r3,#0
00010e  bf14              ITE      NE
000110  b2c9              UXTBNE   r1,r1
000112  f3c10108          UBFXEQ   r1,r1,#0,#9
000116  8011              STRH     r1,[r2,#0]
000118  6a81              LDR      r1,[r0,#0x28]
00011a  bf14              ITE      NE
00011c  1c49              ADDNE    r1,r1,#1
00011e  1c89              ADDEQ    r1,r1,#2
000120  6281              STR      r1,[r0,#0x28]
000122  e7d6              B        |L25.210|
                  |L25.292|
000124  e7ff              B        |L25.294|
                  |L25.294|
000126  684a              LDR      r2,[r1,#4]
000128  6a81              LDR      r1,[r0,#0x28]
00012a  1c4b              ADDS     r3,r1,#1
00012c  6283              STR      r3,[r0,#0x28]
00012e  700a              STRB     r2,[r1,#0]
000130  e7cf              B        |L25.210|
                  |L25.306|
000132  6882              LDR      r2,[r0,#8]
000134  f5b25f80          CMP      r2,#0x1000
000138  d00f              BEQ      |L25.346|
00013a  6902              LDR      r2,[r0,#0x10]
00013c  b1ea              CBZ      r2,|L25.378|
00013e  6849              LDR      r1,[r1,#4]
000140  f001027f          AND      r2,r1,#0x7f
000144  6a81              LDR      r1,[r0,#0x28]
000146  1c4b              ADDS     r3,r1,#1
000148  6283              STR      r3,[r0,#0x28]
00014a  700a              STRB     r2,[r1,#0]
                  |L25.332|
00014c  8dc1              LDRH     r1,[r0,#0x2e]
00014e  1e49              SUBS     r1,r1,#1
000150  0409              LSLS     r1,r1,#16
000152  0c09              LSRS     r1,r1,#16
000154  85c1              STRH     r1,[r0,#0x2e]
000156  d128              BNE      |L25.426|
000158  e015              B        |L25.390|
                  |L25.346|
00015a  6903              LDR      r3,[r0,#0x10]
00015c  6a82              LDR      r2,[r0,#0x28]
00015e  6849              LDR      r1,[r1,#4]
000160  2b00              CMP      r3,#0
000162  bf14              ITE      NE
000164  b2c9              UXTBNE   r1,r1
000166  f3c10108          UBFXEQ   r1,r1,#0,#9
00016a  8011              STRH     r1,[r2,#0]
00016c  6a81              LDR      r1,[r0,#0x28]
00016e  bf14              ITE      NE
000170  1c49              ADDNE    r1,r1,#1
000172  1c89              ADDEQ    r1,r1,#2
000174  6281              STR      r1,[r0,#0x28]
000176  e7e9              B        |L25.332|
                  |L25.376|
000178  e017              B        |L25.426|
                  |L25.378|
00017a  684a              LDR      r2,[r1,#4]
00017c  6a81              LDR      r1,[r0,#0x28]
00017e  1c4b              ADDS     r3,r1,#1
000180  6283              STR      r3,[r0,#0x28]
000182  700a              STRB     r2,[r1,#0]
000184  e7e2              B        |L25.332|
                  |L25.390|
000186  6801              LDR      r1,[r0,#0]
000188  68ca              LDR      r2,[r1,#0xc]
00018a  f0220220          BIC      r2,r2,#0x20
00018e  60ca              STR      r2,[r1,#0xc]
000190  6801              LDR      r1,[r0,#0]
000192  68ca              LDR      r2,[r1,#0xc]
000194  f4227280          BIC      r2,r2,#0x100
000198  60ca              STR      r2,[r1,#0xc]
00019a  6801              LDR      r1,[r0,#0]
00019c  694a              LDR      r2,[r1,#0x14]
00019e  f0220201          BIC      r2,r2,#1
0001a2  614a              STR      r2,[r1,#0x14]
0001a4  6405              STR      r5,[r0,#0x40]
0001a6  f7fffffe          BL       HAL_UART_RxCpltCallback
                  |L25.426|
0001aa  6820              LDR      r0,[r4,#0]            ;1615
0001ac  6941              LDR      r1,[r0,#0x14]         ;1615
0001ae  6c62              LDR      r2,[r4,#0x44]         ;1616
0001b0  f3c11180          UBFX     r1,r1,#6,#1           ;1615
0001b4  f0020208          AND      r2,r2,#8              ;1616
0001b8  4311              ORRS     r1,r1,r2              ;1616
0001ba  d025              BEQ      |L25.520|
0001bc  68c1              LDR      r1,[r0,#0xc]          ;1616
0001be  f4217190          BIC      r1,r1,#0x120          ;1616
0001c2  60c1              STR      r1,[r0,#0xc]          ;1616
0001c4  6820              LDR      r0,[r4,#0]            ;1616
0001c6  6941              LDR      r1,[r0,#0x14]         ;1616
0001c8  f0210101          BIC      r1,r1,#1              ;1616
0001cc  6141              STR      r1,[r0,#0x14]         ;1616
0001ce  6425              STR      r5,[r4,#0x40]         ;1616
0001d0  6820              LDR      r0,[r4,#0]            ;1624
0001d2  6941              LDR      r1,[r0,#0x14]         ;1624
0001d4  f0110f40          TST      r1,#0x40              ;1624
0001d8  d012              BEQ      |L25.512|
0001da  6941              LDR      r1,[r0,#0x14]         ;1626
0001dc  f0210140          BIC      r1,r1,#0x40           ;1626
0001e0  6141              STR      r1,[r0,#0x14]         ;1626
0001e2  6b60              LDR      r0,[r4,#0x34]         ;1629
0001e4  b160              CBZ      r0,|L25.512|
0001e6  492c              LDR      r1,|L25.664|
0001e8  6381              STR      r1,[r0,#0x38]         ;1634
0001ea  6b60              LDR      r0,[r4,#0x34]         ;1634
0001ec  f7fffffe          BL       HAL_DMA_Abort_IT
0001f0  2800              CMP      r0,#0                 ;1634
0001f2  bf08              IT       EQ
0001f4  bd70              POPEQ    {r4-r6,pc}
0001f6  6b60              LDR      r0,[r4,#0x34]         ;1637
0001f8  6b81              LDR      r1,[r0,#0x38]         ;1637
0001fa  e8bd4070          POP      {r4-r6,lr}            ;1637
0001fe  4708              BX       r1                    ;1637
                  |L25.512|
000200  4620              MOV      r0,r4                 ;1649
000202  f7fffffe          BL       HAL_UART_ErrorCallback
000206  bd70              POP      {r4-r6,pc}
                  |L25.520|
000208  4620              MOV      r0,r4                 ;1656
00020a  f7fffffe          BL       HAL_UART_ErrorCallback
00020e  2000              MOVS     r0,#0                 ;1657
000210  6460              STR      r0,[r4,#0x44]         ;1657
000212  bd70              POP      {r4-r6,pc}
                  |L25.532|
000214  f0100f80          TST      r0,#0x80              ;1664
000218  bf18              IT       NE                    ;1664
00021a  f0120f80          TSTNE    r2,#0x80              ;1664
00021e  d02b              BEQ      |L25.632|
000220  6be0              LDR      r0,[r4,#0x3c]         ;1664
000222  2821              CMP      r0,#0x21              ;1664
000224  bf18              IT       NE
000226  bd70              POPNE    {r4-r6,pc}
000228  68a0              LDR      r0,[r4,#8]
00022a  f5b05f80          CMP      r0,#0x1000
00022e  6a20              LDR      r0,[r4,#0x20]
000230  d016              BEQ      |L25.608|
000232  1c41              ADDS     r1,r0,#1
000234  6221              STR      r1,[r4,#0x20]
000236  6821              LDR      r1,[r4,#0]
000238  7800              LDRB     r0,[r0,#0]
00023a  6048              STR      r0,[r1,#4]
                  |L25.572|
00023c  8ce0              LDRH     r0,[r4,#0x26]
00023e  1e40              SUBS     r0,r0,#1
000240  0400              LSLS     r0,r0,#16
000242  0c00              LSRS     r0,r0,#16
000244  84e0              STRH     r0,[r4,#0x26]
000246  bf18              IT       NE
000248  bd70              POPNE    {r4-r6,pc}
00024a  6820              LDR      r0,[r4,#0]
00024c  68c1              LDR      r1,[r0,#0xc]
00024e  f0210180          BIC      r1,r1,#0x80
000252  60c1              STR      r1,[r0,#0xc]
000254  6820              LDR      r0,[r4,#0]
000256  68c1              LDR      r1,[r0,#0xc]
000258  f0410140          ORR      r1,r1,#0x40
00025c  60c1              STR      r1,[r0,#0xc]
00025e  bd70              POP      {r4-r6,pc}
                  |L25.608|
000260  8800              LDRH     r0,[r0,#0]
000262  f3c00008          UBFX     r0,r0,#0,#9
000266  6048              STR      r0,[r1,#4]
000268  6920              LDR      r0,[r4,#0x10]
00026a  2800              CMP      r0,#0
00026c  6a20              LDR      r0,[r4,#0x20]
00026e  bf14              ITE      NE
000270  1c40              ADDNE    r0,r0,#1
000272  1c80              ADDEQ    r0,r0,#2
000274  6220              STR      r0,[r4,#0x20]
000276  e7e1              B        |L25.572|
                  |L25.632|
000278  f0100f40          TST      r0,#0x40              ;1671
00027c  bf14              ITE      NE                    ;1671
00027e  f0120f40          TSTNE    r2,#0x40              ;1671
000282  bd70              POPEQ    {r4-r6,pc}
000284  4620              MOV      r0,r4                 ;1673
000286  68ca              LDR      r2,[r1,#0xc]          ;1673
000288  f0220240          BIC      r2,r2,#0x40           ;1673
00028c  60ca              STR      r2,[r1,#0xc]          ;1673
00028e  63e5              STR      r5,[r4,#0x3c]         ;1673
000290  f7fffffe          BL       HAL_UART_TxCpltCallback
000294  bd70              POP      {r4-r6,pc}
;;;1677   
                          ENDP

000296  0000              DCW      0x0000
                  |L25.664|
                          DCD      UART_DMAAbortOnError

                          AREA ||i.HAL_UART_Init||, CODE, READONLY, ALIGN=1

                  HAL_UART_Init PROC
;;;260      */
;;;261    HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
000000  2800              CMP      r0,#0
;;;262    {
;;;263      /* Check the UART handle allocation */
;;;264      if(huart == NULL)
;;;265      {
;;;266        return HAL_ERROR;
000002  bf04              ITT      EQ
000004  2001              MOVEQ    r0,#1
;;;267      }
;;;268    
;;;269      /* Check the parameters */
;;;270      if(huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
;;;271      {
;;;272        /* The hardware flow control is available only for USART1, USART2, USART3 */
;;;273        assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
;;;274        assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
;;;275      }
;;;276      else
;;;277      {
;;;278        assert_param(IS_UART_INSTANCE(huart->Instance));
;;;279      }
;;;280      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;281    #if defined(USART_CR1_OVER8)
;;;282      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;283    #endif /* USART_CR1_OVER8 */
;;;284      
;;;285      if(huart->gState == HAL_UART_STATE_RESET)
;;;286      {  
;;;287        /* Allocate lock resource and initialize it */
;;;288        huart->Lock = HAL_UNLOCKED;
;;;289    
;;;290        /* Init the low level hardware */
;;;291        HAL_UART_MspInit(huart);
;;;292      }
;;;293    
;;;294      huart->gState = HAL_UART_STATE_BUSY;
;;;295    
;;;296      /* Disable the peripheral */
;;;297      __HAL_UART_DISABLE(huart);
;;;298      
;;;299      /* Set the UART Communication parameters */
;;;300      UART_SetConfig(huart);
;;;301      
;;;302      /* In asynchronous mode, the following bits must be kept cleared: 
;;;303         - LINEN and CLKEN bits in the USART_CR2 register,
;;;304         - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
;;;305      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;306      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;307      
;;;308      /* Enable the peripheral */
;;;309      __HAL_UART_ENABLE(huart);
;;;310      
;;;311      /* Initialize the UART state */
;;;312      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;313      huart->gState= HAL_UART_STATE_READY;
;;;314      huart->RxState= HAL_UART_STATE_READY;
;;;315      
;;;316      return HAL_OK;
;;;317    }
000006  4770              BXEQ     lr
000008  b570              PUSH     {r4-r6,lr}            ;262
00000a  4604              MOV      r4,r0                 ;262
00000c  6bc0              LDR      r0,[r0,#0x3c]         ;285
00000e  2500              MOVS     r5,#0                 ;285
000010  b918              CBNZ     r0,|L26.26|
000012  4620              MOV      r0,r4                 ;291
000014  63a5              STR      r5,[r4,#0x38]         ;291
000016  f7fffffe          BL       HAL_UART_MspInit
                  |L26.26|
00001a  2024              MOVS     r0,#0x24              ;294
00001c  63e0              STR      r0,[r4,#0x3c]         ;294
00001e  6820              LDR      r0,[r4,#0]            ;297
000020  68c1              LDR      r1,[r0,#0xc]          ;297
000022  f4215100          BIC      r1,r1,#0x2000         ;297
000026  60c1              STR      r1,[r0,#0xc]          ;297
000028  4620              MOV      r0,r4                 ;300
00002a  f7fffffe          BL       UART_SetConfig
00002e  6820              LDR      r0,[r4,#0]            ;305
000030  6901              LDR      r1,[r0,#0x10]         ;305
000032  f4214190          BIC      r1,r1,#0x4800         ;305
000036  6101              STR      r1,[r0,#0x10]         ;305
000038  6820              LDR      r0,[r4,#0]            ;306
00003a  6941              LDR      r1,[r0,#0x14]         ;306
00003c  f021012a          BIC      r1,r1,#0x2a           ;306
000040  6141              STR      r1,[r0,#0x14]         ;306
000042  6820              LDR      r0,[r4,#0]            ;309
000044  68c1              LDR      r1,[r0,#0xc]          ;309
000046  f4415100          ORR      r1,r1,#0x2000         ;309
00004a  60c1              STR      r1,[r0,#0xc]          ;309
00004c  6465              STR      r5,[r4,#0x44]         ;312
00004e  2020              MOVS     r0,#0x20              ;313
000050  63e0              STR      r0,[r4,#0x3c]         ;313
000052  6420              STR      r0,[r4,#0x40]         ;314
000054  2000              MOVS     r0,#0                 ;316
000056  bd70              POP      {r4-r6,pc}
;;;318    
                          ENDP


                          AREA ||i.HAL_UART_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspDeInit PROC
;;;565      */
;;;566    __weak void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;567    {
;;;568      /* Prevent unused argument(s) compilation warning */
;;;569      UNUSED(huart);
;;;570      /* NOTE: This function should not be modified, when the callback is needed,
;;;571               the HAL_UART_MspDeInit could be implemented in the user file
;;;572       */
;;;573    }
;;;574    
                          ENDP


                          AREA ||i.HAL_UART_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspInit PROC
;;;550      */
;;;551    __weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;552    {
;;;553      /* Prevent unused argument(s) compilation warning */
;;;554      UNUSED(huart);
;;;555      /* NOTE: This function should not be modified, when the callback is needed,
;;;556               the HAL_UART_MspInit could be implemented in the user file
;;;557       */
;;;558    }
;;;559    
                          ENDP


                          AREA ||i.HAL_UART_Receive||, CODE, READONLY, ALIGN=2

                  HAL_UART_Receive PROC
;;;726      */
;;;727    HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;728    {
000004  4604              MOV      r4,r0
;;;729      uint16_t* tmp;
;;;730      uint32_t tickstart = 0U;
;;;731      
;;;732      /* Check that a Rx process is not already ongoing */
;;;733      if(huart->RxState == HAL_UART_STATE_READY)
000006  6c00              LDR      r0,[r0,#0x40]
000008  461d              MOV      r5,r3                 ;728
00000a  4617              MOV      r7,r2                 ;728
00000c  460e              MOV      r6,r1                 ;728
00000e  2820              CMP      r0,#0x20
000010  d17f              BNE      |L29.274|
;;;734      {
;;;735        if((pData == NULL) || (Size == 0U))
000012  2e00              CMP      r6,#0
000014  bf12              ITEE     NE
000016  2f00              CMPNE    r7,#0
;;;736        {
;;;737          return  HAL_ERROR;
000018  2001              MOVEQ    r0,#1
;;;738        }
;;;739    
;;;740        /* Process Locked */
;;;741        __HAL_LOCK(huart);
;;;742        
;;;743        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;744        huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;745    
;;;746        /* Init tickstart for timeout managment */
;;;747        tickstart = HAL_GetTick();
;;;748    
;;;749        huart->RxXferSize = Size;
;;;750        huart->RxXferCount = Size;
;;;751    
;;;752        /* Check the remain data to be received */
;;;753        while(huart->RxXferCount > 0U)
;;;754        {
;;;755          huart->RxXferCount--;
;;;756          if(huart->Init.WordLength == UART_WORDLENGTH_9B)
;;;757          {
;;;758            if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;759            {
;;;760              return HAL_TIMEOUT;
;;;761            }
;;;762            tmp = (uint16_t*)pData;
;;;763            if(huart->Init.Parity == UART_PARITY_NONE)
;;;764            {
;;;765              *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
;;;766              pData +=2U;
;;;767            }
;;;768            else
;;;769            {
;;;770              *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FF);
;;;771              pData +=1U;
;;;772            }
;;;773    
;;;774          } 
;;;775          else
;;;776          {
;;;777            if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;778            {
;;;779              return HAL_TIMEOUT;
;;;780            }
;;;781            if(huart->Init.Parity == UART_PARITY_NONE)
;;;782            {
;;;783              *pData++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
;;;784            }
;;;785            else
;;;786            {
;;;787              *pData++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
;;;788            }
;;;789    
;;;790          }
;;;791        }
;;;792    
;;;793        /* At end of Rx process, restore huart->RxState to Ready */
;;;794        huart->RxState = HAL_UART_STATE_READY;
;;;795        
;;;796        /* Process Unlocked */
;;;797        __HAL_UNLOCK(huart);
;;;798    
;;;799        return HAL_OK;
;;;800      }
;;;801      else
;;;802      {
;;;803        return HAL_BUSY;
;;;804      }
;;;805    }
00001a  e8bd87f0          POPEQ    {r4-r10,pc}
00001e  6ba0              LDR      r0,[r4,#0x38]         ;741
000020  2801              CMP      r0,#1                 ;741
000022  d076              BEQ      |L29.274|
000024  f04f0a00          MOV      r10,#0                ;743
000028  2001              MOVS     r0,#1                 ;741
00002a  f8c4a044          STR      r10,[r4,#0x44]        ;743
00002e  63a0              STR      r0,[r4,#0x38]         ;743
000030  2022              MOVS     r0,#0x22              ;744
000032  6420              STR      r0,[r4,#0x40]         ;744
000034  f7fffffe          BL       HAL_GetTick
000038  85a7              STRH     r7,[r4,#0x2c]         ;749
00003a  4680              MOV      r8,r0                 ;747
00003c  85e7              STRH     r7,[r4,#0x2e]         ;750
00003e  8de0              LDRH     r0,[r4,#0x2e]         ;753
000040  f04f0920          MOV      r9,#0x20              ;758
000044  2800              CMP      r0,#0                 ;753
000046  d04d              BEQ      |L29.228|
                  |L29.72|
000048  8de0              LDRH     r0,[r4,#0x2e]         ;755
00004a  1e40              SUBS     r0,r0,#1              ;755
00004c  85e0              STRH     r0,[r4,#0x2e]         ;755
00004e  68a0              LDR      r0,[r4,#8]            ;756
000050  f04f0720          MOV      r7,#0x20              ;777
000054  f5b05f80          CMP      r0,#0x1000            ;756
000058  6820              LDR      r0,[r4,#0]            ;756
00005a  6800              LDR      r0,[r0,#0]            ;756
00005c  ea270000          BIC      r0,r7,r0              ;756
000060  d01f              BEQ      |L29.162|
000062  2800              CMP      r0,#0                 ;756
000064  d04b              BEQ      |L29.254|
000066  bf00              NOP                            ;756
                  |L29.104|
000068  f1b53fff          CMP      r5,#0xffffffff        ;756
00006c  d042              BEQ      |L29.244|
00006e  b12d              CBZ      r5,|L29.124|
000070  f7fffffe          BL       HAL_GetTick
000074  eba00108          SUB      r1,r0,r8              ;756
000078  42a9              CMP      r1,r5                 ;756
00007a  d93b              BLS      |L29.244|
                  |L29.124|
00007c  6820              LDR      r0,[r4,#0]            ;756
00007e  68c1              LDR      r1,[r0,#0xc]          ;756
000080  f42171d0          BIC      r1,r1,#0x1a0          ;756
000084  60c1              STR      r1,[r0,#0xc]          ;756
000086  6820              LDR      r0,[r4,#0]            ;756
000088  6941              LDR      r1,[r0,#0x14]         ;756
00008a  f0210101          BIC      r1,r1,#1              ;756
00008e  6141              STR      r1,[r0,#0x14]         ;756
000090  f8c4903c          STR      r9,[r4,#0x3c]         ;756
000094  f8c49040          STR      r9,[r4,#0x40]         ;756
000098  2003              MOVS     r0,#3                 ;779
00009a  f8c4a038          STR      r10,[r4,#0x38]        ;779
00009e  e8bd87f0          POP      {r4-r10,pc}
                  |L29.162|
0000a2  b178              CBZ      r0,|L29.196|
                  |L29.164|
0000a4  f1b53fff          CMP      r5,#0xffffffff
0000a8  d007              BEQ      |L29.186|
0000aa  2d00              CMP      r5,#0
0000ac  d0e6              BEQ      |L29.124|
0000ae  f7fffffe          BL       HAL_GetTick
0000b2  eba00108          SUB      r1,r0,r8
0000b6  42a9              CMP      r1,r5
0000b8  d8e0              BHI      |L29.124|
                  |L29.186|
0000ba  6820              LDR      r0,[r4,#0]
0000bc  6800              LDR      r0,[r0,#0]
0000be  ea370000          BICS     r0,r7,r0
0000c2  d1ef              BNE      |L29.164|
                  |L29.196|
0000c4  6920              LDR      r0,[r4,#0x10]         ;763
0000c6  2800              CMP      r0,#0                 ;763
0000c8  6820              LDR      r0,[r4,#0]            ;770
0000ca  6840              LDR      r0,[r0,#4]            ;770
0000cc  bf0c              ITE      EQ                    ;765
0000ce  f3c00108          UBFXEQ   r1,r0,#0,#9           ;765
0000d2  b2c1              UXTBNE   r1,r0                 ;770
0000d4  4630              MOV      r0,r6                 ;770
0000d6  8031              STRH     r1,[r6,#0]            ;770
0000d8  bf0c              ITE      EQ                    ;766
0000da  1c86              ADDEQ    r6,r0,#2              ;766
0000dc  1c46              ADDNE    r6,r0,#1              ;771
                  |L29.222|
0000de  8de0              LDRH     r0,[r4,#0x2e]         ;787
0000e0  2800              CMP      r0,#0                 ;787
0000e2  d1b1              BNE      |L29.72|
                  |L29.228|
0000e4  f8c49040          STR      r9,[r4,#0x40]         ;794
0000e8  2000              MOVS     r0,#0                 ;799
0000ea  f8c4a038          STR      r10,[r4,#0x38]        ;799
0000ee  e8bd87f0          POP      {r4-r10,pc}
0000f2  e00e              B        |L29.274|
                  |L29.244|
0000f4  6820              LDR      r0,[r4,#0]
0000f6  6800              LDR      r0,[r0,#0]
0000f8  ea370000          BICS     r0,r7,r0
0000fc  d1b4              BNE      |L29.104|
                  |L29.254|
0000fe  6920              LDR      r0,[r4,#0x10]         ;781
000100  2800              CMP      r0,#0                 ;781
000102  6820              LDR      r0,[r4,#0]            ;787
000104  6840              LDR      r0,[r0,#4]            ;787
000106  bf18              IT       NE                    ;787
000108  f000007f          ANDNE    r0,r0,#0x7f           ;787
00010c  f8060b01          STRB     r0,[r6],#1            ;783
000110  e7e5              B        |L29.222|
                  |L29.274|
000112  2002              MOVS     r0,#2                 ;803
000114  e8bd87f0          POP      {r4-r10,pc}
;;;806    
                          ENDP


                          AREA ||i.HAL_UART_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Receive_DMA PROC
;;;968      */
;;;969    HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b538              PUSH     {r3-r5,lr}
;;;970    {
000002  4604              MOV      r4,r0
;;;971      uint32_t *tmp;
;;;972      
;;;973      /* Check that a Rx process is not already ongoing */
;;;974      if(huart->RxState == HAL_UART_STATE_READY) 
000004  6c00              LDR      r0,[r0,#0x40]
000006  2820              CMP      r0,#0x20
000008  d139              BNE      |L30.126|
;;;975      {
;;;976        if((pData == NULL) || (Size == 0U))
00000a  2900              CMP      r1,#0
00000c  bf12              ITEE     NE
00000e  2a00              CMPNE    r2,#0
;;;977        {
;;;978          return HAL_ERROR;
000010  2001              MOVEQ    r0,#1
;;;979        }
;;;980    
;;;981        /* Process Locked */
;;;982        __HAL_LOCK(huart);
;;;983    
;;;984        huart->pRxBuffPtr = pData;
;;;985        huart->RxXferSize = Size;
;;;986    
;;;987        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;988        huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;989    
;;;990        /* Set the UART DMA transfer complete callback */
;;;991        huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
;;;992    
;;;993        /* Set the UART DMA Half transfer complete callback */
;;;994        huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
;;;995    
;;;996        /* Set the DMA error callback */
;;;997        huart->hdmarx->XferErrorCallback = UART_DMAError;
;;;998    
;;;999        /* Set the DMA abort callback */
;;;1000       huart->hdmarx->XferAbortCallback = NULL;
;;;1001   
;;;1002       /* Enable the DMA channel */
;;;1003       tmp = (uint32_t*)&pData;
;;;1004       HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->DR, *(uint32_t*)tmp, Size);
;;;1005   
;;;1006       /* Clear the Overrun flag just before enabling the DMA Rx request: can be mandatory for the second transfer */
;;;1007       __HAL_UART_CLEAR_OREFLAG(huart);
;;;1008   
;;;1009       /* Process Unlocked */
;;;1010       __HAL_UNLOCK(huart);
;;;1011   
;;;1012       /* Enable the UART Parity Error Interrupt */
;;;1013       SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1014   
;;;1015       /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1016       SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1017   
;;;1018       /* Enable the DMA transfer for the receiver request by setting the DMAR bit 
;;;1019       in the UART CR3 register */
;;;1020       SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1021   
;;;1022       return HAL_OK;
;;;1023     }
;;;1024     else
;;;1025     {
;;;1026       return HAL_BUSY;
;;;1027     }
;;;1028   }
000012  bd38              POPEQ    {r3-r5,pc}
000014  6ba0              LDR      r0,[r4,#0x38]         ;982
000016  2801              CMP      r0,#1                 ;982
000018  d031              BEQ      |L30.126|
00001a  2001              MOVS     r0,#1                 ;982
00001c  62a1              STR      r1,[r4,#0x28]         ;985
00001e  63a0              STR      r0,[r4,#0x38]         ;985
000020  85a2              STRH     r2,[r4,#0x2c]         ;985
000022  2500              MOVS     r5,#0                 ;987
000024  6465              STR      r5,[r4,#0x44]         ;987
000026  2022              MOVS     r0,#0x22              ;988
000028  6420              STR      r0,[r4,#0x40]         ;988
00002a  6b63              LDR      r3,[r4,#0x34]         ;991
00002c  4815              LDR      r0,|L30.132|
00002e  62d8              STR      r0,[r3,#0x2c]         ;994
000030  6b63              LDR      r3,[r4,#0x34]         ;994
000032  4815              LDR      r0,|L30.136|
000034  6318              STR      r0,[r3,#0x30]         ;997
000036  6b63              LDR      r3,[r4,#0x34]         ;997
000038  4814              LDR      r0,|L30.140|
00003a  6358              STR      r0,[r3,#0x34]         ;1000
00003c  6b60              LDR      r0,[r4,#0x34]         ;1000
00003e  4613              MOV      r3,r2                 ;1004
000040  6385              STR      r5,[r0,#0x38]         ;1000
000042  4608              MOV      r0,r1                 ;1000
000044  f8d4c034          LDR      r12,[r4,#0x34]        ;1004
000048  6821              LDR      r1,[r4,#0]            ;1004
00004a  4602              MOV      r2,r0                 ;1004
00004c  4660              MOV      r0,r12                ;1004
00004e  1d09              ADDS     r1,r1,#4              ;1004
000050  f7fffffe          BL       HAL_DMA_Start_IT
000054  6820              LDR      r0,[r4,#0]            ;1007
000056  6801              LDR      r1,[r0,#0]            ;1007
000058  6841              LDR      r1,[r0,#4]            ;1007
00005a  9100              STR      r1,[sp,#0]            ;1010
00005c  63a5              STR      r5,[r4,#0x38]         ;1013
00005e  68c1              LDR      r1,[r0,#0xc]          ;1013
000060  f4417180          ORR      r1,r1,#0x100          ;1013
000064  60c1              STR      r1,[r0,#0xc]          ;1013
000066  6820              LDR      r0,[r4,#0]            ;1016
000068  6941              LDR      r1,[r0,#0x14]         ;1016
00006a  f0410101          ORR      r1,r1,#1              ;1016
00006e  6141              STR      r1,[r0,#0x14]         ;1016
000070  6820              LDR      r0,[r4,#0]            ;1020
000072  6941              LDR      r1,[r0,#0x14]         ;1020
000074  f0410140          ORR      r1,r1,#0x40           ;1020
000078  6141              STR      r1,[r0,#0x14]         ;1020
00007a  2000              MOVS     r0,#0                 ;1022
00007c  bd38              POP      {r3-r5,pc}
                  |L30.126|
00007e  2002              MOVS     r0,#2                 ;1026
000080  bd38              POP      {r3-r5,pc}
;;;1029   
                          ENDP

000082  0000              DCW      0x0000
                  |L30.132|
                          DCD      UART_DMAReceiveCplt
                  |L30.136|
                          DCD      UART_DMARxHalfCplt
                  |L30.140|
                          DCD      UART_DMAError

                          AREA ||i.HAL_UART_Receive_IT||, CODE, READONLY, ALIGN=1

                  HAL_UART_Receive_IT PROC
;;;855      */
;;;856    HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  6c03              LDR      r3,[r0,#0x40]
;;;857    {
;;;858      /* Check that a Rx process is not already ongoing */
;;;859      if(huart->RxState == HAL_UART_STATE_READY)
000002  2b20              CMP      r3,#0x20
000004  d120              BNE      |L31.72|
;;;860      {
;;;861        if((pData == NULL) || (Size == 0U))
000006  2900              CMP      r1,#0
000008  bf12              ITEE     NE
00000a  2a00              CMPNE    r2,#0
;;;862        {
;;;863          return HAL_ERROR;
00000c  2001              MOVEQ    r0,#1
;;;864        }
;;;865    
;;;866        /* Process Locked */
;;;867        __HAL_LOCK(huart);
;;;868    
;;;869        huart->pRxBuffPtr = pData;
;;;870        huart->RxXferSize = Size;
;;;871        huart->RxXferCount = Size;
;;;872    
;;;873        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;874        huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;875        
;;;876        /* Process Unlocked */
;;;877        __HAL_UNLOCK(huart);
;;;878    
;;;879        /* Enable the UART Parity Error Interrupt */
;;;880        __HAL_UART_ENABLE_IT(huart, UART_IT_PE);
;;;881    
;;;882        /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;883        __HAL_UART_ENABLE_IT(huart, UART_IT_ERR);
;;;884    
;;;885        /* Enable the UART Data Register not empty Interrupt */
;;;886        __HAL_UART_ENABLE_IT(huart, UART_IT_RXNE);
;;;887    
;;;888        return HAL_OK;
;;;889      }
;;;890      else
;;;891      {
;;;892        return HAL_BUSY;
;;;893      }
;;;894    }
00000e  4770              BXEQ     lr
000010  6b83              LDR      r3,[r0,#0x38]         ;867
000012  2b01              CMP      r3,#1                 ;867
000014  d018              BEQ      |L31.72|
000016  6281              STR      r1,[r0,#0x28]         ;870
000018  8582              STRH     r2,[r0,#0x2c]         ;870
00001a  85c2              STRH     r2,[r0,#0x2e]         ;871
00001c  2100              MOVS     r1,#0                 ;873
00001e  6441              STR      r1,[r0,#0x44]         ;873
000020  2222              MOVS     r2,#0x22              ;874
000022  6402              STR      r2,[r0,#0x40]         ;874
000024  6381              STR      r1,[r0,#0x38]         ;880
000026  6801              LDR      r1,[r0,#0]            ;880
000028  68ca              LDR      r2,[r1,#0xc]          ;880
00002a  f4427280          ORR      r2,r2,#0x100          ;880
00002e  60ca              STR      r2,[r1,#0xc]          ;880
000030  6801              LDR      r1,[r0,#0]            ;883
000032  694a              LDR      r2,[r1,#0x14]         ;883
000034  f0420201          ORR      r2,r2,#1              ;883
000038  614a              STR      r2,[r1,#0x14]         ;883
00003a  6800              LDR      r0,[r0,#0]            ;886
00003c  68c1              LDR      r1,[r0,#0xc]          ;886
00003e  f0410120          ORR      r1,r1,#0x20           ;886
000042  60c1              STR      r1,[r0,#0xc]          ;886
000044  2000              MOVS     r0,#0                 ;888
000046  4770              BX       lr
                  |L31.72|
000048  2002              MOVS     r0,#2                 ;892
00004a  4770              BX       lr
;;;895    
                          ENDP


                          AREA ||i.HAL_UART_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxCpltCallback PROC
;;;1713     */
;;;1714   __weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1715   {
;;;1716     /* Prevent unused argument(s) compilation warning */
;;;1717     UNUSED(huart);
;;;1718     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1719              the HAL_UART_RxCpltCallback could be implemented in the user file
;;;1720      */
;;;1721   }
;;;1722   
                          ENDP


                          AREA ||i.HAL_UART_RxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxHalfCpltCallback PROC
;;;1728     */
;;;1729   __weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1730   {
;;;1731     /* Prevent unused argument(s) compilation warning */
;;;1732     UNUSED(huart);
;;;1733     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1734              the HAL_UART_RxHalfCpltCallback could be implemented in the user file
;;;1735      */
;;;1736   }
;;;1737   
                          ENDP


                          AREA ||i.HAL_UART_Transmit||, CODE, READONLY, ALIGN=2

                  HAL_UART_Transmit PROC
;;;644      */
;;;645    HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;646    {
000004  4604              MOV      r4,r0
;;;647      uint16_t* tmp;
;;;648      uint32_t tickstart = 0U;
;;;649      
;;;650      /* Check that a Tx process is not already ongoing */
;;;651      if(huart->gState == HAL_UART_STATE_READY)
000006  6bc0              LDR      r0,[r0,#0x3c]
000008  461d              MOV      r5,r3                 ;646
00000a  4617              MOV      r7,r2                 ;646
00000c  460e              MOV      r6,r1                 ;646
00000e  2820              CMP      r0,#0x20
000010  d17e              BNE      |L34.272|
;;;652      {
;;;653        if((pData == NULL) || (Size == 0U))
000012  2e00              CMP      r6,#0
000014  bf12              ITEE     NE
000016  2f00              CMPNE    r7,#0
;;;654        {
;;;655          return  HAL_ERROR;
000018  2001              MOVEQ    r0,#1
;;;656        }
;;;657    
;;;658        /* Process Locked */
;;;659        __HAL_LOCK(huart);
;;;660    
;;;661        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;662        huart->gState = HAL_UART_STATE_BUSY_TX;
;;;663    
;;;664        /* Init tickstart for timeout managment */
;;;665        tickstart = HAL_GetTick();
;;;666    
;;;667        huart->TxXferSize = Size;
;;;668        huart->TxXferCount = Size;
;;;669        while(huart->TxXferCount > 0U)
;;;670        {
;;;671          huart->TxXferCount--;
;;;672          if(huart->Init.WordLength == UART_WORDLENGTH_9B)
;;;673          {
;;;674            if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;675            {
;;;676              return HAL_TIMEOUT;
;;;677            }
;;;678            tmp = (uint16_t*) pData;
;;;679            huart->Instance->DR = (*tmp & (uint16_t)0x01FF);
;;;680            if(huart->Init.Parity == UART_PARITY_NONE)
;;;681            {
;;;682              pData +=2U;
;;;683            }
;;;684            else
;;;685            {
;;;686              pData +=1U;
;;;687            }
;;;688          }
;;;689          else
;;;690          {
;;;691            if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;692            {
;;;693              return HAL_TIMEOUT;
;;;694            }
;;;695            huart->Instance->DR = (*pData++ & (uint8_t)0xFF);
;;;696          }
;;;697        }
;;;698    
;;;699        if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
;;;700        {
;;;701          return HAL_TIMEOUT;
;;;702        }
;;;703    
;;;704        /* At end of Tx process, restore huart->gState to Ready */
;;;705        huart->gState = HAL_UART_STATE_READY;
;;;706    
;;;707        /* Process Unlocked */
;;;708        __HAL_UNLOCK(huart);
;;;709    
;;;710        return HAL_OK;
;;;711      }
;;;712      else
;;;713      {
;;;714        return HAL_BUSY;
;;;715      }
;;;716    }
00001a  e8bd8ff8          POPEQ    {r3-r11,pc}
00001e  6ba0              LDR      r0,[r4,#0x38]         ;659
000020  2801              CMP      r0,#1                 ;659
000022  d07b              BEQ      |L34.284|
000024  f04f0a00          MOV      r10,#0                ;661
000028  2001              MOVS     r0,#1                 ;659
00002a  f8c4a044          STR      r10,[r4,#0x44]        ;661
00002e  63a0              STR      r0,[r4,#0x38]         ;661
000030  2021              MOVS     r0,#0x21              ;662
000032  63e0              STR      r0,[r4,#0x3c]         ;662
000034  f7fffffe          BL       HAL_GetTick
000038  84a7              STRH     r7,[r4,#0x24]         ;667
00003a  4680              MOV      r8,r0                 ;665
00003c  84e7              STRH     r7,[r4,#0x26]         ;668
00003e  8ce0              LDRH     r0,[r4,#0x26]         ;669
000040  f04f0920          MOV      r9,#0x20              ;669
000044  2800              CMP      r0,#0                 ;669
000046  d054              BEQ      |L34.242|
                  |L34.72|
000048  8ce0              LDRH     r0,[r4,#0x26]         ;671
00004a  1e40              SUBS     r0,r0,#1              ;671
00004c  84e0              STRH     r0,[r4,#0x26]         ;671
00004e  68a0              LDR      r0,[r4,#8]            ;672
000050  f04f0780          MOV      r7,#0x80              ;691
000054  f5b05f80          CMP      r0,#0x1000            ;672
000058  6820              LDR      r0,[r4,#0]            ;672
00005a  6800              LDR      r0,[r0,#0]            ;672
00005c  ea270000          BIC      r0,r7,r0              ;672
000060  d01f              BEQ      |L34.162|
000062  2800              CMP      r0,#0                 ;672
000064  d03e              BEQ      |L34.228|
000066  bf00              NOP                            ;672
                  |L34.104|
000068  f1b53fff          CMP      r5,#0xffffffff        ;672
00006c  d035              BEQ      |L34.218|
00006e  b12d              CBZ      r5,|L34.124|
000070  f7fffffe          BL       HAL_GetTick
000074  eba00108          SUB      r1,r0,r8              ;672
000078  42a9              CMP      r1,r5                 ;672
00007a  d92e              BLS      |L34.218|
                  |L34.124|
00007c  6820              LDR      r0,[r4,#0]            ;672
00007e  68c1              LDR      r1,[r0,#0xc]          ;672
000080  f42171d0          BIC      r1,r1,#0x1a0          ;672
000084  60c1              STR      r1,[r0,#0xc]          ;672
000086  6820              LDR      r0,[r4,#0]            ;672
000088  6941              LDR      r1,[r0,#0x14]         ;672
00008a  f0210101          BIC      r1,r1,#1              ;672
00008e  6141              STR      r1,[r0,#0x14]         ;672
000090  f8c4903c          STR      r9,[r4,#0x3c]         ;672
000094  f8c49040          STR      r9,[r4,#0x40]         ;672
000098  2003              MOVS     r0,#3                 ;693
00009a  f8c4a038          STR      r10,[r4,#0x38]        ;693
00009e  e8bd8ff8          POP      {r3-r11,pc}
                  |L34.162|
0000a2  b178              CBZ      r0,|L34.196|
                  |L34.164|
0000a4  f1b53fff          CMP      r5,#0xffffffff
0000a8  d007              BEQ      |L34.186|
0000aa  2d00              CMP      r5,#0
0000ac  d0e6              BEQ      |L34.124|
0000ae  f7fffffe          BL       HAL_GetTick
0000b2  eba00108          SUB      r1,r0,r8
0000b6  42a9              CMP      r1,r5
0000b8  d8e0              BHI      |L34.124|
                  |L34.186|
0000ba  6820              LDR      r0,[r4,#0]
0000bc  6800              LDR      r0,[r0,#0]
0000be  ea370000          BICS     r0,r7,r0
0000c2  d1ef              BNE      |L34.164|
                  |L34.196|
0000c4  8830              LDRH     r0,[r6,#0]            ;679
0000c6  6821              LDR      r1,[r4,#0]            ;679
0000c8  f3c00008          UBFX     r0,r0,#0,#9           ;679
0000cc  6048              STR      r0,[r1,#4]            ;679
0000ce  6920              LDR      r0,[r4,#0x10]         ;680
0000d0  2800              CMP      r0,#0                 ;680
0000d2  bf0c              ITE      EQ                    ;680
0000d4  1cb6              ADDEQ    r6,r6,#2              ;680
0000d6  1c76              ADDNE    r6,r6,#1              ;680
0000d8  e008              B        |L34.236|
                  |L34.218|
0000da  6820              LDR      r0,[r4,#0]            ;680
0000dc  6800              LDR      r0,[r0,#0]            ;680
0000de  ea370000          BICS     r0,r7,r0              ;680
0000e2  d1c1              BNE      |L34.104|
                  |L34.228|
0000e4  6821              LDR      r1,[r4,#0]            ;695
0000e6  f8160b01          LDRB     r0,[r6],#1            ;695
0000ea  6048              STR      r0,[r1,#4]            ;695
                  |L34.236|
0000ec  8ce0              LDRH     r0,[r4,#0x26]         ;695
0000ee  2800              CMP      r0,#0                 ;695
0000f0  d1aa              BNE      |L34.72|
                  |L34.242|
0000f2  4643              MOV      r3,r8                 ;699
0000f4  2200              MOVS     r2,#0                 ;699
0000f6  2140              MOVS     r1,#0x40              ;699
0000f8  4620              MOV      r0,r4                 ;699
0000fa  9500              STR      r5,[sp,#0]            ;699
0000fc  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
000100  2800              CMP      r0,#0                 ;699
000102  bf1c              ITT      NE                    ;701
000104  2003              MOVNE    r0,#3                 ;701
000106  e8bd8ff8          POPNE    {r3-r11,pc}
00010a  f8c4903c          STR      r9,[r4,#0x3c]         ;705
00010e  e000              B        |L34.274|
                  |L34.272|
000110  e004              B        |L34.284|
                  |L34.274|
000112  2000              MOVS     r0,#0                 ;710
000114  f8c4a038          STR      r10,[r4,#0x38]        ;710
000118  e8bd8ff8          POP      {r3-r11,pc}
                  |L34.284|
00011c  2002              MOVS     r0,#2                 ;714
00011e  e8bd8ff8          POP      {r3-r11,pc}
;;;717    
                          ENDP


                          AREA ||i.HAL_UART_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Transmit_DMA PROC
;;;903      */
;;;904    HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;905    {
000002  4604              MOV      r4,r0
;;;906      uint32_t *tmp;
;;;907      
;;;908      /* Check that a Tx process is not already ongoing */
;;;909      if(huart->gState == HAL_UART_STATE_READY)
000004  6bc0              LDR      r0,[r0,#0x3c]
000006  2820              CMP      r0,#0x20
000008  d12f              BNE      |L35.106|
;;;910      {
;;;911        if((pData == NULL) || (Size == 0U))
00000a  2900              CMP      r1,#0
00000c  bf12              ITEE     NE
00000e  2a00              CMPNE    r2,#0
;;;912        {
;;;913          return HAL_ERROR;
000010  2001              MOVEQ    r0,#1
;;;914        }
;;;915    
;;;916        /* Process Locked */
;;;917        __HAL_LOCK(huart);
;;;918    
;;;919        huart->pTxBuffPtr = pData;
;;;920        huart->TxXferSize = Size;
;;;921        huart->TxXferCount = Size;
;;;922    
;;;923        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;924        huart->gState = HAL_UART_STATE_BUSY_TX;
;;;925    
;;;926        /* Set the UART DMA transfer complete callback */
;;;927        huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
;;;928    
;;;929        /* Set the UART DMA Half transfer complete callback */
;;;930        huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
;;;931    
;;;932        /* Set the DMA error callback */
;;;933        huart->hdmatx->XferErrorCallback = UART_DMAError;
;;;934    
;;;935        /* Set the DMA abort callback */
;;;936        huart->hdmatx->XferAbortCallback = NULL;
;;;937    
;;;938        /* Enable the UART transmit DMA channel */
;;;939        tmp = (uint32_t*)&pData;
;;;940        HAL_DMA_Start_IT(huart->hdmatx, *(uint32_t*)tmp, (uint32_t)&huart->Instance->DR, Size);
;;;941    
;;;942        /* Clear the TC flag in the SR register by writing 0 to it */
;;;943        __HAL_UART_CLEAR_FLAG(huart, UART_FLAG_TC);
;;;944    
;;;945        /* Process Unlocked */
;;;946        __HAL_UNLOCK(huart);
;;;947    
;;;948        /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;949           in the UART CR3 register */
;;;950        SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;951    
;;;952        return HAL_OK;
;;;953      }
;;;954      else
;;;955      {
;;;956        return HAL_BUSY;
;;;957      }
;;;958    }
000012  bd70              POPEQ    {r4-r6,pc}
000014  6ba0              LDR      r0,[r4,#0x38]         ;917
000016  2801              CMP      r0,#1                 ;917
000018  d027              BEQ      |L35.106|
00001a  2001              MOVS     r0,#1                 ;917
00001c  6221              STR      r1,[r4,#0x20]         ;920
00001e  63a0              STR      r0,[r4,#0x38]         ;920
000020  84a2              STRH     r2,[r4,#0x24]         ;920
000022  84e2              STRH     r2,[r4,#0x26]         ;921
000024  2500              MOVS     r5,#0                 ;923
000026  6465              STR      r5,[r4,#0x44]         ;923
000028  2021              MOVS     r0,#0x21              ;924
00002a  63e0              STR      r0,[r4,#0x3c]         ;924
00002c  6b23              LDR      r3,[r4,#0x30]         ;927
00002e  4810              LDR      r0,|L35.112|
000030  62d8              STR      r0,[r3,#0x2c]         ;930
000032  6b23              LDR      r3,[r4,#0x30]         ;930
000034  480f              LDR      r0,|L35.116|
000036  6318              STR      r0,[r3,#0x30]         ;933
000038  6b23              LDR      r3,[r4,#0x30]         ;933
00003a  480f              LDR      r0,|L35.120|
00003c  6358              STR      r0,[r3,#0x34]         ;936
00003e  6b20              LDR      r0,[r4,#0x30]         ;936
000040  4613              MOV      r3,r2                 ;940
000042  6385              STR      r5,[r0,#0x38]         ;940
000044  6820              LDR      r0,[r4,#0]            ;940
000046  f1000c04          ADD      r12,r0,#4             ;940
00004a  4662              MOV      r2,r12                ;940
00004c  6b20              LDR      r0,[r4,#0x30]         ;940
00004e  f7fffffe          BL       HAL_DMA_Start_IT
000052  6821              LDR      r1,[r4,#0]            ;943
000054  f06f0040          MVN      r0,#0x40              ;943
000058  6008              STR      r0,[r1,#0]            ;943
00005a  63a5              STR      r5,[r4,#0x38]         ;950
00005c  6820              LDR      r0,[r4,#0]            ;950
00005e  6941              LDR      r1,[r0,#0x14]         ;950
000060  f0410180          ORR      r1,r1,#0x80           ;950
000064  6141              STR      r1,[r0,#0x14]         ;950
000066  2000              MOVS     r0,#0                 ;952
000068  bd70              POP      {r4-r6,pc}
                  |L35.106|
00006a  2002              MOVS     r0,#2                 ;956
00006c  bd70              POP      {r4-r6,pc}
;;;959    
                          ENDP

00006e  0000              DCW      0x0000
                  |L35.112|
                          DCD      UART_DMATransmitCplt
                  |L35.116|
                          DCD      UART_DMATxHalfCplt
                  |L35.120|
                          DCD      UART_DMAError

                          AREA ||i.HAL_UART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  HAL_UART_Transmit_IT PROC
;;;814      */
;;;815    HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  6bc3              LDR      r3,[r0,#0x3c]
;;;816    {
;;;817      /* Check that a Tx process is not already ongoing */
;;;818      if(huart->gState == HAL_UART_STATE_READY)
000002  2b20              CMP      r3,#0x20
000004  d116              BNE      |L36.52|
;;;819      {
;;;820        if((pData == NULL) || (Size == 0U)) 
000006  2900              CMP      r1,#0
000008  bf12              ITEE     NE
00000a  2a00              CMPNE    r2,#0
;;;821        {
;;;822          return HAL_ERROR;
00000c  2001              MOVEQ    r0,#1
;;;823        }
;;;824        /* Process Locked */
;;;825        __HAL_LOCK(huart);
;;;826    
;;;827        huart->pTxBuffPtr = pData;
;;;828        huart->TxXferSize = Size;
;;;829        huart->TxXferCount = Size;
;;;830    
;;;831        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;832        huart->gState = HAL_UART_STATE_BUSY_TX;
;;;833    
;;;834        /* Process Unlocked */
;;;835        __HAL_UNLOCK(huart);
;;;836    
;;;837        /* Enable the UART Transmit data register empty Interrupt */
;;;838        __HAL_UART_ENABLE_IT(huart, UART_IT_TXE);
;;;839    
;;;840        return HAL_OK;
;;;841      }
;;;842      else
;;;843      {
;;;844        return HAL_BUSY;
;;;845      }
;;;846    }
00000e  4770              BXEQ     lr
000010  6b83              LDR      r3,[r0,#0x38]         ;825
000012  2b01              CMP      r3,#1                 ;825
000014  d00e              BEQ      |L36.52|
000016  6201              STR      r1,[r0,#0x20]         ;828
000018  8482              STRH     r2,[r0,#0x24]         ;828
00001a  84c2              STRH     r2,[r0,#0x26]         ;829
00001c  2100              MOVS     r1,#0                 ;831
00001e  6441              STR      r1,[r0,#0x44]         ;831
000020  2221              MOVS     r2,#0x21              ;832
000022  63c2              STR      r2,[r0,#0x3c]         ;832
000024  6381              STR      r1,[r0,#0x38]         ;838
000026  6800              LDR      r0,[r0,#0]            ;838
000028  68c1              LDR      r1,[r0,#0xc]          ;838
00002a  f0410180          ORR      r1,r1,#0x80           ;838
00002e  60c1              STR      r1,[r0,#0xc]          ;838
000030  2000              MOVS     r0,#0                 ;840
000032  4770              BX       lr
                  |L36.52|
000034  2002              MOVS     r0,#2                 ;844
000036  4770              BX       lr
;;;847    
                          ENDP


                          AREA ||i.HAL_UART_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxCpltCallback PROC
;;;1683     */
;;;1684    __weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1685   {
;;;1686     /* Prevent unused argument(s) compilation warning */
;;;1687     UNUSED(huart);
;;;1688     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1689              the HAL_UART_TxCpltCallback could be implemented in the user file
;;;1690      */ 
;;;1691   }
;;;1692   
                          ENDP


                          AREA ||i.HAL_UART_TxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxHalfCpltCallback PROC
;;;1698     */
;;;1699    __weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1700   {
;;;1701     /* Prevent unused argument(s) compilation warning */
;;;1702     UNUSED(huart);
;;;1703     /* NOTE: This function Should not be modified, when the callback is needed,
;;;1704              the HAL_UART_TxHalfCpltCallback could be implemented in the user file
;;;1705      */ 
;;;1706   }
;;;1707   
                          ENDP


                          AREA ||i.UART_DMAAbortOnError||, CODE, READONLY, ALIGN=1

                  UART_DMAAbortOnError PROC
;;;2205     */
;;;2206   static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2207   {
;;;2208     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a80              LDR      r0,[r0,#0x28]
;;;2209     huart->RxXferCount = 0x00U;
000004  2100              MOVS     r1,#0
000006  85c1              STRH     r1,[r0,#0x2e]
;;;2210     huart->TxXferCount = 0x00U;
000008  84c1              STRH     r1,[r0,#0x26]
;;;2211   
;;;2212     HAL_UART_ErrorCallback(huart);
00000a  f7fffffe          BL       HAL_UART_ErrorCallback
;;;2213   }
00000e  bd10              POP      {r4,pc}
;;;2214   
                          ENDP


                          AREA ||i.UART_DMAError||, CODE, READONLY, ALIGN=1

                  UART_DMAError PROC
;;;2107     */
;;;2108   static void UART_DMAError(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2109   {
;;;2110     uint32_t dmarequest = 0x00U;
;;;2111     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a80              LDR      r0,[r0,#0x28]
;;;2112   
;;;2113     /* Stop UART DMA Tx request if ongoing */
;;;2114     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
000004  6801              LDR      r1,[r0,#0]
000006  6949              LDR      r1,[r1,#0x14]
;;;2115     if((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
000008  f8d0c03c          LDR      r12,[r0,#0x3c]
00000c  f3c111c0          UBFX     r1,r1,#7,#1           ;2114
000010  2200              MOVS     r2,#0
000012  2320              MOVS     r3,#0x20
000014  f1bc0f21          CMP      r12,#0x21
000018  d109              BNE      |L40.46|
00001a  b141              CBZ      r1,|L40.46|
;;;2116     {
;;;2117       huart->TxXferCount = 0U;
00001c  84c2              STRH     r2,[r0,#0x26]
00001e  6801              LDR      r1,[r0,#0]
000020  f8d1c00c          LDR      r12,[r1,#0xc]
000024  f02c0cc0          BIC      r12,r12,#0xc0
000028  f8c1c00c          STR      r12,[r1,#0xc]
00002c  63c3              STR      r3,[r0,#0x3c]
                  |L40.46|
;;;2118       UART_EndTxTransfer(huart);
;;;2119     }
;;;2120   
;;;2121     /* Stop UART DMA Rx request if ongoing */
;;;2122     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR); 
00002e  6801              LDR      r1,[r0,#0]
000030  f8d1c014          LDR      r12,[r1,#0x14]
;;;2123     if((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
000034  6c04              LDR      r4,[r0,#0x40]
000036  f3cc1c80          UBFX     r12,r12,#6,#1         ;2122
00003a  2c22              CMP      r4,#0x22
00003c  d10d              BNE      |L40.90|
00003e  f1bc0f00          CMP      r12,#0
000042  d00a              BEQ      |L40.90|
;;;2124     {
;;;2125       huart->RxXferCount = 0U;
000044  85c2              STRH     r2,[r0,#0x2e]
000046  68ca              LDR      r2,[r1,#0xc]
000048  f4227290          BIC      r2,r2,#0x120
00004c  60ca              STR      r2,[r1,#0xc]
00004e  6801              LDR      r1,[r0,#0]
000050  694a              LDR      r2,[r1,#0x14]
000052  f0220201          BIC      r2,r2,#1
000056  614a              STR      r2,[r1,#0x14]
000058  6403              STR      r3,[r0,#0x40]
                  |L40.90|
;;;2126       UART_EndRxTransfer(huart);
;;;2127     }
;;;2128   
;;;2129     huart->ErrorCode |= HAL_UART_ERROR_DMA;
00005a  6c41              LDR      r1,[r0,#0x44]
00005c  f0410110          ORR      r1,r1,#0x10
000060  6441              STR      r1,[r0,#0x44]
;;;2130     HAL_UART_ErrorCallback(huart);
000062  f7fffffe          BL       HAL_UART_ErrorCallback
;;;2131   }
000066  bd10              POP      {r4,pc}
;;;2132   
                          ENDP


                          AREA ||i.UART_DMAReceiveCplt||, CODE, READONLY, ALIGN=1

                  UART_DMAReceiveCplt PROC
;;;2068     */
;;;2069   static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2070   {
000002  4601              MOV      r1,r0
;;;2071     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6a80              LDR      r0,[r0,#0x28]
;;;2072     /* DMA Normal mode*/
;;;2073     if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
000006  6809              LDR      r1,[r1,#0]
000008  6809              LDR      r1,[r1,#0]
00000a  f0110f20          TST      r1,#0x20
00000e  d112              BNE      |L41.54|
;;;2074     {
;;;2075       huart->RxXferCount = 0U;
000010  2100              MOVS     r1,#0
000012  85c1              STRH     r1,[r0,#0x2e]
;;;2076     
;;;2077       /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;2078       CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
000014  6801              LDR      r1,[r0,#0]
000016  68ca              LDR      r2,[r1,#0xc]
000018  f4227280          BIC      r2,r2,#0x100
00001c  60ca              STR      r2,[r1,#0xc]
;;;2079       CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00001e  6801              LDR      r1,[r0,#0]
000020  694a              LDR      r2,[r1,#0x14]
000022  f0220201          BIC      r2,r2,#1
000026  614a              STR      r2,[r1,#0x14]
;;;2080       
;;;2081       /* Disable the DMA transfer for the receiver request by setting the DMAR bit 
;;;2082          in the UART CR3 register */
;;;2083       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000028  6801              LDR      r1,[r0,#0]
00002a  694a              LDR      r2,[r1,#0x14]
00002c  f0220240          BIC      r2,r2,#0x40
000030  614a              STR      r2,[r1,#0x14]
;;;2084   
;;;2085       /* At end of Rx process, restore huart->RxState to Ready */
;;;2086       huart->RxState = HAL_UART_STATE_READY;
000032  2120              MOVS     r1,#0x20
000034  6401              STR      r1,[r0,#0x40]
                  |L41.54|
;;;2087     }
;;;2088     HAL_UART_RxCpltCallback(huart);
000036  f7fffffe          BL       HAL_UART_RxCpltCallback
;;;2089   }
00003a  bd10              POP      {r4,pc}
;;;2090   
                          ENDP


                          AREA ||i.UART_DMARxAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMARxAbortCallback PROC
;;;2260     */
;;;2261   static void UART_DMARxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2262   {
;;;2263     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a80              LDR      r0,[r0,#0x28]
;;;2264     
;;;2265     huart->hdmarx->XferAbortCallback = NULL;
000004  2100              MOVS     r1,#0
000006  6b42              LDR      r2,[r0,#0x34]
;;;2266   
;;;2267     /* Check if an Abort process is still ongoing */
;;;2268     if(huart->hdmatx != NULL)
000008  6391              STR      r1,[r2,#0x38]
00000a  6b02              LDR      r2,[r0,#0x30]
00000c  2a00              CMP      r2,#0
;;;2269     {
;;;2270       if(huart->hdmatx->XferAbortCallback != NULL)
00000e  bf1e              ITTT     NE
000010  6b92              LDRNE    r2,[r2,#0x38]
000012  2a00              CMPNE    r2,#0
;;;2271       {
;;;2272         return;
;;;2273       }
;;;2274     }
;;;2275     
;;;2276     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;2277     huart->TxXferCount = 0x00U;
;;;2278     huart->RxXferCount = 0x00U;
;;;2279   
;;;2280     /* Reset ErrorCode */
;;;2281     huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;2282   
;;;2283     /* Restore huart->gState and huart->RxState to Ready */
;;;2284     huart->gState  = HAL_UART_STATE_READY;
;;;2285     huart->RxState = HAL_UART_STATE_READY;
;;;2286   
;;;2287     /* Call user Abort complete callback */
;;;2288     HAL_UART_AbortCpltCallback(huart);
;;;2289   }
000014  bd10              POPNE    {r4,pc}
000016  84c1              STRH     r1,[r0,#0x26]         ;2277
000018  85c1              STRH     r1,[r0,#0x2e]         ;2278
00001a  6441              STR      r1,[r0,#0x44]         ;2281
00001c  2120              MOVS     r1,#0x20              ;2284
00001e  63c1              STR      r1,[r0,#0x3c]         ;2284
000020  6401              STR      r1,[r0,#0x40]         ;2285
000022  f7fffffe          BL       HAL_UART_AbortCpltCallback
000026  bd10              POP      {r4,pc}
;;;2290   
                          ENDP


                          AREA ||i.UART_DMARxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMARxHalfCplt PROC
;;;2096     */
;;;2097   static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2098   {
;;;2099     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000002  6a80              LDR      r0,[r0,#0x28]
;;;2100     HAL_UART_RxHalfCpltCallback(huart); 
000004  f7fffffe          BL       HAL_UART_RxHalfCpltCallback
;;;2101   }
000008  bd10              POP      {r4,pc}
;;;2102   
                          ENDP


                          AREA ||i.UART_DMARxOnlyAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMARxOnlyAbortCallback PROC
;;;2319     */
;;;2320   static void UART_DMARxOnlyAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2321   {
;;;2322     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a80              LDR      r0,[r0,#0x28]
;;;2323   
;;;2324     huart->RxXferCount = 0x00U;
000004  2100              MOVS     r1,#0
000006  85c1              STRH     r1,[r0,#0x2e]
;;;2325   
;;;2326     /* Restore huart->RxState to Ready */
;;;2327     huart->RxState = HAL_UART_STATE_READY;
000008  2120              MOVS     r1,#0x20
00000a  6401              STR      r1,[r0,#0x40]
;;;2328   
;;;2329     /* Call user Abort complete callback */
;;;2330     HAL_UART_AbortReceiveCpltCallback(huart);
00000c  f7fffffe          BL       HAL_UART_AbortReceiveCpltCallback
;;;2331   }
000010  bd10              POP      {r4,pc}
;;;2332   
                          ENDP


                          AREA ||i.UART_DMATransmitCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATransmitCplt PROC
;;;2027     */
;;;2028   static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2029   {
000002  4601              MOV      r1,r0
;;;2030     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6a80              LDR      r0,[r0,#0x28]
;;;2031     /* DMA Normal mode*/
;;;2032     if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
000006  6809              LDR      r1,[r1,#0]
000008  6809              LDR      r1,[r1,#0]
00000a  f0110f20          TST      r1,#0x20
00000e  d002              BEQ      |L45.22|
;;;2033     {
;;;2034       huart->TxXferCount = 0U;
;;;2035   
;;;2036       /* Disable the DMA transfer for transmit request by setting the DMAT bit
;;;2037          in the UART CR3 register */
;;;2038       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;2039   
;;;2040       /* Enable the UART Transmit Complete Interrupt */
;;;2041       SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
;;;2042   
;;;2043     }
;;;2044     /* DMA Circular mode */
;;;2045     else
;;;2046     {
;;;2047       HAL_UART_TxCpltCallback(huart);
000010  f7fffffe          BL       HAL_UART_TxCpltCallback
;;;2048     }
;;;2049   }
000014  bd10              POP      {r4,pc}
                  |L45.22|
000016  2100              MOVS     r1,#0                 ;2034
000018  84c1              STRH     r1,[r0,#0x26]         ;2034
00001a  6801              LDR      r1,[r0,#0]            ;2038
00001c  694a              LDR      r2,[r1,#0x14]         ;2038
00001e  f0220280          BIC      r2,r2,#0x80           ;2038
000022  614a              STR      r2,[r1,#0x14]         ;2038
000024  6800              LDR      r0,[r0,#0]            ;2041
000026  68c1              LDR      r1,[r0,#0xc]          ;2041
000028  f0410140          ORR      r1,r1,#0x40           ;2041
00002c  60c1              STR      r1,[r0,#0xc]          ;2041
00002e  bd10              POP      {r4,pc}
;;;2050   
                          ENDP


                          AREA ||i.UART_DMATxAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMATxAbortCallback PROC
;;;2222     */
;;;2223   static void UART_DMATxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2224   {
;;;2225     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a80              LDR      r0,[r0,#0x28]
;;;2226     
;;;2227     huart->hdmatx->XferAbortCallback = NULL;
000004  2100              MOVS     r1,#0
000006  6b02              LDR      r2,[r0,#0x30]
;;;2228   
;;;2229     /* Check if an Abort process is still ongoing */
;;;2230     if(huart->hdmarx != NULL)
000008  6391              STR      r1,[r2,#0x38]
00000a  6b42              LDR      r2,[r0,#0x34]
00000c  2a00              CMP      r2,#0
;;;2231     {
;;;2232       if(huart->hdmarx->XferAbortCallback != NULL)
00000e  bf1e              ITTT     NE
000010  6b92              LDRNE    r2,[r2,#0x38]
000012  2a00              CMPNE    r2,#0
;;;2233       {
;;;2234         return;
;;;2235       }
;;;2236     }
;;;2237   
;;;2238     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;2239     huart->TxXferCount = 0x00U;
;;;2240     huart->RxXferCount = 0x00U;
;;;2241   
;;;2242     /* Reset ErrorCode */
;;;2243     huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;2244   
;;;2245     /* Restore huart->gState and huart->RxState to Ready */
;;;2246     huart->gState  = HAL_UART_STATE_READY;
;;;2247     huart->RxState = HAL_UART_STATE_READY;
;;;2248   
;;;2249     /* Call user Abort complete callback */
;;;2250     HAL_UART_AbortCpltCallback(huart);
;;;2251   }
000014  bd10              POPNE    {r4,pc}
000016  84c1              STRH     r1,[r0,#0x26]         ;2239
000018  85c1              STRH     r1,[r0,#0x2e]         ;2240
00001a  6441              STR      r1,[r0,#0x44]         ;2243
00001c  2120              MOVS     r1,#0x20              ;2246
00001e  63c1              STR      r1,[r0,#0x3c]         ;2246
000020  6401              STR      r1,[r0,#0x40]         ;2247
000022  f7fffffe          BL       HAL_UART_AbortCpltCallback
000026  bd10              POP      {r4,pc}
;;;2252   
                          ENDP


                          AREA ||i.UART_DMATxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATxHalfCplt PROC
;;;2056     */
;;;2057   static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2058   {
;;;2059     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000002  6a80              LDR      r0,[r0,#0x28]
;;;2060   
;;;2061     HAL_UART_TxHalfCpltCallback(huart);
000004  f7fffffe          BL       HAL_UART_TxHalfCpltCallback
;;;2062   }
000008  bd10              POP      {r4,pc}
;;;2063   
                          ENDP


                          AREA ||i.UART_DMATxOnlyAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMATxOnlyAbortCallback PROC
;;;2298     */
;;;2299   static void UART_DMATxOnlyAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2300   {
;;;2301     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000002  6a80              LDR      r0,[r0,#0x28]
;;;2302   
;;;2303     huart->TxXferCount = 0x00U;
000004  2100              MOVS     r1,#0
000006  84c1              STRH     r1,[r0,#0x26]
;;;2304   
;;;2305     /* Restore huart->gState to Ready */
;;;2306     huart->gState = HAL_UART_STATE_READY;
000008  2120              MOVS     r1,#0x20
00000a  63c1              STR      r1,[r0,#0x3c]
;;;2307   
;;;2308     /* Call user Abort complete callback */
;;;2309     HAL_UART_AbortTransmitCpltCallback(huart);
00000c  f7fffffe          BL       HAL_UART_AbortTransmitCpltCallback
;;;2310   }
000010  bd10              POP      {r4,pc}
;;;2311   
                          ENDP


                          AREA ||i.UART_SetConfig||, CODE, READONLY, ALIGN=2

                  UART_SetConfig PROC
;;;2467     */
;;;2468   static void UART_SetConfig(UART_HandleTypeDef *huart)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2469   {
000004  4604              MOV      r4,r0
;;;2470     uint32_t tmpreg = 0x00U;
;;;2471   
;;;2472     /* Check the parameters */
;;;2473     assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
;;;2474     assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
;;;2475     assert_param(IS_UART_PARITY(huart->Init.Parity));
;;;2476     assert_param(IS_UART_MODE(huart->Init.Mode));
;;;2477   
;;;2478     /*------- UART-associated USART registers setting : CR2 Configuration ------*/
;;;2479     /* Configure the UART Stop Bits: Set STOP[13:12] bits according 
;;;2480      * to huart->Init.StopBits value */
;;;2481     MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
000006  6800              LDR      r0,[r0,#0]
000008  6901              LDR      r1,[r0,#0x10]
00000a  68e2              LDR      r2,[r4,#0xc]
00000c  f4215140          BIC      r1,r1,#0x3000
000010  4311              ORRS     r1,r1,r2
000012  6101              STR      r1,[r0,#0x10]
;;;2482   
;;;2483     /*------- UART-associated USART registers setting : CR1 Configuration ------*/
;;;2484     /* Configure the UART Word Length, Parity and mode: 
;;;2485        Set the M bits according to huart->Init.WordLength value 
;;;2486        Set PCE and PS bits according to huart->Init.Parity value
;;;2487        Set TE and RE bits according to huart->Init.Mode value
;;;2488        Set OVER8 bit according to huart->Init.OverSampling value */
;;;2489   
;;;2490   #if defined(USART_CR1_OVER8)
;;;2491     tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
;;;2492     MODIFY_REG(huart->Instance->CR1, 
;;;2493                (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8), 
;;;2494                tmpreg);
;;;2495   #else
;;;2496     tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode;
000014  6921              LDR      r1,[r4,#0x10]
000016  68a0              LDR      r0,[r4,#8]
000018  4301              ORRS     r1,r1,r0
00001a  6960              LDR      r0,[r4,#0x14]
00001c  4301              ORRS     r1,r1,r0
;;;2497     MODIFY_REG(huart->Instance->CR1, 
00001e  6820              LDR      r0,[r4,#0]
000020  68c2              LDR      r2,[r0,#0xc]
000022  f4227203          BIC      r2,r2,#0x20c
000026  f42252a0          BIC      r2,r2,#0x1400
00002a  4311              ORRS     r1,r1,r2
00002c  60c1              STR      r1,[r0,#0xc]
;;;2498                (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE), 
;;;2499                tmpreg);
;;;2500   #endif /* USART_CR1_OVER8 */
;;;2501   
;;;2502     /*------- UART-associated USART registers setting : CR3 Configuration ------*/
;;;2503     /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
;;;2504     MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
00002e  6820              LDR      r0,[r4,#0]
000030  6941              LDR      r1,[r0,#0x14]
000032  69a2              LDR      r2,[r4,#0x18]
000034  f4217140          BIC      r1,r1,#0x300
000038  4311              ORRS     r1,r1,r2
00003a  6141              STR      r1,[r0,#0x14]
;;;2505   
;;;2506   #if defined(USART_CR1_OVER8)
;;;2507     /* Check the Over Sampling */
;;;2508     if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
;;;2509     {
;;;2510       /*-------------------------- USART BRR Configuration ---------------------*/
;;;2511       if(huart->Instance == USART1)
;;;2512       {
;;;2513         huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
;;;2514       }
;;;2515       else
;;;2516       {
;;;2517         huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
;;;2518       }
;;;2519     }
;;;2520     else
;;;2521     {
;;;2522       /*-------------------------- USART BRR Configuration ---------------------*/
;;;2523       if(huart->Instance == USART1)
;;;2524       {
;;;2525         huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
;;;2526       }
;;;2527       else
;;;2528       {
;;;2529         huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
;;;2530       }
;;;2531     }
;;;2532   #else
;;;2533     /*-------------------------- USART BRR Configuration ---------------------*/
;;;2534     if(huart->Instance == USART1)
00003c  6820              LDR      r0,[r4,#0]
;;;2535     {
;;;2536       huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
00003e  4d5c              LDR      r5,|L49.432|
000040  2632              MOVS     r6,#0x32
000042  f1a04180          SUB      r1,r0,#0x40000000     ;2534
000046  f5b1319c          SUBS     r1,r1,#0x13800        ;2534
00004a  d058              BEQ      |L49.254|
;;;2537     }
;;;2538     else
;;;2539     {
;;;2540       huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
00004c  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
000050  eb0001c0          ADD      r1,r0,r0,LSL #3
000054  eb011000          ADD      r0,r1,r0,LSL #4
000058  6861              LDR      r1,[r4,#4]
00005a  0089              LSLS     r1,r1,#2
00005c  fbb0f7f1          UDIV     r7,r0,r1
000060  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
000064  eb0001c0          ADD      r1,r0,r0,LSL #3
000068  eb011000          ADD      r0,r1,r0,LSL #4
00006c  6861              LDR      r1,[r4,#4]
00006e  0089              LSLS     r1,r1,#2
000070  fbb0f0f1          UDIV     r0,r0,r1
000074  fba51000          UMULL    r1,r0,r5,r0
000078  0940              LSRS     r0,r0,#5
00007a  f06f0118          MVN      r1,#0x18
00007e  4348              MULS     r0,r1,r0
000080  eb070080          ADD      r0,r7,r0,LSL #2
000084  eb061000          ADD      r0,r6,r0,LSL #4
000088  fba51000          UMULL    r1,r0,r5,r0
00008c  0940              LSRS     r0,r0,#5
00008e  f00007f0          AND      r7,r0,#0xf0
000092  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
000096  eb0001c0          ADD      r1,r0,r0,LSL #3
00009a  eb011000          ADD      r0,r1,r0,LSL #4
00009e  6861              LDR      r1,[r4,#4]
0000a0  0089              LSLS     r1,r1,#2
0000a2  fbb0f0f1          UDIV     r0,r0,r1
0000a6  fba51000          UMULL    r1,r0,r5,r0
0000aa  0940              LSRS     r0,r0,#5
0000ac  eb071700          ADD      r7,r7,r0,LSL #4
0000b0  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
0000b4  eb0001c0          ADD      r1,r0,r0,LSL #3
0000b8  eb011000          ADD      r0,r1,r0,LSL #4
0000bc  6861              LDR      r1,[r4,#4]
0000be  0089              LSLS     r1,r1,#2
0000c0  fbb0f8f1          UDIV     r8,r0,r1
0000c4  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
0000c8  eb0001c0          ADD      r1,r0,r0,LSL #3
0000cc  eb011000          ADD      r0,r1,r0,LSL #4
0000d0  6861              LDR      r1,[r4,#4]
0000d2  0089              LSLS     r1,r1,#2
0000d4  fbb0f0f1          UDIV     r0,r0,r1
0000d8  fba51000          UMULL    r1,r0,r5,r0
0000dc  0940              LSRS     r0,r0,#5
0000de  f06f0118          MVN      r1,#0x18
0000e2  4348              MULS     r0,r1,r0
0000e4  eb080080          ADD      r0,r8,r0,LSL #2
0000e8  eb061000          ADD      r0,r6,r0,LSL #4
0000ec  fba51000          UMULL    r1,r0,r5,r0
0000f0  6821              LDR      r1,[r4,#0]
0000f2  f3c01043          UBFX     r0,r0,#5,#4
0000f6  4438              ADD      r0,r0,r7
0000f8  6088              STR      r0,[r1,#8]
;;;2541     }
;;;2542   #endif /* USART_CR1_OVER8 */
;;;2543   }
0000fa  e8bd81f0          POP      {r4-r8,pc}
                  |L49.254|
0000fe  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
000102  eb0001c0          ADD      r1,r0,r0,LSL #3       ;2536
000106  eb011000          ADD      r0,r1,r0,LSL #4       ;2536
00010a  6861              LDR      r1,[r4,#4]            ;2536
00010c  0089              LSLS     r1,r1,#2              ;2536
00010e  fbb0f7f1          UDIV     r7,r0,r1              ;2536
000112  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
000116  eb0001c0          ADD      r1,r0,r0,LSL #3       ;2536
00011a  eb011000          ADD      r0,r1,r0,LSL #4       ;2536
00011e  6861              LDR      r1,[r4,#4]            ;2536
000120  0089              LSLS     r1,r1,#2              ;2536
000122  fbb0f0f1          UDIV     r0,r0,r1              ;2536
000126  fba51000          UMULL    r1,r0,r5,r0           ;2536
00012a  0940              LSRS     r0,r0,#5              ;2536
00012c  f06f0118          MVN      r1,#0x18              ;2536
000130  4348              MULS     r0,r1,r0              ;2536
000132  eb070080          ADD      r0,r7,r0,LSL #2       ;2536
000136  eb061000          ADD      r0,r6,r0,LSL #4       ;2536
00013a  fba51000          UMULL    r1,r0,r5,r0           ;2536
00013e  0940              LSRS     r0,r0,#5              ;2536
000140  f00007f0          AND      r7,r0,#0xf0           ;2536
000144  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
000148  eb0001c0          ADD      r1,r0,r0,LSL #3       ;2536
00014c  eb011000          ADD      r0,r1,r0,LSL #4       ;2536
000150  6861              LDR      r1,[r4,#4]            ;2536
000152  0089              LSLS     r1,r1,#2              ;2536
000154  fbb0f0f1          UDIV     r0,r0,r1              ;2536
000158  fba51000          UMULL    r1,r0,r5,r0           ;2536
00015c  0940              LSRS     r0,r0,#5              ;2536
00015e  eb071700          ADD      r7,r7,r0,LSL #4       ;2536
000162  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
000166  eb0001c0          ADD      r1,r0,r0,LSL #3       ;2536
00016a  eb011000          ADD      r0,r1,r0,LSL #4       ;2536
00016e  6861              LDR      r1,[r4,#4]            ;2536
000170  0089              LSLS     r1,r1,#2              ;2536
000172  fbb0f8f1          UDIV     r8,r0,r1              ;2536
000176  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
00017a  eb0001c0          ADD      r1,r0,r0,LSL #3       ;2536
00017e  eb011000          ADD      r0,r1,r0,LSL #4       ;2536
000182  6861              LDR      r1,[r4,#4]            ;2536
000184  0089              LSLS     r1,r1,#2              ;2536
000186  fbb0f0f1          UDIV     r0,r0,r1              ;2536
00018a  fba51000          UMULL    r1,r0,r5,r0           ;2536
00018e  0940              LSRS     r0,r0,#5              ;2536
000190  f06f0118          MVN      r1,#0x18              ;2536
000194  4348              MULS     r0,r1,r0              ;2536
000196  eb080080          ADD      r0,r8,r0,LSL #2       ;2536
00019a  eb061000          ADD      r0,r6,r0,LSL #4       ;2536
00019e  fba51000          UMULL    r1,r0,r5,r0           ;2536
0001a2  6821              LDR      r1,[r4,#0]            ;2536
0001a4  f3c01043          UBFX     r0,r0,#5,#4           ;2536
0001a8  4438              ADD      r0,r0,r7              ;2536
0001aa  6088              STR      r0,[r1,#8]            ;2536
0001ac  e8bd81f0          POP      {r4-r8,pc}
;;;2544   
                          ENDP

                  |L49.432|
                          DCD      0x51eb851f

                          AREA ||i.UART_WaitOnFlagUntilTimeout||, CODE, READONLY, ALIGN=2

                  UART_WaitOnFlagUntilTimeout PROC
;;;2142     */
;;;2143   static HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2144   {
000004  4604              MOV      r4,r0
;;;2145     /* Wait until flag is set */
;;;2146     while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status) 
000006  6800              LDR      r0,[r0,#0]
000008  9e06              LDR      r6,[sp,#0x18]
00000a  461f              MOV      r7,r3                 ;2144
00000c  6800              LDR      r0,[r0,#0]
00000e  460d              MOV      r5,r1                 ;2144
000010  ea310000          BICS     r0,r1,r0
000014  d020              BEQ      |L50.88|
;;;2147     {
;;;2148       /* Check for the Timeout */
;;;2149       if(Timeout != HAL_MAX_DELAY)
000016  bf00              NOP      
                  |L50.24|
000018  f1b63fff          CMP      r6,#0xffffffff
00001c  d017              BEQ      |L50.78|
;;;2150       {
;;;2151         if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
00001e  b126              CBZ      r6,|L50.42|
000020  f7fffffe          BL       HAL_GetTick
000024  1bc0              SUBS     r0,r0,r7
000026  42b0              CMP      r0,r6
000028  d911              BLS      |L50.78|
                  |L50.42|
;;;2152         {
;;;2153           /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
;;;2154           CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
00002a  6820              LDR      r0,[r4,#0]
00002c  68c1              LDR      r1,[r0,#0xc]
00002e  f42171d0          BIC      r1,r1,#0x1a0
000032  60c1              STR      r1,[r0,#0xc]
;;;2155           CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000034  6820              LDR      r0,[r4,#0]
000036  6941              LDR      r1,[r0,#0x14]
000038  f0210101          BIC      r1,r1,#1
00003c  6141              STR      r1,[r0,#0x14]
;;;2156           
;;;2157           huart->gState  = HAL_UART_STATE_READY;
00003e  2020              MOVS     r0,#0x20
000040  63e0              STR      r0,[r4,#0x3c]
;;;2158           huart->RxState = HAL_UART_STATE_READY;
000042  6420              STR      r0,[r4,#0x40]
;;;2159           
;;;2160           /* Process Unlocked */
;;;2161           __HAL_UNLOCK(huart);
000044  2000              MOVS     r0,#0
;;;2162           
;;;2163           return HAL_TIMEOUT;
000046  63a0              STR      r0,[r4,#0x38]
000048  2003              MOVS     r0,#3
;;;2164         }
;;;2165       }
;;;2166     }
;;;2167     
;;;2168     return HAL_OK;
;;;2169   }
00004a  e8bd81f0          POP      {r4-r8,pc}
                  |L50.78|
00004e  6820              LDR      r0,[r4,#0]            ;2163
000050  6800              LDR      r0,[r0,#0]            ;2163
000052  ea350000          BICS     r0,r5,r0              ;2163
000056  d1df              BNE      |L50.24|
                  |L50.88|
000058  2000              MOVS     r0,#0                 ;2168
00005a  e8bd81f0          POP      {r4-r8,pc}
;;;2170   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F1_V1.6.0\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_uart_c_d497114f____REV16|
#line 388 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F1_V1.6.0\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___20_stm32f1xx_hal_uart_c_d497114f____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_uart_c_d497114f____REVSH|
#line 402
|__asm___20_stm32f1xx_hal_uart_c_d497114f____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_uart_c_d497114f____RRX|
#line 587
|__asm___20_stm32f1xx_hal_uart_c_d497114f____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
