; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\rmp_kernel.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\rmp_kernel.d --cpu=Cortex-M7 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Inc -I.\Source -I.\Drivers -I..\..\..\M6P1(D)_Duktape\duktape\src -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6-ALIENTEK-DUKTAPE\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER -DDUK_USE_BYTEORDER=1 --enum_is_int --signed_chars --omf_browse=.\debug\output\rmp_kernel.crf ..\..\MProkaron\Kernel\rmp_kernel.c]
                          THUMB

                          AREA ||i.RMP_CRC16||, CODE, READONLY, ALIGN=2

                  RMP_CRC16 PROC
;;;280    #ifdef __RMP_U16_T__
;;;281    rmp_ptr_t RMP_CRC16(const rmp_u8_t* Data, rmp_ptr_t Length)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;282    {
000004  b0c1              SUB      sp,sp,#0x104
000006  4606              MOV      r6,r0
000008  460f              MOV      r7,r1
;;;283        rmp_ptr_t Data_Cnt;
;;;284        rmp_u8_t Index;
;;;285        rmp_u8_t Temp_High;
;;;286        rmp_u8_t Temp_Low;
;;;287        
;;;288        /* CRC16 constants with X^16+X^15+X^2+1 */
;;;289        static const rmp_u8_t CRC16_High[256]=
;;;290        {
;;;291            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;292            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;293            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;294            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;295            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;296            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;297            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;298            0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;299            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;300            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;301            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;302            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;303            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;304            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;305            0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;306            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;307            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;308            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;309            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;310            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;311            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;312            0x00, 0xC1, 0x81, 0x40
;;;313        };
;;;314    
;;;315        const rmp_u8_t CRC16_Low[256]=
00000a  f44f7280          MOV      r2,#0x100
00000e  490d              LDR      r1,|L1.68|
000010  a801              ADD      r0,sp,#4
000012  f7fffffe          BL       __aeabi_memcpy4
;;;316        {
;;;317            0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7,
;;;318            0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E,
;;;319            0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9,
;;;320            0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC,
;;;321            0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
;;;322            0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32,
;;;323            0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D,
;;;324            0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38,
;;;325            0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF,
;;;326            0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
;;;327            0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1,
;;;328            0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4,
;;;329            0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB,
;;;330            0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA,
;;;331            0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
;;;332            0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0,
;;;333            0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97,
;;;334            0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E,
;;;335            0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89,
;;;336            0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
;;;337            0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83,
;;;338            0x41, 0x81, 0x80, 0x40
;;;339        };
;;;340    
;;;341        Temp_High=0xFF;
000016  f04f08ff          MOV      r8,#0xff
;;;342        Temp_Low=0xFF;
00001a  46c1              MOV      r9,r8
;;;343        for(Data_Cnt=0;Data_Cnt<Length;Data_Cnt++)
00001c  2400              MOVS     r4,#0
00001e  e00a              B        |L1.54|
                  |L1.32|
;;;344        {
;;;345            Index=Temp_Low^Data[Data_Cnt];
000020  5d30              LDRB     r0,[r6,r4]
000022  ea800509          EOR      r5,r0,r9
;;;346            Temp_Low=(rmp_u8_t)(Temp_High^CRC16_High[Index]);
000026  4808              LDR      r0,|L1.72|
000028  5d40              LDRB     r0,[r0,r5]
00002a  ea800908          EOR      r9,r0,r8
;;;347            Temp_High=CRC16_Low[Index];
00002e  a801              ADD      r0,sp,#4
000030  f8108005          LDRB     r8,[r0,r5]
000034  1c64              ADDS     r4,r4,#1              ;343
                  |L1.54|
000036  42bc              CMP      r4,r7                 ;343
000038  d3f2              BCC      |L1.32|
;;;348        }
;;;349    
;;;350        return (rmp_u16_t)(((rmp_u16_t)Temp_High)<<8|Temp_Low);
00003a  ea492008          ORR      r0,r9,r8,LSL #8
;;;351    }
00003e  b041              ADD      sp,sp,#0x104
000040  e8bd83f0          POP      {r4-r9,pc}
;;;352    #endif
                          ENDP

                  |L1.68|
                          DCD      ||.constdata||+0x4e0
                  |L1.72|
                          DCD      CRC16_High

                          AREA ||i.RMP_Checkbox||, CODE, READONLY, ALIGN=1

                  RMP_Checkbox PROC
;;;3426   ******************************************************************************/
;;;3427   void RMP_Checkbox(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_ptr_t Status)    
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;3428   {   
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4614              MOV      r4,r2
00000a  461f              MOV      r7,r3
;;;3429       /* Clear the area */
;;;3430       RMP_Rectangle(Coord_X,Coord_Y,Length,Length,RMP_CTL_WHITE,RMP_CTL_WHITE);
00000c  f64f70ff          MOV      r0,#0xffff
000010  9000              STR      r0,[sp,#0]
000012  4623              MOV      r3,r4
000014  4622              MOV      r2,r4
000016  4629              MOV      r1,r5
000018  9001              STR      r0,[sp,#4]
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       RMP_Rectangle
;;;3431                                                                        
;;;3432       /* Draw checkbox outline */
;;;3433       RMP_Line(Coord_X,Coord_Y,Coord_X+Length-1,Coord_Y,RMP_CTL_DARK);                 
000020  f64730ef          MOV      r0,#0x7bef
000024  9000              STR      r0,[sp,#0]
000026  1930              ADDS     r0,r6,r4
000028  1e42              SUBS     r2,r0,#1
00002a  462b              MOV      r3,r5
00002c  4629              MOV      r1,r5
00002e  4630              MOV      r0,r6
000030  f7fffffe          BL       RMP_Line
;;;3434       RMP_Line(Coord_X+Length-1,Coord_Y,Coord_X+Length-1,Coord_Y+Length-1,RMP_CTL_WHITE);
000034  f64f70ff          MOV      r0,#0xffff
000038  1929              ADDS     r1,r5,r4
00003a  1e4b              SUBS     r3,r1,#1
00003c  1931              ADDS     r1,r6,r4
00003e  1e4a              SUBS     r2,r1,#1
000040  1931              ADDS     r1,r6,r4
000042  9000              STR      r0,[sp,#0]
000044  1e48              SUBS     r0,r1,#1
000046  4629              MOV      r1,r5
000048  f7fffffe          BL       RMP_Line
;;;3435       RMP_Line(Coord_X+Length-1,Coord_Y+Length-1,Coord_X,Coord_Y+Length-1,RMP_CTL_WHITE);
00004c  f64f70ff          MOV      r0,#0xffff
000050  192a              ADDS     r2,r5,r4
000052  1e53              SUBS     r3,r2,#1
000054  192a              ADDS     r2,r5,r4
000056  1e51              SUBS     r1,r2,#1
000058  1932              ADDS     r2,r6,r4
00005a  9000              STR      r0,[sp,#0]
00005c  1e50              SUBS     r0,r2,#1
00005e  4632              MOV      r2,r6
000060  f7fffffe          BL       RMP_Line
;;;3436       RMP_Line(Coord_X,Coord_Y+Length-1,Coord_X,Coord_Y,RMP_CTL_DARK);
000064  f64730ef          MOV      r0,#0x7bef
000068  9000              STR      r0,[sp,#0]
00006a  1928              ADDS     r0,r5,r4
00006c  1e41              SUBS     r1,r0,#1
00006e  462b              MOV      r3,r5
000070  4632              MOV      r2,r6
000072  4630              MOV      r0,r6
000074  f7fffffe          BL       RMP_Line
;;;3437   
;;;3438       RMP_Line(Coord_X+1,Coord_Y+1,Coord_X+Length-2,Coord_Y+1,RMP_CTL_BLACK);
000078  2000              MOVS     r0,#0
00007a  9000              STR      r0,[sp,#0]
00007c  1930              ADDS     r0,r6,r4
00007e  1e82              SUBS     r2,r0,#2
000080  1c6b              ADDS     r3,r5,#1
000082  1c69              ADDS     r1,r5,#1
000084  1c70              ADDS     r0,r6,#1
000086  f7fffffe          BL       RMP_Line
;;;3439       RMP_Line(Coord_X+Length-2,Coord_Y+1,Coord_X+Length-2,Coord_Y+Length-2,RMP_CTL_DARK);
00008a  f64730ef          MOV      r0,#0x7bef
00008e  1929              ADDS     r1,r5,r4
000090  1e8b              SUBS     r3,r1,#2
000092  1931              ADDS     r1,r6,r4
000094  1e8a              SUBS     r2,r1,#2
000096  1931              ADDS     r1,r6,r4
000098  9000              STR      r0,[sp,#0]
00009a  1e88              SUBS     r0,r1,#2
00009c  1c69              ADDS     r1,r5,#1
00009e  f7fffffe          BL       RMP_Line
;;;3440       RMP_Line(Coord_X+Length-2,Coord_Y+Length-2,Coord_X,Coord_Y+Length-2,RMP_CTL_DARK);
0000a2  f64730ef          MOV      r0,#0x7bef
0000a6  192a              ADDS     r2,r5,r4
0000a8  1e93              SUBS     r3,r2,#2
0000aa  192a              ADDS     r2,r5,r4
0000ac  1e91              SUBS     r1,r2,#2
0000ae  1932              ADDS     r2,r6,r4
0000b0  9000              STR      r0,[sp,#0]
0000b2  1e90              SUBS     r0,r2,#2
0000b4  4632              MOV      r2,r6
0000b6  f7fffffe          BL       RMP_Line
;;;3441       RMP_Line(Coord_X+1,Coord_Y+Length-2,Coord_X+1,Coord_Y+1,RMP_CTL_BLACK);
0000ba  2000              MOVS     r0,#0
0000bc  9000              STR      r0,[sp,#0]
0000be  1928              ADDS     r0,r5,r4
0000c0  1e81              SUBS     r1,r0,#2
0000c2  1c6b              ADDS     r3,r5,#1
0000c4  1c72              ADDS     r2,r6,#1
0000c6  1c70              ADDS     r0,r6,#1
0000c8  f7fffffe          BL       RMP_Line
;;;3442       
;;;3443       if(Status!=0)
0000cc  b127              CBZ      r7,|L2.216|
;;;3444           RMP_Checkbox_Set(Coord_X, Coord_Y, Length);
0000ce  4622              MOV      r2,r4
0000d0  4629              MOV      r1,r5
0000d2  4630              MOV      r0,r6
0000d4  f7fffffe          BL       RMP_Checkbox_Set
                  |L2.216|
;;;3445   }
0000d8  e8bd81fc          POP      {r2-r8,pc}
;;;3446   /* End Function:RMP_Checkbox *************************************************/
                          ENDP


                          AREA ||i.RMP_Checkbox_Clr||, CODE, READONLY, ALIGN=1

                  RMP_Checkbox_Clr PROC
;;;3399   ******************************************************************************/
;;;3400   void RMP_Checkbox_Clr(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;3401   {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;3402       rmp_cnt_t Count;
;;;3403       
;;;3404       /* Erase the tick inside */
;;;3405       for(Count=0;Count<=2*Length/13;Count++)
00000a  2400              MOVS     r4,#0
00000c  e024              B        |L3.88|
                  |L3.14|
;;;3406       {
;;;3407           RMP_Line(Coord_X+4*Length/13+Count,Coord_Y+6*Length/13+Count,
00000e  00e8              LSLS     r0,r5,#3
000010  210d              MOVS     r1,#0xd
000012  fb90f0f1          SDIV     r0,r0,r1
000016  4438              ADD      r0,r0,r7
000018  eb000804          ADD      r8,r0,r4
00001c  00a8              LSLS     r0,r5,#2
00001e  fb90f0f1          SDIV     r0,r0,r1
000022  4430              ADD      r0,r0,r6
000024  eb000904          ADD      r9,r0,r4
000028  eb050045          ADD      r0,r5,r5,LSL #1
00002c  0040              LSLS     r0,r0,#1
00002e  fb90f0f1          SDIV     r0,r0,r1
000032  4438              ADD      r0,r0,r7
000034  eb000a04          ADD      r10,r0,r4
000038  00a8              LSLS     r0,r5,#2
00003a  fb90f0f1          SDIV     r0,r0,r1
00003e  4430              ADD      r0,r0,r6
000040  eb000b04          ADD      r11,r0,r4
000044  f64f70ff          MOV      r0,#0xffff
000048  4643              MOV      r3,r8
00004a  464a              MOV      r2,r9
00004c  4651              MOV      r1,r10
00004e  9000              STR      r0,[sp,#0]
000050  4658              MOV      r0,r11
000052  f7fffffe          BL       RMP_Line
000056  1c64              ADDS     r4,r4,#1              ;3405
                  |L3.88|
000058  0068              LSLS     r0,r5,#1              ;3405
00005a  210d              MOVS     r1,#0xd               ;3405
00005c  fb90f0f1          SDIV     r0,r0,r1              ;3405
000060  42a0              CMP      r0,r4                 ;3405
000062  dad4              BGE      |L3.14|
;;;3408                    Coord_X+4*Length/13+Count,Coord_Y+8*Length/13+Count,RMP_CTL_WHITE);
;;;3409       }
;;;3410       for(Count=0;Count<=4*Length/13;Count++)
000064  2400              MOVS     r4,#0
000066  e028              B        |L3.186|
                  |L3.104|
;;;3411       {
;;;3412           RMP_Line(Coord_X+6*Length/13+Count,Coord_Y+8*Length/13-Count,
000068  eb050085          ADD      r0,r5,r5,LSL #2
00006c  0040              LSLS     r0,r0,#1
00006e  210d              MOVS     r1,#0xd
000070  fb90f0f1          SDIV     r0,r0,r1
000074  4438              ADD      r0,r0,r7
000076  eba00804          SUB      r8,r0,r4
00007a  eb050045          ADD      r0,r5,r5,LSL #1
00007e  0040              LSLS     r0,r0,#1
000080  fb90f0f1          SDIV     r0,r0,r1
000084  4430              ADD      r0,r0,r6
000086  eb000904          ADD      r9,r0,r4
00008a  00e8              LSLS     r0,r5,#3
00008c  fb90f0f1          SDIV     r0,r0,r1
000090  4438              ADD      r0,r0,r7
000092  eba00a04          SUB      r10,r0,r4
000096  eb050045          ADD      r0,r5,r5,LSL #1
00009a  0040              LSLS     r0,r0,#1
00009c  fb90f0f1          SDIV     r0,r0,r1
0000a0  4430              ADD      r0,r0,r6
0000a2  eb000b04          ADD      r11,r0,r4
0000a6  f64f70ff          MOV      r0,#0xffff
0000aa  4643              MOV      r3,r8
0000ac  464a              MOV      r2,r9
0000ae  4651              MOV      r1,r10
0000b0  9000              STR      r0,[sp,#0]
0000b2  4658              MOV      r0,r11
0000b4  f7fffffe          BL       RMP_Line
0000b8  1c64              ADDS     r4,r4,#1              ;3410
                  |L3.186|
0000ba  00a8              LSLS     r0,r5,#2              ;3410
0000bc  210d              MOVS     r1,#0xd               ;3410
0000be  fb90f0f1          SDIV     r0,r0,r1              ;3410
0000c2  42a0              CMP      r0,r4                 ;3410
0000c4  dad0              BGE      |L3.104|
;;;3413                    Coord_X+6*Length/13+Count,Coord_Y+10*Length/13-Count,RMP_CTL_WHITE);
;;;3414       }
;;;3415   }
0000c6  e8bd8ff8          POP      {r3-r11,pc}
;;;3416   /* End Function:RMP_Checkbox_Clr *********************************************/
                          ENDP


                          AREA ||i.RMP_Checkbox_Set||, CODE, READONLY, ALIGN=1

                  RMP_Checkbox_Set PROC
;;;3373   ******************************************************************************/
;;;3374   void RMP_Checkbox_Set(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;3375   {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;3376       rmp_cnt_t Count;
;;;3377       
;;;3378       /* Draw a tick inside */
;;;3379       for(Count=0;Count<=2*Length/13;Count++)
00000a  2400              MOVS     r4,#0
00000c  e023              B        |L4.86|
                  |L4.14|
;;;3380       {
;;;3381           RMP_Line(Coord_X+4*Length/13+Count,Coord_Y+6*Length/13+Count,
00000e  00e8              LSLS     r0,r5,#3
000010  210d              MOVS     r1,#0xd
000012  fb90f0f1          SDIV     r0,r0,r1
000016  4438              ADD      r0,r0,r7
000018  eb000804          ADD      r8,r0,r4
00001c  00a8              LSLS     r0,r5,#2
00001e  fb90f0f1          SDIV     r0,r0,r1
000022  4430              ADD      r0,r0,r6
000024  eb000904          ADD      r9,r0,r4
000028  eb050045          ADD      r0,r5,r5,LSL #1
00002c  0040              LSLS     r0,r0,#1
00002e  fb90f0f1          SDIV     r0,r0,r1
000032  4438              ADD      r0,r0,r7
000034  eb000a04          ADD      r10,r0,r4
000038  00a8              LSLS     r0,r5,#2
00003a  fb90f0f1          SDIV     r0,r0,r1
00003e  4430              ADD      r0,r0,r6
000040  eb000b04          ADD      r11,r0,r4
000044  2000              MOVS     r0,#0
000046  4643              MOV      r3,r8
000048  464a              MOV      r2,r9
00004a  4651              MOV      r1,r10
00004c  9000              STR      r0,[sp,#0]
00004e  4658              MOV      r0,r11
000050  f7fffffe          BL       RMP_Line
000054  1c64              ADDS     r4,r4,#1              ;3379
                  |L4.86|
000056  0068              LSLS     r0,r5,#1              ;3379
000058  210d              MOVS     r1,#0xd               ;3379
00005a  fb90f0f1          SDIV     r0,r0,r1              ;3379
00005e  42a0              CMP      r0,r4                 ;3379
000060  dad5              BGE      |L4.14|
;;;3382                    Coord_X+4*Length/13+Count,Coord_Y+8*Length/13+Count,RMP_CTL_BLACK);
;;;3383       }
;;;3384       for(Count=0;Count<=4*Length/13;Count++)
000062  2400              MOVS     r4,#0
000064  e027              B        |L4.182|
                  |L4.102|
;;;3385       {
;;;3386           RMP_Line(Coord_X+6*Length/13+Count,Coord_Y+8*Length/13-Count,
000066  eb050085          ADD      r0,r5,r5,LSL #2
00006a  0040              LSLS     r0,r0,#1
00006c  210d              MOVS     r1,#0xd
00006e  fb90f0f1          SDIV     r0,r0,r1
000072  4438              ADD      r0,r0,r7
000074  eba00804          SUB      r8,r0,r4
000078  eb050045          ADD      r0,r5,r5,LSL #1
00007c  0040              LSLS     r0,r0,#1
00007e  fb90f0f1          SDIV     r0,r0,r1
000082  4430              ADD      r0,r0,r6
000084  eb000904          ADD      r9,r0,r4
000088  00e8              LSLS     r0,r5,#3
00008a  fb90f0f1          SDIV     r0,r0,r1
00008e  4438              ADD      r0,r0,r7
000090  eba00a04          SUB      r10,r0,r4
000094  eb050045          ADD      r0,r5,r5,LSL #1
000098  0040              LSLS     r0,r0,#1
00009a  fb90f0f1          SDIV     r0,r0,r1
00009e  4430              ADD      r0,r0,r6
0000a0  eb000b04          ADD      r11,r0,r4
0000a4  2000              MOVS     r0,#0
0000a6  4643              MOV      r3,r8
0000a8  464a              MOV      r2,r9
0000aa  4651              MOV      r1,r10
0000ac  9000              STR      r0,[sp,#0]
0000ae  4658              MOV      r0,r11
0000b0  f7fffffe          BL       RMP_Line
0000b4  1c64              ADDS     r4,r4,#1              ;3384
                  |L4.182|
0000b6  00a8              LSLS     r0,r5,#2              ;3384
0000b8  210d              MOVS     r1,#0xd               ;3384
0000ba  fb90f0f1          SDIV     r0,r0,r1              ;3384
0000be  42a0              CMP      r0,r4                 ;3384
0000c0  dad1              BGE      |L4.102|
;;;3387                    Coord_X+6*Length/13+Count,Coord_Y+10*Length/13-Count,RMP_CTL_BLACK);
;;;3388       }
;;;3389   }
0000c2  e8bd8ff8          POP      {r3-r11,pc}
;;;3390   /* End Function:RMP_Checkbox_Set *********************************************/
                          ENDP


                          AREA ||i.RMP_Circle||, CODE, READONLY, ALIGN=1

                  RMP_Circle PROC
;;;2884   ******************************************************************************/
;;;2885   void RMP_Circle(rmp_cnt_t Center_X, rmp_cnt_t Center_Y, rmp_cnt_t Radius, rmp_ptr_t Border, rmp_ptr_t Fill)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;2886   {
000004  b083              SUB      sp,sp,#0xc
000006  4605              MOV      r5,r0
000008  460e              MOV      r6,r1
00000a  4693              MOV      r11,r2
;;;2887       rmp_cnt_t Cur_X;
;;;2888       rmp_cnt_t Cur_Y;
;;;2889       rmp_cnt_t Fill_Y;
;;;2890       rmp_cnt_t Error;  
;;;2891       rmp_cnt_t Quick;
;;;2892   
;;;2893       Cur_X=0;
00000c  2400              MOVS     r4,#0
;;;2894       Cur_Y=Radius;
00000e  465f              MOV      r7,r11
;;;2895       Error=3-(Radius<<1);
000010  2003              MOVS     r0,#3
000012  eba00a4b          SUB      r10,r0,r11,LSL #1
;;;2896   
;;;2897       if(Fill!=RMP_TRANS)
000016  9810              LDR      r0,[sp,#0x40]
000018  2801              CMP      r0,#1
00001a  d07c              BEQ      |L5.278|
;;;2898       {  
;;;2899           /* When we are filling the circle, we can try not to fill the areas that have been filled
;;;2900            * using the rectangle fill method to increase fill speed.
;;;2901            * Square 2 is 1.414. Here we let the condition to be 1.5. */
;;;2902           Quick=(Radius<<1)/3;
00001c  ea4f004b          LSL      r0,r11,#1
000020  2103              MOVS     r1,#3
000022  fb90f9f1          SDIV     r9,r0,r1
;;;2903           /* First, fill the square hole using the fast direct-fill method */
;;;2904           RMP_Rectangle(Center_X-Quick,Center_Y-Quick, (Quick<<1)+1,(Quick<<1)+1, Fill, Fill);  
000026  9810              LDR      r0,[sp,#0x40]
000028  9000              STR      r0,[sp,#0]
00002a  f04f0c01          MOV      r12,#1
00002e  eb0c0349          ADD      r3,r12,r9,LSL #1
000032  eb0c0249          ADD      r2,r12,r9,LSL #1
000036  eba60109          SUB      r1,r6,r9
00003a  9001              STR      r0,[sp,#4]
00003c  eba50009          SUB      r0,r5,r9
000040  f7fffffe          BL       RMP_Rectangle
;;;2905   
;;;2906           while(Cur_X<=Cur_Y) 
000044  e0ab              B        |L5.414|
                  |L5.70|
;;;2907           {  
;;;2908               if(Cur_X<Quick)
000046  454c              CMP      r4,r9
000048  da3a              BGE      |L5.192|
;;;2909               {
;;;2910                   for(Fill_Y=Cur_X;Fill_Y<=Cur_Y;Fill_Y++)  
00004a  46a0              MOV      r8,r4
00004c  e035              B        |L5.186|
                  |L5.78|
;;;2911                   {
;;;2912                       if(Fill_Y<Quick)
00004e  45c8              CMP      r8,r9
000050  da00              BGE      |L5.84|
;;;2913                           continue;
000052  e030              B        |L5.182|
                  |L5.84|
;;;2914                       
;;;2915                       RMP_POINT(Center_X+Cur_X,Center_Y+Fill_Y,Fill);  
000054  eb060108          ADD      r1,r6,r8
000058  1928              ADDS     r0,r5,r4
00005a  9a10              LDR      r2,[sp,#0x40]
00005c  f7fffffe          BL       RMP_Point
;;;2916                       RMP_POINT(Center_X-Cur_X,Center_Y+Fill_Y,Fill);  
000060  eb060108          ADD      r1,r6,r8
000064  1b28              SUBS     r0,r5,r4
000066  9a10              LDR      r2,[sp,#0x40]
000068  f7fffffe          BL       RMP_Point
;;;2917                       RMP_POINT(Center_X+Cur_X,Center_Y-Fill_Y,Fill); 
00006c  eba60108          SUB      r1,r6,r8
000070  1928              ADDS     r0,r5,r4
000072  9a10              LDR      r2,[sp,#0x40]
000074  f7fffffe          BL       RMP_Point
;;;2918                       RMP_POINT(Center_X-Cur_X,Center_Y-Fill_Y,Fill);  
000078  eba60108          SUB      r1,r6,r8
00007c  1b28              SUBS     r0,r5,r4
00007e  9a10              LDR      r2,[sp,#0x40]
000080  f7fffffe          BL       RMP_Point
;;;2919                       RMP_POINT(Center_X+Fill_Y,Center_Y+Cur_X,Fill); 
000084  1931              ADDS     r1,r6,r4
000086  eb050008          ADD      r0,r5,r8
00008a  9a10              LDR      r2,[sp,#0x40]
00008c  f7fffffe          BL       RMP_Point
;;;2920                       RMP_POINT(Center_X-Fill_Y,Center_Y+Cur_X,Fill);  
000090  1931              ADDS     r1,r6,r4
000092  eba50008          SUB      r0,r5,r8
000096  9a10              LDR      r2,[sp,#0x40]
000098  f7fffffe          BL       RMP_Point
;;;2921                       RMP_POINT(Center_X+Fill_Y,Center_Y-Cur_X,Fill);  
00009c  1b31              SUBS     r1,r6,r4
00009e  eb050008          ADD      r0,r5,r8
0000a2  9a10              LDR      r2,[sp,#0x40]
0000a4  f7fffffe          BL       RMP_Point
;;;2922                       RMP_POINT(Center_X-Fill_Y,Center_Y-Cur_X,Fill);
0000a8  1b31              SUBS     r1,r6,r4
0000aa  eba50008          SUB      r0,r5,r8
0000ae  9a10              LDR      r2,[sp,#0x40]
0000b0  f7fffffe          BL       RMP_Point
0000b4  bf00              NOP                            ;2913
                  |L5.182|
0000b6  f1080801          ADD      r8,r8,#1              ;2910
                  |L5.186|
0000ba  45b8              CMP      r8,r7                 ;2910
0000bc  ddc7              BLE      |L5.78|
0000be  e037              B        |L5.304|
                  |L5.192|
;;;2923                   }
;;;2924               }
;;;2925               /* Here the "Cur_X" is already out of range. We do not check the conditions anymore */
;;;2926               else
;;;2927               {
;;;2928                   for(Fill_Y=Cur_X;Fill_Y<=Cur_Y;Fill_Y++)  
0000c0  46a0              MOV      r8,r4
0000c2  e033              B        |L5.300|
                  |L5.196|
;;;2929                   {                   
;;;2930                       RMP_POINT(Center_X+Cur_X,Center_Y+Fill_Y,Fill);  
0000c4  eb060108          ADD      r1,r6,r8
0000c8  1928              ADDS     r0,r5,r4
0000ca  9a10              LDR      r2,[sp,#0x40]
0000cc  f7fffffe          BL       RMP_Point
;;;2931                       RMP_POINT(Center_X-Cur_X,Center_Y+Fill_Y,Fill);  
0000d0  eb060108          ADD      r1,r6,r8
0000d4  1b28              SUBS     r0,r5,r4
0000d6  9a10              LDR      r2,[sp,#0x40]
0000d8  f7fffffe          BL       RMP_Point
;;;2932                       RMP_POINT(Center_X+Cur_X,Center_Y-Fill_Y,Fill); 
0000dc  eba60108          SUB      r1,r6,r8
0000e0  1928              ADDS     r0,r5,r4
0000e2  9a10              LDR      r2,[sp,#0x40]
0000e4  f7fffffe          BL       RMP_Point
;;;2933                       RMP_POINT(Center_X-Cur_X,Center_Y-Fill_Y,Fill);  
0000e8  eba60108          SUB      r1,r6,r8
0000ec  1b28              SUBS     r0,r5,r4
0000ee  9a10              LDR      r2,[sp,#0x40]
0000f0  f7fffffe          BL       RMP_Point
;;;2934                       RMP_POINT(Center_X+Fill_Y,Center_Y+Cur_X,Fill); 
0000f4  1931              ADDS     r1,r6,r4
0000f6  eb050008          ADD      r0,r5,r8
0000fa  9a10              LDR      r2,[sp,#0x40]
0000fc  f7fffffe          BL       RMP_Point
;;;2935                       RMP_POINT(Center_X-Fill_Y,Center_Y+Cur_X,Fill);  
000100  1931              ADDS     r1,r6,r4
000102  eba50008          SUB      r0,r5,r8
000106  9a10              LDR      r2,[sp,#0x40]
000108  f7fffffe          BL       RMP_Point
;;;2936                       RMP_POINT(Center_X+Fill_Y,Center_Y-Cur_X,Fill);  
00010c  1b31              SUBS     r1,r6,r4
00010e  eb050008          ADD      r0,r5,r8
000112  9a10              LDR      r2,[sp,#0x40]
000114  e000              B        |L5.280|
                  |L5.278|
000116  e046              B        |L5.422|
                  |L5.280|
000118  f7fffffe          BL       RMP_Point
;;;2937                       RMP_POINT(Center_X-Fill_Y,Center_Y-Cur_X,Fill);
00011c  1b31              SUBS     r1,r6,r4
00011e  eba50008          SUB      r0,r5,r8
000122  9a10              LDR      r2,[sp,#0x40]
000124  f7fffffe          BL       RMP_Point
000128  f1080801          ADD      r8,r8,#1              ;2928
                  |L5.300|
00012c  45b8              CMP      r8,r7                 ;2928
00012e  ddc9              BLE      |L5.196|
                  |L5.304|
;;;2938                   }
;;;2939               }
;;;2940               RMP_POINT(Center_X+Cur_X,Center_Y+Cur_Y,Border);  
000130  19f1              ADDS     r1,r6,r7
000132  1928              ADDS     r0,r5,r4
000134  9a06              LDR      r2,[sp,#0x18]
000136  f7fffffe          BL       RMP_Point
;;;2941               RMP_POINT(Center_X-Cur_X,Center_Y+Cur_Y,Border);  
00013a  19f1              ADDS     r1,r6,r7
00013c  1b28              SUBS     r0,r5,r4
00013e  9a06              LDR      r2,[sp,#0x18]
000140  f7fffffe          BL       RMP_Point
;;;2942               RMP_POINT(Center_X+Cur_X,Center_Y-Cur_Y,Border); 
000144  1bf1              SUBS     r1,r6,r7
000146  1928              ADDS     r0,r5,r4
000148  9a06              LDR      r2,[sp,#0x18]
00014a  f7fffffe          BL       RMP_Point
;;;2943               RMP_POINT(Center_X-Cur_X,Center_Y-Cur_Y,Border);  
00014e  1bf1              SUBS     r1,r6,r7
000150  1b28              SUBS     r0,r5,r4
000152  9a06              LDR      r2,[sp,#0x18]
000154  f7fffffe          BL       RMP_Point
;;;2944               RMP_POINT(Center_X+Cur_Y,Center_Y+Cur_X,Border); 
000158  1931              ADDS     r1,r6,r4
00015a  19e8              ADDS     r0,r5,r7
00015c  9a06              LDR      r2,[sp,#0x18]
00015e  f7fffffe          BL       RMP_Point
;;;2945               RMP_POINT(Center_X-Cur_Y,Center_Y+Cur_X,Border);  
000162  1931              ADDS     r1,r6,r4
000164  1be8              SUBS     r0,r5,r7
000166  9a06              LDR      r2,[sp,#0x18]
000168  f7fffffe          BL       RMP_Point
;;;2946               RMP_POINT(Center_X+Cur_Y,Center_Y-Cur_X,Border);  
00016c  1b31              SUBS     r1,r6,r4
00016e  19e8              ADDS     r0,r5,r7
000170  9a06              LDR      r2,[sp,#0x18]
000172  f7fffffe          BL       RMP_Point
;;;2947               RMP_POINT(Center_X-Cur_Y,Center_Y-Cur_X,Border);
000176  1b31              SUBS     r1,r6,r4
000178  1be8              SUBS     r0,r5,r7
00017a  9a06              LDR      r2,[sp,#0x18]
00017c  f7fffffe          BL       RMP_Point
;;;2948   
;;;2949               if(Error<0) 
000180  f1ba0f00          CMP      r10,#0
000184  da04              BGE      |L5.400|
;;;2950                   Error=Error+(Cur_X<<2)+6;
000186  eb0a0084          ADD      r0,r10,r4,LSL #2
00018a  f1000a06          ADD      r10,r0,#6
00018e  e005              B        |L5.412|
                  |L5.400|
;;;2951               else 
;;;2952               {  
;;;2953                   Error=Error+((Cur_X-Cur_Y)<<2)+10;  
000190  1be0              SUBS     r0,r4,r7
000192  eb0a0080          ADD      r0,r10,r0,LSL #2
000196  f1000a0a          ADD      r10,r0,#0xa
;;;2954                   Cur_Y--;  
00019a  1e7f              SUBS     r7,r7,#1
                  |L5.412|
;;;2955               }  
;;;2956               Cur_X++;  
00019c  1c64              ADDS     r4,r4,#1
                  |L5.414|
00019e  42bc              CMP      r4,r7                 ;2906
0001a0  f77faf51          BLE      |L5.70|
0001a4  e037              B        |L5.534|
                  |L5.422|
;;;2957           }
;;;2958       }
;;;2959       else 
;;;2960       {  
;;;2961           /* Border only */ 
;;;2962           while(Cur_X<=Cur_Y) 
0001a6  e034              B        |L5.530|
                  |L5.424|
;;;2963           {
;;;2964               RMP_POINT(Center_X+Cur_X,Center_Y+Cur_Y,Border);  
0001a8  19f1              ADDS     r1,r6,r7
0001aa  1928              ADDS     r0,r5,r4
0001ac  9a06              LDR      r2,[sp,#0x18]
0001ae  f7fffffe          BL       RMP_Point
;;;2965               RMP_POINT(Center_X-Cur_X,Center_Y+Cur_Y,Border);  
0001b2  19f1              ADDS     r1,r6,r7
0001b4  1b28              SUBS     r0,r5,r4
0001b6  9a06              LDR      r2,[sp,#0x18]
0001b8  f7fffffe          BL       RMP_Point
;;;2966               RMP_POINT(Center_X+Cur_X,Center_Y-Cur_Y,Border); 
0001bc  1bf1              SUBS     r1,r6,r7
0001be  1928              ADDS     r0,r5,r4
0001c0  9a06              LDR      r2,[sp,#0x18]
0001c2  f7fffffe          BL       RMP_Point
;;;2967               RMP_POINT(Center_X-Cur_X,Center_Y-Cur_Y,Border);  
0001c6  1bf1              SUBS     r1,r6,r7
0001c8  1b28              SUBS     r0,r5,r4
0001ca  9a06              LDR      r2,[sp,#0x18]
0001cc  f7fffffe          BL       RMP_Point
;;;2968               RMP_POINT(Center_X+Cur_Y,Center_Y+Cur_X,Border); 
0001d0  1931              ADDS     r1,r6,r4
0001d2  19e8              ADDS     r0,r5,r7
0001d4  9a06              LDR      r2,[sp,#0x18]
0001d6  f7fffffe          BL       RMP_Point
;;;2969               RMP_POINT(Center_X-Cur_Y,Center_Y+Cur_X,Border);  
0001da  1931              ADDS     r1,r6,r4
0001dc  1be8              SUBS     r0,r5,r7
0001de  9a06              LDR      r2,[sp,#0x18]
0001e0  f7fffffe          BL       RMP_Point
;;;2970               RMP_POINT(Center_X+Cur_Y,Center_Y-Cur_X,Border);  
0001e4  1b31              SUBS     r1,r6,r4
0001e6  19e8              ADDS     r0,r5,r7
0001e8  9a06              LDR      r2,[sp,#0x18]
0001ea  f7fffffe          BL       RMP_Point
;;;2971               RMP_POINT(Center_X-Cur_Y,Center_Y-Cur_X,Border);
0001ee  1b31              SUBS     r1,r6,r4
0001f0  1be8              SUBS     r0,r5,r7
0001f2  9a06              LDR      r2,[sp,#0x18]
0001f4  f7fffffe          BL       RMP_Point
;;;2972   
;;;2973               if(Error<0)
0001f8  f1ba0f00          CMP      r10,#0
0001fc  da04              BGE      |L5.520|
;;;2974                   Error=Error+(Cur_X<<2)+6;
0001fe  eb0a0084          ADD      r0,r10,r4,LSL #2
000202  f1000a06          ADD      r10,r0,#6
000206  e003              B        |L5.528|
                  |L5.520|
;;;2975               else 
;;;2976               {
;;;2977                   Error=Error+((Cur_X-Cur_Y)<<2);
000208  1be0              SUBS     r0,r4,r7
00020a  eb0a0a80          ADD      r10,r10,r0,LSL #2
;;;2978                   Cur_Y--;
00020e  1e7f              SUBS     r7,r7,#1
                  |L5.528|
;;;2979               }
;;;2980               Cur_X++;  
000210  1c64              ADDS     r4,r4,#1
                  |L5.530|
000212  42bc              CMP      r4,r7                 ;2962
000214  ddc8              BLE      |L5.424|
                  |L5.534|
;;;2981           }  
;;;2982       }
;;;2983   }
000216  b007              ADD      sp,sp,#0x1c
000218  e8bd8ff0          POP      {r4-r11,pc}
;;;2984   /* End Function:RMP_Circle ***************************************************/
                          ENDP


                          AREA ||i.RMP_Clear||, CODE, READONLY, ALIGN=1

                  RMP_Clear PROC
;;;67     ******************************************************************************/
;;;68     void RMP_Clear(volatile void* Addr, rmp_ptr_t Size)
000000  b510              PUSH     {r4,lr}
;;;69     {
000002  4602              MOV      r2,r0
;;;70         rmp_u8_t* Ptr;
;;;71         rmp_cnt_t Count;
;;;72        
;;;73         Ptr=(rmp_u8_t*)Addr;
000004  4613              MOV      r3,r2
;;;74         for(Count=0;Count<Size;Count++)
000006  2000              MOVS     r0,#0
000008  e002              B        |L6.16|
                  |L6.10|
;;;75             Ptr[Count]=0;
00000a  2400              MOVS     r4,#0
00000c  541c              STRB     r4,[r3,r0]
00000e  1c40              ADDS     r0,r0,#1              ;74
                  |L6.16|
000010  4288              CMP      r0,r1                 ;74
000012  d3fa              BCC      |L6.10|
;;;76     }
000014  bd10              POP      {r4,pc}
;;;77     /* End Function:RMP_Clear ****************************************************/
                          ENDP


                          AREA ||i.RMP_Cmdbtn||, CODE, READONLY, ALIGN=1

                  RMP_Cmdbtn PROC
;;;3505   ******************************************************************************/
;;;3506   void RMP_Cmdbtn(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width, rmp_ptr_t Status)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;3507   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8020          LDR      r8,[sp,#0x20]
;;;3508       RMP_Rectangle(Coord_X,Coord_Y,Length,Width,RMP_CTL_GREY,RMP_CTL_GREY);
000010  f64b50d7          MOV      r0,#0xbdd7
000014  9000              STR      r0,[sp,#0]
000016  463b              MOV      r3,r7
000018  4632              MOV      r2,r6
00001a  4629              MOV      r1,r5
00001c  9001              STR      r0,[sp,#4]
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       RMP_Rectangle
;;;3509   
;;;3510       if(Status!=0)
000024  f1b80f00          CMP      r8,#0
000028  d006              BEQ      |L7.56|
;;;3511           RMP_Cmdbtn_Down(Coord_X, Coord_Y, Length, Width);
00002a  463b              MOV      r3,r7
00002c  4632              MOV      r2,r6
00002e  4629              MOV      r1,r5
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       RMP_Cmdbtn_Down
000036  e005              B        |L7.68|
                  |L7.56|
;;;3512       else
;;;3513           RMP_Cmdbtn_Up(Coord_X, Coord_Y, Length, Width);
000038  463b              MOV      r3,r7
00003a  4632              MOV      r2,r6
00003c  4629              MOV      r1,r5
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       RMP_Cmdbtn_Up
                  |L7.68|
;;;3514   }
000044  e8bd81fc          POP      {r2-r8,pc}
;;;3515   /* End Function:RMP_Cmdbtn ***************************************************/
                          ENDP


                          AREA ||i.RMP_Cmdbtn_Down||, CODE, READONLY, ALIGN=1

                  RMP_Cmdbtn_Down PROC
;;;3456   ******************************************************************************/
;;;3457   void RMP_Cmdbtn_Down(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width)
000000  b5f8              PUSH     {r3-r7,lr}
;;;3458   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;3459       RMP_Line(Coord_X,Coord_Y,Coord_X+Length-1,Coord_Y,RMP_CTL_BLACK);
00000a  2000              MOVS     r0,#0
00000c  9000              STR      r0,[sp,#0]
00000e  19a0              ADDS     r0,r4,r6
000010  1e42              SUBS     r2,r0,#1
000012  462b              MOV      r3,r5
000014  4629              MOV      r1,r5
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       RMP_Line
;;;3460       RMP_Line(Coord_X+Length-1,Coord_Y,Coord_X+Length-1,Coord_Y+Width-1,RMP_CTL_WHITE);
00001c  f64f70ff          MOV      r0,#0xffff
000020  19e9              ADDS     r1,r5,r7
000022  1e4b              SUBS     r3,r1,#1
000024  19a1              ADDS     r1,r4,r6
000026  1e4a              SUBS     r2,r1,#1
000028  19a1              ADDS     r1,r4,r6
00002a  9000              STR      r0,[sp,#0]
00002c  1e48              SUBS     r0,r1,#1
00002e  4629              MOV      r1,r5
000030  f7fffffe          BL       RMP_Line
;;;3461       RMP_Line(Coord_X+Length-1,Coord_Y+Width-1,Coord_X,Coord_Y+Width-1,RMP_CTL_WHITE);
000034  f64f70ff          MOV      r0,#0xffff
000038  19ea              ADDS     r2,r5,r7
00003a  1e53              SUBS     r3,r2,#1
00003c  19ea              ADDS     r2,r5,r7
00003e  1e51              SUBS     r1,r2,#1
000040  19a2              ADDS     r2,r4,r6
000042  9000              STR      r0,[sp,#0]
000044  1e50              SUBS     r0,r2,#1
000046  4622              MOV      r2,r4
000048  f7fffffe          BL       RMP_Line
;;;3462       RMP_Line(Coord_X,Coord_Y+Width-1,Coord_X,Coord_Y,RMP_CTL_BLACK);
00004c  2000              MOVS     r0,#0
00004e  9000              STR      r0,[sp,#0]
000050  19e8              ADDS     r0,r5,r7
000052  1e41              SUBS     r1,r0,#1
000054  462b              MOV      r3,r5
000056  4622              MOV      r2,r4
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       RMP_Line
;;;3463       /* Clear the old shadow */
;;;3464       RMP_Line(Coord_X+Length-2,Coord_Y+Width-2,Coord_X+1,Coord_Y+Width-2,RMP_CTL_GREY);    
00005e  f64b50d7          MOV      r0,#0xbdd7
000062  19ea              ADDS     r2,r5,r7
000064  1e93              SUBS     r3,r2,#2
000066  19ea              ADDS     r2,r5,r7
000068  1e91              SUBS     r1,r2,#2
00006a  19a2              ADDS     r2,r4,r6
00006c  9000              STR      r0,[sp,#0]
00006e  1e90              SUBS     r0,r2,#2
000070  1c62              ADDS     r2,r4,#1
000072  f7fffffe          BL       RMP_Line
;;;3465       RMP_Line(Coord_X+Length-2,Coord_Y+1,Coord_X+Length-2,Coord_Y+Width-2,RMP_CTL_GREY);    
000076  f64b50d7          MOV      r0,#0xbdd7
00007a  19e9              ADDS     r1,r5,r7
00007c  1e8b              SUBS     r3,r1,#2
00007e  19a1              ADDS     r1,r4,r6
000080  1e8a              SUBS     r2,r1,#2
000082  19a1              ADDS     r1,r4,r6
000084  9000              STR      r0,[sp,#0]
000086  1e88              SUBS     r0,r1,#2
000088  1c69              ADDS     r1,r5,#1
00008a  f7fffffe          BL       RMP_Line
;;;3466       /* The shadow */                            
;;;3467       RMP_Line(Coord_X+1,Coord_Y+Width-2,Coord_X+1,Coord_Y+1,RMP_CTL_DARK);    
00008e  f64730ef          MOV      r0,#0x7bef
000092  9000              STR      r0,[sp,#0]
000094  19e8              ADDS     r0,r5,r7
000096  1e81              SUBS     r1,r0,#2
000098  1c6b              ADDS     r3,r5,#1
00009a  1c62              ADDS     r2,r4,#1
00009c  1c60              ADDS     r0,r4,#1
00009e  f7fffffe          BL       RMP_Line
;;;3468       RMP_Line(Coord_X+1,Coord_Y+1,Coord_X+Length-2,Coord_Y+1,RMP_CTL_DARK);    
0000a2  f64730ef          MOV      r0,#0x7bef
0000a6  9000              STR      r0,[sp,#0]
0000a8  19a0              ADDS     r0,r4,r6
0000aa  1e82              SUBS     r2,r0,#2
0000ac  1c6b              ADDS     r3,r5,#1
0000ae  1c69              ADDS     r1,r5,#1
0000b0  1c60              ADDS     r0,r4,#1
0000b2  f7fffffe          BL       RMP_Line
;;;3469   }
0000b6  bdf8              POP      {r3-r7,pc}
;;;3470   /* End Function:RMP_Cmdbtn_Down **********************************************/
                          ENDP


                          AREA ||i.RMP_Cmdbtn_Up||, CODE, READONLY, ALIGN=1

                  RMP_Cmdbtn_Up PROC
;;;3480   ******************************************************************************/
;;;3481   void RMP_Cmdbtn_Up(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width)
000000  b5f8              PUSH     {r3-r7,lr}
;;;3482   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;3483       RMP_Line(Coord_X,Coord_Y,Coord_X+Length-1,Coord_Y,RMP_CTL_WHITE);
00000a  f64f70ff          MOV      r0,#0xffff
00000e  9000              STR      r0,[sp,#0]
000010  19a0              ADDS     r0,r4,r6
000012  1e42              SUBS     r2,r0,#1
000014  462b              MOV      r3,r5
000016  4629              MOV      r1,r5
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       RMP_Line
;;;3484       RMP_Line(Coord_X+Length-1,Coord_Y,Coord_X+Length-1,Coord_Y+Width-1,RMP_CTL_BLACK);
00001e  2000              MOVS     r0,#0
000020  19e9              ADDS     r1,r5,r7
000022  1e4b              SUBS     r3,r1,#1
000024  19a1              ADDS     r1,r4,r6
000026  1e4a              SUBS     r2,r1,#1
000028  19a1              ADDS     r1,r4,r6
00002a  9000              STR      r0,[sp,#0]
00002c  1e48              SUBS     r0,r1,#1
00002e  4629              MOV      r1,r5
000030  f7fffffe          BL       RMP_Line
;;;3485       RMP_Line(Coord_X+Length-1,Coord_Y+Width-1,Coord_X,Coord_Y+Width-1,RMP_CTL_BLACK);
000034  2000              MOVS     r0,#0
000036  19ea              ADDS     r2,r5,r7
000038  1e53              SUBS     r3,r2,#1
00003a  19ea              ADDS     r2,r5,r7
00003c  1e51              SUBS     r1,r2,#1
00003e  19a2              ADDS     r2,r4,r6
000040  9000              STR      r0,[sp,#0]
000042  1e50              SUBS     r0,r2,#1
000044  4622              MOV      r2,r4
000046  f7fffffe          BL       RMP_Line
;;;3486       RMP_Line(Coord_X,Coord_Y+Width-1,Coord_X,Coord_Y,RMP_CTL_WHITE);
00004a  f64f70ff          MOV      r0,#0xffff
00004e  9000              STR      r0,[sp,#0]
000050  19e8              ADDS     r0,r5,r7
000052  1e41              SUBS     r1,r0,#1
000054  462b              MOV      r3,r5
000056  4622              MOV      r2,r4
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       RMP_Line
;;;3487       /* Clear the old shadow */
;;;3488       RMP_Line(Coord_X+1,Coord_Y+Width-2,Coord_X+1,Coord_Y+1,RMP_CTL_GREY);    
00005e  f64b50d7          MOV      r0,#0xbdd7
000062  9000              STR      r0,[sp,#0]
000064  19e8              ADDS     r0,r5,r7
000066  1e81              SUBS     r1,r0,#2
000068  1c6b              ADDS     r3,r5,#1
00006a  1c62              ADDS     r2,r4,#1
00006c  1c60              ADDS     r0,r4,#1
00006e  f7fffffe          BL       RMP_Line
;;;3489       RMP_Line(Coord_X+1,Coord_Y+1,Coord_X+Length-2,Coord_Y+1,RMP_CTL_GREY);    
000072  f64b50d7          MOV      r0,#0xbdd7
000076  9000              STR      r0,[sp,#0]
000078  19a0              ADDS     r0,r4,r6
00007a  1e82              SUBS     r2,r0,#2
00007c  1c6b              ADDS     r3,r5,#1
00007e  1c69              ADDS     r1,r5,#1
000080  1c60              ADDS     r0,r4,#1
000082  f7fffffe          BL       RMP_Line
;;;3490       /* The shadow */
;;;3491       RMP_Line(Coord_X+Length-2,Coord_Y+Width-2,Coord_X+1,Coord_Y+Width-2,RMP_CTL_DARK);    
000086  f64730ef          MOV      r0,#0x7bef
00008a  19ea              ADDS     r2,r5,r7
00008c  1e93              SUBS     r3,r2,#2
00008e  19ea              ADDS     r2,r5,r7
000090  1e91              SUBS     r1,r2,#2
000092  19a2              ADDS     r2,r4,r6
000094  9000              STR      r0,[sp,#0]
000096  1e90              SUBS     r0,r2,#2
000098  1c62              ADDS     r2,r4,#1
00009a  f7fffffe          BL       RMP_Line
;;;3492       RMP_Line(Coord_X+Length-2,Coord_Y+1,Coord_X+Length-2,Coord_Y+Width-2,RMP_CTL_DARK);    
00009e  f64730ef          MOV      r0,#0x7bef
0000a2  19e9              ADDS     r1,r5,r7
0000a4  1e8b              SUBS     r3,r1,#2
0000a6  19a1              ADDS     r1,r4,r6
0000a8  1e8a              SUBS     r2,r1,#2
0000aa  19a1              ADDS     r1,r4,r6
0000ac  9000              STR      r0,[sp,#0]
0000ae  1e88              SUBS     r0,r1,#2
0000b0  1c69              ADDS     r1,r5,#1
0000b2  f7fffffe          BL       RMP_Line
;;;3493   }
0000b6  bdf8              POP      {r3-r7,pc}
;;;3494   /* End Function:RMP_Cmdbtn_Up ************************************************/
                          ENDP


                          AREA ||i.RMP_Cursor||, CODE, READONLY, ALIGN=2

                  RMP_Cursor PROC
;;;3196   #ifdef RMP_CTL_BLACK
;;;3197   void RMP_Cursor(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_ptr_t Style)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;3198   {
000004  4681              MOV      r9,r0
000006  468a              MOV      r10,r1
000008  4693              MOV      r11,r2
;;;3199       rmp_cnt_t Count;
;;;3200       rmp_cnt_t Size_B;
;;;3201       rmp_cnt_t Size_W;
;;;3202       const rmp_u8_t* Black;
;;;3203       const rmp_u8_t* White;
;;;3204   
;;;3205       /* Normal Mouse - all matrix encoded in (Y,X) */
;;;3206       static const rmp_u8_t Arrow_B[]=
;;;3207       {
;;;3208           0x00,0x10,0x11,0x20,0x22,0x30,0x33,0x40,0x44,0x50,0x55,0x60,0x66,0x70,0x77,0x80,
;;;3209           0x88,0x90,0x95,0x96,0x97,0x98,0x99,0xA0,0xA2,0xA3,0xA5,0xB0,0xB1,0xB3,0xB6,0xC0,
;;;3210           0xC1,0xC4,0xC6,0xD0,0xD4,0xD7,0xE5,0xE7,0xF5,0xF6
;;;3211       };
;;;3212       static const rmp_u8_t Arrow_W[]=
;;;3213       {
;;;3214           0x21,0x31,0x32,0x41,0x42,0x43,0x51,0x52,0x53,0x54,0x61,0x62,0x63,0x64,0x65,0x71,
;;;3215           0x72,0x73,0x74,0x75,0x76,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x91,0x92,0x93,0x94,
;;;3216           0xA1,0xA4,0xB4,0xB5,0xC5,0xD5,0xD6,0xE6
;;;3217       };
;;;3218       /* Busy mark - no white part */
;;;3219       static const rmp_u8_t Busy_B[]=
;;;3220       {
;;;3221           0x0A,0x0B,0x0C,0x0D,0x0E,0x1A,0x1B,0x1D,0x1E,0x2A,0x2C,0x2E,0x3B,0x3D,0x4C,0x5B,
;;;3222           0x5D,0x6A,0x6E,0x7A,0x7C,0x7E,0x8A,0x8B,0x8C,0x8D,0x8E
;;;3223       };
;;;3224       static const rmp_u8_t Busy_W[]=
;;;3225       {
;;;3226           0x1C,0x2B,0x2D,0x3C,0x5C,0x6B,0x6C,0x6D,0x7B,0x7D
;;;3227       };
;;;3228       /* Question mark - no white part */
;;;3229       static const rmp_u8_t Question[]=
;;;3230       {
;;;3231           0x0B,0x0C,0x0D,0x1A,0x1B,0x1C,0x1D,0x1E,0x29,0x2A,0x2B,0x2D,0x2E,0x2F,0x39,0x3A,
;;;3232           0x3E,0x3F,0x4A,0x4D,0x4E,0x4F,0x5C,0x5D,0x5E,0x6C,0x6D,0x8D,0x8E,0x9D,0x9E
;;;3233       };
;;;3234       /* Hand-shaped cursor */
;;;3235       static const rmp_u8_t Hand_B[]=
;;;3236       {
;;;3237           0x05,0x06,0x14,0x17,0x24,0x27,0x34,0x37,0x39,0x44,0x47,0x48,0x4A,0x4C,0x51,0x52,
;;;3238           0x54,0x57,0x5A,0x5B,0x5D,0x5E,0x60,0x63,0x64,0x67,0x6A,0x6D,0x6F,0x70,0x74,0x77,
;;;3239           0x7A,0x7D,0x7F,0x80,0x8F,0x90,0x9F,0xA0,0xAF,0xB0,0xBF,0xC1,0xCE,0xD1,0xD2,0xD3,
;;;3240           0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xE1,0xEE,0xF2,0xF3,0xF4,
;;;3241           0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD
;;;3242       };
;;;3243       static const rmp_u8_t Hand_W[]=
;;;3244       {
;;;3245           0x15,0x16,0x25,0x26,0x35,0x36,0x45,0x46,0x49,0x55,0x56,0x58,0x59,0x5C,0x61,0x62,
;;;3246           0x65,0x66,0x68,0x69,0x6B,0x6C,0x6E,0x71,0x72,0x73,0x75,0x76,0x78,0x79,0x7B,0x7C,
;;;3247           0x7E,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x91,
;;;3248           0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0xA1,0xA2,0xA3,
;;;3249           0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xB1,0xB2,0xB3,0xB4,0xB5,
;;;3250           0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,
;;;3251           0xC9,0xCA,0xCB,0xCC,0xCD,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,
;;;3252           0xED
;;;3253       };
;;;3254       /* The cursor for text editing - no white part */
;;;3255       static const rmp_u8_t Text[]=
;;;3256       {
;;;3257           0x00,0x01,0x02,0x04,0x05,0x06,0x13,0x23,0x33,0x43,0x53,0x63,0x73,0x83,0x93,0xA3,
;;;3258           0xB3,0xC3,0xD3,0xE3,0xF0,0xF1,0xF2,0xF4,0xF5,0xF6
;;;3259       };
;;;3260       /* The stop cursor */
;;;3261       static const rmp_u8_t Stop_B[]=
;;;3262       {
;;;3263           0x05,0x06,0x07,0x08,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x22,0x23,0x24,0x29,
;;;3264           0x2A,0x2B,0x31,0x32,0x33,0x34,0x3A,0x3B,0x3C,0x41,0x42,0x43,0x44,0x45,0x4B,0x4C,
;;;3265           0x50,0x51,0x54,0x55,0x56,0x5C,0x5D,0x60,0x61,0x65,0x66,0x67,0x6C,0x6D,0x70,0x71,
;;;3266           0x76,0x77,0x78,0x7C,0x7D,0x80,0x81,0x87,0x88,0x89,0x8C,0x8D,0x91,0x92,0x98,0x99,
;;;3267           0x9A,0x9B,0x9C,0xA1,0xA2,0xA3,0xA9,0xAA,0xAB,0xAC,0xB2,0xB3,0xB4,0xB9,0xBA,0xBB,
;;;3268           0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xD5,0xD6,0xD7,0xD8
;;;3269       };
;;;3270       static const rmp_u8_t Stop_W[]=
;;;3271       {
;;;3272           0x25,0x26,0x27,0x28,0x35,0x36,0x37,0x38,0x39,0x46,0x47,0x48,0x49,0x4A,0x52,0x53,
;;;3273           0x57,0x58,0x59,0x5A,0x5B,0x62,0x63,0x64,0x68,0x69,0x6A,0x6B,0x72,0x73,0x74,0x75,
;;;3274           0x79,0x7A,0x7B,0x82,0x83,0x84,0x85,0x86,0x8A,0x8B,0x93,0x94,0x95,0x96,0x97,0xA4,
;;;3275           0xA5,0xA6,0xA7,0xA8,0xB5,0xB6,0xB7,0xB8
;;;3276       };
;;;3277          /* Cross arrow - no white part  */
;;;3278       static const rmp_u8_t Adj_ALL[]=
;;;3279       {
;;;3280           0x07,0x16,0x17,0x18,0x25,0x26,0x27,0x28,0x29,0x37,0x47,0x52,0x57,0x5C,0x61,0x62,
;;;3281           0x67,0x6C,0x6D,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7A,0x7B,0x7C,
;;;3282           0x7D,0x7E,0x81,0x82,0x87,0x8C,0x8D,0x92,0x97,0x9C,0xA7,0xB7,0xC5,0xC6,0xC7,0xC8,
;;;3283           0xC9,0xD6,0xD7,0xD8,0xE7
;;;3284       };    
;;;3285       /* Left to right arrow - no white part */
;;;3286       static const rmp_u8_t Adj_LR[]=
;;;3287       {
;;;3288           0x52,0x5D,0x61,0x62,0x6D,0x6E,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,
;;;3289           0x7A,0x7B,0x7C,0x7D,0x7E,0x7F,0x81,0x82,0x8D,0x8E,0x92,0x9D
;;;3290       };
;;;3291       /* Up to down arrow - no white part */
;;;3292       static const rmp_u8_t Adj_UD[]=
;;;3293       {
;;;3294           0x07,0x16,0x17,0x18,0x25,0x26,0x27,0x28,0x29,0x37,0x47,0x57,0x67,0x77,0x87,0x97,
;;;3295           0xA7,0xB7,0xC7,0xD5,0xD6,0xD7,0xD8,0xD9,0xE6,0xE7,0xE8,0xF7
;;;3296   
;;;3297       };
;;;3298       /* Bottom-right to top-left arrow - no white part */
;;;3299       static const rmp_u8_t Adj_BRUL[]=
;;;3300       {
;;;3301           0x00,0x01,0x02,0x03,0x04,0x10,0x11,0x12,0x13,0x20,0x21,0x22,0x30,0x31,0x33,0x40,
;;;3302           0x44,0x55,0x66,0x77,0x88,0x99,0xAA,0xBB,0xBF,0xCC,0xCE,0xCF,0xDD,0xDE,0xDF,0xEC,
;;;3303           0xED,0xEE,0xEF,0xFB,0xFC,0xFD,0xFE,0xFF
;;;3304       };
;;;3305       /* Bottom-left to top-right arrow - no white part */
;;;3306       static const rmp_u8_t Adj_BLUR[]=
;;;3307       {
;;;3308           0x0B,0x0C,0x0D,0x0E,0x0F,0x1C,0x1D,0x1E,0x1F,0x2D,0x2E,0x2F,0x3C,0x3E,0x3F,0x4B,
;;;3309           0x4F,0x5A,0x69,0x78,0x87,0x96,0xA5,0xB0,0xB4,0xC0,0xC1,0xC3,0xD0,0xD1,0xD2,0xE0,
;;;3310           0xE1,0xE2,0xE3,0xF0,0xF1,0xF2,0xF3,0xF4
;;;3311       };
;;;3312       /* The crosshair cursor - no white part */
;;;3313       static const rmp_u8_t Cross[]=
;;;3314       {
;;;3315           0x07,0x17,0x27,0x37,0x46,0x47,0x48,0x55,0x57,0x59,0x64,0x6A,0x70,0x71,0x72,0x73,
;;;3316           0x74,0x75,0x77,0x79,0x7A,0x7B,0x7C,0x7D,0x7E,0x84,0x8A,0x95,0x97,0x99,0xA6,0xA7,
;;;3317           0xA8,0xB7,0xC7,0xD7,0xE7
;;;3318       };
;;;3319       
;;;3320       /* Draw them */
;;;3321       switch(Style)
00000a  f1bb0f0c          CMP      r11,#0xc
00000e  d279              BCS      |L10.260|
000010  e8dff00b          TBB      [pc,r11]
000014  060c0d41          DCB      0x06,0x0c,0x0d,0x41
000018  474d5359          DCB      0x47,0x4d,0x53,0x59
00001c  5f656b72          DCB      0x5f,0x65,0x6b,0x72
;;;3322       {
;;;3323           case RMP_CUR_NORM:{Size_B=sizeof(Arrow_B);Size_W=sizeof(Arrow_W);Black=Arrow_B;White=Arrow_W;break;}
000020  272a              MOVS     r7,#0x2a
000022  f04f0828          MOV      r8,#0x28
000026  4d4a              LDR      r5,|L10.336|
000028  4e4a              LDR      r6,|L10.340|
00002a  e06d              B        |L10.264|
;;;3324           case RMP_CUR_BUSY:case RMP_CUR_QUESTION:
00002c  bf00              NOP      
;;;3325           {
;;;3326               for(Count=0;Count<sizeof(Arrow_B);Count++)                                                              
00002e  2400              MOVS     r4,#0
000030  e00d              B        |L10.78|
                  |L10.50|
;;;3327                   RMP_POINT(Coord_X+(Arrow_B[Count]&0x0F),Coord_Y+(Arrow_B[Count]>>4),RMP_CTL_BLACK);
000032  4a47              LDR      r2,|L10.336|
000034  5d12              LDRB     r2,[r2,r4]
000036  eb0a1122          ADD      r1,r10,r2,ASR #4
00003a  4a45              LDR      r2,|L10.336|
00003c  5d12              LDRB     r2,[r2,r4]
00003e  f002020f          AND      r2,r2,#0xf
000042  eb020009          ADD      r0,r2,r9
000046  2200              MOVS     r2,#0
000048  f7fffffe          BL       RMP_Point
00004c  1c64              ADDS     r4,r4,#1              ;3326
                  |L10.78|
00004e  2c2a              CMP      r4,#0x2a              ;3326
000050  d3ef              BCC      |L10.50|
;;;3328               for(Count=0;Count<sizeof(Arrow_W);Count++)                                                              
000052  2400              MOVS     r4,#0
000054  e00e              B        |L10.116|
                  |L10.86|
;;;3329                   RMP_POINT(Coord_X+(Arrow_W[Count]&0x0F),Coord_Y+(Arrow_W[Count]>>4),RMP_CTL_WHITE);
000056  4a3f              LDR      r2,|L10.340|
000058  5d12              LDRB     r2,[r2,r4]
00005a  eb0a1122          ADD      r1,r10,r2,ASR #4
00005e  4a3d              LDR      r2,|L10.340|
000060  5d12              LDRB     r2,[r2,r4]
000062  f002020f          AND      r2,r2,#0xf
000066  eb020009          ADD      r0,r2,r9
00006a  f64f72ff          MOV      r2,#0xffff
00006e  f7fffffe          BL       RMP_Point
000072  1c64              ADDS     r4,r4,#1              ;3328
                  |L10.116|
000074  2c28              CMP      r4,#0x28              ;3328
000076  d3ee              BCC      |L10.86|
;;;3330               
;;;3331               if(Style==RMP_CUR_BUSY)
000078  f1bb0f01          CMP      r11,#1
00007c  d105              BNE      |L10.138|
;;;3332               {
;;;3333                   Size_B=sizeof(Busy_B);
00007e  271b              MOVS     r7,#0x1b
;;;3334                   Size_W=sizeof(Busy_W);
000080  f04f080a          MOV      r8,#0xa
;;;3335                   Black=Busy_B;
000084  4d34              LDR      r5,|L10.344|
;;;3336                   White=Busy_W;
000086  4e35              LDR      r6,|L10.348|
000088  e004              B        |L10.148|
                  |L10.138|
;;;3337               }
;;;3338               else
;;;3339               {
;;;3340                   Size_B=sizeof(Question);
00008a  271f              MOVS     r7,#0x1f
;;;3341                   Size_W=0;
00008c  f04f0800          MOV      r8,#0
;;;3342                   Black=Question;
000090  4d33              LDR      r5,|L10.352|
;;;3343                   White=0;
000092  2600              MOVS     r6,#0
                  |L10.148|
;;;3344               }
;;;3345               break;
000094  e038              B        |L10.264|
;;;3346           }       
;;;3347           case RMP_CUR_HAND:{Size_B=sizeof(Hand_B);Size_W=sizeof(Hand_W);Black=Hand_B;White=Hand_W;break;}
000096  2749              MOVS     r7,#0x49
000098  f04f0871          MOV      r8,#0x71
00009c  4d31              LDR      r5,|L10.356|
00009e  4e32              LDR      r6,|L10.360|
0000a0  e032              B        |L10.264|
;;;3348           case RMP_CUR_TEXT:{Size_B=sizeof(Text);Size_W=0;Black=Text;White=0;break;}
0000a2  271a              MOVS     r7,#0x1a
0000a4  f04f0800          MOV      r8,#0
0000a8  4d30              LDR      r5,|L10.364|
0000aa  2600              MOVS     r6,#0
0000ac  e02c              B        |L10.264|
;;;3349           case RMP_CUR_STOP:{Size_B=sizeof(Stop_B);Size_W=sizeof(Stop_W);Black=Stop_B;White=Stop_W;break;}
0000ae  275c              MOVS     r7,#0x5c
0000b0  f04f0838          MOV      r8,#0x38
0000b4  4d2e              LDR      r5,|L10.368|
0000b6  4e2f              LDR      r6,|L10.372|
0000b8  e026              B        |L10.264|
;;;3350           case RMP_CUR_MOVE:{Size_B=sizeof(Adj_ALL);Size_W=0;Black=Adj_ALL;White=0;break;}
0000ba  2735              MOVS     r7,#0x35
0000bc  f04f0800          MOV      r8,#0
0000c0  4d2d              LDR      r5,|L10.376|
0000c2  2600              MOVS     r6,#0
0000c4  e020              B        |L10.264|
;;;3351           case RMP_CUR_LR:{Size_B=sizeof(Adj_LR);Size_W=0;Black=Adj_LR;White=0;break;}
0000c6  271c              MOVS     r7,#0x1c
0000c8  f04f0800          MOV      r8,#0
0000cc  4d2b              LDR      r5,|L10.380|
0000ce  2600              MOVS     r6,#0
0000d0  e01a              B        |L10.264|
;;;3352           case RMP_CUR_UD:{Size_B=sizeof(Adj_UD);Size_W=0;Black=Adj_UD;White=0;break;}
0000d2  271c              MOVS     r7,#0x1c
0000d4  f04f0800          MOV      r8,#0
0000d8  4d29              LDR      r5,|L10.384|
0000da  2600              MOVS     r6,#0
0000dc  e014              B        |L10.264|
;;;3353           case RMP_CUR_ULBR:{Size_B=sizeof(Adj_BRUL);Size_W=0;Black=Adj_BRUL;White=0;break;}
0000de  2728              MOVS     r7,#0x28
0000e0  f04f0800          MOV      r8,#0
0000e4  4d27              LDR      r5,|L10.388|
0000e6  2600              MOVS     r6,#0
0000e8  e00e              B        |L10.264|
;;;3354           case RMP_CUR_URBL:{Size_B=sizeof(Adj_BLUR);Size_W=0;Black=Adj_BLUR;White=0;break;}
0000ea  2728              MOVS     r7,#0x28
0000ec  f04f0800          MOV      r8,#0
0000f0  4d25              LDR      r5,|L10.392|
0000f2  2600              MOVS     r6,#0
0000f4  e008              B        |L10.264|
0000f6  e005              B        |L10.260|
;;;3355           case RMP_CUR_CROSS:{Size_B=sizeof(Cross);Size_W=0;Black=Cross;White=0;break;}
0000f8  2725              MOVS     r7,#0x25
0000fa  f04f0800          MOV      r8,#0
0000fe  4d23              LDR      r5,|L10.396|
000100  2600              MOVS     r6,#0
000102  e001              B        |L10.264|
                  |L10.260|
;;;3356           default:return;
;;;3357       }
;;;3358       
;;;3359       for(Count=0;Count<Size_B;Count++)                                                              
;;;3360           RMP_POINT(Coord_X+(Black[Count]&0x0F),Coord_Y+(Black[Count]>>4),RMP_CTL_BLACK);
;;;3361       for(Count=0;Count<Size_W;Count++)                                                              
;;;3362           RMP_POINT(Coord_X+(White[Count]&0x0F),Coord_Y+(White[Count]>>4),RMP_CTL_WHITE);
;;;3363   }
000104  e8bd9ff0          POP      {r4-r12,pc}
                  |L10.264|
000108  bf00              NOP                            ;3323
00010a  2400              MOVS     r4,#0                 ;3359
00010c  e00b              B        |L10.294|
                  |L10.270|
00010e  5d2a              LDRB     r2,[r5,r4]            ;3360
000110  eb0a1122          ADD      r1,r10,r2,ASR #4      ;3360
000114  5d2a              LDRB     r2,[r5,r4]            ;3360
000116  f002020f          AND      r2,r2,#0xf            ;3360
00011a  eb020009          ADD      r0,r2,r9              ;3360
00011e  2200              MOVS     r2,#0                 ;3360
000120  f7fffffe          BL       RMP_Point
000124  1c64              ADDS     r4,r4,#1              ;3359
                  |L10.294|
000126  42bc              CMP      r4,r7                 ;3359
000128  dbf1              BLT      |L10.270|
00012a  2400              MOVS     r4,#0                 ;3361
00012c  e00c              B        |L10.328|
                  |L10.302|
00012e  5d32              LDRB     r2,[r6,r4]            ;3362
000130  eb0a1122          ADD      r1,r10,r2,ASR #4      ;3362
000134  5d32              LDRB     r2,[r6,r4]            ;3362
000136  f002020f          AND      r2,r2,#0xf            ;3362
00013a  eb020009          ADD      r0,r2,r9              ;3362
00013e  f64f72ff          MOV      r2,#0xffff            ;3362
000142  f7fffffe          BL       RMP_Point
000146  1c64              ADDS     r4,r4,#1              ;3361
                  |L10.328|
000148  4544              CMP      r4,r8                 ;3361
00014a  dbf0              BLT      |L10.302|
00014c  bf00              NOP      
00014e  e7d9              B        |L10.260|
;;;3364   /* End Function: RMP_Cursor **************************************************/
                          ENDP

                  |L10.336|
                          DCD      Arrow_B
                  |L10.340|
                          DCD      Arrow_W
                  |L10.344|
                          DCD      Busy_B
                  |L10.348|
                          DCD      Busy_W
                  |L10.352|
                          DCD      Question
                  |L10.356|
                          DCD      Hand_B
                  |L10.360|
                          DCD      Hand_W
                  |L10.364|
                          DCD      Text
                  |L10.368|
                          DCD      Stop_B
                  |L10.372|
                          DCD      Stop_W
                  |L10.376|
                          DCD      Adj_ALL
                  |L10.380|
                          DCD      Adj_LR
                  |L10.384|
                          DCD      Adj_UD
                  |L10.388|
                          DCD      Adj_BRUL
                  |L10.392|
                          DCD      Adj_BLUR
                  |L10.396|
                          DCD      Cross

                          AREA ||i.RMP_Dot_Line||, CODE, READONLY, ALIGN=1

                  RMP_Dot_Line PROC
;;;2724   ******************************************************************************/
;;;2725   void RMP_Dot_Line(rmp_cnt_t Start_X, rmp_cnt_t Start_Y, rmp_cnt_t End_X,rmp_cnt_t End_Y, rmp_ptr_t Dot, rmp_ptr_t Space)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;2726   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
;;;2727       rmp_cnt_t Trav_X;
;;;2728       rmp_cnt_t Trav_Y;
;;;2729       rmp_cnt_t Dir_X;
;;;2730       rmp_cnt_t Dir_Y;
;;;2731       rmp_cnt_t Error;
;;;2732       rmp_cnt_t Cur_X;
;;;2733       rmp_cnt_t Cur_Y;
;;;2734   
;;;2735       Error=0;
00000c  f04f0a00          MOV      r10,#0
;;;2736       /* Get their absolute value, and then draw the line */
;;;2737       Trav_X=(Start_X>End_X)?(Start_X-End_X):(End_X-Start_X);
000010  4544              CMP      r4,r8
000012  dd02              BLE      |L11.26|
000014  eba40008          SUB      r0,r4,r8
000018  e001              B        |L11.30|
                  |L11.26|
00001a  eba80004          SUB      r0,r8,r4
                  |L11.30|
00001e  9002              STR      r0,[sp,#8]
;;;2738       Trav_Y=(Start_Y>End_Y)?(Start_Y-End_Y):(End_Y-Start_Y);
000020  454d              CMP      r5,r9
000022  dd02              BLE      |L11.42|
000024  eba50009          SUB      r0,r5,r9
000028  e001              B        |L11.46|
                  |L11.42|
00002a  eba90005          SUB      r0,r9,r5
                  |L11.46|
00002e  9001              STR      r0,[sp,#4]
;;;2739   
;;;2740       /* Decide the increment direction */
;;;2741       if(End_X-Start_X>0)
000030  eba80004          SUB      r0,r8,r4
000034  2800              CMP      r0,#0
000036  dd02              BLE      |L11.62|
;;;2742           Dir_X=1;
000038  f04f0b01          MOV      r11,#1
00003c  e001              B        |L11.66|
                  |L11.62|
;;;2743       else
;;;2744           Dir_X=-1;
00003e  f04f3bff          MOV      r11,#0xffffffff
                  |L11.66|
;;;2745   
;;;2746       if(End_Y-Start_Y>0)
000042  eba90005          SUB      r0,r9,r5
000046  2800              CMP      r0,#0
000048  dd02              BLE      |L11.80|
;;;2747           Dir_Y=1;
00004a  2001              MOVS     r0,#1
00004c  9000              STR      r0,[sp,#0]
00004e  e002              B        |L11.86|
                  |L11.80|
;;;2748       else
;;;2749           Dir_Y=-1;
000050  f04f30ff          MOV      r0,#0xffffffff
000054  9000              STR      r0,[sp,#0]
                  |L11.86|
;;;2750   
;;;2751       if(Trav_X>Trav_Y)
000056  e9dd1001          LDRD     r1,r0,[sp,#4]
00005a  4288              CMP      r0,r1
00005c  dd24              BLE      |L11.168|
;;;2752       {
;;;2753           Cur_Y=Start_Y;
00005e  462f              MOV      r7,r5
;;;2754           for(Cur_X=Start_X;Cur_X!=End_X+Dir_X;Cur_X+=Dir_X)
000060  4626              MOV      r6,r4
000062  e01c              B        |L11.158|
                  |L11.100|
;;;2755           {
;;;2756               /* Draw the dot and the white space alternatively */
;;;2757               if((Cur_X&0x01)!=0)
000064  f0060001          AND      r0,r6,#1
000068  b128              CBZ      r0,|L11.118|
;;;2758                   RMP_POINT(Cur_X,Cur_Y,Dot);
00006a  4639              MOV      r1,r7
00006c  4630              MOV      r0,r6
00006e  9a0c              LDR      r2,[sp,#0x30]
000070  f7fffffe          BL       RMP_Point
000074  e007              B        |L11.134|
                  |L11.118|
;;;2759               else
;;;2760               {
;;;2761                   if(Space!=RMP_TRANS)
000076  980d              LDR      r0,[sp,#0x34]
000078  2801              CMP      r0,#1
00007a  d004              BEQ      |L11.134|
;;;2762                       RMP_POINT(Cur_X,Cur_Y,Space);
00007c  4639              MOV      r1,r7
00007e  4630              MOV      r0,r6
000080  9a0d              LDR      r2,[sp,#0x34]
000082  f7fffffe          BL       RMP_Point
                  |L11.134|
;;;2763               }
;;;2764               Error+=Trav_Y;
000086  9801              LDR      r0,[sp,#4]
000088  4482              ADD      r10,r10,r0
;;;2765               if((Error<<1)>=Trav_X)
00008a  9802              LDR      r0,[sp,#8]
00008c  ebb00f4a          CMP      r0,r10,LSL #1
000090  dc04              BGT      |L11.156|
;;;2766               {
;;;2767                   Cur_Y+=Dir_Y;
000092  9800              LDR      r0,[sp,#0]
000094  4407              ADD      r7,r7,r0
;;;2768                   Error-=Trav_X;
000096  9802              LDR      r0,[sp,#8]
000098  ebaa0a00          SUB      r10,r10,r0
                  |L11.156|
00009c  445e              ADD      r6,r6,r11             ;2754
                  |L11.158|
00009e  eb08000b          ADD      r0,r8,r11             ;2754
0000a2  42b0              CMP      r0,r6                 ;2754
0000a4  d1de              BNE      |L11.100|
0000a6  e023              B        |L11.240|
                  |L11.168|
;;;2769               }
;;;2770           }
;;;2771       }
;;;2772       else
;;;2773       {
;;;2774           Cur_X=Start_X;
0000a8  4626              MOV      r6,r4
;;;2775           for(Cur_Y=Start_Y;Cur_Y!=End_Y+Dir_Y;Cur_Y+=Dir_Y)
0000aa  462f              MOV      r7,r5
0000ac  e01c              B        |L11.232|
                  |L11.174|
;;;2776           {
;;;2777               /* Draw the dot and the white space alternatively */
;;;2778               if((Cur_Y&0x01)!=0)
0000ae  f0070001          AND      r0,r7,#1
0000b2  b128              CBZ      r0,|L11.192|
;;;2779                   RMP_POINT(Cur_X,Cur_Y,Dot);
0000b4  4639              MOV      r1,r7
0000b6  4630              MOV      r0,r6
0000b8  9a0c              LDR      r2,[sp,#0x30]
0000ba  f7fffffe          BL       RMP_Point
0000be  e007              B        |L11.208|
                  |L11.192|
;;;2780               else
;;;2781               {
;;;2782                   if(Space!=RMP_TRANS)
0000c0  980d              LDR      r0,[sp,#0x34]
0000c2  2801              CMP      r0,#1
0000c4  d004              BEQ      |L11.208|
;;;2783                       RMP_POINT(Cur_X,Cur_Y,Space);
0000c6  4639              MOV      r1,r7
0000c8  4630              MOV      r0,r6
0000ca  9a0d              LDR      r2,[sp,#0x34]
0000cc  f7fffffe          BL       RMP_Point
                  |L11.208|
;;;2784               }
;;;2785   
;;;2786               Error+=Trav_X;
0000d0  9802              LDR      r0,[sp,#8]
0000d2  4482              ADD      r10,r10,r0
;;;2787               if((Error<<1)>=Trav_Y)
0000d4  9801              LDR      r0,[sp,#4]
0000d6  ebb00f4a          CMP      r0,r10,LSL #1
0000da  dc03              BGT      |L11.228|
;;;2788               {
;;;2789                   Cur_X+=Dir_X;
0000dc  445e              ADD      r6,r6,r11
;;;2790                   Error-=Trav_Y;
0000de  9801              LDR      r0,[sp,#4]
0000e0  ebaa0a00          SUB      r10,r10,r0
                  |L11.228|
0000e4  9800              LDR      r0,[sp,#0]            ;2775
0000e6  4407              ADD      r7,r7,r0              ;2775
                  |L11.232|
0000e8  9800              LDR      r0,[sp,#0]            ;2775
0000ea  4448              ADD      r0,r0,r9              ;2775
0000ec  42b8              CMP      r0,r7                 ;2775
0000ee  d1de              BNE      |L11.174|
                  |L11.240|
;;;2791               }
;;;2792           }
;;;2793       }
;;;2794   }
0000f0  e8bd8ffe          POP      {r1-r11,pc}
;;;2795   /* End Function:RMP_Dot_Line *************************************************/
                          ENDP


                          AREA ||i.RMP_Free||, CODE, READONLY, ALIGN=1

                  RMP_Free PROC
;;;2505   ******************************************************************************/
;;;2506   void RMP_Free(volatile void* Pool, void* Mem_Ptr)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;2507   {
000004  4681              MOV      r9,r0
000006  460e              MOV      r6,r1
;;;2508       volatile struct RMP_Mem* Mem; 
;;;2509       volatile struct RMP_Mem_Head* Mem_Head;
;;;2510       volatile struct RMP_Mem_Head* Left_Head;
;;;2511       volatile struct RMP_Mem_Head* Right_Head;
;;;2512       rmp_cnt_t Merge_Left;
;;;2513   
;;;2514       /* Check if pointer is null */
;;;2515       if((Pool==0)||(Mem_Ptr==0))
000008  f1b90f00          CMP      r9,#0
00000c  d000              BEQ      |L12.16|
00000e  b91e              CBNZ     r6,|L12.24|
                  |L12.16|
;;;2516       {
;;;2517           RMP_COVERAGE_MARKER();
000010  bf00              NOP      
000012  bf00              NOP      
                  |L12.20|
;;;2518           return;
;;;2519       }
;;;2520       else
;;;2521           RMP_COVERAGE_MARKER();
;;;2522       
;;;2523       /* See if the address is within the allocatable address range. If not, abort directly. */
;;;2524       Mem=(volatile struct RMP_Mem*)Pool;
;;;2525       if((((rmp_ptr_t)Mem_Ptr)<=((rmp_ptr_t)Mem))||(((rmp_ptr_t)Mem_Ptr)>=(((rmp_ptr_t)Mem)+Mem->Size)))
;;;2526       {
;;;2527           RMP_COVERAGE_MARKER();
;;;2528           return;
;;;2529       }
;;;2530       else
;;;2531           RMP_COVERAGE_MARKER();
;;;2532   
;;;2533       Mem_Head=(struct RMP_Mem_Head*)(((rmp_ptr_t)Mem_Ptr)-sizeof(struct RMP_Mem_Head));
;;;2534       /* See if the block can really be freed */
;;;2535       if(Mem_Head->State==RMP_MEM_FREE)
;;;2536       {
;;;2537           RMP_COVERAGE_MARKER();
;;;2538           return;
;;;2539       }
;;;2540       else
;;;2541           RMP_COVERAGE_MARKER();
;;;2542   
;;;2543       /* Now we are sure that it can be freed. Delete it from the allocated list now */
;;;2544       RMP_List_Del(Mem_Head->Head.Prev,Mem_Head->Head.Next);
;;;2545       Mem_Head->State=RMP_MEM_FREE;
;;;2546       
;;;2547       /* Now check if we can merge it with the higher blocks */
;;;2548       Right_Head=(struct RMP_Mem_Head*)(((rmp_ptr_t)(Mem_Head->Tail))+sizeof(struct RMP_Mem_Tail));
;;;2549       if(((rmp_ptr_t)Right_Head)!=(((rmp_ptr_t)Mem)+Mem->Size))
;;;2550       {
;;;2551           RMP_COVERAGE_MARKER();
;;;2552           /* If this one is unoccupied */
;;;2553           if((Right_Head->State)==RMP_MEM_FREE)
;;;2554           {
;;;2555               RMP_COVERAGE_MARKER();
;;;2556               /* Delete, merge */
;;;2557               _RMP_Mem_Del(Pool,Right_Head);
;;;2558               _RMP_Mem_Block(Mem_Head,
;;;2559                              ((rmp_ptr_t)(Right_Head->Tail))+sizeof(struct RMP_Mem_Tail)-(rmp_ptr_t)Mem_Head);
;;;2560           }
;;;2561           else
;;;2562               RMP_COVERAGE_MARKER();
;;;2563       }
;;;2564       else
;;;2565           RMP_COVERAGE_MARKER();
;;;2566   
;;;2567       /* Now check if we can merge it with the lower blocks */
;;;2568       Merge_Left=0;
;;;2569       if((rmp_ptr_t)Mem_Head!=Mem->Start)
;;;2570       {
;;;2571           RMP_COVERAGE_MARKER();
;;;2572           Left_Head=((struct RMP_Mem_Tail*)(((rmp_ptr_t)Mem_Head)-sizeof(struct RMP_Mem_Tail)))->Head;
;;;2573   
;;;2574           /* If this one is unoccupied */
;;;2575           if(Left_Head->State==RMP_MEM_FREE)
;;;2576           {
;;;2577               RMP_COVERAGE_MARKER();
;;;2578               /* Delete, merge */
;;;2579               _RMP_Mem_Del(Pool, Left_Head);
;;;2580               _RMP_Mem_Block(Left_Head,
;;;2581                              (rmp_ptr_t)((rmp_ptr_t)(Mem_Head->Tail)+sizeof(struct RMP_Mem_Tail)-(rmp_ptr_t)Left_Head));
;;;2582   
;;;2583               /* We have completed the merge here and the original block has destroyed.
;;;2584                * Thus there's no need to insert it into the list again */
;;;2585               Merge_Left=1;
;;;2586           }
;;;2587           else
;;;2588               RMP_COVERAGE_MARKER();
;;;2589       }
;;;2590       else
;;;2591           RMP_COVERAGE_MARKER();
;;;2592   
;;;2593       /* If we did not merge it with the left-side blocks, insert the original pointer's block 
;;;2594        * into the TLSF table(Merging with the right-side one won't disturb this) */
;;;2595       if(Merge_Left==0)
;;;2596       {
;;;2597           RMP_COVERAGE_MARKER();
;;;2598           _RMP_Mem_Ins(Pool, Mem_Head);
;;;2599       }
;;;2600       else
;;;2601       {
;;;2602           RMP_COVERAGE_MARKER();
;;;2603           _RMP_Mem_Ins(Pool, Left_Head);
;;;2604       }
;;;2605   }
000014  e8bd87f0          POP      {r4-r10,pc}
                  |L12.24|
000018  bf00              NOP                            ;2521
00001a  bf00              NOP                            ;2521
00001c  464d              MOV      r5,r9                 ;2524
00001e  42ae              CMP      r6,r5                 ;2525
000020  d903              BLS      |L12.42|
000022  6928              LDR      r0,[r5,#0x10]         ;2525
000024  4428              ADD      r0,r0,r5              ;2525
000026  42b0              CMP      r0,r6                 ;2525
000028  d802              BHI      |L12.48|
                  |L12.42|
00002a  bf00              NOP                            ;2527
00002c  bf00              NOP                            ;2527
00002e  e7f1              B        |L12.20|
                  |L12.48|
000030  bf00              NOP                            ;2531
000032  bf00              NOP                            ;2531
000034  f1a60410          SUB      r4,r6,#0x10           ;2533
000038  68a0              LDR      r0,[r4,#8]            ;2535
00003a  b910              CBNZ     r0,|L12.66|
00003c  bf00              NOP                            ;2537
00003e  bf00              NOP                            ;2537
000040  e7e8              B        |L12.20|
                  |L12.66|
000042  bf00              NOP                            ;2541
000044  bf00              NOP                            ;2541
000046  6861              LDR      r1,[r4,#4]            ;2544
000048  6820              LDR      r0,[r4,#0]            ;2544
00004a  f7fffffe          BL       RMP_List_Del
00004e  2000              MOVS     r0,#0                 ;2545
000050  60a0              STR      r0,[r4,#8]            ;2545
000052  68e0              LDR      r0,[r4,#0xc]          ;2548
000054  f1000804          ADD      r8,r0,#4              ;2548
000058  6928              LDR      r0,[r5,#0x10]         ;2549
00005a  4428              ADD      r0,r0,r5              ;2549
00005c  4540              CMP      r0,r8                 ;2549
00005e  d014              BEQ      |L12.138|
000060  bf00              NOP                            ;2551
000062  bf00              NOP                            ;2551
000064  f8d80008          LDR      r0,[r8,#8]            ;2553
000068  b968              CBNZ     r0,|L12.134|
00006a  bf00              NOP                            ;2555
00006c  bf00              NOP                            ;2555
00006e  4641              MOV      r1,r8                 ;2557
000070  4648              MOV      r0,r9                 ;2557
000072  f7fffffe          BL       _RMP_Mem_Del
000076  f8d8000c          LDR      r0,[r8,#0xc]          ;2558
00007a  1d00              ADDS     r0,r0,#4              ;2558
00007c  1b01              SUBS     r1,r0,r4              ;2558
00007e  4620              MOV      r0,r4                 ;2558
000080  f7fffffe          BL       _RMP_Mem_Block
000084  e003              B        |L12.142|
                  |L12.134|
000086  bf00              NOP                            ;2562
000088  e001              B        |L12.142|
                  |L12.138|
00008a  bf00              NOP                            ;2565
00008c  bf00              NOP                            ;2565
                  |L12.142|
00008e  f04f0a00          MOV      r10,#0                ;2568
000092  68e8              LDR      r0,[r5,#0xc]          ;2569
000094  42a0              CMP      r0,r4                 ;2569
000096  d016              BEQ      |L12.198|
000098  bf00              NOP                            ;2571
00009a  bf00              NOP                            ;2571
00009c  f8547c04          LDR      r7,[r4,#-4]           ;2572
0000a0  68b8              LDR      r0,[r7,#8]            ;2575
0000a2  b970              CBNZ     r0,|L12.194|
0000a4  bf00              NOP                            ;2577
0000a6  bf00              NOP                            ;2577
0000a8  4639              MOV      r1,r7                 ;2579
0000aa  4648              MOV      r0,r9                 ;2579
0000ac  f7fffffe          BL       _RMP_Mem_Del
0000b0  68e0              LDR      r0,[r4,#0xc]          ;2580
0000b2  1d00              ADDS     r0,r0,#4              ;2580
0000b4  1bc1              SUBS     r1,r0,r7              ;2580
0000b6  4638              MOV      r0,r7                 ;2580
0000b8  f7fffffe          BL       _RMP_Mem_Block
0000bc  f04f0a01          MOV      r10,#1                ;2585
0000c0  e003              B        |L12.202|
                  |L12.194|
0000c2  bf00              NOP                            ;2588
0000c4  e001              B        |L12.202|
                  |L12.198|
0000c6  bf00              NOP                            ;2591
0000c8  bf00              NOP                            ;2591
                  |L12.202|
0000ca  f1ba0f00          CMP      r10,#0                ;2595
0000ce  d106              BNE      |L12.222|
0000d0  bf00              NOP                            ;2597
0000d2  bf00              NOP                            ;2597
0000d4  4621              MOV      r1,r4                 ;2598
0000d6  4648              MOV      r0,r9                 ;2598
0000d8  f7fffffe          BL       _RMP_Mem_Ins
0000dc  e005              B        |L12.234|
                  |L12.222|
0000de  bf00              NOP                            ;2602
0000e0  bf00              NOP                            ;2602
0000e2  4639              MOV      r1,r7                 ;2603
0000e4  4648              MOV      r0,r9                 ;2603
0000e6  f7fffffe          BL       _RMP_Mem_Ins
                  |L12.234|
0000ea  bf00              NOP      
0000ec  e792              B        |L12.20|
;;;2606   /* End Function:RMP_Free *****************************************************/
                          ENDP


                          AREA ||i.RMP_Init||, CODE, READONLY, ALIGN=1

                  RMP_Init PROC
;;;1971   ******************************************************************************/
;;;1972   void RMP_Init(void)
000000  f7fffffe          BL       RMP_Lock_Sched
;;;1973   {
;;;1974       RMP_Lock_Sched();
;;;1975       
;;;1976       /* Platform will use this hook to do something */
;;;1977       _RMP_Plat_Hook();
000004  f7fffffe          BL       _RMP_Plat_Hook
;;;1978       /* Start the second thread here */
;;;1979       RMP_Init_Hook();
000008  f7fffffe          BL       RMP_Init_Hook
;;;1980       
;;;1981       RMP_Unlock_Sched();
00000c  f7fffffe          BL       RMP_Unlock_Sched
;;;1982       
;;;1983       while(1)
000010  e001              B        |L13.22|
                  |L13.18|
;;;1984           RMP_Init_Idle();
000012  f7fffffe          BL       RMP_Init_Idle
                  |L13.22|
000016  e7fc              B        |L13.18|
;;;1985   }
;;;1986   /* End Function:RMP_Init *****************************************************/
                          ENDP


                          AREA ||i.RMP_LSB_Get||, CODE, READONLY, ALIGN=1

                  RMP_LSB_Get PROC
;;;2119   ******************************************************************************/
;;;2120   rmp_ptr_t RMP_LSB_Get(rmp_ptr_t Val)
000000  b570              PUSH     {r4-r6,lr}
;;;2121   {
000002  4604              MOV      r4,r0
;;;2122       return RMP_WORD_SIZE-1-RMP_MSB_Get(RMP_RBIT_Get(Val));
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       RMP_RBIT_Get
00000a  4605              MOV      r5,r0
00000c  f7fffffe          BL       RMP_MSB_Get
000010  f1c0001f          RSB      r0,r0,#0x1f
;;;2123   }
000014  bd70              POP      {r4-r6,pc}
;;;2124   /* End Function:RMP_LSB_Get **************************************************/
                          ENDP


                          AREA ||i.RMP_Line||, CODE, READONLY, ALIGN=1

                  RMP_Line PROC
;;;2618   #ifdef RMP_POINT
;;;2619   void RMP_Line(rmp_cnt_t Start_X, rmp_cnt_t Start_Y, rmp_cnt_t End_X, rmp_cnt_t End_Y, rmp_ptr_t Color)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;2620   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;2621       rmp_cnt_t Trav_X;
;;;2622       rmp_cnt_t Trav_Y;
;;;2623       rmp_cnt_t Dir_X;
;;;2624       rmp_cnt_t Dir_Y;
;;;2625       rmp_cnt_t Error;
;;;2626       rmp_cnt_t Cur_X;
;;;2627       rmp_cnt_t Cur_Y;
;;;2628       
;;;2629       /* See if this line is horizontal or vertical. If so we speed it up */
;;;2630       if(Start_X==End_X)
00000c  42b4              CMP      r4,r6
00000e  d114              BNE      |L15.58|
;;;2631       {
;;;2632           /* Vertical */
;;;2633           if(Start_Y>End_Y)
000010  42bd              CMP      r5,r7
000012  dd02              BLE      |L15.26|
;;;2634           {
;;;2635               Dir_Y=End_Y;
000014  46bb              MOV      r11,r7
;;;2636               Trav_Y=Start_Y;
000016  9501              STR      r5,[sp,#4]
000018  e001              B        |L15.30|
                  |L15.26|
;;;2637           }
;;;2638           else
;;;2639           {
;;;2640               Dir_Y=Start_Y;
00001a  46ab              MOV      r11,r5
;;;2641               Trav_Y=End_Y;
00001c  9701              STR      r7,[sp,#4]
                  |L15.30|
;;;2642           }
;;;2643           
;;;2644           for(Cur_Y=Dir_Y;Cur_Y<=Trav_Y;Cur_Y++)
00001e  46d9              MOV      r9,r11
000020  e006              B        |L15.48|
                  |L15.34|
;;;2645               RMP_POINT(Start_X,Cur_Y,Color);
000022  4649              MOV      r1,r9
000024  4620              MOV      r0,r4
000026  9a0c              LDR      r2,[sp,#0x30]
000028  f7fffffe          BL       RMP_Point
00002c  f1090901          ADD      r9,r9,#1              ;2644
                  |L15.48|
000030  9801              LDR      r0,[sp,#4]            ;2644
000032  4581              CMP      r9,r0                 ;2644
000034  ddf5              BLE      |L15.34|
                  |L15.54|
;;;2646           return;
;;;2647       }
;;;2648       else if(Start_Y==End_Y)
;;;2649       {
;;;2650           /* Horizontal */
;;;2651           if(Start_X>End_X)
;;;2652           {
;;;2653               Dir_X=End_X;
;;;2654               Trav_X=Start_X;
;;;2655           }
;;;2656           else
;;;2657           {
;;;2658               Dir_X=Start_X;
;;;2659               Trav_X=End_X;
;;;2660           }
;;;2661           
;;;2662           for(Cur_X=Dir_X;Cur_X<=Trav_X;Cur_X++)
;;;2663               RMP_POINT(Cur_X,Start_Y,Color);
;;;2664           return;
;;;2665       }
;;;2666   
;;;2667       Error=0;
;;;2668       /* Get their absolute value, and then draw the line */
;;;2669       Trav_X=(Start_X>End_X)?(Start_X-End_X):(End_X-Start_X);
;;;2670       Trav_Y=(Start_Y>End_Y)?(Start_Y-End_Y):(End_Y-Start_Y);
;;;2671   
;;;2672       /* Decide the increment direction */
;;;2673       if(End_X-Start_X>0)
;;;2674           Dir_X=1;
;;;2675       else
;;;2676           Dir_X=-1;
;;;2677   
;;;2678       if(End_Y-Start_Y>0)
;;;2679           Dir_Y=1;
;;;2680       else
;;;2681           Dir_Y=-1;
;;;2682   
;;;2683       if(Trav_X>Trav_Y)
;;;2684       {
;;;2685           Cur_Y=Start_Y;
;;;2686           for(Cur_X=Start_X;Cur_X!=End_X+Dir_X;Cur_X+=Dir_X)
;;;2687           {
;;;2688               RMP_POINT(Cur_X,Cur_Y,Color);
;;;2689               Error+=Trav_Y;
;;;2690               if((Error<<1)>=Trav_X)
;;;2691               {
;;;2692                   Cur_Y+=Dir_Y;
;;;2693                   Error-=Trav_X;
;;;2694               }
;;;2695           }
;;;2696       }
;;;2697       else
;;;2698       {
;;;2699           Cur_X=Start_X;
;;;2700           for(Cur_Y=Start_Y;Cur_Y!=End_Y+Dir_Y;Cur_Y+=Dir_Y)
;;;2701           {
;;;2702               RMP_POINT(Cur_X,Cur_Y,Color);
;;;2703               Error+=Trav_X;
;;;2704               if((Error<<1)>=Trav_Y)
;;;2705               {
;;;2706                   Cur_X+=Dir_X;
;;;2707                   Error-=Trav_Y;
;;;2708               }
;;;2709           }
;;;2710       }
;;;2711   }
000036  e8bd8ffe          POP      {r1-r11,pc}
                  |L15.58|
00003a  42bd              CMP      r5,r7                 ;2648
00003c  d113              BNE      |L15.102|
00003e  42b4              CMP      r4,r6                 ;2651
000040  dd02              BLE      |L15.72|
000042  46b2              MOV      r10,r6                ;2653
000044  9402              STR      r4,[sp,#8]            ;2654
000046  e001              B        |L15.76|
                  |L15.72|
000048  46a2              MOV      r10,r4                ;2658
00004a  9602              STR      r6,[sp,#8]            ;2659
                  |L15.76|
00004c  46d0              MOV      r8,r10                ;2662
00004e  e006              B        |L15.94|
                  |L15.80|
000050  4629              MOV      r1,r5                 ;2663
000052  4640              MOV      r0,r8                 ;2663
000054  9a0c              LDR      r2,[sp,#0x30]         ;2663
000056  f7fffffe          BL       RMP_Point
00005a  f1080801          ADD      r8,r8,#1              ;2662
                  |L15.94|
00005e  9802              LDR      r0,[sp,#8]            ;2662
000060  4580              CMP      r8,r0                 ;2662
000062  ddf5              BLE      |L15.80|
000064  e7e7              B        |L15.54|
                  |L15.102|
000066  2000              MOVS     r0,#0                 ;2667
000068  9000              STR      r0,[sp,#0]            ;2667
00006a  42b4              CMP      r4,r6                 ;2669
00006c  dd01              BLE      |L15.114|
00006e  1ba0              SUBS     r0,r4,r6              ;2669
000070  e000              B        |L15.116|
                  |L15.114|
000072  1b30              SUBS     r0,r6,r4              ;2669
                  |L15.116|
000074  9002              STR      r0,[sp,#8]            ;2669
000076  42bd              CMP      r5,r7                 ;2670
000078  dd01              BLE      |L15.126|
00007a  1be8              SUBS     r0,r5,r7              ;2670
00007c  e000              B        |L15.128|
                  |L15.126|
00007e  1b78              SUBS     r0,r7,r5              ;2670
                  |L15.128|
000080  9001              STR      r0,[sp,#4]            ;2670
000082  1b30              SUBS     r0,r6,r4              ;2673
000084  2800              CMP      r0,#0                 ;2673
000086  dd02              BLE      |L15.142|
000088  f04f0a01          MOV      r10,#1                ;2674
00008c  e001              B        |L15.146|
                  |L15.142|
00008e  f04f3aff          MOV      r10,#0xffffffff       ;2676
                  |L15.146|
000092  1b78              SUBS     r0,r7,r5              ;2678
000094  2800              CMP      r0,#0                 ;2678
000096  dd02              BLE      |L15.158|
000098  f04f0b01          MOV      r11,#1                ;2679
00009c  e001              B        |L15.162|
                  |L15.158|
00009e  f04f3bff          MOV      r11,#0xffffffff       ;2681
                  |L15.162|
0000a2  e9dd1001          LDRD     r1,r0,[sp,#4]         ;2683
0000a6  4288              CMP      r0,r1                 ;2683
0000a8  dd1b              BLE      |L15.226|
0000aa  46a9              MOV      r9,r5                 ;2685
0000ac  46a0              MOV      r8,r4                 ;2686
0000ae  e013              B        |L15.216|
                  |L15.176|
0000b0  4649              MOV      r1,r9                 ;2688
0000b2  4640              MOV      r0,r8                 ;2688
0000b4  9a0c              LDR      r2,[sp,#0x30]         ;2688
0000b6  f7fffffe          BL       RMP_Point
0000ba  e9dd0100          LDRD     r0,r1,[sp,#0]         ;2689
0000be  4408              ADD      r0,r0,r1              ;2689
0000c0  9000              STR      r0,[sp,#0]            ;2689
0000c2  9900              LDR      r1,[sp,#0]            ;2690
0000c4  9802              LDR      r0,[sp,#8]            ;2690
0000c6  ebb00f41          CMP      r0,r1,LSL #1          ;2690
0000ca  dc04              BGT      |L15.214|
0000cc  44d9              ADD      r9,r9,r11             ;2692
0000ce  9902              LDR      r1,[sp,#8]            ;2693
0000d0  9800              LDR      r0,[sp,#0]            ;2693
0000d2  1a40              SUBS     r0,r0,r1              ;2693
0000d4  9000              STR      r0,[sp,#0]            ;2693
                  |L15.214|
0000d6  44d0              ADD      r8,r8,r10             ;2686
                  |L15.216|
0000d8  eb06000a          ADD      r0,r6,r10             ;2686
0000dc  4540              CMP      r0,r8                 ;2686
0000de  d1e7              BNE      |L15.176|
0000e0  e01a              B        |L15.280|
                  |L15.226|
0000e2  46a0              MOV      r8,r4                 ;2699
0000e4  46a9              MOV      r9,r5                 ;2700
0000e6  e013              B        |L15.272|
                  |L15.232|
0000e8  4649              MOV      r1,r9                 ;2702
0000ea  4640              MOV      r0,r8                 ;2702
0000ec  9a0c              LDR      r2,[sp,#0x30]         ;2702
0000ee  f7fffffe          BL       RMP_Point
0000f2  9902              LDR      r1,[sp,#8]            ;2703
0000f4  9800              LDR      r0,[sp,#0]            ;2703
0000f6  4408              ADD      r0,r0,r1              ;2703
0000f8  9000              STR      r0,[sp,#0]            ;2703
0000fa  e9dd1000          LDRD     r1,r0,[sp,#0]         ;2704
0000fe  ebb00f41          CMP      r0,r1,LSL #1          ;2704
000102  dc04              BGT      |L15.270|
000104  44d0              ADD      r8,r8,r10             ;2706
000106  e9dd0100          LDRD     r0,r1,[sp,#0]         ;2707
00010a  1a40              SUBS     r0,r0,r1              ;2707
00010c  9000              STR      r0,[sp,#0]            ;2707
                  |L15.270|
00010e  44d9              ADD      r9,r9,r11             ;2700
                  |L15.272|
000110  eb07000b          ADD      r0,r7,r11             ;2700
000114  4548              CMP      r0,r9                 ;2700
000116  d1e7              BNE      |L15.232|
                  |L15.280|
000118  bf00              NOP      
00011a  e78c              B        |L15.54|
;;;2712   /* End Function:RMP_Line *****************************************************/
                          ENDP


                          AREA ||i.RMP_Lineedit||, CODE, READONLY, ALIGN=1

                  RMP_Lineedit PROC
;;;3543   ******************************************************************************/
;;;3544   void RMP_Lineedit(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;3545   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;3546       RMP_Rectangle(Coord_X,Coord_Y,Length,Width,RMP_CTL_WHITE,RMP_CTL_WHITE);
00000c  f64f70ff          MOV      r0,#0xffff
000010  9000              STR      r0,[sp,#0]
000012  463b              MOV      r3,r7
000014  4632              MOV      r2,r6
000016  4629              MOV      r1,r5
000018  9001              STR      r0,[sp,#4]
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       RMP_Rectangle
;;;3547       
;;;3548       /* Now draw the border */
;;;3549       RMP_Line(Coord_X,Coord_Y,Coord_X+Length-1,Coord_Y,RMP_CTL_DARK);
000020  f64730ef          MOV      r0,#0x7bef
000024  9000              STR      r0,[sp,#0]
000026  19a0              ADDS     r0,r4,r6
000028  1e42              SUBS     r2,r0,#1
00002a  462b              MOV      r3,r5
00002c  4629              MOV      r1,r5
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       RMP_Line
;;;3550       RMP_Line(Coord_X+Length-1,Coord_Y,Coord_X+Length-1,Coord_Y+Width-1,RMP_CTL_WHITE);
000034  f64f70ff          MOV      r0,#0xffff
000038  19e9              ADDS     r1,r5,r7
00003a  1e4b              SUBS     r3,r1,#1
00003c  19a1              ADDS     r1,r4,r6
00003e  1e4a              SUBS     r2,r1,#1
000040  19a1              ADDS     r1,r4,r6
000042  9000              STR      r0,[sp,#0]
000044  1e48              SUBS     r0,r1,#1
000046  4629              MOV      r1,r5
000048  f7fffffe          BL       RMP_Line
;;;3551       RMP_Line(Coord_X+Length-1,Coord_Y+Width-1,Coord_X,Coord_Y+Width-1,RMP_CTL_WHITE);
00004c  f64f70ff          MOV      r0,#0xffff
000050  19ea              ADDS     r2,r5,r7
000052  1e53              SUBS     r3,r2,#1
000054  19ea              ADDS     r2,r5,r7
000056  1e51              SUBS     r1,r2,#1
000058  19a2              ADDS     r2,r4,r6
00005a  9000              STR      r0,[sp,#0]
00005c  1e50              SUBS     r0,r2,#1
00005e  4622              MOV      r2,r4
000060  f7fffffe          BL       RMP_Line
;;;3552       RMP_Line(Coord_X,Coord_Y+Width-1,Coord_X,Coord_Y,RMP_CTL_DARK);
000064  f64730ef          MOV      r0,#0x7bef
000068  9000              STR      r0,[sp,#0]
00006a  19e8              ADDS     r0,r5,r7
00006c  1e41              SUBS     r1,r0,#1
00006e  462b              MOV      r3,r5
000070  4622              MOV      r2,r4
000072  4620              MOV      r0,r4
000074  f7fffffe          BL       RMP_Line
;;;3553       /* The shadow */
;;;3554       RMP_Line(Coord_X+1,Coord_Y+Width-2,Coord_X+1,Coord_Y+1,RMP_CTL_BLACK);    
000078  2000              MOVS     r0,#0
00007a  9000              STR      r0,[sp,#0]
00007c  19e8              ADDS     r0,r5,r7
00007e  1e81              SUBS     r1,r0,#2
000080  1c6b              ADDS     r3,r5,#1
000082  1c62              ADDS     r2,r4,#1
000084  1c60              ADDS     r0,r4,#1
000086  f7fffffe          BL       RMP_Line
;;;3555       RMP_Line(Coord_X+1,Coord_Y+1,Coord_X+Length-2,Coord_Y+1,RMP_CTL_BLACK);
00008a  2000              MOVS     r0,#0
00008c  9000              STR      r0,[sp,#0]
00008e  19a0              ADDS     r0,r4,r6
000090  1e82              SUBS     r2,r0,#2
000092  1c6b              ADDS     r3,r5,#1
000094  1c69              ADDS     r1,r5,#1
000096  1c60              ADDS     r0,r4,#1
000098  f7fffffe          BL       RMP_Line
;;;3556   }
00009c  e8bd81fc          POP      {r2-r8,pc}
;;;3557   /* End Function:RMP_Lineedit *************************************************/
                          ENDP


                          AREA ||i.RMP_Lineedit_Clr||, CODE, READONLY, ALIGN=1

                  RMP_Lineedit_Clr PROC
;;;3527   ******************************************************************************/
;;;3528   void RMP_Lineedit_Clr(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length,
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;3529                         rmp_cnt_t Width, rmp_cnt_t Clr_X, rmp_cnt_t Clr_Len)
;;;3530   {
000004  4680              MOV      r8,r0
000006  460c              MOV      r4,r1
000008  4691              MOV      r9,r2
00000a  461d              MOV      r5,r3
00000c  e9dd670a          LDRD     r6,r7,[sp,#0x28]
;;;3531       RMP_Rectangle(Clr_X,Coord_Y+1,Clr_Len,Width-2,RMP_CTL_WHITE,RMP_CTL_WHITE);
000010  f64f70ff          MOV      r0,#0xffff
000014  9000              STR      r0,[sp,#0]
000016  1eab              SUBS     r3,r5,#2
000018  463a              MOV      r2,r7
00001a  1c61              ADDS     r1,r4,#1
00001c  9001              STR      r0,[sp,#4]
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       RMP_Rectangle
;;;3532   }
000024  e8bd87fc          POP      {r2-r10,pc}
;;;3533   /* End Function:RMP_Lineedit_Clr *********************************************/
                          ENDP


                          AREA ||i.RMP_List_Crt||, CODE, READONLY, ALIGN=1

                  RMP_List_Crt PROC
;;;231    ******************************************************************************/
;;;232    void RMP_List_Crt(volatile struct RMP_List* Head)
000000  6000              STR      r0,[r0,#0]
;;;233    {
;;;234        Head->Prev=(struct RMP_List*)Head;
;;;235        Head->Next=(struct RMP_List*)Head;
000002  6040              STR      r0,[r0,#4]
;;;236    }
000004  4770              BX       lr
;;;237    /* End Function:RMP_List_Crt *************************************************/
                          ENDP


                          AREA ||i.RMP_List_Del||, CODE, READONLY, ALIGN=1

                  RMP_List_Del PROC
;;;245    ******************************************************************************/
;;;246    void RMP_List_Del(volatile struct RMP_List* Prev,volatile struct RMP_List* Next)
000000  6008              STR      r0,[r1,#0]
;;;247    {
;;;248        Next->Prev=(struct RMP_List*)Prev;
;;;249        Prev->Next=(struct RMP_List*)Next;
000002  6041              STR      r1,[r0,#4]
;;;250    }
000004  4770              BX       lr
;;;251    /* End Function:RMP_List_Del *************************************************/
                          ENDP


                          AREA ||i.RMP_List_Ins||, CODE, READONLY, ALIGN=1

                  RMP_List_Ins PROC
;;;260    ******************************************************************************/
;;;261    void RMP_List_Ins(volatile struct RMP_List* New,
000000  6010              STR      r0,[r2,#0]
;;;262                      volatile struct RMP_List* Prev,
;;;263                      volatile struct RMP_List* Next)
;;;264    {
;;;265        Next->Prev=(struct RMP_List*)New;
;;;266        New->Next=(struct RMP_List*)Next;
000002  6042              STR      r2,[r0,#4]
;;;267        New->Prev=(struct RMP_List*)Prev;
000004  6001              STR      r1,[r0,#0]
;;;268        Prev->Next=(struct RMP_List*)New;
000006  6048              STR      r0,[r1,#4]
;;;269    }
000008  4770              BX       lr
;;;270    /* End Function:RMP_List_Ins *************************************************/
                          ENDP


                          AREA ||i.RMP_Load_Ctx||, CODE, READONLY, ALIGN=1

                  RMP_Load_Ctx PROC
;;;1956   #if(RMP_USE_HOOKS==RMP_FALSE)
;;;1957   void RMP_Load_Ctx(void)
000000  4770              BX       lr
;;;1958   {
;;;1959       return;
;;;1960   }
;;;1961   #endif
                          ENDP


                          AREA ||i.RMP_Lock_Sched||, CODE, READONLY, ALIGN=2

                  RMP_Lock_Sched PROC
;;;361    ******************************************************************************/
;;;362    void RMP_Lock_Sched(void)
000000  b510              PUSH     {r4,lr}
;;;363    {
;;;364        RMP_MASK_INT();
000002  20ff              MOVS     r0,#0xff
000004  f7fffffe          BL       RMP_Mask_Int
;;;365        RMP_Sched_Locked=1;
000008  2001              MOVS     r0,#1
00000a  4904              LDR      r1,|L22.28|
00000c  6008              STR      r0,[r1,#0]  ; RMP_Sched_Locked
;;;366        RMP_Sched_Lock_Cnt++;
00000e  4804              LDR      r0,|L22.32|
000010  6800              LDR      r0,[r0,#0]  ; RMP_Sched_Lock_Cnt
000012  1c40              ADDS     r0,r0,#1
000014  4902              LDR      r1,|L22.32|
000016  6008              STR      r0,[r1,#0]  ; RMP_Sched_Lock_Cnt
;;;367    }
000018  bd10              POP      {r4,pc}
;;;368    /* End Function:RMP_Lock_Sched ***********************************************/
                          ENDP

00001a  0000              DCW      0x0000
                  |L22.28|
                          DCD      RMP_Sched_Locked
                  |L22.32|
                          DCD      RMP_Sched_Lock_Cnt

                          AREA ||i.RMP_Malloc||, CODE, READONLY, ALIGN=1

                  RMP_Malloc PROC
;;;2431   ******************************************************************************/
;;;2432   void* RMP_Malloc(volatile void* Pool, rmp_ptr_t Size)                                                       
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;2433   {    
000004  4606              MOV      r6,r0
000006  4688              MOV      r8,r1
;;;2434       rmp_cnt_t FLI_Level;
;;;2435       rmp_cnt_t SLI_Level;
;;;2436       volatile struct RMP_Mem* Mem;
;;;2437       rmp_ptr_t Old_Size;
;;;2438       volatile struct RMP_Mem_Head* Mem_Head;
;;;2439       rmp_ptr_t Rounded_Size;
;;;2440       volatile struct RMP_Mem_Head* New_Mem;
;;;2441       rmp_ptr_t New_Size;
;;;2442       
;;;2443       if((Pool==0)||(Size==0))
000008  b116              CBZ      r6,|L23.16|
00000a  f1b80f00          CMP      r8,#0
00000e  d104              BNE      |L23.26|
                  |L23.16|
;;;2444       {
;;;2445           RMP_COVERAGE_MARKER();
000010  bf00              NOP      
000012  bf00              NOP      
;;;2446           return (void*)(0);
000014  2000              MOVS     r0,#0
                  |L23.22|
;;;2447       }
;;;2448       else
;;;2449           RMP_COVERAGE_MARKER();
;;;2450       
;;;2451       /* Round up the size:a multiple of 8 and bigger than 64B */
;;;2452       Rounded_Size=(((Size-1)>>3)+1)<<3;
;;;2453       /* See if it is smaller than the smallest block */
;;;2454       Rounded_Size=(Rounded_Size>64)?Rounded_Size:64;
;;;2455   
;;;2456       /* See if such block exists, if not, abort */
;;;2457       if(_RMP_Mem_Search(Pool,Rounded_Size,&FLI_Level,&SLI_Level)!=0)
;;;2458       {
;;;2459           RMP_COVERAGE_MARKER();
;;;2460           return (void*)(0);
;;;2461       }
;;;2462       else
;;;2463           RMP_COVERAGE_MARKER();
;;;2464       
;;;2465       Mem=(volatile struct RMP_Mem*)Pool;
;;;2466       
;;;2467       /* There is such block. Get it and delete it from the TLSF list. */
;;;2468       Mem_Head=(struct RMP_Mem_Head*)(Mem->Table[RMP_MEM_POS(FLI_Level,SLI_Level)].Next);
;;;2469       _RMP_Mem_Del(Pool, Mem_Head);
;;;2470   
;;;2471       /* Allocate and calculate if the space left could be big enough to be a new 
;;;2472        * block. If so, we will put the block back into the TLSF table */
;;;2473       New_Size=((rmp_ptr_t)(Mem_Head->Tail))-((rmp_ptr_t)Mem_Head)-sizeof(struct RMP_Mem_Head)-Rounded_Size;
;;;2474       if(New_Size>=(sizeof(struct RMP_Mem_Head)+64+sizeof(struct RMP_Mem_Tail)))
;;;2475       {
;;;2476           RMP_COVERAGE_MARKER();
;;;2477           Old_Size=sizeof(struct RMP_Mem_Head)+Rounded_Size+sizeof(struct RMP_Mem_Tail);
;;;2478           New_Mem=(volatile struct RMP_Mem_Head*)(((rmp_ptr_t)Mem_Head)+Old_Size);
;;;2479   
;;;2480           _RMP_Mem_Block(Mem_Head, Old_Size);
;;;2481           _RMP_Mem_Block(New_Mem, New_Size);
;;;2482   
;;;2483           /* Put the extra block back */
;;;2484           _RMP_Mem_Ins(Pool, New_Mem);
;;;2485       }
;;;2486       else
;;;2487           RMP_COVERAGE_MARKER();
;;;2488   
;;;2489       /* Insert the allocated block into the lists */
;;;2490       RMP_List_Ins(&(Mem_Head->Head),&(Mem->Alloc),Mem->Alloc.Next);
;;;2491       Mem_Head->State=RMP_MEM_USED;
;;;2492   
;;;2493       /* Finally, return the start address */
;;;2494       return (void*)(((rmp_ptr_t)Mem_Head)+sizeof(struct RMP_Mem_Head));
;;;2495   }
000016  e8bd9ffc          POP      {r2-r12,pc}
                  |L23.26|
00001a  bf00              NOP                            ;2449
00001c  bf00              NOP                            ;2449
00001e  f1a80001          SUB      r0,r8,#1              ;2452
000022  2101              MOVS     r1,#1                 ;2452
000024  eb0100d0          ADD      r0,r1,r0,LSR #3       ;2452
000028  00c5              LSLS     r5,r0,#3              ;2452
00002a  2d40              CMP      r5,#0x40              ;2454
00002c  d901              BLS      |L23.50|
00002e  4628              MOV      r0,r5                 ;2454
000030  e000              B        |L23.52|
                  |L23.50|
000032  2040              MOVS     r0,#0x40              ;2454
                  |L23.52|
000034  4605              MOV      r5,r0                 ;2454
000036  466b              MOV      r3,sp                 ;2457
000038  aa01              ADD      r2,sp,#4              ;2457
00003a  4629              MOV      r1,r5                 ;2457
00003c  4630              MOV      r0,r6                 ;2457
00003e  f7fffffe          BL       _RMP_Mem_Search
000042  b118              CBZ      r0,|L23.76|
000044  bf00              NOP                            ;2459
000046  bf00              NOP                            ;2459
000048  2000              MOVS     r0,#0                 ;2460
00004a  e7e4              B        |L23.22|
                  |L23.76|
00004c  bf00              NOP                            ;2463
00004e  bf00              NOP                            ;2463
000050  4637              MOV      r7,r6                 ;2465
000052  e9dd0100          LDRD     r0,r1,[sp,#0]         ;2468
000056  eb0001c1          ADD      r1,r0,r1,LSL #3       ;2468
00005a  f1070028          ADD      r0,r7,#0x28           ;2468
00005e  eb0000c1          ADD      r0,r0,r1,LSL #3       ;2468
000062  6844              LDR      r4,[r0,#4]            ;2468
000064  4621              MOV      r1,r4                 ;2469
000066  4630              MOV      r0,r6                 ;2469
000068  f7fffffe          BL       _RMP_Mem_Del
00006c  68e0              LDR      r0,[r4,#0xc]          ;2473
00006e  1b00              SUBS     r0,r0,r4              ;2473
000070  3810              SUBS     r0,r0,#0x10           ;2473
000072  eba00b05          SUB      r11,r0,r5             ;2473
000076  f1bb0f54          CMP      r11,#0x54             ;2474
00007a  d312              BCC      |L23.162|
00007c  bf00              NOP                            ;2476
00007e  bf00              NOP                            ;2476
000080  f1050914          ADD      r9,r5,#0x14           ;2477
000084  eb040a09          ADD      r10,r4,r9             ;2478
000088  4649              MOV      r1,r9                 ;2480
00008a  4620              MOV      r0,r4                 ;2480
00008c  f7fffffe          BL       _RMP_Mem_Block
000090  4659              MOV      r1,r11                ;2481
000092  4650              MOV      r0,r10                ;2481
000094  f7fffffe          BL       _RMP_Mem_Block
000098  4651              MOV      r1,r10                ;2484
00009a  4630              MOV      r0,r6                 ;2484
00009c  f7fffffe          BL       _RMP_Mem_Ins
0000a0  e001              B        |L23.166|
                  |L23.162|
0000a2  bf00              NOP                            ;2487
0000a4  bf00              NOP                            ;2487
                  |L23.166|
0000a6  687a              LDR      r2,[r7,#4]            ;2490
0000a8  4639              MOV      r1,r7                 ;2490
0000aa  4620              MOV      r0,r4                 ;2490
0000ac  f7fffffe          BL       RMP_List_Ins
0000b0  2001              MOVS     r0,#1                 ;2491
0000b2  60a0              STR      r0,[r4,#8]            ;2491
0000b4  f1040010          ADD      r0,r4,#0x10           ;2494
0000b8  e7ad              B        |L23.22|
;;;2496   /* End Function:RMP_Malloc ***************************************************/
                          ENDP


                          AREA ||i.RMP_Matrix||, CODE, READONLY, ALIGN=1

                  RMP_Matrix PROC
;;;2996   ******************************************************************************/
;;;2997   void RMP_Matrix(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, const rmp_u8_t* Matrix,
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;2998                   rmp_cnt_t Bit_Order, rmp_cnt_t Length, rmp_cnt_t Width, rmp_ptr_t Color)
;;;2999   {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4691              MOV      r9,r2
00000a  e9ddab0e          LDRD     r10,r11,[sp,#0x38]
;;;3000       rmp_cnt_t Len_Cnt;
;;;3001       rmp_cnt_t Wid_Cnt;
;;;3002       rmp_cnt_t Mat_Pos;
;;;3003       
;;;3004       if((Matrix==0)||((Length&0x07)!=0)||(Length==0)||(Width==0))
00000e  f1b90f00          CMP      r9,#0
000012  d008              BEQ      |L24.38|
000014  f00a0007          AND      r0,r10,#7
000018  b928              CBNZ     r0,|L24.38|
00001a  f1ba0f00          CMP      r10,#0
00001e  d002              BEQ      |L24.38|
000020  f1bb0f00          CMP      r11,#0
000024  d101              BNE      |L24.42|
                  |L24.38|
;;;3005           return;
;;;3006       
;;;3007       Mat_Pos=0;
;;;3008       /* Natural order */
;;;3009       if(Bit_Order==RMP_MAT_BIG)
;;;3010       {
;;;3011           for(Wid_Cnt=Coord_Y;Wid_Cnt<Width+Coord_Y;Wid_Cnt++)
;;;3012           {
;;;3013               for(Len_Cnt=Coord_X;Len_Cnt<Length+Coord_X;Len_Cnt++)
;;;3014               {
;;;3015                   if(RMP_MAT_BPOS(Matrix,Mat_Pos)!=0)
;;;3016                       RMP_Point(Len_Cnt,Wid_Cnt,Color);
;;;3017                   Mat_Pos++;
;;;3018               }
;;;3019           }
;;;3020       }
;;;3021       /* Small order */
;;;3022       else
;;;3023       {
;;;3024           for(Wid_Cnt=Coord_Y;Wid_Cnt<Width+Coord_Y;Wid_Cnt++)
;;;3025           {
;;;3026               for(Len_Cnt=Coord_X;Len_Cnt<Length+Coord_X;Len_Cnt++)
;;;3027               {
;;;3028                   if(RMP_MAT_SPOS(Matrix,Mat_Pos)!=0)
;;;3029                       RMP_Point(Len_Cnt,Wid_Cnt,Color);
;;;3030                   Mat_Pos++;
;;;3031               }
;;;3032           }
;;;3033       }
;;;3034   }
000026  e8bd9fff          POP      {r0-r12,pc}
                  |L24.42|
00002a  2500              MOVS     r5,#0                 ;3007
00002c  9803              LDR      r0,[sp,#0xc]          ;3009
00002e  2801              CMP      r0,#1                 ;3009
000030  d120              BNE      |L24.116|
000032  463c              MOV      r4,r7                 ;3011
000034  e019              B        |L24.106|
                  |L24.54|
000036  46b0              MOV      r8,r6                 ;3013
000038  e012              B        |L24.96|
                  |L24.58|
00003a  eb0900e5          ADD      r0,r9,r5,ASR #3       ;3015
00003e  7800              LDRB     r0,[r0,#0]            ;3015
000040  f0050107          AND      r1,r5,#7              ;3015
000044  f1c10207          RSB      r2,r1,#7              ;3015
000048  2101              MOVS     r1,#1                 ;3015
00004a  4091              LSLS     r1,r1,r2              ;3015
00004c  4008              ANDS     r0,r0,r1              ;3015
00004e  b120              CBZ      r0,|L24.90|
000050  4621              MOV      r1,r4                 ;3016
000052  4640              MOV      r0,r8                 ;3016
000054  9a10              LDR      r2,[sp,#0x40]         ;3016
000056  f7fffffe          BL       RMP_Point
                  |L24.90|
00005a  1c6d              ADDS     r5,r5,#1              ;3017
00005c  f1080801          ADD      r8,r8,#1              ;3013
                  |L24.96|
000060  eb0a0006          ADD      r0,r10,r6             ;3013
000064  4540              CMP      r0,r8                 ;3013
000066  dce8              BGT      |L24.58|
000068  1c64              ADDS     r4,r4,#1              ;3011
                  |L24.106|
00006a  eb0b0007          ADD      r0,r11,r7             ;3011
00006e  42a0              CMP      r0,r4                 ;3011
000070  dce1              BGT      |L24.54|
000072  e01d              B        |L24.176|
                  |L24.116|
000074  463c              MOV      r4,r7                 ;3024
000076  e017              B        |L24.168|
                  |L24.120|
000078  46b0              MOV      r8,r6                 ;3026
00007a  e010              B        |L24.158|
                  |L24.124|
00007c  eb0900e5          ADD      r0,r9,r5,ASR #3       ;3028
000080  7800              LDRB     r0,[r0,#0]            ;3028
000082  f0050207          AND      r2,r5,#7              ;3028
000086  2101              MOVS     r1,#1                 ;3028
000088  4091              LSLS     r1,r1,r2              ;3028
00008a  4008              ANDS     r0,r0,r1              ;3028
00008c  b120              CBZ      r0,|L24.152|
00008e  4621              MOV      r1,r4                 ;3029
000090  4640              MOV      r0,r8                 ;3029
000092  9a10              LDR      r2,[sp,#0x40]         ;3029
000094  f7fffffe          BL       RMP_Point
                  |L24.152|
000098  1c6d              ADDS     r5,r5,#1              ;3030
00009a  f1080801          ADD      r8,r8,#1              ;3026
                  |L24.158|
00009e  eb0a0006          ADD      r0,r10,r6             ;3026
0000a2  4540              CMP      r0,r8                 ;3026
0000a4  dcea              BGT      |L24.124|
0000a6  1c64              ADDS     r4,r4,#1              ;3024
                  |L24.168|
0000a8  eb0b0007          ADD      r0,r11,r7             ;3024
0000ac  42a0              CMP      r0,r4                 ;3024
0000ae  dce3              BGT      |L24.120|
                  |L24.176|
0000b0  bf00              NOP      
0000b2  e7b8              B        |L24.38|
;;;3035   /* End Function:RMP_Matrix ***************************************************/
                          ENDP


                          AREA ||i.RMP_Matrix_AA||, CODE, READONLY, ALIGN=1

                  RMP_Matrix_AA PROC
;;;3054   #ifdef RMP_COLOR_75P
;;;3055   void RMP_Matrix_AA(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, const rmp_u8_t* Matrix,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;3056                      rmp_cnt_t Bit_Order, rmp_cnt_t Length, rmp_cnt_t Width, rmp_ptr_t Color, rmp_ptr_t Back)
;;;3057   {
000004  b085              SUB      sp,sp,#0x14
000006  4681              MOV      r9,r0
000008  4616              MOV      r6,r2
00000a  e9dd7a14          LDRD     r7,r10,[sp,#0x50]
00000e  9d12              LDR      r5,[sp,#0x48]
;;;3058       rmp_cnt_t Len_Cnt;
;;;3059       rmp_cnt_t Wid_Cnt;
;;;3060       rmp_cnt_t Mat_Pos;
;;;3061       rmp_cnt_t Anti_Alias;
;;;3062       rmp_ptr_t Color_25;
;;;3063       rmp_ptr_t Color_50;
;;;3064       rmp_ptr_t Color_75;
;;;3065       rmp_ptr_t Total;
;;;3066       
;;;3067       if((Matrix==0)||((Length&0x07)!=0)||(Length==0)||(Width==0))
000010  b12e              CBZ      r6,|L25.30|
000012  f0050007          AND      r0,r5,#7
000016  b910              CBNZ     r0,|L25.30|
000018  b10d              CBZ      r5,|L25.30|
00001a  9813              LDR      r0,[sp,#0x4c]
00001c  b910              CBNZ     r0,|L25.36|
                  |L25.30|
;;;3068           return;
;;;3069       
;;;3070       Mat_Pos=0;
;;;3071       Total=Length*Width;
;;;3072       Color_25=RMP_COLOR_25P(Color,Back);
;;;3073       Color_50=RMP_COLOR_50P(Color,Back);
;;;3074       Color_75=RMP_COLOR_75P(Color,Back);
;;;3075       
;;;3076       /* Natural order */
;;;3077       if(Bit_Order==RMP_MAT_BIG)
;;;3078       {
;;;3079           for(Wid_Cnt=Coord_Y;Wid_Cnt<Width+Coord_Y;Wid_Cnt++)
;;;3080           {
;;;3081               for(Len_Cnt=Coord_X;Len_Cnt<Length+Coord_X;Len_Cnt++)
;;;3082               {
;;;3083                   if(RMP_MAT_BPOS(Matrix,Mat_Pos)!=0)
;;;3084                       RMP_Point(Len_Cnt,Wid_Cnt,Color);
;;;3085                   else
;;;3086                   {
;;;3087                       /* Anti-aliasing */
;;;3088                       Anti_Alias=0;
;;;3089                       
;;;3090                       if(Mat_Pos-1>=0)
;;;3091                       {
;;;3092                           if((Len_Cnt!=Coord_X)&&(RMP_MAT_BPOS(Matrix,Mat_Pos-1)!=0))
;;;3093                               Anti_Alias++;
;;;3094                           if((Mat_Pos-Length>=0)&&(RMP_MAT_BPOS(Matrix,Mat_Pos-Length)!=0))
;;;3095                               Anti_Alias++;
;;;3096                       }
;;;3097                       
;;;3098                       if(Mat_Pos+1<Total)
;;;3099                       {
;;;3100                           if((Len_Cnt!=Coord_X+Length-1)&&(RMP_MAT_BPOS(Matrix,Mat_Pos+1)!=0))
;;;3101                               Anti_Alias++;
;;;3102                           if((Mat_Pos+Length<Total)&&(RMP_MAT_BPOS(Matrix,Mat_Pos+Length)!=0))
;;;3103                               Anti_Alias++;
;;;3104                       }
;;;3105                       
;;;3106                       switch(Anti_Alias)
;;;3107                       {
;;;3108                           case 1:RMP_Point(Len_Cnt,Wid_Cnt,Color_25);break;
;;;3109                           case 2:RMP_Point(Len_Cnt,Wid_Cnt,Color_50);break;
;;;3110                           case 3:RMP_Point(Len_Cnt,Wid_Cnt,Color_75);break;
;;;3111                           default:break;
;;;3112                       }
;;;3113                   }
;;;3114                   
;;;3115                   Mat_Pos++;
;;;3116               }
;;;3117           }
;;;3118       }
;;;3119       /* Small order */
;;;3120       else
;;;3121       {
;;;3122           for(Wid_Cnt=Coord_Y;Wid_Cnt<Width+Coord_Y;Wid_Cnt++)
;;;3123           {
;;;3124               for(Len_Cnt=Coord_X;Len_Cnt<Length+Coord_X;Len_Cnt++)
;;;3125               {
;;;3126                   if(RMP_MAT_SPOS(Matrix,Mat_Pos)!=0)
;;;3127                       RMP_Point(Len_Cnt,Wid_Cnt,Color);
;;;3128                   else
;;;3129                   {
;;;3130                       /* Anti-aliasing */
;;;3131                       Anti_Alias=0;
;;;3132                       
;;;3133                       if(Mat_Pos-1>=0)
;;;3134                       {
;;;3135                           if((Len_Cnt!=Coord_X)&&(RMP_MAT_SPOS(Matrix,Mat_Pos-1)!=0))
;;;3136                               Anti_Alias++;
;;;3137                           if((Mat_Pos-Length>=0)&&(RMP_MAT_SPOS(Matrix,Mat_Pos-Length)!=0))
;;;3138                               Anti_Alias++;
;;;3139                       }
;;;3140                       
;;;3141                       if(Mat_Pos+1<Total)
;;;3142                       {
;;;3143                           if((Len_Cnt!=Coord_X+Length-1)&&(RMP_MAT_SPOS(Matrix,Mat_Pos+1)!=0))
;;;3144                               Anti_Alias++;
;;;3145                           if((Mat_Pos+Length<Total)&&(RMP_MAT_SPOS(Matrix,Mat_Pos+Length)!=0))
;;;3146                               Anti_Alias++;
;;;3147                       }
;;;3148                       
;;;3149                       switch(Anti_Alias)
;;;3150                       {
;;;3151                           case 1:RMP_Point(Len_Cnt,Wid_Cnt,Color_25);break;
;;;3152                           case 2:RMP_Point(Len_Cnt,Wid_Cnt,Color_50);break;
;;;3153                           case 3:RMP_Point(Len_Cnt,Wid_Cnt,Color_75);break;
;;;3154                           default:break;
;;;3155                       }
;;;3156                   }
;;;3157                   
;;;3158                   Mat_Pos++;
;;;3159               }
;;;3160           }
;;;3161       }
;;;3162   }
00001e  b009              ADD      sp,sp,#0x24
000020  e8bd8ff0          POP      {r4-r11,pc}
                  |L25.36|
000024  2400              MOVS     r4,#0                 ;3070
000026  9913              LDR      r1,[sp,#0x4c]         ;3071
000028  fb05f001          MUL      r0,r5,r1              ;3071
00002c  9000              STR      r0,[sp,#0]            ;3071
00002e  ea4f20da          LSR      r0,r10,#11            ;3072
000032  eb000040          ADD      r0,r0,r0,LSL #1       ;3072
000036  eb0020d7          ADD      r0,r0,r7,LSR #11      ;3072
00003a  0880              LSRS     r0,r0,#2              ;3072
00003c  02c0              LSLS     r0,r0,#11             ;3072
00003e  f3ca1145          UBFX     r1,r10,#5,#6          ;3072
000042  eb010141          ADD      r1,r1,r1,LSL #1       ;3072
000046  f3c71245          UBFX     r2,r7,#5,#6           ;3072
00004a  4411              ADD      r1,r1,r2              ;3072
00004c  0889              LSRS     r1,r1,#2              ;3072
00004e  ea401041          ORR      r0,r0,r1,LSL #5       ;3072
000052  f007011f          AND      r1,r7,#0x1f           ;3072
000056  f00a021f          AND      r2,r10,#0x1f          ;3072
00005a  eb020242          ADD      r2,r2,r2,LSL #1       ;3072
00005e  4411              ADD      r1,r1,r2              ;3072
000060  ea400091          ORR      r0,r0,r1,LSR #2       ;3072
000064  9003              STR      r0,[sp,#0xc]          ;3072
000066  0af8              LSRS     r0,r7,#11             ;3073
000068  eb0020da          ADD      r0,r0,r10,LSR #11     ;3073
00006c  0840              LSRS     r0,r0,#1              ;3073
00006e  02c0              LSLS     r0,r0,#11             ;3073
000070  f3c71145          UBFX     r1,r7,#5,#6           ;3073
000074  f3ca1245          UBFX     r2,r10,#5,#6          ;3073
000078  4411              ADD      r1,r1,r2              ;3073
00007a  0849              LSRS     r1,r1,#1              ;3073
00007c  ea401041          ORR      r0,r0,r1,LSL #5       ;3073
000080  f007011f          AND      r1,r7,#0x1f           ;3073
000084  f00a021f          AND      r2,r10,#0x1f          ;3073
000088  4411              ADD      r1,r1,r2              ;3073
00008a  ea400051          ORR      r0,r0,r1,LSR #1       ;3073
00008e  9002              STR      r0,[sp,#8]            ;3073
000090  0af8              LSRS     r0,r7,#11             ;3074
000092  eb000040          ADD      r0,r0,r0,LSL #1       ;3074
000096  eb0020da          ADD      r0,r0,r10,LSR #11     ;3074
00009a  0880              LSRS     r0,r0,#2              ;3074
00009c  02c0              LSLS     r0,r0,#11             ;3074
00009e  f3c71145          UBFX     r1,r7,#5,#6           ;3074
0000a2  eb010141          ADD      r1,r1,r1,LSL #1       ;3074
0000a6  f3ca1245          UBFX     r2,r10,#5,#6          ;3074
0000aa  4411              ADD      r1,r1,r2              ;3074
0000ac  0889              LSRS     r1,r1,#2              ;3074
0000ae  ea401041          ORR      r0,r0,r1,LSL #5       ;3074
0000b2  f007011f          AND      r1,r7,#0x1f           ;3074
0000b6  eb010141          ADD      r1,r1,r1,LSL #1       ;3074
0000ba  f00a021f          AND      r2,r10,#0x1f          ;3074
0000be  4411              ADD      r1,r1,r2              ;3074
0000c0  ea400091          ORR      r0,r0,r1,LSR #2       ;3074
0000c4  9001              STR      r0,[sp,#4]            ;3074
0000c6  9808              LDR      r0,[sp,#0x20]         ;3077
0000c8  2801              CMP      r0,#1                 ;3077
0000ca  d170              BNE      |L25.430|
0000cc  9806              LDR      r0,[sp,#0x18]         ;3079
0000ce  9004              STR      r0,[sp,#0x10]         ;3079
0000d0  e08d              B        |L25.494|
                  |L25.210|
0000d2  46cb              MOV      r11,r9                ;3081
0000d4  e083              B        |L25.478|
                  |L25.214|
0000d6  eb0600e4          ADD      r0,r6,r4,ASR #3       ;3083
0000da  7800              LDRB     r0,[r0,#0]            ;3083
0000dc  f0040107          AND      r1,r4,#7              ;3083
0000e0  f1c10207          RSB      r2,r1,#7              ;3083
0000e4  2101              MOVS     r1,#1                 ;3083
0000e6  4091              LSLS     r1,r1,r2              ;3083
0000e8  4008              ANDS     r0,r0,r1              ;3083
0000ea  b128              CBZ      r0,|L25.248|
0000ec  463a              MOV      r2,r7                 ;3084
0000ee  4658              MOV      r0,r11                ;3084
0000f0  9904              LDR      r1,[sp,#0x10]         ;3084
0000f2  f7fffffe          BL       RMP_Point
0000f6  e06f              B        |L25.472|
                  |L25.248|
0000f8  f04f0800          MOV      r8,#0                 ;3088
0000fc  1e60              SUBS     r0,r4,#1              ;3090
0000fe  2800              CMP      r0,#0                 ;3090
000100  d420              BMI      |L25.324|
000102  45cb              CMP      r11,r9                ;3092
000104  d00d              BEQ      |L25.290|
000106  eb0600e0          ADD      r0,r6,r0,ASR #3       ;3092
00010a  7800              LDRB     r0,[r0,#0]            ;3092
00010c  1e61              SUBS     r1,r4,#1              ;3092
00010e  f0010107          AND      r1,r1,#7              ;3092
000112  f1c10207          RSB      r2,r1,#7              ;3092
000116  2101              MOVS     r1,#1                 ;3092
000118  4091              LSLS     r1,r1,r2              ;3092
00011a  4008              ANDS     r0,r0,r1              ;3092
00011c  b108              CBZ      r0,|L25.290|
00011e  f1080801          ADD      r8,r8,#1              ;3093
                  |L25.290|
000122  1b60              SUBS     r0,r4,r5              ;3094
000124  d40e              BMI      |L25.324|
000126  1b60              SUBS     r0,r4,r5              ;3094
000128  eb0600e0          ADD      r0,r6,r0,ASR #3       ;3094
00012c  7800              LDRB     r0,[r0,#0]            ;3094
00012e  1b61              SUBS     r1,r4,r5              ;3094
000130  f0010107          AND      r1,r1,#7              ;3094
000134  f1c10207          RSB      r2,r1,#7              ;3094
000138  2101              MOVS     r1,#1                 ;3094
00013a  4091              LSLS     r1,r1,r2              ;3094
00013c  4008              ANDS     r0,r0,r1              ;3094
00013e  b108              CBZ      r0,|L25.324|
000140  f1080801          ADD      r8,r8,#1              ;3095
                  |L25.324|
000144  1c60              ADDS     r0,r4,#1              ;3098
000146  9900              LDR      r1,[sp,#0]            ;3098
000148  4288              CMP      r0,r1                 ;3098
00014a  d226              BCS      |L25.410|
00014c  eb090005          ADD      r0,r9,r5              ;3100
000150  1e40              SUBS     r0,r0,#1              ;3100
000152  4558              CMP      r0,r11                ;3100
000154  d00e              BEQ      |L25.372|
000156  1c60              ADDS     r0,r4,#1              ;3100
000158  eb0600e0          ADD      r0,r6,r0,ASR #3       ;3100
00015c  7800              LDRB     r0,[r0,#0]            ;3100
00015e  1c61              ADDS     r1,r4,#1              ;3100
000160  f0010107          AND      r1,r1,#7              ;3100
000164  f1c10207          RSB      r2,r1,#7              ;3100
000168  2101              MOVS     r1,#1                 ;3100
00016a  4091              LSLS     r1,r1,r2              ;3100
00016c  4008              ANDS     r0,r0,r1              ;3100
00016e  b108              CBZ      r0,|L25.372|
000170  f1080801          ADD      r8,r8,#1              ;3101
                  |L25.372|
000174  1961              ADDS     r1,r4,r5              ;3102
000176  9800              LDR      r0,[sp,#0]            ;3102
000178  4281              CMP      r1,r0                 ;3102
00017a  d20e              BCS      |L25.410|
00017c  1960              ADDS     r0,r4,r5              ;3102
00017e  eb0600e0          ADD      r0,r6,r0,ASR #3       ;3102
000182  7800              LDRB     r0,[r0,#0]            ;3102
000184  1961              ADDS     r1,r4,r5              ;3102
000186  f0010107          AND      r1,r1,#7              ;3102
00018a  f1c10207          RSB      r2,r1,#7              ;3102
00018e  2101              MOVS     r1,#1                 ;3102
000190  4091              LSLS     r1,r1,r2              ;3102
000192  4008              ANDS     r0,r0,r1              ;3102
000194  b108              CBZ      r0,|L25.410|
000196  f1080801          ADD      r8,r8,#1              ;3103
                  |L25.410|
00019a  f1b80f01          CMP      r8,#1                 ;3106
00019e  d007              BEQ      |L25.432|
0001a0  f1b80f02          CMP      r8,#2                 ;3106
0001a4  d00a              BEQ      |L25.444|
0001a6  f1b80f03          CMP      r8,#3                 ;3106
0001aa  d113              BNE      |L25.468|
0001ac  e00c              B        |L25.456|
                  |L25.430|
0001ae  e026              B        |L25.510|
                  |L25.432|
0001b0  4658              MOV      r0,r11                ;3108
0001b2  e9dd2103          LDRD     r2,r1,[sp,#0xc]       ;3108
0001b6  f7fffffe          BL       RMP_Point
0001ba  e00c              B        |L25.470|
                  |L25.444|
0001bc  4658              MOV      r0,r11                ;3109
0001be  9a02              LDR      r2,[sp,#8]            ;3109
0001c0  9904              LDR      r1,[sp,#0x10]         ;3109
0001c2  f7fffffe          BL       RMP_Point
0001c6  e006              B        |L25.470|
                  |L25.456|
0001c8  4658              MOV      r0,r11                ;3110
0001ca  9a01              LDR      r2,[sp,#4]            ;3110
0001cc  9904              LDR      r1,[sp,#0x10]         ;3110
0001ce  f7fffffe          BL       RMP_Point
0001d2  e000              B        |L25.470|
                  |L25.468|
0001d4  bf00              NOP                            ;3111
                  |L25.470|
0001d6  bf00              NOP                            ;3108
                  |L25.472|
0001d8  1c64              ADDS     r4,r4,#1              ;3115
0001da  f10b0b01          ADD      r11,r11,#1            ;3081
                  |L25.478|
0001de  eb050009          ADD      r0,r5,r9              ;3081
0001e2  4558              CMP      r0,r11                ;3081
0001e4  f73faf77          BGT      |L25.214|
0001e8  9804              LDR      r0,[sp,#0x10]         ;3079
0001ea  1c40              ADDS     r0,r0,#1              ;3079
0001ec  9004              STR      r0,[sp,#0x10]         ;3079
                  |L25.494|
0001ee  9906              LDR      r1,[sp,#0x18]         ;3079
0001f0  9813              LDR      r0,[sp,#0x4c]         ;3079
0001f2  4401              ADD      r1,r1,r0              ;3079
0001f4  9804              LDR      r0,[sp,#0x10]         ;3079
0001f6  4281              CMP      r1,r0                 ;3079
0001f8  f73faf6b          BGT      |L25.210|
0001fc  e08b              B        |L25.790|
                  |L25.510|
0001fe  9806              LDR      r0,[sp,#0x18]         ;3122
000200  9004              STR      r0,[sp,#0x10]         ;3122
000202  e081              B        |L25.776|
                  |L25.516|
000204  46cb              MOV      r11,r9                ;3124
000206  e078              B        |L25.762|
                  |L25.520|
000208  eb0600e4          ADD      r0,r6,r4,ASR #3       ;3126
00020c  7800              LDRB     r0,[r0,#0]            ;3126
00020e  f0040207          AND      r2,r4,#7              ;3126
000212  2101              MOVS     r1,#1                 ;3126
000214  4091              LSLS     r1,r1,r2              ;3126
000216  4008              ANDS     r0,r0,r1              ;3126
000218  b128              CBZ      r0,|L25.550|
00021a  463a              MOV      r2,r7                 ;3127
00021c  4658              MOV      r0,r11                ;3127
00021e  9904              LDR      r1,[sp,#0x10]         ;3127
000220  f7fffffe          BL       RMP_Point
000224  e066              B        |L25.756|
                  |L25.550|
000226  f04f0800          MOV      r8,#0                 ;3131
00022a  1e60              SUBS     r0,r4,#1              ;3133
00022c  2800              CMP      r0,#0                 ;3133
00022e  d41c              BMI      |L25.618|
000230  45cb              CMP      r11,r9                ;3135
000232  d00b              BEQ      |L25.588|
000234  eb0600e0          ADD      r0,r6,r0,ASR #3       ;3135
000238  7800              LDRB     r0,[r0,#0]            ;3135
00023a  1e61              SUBS     r1,r4,#1              ;3135
00023c  f0010207          AND      r2,r1,#7              ;3135
000240  2101              MOVS     r1,#1                 ;3135
000242  4091              LSLS     r1,r1,r2              ;3135
000244  4008              ANDS     r0,r0,r1              ;3135
000246  b108              CBZ      r0,|L25.588|
000248  f1080801          ADD      r8,r8,#1              ;3136
                  |L25.588|
00024c  1b60              SUBS     r0,r4,r5              ;3137
00024e  d40c              BMI      |L25.618|
000250  1b60              SUBS     r0,r4,r5              ;3137
000252  eb0600e0          ADD      r0,r6,r0,ASR #3       ;3137
000256  7800              LDRB     r0,[r0,#0]            ;3137
000258  1b61              SUBS     r1,r4,r5              ;3137
00025a  f0010207          AND      r2,r1,#7              ;3137
00025e  2101              MOVS     r1,#1                 ;3137
000260  4091              LSLS     r1,r1,r2              ;3137
000262  4008              ANDS     r0,r0,r1              ;3137
000264  b108              CBZ      r0,|L25.618|
000266  f1080801          ADD      r8,r8,#1              ;3138
                  |L25.618|
00026a  1c60              ADDS     r0,r4,#1              ;3141
00026c  9900              LDR      r1,[sp,#0]            ;3141
00026e  4288              CMP      r0,r1                 ;3141
000270  d222              BCS      |L25.696|
000272  eb090005          ADD      r0,r9,r5              ;3143
000276  1e40              SUBS     r0,r0,#1              ;3143
000278  4558              CMP      r0,r11                ;3143
00027a  d00c              BEQ      |L25.662|
00027c  1c60              ADDS     r0,r4,#1              ;3143
00027e  eb0600e0          ADD      r0,r6,r0,ASR #3       ;3143
000282  7800              LDRB     r0,[r0,#0]            ;3143
000284  1c61              ADDS     r1,r4,#1              ;3143
000286  f0010207          AND      r2,r1,#7              ;3143
00028a  2101              MOVS     r1,#1                 ;3143
00028c  4091              LSLS     r1,r1,r2              ;3143
00028e  4008              ANDS     r0,r0,r1              ;3143
000290  b108              CBZ      r0,|L25.662|
000292  f1080801          ADD      r8,r8,#1              ;3144
                  |L25.662|
000296  1961              ADDS     r1,r4,r5              ;3145
000298  9800              LDR      r0,[sp,#0]            ;3145
00029a  4281              CMP      r1,r0                 ;3145
00029c  d20c              BCS      |L25.696|
00029e  1960              ADDS     r0,r4,r5              ;3145
0002a0  eb0600e0          ADD      r0,r6,r0,ASR #3       ;3145
0002a4  7800              LDRB     r0,[r0,#0]            ;3145
0002a6  1961              ADDS     r1,r4,r5              ;3145
0002a8  f0010207          AND      r2,r1,#7              ;3145
0002ac  2101              MOVS     r1,#1                 ;3145
0002ae  4091              LSLS     r1,r1,r2              ;3145
0002b0  4008              ANDS     r0,r0,r1              ;3145
0002b2  b108              CBZ      r0,|L25.696|
0002b4  f1080801          ADD      r8,r8,#1              ;3146
                  |L25.696|
0002b8  f1b80f01          CMP      r8,#1                 ;3149
0002bc  d006              BEQ      |L25.716|
0002be  f1b80f02          CMP      r8,#2                 ;3149
0002c2  d009              BEQ      |L25.728|
0002c4  f1b80f03          CMP      r8,#3                 ;3149
0002c8  d112              BNE      |L25.752|
0002ca  e00b              B        |L25.740|
                  |L25.716|
0002cc  4658              MOV      r0,r11                ;3151
0002ce  e9dd2103          LDRD     r2,r1,[sp,#0xc]       ;3151
0002d2  f7fffffe          BL       RMP_Point
0002d6  e00c              B        |L25.754|
                  |L25.728|
0002d8  4658              MOV      r0,r11                ;3152
0002da  9a02              LDR      r2,[sp,#8]            ;3152
0002dc  9904              LDR      r1,[sp,#0x10]         ;3152
0002de  f7fffffe          BL       RMP_Point
0002e2  e006              B        |L25.754|
                  |L25.740|
0002e4  4658              MOV      r0,r11                ;3153
0002e6  9a01              LDR      r2,[sp,#4]            ;3153
0002e8  9904              LDR      r1,[sp,#0x10]         ;3153
0002ea  f7fffffe          BL       RMP_Point
0002ee  e000              B        |L25.754|
                  |L25.752|
0002f0  bf00              NOP                            ;3154
                  |L25.754|
0002f2  bf00              NOP                            ;3151
                  |L25.756|
0002f4  1c64              ADDS     r4,r4,#1              ;3158
0002f6  f10b0b01          ADD      r11,r11,#1            ;3124
                  |L25.762|
0002fa  eb050009          ADD      r0,r5,r9              ;3124
0002fe  4558              CMP      r0,r11                ;3124
000300  dc82              BGT      |L25.520|
000302  9804              LDR      r0,[sp,#0x10]         ;3122
000304  1c40              ADDS     r0,r0,#1              ;3122
000306  9004              STR      r0,[sp,#0x10]         ;3122
                  |L25.776|
000308  9906              LDR      r1,[sp,#0x18]         ;3122
00030a  9813              LDR      r0,[sp,#0x4c]         ;3122
00030c  4401              ADD      r1,r1,r0              ;3122
00030e  9804              LDR      r0,[sp,#0x10]         ;3122
000310  4281              CMP      r1,r0                 ;3122
000312  f73faf77          BGT      |L25.516|
                  |L25.790|
000316  bf00              NOP      
000318  e681              B        |L25.30|
;;;3163   #endif
                          ENDP


                          AREA ||i.RMP_Mem_Init||, CODE, READONLY, ALIGN=1

                  RMP_Mem_Init PROC
;;;2160   ******************************************************************************/
;;;2161   rmp_ret_t RMP_Mem_Init(volatile void* Pool, rmp_ptr_t Size)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;2162   {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;2163       rmp_cnt_t FLI_Cnt;
;;;2164       rmp_ptr_t Usable_Size;
;;;2165       volatile struct RMP_Mem* Mem;
;;;2166       volatile struct RMP_Mem_Head* Mem_Head;
;;;2167       
;;;2168       /* See if the memory pool is large enough to enable dynamic allocation - at
;;;2169        * least 4096 words and no more than 128MB */
;;;2170       if((Pool==0)||(Size<(4096*sizeof(rmp_ptr_t)))||(((Size>>15)>>12)>0))
000008  b126              CBZ      r6,|L26.20|
00000a  f5b74f80          CMP      r7,#0x4000
00000e  d301              BCC      |L26.20|
000010  0ef8              LSRS     r0,r7,#27
000012  b128              CBZ      r0,|L26.32|
                  |L26.20|
;;;2171       {
;;;2172           RMP_COVERAGE_MARKER();
000014  bf00              NOP      
000016  bf00              NOP      
;;;2173           return RMP_ERR_MEM;
000018  f06f0006          MVN      r0,#6
                  |L26.28|
;;;2174       }
;;;2175       else
;;;2176           RMP_COVERAGE_MARKER();
;;;2177       
;;;2178       /* See if the address and size is word-aligned */
;;;2179       if((((rmp_ptr_t)Pool&(RMP_WORD_MASK>>3))!=0)||((Size&(RMP_WORD_MASK>>3))!=0))
;;;2180       {
;;;2181           RMP_COVERAGE_MARKER();
;;;2182           return RMP_ERR_MEM;
;;;2183       }
;;;2184       else
;;;2185           RMP_COVERAGE_MARKER();
;;;2186           
;;;2187       Mem=(volatile struct RMP_Mem*)Pool;
;;;2188       Mem->Size=Size;
;;;2189       /* Initialize the allocated block list */
;;;2190       RMP_List_Crt(&(Mem->Alloc));
;;;2191       /* Calculate the FLI value needed for this - we always align to 64 byte */
;;;2192       Mem->FLI_Num=RMP_MSB_Get(Size-sizeof(struct RMP_Mem))-6+1;
;;;2193       /* Initialize the TLSF allocation table first */
;;;2194       for(FLI_Cnt=0;FLI_Cnt<(rmp_cnt_t)(Mem->FLI_Num);FLI_Cnt++)
;;;2195       {
;;;2196           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,0)]));
;;;2197           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,1)]));
;;;2198           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,2)]));
;;;2199           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,3)]));
;;;2200           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,4)]));
;;;2201           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,5)]));
;;;2202           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,6)]));
;;;2203           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,7)]));
;;;2204       }
;;;2205       for(FLI_Cnt=0;FLI_Cnt<5;FLI_Cnt++)
;;;2206           Mem->Bitmap[FLI_Cnt]=0;
;;;2207       
;;;2208       /* Get the big memory block's size and position */
;;;2209       Usable_Size=sizeof(struct RMP_Mem)+(sizeof(struct RMP_List)<<3)*(Mem->FLI_Num-8);
;;;2210       Mem_Head=(struct RMP_Mem_Head*)(((rmp_ptr_t)Pool)+Usable_Size);
;;;2211       Mem->Start=(rmp_ptr_t)Mem_Head;
;;;2212       Usable_Size=Size-Usable_Size;
;;;2213       
;;;2214       /* Initialize the big block */
;;;2215       _RMP_Mem_Block(Mem_Head,Usable_Size);
;;;2216       
;;;2217       /* Insert the memory into the corresponding level */
;;;2218       _RMP_Mem_Ins(Pool, Mem_Head);
;;;2219       return 0;
;;;2220   }
00001c  e8bd87f0          POP      {r4-r10,pc}
                  |L26.32|
000020  bf00              NOP                            ;2176
000022  bf00              NOP                            ;2176
000024  f0060003          AND      r0,r6,#3              ;2179
000028  b910              CBNZ     r0,|L26.48|
00002a  f0070003          AND      r0,r7,#3              ;2179
00002e  b120              CBZ      r0,|L26.58|
                  |L26.48|
000030  bf00              NOP                            ;2181
000032  bf00              NOP                            ;2181
000034  f06f0006          MVN      r0,#6                 ;2182
000038  e7f0              B        |L26.28|
                  |L26.58|
00003a  bf00              NOP                            ;2185
00003c  bf00              NOP                            ;2185
00003e  4634              MOV      r4,r6                 ;2187
000040  6127              STR      r7,[r4,#0x10]         ;2188
000042  4620              MOV      r0,r4                 ;2190
000044  f7fffffe          BL       RMP_List_Crt
000048  f5a7700a          SUB      r0,r7,#0x228          ;2192
00004c  f7fffffe          BL       RMP_MSB_Get
000050  1f40              SUBS     r0,r0,#5              ;2192
000052  60a0              STR      r0,[r4,#8]            ;2192
000054  2500              MOVS     r5,#0                 ;2194
000056  e048              B        |L26.234|
                  |L26.88|
000058  2100              MOVS     r1,#0                 ;2196
00005a  eb0102c5          ADD      r2,r1,r5,LSL #3       ;2196
00005e  f1040128          ADD      r1,r4,#0x28           ;2196
000062  eb0100c2          ADD      r0,r1,r2,LSL #3       ;2196
000066  f7fffffe          BL       RMP_List_Crt
00006a  2101              MOVS     r1,#1                 ;2197
00006c  eb0102c5          ADD      r2,r1,r5,LSL #3       ;2197
000070  f1040128          ADD      r1,r4,#0x28           ;2197
000074  eb0100c2          ADD      r0,r1,r2,LSL #3       ;2197
000078  f7fffffe          BL       RMP_List_Crt
00007c  2102              MOVS     r1,#2                 ;2198
00007e  eb0102c5          ADD      r2,r1,r5,LSL #3       ;2198
000082  f1040128          ADD      r1,r4,#0x28           ;2198
000086  eb0100c2          ADD      r0,r1,r2,LSL #3       ;2198
00008a  f7fffffe          BL       RMP_List_Crt
00008e  2103              MOVS     r1,#3                 ;2199
000090  eb0102c5          ADD      r2,r1,r5,LSL #3       ;2199
000094  f1040128          ADD      r1,r4,#0x28           ;2199
000098  eb0100c2          ADD      r0,r1,r2,LSL #3       ;2199
00009c  f7fffffe          BL       RMP_List_Crt
0000a0  2104              MOVS     r1,#4                 ;2200
0000a2  eb0102c5          ADD      r2,r1,r5,LSL #3       ;2200
0000a6  f1040128          ADD      r1,r4,#0x28           ;2200
0000aa  eb0100c2          ADD      r0,r1,r2,LSL #3       ;2200
0000ae  f7fffffe          BL       RMP_List_Crt
0000b2  2105              MOVS     r1,#5                 ;2201
0000b4  eb0102c5          ADD      r2,r1,r5,LSL #3       ;2201
0000b8  f1040128          ADD      r1,r4,#0x28           ;2201
0000bc  eb0100c2          ADD      r0,r1,r2,LSL #3       ;2201
0000c0  f7fffffe          BL       RMP_List_Crt
0000c4  2106              MOVS     r1,#6                 ;2202
0000c6  eb0102c5          ADD      r2,r1,r5,LSL #3       ;2202
0000ca  f1040128          ADD      r1,r4,#0x28           ;2202
0000ce  eb0100c2          ADD      r0,r1,r2,LSL #3       ;2202
0000d2  f7fffffe          BL       RMP_List_Crt
0000d6  2107              MOVS     r1,#7                 ;2203
0000d8  eb0102c5          ADD      r2,r1,r5,LSL #3       ;2203
0000dc  f1040128          ADD      r1,r4,#0x28           ;2203
0000e0  eb0100c2          ADD      r0,r1,r2,LSL #3       ;2203
0000e4  f7fffffe          BL       RMP_List_Crt
0000e8  1c6d              ADDS     r5,r5,#1              ;2194
                  |L26.234|
0000ea  68a0              LDR      r0,[r4,#8]            ;2194
0000ec  42a8              CMP      r0,r5                 ;2194
0000ee  dcb3              BGT      |L26.88|
0000f0  2500              MOVS     r5,#0                 ;2205
0000f2  e005              B        |L26.256|
                  |L26.244|
0000f4  2100              MOVS     r1,#0                 ;2206
0000f6  f1040014          ADD      r0,r4,#0x14           ;2206
0000fa  f8401025          STR      r1,[r0,r5,LSL #2]     ;2206
0000fe  1c6d              ADDS     r5,r5,#1              ;2205
                  |L26.256|
000100  2d05              CMP      r5,#5                 ;2205
000102  dbf7              BLT      |L26.244|
000104  68a0              LDR      r0,[r4,#8]            ;2209
000106  3808              SUBS     r0,r0,#8              ;2209
000108  0180              LSLS     r0,r0,#6              ;2209
00010a  f500790a          ADD      r9,r0,#0x228          ;2209
00010e  eb060809          ADD      r8,r6,r9              ;2210
000112  f8c4800c          STR      r8,[r4,#0xc]          ;2211
000116  eba70909          SUB      r9,r7,r9              ;2212
00011a  4649              MOV      r1,r9                 ;2215
00011c  4640              MOV      r0,r8                 ;2215
00011e  f7fffffe          BL       _RMP_Mem_Block
000122  4641              MOV      r1,r8                 ;2218
000124  4630              MOV      r0,r6                 ;2218
000126  f7fffffe          BL       _RMP_Mem_Ins
00012a  2000              MOVS     r0,#0                 ;2219
00012c  e776              B        |L26.28|
;;;2221   /* End Function:RMP_Mem_Init *************************************************/
                          ENDP


                          AREA ||i.RMP_Print_Int||, CODE, READONLY, ALIGN=1

                  RMP_Print_Int PROC
;;;85     ******************************************************************************/
;;;86     rmp_cnt_t RMP_Print_Int(rmp_cnt_t Int)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;87     {
000004  4607              MOV      r7,r0
;;;88         rmp_ptr_t Iter;
;;;89         rmp_cnt_t Count;
;;;90         rmp_cnt_t Num;
;;;91         rmp_ptr_t Div;
;;;92         
;;;93         /* how many digits are there? */
;;;94         if(Int==0)
000006  b92f              CBNZ     r7,|L27.20|
;;;95         {
;;;96             RMP_Putchar('0');
000008  2030              MOVS     r0,#0x30
00000a  f7fffffe          BL       RMP_Putchar
;;;97             return 1;
00000e  2001              MOVS     r0,#1
                  |L27.16|
;;;98         }
;;;99         else if(Int<0)
;;;100        {
;;;101            /* How many digits are there? */
;;;102            Count=0;
;;;103            Div=1;
;;;104            Iter=(rmp_ptr_t)(-Int);
;;;105            while(Iter!=0)
;;;106            {
;;;107                Iter/=10;
;;;108                Count++;
;;;109                Div*=10;
;;;110            }
;;;111            Div/=10;
;;;112            
;;;113            RMP_Putchar('-');
;;;114            Iter=-Int;
;;;115            Num=Count+1;
;;;116            
;;;117            while(Count>0)
;;;118            {
;;;119                Count--;
;;;120                RMP_Putchar(Iter/Div+'0');
;;;121                Iter=Iter%Div;
;;;122                Div/=10;
;;;123            }
;;;124        }
;;;125        else
;;;126        {
;;;127            /* How many digits are there? */
;;;128            Count=0;
;;;129            Div=1;
;;;130            Iter=Int;
;;;131            while(Iter!=0)
;;;132            {
;;;133                Iter/=10;
;;;134                Count++;
;;;135                Div*=10;
;;;136            }
;;;137            Div/=10;
;;;138            
;;;139            Iter=Int;
;;;140            Num=Count;
;;;141            
;;;142            while(Count>0)
;;;143            {
;;;144                Count--;
;;;145                RMP_Putchar(Iter/Div+'0');
;;;146                Iter=Iter%Div;
;;;147                Div/=10;
;;;148            }
;;;149        }
;;;150        
;;;151        return Num;
;;;152    }
000010  e8bd87f0          POP      {r4-r10,pc}
                  |L27.20|
000014  2f00              CMP      r7,#0                 ;99
000016  da29              BGE      |L27.108|
000018  2600              MOVS     r6,#0                 ;102
00001a  2401              MOVS     r4,#1                 ;103
00001c  427d              RSBS     r5,r7,#0              ;104
00001e  e006              B        |L27.46|
                  |L27.32|
000020  200a              MOVS     r0,#0xa               ;107
000022  fbb5f5f0          UDIV     r5,r5,r0              ;107
000026  1c76              ADDS     r6,r6,#1              ;108
000028  eb040084          ADD      r0,r4,r4,LSL #2       ;109
00002c  0044              LSLS     r4,r0,#1              ;109
                  |L27.46|
00002e  2d00              CMP      r5,#0                 ;105
000030  d1f6              BNE      |L27.32|
000032  200a              MOVS     r0,#0xa               ;111
000034  fbb4f4f0          UDIV     r4,r4,r0              ;111
000038  202d              MOVS     r0,#0x2d              ;113
00003a  f7fffffe          BL       RMP_Putchar
00003e  427d              RSBS     r5,r7,#0              ;114
000040  f1060801          ADD      r8,r6,#1              ;115
000044  e00f              B        |L27.102|
                  |L27.70|
000046  1e76              SUBS     r6,r6,#1              ;119
000048  fbb5f0f4          UDIV     r0,r5,r4              ;120
00004c  3030              ADDS     r0,r0,#0x30           ;120
00004e  fa4ff980          SXTB     r9,r0                 ;120
000052  4648              MOV      r0,r9                 ;120
000054  f7fffffe          BL       RMP_Putchar
000058  fbb5f0f4          UDIV     r0,r5,r4              ;121
00005c  fb045510          MLS      r5,r4,r0,r5           ;121
000060  200a              MOVS     r0,#0xa               ;122
000062  fbb4f4f0          UDIV     r4,r4,r0              ;122
                  |L27.102|
000066  2e00              CMP      r6,#0                 ;117
000068  dced              BGT      |L27.70|
00006a  e024              B        |L27.182|
                  |L27.108|
00006c  2600              MOVS     r6,#0                 ;128
00006e  2401              MOVS     r4,#1                 ;129
000070  463d              MOV      r5,r7                 ;130
000072  e006              B        |L27.130|
                  |L27.116|
000074  200a              MOVS     r0,#0xa               ;133
000076  fbb5f5f0          UDIV     r5,r5,r0              ;133
00007a  1c76              ADDS     r6,r6,#1              ;134
00007c  eb040084          ADD      r0,r4,r4,LSL #2       ;135
000080  0044              LSLS     r4,r0,#1              ;135
                  |L27.130|
000082  2d00              CMP      r5,#0                 ;131
000084  d1f6              BNE      |L27.116|
000086  200a              MOVS     r0,#0xa               ;137
000088  fbb4f4f0          UDIV     r4,r4,r0              ;137
00008c  463d              MOV      r5,r7                 ;139
00008e  46b0              MOV      r8,r6                 ;140
000090  e00f              B        |L27.178|
                  |L27.146|
000092  1e76              SUBS     r6,r6,#1              ;144
000094  fbb5f0f4          UDIV     r0,r5,r4              ;145
000098  3030              ADDS     r0,r0,#0x30           ;145
00009a  fa4ff980          SXTB     r9,r0                 ;145
00009e  4648              MOV      r0,r9                 ;145
0000a0  f7fffffe          BL       RMP_Putchar
0000a4  fbb5f0f4          UDIV     r0,r5,r4              ;146
0000a8  fb045510          MLS      r5,r4,r0,r5           ;146
0000ac  200a              MOVS     r0,#0xa               ;147
0000ae  fbb4f4f0          UDIV     r4,r4,r0              ;147
                  |L27.178|
0000b2  2e00              CMP      r6,#0                 ;142
0000b4  dced              BGT      |L27.146|
                  |L27.182|
0000b6  4640              MOV      r0,r8                 ;151
0000b8  e7aa              B        |L27.16|
;;;153    /* End Function:RMP_Print_Int ************************************************/
                          ENDP


                          AREA ||i.RMP_Print_String||, CODE, READONLY, ALIGN=1

                  RMP_Print_String PROC
;;;208    ******************************************************************************/
;;;209    rmp_cnt_t RMP_Print_String(rmp_s8_t* String)
000000  b570              PUSH     {r4-r6,lr}
;;;210    {
000002  4605              MOV      r5,r0
;;;211        rmp_cnt_t Count;
;;;212        
;;;213        Count=0;
000004  2400              MOVS     r4,#0
;;;214        while(Count<RMP_KERNEL_DEBUG_MAX_STR)
000006  e007              B        |L28.24|
                  |L28.8|
;;;215        {
;;;216            if(String[Count]=='\0')
000008  5d28              LDRB     r0,[r5,r4]
00000a  b900              CBNZ     r0,|L28.14|
;;;217                break;
00000c  e006              B        |L28.28|
                  |L28.14|
;;;218            
;;;219            RMP_Putchar(String[Count++]);
00000e  4621              MOV      r1,r4
000010  1c64              ADDS     r4,r4,#1
000012  5668              LDRSB    r0,[r5,r1]
000014  f7fffffe          BL       RMP_Putchar
                  |L28.24|
000018  2cff              CMP      r4,#0xff              ;214
00001a  dbf5              BLT      |L28.8|
                  |L28.28|
00001c  bf00              NOP                            ;217
;;;220        }
;;;221        
;;;222        return Count;
00001e  4620              MOV      r0,r4
;;;223    }
000020  bd70              POP      {r4-r6,pc}
;;;224    /* End Function:RMP_Print_String *********************************************/
                          ENDP


                          AREA ||i.RMP_Print_Uint||, CODE, READONLY, ALIGN=1

                  RMP_Print_Uint PROC
;;;161    ******************************************************************************/
;;;162    rmp_cnt_t RMP_Print_Uint(rmp_ptr_t Uint)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;163    {
000004  4606              MOV      r6,r0
;;;164        rmp_ptr_t Iter;
;;;165        rmp_cnt_t Count;
;;;166        rmp_cnt_t Num;
;;;167        
;;;168        /* how many digits are there? */
;;;169        if(Uint==0)
000006  b92e              CBNZ     r6,|L29.20|
;;;170        {
;;;171            RMP_Putchar('0');
000008  2030              MOVS     r0,#0x30
00000a  f7fffffe          BL       RMP_Putchar
;;;172            return 1;
00000e  2001              MOVS     r0,#1
                  |L29.16|
;;;173        }
;;;174        else
;;;175        {
;;;176            /* Filter out all the zeroes */
;;;177            Count=0;
;;;178            Iter=Uint;
;;;179            while((Iter>>((sizeof(rmp_ptr_t)*8)-4))==0)
;;;180            {
;;;181                Iter<<=4;
;;;182                Count++;
;;;183            }
;;;184            /* Count is the number of pts to print */
;;;185            Count=sizeof(rmp_ptr_t)*2-Count;
;;;186            Num=Count;
;;;187            while(Count>0)
;;;188            {
;;;189                Count--;
;;;190                Iter=(Uint>>(Count*4))&0x0F;
;;;191                if(Iter<10)
;;;192                    RMP_Putchar('0'+Iter);
;;;193                else
;;;194                    RMP_Putchar('A'+Iter-10);
;;;195            }
;;;196        }
;;;197        
;;;198        return Num;
;;;199    }
000010  e8bd81f0          POP      {r4-r8,pc}
                  |L29.20|
000014  2400              MOVS     r4,#0                 ;177
000016  4635              MOV      r5,r6                 ;178
000018  e001              B        |L29.30|
                  |L29.26|
00001a  012d              LSLS     r5,r5,#4              ;181
00001c  1c64              ADDS     r4,r4,#1              ;182
                  |L29.30|
00001e  0f28              LSRS     r0,r5,#28             ;179
000020  2800              CMP      r0,#0                 ;179
000022  d0fa              BEQ      |L29.26|
000024  f1c40408          RSB      r4,r4,#8              ;185
000028  4627              MOV      r7,r4                 ;186
00002a  e012              B        |L29.82|
                  |L29.44|
00002c  1e64              SUBS     r4,r4,#1              ;189
00002e  00a0              LSLS     r0,r4,#2              ;190
000030  fa26f000          LSR      r0,r6,r0              ;190
000034  f000050f          AND      r5,r0,#0xf            ;190
000038  2d0a              CMP      r5,#0xa               ;191
00003a  d205              BCS      |L29.72|
00003c  f1050130          ADD      r1,r5,#0x30           ;192
000040  b248              SXTB     r0,r1                 ;192
000042  f7fffffe          BL       RMP_Putchar
000046  e004              B        |L29.82|
                  |L29.72|
000048  f1050137          ADD      r1,r5,#0x37           ;194
00004c  b248              SXTB     r0,r1                 ;194
00004e  f7fffffe          BL       RMP_Putchar
                  |L29.82|
000052  2c00              CMP      r4,#0                 ;187
000054  dcea              BGT      |L29.44|
000056  4638              MOV      r0,r7                 ;198
000058  e7da              B        |L29.16|
;;;200    /* End Function:RMP_Print_Uint ***********************************************/
                          ENDP


                          AREA ||i.RMP_Progbar||, CODE, READONLY, ALIGN=1

                  RMP_Progbar PROC
;;;3850   ******************************************************************************/
;;;3851   void RMP_Progbar(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width,
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;3852                    rmp_cnt_t Style, rmp_cnt_t Prog, rmp_ptr_t Fore, rmp_ptr_t Back)
;;;3853   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  e9ddab10          LDRD     r10,r11,[sp,#0x40]
000010  e9dd890e          LDRD     r8,r9,[sp,#0x38]
;;;3854       /* Draw the progress bar according to the style of the progress bar */
;;;3855       RMP_Progbar_Prog(Coord_X,Coord_Y,Length,Width,Style,Prog,Fore,Back);
000014  463b              MOV      r3,r7
000016  4632              MOV      r2,r6
000018  4629              MOV      r1,r5
00001a  4620              MOV      r0,r4
00001c  e88d0f00          STM      sp,{r8-r11}
000020  f7fffffe          BL       RMP_Progbar_Prog
;;;3856       /* Now draw the border */
;;;3857       RMP_Line(Coord_X,Coord_Y,Coord_X+Length-1,Coord_Y,RMP_CTL_BLACK);
000024  2000              MOVS     r0,#0
000026  9000              STR      r0,[sp,#0]
000028  19a0              ADDS     r0,r4,r6
00002a  1e42              SUBS     r2,r0,#1
00002c  462b              MOV      r3,r5
00002e  4629              MOV      r1,r5
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       RMP_Line
;;;3858       RMP_Line(Coord_X+Length-1,Coord_Y,Coord_X+Length-1,Coord_Y+Width-1,RMP_CTL_BLACK);
000036  2000              MOVS     r0,#0
000038  19e9              ADDS     r1,r5,r7
00003a  1e4b              SUBS     r3,r1,#1
00003c  19a1              ADDS     r1,r4,r6
00003e  1e4a              SUBS     r2,r1,#1
000040  19a1              ADDS     r1,r4,r6
000042  9000              STR      r0,[sp,#0]
000044  1e48              SUBS     r0,r1,#1
000046  4629              MOV      r1,r5
000048  f7fffffe          BL       RMP_Line
;;;3859       RMP_Line(Coord_X+Length-1,Coord_Y+Width-1,Coord_X,Coord_Y+Width-1,RMP_CTL_BLACK);
00004c  2000              MOVS     r0,#0
00004e  19ea              ADDS     r2,r5,r7
000050  1e53              SUBS     r3,r2,#1
000052  19ea              ADDS     r2,r5,r7
000054  1e51              SUBS     r1,r2,#1
000056  19a2              ADDS     r2,r4,r6
000058  9000              STR      r0,[sp,#0]
00005a  1e50              SUBS     r0,r2,#1
00005c  4622              MOV      r2,r4
00005e  f7fffffe          BL       RMP_Line
;;;3860       RMP_Line(Coord_X,Coord_Y+Width-1,Coord_X,Coord_Y,RMP_CTL_BLACK);
000062  2000              MOVS     r0,#0
000064  9000              STR      r0,[sp,#0]
000066  19e8              ADDS     r0,r5,r7
000068  1e41              SUBS     r1,r0,#1
00006a  462b              MOV      r3,r5
00006c  4622              MOV      r2,r4
00006e  4620              MOV      r0,r4
000070  f7fffffe          BL       RMP_Line
;;;3861   }
000074  e8bd9fff          POP      {r0-r12,pc}
;;;3862   #endif
                          ENDP


                          AREA ||i.RMP_Progbar_Prog||, CODE, READONLY, ALIGN=1

                  RMP_Progbar_Prog PROC
;;;3788   ******************************************************************************/
;;;3789   void RMP_Progbar_Prog(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width,
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;3790                         rmp_cnt_t Style, rmp_cnt_t Prog, rmp_ptr_t Fore, rmp_ptr_t Back)
;;;3791   {
000004  4682              MOV      r10,r0
000006  468b              MOV      r11,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
00000c  ad0d              ADD      r5,sp,#0x34
00000e  cde0              LDM      r5,{r5-r7}
;;;3792       /* The critical value for drawing the bar */
;;;3793       rmp_ptr_t Pivot;
;;;3794       
;;;3795       switch(Style)
000010  980c              LDR      r0,[sp,#0x30]
000012  b130              CBZ      r0,|L31.34|
000014  2801              CMP      r0,#1
000016  d01f              BEQ      |L31.88|
000018  2802              CMP      r0,#2
00001a  d039              BEQ      |L31.144|
00001c  2803              CMP      r0,#3
00001e  d16f              BNE      |L31.256|
000020  e052              B        |L31.200|
                  |L31.34|
;;;3796       {
;;;3797           case RMP_PBAR_L2R:
;;;3798           {
;;;3799               Pivot=Length*Prog/100;
000022  fb08f005          MUL      r0,r8,r5
000026  2164              MOVS     r1,#0x64
000028  fb90f4f1          SDIV     r4,r0,r1
;;;3800               if(Prog!=0)
00002c  b13d              CBZ      r5,|L31.62|
;;;3801                   RMP_Rectangle(Coord_X,Coord_Y,Pivot,Width,Fore,Fore);
00002e  9600              STR      r6,[sp,#0]
000030  464b              MOV      r3,r9
000032  4622              MOV      r2,r4
000034  4659              MOV      r1,r11
000036  4650              MOV      r0,r10
000038  9601              STR      r6,[sp,#4]
00003a  f7fffffe          BL       RMP_Rectangle
                  |L31.62|
;;;3802               if(Prog!=100)
00003e  2d64              CMP      r5,#0x64
000040  d009              BEQ      |L31.86|
;;;3803                   RMP_Rectangle(Coord_X+Pivot,Coord_Y,Length-Pivot,Width,Back,Back);
000042  9700              STR      r7,[sp,#0]
000044  eba80204          SUB      r2,r8,r4
000048  eb0a0004          ADD      r0,r10,r4
00004c  464b              MOV      r3,r9
00004e  4659              MOV      r1,r11
000050  9701              STR      r7,[sp,#4]
000052  f7fffffe          BL       RMP_Rectangle
                  |L31.86|
;;;3804               break;
000056  e054              B        |L31.258|
                  |L31.88|
;;;3805           }
;;;3806           case RMP_PBAR_D2U:
;;;3807           {
;;;3808               Pivot=Width*Prog/100;
000058  fb09f005          MUL      r0,r9,r5
00005c  2164              MOVS     r1,#0x64
00005e  fb90f4f1          SDIV     r4,r0,r1
;;;3809               if(Prog!=0)
000062  b14d              CBZ      r5,|L31.120|
;;;3810                   RMP_Rectangle(Coord_X,Coord_Y+Width-Pivot,Length,Pivot,Fore,Fore);
000064  9600              STR      r6,[sp,#0]
000066  eb0b0009          ADD      r0,r11,r9
00006a  1b01              SUBS     r1,r0,r4
00006c  4623              MOV      r3,r4
00006e  4642              MOV      r2,r8
000070  4650              MOV      r0,r10
000072  9601              STR      r6,[sp,#4]
000074  f7fffffe          BL       RMP_Rectangle
                  |L31.120|
;;;3811               if(Prog!=100)
000078  2d64              CMP      r5,#0x64
00007a  d008              BEQ      |L31.142|
;;;3812                   RMP_Rectangle(Coord_X,Coord_Y,Length,Width-Pivot,Back,Back);
00007c  9700              STR      r7,[sp,#0]
00007e  eba90304          SUB      r3,r9,r4
000082  4642              MOV      r2,r8
000084  4659              MOV      r1,r11
000086  4650              MOV      r0,r10
000088  9701              STR      r7,[sp,#4]
00008a  f7fffffe          BL       RMP_Rectangle
                  |L31.142|
;;;3813               break;
00008e  e038              B        |L31.258|
                  |L31.144|
;;;3814           }
;;;3815           case RMP_PBAR_R2L:
;;;3816           {
;;;3817               Pivot=Length*Prog/100;
000090  fb08f005          MUL      r0,r8,r5
000094  2164              MOVS     r1,#0x64
000096  fb90f4f1          SDIV     r4,r0,r1
;;;3818               if(Prog!=0)
00009a  b14d              CBZ      r5,|L31.176|
;;;3819                   RMP_Rectangle(Coord_X+Length-Pivot,Coord_Y,Pivot,Width,Fore,Fore);
00009c  9600              STR      r6,[sp,#0]
00009e  eb0a0108          ADD      r1,r10,r8
0000a2  1b08              SUBS     r0,r1,r4
0000a4  464b              MOV      r3,r9
0000a6  4622              MOV      r2,r4
0000a8  4659              MOV      r1,r11
0000aa  9601              STR      r6,[sp,#4]
0000ac  f7fffffe          BL       RMP_Rectangle
                  |L31.176|
;;;3820               if(Prog!=100)
0000b0  2d64              CMP      r5,#0x64
0000b2  d008              BEQ      |L31.198|
;;;3821                   RMP_Rectangle(Coord_X,Coord_Y,Length-Pivot,Width,Back,Back);
0000b4  9700              STR      r7,[sp,#0]
0000b6  eba80204          SUB      r2,r8,r4
0000ba  464b              MOV      r3,r9
0000bc  4659              MOV      r1,r11
0000be  4650              MOV      r0,r10
0000c0  9701              STR      r7,[sp,#4]
0000c2  f7fffffe          BL       RMP_Rectangle
                  |L31.198|
;;;3822               break;
0000c6  e01c              B        |L31.258|
                  |L31.200|
;;;3823           }
;;;3824           case RMP_PBAR_U2D:
;;;3825           {
;;;3826               Pivot=Width*Prog/100;
0000c8  fb09f005          MUL      r0,r9,r5
0000cc  2164              MOVS     r1,#0x64
0000ce  fb90f4f1          SDIV     r4,r0,r1
;;;3827               if(Prog!=0)
0000d2  b13d              CBZ      r5,|L31.228|
;;;3828                   RMP_Rectangle(Coord_X,Coord_Y,Length,Pivot,Fore,Fore);
0000d4  9600              STR      r6,[sp,#0]
0000d6  4623              MOV      r3,r4
0000d8  4642              MOV      r2,r8
0000da  4659              MOV      r1,r11
0000dc  4650              MOV      r0,r10
0000de  9601              STR      r6,[sp,#4]
0000e0  f7fffffe          BL       RMP_Rectangle
                  |L31.228|
;;;3829               if(Prog!=100)
0000e4  2d64              CMP      r5,#0x64
0000e6  d009              BEQ      |L31.252|
;;;3830                   RMP_Rectangle(Coord_X,Coord_Y+Pivot,Length,Width-Pivot,Back,Back);
0000e8  9700              STR      r7,[sp,#0]
0000ea  eba90304          SUB      r3,r9,r4
0000ee  eb0b0104          ADD      r1,r11,r4
0000f2  4642              MOV      r2,r8
0000f4  4650              MOV      r0,r10
0000f6  9701              STR      r7,[sp,#4]
0000f8  f7fffffe          BL       RMP_Rectangle
                  |L31.252|
;;;3831               break;
0000fc  e001              B        |L31.258|
0000fe  e7ff              B        |L31.256|
                  |L31.256|
;;;3832           }
;;;3833           default: break;
000100  bf00              NOP      
                  |L31.258|
000102  bf00              NOP                            ;3804
;;;3834       }
;;;3835   }
000104  e8bd9ffc          POP      {r2-r12,pc}
;;;3836   /* End Function:RMP_Progbar_Prog *********************************************/
                          ENDP


                          AREA ||i.RMP_Progbar_Set||, CODE, READONLY, ALIGN=1

                  RMP_Progbar_Set PROC
;;;3709   ******************************************************************************/
;;;3710   void RMP_Progbar_Set(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width,
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;3711                        rmp_cnt_t Style, rmp_cnt_t Old_Prog, rmp_cnt_t New_Prog, rmp_ptr_t Fore, rmp_ptr_t Back)
;;;3712   {
000004  4680              MOV      r8,r0
000006  4689              MOV      r9,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  e9ddab0f          LDRD     r10,r11,[sp,#0x3c]
;;;3713       /* The critical values for drawing the bar */
;;;3714       rmp_ptr_t Old_Pivot;
;;;3715       rmp_ptr_t New_Pivot;
;;;3716       
;;;3717       /* If things does not change, return to save time */
;;;3718       if(Old_Prog==New_Prog)
000010  e9dd010d          LDRD     r0,r1,[sp,#0x34]
000014  4288              CMP      r0,r1
000016  d101              BNE      |L32.28|
                  |L32.24|
;;;3719           return;
;;;3720       
;;;3721       switch(Style)
;;;3722       {
;;;3723           case RMP_PBAR_L2R:
;;;3724           {
;;;3725               Old_Pivot=(Length-2)*Old_Prog/100;
;;;3726               New_Pivot=(Length-2)*New_Prog/100;
;;;3727               /* Progress decreased */
;;;3728               if(Old_Pivot>New_Pivot)
;;;3729                   RMP_Rectangle(Coord_X+1+New_Pivot,Coord_Y+1,Old_Pivot-New_Pivot,Width-2,Back,Back);
;;;3730               /* Progress increased */
;;;3731               else
;;;3732                   RMP_Rectangle(Coord_X+1+Old_Pivot,Coord_Y+1,New_Pivot-Old_Pivot,Width-2,Fore,Fore);
;;;3733               break;
;;;3734           }
;;;3735           case RMP_PBAR_D2U:
;;;3736           {
;;;3737               Old_Pivot=(Width-2)*Old_Prog/100;
;;;3738               New_Pivot=(Width-2)*New_Prog/100;
;;;3739               /* Progress decreased */
;;;3740               if(Old_Pivot>New_Pivot)
;;;3741                   RMP_Rectangle(Coord_X+1,Coord_Y-1+Width-Old_Pivot,Length-2,Old_Pivot-New_Pivot,Back,Back);
;;;3742               /* Progress increased */
;;;3743               else
;;;3744                   RMP_Rectangle(Coord_X+1,Coord_Y-1+Width-New_Pivot,Length-2,New_Pivot-Old_Pivot,Fore,Fore);
;;;3745               break;
;;;3746           }
;;;3747           case RMP_PBAR_R2L:
;;;3748           {
;;;3749               Old_Pivot=(Length-2)*Old_Prog/100;
;;;3750               New_Pivot=(Length-2)*New_Prog/100;
;;;3751               /* Progress decreased */
;;;3752               if(Old_Pivot>New_Pivot)
;;;3753                   RMP_Rectangle(Coord_X-1+Length-Old_Pivot,Coord_Y+1,Old_Pivot-New_Pivot,Width-2,Back,Back);
;;;3754               /* Progress increased */
;;;3755               else
;;;3756                   RMP_Rectangle(Coord_X-1+Length-New_Pivot,Coord_Y+1,New_Pivot-Old_Pivot,Width-2,Fore,Fore);
;;;3757               break;
;;;3758           }
;;;3759           case RMP_PBAR_U2D:
;;;3760           {
;;;3761               Old_Pivot=(Width-2)*Old_Prog/100;
;;;3762               New_Pivot=(Width-2)*New_Prog/100;
;;;3763               /* Progress decreased */
;;;3764               if(Old_Pivot>New_Pivot)
;;;3765                   RMP_Rectangle(Coord_X+1,Coord_Y+1+New_Pivot,Length-2,Old_Pivot-New_Pivot,Back,Back);
;;;3766               /* Progress increased */
;;;3767               else
;;;3768                   RMP_Rectangle(Coord_X+1,Coord_Y+1+Old_Pivot,Length-2,New_Pivot-Old_Pivot,Fore,Fore);
;;;3769               break;
;;;3770           }
;;;3771           default: break;
;;;3772       }
;;;3773   }
000018  e8bd9ffc          POP      {r2-r12,pc}
                  |L32.28|
00001c  980c              LDR      r0,[sp,#0x30]         ;3721
00001e  b130              CBZ      r0,|L32.46|
000020  2801              CMP      r0,#1                 ;3721
000022  d02e              BEQ      |L32.130|
000024  2802              CMP      r0,#2                 ;3721
000026  d058              BEQ      |L32.218|
000028  2803              CMP      r0,#3                 ;3721
00002a  d173              BNE      |L32.276|
00002c  e082              B        |L32.308|
                  |L32.46|
00002e  1eb0              SUBS     r0,r6,#2              ;3725
000030  990d              LDR      r1,[sp,#0x34]         ;3725
000032  4348              MULS     r0,r1,r0              ;3725
000034  2164              MOVS     r1,#0x64              ;3725
000036  fb90f4f1          SDIV     r4,r0,r1              ;3725
00003a  1eb0              SUBS     r0,r6,#2              ;3726
00003c  990e              LDR      r1,[sp,#0x38]         ;3726
00003e  4348              MULS     r0,r1,r0              ;3726
000040  2164              MOVS     r1,#0x64              ;3726
000042  fb90f5f1          SDIV     r5,r0,r1              ;3726
000046  42ac              CMP      r4,r5                 ;3728
000048  d90d              BLS      |L32.102|
00004a  f8cdb000          STR      r11,[sp,#0]           ;3729
00004e  1ebb              SUBS     r3,r7,#2              ;3729
000050  1b62              SUBS     r2,r4,r5              ;3729
000052  f1080101          ADD      r1,r8,#1              ;3729
000056  1948              ADDS     r0,r1,r5              ;3729
000058  f1090101          ADD      r1,r9,#1              ;3729
00005c  f8cdb004          STR      r11,[sp,#4]           ;3729
000060  f7fffffe          BL       RMP_Rectangle
000064  e00c              B        |L32.128|
                  |L32.102|
000066  f8cda000          STR      r10,[sp,#0]           ;3732
00006a  1ebb              SUBS     r3,r7,#2              ;3732
00006c  1b2a              SUBS     r2,r5,r4              ;3732
00006e  f1080101          ADD      r1,r8,#1              ;3732
000072  1908              ADDS     r0,r1,r4              ;3732
000074  f1090101          ADD      r1,r9,#1              ;3732
000078  f8cda004          STR      r10,[sp,#4]           ;3732
00007c  f7fffffe          BL       RMP_Rectangle
                  |L32.128|
000080  e083              B        |L32.394|
                  |L32.130|
000082  1eb8              SUBS     r0,r7,#2              ;3737
000084  990d              LDR      r1,[sp,#0x34]         ;3737
000086  4348              MULS     r0,r1,r0              ;3737
000088  2164              MOVS     r1,#0x64              ;3737
00008a  fb90f4f1          SDIV     r4,r0,r1              ;3737
00008e  1eb8              SUBS     r0,r7,#2              ;3738
000090  990e              LDR      r1,[sp,#0x38]         ;3738
000092  4348              MULS     r0,r1,r0              ;3738
000094  2164              MOVS     r1,#0x64              ;3738
000096  fb90f5f1          SDIV     r5,r0,r1              ;3738
00009a  42ac              CMP      r4,r5                 ;3740
00009c  d90e              BLS      |L32.188|
00009e  f8cdb000          STR      r11,[sp,#0]           ;3741
0000a2  1b63              SUBS     r3,r4,r5              ;3741
0000a4  1eb2              SUBS     r2,r6,#2              ;3741
0000a6  f1a90001          SUB      r0,r9,#1              ;3741
0000aa  4438              ADD      r0,r0,r7              ;3741
0000ac  1b01              SUBS     r1,r0,r4              ;3741
0000ae  f1080001          ADD      r0,r8,#1              ;3741
0000b2  f8cdb004          STR      r11,[sp,#4]           ;3741
0000b6  f7fffffe          BL       RMP_Rectangle
0000ba  e00d              B        |L32.216|
                  |L32.188|
0000bc  f8cda000          STR      r10,[sp,#0]           ;3744
0000c0  1b2b              SUBS     r3,r5,r4              ;3744
0000c2  1eb2              SUBS     r2,r6,#2              ;3744
0000c4  f1a90001          SUB      r0,r9,#1              ;3744
0000c8  4438              ADD      r0,r0,r7              ;3744
0000ca  1b41              SUBS     r1,r0,r5              ;3744
0000cc  f1080001          ADD      r0,r8,#1              ;3744
0000d0  f8cda004          STR      r10,[sp,#4]           ;3744
0000d4  f7fffffe          BL       RMP_Rectangle
                  |L32.216|
0000d8  e057              B        |L32.394|
                  |L32.218|
0000da  1eb0              SUBS     r0,r6,#2              ;3749
0000dc  990d              LDR      r1,[sp,#0x34]         ;3749
0000de  4348              MULS     r0,r1,r0              ;3749
0000e0  2164              MOVS     r1,#0x64              ;3749
0000e2  fb90f4f1          SDIV     r4,r0,r1              ;3749
0000e6  1eb0              SUBS     r0,r6,#2              ;3750
0000e8  990e              LDR      r1,[sp,#0x38]         ;3750
0000ea  4348              MULS     r0,r1,r0              ;3750
0000ec  2164              MOVS     r1,#0x64              ;3750
0000ee  fb90f5f1          SDIV     r5,r0,r1              ;3750
0000f2  42ac              CMP      r4,r5                 ;3752
0000f4  d90f              BLS      |L32.278|
0000f6  f8cdb000          STR      r11,[sp,#0]           ;3753
0000fa  1ebb              SUBS     r3,r7,#2              ;3753
0000fc  1b62              SUBS     r2,r4,r5              ;3753
0000fe  f1a80101          SUB      r1,r8,#1              ;3753
000102  4431              ADD      r1,r1,r6              ;3753
000104  1b08              SUBS     r0,r1,r4              ;3753
000106  f1090101          ADD      r1,r9,#1              ;3753
00010a  f8cdb004          STR      r11,[sp,#4]           ;3753
00010e  f7fffffe          BL       RMP_Rectangle
000112  e00e              B        |L32.306|
                  |L32.276|
000114  e038              B        |L32.392|
                  |L32.278|
000116  f8cda000          STR      r10,[sp,#0]           ;3756
00011a  1ebb              SUBS     r3,r7,#2              ;3756
00011c  1b2a              SUBS     r2,r5,r4              ;3756
00011e  f1a80101          SUB      r1,r8,#1              ;3756
000122  4431              ADD      r1,r1,r6              ;3756
000124  1b48              SUBS     r0,r1,r5              ;3756
000126  f1090101          ADD      r1,r9,#1              ;3756
00012a  f8cda004          STR      r10,[sp,#4]           ;3756
00012e  f7fffffe          BL       RMP_Rectangle
                  |L32.306|
000132  e02a              B        |L32.394|
                  |L32.308|
000134  1eb8              SUBS     r0,r7,#2              ;3761
000136  990d              LDR      r1,[sp,#0x34]         ;3761
000138  4348              MULS     r0,r1,r0              ;3761
00013a  2164              MOVS     r1,#0x64              ;3761
00013c  fb90f4f1          SDIV     r4,r0,r1              ;3761
000140  1eb8              SUBS     r0,r7,#2              ;3762
000142  990e              LDR      r1,[sp,#0x38]         ;3762
000144  4348              MULS     r0,r1,r0              ;3762
000146  2164              MOVS     r1,#0x64              ;3762
000148  fb90f5f1          SDIV     r5,r0,r1              ;3762
00014c  42ac              CMP      r4,r5                 ;3764
00014e  d90d              BLS      |L32.364|
000150  f8cdb000          STR      r11,[sp,#0]           ;3765
000154  1b63              SUBS     r3,r4,r5              ;3765
000156  1eb2              SUBS     r2,r6,#2              ;3765
000158  f1090001          ADD      r0,r9,#1              ;3765
00015c  1941              ADDS     r1,r0,r5              ;3765
00015e  f1080001          ADD      r0,r8,#1              ;3765
000162  f8cdb004          STR      r11,[sp,#4]           ;3765
000166  f7fffffe          BL       RMP_Rectangle
00016a  e00c              B        |L32.390|
                  |L32.364|
00016c  f8cda000          STR      r10,[sp,#0]           ;3768
000170  1b2b              SUBS     r3,r5,r4              ;3768
000172  1eb2              SUBS     r2,r6,#2              ;3768
000174  f1090001          ADD      r0,r9,#1              ;3768
000178  1901              ADDS     r1,r0,r4              ;3768
00017a  f1080001          ADD      r0,r8,#1              ;3768
00017e  f8cda004          STR      r10,[sp,#4]           ;3768
000182  f7fffffe          BL       RMP_Rectangle
                  |L32.390|
000186  e000              B        |L32.394|
                  |L32.392|
000188  bf00              NOP                            ;3771
                  |L32.394|
00018a  bf00              NOP                            ;3733
00018c  bf00              NOP      
00018e  e743              B        |L32.24|
;;;3774   /* End Function:RMP_Progbar_Set **********************************************/
                          ENDP


                          AREA ||i.RMP_RBIT_Get||, CODE, READONLY, ALIGN=2

                  RMP_RBIT_Get PROC
;;;2078   
;;;2079   rmp_ptr_t RMP_RBIT_Get(rmp_ptr_t Val)
000000  b51c              PUSH     {r2-r4,lr}
;;;2080   {
000002  4603              MOV      r3,r0
;;;2081       rmp_ptr_t Ret;
;;;2082       rmp_ptr_t Src;
;;;2083       rmp_u8_t* To;
;;;2084       rmp_u8_t* From;
;;;2085       
;;;2086       Src=Val;
000004  9300              STR      r3,[sp,#0]
;;;2087       To=(rmp_u8_t*)(&Ret);
000006  a901              ADD      r1,sp,#4
;;;2088       From=(rmp_u8_t*)(&Src);
000008  466a              MOV      r2,sp
;;;2089       
;;;2090   #if(RMP_WORD_ORDER==4)
;;;2091       To[0]=RMP_RBIT_Table[From[1]];
;;;2092       To[1]=RMP_RBIT_Table[From[0]];
;;;2093   #elif(RMP_WORD_ORDER==5)
;;;2094       To[0]=RMP_RBIT_Table[From[3]];
00000a  78d0              LDRB     r0,[r2,#3]
00000c  4c06              LDR      r4,|L33.40|
00000e  5c20              LDRB     r0,[r4,r0]
000010  7008              STRB     r0,[r1,#0]
;;;2095       To[1]=RMP_RBIT_Table[From[2]];
000012  7890              LDRB     r0,[r2,#2]
000014  5c20              LDRB     r0,[r4,r0]
000016  7048              STRB     r0,[r1,#1]
;;;2096       To[2]=RMP_RBIT_Table[From[1]];
000018  7850              LDRB     r0,[r2,#1]
00001a  5c20              LDRB     r0,[r4,r0]
00001c  7088              STRB     r0,[r1,#2]
;;;2097       To[3]=RMP_RBIT_Table[From[0]];
00001e  7810              LDRB     r0,[r2,#0]
000020  5c20              LDRB     r0,[r4,r0]
000022  70c8              STRB     r0,[r1,#3]
;;;2098   #else
;;;2099       To[0]=RMP_RBIT_Table[From[7]];
;;;2100       To[1]=RMP_RBIT_Table[From[6]];
;;;2101       To[2]=RMP_RBIT_Table[From[5]];
;;;2102       To[3]=RMP_RBIT_Table[From[4]];
;;;2103       To[4]=RMP_RBIT_Table[From[3]];
;;;2104       To[5]=RMP_RBIT_Table[From[2]];
;;;2105       To[6]=RMP_RBIT_Table[From[1]];
;;;2106       To[7]=RMP_RBIT_Table[From[0]];
;;;2107   #endif
;;;2108   
;;;2109       return Ret;
000024  9801              LDR      r0,[sp,#4]
;;;2110   }
000026  bd1c              POP      {r2-r4,pc}
;;;2111   /* End Function:RMP_RBIT_Get *************************************************/
                          ENDP

                  |L33.40|
                          DCD      RMP_RBIT_Table

                          AREA ||i.RMP_Radiobtn||, CODE, READONLY, ALIGN=1

                  RMP_Radiobtn PROC
;;;3681   ******************************************************************************/
;;;3682   void RMP_Radiobtn(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_ptr_t Status)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;3683   {   
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
;;;3684       /* Fill the area with rect */
;;;3685       RMP_Rectangle(Coord_X,Coord_Y,Length,Length,RMP_CTL_GREY,RMP_CTL_GREY);
00000c  f64b50d7          MOV      r0,#0xbdd7
000010  9000              STR      r0,[sp,#0]
000012  4623              MOV      r3,r4
000014  4622              MOV      r2,r4
000016  4639              MOV      r1,r7
000018  9001              STR      r0,[sp,#4]
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       RMP_Rectangle
;;;3686       
;;;3687       /* Draw the circle first */
;;;3688       RMP_Radiobtn_Circle(Coord_X,Coord_Y,Length);
000020  4622              MOV      r2,r4
000022  4639              MOV      r1,r7
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       RMP_Radiobtn_Circle
;;;3689       
;;;3690       /* See if the radio button is selected */
;;;3691       if(Status==RMP_RBTN_SEL)
00002a  2d01              CMP      r5,#1
00002c  d104              BNE      |L34.56|
;;;3692           RMP_Radiobtn_Set(Coord_X, Coord_Y, Length);
00002e  4622              MOV      r2,r4
000030  4639              MOV      r1,r7
000032  4630              MOV      r0,r6
000034  f7fffffe          BL       RMP_Radiobtn_Set
                  |L34.56|
;;;3693   }
000038  e8bd81fc          POP      {r2-r8,pc}
;;;3694   /* End Function:RMP_Radiobtn *************************************************/
                          ENDP


                          AREA ||i.RMP_Radiobtn_Circle||, CODE, READONLY, ALIGN=1

                  RMP_Radiobtn_Circle PROC
;;;3566   ******************************************************************************/
;;;3567   void RMP_Radiobtn_Circle(rmp_cnt_t Coord_X,rmp_cnt_t Coord_Y,rmp_cnt_t Length)
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;3568   {   
000004  4682              MOV      r10,r0
000006  468b              MOV      r11,r1
;;;3569       rmp_cnt_t Radius;
;;;3570       rmp_cnt_t Center_X;
;;;3571       rmp_cnt_t Center_Y;
;;;3572       rmp_cnt_t Cur_X;
;;;3573       rmp_cnt_t Cur_Y;
;;;3574       rmp_cnt_t Error;
;;;3575       
;;;3576       /* The radius is the length/2 */
;;;3577       Radius=Length>>1;
000008  9802              LDR      r0,[sp,#8]
00000a  ea4f0860          ASR      r8,r0,#1
;;;3578       Center_X=Coord_X+Radius;
00000e  eb0a0608          ADD      r6,r10,r8
;;;3579       Center_Y=Coord_Y+Radius;
000012  eb0b0708          ADD      r7,r11,r8
;;;3580       
;;;3581       /* Now we begin to draw the inner halfcircle */
;;;3582       Cur_X=0;
000016  2400              MOVS     r4,#0
;;;3583       Cur_Y=Radius-1;
000018  f1a80501          SUB      r5,r8,#1
;;;3584       Error=3-((Radius-1)<<1);  
00001c  4628              MOV      r0,r5
00001e  2103              MOVS     r1,#3
000020  eba10940          SUB      r9,r1,r0,LSL #1
;;;3585       
;;;3586       while(Cur_X<=Cur_Y) 
000024  e03c              B        |L35.160|
                  |L35.38|
;;;3587       {  
;;;3588           /* This is the upper-left part */
;;;3589           RMP_POINT(Center_X+Cur_X,Center_Y-Cur_Y,RMP_CTL_DDARK);
000026  1b79              SUBS     r1,r7,r5
000028  1930              ADDS     r0,r6,r4
00002a  f646324d          MOV      r2,#0x6b4d
00002e  f7fffffe          BL       RMP_Point
;;;3590           RMP_POINT(Center_X-Cur_X,Center_Y-Cur_Y,RMP_CTL_DDARK);
000032  1b79              SUBS     r1,r7,r5
000034  1b30              SUBS     r0,r6,r4
000036  f646324d          MOV      r2,#0x6b4d
00003a  f7fffffe          BL       RMP_Point
;;;3591           RMP_POINT(Center_X-Cur_Y,Center_Y-Cur_X,RMP_CTL_DDARK);
00003e  1b39              SUBS     r1,r7,r4
000040  1b70              SUBS     r0,r6,r5
000042  f646324d          MOV      r2,#0x6b4d
000046  f7fffffe          BL       RMP_Point
;;;3592           RMP_POINT(Center_X-Cur_Y,Center_Y+Cur_X,RMP_CTL_DDARK);
00004a  1939              ADDS     r1,r7,r4
00004c  1b70              SUBS     r0,r6,r5
00004e  f646324d          MOV      r2,#0x6b4d
000052  f7fffffe          BL       RMP_Point
;;;3593           
;;;3594           /* This is the lower-right part */
;;;3595           RMP_POINT(Center_X+Cur_X,Center_Y+Cur_Y,RMP_CTL_LGREY);
000056  1979              ADDS     r1,r7,r5
000058  1930              ADDS     r0,r6,r4
00005a  f24e721c          MOV      r2,#0xe71c
00005e  f7fffffe          BL       RMP_Point
;;;3596           RMP_POINT(Center_X-Cur_X,Center_Y+Cur_Y,RMP_CTL_LGREY);  
000062  1979              ADDS     r1,r7,r5
000064  1b30              SUBS     r0,r6,r4
000066  f24e721c          MOV      r2,#0xe71c
00006a  f7fffffe          BL       RMP_Point
;;;3597           RMP_POINT(Center_X+Cur_Y,Center_Y+Cur_X,RMP_CTL_LGREY); 
00006e  1939              ADDS     r1,r7,r4
000070  1970              ADDS     r0,r6,r5
000072  f24e721c          MOV      r2,#0xe71c
000076  f7fffffe          BL       RMP_Point
;;;3598           RMP_POINT(Center_X+Cur_Y,Center_Y-Cur_X,RMP_CTL_LGREY);  
00007a  1b39              SUBS     r1,r7,r4
00007c  1970              ADDS     r0,r6,r5
00007e  f24e721c          MOV      r2,#0xe71c
000082  f7fffffe          BL       RMP_Point
;;;3599           
;;;3600           if(Error<0) 
000086  f1b90f00          CMP      r9,#0
00008a  da04              BGE      |L35.150|
;;;3601           {
;;;3602               Error=Error+(Cur_X<<2)+6;
00008c  eb090084          ADD      r0,r9,r4,LSL #2
000090  f1000906          ADD      r9,r0,#6
000094  e003              B        |L35.158|
                  |L35.150|
;;;3603           }
;;;3604           else 
;;;3605           {
;;;3606               Error=Error+((Cur_X-Cur_Y)<<2);
000096  1b60              SUBS     r0,r4,r5
000098  eb090980          ADD      r9,r9,r0,LSL #2
;;;3607               Cur_Y--;
00009c  1e6d              SUBS     r5,r5,#1
                  |L35.158|
;;;3608           }
;;;3609           Cur_X++;
00009e  1c64              ADDS     r4,r4,#1
                  |L35.160|
0000a0  42ac              CMP      r4,r5                 ;3586
0000a2  ddc0              BLE      |L35.38|
;;;3610       } 
;;;3611       
;;;3612       /* Now we begin to draw the outer halfcircle */
;;;3613       Cur_X=0;
0000a4  2400              MOVS     r4,#0
;;;3614       Cur_Y=Radius;
0000a6  4645              MOV      r5,r8
;;;3615       Error=3-(Radius<<1);  
0000a8  2003              MOVS     r0,#3
0000aa  eba00948          SUB      r9,r0,r8,LSL #1
;;;3616       
;;;3617       while(Cur_X<=Cur_Y) 
0000ae  e03c              B        |L35.298|
                  |L35.176|
;;;3618       {  
;;;3619           /* This is the upper-left part */
;;;3620           RMP_POINT(Center_X+Cur_X,Center_Y-Cur_Y,RMP_CTL_DGREY);
0000b0  1b79              SUBS     r1,r7,r5
0000b2  1930              ADDS     r0,r6,r4
0000b4  f24a5214          MOV      r2,#0xa514
0000b8  f7fffffe          BL       RMP_Point
;;;3621           RMP_POINT(Center_X-Cur_X,Center_Y-Cur_Y,RMP_CTL_DGREY);
0000bc  1b79              SUBS     r1,r7,r5
0000be  1b30              SUBS     r0,r6,r4
0000c0  f24a5214          MOV      r2,#0xa514
0000c4  f7fffffe          BL       RMP_Point
;;;3622           RMP_POINT(Center_X-Cur_Y,Center_Y-Cur_X,RMP_CTL_DGREY);
0000c8  1b39              SUBS     r1,r7,r4
0000ca  1b70              SUBS     r0,r6,r5
0000cc  f24a5214          MOV      r2,#0xa514
0000d0  f7fffffe          BL       RMP_Point
;;;3623           RMP_POINT(Center_X-Cur_Y,Center_Y+Cur_X,RMP_CTL_DGREY);
0000d4  1939              ADDS     r1,r7,r4
0000d6  1b70              SUBS     r0,r6,r5
0000d8  f24a5214          MOV      r2,#0xa514
0000dc  f7fffffe          BL       RMP_Point
;;;3624           
;;;3625           /* This is the lower-right part */
;;;3626           RMP_POINT(Center_X+Cur_X,Center_Y+Cur_Y,RMP_CTL_WHITE);
0000e0  1979              ADDS     r1,r7,r5
0000e2  1930              ADDS     r0,r6,r4
0000e4  f64f72ff          MOV      r2,#0xffff
0000e8  f7fffffe          BL       RMP_Point
;;;3627           RMP_POINT(Center_X-Cur_X,Center_Y+Cur_Y,RMP_CTL_WHITE);  
0000ec  1979              ADDS     r1,r7,r5
0000ee  1b30              SUBS     r0,r6,r4
0000f0  f64f72ff          MOV      r2,#0xffff
0000f4  f7fffffe          BL       RMP_Point
;;;3628           RMP_POINT(Center_X+Cur_Y,Center_Y+Cur_X,RMP_CTL_WHITE); 
0000f8  1939              ADDS     r1,r7,r4
0000fa  1970              ADDS     r0,r6,r5
0000fc  f64f72ff          MOV      r2,#0xffff
000100  f7fffffe          BL       RMP_Point
;;;3629           RMP_POINT(Center_X+Cur_Y,Center_Y-Cur_X,RMP_CTL_WHITE);  
000104  1b39              SUBS     r1,r7,r4
000106  1970              ADDS     r0,r6,r5
000108  f64f72ff          MOV      r2,#0xffff
00010c  f7fffffe          BL       RMP_Point
;;;3630           
;;;3631           if(Error<0) 
000110  f1b90f00          CMP      r9,#0
000114  da04              BGE      |L35.288|
;;;3632           {  
;;;3633               Error=Error+(Cur_X<<2)+6;  
000116  eb090084          ADD      r0,r9,r4,LSL #2
00011a  f1000906          ADD      r9,r0,#6
00011e  e003              B        |L35.296|
                  |L35.288|
;;;3634           } 
;;;3635           else 
;;;3636           {  
;;;3637               Error=Error+((Cur_X-Cur_Y)<<2);  
000120  1b60              SUBS     r0,r4,r5
000122  eb090980          ADD      r9,r9,r0,LSL #2
;;;3638               Cur_Y--;  
000126  1e6d              SUBS     r5,r5,#1
                  |L35.296|
;;;3639           }  
;;;3640           Cur_X++;  
000128  1c64              ADDS     r4,r4,#1
                  |L35.298|
00012a  42ac              CMP      r4,r5                 ;3617
00012c  ddc0              BLE      |L35.176|
;;;3641       } 
;;;3642   }
00012e  e8bd8ffe          POP      {r1-r11,pc}
;;;3643   /* End Function:RMP_Radiobtn_Circle ******************************************/
                          ENDP


                          AREA ||i.RMP_Radiobtn_Clr||, CODE, READONLY, ALIGN=1

                  RMP_Radiobtn_Clr PROC
;;;3666   ******************************************************************************/
;;;3667   void RMP_Radiobtn_Clr(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;3668   {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
;;;3669       RMP_Circle(Coord_X+Length/2,Coord_Y+Length/2,Length/6,RMP_CTL_GREY,RMP_CTL_GREY);
00000a  2006              MOVS     r0,#6
00000c  fb94f9f0          SDIV     r9,r4,r0
000010  f64b50d7          MOV      r0,#0xbdd7
000014  4625              MOV      r5,r4
000016  eb0472d5          ADD      r2,r4,r5,LSR #31
00001a  eb070162          ADD      r1,r7,r2,ASR #1
00001e  46a0              MOV      r8,r4
000020  eb0472d8          ADD      r2,r4,r8,LSR #31
000024  9000              STR      r0,[sp,#0]
000026  eb060062          ADD      r0,r6,r2,ASR #1
00002a  f64b53d7          MOV      r3,#0xbdd7
00002e  464a              MOV      r2,r9
000030  f7fffffe          BL       RMP_Circle
;;;3670   }
000034  e8bd83f8          POP      {r3-r9,pc}
;;;3671   /* End Function:RMP_Radiobtn_Clr *********************************************/
                          ENDP


                          AREA ||i.RMP_Radiobtn_Set||, CODE, READONLY, ALIGN=1

                  RMP_Radiobtn_Set PROC
;;;3652   ******************************************************************************/
;;;3653   void RMP_Radiobtn_Set(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;3654   {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
;;;3655       RMP_Circle(Coord_X+Length/2,Coord_Y+Length/2,Length/6,RMP_CTL_BLACK,RMP_CTL_BLACK);
00000a  2006              MOVS     r0,#6
00000c  fb94f9f0          SDIV     r9,r4,r0
000010  2000              MOVS     r0,#0
000012  4625              MOV      r5,r4
000014  eb0472d5          ADD      r2,r4,r5,LSR #31
000018  eb070162          ADD      r1,r7,r2,ASR #1
00001c  46a0              MOV      r8,r4
00001e  eb0472d8          ADD      r2,r4,r8,LSR #31
000022  9000              STR      r0,[sp,#0]
000024  eb060062          ADD      r0,r6,r2,ASR #1
000028  2300              MOVS     r3,#0
00002a  464a              MOV      r2,r9
00002c  f7fffffe          BL       RMP_Circle
;;;3656   }
000030  e8bd83f8          POP      {r3-r9,pc}
;;;3657   /* End Function:RMP_Radiobtn_Set *********************************************/
                          ENDP


                          AREA ||i.RMP_Rectangle||, CODE, READONLY, ALIGN=1

                  RMP_Rectangle PROC
;;;2810   ******************************************************************************/
;;;2811   void RMP_Rectangle(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width, rmp_ptr_t Border, rmp_ptr_t Fill)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;2812   {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  e9dd8a0a          LDRD     r8,r10,[sp,#0x28]
;;;2813       rmp_cnt_t Line_Cnt;
;;;2814       
;;;2815       if(Fill!=RMP_TRANS)
000010  f1ba0f01          CMP      r10,#1
000014  d011              BEQ      |L38.58|
;;;2816       {
;;;2817           for(Line_Cnt=0;Line_Cnt<Width;Line_Cnt++)
000016  f04f0900          MOV      r9,#0
00001a  e00c              B        |L38.54|
                  |L38.28|
;;;2818               RMP_Line(Coord_X,Coord_Y+Line_Cnt,Coord_X+Length-1,Coord_Y+Line_Cnt,Fill);
00001c  eb040309          ADD      r3,r4,r9
000020  19a8              ADDS     r0,r5,r6
000022  1e42              SUBS     r2,r0,#1
000024  eb040109          ADD      r1,r4,r9
000028  4628              MOV      r0,r5
00002a  f8cda000          STR      r10,[sp,#0]
00002e  f7fffffe          BL       RMP_Line
000032  f1090901          ADD      r9,r9,#1              ;2817
                  |L38.54|
000036  45b9              CMP      r9,r7                 ;2817
000038  dbf0              BLT      |L38.28|
                  |L38.58|
;;;2819       }
;;;2820   
;;;2821       if(Border!=RMP_TRANS)
00003a  f1b80f01          CMP      r8,#1
00003e  d027              BEQ      |L38.144|
;;;2822       {
;;;2823           RMP_Line(Coord_X,Coord_Y,Coord_X+Length-1,Coord_Y,Border);
000040  19a8              ADDS     r0,r5,r6
000042  1e42              SUBS     r2,r0,#1
000044  4623              MOV      r3,r4
000046  4621              MOV      r1,r4
000048  4628              MOV      r0,r5
00004a  f8cd8000          STR      r8,[sp,#0]
00004e  f7fffffe          BL       RMP_Line
;;;2824           RMP_Line(Coord_X+Length-1,Coord_Y,Coord_X+Length-1,Coord_Y+Width-1,Border);
000052  19e1              ADDS     r1,r4,r7
000054  1e4b              SUBS     r3,r1,#1
000056  19a9              ADDS     r1,r5,r6
000058  1e4a              SUBS     r2,r1,#1
00005a  19a9              ADDS     r1,r5,r6
00005c  1e48              SUBS     r0,r1,#1
00005e  4621              MOV      r1,r4
000060  f8cd8000          STR      r8,[sp,#0]
000064  f7fffffe          BL       RMP_Line
;;;2825           RMP_Line(Coord_X+Length-1,Coord_Y+Width-1,Coord_X,Coord_Y+Width-1,Border);
000068  19e2              ADDS     r2,r4,r7
00006a  1e53              SUBS     r3,r2,#1
00006c  19e2              ADDS     r2,r4,r7
00006e  1e51              SUBS     r1,r2,#1
000070  19aa              ADDS     r2,r5,r6
000072  1e50              SUBS     r0,r2,#1
000074  462a              MOV      r2,r5
000076  f8cd8000          STR      r8,[sp,#0]
00007a  f7fffffe          BL       RMP_Line
;;;2826           RMP_Line(Coord_X,Coord_Y+Width-1,Coord_X,Coord_Y,Border);
00007e  19e0              ADDS     r0,r4,r7
000080  1e41              SUBS     r1,r0,#1
000082  4623              MOV      r3,r4
000084  462a              MOV      r2,r5
000086  4628              MOV      r0,r5
000088  f8cd8000          STR      r8,[sp,#0]
00008c  f7fffffe          BL       RMP_Line
                  |L38.144|
;;;2827       }
;;;2828   }
000090  e8bd8ff8          POP      {r3-r11,pc}
;;;2829   /* End Function:RMP_Rectangle ************************************************/
                          ENDP


                          AREA ||i.RMP_Round_Rect||, CODE, READONLY, ALIGN=1

                  RMP_Round_Rect PROC
;;;2842   ******************************************************************************/
;;;2843   void RMP_Round_Rect(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width, 
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;2844                       rmp_cnt_t Round, rmp_ptr_t Fore, rmp_ptr_t Back)
;;;2845   {
000004  b085              SUB      sp,sp,#0x14
000006  4607              MOV      r7,r0
000008  4688              MOV      r8,r1
00000a  4693              MOV      r11,r2
00000c  e9dd6513          LDRD     r6,r5,[sp,#0x4c]
000010  9c12              LDR      r4,[sp,#0x48]
;;;2846       rmp_cnt_t Cir_X_0;
;;;2847       rmp_cnt_t Cir_X_1;
;;;2848       rmp_cnt_t Cir_Y_0;
;;;2849       rmp_cnt_t Cir_Y_1;
;;;2850       
;;;2851       Cir_X_0=Coord_X+Round+1;
000012  1938              ADDS     r0,r7,r4
000014  f1000901          ADD      r9,r0,#1
;;;2852       Cir_X_1=Coord_X+Length-Round-1;
000018  eb07000b          ADD      r0,r7,r11
00001c  1b00              SUBS     r0,r0,r4
00001e  1e40              SUBS     r0,r0,#1
000020  9004              STR      r0,[sp,#0x10]
;;;2853       Cir_Y_0=Coord_Y+Round+1;
000022  eb080004          ADD      r0,r8,r4
000026  f1000a01          ADD      r10,r0,#1
;;;2854       Cir_Y_1=Coord_Y+Width-Round-1;
00002a  9808              LDR      r0,[sp,#0x20]
00002c  4440              ADD      r0,r0,r8
00002e  1b00              SUBS     r0,r0,r4
000030  1e40              SUBS     r0,r0,#1
000032  9003              STR      r0,[sp,#0xc]
;;;2855       
;;;2856       RMP_Rectangle(Coord_X,Coord_Y,Length,Width,Fore,Fore);
000034  9600              STR      r6,[sp,#0]
000036  9601              STR      r6,[sp,#4]
000038  465a              MOV      r2,r11
00003a  4641              MOV      r1,r8
00003c  4638              MOV      r0,r7
00003e  9b08              LDR      r3,[sp,#0x20]
000040  f7fffffe          BL       RMP_Rectangle
;;;2857       
;;;2858       RMP_Rectangle(Cir_X_0-Round-1,Cir_Y_0-Round-1,Round+1,Round+1,Back,Back);
000044  9500              STR      r5,[sp,#0]
000046  ebaa0204          SUB      r2,r10,r4
00004a  1e51              SUBS     r1,r2,#1
00004c  eba90204          SUB      r2,r9,r4
000050  1e50              SUBS     r0,r2,#1
000052  1c63              ADDS     r3,r4,#1
000054  1c62              ADDS     r2,r4,#1
000056  9501              STR      r5,[sp,#4]
000058  f7fffffe          BL       RMP_Rectangle
;;;2859       RMP_Rectangle(Cir_X_1,Cir_Y_0-Round-1,Round+1,Round+1,Back,Back);
00005c  9500              STR      r5,[sp,#0]
00005e  ebaa0004          SUB      r0,r10,r4
000062  1e41              SUBS     r1,r0,#1
000064  1c63              ADDS     r3,r4,#1
000066  1c62              ADDS     r2,r4,#1
000068  9501              STR      r5,[sp,#4]
00006a  9804              LDR      r0,[sp,#0x10]
00006c  f7fffffe          BL       RMP_Rectangle
;;;2860       RMP_Rectangle(Cir_X_0-Round-1,Cir_Y_1,Round+1,Round+1,Back,Back);
000070  9500              STR      r5,[sp,#0]
000072  eba90104          SUB      r1,r9,r4
000076  1e48              SUBS     r0,r1,#1
000078  1c63              ADDS     r3,r4,#1
00007a  1c62              ADDS     r2,r4,#1
00007c  9501              STR      r5,[sp,#4]
00007e  9903              LDR      r1,[sp,#0xc]
000080  f7fffffe          BL       RMP_Rectangle
;;;2861       RMP_Rectangle(Cir_X_1,Cir_Y_1,Round+1,Round+1,Back,Back);
000084  9500              STR      r5,[sp,#0]
000086  1c63              ADDS     r3,r4,#1
000088  1c62              ADDS     r2,r4,#1
00008a  9501              STR      r5,[sp,#4]
00008c  e9dd1003          LDRD     r1,r0,[sp,#0xc]
000090  f7fffffe          BL       RMP_Rectangle
;;;2862       
;;;2863       RMP_Circle(Cir_X_0,Cir_Y_0,Round,Fore,Fore);
000094  4633              MOV      r3,r6
000096  4622              MOV      r2,r4
000098  4651              MOV      r1,r10
00009a  4648              MOV      r0,r9
00009c  9600              STR      r6,[sp,#0]
00009e  f7fffffe          BL       RMP_Circle
;;;2864       RMP_Circle(Cir_X_1,Cir_Y_0,Round,Fore,Fore);
0000a2  4633              MOV      r3,r6
0000a4  4622              MOV      r2,r4
0000a6  4651              MOV      r1,r10
0000a8  9600              STR      r6,[sp,#0]
0000aa  9804              LDR      r0,[sp,#0x10]
0000ac  f7fffffe          BL       RMP_Circle
;;;2865       RMP_Circle(Cir_X_0,Cir_Y_1,Round,Fore,Fore);
0000b0  4633              MOV      r3,r6
0000b2  4622              MOV      r2,r4
0000b4  9600              STR      r6,[sp,#0]
0000b6  4648              MOV      r0,r9
0000b8  9903              LDR      r1,[sp,#0xc]
0000ba  f7fffffe          BL       RMP_Circle
;;;2866       RMP_Circle(Cir_X_1,Cir_Y_1,Round,Fore,Fore);
0000be  4633              MOV      r3,r6
0000c0  4622              MOV      r2,r4
0000c2  9600              STR      r6,[sp,#0]
0000c4  e9dd1003          LDRD     r1,r0,[sp,#0xc]
0000c8  f7fffffe          BL       RMP_Circle
;;;2867   }
0000cc  b009              ADD      sp,sp,#0x24
0000ce  e8bd8ff0          POP      {r4-r11,pc}
;;;2868   /* End Function:RMP_Round_Rect ***********************************************/
                          ENDP


                          AREA ||i.RMP_Save_Ctx||, CODE, READONLY, ALIGN=1

                  RMP_Save_Ctx PROC
;;;1942   #if(RMP_USE_HOOKS==RMP_FALSE)
;;;1943   void RMP_Save_Ctx(void)
000000  4770              BX       lr
;;;1944   {
;;;1945       return;
;;;1946   }
;;;1947   #endif
                          ENDP


                          AREA ||i.RMP_Sem_Abort||, CODE, READONLY, ALIGN=1

                  RMP_Sem_Abort PROC
;;;1737   ******************************************************************************/
;;;1738   rmp_ret_t RMP_Sem_Abort(volatile struct RMP_Thd* Thread)
000000  b510              PUSH     {r4,lr}
;;;1739   {
000002  4604              MOV      r4,r0
;;;1740       /* Check if this thread structure could possibly be in use */
;;;1741       if(Thread==0)
000004  b924              CBNZ     r4,|L41.16|
;;;1742       {
;;;1743           RMP_COVERAGE_MARKER();
000006  bf00              NOP      
000008  bf00              NOP      
;;;1744           return RMP_ERR_THD;
00000a  f04f30ff          MOV      r0,#0xffffffff
                  |L41.14|
;;;1745       }
;;;1746       else
;;;1747           RMP_COVERAGE_MARKER();
;;;1748   
;;;1749       RMP_Lock_Sched();
;;;1750       
;;;1751       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;1752       {
;;;1753           RMP_COVERAGE_MARKER();
;;;1754           RMP_Unlock_Sched();
;;;1755           return RMP_ERR_THD;
;;;1756       }
;;;1757       else
;;;1758           RMP_COVERAGE_MARKER();
;;;1759       
;;;1760       /* Is it waiting on a semaphore? If no, we abort and return an error code */
;;;1761       if((RMP_THD_STATE(Thread->State)!=RMP_THD_SEMBLK)&&
;;;1762          (RMP_THD_STATE(Thread->State)!=RMP_THD_SEMDLY))
;;;1763       {
;;;1764           RMP_COVERAGE_MARKER();
;;;1765           RMP_Unlock_Sched();
;;;1766           return RMP_ERR_STATE;
;;;1767       }
;;;1768       else
;;;1769           RMP_COVERAGE_MARKER();
;;;1770   
;;;1771       /* Waiting for a semaphore. We abort it and return */
;;;1772       RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1773       if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1774       {
;;;1775           RMP_COVERAGE_MARKER();
;;;1776           RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1777       }
;;;1778       else
;;;1779           RMP_COVERAGE_MARKER();
;;;1780       
;;;1781       RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1782       /* Set to running if not suspended */
;;;1783       _RMP_Set_Rdy(Thread);
;;;1784       
;;;1785       Thread->Retval=RMP_ERR_OPER;
;;;1786       RMP_Unlock_Sched();
;;;1787       return 0;
;;;1788   }
00000e  bd10              POP      {r4,pc}
                  |L41.16|
000010  bf00              NOP                            ;1747
000012  bf00              NOP                            ;1747
000014  f7fffffe          BL       RMP_Lock_Sched
000018  69a0              LDR      r0,[r4,#0x18]         ;1751
00001a  b2c0              UXTB     r0,r0                 ;1751
00001c  b930              CBNZ     r0,|L41.44|
00001e  bf00              NOP                            ;1753
000020  bf00              NOP                            ;1753
000022  f7fffffe          BL       RMP_Unlock_Sched
000026  f04f30ff          MOV      r0,#0xffffffff        ;1755
00002a  e7f0              B        |L41.14|
                  |L41.44|
00002c  bf00              NOP                            ;1758
00002e  bf00              NOP                            ;1758
000030  69a0              LDR      r0,[r4,#0x18]         ;1761
000032  b2c0              UXTB     r0,r0                 ;1761
000034  2807              CMP      r0,#7                 ;1761
000036  d00a              BEQ      |L41.78|
000038  69a0              LDR      r0,[r4,#0x18]         ;1762
00003a  b2c0              UXTB     r0,r0                 ;1762
00003c  2808              CMP      r0,#8                 ;1762
00003e  d006              BEQ      |L41.78|
000040  bf00              NOP                            ;1764
000042  bf00              NOP                            ;1764
000044  f7fffffe          BL       RMP_Unlock_Sched
000048  f06f0003          MVN      r0,#3                 ;1766
00004c  e7df              B        |L41.14|
                  |L41.78|
00004e  bf00              NOP                            ;1769
000050  bf00              NOP                            ;1769
000052  6861              LDR      r1,[r4,#4]            ;1772
000054  6820              LDR      r0,[r4,#0]            ;1772
000056  f7fffffe          BL       RMP_List_Del
00005a  69a0              LDR      r0,[r4,#0x18]         ;1773
00005c  b2c0              UXTB     r0,r0                 ;1773
00005e  2808              CMP      r0,#8                 ;1773
000060  d106              BNE      |L41.112|
000062  bf00              NOP                            ;1775
000064  bf00              NOP                            ;1775
000066  68e1              LDR      r1,[r4,#0xc]          ;1776
000068  68a0              LDR      r0,[r4,#8]            ;1776
00006a  f7fffffe          BL       RMP_List_Del
00006e  e001              B        |L41.116|
                  |L41.112|
000070  bf00              NOP                            ;1779
000072  bf00              NOP                            ;1779
                  |L41.116|
000074  69a0              LDR      r0,[r4,#0x18]         ;1781
000076  f02000ff          BIC      r0,r0,#0xff           ;1781
00007a  1c40              ADDS     r0,r0,#1              ;1781
00007c  61a0              STR      r0,[r4,#0x18]         ;1781
00007e  4620              MOV      r0,r4                 ;1783
000080  f7fffffe          BL       _RMP_Set_Rdy
000084  f06f0004          MVN      r0,#4                 ;1785
000088  63a0              STR      r0,[r4,#0x38]         ;1785
00008a  f7fffffe          BL       RMP_Unlock_Sched
00008e  2000              MOVS     r0,#0                 ;1787
000090  e7bd              B        |L41.14|
;;;1789   /* End Function:RMP_Sem_Abort ************************************************/
                          ENDP


                          AREA ||i.RMP_Sem_Crt||, CODE, READONLY, ALIGN=1

                  RMP_Sem_Crt PROC
;;;1556   ******************************************************************************/
;;;1557   rmp_ret_t RMP_Sem_Crt(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Number)
000000  b570              PUSH     {r4-r6,lr}
;;;1558   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1559       /* Check if this semaphore structure could possibly be in use */
;;;1560       if(Semaphore==0)
000006  b924              CBNZ     r4,|L42.18|
;;;1561       {
;;;1562           RMP_COVERAGE_MARKER();
000008  bf00              NOP      
00000a  bf00              NOP      
;;;1563           return RMP_ERR_SEM;
00000c  f06f0005          MVN      r0,#5
                  |L42.16|
;;;1564       }
;;;1565       else
;;;1566           RMP_COVERAGE_MARKER();
;;;1567       
;;;1568       RMP_Lock_Sched();
;;;1569       
;;;1570       if(Semaphore->State!=RMP_SEM_FREE)
;;;1571       {
;;;1572           RMP_COVERAGE_MARKER();
;;;1573           RMP_Unlock_Sched();
;;;1574           return RMP_ERR_SEM;
;;;1575       }
;;;1576       else
;;;1577           RMP_COVERAGE_MARKER();
;;;1578       
;;;1579       /* Is the number too great to initialize? */
;;;1580       if(Number>=RMP_SEM_MAX_NUM)
;;;1581       {
;;;1582           RMP_COVERAGE_MARKER();
;;;1583           RMP_Unlock_Sched();
;;;1584           return RMP_ERR_OPER;
;;;1585       }
;;;1586       else
;;;1587           RMP_COVERAGE_MARKER();
;;;1588   
;;;1589       /* Initialize contents */
;;;1590       Semaphore->Cur_Num=Number;
;;;1591       Semaphore->State=RMP_SEM_USED;
;;;1592       RMP_List_Crt(&(Semaphore->Wait_List));
;;;1593       
;;;1594       RMP_Unlock_Sched();
;;;1595       
;;;1596       return 0;
;;;1597   }
000010  bd70              POP      {r4-r6,pc}
                  |L42.18|
000012  bf00              NOP                            ;1566
000014  bf00              NOP                            ;1566
000016  f7fffffe          BL       RMP_Lock_Sched
00001a  68a0              LDR      r0,[r4,#8]            ;1570
00001c  b130              CBZ      r0,|L42.44|
00001e  bf00              NOP                            ;1572
000020  bf00              NOP                            ;1572
000022  f7fffffe          BL       RMP_Unlock_Sched
000026  f06f0005          MVN      r0,#5                 ;1574
00002a  e7f1              B        |L42.16|
                  |L42.44|
00002c  bf00              NOP                            ;1577
00002e  bf00              NOP                            ;1577
000030  f5b57f7a          CMP      r5,#0x3e8             ;1580
000034  d306              BCC      |L42.68|
000036  bf00              NOP                            ;1582
000038  bf00              NOP                            ;1582
00003a  f7fffffe          BL       RMP_Unlock_Sched
00003e  f06f0004          MVN      r0,#4                 ;1584
000042  e7e5              B        |L42.16|
                  |L42.68|
000044  bf00              NOP                            ;1587
000046  bf00              NOP                            ;1587
000048  60e5              STR      r5,[r4,#0xc]          ;1590
00004a  2001              MOVS     r0,#1                 ;1591
00004c  60a0              STR      r0,[r4,#8]            ;1591
00004e  4620              MOV      r0,r4                 ;1592
000050  f7fffffe          BL       RMP_List_Crt
000054  f7fffffe          BL       RMP_Unlock_Sched
000058  2000              MOVS     r0,#0                 ;1596
00005a  e7d9              B        |L42.16|
;;;1598   /* End Function:RMP_Sem_Crt **************************************************/
                          ENDP


                          AREA ||i.RMP_Sem_Del||, CODE, READONLY, ALIGN=1

                  RMP_Sem_Del PROC
;;;1605   ******************************************************************************/
;;;1606   rmp_ret_t RMP_Sem_Del(volatile struct RMP_Sem* Semaphore)
000000  b570              PUSH     {r4-r6,lr}
;;;1607   {
000002  4605              MOV      r5,r0
;;;1608       struct RMP_Thd* Thread;
;;;1609       
;;;1610       /* Check if this semaphore structure could possibly be in use */
;;;1611       if(Semaphore==0)
000004  b925              CBNZ     r5,|L43.16|
;;;1612       {
;;;1613           RMP_COVERAGE_MARKER();
000006  bf00              NOP      
000008  bf00              NOP      
;;;1614           return RMP_ERR_SEM;
00000a  f06f0005          MVN      r0,#5
                  |L43.14|
;;;1615       }
;;;1616       else
;;;1617           RMP_COVERAGE_MARKER();
;;;1618       
;;;1619       RMP_Lock_Sched();
;;;1620       
;;;1621       if(Semaphore->State!=RMP_SEM_USED)
;;;1622       {
;;;1623           RMP_COVERAGE_MARKER();
;;;1624           RMP_Unlock_Sched();
;;;1625           return RMP_ERR_SEM;
;;;1626       }
;;;1627       else
;;;1628           RMP_COVERAGE_MARKER();
;;;1629   
;;;1630       /* Get rid of all guys waiting on it */
;;;1631       while(&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)
;;;1632       {
;;;1633           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
;;;1634           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1635           
;;;1636           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1637           {
;;;1638               RMP_COVERAGE_MARKER();
;;;1639               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1640           }
;;;1641           else
;;;1642               RMP_COVERAGE_MARKER();
;;;1643   
;;;1644           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1645           /* Set to running if not suspended */
;;;1646           _RMP_Set_Rdy(Thread);
;;;1647           Thread->Retval=RMP_ERR_OPER;
;;;1648       }
;;;1649       Semaphore->State=RMP_SEM_FREE;
;;;1650       
;;;1651       RMP_Unlock_Sched();
;;;1652   
;;;1653       return 0;
;;;1654   }
00000e  bd70              POP      {r4-r6,pc}
                  |L43.16|
000010  bf00              NOP                            ;1617
000012  bf00              NOP                            ;1617
000014  f7fffffe          BL       RMP_Lock_Sched
000018  68a8              LDR      r0,[r5,#8]            ;1621
00001a  2801              CMP      r0,#1                 ;1621
00001c  d006              BEQ      |L43.44|
00001e  bf00              NOP                            ;1623
000020  bf00              NOP                            ;1623
000022  f7fffffe          BL       RMP_Unlock_Sched
000026  f06f0005          MVN      r0,#5                 ;1625
00002a  e7f0              B        |L43.14|
                  |L43.44|
00002c  bf00              NOP                            ;1628
00002e  bf00              NOP                            ;1628
000030  e01b              B        |L43.106|
                  |L43.50|
000032  686c              LDR      r4,[r5,#4]            ;1633
000034  e9d40100          LDRD     r0,r1,[r4,#0]         ;1634
000038  f7fffffe          BL       RMP_List_Del
00003c  7e20              LDRB     r0,[r4,#0x18]         ;1636
00003e  2808              CMP      r0,#8                 ;1636
000040  d106              BNE      |L43.80|
000042  bf00              NOP                            ;1638
000044  bf00              NOP                            ;1638
000046  e9d40102          LDRD     r0,r1,[r4,#8]         ;1639
00004a  f7fffffe          BL       RMP_List_Del
00004e  e001              B        |L43.84|
                  |L43.80|
000050  bf00              NOP                            ;1642
000052  bf00              NOP                            ;1642
                  |L43.84|
000054  69a0              LDR      r0,[r4,#0x18]         ;1644
000056  f02000ff          BIC      r0,r0,#0xff           ;1644
00005a  1c40              ADDS     r0,r0,#1              ;1644
00005c  61a0              STR      r0,[r4,#0x18]         ;1644
00005e  4620              MOV      r0,r4                 ;1646
000060  f7fffffe          BL       _RMP_Set_Rdy
000064  f06f0004          MVN      r0,#4                 ;1647
000068  63a0              STR      r0,[r4,#0x38]         ;1647
                  |L43.106|
00006a  6868              LDR      r0,[r5,#4]            ;1631
00006c  42a8              CMP      r0,r5                 ;1631
00006e  d1e0              BNE      |L43.50|
000070  2000              MOVS     r0,#0                 ;1649
000072  60a8              STR      r0,[r5,#8]            ;1649
000074  f7fffffe          BL       RMP_Unlock_Sched
000078  2000              MOVS     r0,#0                 ;1653
00007a  e7c8              B        |L43.14|
;;;1655   /* End Function:RMP_Sem_Del **************************************************/
                          ENDP


                          AREA ||i.RMP_Sem_Pend||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Pend PROC
;;;1663   ******************************************************************************/
;;;1664   rmp_ret_t RMP_Sem_Pend(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Slices)
000000  b570              PUSH     {r4-r6,lr}
;;;1665   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1666       /* Check if this semaphore structure could possibly be in use */
;;;1667       if(Semaphore==0)
000006  b924              CBNZ     r4,|L44.18|
;;;1668       {
;;;1669           RMP_COVERAGE_MARKER();
000008  bf00              NOP      
00000a  bf00              NOP      
;;;1670           return RMP_ERR_SEM;
00000c  f06f0005          MVN      r0,#5
                  |L44.16|
;;;1671       }
;;;1672       else
;;;1673           RMP_COVERAGE_MARKER();
;;;1674       
;;;1675       RMP_Lock_Sched();
;;;1676       
;;;1677       if(Semaphore->State!=RMP_SEM_USED)
;;;1678       {
;;;1679           RMP_COVERAGE_MARKER();
;;;1680           RMP_Unlock_Sched();
;;;1681           return RMP_ERR_SEM;
;;;1682       }
;;;1683       else
;;;1684           RMP_COVERAGE_MARKER();
;;;1685       
;;;1686       /* Check if we can get one immediately */
;;;1687       if(Semaphore->Cur_Num!=0)
;;;1688       {
;;;1689           RMP_COVERAGE_MARKER();
;;;1690           Semaphore->Cur_Num--;
;;;1691           RMP_Unlock_Sched();
;;;1692           return Semaphore->Cur_Num;
;;;1693       }
;;;1694       else
;;;1695       {
;;;1696           RMP_COVERAGE_MARKER();
;;;1697           /* Cannot get one, we need to block */
;;;1698           if(Slices==0)
;;;1699           {
;;;1700               RMP_COVERAGE_MARKER();
;;;1701               RMP_Unlock_Sched();
;;;1702               return RMP_ERR_OPER;
;;;1703           }
;;;1704           else
;;;1705               RMP_COVERAGE_MARKER();
;;;1706   
;;;1707           /* We must be running - place into waitlist now */
;;;1708           _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1709           RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),Semaphore->Wait_List.Prev,&(Semaphore->Wait_List));
;;;1710           
;;;1711           if(Slices<RMP_MAX_SLICES)
;;;1712           {
;;;1713               RMP_COVERAGE_MARKER();
;;;1714               _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1715               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SEMDLY);
;;;1716           }
;;;1717           else
;;;1718           {
;;;1719               RMP_COVERAGE_MARKER();
;;;1720               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SEMBLK);
;;;1721           }
;;;1722           
;;;1723           RMP_Cur_Thd->Retval=0;
;;;1724       }
;;;1725       
;;;1726       RMP_Unlock_Sched();
;;;1727   
;;;1728       return RMP_Cur_Thd->Retval;
;;;1729   }
000010  bd70              POP      {r4-r6,pc}
                  |L44.18|
000012  bf00              NOP                            ;1673
000014  bf00              NOP                            ;1673
000016  f7fffffe          BL       RMP_Lock_Sched
00001a  68a0              LDR      r0,[r4,#8]            ;1677
00001c  2801              CMP      r0,#1                 ;1677
00001e  d006              BEQ      |L44.46|
000020  bf00              NOP                            ;1679
000022  bf00              NOP                            ;1679
000024  f7fffffe          BL       RMP_Unlock_Sched
000028  f06f0005          MVN      r0,#5                 ;1681
00002c  e7f0              B        |L44.16|
                  |L44.46|
00002e  bf00              NOP                            ;1684
000030  bf00              NOP                            ;1684
000032  68e0              LDR      r0,[r4,#0xc]          ;1687
000034  b140              CBZ      r0,|L44.72|
000036  bf00              NOP                            ;1689
000038  bf00              NOP                            ;1689
00003a  68e0              LDR      r0,[r4,#0xc]          ;1690
00003c  1e40              SUBS     r0,r0,#1              ;1690
00003e  60e0              STR      r0,[r4,#0xc]          ;1690
000040  f7fffffe          BL       RMP_Unlock_Sched
000044  68e0              LDR      r0,[r4,#0xc]          ;1692
000046  e7e3              B        |L44.16|
                  |L44.72|
000048  bf00              NOP                            ;1696
00004a  bf00              NOP                            ;1696
00004c  b935              CBNZ     r5,|L44.92|
00004e  bf00              NOP                            ;1700
000050  bf00              NOP                            ;1700
000052  f7fffffe          BL       RMP_Unlock_Sched
000056  f06f0004          MVN      r0,#4                 ;1702
00005a  e7d9              B        |L44.16|
                  |L44.92|
00005c  bf00              NOP                            ;1705
00005e  bf00              NOP                            ;1705
000060  4819              LDR      r0,|L44.200|
000062  6800              LDR      r0,[r0,#0]            ;1708  ; RMP_Cur_Thd
000064  f7fffffe          BL       _RMP_Clr_Rdy
000068  6821              LDR      r1,[r4,#0]            ;1709
00006a  4622              MOV      r2,r4                 ;1709
00006c  4816              LDR      r0,|L44.200|
00006e  6800              LDR      r0,[r0,#0]            ;1709  ; RMP_Cur_Thd
000070  f7fffffe          BL       RMP_List_Ins
000074  4815              LDR      r0,|L44.204|
000076  4285              CMP      r5,r0                 ;1711
000078  d211              BCS      |L44.158|
00007a  bf00              NOP                            ;1713
00007c  bf00              NOP                            ;1713
00007e  4629              MOV      r1,r5                 ;1714
000080  4811              LDR      r0,|L44.200|
000082  6800              LDR      r0,[r0,#0]            ;1714  ; RMP_Cur_Thd
000084  f7fffffe          BL       _RMP_Dly_Ins
000088  480f              LDR      r0,|L44.200|
00008a  6800              LDR      r0,[r0,#0]            ;1715  ; RMP_Cur_Thd
00008c  6980              LDR      r0,[r0,#0x18]         ;1715
00008e  f02000ff          BIC      r0,r0,#0xff           ;1715
000092  f0400008          ORR      r0,r0,#8              ;1715
000096  490c              LDR      r1,|L44.200|
000098  6809              LDR      r1,[r1,#0]            ;1715  ; RMP_Cur_Thd
00009a  6188              STR      r0,[r1,#0x18]         ;1715
00009c  e00a              B        |L44.180|
                  |L44.158|
00009e  bf00              NOP                            ;1719
0000a0  bf00              NOP                            ;1719
0000a2  4809              LDR      r0,|L44.200|
0000a4  6800              LDR      r0,[r0,#0]            ;1720  ; RMP_Cur_Thd
0000a6  6980              LDR      r0,[r0,#0x18]         ;1720
0000a8  f02000ff          BIC      r0,r0,#0xff           ;1720
0000ac  1dc0              ADDS     r0,r0,#7              ;1720
0000ae  4906              LDR      r1,|L44.200|
0000b0  6809              LDR      r1,[r1,#0]            ;1720  ; RMP_Cur_Thd
0000b2  6188              STR      r0,[r1,#0x18]         ;1720
                  |L44.180|
0000b4  2000              MOVS     r0,#0                 ;1723
0000b6  4904              LDR      r1,|L44.200|
0000b8  6809              LDR      r1,[r1,#0]            ;1723  ; RMP_Cur_Thd
0000ba  6388              STR      r0,[r1,#0x38]         ;1723
0000bc  f7fffffe          BL       RMP_Unlock_Sched
0000c0  4801              LDR      r0,|L44.200|
0000c2  6800              LDR      r0,[r0,#0]            ;1728  ; RMP_Cur_Thd
0000c4  6b80              LDR      r0,[r0,#0x38]         ;1728
0000c6  e7a3              B        |L44.16|
;;;1730   /* End Function:RMP_Sem_Pend *************************************************/
                          ENDP

                  |L44.200|
                          DCD      RMP_Cur_Thd
                  |L44.204|
                          DCD      0x000186a0

                          AREA ||i.RMP_Sem_Post||, CODE, READONLY, ALIGN=1

                  RMP_Sem_Post PROC
;;;1797   ******************************************************************************/
;;;1798   rmp_ret_t RMP_Sem_Post(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Number)
000000  b570              PUSH     {r4-r6,lr}
;;;1799   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;1800       struct RMP_Thd* Thread;
;;;1801       
;;;1802       /* Check if this semaphore structure could possibly be in use */
;;;1803       if((Semaphore==0)||(Number==0))
000006  b104              CBZ      r4,|L45.10|
000008  b926              CBNZ     r6,|L45.20|
                  |L45.10|
;;;1804       {
;;;1805           RMP_COVERAGE_MARKER();
00000a  bf00              NOP      
00000c  bf00              NOP      
;;;1806           return RMP_ERR_SEM;
00000e  f06f0005          MVN      r0,#5
                  |L45.18|
;;;1807       }
;;;1808       else
;;;1809           RMP_COVERAGE_MARKER();
;;;1810       
;;;1811       RMP_Lock_Sched();
;;;1812       
;;;1813       if(Semaphore->State!=RMP_SEM_USED)
;;;1814       {
;;;1815           RMP_COVERAGE_MARKER();
;;;1816           RMP_Unlock_Sched();
;;;1817           return RMP_ERR_SEM;
;;;1818       }
;;;1819       else
;;;1820           RMP_COVERAGE_MARKER();
;;;1821       
;;;1822       /* Would the maximum value be exceeded if this is posted? */
;;;1823       if((Semaphore->Cur_Num+Number)>=RMP_SEM_MAX_NUM)
;;;1824       {
;;;1825           RMP_COVERAGE_MARKER();
;;;1826           RMP_Unlock_Sched();
;;;1827           return RMP_ERR_OPER;
;;;1828       }
;;;1829       else
;;;1830           RMP_COVERAGE_MARKER();
;;;1831       
;;;1832       Semaphore->Cur_Num+=Number;
;;;1833       /* Is there any thread waiting on it? If there are, clean them up*/
;;;1834       while((&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)&&(Semaphore->Cur_Num!=0))
;;;1835       {
;;;1836           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
;;;1837           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1838           
;;;1839           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1840           {
;;;1841               RMP_COVERAGE_MARKER();
;;;1842               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1843           }
;;;1844           else
;;;1845               RMP_COVERAGE_MARKER();
;;;1846           
;;;1847           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1848           /* Set to running if not suspended */
;;;1849           _RMP_Set_Rdy(Thread);
;;;1850   
;;;1851           /* Finally, return success */
;;;1852           Thread->Retval=0;
;;;1853           Semaphore->Cur_Num--;
;;;1854       }
;;;1855   
;;;1856       RMP_Unlock_Sched();
;;;1857       return 0;
;;;1858   }
000012  bd70              POP      {r4-r6,pc}
                  |L45.20|
000014  bf00              NOP                            ;1809
000016  bf00              NOP                            ;1809
000018  f7fffffe          BL       RMP_Lock_Sched
00001c  68a0              LDR      r0,[r4,#8]            ;1813
00001e  2801              CMP      r0,#1                 ;1813
000020  d006              BEQ      |L45.48|
000022  bf00              NOP                            ;1815
000024  bf00              NOP                            ;1815
000026  f7fffffe          BL       RMP_Unlock_Sched
00002a  f06f0005          MVN      r0,#5                 ;1817
00002e  e7f0              B        |L45.18|
                  |L45.48|
000030  bf00              NOP                            ;1820
000032  bf00              NOP                            ;1820
000034  68e0              LDR      r0,[r4,#0xc]          ;1823
000036  4430              ADD      r0,r0,r6              ;1823
000038  f5b07f7a          CMP      r0,#0x3e8             ;1823
00003c  d306              BCC      |L45.76|
00003e  bf00              NOP                            ;1825
000040  bf00              NOP                            ;1825
000042  f7fffffe          BL       RMP_Unlock_Sched
000046  f06f0004          MVN      r0,#4                 ;1827
00004a  e7e2              B        |L45.18|
                  |L45.76|
00004c  bf00              NOP                            ;1830
00004e  bf00              NOP                            ;1830
000050  68e0              LDR      r0,[r4,#0xc]          ;1832
000052  4430              ADD      r0,r0,r6              ;1832
000054  60e0              STR      r0,[r4,#0xc]          ;1832
000056  e01d              B        |L45.148|
                  |L45.88|
000058  6865              LDR      r5,[r4,#4]            ;1836
00005a  e9d50100          LDRD     r0,r1,[r5,#0]         ;1837
00005e  f7fffffe          BL       RMP_List_Del
000062  7e28              LDRB     r0,[r5,#0x18]         ;1839
000064  2808              CMP      r0,#8                 ;1839
000066  d106              BNE      |L45.118|
000068  bf00              NOP                            ;1841
00006a  bf00              NOP                            ;1841
00006c  e9d50102          LDRD     r0,r1,[r5,#8]         ;1842
000070  f7fffffe          BL       RMP_List_Del
000074  e001              B        |L45.122|
                  |L45.118|
000076  bf00              NOP                            ;1845
000078  bf00              NOP                            ;1845
                  |L45.122|
00007a  69a8              LDR      r0,[r5,#0x18]         ;1847
00007c  f02000ff          BIC      r0,r0,#0xff           ;1847
000080  1c40              ADDS     r0,r0,#1              ;1847
000082  61a8              STR      r0,[r5,#0x18]         ;1847
000084  4628              MOV      r0,r5                 ;1849
000086  f7fffffe          BL       _RMP_Set_Rdy
00008a  2000              MOVS     r0,#0                 ;1852
00008c  63a8              STR      r0,[r5,#0x38]         ;1852
00008e  68e0              LDR      r0,[r4,#0xc]          ;1853
000090  1e40              SUBS     r0,r0,#1              ;1853
000092  60e0              STR      r0,[r4,#0xc]          ;1853
                  |L45.148|
000094  6860              LDR      r0,[r4,#4]            ;1834
000096  42a0              CMP      r0,r4                 ;1834
000098  d002              BEQ      |L45.160|
00009a  68e0              LDR      r0,[r4,#0xc]          ;1834
00009c  2800              CMP      r0,#0                 ;1834
00009e  d1db              BNE      |L45.88|
                  |L45.160|
0000a0  f7fffffe          BL       RMP_Unlock_Sched
0000a4  2000              MOVS     r0,#0                 ;1857
0000a6  e7b4              B        |L45.18|
;;;1859   /* End Function:RMP_Sem_Post *************************************************/
                          ENDP


                          AREA ||i.RMP_Sem_Post_ISR||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Post_ISR PROC
;;;1869   ******************************************************************************/
;;;1870   rmp_ret_t RMP_Sem_Post_ISR(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Number)
000000  b570              PUSH     {r4-r6,lr}
;;;1871   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;1872       struct RMP_Thd* Thread;
;;;1873       /* Check if this semaphore structure could possibly be in use */
;;;1874       if((Semaphore==0)||(Number==0))
000006  b104              CBZ      r4,|L46.10|
000008  b926              CBNZ     r6,|L46.20|
                  |L46.10|
;;;1875       {
;;;1876           RMP_COVERAGE_MARKER();
00000a  bf00              NOP      
00000c  bf00              NOP      
;;;1877           return RMP_ERR_SEM;
00000e  f06f0005          MVN      r0,#5
                  |L46.18|
;;;1878       }
;;;1879       else
;;;1880           RMP_COVERAGE_MARKER();
;;;1881       
;;;1882       if(Semaphore->State!=RMP_SEM_USED)
;;;1883       {
;;;1884           RMP_COVERAGE_MARKER();
;;;1885           return RMP_ERR_SEM;
;;;1886       }
;;;1887       else
;;;1888           RMP_COVERAGE_MARKER();
;;;1889   
;;;1890       /* Would the maximum value be exceeded if this is posted? */
;;;1891       if((Semaphore->Cur_Num+Number)>=RMP_SEM_MAX_NUM)
;;;1892       {
;;;1893           RMP_COVERAGE_MARKER();
;;;1894           return RMP_ERR_OPER;
;;;1895       }
;;;1896       else
;;;1897           RMP_COVERAGE_MARKER();
;;;1898       
;;;1899       Semaphore->Cur_Num+=Number;
;;;1900       /* Is there any thread waiting on it? If there are, clean them up*/
;;;1901       while((&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)&&(Semaphore->Cur_Num!=0))
;;;1902       {
;;;1903           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
;;;1904           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1905           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1906           {
;;;1907               RMP_COVERAGE_MARKER();
;;;1908               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1909           }
;;;1910           else
;;;1911               RMP_COVERAGE_MARKER();
;;;1912           
;;;1913           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1914           /* Set to running if not suspended */
;;;1915           _RMP_Set_Rdy(Thread);
;;;1916           
;;;1917           /* If schedule pending, trigger it now because we are in ISR */
;;;1918           if(RMP_Sched_Pend!=0)
;;;1919           {
;;;1920               RMP_COVERAGE_MARKER();
;;;1921               RMP_Sched_Pend=0;
;;;1922               _RMP_Yield();   
;;;1923           }
;;;1924           else
;;;1925               RMP_COVERAGE_MARKER();
;;;1926   
;;;1927           /* Finally, return success */
;;;1928           Thread->Retval=0;
;;;1929           Semaphore->Cur_Num--;
;;;1930       }
;;;1931   
;;;1932       return 0;
;;;1933   }
000012  bd70              POP      {r4-r6,pc}
                  |L46.20|
000014  bf00              NOP                            ;1880
000016  bf00              NOP                            ;1880
000018  68a0              LDR      r0,[r4,#8]            ;1882
00001a  2801              CMP      r0,#1                 ;1882
00001c  d004              BEQ      |L46.40|
00001e  bf00              NOP                            ;1884
000020  bf00              NOP                            ;1884
000022  f06f0005          MVN      r0,#5                 ;1885
000026  e7f4              B        |L46.18|
                  |L46.40|
000028  bf00              NOP                            ;1888
00002a  bf00              NOP                            ;1888
00002c  68e0              LDR      r0,[r4,#0xc]          ;1891
00002e  4430              ADD      r0,r0,r6              ;1891
000030  f5b07f7a          CMP      r0,#0x3e8             ;1891
000034  d304              BCC      |L46.64|
000036  bf00              NOP                            ;1893
000038  bf00              NOP                            ;1893
00003a  f06f0004          MVN      r0,#4                 ;1894
00003e  e7e8              B        |L46.18|
                  |L46.64|
000040  bf00              NOP                            ;1897
000042  bf00              NOP                            ;1897
000044  68e0              LDR      r0,[r4,#0xc]          ;1899
000046  4430              ADD      r0,r0,r6              ;1899
000048  60e0              STR      r0,[r4,#0xc]          ;1899
00004a  e02a              B        |L46.162|
                  |L46.76|
00004c  6865              LDR      r5,[r4,#4]            ;1903
00004e  e9d50100          LDRD     r0,r1,[r5,#0]         ;1904
000052  f7fffffe          BL       RMP_List_Del
000056  7e28              LDRB     r0,[r5,#0x18]         ;1905
000058  2808              CMP      r0,#8                 ;1905
00005a  d106              BNE      |L46.106|
00005c  bf00              NOP                            ;1907
00005e  bf00              NOP                            ;1907
000060  e9d50102          LDRD     r0,r1,[r5,#8]         ;1908
000064  f7fffffe          BL       RMP_List_Del
000068  e001              B        |L46.110|
                  |L46.106|
00006a  bf00              NOP                            ;1911
00006c  bf00              NOP                            ;1911
                  |L46.110|
00006e  69a8              LDR      r0,[r5,#0x18]         ;1913
000070  f02000ff          BIC      r0,r0,#0xff           ;1913
000074  1c40              ADDS     r0,r0,#1              ;1913
000076  61a8              STR      r0,[r5,#0x18]         ;1913
000078  4628              MOV      r0,r5                 ;1915
00007a  f7fffffe          BL       _RMP_Set_Rdy
00007e  480d              LDR      r0,|L46.180|
000080  6800              LDR      r0,[r0,#0]            ;1918  ; RMP_Sched_Pend
000082  b138              CBZ      r0,|L46.148|
000084  bf00              NOP                            ;1920
000086  bf00              NOP                            ;1920
000088  2000              MOVS     r0,#0                 ;1921
00008a  490a              LDR      r1,|L46.180|
00008c  6008              STR      r0,[r1,#0]            ;1921  ; RMP_Sched_Pend
00008e  f7fffffe          BL       _RMP_Yield
000092  e001              B        |L46.152|
                  |L46.148|
000094  bf00              NOP                            ;1925
000096  bf00              NOP                            ;1925
                  |L46.152|
000098  2000              MOVS     r0,#0                 ;1928
00009a  63a8              STR      r0,[r5,#0x38]         ;1928
00009c  68e0              LDR      r0,[r4,#0xc]          ;1929
00009e  1e40              SUBS     r0,r0,#1              ;1929
0000a0  60e0              STR      r0,[r4,#0xc]          ;1929
                  |L46.162|
0000a2  6860              LDR      r0,[r4,#4]            ;1901
0000a4  42a0              CMP      r0,r4                 ;1901
0000a6  d002              BEQ      |L46.174|
0000a8  68e0              LDR      r0,[r4,#0xc]          ;1901
0000aa  2800              CMP      r0,#0                 ;1901
0000ac  d1ce              BNE      |L46.76|
                  |L46.174|
0000ae  2000              MOVS     r0,#0                 ;1932
0000b0  e7af              B        |L46.18|
;;;1934   /* End Function:RMP_Sem_Post_ISR *********************************************/
                          ENDP

0000b2  0000              DCW      0x0000
                  |L46.180|
                          DCD      RMP_Sched_Pend

                          AREA ||i.RMP_Thd_Cancel||, CODE, READONLY, ALIGN=1

                  RMP_Thd_Cancel PROC
;;;1514   ******************************************************************************/
;;;1515   rmp_ret_t RMP_Thd_Cancel(volatile struct RMP_Thd* Thread)
000000  b510              PUSH     {r4,lr}
;;;1516   {
000002  4604              MOV      r4,r0
;;;1517       /* Check if this thread structure could possibly be in use */
;;;1518       if(Thread==0)
000004  b924              CBNZ     r4,|L47.16|
;;;1519       {
;;;1520           RMP_COVERAGE_MARKER();
000006  bf00              NOP      
000008  bf00              NOP      
;;;1521           return RMP_ERR_THD;
00000a  f04f30ff          MOV      r0,#0xffffffff
                  |L47.14|
;;;1522       }
;;;1523       else
;;;1524           RMP_COVERAGE_MARKER();
;;;1525       
;;;1526       RMP_Lock_Sched();
;;;1527       
;;;1528       /* Is it delayed? */
;;;1529       if(RMP_THD_STATE(Thread->State)!=RMP_THD_DELAYED)
;;;1530       {
;;;1531           RMP_COVERAGE_MARKER();
;;;1532           RMP_Unlock_Sched();
;;;1533           return RMP_ERR_STATE;
;;;1534       }
;;;1535       else
;;;1536           RMP_COVERAGE_MARKER();
;;;1537   
;;;1538       /* Delete it from the delay list */
;;;1539       RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1540       RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1541       /* Set to running if not suspended */
;;;1542       _RMP_Set_Rdy(Thread);
;;;1543       
;;;1544       Thread->Retval=RMP_ERR_OPER;
;;;1545       RMP_Unlock_Sched();
;;;1546       return 0;
;;;1547   }
00000e  bd10              POP      {r4,pc}
                  |L47.16|
000010  bf00              NOP                            ;1524
000012  bf00              NOP                            ;1524
000014  f7fffffe          BL       RMP_Lock_Sched
000018  69a0              LDR      r0,[r4,#0x18]         ;1529
00001a  b2c0              UXTB     r0,r0                 ;1529
00001c  2806              CMP      r0,#6                 ;1529
00001e  d006              BEQ      |L47.46|
000020  bf00              NOP                            ;1531
000022  bf00              NOP                            ;1531
000024  f7fffffe          BL       RMP_Unlock_Sched
000028  f06f0003          MVN      r0,#3                 ;1533
00002c  e7ef              B        |L47.14|
                  |L47.46|
00002e  bf00              NOP                            ;1536
000030  bf00              NOP                            ;1536
000032  68e1              LDR      r1,[r4,#0xc]          ;1539
000034  68a0              LDR      r0,[r4,#8]            ;1539
000036  f7fffffe          BL       RMP_List_Del
00003a  69a0              LDR      r0,[r4,#0x18]         ;1540
00003c  f02000ff          BIC      r0,r0,#0xff           ;1540
000040  1c40              ADDS     r0,r0,#1              ;1540
000042  61a0              STR      r0,[r4,#0x18]         ;1540
000044  4620              MOV      r0,r4                 ;1542
000046  f7fffffe          BL       _RMP_Set_Rdy
00004a  f06f0004          MVN      r0,#4                 ;1544
00004e  63a0              STR      r0,[r4,#0x38]         ;1544
000050  f7fffffe          BL       RMP_Unlock_Sched
000054  2000              MOVS     r0,#0                 ;1546
000056  e7da              B        |L47.14|
;;;1548   /* End Function:RMP_Thd_Cancel ***********************************************/
                          ENDP


                          AREA ||i.RMP_Thd_Crt||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Crt PROC
;;;766    ******************************************************************************/
;;;767    rmp_ret_t RMP_Thd_Crt(volatile struct RMP_Thd* Thread, void* Entry, void* Stack, void* Arg, rmp_ptr_t Prio, rmp_ptr_t Slices)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;768    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
00000a  4698              MOV      r8,r3
00000c  e9dd9508          LDRD     r9,r5,[sp,#0x20]
;;;769        /* Check if the priority and timeslice range is correct */
;;;770        if(Prio>=RMP_MAX_PREEMPT_PRIO)
000010  f1b90f20          CMP      r9,#0x20
000014  d305              BCC      |L48.34|
;;;771        {
;;;772            RMP_COVERAGE_MARKER();
000016  bf00              NOP      
000018  bf00              NOP      
;;;773            return RMP_ERR_PRIO;
00001a  f06f0001          MVN      r0,#1
                  |L48.30|
;;;774        }
;;;775        else
;;;776            RMP_COVERAGE_MARKER();
;;;777        
;;;778        if((Slices==0)||(Slices>=RMP_MAX_SLICES))
;;;779        {
;;;780            RMP_COVERAGE_MARKER();
;;;781            return RMP_ERR_SLICE;
;;;782        }
;;;783        else
;;;784            RMP_COVERAGE_MARKER();
;;;785        
;;;786        /* Check if this thread structure could possibly be in use */
;;;787        if(Thread==0)
;;;788        {
;;;789            RMP_COVERAGE_MARKER();
;;;790            return RMP_ERR_THD;
;;;791        }
;;;792        else
;;;793            RMP_COVERAGE_MARKER();
;;;794        
;;;795        RMP_Lock_Sched();
;;;796        
;;;797        if(RMP_THD_STATE(Thread->State)!=RMP_THD_FREE)
;;;798        {
;;;799            RMP_COVERAGE_MARKER();
;;;800            RMP_Unlock_Sched();
;;;801            return RMP_ERR_THD;
;;;802        }
;;;803        else
;;;804            RMP_COVERAGE_MARKER();
;;;805        
;;;806        /* Create the thread and insert it into the list */
;;;807        Thread->Prio=Prio;
;;;808        Thread->Slices=Slices;
;;;809        Thread->Slices_Left=Slices;
;;;810        Thread->Stack=(rmp_ptr_t)Stack;
;;;811        
;;;812        /* Initialize its stack and sending list */
;;;813        _RMP_Stack_Init((rmp_ptr_t)Entry, (rmp_ptr_t)Stack, (rmp_ptr_t)Arg);
;;;814        RMP_List_Crt(&(Thread->Snd_List));
;;;815        
;;;816        /* Notify the scheduler that we have created something new, also check locks */
;;;817        Thread->State=RMP_THD_RUNNING;
;;;818        _RMP_Set_Rdy(Thread);
;;;819        
;;;820        RMP_Unlock_Sched();
;;;821    
;;;822        return 0;
;;;823    }
00001e  e8bd87f0          POP      {r4-r10,pc}
                  |L48.34|
000022  bf00              NOP                            ;776
000024  bf00              NOP                            ;776
000026  b115              CBZ      r5,|L48.46|
000028  481b              LDR      r0,|L48.152|
00002a  4285              CMP      r5,r0                 ;778
00002c  d304              BCC      |L48.56|
                  |L48.46|
00002e  bf00              NOP                            ;780
000030  bf00              NOP                            ;780
000032  f06f0002          MVN      r0,#2                 ;781
000036  e7f2              B        |L48.30|
                  |L48.56|
000038  bf00              NOP                            ;784
00003a  bf00              NOP                            ;784
00003c  b924              CBNZ     r4,|L48.72|
00003e  bf00              NOP                            ;789
000040  bf00              NOP                            ;789
000042  f04f30ff          MOV      r0,#0xffffffff        ;790
000046  e7ea              B        |L48.30|
                  |L48.72|
000048  bf00              NOP                            ;793
00004a  bf00              NOP                            ;793
00004c  f7fffffe          BL       RMP_Lock_Sched
000050  69a0              LDR      r0,[r4,#0x18]         ;797
000052  b2c0              UXTB     r0,r0                 ;797
000054  b130              CBZ      r0,|L48.100|
000056  bf00              NOP                            ;799
000058  bf00              NOP                            ;799
00005a  f7fffffe          BL       RMP_Unlock_Sched
00005e  f04f30ff          MOV      r0,#0xffffffff        ;801
000062  e7dc              B        |L48.30|
                  |L48.100|
000064  bf00              NOP                            ;804
000066  bf00              NOP                            ;804
000068  f8c49024          STR      r9,[r4,#0x24]         ;807
00006c  61e5              STR      r5,[r4,#0x1c]         ;808
00006e  6225              STR      r5,[r4,#0x20]         ;809
000070  6366              STR      r6,[r4,#0x34]         ;810
000072  4642              MOV      r2,r8                 ;813
000074  4631              MOV      r1,r6                 ;813
000076  4638              MOV      r0,r7                 ;813
000078  f7fffffe          BL       _RMP_Stack_Init
00007c  f1040010          ADD      r0,r4,#0x10           ;814
000080  f7fffffe          BL       RMP_List_Crt
000084  2001              MOVS     r0,#1                 ;817
000086  61a0              STR      r0,[r4,#0x18]         ;817
000088  4620              MOV      r0,r4                 ;818
00008a  f7fffffe          BL       _RMP_Set_Rdy
00008e  f7fffffe          BL       RMP_Unlock_Sched
000092  2000              MOVS     r0,#0                 ;822
000094  e7c3              B        |L48.30|
;;;824    /* End Function:RMP_Thd_Crt **************************************************/
                          ENDP

000096  0000              DCW      0x0000
                  |L48.152|
                          DCD      0x000186a0

                          AREA ||i.RMP_Thd_Del||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Del PROC
;;;831    ******************************************************************************/
;;;832    rmp_ret_t RMP_Thd_Del(volatile struct RMP_Thd* Thread)
000000  b570              PUSH     {r4-r6,lr}
;;;833    {
000002  4604              MOV      r4,r0
;;;834        struct RMP_Thd* Release;
;;;835        
;;;836        /* Check if this thread structure could possibly be in use */
;;;837        if(Thread==0)
000004  b924              CBNZ     r4,|L49.16|
;;;838        {
;;;839            RMP_COVERAGE_MARKER();
000006  bf00              NOP      
000008  bf00              NOP      
;;;840            return RMP_ERR_THD;
00000a  f04f30ff          MOV      r0,#0xffffffff
                  |L49.14|
;;;841        }
;;;842        else
;;;843            RMP_COVERAGE_MARKER();
;;;844        
;;;845        RMP_Lock_Sched();
;;;846        
;;;847        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;848        {
;;;849            RMP_COVERAGE_MARKER();
;;;850            RMP_Unlock_Sched();
;;;851            return RMP_ERR_THD;
;;;852        }
;;;853        else
;;;854            RMP_COVERAGE_MARKER();
;;;855        
;;;856        /* See if anyone waiting to send to this thread. If there is, release all these threads */
;;;857        while(&(Thread->Snd_List)!=Thread->Snd_List.Next)
;;;858        {
;;;859            Release=(struct RMP_Thd*)(Thread->Snd_List.Next);
;;;860            RMP_List_Del(Release->Run_Head.Prev,Release->Run_Head.Next);
;;;861            if(RMP_THD_STATE(Release->State)==RMP_THD_SNDDLY)
;;;862            {
;;;863                RMP_COVERAGE_MARKER();
;;;864                RMP_List_Del(Release->Dly_Head.Prev,Release->Dly_Head.Next);
;;;865            }
;;;866            else
;;;867                RMP_COVERAGE_MARKER();
;;;868            
;;;869            RMP_THD_STATE_SET(Release->State,RMP_THD_RUNNING);
;;;870            /* Set ready if not suspended */
;;;871            _RMP_Set_Rdy(Release);
;;;872            Release->Retval=RMP_ERR_OPER;
;;;873        }
;;;874        
;;;875        /* See what is its state */
;;;876        switch(RMP_THD_STATE(Thread->State))
;;;877        {
;;;878            case RMP_THD_RUNNING:
;;;879            {
;;;880                RMP_COVERAGE_MARKER();
;;;881                /* Clear ready if not suspended */
;;;882                _RMP_Clr_Rdy(Thread);
;;;883                break;
;;;884            }
;;;885            
;;;886            /* Do nothing if it is blocked on receive */
;;;887            case RMP_THD_RCVBLK:
;;;888            {
;;;889                RMP_COVERAGE_MARKER();
;;;890                break;
;;;891            }
;;;892            
;;;893            case RMP_THD_SNDBLK:RMP_COVERAGE_MARKER();
;;;894            case RMP_THD_SEMBLK:
;;;895            {
;;;896                RMP_COVERAGE_MARKER();
;;;897                RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;898                break;
;;;899            }
;;;900            
;;;901            case RMP_THD_SNDDLY:RMP_COVERAGE_MARKER();
;;;902            case RMP_THD_SEMDLY:
;;;903            {
;;;904                RMP_COVERAGE_MARKER();
;;;905                RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;906                /* Fall-through case */
;;;907            }
;;;908            case RMP_THD_RCVDLY:RMP_COVERAGE_MARKER();
;;;909            case RMP_THD_DELAYED:
;;;910            {
;;;911                RMP_COVERAGE_MARKER();
;;;912                RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;913                break;
;;;914            }
;;;915            /* Should not get here */
;;;916            default:while(1);
;;;917        }
;;;918        /* Set return value to failure anyway */
;;;919        Thread->Retval=RMP_ERR_OPER;
;;;920        Thread->State=RMP_THD_FREE;
;;;921        /* If we are deleting ourself, pend a yield */
;;;922        if(Thread==RMP_Cur_Thd)
;;;923        {
;;;924            RMP_COVERAGE_MARKER();
;;;925            RMP_Sched_Pend=1;
;;;926        }
;;;927        else
;;;928            RMP_COVERAGE_MARKER();
;;;929        
;;;930        RMP_Unlock_Sched();
;;;931        
;;;932        /* If we are deleting ourself, just stop the execution here */
;;;933        if(Thread==RMP_Cur_Thd)
;;;934            while(1);
;;;935        else
;;;936            RMP_COVERAGE_MARKER();
;;;937    
;;;938        return 0;
;;;939    }
00000e  bd70              POP      {r4-r6,pc}
                  |L49.16|
000010  bf00              NOP                            ;843
000012  bf00              NOP                            ;843
000014  f7fffffe          BL       RMP_Lock_Sched
000018  69a0              LDR      r0,[r4,#0x18]         ;847
00001a  b2c0              UXTB     r0,r0                 ;847
00001c  b930              CBNZ     r0,|L49.44|
00001e  bf00              NOP                            ;849
000020  bf00              NOP                            ;849
000022  f7fffffe          BL       RMP_Unlock_Sched
000026  f04f30ff          MOV      r0,#0xffffffff        ;851
00002a  e7f0              B        |L49.14|
                  |L49.44|
00002c  bf00              NOP                            ;854
00002e  bf00              NOP                            ;854
000030  e01b              B        |L49.106|
                  |L49.50|
000032  6965              LDR      r5,[r4,#0x14]         ;859
000034  e9d50100          LDRD     r0,r1,[r5,#0]         ;860
000038  f7fffffe          BL       RMP_List_Del
00003c  7e28              LDRB     r0,[r5,#0x18]         ;861
00003e  2803              CMP      r0,#3                 ;861
000040  d106              BNE      |L49.80|
000042  bf00              NOP                            ;863
000044  bf00              NOP                            ;863
000046  e9d50102          LDRD     r0,r1,[r5,#8]         ;864
00004a  f7fffffe          BL       RMP_List_Del
00004e  e001              B        |L49.84|
                  |L49.80|
000050  bf00              NOP                            ;867
000052  bf00              NOP                            ;867
                  |L49.84|
000054  69a8              LDR      r0,[r5,#0x18]         ;869
000056  f02000ff          BIC      r0,r0,#0xff           ;869
00005a  1c40              ADDS     r0,r0,#1              ;869
00005c  61a8              STR      r0,[r5,#0x18]         ;869
00005e  4628              MOV      r0,r5                 ;871
000060  f7fffffe          BL       _RMP_Set_Rdy
000064  f06f0004          MVN      r0,#4                 ;872
000068  63a8              STR      r0,[r5,#0x38]         ;872
                  |L49.106|
00006a  6961              LDR      r1,[r4,#0x14]         ;857
00006c  f1040010          ADD      r0,r4,#0x10           ;857
000070  4281              CMP      r1,r0                 ;857
000072  d1de              BNE      |L49.50|
000074  69a0              LDR      r0,[r4,#0x18]         ;876
000076  b2c0              UXTB     r0,r0                 ;876
000078  2809              CMP      r0,#9                 ;876
00007a  d22d              BCS      |L49.216|
00007c  e8dff000          TBB      [pc,r0]               ;876
000080  2c050e18          DCB      0x2c,0x05,0x0e,0x18
000084  0b222511          DCB      0x0b,0x22,0x25,0x11
000088  1b00              DCB      0x1b,0x00
00008a  bf00              NOP                            ;880
00008c  bf00              NOP                            ;880
00008e  4620              MOV      r0,r4                 ;882
000090  f7fffffe          BL       _RMP_Clr_Rdy
000094  e022              B        |L49.220|
000096  bf00              NOP                            ;889
000098  bf00              NOP                            ;889
00009a  e01f              B        |L49.220|
00009c  bf00              NOP                            ;893
00009e  bf00              NOP                            ;893
0000a0  bf00              NOP                            ;894
0000a2  bf00              NOP                            ;896
0000a4  bf00              NOP                            ;896
0000a6  6861              LDR      r1,[r4,#4]            ;897
0000a8  6820              LDR      r0,[r4,#0]            ;897
0000aa  f7fffffe          BL       RMP_List_Del
0000ae  e015              B        |L49.220|
0000b0  bf00              NOP                            ;901
0000b2  bf00              NOP                            ;901
0000b4  bf00              NOP                            ;902
0000b6  bf00              NOP                            ;904
0000b8  bf00              NOP                            ;904
0000ba  6861              LDR      r1,[r4,#4]            ;905
0000bc  6820              LDR      r0,[r4,#0]            ;905
0000be  f7fffffe          BL       RMP_List_Del
0000c2  bf00              NOP                            ;908
0000c4  bf00              NOP                            ;908
0000c6  bf00              NOP                            ;908
0000c8  bf00              NOP                            ;909
0000ca  bf00              NOP                            ;911
0000cc  bf00              NOP                            ;911
0000ce  68e1              LDR      r1,[r4,#0xc]          ;912
0000d0  68a0              LDR      r0,[r4,#8]            ;912
0000d2  f7fffffe          BL       RMP_List_Del
0000d6  e001              B        |L49.220|
                  |L49.216|
0000d8  bf00              NOP                            ;916
                  |L49.218|
0000da  e7fe              B        |L49.218|
                  |L49.220|
0000dc  bf00              NOP                            ;883
0000de  f06f0004          MVN      r0,#4                 ;919
0000e2  63a0              STR      r0,[r4,#0x38]         ;919
0000e4  2000              MOVS     r0,#0                 ;920
0000e6  61a0              STR      r0,[r4,#0x18]         ;920
0000e8  480b              LDR      r0,|L49.280|
0000ea  6800              LDR      r0,[r0,#0]            ;922  ; RMP_Cur_Thd
0000ec  4284              CMP      r4,r0                 ;922
0000ee  d105              BNE      |L49.252|
0000f0  bf00              NOP                            ;924
0000f2  bf00              NOP                            ;924
0000f4  2001              MOVS     r0,#1                 ;925
0000f6  4909              LDR      r1,|L49.284|
0000f8  6008              STR      r0,[r1,#0]            ;925  ; RMP_Sched_Pend
0000fa  e001              B        |L49.256|
                  |L49.252|
0000fc  bf00              NOP                            ;928
0000fe  bf00              NOP                            ;928
                  |L49.256|
000100  f7fffffe          BL       RMP_Unlock_Sched
000104  4804              LDR      r0,|L49.280|
000106  6800              LDR      r0,[r0,#0]            ;933  ; RMP_Cur_Thd
000108  4284              CMP      r4,r0                 ;933
00010a  d101              BNE      |L49.272|
00010c  bf00              NOP                            ;934
                  |L49.270|
00010e  e7fe              B        |L49.270|
                  |L49.272|
000110  bf00              NOP                            ;936
000112  bf00              NOP                            ;936
000114  2000              MOVS     r0,#0                 ;938
000116  e77a              B        |L49.14|
;;;940    /* End Function:RMP_Thd_Del **************************************************/
                          ENDP

                  |L49.280|
                          DCD      RMP_Cur_Thd
                  |L49.284|
                          DCD      RMP_Sched_Pend

                          AREA ||i.RMP_Thd_Delay||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Delay PROC
;;;1484   ******************************************************************************/
;;;1485   rmp_ret_t RMP_Thd_Delay(rmp_ptr_t Slices)
000000  b510              PUSH     {r4,lr}
;;;1486   {
000002  4604              MOV      r4,r0
;;;1487       if((Slices==0)||(Slices>=RMP_MAX_SLICES))
000004  b114              CBZ      r4,|L50.12|
000006  4814              LDR      r0,|L50.88|
000008  4284              CMP      r4,r0
00000a  d304              BCC      |L50.22|
                  |L50.12|
;;;1488       {
;;;1489           RMP_COVERAGE_MARKER();
00000c  bf00              NOP      
00000e  bf00              NOP      
;;;1490           return RMP_ERR_SLICE;
000010  f06f0002          MVN      r0,#2
                  |L50.20|
;;;1491       }
;;;1492       else
;;;1493           RMP_COVERAGE_MARKER();
;;;1494       
;;;1495       RMP_Lock_Sched();
;;;1496   
;;;1497       /* We must be running and not suspended so we will be out of running queue */
;;;1498       _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1499       RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_DELAYED);
;;;1500       _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1501   
;;;1502       RMP_Cur_Thd->Retval=0;
;;;1503       RMP_Unlock_Sched();
;;;1504       /* Need to return if successful or not */
;;;1505       return RMP_Cur_Thd->Retval;
;;;1506   }
000014  bd10              POP      {r4,pc}
                  |L50.22|
000016  bf00              NOP                            ;1493
000018  bf00              NOP                            ;1493
00001a  f7fffffe          BL       RMP_Lock_Sched
00001e  480f              LDR      r0,|L50.92|
000020  6800              LDR      r0,[r0,#0]            ;1498  ; RMP_Cur_Thd
000022  f7fffffe          BL       _RMP_Clr_Rdy
000026  480d              LDR      r0,|L50.92|
000028  6800              LDR      r0,[r0,#0]            ;1499  ; RMP_Cur_Thd
00002a  6980              LDR      r0,[r0,#0x18]         ;1499
00002c  f02000ff          BIC      r0,r0,#0xff           ;1499
000030  1d80              ADDS     r0,r0,#6              ;1499
000032  490a              LDR      r1,|L50.92|
000034  6809              LDR      r1,[r1,#0]            ;1499  ; RMP_Cur_Thd
000036  6188              STR      r0,[r1,#0x18]         ;1499
000038  4621              MOV      r1,r4                 ;1500
00003a  4808              LDR      r0,|L50.92|
00003c  6800              LDR      r0,[r0,#0]            ;1500  ; RMP_Cur_Thd
00003e  f7fffffe          BL       _RMP_Dly_Ins
000042  2000              MOVS     r0,#0                 ;1502
000044  4905              LDR      r1,|L50.92|
000046  6809              LDR      r1,[r1,#0]            ;1502  ; RMP_Cur_Thd
000048  6388              STR      r0,[r1,#0x38]         ;1502
00004a  f7fffffe          BL       RMP_Unlock_Sched
00004e  4803              LDR      r0,|L50.92|
000050  6800              LDR      r0,[r0,#0]            ;1505  ; RMP_Cur_Thd
000052  6b80              LDR      r0,[r0,#0x38]         ;1505
000054  e7de              B        |L50.20|
;;;1507   /* End Function:RMP_Thd_Delay ************************************************/
                          ENDP

000056  0000              DCW      0x0000
                  |L50.88|
                          DCD      0x000186a0
                  |L50.92|
                          DCD      RMP_Cur_Thd

                          AREA ||i.RMP_Thd_Rcv||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Rcv PROC
;;;1367   ******************************************************************************/
;;;1368   rmp_ret_t RMP_Thd_Rcv(rmp_ptr_t* Data, rmp_ptr_t Slices)
000000  b570              PUSH     {r4-r6,lr}
;;;1369   {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;1370       struct RMP_Thd* Sender;
;;;1371       
;;;1372       if(Data==0)
000006  b925              CBNZ     r5,|L51.18|
;;;1373       {
;;;1374           RMP_COVERAGE_MARKER();
000008  bf00              NOP      
00000a  bf00              NOP      
;;;1375           return RMP_ERR_OPER;
00000c  f06f0004          MVN      r0,#4
                  |L51.16|
;;;1376       }
;;;1377       else
;;;1378           RMP_COVERAGE_MARKER();
;;;1379       
;;;1380       RMP_Lock_Sched();
;;;1381       
;;;1382       /* Is there any other guy waiting on us? If there is, unblock it and set it running */
;;;1383       Sender=0;
;;;1384       if(&(RMP_Cur_Thd->Snd_List)!=RMP_Cur_Thd->Snd_List.Next)
;;;1385       {
;;;1386           RMP_COVERAGE_MARKER();
;;;1387           /* Read the data */
;;;1388           Sender=(struct RMP_Thd*)(RMP_Cur_Thd->Snd_List.Next);
;;;1389           RMP_List_Del(Sender->Run_Head.Prev,Sender->Run_Head.Next);
;;;1390           *Data=Sender->Data;
;;;1391           /* Now we unblock it - what state is it in? */
;;;1392           if((RMP_THD_STATE(Sender->State)==RMP_THD_SNDDLY))
;;;1393           {
;;;1394               RMP_COVERAGE_MARKER();
;;;1395               RMP_List_Del(Sender->Dly_Head.Prev,Sender->Dly_Head.Next);
;;;1396           }
;;;1397           else
;;;1398               RMP_COVERAGE_MARKER();
;;;1399           
;;;1400           RMP_THD_STATE_SET(Sender->State,RMP_THD_RUNNING);
;;;1401           /* Set to running if not suspended */
;;;1402           _RMP_Set_Rdy(Sender);
;;;1403       }
;;;1404   
;;;1405       /* Check if there is a value in our mailbox. If yes, we return with that value */
;;;1406       if((RMP_Cur_Thd->State&RMP_THD_MBOXFUL)!=0)
;;;1407       {
;;;1408           RMP_COVERAGE_MARKER();
;;;1409           /* Get the value from mailbox */
;;;1410           *Data=RMP_Cur_Thd->Mailbox;
;;;1411           /* See if we unblocked a sender. If yes, we place the new value into 
;;;1412            * our mailbox and it is still full */
;;;1413           if(Sender!=0)
;;;1414               RMP_Cur_Thd->Mailbox=Sender->Data;
;;;1415           else
;;;1416               RMP_Cur_Thd->State&=~RMP_THD_MBOXFUL;
;;;1417           
;;;1418           RMP_Unlock_Sched();
;;;1419           return 0;
;;;1420       }
;;;1421       else
;;;1422       {
;;;1423           RMP_COVERAGE_MARKER();
;;;1424           
;;;1425           /* Box empty. Do we have somebody waiting? */
;;;1426           if(Sender!=0)
;;;1427           {
;;;1428               RMP_COVERAGE_MARKER();
;;;1429               RMP_Cur_Thd->Mailbox=Sender->Data;
;;;1430               RMP_Unlock_Sched();
;;;1431               return 0;
;;;1432           }
;;;1433           /* No sender waiting on us and box empty, we need to block */
;;;1434           else
;;;1435           {
;;;1436               RMP_COVERAGE_MARKER();
;;;1437               
;;;1438               if(Slices==0)
;;;1439               {
;;;1440                   RMP_COVERAGE_MARKER();
;;;1441                   RMP_Unlock_Sched();
;;;1442                   return RMP_ERR_OPER;
;;;1443               }
;;;1444               else
;;;1445                   RMP_COVERAGE_MARKER();
;;;1446   
;;;1447               /* We must be running and not suspended so we will surely be deleted from queue */
;;;1448               _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1449   
;;;1450               if(Slices<RMP_MAX_SLICES)
;;;1451               {
;;;1452                   RMP_COVERAGE_MARKER();
;;;1453                   _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1454                   RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_RCVDLY);
;;;1455               }
;;;1456               else
;;;1457               {
;;;1458                   RMP_COVERAGE_MARKER();
;;;1459                   RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_RCVBLK);
;;;1460               }
;;;1461               RMP_Unlock_Sched();
;;;1462               
;;;1463               /* Dummy read - to separate the lock & unlock. If the compiler optimizes these two
;;;1464                * functions(inline them) on some architectures sometimes we never block. */
;;;1465               *Data=RMP_Cur_Thd->Mailbox;
;;;1466               
;;;1467               /* We've been unblocked. There must be something in our mbox, or we should have failed */
;;;1468               RMP_Lock_Sched();
;;;1469               *Data=RMP_Cur_Thd->Mailbox;
;;;1470               RMP_Cur_Thd->State&=~RMP_THD_MBOXFUL;
;;;1471           }
;;;1472       }
;;;1473       
;;;1474       RMP_Unlock_Sched();
;;;1475       return RMP_Cur_Thd->Retval;
;;;1476   }
000010  bd70              POP      {r4-r6,pc}
                  |L51.18|
000012  bf00              NOP                            ;1378
000014  bf00              NOP                            ;1378
000016  f7fffffe          BL       RMP_Lock_Sched
00001a  2400              MOVS     r4,#0                 ;1383
00001c  484d              LDR      r0,|L51.340|
00001e  6800              LDR      r0,[r0,#0]            ;1384  ; RMP_Cur_Thd
000020  6941              LDR      r1,[r0,#0x14]         ;1384
000022  484c              LDR      r0,|L51.340|
000024  6800              LDR      r0,[r0,#0]            ;1384  ; RMP_Cur_Thd
000026  3010              ADDS     r0,r0,#0x10           ;1384
000028  4281              CMP      r1,r0                 ;1384
00002a  d01e              BEQ      |L51.106|
00002c  bf00              NOP                            ;1386
00002e  bf00              NOP                            ;1386
000030  4848              LDR      r0,|L51.340|
000032  6800              LDR      r0,[r0,#0]            ;1388  ; RMP_Cur_Thd
000034  6944              LDR      r4,[r0,#0x14]         ;1388
000036  e9d40100          LDRD     r0,r1,[r4,#0]         ;1389
00003a  f7fffffe          BL       RMP_List_Del
00003e  6b20              LDR      r0,[r4,#0x30]         ;1390
000040  6028              STR      r0,[r5,#0]            ;1390
000042  7e20              LDRB     r0,[r4,#0x18]         ;1392
000044  2803              CMP      r0,#3                 ;1392
000046  d106              BNE      |L51.86|
000048  bf00              NOP                            ;1394
00004a  bf00              NOP                            ;1394
00004c  e9d40102          LDRD     r0,r1,[r4,#8]         ;1395
000050  f7fffffe          BL       RMP_List_Del
000054  e001              B        |L51.90|
                  |L51.86|
000056  bf00              NOP                            ;1398
000058  bf00              NOP                            ;1398
                  |L51.90|
00005a  69a0              LDR      r0,[r4,#0x18]         ;1400
00005c  f02000ff          BIC      r0,r0,#0xff           ;1400
000060  1c40              ADDS     r0,r0,#1              ;1400
000062  61a0              STR      r0,[r4,#0x18]         ;1400
000064  4620              MOV      r0,r4                 ;1402
000066  f7fffffe          BL       _RMP_Set_Rdy
                  |L51.106|
00006a  483a              LDR      r0,|L51.340|
00006c  6800              LDR      r0,[r0,#0]            ;1406  ; RMP_Cur_Thd
00006e  8b00              LDRH     r0,[r0,#0x18]         ;1406
000070  f4007000          AND      r0,r0,#0x200          ;1406
000074  b1b8              CBZ      r0,|L51.166|
000076  bf00              NOP                            ;1408
000078  bf00              NOP                            ;1408
00007a  4836              LDR      r0,|L51.340|
00007c  6800              LDR      r0,[r0,#0]            ;1410  ; RMP_Cur_Thd
00007e  6ac0              LDR      r0,[r0,#0x2c]         ;1410
000080  6028              STR      r0,[r5,#0]            ;1410
000082  b124              CBZ      r4,|L51.142|
000084  4933              LDR      r1,|L51.340|
000086  6b20              LDR      r0,[r4,#0x30]         ;1414
000088  6809              LDR      r1,[r1,#0]            ;1414  ; RMP_Cur_Thd
00008a  62c8              STR      r0,[r1,#0x2c]         ;1414
00008c  e007              B        |L51.158|
                  |L51.142|
00008e  4931              LDR      r1,|L51.340|
000090  6809              LDR      r1,[r1,#0]            ;1416  ; RMP_Cur_Thd
000092  f1010018          ADD      r0,r1,#0x18           ;1416
000096  6989              LDR      r1,[r1,#0x18]         ;1416
000098  f4217100          BIC      r1,r1,#0x200          ;1416
00009c  6001              STR      r1,[r0,#0]            ;1416
                  |L51.158|
00009e  f7fffffe          BL       RMP_Unlock_Sched
0000a2  2000              MOVS     r0,#0                 ;1419
0000a4  e7b4              B        |L51.16|
                  |L51.166|
0000a6  bf00              NOP                            ;1423
0000a8  bf00              NOP                            ;1423
0000aa  b14c              CBZ      r4,|L51.192|
0000ac  bf00              NOP                            ;1428
0000ae  bf00              NOP                            ;1428
0000b0  4928              LDR      r1,|L51.340|
0000b2  6b20              LDR      r0,[r4,#0x30]         ;1429
0000b4  6809              LDR      r1,[r1,#0]            ;1429  ; RMP_Cur_Thd
0000b6  62c8              STR      r0,[r1,#0x2c]         ;1429
0000b8  f7fffffe          BL       RMP_Unlock_Sched
0000bc  2000              MOVS     r0,#0                 ;1431
0000be  e7a7              B        |L51.16|
                  |L51.192|
0000c0  bf00              NOP                            ;1436
0000c2  bf00              NOP                            ;1436
0000c4  b936              CBNZ     r6,|L51.212|
0000c6  bf00              NOP                            ;1440
0000c8  bf00              NOP                            ;1440
0000ca  f7fffffe          BL       RMP_Unlock_Sched
0000ce  f06f0004          MVN      r0,#4                 ;1442
0000d2  e79d              B        |L51.16|
                  |L51.212|
0000d4  bf00              NOP                            ;1445
0000d6  bf00              NOP                            ;1445
0000d8  481e              LDR      r0,|L51.340|
0000da  6800              LDR      r0,[r0,#0]            ;1448  ; RMP_Cur_Thd
0000dc  f7fffffe          BL       _RMP_Clr_Rdy
0000e0  481d              LDR      r0,|L51.344|
0000e2  4286              CMP      r6,r0                 ;1450
0000e4  d210              BCS      |L51.264|
0000e6  bf00              NOP                            ;1452
0000e8  bf00              NOP                            ;1452
0000ea  4631              MOV      r1,r6                 ;1453
0000ec  4819              LDR      r0,|L51.340|
0000ee  6800              LDR      r0,[r0,#0]            ;1453  ; RMP_Cur_Thd
0000f0  f7fffffe          BL       _RMP_Dly_Ins
0000f4  4817              LDR      r0,|L51.340|
0000f6  6800              LDR      r0,[r0,#0]            ;1454  ; RMP_Cur_Thd
0000f8  6980              LDR      r0,[r0,#0x18]         ;1454
0000fa  f02000ff          BIC      r0,r0,#0xff           ;1454
0000fe  1d40              ADDS     r0,r0,#5              ;1454
000100  4914              LDR      r1,|L51.340|
000102  6809              LDR      r1,[r1,#0]            ;1454  ; RMP_Cur_Thd
000104  6188              STR      r0,[r1,#0x18]         ;1454
000106  e00a              B        |L51.286|
                  |L51.264|
000108  bf00              NOP                            ;1458
00010a  bf00              NOP                            ;1458
00010c  4811              LDR      r0,|L51.340|
00010e  6800              LDR      r0,[r0,#0]            ;1459  ; RMP_Cur_Thd
000110  6980              LDR      r0,[r0,#0x18]         ;1459
000112  f02000ff          BIC      r0,r0,#0xff           ;1459
000116  1d00              ADDS     r0,r0,#4              ;1459
000118  490e              LDR      r1,|L51.340|
00011a  6809              LDR      r1,[r1,#0]            ;1459  ; RMP_Cur_Thd
00011c  6188              STR      r0,[r1,#0x18]         ;1459
                  |L51.286|
00011e  f7fffffe          BL       RMP_Unlock_Sched
000122  480c              LDR      r0,|L51.340|
000124  6800              LDR      r0,[r0,#0]            ;1465  ; RMP_Cur_Thd
000126  6ac0              LDR      r0,[r0,#0x2c]         ;1465
000128  6028              STR      r0,[r5,#0]            ;1465
00012a  f7fffffe          BL       RMP_Lock_Sched
00012e  4809              LDR      r0,|L51.340|
000130  6800              LDR      r0,[r0,#0]            ;1469  ; RMP_Cur_Thd
000132  6ac0              LDR      r0,[r0,#0x2c]         ;1469
000134  6028              STR      r0,[r5,#0]            ;1469
000136  4907              LDR      r1,|L51.340|
000138  6809              LDR      r1,[r1,#0]            ;1470  ; RMP_Cur_Thd
00013a  f1010018          ADD      r0,r1,#0x18           ;1470
00013e  6989              LDR      r1,[r1,#0x18]         ;1470
000140  f4217100          BIC      r1,r1,#0x200          ;1470
000144  6001              STR      r1,[r0,#0]            ;1470
000146  f7fffffe          BL       RMP_Unlock_Sched
00014a  4802              LDR      r0,|L51.340|
00014c  6800              LDR      r0,[r0,#0]            ;1475  ; RMP_Cur_Thd
00014e  6b80              LDR      r0,[r0,#0x38]         ;1475
000150  e75e              B        |L51.16|
;;;1477   /* End Function:RMP_Thd_Rcv **************************************************/
                          ENDP

000152  0000              DCW      0x0000
                  |L51.340|
                          DCD      RMP_Cur_Thd
                  |L51.344|
                          DCD      0x000186a0

                          AREA ||i.RMP_Thd_Resume||, CODE, READONLY, ALIGN=1

                  RMP_Thd_Resume PROC
;;;1111   ******************************************************************************/
;;;1112   rmp_ret_t RMP_Thd_Resume(volatile struct RMP_Thd* Thread)
000000  b570              PUSH     {r4-r6,lr}
;;;1113   {
000002  4604              MOV      r4,r0
;;;1114       rmp_ret_t Retval;
;;;1115       
;;;1116       /* Check if this thread structure could possibly be in use */
;;;1117       if(Thread==0)
000004  b924              CBNZ     r4,|L52.16|
;;;1118       {
;;;1119           RMP_COVERAGE_MARKER();
000006  bf00              NOP      
000008  bf00              NOP      
;;;1120           return RMP_ERR_THD;
00000a  f04f30ff          MOV      r0,#0xffffffff
                  |L52.14|
;;;1121       }
;;;1122       else
;;;1123           RMP_COVERAGE_MARKER();
;;;1124   
;;;1125       RMP_Lock_Sched();
;;;1126       
;;;1127       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;1128       {
;;;1129           RMP_COVERAGE_MARKER();
;;;1130           RMP_Unlock_Sched();
;;;1131           return RMP_ERR_THD;
;;;1132       }
;;;1133       else
;;;1134           RMP_COVERAGE_MARKER();
;;;1135       
;;;1136       /* Check if the thread is suspended, if not, then throw an error */
;;;1137       if((Thread->State&RMP_THD_SUSPENDED)!=0)
;;;1138       {
;;;1139           RMP_COVERAGE_MARKER();
;;;1140           
;;;1141           /* Suspended */
;;;1142           Thread->State&=~RMP_THD_SUSPENDED;
;;;1143           /* Only when it is running will we put it back. It can't be suspended here, 
;;;1144            * so the set ready operation will surely put it back */
;;;1145           if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
;;;1146           {
;;;1147               RMP_COVERAGE_MARKER();
;;;1148               _RMP_Set_Rdy(Thread);
;;;1149           }
;;;1150           else
;;;1151               RMP_COVERAGE_MARKER();
;;;1152           
;;;1153           Retval=0;
;;;1154       }
;;;1155       else
;;;1156       {
;;;1157           RMP_COVERAGE_MARKER();
;;;1158           Retval=RMP_ERR_STATE;
;;;1159       }
;;;1160       
;;;1161       RMP_Unlock_Sched();
;;;1162   
;;;1163       return Retval;
;;;1164   }
00000e  bd70              POP      {r4-r6,pc}
                  |L52.16|
000010  bf00              NOP                            ;1123
000012  bf00              NOP                            ;1123
000014  f7fffffe          BL       RMP_Lock_Sched
000018  69a0              LDR      r0,[r4,#0x18]         ;1127
00001a  b2c0              UXTB     r0,r0                 ;1127
00001c  b930              CBNZ     r0,|L52.44|
00001e  bf00              NOP                            ;1129
000020  bf00              NOP                            ;1129
000022  f7fffffe          BL       RMP_Unlock_Sched
000026  f04f30ff          MOV      r0,#0xffffffff        ;1131
00002a  e7f0              B        |L52.14|
                  |L52.44|
00002c  bf00              NOP                            ;1134
00002e  bf00              NOP                            ;1134
000030  69a0              LDR      r0,[r4,#0x18]         ;1137
000032  f4007080          AND      r0,r0,#0x100          ;1137
000036  b198              CBZ      r0,|L52.96|
000038  bf00              NOP                            ;1139
00003a  bf00              NOP                            ;1139
00003c  69a0              LDR      r0,[r4,#0x18]         ;1142
00003e  f4207080          BIC      r0,r0,#0x100          ;1142
000042  61a0              STR      r0,[r4,#0x18]         ;1142
000044  69a0              LDR      r0,[r4,#0x18]         ;1145
000046  b2c0              UXTB     r0,r0                 ;1145
000048  2801              CMP      r0,#1                 ;1145
00004a  d105              BNE      |L52.88|
00004c  bf00              NOP                            ;1147
00004e  bf00              NOP                            ;1147
000050  4620              MOV      r0,r4                 ;1148
000052  f7fffffe          BL       _RMP_Set_Rdy
000056  e001              B        |L52.92|
                  |L52.88|
000058  bf00              NOP                            ;1151
00005a  bf00              NOP                            ;1151
                  |L52.92|
00005c  2500              MOVS     r5,#0                 ;1153
00005e  e003              B        |L52.104|
                  |L52.96|
000060  bf00              NOP                            ;1157
000062  bf00              NOP                            ;1157
000064  f06f0503          MVN      r5,#3                 ;1158
                  |L52.104|
000068  f7fffffe          BL       RMP_Unlock_Sched
00006c  4628              MOV      r0,r5                 ;1163
00006e  e7ce              B        |L52.14|
;;;1165   /* End Function:RMP_Thd_Resume ***********************************************/
                          ENDP


                          AREA ||i.RMP_Thd_Set||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Set PROC
;;;951    ******************************************************************************/
;;;952    rmp_ret_t RMP_Thd_Set(volatile struct RMP_Thd* Thread, rmp_ptr_t Prio, rmp_ptr_t Slices)
000000  b570              PUSH     {r4-r6,lr}
;;;953    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;954        /* Check if the priority and timeslice range is correct */
;;;955        if(Slices==0)
000008  b925              CBNZ     r5,|L53.20|
;;;956        {
;;;957            RMP_COVERAGE_MARKER();
00000a  bf00              NOP      
00000c  bf00              NOP      
;;;958            return RMP_ERR_SLICE;
00000e  f06f0002          MVN      r0,#2
                  |L53.18|
;;;959        }
;;;960        else
;;;961            RMP_COVERAGE_MARKER();
;;;962        
;;;963        /* Check if this thread structure could possibly be in use */
;;;964        if(Thread==0)
;;;965        {
;;;966            RMP_COVERAGE_MARKER();
;;;967            return RMP_ERR_THD;
;;;968        }
;;;969        else
;;;970            RMP_COVERAGE_MARKER();
;;;971        
;;;972        RMP_Lock_Sched();
;;;973        
;;;974        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;975        {
;;;976            RMP_COVERAGE_MARKER();
;;;977            RMP_Unlock_Sched();
;;;978            return RMP_ERR_THD;
;;;979        }
;;;980        else
;;;981            RMP_COVERAGE_MARKER();
;;;982        
;;;983        /* See if the thread is in running state */
;;;984        if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
;;;985        {
;;;986            RMP_COVERAGE_MARKER();
;;;987            
;;;988            /* See if we are gonna change one of it or both */
;;;989            if(Prio<RMP_MAX_PREEMPT_PRIO)
;;;990            {
;;;991                RMP_COVERAGE_MARKER();
;;;992                if(Thread->Prio!=Prio)
;;;993                {
;;;994                    RMP_COVERAGE_MARKER();
;;;995                    /* It doesn't matter whether this is suspended or not. 
;;;996                     * If suspended, the operations will not be conducted. */
;;;997                    _RMP_Clr_Rdy(Thread);
;;;998                    Thread->Prio=Prio;
;;;999                    _RMP_Set_Rdy(Thread);
;;;1000               }
;;;1001               else
;;;1002                   RMP_COVERAGE_MARKER();
;;;1003           }
;;;1004           else
;;;1005               RMP_COVERAGE_MARKER();
;;;1006           
;;;1007           if(Slices<RMP_MAX_SLICES)
;;;1008           {
;;;1009               RMP_COVERAGE_MARKER();
;;;1010               Thread->Slices=Slices;
;;;1011           }
;;;1012           else
;;;1013               RMP_COVERAGE_MARKER();
;;;1014       }
;;;1015       else
;;;1016       {
;;;1017           RMP_COVERAGE_MARKER();
;;;1018           
;;;1019           if(Prio<RMP_MAX_PREEMPT_PRIO)
;;;1020           {
;;;1021               RMP_COVERAGE_MARKER();
;;;1022               Thread->Prio=Prio;
;;;1023           }
;;;1024           else
;;;1025               RMP_COVERAGE_MARKER();
;;;1026           
;;;1027           if(Slices<RMP_MAX_SLICES)
;;;1028           {
;;;1029               RMP_COVERAGE_MARKER();
;;;1030               Thread->Slices=Slices;
;;;1031           }
;;;1032           else
;;;1033               RMP_COVERAGE_MARKER();
;;;1034       }
;;;1035       
;;;1036       RMP_Unlock_Sched();
;;;1037       return 0;
;;;1038   }
000012  bd70              POP      {r4-r6,pc}
                  |L53.20|
000014  bf00              NOP                            ;961
000016  bf00              NOP                            ;961
000018  b924              CBNZ     r4,|L53.36|
00001a  bf00              NOP                            ;966
00001c  bf00              NOP                            ;966
00001e  f04f30ff          MOV      r0,#0xffffffff        ;967
000022  e7f6              B        |L53.18|
                  |L53.36|
000024  bf00              NOP                            ;970
000026  bf00              NOP                            ;970
000028  f7fffffe          BL       RMP_Lock_Sched
00002c  69a0              LDR      r0,[r4,#0x18]         ;974
00002e  b2c0              UXTB     r0,r0                 ;974
000030  b930              CBNZ     r0,|L53.64|
000032  bf00              NOP                            ;976
000034  bf00              NOP                            ;976
000036  f7fffffe          BL       RMP_Unlock_Sched
00003a  f04f30ff          MOV      r0,#0xffffffff        ;978
00003e  e7e8              B        |L53.18|
                  |L53.64|
000040  bf00              NOP                            ;981
000042  bf00              NOP                            ;981
000044  69a0              LDR      r0,[r4,#0x18]         ;984
000046  b2c0              UXTB     r0,r0                 ;984
000048  2801              CMP      r0,#1                 ;984
00004a  d11f              BNE      |L53.140|
00004c  bf00              NOP                            ;986
00004e  bf00              NOP                            ;986
000050  2e20              CMP      r6,#0x20              ;989
000052  d210              BCS      |L53.118|
000054  bf00              NOP                            ;991
000056  bf00              NOP                            ;991
000058  6a60              LDR      r0,[r4,#0x24]         ;992
00005a  42b0              CMP      r0,r6                 ;992
00005c  d009              BEQ      |L53.114|
00005e  bf00              NOP                            ;994
000060  bf00              NOP                            ;994
000062  4620              MOV      r0,r4                 ;997
000064  f7fffffe          BL       _RMP_Clr_Rdy
000068  6266              STR      r6,[r4,#0x24]         ;998
00006a  4620              MOV      r0,r4                 ;999
00006c  f7fffffe          BL       _RMP_Set_Rdy
000070  e003              B        |L53.122|
                  |L53.114|
000072  bf00              NOP                            ;1002
000074  e001              B        |L53.122|
                  |L53.118|
000076  bf00              NOP                            ;1005
000078  bf00              NOP                            ;1005
                  |L53.122|
00007a  4810              LDR      r0,|L53.188|
00007c  4285              CMP      r5,r0                 ;1007
00007e  d203              BCS      |L53.136|
000080  bf00              NOP                            ;1009
000082  bf00              NOP                            ;1009
000084  61e5              STR      r5,[r4,#0x1c]         ;1010
000086  e014              B        |L53.178|
                  |L53.136|
000088  bf00              NOP                            ;1013
00008a  e012              B        |L53.178|
                  |L53.140|
00008c  bf00              NOP                            ;1017
00008e  bf00              NOP                            ;1017
000090  2e20              CMP      r6,#0x20              ;1019
000092  d203              BCS      |L53.156|
000094  bf00              NOP                            ;1021
000096  bf00              NOP                            ;1021
000098  6266              STR      r6,[r4,#0x24]         ;1022
00009a  e001              B        |L53.160|
                  |L53.156|
00009c  bf00              NOP                            ;1025
00009e  bf00              NOP                            ;1025
                  |L53.160|
0000a0  4806              LDR      r0,|L53.188|
0000a2  4285              CMP      r5,r0                 ;1027
0000a4  d203              BCS      |L53.174|
0000a6  bf00              NOP                            ;1029
0000a8  bf00              NOP                            ;1029
0000aa  61e5              STR      r5,[r4,#0x1c]         ;1030
0000ac  e001              B        |L53.178|
                  |L53.174|
0000ae  bf00              NOP                            ;1033
0000b0  bf00              NOP                            ;1033
                  |L53.178|
0000b2  f7fffffe          BL       RMP_Unlock_Sched
0000b6  2000              MOVS     r0,#0                 ;1037
0000b8  e7ab              B        |L53.18|
;;;1039   /* End Function:RMP_Thd_Set **************************************************/
                          ENDP

0000ba  0000              DCW      0x0000
                  |L53.188|
                          DCD      0x000186a0

                          AREA ||i.RMP_Thd_Snd||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Snd PROC
;;;1175   ******************************************************************************/
;;;1176   rmp_ret_t RMP_Thd_Snd(volatile struct RMP_Thd* Thread, rmp_ptr_t Data, rmp_ptr_t Slices)
000000  b570              PUSH     {r4-r6,lr}
;;;1177   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;1178       /* Check if this thread structure could possibly be in use */
;;;1179       if(Thread==0)
000008  b924              CBNZ     r4,|L54.20|
;;;1180       {
;;;1181           RMP_COVERAGE_MARKER();
00000a  bf00              NOP      
00000c  bf00              NOP      
;;;1182           return RMP_ERR_THD;
00000e  f04f30ff          MOV      r0,#0xffffffff
                  |L54.18|
;;;1183       }
;;;1184       else
;;;1185           RMP_COVERAGE_MARKER();
;;;1186       
;;;1187       RMP_Lock_Sched();
;;;1188       
;;;1189       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;1190       {
;;;1191           RMP_COVERAGE_MARKER();
;;;1192           RMP_Unlock_Sched();
;;;1193           return RMP_ERR_THD;
;;;1194       }
;;;1195       else
;;;1196           RMP_COVERAGE_MARKER();
;;;1197       
;;;1198       /* Are we sending to ourself? This is not allowed */
;;;1199       if(RMP_Cur_Thd==Thread)
;;;1200       {
;;;1201           RMP_COVERAGE_MARKER();
;;;1202           RMP_Unlock_Sched();
;;;1203           return RMP_ERR_OPER;
;;;1204       }
;;;1205       else
;;;1206           RMP_COVERAGE_MARKER();
;;;1207       
;;;1208       RMP_Cur_Thd->Retval=0;
;;;1209   
;;;1210       /* See if there is already a value in the mailbox, if yes, we block */
;;;1211       if((Thread->State&RMP_THD_MBOXFUL)!=0)
;;;1212       {
;;;1213           RMP_COVERAGE_MARKER();
;;;1214           
;;;1215           /* Mailbox full, we block, and put ourself into the queue */
;;;1216           if(Slices==0)
;;;1217           {
;;;1218               RMP_COVERAGE_MARKER();
;;;1219               RMP_Unlock_Sched();
;;;1220               return RMP_ERR_OPER;
;;;1221           }
;;;1222           else
;;;1223               RMP_COVERAGE_MARKER();
;;;1224   
;;;1225           /* We must be running */
;;;1226           _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1227           RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),Thread->Snd_List.Prev,&(Thread->Snd_List));
;;;1228   
;;;1229           if(Slices<RMP_MAX_SLICES)
;;;1230           {
;;;1231               RMP_COVERAGE_MARKER();
;;;1232               _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1233               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SNDDLY);
;;;1234           }
;;;1235           else
;;;1236           {
;;;1237               RMP_COVERAGE_MARKER();
;;;1238               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SNDBLK);
;;;1239           }
;;;1240   
;;;1241           RMP_Cur_Thd->Data=Data;
;;;1242       }
;;;1243       else
;;;1244       {
;;;1245           RMP_COVERAGE_MARKER();
;;;1246           
;;;1247           /* Mailbox not full. We need to check if the receiver is waiting for us */
;;;1248           if((RMP_THD_STATE(Thread->State)==RMP_THD_RCVBLK)||
;;;1249              (RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY))
;;;1250           {
;;;1251               RMP_COVERAGE_MARKER();
;;;1252               
;;;1253               /* The receiver is blocked, wake it up and return the value */
;;;1254               if(RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY)
;;;1255               {
;;;1256                   RMP_COVERAGE_MARKER();
;;;1257                   RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1258               }
;;;1259               else
;;;1260                   RMP_COVERAGE_MARKER();
;;;1261               
;;;1262               RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1263               /* Set to running if not suspended */
;;;1264               _RMP_Set_Rdy(Thread);
;;;1265           }
;;;1266           else
;;;1267               RMP_COVERAGE_MARKER();
;;;1268           
;;;1269           /* Set the mailbox */
;;;1270           Thread->Mailbox=Data;
;;;1271           Thread->State|=RMP_THD_MBOXFUL;
;;;1272       }
;;;1273       
;;;1274       RMP_Unlock_Sched();
;;;1275   
;;;1276       return RMP_Cur_Thd->Retval;
;;;1277   }
000012  bd70              POP      {r4-r6,pc}
                  |L54.20|
000014  bf00              NOP                            ;1185
000016  bf00              NOP                            ;1185
000018  f7fffffe          BL       RMP_Lock_Sched
00001c  69a0              LDR      r0,[r4,#0x18]         ;1189
00001e  b2c0              UXTB     r0,r0                 ;1189
000020  b930              CBNZ     r0,|L54.48|
000022  bf00              NOP                            ;1191
000024  bf00              NOP                            ;1191
000026  f7fffffe          BL       RMP_Unlock_Sched
00002a  f04f30ff          MOV      r0,#0xffffffff        ;1193
00002e  e7f0              B        |L54.18|
                  |L54.48|
000030  bf00              NOP                            ;1196
000032  bf00              NOP                            ;1196
000034  483f              LDR      r0,|L54.308|
000036  6800              LDR      r0,[r0,#0]            ;1199  ; RMP_Cur_Thd
000038  42a0              CMP      r0,r4                 ;1199
00003a  d106              BNE      |L54.74|
00003c  bf00              NOP                            ;1201
00003e  bf00              NOP                            ;1201
000040  f7fffffe          BL       RMP_Unlock_Sched
000044  f06f0004          MVN      r0,#4                 ;1203
000048  e7e3              B        |L54.18|
                  |L54.74|
00004a  bf00              NOP                            ;1206
00004c  bf00              NOP                            ;1206
00004e  2000              MOVS     r0,#0                 ;1208
000050  4938              LDR      r1,|L54.308|
000052  6809              LDR      r1,[r1,#0]            ;1208  ; RMP_Cur_Thd
000054  6388              STR      r0,[r1,#0x38]         ;1208
000056  69a0              LDR      r0,[r4,#0x18]         ;1211
000058  f4007000          AND      r0,r0,#0x200          ;1211
00005c  b3c8              CBZ      r0,|L54.210|
00005e  bf00              NOP                            ;1213
000060  bf00              NOP                            ;1213
000062  b935              CBNZ     r5,|L54.114|
000064  bf00              NOP                            ;1218
000066  bf00              NOP                            ;1218
000068  f7fffffe          BL       RMP_Unlock_Sched
00006c  f06f0004          MVN      r0,#4                 ;1220
000070  e7cf              B        |L54.18|
                  |L54.114|
000072  bf00              NOP                            ;1223
000074  bf00              NOP                            ;1223
000076  482f              LDR      r0,|L54.308|
000078  6800              LDR      r0,[r0,#0]            ;1226  ; RMP_Cur_Thd
00007a  f7fffffe          BL       _RMP_Clr_Rdy
00007e  6921              LDR      r1,[r4,#0x10]         ;1227
000080  f1040210          ADD      r2,r4,#0x10           ;1227
000084  482b              LDR      r0,|L54.308|
000086  6800              LDR      r0,[r0,#0]            ;1227  ; RMP_Cur_Thd
000088  f7fffffe          BL       RMP_List_Ins
00008c  482a              LDR      r0,|L54.312|
00008e  4285              CMP      r5,r0                 ;1229
000090  d210              BCS      |L54.180|
000092  bf00              NOP                            ;1231
000094  bf00              NOP                            ;1231
000096  4629              MOV      r1,r5                 ;1232
000098  4826              LDR      r0,|L54.308|
00009a  6800              LDR      r0,[r0,#0]            ;1232  ; RMP_Cur_Thd
00009c  f7fffffe          BL       _RMP_Dly_Ins
0000a0  4824              LDR      r0,|L54.308|
0000a2  6800              LDR      r0,[r0,#0]            ;1233  ; RMP_Cur_Thd
0000a4  6980              LDR      r0,[r0,#0x18]         ;1233
0000a6  f02000ff          BIC      r0,r0,#0xff           ;1233
0000aa  1cc0              ADDS     r0,r0,#3              ;1233
0000ac  4921              LDR      r1,|L54.308|
0000ae  6809              LDR      r1,[r1,#0]            ;1233  ; RMP_Cur_Thd
0000b0  6188              STR      r0,[r1,#0x18]         ;1233
0000b2  e00a              B        |L54.202|
                  |L54.180|
0000b4  bf00              NOP                            ;1237
0000b6  bf00              NOP                            ;1237
0000b8  481e              LDR      r0,|L54.308|
0000ba  6800              LDR      r0,[r0,#0]            ;1238  ; RMP_Cur_Thd
0000bc  6980              LDR      r0,[r0,#0x18]         ;1238
0000be  f02000ff          BIC      r0,r0,#0xff           ;1238
0000c2  1c80              ADDS     r0,r0,#2              ;1238
0000c4  491b              LDR      r1,|L54.308|
0000c6  6809              LDR      r1,[r1,#0]            ;1238  ; RMP_Cur_Thd
0000c8  6188              STR      r0,[r1,#0x18]         ;1238
                  |L54.202|
0000ca  481a              LDR      r0,|L54.308|
0000cc  6800              LDR      r0,[r0,#0]            ;1241  ; RMP_Cur_Thd
0000ce  6306              STR      r6,[r0,#0x30]         ;1241
0000d0  e029              B        |L54.294|
                  |L54.210|
0000d2  e7ff              B        |L54.212|
                  |L54.212|
0000d4  bf00              NOP                            ;1245
0000d6  bf00              NOP                            ;1245
0000d8  69a0              LDR      r0,[r4,#0x18]         ;1248
0000da  b2c0              UXTB     r0,r0                 ;1248
0000dc  2804              CMP      r0,#4                 ;1248
0000de  d003              BEQ      |L54.232|
0000e0  69a0              LDR      r0,[r4,#0x18]         ;1249
0000e2  b2c0              UXTB     r0,r0                 ;1249
0000e4  2805              CMP      r0,#5                 ;1249
0000e6  d117              BNE      |L54.280|
                  |L54.232|
0000e8  bf00              NOP                            ;1251
0000ea  bf00              NOP                            ;1251
0000ec  69a0              LDR      r0,[r4,#0x18]         ;1254
0000ee  b2c0              UXTB     r0,r0                 ;1254
0000f0  2805              CMP      r0,#5                 ;1254
0000f2  d106              BNE      |L54.258|
0000f4  bf00              NOP                            ;1256
0000f6  bf00              NOP                            ;1256
0000f8  68e1              LDR      r1,[r4,#0xc]          ;1257
0000fa  68a0              LDR      r0,[r4,#8]            ;1257
0000fc  f7fffffe          BL       RMP_List_Del
000100  e001              B        |L54.262|
                  |L54.258|
000102  bf00              NOP                            ;1260
000104  bf00              NOP                            ;1260
                  |L54.262|
000106  69a0              LDR      r0,[r4,#0x18]         ;1262
000108  f02000ff          BIC      r0,r0,#0xff           ;1262
00010c  1c40              ADDS     r0,r0,#1              ;1262
00010e  61a0              STR      r0,[r4,#0x18]         ;1262
000110  4620              MOV      r0,r4                 ;1264
000112  f7fffffe          BL       _RMP_Set_Rdy
000116  e001              B        |L54.284|
                  |L54.280|
000118  bf00              NOP                            ;1267
00011a  bf00              NOP                            ;1267
                  |L54.284|
00011c  62e6              STR      r6,[r4,#0x2c]         ;1270
00011e  69a0              LDR      r0,[r4,#0x18]         ;1271
000120  f4407000          ORR      r0,r0,#0x200          ;1271
000124  61a0              STR      r0,[r4,#0x18]         ;1271
                  |L54.294|
000126  f7fffffe          BL       RMP_Unlock_Sched
00012a  4802              LDR      r0,|L54.308|
00012c  6800              LDR      r0,[r0,#0]            ;1276  ; RMP_Cur_Thd
00012e  6b80              LDR      r0,[r0,#0x38]         ;1276
000130  e76f              B        |L54.18|
;;;1278   /* End Function:RMP_Thd_Snd **************************************************/
                          ENDP

000132  0000              DCW      0x0000
                  |L54.308|
                          DCD      RMP_Cur_Thd
                  |L54.312|
                          DCD      0x000186a0

                          AREA ||i.RMP_Thd_Snd_ISR||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Snd_ISR PROC
;;;1290   ******************************************************************************/
;;;1291   rmp_ret_t RMP_Thd_Snd_ISR(volatile struct RMP_Thd* Thread, rmp_ptr_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;1292   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1293       /* Check if this thread structure could possibly be in use */
;;;1294       if(Thread==0)
000006  b924              CBNZ     r4,|L55.18|
;;;1295       {
;;;1296           RMP_COVERAGE_MARKER();
000008  bf00              NOP      
00000a  bf00              NOP      
;;;1297           return RMP_ERR_THD;
00000c  f04f30ff          MOV      r0,#0xffffffff
                  |L55.16|
;;;1298       }
;;;1299       else
;;;1300           RMP_COVERAGE_MARKER();
;;;1301       
;;;1302       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;1303       {
;;;1304           RMP_COVERAGE_MARKER();
;;;1305           return RMP_ERR_THD;
;;;1306       }
;;;1307       else
;;;1308           RMP_COVERAGE_MARKER();
;;;1309   
;;;1310       /* See if there is already a value in the mailbox, if yes, we abort */
;;;1311       if((Thread->State&RMP_THD_MBOXFUL)!=0)
;;;1312       {
;;;1313           RMP_COVERAGE_MARKER();
;;;1314           return RMP_ERR_OPER;
;;;1315       }
;;;1316       else
;;;1317       {
;;;1318           RMP_COVERAGE_MARKER();
;;;1319           
;;;1320           /* Mailbox not full. We need to check if the receiver is waiting for us */
;;;1321           if((RMP_THD_STATE(Thread->State)==RMP_THD_RCVBLK)||
;;;1322              (RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY))
;;;1323           {
;;;1324               RMP_COVERAGE_MARKER();
;;;1325   
;;;1326               /* The receiver is blocked, wake it up and return the value */
;;;1327               if(RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY)
;;;1328               {
;;;1329                   RMP_COVERAGE_MARKER();
;;;1330                   RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1331               }
;;;1332               else
;;;1333                   RMP_COVERAGE_MARKER();
;;;1334               
;;;1335               RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1336   
;;;1337               /* Set to running if not suspended */
;;;1338               _RMP_Set_Rdy(Thread);
;;;1339   
;;;1340               /* If schedule pending, trigger it now because we are in ISR */
;;;1341               if(RMP_Sched_Pend!=0)
;;;1342               {
;;;1343                   RMP_COVERAGE_MARKER();
;;;1344                   RMP_Sched_Pend=0;
;;;1345                   _RMP_Yield();
;;;1346               }
;;;1347               else
;;;1348                   RMP_COVERAGE_MARKER();
;;;1349           }
;;;1350           else
;;;1351               RMP_COVERAGE_MARKER();
;;;1352           
;;;1353           /* Set the mailbox */
;;;1354           Thread->Mailbox=Data;
;;;1355           Thread->State|=RMP_THD_MBOXFUL;
;;;1356       }
;;;1357   
;;;1358       return 0;
;;;1359   }
000010  bd70              POP      {r4-r6,pc}
                  |L55.18|
000012  bf00              NOP                            ;1300
000014  bf00              NOP                            ;1300
000016  69a0              LDR      r0,[r4,#0x18]         ;1302
000018  b2c0              UXTB     r0,r0                 ;1302
00001a  b920              CBNZ     r0,|L55.38|
00001c  bf00              NOP                            ;1304
00001e  bf00              NOP                            ;1304
000020  f04f30ff          MOV      r0,#0xffffffff        ;1305
000024  e7f4              B        |L55.16|
                  |L55.38|
000026  bf00              NOP                            ;1308
000028  bf00              NOP                            ;1308
00002a  69a0              LDR      r0,[r4,#0x18]         ;1311
00002c  f4007000          AND      r0,r0,#0x200          ;1311
000030  b120              CBZ      r0,|L55.60|
000032  bf00              NOP                            ;1313
000034  bf00              NOP                            ;1313
000036  f06f0004          MVN      r0,#4                 ;1314
00003a  e7e9              B        |L55.16|
                  |L55.60|
00003c  bf00              NOP                            ;1318
00003e  bf00              NOP                            ;1318
000040  69a0              LDR      r0,[r4,#0x18]         ;1321
000042  b2c0              UXTB     r0,r0                 ;1321
000044  2804              CMP      r0,#4                 ;1321
000046  d003              BEQ      |L55.80|
000048  69a0              LDR      r0,[r4,#0x18]         ;1322
00004a  b2c0              UXTB     r0,r0                 ;1322
00004c  2805              CMP      r0,#5                 ;1322
00004e  d123              BNE      |L55.152|
                  |L55.80|
000050  bf00              NOP                            ;1324
000052  bf00              NOP                            ;1324
000054  69a0              LDR      r0,[r4,#0x18]         ;1327
000056  b2c0              UXTB     r0,r0                 ;1327
000058  2805              CMP      r0,#5                 ;1327
00005a  d106              BNE      |L55.106|
00005c  bf00              NOP                            ;1329
00005e  bf00              NOP                            ;1329
000060  68e1              LDR      r1,[r4,#0xc]          ;1330
000062  68a0              LDR      r0,[r4,#8]            ;1330
000064  f7fffffe          BL       RMP_List_Del
000068  e001              B        |L55.110|
                  |L55.106|
00006a  bf00              NOP                            ;1333
00006c  bf00              NOP                            ;1333
                  |L55.110|
00006e  69a0              LDR      r0,[r4,#0x18]         ;1335
000070  f02000ff          BIC      r0,r0,#0xff           ;1335
000074  1c40              ADDS     r0,r0,#1              ;1335
000076  61a0              STR      r0,[r4,#0x18]         ;1335
000078  4620              MOV      r0,r4                 ;1338
00007a  f7fffffe          BL       _RMP_Set_Rdy
00007e  480b              LDR      r0,|L55.172|
000080  6800              LDR      r0,[r0,#0]            ;1341  ; RMP_Sched_Pend
000082  b138              CBZ      r0,|L55.148|
000084  bf00              NOP                            ;1343
000086  bf00              NOP                            ;1343
000088  2000              MOVS     r0,#0                 ;1344
00008a  4908              LDR      r1,|L55.172|
00008c  6008              STR      r0,[r1,#0]            ;1344  ; RMP_Sched_Pend
00008e  f7fffffe          BL       _RMP_Yield
000092  e003              B        |L55.156|
                  |L55.148|
000094  bf00              NOP                            ;1348
000096  e001              B        |L55.156|
                  |L55.152|
000098  bf00              NOP                            ;1351
00009a  bf00              NOP                            ;1351
                  |L55.156|
00009c  62e5              STR      r5,[r4,#0x2c]         ;1354
00009e  69a0              LDR      r0,[r4,#0x18]         ;1355
0000a0  f4407000          ORR      r0,r0,#0x200          ;1355
0000a4  61a0              STR      r0,[r4,#0x18]         ;1355
0000a6  2000              MOVS     r0,#0                 ;1358
0000a8  e7b2              B        |L55.16|
;;;1360   /* End Function:RMP_Thd_Snd_ISR **********************************************/
                          ENDP

0000aa  0000              DCW      0x0000
                  |L55.172|
                          DCD      RMP_Sched_Pend

                          AREA ||i.RMP_Thd_Suspend||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Suspend PROC
;;;1046   ******************************************************************************/
;;;1047   rmp_ret_t RMP_Thd_Suspend(volatile struct RMP_Thd* Thread)
000000  b510              PUSH     {r4,lr}
;;;1048   {
000002  4604              MOV      r4,r0
;;;1049       /* Check if this thread structure could possibly be in use */
;;;1050       if(Thread==0)
000004  b924              CBNZ     r4,|L56.16|
;;;1051       {
;;;1052           RMP_COVERAGE_MARKER();
000006  bf00              NOP      
000008  bf00              NOP      
;;;1053           return RMP_ERR_THD;
00000a  f04f30ff          MOV      r0,#0xffffffff
                  |L56.14|
;;;1054       }
;;;1055       else
;;;1056           RMP_COVERAGE_MARKER();
;;;1057       
;;;1058       RMP_Lock_Sched();
;;;1059       
;;;1060       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;1061       {
;;;1062           RMP_COVERAGE_MARKER();
;;;1063           RMP_Unlock_Sched();
;;;1064           return RMP_ERR_THD;
;;;1065       }
;;;1066       else
;;;1067           RMP_COVERAGE_MARKER();
;;;1068       
;;;1069       /* Suspend it */
;;;1070       if((Thread->State&RMP_THD_SUSPENDED)!=0)
;;;1071       {
;;;1072           RMP_COVERAGE_MARKER();
;;;1073           RMP_Unlock_Sched();
;;;1074           return RMP_ERR_STATE;
;;;1075       }
;;;1076       else
;;;1077           RMP_COVERAGE_MARKER();
;;;1078       
;;;1079       /* Only when it is running do we clear this. If we are clearing this, it is not
;;;1080        * suspended, so trhe running queue removal is guaranteed to succceed */
;;;1081       if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
;;;1082       {
;;;1083           RMP_COVERAGE_MARKER();
;;;1084           _RMP_Clr_Rdy(Thread);
;;;1085       }
;;;1086       else
;;;1087           RMP_COVERAGE_MARKER();
;;;1088       
;;;1089       /* Mark this as suspended */
;;;1090       Thread->State|=RMP_THD_SUSPENDED;
;;;1091       
;;;1092       /* If we are suspending ourself, pend a yield */
;;;1093       if(Thread==RMP_Cur_Thd)
;;;1094       {
;;;1095           RMP_COVERAGE_MARKER();
;;;1096           RMP_Sched_Pend=1;
;;;1097       }
;;;1098       else
;;;1099           RMP_COVERAGE_MARKER();
;;;1100       
;;;1101       RMP_Unlock_Sched();
;;;1102       return 0;
;;;1103   }
00000e  bd10              POP      {r4,pc}
                  |L56.16|
000010  bf00              NOP                            ;1056
000012  bf00              NOP                            ;1056
000014  f7fffffe          BL       RMP_Lock_Sched
000018  69a0              LDR      r0,[r4,#0x18]         ;1060
00001a  b2c0              UXTB     r0,r0                 ;1060
00001c  b930              CBNZ     r0,|L56.44|
00001e  bf00              NOP                            ;1062
000020  bf00              NOP                            ;1062
000022  f7fffffe          BL       RMP_Unlock_Sched
000026  f04f30ff          MOV      r0,#0xffffffff        ;1064
00002a  e7f0              B        |L56.14|
                  |L56.44|
00002c  bf00              NOP                            ;1067
00002e  bf00              NOP                            ;1067
000030  69a0              LDR      r0,[r4,#0x18]         ;1070
000032  f4007080          AND      r0,r0,#0x100          ;1070
000036  b130              CBZ      r0,|L56.70|
000038  bf00              NOP                            ;1072
00003a  bf00              NOP                            ;1072
00003c  f7fffffe          BL       RMP_Unlock_Sched
000040  f06f0003          MVN      r0,#3                 ;1074
000044  e7e3              B        |L56.14|
                  |L56.70|
000046  bf00              NOP                            ;1077
000048  bf00              NOP                            ;1077
00004a  69a0              LDR      r0,[r4,#0x18]         ;1081
00004c  b2c0              UXTB     r0,r0                 ;1081
00004e  2801              CMP      r0,#1                 ;1081
000050  d105              BNE      |L56.94|
000052  bf00              NOP                            ;1083
000054  bf00              NOP                            ;1083
000056  4620              MOV      r0,r4                 ;1084
000058  f7fffffe          BL       _RMP_Clr_Rdy
00005c  e001              B        |L56.98|
                  |L56.94|
00005e  bf00              NOP                            ;1087
000060  bf00              NOP                            ;1087
                  |L56.98|
000062  69a0              LDR      r0,[r4,#0x18]         ;1090
000064  f4407080          ORR      r0,r0,#0x100          ;1090
000068  61a0              STR      r0,[r4,#0x18]         ;1090
00006a  4808              LDR      r0,|L56.140|
00006c  6800              LDR      r0,[r0,#0]            ;1093  ; RMP_Cur_Thd
00006e  4284              CMP      r4,r0                 ;1093
000070  d105              BNE      |L56.126|
000072  bf00              NOP                            ;1095
000074  bf00              NOP                            ;1095
000076  2001              MOVS     r0,#1                 ;1096
000078  4905              LDR      r1,|L56.144|
00007a  6008              STR      r0,[r1,#0]            ;1096  ; RMP_Sched_Pend
00007c  e001              B        |L56.130|
                  |L56.126|
00007e  bf00              NOP                            ;1099
000080  bf00              NOP                            ;1099
                  |L56.130|
000082  f7fffffe          BL       RMP_Unlock_Sched
000086  2000              MOVS     r0,#0                 ;1102
000088  e7c1              B        |L56.14|
;;;1104   /* End Function:RMP_Thd_Suspend **********************************************/
                          ENDP

00008a  0000              DCW      0x0000
                  |L56.140|
                          DCD      RMP_Cur_Thd
                  |L56.144|
                          DCD      RMP_Sched_Pend

                          AREA ||i.RMP_Unlock_Sched||, CODE, READONLY, ALIGN=2

                  RMP_Unlock_Sched PROC
;;;375    ******************************************************************************/
;;;376    void RMP_Unlock_Sched(void)
000000  b510              PUSH     {r4,lr}
;;;377    {
;;;378        if(RMP_Sched_Lock_Cnt==1)
000002  4815              LDR      r0,|L57.88|
000004  6800              LDR      r0,[r0,#0]  ; RMP_Sched_Lock_Cnt
000006  2801              CMP      r0,#1
000008  d117              BNE      |L57.58|
;;;379        {
;;;380            RMP_COVERAGE_MARKER();
00000a  bf00              NOP      
00000c  bf00              NOP      
;;;381            /* Clear the count before enabling */
;;;382            RMP_Sched_Lock_Cnt=0;
00000e  2000              MOVS     r0,#0
000010  4911              LDR      r1,|L57.88|
000012  6008              STR      r0,[r1,#0]  ; RMP_Sched_Lock_Cnt
;;;383            RMP_Sched_Locked=0;
000014  4911              LDR      r1,|L57.92|
000016  6008              STR      r0,[r1,#0]  ; RMP_Sched_Locked
;;;384            /* Now see if the scheduler scheduling action is pended in the lock-unlock 
;;;385             * period. If yes, perform a schedule now */
;;;386            if(RMP_Sched_Pend!=0)
000018  4811              LDR      r0,|L57.96|
00001a  6800              LDR      r0,[r0,#0]  ; RMP_Sched_Pend
00001c  b138              CBZ      r0,|L57.46|
;;;387            {
;;;388                RMP_COVERAGE_MARKER();
00001e  bf00              NOP      
000020  bf00              NOP      
;;;389                /* Reset the count and trigger the context switch */
;;;390                RMP_Sched_Pend=0;
000022  2000              MOVS     r0,#0
000024  490e              LDR      r1,|L57.96|
000026  6008              STR      r0,[r1,#0]  ; RMP_Sched_Pend
;;;391                _RMP_Yield();
000028  f7fffffe          BL       _RMP_Yield
00002c  e001              B        |L57.50|
                  |L57.46|
;;;392            }
;;;393            else
;;;394                RMP_COVERAGE_MARKER();
00002e  bf00              NOP      
000030  bf00              NOP      
                  |L57.50|
;;;395            
;;;396            RMP_UNMASK_INT();
000032  2000              MOVS     r0,#0
000034  f7fffffe          BL       RMP_Mask_Int
000038  e00d              B        |L57.86|
                  |L57.58|
;;;397        }
;;;398        else if(RMP_Sched_Lock_Cnt>1)
00003a  4807              LDR      r0,|L57.88|
00003c  6800              LDR      r0,[r0,#0]  ; RMP_Sched_Lock_Cnt
00003e  2801              CMP      r0,#1
000040  d907              BLS      |L57.82|
;;;399        {
;;;400            RMP_COVERAGE_MARKER();
000042  bf00              NOP      
000044  bf00              NOP      
;;;401            RMP_Sched_Lock_Cnt--;
000046  4804              LDR      r0,|L57.88|
000048  6800              LDR      r0,[r0,#0]  ; RMP_Sched_Lock_Cnt
00004a  1e40              SUBS     r0,r0,#1
00004c  4902              LDR      r1,|L57.88|
00004e  6008              STR      r0,[r1,#0]  ; RMP_Sched_Lock_Cnt
000050  e001              B        |L57.86|
                  |L57.82|
;;;402        }
;;;403        /* Trying to unlock a scheduler that is not locked - should never happen */
;;;404        else
;;;405            while(1);
000052  bf00              NOP      
                  |L57.84|
000054  e7fe              B        |L57.84|
                  |L57.86|
;;;406    }
000056  bd10              POP      {r4,pc}
;;;407    /* End Function:RMP_Unlock_Sched *********************************************/
                          ENDP

                  |L57.88|
                          DCD      RMP_Sched_Lock_Cnt
                  |L57.92|
                          DCD      RMP_Sched_Locked
                  |L57.96|
                          DCD      RMP_Sched_Pend

                          AREA ||i.RMP_Yield||, CODE, READONLY, ALIGN=2

                  RMP_Yield PROC
;;;414    ******************************************************************************/
;;;415    void RMP_Yield(void)
000000  b510              PUSH     {r4,lr}
;;;416    {
;;;417        if(RMP_Sched_Locked==0)
000002  4807              LDR      r0,|L58.32|
000004  6800              LDR      r0,[r0,#0]  ; RMP_Sched_Locked
000006  b920              CBNZ     r0,|L58.18|
;;;418        {
;;;419            RMP_COVERAGE_MARKER();
000008  bf00              NOP      
00000a  bf00              NOP      
;;;420            /* Now see if the scheduler scheduling action is pended in the lock-unlock 
;;;421             * period. If yes, perform a schedule now */
;;;422            _RMP_Yield();
00000c  f7fffffe          BL       _RMP_Yield
000010  e004              B        |L58.28|
                  |L58.18|
;;;423        }
;;;424        else
;;;425        {
;;;426            RMP_COVERAGE_MARKER();
000012  bf00              NOP      
000014  bf00              NOP      
;;;427            RMP_Sched_Pend=1;
000016  2001              MOVS     r0,#1
000018  4902              LDR      r1,|L58.36|
00001a  6008              STR      r0,[r1,#0]  ; RMP_Sched_Pend
                  |L58.28|
;;;428        }
;;;429    }
00001c  bd10              POP      {r4,pc}
;;;430    /* End Function:RMP_Yield ****************************************************/
                          ENDP

00001e  0000              DCW      0x0000
                  |L58.32|
                          DCD      RMP_Sched_Locked
                  |L58.36|
                          DCD      RMP_Sched_Pend

                          AREA ||i._RMP_Clr_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Clr_Rdy PROC
;;;686    ******************************************************************************/
;;;687    void _RMP_Clr_Rdy(volatile struct RMP_Thd* Thread)
000000  b510              PUSH     {r4,lr}
;;;688    {
000002  4602              MOV      r2,r0
;;;689        /* Is it suspended? If yes, no need to delete again */
;;;690        if((Thread->State&RMP_THD_SUSPENDED)==0)
000004  6990              LDR      r0,[r2,#0x18]
000006  f4007080          AND      r0,r0,#0x100
00000a  bb38              CBNZ     r0,|L59.92|
;;;691        {
;;;692            RMP_COVERAGE_MARKER();
00000c  bf00              NOP      
00000e  bf00              NOP      
;;;693            /* See if it is the last thread on the priority level */
;;;694            if(Thread->Run_Head.Prev==Thread->Run_Head.Next)
000010  6810              LDR      r0,[r2,#0]
000012  6851              LDR      r1,[r2,#4]
000014  4288              CMP      r0,r1
000016  d10f              BNE      |L59.56|
;;;695            {
;;;696                RMP_COVERAGE_MARKER();
000018  bf00              NOP      
00001a  bf00              NOP      
;;;697                RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]&=~(((rmp_ptr_t)1)<<(Thread->Prio&RMP_WORD_MASK));
00001c  6a51              LDR      r1,[r2,#0x24]
00001e  0949              LSRS     r1,r1,#5
000020  4b10              LDR      r3,|L59.100|
000022  eb030081          ADD      r0,r3,r1,LSL #2
000026  6801              LDR      r1,[r0,#0]
000028  6a53              LDR      r3,[r2,#0x24]
00002a  f003041f          AND      r4,r3,#0x1f
00002e  2301              MOVS     r3,#1
000030  40a3              LSLS     r3,r3,r4
000032  4399              BICS     r1,r1,r3
000034  6001              STR      r1,[r0,#0]
000036  e001              B        |L59.60|
                  |L59.56|
;;;698            }
;;;699            else
;;;700                RMP_COVERAGE_MARKER();
000038  bf00              NOP      
00003a  bf00              NOP      
                  |L59.60|
;;;701            
;;;702            /* Delete this from the corresponding runqueue */
;;;703            RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
00003c  6851              LDR      r1,[r2,#4]
00003e  6810              LDR      r0,[r2,#0]
000040  f7fffffe          BL       RMP_List_Del
;;;704            
;;;705            /* If it is the current thread, request a context switch */
;;;706            if(Thread==RMP_Cur_Thd)
000044  4808              LDR      r0,|L59.104|
000046  6800              LDR      r0,[r0,#0]  ; RMP_Cur_Thd
000048  4282              CMP      r2,r0
00004a  d105              BNE      |L59.88|
;;;707            {
;;;708                RMP_COVERAGE_MARKER();
00004c  bf00              NOP      
00004e  bf00              NOP      
;;;709                RMP_Sched_Pend=1;
000050  2001              MOVS     r0,#1
000052  4906              LDR      r1,|L59.108|
000054  6008              STR      r0,[r1,#0]  ; RMP_Sched_Pend
000056  e003              B        |L59.96|
                  |L59.88|
;;;710            }
;;;711            else
;;;712                RMP_COVERAGE_MARKER();
000058  bf00              NOP      
00005a  e001              B        |L59.96|
                  |L59.92|
;;;713        }
;;;714        else
;;;715            RMP_COVERAGE_MARKER();
00005c  bf00              NOP      
00005e  bf00              NOP      
                  |L59.96|
;;;716    }
000060  bd10              POP      {r4,pc}
;;;717    /* End Function:_RMP_Clr_Rdy *************************************************/
                          ENDP

000062  0000              DCW      0x0000
                  |L59.100|
                          DCD      RMP_Bitmap
                  |L59.104|
                          DCD      RMP_Cur_Thd
                  |L59.108|
                          DCD      RMP_Sched_Pend

                          AREA ||i._RMP_Dly_Ins||, CODE, READONLY, ALIGN=2

                  _RMP_Dly_Ins PROC
;;;726    ******************************************************************************/
;;;727    void _RMP_Dly_Ins(volatile struct RMP_Thd* Thread, rmp_ptr_t Slices)
000000  b570              PUSH     {r4-r6,lr}
;;;728    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;729        struct RMP_List* Trav_Ptr;
;;;730        struct RMP_Thd* Trav_Thd;
;;;731        
;;;732        /* Find a place to insert this timer */
;;;733        Trav_Ptr=(struct RMP_List*)RMP_Delay.Next;
000006  4810              LDR      r0,|L60.72|
000008  6843              LDR      r3,[r0,#4]  ; RMP_Delay
;;;734        while(Trav_Ptr!=&(RMP_Delay))
00000a  e00d              B        |L60.40|
                  |L60.12|
;;;735        {
;;;736            Trav_Thd=RMP_DLY2THD(Trav_Ptr);
00000c  f1a30608          SUB      r6,r3,#8
;;;737            if((Trav_Thd->Timeout-RMP_Tick)>Slices)
000010  490e              LDR      r1,|L60.76|
000012  6ab0              LDR      r0,[r6,#0x28]
000014  6809              LDR      r1,[r1,#0]  ; RMP_Tick
000016  1a40              SUBS     r0,r0,r1
000018  42a8              CMP      r0,r5
00001a  d902              BLS      |L60.34|
;;;738            {
;;;739                RMP_COVERAGE_MARKER();
00001c  bf00              NOP      
00001e  bf00              NOP      
;;;740                break;
000020  e005              B        |L60.46|
                  |L60.34|
;;;741            }
;;;742            else
;;;743                RMP_COVERAGE_MARKER();
000022  bf00              NOP      
000024  bf00              NOP      
;;;744            
;;;745            Trav_Ptr=(struct RMP_List*)(Trav_Ptr->Next);
000026  685b              LDR      r3,[r3,#4]
                  |L60.40|
000028  4807              LDR      r0,|L60.72|
00002a  4283              CMP      r3,r0                 ;734
00002c  d1ee              BNE      |L60.12|
                  |L60.46|
00002e  bf00              NOP                            ;740
;;;746        }
;;;747    
;;;748        /* Insert this into the list */
;;;749        Thread->Timeout=RMP_Tick+Slices;
000030  4806              LDR      r0,|L60.76|
000032  6800              LDR      r0,[r0,#0]  ; RMP_Tick
000034  4428              ADD      r0,r0,r5
000036  62a0              STR      r0,[r4,#0x28]
;;;750        RMP_List_Ins(&Thread->Dly_Head,Trav_Ptr->Prev,Trav_Ptr);
000038  461a              MOV      r2,r3
00003a  f1040008          ADD      r0,r4,#8
00003e  6819              LDR      r1,[r3,#0]
000040  f7fffffe          BL       RMP_List_Ins
;;;751    }
000044  bd70              POP      {r4-r6,pc}
;;;752    /* End Function:_RMP_Dly_Ins *************************************************/
                          ENDP

000046  0000              DCW      0x0000
                  |L60.72|
                          DCD      RMP_Delay
                  |L60.76|
                          DCD      RMP_Tick

                          AREA ||i._RMP_Get_High_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Get_High_Rdy PROC
;;;494    ******************************************************************************/
;;;495    void _RMP_Get_High_Rdy(void)
000000  b510              PUSH     {r4,lr}
;;;496    {
;;;497        rmp_cnt_t Count;
;;;498        
;;;499        /* Write the SP value to thread structure */
;;;500        RMP_Cur_Thd->Stack=RMP_Cur_SP;
000002  482a              LDR      r0,|L61.172|
000004  6800              LDR      r0,[r0,#0]  ; RMP_Cur_SP
000006  492a              LDR      r1,|L61.176|
000008  6809              LDR      r1,[r1,#0]  ; RMP_Cur_Thd
00000a  6348              STR      r0,[r1,#0x34]
;;;501        
;;;502        /* No need to detect scheduler locks - if this interrupt can be entered, the scheduler is not locked */
;;;503        RMP_Sched_Pend=0;
00000c  2000              MOVS     r0,#0
00000e  4929              LDR      r1,|L61.180|
000010  6008              STR      r0,[r1,#0]  ; RMP_Sched_Pend
;;;504        /* See which one is ready, and pick it */
;;;505        for(Count=RMP_BITMAP_SIZE-1;Count>=0;Count--)
000012  2400              MOVS     r4,#0
000014  e041              B        |L61.154|
                  |L61.22|
;;;506        {
;;;507            if(RMP_Bitmap[Count]==0)
000016  4828              LDR      r0,|L61.184|
000018  f8500024          LDR      r0,[r0,r4,LSL #2]
00001c  b910              CBNZ     r0,|L61.36|
;;;508            {
;;;509                RMP_COVERAGE_MARKER();
00001e  bf00              NOP      
000020  bf00              NOP      
;;;510                continue;
000022  e039              B        |L61.152|
                  |L61.36|
;;;511            }
;;;512            else
;;;513                RMP_COVERAGE_MARKER();
000024  bf00              NOP      
000026  bf00              NOP      
;;;514            
;;;515            Count=RMP_MSB_Get(RMP_Bitmap[Count])+(Count<<RMP_WORD_ORDER);
000028  4923              LDR      r1,|L61.184|
00002a  f8510024          LDR      r0,[r1,r4,LSL #2]
00002e  f7fffffe          BL       RMP_MSB_Get
000032  eb001444          ADD      r4,r0,r4,LSL #5
;;;516            
;;;517            /* See if the current thread and the next thread are the same. If yes, place the current at the end of the queue */
;;;518            if(RMP_Cur_Thd==(struct RMP_Thd*)(RMP_Run[Count].Next))
000036  4821              LDR      r0,|L61.188|
000038  eb0000c4          ADD      r0,r0,r4,LSL #3
00003c  6840              LDR      r0,[r0,#4]
00003e  491c              LDR      r1,|L61.176|
000040  6809              LDR      r1,[r1,#0]  ; RMP_Cur_Thd
000042  4288              CMP      r0,r1
000044  d119              BNE      |L61.122|
;;;519            {
;;;520                RMP_COVERAGE_MARKER();
000046  bf00              NOP      
000048  bf00              NOP      
;;;521                RMP_List_Del(RMP_Cur_Thd->Run_Head.Prev, RMP_Cur_Thd->Run_Head.Next);
00004a  4a19              LDR      r2,|L61.176|
00004c  6812              LDR      r2,[r2,#0]  ; RMP_Cur_Thd
00004e  6851              LDR      r1,[r2,#4]
000050  4a17              LDR      r2,|L61.176|
000052  6812              LDR      r2,[r2,#0]  ; RMP_Cur_Thd
000054  6810              LDR      r0,[r2,#0]
000056  f7fffffe          BL       RMP_List_Del
;;;522                RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),
00005a  4815              LDR      r0,|L61.176|
00005c  6800              LDR      r0,[r0,#0]  ; RMP_Cur_Thd
00005e  6a40              LDR      r0,[r0,#0x24]
000060  4b16              LDR      r3,|L61.188|
000062  eb0302c0          ADD      r2,r3,r0,LSL #3
000066  4812              LDR      r0,|L61.176|
000068  6800              LDR      r0,[r0,#0]  ; RMP_Cur_Thd
00006a  6a40              LDR      r0,[r0,#0x24]
00006c  f8531030          LDR      r1,[r3,r0,LSL #3]
000070  480f              LDR      r0,|L61.176|
000072  6800              LDR      r0,[r0,#0]  ; RMP_Cur_Thd
000074  f7fffffe          BL       RMP_List_Ins
000078  e001              B        |L61.126|
                  |L61.122|
;;;523                             RMP_Run[RMP_Cur_Thd->Prio].Prev,
;;;524                             &(RMP_Run[RMP_Cur_Thd->Prio]));
;;;525            }
;;;526            else
;;;527                RMP_COVERAGE_MARKER();
00007a  bf00              NOP      
00007c  bf00              NOP      
                  |L61.126|
;;;528            
;;;529            /* Replenish timeslices */
;;;530            RMP_Cur_Thd->Slices_Left=RMP_Cur_Thd->Slices;
00007e  480c              LDR      r0,|L61.176|
000080  6800              LDR      r0,[r0,#0]  ; RMP_Cur_Thd
000082  69c0              LDR      r0,[r0,#0x1c]
000084  490a              LDR      r1,|L61.176|
000086  6809              LDR      r1,[r1,#0]  ; RMP_Cur_Thd
000088  6208              STR      r0,[r1,#0x20]
;;;531            RMP_Cur_Thd=(struct RMP_Thd*)(RMP_Run[Count].Next);
00008a  480c              LDR      r0,|L61.188|
00008c  eb0000c4          ADD      r0,r0,r4,LSL #3
000090  6840              LDR      r0,[r0,#4]
000092  4907              LDR      r1,|L61.176|
000094  6008              STR      r0,[r1,#0]  ; RMP_Cur_Thd
;;;532            break;
000096  e002              B        |L61.158|
                  |L61.152|
000098  1e64              SUBS     r4,r4,#1              ;505
                  |L61.154|
00009a  2c00              CMP      r4,#0                 ;505
00009c  dabb              BGE      |L61.22|
                  |L61.158|
00009e  bf00              NOP      
;;;533        }
;;;534        
;;;535        /* Load the SP value from thread structure */
;;;536        RMP_Cur_SP=RMP_Cur_Thd->Stack;
0000a0  4803              LDR      r0,|L61.176|
0000a2  6800              LDR      r0,[r0,#0]  ; RMP_Cur_Thd
0000a4  6b40              LDR      r0,[r0,#0x34]
0000a6  4901              LDR      r1,|L61.172|
0000a8  6008              STR      r0,[r1,#0]  ; RMP_Cur_SP
;;;537        
;;;538    #if(RMP_USE_HOOKS==RMP_TRUE)
;;;539        RMP_Sched_Hook();
;;;540    #endif
;;;541    }
0000aa  bd10              POP      {r4,pc}
;;;542    /* End Function:_RMP_Get_High_Rdy ********************************************/
                          ENDP

                  |L61.172|
                          DCD      RMP_Cur_SP
                  |L61.176|
                          DCD      RMP_Cur_Thd
                  |L61.180|
                          DCD      RMP_Sched_Pend
                  |L61.184|
                          DCD      RMP_Bitmap
                  |L61.188|
                          DCD      RMP_Run

                          AREA ||i._RMP_Get_Near_Ticks||, CODE, READONLY, ALIGN=2

                  _RMP_Get_Near_Ticks PROC
;;;612    ******************************************************************************/
;;;613    rmp_ptr_t _RMP_Get_Near_Ticks(void)
000000  4a0f              LDR      r2,|L62.64|
;;;614    {
;;;615        rmp_ptr_t Value;
;;;616        struct RMP_Thd* Thread;
;;;617        
;;;618        /* What is the current thread's timeout value? */
;;;619        Value=RMP_Cur_Thd->Slices_Left;
000002  6812              LDR      r2,[r2,#0]  ; RMP_Cur_Thd
000004  6a10              LDR      r0,[r2,#0x20]
;;;620        
;;;621        /* What is the nearest timer timeout value? */
;;;622        if((&RMP_Delay)!=RMP_Delay.Next)
000006  4a0f              LDR      r2,|L62.68|
000008  6852              LDR      r2,[r2,#4]  ; RMP_Delay
00000a  4b0e              LDR      r3,|L62.68|
00000c  429a              CMP      r2,r3
00000e  d014              BEQ      |L62.58|
;;;623        {
;;;624            RMP_COVERAGE_MARKER();
000010  bf00              NOP      
000012  bf00              NOP      
;;;625            Thread=RMP_DLY2THD(RMP_Delay.Next);
000014  461a              MOV      r2,r3
000016  6852              LDR      r2,[r2,#4]  ; RMP_Delay
000018  f1a20108          SUB      r1,r2,#8
;;;626            /* See if it is nearer - don't worry about the situation that the timer
;;;627             * have overflown, because if that is to happen, it would have been 
;;;628             * already processed by the timeout processing routine just before. */
;;;629            if((Thread->Timeout-RMP_Tick)<Value)
00001c  4b0a              LDR      r3,|L62.72|
00001e  6a8a              LDR      r2,[r1,#0x28]
000020  681b              LDR      r3,[r3,#0]  ; RMP_Tick
000022  1ad2              SUBS     r2,r2,r3
000024  4282              CMP      r2,r0
000026  d206              BCS      |L62.54|
;;;630            {
;;;631                RMP_COVERAGE_MARKER();
000028  bf00              NOP      
00002a  bf00              NOP      
;;;632                Value=Thread->Timeout-RMP_Tick;
00002c  4b06              LDR      r3,|L62.72|
00002e  6a8a              LDR      r2,[r1,#0x28]
000030  681b              LDR      r3,[r3,#0]  ; RMP_Tick
000032  1ad0              SUBS     r0,r2,r3
000034  e003              B        |L62.62|
                  |L62.54|
;;;633            }
;;;634            else
;;;635                RMP_COVERAGE_MARKER();
000036  bf00              NOP      
000038  e001              B        |L62.62|
                  |L62.58|
;;;636        }
;;;637        else
;;;638            RMP_COVERAGE_MARKER();
00003a  bf00              NOP      
00003c  bf00              NOP      
                  |L62.62|
;;;639        
;;;640        return Value;
;;;641    }
00003e  4770              BX       lr
;;;642    /* End Function:_RMP_Get_Near_Ticks ******************************************/
                          ENDP

                  |L62.64|
                          DCD      RMP_Cur_Thd
                  |L62.68|
                          DCD      RMP_Delay
                  |L62.72|
                          DCD      RMP_Tick

                          AREA ||i._RMP_Mem_Block||, CODE, READONLY, ALIGN=1

                  _RMP_Mem_Block PROC
;;;2231   ******************************************************************************/
;;;2232   void _RMP_Mem_Block(volatile struct RMP_Mem_Head* Addr, rmp_ptr_t Size)
000000  460a              MOV      r2,r1
;;;2233   {
;;;2234       volatile struct RMP_Mem_Head* Mem_Head;
;;;2235       
;;;2236       /* Get the big memory block's size and position */
;;;2237       Mem_Head=(struct RMP_Mem_Head*)Addr;
000002  4601              MOV      r1,r0
;;;2238       
;;;2239       /* Initialize the big memory block */
;;;2240       Mem_Head->State=RMP_MEM_FREE;
000004  2300              MOVS     r3,#0
000006  608b              STR      r3,[r1,#8]
;;;2241       Mem_Head->Tail=(struct RMP_Mem_Tail*)(((rmp_ptr_t)Mem_Head)+Size-sizeof(struct RMP_Mem_Tail));
000008  188b              ADDS     r3,r1,r2
00000a  1f1b              SUBS     r3,r3,#4
00000c  60cb              STR      r3,[r1,#0xc]
;;;2242       Mem_Head->Tail->Head=Mem_Head;
00000e  68cb              LDR      r3,[r1,#0xc]
000010  6019              STR      r1,[r3,#0]
;;;2243   }
000012  4770              BX       lr
;;;2244   /* End Function:_RMP_Mem_Block ***********************************************/
                          ENDP


                          AREA ||i._RMP_Mem_Del||, CODE, READONLY, ALIGN=1

                  _RMP_Mem_Del PROC
;;;2297   ******************************************************************************/
;;;2298   void _RMP_Mem_Del(volatile void* Pool, volatile struct RMP_Mem_Head* Mem_Head)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;2299   {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;2300       rmp_cnt_t FLI_Level;
;;;2301       rmp_cnt_t SLI_Level;
;;;2302       rmp_ptr_t Level;
;;;2303       rmp_ptr_t Size;
;;;2304       volatile struct RMP_Mem* Mem;
;;;2305       volatile struct RMP_List* Slot;    
;;;2306       
;;;2307       /* Get the memory pool and block size */
;;;2308       Mem=(volatile struct RMP_Mem*)Pool;
000008  46a8              MOV      r8,r5
;;;2309       Size=(rmp_ptr_t)(Mem_Head->Tail)-((rmp_ptr_t)Mem_Head)-sizeof(struct RMP_Mem_Head);
00000a  68e0              LDR      r0,[r4,#0xc]
00000c  1b00              SUBS     r0,r0,r4
00000e  f1a00a10          SUB      r10,r0,#0x10
;;;2310       
;;;2311       /* Guarantee the Mem_Size is bigger than 64 or a failure will surely occur here */
;;;2312       FLI_Level=RMP_MSB_Get(Size)-6;
000012  4650              MOV      r0,r10
000014  f7fffffe          BL       RMP_MSB_Get
000018  1f86              SUBS     r6,r0,#6
;;;2313       /* Decide the SLI level directly from the FLI level */
;;;2314       SLI_Level=(Size>>(FLI_Level+3))&0x07;
00001a  1cf0              ADDS     r0,r6,#3
00001c  fa2af000          LSR      r0,r10,r0
000020  f0000907          AND      r9,r0,#7
;;;2315       Level=(FLI_Level<<3)+SLI_Level;
000024  eb0907c6          ADD      r7,r9,r6,LSL #3
;;;2316       /* Get the slot */
;;;2317       Slot=&(Mem->Table[RMP_MEM_POS(FLI_Level,SLI_Level)]);
000028  eb0901c6          ADD      r1,r9,r6,LSL #3
00002c  f1080028          ADD      r0,r8,#0x28
000030  eb000bc1          ADD      r11,r0,r1,LSL #3
;;;2318      
;;;2319       RMP_List_Del(Mem_Head->Head.Prev,Mem_Head->Head.Next);
000034  6861              LDR      r1,[r4,#4]
000036  6820              LDR      r0,[r4,#0]
000038  f7fffffe          BL       RMP_List_Del
;;;2320   
;;;2321       /* See if there are any blocks in the level, equal means no. So
;;;2322        * what we deleted is the last block */
;;;2323       if(Slot==Slot->Next)
00003c  f8db0004          LDR      r0,[r11,#4]
000040  4558              CMP      r0,r11
000042  d111              BNE      |L64.104|
;;;2324       {
;;;2325           RMP_COVERAGE_MARKER();
000044  bf00              NOP      
000046  bf00              NOP      
;;;2326           /* Clear the corresponding bit in the TLSF bitmap */
;;;2327           Mem->Bitmap[Level>>RMP_WORD_ORDER]&=~(1<<(Level&RMP_WORD_MASK));
000048  0979              LSRS     r1,r7,#5
00004a  f1080014          ADD      r0,r8,#0x14
00004e  f8500021          LDR      r0,[r0,r1,LSL #2]
000052  f007021f          AND      r2,r7,#0x1f
000056  2101              MOVS     r1,#1
000058  4091              LSLS     r1,r1,r2
00005a  4388              BICS     r0,r0,r1
00005c  097a              LSRS     r2,r7,#5
00005e  f1080114          ADD      r1,r8,#0x14
000062  f8410022          STR      r0,[r1,r2,LSL #2]
000066  e001              B        |L64.108|
                  |L64.104|
;;;2328       }
;;;2329       else
;;;2330           RMP_COVERAGE_MARKER();
000068  bf00              NOP      
00006a  bf00              NOP      
                  |L64.108|
;;;2331   }
00006c  e8bd9ff0          POP      {r4-r12,pc}
;;;2332   /* End Function:_RMP_Mem_Del *************************************************/
                          ENDP


                          AREA ||i._RMP_Mem_Ins||, CODE, READONLY, ALIGN=1

                  _RMP_Mem_Ins PROC
;;;2253   ******************************************************************************/
;;;2254   void _RMP_Mem_Ins(volatile void* Pool, volatile struct RMP_Mem_Head* Mem_Head)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;2255   {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
;;;2256       rmp_cnt_t FLI_Level;
;;;2257       rmp_cnt_t SLI_Level;
;;;2258       rmp_ptr_t Level;
;;;2259       rmp_ptr_t Size;
;;;2260       volatile struct RMP_Mem* Mem;
;;;2261       volatile struct RMP_List* Slot;
;;;2262       
;;;2263       /* Get the memory pool and block size */
;;;2264       Mem=(volatile struct RMP_Mem*)Pool;
000008  46b1              MOV      r9,r6
;;;2265       Size=(rmp_ptr_t)(Mem_Head->Tail)-((rmp_ptr_t)Mem_Head)-sizeof(struct RMP_Mem_Head);
00000a  68e0              LDR      r0,[r4,#0xc]
00000c  1b00              SUBS     r0,r0,r4
00000e  f1a00b10          SUB      r11,r0,#0x10
;;;2266   
;;;2267       /* Guarantee the Mem_Size is bigger than 64 or a failure will surely occur here */
;;;2268       FLI_Level=RMP_MSB_Get(Size)-6;
000012  4658              MOV      r0,r11
000014  f7fffffe          BL       RMP_MSB_Get
000018  1f87              SUBS     r7,r0,#6
;;;2269       /* Decide the SLI level directly from the FLI level */
;;;2270       SLI_Level=(Size>>(FLI_Level+3))&0x07;
00001a  1cf8              ADDS     r0,r7,#3
00001c  fa2bf000          LSR      r0,r11,r0
000020  f0000a07          AND      r10,r0,#7
;;;2271       Level=(FLI_Level<<3)+SLI_Level;
000024  eb0a08c7          ADD      r8,r10,r7,LSL #3
;;;2272       /* Get the slot */
;;;2273       Slot=&(Mem->Table[RMP_MEM_POS(FLI_Level,SLI_Level)]);
000028  eb0a01c7          ADD      r1,r10,r7,LSL #3
00002c  f1090028          ADD      r0,r9,#0x28
000030  eb0005c1          ADD      r5,r0,r1,LSL #3
;;;2274   
;;;2275       /* See if there are any blocks in the level, equal means no. So what we inserted is the first block */
;;;2276       if(Slot==Slot->Next)
000034  6868              LDR      r0,[r5,#4]
000036  42a8              CMP      r0,r5
000038  d113              BNE      |L65.98|
;;;2277       {
;;;2278           RMP_COVERAGE_MARKER();
00003a  bf00              NOP      
00003c  bf00              NOP      
;;;2279           /* Set the corresponding bit in the TLSF bitmap */
;;;2280           Mem->Bitmap[Level>>RMP_WORD_ORDER]|=1<<(Level&RMP_WORD_MASK);
00003e  ea4f1158          LSR      r1,r8,#5
000042  f1090014          ADD      r0,r9,#0x14
000046  f8500021          LDR      r0,[r0,r1,LSL #2]
00004a  f008021f          AND      r2,r8,#0x1f
00004e  2101              MOVS     r1,#1
000050  4091              LSLS     r1,r1,r2
000052  4308              ORRS     r0,r0,r1
000054  ea4f1258          LSR      r2,r8,#5
000058  f1090114          ADD      r1,r9,#0x14
00005c  f8410022          STR      r0,[r1,r2,LSL #2]
000060  e001              B        |L65.102|
                  |L65.98|
;;;2281       }
;;;2282       else
;;;2283           RMP_COVERAGE_MARKER();
000062  bf00              NOP      
000064  bf00              NOP      
                  |L65.102|
;;;2284   
;;;2285       /* Insert the node now */
;;;2286       RMP_List_Ins(&(Mem_Head->Head), Slot, Slot->Next);
000066  686a              LDR      r2,[r5,#4]
000068  4629              MOV      r1,r5
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       RMP_List_Ins
;;;2287   }
000070  e8bd9ff0          POP      {r4-r12,pc}
;;;2288   /* End Function:_RMP_Mem_Ins *************************************************/
                          ENDP


                          AREA ||i._RMP_Mem_Search||, CODE, READONLY, ALIGN=1

                  _RMP_Mem_Search PROC
;;;2342   ******************************************************************************/
;;;2343   rmp_ret_t _RMP_Mem_Search(volatile void* Pool, rmp_ptr_t Size, rmp_cnt_t* FLI_Level, rmp_cnt_t* SLI_Level)
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;2344   {
000004  4682              MOV      r10,r0
000006  4688              MOV      r8,r1
000008  4693              MOV      r11,r2
;;;2345       rmp_cnt_t FLI_Level_Temp;
;;;2346       rmp_cnt_t SLI_Level_Temp;
;;;2347       rmp_cnt_t Level;
;;;2348       rmp_ptr_t LSB;
;;;2349       volatile struct RMP_Mem* Mem;
;;;2350   
;;;2351       /* Make sure that it is bigger than 64. 64=2^6 */
;;;2352       FLI_Level_Temp=RMP_MSB_Get(Size)-6;
00000a  4640              MOV      r0,r8
00000c  f7fffffe          BL       RMP_MSB_Get
000010  1f86              SUBS     r6,r0,#6
;;;2353       
;;;2354       /* Decide the SLI level directly from the FLI level. We plus the number by one here
;;;2355        * so that we can avoid the list search. However, when the allocated memory is just
;;;2356        * one of the levels, then we don't need to jump to the next level and can fit directly */
;;;2357       SLI_Level_Temp=(Size>>(FLI_Level_Temp+3))&0x07;
000012  1cf0              ADDS     r0,r6,#3
000014  fa28f000          LSR      r0,r8,r0
000018  f0000907          AND      r9,r0,#7
;;;2358       if(((rmp_cnt_t)Size)!=((1<<(FLI_Level_Temp+3))*(SLI_Level_Temp+8)))
00001c  1cf0              ADDS     r0,r6,#3
00001e  2101              MOVS     r1,#1
000020  fa01f000          LSL      r0,r1,r0
000024  f1090108          ADD      r1,r9,#8
000028  4348              MULS     r0,r1,r0
00002a  4540              CMP      r0,r8
00002c  d00e              BEQ      |L66.76|
;;;2359       {
;;;2360           RMP_COVERAGE_MARKER();
00002e  bf00              NOP      
000030  bf00              NOP      
;;;2361           SLI_Level_Temp++;
000032  f1090901          ADD      r9,r9,#1
;;;2362           
;;;2363           /* If the SLI level is the largest of the SLI level, then jump to the next FLI level */
;;;2364           if(SLI_Level_Temp==8)
000036  f1b90f08          CMP      r9,#8
00003a  d105              BNE      |L66.72|
;;;2365           {
;;;2366               RMP_COVERAGE_MARKER();
00003c  bf00              NOP      
00003e  bf00              NOP      
;;;2367               FLI_Level_Temp+=1;
000040  1c76              ADDS     r6,r6,#1
;;;2368               SLI_Level_Temp=0;
000042  f04f0900          MOV      r9,#0
000046  e003              B        |L66.80|
                  |L66.72|
;;;2369           }
;;;2370           else
;;;2371               RMP_COVERAGE_MARKER();
000048  bf00              NOP      
00004a  e001              B        |L66.80|
                  |L66.76|
;;;2372       }
;;;2373       else
;;;2374           RMP_COVERAGE_MARKER();
00004c  bf00              NOP      
00004e  bf00              NOP      
                  |L66.80|
;;;2375       
;;;2376       /* Check if the FLI level is over the boundary */
;;;2377       Mem=(volatile struct RMP_Mem*)Pool;
000050  4657              MOV      r7,r10
;;;2378       if((rmp_ptr_t)FLI_Level_Temp>=Mem->FLI_Num)
000052  68b8              LDR      r0,[r7,#8]
000054  42b0              CMP      r0,r6
000056  d806              BHI      |L66.102|
;;;2379       {
;;;2380           RMP_COVERAGE_MARKER();
000058  bf00              NOP      
00005a  bf00              NOP      
;;;2381           return -1;
00005c  f04f30ff          MOV      r0,#0xffffffff
                  |L66.96|
;;;2382       }
;;;2383       else
;;;2384           RMP_COVERAGE_MARKER();
;;;2385       
;;;2386       /* Try to find one position on this processor word level */
;;;2387       Level=(FLI_Level_Temp<<3)+SLI_Level_Temp;
;;;2388       LSB=RMP_LSB_Get(Mem->Bitmap[Level>>RMP_WORD_ORDER]>>(Level&RMP_WORD_MASK));
;;;2389       /* If there's at least one block that matches the query, return the level */
;;;2390       if(LSB<RMP_WORD_SIZE)
;;;2391       {
;;;2392           RMP_COVERAGE_MARKER();
;;;2393           Level=(Level&(~RMP_WORD_MASK))+LSB+(Level&RMP_WORD_MASK);
;;;2394           *FLI_Level=Level>>3;
;;;2395           *SLI_Level=Level&0x07;
;;;2396           return 0;
;;;2397       }
;;;2398       /* No one exactly fits */
;;;2399       else
;;;2400       {
;;;2401           RMP_COVERAGE_MARKER();
;;;2402           /* From the next word, query one by one. 5 is because we never have more than 128MB memory */
;;;2403           for(Level=(Level>>RMP_WORD_ORDER)+1;Level<5;Level++)
;;;2404           {
;;;2405               /* if the level has blocks of one FLI level */
;;;2406               if(Mem->Bitmap[Level]!=0)
;;;2407               {
;;;2408                   RMP_COVERAGE_MARKER();
;;;2409                   /* Find the actual level */ 
;;;2410                   LSB=RMP_LSB_Get(Mem->Bitmap[Level]);
;;;2411                   *FLI_Level=((Level<<RMP_WORD_ORDER)+LSB)>>3;
;;;2412                   *SLI_Level=LSB&0x07;
;;;2413                   return 0;
;;;2414               }
;;;2415               else
;;;2416                   RMP_COVERAGE_MARKER();
;;;2417           }
;;;2418       }
;;;2419   
;;;2420       /* Search failed */
;;;2421       return -1;
;;;2422   }
000060  b004              ADD      sp,sp,#0x10
000062  e8bd9ff0          POP      {r4-r12,pc}
                  |L66.102|
000066  bf00              NOP                            ;2384
000068  bf00              NOP                            ;2384
00006a  eb0904c6          ADD      r4,r9,r6,LSL #3       ;2387
00006e  1162              ASRS     r2,r4,#5              ;2388
000070  f1070114          ADD      r1,r7,#0x14           ;2388
000074  f8511022          LDR      r1,[r1,r2,LSL #2]     ;2388
000078  f004021f          AND      r2,r4,#0x1f           ;2388
00007c  fa21f002          LSR      r0,r1,r2              ;2388
000080  f7fffffe          BL       RMP_LSB_Get
000084  4605              MOV      r5,r0                 ;2388
000086  2d20              CMP      r5,#0x20              ;2390
000088  d210              BCS      |L66.172|
00008a  bf00              NOP                            ;2392
00008c  bf00              NOP                            ;2392
00008e  f024001f          BIC      r0,r4,#0x1f           ;2393
000092  4428              ADD      r0,r0,r5              ;2393
000094  f004011f          AND      r1,r4,#0x1f           ;2393
000098  1844              ADDS     r4,r0,r1              ;2393
00009a  10e0              ASRS     r0,r4,#3              ;2394
00009c  f8cb0000          STR      r0,[r11,#0]           ;2394
0000a0  f0040107          AND      r1,r4,#7              ;2395
0000a4  9803              LDR      r0,[sp,#0xc]          ;2395
0000a6  6001              STR      r1,[r0,#0]            ;2395
0000a8  2000              MOVS     r0,#0                 ;2396
0000aa  e7d9              B        |L66.96|
                  |L66.172|
0000ac  bf00              NOP                            ;2401
0000ae  bf00              NOP                            ;2401
0000b0  2001              MOVS     r0,#1                 ;2403
0000b2  eb001464          ADD      r4,r0,r4,ASR #5       ;2403
0000b6  e01b              B        |L66.240|
                  |L66.184|
0000b8  f1070014          ADD      r0,r7,#0x14           ;2406
0000bc  f8500024          LDR      r0,[r0,r4,LSL #2]     ;2406
0000c0  b198              CBZ      r0,|L66.234|
0000c2  bf00              NOP                            ;2408
0000c4  bf00              NOP                            ;2408
0000c6  f1070114          ADD      r1,r7,#0x14           ;2410
0000ca  f8510024          LDR      r0,[r1,r4,LSL #2]     ;2410
0000ce  f7fffffe          BL       RMP_LSB_Get
0000d2  4605              MOV      r5,r0                 ;2410
0000d4  eb051044          ADD      r0,r5,r4,LSL #5       ;2411
0000d8  08c0              LSRS     r0,r0,#3              ;2411
0000da  f8cb0000          STR      r0,[r11,#0]           ;2411
0000de  f0050107          AND      r1,r5,#7              ;2412
0000e2  9803              LDR      r0,[sp,#0xc]          ;2412
0000e4  6001              STR      r1,[r0,#0]            ;2412
0000e6  2000              MOVS     r0,#0                 ;2413
0000e8  e7ba              B        |L66.96|
                  |L66.234|
0000ea  bf00              NOP                            ;2416
0000ec  bf00              NOP                            ;2416
0000ee  1c64              ADDS     r4,r4,#1              ;2403
                  |L66.240|
0000f0  2c05              CMP      r4,#5                 ;2403
0000f2  dbe1              BLT      |L66.184|
0000f4  f04f30ff          MOV      r0,#0xffffffff        ;2421
0000f8  e7b2              B        |L66.96|
;;;2423   /* End Function:_RMP_Mem_Search **********************************************/
                          ENDP


                          AREA ||i._RMP_Set_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Set_Rdy PROC
;;;653    ******************************************************************************/
;;;654    void _RMP_Set_Rdy(volatile struct RMP_Thd* Thread)
000000  b510              PUSH     {r4,lr}
;;;655    {        
000002  4603              MOV      r3,r0
;;;656        /* Is it suspended? If yes, we can't directly set it running */
;;;657        if((Thread->State&RMP_THD_SUSPENDED)==0)
000004  6998              LDR      r0,[r3,#0x18]
000006  f4007080          AND      r0,r0,#0x100
00000a  bb30              CBNZ     r0,|L67.90|
;;;658        {
;;;659            RMP_COVERAGE_MARKER();
00000c  bf00              NOP      
00000e  bf00              NOP      
;;;660            /* Insert this into the corresponding runqueue */
;;;661            RMP_List_Ins(&(Thread->Run_Head),RMP_Run[Thread->Prio].Prev,&(RMP_Run[Thread->Prio]));
000010  6a58              LDR      r0,[r3,#0x24]
000012  4c13              LDR      r4,|L67.96|
000014  eb0402c0          ADD      r2,r4,r0,LSL #3
000018  6a58              LDR      r0,[r3,#0x24]
00001a  f8541030          LDR      r1,[r4,r0,LSL #3]
00001e  4618              MOV      r0,r3
000020  f7fffffe          BL       RMP_List_Ins
;;;662            /* Set this runlevel as active */
;;;663            RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]|=((rmp_ptr_t)1)<<(Thread->Prio&RMP_WORD_MASK);
000024  6a59              LDR      r1,[r3,#0x24]
000026  0949              LSRS     r1,r1,#5
000028  4a0e              LDR      r2,|L67.100|
00002a  eb020081          ADD      r0,r2,r1,LSL #2
00002e  6801              LDR      r1,[r0,#0]
000030  6a5a              LDR      r2,[r3,#0x24]
000032  f002041f          AND      r4,r2,#0x1f
000036  2201              MOVS     r2,#1
000038  40a2              LSLS     r2,r2,r4
00003a  4311              ORRS     r1,r1,r2
00003c  6001              STR      r1,[r0,#0]
;;;664            
;;;665            /* Compare this with the current one to see if we need a context switch */
;;;666            if(Thread->Prio>RMP_Cur_Thd->Prio)
00003e  6a58              LDR      r0,[r3,#0x24]
000040  4909              LDR      r1,|L67.104|
000042  6809              LDR      r1,[r1,#0]  ; RMP_Cur_Thd
000044  6a49              LDR      r1,[r1,#0x24]
000046  4288              CMP      r0,r1
000048  d905              BLS      |L67.86|
;;;667            {
;;;668                RMP_COVERAGE_MARKER();
00004a  bf00              NOP      
00004c  bf00              NOP      
;;;669                RMP_Sched_Pend=1;
00004e  2001              MOVS     r0,#1
000050  4906              LDR      r1,|L67.108|
000052  6008              STR      r0,[r1,#0]  ; RMP_Sched_Pend
000054  e003              B        |L67.94|
                  |L67.86|
;;;670            }
;;;671            else
;;;672                RMP_COVERAGE_MARKER();
000056  bf00              NOP      
000058  e001              B        |L67.94|
                  |L67.90|
;;;673        }
;;;674        else
;;;675            RMP_COVERAGE_MARKER();
00005a  bf00              NOP      
00005c  bf00              NOP      
                  |L67.94|
;;;676    }
00005e  bd10              POP      {r4,pc}
;;;677    /* End Function:_RMP_Set_Rdy *************************************************/
                          ENDP

                  |L67.96|
                          DCD      RMP_Run
                  |L67.100|
                          DCD      RMP_Bitmap
                  |L67.104|
                          DCD      RMP_Cur_Thd
                  |L67.108|
                          DCD      RMP_Sched_Pend

                          AREA ||i._RMP_Tick_Handler||, CODE, READONLY, ALIGN=2

                  _RMP_Tick_Handler PROC
;;;549    ******************************************************************************/
;;;550    void _RMP_Tick_Handler(rmp_ptr_t Ticks)
000000  b570              PUSH     {r4-r6,lr}
;;;551    {
000002  4604              MOV      r4,r0
;;;552        struct RMP_Thd* Thread;
;;;553        /* Increase the timestamp as always */
;;;554        RMP_Tick+=Ticks;
000004  4820              LDR      r0,|L68.136|
000006  6800              LDR      r0,[r0,#0]  ; RMP_Tick
000008  4420              ADD      r0,r0,r4
00000a  491f              LDR      r1,|L68.136|
00000c  6008              STR      r0,[r1,#0]  ; RMP_Tick
;;;555        
;;;556        /* See if the current thread expired. If yes, trigger a scheduler event */
;;;557        if(Ticks>RMP_Cur_Thd->Slices_Left)
00000e  481f              LDR      r0,|L68.140|
000010  6800              LDR      r0,[r0,#0]  ; RMP_Cur_Thd
000012  6a00              LDR      r0,[r0,#0x20]
000014  42a0              CMP      r0,r4
000016  d205              BCS      |L68.36|
;;;558        {
;;;559            RMP_COVERAGE_MARKER();
000018  bf00              NOP      
00001a  bf00              NOP      
;;;560            RMP_Sched_Pend=1;
00001c  2001              MOVS     r0,#1
00001e  491c              LDR      r1,|L68.144|
000020  6008              STR      r0,[r1,#0]  ; RMP_Sched_Pend
000022  e008              B        |L68.54|
                  |L68.36|
;;;561        }
;;;562        else
;;;563        {
;;;564            RMP_COVERAGE_MARKER();
000024  bf00              NOP      
000026  bf00              NOP      
;;;565            RMP_Cur_Thd->Slices_Left-=Ticks;
000028  4918              LDR      r1,|L68.140|
00002a  6809              LDR      r1,[r1,#0]  ; RMP_Cur_Thd
00002c  f1010020          ADD      r0,r1,#0x20
000030  6a09              LDR      r1,[r1,#0x20]
000032  1b09              SUBS     r1,r1,r4
000034  6001              STR      r1,[r0,#0]
                  |L68.54|
;;;566        }
;;;567        
;;;568        /* Check if there are any timer events */
;;;569        if((&RMP_Delay)!=RMP_Delay.Next)
000036  4817              LDR      r0,|L68.148|
000038  6840              LDR      r0,[r0,#4]  ; RMP_Delay
00003a  4916              LDR      r1,|L68.148|
00003c  4288              CMP      r0,r1
00003e  d013              BEQ      |L68.104|
;;;570        {
;;;571            RMP_COVERAGE_MARKER();
000040  bf00              NOP      
000042  bf00              NOP      
;;;572            Thread=RMP_DLY2THD(RMP_Delay.Next);
000044  4608              MOV      r0,r1
000046  6840              LDR      r0,[r0,#4]  ; RMP_Delay
000048  f1a00508          SUB      r5,r0,#8
;;;573            /* If the value is less than this, then it means that the time have
;;;574             * already passed and we have to process this */
;;;575            if((RMP_Tick-Thread->Timeout)<=(RMP_ALLBITS>>1))
00004c  490e              LDR      r1,|L68.136|
00004e  6aa8              LDR      r0,[r5,#0x28]
000050  6809              LDR      r1,[r1,#0]  ; RMP_Tick
000052  1a08              SUBS     r0,r1,r0
000054  f1b04f00          CMP      r0,#0x80000000
000058  d204              BCS      |L68.100|
;;;576            {
;;;577                RMP_COVERAGE_MARKER();
00005a  bf00              NOP      
00005c  bf00              NOP      
;;;578                /* No need to care about scheduler locks if this interrupt can be entered
;;;579                 * - we have disabled timer and scheduler interrupts in scheduler lock */
;;;580                _RMP_Timer_Proc();
00005e  f7fffffe          BL       _RMP_Timer_Proc
000062  e003              B        |L68.108|
                  |L68.100|
;;;581            }
;;;582            else
;;;583                RMP_COVERAGE_MARKER();
000064  bf00              NOP      
000066  e001              B        |L68.108|
                  |L68.104|
;;;584        }
;;;585        else
;;;586            RMP_COVERAGE_MARKER();
000068  bf00              NOP      
00006a  bf00              NOP      
                  |L68.108|
;;;587        
;;;588        if(RMP_Sched_Pend!=0)
00006c  4808              LDR      r0,|L68.144|
00006e  6800              LDR      r0,[r0,#0]  ; RMP_Sched_Pend
000070  b138              CBZ      r0,|L68.130|
;;;589        {
;;;590            RMP_COVERAGE_MARKER();
000072  bf00              NOP      
000074  bf00              NOP      
;;;591            RMP_Sched_Pend=0;
000076  2000              MOVS     r0,#0
000078  4905              LDR      r1,|L68.144|
00007a  6008              STR      r0,[r1,#0]  ; RMP_Sched_Pend
;;;592            _RMP_Yield();
00007c  f7fffffe          BL       _RMP_Yield
000080  e001              B        |L68.134|
                  |L68.130|
;;;593        }
;;;594        else
;;;595            RMP_COVERAGE_MARKER();
000082  bf00              NOP      
000084  bf00              NOP      
                  |L68.134|
;;;596        
;;;597    #if(RMP_USE_HOOKS==RMP_TRUE)
;;;598        RMP_Tick_Hook(Ticks);
;;;599    #endif
;;;600    }
000086  bd70              POP      {r4-r6,pc}
;;;601    /* End Function:_RMP_Tick_Handler ********************************************/
                          ENDP

                  |L68.136|
                          DCD      RMP_Tick
                  |L68.140|
                          DCD      RMP_Cur_Thd
                  |L68.144|
                          DCD      RMP_Sched_Pend
                  |L68.148|
                          DCD      RMP_Delay

                          AREA ||i._RMP_Timer_Proc||, CODE, READONLY, ALIGN=2

                  _RMP_Timer_Proc PROC
;;;437    ******************************************************************************/
;;;438    void _RMP_Timer_Proc(void)
000000  b510              PUSH     {r4,lr}
;;;439    {
;;;440        struct RMP_Thd* Thread;
;;;441        
;;;442        /* Process the timer events, if there are any of them */
;;;443        while((&RMP_Delay)!=RMP_Delay.Next)
000002  e03e              B        |L69.130|
                  |L69.4|
;;;444        {
;;;445            Thread=RMP_DLY2THD(RMP_Delay.Next);
000004  4822              LDR      r0,|L69.144|
000006  6840              LDR      r0,[r0,#4]  ; RMP_Delay
000008  f1a00408          SUB      r4,r0,#8
;;;446            /* If the value is more than this, then it means that the time have
;;;447             * already passed and we have to process this */
;;;448            if((RMP_Tick-Thread->Timeout)>(RMP_ALLBITS>>1))
00000c  4921              LDR      r1,|L69.148|
00000e  6aa0              LDR      r0,[r4,#0x28]
000010  6809              LDR      r1,[r1,#0]  ; RMP_Tick
000012  1a08              SUBS     r0,r1,r0
000014  f1b04f00          CMP      r0,#0x80000000
000018  d302              BCC      |L69.32|
;;;449            {
;;;450                RMP_COVERAGE_MARKER();
00001a  bf00              NOP      
00001c  bf00              NOP      
;;;451                break;
00001e  e035              B        |L69.140|
                  |L69.32|
;;;452            }
;;;453            else
;;;454                RMP_COVERAGE_MARKER();
000020  bf00              NOP      
000022  bf00              NOP      
;;;455            
;;;456            /* This thread should be processed */
;;;457            RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
000024  e9d40102          LDRD     r0,r1,[r4,#8]
000028  f7fffffe          BL       RMP_List_Del
;;;458            switch(RMP_THD_STATE(Thread->State))
00002c  7e20              LDRB     r0,[r4,#0x18]
00002e  2803              CMP      r0,#3
000030  d006              BEQ      |L69.64|
000032  2805              CMP      r0,#5
000034  d011              BEQ      |L69.90|
000036  2806              CMP      r0,#6
000038  d015              BEQ      |L69.102|
00003a  2808              CMP      r0,#8
00003c  d116              BNE      |L69.108|
00003e  e002              B        |L69.70|
                  |L69.64|
;;;459            {
;;;460                case RMP_THD_SNDDLY:RMP_COVERAGE_MARKER();
000040  bf00              NOP      
000042  bf00              NOP      
;;;461                case RMP_THD_SEMDLY:
000044  bf00              NOP      
                  |L69.70|
;;;462                {
;;;463                    RMP_COVERAGE_MARKER();
000046  bf00              NOP      
000048  bf00              NOP      
;;;464                    RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
00004a  e9d40100          LDRD     r0,r1,[r4,#0]
00004e  f7fffffe          BL       RMP_List_Del
;;;465                    Thread->Retval=RMP_ERR_OPER;
000052  f06f0004          MVN      r0,#4
000056  63a0              STR      r0,[r4,#0x38]
;;;466                    break;
000058  e00a              B        |L69.112|
                  |L69.90|
;;;467                }
;;;468                
;;;469                case RMP_THD_RCVDLY:
;;;470                {
;;;471                    RMP_COVERAGE_MARKER();
00005a  bf00              NOP      
00005c  bf00              NOP      
;;;472                    Thread->Retval=RMP_ERR_OPER;
00005e  f06f0004          MVN      r0,#4
000062  63a0              STR      r0,[r4,#0x38]
;;;473                    break;
000064  e004              B        |L69.112|
                  |L69.102|
;;;474                }
;;;475                
;;;476                case RMP_THD_DELAYED:RMP_COVERAGE_MARKER();break;
000066  bf00              NOP      
000068  bf00              NOP      
00006a  e001              B        |L69.112|
                  |L69.108|
;;;477                /* Should not get here */
;;;478                default:while(1);
00006c  bf00              NOP      
                  |L69.110|
00006e  e7fe              B        |L69.110|
                  |L69.112|
000070  bf00              NOP                            ;466
;;;479            }
;;;480    
;;;481            RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
000072  69a0              LDR      r0,[r4,#0x18]
000074  f02000ff          BIC      r0,r0,#0xff
000078  1c40              ADDS     r0,r0,#1
00007a  61a0              STR      r0,[r4,#0x18]
;;;482            /* Set to ready if not suspended */
;;;483            _RMP_Set_Rdy(Thread);
00007c  4620              MOV      r0,r4
00007e  f7fffffe          BL       _RMP_Set_Rdy
                  |L69.130|
000082  4803              LDR      r0,|L69.144|
000084  6840              LDR      r0,[r0,#4]            ;443  ; RMP_Delay
000086  4902              LDR      r1,|L69.144|
000088  4288              CMP      r0,r1                 ;443
00008a  d1bb              BNE      |L69.4|
                  |L69.140|
00008c  bf00              NOP                            ;451
;;;484        }
;;;485    }
00008e  bd10              POP      {r4,pc}
;;;486    /* Begin Function:_RMP_Timer_Proc ********************************************/
                          ENDP

                  |L69.144|
                          DCD      RMP_Delay
                  |L69.148|
                          DCD      RMP_Tick

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;1994   ******************************************************************************/
;;;1995   int main(void)
000000  b510              PUSH     {r4,lr}
;;;1996   {
;;;1997       rmp_ptr_t Count;
;;;1998       
;;;1999   #ifdef RMP_COVERAGE
;;;2000       /* Initialize coverage markers if coverage enabled */
;;;2001       for(Count=0;Count<RMP_COVERAGE_LINES;Count++)
;;;2002           RMP_Coverage[Count]=0;
;;;2003   #endif
;;;2004       
;;;2005       /* Initialize the kernel data structures first */
;;;2006       _RMP_Low_Level_Init();
000002  f7fffffe          BL       _RMP_Low_Level_Init
;;;2007       
;;;2008   #if(RMP_USE_HOOKS==RMP_TRUE)
;;;2009       RMP_Start_Hook();
;;;2010   #endif
;;;2011       
;;;2012       RMP_Tick=0;
000006  2000              MOVS     r0,#0
000008  4925              LDR      r1,|L70.160|
00000a  6008              STR      r0,[r1,#0]  ; RMP_Tick
;;;2013       /* Now initialize the kernel data structures */
;;;2014       RMP_Sched_Lock_Cnt=0;
00000c  4925              LDR      r1,|L70.164|
00000e  6008              STR      r0,[r1,#0]  ; RMP_Sched_Lock_Cnt
;;;2015       RMP_Sched_Locked=0;
000010  4925              LDR      r1,|L70.168|
000012  6008              STR      r0,[r1,#0]  ; RMP_Sched_Locked
;;;2016       RMP_Sched_Pend=0;
000014  4925              LDR      r1,|L70.172|
000016  6008              STR      r0,[r1,#0]  ; RMP_Sched_Pend
;;;2017       RMP_Timer_Pend=0;
000018  4925              LDR      r1,|L70.176|
00001a  6008              STR      r0,[r1,#0]  ; RMP_Timer_Pend
;;;2018       
;;;2019       /* Linked lists */
;;;2020       RMP_List_Crt(&RMP_Delay);
00001c  4825              LDR      r0,|L70.180|
00001e  f7fffffe          BL       RMP_List_Crt
;;;2021       for(Count=0;Count<RMP_MAX_PREEMPT_PRIO;Count++)
000022  2400              MOVS     r4,#0
000024  e005              B        |L70.50|
                  |L70.38|
;;;2022           RMP_List_Crt(&RMP_Run[Count]);
000026  4924              LDR      r1,|L70.184|
000028  eb0100c4          ADD      r0,r1,r4,LSL #3
00002c  f7fffffe          BL       RMP_List_Crt
000030  1c64              ADDS     r4,r4,#1              ;2021
                  |L70.50|
000032  2c20              CMP      r4,#0x20              ;2021
000034  d3f7              BCC      |L70.38|
;;;2023       for(Count=0;Count<RMP_BITMAP_SIZE;Count++)
000036  2400              MOVS     r4,#0
000038  e004              B        |L70.68|
                  |L70.58|
;;;2024           RMP_Bitmap[Count]=0;
00003a  2000              MOVS     r0,#0
00003c  491f              LDR      r1,|L70.188|
00003e  f8410024          STR      r0,[r1,r4,LSL #2]
000042  1c64              ADDS     r4,r4,#1              ;2023
                  |L70.68|
000044  2c00              CMP      r4,#0                 ;2023
000046  d0f8              BEQ      |L70.58|
;;;2025           
;;;2026       /* Now boot into the first thread */
;;;2027       RMP_Clear(&RMP_Init_Thd,sizeof(struct RMP_Thd));
000048  213c              MOVS     r1,#0x3c
00004a  481d              LDR      r0,|L70.192|
00004c  f7fffffe          BL       RMP_Clear
;;;2028       RMP_Init_Thd.Prio=0;
000050  2000              MOVS     r0,#0
000052  491b              LDR      r1,|L70.192|
000054  6248              STR      r0,[r1,#0x24]  ; RMP_Init_Thd
;;;2029       RMP_Init_Thd.Slices=10;
000056  200a              MOVS     r0,#0xa
000058  61c8              STR      r0,[r1,#0x1c]  ; RMP_Init_Thd
;;;2030       RMP_Init_Thd.Slices_Left=10;
00005a  6208              STR      r0,[r1,#0x20]  ; RMP_Init_Thd
;;;2031       RMP_Init_Thd.State=RMP_THD_RUNNING;
00005c  2001              MOVS     r0,#1
00005e  6188              STR      r0,[r1,#0x18]  ; RMP_Init_Thd
;;;2032       RMP_Init_Thd.Stack=RMP_INIT_STACK;
000060  4818              LDR      r0,|L70.196|
000062  6348              STR      r0,[r1,#0x34]  ; RMP_Init_Thd
;;;2033       
;;;2034       /* Initialize sending list */
;;;2035       RMP_List_Crt(&(RMP_Init_Thd.Snd_List));
000064  f1010010          ADD      r0,r1,#0x10
000068  f7fffffe          BL       RMP_List_Crt
;;;2036       
;;;2037       /* Insert this into the corresponding runqueue */
;;;2038       RMP_List_Ins(&(RMP_Init_Thd.Run_Head),RMP_Run[0].Prev,&(RMP_Run[0]));
00006c  4812              LDR      r0,|L70.184|
00006e  6801              LDR      r1,[r0,#0]  ; RMP_Run
000070  4602              MOV      r2,r0
000072  4813              LDR      r0,|L70.192|
000074  f7fffffe          BL       RMP_List_Ins
;;;2039       /* Set this runlevel as active - in fact it is always active */
;;;2040       RMP_Bitmap[0]|=1;
000078  4810              LDR      r0,|L70.188|
00007a  6800              LDR      r0,[r0,#0]  ; RMP_Bitmap
00007c  f0400001          ORR      r0,r0,#1
000080  490e              LDR      r1,|L70.188|
000082  6008              STR      r0,[r1,#0]  ; RMP_Bitmap
;;;2041       
;;;2042       /* Set current thread and stack */
;;;2043       RMP_Cur_Thd=(struct RMP_Thd*)(&RMP_Init_Thd);
000084  480e              LDR      r0,|L70.192|
000086  4910              LDR      r1,|L70.200|
000088  6008              STR      r0,[r1,#0]  ; RMP_Cur_Thd
;;;2044       RMP_Cur_SP=RMP_Init_Thd.Stack;
00008a  6b40              LDR      r0,[r0,#0x34]  ; RMP_Init_Thd
00008c  490f              LDR      r1,|L70.204|
00008e  6008              STR      r0,[r1,#0]  ; RMP_Cur_SP
;;;2045       
;;;2046       /* Now jump to the user function and will never return. Initialization of stack is not needed */
;;;2047       _RMP_Start((rmp_ptr_t)RMP_Init, (rmp_ptr_t)RMP_Init_Thd.Stack);
000090  480b              LDR      r0,|L70.192|
000092  6b41              LDR      r1,[r0,#0x34]  ; RMP_Init_Thd
000094  480e              LDR      r0,|L70.208|
000096  f7fffffe          BL       _RMP_Start
;;;2048       
;;;2049       return 0;
00009a  2000              MOVS     r0,#0
;;;2050   }
00009c  bd10              POP      {r4,pc}
;;;2051   /* End Function:main *********************************************************/
                          ENDP

00009e  0000              DCW      0x0000
                  |L70.160|
                          DCD      RMP_Tick
                  |L70.164|
                          DCD      RMP_Sched_Lock_Cnt
                  |L70.168|
                          DCD      RMP_Sched_Locked
                  |L70.172|
                          DCD      RMP_Sched_Pend
                  |L70.176|
                          DCD      RMP_Timer_Pend
                  |L70.180|
                          DCD      RMP_Delay
                  |L70.184|
                          DCD      RMP_Run
                  |L70.188|
                          DCD      RMP_Bitmap
                  |L70.192|
                          DCD      RMP_Init_Thd
                  |L70.196|
                          DCD      RMP_Init_Stack+0xbc
                  |L70.200|
                          DCD      RMP_Cur_Thd
                  |L70.204|
                          DCD      RMP_Cur_SP
                  |L70.208|
                          DCD      RMP_Init

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  RMP_Run
                          %        256
                  RMP_Init_Stack
                          %        256
                  RMP_Init_Thd
                          %        60

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  RMP_RBIT_Table
000000  008040c0          DCB      0x00,0x80,0x40,0xc0
000004  20a060e0          DCB      0x20,0xa0,0x60,0xe0
000008  109050d0          DCB      0x10,0x90,0x50,0xd0
00000c  30b070f0          DCB      0x30,0xb0,0x70,0xf0
000010  088848c8          DCB      0x08,0x88,0x48,0xc8
000014  28a868e8          DCB      0x28,0xa8,0x68,0xe8
000018  189858d8          DCB      0x18,0x98,0x58,0xd8
00001c  38b878f8          DCB      0x38,0xb8,0x78,0xf8
000020  048444c4          DCB      0x04,0x84,0x44,0xc4
000024  24a464e4          DCB      0x24,0xa4,0x64,0xe4
000028  149454d4          DCB      0x14,0x94,0x54,0xd4
00002c  34b474f4          DCB      0x34,0xb4,0x74,0xf4
000030  0c8c4ccc          DCB      0x0c,0x8c,0x4c,0xcc
000034  2cac6cec          DCB      0x2c,0xac,0x6c,0xec
000038  1c9c5cdc          DCB      0x1c,0x9c,0x5c,0xdc
00003c  3cbc7cfc          DCB      0x3c,0xbc,0x7c,0xfc
000040  028242c2          DCB      0x02,0x82,0x42,0xc2
000044  22a262e2          DCB      0x22,0xa2,0x62,0xe2
000048  129252d2          DCB      0x12,0x92,0x52,0xd2
00004c  32b272f2          DCB      0x32,0xb2,0x72,0xf2
000050  0a8a4aca          DCB      0x0a,0x8a,0x4a,0xca
000054  2aaa6aea          DCB      0x2a,0xaa,0x6a,0xea
000058  1a9a5ada          DCB      0x1a,0x9a,0x5a,0xda
00005c  3aba7afa          DCB      0x3a,0xba,0x7a,0xfa
000060  068646c6          DCB      0x06,0x86,0x46,0xc6
000064  26a666e6          DCB      0x26,0xa6,0x66,0xe6
000068  169656d6          DCB      0x16,0x96,0x56,0xd6
00006c  36b676f6          DCB      0x36,0xb6,0x76,0xf6
000070  0e8e4ece          DCB      0x0e,0x8e,0x4e,0xce
000074  2eae6eee          DCB      0x2e,0xae,0x6e,0xee
000078  1e9e5ede          DCB      0x1e,0x9e,0x5e,0xde
00007c  3ebe7efe          DCB      0x3e,0xbe,0x7e,0xfe
000080  018141c1          DCB      0x01,0x81,0x41,0xc1
000084  21a161e1          DCB      0x21,0xa1,0x61,0xe1
000088  119151d1          DCB      0x11,0x91,0x51,0xd1
00008c  31b171f1          DCB      0x31,0xb1,0x71,0xf1
000090  098949c9          DCB      0x09,0x89,0x49,0xc9
000094  29a969e9          DCB      0x29,0xa9,0x69,0xe9
000098  199959d9          DCB      0x19,0x99,0x59,0xd9
00009c  39b979f9          DCB      0x39,0xb9,0x79,0xf9
0000a0  058545c5          DCB      0x05,0x85,0x45,0xc5
0000a4  25a565e5          DCB      0x25,0xa5,0x65,0xe5
0000a8  159555d5          DCB      0x15,0x95,0x55,0xd5
0000ac  35b575f5          DCB      0x35,0xb5,0x75,0xf5
0000b0  0d8d4dcd          DCB      0x0d,0x8d,0x4d,0xcd
0000b4  2dad6ded          DCB      0x2d,0xad,0x6d,0xed
0000b8  1d9d5ddd          DCB      0x1d,0x9d,0x5d,0xdd
0000bc  3dbd7dfd          DCB      0x3d,0xbd,0x7d,0xfd
0000c0  038343c3          DCB      0x03,0x83,0x43,0xc3
0000c4  23a363e3          DCB      0x23,0xa3,0x63,0xe3
0000c8  139353d3          DCB      0x13,0x93,0x53,0xd3
0000cc  33b373f3          DCB      0x33,0xb3,0x73,0xf3
0000d0  0b8b4bcb          DCB      0x0b,0x8b,0x4b,0xcb
0000d4  2bab6beb          DCB      0x2b,0xab,0x6b,0xeb
0000d8  1b9b5bdb          DCB      0x1b,0x9b,0x5b,0xdb
0000dc  3bbb7bfb          DCB      0x3b,0xbb,0x7b,0xfb
0000e0  078747c7          DCB      0x07,0x87,0x47,0xc7
0000e4  27a767e7          DCB      0x27,0xa7,0x67,0xe7
0000e8  179757d7          DCB      0x17,0x97,0x57,0xd7
0000ec  37b777f7          DCB      0x37,0xb7,0x77,0xf7
0000f0  0f8f4fcf          DCB      0x0f,0x8f,0x4f,0xcf
0000f4  2faf6fef          DCB      0x2f,0xaf,0x6f,0xef
0000f8  1f9f5fdf          DCB      0x1f,0x9f,0x5f,0xdf
0000fc  3fbf7fff          DCB      0x3f,0xbf,0x7f,0xff
                  CRC16_High
000100  00c18140          DCB      0x00,0xc1,0x81,0x40
000104  01c08041          DCB      0x01,0xc0,0x80,0x41
000108  01c08041          DCB      0x01,0xc0,0x80,0x41
00010c  00c18140          DCB      0x00,0xc1,0x81,0x40
000110  01c08041          DCB      0x01,0xc0,0x80,0x41
000114  00c18140          DCB      0x00,0xc1,0x81,0x40
000118  00c18140          DCB      0x00,0xc1,0x81,0x40
00011c  01c08041          DCB      0x01,0xc0,0x80,0x41
000120  01c08041          DCB      0x01,0xc0,0x80,0x41
000124  00c18140          DCB      0x00,0xc1,0x81,0x40
000128  00c18140          DCB      0x00,0xc1,0x81,0x40
00012c  01c08041          DCB      0x01,0xc0,0x80,0x41
000130  00c18140          DCB      0x00,0xc1,0x81,0x40
000134  01c08041          DCB      0x01,0xc0,0x80,0x41
000138  01c08041          DCB      0x01,0xc0,0x80,0x41
00013c  00c18140          DCB      0x00,0xc1,0x81,0x40
000140  01c08041          DCB      0x01,0xc0,0x80,0x41
000144  00c18140          DCB      0x00,0xc1,0x81,0x40
000148  00c18140          DCB      0x00,0xc1,0x81,0x40
00014c  01c08041          DCB      0x01,0xc0,0x80,0x41
000150  00c18140          DCB      0x00,0xc1,0x81,0x40
000154  01c08041          DCB      0x01,0xc0,0x80,0x41
000158  01c08041          DCB      0x01,0xc0,0x80,0x41
00015c  00c18140          DCB      0x00,0xc1,0x81,0x40
000160  00c18140          DCB      0x00,0xc1,0x81,0x40
000164  01c08041          DCB      0x01,0xc0,0x80,0x41
000168  01c08041          DCB      0x01,0xc0,0x80,0x41
00016c  00c18140          DCB      0x00,0xc1,0x81,0x40
000170  01c08041          DCB      0x01,0xc0,0x80,0x41
000174  00c18140          DCB      0x00,0xc1,0x81,0x40
000178  00c18140          DCB      0x00,0xc1,0x81,0x40
00017c  01c08041          DCB      0x01,0xc0,0x80,0x41
000180  01c08041          DCB      0x01,0xc0,0x80,0x41
000184  00c18140          DCB      0x00,0xc1,0x81,0x40
000188  00c18140          DCB      0x00,0xc1,0x81,0x40
00018c  01c08041          DCB      0x01,0xc0,0x80,0x41
000190  00c18140          DCB      0x00,0xc1,0x81,0x40
000194  01c08041          DCB      0x01,0xc0,0x80,0x41
000198  01c08041          DCB      0x01,0xc0,0x80,0x41
00019c  00c18140          DCB      0x00,0xc1,0x81,0x40
0001a0  00c18140          DCB      0x00,0xc1,0x81,0x40
0001a4  01c08041          DCB      0x01,0xc0,0x80,0x41
0001a8  01c08041          DCB      0x01,0xc0,0x80,0x41
0001ac  00c18140          DCB      0x00,0xc1,0x81,0x40
0001b0  01c08041          DCB      0x01,0xc0,0x80,0x41
0001b4  00c18140          DCB      0x00,0xc1,0x81,0x40
0001b8  00c18140          DCB      0x00,0xc1,0x81,0x40
0001bc  01c08041          DCB      0x01,0xc0,0x80,0x41
0001c0  00c18140          DCB      0x00,0xc1,0x81,0x40
0001c4  01c08041          DCB      0x01,0xc0,0x80,0x41
0001c8  01c08041          DCB      0x01,0xc0,0x80,0x41
0001cc  00c18140          DCB      0x00,0xc1,0x81,0x40
0001d0  01c08041          DCB      0x01,0xc0,0x80,0x41
0001d4  00c18140          DCB      0x00,0xc1,0x81,0x40
0001d8  00c18140          DCB      0x00,0xc1,0x81,0x40
0001dc  01c08041          DCB      0x01,0xc0,0x80,0x41
0001e0  01c08041          DCB      0x01,0xc0,0x80,0x41
0001e4  00c18140          DCB      0x00,0xc1,0x81,0x40
0001e8  00c18140          DCB      0x00,0xc1,0x81,0x40
0001ec  01c08041          DCB      0x01,0xc0,0x80,0x41
0001f0  00c18140          DCB      0x00,0xc1,0x81,0x40
0001f4  01c08041          DCB      0x01,0xc0,0x80,0x41
0001f8  01c08041          DCB      0x01,0xc0,0x80,0x41
0001fc  00c18140          DCB      0x00,0xc1,0x81,0x40
                  Arrow_B
000200  00101120          DCB      0x00,0x10,0x11,0x20
000204  22303340          DCB      0x22,0x30,0x33,0x40
000208  44505560          DCB      0x44,0x50,0x55,0x60
00020c  66707780          DCB      0x66,0x70,0x77,0x80
000210  88909596          DCB      0x88,0x90,0x95,0x96
000214  979899a0          DCB      0x97,0x98,0x99,0xa0
000218  a2a3a5b0          DCB      0xa2,0xa3,0xa5,0xb0
00021c  b1b3b6c0          DCB      0xb1,0xb3,0xb6,0xc0
000220  c1c4c6d0          DCB      0xc1,0xc4,0xc6,0xd0
000224  d4d7e5e7          DCB      0xd4,0xd7,0xe5,0xe7
000228  f5f6              DCB      0xf5,0xf6
                  Arrow_W
00022a  2131              DCB      0x21,0x31
00022c  32414243          DCB      0x32,0x41,0x42,0x43
000230  51525354          DCB      0x51,0x52,0x53,0x54
000234  61626364          DCB      0x61,0x62,0x63,0x64
000238  65717273          DCB      0x65,0x71,0x72,0x73
00023c  74757681          DCB      0x74,0x75,0x76,0x81
000240  82838485          DCB      0x82,0x83,0x84,0x85
000244  86879192          DCB      0x86,0x87,0x91,0x92
000248  9394a1a4          DCB      0x93,0x94,0xa1,0xa4
00024c  b4b5c5d5          DCB      0xb4,0xb5,0xc5,0xd5
000250  d6e6              DCB      0xd6,0xe6
                  Busy_B
000252  0a0b              DCB      0x0a,0x0b
000254  0c0d0e1a          DCB      0x0c,0x0d,0x0e,0x1a
000258  1b1d1e2a          DCB      0x1b,0x1d,0x1e,0x2a
00025c  2c2e3b3d          DCB      0x2c,0x2e,0x3b,0x3d
000260  4c5b5d6a          DCB      0x4c,0x5b,0x5d,0x6a
000264  6e7a7c7e          DCB      0x6e,0x7a,0x7c,0x7e
000268  8a8b8c8d          DCB      0x8a,0x8b,0x8c,0x8d
00026c  8e                DCB      0x8e
                  Busy_W
00026d  1c2b2d            DCB      0x1c,0x2b,0x2d
000270  3c5c6b6c          DCB      0x3c,0x5c,0x6b,0x6c
000274  6d7b7d            DCB      0x6d,0x7b,0x7d
                  Question
000277  0b                DCB      0x0b
000278  0c0d1a1b          DCB      0x0c,0x0d,0x1a,0x1b
00027c  1c1d1e29          DCB      0x1c,0x1d,0x1e,0x29
000280  2a2b2d2e          DCB      0x2a,0x2b,0x2d,0x2e
000284  2f393a3e          DCB      0x2f,0x39,0x3a,0x3e
000288  3f4a4d4e          DCB      0x3f,0x4a,0x4d,0x4e
00028c  4f5c5d5e          DCB      0x4f,0x5c,0x5d,0x5e
000290  6c6d8d8e          DCB      0x6c,0x6d,0x8d,0x8e
000294  9d9e              DCB      0x9d,0x9e
                  Hand_B
000296  0506              DCB      0x05,0x06
000298  14172427          DCB      0x14,0x17,0x24,0x27
00029c  34373944          DCB      0x34,0x37,0x39,0x44
0002a0  47484a4c          DCB      0x47,0x48,0x4a,0x4c
0002a4  51525457          DCB      0x51,0x52,0x54,0x57
0002a8  5a5b5d5e          DCB      0x5a,0x5b,0x5d,0x5e
0002ac  60636467          DCB      0x60,0x63,0x64,0x67
0002b0  6a6d6f70          DCB      0x6a,0x6d,0x6f,0x70
0002b4  74777a7d          DCB      0x74,0x77,0x7a,0x7d
0002b8  7f808f90          DCB      0x7f,0x80,0x8f,0x90
0002bc  9fa0afb0          DCB      0x9f,0xa0,0xaf,0xb0
0002c0  bfc1ced1          DCB      0xbf,0xc1,0xce,0xd1
0002c4  d2d3d4d5          DCB      0xd2,0xd3,0xd4,0xd5
0002c8  d6d7d8d9          DCB      0xd6,0xd7,0xd8,0xd9
0002cc  dadbdcdd          DCB      0xda,0xdb,0xdc,0xdd
0002d0  dee1eef2          DCB      0xde,0xe1,0xee,0xf2
0002d4  f3f4f5f6          DCB      0xf3,0xf4,0xf5,0xf6
0002d8  f7f8f9fa          DCB      0xf7,0xf8,0xf9,0xfa
0002dc  fbfcfd            DCB      0xfb,0xfc,0xfd
                  Hand_W
0002df  15                DCB      0x15
0002e0  16252635          DCB      0x16,0x25,0x26,0x35
0002e4  36454649          DCB      0x36,0x45,0x46,0x49
0002e8  55565859          DCB      0x55,0x56,0x58,0x59
0002ec  5c616265          DCB      0x5c,0x61,0x62,0x65
0002f0  6668696b          DCB      0x66,0x68,0x69,0x6b
0002f4  6c6e7172          DCB      0x6c,0x6e,0x71,0x72
0002f8  73757678          DCB      0x73,0x75,0x76,0x78
0002fc  797b7c7e          DCB      0x79,0x7b,0x7c,0x7e
000300  81828384          DCB      0x81,0x82,0x83,0x84
000304  85868788          DCB      0x85,0x86,0x87,0x88
000308  898a8b8c          DCB      0x89,0x8a,0x8b,0x8c
00030c  8d8e9192          DCB      0x8d,0x8e,0x91,0x92
000310  93949596          DCB      0x93,0x94,0x95,0x96
000314  9798999a          DCB      0x97,0x98,0x99,0x9a
000318  9b9c9d9e          DCB      0x9b,0x9c,0x9d,0x9e
00031c  a1a2a3a4          DCB      0xa1,0xa2,0xa3,0xa4
000320  a5a6a7a8          DCB      0xa5,0xa6,0xa7,0xa8
000324  a9aaabac          DCB      0xa9,0xaa,0xab,0xac
000328  adaeb1b2          DCB      0xad,0xae,0xb1,0xb2
00032c  b3b4b5b6          DCB      0xb3,0xb4,0xb5,0xb6
000330  b7b8b9ba          DCB      0xb7,0xb8,0xb9,0xba
000334  bbbcbdbe          DCB      0xbb,0xbc,0xbd,0xbe
000338  c2c3c4c5          DCB      0xc2,0xc3,0xc4,0xc5
00033c  c6c7c8c9          DCB      0xc6,0xc7,0xc8,0xc9
000340  cacbcccd          DCB      0xca,0xcb,0xcc,0xcd
000344  e2e3e4e5          DCB      0xe2,0xe3,0xe4,0xe5
000348  e6e7e8e9          DCB      0xe6,0xe7,0xe8,0xe9
00034c  eaebeced          DCB      0xea,0xeb,0xec,0xed
                  Text
000350  00010204          DCB      0x00,0x01,0x02,0x04
000354  05061323          DCB      0x05,0x06,0x13,0x23
000358  33435363          DCB      0x33,0x43,0x53,0x63
00035c  738393a3          DCB      0x73,0x83,0x93,0xa3
000360  b3c3d3e3          DCB      0xb3,0xc3,0xd3,0xe3
000364  f0f1f2f4          DCB      0xf0,0xf1,0xf2,0xf4
000368  f5f6              DCB      0xf5,0xf6
                  Stop_B
00036a  0506              DCB      0x05,0x06
00036c  07081314          DCB      0x07,0x08,0x13,0x14
000370  15161718          DCB      0x15,0x16,0x17,0x18
000374  191a2223          DCB      0x19,0x1a,0x22,0x23
000378  24292a2b          DCB      0x24,0x29,0x2a,0x2b
00037c  31323334          DCB      0x31,0x32,0x33,0x34
000380  3a3b3c41          DCB      0x3a,0x3b,0x3c,0x41
000384  42434445          DCB      0x42,0x43,0x44,0x45
000388  4b4c5051          DCB      0x4b,0x4c,0x50,0x51
00038c  5455565c          DCB      0x54,0x55,0x56,0x5c
000390  5d606165          DCB      0x5d,0x60,0x61,0x65
000394  66676c6d          DCB      0x66,0x67,0x6c,0x6d
000398  70717677          DCB      0x70,0x71,0x76,0x77
00039c  787c7d80          DCB      0x78,0x7c,0x7d,0x80
0003a0  81878889          DCB      0x81,0x87,0x88,0x89
0003a4  8c8d9192          DCB      0x8c,0x8d,0x91,0x92
0003a8  98999a9b          DCB      0x98,0x99,0x9a,0x9b
0003ac  9ca1a2a3          DCB      0x9c,0xa1,0xa2,0xa3
0003b0  a9aaabac          DCB      0xa9,0xaa,0xab,0xac
0003b4  b2b3b4b9          DCB      0xb2,0xb3,0xb4,0xb9
0003b8  babbc3c4          DCB      0xba,0xbb,0xc3,0xc4
0003bc  c5c6c7c8          DCB      0xc5,0xc6,0xc7,0xc8
0003c0  c9cad5d6          DCB      0xc9,0xca,0xd5,0xd6
0003c4  d7d8              DCB      0xd7,0xd8
                  Stop_W
0003c6  2526              DCB      0x25,0x26
0003c8  27283536          DCB      0x27,0x28,0x35,0x36
0003cc  37383946          DCB      0x37,0x38,0x39,0x46
0003d0  4748494a          DCB      0x47,0x48,0x49,0x4a
0003d4  52535758          DCB      0x52,0x53,0x57,0x58
0003d8  595a5b62          DCB      0x59,0x5a,0x5b,0x62
0003dc  63646869          DCB      0x63,0x64,0x68,0x69
0003e0  6a6b7273          DCB      0x6a,0x6b,0x72,0x73
0003e4  7475797a          DCB      0x74,0x75,0x79,0x7a
0003e8  7b828384          DCB      0x7b,0x82,0x83,0x84
0003ec  85868a8b          DCB      0x85,0x86,0x8a,0x8b
0003f0  93949596          DCB      0x93,0x94,0x95,0x96
0003f4  97a4a5a6          DCB      0x97,0xa4,0xa5,0xa6
0003f8  a7a8b5b6          DCB      0xa7,0xa8,0xb5,0xb6
0003fc  b7b8              DCB      0xb7,0xb8
                  Adj_ALL
0003fe  0716              DCB      0x07,0x16
000400  17182526          DCB      0x17,0x18,0x25,0x26
000404  27282937          DCB      0x27,0x28,0x29,0x37
000408  4752575c          DCB      0x47,0x52,0x57,0x5c
00040c  6162676c          DCB      0x61,0x62,0x67,0x6c
000410  6d707172          DCB      0x6d,0x70,0x71,0x72
000414  73747576          DCB      0x73,0x74,0x75,0x76
000418  7778797a          DCB      0x77,0x78,0x79,0x7a
00041c  7b7c7d7e          DCB      0x7b,0x7c,0x7d,0x7e
000420  8182878c          DCB      0x81,0x82,0x87,0x8c
000424  8d92979c          DCB      0x8d,0x92,0x97,0x9c
000428  a7b7c5c6          DCB      0xa7,0xb7,0xc5,0xc6
00042c  c7c8c9d6          DCB      0xc7,0xc8,0xc9,0xd6
000430  d7d8e7            DCB      0xd7,0xd8,0xe7
                  Adj_LR
000433  52                DCB      0x52
000434  5d61626d          DCB      0x5d,0x61,0x62,0x6d
000438  6e707172          DCB      0x6e,0x70,0x71,0x72
00043c  73747576          DCB      0x73,0x74,0x75,0x76
000440  7778797a          DCB      0x77,0x78,0x79,0x7a
000444  7b7c7d7e          DCB      0x7b,0x7c,0x7d,0x7e
000448  7f81828d          DCB      0x7f,0x81,0x82,0x8d
00044c  8e929d            DCB      0x8e,0x92,0x9d
                  Adj_UD
00044f  07                DCB      0x07
000450  16171825          DCB      0x16,0x17,0x18,0x25
000454  26272829          DCB      0x26,0x27,0x28,0x29
000458  37475767          DCB      0x37,0x47,0x57,0x67
00045c  778797a7          DCB      0x77,0x87,0x97,0xa7
000460  b7c7d5d6          DCB      0xb7,0xc7,0xd5,0xd6
000464  d7d8d9e6          DCB      0xd7,0xd8,0xd9,0xe6
000468  e7e8f7            DCB      0xe7,0xe8,0xf7
                  Adj_BRUL
00046b  00                DCB      0x00
00046c  01020304          DCB      0x01,0x02,0x03,0x04
000470  10111213          DCB      0x10,0x11,0x12,0x13
000474  20212230          DCB      0x20,0x21,0x22,0x30
000478  31334044          DCB      0x31,0x33,0x40,0x44
00047c  55667788          DCB      0x55,0x66,0x77,0x88
000480  99aabbbf          DCB      0x99,0xaa,0xbb,0xbf
000484  cccecfdd          DCB      0xcc,0xce,0xcf,0xdd
000488  dedfeced          DCB      0xde,0xdf,0xec,0xed
00048c  eeeffbfc          DCB      0xee,0xef,0xfb,0xfc
000490  fdfeff            DCB      0xfd,0xfe,0xff
                  Adj_BLUR
000493  0b                DCB      0x0b
000494  0c0d0e0f          DCB      0x0c,0x0d,0x0e,0x0f
000498  1c1d1e1f          DCB      0x1c,0x1d,0x1e,0x1f
00049c  2d2e2f3c          DCB      0x2d,0x2e,0x2f,0x3c
0004a0  3e3f4b4f          DCB      0x3e,0x3f,0x4b,0x4f
0004a4  5a697887          DCB      0x5a,0x69,0x78,0x87
0004a8  96a5b0b4          DCB      0x96,0xa5,0xb0,0xb4
0004ac  c0c1c3d0          DCB      0xc0,0xc1,0xc3,0xd0
0004b0  d1d2e0e1          DCB      0xd1,0xd2,0xe0,0xe1
0004b4  e2e3f0f1          DCB      0xe2,0xe3,0xf0,0xf1
0004b8  f2f3f4            DCB      0xf2,0xf3,0xf4
                  Cross
0004bb  07                DCB      0x07
0004bc  17273746          DCB      0x17,0x27,0x37,0x46
0004c0  47485557          DCB      0x47,0x48,0x55,0x57
0004c4  59646a70          DCB      0x59,0x64,0x6a,0x70
0004c8  71727374          DCB      0x71,0x72,0x73,0x74
0004cc  7577797a          DCB      0x75,0x77,0x79,0x7a
0004d0  7b7c7d7e          DCB      0x7b,0x7c,0x7d,0x7e
0004d4  848a9597          DCB      0x84,0x8a,0x95,0x97
0004d8  99a6a7a8          DCB      0x99,0xa6,0xa7,0xa8
0004dc  b7c7d7e7          DCB      0xb7,0xc7,0xd7,0xe7
0004e0  00c0c101          DCB      0x00,0xc0,0xc1,0x01
0004e4  c30302c2          DCB      0xc3,0x03,0x02,0xc2
0004e8  c60607c7          DCB      0xc6,0x06,0x07,0xc7
0004ec  05c5c404          DCB      0x05,0xc5,0xc4,0x04
0004f0  cc0c0dcd          DCB      0xcc,0x0c,0x0d,0xcd
0004f4  0fcfce0e          DCB      0x0f,0xcf,0xce,0x0e
0004f8  0acacb0b          DCB      0x0a,0xca,0xcb,0x0b
0004fc  c90908c8          DCB      0xc9,0x09,0x08,0xc8
000500  d81819d9          DCB      0xd8,0x18,0x19,0xd9
000504  1bdbda1a          DCB      0x1b,0xdb,0xda,0x1a
000508  1ededf1f          DCB      0x1e,0xde,0xdf,0x1f
00050c  dd1d1cdc          DCB      0xdd,0x1d,0x1c,0xdc
000510  14d4d515          DCB      0x14,0xd4,0xd5,0x15
000514  d71716d6          DCB      0xd7,0x17,0x16,0xd6
000518  d21213d3          DCB      0xd2,0x12,0x13,0xd3
00051c  11d1d010          DCB      0x11,0xd1,0xd0,0x10
000520  f03031f1          DCB      0xf0,0x30,0x31,0xf1
000524  33f3f232          DCB      0x33,0xf3,0xf2,0x32
000528  36f6f737          DCB      0x36,0xf6,0xf7,0x37
00052c  f53534f4          DCB      0xf5,0x35,0x34,0xf4
000530  3cfcfd3d          DCB      0x3c,0xfc,0xfd,0x3d
000534  ff3f3efe          DCB      0xff,0x3f,0x3e,0xfe
000538  fa3a3bfb          DCB      0xfa,0x3a,0x3b,0xfb
00053c  39f9f838          DCB      0x39,0xf9,0xf8,0x38
000540  28e8e929          DCB      0x28,0xe8,0xe9,0x29
000544  eb2b2aea          DCB      0xeb,0x2b,0x2a,0xea
000548  ee2e2fef          DCB      0xee,0x2e,0x2f,0xef
00054c  2dedec2c          DCB      0x2d,0xed,0xec,0x2c
000550  e42425e5          DCB      0xe4,0x24,0x25,0xe5
000554  27e7e626          DCB      0x27,0xe7,0xe6,0x26
000558  22e2e323          DCB      0x22,0xe2,0xe3,0x23
00055c  e12120e0          DCB      0xe1,0x21,0x20,0xe0
000560  a06061a1          DCB      0xa0,0x60,0x61,0xa1
000564  63a3a262          DCB      0x63,0xa3,0xa2,0x62
000568  66a6a767          DCB      0x66,0xa6,0xa7,0x67
00056c  a56564a4          DCB      0xa5,0x65,0x64,0xa4
000570  6cacad6d          DCB      0x6c,0xac,0xad,0x6d
000574  af6f6eae          DCB      0xaf,0x6f,0x6e,0xae
000578  aa6a6bab          DCB      0xaa,0x6a,0x6b,0xab
00057c  69a9a868          DCB      0x69,0xa9,0xa8,0x68
000580  78b8b979          DCB      0x78,0xb8,0xb9,0x79
000584  bb7b7aba          DCB      0xbb,0x7b,0x7a,0xba
000588  be7e7fbf          DCB      0xbe,0x7e,0x7f,0xbf
00058c  7dbdbc7c          DCB      0x7d,0xbd,0xbc,0x7c
000590  b47475b5          DCB      0xb4,0x74,0x75,0xb5
000594  77b7b676          DCB      0x77,0xb7,0xb6,0x76
000598  72b2b373          DCB      0x72,0xb2,0xb3,0x73
00059c  b17170b0          DCB      0xb1,0x71,0x70,0xb0
0005a0  50909151          DCB      0x50,0x90,0x91,0x51
0005a4  93535292          DCB      0x93,0x53,0x52,0x92
0005a8  96565797          DCB      0x96,0x56,0x57,0x97
0005ac  55959454          DCB      0x55,0x95,0x94,0x54
0005b0  9c5c5d9d          DCB      0x9c,0x5c,0x5d,0x9d
0005b4  5f9f9e5e          DCB      0x5f,0x9f,0x9e,0x5e
0005b8  5a9a9b5b          DCB      0x5a,0x9a,0x9b,0x5b
0005bc  99595898          DCB      0x99,0x59,0x58,0x98
0005c0  88484989          DCB      0x88,0x48,0x49,0x89
0005c4  4b8b8a4a          DCB      0x4b,0x8b,0x8a,0x4a
0005c8  4e8e8f4f          DCB      0x4e,0x8e,0x8f,0x4f
0005cc  8d4d4c8c          DCB      0x8d,0x4d,0x4c,0x8c
0005d0  44848545          DCB      0x44,0x84,0x85,0x45
0005d4  87474686          DCB      0x87,0x47,0x46,0x86
0005d8  82424383          DCB      0x82,0x42,0x43,0x83
0005dc  41818040          DCB      0x41,0x81,0x80,0x40

                          AREA ||.data||, DATA, ALIGN=2

                  RMP_Bitmap
                          DCD      0x00000000
                  RMP_Delay
                          %        8
                  RMP_Sched_Lock_Cnt
                          DCD      0x00000000
                  RMP_Sched_Locked
                          DCD      0x00000000
                  RMP_Sched_Pend
                          DCD      0x00000000
                  RMP_Timer_Pend
                          DCD      0x00000000
                  RMP_Tick
                          DCD      0x00000000
                  RMP_Cur_Thd
                          DCD      0x00000000
                  RMP_Cur_SP
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\MProkaron\\Kernel\\rmp_kernel.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_rmp_kernel_c_346ad0e8____REV16|
#line 464 "D:\\Program_Files_x86\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.1.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___12_rmp_kernel_c_346ad0e8____REV16| PROC
#line 465

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_rmp_kernel_c_346ad0e8____REVSH|
#line 479
|__asm___12_rmp_kernel_c_346ad0e8____REVSH| PROC
#line 480

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___12_rmp_kernel_c_346ad0e8____RRX|
#line 666
|__asm___12_rmp_kernel_c_346ad0e8____RRX| PROC
#line 667

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
