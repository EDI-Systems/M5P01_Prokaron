; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f7xx_hal_cortex.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f7xx_hal_cortex.d --cpu=Cortex-M7 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Inc -I.\Source -I.\Drivers -I..\..\..\M6P1(D)_Duktape\duktape\src -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6-ALIENTEK-DUKTAPE\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER -DDUK_USE_BYTEORDER=1 --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f7xx_hal_cortex.crf ..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_cortex.c]
                          THUMB

                          AREA ||i.HAL_MPU_ConfigRegion||, CODE, READONLY, ALIGN=2

                  HAL_MPU_ConfigRegion PROC
;;;315      */
;;;316    void HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init)
000000  7841              LDRB     r1,[r0,#1]
;;;317    {
;;;318      /* Check the parameters */
;;;319      assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
;;;320      assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));
;;;321    
;;;322      /* Set the Region number */
;;;323      MPU->RNR = MPU_Init->Number;
000002  4a15              LDR      r2,|L1.88|
000004  6011              STR      r1,[r2,#0]
;;;324    
;;;325      if ((MPU_Init->Enable) != RESET)
000006  7801              LDRB     r1,[r0,#0]
000008  b1f9              CBZ      r1,|L1.74|
;;;326      {
;;;327        /* Check the parameters */
;;;328        assert_param(IS_MPU_INSTRUCTION_ACCESS(MPU_Init->DisableExec));
;;;329        assert_param(IS_MPU_REGION_PERMISSION_ATTRIBUTE(MPU_Init->AccessPermission));
;;;330        assert_param(IS_MPU_TEX_LEVEL(MPU_Init->TypeExtField));
;;;331        assert_param(IS_MPU_ACCESS_SHAREABLE(MPU_Init->IsShareable));
;;;332        assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
;;;333        assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
;;;334        assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
;;;335        assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
;;;336        
;;;337        MPU->RBAR = MPU_Init->BaseAddress;
00000a  1d12              ADDS     r2,r2,#4
00000c  6841              LDR      r1,[r0,#4]
00000e  6011              STR      r1,[r2,#0]
;;;338        MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
000010  7b01              LDRB     r1,[r0,#0xc]
000012  0709              LSLS     r1,r1,#28
000014  7ac2              LDRB     r2,[r0,#0xb]
000016  ea416102          ORR      r1,r1,r2,LSL #24
00001a  7a82              LDRB     r2,[r0,#0xa]
00001c  ea4141c2          ORR      r1,r1,r2,LSL #19
000020  7b42              LDRB     r2,[r0,#0xd]
000022  ea414182          ORR      r1,r1,r2,LSL #18
000026  7b82              LDRB     r2,[r0,#0xe]
000028  ea414142          ORR      r1,r1,r2,LSL #17
00002c  7bc2              LDRB     r2,[r0,#0xf]
00002e  ea414102          ORR      r1,r1,r2,LSL #16
000032  7a42              LDRB     r2,[r0,#9]
000034  ea412102          ORR      r1,r1,r2,LSL #8
000038  7a02              LDRB     r2,[r0,#8]
00003a  ea410142          ORR      r1,r1,r2,LSL #1
00003e  7802              LDRB     r2,[r0,#0]
000040  4311              ORRS     r1,r1,r2
000042  4a05              LDR      r2,|L1.88|
000044  3208              ADDS     r2,r2,#8
000046  6011              STR      r1,[r2,#0]
000048  e005              B        |L1.86|
                  |L1.74|
;;;339                    ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
;;;340                    ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
;;;341                    ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
;;;342                    ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
;;;343                    ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
;;;344                    ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
;;;345                    ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
;;;346                    ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);
;;;347      }
;;;348      else
;;;349      {
;;;350        MPU->RBAR = 0x00;
00004a  2100              MOVS     r1,#0
00004c  4a02              LDR      r2,|L1.88|
00004e  1d12              ADDS     r2,r2,#4
000050  6011              STR      r1,[r2,#0]
;;;351        MPU->RASR = 0x00;
000052  1d12              ADDS     r2,r2,#4
000054  6011              STR      r1,[r2,#0]
                  |L1.86|
;;;352      }
;;;353    }
000056  4770              BX       lr
;;;354    #endif /* __MPU_PRESENT */
                          ENDP

                  |L1.88|
                          DCD      0xe000ed98

                          AREA ||i.HAL_MPU_Disable||, CODE, READONLY, ALIGN=2

                  HAL_MPU_Disable PROC
;;;273      */
;;;274    void HAL_MPU_Disable(void)
000000  bf00              NOP      
;;;275    {
;;;276      /* Make sure outstanding transfers are done */
;;;277      __DMB();
000002  bf00              NOP      
000004  bf00              NOP      
000006  f3bf8f5f          DMB      
00000a  bf00              NOP      
00000c  bf00              NOP      
00000e  bf00              NOP      
;;;278    
;;;279      /* Disable fault exceptions */
;;;280      SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
000010  4805              LDR      r0,|L2.40|
000012  6800              LDR      r0,[r0,#0]
000014  f4203080          BIC      r0,r0,#0x10000
000018  4903              LDR      r1,|L2.40|
00001a  6008              STR      r0,[r1,#0]
;;;281      
;;;282      /* Disable the MPU and clear the control register*/
;;;283      MPU->CTRL = 0;
00001c  2000              MOVS     r0,#0
00001e  4902              LDR      r1,|L2.40|
000020  3170              ADDS     r1,r1,#0x70
000022  6008              STR      r0,[r1,#0]
;;;284    }
000024  4770              BX       lr
;;;285    
                          ENDP

000026  0000              DCW      0x0000
                  |L2.40|
                          DCD      0xe000ed24

                          AREA ||i.HAL_MPU_Enable||, CODE, READONLY, ALIGN=2

                  HAL_MPU_Enable PROC
;;;296      */
;;;297    void HAL_MPU_Enable(uint32_t MPU_Control)
000000  f0400101          ORR      r1,r0,#1
;;;298    {
;;;299      /* Enable the MPU */
;;;300      MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
000004  4a0d              LDR      r2,|L3.60|
000006  6011              STR      r1,[r2,#0]
;;;301      
;;;302      /* Enable fault exceptions */
;;;303      SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
000008  490c              LDR      r1,|L3.60|
00000a  3970              SUBS     r1,r1,#0x70
00000c  6809              LDR      r1,[r1,#0]
00000e  f4413180          ORR      r1,r1,#0x10000
000012  4a0a              LDR      r2,|L3.60|
000014  3a70              SUBS     r2,r2,#0x70
000016  6011              STR      r1,[r2,#0]
;;;304      
;;;305      /* Ensure MPU setting take effects */
;;;306      __DSB();
000018  bf00              NOP      
00001a  bf00              NOP      
00001c  bf00              NOP      
00001e  f3bf8f4f          DSB      
000022  bf00              NOP      
000024  bf00              NOP      
000026  bf00              NOP      
;;;307      __ISB();
000028  bf00              NOP      
00002a  bf00              NOP      
00002c  bf00              NOP      
00002e  f3bf8f6f          ISB      
000032  bf00              NOP      
000034  bf00              NOP      
000036  bf00              NOP      
;;;308    }
000038  4770              BX       lr
;;;309    
                          ENDP

00003a  0000              DCW      0x0000
                  |L3.60|
                          DCD      0xe000ed94

                          AREA ||i.HAL_NVIC_ClearPendingIRQ||, CODE, READONLY, ALIGN=2

                  HAL_NVIC_ClearPendingIRQ PROC
;;;435      */
;;;436    void HAL_NVIC_ClearPendingIRQ(IRQn_Type IRQn)
000000  b510              PUSH     {r4,lr}
;;;437    {
000002  4601              MOV      r1,r0
;;;438      /* Check the parameters */
;;;439      assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
;;;440      
;;;441      /* Clear pending interrupt */
;;;442      NVIC_ClearPendingIRQ(IRQn);
000004  4608              MOV      r0,r1
000006  2800              CMP      r0,#0
000008  db07              BLT      |L4.26|
00000a  f000031f          AND      r3,r0,#0x1f
00000e  2201              MOVS     r2,#1
000010  409a              LSLS     r2,r2,r3
000012  4b03              LDR      r3,|L4.32|
000014  0944              LSRS     r4,r0,#5
000016  f8432024          STR      r2,[r3,r4,LSL #2]
                  |L4.26|
00001a  bf00              NOP      
;;;443    }
00001c  bd10              POP      {r4,pc}
;;;444    
                          ENDP

00001e  0000              DCW      0x0000
                  |L4.32|
                          DCD      0xe000e280

                          AREA ||i.HAL_NVIC_DisableIRQ||, CODE, READONLY, ALIGN=2

                  HAL_NVIC_DisableIRQ PROC
;;;218      */
;;;219    void HAL_NVIC_DisableIRQ(IRQn_Type IRQn)
000000  b510              PUSH     {r4,lr}
;;;220    {
000002  4601              MOV      r1,r0
;;;221      /* Check the parameters */
;;;222      assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
;;;223      
;;;224      /* Disable interrupt */
;;;225      NVIC_DisableIRQ(IRQn);
000004  4608              MOV      r0,r1
000006  2800              CMP      r0,#0
000008  db17              BLT      |L5.58|
00000a  f000031f          AND      r3,r0,#0x1f
00000e  2201              MOVS     r2,#1
000010  409a              LSLS     r2,r2,r3
000012  4b0b              LDR      r3,|L5.64|
000014  0944              LSRS     r4,r0,#5
000016  f8432024          STR      r2,[r3,r4,LSL #2]
00001a  bf00              NOP      
00001c  bf00              NOP      
00001e  bf00              NOP      
000020  f3bf8f4f          DSB      
000024  bf00              NOP      
000026  bf00              NOP      
000028  bf00              NOP      
00002a  bf00              NOP      
00002c  bf00              NOP      
00002e  bf00              NOP      
000030  f3bf8f6f          ISB      
000034  bf00              NOP      
000036  bf00              NOP      
000038  bf00              NOP      
                  |L5.58|
00003a  bf00              NOP      
;;;226    }
00003c  bd10              POP      {r4,pc}
;;;227    
                          ENDP

00003e  0000              DCW      0x0000
                  |L5.64|
                          DCD      0xe000e180

                          AREA ||i.HAL_NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  HAL_NVIC_EnableIRQ PROC
;;;202      */
;;;203    void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
000000  4601              MOV      r1,r0
;;;204    {
;;;205      /* Check the parameters */
;;;206      assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
;;;207      
;;;208      /* Enable interrupt */
;;;209      NVIC_EnableIRQ(IRQn);
000002  4608              MOV      r0,r1
000004  2800              CMP      r0,#0
000006  db09              BLT      |L6.28|
000008  f000031f          AND      r3,r0,#0x1f
00000c  2201              MOVS     r2,#1
00000e  409a              LSLS     r2,r2,r3
000010  0943              LSRS     r3,r0,#5
000012  009b              LSLS     r3,r3,#2
000014  f10323e0          ADD      r3,r3,#0xe000e000
000018  f8c32100          STR      r2,[r3,#0x100]
                  |L6.28|
00001c  bf00              NOP      
;;;210    }
00001e  4770              BX       lr
;;;211    
                          ENDP


                          AREA ||i.HAL_NVIC_GetActive||, CODE, READONLY, ALIGN=2

                  HAL_NVIC_GetActive PROC
;;;452      */
;;;453    uint32_t HAL_NVIC_GetActive(IRQn_Type IRQn)
000000  b510              PUSH     {r4,lr}
;;;454    {
000002  4601              MOV      r1,r0
;;;455      /* Check the parameters */
;;;456      assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
;;;457      
;;;458      /* Return 1 if active else 0 */
;;;459      return NVIC_GetActive(IRQn);
000004  4608              MOV      r0,r1
000006  2800              CMP      r0,#0
000008  db0d              BLT      |L7.38|
00000a  4a08              LDR      r2,|L7.44|
00000c  0943              LSRS     r3,r0,#5
00000e  f8522023          LDR      r2,[r2,r3,LSL #2]
000012  f000041f          AND      r4,r0,#0x1f
000016  2301              MOVS     r3,#1
000018  40a3              LSLS     r3,r3,r4
00001a  401a              ANDS     r2,r2,r3
00001c  b10a              CBZ      r2,|L7.34|
00001e  2201              MOVS     r2,#1
000020  e002              B        |L7.40|
                  |L7.34|
000022  2200              MOVS     r2,#0
000024  e000              B        |L7.40|
                  |L7.38|
000026  2200              MOVS     r2,#0
                  |L7.40|
000028  4610              MOV      r0,r2
;;;460    }
00002a  bd10              POP      {r4,pc}
;;;461    
                          ENDP

                  |L7.44|
                          DCD      0xe000e300

                          AREA ||i.HAL_NVIC_GetPendingIRQ||, CODE, READONLY, ALIGN=2

                  HAL_NVIC_GetPendingIRQ PROC
;;;419      */
;;;420    uint32_t HAL_NVIC_GetPendingIRQ(IRQn_Type IRQn)
000000  b510              PUSH     {r4,lr}
;;;421    {
000002  4601              MOV      r1,r0
;;;422      /* Check the parameters */
;;;423      assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
;;;424      
;;;425      /* Return 1 if pending else 0 */
;;;426      return NVIC_GetPendingIRQ(IRQn);
000004  4608              MOV      r0,r1
000006  2800              CMP      r0,#0
000008  db0d              BLT      |L8.38|
00000a  4a08              LDR      r2,|L8.44|
00000c  0943              LSRS     r3,r0,#5
00000e  f8522023          LDR      r2,[r2,r3,LSL #2]
000012  f000041f          AND      r4,r0,#0x1f
000016  2301              MOVS     r3,#1
000018  40a3              LSLS     r3,r3,r4
00001a  401a              ANDS     r2,r2,r3
00001c  b10a              CBZ      r2,|L8.34|
00001e  2201              MOVS     r2,#1
000020  e002              B        |L8.40|
                  |L8.34|
000022  2200              MOVS     r2,#0
000024  e000              B        |L8.40|
                  |L8.38|
000026  2200              MOVS     r2,#0
                  |L8.40|
000028  4610              MOV      r0,r2
;;;427    }
00002a  bd10              POP      {r4,pc}
;;;428    
                          ENDP

                  |L8.44|
                          DCD      0xe000e200

                          AREA ||i.HAL_NVIC_GetPriority||, CODE, READONLY, ALIGN=2

                  HAL_NVIC_GetPriority PROC
;;;386      */
;;;387    void HAL_NVIC_GetPriority(IRQn_Type IRQn, uint32_t PriorityGroup, uint32_t *pPreemptPriority, uint32_t *pSubPriority)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;388    {
000004  4604              MOV      r4,r0
;;;389      /* Check the parameters */
;;;390      assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
;;;391     /* Get priority for Cortex-M system or device specific interrupts */
;;;392      NVIC_DecodePriority(NVIC_GetPriority(IRQn), PriorityGroup, pPreemptPriority, pSubPriority);
000006  4620              MOV      r0,r4
000008  2800              CMP      r0,#0
00000a  db03              BLT      |L9.20|
00000c  4f1f              LDR      r7,|L9.140|
00000e  5c3f              LDRB     r7,[r7,r0]
000010  093f              LSRS     r7,r7,#4
000012  e007              B        |L9.36|
                  |L9.20|
000014  4f1e              LDR      r7,|L9.144|
000016  f0000c0f          AND      r12,r0,#0xf
00001a  f1ac0c04          SUB      r12,r12,#4
00001e  f817700c          LDRB     r7,[r7,r12]
000022  093f              LSRS     r7,r7,#4
                  |L9.36|
000024  463d              MOV      r5,r7
000026  460e              MOV      r6,r1
000028  f0060007          AND      r0,r6,#7
00002c  f1c00807          RSB      r8,r0,#7
000030  f1b80f04          CMP      r8,#4
000034  d902              BLS      |L9.60|
000036  f04f0804          MOV      r8,#4
00003a  e001              B        |L9.64|
                  |L9.60|
00003c  f1c00807          RSB      r8,r0,#7
                  |L9.64|
000040  46c4              MOV      r12,r8
000042  f1000804          ADD      r8,r0,#4
000046  f1b80f07          CMP      r8,#7
00004a  d202              BCS      |L9.82|
00004c  f04f0800          MOV      r8,#0
000050  e001              B        |L9.86|
                  |L9.82|
000052  f1a00803          SUB      r8,r0,#3
                  |L9.86|
000056  4647              MOV      r7,r8
000058  fa25f807          LSR      r8,r5,r7
00005c  f04f0901          MOV      r9,#1
000060  fa09f90c          LSL      r9,r9,r12
000064  f1a90901          SUB      r9,r9,#1
000068  ea080809          AND      r8,r8,r9
00006c  f8c28000          STR      r8,[r2,#0]
000070  f04f0801          MOV      r8,#1
000074  fa08f807          LSL      r8,r8,r7
000078  f1a80801          SUB      r8,r8,#1
00007c  ea080805          AND      r8,r8,r5
000080  f8c38000          STR      r8,[r3,#0]
000084  bf00              NOP      
;;;393    }
000086  e8bd83f0          POP      {r4-r9,pc}
;;;394    
                          ENDP

00008a  0000              DCW      0x0000
                  |L9.140|
                          DCD      0xe000e400
                  |L9.144|
                          DCD      0xe000ed18

                          AREA ||i.HAL_NVIC_GetPriorityGrouping||, CODE, READONLY, ALIGN=1

                  HAL_NVIC_GetPriorityGrouping PROC
;;;359      */
;;;360    uint32_t HAL_NVIC_GetPriorityGrouping(void)
000000  b510              PUSH     {r4,lr}
;;;361    {
;;;362      /* Get the PRIGROUP[10:8] field value */
;;;363      return NVIC_GetPriorityGrouping();
000002  f7fffffe          BL       __NVIC_GetPriorityGrouping
;;;364    }
000006  bd10              POP      {r4,pc}
;;;365    
                          ENDP


                          AREA ||i.HAL_NVIC_SetPendingIRQ||, CODE, READONLY, ALIGN=2

                  HAL_NVIC_SetPendingIRQ PROC
;;;401      */
;;;402    void HAL_NVIC_SetPendingIRQ(IRQn_Type IRQn)
000000  b510              PUSH     {r4,lr}
;;;403    {
000002  4601              MOV      r1,r0
;;;404      /* Check the parameters */
;;;405      assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
;;;406      
;;;407      /* Set interrupt pending */
;;;408      NVIC_SetPendingIRQ(IRQn);
000004  4608              MOV      r0,r1
000006  2800              CMP      r0,#0
000008  db07              BLT      |L11.26|
00000a  f000031f          AND      r3,r0,#0x1f
00000e  2201              MOVS     r2,#1
000010  409a              LSLS     r2,r2,r3
000012  4b03              LDR      r3,|L11.32|
000014  0944              LSRS     r4,r0,#5
000016  f8432024          STR      r2,[r3,r4,LSL #2]
                  |L11.26|
00001a  bf00              NOP      
;;;409    }
00001c  bd10              POP      {r4,pc}
;;;410    
                          ENDP

00001e  0000              DCW      0x0000
                  |L11.32|
                          DCD      0xe000e200

                          AREA ||i.HAL_NVIC_SetPriority||, CODE, READONLY, ALIGN=1

                  HAL_NVIC_SetPriority PROC
;;;180      */
;;;181    void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;182    { 
000004  4680              MOV      r8,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;183      uint32_t prioritygroup = 0x00;
00000a  2700              MOVS     r7,#0
;;;184      
;;;185      /* Check the parameters */
;;;186      assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
;;;187      assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
;;;188      
;;;189      prioritygroup = NVIC_GetPriorityGrouping();
00000c  f7fffffe          BL       __NVIC_GetPriorityGrouping
000010  4607              MOV      r7,r0
;;;190      
;;;191      NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
000012  4639              MOV      r1,r7
000014  462a              MOV      r2,r5
000016  4633              MOV      r3,r6
000018  f0010007          AND      r0,r1,#7
00001c  f1c00a07          RSB      r10,r0,#7
000020  f1ba0f04          CMP      r10,#4
000024  d902              BLS      |L12.44|
000026  f04f0a04          MOV      r10,#4
00002a  e001              B        |L12.48|
                  |L12.44|
00002c  f1c00a07          RSB      r10,r0,#7
                  |L12.48|
000030  46d1              MOV      r9,r10
000032  f1000a04          ADD      r10,r0,#4
000036  f1ba0f07          CMP      r10,#7
00003a  d202              BCS      |L12.66|
00003c  f04f0a00          MOV      r10,#0
000040  e001              B        |L12.70|
                  |L12.66|
000042  f1a00a03          SUB      r10,r0,#3
                  |L12.70|
000046  46d4              MOV      r12,r10
000048  f04f0a01          MOV      r10,#1
00004c  fa0afa09          LSL      r10,r10,r9
000050  f1aa0a01          SUB      r10,r10,#1
000054  ea0a0a02          AND      r10,r10,r2
000058  fa0afa0c          LSL      r10,r10,r12
00005c  f04f0b01          MOV      r11,#1
000060  fa0bfb0c          LSL      r11,r11,r12
000064  f1ab0b01          SUB      r11,r11,#1
000068  ea0b0b03          AND      r11,r11,r3
00006c  ea4a040b          ORR      r4,r10,r11
000070  4621              MOV      r1,r4
000072  4640              MOV      r0,r8
000074  f7fffffe          BL       __NVIC_SetPriority
;;;192    }
000078  e8bd9ff0          POP      {r4-r12,pc}
;;;193    
                          ENDP


                          AREA ||i.HAL_NVIC_SetPriorityGrouping||, CODE, READONLY, ALIGN=2

                  HAL_NVIC_SetPriorityGrouping PROC
;;;158      */
;;;159    void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
000000  bf00              NOP      
000002  f0000207          AND      r2,r0,#7
000006  4b06              LDR      r3,|L13.32|
000008  6819              LDR      r1,[r3,#0]
00000a  f64f03ff          MOV      r3,#0xf8ff
00000e  4019              ANDS     r1,r1,r3
000010  4b04              LDR      r3,|L13.36|
000012  430b              ORRS     r3,r3,r1
000014  ea432102          ORR      r1,r3,r2,LSL #8
000018  4b01              LDR      r3,|L13.32|
00001a  6019              STR      r1,[r3,#0]
00001c  bf00              NOP      
;;;160    {
;;;161      /* Check the parameters */
;;;162      assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
;;;163      
;;;164      /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
;;;165      NVIC_SetPriorityGrouping(PriorityGroup);
;;;166    }
00001e  4770              BX       lr
;;;167    
                          ENDP

                  |L13.32|
                          DCD      0xe000ed0c
                  |L13.36|
                          DCD      0x05fa0000

                          AREA ||i.HAL_NVIC_SystemReset||, CODE, READONLY, ALIGN=2

                  HAL_NVIC_SystemReset PROC
;;;231      */
;;;232    void HAL_NVIC_SystemReset(void)
000000  bf00              NOP      
000002  bf00              NOP      
000004  bf00              NOP      
000006  bf00              NOP      
000008  bf00              NOP      
00000a  f3bf8f4f          DSB      
00000e  bf00              NOP      
000010  bf00              NOP      
000012  bf00              NOP      
000014  4809              LDR      r0,|L14.60|
000016  6800              LDR      r0,[r0,#0]
000018  f40060e0          AND      r0,r0,#0x700
00001c  4908              LDR      r1,|L14.64|
00001e  4308              ORRS     r0,r0,r1
000020  1d00              ADDS     r0,r0,#4
000022  4906              LDR      r1,|L14.60|
000024  6008              STR      r0,[r1,#0]
000026  bf00              NOP      
000028  bf00              NOP      
00002a  bf00              NOP      
00002c  f3bf8f4f          DSB      
000030  bf00              NOP      
000032  bf00              NOP      
000034  bf00              NOP      
000036  bf00              NOP      
                  |L14.56|
000038  bf00              NOP      
00003a  e7fd              B        |L14.56|
;;;233    {
;;;234      /* System Reset */
;;;235      NVIC_SystemReset();
;;;236    }
;;;237    
                          ENDP

                  |L14.60|
                          DCD      0xe000ed0c
                  |L14.64|
                          DCD      0x05fa0000

                          AREA ||i.HAL_SYSTICK_CLKSourceConfig||, CODE, READONLY, ALIGN=1

                  HAL_SYSTICK_CLKSourceConfig PROC
;;;469      */
;;;470    void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
000000  2804              CMP      r0,#4
;;;471    {
;;;472      /* Check the parameters */
;;;473      assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
;;;474      if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
000002  d108              BNE      |L15.22|
;;;475      {
;;;476        SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
000004  f04f21e0          MOV      r1,#0xe000e000
000008  6909              LDR      r1,[r1,#0x10]
00000a  f0410104          ORR      r1,r1,#4
00000e  f04f22e0          MOV      r2,#0xe000e000
000012  6111              STR      r1,[r2,#0x10]
000014  e007              B        |L15.38|
                  |L15.22|
;;;477      }
;;;478      else
;;;479      {
;;;480        SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
000016  f04f21e0          MOV      r1,#0xe000e000
00001a  6909              LDR      r1,[r1,#0x10]
00001c  f0210104          BIC      r1,r1,#4
000020  f04f22e0          MOV      r2,#0xe000e000
000024  6111              STR      r1,[r2,#0x10]
                  |L15.38|
;;;481      }
;;;482    }
000026  4770              BX       lr
;;;483    
                          ENDP


                          AREA ||i.HAL_SYSTICK_Callback||, CODE, READONLY, ALIGN=1

                  HAL_SYSTICK_Callback PROC
;;;496      */
;;;497    __weak void HAL_SYSTICK_Callback(void)
000000  4770              BX       lr
;;;498    {
;;;499      /* NOTE : This function Should not be modified, when the callback is needed,
;;;500                the HAL_SYSTICK_Callback could be implemented in the user file
;;;501       */
;;;502    }
;;;503    
                          ENDP


                          AREA ||i.HAL_SYSTICK_Config||, CODE, READONLY, ALIGN=1

                  HAL_SYSTICK_Config PROC
;;;244      */
;;;245    uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
000000  b570              PUSH     {r4-r6,lr}
;;;246    {
000002  4604              MOV      r4,r0
;;;247       return SysTick_Config(TicksNumb);
000004  4625              MOV      r5,r4
000006  1e68              SUBS     r0,r5,#1
000008  f1b07f80          CMP      r0,#0x1000000
00000c  d301              BCC      |L17.18|
00000e  2001              MOVS     r0,#1
000010  e00f              B        |L17.50|
                  |L17.18|
000012  1e68              SUBS     r0,r5,#1
000014  f04f21e0          MOV      r1,#0xe000e000
000018  6148              STR      r0,[r1,#0x14]
00001a  210f              MOVS     r1,#0xf
00001c  f04f30ff          MOV      r0,#0xffffffff
000020  f7fffffe          BL       __NVIC_SetPriority
000024  2000              MOVS     r0,#0
000026  f04f21e0          MOV      r1,#0xe000e000
00002a  6188              STR      r0,[r1,#0x18]
00002c  2007              MOVS     r0,#7
00002e  6108              STR      r0,[r1,#0x10]
000030  2000              MOVS     r0,#0
                  |L17.50|
;;;248    }
000032  bd70              POP      {r4-r6,pc}
;;;249    /**
                          ENDP


                          AREA ||i.HAL_SYSTICK_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_SYSTICK_IRQHandler PROC
;;;487      */
;;;488    void HAL_SYSTICK_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;489    {
;;;490      HAL_SYSTICK_Callback();
000002  f7fffffe          BL       HAL_SYSTICK_Callback
;;;491    }
000006  bd10              POP      {r4,pc}
;;;492    
                          ENDP


                          AREA ||i.__NVIC_GetPriorityGrouping||, CODE, READONLY, ALIGN=2

                  __NVIC_GetPriorityGrouping PROC
;;;1867    */
;;;1868   __STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
000000  4802              LDR      r0,|L19.12|
;;;1869   {
;;;1870     return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
000002  6800              LDR      r0,[r0,#0]
000004  f3c02002          UBFX     r0,r0,#8,#3
;;;1871   }
000008  4770              BX       lr
;;;1872   
                          ENDP

00000a  0000              DCW      0x0000
                  |L19.12|
                          DCD      0xe000ed0c

                          AREA ||i.__NVIC_SetPriority||, CODE, READONLY, ALIGN=2

                  __NVIC_SetPriority PROC
;;;2007    */
;;;2008   __STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
000000  b510              PUSH     {r4,lr}
;;;2009   {
;;;2010     if ((int32_t)(IRQn) >= 0)
000002  2800              CMP      r0,#0
000004  db04              BLT      |L20.16|
;;;2011     {
;;;2012       NVIC->IP[((uint32_t)(int32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
000006  070a              LSLS     r2,r1,#28
000008  0e13              LSRS     r3,r2,#24
00000a  4a05              LDR      r2,|L20.32|
00000c  5413              STRB     r3,[r2,r0]
00000e  e006              B        |L20.30|
                  |L20.16|
;;;2013     }
;;;2014     else
;;;2015     {
;;;2016       SCB->SHPR[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
000010  070a              LSLS     r2,r1,#28
000012  0e14              LSRS     r4,r2,#24
000014  4a03              LDR      r2,|L20.36|
000016  f000030f          AND      r3,r0,#0xf
00001a  1f1b              SUBS     r3,r3,#4
00001c  54d4              STRB     r4,[r2,r3]
                  |L20.30|
;;;2017     }
;;;2018   }
00001e  bd10              POP      {r4,pc}
;;;2019   
                          ENDP

                  |L20.32|
                          DCD      0xe000e400
                  |L20.36|
                          DCD      0xe000ed18

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F7_V1.11.0\\Drivers\\STM32F7xx_HAL_Driver\\Src\\stm32f7xx_hal_cortex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f7xx_hal_cortex_c_2992dbc0____REV16|
#line 464 "D:\\Program_Files_x86\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.1.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___22_stm32f7xx_hal_cortex_c_2992dbc0____REV16| PROC
#line 465

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f7xx_hal_cortex_c_2992dbc0____REVSH|
#line 479
|__asm___22_stm32f7xx_hal_cortex_c_2992dbc0____REVSH| PROC
#line 480

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f7xx_hal_cortex_c_2992dbc0____RRX|
#line 666
|__asm___22_stm32f7xx_hal_cortex_c_2992dbc0____RRX| PROC
#line 667

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
