; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f7xx_hal_tim.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f7xx_hal_tim.d --cpu=Cortex-M7 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Inc -I.\Source -I.\Drivers -I..\..\..\M6P1(D)_Duktape\duktape\src -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6-ALIENTEK-DUKTAPE\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER -DDUK_USE_BYTEORDER=1 --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f7xx_hal_tim.crf ..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_tim.c]
                          THUMB

                          AREA ||i.HAL_TIM_Base_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_DeInit PROC
;;;308      */
;;;309    HAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;310    {  
000002  4604              MOV      r4,r0
;;;311      /* Check the parameters */
;;;312      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;313    
;;;314      htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  6420              STR      r0,[r4,#0x40]
;;;315       
;;;316      /* Disable the TIM Peripheral Clock */
;;;317      __HAL_TIM_DISABLE(htim);
000008  bf00              NOP      
00000a  6820              LDR      r0,[r4,#0]
00000c  6a00              LDR      r0,[r0,#0x20]
00000e  f2411111          MOV      r1,#0x1111
000012  4008              ANDS     r0,r0,r1
000014  b950              CBNZ     r0,|L1.44|
000016  6820              LDR      r0,[r4,#0]
000018  6a00              LDR      r0,[r0,#0x20]
00001a  1089              ASRS     r1,r1,#2
00001c  4008              ANDS     r0,r0,r1
00001e  b928              CBNZ     r0,|L1.44|
000020  6820              LDR      r0,[r4,#0]
000022  6800              LDR      r0,[r0,#0]
000024  f0200001          BIC      r0,r0,#1
000028  6821              LDR      r1,[r4,#0]
00002a  6008              STR      r0,[r1,#0]
                  |L1.44|
00002c  bf00              NOP      
;;;318    
;;;319    #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;320      if(htim->Base_MspDeInitCallback == NULL)
;;;321      {
;;;322        htim->Base_MspDeInitCallback = HAL_TIM_Base_MspDeInit;
;;;323      }
;;;324      /* DeInit the low level hardware */
;;;325      htim->Base_MspDeInitCallback(htim);
;;;326    #else
;;;327      /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;328      HAL_TIM_Base_MspDeInit(htim);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       HAL_TIM_Base_MspDeInit
;;;329    #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;330      
;;;331      /* Change TIM state */  
;;;332      htim->State = HAL_TIM_STATE_RESET; 
000034  2000              MOVS     r0,#0
000036  6420              STR      r0,[r4,#0x40]
;;;333      
;;;334      /* Release Lock */
;;;335      __HAL_UNLOCK(htim);
000038  bf00              NOP      
00003a  63e0              STR      r0,[r4,#0x3c]
00003c  bf00              NOP      
;;;336    
;;;337      return HAL_OK;
;;;338    }
00003e  bd10              POP      {r4,pc}
;;;339    
                          ENDP


                          AREA ||i.HAL_TIM_Base_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_GetState PROC
;;;5234     */
;;;5235   HAL_TIM_StateTypeDef HAL_TIM_Base_GetState(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;5236   {
;;;5237     return htim->State;
000002  6c08              LDR      r0,[r1,#0x40]
;;;5238   }
000004  4770              BX       lr
;;;5239   
                          ENDP


                          AREA ||i.HAL_TIM_Base_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Init PROC
;;;256      */
;;;257    HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;258    { 
000002  4604              MOV      r4,r0
;;;259      /* Check the TIM handle allocation */
;;;260      if(htim == NULL)
000004  b90c              CBNZ     r4,|L3.10|
;;;261      {
;;;262        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L3.8|
;;;263      }
;;;264    
;;;265      /* Check the parameters */
;;;266      assert_param(IS_TIM_INSTANCE(htim->Instance)); 
;;;267      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;268      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;269      assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;270    
;;;271      if(htim->State == HAL_TIM_STATE_RESET)
;;;272      {
;;;273        /* Allocate lock resource and initialize it */
;;;274        htim->Lock = HAL_UNLOCKED;
;;;275    
;;;276    #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;277        /* Reset interrupt callbacks to legacy week callbacks */
;;;278        TIM_ResetCallback(htim);
;;;279    
;;;280        if(htim->Base_MspInitCallback == NULL)
;;;281        {
;;;282          htim->Base_MspInitCallback = HAL_TIM_Base_MspInit;
;;;283        }
;;;284        /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;285        htim->Base_MspInitCallback(htim);
;;;286    #else
;;;287        /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;288        HAL_TIM_Base_MspInit(htim);
;;;289    #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;290      }
;;;291      /* Set the TIM state */
;;;292      htim->State= HAL_TIM_STATE_BUSY;
;;;293      
;;;294      /* Set the Time Base configuration */
;;;295      TIM_Base_SetConfig(htim->Instance, &htim->Init); 
;;;296      
;;;297      /* Initialize the TIM state*/
;;;298      htim->State= HAL_TIM_STATE_READY;
;;;299      
;;;300      return HAL_OK;
;;;301    }
000008  bd10              POP      {r4,pc}
                  |L3.10|
00000a  6c20              LDR      r0,[r4,#0x40]         ;271
00000c  b920              CBNZ     r0,|L3.24|
00000e  2000              MOVS     r0,#0                 ;274
000010  63e0              STR      r0,[r4,#0x3c]         ;274
000012  4620              MOV      r0,r4                 ;288
000014  f7fffffe          BL       HAL_TIM_Base_MspInit
                  |L3.24|
000018  2002              MOVS     r0,#2                 ;292
00001a  6420              STR      r0,[r4,#0x40]         ;292
00001c  1d21              ADDS     r1,r4,#4              ;295
00001e  6820              LDR      r0,[r4,#0]            ;295
000020  f7fffffe          BL       TIM_Base_SetConfig
000024  2001              MOVS     r0,#1                 ;298
000026  6420              STR      r0,[r4,#0x40]         ;298
000028  2000              MOVS     r0,#0                 ;300
00002a  e7ed              B        |L3.8|
;;;302    
                          ENDP


                          AREA ||i.HAL_TIM_Base_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_MspDeInit PROC
;;;361      */
;;;362    __weak void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;363    {
;;;364      /* Prevent unused argument(s) compilation warning */
;;;365      UNUSED(htim);
;;;366     
;;;367      /* NOTE : This function Should not be modified, when the callback is needed,
;;;368                the HAL_TIM_Base_MspDeInit could be implemented in the user file
;;;369       */
;;;370    }
;;;371    
                          ENDP


                          AREA ||i.HAL_TIM_Base_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_MspInit PROC
;;;345      */
;;;346    __weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;347    {
;;;348      /* Prevent unused argument(s) compilation warning */
;;;349      UNUSED(htim);
;;;350     
;;;351      /* NOTE : This function Should not be modified, when the callback is needed,
;;;352                the HAL_TIM_Base_MspInit could be implemented in the user file
;;;353       */
;;;354    }
;;;355    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Start PROC
;;;377      */
;;;378    HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;379    {
;;;380      /* Check the parameters */
;;;381      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;382      
;;;383      /* Set the TIM state */
;;;384      htim->State= HAL_TIM_STATE_BUSY;
000002  2002              MOVS     r0,#2
000004  6408              STR      r0,[r1,#0x40]
;;;385      
;;;386      /* Enable the Peripheral */
;;;387      __HAL_TIM_ENABLE(htim);
000006  6808              LDR      r0,[r1,#0]
000008  6800              LDR      r0,[r0,#0]
00000a  f0400001          ORR      r0,r0,#1
00000e  680a              LDR      r2,[r1,#0]
000010  6010              STR      r0,[r2,#0]
;;;388      
;;;389      /* Change the TIM state*/
;;;390      htim->State= HAL_TIM_STATE_READY;
000012  2001              MOVS     r0,#1
000014  6408              STR      r0,[r1,#0x40]
;;;391      
;;;392      /* Return function status */
;;;393      return HAL_OK;
000016  2000              MOVS     r0,#0
;;;394    }
000018  4770              BX       lr
;;;395    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Base_Start_DMA PROC
;;;468      */
;;;469    HAL_StatusTypeDef HAL_TIM_Base_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;470    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;471      /* Check the parameters */
;;;472      assert_param(IS_TIM_DMA_INSTANCE(htim->Instance)); 
;;;473      
;;;474      if((htim->State == HAL_TIM_STATE_BUSY))
000008  6c20              LDR      r0,[r4,#0x40]
00000a  2802              CMP      r0,#2
00000c  d100              BNE      |L7.16|
                  |L7.14|
;;;475      {
;;;476         return HAL_BUSY;
;;;477      }
;;;478      else if((htim->State == HAL_TIM_STATE_READY))
;;;479      {
;;;480        if((pData == 0 ) && (Length > 0)) 
;;;481        {
;;;482          return HAL_ERROR;                                    
;;;483        }
;;;484        else
;;;485        {
;;;486          htim->State = HAL_TIM_STATE_BUSY;
;;;487        }
;;;488      }  
;;;489      /* Set the DMA Period elapsed callback */
;;;490      htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;491         
;;;492      /* Set the DMA error callback */
;;;493      htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = HAL_TIM_DMAError ;
;;;494      
;;;495      /* Enable the DMA Stream */
;;;496      HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)pData, (uint32_t)&htim->Instance->ARR, Length);
;;;497      
;;;498      /* Enable the TIM Update DMA request */
;;;499      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_UPDATE);
;;;500    
;;;501      /* Enable the Peripheral */
;;;502      __HAL_TIM_ENABLE(htim);  
;;;503      
;;;504      /* Return function status */
;;;505      return HAL_OK;
;;;506    }
00000e  bd70              POP      {r4-r6,pc}
                  |L7.16|
000010  6c20              LDR      r0,[r4,#0x40]         ;478
000012  2801              CMP      r0,#1                 ;478
000014  d105              BNE      |L7.34|
000016  b916              CBNZ     r6,|L7.30|
000018  2d00              CMP      r5,#0                 ;480
00001a  dd00              BLE      |L7.30|
00001c  e7f7              B        |L7.14|
                  |L7.30|
00001e  2002              MOVS     r0,#2                 ;486
000020  6420              STR      r0,[r4,#0x40]         ;486
                  |L7.34|
000022  480e              LDR      r0,|L7.92|
000024  6a21              LDR      r1,[r4,#0x20]         ;490
000026  6408              STR      r0,[r1,#0x40]         ;490
000028  480d              LDR      r0,|L7.96|
00002a  6a21              LDR      r1,[r4,#0x20]         ;493
00002c  6508              STR      r0,[r1,#0x50]         ;493
00002e  6821              LDR      r1,[r4,#0]            ;496
000030  f101022c          ADD      r2,r1,#0x2c           ;496
000034  462b              MOV      r3,r5                 ;496
000036  4631              MOV      r1,r6                 ;496
000038  6a20              LDR      r0,[r4,#0x20]         ;496
00003a  f7fffffe          BL       HAL_DMA_Start_IT
00003e  6820              LDR      r0,[r4,#0]            ;499
000040  68c0              LDR      r0,[r0,#0xc]          ;499
000042  f4407080          ORR      r0,r0,#0x100          ;499
000046  6821              LDR      r1,[r4,#0]            ;499
000048  60c8              STR      r0,[r1,#0xc]          ;499
00004a  6820              LDR      r0,[r4,#0]            ;502
00004c  6800              LDR      r0,[r0,#0]            ;502
00004e  f0400001          ORR      r0,r0,#1              ;502
000052  6821              LDR      r1,[r4,#0]            ;502
000054  6008              STR      r0,[r1,#0]            ;502
000056  2000              MOVS     r0,#0                 ;505
000058  e7d9              B        |L7.14|
;;;507    
                          ENDP

00005a  0000              DCW      0x0000
                  |L7.92|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L7.96|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_Base_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Start_IT PROC
;;;425      */
;;;426    HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;427    {
;;;428      /* Check the parameters */
;;;429      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;430      
;;;431      /* Enable the TIM Update interrupt */
;;;432      __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
000002  6808              LDR      r0,[r1,#0]
000004  68c0              LDR      r0,[r0,#0xc]
000006  f0400001          ORR      r0,r0,#1
00000a  680a              LDR      r2,[r1,#0]
00000c  60d0              STR      r0,[r2,#0xc]
;;;433          
;;;434      /* Enable the Peripheral */
;;;435      __HAL_TIM_ENABLE(htim);
00000e  6808              LDR      r0,[r1,#0]
000010  6800              LDR      r0,[r0,#0]
000012  f0400001          ORR      r0,r0,#1
000016  680a              LDR      r2,[r1,#0]
000018  6010              STR      r0,[r2,#0]
;;;436          
;;;437      /* Return function status */
;;;438      return HAL_OK;
00001a  2000              MOVS     r0,#0
;;;439    }
00001c  4770              BX       lr
;;;440    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Stop PROC
;;;401      */
;;;402    HAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;403    {
;;;404      /* Check the parameters */
;;;405      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;406      
;;;407      /* Set the TIM state */
;;;408      htim->State= HAL_TIM_STATE_BUSY;
000002  2002              MOVS     r0,#2
000004  6408              STR      r0,[r1,#0x40]
;;;409      
;;;410      /* Disable the Peripheral */
;;;411      __HAL_TIM_DISABLE(htim);
000006  bf00              NOP      
000008  6808              LDR      r0,[r1,#0]
00000a  6a00              LDR      r0,[r0,#0x20]
00000c  f2411211          MOV      r2,#0x1111
000010  4010              ANDS     r0,r0,r2
000012  b950              CBNZ     r0,|L9.42|
000014  6808              LDR      r0,[r1,#0]
000016  6a00              LDR      r0,[r0,#0x20]
000018  1092              ASRS     r2,r2,#2
00001a  4010              ANDS     r0,r0,r2
00001c  b928              CBNZ     r0,|L9.42|
00001e  6808              LDR      r0,[r1,#0]
000020  6800              LDR      r0,[r0,#0]
000022  f0200001          BIC      r0,r0,#1
000026  680a              LDR      r2,[r1,#0]
000028  6010              STR      r0,[r2,#0]
                  |L9.42|
00002a  bf00              NOP      
;;;412      
;;;413      /* Change the TIM state*/
;;;414      htim->State= HAL_TIM_STATE_READY;
00002c  2001              MOVS     r0,#1
00002e  6408              STR      r0,[r1,#0x40]
;;;415      
;;;416      /* Return function status */
;;;417      return HAL_OK;
000030  2000              MOVS     r0,#0
;;;418    }
000032  4770              BX       lr
;;;419    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Stop_DMA PROC
;;;513      */
;;;514    HAL_StatusTypeDef HAL_TIM_Base_Stop_DMA(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;515    {
;;;516      /* Check the parameters */
;;;517      assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
;;;518      
;;;519      /* Disable the TIM Update DMA request */
;;;520      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_UPDATE);
000002  6808              LDR      r0,[r1,#0]
000004  68c0              LDR      r0,[r0,#0xc]
000006  f4207080          BIC      r0,r0,#0x100
00000a  680a              LDR      r2,[r1,#0]
00000c  60d0              STR      r0,[r2,#0xc]
;;;521          
;;;522      /* Disable the Peripheral */
;;;523      __HAL_TIM_DISABLE(htim);
00000e  bf00              NOP      
000010  6808              LDR      r0,[r1,#0]
000012  6a00              LDR      r0,[r0,#0x20]
000014  f2411211          MOV      r2,#0x1111
000018  4010              ANDS     r0,r0,r2
00001a  b950              CBNZ     r0,|L10.50|
00001c  6808              LDR      r0,[r1,#0]
00001e  6a00              LDR      r0,[r0,#0x20]
000020  1092              ASRS     r2,r2,#2
000022  4010              ANDS     r0,r0,r2
000024  b928              CBNZ     r0,|L10.50|
000026  6808              LDR      r0,[r1,#0]
000028  6800              LDR      r0,[r0,#0]
00002a  f0200001          BIC      r0,r0,#1
00002e  680a              LDR      r2,[r1,#0]
000030  6010              STR      r0,[r2,#0]
                  |L10.50|
000032  bf00              NOP      
;;;524        
;;;525      /* Change the htim state */
;;;526      htim->State = HAL_TIM_STATE_READY;
000034  2001              MOVS     r0,#1
000036  6408              STR      r0,[r1,#0x40]
;;;527          
;;;528      /* Return function status */
;;;529      return HAL_OK;
000038  2000              MOVS     r0,#0
;;;530    }
00003a  4770              BX       lr
;;;531    
                          ENDP


                          AREA ||i.HAL_TIM_Base_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Base_Stop_IT PROC
;;;446      */
;;;447    HAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;448    {
;;;449      /* Check the parameters */
;;;450      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;451      /* Disable the TIM Update interrupt */
;;;452      __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
000002  6808              LDR      r0,[r1,#0]
000004  68c0              LDR      r0,[r0,#0xc]
000006  f0200001          BIC      r0,r0,#1
00000a  680a              LDR      r2,[r1,#0]
00000c  60d0              STR      r0,[r2,#0xc]
;;;453          
;;;454      /* Disable the Peripheral */
;;;455      __HAL_TIM_DISABLE(htim);
00000e  bf00              NOP      
000010  6808              LDR      r0,[r1,#0]
000012  6a00              LDR      r0,[r0,#0x20]
000014  f2411211          MOV      r2,#0x1111
000018  4010              ANDS     r0,r0,r2
00001a  b950              CBNZ     r0,|L11.50|
00001c  6808              LDR      r0,[r1,#0]
00001e  6a00              LDR      r0,[r0,#0x20]
000020  1092              ASRS     r2,r2,#2
000022  4010              ANDS     r0,r0,r2
000024  b928              CBNZ     r0,|L11.50|
000026  6808              LDR      r0,[r1,#0]
000028  6800              LDR      r0,[r0,#0]
00002a  f0200001          BIC      r0,r0,#1
00002e  680a              LDR      r2,[r1,#0]
000030  6010              STR      r0,[r2,#0]
                  |L11.50|
000032  bf00              NOP      
;;;456        
;;;457      /* Return function status */
;;;458      return HAL_OK;
000034  2000              MOVS     r0,#0
;;;459    }
000036  4770              BX       lr
;;;460    
                          ENDP


                          AREA ||i.HAL_TIM_ConfigClockSource||, CODE, READONLY, ALIGN=2

                  HAL_TIM_ConfigClockSource PROC
;;;4223     */ 
;;;4224   HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef * sClockSourceConfig)    
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;4225   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;4226     uint32_t tmpsmcr = 0;
000008  2600              MOVS     r6,#0
;;;4227       
;;;4228     /* Process Locked */
;;;4229     __HAL_LOCK(htim);
00000a  bf00              NOP      
00000c  6be0              LDR      r0,[r4,#0x3c]
00000e  2801              CMP      r0,#1
000010  d102              BNE      |L12.24|
000012  2002              MOVS     r0,#2
                  |L12.20|
;;;4230     
;;;4231     htim->State = HAL_TIM_STATE_BUSY;
;;;4232     
;;;4233     /* Check the parameters */
;;;4234     assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
;;;4235     
;;;4236     /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
;;;4237     tmpsmcr = htim->Instance->SMCR;
;;;4238     tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
;;;4239     tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
;;;4240     htim->Instance->SMCR = tmpsmcr;
;;;4241     
;;;4242     switch (sClockSourceConfig->ClockSource)
;;;4243     {
;;;4244       case TIM_CLOCKSOURCE_INTERNAL:
;;;4245       { 
;;;4246         assert_param(IS_TIM_INSTANCE(htim->Instance));      
;;;4247         /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;4248         htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;4249       }
;;;4250       break;
;;;4251       
;;;4252       case TIM_CLOCKSOURCE_ETRMODE1:
;;;4253       {
;;;4254         assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
;;;4255         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4256         assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
;;;4257         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4258         /* Configure the ETR Clock source */
;;;4259         TIM_ETR_SetConfig(htim->Instance, 
;;;4260                           sClockSourceConfig->ClockPrescaler, 
;;;4261                           sClockSourceConfig->ClockPolarity, 
;;;4262                           sClockSourceConfig->ClockFilter);
;;;4263         /* Get the TIMx SMCR register value */
;;;4264         tmpsmcr = htim->Instance->SMCR;
;;;4265         /* Reset the SMS and TS Bits */
;;;4266         tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
;;;4267         /* Select the External clock mode1 and the ETRF trigger */
;;;4268         tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
;;;4269         /* Write to TIMx SMCR */
;;;4270         htim->Instance->SMCR = tmpsmcr;
;;;4271       }
;;;4272       break;
;;;4273       
;;;4274       case TIM_CLOCKSOURCE_ETRMODE2:
;;;4275       {
;;;4276         assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
;;;4277         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4278         assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
;;;4279         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4280         
;;;4281         /* Configure the ETR Clock source */
;;;4282         TIM_ETR_SetConfig(htim->Instance, 
;;;4283                           sClockSourceConfig->ClockPrescaler, 
;;;4284                           sClockSourceConfig->ClockPolarity,
;;;4285                           sClockSourceConfig->ClockFilter);
;;;4286         /* Enable the External clock mode2 */
;;;4287         htim->Instance->SMCR |= TIM_SMCR_ECE;
;;;4288       }
;;;4289       break;
;;;4290       
;;;4291       case TIM_CLOCKSOURCE_TI1:
;;;4292       {
;;;4293         assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
;;;4294     
;;;4295         /* Check TI1 input conditioning related parameters */
;;;4296         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4297         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4298   
;;;4299         TIM_TI1_ConfigInputStage(htim->Instance, 
;;;4300                           sClockSourceConfig->ClockPolarity, 
;;;4301                           sClockSourceConfig->ClockFilter);
;;;4302         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
;;;4303       }
;;;4304       break;
;;;4305       case TIM_CLOCKSOURCE_TI2:
;;;4306       {
;;;4307         assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
;;;4308         
;;;4309         /* Check TI1 input conditioning related parameters */
;;;4310         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4311         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4312   
;;;4313         TIM_TI2_ConfigInputStage(htim->Instance, 
;;;4314                           sClockSourceConfig->ClockPolarity, 
;;;4315                           sClockSourceConfig->ClockFilter);
;;;4316         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
;;;4317       }
;;;4318       break;
;;;4319       case TIM_CLOCKSOURCE_TI1ED:
;;;4320       {
;;;4321         assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
;;;4322         /* Check TI1 input conditioning related parameters */
;;;4323         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4324         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4325     
;;;4326         TIM_TI1_ConfigInputStage(htim->Instance, 
;;;4327                           sClockSourceConfig->ClockPolarity,
;;;4328                           sClockSourceConfig->ClockFilter);
;;;4329         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
;;;4330       }
;;;4331       break;
;;;4332       case TIM_CLOCKSOURCE_ITR0:
;;;4333       {
;;;4334         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4335         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR0);
;;;4336       }
;;;4337       break;
;;;4338       case TIM_CLOCKSOURCE_ITR1:
;;;4339       {
;;;4340         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4341         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR1);
;;;4342       }
;;;4343       break;
;;;4344       case TIM_CLOCKSOURCE_ITR2:
;;;4345       {
;;;4346         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4347         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR2);
;;;4348       }
;;;4349       break;
;;;4350       case TIM_CLOCKSOURCE_ITR3:
;;;4351       {
;;;4352         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4353         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR3);
;;;4354       }
;;;4355       break;
;;;4356       
;;;4357       default:
;;;4358       break;    
;;;4359     }
;;;4360     htim->State = HAL_TIM_STATE_READY;
;;;4361     
;;;4362     __HAL_UNLOCK(htim);
;;;4363     
;;;4364     return HAL_OK;
;;;4365   }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L12.24|
000018  2001              MOVS     r0,#1                 ;4229
00001a  63e0              STR      r0,[r4,#0x3c]         ;4229
00001c  bf00              NOP                            ;4229
00001e  2002              MOVS     r0,#2                 ;4231
000020  6420              STR      r0,[r4,#0x40]         ;4231
000022  6820              LDR      r0,[r4,#0]            ;4237
000024  6886              LDR      r6,[r0,#8]            ;4237
000026  4841              LDR      r0,|L12.300|
000028  4006              ANDS     r6,r6,r0              ;4238
00002a  f426467f          BIC      r6,r6,#0xff00         ;4239
00002e  6820              LDR      r0,[r4,#0]            ;4240
000030  6086              STR      r6,[r0,#8]            ;4240
000032  6828              LDR      r0,[r5,#0]            ;4242
000034  2850              CMP      r0,#0x50              ;4242
000036  d03c              BEQ      |L12.178|
000038  dc0c              BGT      |L12.84|
00003a  2820              CMP      r0,#0x20              ;4242
00003c  d061              BEQ      |L12.258|
00003e  dc04              BGT      |L12.74|
000040  2800              CMP      r0,#0                 ;4242
000042  d054              BEQ      |L12.238|
000044  2810              CMP      r0,#0x10              ;4242
000046  d166              BNE      |L12.278|
000048  e056              B        |L12.248|
                  |L12.74|
00004a  2830              CMP      r0,#0x30              ;4242
00004c  d05e              BEQ      |L12.268|
00004e  2840              CMP      r0,#0x40              ;4242
000050  d161              BNE      |L12.278|
000052  e042              B        |L12.218|
                  |L12.84|
000054  2860              CMP      r0,#0x60              ;4242
000056  d036              BEQ      |L12.198|
000058  2870              CMP      r0,#0x70              ;4242
00005a  d00e              BEQ      |L12.122|
00005c  f5b05f80          CMP      r0,#0x1000            ;4242
000060  d003              BEQ      |L12.106|
000062  f5b05f00          CMP      r0,#0x2000            ;4242
000066  d156              BNE      |L12.278|
000068  e016              B        |L12.152|
                  |L12.106|
00006a  6820              LDR      r0,[r4,#0]            ;4248
00006c  6880              LDR      r0,[r0,#8]            ;4248
00006e  492f              LDR      r1,|L12.300|
000070  3170              ADDS     r1,r1,#0x70           ;4248
000072  4008              ANDS     r0,r0,r1              ;4248
000074  6821              LDR      r1,[r4,#0]            ;4248
000076  6088              STR      r0,[r1,#8]            ;4248
000078  e04e              B        |L12.280|
                  |L12.122|
00007a  e9d51302          LDRD     r1,r3,[r5,#8]         ;4259
00007e  686a              LDR      r2,[r5,#4]            ;4259
000080  6820              LDR      r0,[r4,#0]            ;4259
000082  f7fffffe          BL       TIM_ETR_SetConfig
000086  6820              LDR      r0,[r4,#0]            ;4264
000088  6886              LDR      r6,[r0,#8]            ;4264
00008a  4828              LDR      r0,|L12.300|
00008c  4006              ANDS     r6,r6,r0              ;4266
00008e  f0460677          ORR      r6,r6,#0x77           ;4268
000092  6820              LDR      r0,[r4,#0]            ;4270
000094  6086              STR      r6,[r0,#8]            ;4270
000096  e03f              B        |L12.280|
                  |L12.152|
000098  e9d51302          LDRD     r1,r3,[r5,#8]         ;4282
00009c  686a              LDR      r2,[r5,#4]            ;4282
00009e  6820              LDR      r0,[r4,#0]            ;4282
0000a0  f7fffffe          BL       TIM_ETR_SetConfig
0000a4  6820              LDR      r0,[r4,#0]            ;4287
0000a6  6880              LDR      r0,[r0,#8]            ;4287
0000a8  f4404080          ORR      r0,r0,#0x4000         ;4287
0000ac  6821              LDR      r1,[r4,#0]            ;4287
0000ae  6088              STR      r0,[r1,#8]            ;4287
0000b0  e032              B        |L12.280|
                  |L12.178|
0000b2  68ea              LDR      r2,[r5,#0xc]          ;4299
0000b4  6869              LDR      r1,[r5,#4]            ;4299
0000b6  6820              LDR      r0,[r4,#0]            ;4299
0000b8  f7fffffe          BL       TIM_TI1_ConfigInputStage
0000bc  2150              MOVS     r1,#0x50              ;4302
0000be  6820              LDR      r0,[r4,#0]            ;4302
0000c0  f7fffffe          BL       TIM_ITRx_SetConfig
0000c4  e028              B        |L12.280|
                  |L12.198|
0000c6  68ea              LDR      r2,[r5,#0xc]          ;4313
0000c8  6869              LDR      r1,[r5,#4]            ;4313
0000ca  6820              LDR      r0,[r4,#0]            ;4313
0000cc  f7fffffe          BL       TIM_TI2_ConfigInputStage
0000d0  2160              MOVS     r1,#0x60              ;4316
0000d2  6820              LDR      r0,[r4,#0]            ;4316
0000d4  f7fffffe          BL       TIM_ITRx_SetConfig
0000d8  e01e              B        |L12.280|
                  |L12.218|
0000da  68ea              LDR      r2,[r5,#0xc]          ;4326
0000dc  6869              LDR      r1,[r5,#4]            ;4326
0000de  6820              LDR      r0,[r4,#0]            ;4326
0000e0  f7fffffe          BL       TIM_TI1_ConfigInputStage
0000e4  2140              MOVS     r1,#0x40              ;4329
0000e6  6820              LDR      r0,[r4,#0]            ;4329
0000e8  f7fffffe          BL       TIM_ITRx_SetConfig
0000ec  e014              B        |L12.280|
                  |L12.238|
0000ee  2100              MOVS     r1,#0                 ;4335
0000f0  6820              LDR      r0,[r4,#0]            ;4335
0000f2  f7fffffe          BL       TIM_ITRx_SetConfig
0000f6  e00f              B        |L12.280|
                  |L12.248|
0000f8  2110              MOVS     r1,#0x10              ;4341
0000fa  6820              LDR      r0,[r4,#0]            ;4341
0000fc  f7fffffe          BL       TIM_ITRx_SetConfig
000100  e00a              B        |L12.280|
                  |L12.258|
000102  2120              MOVS     r1,#0x20              ;4347
000104  6820              LDR      r0,[r4,#0]            ;4347
000106  f7fffffe          BL       TIM_ITRx_SetConfig
00010a  e005              B        |L12.280|
                  |L12.268|
00010c  2130              MOVS     r1,#0x30              ;4353
00010e  6820              LDR      r0,[r4,#0]            ;4353
000110  f7fffffe          BL       TIM_ITRx_SetConfig
000114  e000              B        |L12.280|
                  |L12.278|
000116  bf00              NOP                            ;4358
                  |L12.280|
000118  bf00              NOP                            ;4250
00011a  2001              MOVS     r0,#1                 ;4360
00011c  6420              STR      r0,[r4,#0x40]         ;4360
00011e  bf00              NOP                            ;4362
000120  2000              MOVS     r0,#0                 ;4362
000122  63e0              STR      r0,[r4,#0x3c]         ;4362
000124  bf00              NOP                            ;4362
000126  bf00              NOP                            ;4364
000128  e774              B        |L12.20|
;;;4366   
                          ENDP

00012a  0000              DCW      0x0000
                  |L12.300|
                          DCD      0xfffeff88

                          AREA ||i.HAL_TIM_ConfigOCrefClear||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ConfigOCrefClear PROC
;;;4119     */ 
;;;4120   __weak HAL_StatusTypeDef HAL_TIM_ConfigOCrefClear(TIM_HandleTypeDef *htim, TIM_ClearInputConfigTypeDef * sClearInputConfig, uint32_t Channel)
000000  b5f0              PUSH     {r4-r7,lr}
;;;4121   { 
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;4122     /* Check the parameters */
;;;4123     assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4124     assert_param(IS_TIM_CHANNELS(Channel));
;;;4125     assert_param(IS_TIM_CLEARINPUT_SOURCE(sClearInputConfig->ClearInputSource));
;;;4126      
;;;4127     /* Process Locked */
;;;4128     __HAL_LOCK(htim);
000008  bf00              NOP      
00000a  6be0              LDR      r0,[r4,#0x3c]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L13.20|
000010  2002              MOVS     r0,#2
                  |L13.18|
;;;4129     
;;;4130     htim->State = HAL_TIM_STATE_BUSY;
;;;4131     
;;;4132     if(sClearInputConfig->ClearInputSource == TIM_CLEARINPUTSOURCE_ETR)
;;;4133     {
;;;4134       assert_param(IS_TIM_CLEARINPUT_POLARITY(sClearInputConfig->ClearInputPolarity));
;;;4135       assert_param(IS_TIM_CLEARINPUT_PRESCALER(sClearInputConfig->ClearInputPrescaler));
;;;4136       assert_param(IS_TIM_CLEARINPUT_FILTER(sClearInputConfig->ClearInputFilter));
;;;4137     
;;;4138       TIM_ETR_SetConfig(htim->Instance, 
;;;4139                         sClearInputConfig->ClearInputPrescaler,
;;;4140                         sClearInputConfig->ClearInputPolarity,
;;;4141                         sClearInputConfig->ClearInputFilter);
;;;4142     }
;;;4143     
;;;4144     switch (Channel)
;;;4145     {
;;;4146       case TIM_CHANNEL_1:
;;;4147       {        
;;;4148         if(sClearInputConfig->ClearInputState != RESET)  
;;;4149         {
;;;4150           /* Enable the Ocref clear feature for Channel 1 */
;;;4151           htim->Instance->CCMR1 |= TIM_CCMR1_OC1CE;
;;;4152         }
;;;4153         else
;;;4154         {
;;;4155           /* Disable the Ocref clear feature for Channel 1 */
;;;4156           htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1CE;      
;;;4157         }
;;;4158       }    
;;;4159       break;
;;;4160       case TIM_CHANNEL_2:    
;;;4161       { 
;;;4162         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance)); 
;;;4163         if(sClearInputConfig->ClearInputState != RESET)  
;;;4164         {
;;;4165           /* Enable the Ocref clear feature for Channel 2 */
;;;4166           htim->Instance->CCMR1 |= TIM_CCMR1_OC2CE;
;;;4167         }
;;;4168         else
;;;4169         {
;;;4170           /* Disable the Ocref clear feature for Channel 2 */
;;;4171           htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2CE;      
;;;4172         }
;;;4173       } 
;;;4174       break;
;;;4175       case TIM_CHANNEL_3:   
;;;4176       {  
;;;4177         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;4178         if(sClearInputConfig->ClearInputState != RESET)  
;;;4179         {
;;;4180           /* Enable the Ocref clear feature for Channel 3 */
;;;4181           htim->Instance->CCMR2 |= TIM_CCMR2_OC3CE;
;;;4182         }
;;;4183         else
;;;4184         {
;;;4185           /* Disable the Ocref clear feature for Channel 3 */
;;;4186           htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3CE;      
;;;4187         }
;;;4188       } 
;;;4189       break;
;;;4190       case TIM_CHANNEL_4:    
;;;4191       {  
;;;4192         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;4193         if(sClearInputConfig->ClearInputState != RESET)  
;;;4194         {
;;;4195           /* Enable the Ocref clear feature for Channel 4 */
;;;4196           htim->Instance->CCMR2 |= TIM_CCMR2_OC4CE;
;;;4197         }
;;;4198         else
;;;4199         {
;;;4200           /* Disable the Ocref clear feature for Channel 4 */
;;;4201           htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4CE;      
;;;4202         }
;;;4203       } 
;;;4204       break;
;;;4205       default:  
;;;4206       break;
;;;4207     } 
;;;4208   
;;;4209     htim->State = HAL_TIM_STATE_READY;
;;;4210     
;;;4211     __HAL_UNLOCK(htim);
;;;4212     
;;;4213     return HAL_OK;  
;;;4214   }  
000012  bdf0              POP      {r4-r7,pc}
                  |L13.20|
000014  2001              MOVS     r0,#1                 ;4128
000016  63e0              STR      r0,[r4,#0x3c]         ;4128
000018  bf00              NOP                            ;4128
00001a  2002              MOVS     r0,#2                 ;4130
00001c  6420              STR      r0,[r4,#0x40]         ;4130
00001e  6868              LDR      r0,[r5,#4]            ;4132
000020  2801              CMP      r0,#1                 ;4132
000022  d105              BNE      |L13.48|
000024  e9d51303          LDRD     r1,r3,[r5,#0xc]       ;4138
000028  68aa              LDR      r2,[r5,#8]            ;4138
00002a  6820              LDR      r0,[r4,#0]            ;4138
00002c  f7fffffe          BL       TIM_ETR_SetConfig
                  |L13.48|
000030  b136              CBZ      r6,|L13.64|
000032  2e04              CMP      r6,#4                 ;4144
000034  d014              BEQ      |L13.96|
000036  2e08              CMP      r6,#8                 ;4144
000038  d022              BEQ      |L13.128|
00003a  2e0c              CMP      r6,#0xc               ;4144
00003c  d140              BNE      |L13.192|
00003e  e02f              B        |L13.160|
                  |L13.64|
000040  6828              LDR      r0,[r5,#0]            ;4148
000042  b130              CBZ      r0,|L13.82|
000044  6820              LDR      r0,[r4,#0]            ;4151
000046  6980              LDR      r0,[r0,#0x18]         ;4151
000048  f0400080          ORR      r0,r0,#0x80           ;4151
00004c  6821              LDR      r1,[r4,#0]            ;4151
00004e  6188              STR      r0,[r1,#0x18]         ;4151
000050  e005              B        |L13.94|
                  |L13.82|
000052  6820              LDR      r0,[r4,#0]            ;4156
000054  6980              LDR      r0,[r0,#0x18]         ;4156
000056  f0200080          BIC      r0,r0,#0x80           ;4156
00005a  6821              LDR      r1,[r4,#0]            ;4156
00005c  6188              STR      r0,[r1,#0x18]         ;4156
                  |L13.94|
00005e  e030              B        |L13.194|
                  |L13.96|
000060  6828              LDR      r0,[r5,#0]            ;4163
000062  b130              CBZ      r0,|L13.114|
000064  6820              LDR      r0,[r4,#0]            ;4166
000066  6980              LDR      r0,[r0,#0x18]         ;4166
000068  f4404000          ORR      r0,r0,#0x8000         ;4166
00006c  6821              LDR      r1,[r4,#0]            ;4166
00006e  6188              STR      r0,[r1,#0x18]         ;4166
000070  e005              B        |L13.126|
                  |L13.114|
000072  6820              LDR      r0,[r4,#0]            ;4171
000074  6980              LDR      r0,[r0,#0x18]         ;4171
000076  f4204000          BIC      r0,r0,#0x8000         ;4171
00007a  6821              LDR      r1,[r4,#0]            ;4171
00007c  6188              STR      r0,[r1,#0x18]         ;4171
                  |L13.126|
00007e  e020              B        |L13.194|
                  |L13.128|
000080  6828              LDR      r0,[r5,#0]            ;4178
000082  b130              CBZ      r0,|L13.146|
000084  6820              LDR      r0,[r4,#0]            ;4181
000086  69c0              LDR      r0,[r0,#0x1c]         ;4181
000088  f0400080          ORR      r0,r0,#0x80           ;4181
00008c  6821              LDR      r1,[r4,#0]            ;4181
00008e  61c8              STR      r0,[r1,#0x1c]         ;4181
000090  e005              B        |L13.158|
                  |L13.146|
000092  6820              LDR      r0,[r4,#0]            ;4186
000094  69c0              LDR      r0,[r0,#0x1c]         ;4186
000096  f0200080          BIC      r0,r0,#0x80           ;4186
00009a  6821              LDR      r1,[r4,#0]            ;4186
00009c  61c8              STR      r0,[r1,#0x1c]         ;4186
                  |L13.158|
00009e  e010              B        |L13.194|
                  |L13.160|
0000a0  6828              LDR      r0,[r5,#0]            ;4193
0000a2  b130              CBZ      r0,|L13.178|
0000a4  6820              LDR      r0,[r4,#0]            ;4196
0000a6  69c0              LDR      r0,[r0,#0x1c]         ;4196
0000a8  f4404000          ORR      r0,r0,#0x8000         ;4196
0000ac  6821              LDR      r1,[r4,#0]            ;4196
0000ae  61c8              STR      r0,[r1,#0x1c]         ;4196
0000b0  e005              B        |L13.190|
                  |L13.178|
0000b2  6820              LDR      r0,[r4,#0]            ;4201
0000b4  69c0              LDR      r0,[r0,#0x1c]         ;4201
0000b6  f4204000          BIC      r0,r0,#0x8000         ;4201
0000ba  6821              LDR      r1,[r4,#0]            ;4201
0000bc  61c8              STR      r0,[r1,#0x1c]         ;4201
                  |L13.190|
0000be  e000              B        |L13.194|
                  |L13.192|
0000c0  bf00              NOP                            ;4206
                  |L13.194|
0000c2  bf00              NOP                            ;4159
0000c4  2001              MOVS     r0,#1                 ;4209
0000c6  6420              STR      r0,[r4,#0x40]         ;4209
0000c8  bf00              NOP                            ;4211
0000ca  2000              MOVS     r0,#0                 ;4211
0000cc  63e0              STR      r0,[r4,#0x3c]         ;4211
0000ce  bf00              NOP                            ;4211
0000d0  bf00              NOP                            ;4213
0000d2  e79e              B        |L13.18|
;;;4215   
                          ENDP


                          AREA ||i.HAL_TIM_ConfigTI1Input||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ConfigTI1Input PROC
;;;4379     */
;;;4380   HAL_StatusTypeDef HAL_TIM_ConfigTI1Input(TIM_HandleTypeDef *htim, uint32_t TI1_Selection)
000000  4602              MOV      r2,r0
;;;4381   {
000002  460b              MOV      r3,r1
;;;4382     uint32_t tmpcr2 = 0;
000004  2100              MOVS     r1,#0
;;;4383     
;;;4384     /* Check the parameters */
;;;4385     assert_param(IS_TIM_XOR_INSTANCE(htim->Instance)); 
;;;4386     assert_param(IS_TIM_TI1SELECTION(TI1_Selection));
;;;4387   
;;;4388     /* Get the TIMx CR2 register value */
;;;4389     tmpcr2 = htim->Instance->CR2;
000006  6810              LDR      r0,[r2,#0]
000008  6841              LDR      r1,[r0,#4]
;;;4390   
;;;4391     /* Reset the TI1 selection */
;;;4392     tmpcr2 &= ~TIM_CR2_TI1S;
00000a  f0210180          BIC      r1,r1,#0x80
;;;4393   
;;;4394     /* Set the TI1 selection */
;;;4395     tmpcr2 |= TI1_Selection;
00000e  4319              ORRS     r1,r1,r3
;;;4396     
;;;4397     /* Write to TIMxCR2 */
;;;4398     htim->Instance->CR2 = tmpcr2;
000010  6810              LDR      r0,[r2,#0]
000012  6041              STR      r1,[r0,#4]
;;;4399   
;;;4400     return HAL_OK;
000014  2000              MOVS     r0,#0
;;;4401   }
000016  4770              BX       lr
;;;4402   
                          ENDP


                          AREA ||i.HAL_TIM_DMABurst_ReadStart||, CODE, READONLY, ALIGN=2

                  HAL_TIM_DMABurst_ReadStart PROC
;;;3874     */
;;;3875   HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3876                                                uint32_t  *BurstBuffer, uint32_t  BurstLength)
;;;3877   {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  9d06              LDR      r5,[sp,#0x18]
;;;3878     /* Check the parameters */
;;;3879     assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
;;;3880     assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
;;;3881     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3882     assert_param(IS_TIM_DMA_LENGTH(BurstLength));
;;;3883     
;;;3884     if((htim->State == HAL_TIM_STATE_BUSY))
00000e  6c20              LDR      r0,[r4,#0x40]
000010  2802              CMP      r0,#2
000012  d101              BNE      |L15.24|
                  |L15.20|
;;;3885     {
;;;3886        return HAL_BUSY;
;;;3887     }
;;;3888     else if((htim->State == HAL_TIM_STATE_READY))
;;;3889     {
;;;3890       if((BurstBuffer == 0 ) && (BurstLength > 0)) 
;;;3891       {
;;;3892         return HAL_ERROR;                                    
;;;3893       }
;;;3894       else
;;;3895       {
;;;3896         htim->State = HAL_TIM_STATE_BUSY;
;;;3897       }
;;;3898     }  
;;;3899     switch(BurstRequestSrc)
;;;3900     {
;;;3901       case TIM_DMA_UPDATE:
;;;3902       {  
;;;3903         /* Set the DMA Period elapsed callback */
;;;3904         htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;3905        
;;;3906         /* Set the DMA error callback */
;;;3907         htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3908     
;;;3909         /* Enable the DMA Stream */
;;;3910          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);     
;;;3911       }
;;;3912       break;
;;;3913       case TIM_DMA_CC1:
;;;3914       {  
;;;3915         /* Set the DMA Period elapsed callback */
;;;3916         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;3917        
;;;3918         /* Set the DMA error callback */
;;;3919         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3920     
;;;3921         /* Enable the DMA Stream */
;;;3922         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
;;;3923       }
;;;3924       break;
;;;3925       case TIM_DMA_CC2:
;;;3926       {  
;;;3927         /* Set the DMA Period elapsed callback */
;;;3928         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;3929        
;;;3930         /* Set the DMA error callback */
;;;3931         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3932     
;;;3933         /* Enable the DMA Stream */
;;;3934         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);     
;;;3935       }
;;;3936       break;
;;;3937       case TIM_DMA_CC3:
;;;3938       {  
;;;3939         /* Set the DMA Period elapsed callback */
;;;3940         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;3941        
;;;3942         /* Set the DMA error callback */
;;;3943         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3944     
;;;3945         /* Enable the DMA Stream */
;;;3946         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
;;;3947       }
;;;3948       break;
;;;3949       case TIM_DMA_CC4:
;;;3950       {  
;;;3951         /* Set the DMA Period elapsed callback */
;;;3952         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;3953        
;;;3954         /* Set the DMA error callback */
;;;3955         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3956     
;;;3957         /* Enable the DMA Stream */
;;;3958         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
;;;3959       }
;;;3960       break;
;;;3961       case TIM_DMA_COM:
;;;3962       {  
;;;3963         /* Set the DMA Period elapsed callback */
;;;3964         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = HAL_TIMEx_DMACommutationCplt;
;;;3965        
;;;3966         /* Set the DMA error callback */
;;;3967         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3968     
;;;3969         /* Enable the DMA Stream */
;;;3970         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
;;;3971       }
;;;3972       break;
;;;3973       case TIM_DMA_TRIGGER:
;;;3974       {  
;;;3975         /* Set the DMA Period elapsed callback */
;;;3976         htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
;;;3977        
;;;3978         /* Set the DMA error callback */
;;;3979         htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3980     
;;;3981         /* Enable the DMA Stream */
;;;3982         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);      
;;;3983       }
;;;3984       break;
;;;3985       default:
;;;3986       break;  
;;;3987     }
;;;3988   
;;;3989     /* configure the DMA Burst Mode */
;;;3990     htim->Instance->DCR = BurstBaseAddress | BurstLength;  
;;;3991     
;;;3992     /* Enable the TIM DMA Request */
;;;3993     __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
;;;3994     
;;;3995     htim->State = HAL_TIM_STATE_READY;
;;;3996     
;;;3997     /* Return function status */
;;;3998     return HAL_OK;
;;;3999   }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L15.24|
000018  6c20              LDR      r0,[r4,#0x40]         ;3888
00001a  2801              CMP      r0,#1                 ;3888
00001c  d104              BNE      |L15.40|
00001e  b90f              CBNZ     r7,|L15.36|
000020  b105              CBZ      r5,|L15.36|
000022  e7f7              B        |L15.20|
                  |L15.36|
000024  2002              MOVS     r0,#2                 ;3896
000026  6420              STR      r0,[r4,#0x40]         ;3896
                  |L15.40|
000028  f5b66f00          CMP      r6,#0x800             ;3899
00002c  d047              BEQ      |L15.190|
00002e  dc09              BGT      |L15.68|
000030  f5b67f80          CMP      r6,#0x100             ;3899
000034  d010              BEQ      |L15.88|
000036  f5b67f00          CMP      r6,#0x200             ;3899
00003a  d01e              BEQ      |L15.122|
00003c  f5b66f80          CMP      r6,#0x400             ;3899
000040  d170              BNE      |L15.292|
000042  e02b              B        |L15.156|
                  |L15.68|
000044  f5b65f80          CMP      r6,#0x1000            ;3899
000048  d04a              BEQ      |L15.224|
00004a  f5b65f00          CMP      r6,#0x2000            ;3899
00004e  d058              BEQ      |L15.258|
000050  f5b64f80          CMP      r6,#0x4000            ;3899
000054  d178              BNE      |L15.328|
000056  e066              B        |L15.294|
                  |L15.88|
000058  4843              LDR      r0,|L15.360|
00005a  6a21              LDR      r1,[r4,#0x20]         ;3904
00005c  6408              STR      r0,[r1,#0x40]         ;3904
00005e  4843              LDR      r0,|L15.364|
000060  6a21              LDR      r1,[r4,#0x20]         ;3907
000062  6508              STR      r0,[r1,#0x50]         ;3907
000064  2201              MOVS     r2,#1                 ;3910
000066  eb022315          ADD      r3,r2,r5,LSR #8       ;3910
00006a  6822              LDR      r2,[r4,#0]            ;3910
00006c  f102014c          ADD      r1,r2,#0x4c           ;3910
000070  463a              MOV      r2,r7                 ;3910
000072  6a20              LDR      r0,[r4,#0x20]         ;3910
000074  f7fffffe          BL       HAL_DMA_Start_IT
000078  e067              B        |L15.330|
                  |L15.122|
00007a  493d              LDR      r1,|L15.368|
00007c  6a60              LDR      r0,[r4,#0x24]         ;3916
00007e  6401              STR      r1,[r0,#0x40]         ;3916
000080  493a              LDR      r1,|L15.364|
000082  6a60              LDR      r0,[r4,#0x24]         ;3919
000084  6501              STR      r1,[r0,#0x50]         ;3919
000086  2201              MOVS     r2,#1                 ;3922
000088  eb022315          ADD      r3,r2,r5,LSR #8       ;3922
00008c  6822              LDR      r2,[r4,#0]            ;3922
00008e  f102014c          ADD      r1,r2,#0x4c           ;3922
000092  463a              MOV      r2,r7                 ;3922
000094  6a60              LDR      r0,[r4,#0x24]         ;3922
000096  f7fffffe          BL       HAL_DMA_Start_IT
00009a  e056              B        |L15.330|
                  |L15.156|
00009c  4934              LDR      r1,|L15.368|
00009e  6aa0              LDR      r0,[r4,#0x28]         ;3928
0000a0  6401              STR      r1,[r0,#0x40]         ;3928
0000a2  4932              LDR      r1,|L15.364|
0000a4  6aa0              LDR      r0,[r4,#0x28]         ;3931
0000a6  6501              STR      r1,[r0,#0x50]         ;3931
0000a8  2201              MOVS     r2,#1                 ;3934
0000aa  eb022315          ADD      r3,r2,r5,LSR #8       ;3934
0000ae  6822              LDR      r2,[r4,#0]            ;3934
0000b0  f102014c          ADD      r1,r2,#0x4c           ;3934
0000b4  463a              MOV      r2,r7                 ;3934
0000b6  6aa0              LDR      r0,[r4,#0x28]         ;3934
0000b8  f7fffffe          BL       HAL_DMA_Start_IT
0000bc  e045              B        |L15.330|
                  |L15.190|
0000be  492c              LDR      r1,|L15.368|
0000c0  6ae0              LDR      r0,[r4,#0x2c]         ;3940
0000c2  6401              STR      r1,[r0,#0x40]         ;3940
0000c4  4929              LDR      r1,|L15.364|
0000c6  6ae0              LDR      r0,[r4,#0x2c]         ;3943
0000c8  6501              STR      r1,[r0,#0x50]         ;3943
0000ca  2201              MOVS     r2,#1                 ;3946
0000cc  eb022315          ADD      r3,r2,r5,LSR #8       ;3946
0000d0  6822              LDR      r2,[r4,#0]            ;3946
0000d2  f102014c          ADD      r1,r2,#0x4c           ;3946
0000d6  463a              MOV      r2,r7                 ;3946
0000d8  6ae0              LDR      r0,[r4,#0x2c]         ;3946
0000da  f7fffffe          BL       HAL_DMA_Start_IT
0000de  e034              B        |L15.330|
                  |L15.224|
0000e0  4923              LDR      r1,|L15.368|
0000e2  6b20              LDR      r0,[r4,#0x30]         ;3952
0000e4  6401              STR      r1,[r0,#0x40]         ;3952
0000e6  4921              LDR      r1,|L15.364|
0000e8  6b20              LDR      r0,[r4,#0x30]         ;3955
0000ea  6501              STR      r1,[r0,#0x50]         ;3955
0000ec  2201              MOVS     r2,#1                 ;3958
0000ee  eb022315          ADD      r3,r2,r5,LSR #8       ;3958
0000f2  6822              LDR      r2,[r4,#0]            ;3958
0000f4  f102014c          ADD      r1,r2,#0x4c           ;3958
0000f8  463a              MOV      r2,r7                 ;3958
0000fa  6b20              LDR      r0,[r4,#0x30]         ;3958
0000fc  f7fffffe          BL       HAL_DMA_Start_IT
000100  e023              B        |L15.330|
                  |L15.258|
000102  491c              LDR      r1,|L15.372|
000104  6b60              LDR      r0,[r4,#0x34]         ;3964
000106  6401              STR      r1,[r0,#0x40]         ;3964
000108  4918              LDR      r1,|L15.364|
00010a  6b60              LDR      r0,[r4,#0x34]         ;3967
00010c  6501              STR      r1,[r0,#0x50]         ;3967
00010e  2201              MOVS     r2,#1                 ;3970
000110  eb022315          ADD      r3,r2,r5,LSR #8       ;3970
000114  6822              LDR      r2,[r4,#0]            ;3970
000116  f102014c          ADD      r1,r2,#0x4c           ;3970
00011a  463a              MOV      r2,r7                 ;3970
00011c  6b60              LDR      r0,[r4,#0x34]         ;3970
00011e  f7fffffe          BL       HAL_DMA_Start_IT
000122  e012              B        |L15.330|
                  |L15.292|
000124  e010              B        |L15.328|
                  |L15.294|
000126  4914              LDR      r1,|L15.376|
000128  6ba0              LDR      r0,[r4,#0x38]         ;3976
00012a  6401              STR      r1,[r0,#0x40]         ;3976
00012c  490f              LDR      r1,|L15.364|
00012e  6ba0              LDR      r0,[r4,#0x38]         ;3979
000130  6501              STR      r1,[r0,#0x50]         ;3979
000132  2201              MOVS     r2,#1                 ;3982
000134  eb022315          ADD      r3,r2,r5,LSR #8       ;3982
000138  6822              LDR      r2,[r4,#0]            ;3982
00013a  f102014c          ADD      r1,r2,#0x4c           ;3982
00013e  463a              MOV      r2,r7                 ;3982
000140  6ba0              LDR      r0,[r4,#0x38]         ;3982
000142  f7fffffe          BL       HAL_DMA_Start_IT
000146  e000              B        |L15.330|
                  |L15.328|
000148  bf00              NOP                            ;3986
                  |L15.330|
00014a  bf00              NOP                            ;3912
00014c  ea480005          ORR      r0,r8,r5              ;3990
000150  6821              LDR      r1,[r4,#0]            ;3990
000152  6488              STR      r0,[r1,#0x48]         ;3990
000154  6820              LDR      r0,[r4,#0]            ;3993
000156  68c0              LDR      r0,[r0,#0xc]          ;3993
000158  4330              ORRS     r0,r0,r6              ;3993
00015a  6821              LDR      r1,[r4,#0]            ;3993
00015c  60c8              STR      r0,[r1,#0xc]          ;3993
00015e  2001              MOVS     r0,#1                 ;3995
000160  6420              STR      r0,[r4,#0x40]         ;3995
000162  2000              MOVS     r0,#0                 ;3998
000164  e756              B        |L15.20|
;;;4000   
                          ENDP

000166  0000              DCW      0x0000
                  |L15.360|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L15.364|
                          DCD      TIM_DMAError
                  |L15.368|
                          DCD      TIM_DMACaptureCplt
                  |L15.372|
                          DCD      TIMEx_DMACommutationCplt
                  |L15.376|
                          DCD      TIM_DMATriggerCplt

                          AREA ||i.HAL_TIM_DMABurst_ReadStop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_DMABurst_ReadStop PROC
;;;4007     */
;;;4008   HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
000000  b570              PUSH     {r4-r6,lr}
;;;4009   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;4010     /* Check the parameters */
;;;4011     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;4012     
;;;4013     /* Abort the DMA transfer (at least disable the DMA channel) */
;;;4014     switch(BurstRequestSrc)
000006  f5b56f00          CMP      r5,#0x800
00000a  d020              BEQ      |L16.78|
00000c  dc09              BGT      |L16.34|
00000e  f5b57f80          CMP      r5,#0x100
000012  d010              BEQ      |L16.54|
000014  f5b57f00          CMP      r5,#0x200
000018  d011              BEQ      |L16.62|
00001a  f5b56f80          CMP      r5,#0x400
00001e  d126              BNE      |L16.110|
000020  e011              B        |L16.70|
                  |L16.34|
000022  f5b55f80          CMP      r5,#0x1000
000026  d016              BEQ      |L16.86|
000028  f5b55f00          CMP      r5,#0x2000
00002c  d017              BEQ      |L16.94|
00002e  f5b54f80          CMP      r5,#0x4000
000032  d11c              BNE      |L16.110|
000034  e017              B        |L16.102|
                  |L16.54|
;;;4015     {
;;;4016       case TIM_DMA_UPDATE:
;;;4017       {  
;;;4018         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
000036  6a20              LDR      r0,[r4,#0x20]
000038  f7fffffe          BL       HAL_DMA_Abort
;;;4019       }
;;;4020       break;
00003c  e018              B        |L16.112|
                  |L16.62|
;;;4021       case TIM_DMA_CC1:
;;;4022       {  
;;;4023         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
00003e  6a60              LDR      r0,[r4,#0x24]
000040  f7fffffe          BL       HAL_DMA_Abort
;;;4024       }
;;;4025       break;
000044  e014              B        |L16.112|
                  |L16.70|
;;;4026       case TIM_DMA_CC2:
;;;4027       {  
;;;4028         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
000046  6aa0              LDR      r0,[r4,#0x28]
000048  f7fffffe          BL       HAL_DMA_Abort
;;;4029       }
;;;4030       break;
00004c  e010              B        |L16.112|
                  |L16.78|
;;;4031       case TIM_DMA_CC3:
;;;4032       {  
;;;4033         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
00004e  6ae0              LDR      r0,[r4,#0x2c]
000050  f7fffffe          BL       HAL_DMA_Abort
;;;4034       }
;;;4035       break;
000054  e00c              B        |L16.112|
                  |L16.86|
;;;4036       case TIM_DMA_CC4:
;;;4037       {  
;;;4038         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
000056  6b20              LDR      r0,[r4,#0x30]
000058  f7fffffe          BL       HAL_DMA_Abort
;;;4039       }
;;;4040       break;
00005c  e008              B        |L16.112|
                  |L16.94|
;;;4041       case TIM_DMA_COM:
;;;4042       {  
;;;4043         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
00005e  6b60              LDR      r0,[r4,#0x34]
000060  f7fffffe          BL       HAL_DMA_Abort
;;;4044       }
;;;4045       break;
000064  e004              B        |L16.112|
                  |L16.102|
;;;4046       case TIM_DMA_TRIGGER:
;;;4047       {  
;;;4048         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
000066  6ba0              LDR      r0,[r4,#0x38]
000068  f7fffffe          BL       HAL_DMA_Abort
;;;4049       }
;;;4050       break;
00006c  e000              B        |L16.112|
                  |L16.110|
;;;4051       default:
;;;4052       break;  
00006e  bf00              NOP      
                  |L16.112|
000070  bf00              NOP                            ;4020
;;;4053     }
;;;4054     
;;;4055     /* Disable the TIM Update DMA request */
;;;4056     __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
000072  6820              LDR      r0,[r4,#0]
000074  68c0              LDR      r0,[r0,#0xc]
000076  43a8              BICS     r0,r0,r5
000078  6821              LDR      r1,[r4,#0]
00007a  60c8              STR      r0,[r1,#0xc]
;;;4057         
;;;4058     /* Return function status */
;;;4059     return HAL_OK;  
00007c  2000              MOVS     r0,#0
;;;4060   }
00007e  bd70              POP      {r4-r6,pc}
;;;4061   
                          ENDP


                          AREA ||i.HAL_TIM_DMABurst_WriteStart||, CODE, READONLY, ALIGN=2

                  HAL_TIM_DMABurst_WriteStart PROC
;;;3649     */
;;;3650   HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3651                                                 uint32_t* BurstBuffer, uint32_t  BurstLength)
;;;3652   {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  9d06              LDR      r5,[sp,#0x18]
;;;3653     /* Check the parameters */
;;;3654     assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
;;;3655     assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
;;;3656     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3657     assert_param(IS_TIM_DMA_LENGTH(BurstLength));
;;;3658     
;;;3659     if((htim->State == HAL_TIM_STATE_BUSY))
00000e  6c20              LDR      r0,[r4,#0x40]
000010  2802              CMP      r0,#2
000012  d101              BNE      |L17.24|
                  |L17.20|
;;;3660     {
;;;3661        return HAL_BUSY;
;;;3662     }
;;;3663     else if((htim->State == HAL_TIM_STATE_READY))
;;;3664     {
;;;3665       if((BurstBuffer == 0 ) && (BurstLength > 0)) 
;;;3666       {
;;;3667         return HAL_ERROR;                                    
;;;3668       }
;;;3669       else
;;;3670       {
;;;3671         htim->State = HAL_TIM_STATE_BUSY;
;;;3672       }
;;;3673     }
;;;3674     switch(BurstRequestSrc)
;;;3675     {
;;;3676       case TIM_DMA_UPDATE:
;;;3677       {  
;;;3678         /* Set the DMA Period elapsed callback */
;;;3679         htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;3680        
;;;3681         /* Set the DMA error callback */
;;;3682         htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3683     
;;;3684         /* Enable the DMA Stream */
;;;3685         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1); 
;;;3686       }
;;;3687       break;
;;;3688       case TIM_DMA_CC1:
;;;3689       {  
;;;3690         /* Set the DMA Period elapsed callback */
;;;3691         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;3692        
;;;3693         /* Set the DMA error callback */
;;;3694         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3695     
;;;3696         /* Enable the DMA Stream */
;;;3697         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
;;;3698       }
;;;3699       break;
;;;3700       case TIM_DMA_CC2:
;;;3701       {  
;;;3702         /* Set the DMA Period elapsed callback */
;;;3703         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;3704        
;;;3705         /* Set the DMA error callback */
;;;3706         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3707     
;;;3708         /* Enable the DMA Stream */
;;;3709         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
;;;3710       }
;;;3711       break;
;;;3712       case TIM_DMA_CC3:
;;;3713       {  
;;;3714         /* Set the DMA Period elapsed callback */
;;;3715         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;3716        
;;;3717         /* Set the DMA error callback */
;;;3718         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3719     
;;;3720         /* Enable the DMA Stream */
;;;3721         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
;;;3722       }
;;;3723       break;
;;;3724       case TIM_DMA_CC4:
;;;3725       {  
;;;3726         /* Set the DMA Period elapsed callback */
;;;3727         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;3728        
;;;3729         /* Set the DMA error callback */
;;;3730         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3731     
;;;3732         /* Enable the DMA Stream */
;;;3733         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
;;;3734       }
;;;3735       break;
;;;3736       case TIM_DMA_COM:
;;;3737       {  
;;;3738         /* Set the DMA Period elapsed callback */
;;;3739         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = HAL_TIMEx_DMACommutationCplt;
;;;3740        
;;;3741         /* Set the DMA error callback */
;;;3742         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3743     
;;;3744         /* Enable the DMA Stream */
;;;3745         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
;;;3746       }
;;;3747       break;
;;;3748       case TIM_DMA_TRIGGER:
;;;3749       {  
;;;3750         /* Set the DMA Period elapsed callback */
;;;3751         htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
;;;3752        
;;;3753         /* Set the DMA error callback */
;;;3754         htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = HAL_TIM_DMAError ;
;;;3755     
;;;3756         /* Enable the DMA Stream */
;;;3757         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);     
;;;3758       }
;;;3759       break;
;;;3760       default:
;;;3761       break;  
;;;3762     }
;;;3763      /* configure the DMA Burst Mode */
;;;3764      htim->Instance->DCR = BurstBaseAddress | BurstLength;  
;;;3765      
;;;3766      /* Enable the TIM DMA Request */
;;;3767      __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);  
;;;3768      
;;;3769      htim->State = HAL_TIM_STATE_READY;
;;;3770     
;;;3771     /* Return function status */
;;;3772     return HAL_OK;
;;;3773   }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L17.24|
000018  6c20              LDR      r0,[r4,#0x40]         ;3663
00001a  2801              CMP      r0,#1                 ;3663
00001c  d104              BNE      |L17.40|
00001e  b90f              CBNZ     r7,|L17.36|
000020  b105              CBZ      r5,|L17.36|
000022  e7f7              B        |L17.20|
                  |L17.36|
000024  2002              MOVS     r0,#2                 ;3671
000026  6420              STR      r0,[r4,#0x40]         ;3671
                  |L17.40|
000028  f5b66f00          CMP      r6,#0x800             ;3674
00002c  d047              BEQ      |L17.190|
00002e  dc09              BGT      |L17.68|
000030  f5b67f80          CMP      r6,#0x100             ;3674
000034  d010              BEQ      |L17.88|
000036  f5b67f00          CMP      r6,#0x200             ;3674
00003a  d01e              BEQ      |L17.122|
00003c  f5b66f80          CMP      r6,#0x400             ;3674
000040  d170              BNE      |L17.292|
000042  e02b              B        |L17.156|
                  |L17.68|
000044  f5b65f80          CMP      r6,#0x1000            ;3674
000048  d04a              BEQ      |L17.224|
00004a  f5b65f00          CMP      r6,#0x2000            ;3674
00004e  d058              BEQ      |L17.258|
000050  f5b64f80          CMP      r6,#0x4000            ;3674
000054  d178              BNE      |L17.328|
000056  e066              B        |L17.294|
                  |L17.88|
000058  4843              LDR      r0,|L17.360|
00005a  6a21              LDR      r1,[r4,#0x20]         ;3679
00005c  6408              STR      r0,[r1,#0x40]         ;3679
00005e  4843              LDR      r0,|L17.364|
000060  6a21              LDR      r1,[r4,#0x20]         ;3682
000062  6508              STR      r0,[r1,#0x50]         ;3682
000064  2101              MOVS     r1,#1                 ;3685
000066  eb012315          ADD      r3,r1,r5,LSR #8       ;3685
00006a  6821              LDR      r1,[r4,#0]            ;3685
00006c  f101024c          ADD      r2,r1,#0x4c           ;3685
000070  4639              MOV      r1,r7                 ;3685
000072  6a20              LDR      r0,[r4,#0x20]         ;3685
000074  f7fffffe          BL       HAL_DMA_Start_IT
000078  e067              B        |L17.330|
                  |L17.122|
00007a  493d              LDR      r1,|L17.368|
00007c  6a60              LDR      r0,[r4,#0x24]         ;3691
00007e  6401              STR      r1,[r0,#0x40]         ;3691
000080  493a              LDR      r1,|L17.364|
000082  6a60              LDR      r0,[r4,#0x24]         ;3694
000084  6501              STR      r1,[r0,#0x50]         ;3694
000086  2101              MOVS     r1,#1                 ;3697
000088  eb012315          ADD      r3,r1,r5,LSR #8       ;3697
00008c  6821              LDR      r1,[r4,#0]            ;3697
00008e  f101024c          ADD      r2,r1,#0x4c           ;3697
000092  4639              MOV      r1,r7                 ;3697
000094  6a60              LDR      r0,[r4,#0x24]         ;3697
000096  f7fffffe          BL       HAL_DMA_Start_IT
00009a  e056              B        |L17.330|
                  |L17.156|
00009c  4934              LDR      r1,|L17.368|
00009e  6aa0              LDR      r0,[r4,#0x28]         ;3703
0000a0  6401              STR      r1,[r0,#0x40]         ;3703
0000a2  4932              LDR      r1,|L17.364|
0000a4  6aa0              LDR      r0,[r4,#0x28]         ;3706
0000a6  6501              STR      r1,[r0,#0x50]         ;3706
0000a8  2101              MOVS     r1,#1                 ;3709
0000aa  eb012315          ADD      r3,r1,r5,LSR #8       ;3709
0000ae  6821              LDR      r1,[r4,#0]            ;3709
0000b0  f101024c          ADD      r2,r1,#0x4c           ;3709
0000b4  4639              MOV      r1,r7                 ;3709
0000b6  6aa0              LDR      r0,[r4,#0x28]         ;3709
0000b8  f7fffffe          BL       HAL_DMA_Start_IT
0000bc  e045              B        |L17.330|
                  |L17.190|
0000be  492c              LDR      r1,|L17.368|
0000c0  6ae0              LDR      r0,[r4,#0x2c]         ;3715
0000c2  6401              STR      r1,[r0,#0x40]         ;3715
0000c4  4929              LDR      r1,|L17.364|
0000c6  6ae0              LDR      r0,[r4,#0x2c]         ;3718
0000c8  6501              STR      r1,[r0,#0x50]         ;3718
0000ca  2101              MOVS     r1,#1                 ;3721
0000cc  eb012315          ADD      r3,r1,r5,LSR #8       ;3721
0000d0  6821              LDR      r1,[r4,#0]            ;3721
0000d2  f101024c          ADD      r2,r1,#0x4c           ;3721
0000d6  4639              MOV      r1,r7                 ;3721
0000d8  6ae0              LDR      r0,[r4,#0x2c]         ;3721
0000da  f7fffffe          BL       HAL_DMA_Start_IT
0000de  e034              B        |L17.330|
                  |L17.224|
0000e0  4923              LDR      r1,|L17.368|
0000e2  6b20              LDR      r0,[r4,#0x30]         ;3727
0000e4  6401              STR      r1,[r0,#0x40]         ;3727
0000e6  4921              LDR      r1,|L17.364|
0000e8  6b20              LDR      r0,[r4,#0x30]         ;3730
0000ea  6501              STR      r1,[r0,#0x50]         ;3730
0000ec  2101              MOVS     r1,#1                 ;3733
0000ee  eb012315          ADD      r3,r1,r5,LSR #8       ;3733
0000f2  6821              LDR      r1,[r4,#0]            ;3733
0000f4  f101024c          ADD      r2,r1,#0x4c           ;3733
0000f8  4639              MOV      r1,r7                 ;3733
0000fa  6b20              LDR      r0,[r4,#0x30]         ;3733
0000fc  f7fffffe          BL       HAL_DMA_Start_IT
000100  e023              B        |L17.330|
                  |L17.258|
000102  491c              LDR      r1,|L17.372|
000104  6b60              LDR      r0,[r4,#0x34]         ;3739
000106  6401              STR      r1,[r0,#0x40]         ;3739
000108  4918              LDR      r1,|L17.364|
00010a  6b60              LDR      r0,[r4,#0x34]         ;3742
00010c  6501              STR      r1,[r0,#0x50]         ;3742
00010e  2101              MOVS     r1,#1                 ;3745
000110  eb012315          ADD      r3,r1,r5,LSR #8       ;3745
000114  6821              LDR      r1,[r4,#0]            ;3745
000116  f101024c          ADD      r2,r1,#0x4c           ;3745
00011a  4639              MOV      r1,r7                 ;3745
00011c  6b60              LDR      r0,[r4,#0x34]         ;3745
00011e  f7fffffe          BL       HAL_DMA_Start_IT
000122  e012              B        |L17.330|
                  |L17.292|
000124  e010              B        |L17.328|
                  |L17.294|
000126  4914              LDR      r1,|L17.376|
000128  6ba0              LDR      r0,[r4,#0x38]         ;3751
00012a  6401              STR      r1,[r0,#0x40]         ;3751
00012c  490f              LDR      r1,|L17.364|
00012e  6ba0              LDR      r0,[r4,#0x38]         ;3754
000130  6501              STR      r1,[r0,#0x50]         ;3754
000132  2101              MOVS     r1,#1                 ;3757
000134  eb012315          ADD      r3,r1,r5,LSR #8       ;3757
000138  6821              LDR      r1,[r4,#0]            ;3757
00013a  f101024c          ADD      r2,r1,#0x4c           ;3757
00013e  4639              MOV      r1,r7                 ;3757
000140  6ba0              LDR      r0,[r4,#0x38]         ;3757
000142  f7fffffe          BL       HAL_DMA_Start_IT
000146  e000              B        |L17.330|
                  |L17.328|
000148  bf00              NOP                            ;3761
                  |L17.330|
00014a  bf00              NOP                            ;3687
00014c  ea480005          ORR      r0,r8,r5              ;3764
000150  6821              LDR      r1,[r4,#0]            ;3764
000152  6488              STR      r0,[r1,#0x48]         ;3764
000154  6820              LDR      r0,[r4,#0]            ;3767
000156  68c0              LDR      r0,[r0,#0xc]          ;3767
000158  4330              ORRS     r0,r0,r6              ;3767
00015a  6821              LDR      r1,[r4,#0]            ;3767
00015c  60c8              STR      r0,[r1,#0xc]          ;3767
00015e  2001              MOVS     r0,#1                 ;3769
000160  6420              STR      r0,[r4,#0x40]         ;3769
000162  2000              MOVS     r0,#0                 ;3772
000164  e756              B        |L17.20|
;;;3774   
                          ENDP

000166  0000              DCW      0x0000
                  |L17.360|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L17.364|
                          DCD      TIM_DMAError
                  |L17.368|
                          DCD      TIM_DMADelayPulseCplt
                  |L17.372|
                          DCD      TIMEx_DMACommutationCplt
                  |L17.376|
                          DCD      TIM_DMATriggerCplt

                          AREA ||i.HAL_TIM_DMABurst_WriteStop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_DMABurst_WriteStop PROC
;;;3781     */
;;;3782   HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
000000  b570              PUSH     {r4-r6,lr}
;;;3783   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;3784     /* Check the parameters */
;;;3785     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3786     
;;;3787     /* Abort the DMA transfer (at least disable the DMA channel) */
;;;3788     switch(BurstRequestSrc)
000006  f5b56f00          CMP      r5,#0x800
00000a  d020              BEQ      |L18.78|
00000c  dc09              BGT      |L18.34|
00000e  f5b57f80          CMP      r5,#0x100
000012  d010              BEQ      |L18.54|
000014  f5b57f00          CMP      r5,#0x200
000018  d011              BEQ      |L18.62|
00001a  f5b56f80          CMP      r5,#0x400
00001e  d126              BNE      |L18.110|
000020  e011              B        |L18.70|
                  |L18.34|
000022  f5b55f80          CMP      r5,#0x1000
000026  d016              BEQ      |L18.86|
000028  f5b55f00          CMP      r5,#0x2000
00002c  d017              BEQ      |L18.94|
00002e  f5b54f80          CMP      r5,#0x4000
000032  d11c              BNE      |L18.110|
000034  e017              B        |L18.102|
                  |L18.54|
;;;3789     {
;;;3790       case TIM_DMA_UPDATE:
;;;3791       {  
;;;3792         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
000036  6a20              LDR      r0,[r4,#0x20]
000038  f7fffffe          BL       HAL_DMA_Abort
;;;3793       }
;;;3794       break;
00003c  e018              B        |L18.112|
                  |L18.62|
;;;3795       case TIM_DMA_CC1:
;;;3796       {  
;;;3797         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
00003e  6a60              LDR      r0,[r4,#0x24]
000040  f7fffffe          BL       HAL_DMA_Abort
;;;3798       }
;;;3799       break;
000044  e014              B        |L18.112|
                  |L18.70|
;;;3800       case TIM_DMA_CC2:
;;;3801       {  
;;;3802         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
000046  6aa0              LDR      r0,[r4,#0x28]
000048  f7fffffe          BL       HAL_DMA_Abort
;;;3803       }
;;;3804       break;
00004c  e010              B        |L18.112|
                  |L18.78|
;;;3805       case TIM_DMA_CC3:
;;;3806       {  
;;;3807         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
00004e  6ae0              LDR      r0,[r4,#0x2c]
000050  f7fffffe          BL       HAL_DMA_Abort
;;;3808       }
;;;3809       break;
000054  e00c              B        |L18.112|
                  |L18.86|
;;;3810       case TIM_DMA_CC4:
;;;3811       {  
;;;3812         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
000056  6b20              LDR      r0,[r4,#0x30]
000058  f7fffffe          BL       HAL_DMA_Abort
;;;3813       }
;;;3814       break;
00005c  e008              B        |L18.112|
                  |L18.94|
;;;3815       case TIM_DMA_COM:
;;;3816       {  
;;;3817         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
00005e  6b60              LDR      r0,[r4,#0x34]
000060  f7fffffe          BL       HAL_DMA_Abort
;;;3818       }
;;;3819       break;
000064  e004              B        |L18.112|
                  |L18.102|
;;;3820       case TIM_DMA_TRIGGER:
;;;3821       {  
;;;3822         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
000066  6ba0              LDR      r0,[r4,#0x38]
000068  f7fffffe          BL       HAL_DMA_Abort
;;;3823       }
;;;3824       break;
00006c  e000              B        |L18.112|
                  |L18.110|
;;;3825       default:
;;;3826       break;
00006e  bf00              NOP      
                  |L18.112|
000070  bf00              NOP                            ;3794
;;;3827     }
;;;3828   
;;;3829     /* Disable the TIM Update DMA request */
;;;3830     __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
000072  6820              LDR      r0,[r4,#0]
000074  68c0              LDR      r0,[r0,#0xc]
000076  43a8              BICS     r0,r0,r5
000078  6821              LDR      r1,[r4,#0]
00007a  60c8              STR      r0,[r1,#0xc]
;;;3831         
;;;3832     /* Return function status */
;;;3833     return HAL_OK;  
00007c  2000              MOVS     r0,#0
;;;3834   }
00007e  bd70              POP      {r4-r6,pc}
;;;3835   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_DeInit PROC
;;;2566     */
;;;2567   HAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;2568   {
000002  4604              MOV      r4,r0
;;;2569     /* Check the parameters */
;;;2570     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;2571     
;;;2572     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  6420              STR      r0,[r4,#0x40]
;;;2573     
;;;2574     /* Disable the TIM Peripheral Clock */
;;;2575     __HAL_TIM_DISABLE(htim);
000008  bf00              NOP      
00000a  6820              LDR      r0,[r4,#0]
00000c  6a00              LDR      r0,[r0,#0x20]
00000e  f2411111          MOV      r1,#0x1111
000012  4008              ANDS     r0,r0,r1
000014  b950              CBNZ     r0,|L19.44|
000016  6820              LDR      r0,[r4,#0]
000018  6a00              LDR      r0,[r0,#0x20]
00001a  1089              ASRS     r1,r1,#2
00001c  4008              ANDS     r0,r0,r1
00001e  b928              CBNZ     r0,|L19.44|
000020  6820              LDR      r0,[r4,#0]
000022  6800              LDR      r0,[r0,#0]
000024  f0200001          BIC      r0,r0,#1
000028  6821              LDR      r1,[r4,#0]
00002a  6008              STR      r0,[r1,#0]
                  |L19.44|
00002c  bf00              NOP      
;;;2576   
;;;2577   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;2578     if(htim->Encoder_MspDeInitCallback == NULL)
;;;2579     {
;;;2580       htim->Encoder_MspDeInitCallback = HAL_TIM_Encoder_MspDeInit;
;;;2581     }
;;;2582     /* DeInit the low level hardware */
;;;2583     htim->Encoder_MspDeInitCallback(htim);
;;;2584   #else
;;;2585     /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;2586     HAL_TIM_Encoder_MspDeInit(htim);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       HAL_TIM_Encoder_MspDeInit
;;;2587   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;2588   
;;;2589     /* Change TIM state */  
;;;2590     htim->State = HAL_TIM_STATE_RESET;
000034  2000              MOVS     r0,#0
000036  6420              STR      r0,[r4,#0x40]
;;;2591    
;;;2592     /* Release Lock */
;;;2593     __HAL_UNLOCK(htim);
000038  bf00              NOP      
00003a  63e0              STR      r0,[r4,#0x3c]
00003c  bf00              NOP      
;;;2594   
;;;2595     return HAL_OK;
;;;2596   }
00003e  bd10              POP      {r4,pc}
;;;2597   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_GetState PROC
;;;5289     */
;;;5290   HAL_TIM_StateTypeDef HAL_TIM_Encoder_GetState(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;5291   {
;;;5292     return htim->State;
000002  6c08              LDR      r0,[r1,#0x40]
;;;5293   }
000004  4770              BX       lr
;;;5294   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Init||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Encoder_Init PROC
;;;2461     */
;;;2462   HAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim,  TIM_Encoder_InitTypeDef* sConfig)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2463   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;2464     uint32_t tmpsmcr = 0;
000008  f04f0800          MOV      r8,#0
;;;2465     uint32_t tmpccmr1 = 0;
00000c  2600              MOVS     r6,#0
;;;2466     uint32_t tmpccer = 0;
00000e  2700              MOVS     r7,#0
;;;2467     
;;;2468     /* Check the TIM handle allocation */
;;;2469     if(htim == NULL)
000010  b914              CBNZ     r4,|L21.24|
;;;2470     {
;;;2471       return HAL_ERROR;
000012  2001              MOVS     r0,#1
                  |L21.20|
;;;2472     }
;;;2473      
;;;2474     /* Check the parameters */
;;;2475     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2476     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;2477     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;2478     assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;2479     assert_param(IS_TIM_ENCODER_MODE(sConfig->EncoderMode));
;;;2480     assert_param(IS_TIM_IC_SELECTION(sConfig->IC1Selection));
;;;2481     assert_param(IS_TIM_IC_SELECTION(sConfig->IC2Selection));
;;;2482     assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
;;;2483     assert_param(IS_TIM_IC_POLARITY(sConfig->IC2Polarity));
;;;2484     assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
;;;2485     assert_param(IS_TIM_IC_PRESCALER(sConfig->IC2Prescaler));
;;;2486     assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
;;;2487     assert_param(IS_TIM_IC_FILTER(sConfig->IC2Filter));
;;;2488   
;;;2489     if(htim->State == HAL_TIM_STATE_RESET)
;;;2490     {
;;;2491       /* Allocate lock resource and initialize it */
;;;2492       htim->Lock = HAL_UNLOCKED;
;;;2493   
;;;2494   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;2495       /* Reset interrupt callbacks to legacy week callbacks */
;;;2496       TIM_ResetCallback(htim);
;;;2497   
;;;2498       if(htim->Encoder_MspInitCallback == NULL)
;;;2499       {
;;;2500         htim->Encoder_MspInitCallback = HAL_TIM_Encoder_MspInit;
;;;2501       }
;;;2502       /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;2503       htim->Encoder_MspInitCallback(htim);
;;;2504   #else
;;;2505       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;2506       HAL_TIM_Encoder_MspInit(htim);
;;;2507   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;2508     }
;;;2509   
;;;2510     /* Set the TIM state */
;;;2511     htim->State= HAL_TIM_STATE_BUSY;   
;;;2512       
;;;2513     /* Reset the SMS bits */
;;;2514     htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;2515     
;;;2516     /* Configure the Time base in the Encoder Mode */
;;;2517     TIM_Base_SetConfig(htim->Instance, &htim->Init);  
;;;2518     
;;;2519     /* Get the TIMx SMCR register value */
;;;2520     tmpsmcr = htim->Instance->SMCR;
;;;2521   
;;;2522     /* Get the TIMx CCMR1 register value */
;;;2523     tmpccmr1 = htim->Instance->CCMR1;
;;;2524   
;;;2525     /* Get the TIMx CCER register value */
;;;2526     tmpccer = htim->Instance->CCER;
;;;2527   
;;;2528     /* Set the encoder Mode */
;;;2529     tmpsmcr |= sConfig->EncoderMode;
;;;2530   
;;;2531     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;2532     tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
;;;2533     tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8));
;;;2534     
;;;2535     /* Set the Capture Compare 1 and the Capture Compare 2 prescalers and filters */
;;;2536     tmpccmr1 &= ~(TIM_CCMR1_IC1PSC | TIM_CCMR1_IC2PSC);
;;;2537     tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
;;;2538     tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8);
;;;2539     tmpccmr1 |= (sConfig->IC1Filter << 4) | (sConfig->IC2Filter << 12);
;;;2540   
;;;2541     /* Set the TI1 and the TI2 Polarities */
;;;2542     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);
;;;2543     tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
;;;2544     tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4);
;;;2545     
;;;2546     /* Write to TIMx SMCR */
;;;2547     htim->Instance->SMCR = tmpsmcr;
;;;2548   
;;;2549     /* Write to TIMx CCMR1 */
;;;2550     htim->Instance->CCMR1 = tmpccmr1;
;;;2551   
;;;2552     /* Write to TIMx CCER */
;;;2553     htim->Instance->CCER = tmpccer;
;;;2554     
;;;2555     /* Initialize the TIM state*/
;;;2556     htim->State= HAL_TIM_STATE_READY;
;;;2557     
;;;2558     return HAL_OK;
;;;2559   }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L21.24|
000018  6c20              LDR      r0,[r4,#0x40]         ;2489
00001a  b920              CBNZ     r0,|L21.38|
00001c  2000              MOVS     r0,#0                 ;2492
00001e  63e0              STR      r0,[r4,#0x3c]         ;2492
000020  4620              MOV      r0,r4                 ;2506
000022  f7fffffe          BL       HAL_TIM_Encoder_MspInit
                  |L21.38|
000026  2002              MOVS     r0,#2                 ;2511
000028  6420              STR      r0,[r4,#0x40]         ;2511
00002a  6820              LDR      r0,[r4,#0]            ;2514
00002c  6880              LDR      r0,[r0,#8]            ;2514
00002e  491f              LDR      r1,|L21.172|
000030  4008              ANDS     r0,r0,r1              ;2514
000032  6821              LDR      r1,[r4,#0]            ;2514
000034  6088              STR      r0,[r1,#8]            ;2514
000036  1d21              ADDS     r1,r4,#4              ;2517
000038  6820              LDR      r0,[r4,#0]            ;2517
00003a  f7fffffe          BL       TIM_Base_SetConfig
00003e  6820              LDR      r0,[r4,#0]            ;2520
000040  f8d08008          LDR      r8,[r0,#8]            ;2520
000044  6820              LDR      r0,[r4,#0]            ;2523
000046  6986              LDR      r6,[r0,#0x18]         ;2523
000048  6820              LDR      r0,[r4,#0]            ;2526
00004a  6a07              LDR      r7,[r0,#0x20]         ;2526
00004c  6828              LDR      r0,[r5,#0]            ;2529
00004e  ea400808          ORR      r8,r0,r8              ;2529
000052  f2403003          MOV      r0,#0x303             ;2532
000056  4386              BICS     r6,r6,r0              ;2532
000058  69a9              LDR      r1,[r5,#0x18]         ;2533
00005a  68a8              LDR      r0,[r5,#8]            ;2533
00005c  ea402001          ORR      r0,r0,r1,LSL #8       ;2533
000060  4306              ORRS     r6,r6,r0              ;2533
000062  f640400c          MOV      r0,#0xc0c             ;2536
000066  4386              BICS     r6,r6,r0              ;2536
000068  f24f00f0          MOV      r0,#0xf0f0            ;2537
00006c  4386              BICS     r6,r6,r0              ;2537
00006e  69e9              LDR      r1,[r5,#0x1c]         ;2538
000070  68e8              LDR      r0,[r5,#0xc]          ;2538
000072  ea402001          ORR      r0,r0,r1,LSL #8       ;2538
000076  4306              ORRS     r6,r6,r0              ;2538
000078  6928              LDR      r0,[r5,#0x10]         ;2539
00007a  0100              LSLS     r0,r0,#4              ;2539
00007c  6a29              LDR      r1,[r5,#0x20]         ;2539
00007e  ea403001          ORR      r0,r0,r1,LSL #12      ;2539
000082  4306              ORRS     r6,r6,r0              ;2539
000084  f0270722          BIC      r7,r7,#0x22           ;2542
000088  f0270788          BIC      r7,r7,#0x88           ;2543
00008c  6969              LDR      r1,[r5,#0x14]         ;2544
00008e  6868              LDR      r0,[r5,#4]            ;2544
000090  ea401001          ORR      r0,r0,r1,LSL #4       ;2544
000094  4307              ORRS     r7,r7,r0              ;2544
000096  6820              LDR      r0,[r4,#0]            ;2547
000098  f8c08008          STR      r8,[r0,#8]            ;2547
00009c  6820              LDR      r0,[r4,#0]            ;2550
00009e  6186              STR      r6,[r0,#0x18]         ;2550
0000a0  6820              LDR      r0,[r4,#0]            ;2553
0000a2  6207              STR      r7,[r0,#0x20]         ;2553
0000a4  2001              MOVS     r0,#1                 ;2556
0000a6  6420              STR      r0,[r4,#0x40]         ;2556
0000a8  2000              MOVS     r0,#0                 ;2558
0000aa  e7b3              B        |L21.20|
;;;2560   
                          ENDP

                  |L21.172|
                          DCD      0xfffefff8

                          AREA ||i.HAL_TIM_Encoder_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_MspDeInit PROC
;;;2619     */
;;;2620   __weak void HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2621   {
;;;2622     /* Prevent unused argument(s) compilation warning */
;;;2623     UNUSED(htim);
;;;2624    
;;;2625     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2626               the HAL_TIM_Encoder_MspDeInit could be implemented in the user file
;;;2627      */
;;;2628   }
;;;2629   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_MspInit PROC
;;;2603     */
;;;2604   __weak void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2605   {
;;;2606     /* Prevent unused argument(s) compilation warning */
;;;2607     UNUSED(htim);
;;;2608    
;;;2609     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2610               the HAL_TIM_Encoder_MspInit could be implemented in the user file
;;;2611      */
;;;2612   }
;;;2613   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Start PROC
;;;2640     */
;;;2641   HAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;2642   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2643     /* Check the parameters */
;;;2644     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2645     
;;;2646     /* Enable the encoder interface channels */
;;;2647     switch (Channel)
000006  b115              CBZ      r5,|L24.14|
000008  2d04              CMP      r5,#4
00000a  d10c              BNE      |L24.38|
00000c  e005              B        |L24.26|
                  |L24.14|
;;;2648     {
;;;2649       case TIM_CHANNEL_1:
;;;2650       {
;;;2651         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
00000e  2201              MOVS     r2,#1
000010  2100              MOVS     r1,#0
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       TIM_CCxChannelCmd
;;;2652         break; 
000018  e010              B        |L24.60|
                  |L24.26|
;;;2653       }
;;;2654       case TIM_CHANNEL_2:
;;;2655       { 
;;;2656         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
00001a  2201              MOVS     r2,#1
00001c  2104              MOVS     r1,#4
00001e  6820              LDR      r0,[r4,#0]
000020  f7fffffe          BL       TIM_CCxChannelCmd
;;;2657         break;
000024  e00a              B        |L24.60|
                  |L24.38|
;;;2658       }  
;;;2659       default :
;;;2660       {
;;;2661        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
000026  2201              MOVS     r2,#1
000028  2100              MOVS     r1,#0
00002a  6820              LDR      r0,[r4,#0]
00002c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2662        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
000030  2201              MOVS     r2,#1
000032  2104              MOVS     r1,#4
000034  6820              LDR      r0,[r4,#0]
000036  f7fffffe          BL       TIM_CCxChannelCmd
;;;2663        break; 
00003a  bf00              NOP      
                  |L24.60|
00003c  bf00              NOP                            ;2652
;;;2664       }
;;;2665     }  
;;;2666     /* Enable the Peripheral */
;;;2667     __HAL_TIM_ENABLE(htim);
00003e  6820              LDR      r0,[r4,#0]
000040  6800              LDR      r0,[r0,#0]
000042  f0400001          ORR      r0,r0,#1
000046  6821              LDR      r1,[r4,#0]
000048  6008              STR      r0,[r1,#0]
;;;2668     
;;;2669     /* Return function status */
;;;2670     return HAL_OK;
00004a  2000              MOVS     r0,#0
;;;2671   }
00004c  bd30              POP      {r4,r5,pc}
;;;2672   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_Encoder_Start_DMA PROC
;;;2831     */
;;;2832   HAL_StatusTypeDef HAL_TIM_Encoder_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData1, uint32_t *pData2, uint16_t Length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2833   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
00000c  f8dd8018          LDR      r8,[sp,#0x18]
;;;2834     /* Check the parameters */
;;;2835     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;2836     
;;;2837     if((htim->State == HAL_TIM_STATE_BUSY))
000010  6c20              LDR      r0,[r4,#0x40]
000012  2802              CMP      r0,#2
000014  d101              BNE      |L25.26|
                  |L25.22|
;;;2838     {
;;;2839        return HAL_BUSY;
;;;2840     }
;;;2841     else if((htim->State == HAL_TIM_STATE_READY))
;;;2842     {
;;;2843       if((((pData1 == 0) || (pData2 == 0) )) && (Length > 0)) 
;;;2844       {
;;;2845         return HAL_ERROR;                                    
;;;2846       }
;;;2847       else
;;;2848       {
;;;2849         htim->State = HAL_TIM_STATE_BUSY;
;;;2850       }
;;;2851     }  
;;;2852      
;;;2853     switch (Channel)
;;;2854     {
;;;2855       case TIM_CHANNEL_1:
;;;2856       {
;;;2857         /* Set the DMA Period elapsed callback */
;;;2858         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;2859        
;;;2860         /* Set the DMA error callback */
;;;2861         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
;;;2862         
;;;2863         /* Enable the DMA Stream */
;;;2864         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t )pData1, Length); 
;;;2865         
;;;2866         /* Enable the TIM Input Capture DMA request */      
;;;2867         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;2868               
;;;2869         /* Enable the Peripheral */
;;;2870         __HAL_TIM_ENABLE(htim);
;;;2871         
;;;2872         /* Enable the Capture compare channel */
;;;2873         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2874       }
;;;2875       break;
;;;2876       
;;;2877       case TIM_CHANNEL_2:
;;;2878       {
;;;2879         /* Set the DMA Period elapsed callback */
;;;2880         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;2881        
;;;2882         /* Set the DMA error callback */
;;;2883         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError;
;;;2884         /* Enable the DMA Stream */
;;;2885         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
;;;2886         
;;;2887         /* Enable the TIM Input Capture  DMA request */
;;;2888         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;2889        
;;;2890         /* Enable the Peripheral */
;;;2891         __HAL_TIM_ENABLE(htim);
;;;2892         
;;;2893         /* Enable the Capture compare channel */
;;;2894         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2895       }
;;;2896       break;
;;;2897       
;;;2898       case TIM_CHANNEL_ALL:
;;;2899       {
;;;2900         /* Set the DMA Period elapsed callback */
;;;2901         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;2902        
;;;2903         /* Set the DMA error callback */
;;;2904         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
;;;2905         
;;;2906         /* Enable the DMA Stream */
;;;2907         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length);
;;;2908         
;;;2909         /* Set the DMA Period elapsed callback */
;;;2910         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;2911        
;;;2912         /* Set the DMA error callback */
;;;2913         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
;;;2914         
;;;2915         /* Enable the DMA Stream */
;;;2916         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
;;;2917             
;;;2918        /* Enable the Peripheral */
;;;2919         __HAL_TIM_ENABLE(htim);
;;;2920         
;;;2921         /* Enable the Capture compare channel */
;;;2922         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2923         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2924         
;;;2925         /* Enable the TIM Input Capture  DMA request */
;;;2926         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;2927         /* Enable the TIM Input Capture  DMA request */
;;;2928         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;2929       }
;;;2930       break;
;;;2931       
;;;2932       default:
;;;2933       break;
;;;2934     }  
;;;2935     /* Return function status */
;;;2936     return HAL_OK;
;;;2937   }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L25.26|
00001a  6c20              LDR      r0,[r4,#0x40]         ;2841
00001c  2801              CMP      r0,#1                 ;2841
00001e  d108              BNE      |L25.50|
000020  b107              CBZ      r7,|L25.36|
000022  b925              CBNZ     r5,|L25.46|
                  |L25.36|
000024  f1b80f00          CMP      r8,#0                 ;2843
000028  dd01              BLE      |L25.46|
00002a  2001              MOVS     r0,#1                 ;2845
00002c  e7f3              B        |L25.22|
                  |L25.46|
00002e  2002              MOVS     r0,#2                 ;2849
000030  6420              STR      r0,[r4,#0x40]         ;2849
                  |L25.50|
000032  b126              CBZ      r6,|L25.62|
000034  2e04              CMP      r6,#4                 ;2853
000036  d022              BEQ      |L25.126|
000038  2e3c              CMP      r6,#0x3c              ;2853
00003a  d17a              BNE      |L25.306|
00003c  e03f              B        |L25.190|
                  |L25.62|
00003e  493f              LDR      r1,|L25.316|
000040  6a60              LDR      r0,[r4,#0x24]         ;2858
000042  6401              STR      r1,[r0,#0x40]         ;2858
000044  493e              LDR      r1,|L25.320|
000046  6a60              LDR      r0,[r4,#0x24]         ;2861
000048  6501              STR      r1,[r0,#0x50]         ;2861
00004a  6822              LDR      r2,[r4,#0]            ;2864
00004c  f1020134          ADD      r1,r2,#0x34           ;2864
000050  4643              MOV      r3,r8                 ;2864
000052  463a              MOV      r2,r7                 ;2864
000054  6a60              LDR      r0,[r4,#0x24]         ;2864
000056  f7fffffe          BL       HAL_DMA_Start_IT
00005a  6820              LDR      r0,[r4,#0]            ;2867
00005c  68c0              LDR      r0,[r0,#0xc]          ;2867
00005e  f4407000          ORR      r0,r0,#0x200          ;2867
000062  6821              LDR      r1,[r4,#0]            ;2867
000064  60c8              STR      r0,[r1,#0xc]          ;2867
000066  6820              LDR      r0,[r4,#0]            ;2870
000068  6800              LDR      r0,[r0,#0]            ;2870
00006a  f0400001          ORR      r0,r0,#1              ;2870
00006e  6821              LDR      r1,[r4,#0]            ;2870
000070  6008              STR      r0,[r1,#0]            ;2870
000072  2201              MOVS     r2,#1                 ;2873
000074  2100              MOVS     r1,#0                 ;2873
000076  6820              LDR      r0,[r4,#0]            ;2873
000078  f7fffffe          BL       TIM_CCxChannelCmd
00007c  e05a              B        |L25.308|
                  |L25.126|
00007e  492f              LDR      r1,|L25.316|
000080  6aa0              LDR      r0,[r4,#0x28]         ;2880
000082  6401              STR      r1,[r0,#0x40]         ;2880
000084  492e              LDR      r1,|L25.320|
000086  6aa0              LDR      r0,[r4,#0x28]         ;2883
000088  6501              STR      r1,[r0,#0x50]         ;2883
00008a  6822              LDR      r2,[r4,#0]            ;2885
00008c  f1020138          ADD      r1,r2,#0x38           ;2885
000090  4643              MOV      r3,r8                 ;2885
000092  462a              MOV      r2,r5                 ;2885
000094  6aa0              LDR      r0,[r4,#0x28]         ;2885
000096  f7fffffe          BL       HAL_DMA_Start_IT
00009a  6820              LDR      r0,[r4,#0]            ;2888
00009c  68c0              LDR      r0,[r0,#0xc]          ;2888
00009e  f4406080          ORR      r0,r0,#0x400          ;2888
0000a2  6821              LDR      r1,[r4,#0]            ;2888
0000a4  60c8              STR      r0,[r1,#0xc]          ;2888
0000a6  6820              LDR      r0,[r4,#0]            ;2891
0000a8  6800              LDR      r0,[r0,#0]            ;2891
0000aa  f0400001          ORR      r0,r0,#1              ;2891
0000ae  6821              LDR      r1,[r4,#0]            ;2891
0000b0  6008              STR      r0,[r1,#0]            ;2891
0000b2  2201              MOVS     r2,#1                 ;2894
0000b4  2104              MOVS     r1,#4                 ;2894
0000b6  6820              LDR      r0,[r4,#0]            ;2894
0000b8  f7fffffe          BL       TIM_CCxChannelCmd
0000bc  e03a              B        |L25.308|
                  |L25.190|
0000be  491f              LDR      r1,|L25.316|
0000c0  6a60              LDR      r0,[r4,#0x24]         ;2901
0000c2  6401              STR      r1,[r0,#0x40]         ;2901
0000c4  491e              LDR      r1,|L25.320|
0000c6  6a60              LDR      r0,[r4,#0x24]         ;2904
0000c8  6501              STR      r1,[r0,#0x50]         ;2904
0000ca  6822              LDR      r2,[r4,#0]            ;2907
0000cc  f1020134          ADD      r1,r2,#0x34           ;2907
0000d0  4643              MOV      r3,r8                 ;2907
0000d2  463a              MOV      r2,r7                 ;2907
0000d4  6a60              LDR      r0,[r4,#0x24]         ;2907
0000d6  f7fffffe          BL       HAL_DMA_Start_IT
0000da  4918              LDR      r1,|L25.316|
0000dc  6aa0              LDR      r0,[r4,#0x28]         ;2910
0000de  6401              STR      r1,[r0,#0x40]         ;2910
0000e0  4917              LDR      r1,|L25.320|
0000e2  6aa0              LDR      r0,[r4,#0x28]         ;2913
0000e4  6501              STR      r1,[r0,#0x50]         ;2913
0000e6  6822              LDR      r2,[r4,#0]            ;2916
0000e8  f1020138          ADD      r1,r2,#0x38           ;2916
0000ec  4643              MOV      r3,r8                 ;2916
0000ee  462a              MOV      r2,r5                 ;2916
0000f0  6aa0              LDR      r0,[r4,#0x28]         ;2916
0000f2  f7fffffe          BL       HAL_DMA_Start_IT
0000f6  6820              LDR      r0,[r4,#0]            ;2919
0000f8  6800              LDR      r0,[r0,#0]            ;2919
0000fa  f0400001          ORR      r0,r0,#1              ;2919
0000fe  6821              LDR      r1,[r4,#0]            ;2919
000100  6008              STR      r0,[r1,#0]            ;2919
000102  2201              MOVS     r2,#1                 ;2922
000104  2100              MOVS     r1,#0                 ;2922
000106  6820              LDR      r0,[r4,#0]            ;2922
000108  f7fffffe          BL       TIM_CCxChannelCmd
00010c  2201              MOVS     r2,#1                 ;2923
00010e  2104              MOVS     r1,#4                 ;2923
000110  6820              LDR      r0,[r4,#0]            ;2923
000112  f7fffffe          BL       TIM_CCxChannelCmd
000116  6820              LDR      r0,[r4,#0]            ;2926
000118  68c0              LDR      r0,[r0,#0xc]          ;2926
00011a  f4407000          ORR      r0,r0,#0x200          ;2926
00011e  6821              LDR      r1,[r4,#0]            ;2926
000120  60c8              STR      r0,[r1,#0xc]          ;2926
000122  6820              LDR      r0,[r4,#0]            ;2928
000124  68c0              LDR      r0,[r0,#0xc]          ;2928
000126  f4406080          ORR      r0,r0,#0x400          ;2928
00012a  6821              LDR      r1,[r4,#0]            ;2928
00012c  60c8              STR      r0,[r1,#0xc]          ;2928
00012e  e001              B        |L25.308|
000130  e7ff              B        |L25.306|
                  |L25.306|
000132  bf00              NOP                            ;2933
                  |L25.308|
000134  bf00              NOP                            ;2875
000136  2000              MOVS     r0,#0                 ;2936
000138  e76d              B        |L25.22|
;;;2938   
                          ENDP

00013a  0000              DCW      0x0000
                  |L25.316|
                          DCD      TIM_DMACaptureCplt
                  |L25.320|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_Encoder_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Start_IT PROC
;;;2727     */
;;;2728   HAL_StatusTypeDef HAL_TIM_Encoder_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;2729   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2730     /* Check the parameters */
;;;2731     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2732     
;;;2733     /* Enable the encoder interface channels */
;;;2734     /* Enable the capture compare Interrupts 1 and/or 2 */
;;;2735     switch (Channel)
000006  b115              CBZ      r5,|L26.14|
000008  2d04              CMP      r5,#4
00000a  d118              BNE      |L26.62|
00000c  e00b              B        |L26.38|
                  |L26.14|
;;;2736     {
;;;2737       case TIM_CHANNEL_1:
;;;2738       {
;;;2739         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
00000e  2201              MOVS     r2,#1
000010  2100              MOVS     r1,#0
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       TIM_CCxChannelCmd
;;;2740         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000018  6820              LDR      r0,[r4,#0]
00001a  68c0              LDR      r0,[r0,#0xc]
00001c  f0400002          ORR      r0,r0,#2
000020  6821              LDR      r1,[r4,#0]
000022  60c8              STR      r0,[r1,#0xc]
;;;2741         break; 
000024  e022              B        |L26.108|
                  |L26.38|
;;;2742       }
;;;2743       case TIM_CHANNEL_2:
;;;2744       { 
;;;2745         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
000026  2201              MOVS     r2,#1
000028  2104              MOVS     r1,#4
00002a  6820              LDR      r0,[r4,#0]
00002c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2746         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2); 
000030  6820              LDR      r0,[r4,#0]
000032  68c0              LDR      r0,[r0,#0xc]
000034  f0400004          ORR      r0,r0,#4
000038  6821              LDR      r1,[r4,#0]
00003a  60c8              STR      r0,[r1,#0xc]
;;;2747         break;
00003c  e016              B        |L26.108|
                  |L26.62|
;;;2748       }  
;;;2749       default :
;;;2750       {
;;;2751        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
00003e  2201              MOVS     r2,#1
000040  2100              MOVS     r1,#0
000042  6820              LDR      r0,[r4,#0]
000044  f7fffffe          BL       TIM_CCxChannelCmd
;;;2752        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
000048  2201              MOVS     r2,#1
00004a  2104              MOVS     r1,#4
00004c  6820              LDR      r0,[r4,#0]
00004e  f7fffffe          BL       TIM_CCxChannelCmd
;;;2753        __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000052  6820              LDR      r0,[r4,#0]
000054  68c0              LDR      r0,[r0,#0xc]
000056  f0400002          ORR      r0,r0,#2
00005a  6821              LDR      r1,[r4,#0]
00005c  60c8              STR      r0,[r1,#0xc]
;;;2754        __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
00005e  6820              LDR      r0,[r4,#0]
000060  68c0              LDR      r0,[r0,#0xc]
000062  f0400004          ORR      r0,r0,#4
000066  6821              LDR      r1,[r4,#0]
000068  60c8              STR      r0,[r1,#0xc]
;;;2755        break; 
00006a  bf00              NOP      
                  |L26.108|
00006c  bf00              NOP                            ;2741
;;;2756       }
;;;2757     }
;;;2758     
;;;2759     /* Enable the Peripheral */
;;;2760     __HAL_TIM_ENABLE(htim);
00006e  6820              LDR      r0,[r4,#0]
000070  6800              LDR      r0,[r0,#0]
000072  f0400001          ORR      r0,r0,#1
000076  6821              LDR      r1,[r4,#0]
000078  6008              STR      r0,[r1,#0]
;;;2761     
;;;2762     /* Return function status */
;;;2763     return HAL_OK;
00007a  2000              MOVS     r0,#0
;;;2764   }
00007c  bd30              POP      {r4,r5,pc}
;;;2765   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Stop PROC
;;;2683     */
;;;2684   HAL_StatusTypeDef HAL_TIM_Encoder_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;2685   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2686     /* Check the parameters */
;;;2687       assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2688       
;;;2689      /* Disable the Input Capture channels 1 and 2
;;;2690       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
;;;2691     switch (Channel)
000006  b115              CBZ      r5,|L27.14|
000008  2d04              CMP      r5,#4
00000a  d10c              BNE      |L27.38|
00000c  e005              B        |L27.26|
                  |L27.14|
;;;2692     {
;;;2693       case TIM_CHANNEL_1:
;;;2694       {
;;;2695         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
00000e  2200              MOVS     r2,#0
000010  4611              MOV      r1,r2
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       TIM_CCxChannelCmd
;;;2696         break; 
000018  e010              B        |L27.60|
                  |L27.26|
;;;2697       }
;;;2698       case TIM_CHANNEL_2:
;;;2699       { 
;;;2700         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
00001a  2200              MOVS     r2,#0
00001c  2104              MOVS     r1,#4
00001e  6820              LDR      r0,[r4,#0]
000020  f7fffffe          BL       TIM_CCxChannelCmd
;;;2701         break;
000024  e00a              B        |L27.60|
                  |L27.38|
;;;2702       }  
;;;2703       default :
;;;2704       {
;;;2705        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000026  2200              MOVS     r2,#0
000028  4611              MOV      r1,r2
00002a  6820              LDR      r0,[r4,#0]
00002c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2706        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
000030  2200              MOVS     r2,#0
000032  2104              MOVS     r1,#4
000034  6820              LDR      r0,[r4,#0]
000036  f7fffffe          BL       TIM_CCxChannelCmd
;;;2707        break; 
00003a  bf00              NOP      
                  |L27.60|
00003c  bf00              NOP                            ;2696
;;;2708       }
;;;2709     }  
;;;2710     /* Disable the Peripheral */
;;;2711     __HAL_TIM_DISABLE(htim);
00003e  bf00              NOP      
000040  6820              LDR      r0,[r4,#0]
000042  6a00              LDR      r0,[r0,#0x20]
000044  f2411111          MOV      r1,#0x1111
000048  4008              ANDS     r0,r0,r1
00004a  b950              CBNZ     r0,|L27.98|
00004c  6820              LDR      r0,[r4,#0]
00004e  6a00              LDR      r0,[r0,#0x20]
000050  1089              ASRS     r1,r1,#2
000052  4008              ANDS     r0,r0,r1
000054  b928              CBNZ     r0,|L27.98|
000056  6820              LDR      r0,[r4,#0]
000058  6800              LDR      r0,[r0,#0]
00005a  f0200001          BIC      r0,r0,#1
00005e  6821              LDR      r1,[r4,#0]
000060  6008              STR      r0,[r1,#0]
                  |L27.98|
000062  bf00              NOP      
;;;2712     
;;;2713     /* Return function status */
;;;2714     return HAL_OK;
000064  2000              MOVS     r0,#0
;;;2715   }
000066  bd30              POP      {r4,r5,pc}
;;;2716   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Stop_DMA PROC
;;;2949     */
;;;2950   HAL_StatusTypeDef HAL_TIM_Encoder_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;2951   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2952     /* Check the parameters */
;;;2953     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;2954     
;;;2955     /* Disable the Input Capture channels 1 and 2
;;;2956       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
;;;2957     if(Channel == TIM_CHANNEL_1)
000006  b95d              CBNZ     r5,|L28.32|
;;;2958     {
;;;2959       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
000008  2200              MOVS     r2,#0
00000a  4611              MOV      r1,r2
00000c  6820              LDR      r0,[r4,#0]
00000e  f7fffffe          BL       TIM_CCxChannelCmd
;;;2960       
;;;2961       /* Disable the capture compare DMA Request 1 */
;;;2962       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000012  6820              LDR      r0,[r4,#0]
000014  68c0              LDR      r0,[r0,#0xc]
000016  f4207000          BIC      r0,r0,#0x200
00001a  6821              LDR      r1,[r4,#0]
00001c  60c8              STR      r0,[r1,#0xc]
00001e  e023              B        |L28.104|
                  |L28.32|
;;;2963     }  
;;;2964     else if(Channel == TIM_CHANNEL_2)
000020  2d04              CMP      r5,#4
000022  d10b              BNE      |L28.60|
;;;2965     {  
;;;2966       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
000024  2200              MOVS     r2,#0
000026  2104              MOVS     r1,#4
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       TIM_CCxChannelCmd
;;;2967       
;;;2968       /* Disable the capture compare DMA Request 2 */
;;;2969       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
00002e  6820              LDR      r0,[r4,#0]
000030  68c0              LDR      r0,[r0,#0xc]
000032  f4206080          BIC      r0,r0,#0x400
000036  6821              LDR      r1,[r4,#0]
000038  60c8              STR      r0,[r1,#0xc]
00003a  e015              B        |L28.104|
                  |L28.60|
;;;2970     }  
;;;2971     else
;;;2972     {
;;;2973       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
00003c  2200              MOVS     r2,#0
00003e  4611              MOV      r1,r2
000040  6820              LDR      r0,[r4,#0]
000042  f7fffffe          BL       TIM_CCxChannelCmd
;;;2974       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
000046  2200              MOVS     r2,#0
000048  2104              MOVS     r1,#4
00004a  6820              LDR      r0,[r4,#0]
00004c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2975       
;;;2976       /* Disable the capture compare DMA Request 1 and 2 */
;;;2977       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000050  6820              LDR      r0,[r4,#0]
000052  68c0              LDR      r0,[r0,#0xc]
000054  f4207000          BIC      r0,r0,#0x200
000058  6821              LDR      r1,[r4,#0]
00005a  60c8              STR      r0,[r1,#0xc]
;;;2978       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
00005c  6820              LDR      r0,[r4,#0]
00005e  68c0              LDR      r0,[r0,#0xc]
000060  f4206080          BIC      r0,r0,#0x400
000064  6821              LDR      r1,[r4,#0]
000066  60c8              STR      r0,[r1,#0xc]
                  |L28.104|
;;;2979     }
;;;2980     
;;;2981     /* Disable the Peripheral */
;;;2982     __HAL_TIM_DISABLE(htim);
000068  bf00              NOP      
00006a  6820              LDR      r0,[r4,#0]
00006c  6a00              LDR      r0,[r0,#0x20]
00006e  f2411111          MOV      r1,#0x1111
000072  4008              ANDS     r0,r0,r1
000074  b950              CBNZ     r0,|L28.140|
000076  6820              LDR      r0,[r4,#0]
000078  6a00              LDR      r0,[r0,#0x20]
00007a  1089              ASRS     r1,r1,#2
00007c  4008              ANDS     r0,r0,r1
00007e  b928              CBNZ     r0,|L28.140|
000080  6820              LDR      r0,[r4,#0]
000082  6800              LDR      r0,[r0,#0]
000084  f0200001          BIC      r0,r0,#1
000088  6821              LDR      r1,[r4,#0]
00008a  6008              STR      r0,[r1,#0]
                  |L28.140|
00008c  bf00              NOP      
;;;2983     
;;;2984     /* Change the htim state */
;;;2985     htim->State = HAL_TIM_STATE_READY;
00008e  2001              MOVS     r0,#1
000090  6420              STR      r0,[r4,#0x40]
;;;2986     
;;;2987     /* Return function status */
;;;2988     return HAL_OK;
000092  2000              MOVS     r0,#0
;;;2989   }
000094  bd30              POP      {r4,r5,pc}
;;;2990   
                          ENDP


                          AREA ||i.HAL_TIM_Encoder_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_Encoder_Stop_IT PROC
;;;2776     */
;;;2777   HAL_StatusTypeDef HAL_TIM_Encoder_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;2778   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2779     /* Check the parameters */
;;;2780     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2781       
;;;2782     /* Disable the Input Capture channels 1 and 2
;;;2783       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
;;;2784     if(Channel == TIM_CHANNEL_1)
000006  b95d              CBNZ     r5,|L29.32|
;;;2785     {
;;;2786       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
000008  2200              MOVS     r2,#0
00000a  4611              MOV      r1,r2
00000c  6820              LDR      r0,[r4,#0]
00000e  f7fffffe          BL       TIM_CCxChannelCmd
;;;2787       
;;;2788       /* Disable the capture compare Interrupts 1 */
;;;2789     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000012  6820              LDR      r0,[r4,#0]
000014  68c0              LDR      r0,[r0,#0xc]
000016  f0200002          BIC      r0,r0,#2
00001a  6821              LDR      r1,[r4,#0]
00001c  60c8              STR      r0,[r1,#0xc]
00001e  e023              B        |L29.104|
                  |L29.32|
;;;2790     }  
;;;2791     else if(Channel == TIM_CHANNEL_2)
000020  2d04              CMP      r5,#4
000022  d10b              BNE      |L29.60|
;;;2792     {  
;;;2793       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
000024  2200              MOVS     r2,#0
000026  2104              MOVS     r1,#4
000028  6820              LDR      r0,[r4,#0]
00002a  f7fffffe          BL       TIM_CCxChannelCmd
;;;2794       
;;;2795       /* Disable the capture compare Interrupts 2 */
;;;2796     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00002e  6820              LDR      r0,[r4,#0]
000030  68c0              LDR      r0,[r0,#0xc]
000032  f0200004          BIC      r0,r0,#4
000036  6821              LDR      r1,[r4,#0]
000038  60c8              STR      r0,[r1,#0xc]
00003a  e015              B        |L29.104|
                  |L29.60|
;;;2797     }  
;;;2798     else
;;;2799     {
;;;2800       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
00003c  2200              MOVS     r2,#0
00003e  4611              MOV      r1,r2
000040  6820              LDR      r0,[r4,#0]
000042  f7fffffe          BL       TIM_CCxChannelCmd
;;;2801       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
000046  2200              MOVS     r2,#0
000048  2104              MOVS     r1,#4
00004a  6820              LDR      r0,[r4,#0]
00004c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2802       
;;;2803       /* Disable the capture compare Interrupts 1 and 2 */
;;;2804       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000050  6820              LDR      r0,[r4,#0]
000052  68c0              LDR      r0,[r0,#0xc]
000054  f0200002          BIC      r0,r0,#2
000058  6821              LDR      r1,[r4,#0]
00005a  60c8              STR      r0,[r1,#0xc]
;;;2805       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
00005c  6820              LDR      r0,[r4,#0]
00005e  68c0              LDR      r0,[r0,#0xc]
000060  f0200004          BIC      r0,r0,#4
000064  6821              LDR      r1,[r4,#0]
000066  60c8              STR      r0,[r1,#0xc]
                  |L29.104|
;;;2806     }
;;;2807       
;;;2808     /* Disable the Peripheral */
;;;2809     __HAL_TIM_DISABLE(htim);
000068  bf00              NOP      
00006a  6820              LDR      r0,[r4,#0]
00006c  6a00              LDR      r0,[r0,#0x20]
00006e  f2411111          MOV      r1,#0x1111
000072  4008              ANDS     r0,r0,r1
000074  b950              CBNZ     r0,|L29.140|
000076  6820              LDR      r0,[r4,#0]
000078  6a00              LDR      r0,[r0,#0x20]
00007a  1089              ASRS     r1,r1,#2
00007c  4008              ANDS     r0,r0,r1
00007e  b928              CBNZ     r0,|L29.140|
000080  6820              LDR      r0,[r4,#0]
000082  6800              LDR      r0,[r0,#0]
000084  f0200001          BIC      r0,r0,#1
000088  6821              LDR      r1,[r4,#0]
00008a  6008              STR      r0,[r1,#0]
                  |L29.140|
00008c  bf00              NOP      
;;;2810     
;;;2811     /* Change the htim state */
;;;2812     htim->State = HAL_TIM_STATE_READY;
00008e  2001              MOVS     r0,#1
000090  6420              STR      r0,[r4,#0x40]
;;;2813     
;;;2814     /* Return function status */
;;;2815     return HAL_OK;
000092  2000              MOVS     r0,#0
;;;2816   }
000094  bd30              POP      {r4,r5,pc}
;;;2817   
                          ENDP


                          AREA ||i.HAL_TIM_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ErrorCallback PROC
;;;4767     */
;;;4768   __weak void HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4769   {
;;;4770     /* Prevent unused argument(s) compilation warning */
;;;4771     UNUSED(htim);
;;;4772    
;;;4773     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4774               the HAL_TIM_ErrorCallback could be implemented in the user file
;;;4775      */
;;;4776   }
;;;4777   
                          ENDP


                          AREA ||i.HAL_TIM_GenerateEvent||, CODE, READONLY, ALIGN=1

                  HAL_TIM_GenerateEvent PROC
;;;4081   
;;;4082   HAL_StatusTypeDef HAL_TIM_GenerateEvent(TIM_HandleTypeDef *htim, uint32_t EventSource)
000000  4602              MOV      r2,r0
;;;4083   {
;;;4084     /* Check the parameters */
;;;4085     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;4086     assert_param(IS_TIM_EVENT_SOURCE(EventSource));
;;;4087     
;;;4088     /* Process Locked */
;;;4089     __HAL_LOCK(htim);
000002  bf00              NOP      
000004  6bd0              LDR      r0,[r2,#0x3c]
000006  2801              CMP      r0,#1
000008  d101              BNE      |L31.14|
00000a  2002              MOVS     r0,#2
                  |L31.12|
;;;4090     
;;;4091     /* Change the TIM state */
;;;4092     htim->State = HAL_TIM_STATE_BUSY;
;;;4093     
;;;4094     /* Set the event sources */
;;;4095     htim->Instance->EGR = EventSource;
;;;4096     
;;;4097     /* Change the TIM state */
;;;4098     htim->State = HAL_TIM_STATE_READY;
;;;4099     
;;;4100     __HAL_UNLOCK(htim);
;;;4101     
;;;4102     /* Return function status */
;;;4103     return HAL_OK;  
;;;4104   }
00000c  4770              BX       lr
                  |L31.14|
00000e  2001              MOVS     r0,#1                 ;4089
000010  63d0              STR      r0,[r2,#0x3c]         ;4089
000012  bf00              NOP                            ;4089
000014  2002              MOVS     r0,#2                 ;4092
000016  6410              STR      r0,[r2,#0x40]         ;4092
000018  6810              LDR      r0,[r2,#0]            ;4095
00001a  6141              STR      r1,[r0,#0x14]         ;4095
00001c  2001              MOVS     r0,#1                 ;4098
00001e  6410              STR      r0,[r2,#0x40]         ;4098
000020  bf00              NOP                            ;4100
000022  2000              MOVS     r0,#0                 ;4100
000024  63d0              STR      r0,[r2,#0x3c]         ;4100
000026  bf00              NOP                            ;4100
000028  bf00              NOP                            ;4103
00002a  e7ef              B        |L31.12|
;;;4105   
                          ENDP


                          AREA ||i.HAL_TIM_IC_CaptureCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_CaptureCallback PROC
;;;4719     */
;;;4720   __weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4721   {
;;;4722     /* Prevent unused argument(s) compilation warning */
;;;4723     UNUSED(htim);
;;;4724    
;;;4725     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4726               the __HAL_TIM_IC_CaptureCallback could be implemented in the user file
;;;4727      */
;;;4728   }
;;;4729   
                          ENDP


                          AREA ||i.HAL_TIM_IC_ConfigChannel||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_ConfigChannel PROC
;;;3314     */
;;;3315   HAL_StatusTypeDef HAL_TIM_IC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_IC_InitTypeDef* sConfig, uint32_t Channel)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3316   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;3317     /* Check the parameters */
;;;3318     assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3319     assert_param(IS_TIM_IC_POLARITY(sConfig->ICPolarity));
;;;3320     assert_param(IS_TIM_IC_SELECTION(sConfig->ICSelection));
;;;3321     assert_param(IS_TIM_IC_PRESCALER(sConfig->ICPrescaler));
;;;3322     assert_param(IS_TIM_IC_FILTER(sConfig->ICFilter));
;;;3323     
;;;3324     __HAL_LOCK(htim);
00000a  bf00              NOP      
00000c  6be0              LDR      r0,[r4,#0x3c]
00000e  2801              CMP      r0,#1
000010  d102              BNE      |L33.24|
000012  2002              MOVS     r0,#2
                  |L33.20|
;;;3325     
;;;3326     htim->State = HAL_TIM_STATE_BUSY;
;;;3327     
;;;3328     if (Channel == TIM_CHANNEL_1)
;;;3329     {
;;;3330       /* TI1 Configuration */
;;;3331       TIM_TI1_SetConfig(htim->Instance,
;;;3332                  sConfig->ICPolarity,
;;;3333                  sConfig->ICSelection,
;;;3334                  sConfig->ICFilter);
;;;3335                  
;;;3336       /* Reset the IC1PSC Bits */
;;;3337       htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
;;;3338   
;;;3339       /* Set the IC1PSC value */
;;;3340       htim->Instance->CCMR1 |= sConfig->ICPrescaler;
;;;3341     }
;;;3342     else if (Channel == TIM_CHANNEL_2)
;;;3343     {
;;;3344       /* TI2 Configuration */
;;;3345       assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3346       
;;;3347       TIM_TI2_SetConfig(htim->Instance, 
;;;3348                         sConfig->ICPolarity,
;;;3349                         sConfig->ICSelection,
;;;3350                         sConfig->ICFilter);
;;;3351                  
;;;3352       /* Reset the IC2PSC Bits */
;;;3353       htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
;;;3354   
;;;3355       /* Set the IC2PSC value */
;;;3356       htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8);
;;;3357     }
;;;3358     else if (Channel == TIM_CHANNEL_3)
;;;3359     {
;;;3360       /* TI3 Configuration */
;;;3361       assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3362       
;;;3363       TIM_TI3_SetConfig(htim->Instance,  
;;;3364                  sConfig->ICPolarity,
;;;3365                  sConfig->ICSelection,
;;;3366                  sConfig->ICFilter);
;;;3367                  
;;;3368       /* Reset the IC3PSC Bits */
;;;3369       htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;
;;;3370   
;;;3371       /* Set the IC3PSC value */
;;;3372       htim->Instance->CCMR2 |= sConfig->ICPrescaler;
;;;3373     }
;;;3374     else
;;;3375     {
;;;3376       /* TI4 Configuration */
;;;3377       assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3378       
;;;3379       TIM_TI4_SetConfig(htim->Instance, 
;;;3380                  sConfig->ICPolarity,
;;;3381                  sConfig->ICSelection,
;;;3382                  sConfig->ICFilter);
;;;3383                  
;;;3384       /* Reset the IC4PSC Bits */
;;;3385       htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;
;;;3386   
;;;3387       /* Set the IC4PSC value */
;;;3388       htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8);
;;;3389     }
;;;3390     
;;;3391     htim->State = HAL_TIM_STATE_READY;
;;;3392       
;;;3393     __HAL_UNLOCK(htim);
;;;3394     
;;;3395     return HAL_OK; 
;;;3396   }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L33.24|
000018  2001              MOVS     r0,#1                 ;3324
00001a  63e0              STR      r0,[r4,#0x3c]         ;3324
00001c  bf00              NOP                            ;3324
00001e  2002              MOVS     r0,#2                 ;3326
000020  6420              STR      r0,[r4,#0x40]         ;3326
000022  b996              CBNZ     r6,|L33.74|
000024  68eb              LDR      r3,[r5,#0xc]          ;3331
000026  e9d51200          LDRD     r1,r2,[r5,#0]         ;3331
00002a  6820              LDR      r0,[r4,#0]            ;3331
00002c  f7fffffe          BL       TIM_TI1_SetConfig
000030  6820              LDR      r0,[r4,#0]            ;3337
000032  6980              LDR      r0,[r0,#0x18]         ;3337
000034  f020000c          BIC      r0,r0,#0xc            ;3337
000038  6821              LDR      r1,[r4,#0]            ;3337
00003a  6188              STR      r0,[r1,#0x18]         ;3337
00003c  6820              LDR      r0,[r4,#0]            ;3340
00003e  6980              LDR      r0,[r0,#0x18]         ;3340
000040  68a9              LDR      r1,[r5,#8]            ;3340
000042  4308              ORRS     r0,r0,r1              ;3340
000044  6821              LDR      r1,[r4,#0]            ;3340
000046  6188              STR      r0,[r1,#0x18]         ;3340
000048  e03d              B        |L33.198|
                  |L33.74|
00004a  2e04              CMP      r6,#4                 ;3342
00004c  d113              BNE      |L33.118|
00004e  68eb              LDR      r3,[r5,#0xc]          ;3347
000050  e9d51200          LDRD     r1,r2,[r5,#0]         ;3347
000054  6820              LDR      r0,[r4,#0]            ;3347
000056  f7fffffe          BL       TIM_TI2_SetConfig
00005a  6820              LDR      r0,[r4,#0]            ;3353
00005c  6980              LDR      r0,[r0,#0x18]         ;3353
00005e  f4206040          BIC      r0,r0,#0xc00          ;3353
000062  6821              LDR      r1,[r4,#0]            ;3353
000064  6188              STR      r0,[r1,#0x18]         ;3353
000066  6820              LDR      r0,[r4,#0]            ;3356
000068  6980              LDR      r0,[r0,#0x18]         ;3356
00006a  68a9              LDR      r1,[r5,#8]            ;3356
00006c  ea402001          ORR      r0,r0,r1,LSL #8       ;3356
000070  6821              LDR      r1,[r4,#0]            ;3356
000072  6188              STR      r0,[r1,#0x18]         ;3356
000074  e027              B        |L33.198|
                  |L33.118|
000076  2e08              CMP      r6,#8                 ;3358
000078  d112              BNE      |L33.160|
00007a  68eb              LDR      r3,[r5,#0xc]          ;3363
00007c  e9d51200          LDRD     r1,r2,[r5,#0]         ;3363
000080  6820              LDR      r0,[r4,#0]            ;3363
000082  f7fffffe          BL       TIM_TI3_SetConfig
000086  6820              LDR      r0,[r4,#0]            ;3369
000088  69c0              LDR      r0,[r0,#0x1c]         ;3369
00008a  f020000c          BIC      r0,r0,#0xc            ;3369
00008e  6821              LDR      r1,[r4,#0]            ;3369
000090  61c8              STR      r0,[r1,#0x1c]         ;3369
000092  6820              LDR      r0,[r4,#0]            ;3372
000094  69c0              LDR      r0,[r0,#0x1c]         ;3372
000096  68a9              LDR      r1,[r5,#8]            ;3372
000098  4308              ORRS     r0,r0,r1              ;3372
00009a  6821              LDR      r1,[r4,#0]            ;3372
00009c  61c8              STR      r0,[r1,#0x1c]         ;3372
00009e  e012              B        |L33.198|
                  |L33.160|
0000a0  68eb              LDR      r3,[r5,#0xc]          ;3379
0000a2  e9d51200          LDRD     r1,r2,[r5,#0]         ;3379
0000a6  6820              LDR      r0,[r4,#0]            ;3379
0000a8  f7fffffe          BL       TIM_TI4_SetConfig
0000ac  6820              LDR      r0,[r4,#0]            ;3385
0000ae  69c0              LDR      r0,[r0,#0x1c]         ;3385
0000b0  f4206040          BIC      r0,r0,#0xc00          ;3385
0000b4  6821              LDR      r1,[r4,#0]            ;3385
0000b6  61c8              STR      r0,[r1,#0x1c]         ;3385
0000b8  6820              LDR      r0,[r4,#0]            ;3388
0000ba  69c0              LDR      r0,[r0,#0x1c]         ;3388
0000bc  68a9              LDR      r1,[r5,#8]            ;3388
0000be  ea402001          ORR      r0,r0,r1,LSL #8       ;3388
0000c2  6821              LDR      r1,[r4,#0]            ;3388
0000c4  61c8              STR      r0,[r1,#0x1c]         ;3388
                  |L33.198|
0000c6  2001              MOVS     r0,#1                 ;3391
0000c8  6420              STR      r0,[r4,#0x40]         ;3391
0000ca  bf00              NOP                            ;3393
0000cc  2000              MOVS     r0,#0                 ;3393
0000ce  63e0              STR      r0,[r4,#0x3c]         ;3393
0000d0  bf00              NOP                            ;3393
0000d2  bf00              NOP                            ;3395
0000d4  e79e              B        |L33.20|
;;;3397   
                          ENDP


                          AREA ||i.HAL_TIM_IC_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_DeInit PROC
;;;1693     */
;;;1694   HAL_StatusTypeDef HAL_TIM_IC_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1695   {
000002  4604              MOV      r4,r0
;;;1696     /* Check the parameters */
;;;1697     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1698   
;;;1699     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  6420              STR      r0,[r4,#0x40]
;;;1700     
;;;1701     /* Disable the TIM Peripheral Clock */
;;;1702     __HAL_TIM_DISABLE(htim);
000008  bf00              NOP      
00000a  6820              LDR      r0,[r4,#0]
00000c  6a00              LDR      r0,[r0,#0x20]
00000e  f2411111          MOV      r1,#0x1111
000012  4008              ANDS     r0,r0,r1
000014  b950              CBNZ     r0,|L34.44|
000016  6820              LDR      r0,[r4,#0]
000018  6a00              LDR      r0,[r0,#0x20]
00001a  1089              ASRS     r1,r1,#2
00001c  4008              ANDS     r0,r0,r1
00001e  b928              CBNZ     r0,|L34.44|
000020  6820              LDR      r0,[r4,#0]
000022  6800              LDR      r0,[r0,#0]
000024  f0200001          BIC      r0,r0,#1
000028  6821              LDR      r1,[r4,#0]
00002a  6008              STR      r0,[r1,#0]
                  |L34.44|
00002c  bf00              NOP      
;;;1703   
;;;1704   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;1705     if(htim->IC_MspDeInitCallback == NULL)
;;;1706     {
;;;1707       htim->IC_MspDeInitCallback = HAL_TIM_IC_MspDeInit;
;;;1708     }
;;;1709     /* DeInit the low level hardware */
;;;1710     htim->IC_MspDeInitCallback(htim);
;;;1711   #else
;;;1712     /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;1713     HAL_TIM_IC_MspDeInit(htim);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       HAL_TIM_IC_MspDeInit
;;;1714   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;1715   
;;;1716     /* Change TIM state */  
;;;1717     htim->State = HAL_TIM_STATE_RESET;
000034  2000              MOVS     r0,#0
000036  6420              STR      r0,[r4,#0x40]
;;;1718   
;;;1719     /* Release Lock */
;;;1720     __HAL_UNLOCK(htim);
000038  bf00              NOP      
00003a  63e0              STR      r0,[r4,#0x3c]
00003c  bf00              NOP      
;;;1721   
;;;1722     return HAL_OK;
;;;1723   }
00003e  bd10              POP      {r4,pc}
;;;1724   
                          ENDP


                          AREA ||i.HAL_TIM_IC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_GetState PROC
;;;5267     */
;;;5268   HAL_TIM_StateTypeDef HAL_TIM_IC_GetState(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;5269   {
;;;5270     return htim->State;
000002  6c08              LDR      r0,[r1,#0x40]
;;;5271   }
000004  4770              BX       lr
;;;5272   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Init PROC
;;;1640     */
;;;1641   HAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1642   {
000002  4604              MOV      r4,r0
;;;1643     /* Check the TIM handle allocation */
;;;1644     if(htim == NULL)
000004  b90c              CBNZ     r4,|L36.10|
;;;1645     {
;;;1646       return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L36.8|
;;;1647     }
;;;1648   
;;;1649     /* Check the parameters */
;;;1650     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1651     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;1652     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision)); 
;;;1653     assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;1654   
;;;1655     if(htim->State == HAL_TIM_STATE_RESET)
;;;1656     {
;;;1657       /* Allocate lock resource and initialize it */
;;;1658       htim->Lock = HAL_UNLOCKED;
;;;1659   
;;;1660   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;1661       /* Reset interrupt callbacks to legacy week callbacks */
;;;1662       TIM_ResetCallback(htim);
;;;1663   
;;;1664       if(htim->IC_MspInitCallback == NULL)
;;;1665       {
;;;1666         htim->IC_MspInitCallback = HAL_TIM_IC_MspInit;
;;;1667       }
;;;1668       /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;1669       htim->IC_MspInitCallback(htim);
;;;1670   #else
;;;1671       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;1672       HAL_TIM_IC_MspInit(htim);
;;;1673   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;1674     }
;;;1675   
;;;1676     /* Set the TIM state */
;;;1677     htim->State= HAL_TIM_STATE_BUSY;   
;;;1678     
;;;1679     /* Init the base time for the input capture */  
;;;1680     TIM_Base_SetConfig(htim->Instance, &htim->Init); 
;;;1681      
;;;1682     /* Initialize the TIM state*/
;;;1683     htim->State= HAL_TIM_STATE_READY;
;;;1684     
;;;1685     return HAL_OK;
;;;1686   }
000008  bd10              POP      {r4,pc}
                  |L36.10|
00000a  6c20              LDR      r0,[r4,#0x40]         ;1655
00000c  b920              CBNZ     r0,|L36.24|
00000e  2000              MOVS     r0,#0                 ;1658
000010  63e0              STR      r0,[r4,#0x3c]         ;1658
000012  4620              MOV      r0,r4                 ;1672
000014  f7fffffe          BL       HAL_TIM_IC_MspInit
                  |L36.24|
000018  2002              MOVS     r0,#2                 ;1677
00001a  6420              STR      r0,[r4,#0x40]         ;1677
00001c  1d21              ADDS     r1,r4,#4              ;1680
00001e  6820              LDR      r0,[r4,#0]            ;1680
000020  f7fffffe          BL       TIM_Base_SetConfig
000024  2001              MOVS     r0,#1                 ;1683
000026  6420              STR      r0,[r4,#0x40]         ;1683
000028  2000              MOVS     r0,#0                 ;1685
00002a  e7ed              B        |L36.8|
;;;1687   
                          ENDP


                          AREA ||i.HAL_TIM_IC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_MspDeInit PROC
;;;1746     */
;;;1747   __weak void HAL_TIM_IC_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1748   {
;;;1749     /* Prevent unused argument(s) compilation warning */
;;;1750     UNUSED(htim);
;;;1751      
;;;1752     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1753               the HAL_TIM_IC_MspDeInit could be implemented in the user file
;;;1754      */
;;;1755   }
;;;1756   
                          ENDP


                          AREA ||i.HAL_TIM_IC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_MspInit PROC
;;;1730     */
;;;1731   __weak void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1732   {
;;;1733     /* Prevent unused argument(s) compilation warning */
;;;1734     UNUSED(htim);
;;;1735    
;;;1736     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1737               the HAL_TIM_IC_MspInit could be implemented in the user file
;;;1738      */
;;;1739   }
;;;1740   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Start||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Start PROC
;;;1768     */
;;;1769   HAL_StatusTypeDef HAL_TIM_IC_Start (TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1770   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1771     /* Check the parameters */
;;;1772     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1773     
;;;1774     /* Enable the Input Capture channel */
;;;1775     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000006  2201              MOVS     r2,#1
000008  4629              MOV      r1,r5
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxChannelCmd
;;;1776       
;;;1777     /* Enable the Peripheral */
;;;1778     __HAL_TIM_ENABLE(htim);  
000010  6820              LDR      r0,[r4,#0]
000012  6800              LDR      r0,[r0,#0]
000014  f0400001          ORR      r0,r0,#1
000018  6821              LDR      r1,[r4,#0]
00001a  6008              STR      r0,[r1,#0]
;;;1779   
;;;1780     /* Return function status */
;;;1781     return HAL_OK;  
00001c  2000              MOVS     r0,#0
;;;1782   } 
00001e  bd30              POP      {r4,r5,pc}
;;;1783   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_IC_Start_DMA PROC
;;;1945     */
;;;1946   HAL_StatusTypeDef HAL_TIM_IC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1947   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1948     /* Check the parameters */
;;;1949     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1950     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;1951     
;;;1952     if((htim->State == HAL_TIM_STATE_BUSY))
00000c  6c20              LDR      r0,[r4,#0x40]
00000e  2802              CMP      r0,#2
000010  d101              BNE      |L40.22|
                  |L40.18|
;;;1953     {
;;;1954        return HAL_BUSY;
;;;1955     }
;;;1956     else if((htim->State == HAL_TIM_STATE_READY))
;;;1957     {
;;;1958       if((pData == 0 ) && (Length > 0)) 
;;;1959       {
;;;1960         return HAL_ERROR;                                    
;;;1961       }
;;;1962       else
;;;1963       {
;;;1964         htim->State = HAL_TIM_STATE_BUSY;
;;;1965       }
;;;1966     }  
;;;1967      
;;;1968     switch (Channel)
;;;1969     {
;;;1970       case TIM_CHANNEL_1:
;;;1971       {
;;;1972         /* Set the DMA Period elapsed callback */
;;;1973         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;1974        
;;;1975         /* Set the DMA error callback */
;;;1976         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
;;;1977         
;;;1978         /* Enable the DMA Stream */
;;;1979         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length); 
;;;1980         
;;;1981         /* Enable the TIM Capture/Compare 1 DMA request */      
;;;1982         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;1983       }
;;;1984       break;
;;;1985       
;;;1986       case TIM_CHANNEL_2:
;;;1987       {
;;;1988         /* Set the DMA Period elapsed callback */
;;;1989         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;1990        
;;;1991         /* Set the DMA error callback */
;;;1992         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
;;;1993         
;;;1994         /* Enable the DMA Stream */
;;;1995         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData, Length);
;;;1996         
;;;1997         /* Enable the TIM Capture/Compare 2  DMA request */
;;;1998         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;1999       }
;;;2000       break;
;;;2001       
;;;2002       case TIM_CHANNEL_3:
;;;2003       {
;;;2004         /* Set the DMA Period elapsed callback */
;;;2005         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;2006        
;;;2007         /* Set the DMA error callback */
;;;2008         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
;;;2009         
;;;2010         /* Enable the DMA Stream */
;;;2011         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->CCR3, (uint32_t)pData, Length);
;;;2012         
;;;2013         /* Enable the TIM Capture/Compare 3  DMA request */
;;;2014         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;2015       }
;;;2016       break;
;;;2017       
;;;2018       case TIM_CHANNEL_4:
;;;2019       {
;;;2020         /* Set the DMA Period elapsed callback */
;;;2021         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMACaptureCplt;
;;;2022        
;;;2023         /* Set the DMA error callback */
;;;2024         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
;;;2025         
;;;2026         /* Enable the DMA Stream */
;;;2027         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->CCR4, (uint32_t)pData, Length);
;;;2028         
;;;2029         /* Enable the TIM Capture/Compare 4  DMA request */
;;;2030         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;2031       }
;;;2032       break;
;;;2033       
;;;2034       default:
;;;2035       break;
;;;2036     }
;;;2037   
;;;2038     /* Enable the Input Capture channel */
;;;2039     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;2040      
;;;2041     /* Enable the Peripheral */
;;;2042     __HAL_TIM_ENABLE(htim); 
;;;2043     
;;;2044     /* Return function status */
;;;2045     return HAL_OK;
;;;2046   }
000012  e8bd81f0          POP      {r4-r8,pc}
                  |L40.22|
000016  6c20              LDR      r0,[r4,#0x40]         ;1956
000018  2801              CMP      r0,#1                 ;1956
00001a  d105              BNE      |L40.40|
00001c  b916              CBNZ     r6,|L40.36|
00001e  2f00              CMP      r7,#0                 ;1958
000020  dd00              BLE      |L40.36|
000022  e7f6              B        |L40.18|
                  |L40.36|
000024  2002              MOVS     r0,#2                 ;1964
000026  6420              STR      r0,[r4,#0x40]         ;1964
                  |L40.40|
000028  b135              CBZ      r5,|L40.56|
00002a  2d04              CMP      r5,#4                 ;1968
00002c  d019              BEQ      |L40.98|
00002e  2d08              CMP      r5,#8                 ;1968
000030  d02c              BEQ      |L40.140|
000032  2d0c              CMP      r5,#0xc               ;1968
000034  d154              BNE      |L40.224|
000036  e03e              B        |L40.182|
                  |L40.56|
000038  4931              LDR      r1,|L40.256|
00003a  6a60              LDR      r0,[r4,#0x24]         ;1973
00003c  6401              STR      r1,[r0,#0x40]         ;1973
00003e  4931              LDR      r1,|L40.260|
000040  6a60              LDR      r0,[r4,#0x24]         ;1976
000042  6501              STR      r1,[r0,#0x50]         ;1976
000044  6822              LDR      r2,[r4,#0]            ;1979
000046  f1020134          ADD      r1,r2,#0x34           ;1979
00004a  463b              MOV      r3,r7                 ;1979
00004c  4632              MOV      r2,r6                 ;1979
00004e  6a60              LDR      r0,[r4,#0x24]         ;1979
000050  f7fffffe          BL       HAL_DMA_Start_IT
000054  6820              LDR      r0,[r4,#0]            ;1982
000056  68c0              LDR      r0,[r0,#0xc]          ;1982
000058  f4407000          ORR      r0,r0,#0x200          ;1982
00005c  6821              LDR      r1,[r4,#0]            ;1982
00005e  60c8              STR      r0,[r1,#0xc]          ;1982
000060  e03f              B        |L40.226|
                  |L40.98|
000062  4927              LDR      r1,|L40.256|
000064  6aa0              LDR      r0,[r4,#0x28]         ;1989
000066  6401              STR      r1,[r0,#0x40]         ;1989
000068  4926              LDR      r1,|L40.260|
00006a  6aa0              LDR      r0,[r4,#0x28]         ;1992
00006c  6501              STR      r1,[r0,#0x50]         ;1992
00006e  6822              LDR      r2,[r4,#0]            ;1995
000070  f1020138          ADD      r1,r2,#0x38           ;1995
000074  463b              MOV      r3,r7                 ;1995
000076  4632              MOV      r2,r6                 ;1995
000078  6aa0              LDR      r0,[r4,#0x28]         ;1995
00007a  f7fffffe          BL       HAL_DMA_Start_IT
00007e  6820              LDR      r0,[r4,#0]            ;1998
000080  68c0              LDR      r0,[r0,#0xc]          ;1998
000082  f4406080          ORR      r0,r0,#0x400          ;1998
000086  6821              LDR      r1,[r4,#0]            ;1998
000088  60c8              STR      r0,[r1,#0xc]          ;1998
00008a  e02a              B        |L40.226|
                  |L40.140|
00008c  491c              LDR      r1,|L40.256|
00008e  6ae0              LDR      r0,[r4,#0x2c]         ;2005
000090  6401              STR      r1,[r0,#0x40]         ;2005
000092  491c              LDR      r1,|L40.260|
000094  6ae0              LDR      r0,[r4,#0x2c]         ;2008
000096  6501              STR      r1,[r0,#0x50]         ;2008
000098  6822              LDR      r2,[r4,#0]            ;2011
00009a  f102013c          ADD      r1,r2,#0x3c           ;2011
00009e  463b              MOV      r3,r7                 ;2011
0000a0  4632              MOV      r2,r6                 ;2011
0000a2  6ae0              LDR      r0,[r4,#0x2c]         ;2011
0000a4  f7fffffe          BL       HAL_DMA_Start_IT
0000a8  6820              LDR      r0,[r4,#0]            ;2014
0000aa  68c0              LDR      r0,[r0,#0xc]          ;2014
0000ac  f4406000          ORR      r0,r0,#0x800          ;2014
0000b0  6821              LDR      r1,[r4,#0]            ;2014
0000b2  60c8              STR      r0,[r1,#0xc]          ;2014
0000b4  e015              B        |L40.226|
                  |L40.182|
0000b6  4912              LDR      r1,|L40.256|
0000b8  6b20              LDR      r0,[r4,#0x30]         ;2021
0000ba  6401              STR      r1,[r0,#0x40]         ;2021
0000bc  4911              LDR      r1,|L40.260|
0000be  6b20              LDR      r0,[r4,#0x30]         ;2024
0000c0  6501              STR      r1,[r0,#0x50]         ;2024
0000c2  6822              LDR      r2,[r4,#0]            ;2027
0000c4  f1020140          ADD      r1,r2,#0x40           ;2027
0000c8  463b              MOV      r3,r7                 ;2027
0000ca  4632              MOV      r2,r6                 ;2027
0000cc  6b20              LDR      r0,[r4,#0x30]         ;2027
0000ce  f7fffffe          BL       HAL_DMA_Start_IT
0000d2  6820              LDR      r0,[r4,#0]            ;2030
0000d4  68c0              LDR      r0,[r0,#0xc]          ;2030
0000d6  f4405080          ORR      r0,r0,#0x1000         ;2030
0000da  6821              LDR      r1,[r4,#0]            ;2030
0000dc  60c8              STR      r0,[r1,#0xc]          ;2030
0000de  e000              B        |L40.226|
                  |L40.224|
0000e0  bf00              NOP                            ;2035
                  |L40.226|
0000e2  bf00              NOP                            ;1984
0000e4  2201              MOVS     r2,#1                 ;2039
0000e6  4629              MOV      r1,r5                 ;2039
0000e8  6820              LDR      r0,[r4,#0]            ;2039
0000ea  f7fffffe          BL       TIM_CCxChannelCmd
0000ee  6820              LDR      r0,[r4,#0]            ;2042
0000f0  6800              LDR      r0,[r0,#0]            ;2042
0000f2  f0400001          ORR      r0,r0,#1              ;2042
0000f6  6821              LDR      r1,[r4,#0]            ;2042
0000f8  6008              STR      r0,[r1,#0]            ;2042
0000fa  2000              MOVS     r0,#0                 ;2045
0000fc  e789              B        |L40.18|
;;;2047   
                          ENDP

0000fe  0000              DCW      0x0000
                  |L40.256|
                          DCD      TIM_DMACaptureCplt
                  |L40.260|
                          DCD      TIM_DMAError

                          AREA ||i.HAL_TIM_IC_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Start_IT PROC
;;;1822     */
;;;1823   HAL_StatusTypeDef HAL_TIM_IC_Start_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1824   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1825     /* Check the parameters */
;;;1826     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1827     
;;;1828     switch (Channel)
000006  b135              CBZ      r5,|L41.22|
000008  2d04              CMP      r5,#4
00000a  d00b              BEQ      |L41.36|
00000c  2d08              CMP      r5,#8
00000e  d010              BEQ      |L41.50|
000010  2d0c              CMP      r5,#0xc
000012  d11c              BNE      |L41.78|
000014  e014              B        |L41.64|
                  |L41.22|
;;;1829     {
;;;1830       case TIM_CHANNEL_1:
;;;1831       {       
;;;1832         /* Enable the TIM Capture/Compare 1 interrupt */
;;;1833         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000016  6820              LDR      r0,[r4,#0]
000018  68c0              LDR      r0,[r0,#0xc]
00001a  f0400002          ORR      r0,r0,#2
00001e  6821              LDR      r1,[r4,#0]
000020  60c8              STR      r0,[r1,#0xc]
;;;1834       }
;;;1835       break;
000022  e015              B        |L41.80|
                  |L41.36|
;;;1836       
;;;1837       case TIM_CHANNEL_2:
;;;1838       {
;;;1839         /* Enable the TIM Capture/Compare 2 interrupt */
;;;1840         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000024  6820              LDR      r0,[r4,#0]
000026  68c0              LDR      r0,[r0,#0xc]
000028  f0400004          ORR      r0,r0,#4
00002c  6821              LDR      r1,[r4,#0]
00002e  60c8              STR      r0,[r1,#0xc]
;;;1841       }
;;;1842       break;
000030  e00e              B        |L41.80|
                  |L41.50|
;;;1843       
;;;1844       case TIM_CHANNEL_3:
;;;1845       {
;;;1846         /* Enable the TIM Capture/Compare 3 interrupt */
;;;1847         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
000032  6820              LDR      r0,[r4,#0]
000034  68c0              LDR      r0,[r0,#0xc]
000036  f0400008          ORR      r0,r0,#8
00003a  6821              LDR      r1,[r4,#0]
00003c  60c8              STR      r0,[r1,#0xc]
;;;1848       }
;;;1849       break;
00003e  e007              B        |L41.80|
                  |L41.64|
;;;1850       
;;;1851       case TIM_CHANNEL_4:
;;;1852       {
;;;1853         /* Enable the TIM Capture/Compare 4 interrupt */
;;;1854         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
000040  6820              LDR      r0,[r4,#0]
000042  68c0              LDR      r0,[r0,#0xc]
000044  f0400010          ORR      r0,r0,#0x10
000048  6821              LDR      r1,[r4,#0]
00004a  60c8              STR      r0,[r1,#0xc]
;;;1855       }
;;;1856       break;
00004c  e000              B        |L41.80|
                  |L41.78|
;;;1857       
;;;1858       default:
;;;1859       break;
00004e  bf00              NOP      
                  |L41.80|
000050  bf00              NOP                            ;1835
;;;1860     }  
;;;1861     /* Enable the Input Capture channel */
;;;1862     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000052  2201              MOVS     r2,#1
000054  4629              MOV      r1,r5
000056  6820              LDR      r0,[r4,#0]
000058  f7fffffe          BL       TIM_CCxChannelCmd
;;;1863       
;;;1864     /* Enable the Peripheral */
;;;1865     __HAL_TIM_ENABLE(htim);  
00005c  6820              LDR      r0,[r4,#0]
00005e  6800              LDR      r0,[r0,#0]
000060  f0400001          ORR      r0,r0,#1
000064  6821              LDR      r1,[r4,#0]
000066  6008              STR      r0,[r1,#0]
;;;1866   
;;;1867     /* Return function status */
;;;1868     return HAL_OK;  
000068  2000              MOVS     r0,#0
;;;1869   } 
00006a  bd30              POP      {r4,r5,pc}
;;;1870   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Stop||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Stop PROC
;;;1795     */
;;;1796   HAL_StatusTypeDef HAL_TIM_IC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1797   { 
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1798     /* Check the parameters */
;;;1799     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1800     
;;;1801     /* Disable the Input Capture channel */
;;;1802     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000006  2200              MOVS     r2,#0
000008  4629              MOV      r1,r5
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxChannelCmd
;;;1803     
;;;1804     /* Disable the Peripheral */
;;;1805     __HAL_TIM_DISABLE(htim); 
000010  bf00              NOP      
000012  6820              LDR      r0,[r4,#0]
000014  6a00              LDR      r0,[r0,#0x20]
000016  f2411111          MOV      r1,#0x1111
00001a  4008              ANDS     r0,r0,r1
00001c  b950              CBNZ     r0,|L42.52|
00001e  6820              LDR      r0,[r4,#0]
000020  6a00              LDR      r0,[r0,#0x20]
000022  1089              ASRS     r1,r1,#2
000024  4008              ANDS     r0,r0,r1
000026  b928              CBNZ     r0,|L42.52|
000028  6820              LDR      r0,[r4,#0]
00002a  6800              LDR      r0,[r0,#0]
00002c  f0200001          BIC      r0,r0,#1
000030  6821              LDR      r1,[r4,#0]
000032  6008              STR      r0,[r1,#0]
                  |L42.52|
000034  bf00              NOP      
;;;1806     
;;;1807     /* Return function status */
;;;1808     return HAL_OK;
000036  2000              MOVS     r0,#0
;;;1809   }
000038  bd30              POP      {r4,r5,pc}
;;;1810   
                          ENDP


                          AREA ||i.HAL_TIM_IC_Stop_DMA||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Stop_DMA PROC
;;;2059     */
;;;2060   HAL_StatusTypeDef HAL_TIM_IC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;2061   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2062     /* Check the parameters */
;;;2063     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;2064     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;2065     
;;;2066     switch (Channel)
000006  b135              CBZ      r5,|L43.22|
000008  2d04              CMP      r5,#4
00000a  d00b              BEQ      |L43.36|
00000c  2d08              CMP      r5,#8
00000e  d010              BEQ      |L43.50|
000010  2d0c              CMP      r5,#0xc
000012  d11c              BNE      |L43.78|
000014  e014              B        |L43.64|
                  |L43.22|
;;;2067     {
;;;2068       case TIM_CHANNEL_1:
;;;2069       {       
;;;2070         /* Disable the TIM Capture/Compare 1 DMA request */
;;;2071         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000016  6820              LDR      r0,[r4,#0]
000018  68c0              LDR      r0,[r0,#0xc]
00001a  f4207000          BIC      r0,r0,#0x200
00001e  6821              LDR      r1,[r4,#0]
000020  60c8              STR      r0,[r1,#0xc]
;;;2072       }
;;;2073       break;
000022  e015              B        |L43.80|
                  |L43.36|
;;;2074       
;;;2075       case TIM_CHANNEL_2:
;;;2076       {
;;;2077         /* Disable the TIM Capture/Compare 2 DMA request */
;;;2078         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000024  6820              LDR      r0,[r4,#0]
000026  68c0              LDR      r0,[r0,#0xc]
000028  f4206080          BIC      r0,r0,#0x400
00002c  6821              LDR      r1,[r4,#0]
00002e  60c8              STR      r0,[r1,#0xc]
;;;2079       }
;;;2080       break;
000030  e00e              B        |L43.80|
                  |L43.50|
;;;2081       
;;;2082       case TIM_CHANNEL_3:
;;;2083       {
;;;2084         /* Disable the TIM Capture/Compare 3  DMA request */
;;;2085         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
000032  6820              LDR      r0,[r4,#0]
000034  68c0              LDR      r0,[r0,#0xc]
000036  f4206000          BIC      r0,r0,#0x800
00003a  6821              LDR      r1,[r4,#0]
00003c  60c8              STR      r0,[r1,#0xc]
;;;2086       }
;;;2087       break;
00003e  e007              B        |L43.80|
                  |L43.64|
;;;2088       
;;;2089       case TIM_CHANNEL_4:
;;;2090       {
;;;2091         /* Disable the TIM Capture/Compare 4  DMA request */
;;;2092         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
000040  6820              LDR      r0,[r4,#0]
000042  68c0              LDR      r0,[r0,#0xc]
000044  f4205080          BIC      r0,r0,#0x1000
000048  6821              LDR      r1,[r4,#0]
00004a  60c8              STR      r0,[r1,#0xc]
;;;2093       }
;;;2094       break;
00004c  e000              B        |L43.80|
                  |L43.78|
;;;2095       
;;;2096       default:
;;;2097       break;
00004e  bf00              NOP      
                  |L43.80|
000050  bf00              NOP                            ;2073
;;;2098     }
;;;2099   
;;;2100     /* Disable the Input Capture channel */
;;;2101     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000052  2200              MOVS     r2,#0
000054  4629              MOV      r1,r5
000056  6820              LDR      r0,[r4,#0]
000058  f7fffffe          BL       TIM_CCxChannelCmd
;;;2102     
;;;2103     /* Disable the Peripheral */
;;;2104     __HAL_TIM_DISABLE(htim); 
00005c  bf00              NOP      
00005e  6820              LDR      r0,[r4,#0]
000060  6a00              LDR      r0,[r0,#0x20]
000062  f2411111          MOV      r1,#0x1111
000066  4008              ANDS     r0,r0,r1
000068  b950              CBNZ     r0,|L43.128|
00006a  6820              LDR      r0,[r4,#0]
00006c  6a00              LDR      r0,[r0,#0x20]
00006e  1089              ASRS     r1,r1,#2
000070  4008              ANDS     r0,r0,r1
000072  b928              CBNZ     r0,|L43.128|
000074  6820              LDR      r0,[r4,#0]
000076  6800              LDR      r0,[r0,#0]
000078  f0200001          BIC      r0,r0,#1
00007c  6821              LDR      r1,[r4,#0]
00007e  6008              STR      r0,[r1,#0]
                  |L43.128|
000080  bf00              NOP      
;;;2105     
;;;2106     /* Change the htim state */
;;;2107     htim->State = HAL_TIM_STATE_READY;
000082  2001              MOVS     r0,#1
000084  6420              STR      r0,[r4,#0x40]
;;;2108     
;;;2109     /* Return function status */
;;;2110     return HAL_OK;
000086  2000              MOVS     r0,#0
;;;2111   }  
000088  bd30              POP      {r4,r5,pc}
;;;2112   /**
                          ENDP


                          AREA ||i.HAL_TIM_IC_Stop_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IC_Stop_IT PROC
;;;1882     */
;;;1883   HAL_StatusTypeDef HAL_TIM_IC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1884   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1885     /* Check the parameters */
;;;1886     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1887     
;;;1888     switch (Channel)
000006  b135              CBZ      r5,|L44.22|
000008  2d04              CMP      r5,#4
00000a  d00b              BEQ      |L44.36|
00000c  2d08              CMP      r5,#8
00000e  d010              BEQ      |L44.50|
000010  2d0c              CMP      r5,#0xc
000012  d11c              BNE      |L44.78|
000014  e014              B        |L44.64|
                  |L44.22|
;;;1889     {
;;;1890       case TIM_CHANNEL_1:
;;;1891       {       
;;;1892         /* Disable the TIM Capture/Compare 1 interrupt */
;;;1893         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000016  6820              LDR      r0,[r4,#0]
000018  68c0              LDR      r0,[r0,#0xc]
00001a  f0200002          BIC      r0,r0,#2
00001e  6821              LDR      r1,[r4,#0]
000020  60c8              STR      r0,[r1,#0xc]
;;;1894       }
;;;1895       break;
000022  e015              B        |L44.80|
                  |L44.36|
;;;1896       
;;;1897       case TIM_CHANNEL_2:
;;;1898       {
;;;1899         /* Disable the TIM Capture/Compare 2 interrupt */
;;;1900         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000024  6820              LDR      r0,[r4,#0]
000026  68c0              LDR      r0,[r0,#0xc]
000028  f0200004          BIC      r0,r0,#4
00002c  6821              LDR      r1,[r4,#0]
00002e  60c8              STR      r0,[r1,#0xc]
;;;1901       }
;;;1902       break;
000030  e00e              B        |L44.80|
                  |L44.50|
;;;1903       
;;;1904       case TIM_CHANNEL_3:
;;;1905       {
;;;1906         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1907         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
000032  6820              LDR      r0,[r4,#0]
000034  68c0              LDR      r0,[r0,#0xc]
000036  f0200008          BIC      r0,r0,#8
00003a  6821              LDR      r1,[r4,#0]
00003c  60c8              STR      r0,[r1,#0xc]
;;;1908       }
;;;1909       break;
00003e  e007              B        |L44.80|
                  |L44.64|
;;;1910       
;;;1911       case TIM_CHANNEL_4:
;;;1912       {
;;;1913         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1914         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
000040  6820              LDR      r0,[r4,#0]
000042  68c0              LDR      r0,[r0,#0xc]
000044  f0200010          BIC      r0,r0,#0x10
000048  6821              LDR      r1,[r4,#0]
00004a  60c8              STR      r0,[r1,#0xc]
;;;1915       }
;;;1916       break;
00004c  e000              B        |L44.80|
                  |L44.78|
;;;1917       
;;;1918       default:
;;;1919       break; 
00004e  bf00              NOP      
                  |L44.80|
000050  bf00              NOP                            ;1895
;;;1920     } 
;;;1921     
;;;1922     /* Disable the Input Capture channel */
;;;1923     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE); 
000052  2200              MOVS     r2,#0
000054  4629              MOV      r1,r5
000056  6820              LDR      r0,[r4,#0]
000058  f7fffffe          BL       TIM_CCxChannelCmd
;;;1924     
;;;1925     /* Disable the Peripheral */
;;;1926     __HAL_TIM_DISABLE(htim); 
00005c  bf00              NOP      
00005e  6820              LDR      r0,[r4,#0]
000060  6a00              LDR      r0,[r0,#0x20]
000062  f2411111          MOV      r1,#0x1111
000066  4008              ANDS     r0,r0,r1
000068  b950              CBNZ     r0,|L44.128|
00006a  6820              LDR      r0,[r4,#0]
00006c  6a00              LDR      r0,[r0,#0x20]
00006e  1089              ASRS     r1,r1,#2
000070  4008              ANDS     r0,r0,r1
000072  b928              CBNZ     r0,|L44.128|
000074  6820              LDR      r0,[r4,#0]
000076  6800              LDR      r0,[r0,#0]
000078  f0200001          BIC      r0,r0,#1
00007c  6821              LDR      r1,[r4,#0]
00007e  6008              STR      r0,[r1,#0]
                  |L44.128|
000080  bf00              NOP      
;;;1927     
;;;1928     /* Return function status */
;;;1929     return HAL_OK;
000082  2000              MOVS     r0,#0
;;;1930   }
000084  bd30              POP      {r4,r5,pc}
;;;1931   
                          ENDP


                          AREA ||i.HAL_TIM_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_TIM_IRQHandler PROC
;;;3012     */
;;;3013   void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;3014   {
000002  4604              MOV      r4,r0
;;;3015     /* Capture compare 1 event */
;;;3016     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
000004  6820              LDR      r0,[r4,#0]
000006  6900              LDR      r0,[r0,#0x10]
000008  f3c00040          UBFX     r0,r0,#1,#1
00000c  b1d8              CBZ      r0,|L45.70|
;;;3017     {
;;;3018       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) !=RESET)
00000e  6820              LDR      r0,[r4,#0]
000010  68c0              LDR      r0,[r0,#0xc]
000012  f3c00040          UBFX     r0,r0,#1,#1
000016  b1b0              CBZ      r0,|L45.70|
;;;3019       {
;;;3020         {
;;;3021           __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
000018  f06f0002          MVN      r0,#2
00001c  6821              LDR      r1,[r4,#0]
00001e  6108              STR      r0,[r1,#0x10]
;;;3022           htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
000020  2001              MOVS     r0,#1
000022  61e0              STR      r0,[r4,#0x1c]
;;;3023           
;;;3024           /* Input capture event */
;;;3025           if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00)
000024  6820              LDR      r0,[r4,#0]
000026  6980              LDR      r0,[r0,#0x18]
000028  f0000003          AND      r0,r0,#3
00002c  b118              CBZ      r0,|L45.54|
;;;3026           {
;;;3027   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3028             htim->IC_CaptureCallback(htim);
;;;3029   #else
;;;3030             HAL_TIM_IC_CaptureCallback(htim);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
000034  e005              B        |L45.66|
                  |L45.54|
;;;3031   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3032           }
;;;3033           /* Output compare event */
;;;3034           else
;;;3035           {
;;;3036   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3037             htim->OC_DelayElapsedCallback(htim);
;;;3038             htim->PWM_PulseFinishedCallback(htim);
;;;3039   #else
;;;3040             HAL_TIM_OC_DelayElapsedCallback(htim);
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;3041             HAL_TIM_PWM_PulseFinishedCallback(htim);
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L45.66|
;;;3042   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3043           }
;;;3044           htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000042  2000              MOVS     r0,#0
000044  61e0              STR      r0,[r4,#0x1c]
                  |L45.70|
;;;3045         }
;;;3046       }
;;;3047     }
;;;3048     /* Capture compare 2 event */
;;;3049     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
000046  6820              LDR      r0,[r4,#0]
000048  6900              LDR      r0,[r0,#0x10]
00004a  f3c00080          UBFX     r0,r0,#2,#1
00004e  b1d8              CBZ      r0,|L45.136|
;;;3050     {
;;;3051       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) !=RESET)
000050  6820              LDR      r0,[r4,#0]
000052  68c0              LDR      r0,[r0,#0xc]
000054  f3c00080          UBFX     r0,r0,#2,#1
000058  b1b0              CBZ      r0,|L45.136|
;;;3052       {
;;;3053         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
00005a  f06f0004          MVN      r0,#4
00005e  6821              LDR      r1,[r4,#0]
000060  6108              STR      r0,[r1,#0x10]
;;;3054         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
000062  2002              MOVS     r0,#2
000064  61e0              STR      r0,[r4,#0x1c]
;;;3055         /* Input capture event */
;;;3056         if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00)
000066  6820              LDR      r0,[r4,#0]
000068  6980              LDR      r0,[r0,#0x18]
00006a  f4007040          AND      r0,r0,#0x300
00006e  b118              CBZ      r0,|L45.120|
;;;3057         {
;;;3058   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3059           htim->IC_CaptureCallback(htim);
;;;3060   #else
;;;3061           HAL_TIM_IC_CaptureCallback(htim);
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
000076  e005              B        |L45.132|
                  |L45.120|
;;;3062   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3063         }
;;;3064         /* Output compare event */
;;;3065         else
;;;3066         {
;;;3067   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3068           htim->OC_DelayElapsedCallback(htim);
;;;3069           htim->PWM_PulseFinishedCallback(htim);
;;;3070   #else
;;;3071           HAL_TIM_OC_DelayElapsedCallback(htim);
000078  4620              MOV      r0,r4
00007a  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;3072           HAL_TIM_PWM_PulseFinishedCallback(htim);
00007e  4620              MOV      r0,r4
000080  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L45.132|
;;;3073   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3074         }
;;;3075         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000084  2000              MOVS     r0,#0
000086  61e0              STR      r0,[r4,#0x1c]
                  |L45.136|
;;;3076       }
;;;3077     }
;;;3078     /* Capture compare 3 event */
;;;3079     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
000088  6820              LDR      r0,[r4,#0]
00008a  6900              LDR      r0,[r0,#0x10]
00008c  f3c000c0          UBFX     r0,r0,#3,#1
000090  b1d8              CBZ      r0,|L45.202|
;;;3080     {
;;;3081       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) !=RESET)
000092  6820              LDR      r0,[r4,#0]
000094  68c0              LDR      r0,[r0,#0xc]
000096  f3c000c0          UBFX     r0,r0,#3,#1
00009a  b1b0              CBZ      r0,|L45.202|
;;;3082       {
;;;3083         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
00009c  f06f0008          MVN      r0,#8
0000a0  6821              LDR      r1,[r4,#0]
0000a2  6108              STR      r0,[r1,#0x10]
;;;3084         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
0000a4  2004              MOVS     r0,#4
0000a6  61e0              STR      r0,[r4,#0x1c]
;;;3085         /* Input capture event */
;;;3086         if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00)
0000a8  6820              LDR      r0,[r4,#0]
0000aa  69c0              LDR      r0,[r0,#0x1c]
0000ac  f0000003          AND      r0,r0,#3
0000b0  b118              CBZ      r0,|L45.186|
;;;3087         {          
;;;3088   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3089           htim->IC_CaptureCallback(htim);
;;;3090   #else
;;;3091           HAL_TIM_IC_CaptureCallback(htim);
0000b2  4620              MOV      r0,r4
0000b4  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
0000b8  e005              B        |L45.198|
                  |L45.186|
;;;3092   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3093         }
;;;3094         /* Output compare event */
;;;3095         else
;;;3096         {
;;;3097   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3098           htim->OC_DelayElapsedCallback(htim);
;;;3099           htim->PWM_PulseFinishedCallback(htim);
;;;3100   #else
;;;3101           HAL_TIM_OC_DelayElapsedCallback(htim);
0000ba  4620              MOV      r0,r4
0000bc  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;3102           HAL_TIM_PWM_PulseFinishedCallback(htim);
0000c0  4620              MOV      r0,r4
0000c2  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L45.198|
;;;3103   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3104         }
;;;3105         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
0000c6  2000              MOVS     r0,#0
0000c8  61e0              STR      r0,[r4,#0x1c]
                  |L45.202|
;;;3106       }
;;;3107     }
;;;3108     /* Capture compare 4 event */
;;;3109     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
0000ca  6820              LDR      r0,[r4,#0]
0000cc  6900              LDR      r0,[r0,#0x10]
0000ce  f3c01000          UBFX     r0,r0,#4,#1
0000d2  b1d8              CBZ      r0,|L45.268|
;;;3110     {
;;;3111       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) !=RESET)
0000d4  6820              LDR      r0,[r4,#0]
0000d6  68c0              LDR      r0,[r0,#0xc]
0000d8  f3c01000          UBFX     r0,r0,#4,#1
0000dc  b1b0              CBZ      r0,|L45.268|
;;;3112       {
;;;3113         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
0000de  f06f0010          MVN      r0,#0x10
0000e2  6821              LDR      r1,[r4,#0]
0000e4  6108              STR      r0,[r1,#0x10]
;;;3114         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
0000e6  2008              MOVS     r0,#8
0000e8  61e0              STR      r0,[r4,#0x1c]
;;;3115         /* Input capture event */
;;;3116         if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00)
0000ea  6820              LDR      r0,[r4,#0]
0000ec  69c0              LDR      r0,[r0,#0x1c]
0000ee  f4007040          AND      r0,r0,#0x300
0000f2  b118              CBZ      r0,|L45.252|
;;;3117         {          
;;;3118   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3119           htim->IC_CaptureCallback(htim);
;;;3120   #else
;;;3121           HAL_TIM_IC_CaptureCallback(htim);
0000f4  4620              MOV      r0,r4
0000f6  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
0000fa  e005              B        |L45.264|
                  |L45.252|
;;;3122   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3123         }
;;;3124         /* Output compare event */
;;;3125         else
;;;3126         {
;;;3127   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3128           htim->OC_DelayElapsedCallback(htim);
;;;3129           htim->PWM_PulseFinishedCallback(htim);
;;;3130   #else
;;;3131           HAL_TIM_OC_DelayElapsedCallback(htim);
0000fc  4620              MOV      r0,r4
0000fe  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;3132           HAL_TIM_PWM_PulseFinishedCallback(htim);
000102  4620              MOV      r0,r4
000104  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L45.264|
;;;3133   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3134         }
;;;3135         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000108  2000              MOVS     r0,#0
00010a  61e0              STR      r0,[r4,#0x1c]
                  |L45.268|
;;;3136       }
;;;3137     }
;;;3138     /* TIM Update event */
;;;3139     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
00010c  6820              LDR      r0,[r4,#0]
00010e  6900              LDR      r0,[r0,#0x10]
000110  f0000001          AND      r0,r0,#1
000114  b158              CBZ      r0,|L45.302|
;;;3140     {
;;;3141       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) !=RESET)
000116  6820              LDR      r0,[r4,#0]
000118  68c0              LDR      r0,[r0,#0xc]
00011a  f0000001          AND      r0,r0,#1
00011e  b130              CBZ      r0,|L45.302|
;;;3142       {
;;;3143         __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
000120  f06f0001          MVN      r0,#1
000124  6821              LDR      r1,[r4,#0]
000126  6108              STR      r0,[r1,#0x10]
;;;3144   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3145         htim->PeriodElapsedCallback(htim);
;;;3146   #else
;;;3147         HAL_TIM_PeriodElapsedCallback(htim);
000128  4620              MOV      r0,r4
00012a  f7fffffe          BL       HAL_TIM_PeriodElapsedCallback
                  |L45.302|
;;;3148   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3149       }
;;;3150     }
;;;3151     /* TIM Break input event */
;;;3152     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
00012e  6820              LDR      r0,[r4,#0]
000130  6900              LDR      r0,[r0,#0x10]
000132  f3c010c0          UBFX     r0,r0,#7,#1
000136  b158              CBZ      r0,|L45.336|
;;;3153     {
;;;3154       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
000138  6820              LDR      r0,[r4,#0]
00013a  68c0              LDR      r0,[r0,#0xc]
00013c  f3c010c0          UBFX     r0,r0,#7,#1
000140  b130              CBZ      r0,|L45.336|
;;;3155       {
;;;3156         __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
000142  f06f0080          MVN      r0,#0x80
000146  6821              LDR      r1,[r4,#0]
000148  6108              STR      r0,[r1,#0x10]
;;;3157   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3158         htim->BreakCallback(htim);
;;;3159   #else
;;;3160         HAL_TIMEx_BreakCallback(htim);
00014a  4620              MOV      r0,r4
00014c  f7fffffe          BL       HAL_TIMEx_BreakCallback
                  |L45.336|
;;;3161   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3162   
;;;3163       }
;;;3164     }
;;;3165     
;;;3166       /* TIM Break input event */
;;;3167     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
000150  6820              LDR      r0,[r4,#0]
000152  6900              LDR      r0,[r0,#0x10]
000154  f3c02000          UBFX     r0,r0,#8,#1
000158  b158              CBZ      r0,|L45.370|
;;;3168     {
;;;3169       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
00015a  6820              LDR      r0,[r4,#0]
00015c  68c0              LDR      r0,[r0,#0xc]
00015e  f3c010c0          UBFX     r0,r0,#7,#1
000162  b130              CBZ      r0,|L45.370|
;;;3170       {
;;;3171         __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
000164  f06f0080          MVN      r0,#0x80
000168  6821              LDR      r1,[r4,#0]
00016a  6108              STR      r0,[r1,#0x10]
;;;3172   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3173         htim->BreakCallback(htim);
;;;3174   #else
;;;3175         HAL_TIMEx_BreakCallback(htim);
00016c  4620              MOV      r0,r4
00016e  f7fffffe          BL       HAL_TIMEx_BreakCallback
                  |L45.370|
;;;3176   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3177       }
;;;3178     }
;;;3179   
;;;3180     /* TIM Trigger detection event */
;;;3181     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
000172  6820              LDR      r0,[r4,#0]
000174  6900              LDR      r0,[r0,#0x10]
000176  f3c01080          UBFX     r0,r0,#6,#1
00017a  b158              CBZ      r0,|L45.404|
;;;3182     {
;;;3183       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) !=RESET)
00017c  6820              LDR      r0,[r4,#0]
00017e  68c0              LDR      r0,[r0,#0xc]
000180  f3c01080          UBFX     r0,r0,#6,#1
000184  b130              CBZ      r0,|L45.404|
;;;3184       {
;;;3185         __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
000186  f06f0040          MVN      r0,#0x40
00018a  6821              LDR      r1,[r4,#0]
00018c  6108              STR      r0,[r1,#0x10]
;;;3186   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3187         htim->TriggerCallback(htim);
;;;3188   #else
;;;3189         HAL_TIM_TriggerCallback(htim);
00018e  4620              MOV      r0,r4
000190  f7fffffe          BL       HAL_TIM_TriggerCallback
                  |L45.404|
;;;3190   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3191       }
;;;3192     }
;;;3193     /* TIM commutation event */
;;;3194     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
000194  6820              LDR      r0,[r4,#0]
000196  6900              LDR      r0,[r0,#0x10]
000198  f3c01040          UBFX     r0,r0,#5,#1
00019c  b158              CBZ      r0,|L45.438|
;;;3195     {
;;;3196       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) !=RESET)
00019e  6820              LDR      r0,[r4,#0]
0001a0  68c0              LDR      r0,[r0,#0xc]
0001a2  f3c01040          UBFX     r0,r0,#5,#1
0001a6  b130              CBZ      r0,|L45.438|
;;;3197       {
;;;3198         __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
0001a8  f06f0020          MVN      r0,#0x20
0001ac  6821              LDR      r1,[r4,#0]
0001ae  6108              STR      r0,[r1,#0x10]
;;;3199   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;3200         htim->CommutationCallback(htim);
;;;3201   #else
;;;3202         HAL_TIMEx_CommutationCallback(htim);
0001b0  4620              MOV      r0,r4
0001b2  f7fffffe          BL       HAL_TIMEx_CommutationCallback
                  |L45.438|
;;;3203   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;3204       }
;;;3205     }
;;;3206   }
0001b6  bd10              POP      {r4,pc}
;;;3207   
                          ENDP


                          AREA ||i.HAL_TIM_OC_ConfigChannel||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_ConfigChannel PROC
;;;3244     */
;;;3245   __weak HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;3246   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;3247     /* Check the parameters */ 
;;;3248     assert_param(IS_TIM_CHANNELS(Channel)); 
;;;3249     assert_param(IS_TIM_OC_MODE(sConfig->OCMode));
;;;3250     assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
;;;3251     
;;;3252     /* Check input state */
;;;3253     __HAL_LOCK(htim); 
000008  bf00              NOP      
00000a  6be0              LDR      r0,[r4,#0x3c]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L46.20|
000010  2002              MOVS     r0,#2
                  |L46.18|
;;;3254     
;;;3255     htim->State = HAL_TIM_STATE_BUSY;
;;;3256     
;;;3257     switch (Channel)
;;;3258     {
;;;3259       case TIM_CHANNEL_1:
;;;3260       {
;;;3261         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3262         /* Configure the TIM Channel 1 in Output Compare */
;;;3263         TIM_OC1_SetConfig(htim->Instance, sConfig);
;;;3264       }
;;;3265       break;
;;;3266       
;;;3267       case TIM_CHANNEL_2:
;;;3268       {
;;;3269         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3270         /* Configure the TIM Channel 2 in Output Compare */
;;;3271         TIM_OC2_SetConfig(htim->Instance, sConfig);
;;;3272       }
;;;3273       break;
;;;3274       
;;;3275       case TIM_CHANNEL_3:
;;;3276       {
;;;3277          assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3278         /* Configure the TIM Channel 3 in Output Compare */
;;;3279         TIM_OC3_SetConfig(htim->Instance, sConfig);
;;;3280       }
;;;3281       break;
;;;3282       
;;;3283       case TIM_CHANNEL_4:
;;;3284       {
;;;3285         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3286         /* Configure the TIM Channel 4 in Output Compare */
;;;3287         TIM_OC4_SetConfig(htim->Instance, sConfig);
;;;3288       }
;;;3289       break;
;;;3290       
;;;3291       default:
;;;3292       break;    
;;;3293     }
;;;3294     htim->State = HAL_TIM_STATE_READY;
;;;3295     
;;;3296     __HAL_UNLOCK(htim); 
;;;3297     
;;;3298     return HAL_OK;
;;;3299   }
000012  bd70              POP      {r4-r6,pc}
                  |L46.20|
000014  2001              MOVS     r0,#1                 ;3253
000016  63e0              STR      r0,[r4,#0x3c]         ;3253
000018  bf00              NOP                            ;3253
00001a  2002              MOVS     r0,#2                 ;3255
00001c  6420              STR      r0,[r4,#0x40]         ;3255
00001e  b135              CBZ      r5,|L46.46|
000020  2d04              CMP      r5,#4                 ;3257
000022  d009              BEQ      |L46.56|
000024  2d08              CMP      r5,#8                 ;3257
000026  d00c              BEQ      |L46.66|
000028  2d0c              CMP      r5,#0xc               ;3257
00002a  d114              BNE      |L46.86|
00002c  e00e              B        |L46.76|
                  |L46.46|
00002e  4631              MOV      r1,r6                 ;3263
000030  6820              LDR      r0,[r4,#0]            ;3263
000032  f7fffffe          BL       TIM_OC1_SetConfig
000036  e00f              B        |L46.88|
                  |L46.56|
000038  4631              MOV      r1,r6                 ;3271
00003a  6820              LDR      r0,[r4,#0]            ;3271
00003c  f7fffffe          BL       TIM_OC2_SetConfig
000040  e00a              B        |L46.88|
                  |L46.66|
000042  4631              MOV      r1,r6                 ;3279
000044  6820              LDR      r0,[r4,#0]            ;3279
000046  f7fffffe          BL       TIM_OC3_SetConfig
00004a  e005              B        |L46.88|
                  |L46.76|
00004c  4631              MOV      r1,r6                 ;3287
00004e  6820              LDR      r0,[r4,#0]            ;3287
000050  f7fffffe          BL       TIM_OC4_SetConfig
000054  e000              B        |L46.88|
                  |L46.86|
000056  bf00              NOP                            ;3292
                  |L46.88|
000058  bf00              NOP                            ;3265
00005a  2001              MOVS     r0,#1                 ;3294
00005c  6420              STR      r0,[r4,#0x40]         ;3294
00005e  bf00              NOP                            ;3296
000060  2000              MOVS     r0,#0                 ;3296
000062  63e0              STR      r0,[r4,#0x3c]         ;3296
000064  bf00              NOP                            ;3296
000066  bf00              NOP                            ;3298
000068  e7d3              B        |L46.18|
;;;3300   
                          ENDP


                          AREA ||i.HAL_TIM_OC_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_DeInit PROC
;;;615      */
;;;616    HAL_StatusTypeDef HAL_TIM_OC_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;617    {
000002  4604              MOV      r4,r0
;;;618      /* Check the parameters */
;;;619      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;620      
;;;621       htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  6420              STR      r0,[r4,#0x40]
;;;622       
;;;623      /* Disable the TIM Peripheral Clock */
;;;624      __HAL_TIM_DISABLE(htim);
000008  bf00              NOP      
00000a  6820              LDR      r0,[r4,#0]
00000c  6a00              LDR      r0,[r0,#0x20]
00000e  f2411111          MOV      r1,#0x1111
000012  4008              ANDS     r0,r0,r1
000014  b950              CBNZ     r0,|L47.44|
000016  6820              LDR      r0,[r4,#0]
000018  6a00              LDR      r0,[r0,#0x20]
00001a  1089              ASRS     r1,r1,#2
00001c  4008              ANDS     r0,r0,r1
00001e  b928              CBNZ     r0,|L47.44|
000020  6820              LDR      r0,[r4,#0]
000022  6800              LDR      r0,[r0,#0]
000024  f0200001          BIC      r0,r0,#1
000028  6821              LDR      r1,[r4,#0]
00002a  6008              STR      r0,[r1,#0]
                  |L47.44|
00002c  bf00              NOP      
;;;625    
;;;626    #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;627      if(htim->OC_MspDeInitCallback == NULL)
;;;628      {
;;;629        htim->OC_MspDeInitCallback = HAL_TIM_OC_MspDeInit;
;;;630      }
;;;631      /* DeInit the low level hardware */
;;;632      htim->OC_MspDeInitCallback(htim);
;;;633    #else
;;;634      /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;635      HAL_TIM_OC_MspDeInit(htim);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       HAL_TIM_OC_MspDeInit
;;;636    #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;637    
;;;638      /* Change TIM state */  
;;;639      htim->State = HAL_TIM_STATE_RESET; 
000034  2000              MOVS     r0,#0
000036  6420              STR      r0,[r4,#0x40]
;;;640    
;;;641      /* Release Lock */
;;;642      __HAL_UNLOCK(htim);
000038  bf00              NOP      
00003a  63e0              STR      r0,[r4,#0x3c]
00003c  bf00              NOP      
;;;643    
;;;644      return HAL_OK;
;;;645    }
00003e  bd10              POP      {r4,pc}
;;;646    
                          ENDP


                          AREA ||i.HAL_TIM_OC_DelayElapsedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_DelayElapsedCallback PROC
;;;4704     */
;;;4705   __weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4706   {
;;;4707     /* Prevent unused argument(s) compilation warning */
;;;4708     UNUSED(htim);
;;;4709    
;;;4710     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4711               the __HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
;;;4712      */
;;;4713   }
;;;4714   /**
                          ENDP


                          AREA ||i.HAL_TIM_OC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_GetState PROC
;;;5245     */
;;;5246   HAL_TIM_StateTypeDef HAL_TIM_OC_GetState(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;5247   {
;;;5248     return htim->State;
000002  6c08              LDR      r0,[r1,#0x40]
;;;5249   }
000004  4770              BX       lr
;;;5250   
                          ENDP


                          AREA ||i.HAL_TIM_OC_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_Init PROC
;;;563      */
;;;564    HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef* htim)
000000  b510              PUSH     {r4,lr}
;;;565    {
000002  4604              MOV      r4,r0
;;;566      /* Check the TIM handle allocation */
;;;567      if(htim == NULL)
000004  b90c              CBNZ     r4,|L50.10|
;;;568      {
;;;569        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L50.8|
;;;570      }
;;;571    
;;;572      /* Check the parameters */
;;;573      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;574      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;575      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;576      assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;577    
;;;578      if(htim->State == HAL_TIM_STATE_RESET)
;;;579      {
;;;580        /* Allocate lock resource and initialize it */
;;;581        htim->Lock = HAL_UNLOCKED;
;;;582    
;;;583    #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;584        /* Reset interrupt callbacks to legacy week callbacks */
;;;585        TIM_ResetCallback(htim);
;;;586    
;;;587        if(htim->OC_MspInitCallback == NULL)
;;;588        {
;;;589          htim->OC_MspInitCallback = HAL_TIM_OC_MspDeInit;
;;;590        }
;;;591        /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;592        htim->OC_MspInitCallback(htim);
;;;593    #else
;;;594        /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;595        HAL_TIM_OC_MspInit(htim);
;;;596    #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;597      }
;;;598      /* Set the TIM state */
;;;599      htim->State= HAL_TIM_STATE_BUSY;
;;;600      
;;;601      /* Init the base time for the Output Compare */  
;;;602      TIM_Base_SetConfig(htim->Instance,  &htim->Init); 
;;;603      
;;;604      /* Initialize the TIM state*/
;;;605      htim->State= HAL_TIM_STATE_READY;
;;;606      
;;;607      return HAL_OK;
;;;608    }
000008  bd10              POP      {r4,pc}
                  |L50.10|
00000a  6c20              LDR      r0,[r4,#0x40]         ;578
00000c  b920              CBNZ     r0,|L50.24|
00000e  2000              MOVS     r0,#0                 ;581
000010  63e0              STR      r0,[r4,#0x3c]         ;581
000012  4620              MOV      r0,r4                 ;595
000014  f7fffffe          BL       HAL_TIM_OC_MspInit
                  |L50.24|
000018  2002              MOVS     r0,#2                 ;599
00001a  6420              STR      r0,[r4,#0x40]         ;599
00001c  1d21              ADDS     r1,r4,#4              ;602
00001e  6820              LDR      r0,[r4,#0]            ;602
000020  f7fffffe          BL       TIM_Base_SetConfig
000024  2001              MOVS     r0,#1                 ;605
000026  6420              STR      r0,[r4,#0x40]         ;605
000028  2000              MOVS     r0,#0                 ;607
00002a  e7ed              B        |L50.8|
;;;609    
                          ENDP


                          AREA ||i.HAL_TIM_OC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_MspDeInit PROC
;;;668      */
;;;669    __weak void HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;670    {
;;;671      /* Prevent unused argument(s) compilation warning */
;;;672      UNUSED(htim);
;;;673     
;;;674      /* NOTE : This function Should not be modified, when the callback is needed,
;;;675                the HAL_TIM_OC_MspDeInit could be implemented in the user file
;;;676       */
;;;677    }
;;;678    
                          ENDP


                          AREA ||i.HAL_TIM_OC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OC_MspInit PROC
;;;652      */
;;;653    __weak void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;654    {
;;;655      /* Prevent unused argument(s) compilation warning */
;;;656      UNUSED(htim);
;;;657     
;;;658      /* NOTE : This function Should not be modified, when the callback is needed,
;;;659                the HAL_TIM_OC_MspInit could be implemented in the user file
;;;660       */
;;;661    }
;;;662    
                          ENDP


                          AREA ||i.HAL_TIM_OC_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Start PROC
;;;690      */
;;;691    HAL_StatusTypeDef HAL_TIM_OC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;692    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;693      /* Check the parameters */
;;;694      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;695      
;;;696      /* Enable the Output compare channel */
;;;697      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000006  2201              MOVS     r2,#1
000008  4629              MOV      r1,r5
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxChannelCmd
;;;698      
;;;699      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000010  490c              LDR      r1,|L53.68|
000012  6820              LDR      r0,[r4,#0]
000014  4288              CMP      r0,r1
000016  d003              BEQ      |L53.32|
000018  490b              LDR      r1,|L53.72|
00001a  6820              LDR      r0,[r4,#0]
00001c  4288              CMP      r0,r1
00001e  d101              BNE      |L53.36|
                  |L53.32|
000020  2001              MOVS     r0,#1
000022  e000              B        |L53.38|
                  |L53.36|
000024  2000              MOVS     r0,#0
                  |L53.38|
000026  b128              CBZ      r0,|L53.52|
;;;700      {
;;;701        /* Enable the main output */
;;;702        __HAL_TIM_MOE_ENABLE(htim);
000028  6820              LDR      r0,[r4,#0]
00002a  6c40              LDR      r0,[r0,#0x44]
00002c  f4404000          ORR      r0,r0,#0x8000
000030  6821              LDR      r1,[r4,#0]
000032  6448              STR      r0,[r1,#0x44]
                  |L53.52|
;;;703      }
;;;704      
;;;705      /* Enable the Peripheral */
;;;706      __HAL_TIM_ENABLE(htim); 
000034  6820              LDR      r0,[r4,#0]
000036  6800              LDR      r0,[r0,#0]
000038  f0400001          ORR      r0,r0,#1
00003c  6821              LDR      r1,[r4,#0]
00003e  6008              STR      r0,[r1,#0]
;;;707      
;;;708      /* Return function status */
;;;709      return HAL_OK;
000040  2000              MOVS     r0,#0
;;;710    }
000042  bd30              POP      {r4,r5,pc}
;;;711    
                          ENDP

                  |L53.68|
                          DCD      0x40010000
                  |L53.72|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OC_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Start_DMA PROC
;;;892      */
;;;893    HAL_StatusTypeDef HAL_TIM_OC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;894    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
00000a  461f              MOV      r7,r3
;;;895      /* Check the parameters */
;;;896      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;897      
;;;898      if((htim->State == HAL_TIM_STATE_BUSY))
00000c  6c20              LDR      r0,[r4,#0x40]
00000e  2802              CMP      r0,#2
000010  d101              BNE      |L54.22|
                  |L54.18|
;;;899      {
;;;900         return HAL_BUSY;
;;;901      }
;;;902      else if((htim->State == HAL_TIM_STATE_READY))
;;;903      {
;;;904        if(((uint32_t)pData == 0 ) && (Length > 0)) 
;;;905        {
;;;906          return HAL_ERROR;                                    
;;;907        }
;;;908        else
;;;909        {
;;;910          htim->State = HAL_TIM_STATE_BUSY;
;;;911        }
;;;912      }    
;;;913      switch (Channel)
;;;914      {
;;;915        case TIM_CHANNEL_1:
;;;916        {      
;;;917          /* Set the DMA Period elapsed callback */
;;;918          htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;919         
;;;920          /* Set the DMA error callback */
;;;921          htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
;;;922          
;;;923          /* Enable the DMA Stream */
;;;924          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
;;;925          
;;;926          /* Enable the TIM Capture/Compare 1 DMA request */
;;;927          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;928        }
;;;929        break;
;;;930        
;;;931        case TIM_CHANNEL_2:
;;;932        {
;;;933          /* Set the DMA Period elapsed callback */
;;;934          htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;935         
;;;936          /* Set the DMA error callback */
;;;937          htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
;;;938          
;;;939          /* Enable the DMA Stream */
;;;940          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
;;;941          
;;;942          /* Enable the TIM Capture/Compare 2 DMA request */
;;;943          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;944        }
;;;945        break;
;;;946        
;;;947        case TIM_CHANNEL_3:
;;;948        {
;;;949          /* Set the DMA Period elapsed callback */
;;;950          htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;951         
;;;952          /* Set the DMA error callback */
;;;953          htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
;;;954          
;;;955          /* Enable the DMA Stream */
;;;956          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
;;;957          
;;;958          /* Enable the TIM Capture/Compare 3 DMA request */
;;;959          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;960        }
;;;961        break;
;;;962        
;;;963        case TIM_CHANNEL_4:
;;;964        {
;;;965         /* Set the DMA Period elapsed callback */
;;;966          htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;967         
;;;968          /* Set the DMA error callback */
;;;969          htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
;;;970          
;;;971          /* Enable the DMA Stream */
;;;972          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
;;;973          
;;;974          /* Enable the TIM Capture/Compare 4 DMA request */
;;;975          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;976        }
;;;977        break;
;;;978        
;;;979        default:
;;;980        break;
;;;981      }
;;;982    
;;;983      /* Enable the Output compare channel */
;;;984      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;985      
;;;986      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
;;;987      {
;;;988        /* Enable the main output */
;;;989        __HAL_TIM_MOE_ENABLE(htim);
;;;990      }  
;;;991      
;;;992      /* Enable the Peripheral */
;;;993      __HAL_TIM_ENABLE(htim); 
;;;994      
;;;995      /* Return function status */
;;;996      return HAL_OK;
;;;997    }
000012  e8bd81f0          POP      {r4-r8,pc}
                  |L54.22|
000016  6c20              LDR      r0,[r4,#0x40]         ;902
000018  2801              CMP      r0,#1                 ;902
00001a  d105              BNE      |L54.40|
00001c  b915              CBNZ     r5,|L54.36|
00001e  2f00              CMP      r7,#0                 ;904
000020  dd00              BLE      |L54.36|
000022  e7f6              B        |L54.18|
                  |L54.36|
000024  2002              MOVS     r0,#2                 ;910
000026  6420              STR      r0,[r4,#0x40]         ;910
                  |L54.40|
000028  b136              CBZ      r6,|L54.56|
00002a  2e04              CMP      r6,#4                 ;913
00002c  d019              BEQ      |L54.98|
00002e  2e08              CMP      r6,#8                 ;913
000030  d02c              BEQ      |L54.140|
000032  2e0c              CMP      r6,#0xc               ;913
000034  d154              BNE      |L54.224|
000036  e03e              B        |L54.182|
                  |L54.56|
000038  493a              LDR      r1,|L54.292|
00003a  6a60              LDR      r0,[r4,#0x24]         ;918
00003c  6401              STR      r1,[r0,#0x40]         ;918
00003e  493a              LDR      r1,|L54.296|
000040  6a60              LDR      r0,[r4,#0x24]         ;921
000042  6501              STR      r1,[r0,#0x50]         ;921
000044  6821              LDR      r1,[r4,#0]            ;924
000046  f1010234          ADD      r2,r1,#0x34           ;924
00004a  463b              MOV      r3,r7                 ;924
00004c  4629              MOV      r1,r5                 ;924
00004e  6a60              LDR      r0,[r4,#0x24]         ;924
000050  f7fffffe          BL       HAL_DMA_Start_IT
000054  6820              LDR      r0,[r4,#0]            ;927
000056  68c0              LDR      r0,[r0,#0xc]          ;927
000058  f4407000          ORR      r0,r0,#0x200          ;927
00005c  6821              LDR      r1,[r4,#0]            ;927
00005e  60c8              STR      r0,[r1,#0xc]          ;927
000060  e03f              B        |L54.226|
                  |L54.98|
000062  4930              LDR      r1,|L54.292|
000064  6aa0              LDR      r0,[r4,#0x28]         ;934
000066  6401              STR      r1,[r0,#0x40]         ;934
000068  492f              LDR      r1,|L54.296|
00006a  6aa0              LDR      r0,[r4,#0x28]         ;937
00006c  6501              STR      r1,[r0,#0x50]         ;937
00006e  6821              LDR      r1,[r4,#0]            ;940
000070  f1010238          ADD      r2,r1,#0x38           ;940
000074  463b              MOV      r3,r7                 ;940
000076  4629              MOV      r1,r5                 ;940
000078  6aa0              LDR      r0,[r4,#0x28]         ;940
00007a  f7fffffe          BL       HAL_DMA_Start_IT
00007e  6820              LDR      r0,[r4,#0]            ;943
000080  68c0              LDR      r0,[r0,#0xc]          ;943
000082  f4406080          ORR      r0,r0,#0x400          ;943
000086  6821              LDR      r1,[r4,#0]            ;943
000088  60c8              STR      r0,[r1,#0xc]          ;943
00008a  e02a              B        |L54.226|
                  |L54.140|
00008c  4925              LDR      r1,|L54.292|
00008e  6ae0              LDR      r0,[r4,#0x2c]         ;950
000090  6401              STR      r1,[r0,#0x40]         ;950
000092  4925              LDR      r1,|L54.296|
000094  6ae0              LDR      r0,[r4,#0x2c]         ;953
000096  6501              STR      r1,[r0,#0x50]         ;953
000098  6821              LDR      r1,[r4,#0]            ;956
00009a  f101023c          ADD      r2,r1,#0x3c           ;956
00009e  463b              MOV      r3,r7                 ;956
0000a0  4629              MOV      r1,r5                 ;956
0000a2  6ae0              LDR      r0,[r4,#0x2c]         ;956
0000a4  f7fffffe          BL       HAL_DMA_Start_IT
0000a8  6820              LDR      r0,[r4,#0]            ;959
0000aa  68c0              LDR      r0,[r0,#0xc]          ;959
0000ac  f4406000          ORR      r0,r0,#0x800          ;959
0000b0  6821              LDR      r1,[r4,#0]            ;959
0000b2  60c8              STR      r0,[r1,#0xc]          ;959
0000b4  e015              B        |L54.226|
                  |L54.182|
0000b6  491b              LDR      r1,|L54.292|
0000b8  6b20              LDR      r0,[r4,#0x30]         ;966
0000ba  6401              STR      r1,[r0,#0x40]         ;966
0000bc  491a              LDR      r1,|L54.296|
0000be  6b20              LDR      r0,[r4,#0x30]         ;969
0000c0  6501              STR      r1,[r0,#0x50]         ;969
0000c2  6821              LDR      r1,[r4,#0]            ;972
0000c4  f1010240          ADD      r2,r1,#0x40           ;972
0000c8  463b              MOV      r3,r7                 ;972
0000ca  4629              MOV      r1,r5                 ;972
0000cc  6b20              LDR      r0,[r4,#0x30]         ;972
0000ce  f7fffffe          BL       HAL_DMA_Start_IT
0000d2  6820              LDR      r0,[r4,#0]            ;975
0000d4  68c0              LDR      r0,[r0,#0xc]          ;975
0000d6  f4405080          ORR      r0,r0,#0x1000         ;975
0000da  6821              LDR      r1,[r4,#0]            ;975
0000dc  60c8              STR      r0,[r1,#0xc]          ;975
0000de  e000              B        |L54.226|
                  |L54.224|
0000e0  bf00              NOP                            ;980
                  |L54.226|
0000e2  bf00              NOP                            ;929
0000e4  2201              MOVS     r2,#1                 ;984
0000e6  4631              MOV      r1,r6                 ;984
0000e8  6820              LDR      r0,[r4,#0]            ;984
0000ea  f7fffffe          BL       TIM_CCxChannelCmd
0000ee  490f              LDR      r1,|L54.300|
0000f0  6820              LDR      r0,[r4,#0]            ;986
0000f2  4288              CMP      r0,r1                 ;986
0000f4  d003              BEQ      |L54.254|
0000f6  490e              LDR      r1,|L54.304|
0000f8  6820              LDR      r0,[r4,#0]            ;986
0000fa  4288              CMP      r0,r1                 ;986
0000fc  d101              BNE      |L54.258|
                  |L54.254|
0000fe  2001              MOVS     r0,#1                 ;986
000100  e000              B        |L54.260|
                  |L54.258|
000102  2000              MOVS     r0,#0                 ;986
                  |L54.260|
000104  b128              CBZ      r0,|L54.274|
000106  6820              LDR      r0,[r4,#0]            ;989
000108  6c40              LDR      r0,[r0,#0x44]         ;989
00010a  f4404000          ORR      r0,r0,#0x8000         ;989
00010e  6821              LDR      r1,[r4,#0]            ;989
000110  6448              STR      r0,[r1,#0x44]         ;989
                  |L54.274|
000112  6820              LDR      r0,[r4,#0]            ;993
000114  6800              LDR      r0,[r0,#0]            ;993
000116  f0400001          ORR      r0,r0,#1              ;993
00011a  6821              LDR      r1,[r4,#0]            ;993
00011c  6008              STR      r0,[r1,#0]            ;993
00011e  2000              MOVS     r0,#0                 ;996
000120  e777              B        |L54.18|
;;;998    
                          ENDP

000122  0000              DCW      0x0000
                  |L54.292|
                          DCD      TIM_DMADelayPulseCplt
                  |L54.296|
                          DCD      TIM_DMAError
                  |L54.300|
                          DCD      0x40010000
                  |L54.304|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OC_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Start_IT PROC
;;;756      */
;;;757    HAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;758    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;759      /* Check the parameters */
;;;760      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;761      
;;;762      switch (Channel)
000006  b135              CBZ      r5,|L55.22|
000008  2d04              CMP      r5,#4
00000a  d00b              BEQ      |L55.36|
00000c  2d08              CMP      r5,#8
00000e  d010              BEQ      |L55.50|
000010  2d0c              CMP      r5,#0xc
000012  d11c              BNE      |L55.78|
000014  e014              B        |L55.64|
                  |L55.22|
;;;763      {
;;;764        case TIM_CHANNEL_1:
;;;765        {       
;;;766          /* Enable the TIM Capture/Compare 1 interrupt */
;;;767          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000016  6820              LDR      r0,[r4,#0]
000018  68c0              LDR      r0,[r0,#0xc]
00001a  f0400002          ORR      r0,r0,#2
00001e  6821              LDR      r1,[r4,#0]
000020  60c8              STR      r0,[r1,#0xc]
;;;768        }
;;;769        break;
000022  e015              B        |L55.80|
                  |L55.36|
;;;770        
;;;771        case TIM_CHANNEL_2:
;;;772        {
;;;773          /* Enable the TIM Capture/Compare 2 interrupt */
;;;774          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000024  6820              LDR      r0,[r4,#0]
000026  68c0              LDR      r0,[r0,#0xc]
000028  f0400004          ORR      r0,r0,#4
00002c  6821              LDR      r1,[r4,#0]
00002e  60c8              STR      r0,[r1,#0xc]
;;;775        }
;;;776        break;
000030  e00e              B        |L55.80|
                  |L55.50|
;;;777        
;;;778        case TIM_CHANNEL_3:
;;;779        {
;;;780          /* Enable the TIM Capture/Compare 3 interrupt */
;;;781          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
000032  6820              LDR      r0,[r4,#0]
000034  68c0              LDR      r0,[r0,#0xc]
000036  f0400008          ORR      r0,r0,#8
00003a  6821              LDR      r1,[r4,#0]
00003c  60c8              STR      r0,[r1,#0xc]
;;;782        }
;;;783        break;
00003e  e007              B        |L55.80|
                  |L55.64|
;;;784        
;;;785        case TIM_CHANNEL_4:
;;;786        {
;;;787          /* Enable the TIM Capture/Compare 4 interrupt */
;;;788          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
000040  6820              LDR      r0,[r4,#0]
000042  68c0              LDR      r0,[r0,#0xc]
000044  f0400010          ORR      r0,r0,#0x10
000048  6821              LDR      r1,[r4,#0]
00004a  60c8              STR      r0,[r1,#0xc]
;;;789        }
;;;790        break;
00004c  e000              B        |L55.80|
                  |L55.78|
;;;791        
;;;792        default:
;;;793        break;
00004e  bf00              NOP      
                  |L55.80|
000050  bf00              NOP                            ;769
;;;794      } 
;;;795    
;;;796      /* Enable the Output compare channel */
;;;797      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000052  2201              MOVS     r2,#1
000054  4629              MOV      r1,r5
000056  6820              LDR      r0,[r4,#0]
000058  f7fffffe          BL       TIM_CCxChannelCmd
;;;798      
;;;799      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00005c  490c              LDR      r1,|L55.144|
00005e  6820              LDR      r0,[r4,#0]
000060  4288              CMP      r0,r1
000062  d003              BEQ      |L55.108|
000064  490b              LDR      r1,|L55.148|
000066  6820              LDR      r0,[r4,#0]
000068  4288              CMP      r0,r1
00006a  d101              BNE      |L55.112|
                  |L55.108|
00006c  2001              MOVS     r0,#1
00006e  e000              B        |L55.114|
                  |L55.112|
000070  2000              MOVS     r0,#0
                  |L55.114|
000072  b128              CBZ      r0,|L55.128|
;;;800      {
;;;801        /* Enable the main output */
;;;802        __HAL_TIM_MOE_ENABLE(htim);
000074  6820              LDR      r0,[r4,#0]
000076  6c40              LDR      r0,[r0,#0x44]
000078  f4404000          ORR      r0,r0,#0x8000
00007c  6821              LDR      r1,[r4,#0]
00007e  6448              STR      r0,[r1,#0x44]
                  |L55.128|
;;;803      }
;;;804    
;;;805      /* Enable the Peripheral */
;;;806      __HAL_TIM_ENABLE(htim);
000080  6820              LDR      r0,[r4,#0]
000082  6800              LDR      r0,[r0,#0]
000084  f0400001          ORR      r0,r0,#1
000088  6821              LDR      r1,[r4,#0]
00008a  6008              STR      r0,[r1,#0]
;;;807      
;;;808      /* Return function status */
;;;809      return HAL_OK;
00008c  2000              MOVS     r0,#0
;;;810    }
00008e  bd30              POP      {r4,r5,pc}
;;;811    
                          ENDP

                  |L55.144|
                          DCD      0x40010000
                  |L55.148|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OC_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Stop PROC
;;;723      */
;;;724    HAL_StatusTypeDef HAL_TIM_OC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;725    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;726      /* Check the parameters */
;;;727      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;728      
;;;729      /* Disable the Output compare channel */
;;;730      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000006  2200              MOVS     r2,#0
000008  4629              MOV      r1,r5
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxChannelCmd
;;;731      
;;;732      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000010  4919              LDR      r1,|L56.120|
000012  6820              LDR      r0,[r4,#0]
000014  4288              CMP      r0,r1
000016  d003              BEQ      |L56.32|
000018  4918              LDR      r1,|L56.124|
00001a  6820              LDR      r0,[r4,#0]
00001c  4288              CMP      r0,r1
00001e  d101              BNE      |L56.36|
                  |L56.32|
000020  2001              MOVS     r0,#1
000022  e000              B        |L56.38|
                  |L56.36|
000024  2000              MOVS     r0,#0
                  |L56.38|
000026  b190              CBZ      r0,|L56.78|
;;;733      {
;;;734        /* Disable the Main Output */
;;;735        __HAL_TIM_MOE_DISABLE(htim);
000028  bf00              NOP      
00002a  6820              LDR      r0,[r4,#0]
00002c  6a00              LDR      r0,[r0,#0x20]
00002e  f2411111          MOV      r1,#0x1111
000032  4008              ANDS     r0,r0,r1
000034  b950              CBNZ     r0,|L56.76|
000036  6820              LDR      r0,[r4,#0]
000038  6a00              LDR      r0,[r0,#0x20]
00003a  1089              ASRS     r1,r1,#2
00003c  4008              ANDS     r0,r0,r1
00003e  b928              CBNZ     r0,|L56.76|
000040  6820              LDR      r0,[r4,#0]
000042  6c40              LDR      r0,[r0,#0x44]
000044  f4204000          BIC      r0,r0,#0x8000
000048  6821              LDR      r1,[r4,#0]
00004a  6448              STR      r0,[r1,#0x44]
                  |L56.76|
00004c  bf00              NOP      
                  |L56.78|
;;;736      }  
;;;737      
;;;738      /* Disable the Peripheral */
;;;739      __HAL_TIM_DISABLE(htim);  
00004e  bf00              NOP      
000050  6820              LDR      r0,[r4,#0]
000052  6a00              LDR      r0,[r0,#0x20]
000054  f2411111          MOV      r1,#0x1111
000058  4008              ANDS     r0,r0,r1
00005a  b950              CBNZ     r0,|L56.114|
00005c  6820              LDR      r0,[r4,#0]
00005e  6a00              LDR      r0,[r0,#0x20]
000060  1089              ASRS     r1,r1,#2
000062  4008              ANDS     r0,r0,r1
000064  b928              CBNZ     r0,|L56.114|
000066  6820              LDR      r0,[r4,#0]
000068  6800              LDR      r0,[r0,#0]
00006a  f0200001          BIC      r0,r0,#1
00006e  6821              LDR      r1,[r4,#0]
000070  6008              STR      r0,[r1,#0]
                  |L56.114|
000072  bf00              NOP      
;;;740      
;;;741      /* Return function status */
;;;742      return HAL_OK;
000074  2000              MOVS     r0,#0
;;;743    }  
000076  bd30              POP      {r4,r5,pc}
;;;744    
                          ENDP

                  |L56.120|
                          DCD      0x40010000
                  |L56.124|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OC_Stop_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Stop_DMA PROC
;;;1010     */
;;;1011   HAL_StatusTypeDef HAL_TIM_OC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1012   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1013     /* Check the parameters */
;;;1014     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1015     
;;;1016     switch (Channel)
000006  b135              CBZ      r5,|L57.22|
000008  2d04              CMP      r5,#4
00000a  d00b              BEQ      |L57.36|
00000c  2d08              CMP      r5,#8
00000e  d010              BEQ      |L57.50|
000010  2d0c              CMP      r5,#0xc
000012  d11c              BNE      |L57.78|
000014  e014              B        |L57.64|
                  |L57.22|
;;;1017     {
;;;1018       case TIM_CHANNEL_1:
;;;1019       {       
;;;1020         /* Disable the TIM Capture/Compare 1 DMA request */
;;;1021         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000016  6820              LDR      r0,[r4,#0]
000018  68c0              LDR      r0,[r0,#0xc]
00001a  f4207000          BIC      r0,r0,#0x200
00001e  6821              LDR      r1,[r4,#0]
000020  60c8              STR      r0,[r1,#0xc]
;;;1022       }
;;;1023       break;
000022  e015              B        |L57.80|
                  |L57.36|
;;;1024       
;;;1025       case TIM_CHANNEL_2:
;;;1026       {
;;;1027         /* Disable the TIM Capture/Compare 2 DMA request */
;;;1028         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000024  6820              LDR      r0,[r4,#0]
000026  68c0              LDR      r0,[r0,#0xc]
000028  f4206080          BIC      r0,r0,#0x400
00002c  6821              LDR      r1,[r4,#0]
00002e  60c8              STR      r0,[r1,#0xc]
;;;1029       }
;;;1030       break;
000030  e00e              B        |L57.80|
                  |L57.50|
;;;1031       
;;;1032       case TIM_CHANNEL_3:
;;;1033       {
;;;1034         /* Disable the TIM Capture/Compare 3 DMA request */
;;;1035         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
000032  6820              LDR      r0,[r4,#0]
000034  68c0              LDR      r0,[r0,#0xc]
000036  f4206000          BIC      r0,r0,#0x800
00003a  6821              LDR      r1,[r4,#0]
00003c  60c8              STR      r0,[r1,#0xc]
;;;1036       }
;;;1037       break;
00003e  e007              B        |L57.80|
                  |L57.64|
;;;1038       
;;;1039       case TIM_CHANNEL_4:
;;;1040       {
;;;1041         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1042         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
000040  6820              LDR      r0,[r4,#0]
000042  68c0              LDR      r0,[r0,#0xc]
000044  f4205080          BIC      r0,r0,#0x1000
000048  6821              LDR      r1,[r4,#0]
00004a  60c8              STR      r0,[r1,#0xc]
;;;1043       }
;;;1044       break;
00004c  e000              B        |L57.80|
                  |L57.78|
;;;1045       
;;;1046       default:
;;;1047       break;
00004e  bf00              NOP      
                  |L57.80|
000050  bf00              NOP                            ;1023
;;;1048     } 
;;;1049     
;;;1050     /* Disable the Output compare channel */
;;;1051     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000052  2200              MOVS     r2,#0
000054  4629              MOV      r1,r5
000056  6820              LDR      r0,[r4,#0]
000058  f7fffffe          BL       TIM_CCxChannelCmd
;;;1052     
;;;1053     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00005c  491a              LDR      r1,|L57.200|
00005e  6820              LDR      r0,[r4,#0]
000060  4288              CMP      r0,r1
000062  d003              BEQ      |L57.108|
000064  4919              LDR      r1,|L57.204|
000066  6820              LDR      r0,[r4,#0]
000068  4288              CMP      r0,r1
00006a  d101              BNE      |L57.112|
                  |L57.108|
00006c  2001              MOVS     r0,#1
00006e  e000              B        |L57.114|
                  |L57.112|
000070  2000              MOVS     r0,#0
                  |L57.114|
000072  b190              CBZ      r0,|L57.154|
;;;1054     {
;;;1055       /* Disable the Main Output */
;;;1056       __HAL_TIM_MOE_DISABLE(htim);
000074  bf00              NOP      
000076  6820              LDR      r0,[r4,#0]
000078  6a00              LDR      r0,[r0,#0x20]
00007a  f2411111          MOV      r1,#0x1111
00007e  4008              ANDS     r0,r0,r1
000080  b950              CBNZ     r0,|L57.152|
000082  6820              LDR      r0,[r4,#0]
000084  6a00              LDR      r0,[r0,#0x20]
000086  1089              ASRS     r1,r1,#2
000088  4008              ANDS     r0,r0,r1
00008a  b928              CBNZ     r0,|L57.152|
00008c  6820              LDR      r0,[r4,#0]
00008e  6c40              LDR      r0,[r0,#0x44]
000090  f4204000          BIC      r0,r0,#0x8000
000094  6821              LDR      r1,[r4,#0]
000096  6448              STR      r0,[r1,#0x44]
                  |L57.152|
000098  bf00              NOP      
                  |L57.154|
;;;1057     }
;;;1058     
;;;1059     /* Disable the Peripheral */
;;;1060     __HAL_TIM_DISABLE(htim);
00009a  bf00              NOP      
00009c  6820              LDR      r0,[r4,#0]
00009e  6a00              LDR      r0,[r0,#0x20]
0000a0  f2411111          MOV      r1,#0x1111
0000a4  4008              ANDS     r0,r0,r1
0000a6  b950              CBNZ     r0,|L57.190|
0000a8  6820              LDR      r0,[r4,#0]
0000aa  6a00              LDR      r0,[r0,#0x20]
0000ac  1089              ASRS     r1,r1,#2
0000ae  4008              ANDS     r0,r0,r1
0000b0  b928              CBNZ     r0,|L57.190|
0000b2  6820              LDR      r0,[r4,#0]
0000b4  6800              LDR      r0,[r0,#0]
0000b6  f0200001          BIC      r0,r0,#1
0000ba  6821              LDR      r1,[r4,#0]
0000bc  6008              STR      r0,[r1,#0]
                  |L57.190|
0000be  bf00              NOP      
;;;1061     
;;;1062     /* Change the htim state */
;;;1063     htim->State = HAL_TIM_STATE_READY;
0000c0  2001              MOVS     r0,#1
0000c2  6420              STR      r0,[r4,#0x40]
;;;1064     
;;;1065     /* Return function status */
;;;1066     return HAL_OK;
0000c4  2000              MOVS     r0,#0
;;;1067   }
0000c6  bd30              POP      {r4,r5,pc}
;;;1068   
                          ENDP

                  |L57.200|
                          DCD      0x40010000
                  |L57.204|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OC_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OC_Stop_IT PROC
;;;823      */
;;;824    HAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;825    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;826      /* Check the parameters */
;;;827      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;828      
;;;829      switch (Channel)
000006  b135              CBZ      r5,|L58.22|
000008  2d04              CMP      r5,#4
00000a  d00b              BEQ      |L58.36|
00000c  2d08              CMP      r5,#8
00000e  d010              BEQ      |L58.50|
000010  2d0c              CMP      r5,#0xc
000012  d11c              BNE      |L58.78|
000014  e014              B        |L58.64|
                  |L58.22|
;;;830      {
;;;831        case TIM_CHANNEL_1:
;;;832        {       
;;;833          /* Disable the TIM Capture/Compare 1 interrupt */
;;;834          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000016  6820              LDR      r0,[r4,#0]
000018  68c0              LDR      r0,[r0,#0xc]
00001a  f0200002          BIC      r0,r0,#2
00001e  6821              LDR      r1,[r4,#0]
000020  60c8              STR      r0,[r1,#0xc]
;;;835        }
;;;836        break;
000022  e015              B        |L58.80|
                  |L58.36|
;;;837        
;;;838        case TIM_CHANNEL_2:
;;;839        {
;;;840          /* Disable the TIM Capture/Compare 2 interrupt */
;;;841          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000024  6820              LDR      r0,[r4,#0]
000026  68c0              LDR      r0,[r0,#0xc]
000028  f0200004          BIC      r0,r0,#4
00002c  6821              LDR      r1,[r4,#0]
00002e  60c8              STR      r0,[r1,#0xc]
;;;842        }
;;;843        break;
000030  e00e              B        |L58.80|
                  |L58.50|
;;;844        
;;;845        case TIM_CHANNEL_3:
;;;846        {
;;;847          /* Disable the TIM Capture/Compare 3 interrupt */
;;;848          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
000032  6820              LDR      r0,[r4,#0]
000034  68c0              LDR      r0,[r0,#0xc]
000036  f0200008          BIC      r0,r0,#8
00003a  6821              LDR      r1,[r4,#0]
00003c  60c8              STR      r0,[r1,#0xc]
;;;849        }
;;;850        break;
00003e  e007              B        |L58.80|
                  |L58.64|
;;;851        
;;;852        case TIM_CHANNEL_4:
;;;853        {
;;;854          /* Disable the TIM Capture/Compare 4 interrupt */
;;;855          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
000040  6820              LDR      r0,[r4,#0]
000042  68c0              LDR      r0,[r0,#0xc]
000044  f0200010          BIC      r0,r0,#0x10
000048  6821              LDR      r1,[r4,#0]
00004a  60c8              STR      r0,[r1,#0xc]
;;;856        }
;;;857        break;
00004c  e000              B        |L58.80|
                  |L58.78|
;;;858        
;;;859        default:
;;;860        break; 
00004e  bf00              NOP      
                  |L58.80|
000050  bf00              NOP                            ;836
;;;861      } 
;;;862      
;;;863      /* Disable the Output compare channel */
;;;864      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE); 
000052  2200              MOVS     r2,#0
000054  4629              MOV      r1,r5
000056  6820              LDR      r0,[r4,#0]
000058  f7fffffe          BL       TIM_CCxChannelCmd
;;;865      
;;;866      if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00005c  4919              LDR      r1,|L58.196|
00005e  6820              LDR      r0,[r4,#0]
000060  4288              CMP      r0,r1
000062  d003              BEQ      |L58.108|
000064  4918              LDR      r1,|L58.200|
000066  6820              LDR      r0,[r4,#0]
000068  4288              CMP      r0,r1
00006a  d101              BNE      |L58.112|
                  |L58.108|
00006c  2001              MOVS     r0,#1
00006e  e000              B        |L58.114|
                  |L58.112|
000070  2000              MOVS     r0,#0
                  |L58.114|
000072  b190              CBZ      r0,|L58.154|
;;;867      {
;;;868        /* Disable the Main Output */
;;;869        __HAL_TIM_MOE_DISABLE(htim);
000074  bf00              NOP      
000076  6820              LDR      r0,[r4,#0]
000078  6a00              LDR      r0,[r0,#0x20]
00007a  f2411111          MOV      r1,#0x1111
00007e  4008              ANDS     r0,r0,r1
000080  b950              CBNZ     r0,|L58.152|
000082  6820              LDR      r0,[r4,#0]
000084  6a00              LDR      r0,[r0,#0x20]
000086  1089              ASRS     r1,r1,#2
000088  4008              ANDS     r0,r0,r1
00008a  b928              CBNZ     r0,|L58.152|
00008c  6820              LDR      r0,[r4,#0]
00008e  6c40              LDR      r0,[r0,#0x44]
000090  f4204000          BIC      r0,r0,#0x8000
000094  6821              LDR      r1,[r4,#0]
000096  6448              STR      r0,[r1,#0x44]
                  |L58.152|
000098  bf00              NOP      
                  |L58.154|
;;;870      }
;;;871      
;;;872      /* Disable the Peripheral */
;;;873      __HAL_TIM_DISABLE(htim);  
00009a  bf00              NOP      
00009c  6820              LDR      r0,[r4,#0]
00009e  6a00              LDR      r0,[r0,#0x20]
0000a0  f2411111          MOV      r1,#0x1111
0000a4  4008              ANDS     r0,r0,r1
0000a6  b950              CBNZ     r0,|L58.190|
0000a8  6820              LDR      r0,[r4,#0]
0000aa  6a00              LDR      r0,[r0,#0x20]
0000ac  1089              ASRS     r1,r1,#2
0000ae  4008              ANDS     r0,r0,r1
0000b0  b928              CBNZ     r0,|L58.190|
0000b2  6820              LDR      r0,[r4,#0]
0000b4  6800              LDR      r0,[r0,#0]
0000b6  f0200001          BIC      r0,r0,#1
0000ba  6821              LDR      r1,[r4,#0]
0000bc  6008              STR      r0,[r1,#0]
                  |L58.190|
0000be  bf00              NOP      
;;;874      
;;;875      /* Return function status */
;;;876      return HAL_OK;
0000c0  2000              MOVS     r0,#0
;;;877    }
0000c2  bd30              POP      {r4,r5,pc}
;;;878    
                          ENDP

                  |L58.196|
                          DCD      0x40010000
                  |L58.200|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OnePulse_ConfigChannel||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_ConfigChannel PROC
;;;3512     */
;;;3513   HAL_StatusTypeDef HAL_TIM_OnePulse_ConfigChannel(TIM_HandleTypeDef *htim,  TIM_OnePulse_InitTypeDef* sConfig, uint32_t OutputChannel,  uint32_t InputChannel)
000000  b5f0              PUSH     {r4-r7,lr}
;;;3514   {
000002  b087              SUB      sp,sp,#0x1c
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;3515     TIM_OC_InitTypeDef temp1;
;;;3516     
;;;3517     /* Check the parameters */
;;;3518     assert_param(IS_TIM_OPM_CHANNELS(OutputChannel));
;;;3519     assert_param(IS_TIM_OPM_CHANNELS(InputChannel));
;;;3520   
;;;3521     if(OutputChannel != InputChannel)  
00000c  42be              CMP      r6,r7
00000e  d07f              BEQ      |L59.272|
;;;3522     {
;;;3523       __HAL_LOCK(htim);
000010  bf00              NOP      
000012  6be0              LDR      r0,[r4,#0x3c]
000014  2801              CMP      r0,#1
000016  d102              BNE      |L59.30|
000018  2002              MOVS     r0,#2
                  |L59.26|
;;;3524     
;;;3525       htim->State = HAL_TIM_STATE_BUSY;
;;;3526   
;;;3527       /* Extract the Output compare configuration from sConfig structure */  
;;;3528       temp1.OCMode = sConfig->OCMode;
;;;3529       temp1.Pulse = sConfig->Pulse;
;;;3530       temp1.OCPolarity = sConfig->OCPolarity;
;;;3531       temp1.OCNPolarity = sConfig->OCNPolarity;
;;;3532       temp1.OCIdleState = sConfig->OCIdleState;
;;;3533       temp1.OCNIdleState = sConfig->OCNIdleState; 
;;;3534       
;;;3535       switch (OutputChannel)
;;;3536       {
;;;3537         case TIM_CHANNEL_1:
;;;3538         {
;;;3539           assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3540         
;;;3541           TIM_OC1_SetConfig(htim->Instance, &temp1); 
;;;3542         }
;;;3543         break;
;;;3544         case TIM_CHANNEL_2:
;;;3545         {
;;;3546           assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3547         
;;;3548           TIM_OC2_SetConfig(htim->Instance, &temp1);
;;;3549         }
;;;3550         break;
;;;3551         default:
;;;3552         break;  
;;;3553       } 
;;;3554       switch (InputChannel)
;;;3555       {
;;;3556         case TIM_CHANNEL_1:
;;;3557         {
;;;3558           assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3559         
;;;3560           TIM_TI1_SetConfig(htim->Instance, sConfig->ICPolarity,
;;;3561                           sConfig->ICSelection, sConfig->ICFilter);
;;;3562                  
;;;3563           /* Reset the IC1PSC Bits */
;;;3564           htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
;;;3565   
;;;3566           /* Select the Trigger source */
;;;3567           htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;3568           htim->Instance->SMCR |= TIM_TS_TI1FP1;
;;;3569         
;;;3570           /* Select the Slave Mode */      
;;;3571           htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;3572           htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
;;;3573         }
;;;3574         break;
;;;3575         case TIM_CHANNEL_2:
;;;3576         {
;;;3577           assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3578         
;;;3579           TIM_TI2_SetConfig(htim->Instance, sConfig->ICPolarity,
;;;3580                    sConfig->ICSelection, sConfig->ICFilter);
;;;3581                  
;;;3582           /* Reset the IC2PSC Bits */
;;;3583           htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
;;;3584   
;;;3585           /* Select the Trigger source */
;;;3586           htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;3587           htim->Instance->SMCR |= TIM_TS_TI2FP2;
;;;3588         
;;;3589           /* Select the Slave Mode */      
;;;3590           htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;3591           htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
;;;3592         }
;;;3593         break;
;;;3594       
;;;3595         default:
;;;3596         break;  
;;;3597       }
;;;3598     
;;;3599       htim->State = HAL_TIM_STATE_READY;
;;;3600       
;;;3601       __HAL_UNLOCK(htim);
;;;3602     
;;;3603       return HAL_OK;
;;;3604     }
;;;3605     else
;;;3606     {
;;;3607       return HAL_ERROR;
;;;3608     }
;;;3609   } 
00001a  b007              ADD      sp,sp,#0x1c
00001c  bdf0              POP      {r4-r7,pc}
                  |L59.30|
00001e  2001              MOVS     r0,#1                 ;3523
000020  63e0              STR      r0,[r4,#0x3c]         ;3523
000022  bf00              NOP                            ;3523
000024  2002              MOVS     r0,#2                 ;3525
000026  6420              STR      r0,[r4,#0x40]         ;3525
000028  6828              LDR      r0,[r5,#0]            ;3528
00002a  9000              STR      r0,[sp,#0]            ;3528
00002c  6868              LDR      r0,[r5,#4]            ;3529
00002e  9001              STR      r0,[sp,#4]            ;3529
000030  68a8              LDR      r0,[r5,#8]            ;3530
000032  9002              STR      r0,[sp,#8]            ;3530
000034  68e8              LDR      r0,[r5,#0xc]          ;3531
000036  9003              STR      r0,[sp,#0xc]          ;3531
000038  6928              LDR      r0,[r5,#0x10]         ;3532
00003a  9005              STR      r0,[sp,#0x14]         ;3532
00003c  6968              LDR      r0,[r5,#0x14]         ;3533
00003e  9006              STR      r0,[sp,#0x18]         ;3533
000040  b116              CBZ      r6,|L59.72|
000042  2e04              CMP      r6,#4                 ;3535
000044  d10a              BNE      |L59.92|
000046  e004              B        |L59.82|
                  |L59.72|
000048  4669              MOV      r1,sp                 ;3541
00004a  6820              LDR      r0,[r4,#0]            ;3541
00004c  f7fffffe          BL       TIM_OC1_SetConfig
000050  e005              B        |L59.94|
                  |L59.82|
000052  4669              MOV      r1,sp                 ;3548
000054  6820              LDR      r0,[r4,#0]            ;3548
000056  f7fffffe          BL       TIM_OC2_SetConfig
00005a  e000              B        |L59.94|
                  |L59.92|
00005c  bf00              NOP                            ;3552
                  |L59.94|
00005e  bf00              NOP                            ;3543
000060  b117              CBZ      r7,|L59.104|
000062  2f04              CMP      r7,#4                 ;3554
000064  d14b              BNE      |L59.254|
000066  e024              B        |L59.178|
                  |L59.104|
000068  e9d52307          LDRD     r2,r3,[r5,#0x1c]      ;3560
00006c  69a9              LDR      r1,[r5,#0x18]         ;3560
00006e  6820              LDR      r0,[r4,#0]            ;3560
000070  f7fffffe          BL       TIM_TI1_SetConfig
000074  6820              LDR      r0,[r4,#0]            ;3564
000076  6980              LDR      r0,[r0,#0x18]         ;3564
000078  f020000c          BIC      r0,r0,#0xc            ;3564
00007c  6821              LDR      r1,[r4,#0]            ;3564
00007e  6188              STR      r0,[r1,#0x18]         ;3564
000080  6820              LDR      r0,[r4,#0]            ;3567
000082  6880              LDR      r0,[r0,#8]            ;3567
000084  f0200070          BIC      r0,r0,#0x70           ;3567
000088  6821              LDR      r1,[r4,#0]            ;3567
00008a  6088              STR      r0,[r1,#8]            ;3567
00008c  6820              LDR      r0,[r4,#0]            ;3568
00008e  6880              LDR      r0,[r0,#8]            ;3568
000090  f0400050          ORR      r0,r0,#0x50           ;3568
000094  6821              LDR      r1,[r4,#0]            ;3568
000096  6088              STR      r0,[r1,#8]            ;3568
000098  6820              LDR      r0,[r4,#0]            ;3571
00009a  6880              LDR      r0,[r0,#8]            ;3571
00009c  491d              LDR      r1,|L59.276|
00009e  4008              ANDS     r0,r0,r1              ;3571
0000a0  6821              LDR      r1,[r4,#0]            ;3571
0000a2  6088              STR      r0,[r1,#8]            ;3571
0000a4  6820              LDR      r0,[r4,#0]            ;3572
0000a6  6880              LDR      r0,[r0,#8]            ;3572
0000a8  f0400006          ORR      r0,r0,#6              ;3572
0000ac  6821              LDR      r1,[r4,#0]            ;3572
0000ae  6088              STR      r0,[r1,#8]            ;3572
0000b0  e026              B        |L59.256|
                  |L59.178|
0000b2  e9d52307          LDRD     r2,r3,[r5,#0x1c]      ;3579
0000b6  69a9              LDR      r1,[r5,#0x18]         ;3579
0000b8  6820              LDR      r0,[r4,#0]            ;3579
0000ba  f7fffffe          BL       TIM_TI2_SetConfig
0000be  6820              LDR      r0,[r4,#0]            ;3583
0000c0  6980              LDR      r0,[r0,#0x18]         ;3583
0000c2  f4206040          BIC      r0,r0,#0xc00          ;3583
0000c6  6821              LDR      r1,[r4,#0]            ;3583
0000c8  6188              STR      r0,[r1,#0x18]         ;3583
0000ca  6820              LDR      r0,[r4,#0]            ;3586
0000cc  6880              LDR      r0,[r0,#8]            ;3586
0000ce  f0200070          BIC      r0,r0,#0x70           ;3586
0000d2  6821              LDR      r1,[r4,#0]            ;3586
0000d4  6088              STR      r0,[r1,#8]            ;3586
0000d6  6820              LDR      r0,[r4,#0]            ;3587
0000d8  6880              LDR      r0,[r0,#8]            ;3587
0000da  f0400060          ORR      r0,r0,#0x60           ;3587
0000de  6821              LDR      r1,[r4,#0]            ;3587
0000e0  6088              STR      r0,[r1,#8]            ;3587
0000e2  6820              LDR      r0,[r4,#0]            ;3590
0000e4  6880              LDR      r0,[r0,#8]            ;3590
0000e6  490b              LDR      r1,|L59.276|
0000e8  4008              ANDS     r0,r0,r1              ;3590
0000ea  6821              LDR      r1,[r4,#0]            ;3590
0000ec  6088              STR      r0,[r1,#8]            ;3590
0000ee  6820              LDR      r0,[r4,#0]            ;3591
0000f0  6880              LDR      r0,[r0,#8]            ;3591
0000f2  f0400006          ORR      r0,r0,#6              ;3591
0000f6  6821              LDR      r1,[r4,#0]            ;3591
0000f8  6088              STR      r0,[r1,#8]            ;3591
0000fa  e001              B        |L59.256|
0000fc  e008              B        |L59.272|
                  |L59.254|
0000fe  bf00              NOP                            ;3596
                  |L59.256|
000100  bf00              NOP                            ;3574
000102  2001              MOVS     r0,#1                 ;3599
000104  6420              STR      r0,[r4,#0x40]         ;3599
000106  bf00              NOP                            ;3601
000108  2000              MOVS     r0,#0                 ;3601
00010a  63e0              STR      r0,[r4,#0x3c]         ;3601
00010c  bf00              NOP                            ;3601
00010e  e784              B        |L59.26|
                  |L59.272|
000110  2001              MOVS     r0,#1                 ;3607
000112  e782              B        |L59.26|
;;;3610   
                          ENDP

                  |L59.276|
                          DCD      0xfffefff8

                          AREA ||i.HAL_TIM_OnePulse_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_DeInit PROC
;;;2207     */
;;;2208   HAL_StatusTypeDef HAL_TIM_OnePulse_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;2209   {
000002  4604              MOV      r4,r0
;;;2210     /* Check the parameters */
;;;2211     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;2212     
;;;2213     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  6420              STR      r0,[r4,#0x40]
;;;2214     
;;;2215     /* Disable the TIM Peripheral Clock */
;;;2216     __HAL_TIM_DISABLE(htim);
000008  bf00              NOP      
00000a  6820              LDR      r0,[r4,#0]
00000c  6a00              LDR      r0,[r0,#0x20]
00000e  f2411111          MOV      r1,#0x1111
000012  4008              ANDS     r0,r0,r1
000014  b950              CBNZ     r0,|L60.44|
000016  6820              LDR      r0,[r4,#0]
000018  6a00              LDR      r0,[r0,#0x20]
00001a  1089              ASRS     r1,r1,#2
00001c  4008              ANDS     r0,r0,r1
00001e  b928              CBNZ     r0,|L60.44|
000020  6820              LDR      r0,[r4,#0]
000022  6800              LDR      r0,[r0,#0]
000024  f0200001          BIC      r0,r0,#1
000028  6821              LDR      r1,[r4,#0]
00002a  6008              STR      r0,[r1,#0]
                  |L60.44|
00002c  bf00              NOP      
;;;2217   
;;;2218   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;2219     if(htim->OnePulse_MspDeInitCallback == NULL)
;;;2220     {
;;;2221       htim->OnePulse_MspDeInitCallback = HAL_TIM_OnePulse_MspDeInit;
;;;2222     }
;;;2223     /* DeInit the low level hardware */
;;;2224     htim->OnePulse_MspDeInitCallback(htim);
;;;2225   #else
;;;2226     /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;2227     HAL_TIM_OnePulse_MspDeInit(htim);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       HAL_TIM_OnePulse_MspDeInit
;;;2228   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;2229   
;;;2230     /* Change TIM state */  
;;;2231     htim->State = HAL_TIM_STATE_RESET;
000034  2000              MOVS     r0,#0
000036  6420              STR      r0,[r4,#0x40]
;;;2232   
;;;2233     /* Release Lock */
;;;2234     __HAL_UNLOCK(htim);
000038  bf00              NOP      
00003a  63e0              STR      r0,[r4,#0x3c]
00003c  bf00              NOP      
;;;2235   
;;;2236     return HAL_OK;
;;;2237   }
00003e  bd10              POP      {r4,pc}
;;;2238   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_GetState PROC
;;;5278     */
;;;5279   HAL_TIM_StateTypeDef HAL_TIM_OnePulse_GetState(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;5280   {
;;;5281     return htim->State;
000002  6c08              LDR      r0,[r1,#0x40]
;;;5282   }
000004  4770              BX       lr
;;;5283   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_Init PROC
;;;2147     */
;;;2148   HAL_StatusTypeDef HAL_TIM_OnePulse_Init(TIM_HandleTypeDef *htim, uint32_t OnePulseMode)
000000  b570              PUSH     {r4-r6,lr}
;;;2149   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2150     /* Check the TIM handle allocation */
;;;2151     if(htim == NULL)
000006  b90c              CBNZ     r4,|L62.12|
;;;2152     {
;;;2153       return HAL_ERROR;
000008  2001              MOVS     r0,#1
                  |L62.10|
;;;2154     }
;;;2155   
;;;2156     /* Check the parameters */
;;;2157     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;2158     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;2159     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;2160     assert_param(IS_TIM_OPM_MODE(OnePulseMode));
;;;2161     assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;2162   
;;;2163     if(htim->State == HAL_TIM_STATE_RESET)
;;;2164     {
;;;2165       /* Allocate lock resource and initialize it */
;;;2166       htim->Lock = HAL_UNLOCKED;
;;;2167   
;;;2168   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;2169       /* Reset interrupt callbacks to legacy week callbacks */
;;;2170       TIM_ResetCallback(htim);
;;;2171   
;;;2172       if(htim->OnePulse_MspDeInitCallback == NULL)
;;;2173       {
;;;2174         htim->OnePulse_MspDeInitCallback = HAL_TIM_OnePulse_MspInit;
;;;2175       }
;;;2176       /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;2177       htim->OnePulse_MspDeInitCallback(htim);
;;;2178   #else
;;;2179       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;2180       HAL_TIM_OnePulse_MspInit(htim);
;;;2181   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;2182     }
;;;2183   
;;;2184     /* Set the TIM state */
;;;2185     htim->State= HAL_TIM_STATE_BUSY;  
;;;2186     
;;;2187     /* Configure the Time base in the One Pulse Mode */
;;;2188     TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;2189     
;;;2190     /* Reset the OPM Bit */
;;;2191     htim->Instance->CR1 &= ~TIM_CR1_OPM;
;;;2192   
;;;2193     /* Configure the OPM Mode */
;;;2194     htim->Instance->CR1 |= OnePulseMode;
;;;2195      
;;;2196     /* Initialize the TIM state*/
;;;2197     htim->State= HAL_TIM_STATE_READY;
;;;2198     
;;;2199     return HAL_OK;
;;;2200   }
00000a  bd70              POP      {r4-r6,pc}
                  |L62.12|
00000c  6c20              LDR      r0,[r4,#0x40]         ;2163
00000e  b920              CBNZ     r0,|L62.26|
000010  2000              MOVS     r0,#0                 ;2166
000012  63e0              STR      r0,[r4,#0x3c]         ;2166
000014  4620              MOV      r0,r4                 ;2180
000016  f7fffffe          BL       HAL_TIM_OnePulse_MspInit
                  |L62.26|
00001a  2002              MOVS     r0,#2                 ;2185
00001c  6420              STR      r0,[r4,#0x40]         ;2185
00001e  1d21              ADDS     r1,r4,#4              ;2188
000020  6820              LDR      r0,[r4,#0]            ;2188
000022  f7fffffe          BL       TIM_Base_SetConfig
000026  6820              LDR      r0,[r4,#0]            ;2191
000028  6800              LDR      r0,[r0,#0]            ;2191
00002a  f0200008          BIC      r0,r0,#8              ;2191
00002e  6821              LDR      r1,[r4,#0]            ;2191
000030  6008              STR      r0,[r1,#0]            ;2191
000032  6820              LDR      r0,[r4,#0]            ;2194
000034  6800              LDR      r0,[r0,#0]            ;2194
000036  4328              ORRS     r0,r0,r5              ;2194
000038  6821              LDR      r1,[r4,#0]            ;2194
00003a  6008              STR      r0,[r1,#0]            ;2194
00003c  2001              MOVS     r0,#1                 ;2197
00003e  6420              STR      r0,[r4,#0x40]         ;2197
000040  2000              MOVS     r0,#0                 ;2199
000042  e7e2              B        |L62.10|
;;;2201   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_MspDeInit PROC
;;;2260     */
;;;2261   __weak void HAL_TIM_OnePulse_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2262   {
;;;2263     /* Prevent unused argument(s) compilation warning */
;;;2264     UNUSED(htim);
;;;2265    
;;;2266     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2267               the HAL_TIM_OnePulse_MspDeInit could be implemented in the user file
;;;2268      */
;;;2269   }
;;;2270   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_OnePulse_MspInit PROC
;;;2244     */
;;;2245   __weak void HAL_TIM_OnePulse_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;2246   {
;;;2247     /* Prevent unused argument(s) compilation warning */
;;;2248     UNUSED(htim);
;;;2249    
;;;2250     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2251               the HAL_TIM_OnePulse_MspInit could be implemented in the user file
;;;2252      */
;;;2253   }
;;;2254   
                          ENDP


                          AREA ||i.HAL_TIM_OnePulse_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Start PROC
;;;2280     */
;;;2281   HAL_StatusTypeDef HAL_TIM_OnePulse_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b530              PUSH     {r4,r5,lr}
;;;2282   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2283     /* Prevent unused argument(s) compilation warning */
;;;2284     UNUSED(OutputChannel);
;;;2285   
;;;2286     /* Enable the Capture compare and the Input Capture channels 
;;;2287       (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2288       if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2289       if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2290       in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
;;;2291       
;;;2292       No need to enable the counter, it's enabled automatically by hardware 
;;;2293       (the counter starts in response to a stimulus and generate a pulse */
;;;2294     
;;;2295     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE); 
000006  2201              MOVS     r2,#1
000008  2100              MOVS     r1,#0
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2296     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
000010  2201              MOVS     r2,#1
000012  2104              MOVS     r1,#4
000014  6820              LDR      r0,[r4,#0]
000016  f7fffffe          BL       TIM_CCxChannelCmd
;;;2297     
;;;2298     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00001a  490a              LDR      r1,|L65.68|
00001c  6820              LDR      r0,[r4,#0]
00001e  4288              CMP      r0,r1
000020  d003              BEQ      |L65.42|
000022  4909              LDR      r1,|L65.72|
000024  6820              LDR      r0,[r4,#0]
000026  4288              CMP      r0,r1
000028  d101              BNE      |L65.46|
                  |L65.42|
00002a  2001              MOVS     r0,#1
00002c  e000              B        |L65.48|
                  |L65.46|
00002e  2000              MOVS     r0,#0
                  |L65.48|
000030  b128              CBZ      r0,|L65.62|
;;;2299     {
;;;2300       /* Enable the main output */
;;;2301       __HAL_TIM_MOE_ENABLE(htim);
000032  6820              LDR      r0,[r4,#0]
000034  6c40              LDR      r0,[r0,#0x44]
000036  f4404000          ORR      r0,r0,#0x8000
00003a  6821              LDR      r1,[r4,#0]
00003c  6448              STR      r0,[r1,#0x44]
                  |L65.62|
;;;2302     }
;;;2303     
;;;2304     /* Return function status */
;;;2305     return HAL_OK;
00003e  2000              MOVS     r0,#0
;;;2306   }
000040  bd30              POP      {r4,r5,pc}
;;;2307   
                          ENDP

000042  0000              DCW      0x0000
                  |L65.68|
                          DCD      0x40010000
                  |L65.72|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OnePulse_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Start_IT PROC
;;;2354     */
;;;2355   HAL_StatusTypeDef HAL_TIM_OnePulse_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b530              PUSH     {r4,r5,lr}
;;;2356   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2357     /* Enable the Capture compare and the Input Capture channels 
;;;2358       (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2359       if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2360       if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2361       in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
;;;2362       
;;;2363       No need to enable the counter, it's enabled automatically by hardware 
;;;2364       (the counter starts in response to a stimulus and generate a pulse */
;;;2365   
;;;2366     /* Prevent unused argument(s) compilation warning */
;;;2367     UNUSED(OutputChannel);
;;;2368   
;;;2369     /* Enable the TIM Capture/Compare 1 interrupt */
;;;2370     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000006  6820              LDR      r0,[r4,#0]
000008  68c0              LDR      r0,[r0,#0xc]
00000a  f0400002          ORR      r0,r0,#2
00000e  6821              LDR      r1,[r4,#0]
000010  60c8              STR      r0,[r1,#0xc]
;;;2371     
;;;2372     /* Enable the TIM Capture/Compare 2 interrupt */
;;;2373     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000012  6820              LDR      r0,[r4,#0]
000014  68c0              LDR      r0,[r0,#0xc]
000016  f0400004          ORR      r0,r0,#4
00001a  6821              LDR      r1,[r4,#0]
00001c  60c8              STR      r0,[r1,#0xc]
;;;2374     
;;;2375     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE); 
00001e  2201              MOVS     r2,#1
000020  2100              MOVS     r1,#0
000022  6820              LDR      r0,[r4,#0]
000024  f7fffffe          BL       TIM_CCxChannelCmd
;;;2376     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
000028  2201              MOVS     r2,#1
00002a  2104              MOVS     r1,#4
00002c  6820              LDR      r0,[r4,#0]
00002e  f7fffffe          BL       TIM_CCxChannelCmd
;;;2377     
;;;2378     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000032  490a              LDR      r1,|L66.92|
000034  6820              LDR      r0,[r4,#0]
000036  4288              CMP      r0,r1
000038  d003              BEQ      |L66.66|
00003a  4909              LDR      r1,|L66.96|
00003c  6820              LDR      r0,[r4,#0]
00003e  4288              CMP      r0,r1
000040  d101              BNE      |L66.70|
                  |L66.66|
000042  2001              MOVS     r0,#1
000044  e000              B        |L66.72|
                  |L66.70|
000046  2000              MOVS     r0,#0
                  |L66.72|
000048  b128              CBZ      r0,|L66.86|
;;;2379     {
;;;2380       /* Enable the main output */
;;;2381       __HAL_TIM_MOE_ENABLE(htim);
00004a  6820              LDR      r0,[r4,#0]
00004c  6c40              LDR      r0,[r0,#0x44]
00004e  f4404000          ORR      r0,r0,#0x8000
000052  6821              LDR      r1,[r4,#0]
000054  6448              STR      r0,[r1,#0x44]
                  |L66.86|
;;;2382     }
;;;2383     
;;;2384     /* Return function status */
;;;2385     return HAL_OK;
000056  2000              MOVS     r0,#0
;;;2386   }
000058  bd30              POP      {r4,r5,pc}
;;;2387   
                          ENDP

00005a  0000              DCW      0x0000
                  |L66.92|
                          DCD      0x40010000
                  |L66.96|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OnePulse_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Stop PROC
;;;2317     */
;;;2318   HAL_StatusTypeDef HAL_TIM_OnePulse_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b530              PUSH     {r4,r5,lr}
;;;2319   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2320     /* Prevent unused argument(s) compilation warning */
;;;2321     UNUSED(OutputChannel);
;;;2322   
;;;2323     /* Disable the Capture compare and the Input Capture channels 
;;;2324     (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2325     if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2326     if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2327     in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
;;;2328     
;;;2329     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
000006  2200              MOVS     r2,#0
000008  4611              MOV      r1,r2
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2330     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
000010  2200              MOVS     r2,#0
000012  2104              MOVS     r1,#4
000014  6820              LDR      r0,[r4,#0]
000016  f7fffffe          BL       TIM_CCxChannelCmd
;;;2331       
;;;2332     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00001a  491a              LDR      r1,|L67.132|
00001c  6820              LDR      r0,[r4,#0]
00001e  4288              CMP      r0,r1
000020  d003              BEQ      |L67.42|
000022  4919              LDR      r1,|L67.136|
000024  6820              LDR      r0,[r4,#0]
000026  4288              CMP      r0,r1
000028  d101              BNE      |L67.46|
                  |L67.42|
00002a  2001              MOVS     r0,#1
00002c  e000              B        |L67.48|
                  |L67.46|
00002e  2000              MOVS     r0,#0
                  |L67.48|
000030  b190              CBZ      r0,|L67.88|
;;;2333     {
;;;2334       /* Disable the Main Output */
;;;2335       __HAL_TIM_MOE_DISABLE(htim);
000032  bf00              NOP      
000034  6820              LDR      r0,[r4,#0]
000036  6a00              LDR      r0,[r0,#0x20]
000038  f2411111          MOV      r1,#0x1111
00003c  4008              ANDS     r0,r0,r1
00003e  b950              CBNZ     r0,|L67.86|
000040  6820              LDR      r0,[r4,#0]
000042  6a00              LDR      r0,[r0,#0x20]
000044  1089              ASRS     r1,r1,#2
000046  4008              ANDS     r0,r0,r1
000048  b928              CBNZ     r0,|L67.86|
00004a  6820              LDR      r0,[r4,#0]
00004c  6c40              LDR      r0,[r0,#0x44]
00004e  f4204000          BIC      r0,r0,#0x8000
000052  6821              LDR      r1,[r4,#0]
000054  6448              STR      r0,[r1,#0x44]
                  |L67.86|
000056  bf00              NOP      
                  |L67.88|
;;;2336     }
;;;2337       
;;;2338     /* Disable the Peripheral */
;;;2339     __HAL_TIM_DISABLE(htim); 
000058  bf00              NOP      
00005a  6820              LDR      r0,[r4,#0]
00005c  6a00              LDR      r0,[r0,#0x20]
00005e  f2411111          MOV      r1,#0x1111
000062  4008              ANDS     r0,r0,r1
000064  b950              CBNZ     r0,|L67.124|
000066  6820              LDR      r0,[r4,#0]
000068  6a00              LDR      r0,[r0,#0x20]
00006a  1089              ASRS     r1,r1,#2
00006c  4008              ANDS     r0,r0,r1
00006e  b928              CBNZ     r0,|L67.124|
000070  6820              LDR      r0,[r4,#0]
000072  6800              LDR      r0,[r0,#0]
000074  f0200001          BIC      r0,r0,#1
000078  6821              LDR      r1,[r4,#0]
00007a  6008              STR      r0,[r1,#0]
                  |L67.124|
00007c  bf00              NOP      
;;;2340     
;;;2341     /* Return function status */
;;;2342     return HAL_OK;
00007e  2000              MOVS     r0,#0
;;;2343   }
000080  bd30              POP      {r4,r5,pc}
;;;2344   
                          ENDP

000082  0000              DCW      0x0000
                  |L67.132|
                          DCD      0x40010000
                  |L67.136|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_OnePulse_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_OnePulse_Stop_IT PROC
;;;2397     */
;;;2398   HAL_StatusTypeDef HAL_TIM_OnePulse_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000000  b530              PUSH     {r4,r5,lr}
;;;2399   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2400     /* Prevent unused argument(s) compilation warning */
;;;2401     UNUSED(OutputChannel);
;;;2402     
;;;2403     /* Disable the TIM Capture/Compare 1 interrupt */
;;;2404     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);  
000006  6820              LDR      r0,[r4,#0]
000008  68c0              LDR      r0,[r0,#0xc]
00000a  f0200002          BIC      r0,r0,#2
00000e  6821              LDR      r1,[r4,#0]
000010  60c8              STR      r0,[r1,#0xc]
;;;2405     
;;;2406     /* Disable the TIM Capture/Compare 2 interrupt */
;;;2407     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000012  6820              LDR      r0,[r4,#0]
000014  68c0              LDR      r0,[r0,#0xc]
000016  f0200004          BIC      r0,r0,#4
00001a  6821              LDR      r1,[r4,#0]
00001c  60c8              STR      r0,[r1,#0xc]
;;;2408     
;;;2409     /* Disable the Capture compare and the Input Capture channels 
;;;2410     (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2411     if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2412     if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2413     in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */  
;;;2414     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
00001e  2200              MOVS     r2,#0
000020  4611              MOV      r1,r2
000022  6820              LDR      r0,[r4,#0]
000024  f7fffffe          BL       TIM_CCxChannelCmd
;;;2415     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
000028  2200              MOVS     r2,#0
00002a  2104              MOVS     r1,#4
00002c  6820              LDR      r0,[r4,#0]
00002e  f7fffffe          BL       TIM_CCxChannelCmd
;;;2416       
;;;2417     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000032  491a              LDR      r1,|L68.156|
000034  6820              LDR      r0,[r4,#0]
000036  4288              CMP      r0,r1
000038  d003              BEQ      |L68.66|
00003a  4919              LDR      r1,|L68.160|
00003c  6820              LDR      r0,[r4,#0]
00003e  4288              CMP      r0,r1
000040  d101              BNE      |L68.70|
                  |L68.66|
000042  2001              MOVS     r0,#1
000044  e000              B        |L68.72|
                  |L68.70|
000046  2000              MOVS     r0,#0
                  |L68.72|
000048  b190              CBZ      r0,|L68.112|
;;;2418     {
;;;2419       /* Disable the Main Output */
;;;2420       __HAL_TIM_MOE_DISABLE(htim);
00004a  bf00              NOP      
00004c  6820              LDR      r0,[r4,#0]
00004e  6a00              LDR      r0,[r0,#0x20]
000050  f2411111          MOV      r1,#0x1111
000054  4008              ANDS     r0,r0,r1
000056  b950              CBNZ     r0,|L68.110|
000058  6820              LDR      r0,[r4,#0]
00005a  6a00              LDR      r0,[r0,#0x20]
00005c  1089              ASRS     r1,r1,#2
00005e  4008              ANDS     r0,r0,r1
000060  b928              CBNZ     r0,|L68.110|
000062  6820              LDR      r0,[r4,#0]
000064  6c40              LDR      r0,[r0,#0x44]
000066  f4204000          BIC      r0,r0,#0x8000
00006a  6821              LDR      r1,[r4,#0]
00006c  6448              STR      r0,[r1,#0x44]
                  |L68.110|
00006e  bf00              NOP      
                  |L68.112|
;;;2421     }
;;;2422       
;;;2423     /* Disable the Peripheral */
;;;2424      __HAL_TIM_DISABLE(htim);  
000070  bf00              NOP      
000072  6820              LDR      r0,[r4,#0]
000074  6a00              LDR      r0,[r0,#0x20]
000076  f2411111          MOV      r1,#0x1111
00007a  4008              ANDS     r0,r0,r1
00007c  b950              CBNZ     r0,|L68.148|
00007e  6820              LDR      r0,[r4,#0]
000080  6a00              LDR      r0,[r0,#0x20]
000082  1089              ASRS     r1,r1,#2
000084  4008              ANDS     r0,r0,r1
000086  b928              CBNZ     r0,|L68.148|
000088  6820              LDR      r0,[r4,#0]
00008a  6800              LDR      r0,[r0,#0]
00008c  f0200001          BIC      r0,r0,#1
000090  6821              LDR      r1,[r4,#0]
000092  6008              STR      r0,[r1,#0]
                  |L68.148|
000094  bf00              NOP      
;;;2425     
;;;2426     /* Return function status */
;;;2427     return HAL_OK;
000096  2000              MOVS     r0,#0
;;;2428   }
000098  bd30              POP      {r4,r5,pc}
;;;2429   
                          ENDP

00009a  0000              DCW      0x0000
                  |L68.156|
                          DCD      0x40010000
                  |L68.160|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_PWM_ConfigChannel||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_ConfigChannel PROC
;;;3411     */
;;;3412   __weak HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;3413   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;3414     __HAL_LOCK(htim);
000008  bf00              NOP      
00000a  6be0              LDR      r0,[r4,#0x3c]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L69.20|
000010  2002              MOVS     r0,#2
                  |L69.18|
;;;3415     
;;;3416     /* Check the parameters */ 
;;;3417     assert_param(IS_TIM_CHANNELS(Channel)); 
;;;3418     assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
;;;3419     assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
;;;3420     assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode)); 
;;;3421     
;;;3422     htim->State = HAL_TIM_STATE_BUSY;
;;;3423       
;;;3424     switch (Channel)
;;;3425     {
;;;3426       case TIM_CHANNEL_1:
;;;3427       {
;;;3428         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3429         /* Configure the Channel 1 in PWM mode */
;;;3430         TIM_OC1_SetConfig(htim->Instance, sConfig);
;;;3431         
;;;3432         /* Set the Preload enable bit for channel1 */
;;;3433         htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
;;;3434         
;;;3435         /* Configure the Output Fast mode */
;;;3436         htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
;;;3437         htim->Instance->CCMR1 |= sConfig->OCFastMode;
;;;3438       }
;;;3439       break;
;;;3440       
;;;3441       case TIM_CHANNEL_2:
;;;3442       {
;;;3443         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3444         /* Configure the Channel 2 in PWM mode */
;;;3445         TIM_OC2_SetConfig(htim->Instance, sConfig);
;;;3446         
;;;3447         /* Set the Preload enable bit for channel2 */
;;;3448         htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
;;;3449         
;;;3450         /* Configure the Output Fast mode */
;;;3451         htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
;;;3452         htim->Instance->CCMR1 |= sConfig->OCFastMode << 8;
;;;3453       }
;;;3454       break;
;;;3455       
;;;3456       case TIM_CHANNEL_3:
;;;3457       {
;;;3458         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3459         /* Configure the Channel 3 in PWM mode */
;;;3460         TIM_OC3_SetConfig(htim->Instance, sConfig);
;;;3461         
;;;3462         /* Set the Preload enable bit for channel3 */
;;;3463         htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
;;;3464         
;;;3465        /* Configure the Output Fast mode */
;;;3466         htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
;;;3467         htim->Instance->CCMR2 |= sConfig->OCFastMode;  
;;;3468       }
;;;3469       break;
;;;3470       
;;;3471       case TIM_CHANNEL_4:
;;;3472       {
;;;3473         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3474         /* Configure the Channel 4 in PWM mode */
;;;3475         TIM_OC4_SetConfig(htim->Instance, sConfig);
;;;3476         
;;;3477         /* Set the Preload enable bit for channel4 */
;;;3478         htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
;;;3479         
;;;3480        /* Configure the Output Fast mode */
;;;3481         htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
;;;3482         htim->Instance->CCMR2 |= sConfig->OCFastMode << 8;  
;;;3483       }
;;;3484       break;
;;;3485       
;;;3486       default:
;;;3487       break;    
;;;3488     }
;;;3489     
;;;3490     htim->State = HAL_TIM_STATE_READY;
;;;3491       
;;;3492     __HAL_UNLOCK(htim);
;;;3493     
;;;3494     return HAL_OK;
;;;3495   }
000012  bd70              POP      {r4-r6,pc}
                  |L69.20|
000014  2001              MOVS     r0,#1                 ;3414
000016  63e0              STR      r0,[r4,#0x3c]         ;3414
000018  bf00              NOP                            ;3414
00001a  2002              MOVS     r0,#2                 ;3422
00001c  6420              STR      r0,[r4,#0x40]         ;3422
00001e  b136              CBZ      r6,|L69.46|
000020  2e04              CMP      r6,#4                 ;3424
000022  d01b              BEQ      |L69.92|
000024  2e08              CMP      r6,#8                 ;3424
000026  d031              BEQ      |L69.140|
000028  2e0c              CMP      r6,#0xc               ;3424
00002a  d15e              BNE      |L69.234|
00002c  e045              B        |L69.186|
                  |L69.46|
00002e  4629              MOV      r1,r5                 ;3430
000030  6820              LDR      r0,[r4,#0]            ;3430
000032  f7fffffe          BL       TIM_OC1_SetConfig
000036  6820              LDR      r0,[r4,#0]            ;3433
000038  6980              LDR      r0,[r0,#0x18]         ;3433
00003a  f0400008          ORR      r0,r0,#8              ;3433
00003e  6821              LDR      r1,[r4,#0]            ;3433
000040  6188              STR      r0,[r1,#0x18]         ;3433
000042  6820              LDR      r0,[r4,#0]            ;3436
000044  6980              LDR      r0,[r0,#0x18]         ;3436
000046  f0200004          BIC      r0,r0,#4              ;3436
00004a  6821              LDR      r1,[r4,#0]            ;3436
00004c  6188              STR      r0,[r1,#0x18]         ;3436
00004e  6820              LDR      r0,[r4,#0]            ;3437
000050  6980              LDR      r0,[r0,#0x18]         ;3437
000052  6929              LDR      r1,[r5,#0x10]         ;3437
000054  4308              ORRS     r0,r0,r1              ;3437
000056  6821              LDR      r1,[r4,#0]            ;3437
000058  6188              STR      r0,[r1,#0x18]         ;3437
00005a  e047              B        |L69.236|
                  |L69.92|
00005c  4629              MOV      r1,r5                 ;3445
00005e  6820              LDR      r0,[r4,#0]            ;3445
000060  f7fffffe          BL       TIM_OC2_SetConfig
000064  6820              LDR      r0,[r4,#0]            ;3448
000066  6980              LDR      r0,[r0,#0x18]         ;3448
000068  f4406000          ORR      r0,r0,#0x800          ;3448
00006c  6821              LDR      r1,[r4,#0]            ;3448
00006e  6188              STR      r0,[r1,#0x18]         ;3448
000070  6820              LDR      r0,[r4,#0]            ;3451
000072  6980              LDR      r0,[r0,#0x18]         ;3451
000074  f4206080          BIC      r0,r0,#0x400          ;3451
000078  6821              LDR      r1,[r4,#0]            ;3451
00007a  6188              STR      r0,[r1,#0x18]         ;3451
00007c  6820              LDR      r0,[r4,#0]            ;3452
00007e  6980              LDR      r0,[r0,#0x18]         ;3452
000080  6929              LDR      r1,[r5,#0x10]         ;3452
000082  ea402001          ORR      r0,r0,r1,LSL #8       ;3452
000086  6821              LDR      r1,[r4,#0]            ;3452
000088  6188              STR      r0,[r1,#0x18]         ;3452
00008a  e02f              B        |L69.236|
                  |L69.140|
00008c  4629              MOV      r1,r5                 ;3460
00008e  6820              LDR      r0,[r4,#0]            ;3460
000090  f7fffffe          BL       TIM_OC3_SetConfig
000094  6820              LDR      r0,[r4,#0]            ;3463
000096  69c0              LDR      r0,[r0,#0x1c]         ;3463
000098  f0400008          ORR      r0,r0,#8              ;3463
00009c  6821              LDR      r1,[r4,#0]            ;3463
00009e  61c8              STR      r0,[r1,#0x1c]         ;3463
0000a0  6820              LDR      r0,[r4,#0]            ;3466
0000a2  69c0              LDR      r0,[r0,#0x1c]         ;3466
0000a4  f0200004          BIC      r0,r0,#4              ;3466
0000a8  6821              LDR      r1,[r4,#0]            ;3466
0000aa  61c8              STR      r0,[r1,#0x1c]         ;3466
0000ac  6820              LDR      r0,[r4,#0]            ;3467
0000ae  69c0              LDR      r0,[r0,#0x1c]         ;3467
0000b0  6929              LDR      r1,[r5,#0x10]         ;3467
0000b2  4308              ORRS     r0,r0,r1              ;3467
0000b4  6821              LDR      r1,[r4,#0]            ;3467
0000b6  61c8              STR      r0,[r1,#0x1c]         ;3467
0000b8  e018              B        |L69.236|
                  |L69.186|
0000ba  4629              MOV      r1,r5                 ;3475
0000bc  6820              LDR      r0,[r4,#0]            ;3475
0000be  f7fffffe          BL       TIM_OC4_SetConfig
0000c2  6820              LDR      r0,[r4,#0]            ;3478
0000c4  69c0              LDR      r0,[r0,#0x1c]         ;3478
0000c6  f4406000          ORR      r0,r0,#0x800          ;3478
0000ca  6821              LDR      r1,[r4,#0]            ;3478
0000cc  61c8              STR      r0,[r1,#0x1c]         ;3478
0000ce  6820              LDR      r0,[r4,#0]            ;3481
0000d0  69c0              LDR      r0,[r0,#0x1c]         ;3481
0000d2  f4206080          BIC      r0,r0,#0x400          ;3481
0000d6  6821              LDR      r1,[r4,#0]            ;3481
0000d8  61c8              STR      r0,[r1,#0x1c]         ;3481
0000da  6820              LDR      r0,[r4,#0]            ;3482
0000dc  69c0              LDR      r0,[r0,#0x1c]         ;3482
0000de  6929              LDR      r1,[r5,#0x10]         ;3482
0000e0  ea402001          ORR      r0,r0,r1,LSL #8       ;3482
0000e4  6821              LDR      r1,[r4,#0]            ;3482
0000e6  61c8              STR      r0,[r1,#0x1c]         ;3482
0000e8  e000              B        |L69.236|
                  |L69.234|
0000ea  bf00              NOP                            ;3487
                  |L69.236|
0000ec  bf00              NOP                            ;3439
0000ee  2001              MOVS     r0,#1                 ;3490
0000f0  6420              STR      r0,[r4,#0x40]         ;3490
0000f2  bf00              NOP                            ;3492
0000f4  2000              MOVS     r0,#0                 ;3492
0000f6  63e0              STR      r0,[r4,#0x3c]         ;3492
0000f8  bf00              NOP                            ;3492
0000fa  bf00              NOP                            ;3494
0000fc  e789              B        |L69.18|
;;;3496   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_DeInit PROC
;;;1152     */
;;;1153   HAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1154   {
000002  4604              MOV      r4,r0
;;;1155     /* Check the parameters */
;;;1156     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1157     
;;;1158     htim->State = HAL_TIM_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  6420              STR      r0,[r4,#0x40]
;;;1159     
;;;1160     /* Disable the TIM Peripheral Clock */
;;;1161     __HAL_TIM_DISABLE(htim);
000008  bf00              NOP      
00000a  6820              LDR      r0,[r4,#0]
00000c  6a00              LDR      r0,[r0,#0x20]
00000e  f2411111          MOV      r1,#0x1111
000012  4008              ANDS     r0,r0,r1
000014  b950              CBNZ     r0,|L70.44|
000016  6820              LDR      r0,[r4,#0]
000018  6a00              LDR      r0,[r0,#0x20]
00001a  1089              ASRS     r1,r1,#2
00001c  4008              ANDS     r0,r0,r1
00001e  b928              CBNZ     r0,|L70.44|
000020  6820              LDR      r0,[r4,#0]
000022  6800              LDR      r0,[r0,#0]
000024  f0200001          BIC      r0,r0,#1
000028  6821              LDR      r1,[r4,#0]
00002a  6008              STR      r0,[r1,#0]
                  |L70.44|
00002c  bf00              NOP      
;;;1162   
;;;1163   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;1164     if(htim->PWM_MspDeInitCallback == NULL)
;;;1165     {
;;;1166       htim->PWM_MspDeInitCallback = HAL_TIM_PWM_MspDeInit;
;;;1167     }
;;;1168     /* DeInit the low level hardware */
;;;1169     htim->PWM_MspDeInitCallback(htim);
;;;1170   #else
;;;1171     /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;1172     HAL_TIM_PWM_MspDeInit(htim);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       HAL_TIM_PWM_MspDeInit
;;;1173   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;1174   
;;;1175     /* Change TIM state */  
;;;1176     htim->State = HAL_TIM_STATE_RESET; 
000034  2000              MOVS     r0,#0
000036  6420              STR      r0,[r4,#0x40]
;;;1177   
;;;1178     /* Release Lock */
;;;1179     __HAL_UNLOCK(htim);
000038  bf00              NOP      
00003a  63e0              STR      r0,[r4,#0x3c]
00003c  bf00              NOP      
;;;1180   
;;;1181     return HAL_OK;
;;;1182   }
00003e  bd10              POP      {r4,pc}
;;;1183   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_GetState||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_GetState PROC
;;;5256     */
;;;5257   HAL_TIM_StateTypeDef HAL_TIM_PWM_GetState(TIM_HandleTypeDef *htim)
000000  4601              MOV      r1,r0
;;;5258   {
;;;5259     return htim->State;
000002  6c08              LDR      r0,[r1,#0x40]
;;;5260   }
000004  4770              BX       lr
;;;5261   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_Init||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_Init PROC
;;;1100     */
;;;1101   HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
000000  b510              PUSH     {r4,lr}
;;;1102   {
000002  4604              MOV      r4,r0
;;;1103     /* Check the TIM handle allocation */
;;;1104     if(htim == NULL)
000004  b90c              CBNZ     r4,|L72.10|
;;;1105     {
;;;1106       return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L72.8|
;;;1107     }
;;;1108   
;;;1109     /* Check the parameters */
;;;1110     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1111     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;1112     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;1113     assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
;;;1114   
;;;1115     if(htim->State == HAL_TIM_STATE_RESET)
;;;1116     {
;;;1117       /* Allocate lock resource and initialize it */
;;;1118       htim->Lock = HAL_UNLOCKED;
;;;1119   
;;;1120   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;1121       /* Reset interrupt callbacks to legacy week callbacks */
;;;1122       TIM_ResetCallback(htim);
;;;1123   
;;;1124       if(htim->PWM_MspInitCallback == NULL)
;;;1125       {
;;;1126         htim->PWM_MspInitCallback = HAL_TIM_PWM_MspInit;
;;;1127       }
;;;1128       /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;1129       htim->PWM_MspInitCallback(htim);
;;;1130   #else
;;;1131       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;1132       HAL_TIM_PWM_MspInit(htim);
;;;1133   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;1134     }
;;;1135     /* Set the TIM state */
;;;1136     htim->State= HAL_TIM_STATE_BUSY;  
;;;1137     
;;;1138     /* Init the base time for the PWM */  
;;;1139     TIM_Base_SetConfig(htim->Instance, &htim->Init); 
;;;1140      
;;;1141     /* Initialize the TIM state*/
;;;1142     htim->State= HAL_TIM_STATE_READY;
;;;1143     
;;;1144     return HAL_OK;
;;;1145   }  
000008  bd10              POP      {r4,pc}
                  |L72.10|
00000a  6c20              LDR      r0,[r4,#0x40]         ;1115
00000c  b920              CBNZ     r0,|L72.24|
00000e  2000              MOVS     r0,#0                 ;1118
000010  63e0              STR      r0,[r4,#0x3c]         ;1118
000012  4620              MOV      r0,r4                 ;1132
000014  f7fffffe          BL       HAL_TIM_PWM_MspInit
                  |L72.24|
000018  2002              MOVS     r0,#2                 ;1136
00001a  6420              STR      r0,[r4,#0x40]         ;1136
00001c  1d21              ADDS     r1,r4,#4              ;1139
00001e  6820              LDR      r0,[r4,#0]            ;1139
000020  f7fffffe          BL       TIM_Base_SetConfig
000024  2001              MOVS     r0,#1                 ;1142
000026  6420              STR      r0,[r4,#0x40]         ;1142
000028  2000              MOVS     r0,#0                 ;1144
00002a  e7ed              B        |L72.8|
;;;1146   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_MspDeInit PROC
;;;1205     */
;;;1206   __weak void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1207   {
;;;1208     /* Prevent unused argument(s) compilation warning */
;;;1209     UNUSED(htim);
;;;1210    
;;;1211     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1212               the HAL_TIM_PWM_MspDeInit could be implemented in the user file
;;;1213      */
;;;1214   }
;;;1215   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_MspInit PROC
;;;1189     */
;;;1190   __weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;1191   {
;;;1192     /* Prevent unused argument(s) compilation warning */
;;;1193     UNUSED(htim);
;;;1194    
;;;1195     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1196               the HAL_TIM_PWM_MspInit could be implemented in the user file
;;;1197      */
;;;1198   }
;;;1199   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_PulseFinishedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PWM_PulseFinishedCallback PROC
;;;4735     */
;;;4736   __weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4737   {
;;;4738     /* Prevent unused argument(s) compilation warning */
;;;4739     UNUSED(htim);
;;;4740    
;;;4741     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4742               the __HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
;;;4743      */
;;;4744   }
;;;4745   
                          ENDP


                          AREA ||i.HAL_TIM_PWM_Start||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Start PROC
;;;1227     */
;;;1228   HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1229   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1230     /* Check the parameters */
;;;1231     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1232   
;;;1233     /* Enable the Capture compare channel */
;;;1234     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000006  2201              MOVS     r2,#1
000008  4629              MOV      r1,r5
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxChannelCmd
;;;1235     
;;;1236     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000010  490c              LDR      r1,|L76.68|
000012  6820              LDR      r0,[r4,#0]
000014  4288              CMP      r0,r1
000016  d003              BEQ      |L76.32|
000018  490b              LDR      r1,|L76.72|
00001a  6820              LDR      r0,[r4,#0]
00001c  4288              CMP      r0,r1
00001e  d101              BNE      |L76.36|
                  |L76.32|
000020  2001              MOVS     r0,#1
000022  e000              B        |L76.38|
                  |L76.36|
000024  2000              MOVS     r0,#0
                  |L76.38|
000026  b128              CBZ      r0,|L76.52|
;;;1237     {
;;;1238       /* Enable the main output */
;;;1239       __HAL_TIM_MOE_ENABLE(htim);
000028  6820              LDR      r0,[r4,#0]
00002a  6c40              LDR      r0,[r0,#0x44]
00002c  f4404000          ORR      r0,r0,#0x8000
000030  6821              LDR      r1,[r4,#0]
000032  6448              STR      r0,[r1,#0x44]
                  |L76.52|
;;;1240     }
;;;1241       
;;;1242     /* Enable the Peripheral */
;;;1243     __HAL_TIM_ENABLE(htim);
000034  6820              LDR      r0,[r4,#0]
000036  6800              LDR      r0,[r0,#0]
000038  f0400001          ORR      r0,r0,#1
00003c  6821              LDR      r1,[r4,#0]
00003e  6008              STR      r0,[r1,#0]
;;;1244     
;;;1245     /* Return function status */
;;;1246     return HAL_OK;
000040  2000              MOVS     r0,#0
;;;1247   } 
000042  bd30              POP      {r4,r5,pc}
;;;1248   
                          ENDP

                  |L76.68|
                          DCD      0x40010000
                  |L76.72|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_PWM_Start_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Start_DMA PROC
;;;1432     */
;;;1433   HAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1434   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
00000a  461f              MOV      r7,r3
;;;1435     /* Check the parameters */
;;;1436     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1437     
;;;1438     if((htim->State == HAL_TIM_STATE_BUSY))
00000c  6c20              LDR      r0,[r4,#0x40]
00000e  2802              CMP      r0,#2
000010  d101              BNE      |L77.22|
                  |L77.18|
;;;1439     {
;;;1440        return HAL_BUSY;
;;;1441     }
;;;1442     else if((htim->State == HAL_TIM_STATE_READY))
;;;1443     {
;;;1444       if(((uint32_t)pData == 0 ) && (Length > 0)) 
;;;1445       {
;;;1446         return HAL_ERROR;                                    
;;;1447       }
;;;1448       else
;;;1449       {
;;;1450         htim->State = HAL_TIM_STATE_BUSY;
;;;1451       }
;;;1452     }    
;;;1453     switch (Channel)
;;;1454     {
;;;1455       case TIM_CHANNEL_1:
;;;1456       {      
;;;1457         /* Set the DMA Period elapsed callback */
;;;1458         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;1459        
;;;1460         /* Set the DMA error callback */
;;;1461         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = HAL_TIM_DMAError ;
;;;1462         
;;;1463         /* Enable the DMA Stream */
;;;1464         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
;;;1465         
;;;1466         /* Enable the TIM Capture/Compare 1 DMA request */
;;;1467         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;1468       }
;;;1469       break;
;;;1470       
;;;1471       case TIM_CHANNEL_2:
;;;1472       {
;;;1473         /* Set the DMA Period elapsed callback */
;;;1474         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;1475        
;;;1476         /* Set the DMA error callback */
;;;1477         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = HAL_TIM_DMAError ;
;;;1478         
;;;1479         /* Enable the DMA Stream */
;;;1480         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
;;;1481         
;;;1482         /* Enable the TIM Capture/Compare 2 DMA request */
;;;1483         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;1484       }
;;;1485       break;
;;;1486       
;;;1487       case TIM_CHANNEL_3:
;;;1488       {
;;;1489         /* Set the DMA Period elapsed callback */
;;;1490         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;1491        
;;;1492         /* Set the DMA error callback */
;;;1493         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = HAL_TIM_DMAError ;
;;;1494         
;;;1495         /* Enable the DMA Stream */
;;;1496         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
;;;1497         
;;;1498         /* Enable the TIM Output Capture/Compare 3 request */
;;;1499         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;1500       }
;;;1501       break;
;;;1502       
;;;1503       case TIM_CHANNEL_4:
;;;1504       {
;;;1505        /* Set the DMA Period elapsed callback */
;;;1506         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = HAL_TIM_DMADelayPulseCplt;
;;;1507        
;;;1508         /* Set the DMA error callback */
;;;1509         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = HAL_TIM_DMAError ;
;;;1510         
;;;1511         /* Enable the DMA Stream */
;;;1512         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
;;;1513         
;;;1514         /* Enable the TIM Capture/Compare 4 DMA request */
;;;1515         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;1516       }
;;;1517       break;
;;;1518       
;;;1519       default:
;;;1520       break;
;;;1521     }
;;;1522   
;;;1523     /* Enable the Capture compare channel */
;;;1524     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1525       
;;;1526     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
;;;1527     {
;;;1528       /* Enable the main output */
;;;1529       __HAL_TIM_MOE_ENABLE(htim);
;;;1530     }
;;;1531     
;;;1532     /* Enable the Peripheral */
;;;1533     __HAL_TIM_ENABLE(htim); 
;;;1534     
;;;1535     /* Return function status */
;;;1536     return HAL_OK;
;;;1537   }
000012  e8bd81f0          POP      {r4-r8,pc}
                  |L77.22|
000016  6c20              LDR      r0,[r4,#0x40]         ;1442
000018  2801              CMP      r0,#1                 ;1442
00001a  d105              BNE      |L77.40|
00001c  b915              CBNZ     r5,|L77.36|
00001e  2f00              CMP      r7,#0                 ;1444
000020  dd00              BLE      |L77.36|
000022  e7f6              B        |L77.18|
                  |L77.36|
000024  2002              MOVS     r0,#2                 ;1450
000026  6420              STR      r0,[r4,#0x40]         ;1450
                  |L77.40|
000028  b136              CBZ      r6,|L77.56|
00002a  2e04              CMP      r6,#4                 ;1453
00002c  d019              BEQ      |L77.98|
00002e  2e08              CMP      r6,#8                 ;1453
000030  d02c              BEQ      |L77.140|
000032  2e0c              CMP      r6,#0xc               ;1453
000034  d154              BNE      |L77.224|
000036  e03e              B        |L77.182|
                  |L77.56|
000038  493a              LDR      r1,|L77.292|
00003a  6a60              LDR      r0,[r4,#0x24]         ;1458
00003c  6401              STR      r1,[r0,#0x40]         ;1458
00003e  493a              LDR      r1,|L77.296|
000040  6a60              LDR      r0,[r4,#0x24]         ;1461
000042  6501              STR      r1,[r0,#0x50]         ;1461
000044  6821              LDR      r1,[r4,#0]            ;1464
000046  f1010234          ADD      r2,r1,#0x34           ;1464
00004a  463b              MOV      r3,r7                 ;1464
00004c  4629              MOV      r1,r5                 ;1464
00004e  6a60              LDR      r0,[r4,#0x24]         ;1464
000050  f7fffffe          BL       HAL_DMA_Start_IT
000054  6820              LDR      r0,[r4,#0]            ;1467
000056  68c0              LDR      r0,[r0,#0xc]          ;1467
000058  f4407000          ORR      r0,r0,#0x200          ;1467
00005c  6821              LDR      r1,[r4,#0]            ;1467
00005e  60c8              STR      r0,[r1,#0xc]          ;1467
000060  e03f              B        |L77.226|
                  |L77.98|
000062  4930              LDR      r1,|L77.292|
000064  6aa0              LDR      r0,[r4,#0x28]         ;1474
000066  6401              STR      r1,[r0,#0x40]         ;1474
000068  492f              LDR      r1,|L77.296|
00006a  6aa0              LDR      r0,[r4,#0x28]         ;1477
00006c  6501              STR      r1,[r0,#0x50]         ;1477
00006e  6821              LDR      r1,[r4,#0]            ;1480
000070  f1010238          ADD      r2,r1,#0x38           ;1480
000074  463b              MOV      r3,r7                 ;1480
000076  4629              MOV      r1,r5                 ;1480
000078  6aa0              LDR      r0,[r4,#0x28]         ;1480
00007a  f7fffffe          BL       HAL_DMA_Start_IT
00007e  6820              LDR      r0,[r4,#0]            ;1483
000080  68c0              LDR      r0,[r0,#0xc]          ;1483
000082  f4406080          ORR      r0,r0,#0x400          ;1483
000086  6821              LDR      r1,[r4,#0]            ;1483
000088  60c8              STR      r0,[r1,#0xc]          ;1483
00008a  e02a              B        |L77.226|
                  |L77.140|
00008c  4925              LDR      r1,|L77.292|
00008e  6ae0              LDR      r0,[r4,#0x2c]         ;1490
000090  6401              STR      r1,[r0,#0x40]         ;1490
000092  4925              LDR      r1,|L77.296|
000094  6ae0              LDR      r0,[r4,#0x2c]         ;1493
000096  6501              STR      r1,[r0,#0x50]         ;1493
000098  6821              LDR      r1,[r4,#0]            ;1496
00009a  f101023c          ADD      r2,r1,#0x3c           ;1496
00009e  463b              MOV      r3,r7                 ;1496
0000a0  4629              MOV      r1,r5                 ;1496
0000a2  6ae0              LDR      r0,[r4,#0x2c]         ;1496
0000a4  f7fffffe          BL       HAL_DMA_Start_IT
0000a8  6820              LDR      r0,[r4,#0]            ;1499
0000aa  68c0              LDR      r0,[r0,#0xc]          ;1499
0000ac  f4406000          ORR      r0,r0,#0x800          ;1499
0000b0  6821              LDR      r1,[r4,#0]            ;1499
0000b2  60c8              STR      r0,[r1,#0xc]          ;1499
0000b4  e015              B        |L77.226|
                  |L77.182|
0000b6  491b              LDR      r1,|L77.292|
0000b8  6b20              LDR      r0,[r4,#0x30]         ;1506
0000ba  6401              STR      r1,[r0,#0x40]         ;1506
0000bc  491a              LDR      r1,|L77.296|
0000be  6b20              LDR      r0,[r4,#0x30]         ;1509
0000c0  6501              STR      r1,[r0,#0x50]         ;1509
0000c2  6821              LDR      r1,[r4,#0]            ;1512
0000c4  f1010240          ADD      r2,r1,#0x40           ;1512
0000c8  463b              MOV      r3,r7                 ;1512
0000ca  4629              MOV      r1,r5                 ;1512
0000cc  6b20              LDR      r0,[r4,#0x30]         ;1512
0000ce  f7fffffe          BL       HAL_DMA_Start_IT
0000d2  6820              LDR      r0,[r4,#0]            ;1515
0000d4  68c0              LDR      r0,[r0,#0xc]          ;1515
0000d6  f4405080          ORR      r0,r0,#0x1000         ;1515
0000da  6821              LDR      r1,[r4,#0]            ;1515
0000dc  60c8              STR      r0,[r1,#0xc]          ;1515
0000de  e000              B        |L77.226|
                  |L77.224|
0000e0  bf00              NOP                            ;1520
                  |L77.226|
0000e2  bf00              NOP                            ;1469
0000e4  2201              MOVS     r2,#1                 ;1524
0000e6  4631              MOV      r1,r6                 ;1524
0000e8  6820              LDR      r0,[r4,#0]            ;1524
0000ea  f7fffffe          BL       TIM_CCxChannelCmd
0000ee  490f              LDR      r1,|L77.300|
0000f0  6820              LDR      r0,[r4,#0]            ;1526
0000f2  4288              CMP      r0,r1                 ;1526
0000f4  d003              BEQ      |L77.254|
0000f6  490e              LDR      r1,|L77.304|
0000f8  6820              LDR      r0,[r4,#0]            ;1526
0000fa  4288              CMP      r0,r1                 ;1526
0000fc  d101              BNE      |L77.258|
                  |L77.254|
0000fe  2001              MOVS     r0,#1                 ;1526
000100  e000              B        |L77.260|
                  |L77.258|
000102  2000              MOVS     r0,#0                 ;1526
                  |L77.260|
000104  b128              CBZ      r0,|L77.274|
000106  6820              LDR      r0,[r4,#0]            ;1529
000108  6c40              LDR      r0,[r0,#0x44]         ;1529
00010a  f4404000          ORR      r0,r0,#0x8000         ;1529
00010e  6821              LDR      r1,[r4,#0]            ;1529
000110  6448              STR      r0,[r1,#0x44]         ;1529
                  |L77.274|
000112  6820              LDR      r0,[r4,#0]            ;1533
000114  6800              LDR      r0,[r0,#0]            ;1533
000116  f0400001          ORR      r0,r0,#1              ;1533
00011a  6821              LDR      r1,[r4,#0]            ;1533
00011c  6008              STR      r0,[r1,#0]            ;1533
00011e  2000              MOVS     r0,#0                 ;1536
000120  e777              B        |L77.18|
;;;1538   
                          ENDP

000122  0000              DCW      0x0000
                  |L77.292|
                          DCD      TIM_DMADelayPulseCplt
                  |L77.296|
                          DCD      TIM_DMAError
                  |L77.300|
                          DCD      0x40010000
                  |L77.304|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_PWM_Start_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Start_IT PROC
;;;1296     */
;;;1297   HAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1298   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1299     /* Check the parameters */
;;;1300     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1301     
;;;1302     switch (Channel)
000006  b135              CBZ      r5,|L78.22|
000008  2d04              CMP      r5,#4
00000a  d00b              BEQ      |L78.36|
00000c  2d08              CMP      r5,#8
00000e  d010              BEQ      |L78.50|
000010  2d0c              CMP      r5,#0xc
000012  d11c              BNE      |L78.78|
000014  e014              B        |L78.64|
                  |L78.22|
;;;1303     {
;;;1304       case TIM_CHANNEL_1:
;;;1305       {       
;;;1306         /* Enable the TIM Capture/Compare 1 interrupt */
;;;1307         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000016  6820              LDR      r0,[r4,#0]
000018  68c0              LDR      r0,[r0,#0xc]
00001a  f0400002          ORR      r0,r0,#2
00001e  6821              LDR      r1,[r4,#0]
000020  60c8              STR      r0,[r1,#0xc]
;;;1308       }
;;;1309       break;
000022  e015              B        |L78.80|
                  |L78.36|
;;;1310       
;;;1311       case TIM_CHANNEL_2:
;;;1312       {
;;;1313         /* Enable the TIM Capture/Compare 2 interrupt */
;;;1314         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000024  6820              LDR      r0,[r4,#0]
000026  68c0              LDR      r0,[r0,#0xc]
000028  f0400004          ORR      r0,r0,#4
00002c  6821              LDR      r1,[r4,#0]
00002e  60c8              STR      r0,[r1,#0xc]
;;;1315       }
;;;1316       break;
000030  e00e              B        |L78.80|
                  |L78.50|
;;;1317       
;;;1318       case TIM_CHANNEL_3:
;;;1319       {
;;;1320         /* Enable the TIM Capture/Compare 3 interrupt */
;;;1321         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
000032  6820              LDR      r0,[r4,#0]
000034  68c0              LDR      r0,[r0,#0xc]
000036  f0400008          ORR      r0,r0,#8
00003a  6821              LDR      r1,[r4,#0]
00003c  60c8              STR      r0,[r1,#0xc]
;;;1322       }
;;;1323       break;
00003e  e007              B        |L78.80|
                  |L78.64|
;;;1324       
;;;1325       case TIM_CHANNEL_4:
;;;1326       {
;;;1327         /* Enable the TIM Capture/Compare 4 interrupt */
;;;1328         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
000040  6820              LDR      r0,[r4,#0]
000042  68c0              LDR      r0,[r0,#0xc]
000044  f0400010          ORR      r0,r0,#0x10
000048  6821              LDR      r1,[r4,#0]
00004a  60c8              STR      r0,[r1,#0xc]
;;;1329       }
;;;1330       break;
00004c  e000              B        |L78.80|
                  |L78.78|
;;;1331       
;;;1332       default:
;;;1333       break;
00004e  bf00              NOP      
                  |L78.80|
000050  bf00              NOP                            ;1309
;;;1334     } 
;;;1335     
;;;1336     /* Enable the Capture compare channel */
;;;1337     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000052  2201              MOVS     r2,#1
000054  4629              MOV      r1,r5
000056  6820              LDR      r0,[r4,#0]
000058  f7fffffe          BL       TIM_CCxChannelCmd
;;;1338     
;;;1339     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00005c  490c              LDR      r1,|L78.144|
00005e  6820              LDR      r0,[r4,#0]
000060  4288              CMP      r0,r1
000062  d003              BEQ      |L78.108|
000064  490b              LDR      r1,|L78.148|
000066  6820              LDR      r0,[r4,#0]
000068  4288              CMP      r0,r1
00006a  d101              BNE      |L78.112|
                  |L78.108|
00006c  2001              MOVS     r0,#1
00006e  e000              B        |L78.114|
                  |L78.112|
000070  2000              MOVS     r0,#0
                  |L78.114|
000072  b128              CBZ      r0,|L78.128|
;;;1340     {
;;;1341       /* Enable the main output */
;;;1342       __HAL_TIM_MOE_ENABLE(htim);
000074  6820              LDR      r0,[r4,#0]
000076  6c40              LDR      r0,[r0,#0x44]
000078  f4404000          ORR      r0,r0,#0x8000
00007c  6821              LDR      r1,[r4,#0]
00007e  6448              STR      r0,[r1,#0x44]
                  |L78.128|
;;;1343     }
;;;1344   
;;;1345     /* Enable the Peripheral */
;;;1346     __HAL_TIM_ENABLE(htim);
000080  6820              LDR      r0,[r4,#0]
000082  6800              LDR      r0,[r0,#0]
000084  f0400001          ORR      r0,r0,#1
000088  6821              LDR      r1,[r4,#0]
00008a  6008              STR      r0,[r1,#0]
;;;1347     
;;;1348     /* Return function status */
;;;1349     return HAL_OK;
00008c  2000              MOVS     r0,#0
;;;1350   } 
00008e  bd30              POP      {r4,r5,pc}
;;;1351   
                          ENDP

                  |L78.144|
                          DCD      0x40010000
                  |L78.148|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_PWM_Stop||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Stop PROC
;;;1260     */
;;;1261   HAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1262   { 
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1263     /* Check the parameters */
;;;1264     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1265       
;;;1266     /* Disable the Capture compare channel */
;;;1267     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000006  2200              MOVS     r2,#0
000008  4629              MOV      r1,r5
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       TIM_CCxChannelCmd
;;;1268     
;;;1269     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
000010  491a              LDR      r1,|L79.124|
000012  6820              LDR      r0,[r4,#0]
000014  4288              CMP      r0,r1
000016  d003              BEQ      |L79.32|
000018  4919              LDR      r1,|L79.128|
00001a  6820              LDR      r0,[r4,#0]
00001c  4288              CMP      r0,r1
00001e  d101              BNE      |L79.36|
                  |L79.32|
000020  2001              MOVS     r0,#1
000022  e000              B        |L79.38|
                  |L79.36|
000024  2000              MOVS     r0,#0
                  |L79.38|
000026  b190              CBZ      r0,|L79.78|
;;;1270     {
;;;1271       /* Disable the Main Output */
;;;1272       __HAL_TIM_MOE_DISABLE(htim);
000028  bf00              NOP      
00002a  6820              LDR      r0,[r4,#0]
00002c  6a00              LDR      r0,[r0,#0x20]
00002e  f2411111          MOV      r1,#0x1111
000032  4008              ANDS     r0,r0,r1
000034  b950              CBNZ     r0,|L79.76|
000036  6820              LDR      r0,[r4,#0]
000038  6a00              LDR      r0,[r0,#0x20]
00003a  1089              ASRS     r1,r1,#2
00003c  4008              ANDS     r0,r0,r1
00003e  b928              CBNZ     r0,|L79.76|
000040  6820              LDR      r0,[r4,#0]
000042  6c40              LDR      r0,[r0,#0x44]
000044  f4204000          BIC      r0,r0,#0x8000
000048  6821              LDR      r1,[r4,#0]
00004a  6448              STR      r0,[r1,#0x44]
                  |L79.76|
00004c  bf00              NOP      
                  |L79.78|
;;;1273     }
;;;1274     
;;;1275     /* Disable the Peripheral */
;;;1276     __HAL_TIM_DISABLE(htim);
00004e  bf00              NOP      
000050  6820              LDR      r0,[r4,#0]
000052  6a00              LDR      r0,[r0,#0x20]
000054  f2411111          MOV      r1,#0x1111
000058  4008              ANDS     r0,r0,r1
00005a  b950              CBNZ     r0,|L79.114|
00005c  6820              LDR      r0,[r4,#0]
00005e  6a00              LDR      r0,[r0,#0x20]
000060  1089              ASRS     r1,r1,#2
000062  4008              ANDS     r0,r0,r1
000064  b928              CBNZ     r0,|L79.114|
000066  6820              LDR      r0,[r4,#0]
000068  6800              LDR      r0,[r0,#0]
00006a  f0200001          BIC      r0,r0,#1
00006e  6821              LDR      r1,[r4,#0]
000070  6008              STR      r0,[r1,#0]
                  |L79.114|
000072  bf00              NOP      
;;;1277     
;;;1278     /* Change the htim state */
;;;1279     htim->State = HAL_TIM_STATE_READY;
000074  2001              MOVS     r0,#1
000076  6420              STR      r0,[r4,#0x40]
;;;1280     
;;;1281     /* Return function status */
;;;1282     return HAL_OK;
000078  2000              MOVS     r0,#0
;;;1283   } 
00007a  bd30              POP      {r4,r5,pc}
;;;1284   
                          ENDP

                  |L79.124|
                          DCD      0x40010000
                  |L79.128|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_PWM_Stop_DMA||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Stop_DMA PROC
;;;1550     */
;;;1551   HAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1552   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1553     /* Check the parameters */
;;;1554     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1555     
;;;1556     switch (Channel)
000006  b135              CBZ      r5,|L80.22|
000008  2d04              CMP      r5,#4
00000a  d00b              BEQ      |L80.36|
00000c  2d08              CMP      r5,#8
00000e  d010              BEQ      |L80.50|
000010  2d0c              CMP      r5,#0xc
000012  d11c              BNE      |L80.78|
000014  e014              B        |L80.64|
                  |L80.22|
;;;1557     {
;;;1558       case TIM_CHANNEL_1:
;;;1559       {       
;;;1560         /* Disable the TIM Capture/Compare 1 DMA request */
;;;1561         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000016  6820              LDR      r0,[r4,#0]
000018  68c0              LDR      r0,[r0,#0xc]
00001a  f4207000          BIC      r0,r0,#0x200
00001e  6821              LDR      r1,[r4,#0]
000020  60c8              STR      r0,[r1,#0xc]
;;;1562       }
;;;1563       break;
000022  e015              B        |L80.80|
                  |L80.36|
;;;1564       
;;;1565       case TIM_CHANNEL_2:
;;;1566       {
;;;1567         /* Disable the TIM Capture/Compare 2 DMA request */
;;;1568         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000024  6820              LDR      r0,[r4,#0]
000026  68c0              LDR      r0,[r0,#0xc]
000028  f4206080          BIC      r0,r0,#0x400
00002c  6821              LDR      r1,[r4,#0]
00002e  60c8              STR      r0,[r1,#0xc]
;;;1569       }
;;;1570       break;
000030  e00e              B        |L80.80|
                  |L80.50|
;;;1571       
;;;1572       case TIM_CHANNEL_3:
;;;1573       {
;;;1574         /* Disable the TIM Capture/Compare 3 DMA request */
;;;1575         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
000032  6820              LDR      r0,[r4,#0]
000034  68c0              LDR      r0,[r0,#0xc]
000036  f4206000          BIC      r0,r0,#0x800
00003a  6821              LDR      r1,[r4,#0]
00003c  60c8              STR      r0,[r1,#0xc]
;;;1576       }
;;;1577       break;
00003e  e007              B        |L80.80|
                  |L80.64|
;;;1578       
;;;1579       case TIM_CHANNEL_4:
;;;1580       {
;;;1581         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1582         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
000040  6820              LDR      r0,[r4,#0]
000042  68c0              LDR      r0,[r0,#0xc]
000044  f4205080          BIC      r0,r0,#0x1000
000048  6821              LDR      r1,[r4,#0]
00004a  60c8              STR      r0,[r1,#0xc]
;;;1583       }
;;;1584       break;
00004c  e000              B        |L80.80|
                  |L80.78|
;;;1585       
;;;1586       default:
;;;1587       break;
00004e  bf00              NOP      
                  |L80.80|
000050  bf00              NOP                            ;1563
;;;1588     } 
;;;1589     
;;;1590     /* Disable the Capture compare channel */
;;;1591     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000052  2200              MOVS     r2,#0
000054  4629              MOV      r1,r5
000056  6820              LDR      r0,[r4,#0]
000058  f7fffffe          BL       TIM_CCxChannelCmd
;;;1592     
;;;1593     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00005c  491a              LDR      r1,|L80.200|
00005e  6820              LDR      r0,[r4,#0]
000060  4288              CMP      r0,r1
000062  d003              BEQ      |L80.108|
000064  4919              LDR      r1,|L80.204|
000066  6820              LDR      r0,[r4,#0]
000068  4288              CMP      r0,r1
00006a  d101              BNE      |L80.112|
                  |L80.108|
00006c  2001              MOVS     r0,#1
00006e  e000              B        |L80.114|
                  |L80.112|
000070  2000              MOVS     r0,#0
                  |L80.114|
000072  b190              CBZ      r0,|L80.154|
;;;1594     {
;;;1595       /* Disable the Main Output */
;;;1596       __HAL_TIM_MOE_DISABLE(htim);
000074  bf00              NOP      
000076  6820              LDR      r0,[r4,#0]
000078  6a00              LDR      r0,[r0,#0x20]
00007a  f2411111          MOV      r1,#0x1111
00007e  4008              ANDS     r0,r0,r1
000080  b950              CBNZ     r0,|L80.152|
000082  6820              LDR      r0,[r4,#0]
000084  6a00              LDR      r0,[r0,#0x20]
000086  1089              ASRS     r1,r1,#2
000088  4008              ANDS     r0,r0,r1
00008a  b928              CBNZ     r0,|L80.152|
00008c  6820              LDR      r0,[r4,#0]
00008e  6c40              LDR      r0,[r0,#0x44]
000090  f4204000          BIC      r0,r0,#0x8000
000094  6821              LDR      r1,[r4,#0]
000096  6448              STR      r0,[r1,#0x44]
                  |L80.152|
000098  bf00              NOP      
                  |L80.154|
;;;1597     }
;;;1598     
;;;1599     /* Disable the Peripheral */
;;;1600     __HAL_TIM_DISABLE(htim);
00009a  bf00              NOP      
00009c  6820              LDR      r0,[r4,#0]
00009e  6a00              LDR      r0,[r0,#0x20]
0000a0  f2411111          MOV      r1,#0x1111
0000a4  4008              ANDS     r0,r0,r1
0000a6  b950              CBNZ     r0,|L80.190|
0000a8  6820              LDR      r0,[r4,#0]
0000aa  6a00              LDR      r0,[r0,#0x20]
0000ac  1089              ASRS     r1,r1,#2
0000ae  4008              ANDS     r0,r0,r1
0000b0  b928              CBNZ     r0,|L80.190|
0000b2  6820              LDR      r0,[r4,#0]
0000b4  6800              LDR      r0,[r0,#0]
0000b6  f0200001          BIC      r0,r0,#1
0000ba  6821              LDR      r1,[r4,#0]
0000bc  6008              STR      r0,[r1,#0]
                  |L80.190|
0000be  bf00              NOP      
;;;1601     
;;;1602     /* Change the htim state */
;;;1603     htim->State = HAL_TIM_STATE_READY;
0000c0  2001              MOVS     r0,#1
0000c2  6420              STR      r0,[r4,#0x40]
;;;1604     
;;;1605     /* Return function status */
;;;1606     return HAL_OK;
0000c4  2000              MOVS     r0,#0
;;;1607   }
0000c6  bd30              POP      {r4,r5,pc}
;;;1608   
                          ENDP

                  |L80.200|
                          DCD      0x40010000
                  |L80.204|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_PWM_Stop_IT||, CODE, READONLY, ALIGN=2

                  HAL_TIM_PWM_Stop_IT PROC
;;;1363     */
;;;1364   HAL_StatusTypeDef HAL_TIM_PWM_Stop_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
000000  b530              PUSH     {r4,r5,lr}
;;;1365   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1366     /* Check the parameters */
;;;1367     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1368     
;;;1369     switch (Channel)
000006  b135              CBZ      r5,|L81.22|
000008  2d04              CMP      r5,#4
00000a  d00b              BEQ      |L81.36|
00000c  2d08              CMP      r5,#8
00000e  d010              BEQ      |L81.50|
000010  2d0c              CMP      r5,#0xc
000012  d11c              BNE      |L81.78|
000014  e014              B        |L81.64|
                  |L81.22|
;;;1370     {
;;;1371       case TIM_CHANNEL_1:
;;;1372       {       
;;;1373         /* Disable the TIM Capture/Compare 1 interrupt */
;;;1374         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000016  6820              LDR      r0,[r4,#0]
000018  68c0              LDR      r0,[r0,#0xc]
00001a  f0200002          BIC      r0,r0,#2
00001e  6821              LDR      r1,[r4,#0]
000020  60c8              STR      r0,[r1,#0xc]
;;;1375       }
;;;1376       break;
000022  e015              B        |L81.80|
                  |L81.36|
;;;1377       
;;;1378       case TIM_CHANNEL_2:
;;;1379       {
;;;1380         /* Disable the TIM Capture/Compare 2 interrupt */
;;;1381         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000024  6820              LDR      r0,[r4,#0]
000026  68c0              LDR      r0,[r0,#0xc]
000028  f0200004          BIC      r0,r0,#4
00002c  6821              LDR      r1,[r4,#0]
00002e  60c8              STR      r0,[r1,#0xc]
;;;1382       }
;;;1383       break;
000030  e00e              B        |L81.80|
                  |L81.50|
;;;1384       
;;;1385       case TIM_CHANNEL_3:
;;;1386       {
;;;1387         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1388         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
000032  6820              LDR      r0,[r4,#0]
000034  68c0              LDR      r0,[r0,#0xc]
000036  f0200008          BIC      r0,r0,#8
00003a  6821              LDR      r1,[r4,#0]
00003c  60c8              STR      r0,[r1,#0xc]
;;;1389       }
;;;1390       break;
00003e  e007              B        |L81.80|
                  |L81.64|
;;;1391       
;;;1392       case TIM_CHANNEL_4:
;;;1393       {
;;;1394         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1395         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
000040  6820              LDR      r0,[r4,#0]
000042  68c0              LDR      r0,[r0,#0xc]
000044  f0200010          BIC      r0,r0,#0x10
000048  6821              LDR      r1,[r4,#0]
00004a  60c8              STR      r0,[r1,#0xc]
;;;1396       }
;;;1397       break;
00004c  e000              B        |L81.80|
                  |L81.78|
;;;1398       
;;;1399       default:
;;;1400       break; 
00004e  bf00              NOP      
                  |L81.80|
000050  bf00              NOP                            ;1376
;;;1401     }
;;;1402     
;;;1403     /* Disable the Capture compare channel */
;;;1404     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000052  2200              MOVS     r2,#0
000054  4629              MOV      r1,r5
000056  6820              LDR      r0,[r4,#0]
000058  f7fffffe          BL       TIM_CCxChannelCmd
;;;1405     
;;;1406     if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
00005c  4919              LDR      r1,|L81.196|
00005e  6820              LDR      r0,[r4,#0]
000060  4288              CMP      r0,r1
000062  d003              BEQ      |L81.108|
000064  4918              LDR      r1,|L81.200|
000066  6820              LDR      r0,[r4,#0]
000068  4288              CMP      r0,r1
00006a  d101              BNE      |L81.112|
                  |L81.108|
00006c  2001              MOVS     r0,#1
00006e  e000              B        |L81.114|
                  |L81.112|
000070  2000              MOVS     r0,#0
                  |L81.114|
000072  b190              CBZ      r0,|L81.154|
;;;1407     {
;;;1408       /* Disable the Main Output */
;;;1409       __HAL_TIM_MOE_DISABLE(htim);
000074  bf00              NOP      
000076  6820              LDR      r0,[r4,#0]
000078  6a00              LDR      r0,[r0,#0x20]
00007a  f2411111          MOV      r1,#0x1111
00007e  4008              ANDS     r0,r0,r1
000080  b950              CBNZ     r0,|L81.152|
000082  6820              LDR      r0,[r4,#0]
000084  6a00              LDR      r0,[r0,#0x20]
000086  1089              ASRS     r1,r1,#2
000088  4008              ANDS     r0,r0,r1
00008a  b928              CBNZ     r0,|L81.152|
00008c  6820              LDR      r0,[r4,#0]
00008e  6c40              LDR      r0,[r0,#0x44]
000090  f4204000          BIC      r0,r0,#0x8000
000094  6821              LDR      r1,[r4,#0]
000096  6448              STR      r0,[r1,#0x44]
                  |L81.152|
000098  bf00              NOP      
                  |L81.154|
;;;1410     }
;;;1411     
;;;1412     /* Disable the Peripheral */
;;;1413     __HAL_TIM_DISABLE(htim);
00009a  bf00              NOP      
00009c  6820              LDR      r0,[r4,#0]
00009e  6a00              LDR      r0,[r0,#0x20]
0000a0  f2411111          MOV      r1,#0x1111
0000a4  4008              ANDS     r0,r0,r1
0000a6  b950              CBNZ     r0,|L81.190|
0000a8  6820              LDR      r0,[r4,#0]
0000aa  6a00              LDR      r0,[r0,#0x20]
0000ac  1089              ASRS     r1,r1,#2
0000ae  4008              ANDS     r0,r0,r1
0000b0  b928              CBNZ     r0,|L81.190|
0000b2  6820              LDR      r0,[r4,#0]
0000b4  6800              LDR      r0,[r0,#0]
0000b6  f0200001          BIC      r0,r0,#1
0000ba  6821              LDR      r1,[r4,#0]
0000bc  6008              STR      r0,[r1,#0]
                  |L81.190|
0000be  bf00              NOP      
;;;1414     
;;;1415     /* Return function status */
;;;1416     return HAL_OK;
0000c0  2000              MOVS     r0,#0
;;;1417   } 
0000c2  bd30              POP      {r4,r5,pc}
;;;1418   
                          ENDP

                  |L81.196|
                          DCD      0x40010000
                  |L81.200|
                          DCD      0x40010400

                          AREA ||i.HAL_TIM_PeriodElapsedCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_PeriodElapsedCallback PROC
;;;4688     */
;;;4689   __weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4690   {
;;;4691     /* Prevent unused argument(s) compilation warning */
;;;4692     UNUSED(htim);
;;;4693    
;;;4694     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4695               the __HAL_TIM_PeriodElapsedCallback could be implemented in the user file
;;;4696      */
;;;4697     
;;;4698   }
;;;4699   /**
                          ENDP


                          AREA ||i.HAL_TIM_ReadCapturedValue||, CODE, READONLY, ALIGN=1

                  HAL_TIM_ReadCapturedValue PROC
;;;4598     */
;;;4599   uint32_t HAL_TIM_ReadCapturedValue(TIM_HandleTypeDef *htim, uint32_t Channel)
000000  4602              MOV      r2,r0
;;;4600   {
;;;4601     uint32_t tmpreg = 0;
000002  2300              MOVS     r3,#0
;;;4602     
;;;4603     __HAL_LOCK(htim);
000004  bf00              NOP      
000006  6bd0              LDR      r0,[r2,#0x3c]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L83.16|
00000c  2002              MOVS     r0,#2
                  |L83.14|
;;;4604     
;;;4605     switch (Channel)
;;;4606     {
;;;4607       case TIM_CHANNEL_1:
;;;4608       {
;;;4609         /* Check the parameters */
;;;4610         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4611         
;;;4612         /* Return the capture 1 value */
;;;4613         tmpreg = htim->Instance->CCR1;
;;;4614         
;;;4615         break;
;;;4616       }
;;;4617       case TIM_CHANNEL_2:
;;;4618       {
;;;4619         /* Check the parameters */
;;;4620         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4621         
;;;4622         /* Return the capture 2 value */
;;;4623         tmpreg = htim->Instance->CCR2;
;;;4624         
;;;4625         break;
;;;4626       }
;;;4627       
;;;4628       case TIM_CHANNEL_3:
;;;4629       {
;;;4630         /* Check the parameters */
;;;4631         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;4632         
;;;4633         /* Return the capture 3 value */
;;;4634         tmpreg = htim->Instance->CCR3;
;;;4635         
;;;4636         break;
;;;4637       }
;;;4638       
;;;4639       case TIM_CHANNEL_4:
;;;4640       {
;;;4641         /* Check the parameters */
;;;4642         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;4643         
;;;4644         /* Return the capture 4 value */
;;;4645         tmpreg = htim->Instance->CCR4;
;;;4646         
;;;4647         break;
;;;4648       }
;;;4649       
;;;4650       default:
;;;4651       break;  
;;;4652     }
;;;4653        
;;;4654     __HAL_UNLOCK(htim);  
;;;4655     return tmpreg;
;;;4656   }
00000e  4770              BX       lr
                  |L83.16|
000010  2001              MOVS     r0,#1                 ;4603
000012  63d0              STR      r0,[r2,#0x3c]         ;4603
000014  bf00              NOP                            ;4603
000016  b131              CBZ      r1,|L83.38|
000018  2904              CMP      r1,#4                 ;4605
00001a  d007              BEQ      |L83.44|
00001c  2908              CMP      r1,#8                 ;4605
00001e  d008              BEQ      |L83.50|
000020  290c              CMP      r1,#0xc               ;4605
000022  d10c              BNE      |L83.62|
000024  e008              B        |L83.56|
                  |L83.38|
000026  6810              LDR      r0,[r2,#0]            ;4613
000028  6b43              LDR      r3,[r0,#0x34]         ;4613
00002a  e009              B        |L83.64|
                  |L83.44|
00002c  6810              LDR      r0,[r2,#0]            ;4623
00002e  6b83              LDR      r3,[r0,#0x38]         ;4623
000030  e006              B        |L83.64|
                  |L83.50|
000032  6810              LDR      r0,[r2,#0]            ;4634
000034  6bc3              LDR      r3,[r0,#0x3c]         ;4634
000036  e003              B        |L83.64|
                  |L83.56|
000038  6810              LDR      r0,[r2,#0]            ;4645
00003a  6c03              LDR      r3,[r0,#0x40]         ;4645
00003c  e000              B        |L83.64|
                  |L83.62|
00003e  bf00              NOP                            ;4651
                  |L83.64|
000040  bf00              NOP                            ;4615
000042  bf00              NOP                            ;4654
000044  2000              MOVS     r0,#0                 ;4654
000046  63d0              STR      r0,[r2,#0x3c]         ;4654
000048  bf00              NOP                            ;4654
00004a  4618              MOV      r0,r3                 ;4655
00004c  e7df              B        |L83.14|
;;;4657   
                          ENDP


                          AREA ||i.HAL_TIM_SlaveConfigSynchronization||, CODE, READONLY, ALIGN=2

                  HAL_TIM_SlaveConfigSynchronization PROC
;;;4412     */
;;;4413   HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization(TIM_HandleTypeDef *htim, TIM_SlaveConfigTypeDef * sSlaveConfig)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;4414   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;4415     uint32_t tmpsmcr  = 0;
000008  2600              MOVS     r6,#0
;;;4416     uint32_t tmpccmr1 = 0;
00000a  2700              MOVS     r7,#0
;;;4417     uint32_t tmpccer = 0;
00000c  46b0              MOV      r8,r6
;;;4418   
;;;4419     /* Check the parameters */
;;;4420     assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
;;;4421     assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
;;;4422     assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
;;;4423      
;;;4424     __HAL_LOCK(htim);
00000e  bf00              NOP      
000010  6be0              LDR      r0,[r4,#0x3c]
000012  2801              CMP      r0,#1
000014  d102              BNE      |L84.28|
000016  2002              MOVS     r0,#2
                  |L84.24|
;;;4425     
;;;4426     htim->State = HAL_TIM_STATE_BUSY;
;;;4427   
;;;4428     /* Get the TIMx SMCR register value */
;;;4429     tmpsmcr = htim->Instance->SMCR;
;;;4430   
;;;4431     /* Reset the Trigger Selection Bits */
;;;4432     tmpsmcr &= ~TIM_SMCR_TS;
;;;4433     /* Set the Input Trigger source */
;;;4434     tmpsmcr |= sSlaveConfig->InputTrigger;
;;;4435   
;;;4436     /* Reset the slave mode Bits */
;;;4437     tmpsmcr &= ~TIM_SMCR_SMS;
;;;4438     /* Set the slave mode */
;;;4439     tmpsmcr |= sSlaveConfig->SlaveMode;
;;;4440   
;;;4441     /* Write to TIMx SMCR */
;;;4442     htim->Instance->SMCR = tmpsmcr;
;;;4443     
;;;4444     /* Configure the trigger prescaler, filter, and polarity */
;;;4445     switch (sSlaveConfig->InputTrigger)
;;;4446     {
;;;4447     case TIM_TS_ETRF:
;;;4448       {
;;;4449         /* Check the parameters */
;;;4450         assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
;;;4451         assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));
;;;4452         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;4453         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;4454         /* Configure the ETR Trigger source */
;;;4455         TIM_ETR_SetConfig(htim->Instance, 
;;;4456                           sSlaveConfig->TriggerPrescaler, 
;;;4457                           sSlaveConfig->TriggerPolarity, 
;;;4458                           sSlaveConfig->TriggerFilter);
;;;4459       }
;;;4460       break;
;;;4461       
;;;4462     case TIM_TS_TI1F_ED:
;;;4463       {
;;;4464         /* Check the parameters */
;;;4465         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4466         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;4467         
;;;4468         /* Disable the Channel 1: Reset the CC1E Bit */
;;;4469         tmpccer = htim->Instance->CCER;
;;;4470         htim->Instance->CCER &= ~TIM_CCER_CC1E;
;;;4471         tmpccmr1 = htim->Instance->CCMR1;    
;;;4472         
;;;4473         /* Set the filter */
;;;4474         tmpccmr1 &= ~TIM_CCMR1_IC1F;
;;;4475         tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4);
;;;4476         
;;;4477         /* Write to TIMx CCMR1 and CCER registers */
;;;4478         htim->Instance->CCMR1 = tmpccmr1;
;;;4479         htim->Instance->CCER = tmpccer;                               
;;;4480                                  
;;;4481       }
;;;4482       break;
;;;4483       
;;;4484     case TIM_TS_TI1FP1:
;;;4485       {
;;;4486         /* Check the parameters */
;;;4487         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4488         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;4489         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;4490   
;;;4491         /* Configure TI1 Filter and Polarity */
;;;4492         TIM_TI1_ConfigInputStage(htim->Instance,
;;;4493                                  sSlaveConfig->TriggerPolarity,
;;;4494                                  sSlaveConfig->TriggerFilter);
;;;4495       }
;;;4496       break;
;;;4497       
;;;4498     case TIM_TS_TI2FP2:
;;;4499       {
;;;4500         /* Check the parameters */
;;;4501         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4502         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;4503         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;4504         
;;;4505         /* Configure TI2 Filter and Polarity */
;;;4506         TIM_TI2_ConfigInputStage(htim->Instance,
;;;4507                                   sSlaveConfig->TriggerPolarity,
;;;4508                                   sSlaveConfig->TriggerFilter);
;;;4509       }
;;;4510       break;
;;;4511       
;;;4512     case TIM_TS_ITR0:
;;;4513       {
;;;4514         /* Check the parameter */
;;;4515         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4516       }
;;;4517       break;
;;;4518       
;;;4519     case TIM_TS_ITR1:
;;;4520       {
;;;4521         /* Check the parameter */
;;;4522         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4523       }
;;;4524       break;
;;;4525       
;;;4526     case TIM_TS_ITR2:
;;;4527       {
;;;4528         /* Check the parameter */
;;;4529         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4530       }
;;;4531       break;
;;;4532       
;;;4533     case TIM_TS_ITR3:
;;;4534       {
;;;4535         /* Check the parameter */
;;;4536         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4537       }
;;;4538       break;
;;;4539          
;;;4540     default:
;;;4541       break;
;;;4542     }
;;;4543     
;;;4544     htim->State = HAL_TIM_STATE_READY;
;;;4545        
;;;4546     __HAL_UNLOCK(htim);  
;;;4547     
;;;4548     return HAL_OK;
;;;4549   } 
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L84.28|
00001c  2001              MOVS     r0,#1                 ;4424
00001e  63e0              STR      r0,[r4,#0x3c]         ;4424
000020  bf00              NOP                            ;4424
000022  2002              MOVS     r0,#2                 ;4426
000024  6420              STR      r0,[r4,#0x40]         ;4426
000026  6820              LDR      r0,[r4,#0]            ;4429
000028  6886              LDR      r6,[r0,#8]            ;4429
00002a  f0260670          BIC      r6,r6,#0x70           ;4432
00002e  6868              LDR      r0,[r5,#4]            ;4434
000030  4306              ORRS     r6,r6,r0              ;4434
000032  4825              LDR      r0,|L84.200|
000034  4006              ANDS     r6,r6,r0              ;4437
000036  6828              LDR      r0,[r5,#0]            ;4439
000038  4306              ORRS     r6,r6,r0              ;4439
00003a  6820              LDR      r0,[r4,#0]            ;4442
00003c  6086              STR      r6,[r0,#8]            ;4442
00003e  6868              LDR      r0,[r5,#4]            ;4445
000040  f000010f          AND      r1,r0,#0xf            ;4445
000044  2900              CMP      r1,#0                 ;4445
000046  d135              BNE      |L84.180|
000048  1100              ASRS     r0,r0,#4              ;4445
00004a  2808              CMP      r0,#8                 ;4445
00004c  d232              BCS      |L84.180|
00004e  e8dff000          TBB      [pc,r0]               ;4445
000052  2d2e              DCB      0x2d,0x2e
000054  2f300b21          DCB      0x2f,0x30,0x0b,0x21
000058  2704              DCB      0x27,0x04
00005a  e9d51303          LDRD     r1,r3,[r5,#0xc]       ;4455
00005e  68aa              LDR      r2,[r5,#8]            ;4455
000060  6820              LDR      r0,[r4,#0]            ;4455
000062  f7fffffe          BL       TIM_ETR_SetConfig
000066  e026              B        |L84.182|
000068  6820              LDR      r0,[r4,#0]            ;4469
00006a  f8d08020          LDR      r8,[r0,#0x20]         ;4469
00006e  6820              LDR      r0,[r4,#0]            ;4470
000070  6a00              LDR      r0,[r0,#0x20]         ;4470
000072  f0200001          BIC      r0,r0,#1              ;4470
000076  6821              LDR      r1,[r4,#0]            ;4470
000078  6208              STR      r0,[r1,#0x20]         ;4470
00007a  6820              LDR      r0,[r4,#0]            ;4471
00007c  6987              LDR      r7,[r0,#0x18]         ;4471
00007e  f02707f0          BIC      r7,r7,#0xf0           ;4474
000082  6928              LDR      r0,[r5,#0x10]         ;4475
000084  ea471700          ORR      r7,r7,r0,LSL #4       ;4475
000088  6820              LDR      r0,[r4,#0]            ;4478
00008a  6187              STR      r7,[r0,#0x18]         ;4478
00008c  6820              LDR      r0,[r4,#0]            ;4479
00008e  f8c08020          STR      r8,[r0,#0x20]         ;4479
000092  e010              B        |L84.182|
000094  692a              LDR      r2,[r5,#0x10]         ;4492
000096  68a9              LDR      r1,[r5,#8]            ;4492
000098  6820              LDR      r0,[r4,#0]            ;4492
00009a  f7fffffe          BL       TIM_TI1_ConfigInputStage
00009e  e00a              B        |L84.182|
0000a0  692a              LDR      r2,[r5,#0x10]         ;4506
0000a2  68a9              LDR      r1,[r5,#8]            ;4506
0000a4  6820              LDR      r0,[r4,#0]            ;4506
0000a6  f7fffffe          BL       TIM_TI2_ConfigInputStage
0000aa  e004              B        |L84.182|
0000ac  e003              B        |L84.182|
0000ae  e002              B        |L84.182|
0000b0  e001              B        |L84.182|
0000b2  e000              B        |L84.182|
                  |L84.180|
0000b4  bf00              NOP                            ;4541
                  |L84.182|
0000b6  bf00              NOP                            ;4460
0000b8  2001              MOVS     r0,#1                 ;4544
0000ba  6420              STR      r0,[r4,#0x40]         ;4544
0000bc  bf00              NOP                            ;4546
0000be  2000              MOVS     r0,#0                 ;4546
0000c0  63e0              STR      r0,[r4,#0x3c]         ;4546
0000c2  bf00              NOP                            ;4546
0000c4  bf00              NOP                            ;4548
0000c6  e7a7              B        |L84.24|
;;;4550   
                          ENDP

                  |L84.200|
                          DCD      0xfffefff8

                          AREA ||i.HAL_TIM_SlaveConfigSynchronization_IT||, CODE, READONLY, ALIGN=1

                  HAL_TIM_SlaveConfigSynchronization_IT PROC
;;;4559     */
;;;4560   HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization_IT(TIM_HandleTypeDef *htim, 
000000  b570              PUSH     {r4-r6,lr}
;;;4561                                                           TIM_SlaveConfigTypeDef * sSlaveConfig)
;;;4562   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;4563     /* Check the parameters */
;;;4564     assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
;;;4565     assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
;;;4566     assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
;;;4567     
;;;4568     __HAL_LOCK(htim);
000006  bf00              NOP      
000008  6be0              LDR      r0,[r4,#0x3c]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L85.18|
00000e  2002              MOVS     r0,#2
                  |L85.16|
;;;4569   
;;;4570     htim->State = HAL_TIM_STATE_BUSY;
;;;4571     
;;;4572     TIM_SlaveTimer_SetConfig(htim, sSlaveConfig);
;;;4573     
;;;4574     /* Enable Trigger Interrupt */
;;;4575     __HAL_TIM_ENABLE_IT(htim, TIM_IT_TRIGGER);
;;;4576     
;;;4577     /* Disable Trigger DMA request */
;;;4578     __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
;;;4579     
;;;4580     htim->State = HAL_TIM_STATE_READY;
;;;4581        
;;;4582     __HAL_UNLOCK(htim);  
;;;4583     
;;;4584     return HAL_OK;
;;;4585   }
000010  bd70              POP      {r4-r6,pc}
                  |L85.18|
000012  2001              MOVS     r0,#1                 ;4568
000014  63e0              STR      r0,[r4,#0x3c]         ;4568
000016  bf00              NOP                            ;4568
000018  2002              MOVS     r0,#2                 ;4570
00001a  6420              STR      r0,[r4,#0x40]         ;4570
00001c  4629              MOV      r1,r5                 ;4572
00001e  4620              MOV      r0,r4                 ;4572
000020  f7fffffe          BL       TIM_SlaveTimer_SetConfig
000024  6820              LDR      r0,[r4,#0]            ;4575
000026  68c0              LDR      r0,[r0,#0xc]          ;4575
000028  f0400040          ORR      r0,r0,#0x40           ;4575
00002c  6821              LDR      r1,[r4,#0]            ;4575
00002e  60c8              STR      r0,[r1,#0xc]          ;4575
000030  6820              LDR      r0,[r4,#0]            ;4578
000032  68c0              LDR      r0,[r0,#0xc]          ;4578
000034  f4204080          BIC      r0,r0,#0x4000         ;4578
000038  6821              LDR      r1,[r4,#0]            ;4578
00003a  60c8              STR      r0,[r1,#0xc]          ;4578
00003c  2001              MOVS     r0,#1                 ;4580
00003e  6420              STR      r0,[r4,#0x40]         ;4580
000040  bf00              NOP                            ;4582
000042  2000              MOVS     r0,#0                 ;4582
000044  63e0              STR      r0,[r4,#0x3c]         ;4582
000046  bf00              NOP                            ;4582
000048  bf00              NOP                            ;4584
00004a  e7e1              B        |L85.16|
;;;4586   
                          ENDP


                          AREA ||i.HAL_TIM_TriggerCallback||, CODE, READONLY, ALIGN=1

                  HAL_TIM_TriggerCallback PROC
;;;4751     */
;;;4752   __weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
000000  4770              BX       lr
;;;4753   {
;;;4754     /* Prevent unused argument(s) compilation warning */
;;;4755     UNUSED(htim);
;;;4756    
;;;4757     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4758               the HAL_TIM_TriggerCallback could be implemented in the user file
;;;4759      */
;;;4760   }
;;;4761   
                          ENDP


                          AREA ||i.TIM_Base_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_Base_SetConfig PROC
;;;5431     */
;;;5432   void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
000000  b510              PUSH     {r4,lr}
;;;5433   {
;;;5434     uint32_t tmpcr1 = 0;
000002  2200              MOVS     r2,#0
;;;5435     tmpcr1 = TIMx->CR1;
000004  6802              LDR      r2,[r0,#0]
;;;5436     
;;;5437     /* Set TIM Time Base Unit parameters ---------------------------------------*/
;;;5438     if(IS_TIM_CC3_INSTANCE(TIMx) != RESET)   
000006  4b2f              LDR      r3,|L87.196|
000008  4298              CMP      r0,r3
00000a  d00e              BEQ      |L87.42|
00000c  f1b04f80          CMP      r0,#0x40000000
000010  d00b              BEQ      |L87.42|
000012  4b2d              LDR      r3,|L87.200|
000014  4298              CMP      r0,r3
000016  d008              BEQ      |L87.42|
000018  4b2c              LDR      r3,|L87.204|
00001a  4298              CMP      r0,r3
00001c  d005              BEQ      |L87.42|
00001e  4b2c              LDR      r3,|L87.208|
000020  4298              CMP      r0,r3
000022  d002              BEQ      |L87.42|
000024  4b2b              LDR      r3,|L87.212|
000026  4298              CMP      r0,r3
000028  d101              BNE      |L87.46|
                  |L87.42|
00002a  2301              MOVS     r3,#1
00002c  e000              B        |L87.48|
                  |L87.46|
00002e  2300              MOVS     r3,#0
                  |L87.48|
000030  b11b              CBZ      r3,|L87.58|
;;;5439     {
;;;5440       /* Select the Counter Mode */
;;;5441       tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
000032  f0220270          BIC      r2,r2,#0x70
;;;5442       tmpcr1 |= Structure->CounterMode;
000036  684b              LDR      r3,[r1,#4]
000038  431a              ORRS     r2,r2,r3
                  |L87.58|
;;;5443     }
;;;5444    
;;;5445     if(IS_TIM_CC1_INSTANCE(TIMx) != RESET)  
00003a  4b22              LDR      r3,|L87.196|
00003c  4298              CMP      r0,r3
00003e  d020              BEQ      |L87.130|
000040  f1b04f80          CMP      r0,#0x40000000
000044  d01d              BEQ      |L87.130|
000046  4b20              LDR      r3,|L87.200|
000048  4298              CMP      r0,r3
00004a  d01a              BEQ      |L87.130|
00004c  4b1f              LDR      r3,|L87.204|
00004e  4298              CMP      r0,r3
000050  d017              BEQ      |L87.130|
000052  4b1f              LDR      r3,|L87.208|
000054  4298              CMP      r0,r3
000056  d014              BEQ      |L87.130|
000058  4b1e              LDR      r3,|L87.212|
00005a  4298              CMP      r0,r3
00005c  d011              BEQ      |L87.130|
00005e  4b1e              LDR      r3,|L87.216|
000060  4298              CMP      r0,r3
000062  d00e              BEQ      |L87.130|
000064  4b1d              LDR      r3,|L87.220|
000066  4298              CMP      r0,r3
000068  d00b              BEQ      |L87.130|
00006a  4b1d              LDR      r3,|L87.224|
00006c  4298              CMP      r0,r3
00006e  d008              BEQ      |L87.130|
000070  4b1c              LDR      r3,|L87.228|
000072  4298              CMP      r0,r3
000074  d005              BEQ      |L87.130|
000076  4b1c              LDR      r3,|L87.232|
000078  4298              CMP      r0,r3
00007a  d002              BEQ      |L87.130|
00007c  4b1b              LDR      r3,|L87.236|
00007e  4298              CMP      r0,r3
000080  d101              BNE      |L87.134|
                  |L87.130|
000082  2301              MOVS     r3,#1
000084  e000              B        |L87.136|
                  |L87.134|
000086  2300              MOVS     r3,#0
                  |L87.136|
000088  b11b              CBZ      r3,|L87.146|
;;;5446     {
;;;5447       /* Set the clock division */
;;;5448       tmpcr1 &= ~TIM_CR1_CKD;
00008a  f4227240          BIC      r2,r2,#0x300
;;;5449       tmpcr1 |= (uint32_t)Structure->ClockDivision;
00008e  68cb              LDR      r3,[r1,#0xc]
000090  431a              ORRS     r2,r2,r3
                  |L87.146|
;;;5450     }
;;;5451   
;;;5452     /* Set the auto-reload preload */
;;;5453     MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
000092  f0220380          BIC      r3,r2,#0x80
000096  694c              LDR      r4,[r1,#0x14]
000098  ea430204          ORR      r2,r3,r4
;;;5454   
;;;5455     TIMx->CR1 = tmpcr1;
00009c  6002              STR      r2,[r0,#0]
;;;5456   
;;;5457     /* Set the Auto-reload value */
;;;5458     TIMx->ARR = (uint32_t)Structure->Period ;
00009e  688b              LDR      r3,[r1,#8]
0000a0  62c3              STR      r3,[r0,#0x2c]
;;;5459    
;;;5460     /* Set the Prescaler value */
;;;5461     TIMx->PSC = (uint32_t)Structure->Prescaler;
0000a2  680b              LDR      r3,[r1,#0]
0000a4  6283              STR      r3,[r0,#0x28]
;;;5462       
;;;5463     if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)  
0000a6  4b07              LDR      r3,|L87.196|
0000a8  4298              CMP      r0,r3
0000aa  d002              BEQ      |L87.178|
0000ac  4b09              LDR      r3,|L87.212|
0000ae  4298              CMP      r0,r3
0000b0  d101              BNE      |L87.182|
                  |L87.178|
0000b2  2301              MOVS     r3,#1
0000b4  e000              B        |L87.184|
                  |L87.182|
0000b6  2300              MOVS     r3,#0
                  |L87.184|
0000b8  b10b              CBZ      r3,|L87.190|
;;;5464     {
;;;5465       /* Set the Repetition Counter value */
;;;5466       TIMx->RCR = Structure->RepetitionCounter;
0000ba  690b              LDR      r3,[r1,#0x10]
0000bc  6303              STR      r3,[r0,#0x30]
                  |L87.190|
;;;5467     }
;;;5468   
;;;5469     /* Generate an update event to reload the Prescaler 
;;;5470        and the repetition counter(only for TIM1 and TIM8) value immediately */
;;;5471     TIMx->EGR = TIM_EGR_UG;
0000be  2301              MOVS     r3,#1
0000c0  6143              STR      r3,[r0,#0x14]
;;;5472   }
0000c2  bd10              POP      {r4,pc}
;;;5473   
                          ENDP

                  |L87.196|
                          DCD      0x40010000
                  |L87.200|
                          DCD      0x40000400
                  |L87.204|
                          DCD      0x40000800
                  |L87.208|
                          DCD      0x40000c00
                  |L87.212|
                          DCD      0x40010400
                  |L87.216|
                          DCD      0x40014000
                  |L87.220|
                          DCD      0x40014400
                  |L87.224|
                          DCD      0x40014800
                  |L87.228|
                          DCD      0x40001800
                  |L87.232|
                          DCD      0x40001c00
                  |L87.236|
                          DCD      0x40002000

                          AREA ||i.TIM_CCxChannelCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxChannelCmd PROC
;;;6205     */
;;;6206   void TIM_CCxChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelState)
000000  b530              PUSH     {r4,r5,lr}
;;;6207   {
;;;6208     uint32_t tmp = 0;
000002  2300              MOVS     r3,#0
;;;6209   
;;;6210     /* Check the parameters */
;;;6211     assert_param(IS_TIM_CC1_INSTANCE(TIMx)); 
;;;6212     assert_param(IS_TIM_CHANNELS(Channel));
;;;6213   
;;;6214     tmp = TIM_CCER_CC1E << Channel;
000004  2401              MOVS     r4,#1
000006  fa04f301          LSL      r3,r4,r1
;;;6215   
;;;6216     /* Reset the CCxE Bit */
;;;6217     TIMx->CCER &= ~tmp;
00000a  6a04              LDR      r4,[r0,#0x20]
00000c  439c              BICS     r4,r4,r3
00000e  6204              STR      r4,[r0,#0x20]
;;;6218   
;;;6219     /* Set or reset the CCxE Bit */ 
;;;6220     TIMx->CCER |= (uint32_t)(ChannelState << Channel);
000010  6a04              LDR      r4,[r0,#0x20]
000012  fa02f501          LSL      r5,r2,r1
000016  432c              ORRS     r4,r4,r5
000018  6204              STR      r4,[r0,#0x20]
;;;6221   }
00001a  bd30              POP      {r4,r5,pc}
;;;6222   
                          ENDP


                          AREA ||i.TIM_DMACaptureCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMACaptureCplt PROC
;;;5358     */
;;;5359   void HAL_TIM_DMACaptureCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;5360   {
000002  4605              MOV      r5,r0
;;;5361     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6bec              LDR      r4,[r5,#0x3c]
;;;5362       
;;;5363      htim->State= HAL_TIM_STATE_READY; 
000006  2001              MOVS     r0,#1
000008  6420              STR      r0,[r4,#0x40]
;;;5364       
;;;5365     if (hdma == htim->hdma[TIM_DMA_ID_CC1])
00000a  6a60              LDR      r0,[r4,#0x24]
00000c  42a8              CMP      r0,r5
00000e  d102              BNE      |L89.22|
;;;5366     {
;;;5367       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
000010  2001              MOVS     r0,#1
000012  61e0              STR      r0,[r4,#0x1c]
000014  e010              B        |L89.56|
                  |L89.22|
;;;5368     }
;;;5369     else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
000016  6aa0              LDR      r0,[r4,#0x28]
000018  42a8              CMP      r0,r5
00001a  d102              BNE      |L89.34|
;;;5370     {
;;;5371       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
00001c  2002              MOVS     r0,#2
00001e  61e0              STR      r0,[r4,#0x1c]
000020  e00a              B        |L89.56|
                  |L89.34|
;;;5372     }
;;;5373     else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
000022  6ae0              LDR      r0,[r4,#0x2c]
000024  42a8              CMP      r0,r5
000026  d102              BNE      |L89.46|
;;;5374     {
;;;5375       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
000028  2004              MOVS     r0,#4
00002a  61e0              STR      r0,[r4,#0x1c]
00002c  e004              B        |L89.56|
                  |L89.46|
;;;5376     }
;;;5377     else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
00002e  6b20              LDR      r0,[r4,#0x30]
000030  42a8              CMP      r0,r5
000032  d101              BNE      |L89.56|
;;;5378     {
;;;5379       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
000034  2008              MOVS     r0,#8
000036  61e0              STR      r0,[r4,#0x1c]
                  |L89.56|
;;;5380     }
;;;5381   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;5382     htim->IC_CaptureCallback(htim);
;;;5383   #else
;;;5384     HAL_TIM_IC_CaptureCallback(htim);
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
;;;5385   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;5386     htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
00003e  2000              MOVS     r0,#0
000040  61e0              STR      r0,[r4,#0x1c]
;;;5387   
;;;5388   }
000042  bd70              POP      {r4-r6,pc}
;;;5389   
                          ENDP


                          AREA ||i.TIM_DMADelayPulseCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMADelayPulseCplt PROC
;;;5322     */
;;;5323   void HAL_TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;5324   {
000002  4605              MOV      r5,r0
;;;5325     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6bec              LDR      r4,[r5,#0x3c]
;;;5326     
;;;5327     htim->State= HAL_TIM_STATE_READY; 
000006  2001              MOVS     r0,#1
000008  6420              STR      r0,[r4,#0x40]
;;;5328     
;;;5329     if (hdma == htim->hdma[TIM_DMA_ID_CC1])
00000a  6a60              LDR      r0,[r4,#0x24]
00000c  42a8              CMP      r0,r5
00000e  d102              BNE      |L90.22|
;;;5330     {
;;;5331       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
000010  2001              MOVS     r0,#1
000012  61e0              STR      r0,[r4,#0x1c]
000014  e010              B        |L90.56|
                  |L90.22|
;;;5332     }
;;;5333     else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
000016  6aa0              LDR      r0,[r4,#0x28]
000018  42a8              CMP      r0,r5
00001a  d102              BNE      |L90.34|
;;;5334     {
;;;5335       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
00001c  2002              MOVS     r0,#2
00001e  61e0              STR      r0,[r4,#0x1c]
000020  e00a              B        |L90.56|
                  |L90.34|
;;;5336     }
;;;5337     else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
000022  6ae0              LDR      r0,[r4,#0x2c]
000024  42a8              CMP      r0,r5
000026  d102              BNE      |L90.46|
;;;5338     {
;;;5339       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
000028  2004              MOVS     r0,#4
00002a  61e0              STR      r0,[r4,#0x1c]
00002c  e004              B        |L90.56|
                  |L90.46|
;;;5340     }
;;;5341     else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
00002e  6b20              LDR      r0,[r4,#0x30]
000030  42a8              CMP      r0,r5
000032  d101              BNE      |L90.56|
;;;5342     {
;;;5343       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
000034  2008              MOVS     r0,#8
000036  61e0              STR      r0,[r4,#0x1c]
                  |L90.56|
;;;5344     }
;;;5345   
;;;5346   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;5347     htim->PWM_PulseFinishedCallback(htim);
;;;5348   #else
;;;5349     HAL_TIM_PWM_PulseFinishedCallback(htim);
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
;;;5350   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;5351     htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
00003e  2000              MOVS     r0,#0
000040  61e0              STR      r0,[r4,#0x1c]
;;;5352   }
000042  bd70              POP      {r4-r6,pc}
;;;5353   /**
                          ENDP


                          AREA ||i.TIM_DMAError||, CODE, READONLY, ALIGN=1

                  TIM_DMAError PROC
;;;5304     */
;;;5305   void HAL_TIM_DMAError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;5306   {
000002  4604              MOV      r4,r0
;;;5307     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6be5              LDR      r5,[r4,#0x3c]
;;;5308     
;;;5309     htim->State= HAL_TIM_STATE_READY;
000006  2001              MOVS     r0,#1
000008  6428              STR      r0,[r5,#0x40]
;;;5310   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;5311      htim->ErrorCallback(htim);
;;;5312   #else
;;;5313     HAL_TIM_ErrorCallback(htim);
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       HAL_TIM_ErrorCallback
;;;5314   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;5315   }
000010  bd70              POP      {r4-r6,pc}
;;;5316   
                          ENDP


                          AREA ||i.TIM_DMAPeriodElapsedCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMAPeriodElapsedCplt PROC
;;;5395     */
;;;5396   static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;5397   {
000002  4604              MOV      r4,r0
;;;5398     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6be5              LDR      r5,[r4,#0x3c]
;;;5399   
;;;5400     htim->State= HAL_TIM_STATE_READY;
000006  2001              MOVS     r0,#1
000008  6428              STR      r0,[r5,#0x40]
;;;5401   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;5402     htim->PeriodElapsedCallback(htim);
;;;5403   #else
;;;5404     HAL_TIM_PeriodElapsedCallback(htim);
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       HAL_TIM_PeriodElapsedCallback
;;;5405   #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;5406   }
000010  bd70              POP      {r4-r6,pc}
;;;5407   
                          ENDP


                          AREA ||i.TIM_DMATriggerCplt||, CODE, READONLY, ALIGN=1

                  TIM_DMATriggerCplt PROC
;;;5413     */
;;;5414   static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;5415   {
000002  4604              MOV      r4,r0
;;;5416     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;  
000004  6be5              LDR      r5,[r4,#0x3c]
;;;5417     
;;;5418     htim->State= HAL_TIM_STATE_READY; 
000006  2001              MOVS     r0,#1
000008  6428              STR      r0,[r5,#0x40]
;;;5419   #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
;;;5420     htim->TriggerCallback(htim);
;;;5421   #else
;;;5422     HAL_TIM_TriggerCallback(htim);
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       HAL_TIM_TriggerCallback
;;;5423    #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
;;;5424   }
000010  bd70              POP      {r4-r6,pc}
;;;5425   
                          ENDP


                          AREA ||i.TIM_ETR_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_ETR_SetConfig PROC
;;;6175     */
;;;6176   void TIM_ETR_SetConfig(TIM_TypeDef* TIMx, uint32_t TIM_ExtTRGPrescaler,
000000  b530              PUSH     {r4,r5,lr}
;;;6177                          uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
;;;6178   {
000002  460c              MOV      r4,r1
;;;6179     uint32_t tmpsmcr = 0;
000004  2100              MOVS     r1,#0
;;;6180   
;;;6181     tmpsmcr = TIMx->SMCR;
000006  6881              LDR      r1,[r0,#8]
;;;6182   
;;;6183     /* Reset the ETR Bits */
;;;6184     tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
000008  f421417f          BIC      r1,r1,#0xff00
;;;6185   
;;;6186     /* Set the Prescaler, the Filter value and the Polarity */
;;;6187     tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8)));
00000c  ea422503          ORR      r5,r2,r3,LSL #8
000010  4325              ORRS     r5,r5,r4
000012  4329              ORRS     r1,r1,r5
;;;6188   
;;;6189     /* Write to TIMx SMCR */
;;;6190     TIMx->SMCR = tmpsmcr;
000014  6081              STR      r1,[r0,#8]
;;;6191   } 
000016  bd30              POP      {r4,r5,pc}
;;;6192   
                          ENDP


                          AREA ||i.TIM_ITRx_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITRx_SetConfig PROC
;;;6144     */
;;;6145   static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint16_t TIM_ITRx)
000000  460a              MOV      r2,r1
;;;6146   {
;;;6147     uint32_t tmpsmcr = 0;
000002  2100              MOVS     r1,#0
;;;6148     
;;;6149      /* Get the TIMx SMCR register value */
;;;6150      tmpsmcr = TIMx->SMCR;
000004  6881              LDR      r1,[r0,#8]
;;;6151      /* Reset the TS Bits */
;;;6152      tmpsmcr &= ~TIM_SMCR_TS;
000006  f0210170          BIC      r1,r1,#0x70
;;;6153      /* Set the Input Trigger source and the slave mode*/
;;;6154      tmpsmcr |= TIM_ITRx | TIM_SLAVEMODE_EXTERNAL1;
00000a  f0420307          ORR      r3,r2,#7
00000e  4319              ORRS     r1,r1,r3
;;;6155      /* Write to TIMx SMCR */
;;;6156      TIMx->SMCR = tmpsmcr;
000010  6081              STR      r1,[r0,#8]
;;;6157   }
000012  4770              BX       lr
;;;6158   
                          ENDP


                          AREA ||i.TIM_OC1_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC1_SetConfig PROC
;;;5479     */
;;;5480   void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b530              PUSH     {r4,r5,lr}
;;;5481   {
;;;5482     uint32_t tmpccmrx = 0;
000002  2400              MOVS     r4,#0
;;;5483     uint32_t tmpccer = 0;
000004  2200              MOVS     r2,#0
;;;5484     uint32_t tmpcr2 = 0;  
000006  2300              MOVS     r3,#0
;;;5485   
;;;5486     /* Disable the Channel 1: Reset the CC1E Bit */
;;;5487     TIMx->CCER &= ~TIM_CCER_CC1E;
000008  6a05              LDR      r5,[r0,#0x20]
00000a  f0250501          BIC      r5,r5,#1
00000e  6205              STR      r5,[r0,#0x20]
;;;5488     
;;;5489     /* Get the TIMx CCER register value */
;;;5490     tmpccer = TIMx->CCER;
000010  6a02              LDR      r2,[r0,#0x20]
;;;5491     /* Get the TIMx CR2 register value */
;;;5492     tmpcr2 = TIMx->CR2;
000012  6843              LDR      r3,[r0,#4]
;;;5493     
;;;5494     /* Get the TIMx CCMR1 register value */
;;;5495     tmpccmrx = TIMx->CCMR1;
000014  6984              LDR      r4,[r0,#0x18]
;;;5496       
;;;5497     /* Reset the Output Compare Mode Bits */
;;;5498     tmpccmrx &= ~TIM_CCMR1_OC1M;
000016  4d14              LDR      r5,|L96.104|
000018  402c              ANDS     r4,r4,r5
;;;5499     tmpccmrx &= ~TIM_CCMR1_CC1S;
00001a  f0240403          BIC      r4,r4,#3
;;;5500     /* Select the Output Compare Mode */
;;;5501     tmpccmrx |= OC_Config->OCMode;
00001e  680d              LDR      r5,[r1,#0]
000020  432c              ORRS     r4,r4,r5
;;;5502     
;;;5503     /* Reset the Output Polarity level */
;;;5504     tmpccer &= ~TIM_CCER_CC1P;
000022  f0220202          BIC      r2,r2,#2
;;;5505     /* Set the Output Compare Polarity */
;;;5506     tmpccer |= OC_Config->OCPolarity;
000026  688d              LDR      r5,[r1,#8]
000028  432a              ORRS     r2,r2,r5
;;;5507   
;;;5508       
;;;5509     if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
00002a  4d10              LDR      r5,|L96.108|
00002c  42a8              CMP      r0,r5
00002e  d002              BEQ      |L96.54|
000030  4d0f              LDR      r5,|L96.112|
000032  42a8              CMP      r0,r5
000034  d101              BNE      |L96.58|
                  |L96.54|
000036  2501              MOVS     r5,#1
000038  e000              B        |L96.60|
                  |L96.58|
00003a  2500              MOVS     r5,#0
                  |L96.60|
00003c  b16d              CBZ      r5,|L96.90|
;;;5510     {   
;;;5511       /* Reset the Output N Polarity level */
;;;5512       tmpccer &= ~TIM_CCER_CC1NP;
00003e  f0220208          BIC      r2,r2,#8
;;;5513       /* Set the Output N Polarity */
;;;5514       tmpccer |= OC_Config->OCNPolarity;
000042  68cd              LDR      r5,[r1,#0xc]
000044  432a              ORRS     r2,r2,r5
;;;5515       /* Reset the Output N State */
;;;5516       tmpccer &= ~TIM_CCER_CC1NE;
000046  f0220204          BIC      r2,r2,#4
;;;5517       
;;;5518       /* Reset the Output Compare and Output Compare N IDLE State */
;;;5519       tmpcr2 &= ~TIM_CR2_OIS1;
00004a  f4237380          BIC      r3,r3,#0x100
;;;5520       tmpcr2 &= ~TIM_CR2_OIS1N;
00004e  f4237300          BIC      r3,r3,#0x200
;;;5521       /* Set the Output Idle state */
;;;5522       tmpcr2 |= OC_Config->OCIdleState;
000052  694d              LDR      r5,[r1,#0x14]
000054  432b              ORRS     r3,r3,r5
;;;5523       /* Set the Output N Idle state */
;;;5524       tmpcr2 |= OC_Config->OCNIdleState;
000056  698d              LDR      r5,[r1,#0x18]
000058  432b              ORRS     r3,r3,r5
                  |L96.90|
;;;5525     }
;;;5526     /* Write to TIMx CR2 */
;;;5527     TIMx->CR2 = tmpcr2;
00005a  6043              STR      r3,[r0,#4]
;;;5528     
;;;5529     /* Write to TIMx CCMR1 */
;;;5530     TIMx->CCMR1 = tmpccmrx;
00005c  6184              STR      r4,[r0,#0x18]
;;;5531     
;;;5532     /* Set the Capture Compare Register value */
;;;5533     TIMx->CCR1 = OC_Config->Pulse;
00005e  684d              LDR      r5,[r1,#4]
000060  6345              STR      r5,[r0,#0x34]
;;;5534     
;;;5535     /* Write to TIMx CCER */
;;;5536     TIMx->CCER = tmpccer;  
000062  6202              STR      r2,[r0,#0x20]
;;;5537   } 
000064  bd30              POP      {r4,r5,pc}
;;;5538   
                          ENDP

000066  0000              DCW      0x0000
                  |L96.104|
                          DCD      0xfffeff8f
                  |L96.108|
                          DCD      0x40010000
                  |L96.112|
                          DCD      0x40010400

                          AREA ||i.TIM_OC2_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC2_SetConfig PROC
;;;5544     */
;;;5545   void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b530              PUSH     {r4,r5,lr}
;;;5546   {
;;;5547     uint32_t tmpccmrx = 0;
000002  2400              MOVS     r4,#0
;;;5548     uint32_t tmpccer = 0;
000004  2200              MOVS     r2,#0
;;;5549     uint32_t tmpcr2 = 0;
000006  2300              MOVS     r3,#0
;;;5550      
;;;5551     /* Disable the Channel 2: Reset the CC2E Bit */
;;;5552     TIMx->CCER &= ~TIM_CCER_CC2E;
000008  6a05              LDR      r5,[r0,#0x20]
00000a  f0250510          BIC      r5,r5,#0x10
00000e  6205              STR      r5,[r0,#0x20]
;;;5553     
;;;5554     /* Get the TIMx CCER register value */  
;;;5555     tmpccer = TIMx->CCER;
000010  6a02              LDR      r2,[r0,#0x20]
;;;5556     /* Get the TIMx CR2 register value */
;;;5557     tmpcr2 = TIMx->CR2;
000012  6843              LDR      r3,[r0,#4]
;;;5558     
;;;5559     /* Get the TIMx CCMR1 register value */
;;;5560     tmpccmrx = TIMx->CCMR1;
000014  6984              LDR      r4,[r0,#0x18]
;;;5561       
;;;5562     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;5563     tmpccmrx &= ~TIM_CCMR1_OC2M;
000016  4d16              LDR      r5,|L97.112|
000018  402c              ANDS     r4,r4,r5
;;;5564     tmpccmrx &= ~TIM_CCMR1_CC2S;
00001a  f4247440          BIC      r4,r4,#0x300
;;;5565     
;;;5566     /* Select the Output Compare Mode */
;;;5567     tmpccmrx |= (OC_Config->OCMode << 8);
00001e  680d              LDR      r5,[r1,#0]
000020  ea442405          ORR      r4,r4,r5,LSL #8
;;;5568     
;;;5569     /* Reset the Output Polarity level */
;;;5570     tmpccer &= ~TIM_CCER_CC2P;
000024  f0220220          BIC      r2,r2,#0x20
;;;5571     /* Set the Output Compare Polarity */
;;;5572     tmpccer |= (OC_Config->OCPolarity << 4);
000028  688d              LDR      r5,[r1,#8]
00002a  ea421205          ORR      r2,r2,r5,LSL #4
;;;5573       
;;;5574     if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
00002e  4d11              LDR      r5,|L97.116|
000030  42a8              CMP      r0,r5
000032  d002              BEQ      |L97.58|
000034  4d10              LDR      r5,|L97.120|
000036  42a8              CMP      r0,r5
000038  d101              BNE      |L97.62|
                  |L97.58|
00003a  2501              MOVS     r5,#1
00003c  e000              B        |L97.64|
                  |L97.62|
00003e  2500              MOVS     r5,#0
                  |L97.64|
000040  b185              CBZ      r5,|L97.100|
;;;5575     {
;;;5576       assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
;;;5577       
;;;5578       /* Reset the Output N Polarity level */
;;;5579       tmpccer &= ~TIM_CCER_CC2NP;
000042  f0220280          BIC      r2,r2,#0x80
;;;5580       /* Set the Output N Polarity */
;;;5581       tmpccer |= (OC_Config->OCNPolarity << 4);
000046  68cd              LDR      r5,[r1,#0xc]
000048  ea421205          ORR      r2,r2,r5,LSL #4
;;;5582       /* Reset the Output N State */
;;;5583       tmpccer &= ~TIM_CCER_CC2NE;
00004c  f0220240          BIC      r2,r2,#0x40
;;;5584       
;;;5585       /* Reset the Output Compare and Output Compare N IDLE State */
;;;5586       tmpcr2 &= ~TIM_CR2_OIS2;
000050  f4236380          BIC      r3,r3,#0x400
;;;5587       tmpcr2 &= ~TIM_CR2_OIS2N;
000054  f4236300          BIC      r3,r3,#0x800
;;;5588       /* Set the Output Idle state */
;;;5589       tmpcr2 |= (OC_Config->OCIdleState << 2);
000058  694d              LDR      r5,[r1,#0x14]
00005a  ea430385          ORR      r3,r3,r5,LSL #2
;;;5590       /* Set the Output N Idle state */
;;;5591       tmpcr2 |= (OC_Config->OCNIdleState << 2);
00005e  698d              LDR      r5,[r1,#0x18]
000060  ea430385          ORR      r3,r3,r5,LSL #2
                  |L97.100|
;;;5592     }
;;;5593     /* Write to TIMx CR2 */
;;;5594     TIMx->CR2 = tmpcr2;
000064  6043              STR      r3,[r0,#4]
;;;5595     
;;;5596     /* Write to TIMx CCMR1 */
;;;5597     TIMx->CCMR1 = tmpccmrx;
000066  6184              STR      r4,[r0,#0x18]
;;;5598     
;;;5599     /* Set the Capture Compare Register value */
;;;5600     TIMx->CCR2 = OC_Config->Pulse;
000068  684d              LDR      r5,[r1,#4]
00006a  6385              STR      r5,[r0,#0x38]
;;;5601     
;;;5602     /* Write to TIMx CCER */
;;;5603     TIMx->CCER = tmpccer;
00006c  6202              STR      r2,[r0,#0x20]
;;;5604   }
00006e  bd30              POP      {r4,r5,pc}
;;;5605   
                          ENDP

                  |L97.112|
                          DCD      0xfeff8fff
                  |L97.116|
                          DCD      0x40010000
                  |L97.120|
                          DCD      0x40010400

                          AREA ||i.TIM_OC3_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC3_SetConfig PROC
;;;5611     */
;;;5612   void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b530              PUSH     {r4,r5,lr}
;;;5613   {
;;;5614     uint32_t tmpccmrx = 0;
000002  2400              MOVS     r4,#0
;;;5615     uint32_t tmpccer = 0;
000004  2200              MOVS     r2,#0
;;;5616     uint32_t tmpcr2 = 0;   
000006  2300              MOVS     r3,#0
;;;5617   
;;;5618     /* Disable the Channel 3: Reset the CC2E Bit */
;;;5619     TIMx->CCER &= ~TIM_CCER_CC3E;
000008  6a05              LDR      r5,[r0,#0x20]
00000a  f4257580          BIC      r5,r5,#0x100
00000e  6205              STR      r5,[r0,#0x20]
;;;5620     
;;;5621     /* Get the TIMx CCER register value */
;;;5622     tmpccer = TIMx->CCER;
000010  6a02              LDR      r2,[r0,#0x20]
;;;5623     /* Get the TIMx CR2 register value */
;;;5624     tmpcr2 = TIMx->CR2;
000012  6843              LDR      r3,[r0,#4]
;;;5625     
;;;5626     /* Get the TIMx CCMR2 register value */
;;;5627     tmpccmrx = TIMx->CCMR2;
000014  69c4              LDR      r4,[r0,#0x1c]
;;;5628       
;;;5629     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;5630     tmpccmrx &= ~TIM_CCMR2_OC3M;
000016  4d16              LDR      r5,|L98.112|
000018  402c              ANDS     r4,r4,r5
;;;5631     tmpccmrx &= ~TIM_CCMR2_CC3S;  
00001a  f0240403          BIC      r4,r4,#3
;;;5632     /* Select the Output Compare Mode */
;;;5633     tmpccmrx |= OC_Config->OCMode;
00001e  680d              LDR      r5,[r1,#0]
000020  432c              ORRS     r4,r4,r5
;;;5634     
;;;5635     /* Reset the Output Polarity level */
;;;5636     tmpccer &= ~TIM_CCER_CC3P;
000022  f4227200          BIC      r2,r2,#0x200
;;;5637     /* Set the Output Compare Polarity */
;;;5638     tmpccer |= (OC_Config->OCPolarity << 8);
000026  688d              LDR      r5,[r1,#8]
000028  ea422205          ORR      r2,r2,r5,LSL #8
;;;5639       
;;;5640     if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
00002c  4d11              LDR      r5,|L98.116|
00002e  42a8              CMP      r0,r5
000030  d002              BEQ      |L98.56|
000032  4d11              LDR      r5,|L98.120|
000034  42a8              CMP      r0,r5
000036  d101              BNE      |L98.60|
                  |L98.56|
000038  2501              MOVS     r5,#1
00003a  e000              B        |L98.62|
                  |L98.60|
00003c  2500              MOVS     r5,#0
                  |L98.62|
00003e  b185              CBZ      r5,|L98.98|
;;;5641     {
;;;5642       assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
;;;5643       
;;;5644       /* Reset the Output N Polarity level */
;;;5645       tmpccer &= ~TIM_CCER_CC3NP;
000040  f4226200          BIC      r2,r2,#0x800
;;;5646       /* Set the Output N Polarity */
;;;5647       tmpccer |= (OC_Config->OCNPolarity << 8);
000044  68cd              LDR      r5,[r1,#0xc]
000046  ea422205          ORR      r2,r2,r5,LSL #8
;;;5648       /* Reset the Output N State */
;;;5649       tmpccer &= ~TIM_CCER_CC3NE;
00004a  f4226280          BIC      r2,r2,#0x400
;;;5650       
;;;5651       /* Reset the Output Compare and Output Compare N IDLE State */
;;;5652       tmpcr2 &= ~TIM_CR2_OIS3;
00004e  f4235380          BIC      r3,r3,#0x1000
;;;5653       tmpcr2 &= ~TIM_CR2_OIS3N;
000052  f4235300          BIC      r3,r3,#0x2000
;;;5654       /* Set the Output Idle state */
;;;5655       tmpcr2 |= (OC_Config->OCIdleState << 4);
000056  694d              LDR      r5,[r1,#0x14]
000058  ea431305          ORR      r3,r3,r5,LSL #4
;;;5656       /* Set the Output N Idle state */
;;;5657       tmpcr2 |= (OC_Config->OCNIdleState << 4);
00005c  698d              LDR      r5,[r1,#0x18]
00005e  ea431305          ORR      r3,r3,r5,LSL #4
                  |L98.98|
;;;5658     }
;;;5659     /* Write to TIMx CR2 */
;;;5660     TIMx->CR2 = tmpcr2;
000062  6043              STR      r3,[r0,#4]
;;;5661     
;;;5662     /* Write to TIMx CCMR2 */
;;;5663     TIMx->CCMR2 = tmpccmrx;
000064  61c4              STR      r4,[r0,#0x1c]
;;;5664     
;;;5665     /* Set the Capture Compare Register value */
;;;5666     TIMx->CCR3 = OC_Config->Pulse;
000066  684d              LDR      r5,[r1,#4]
000068  63c5              STR      r5,[r0,#0x3c]
;;;5667     
;;;5668     /* Write to TIMx CCER */
;;;5669     TIMx->CCER = tmpccer;
00006a  6202              STR      r2,[r0,#0x20]
;;;5670   }
00006c  bd30              POP      {r4,r5,pc}
;;;5671   
                          ENDP

00006e  0000              DCW      0x0000
                  |L98.112|
                          DCD      0xfffeff8f
                  |L98.116|
                          DCD      0x40010000
                  |L98.120|
                          DCD      0x40010400

                          AREA ||i.TIM_OC4_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC4_SetConfig PROC
;;;5677     */
;;;5678   void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
000000  b530              PUSH     {r4,r5,lr}
;;;5679   {
;;;5680     uint32_t tmpccmrx = 0;
000002  2200              MOVS     r2,#0
;;;5681     uint32_t tmpccer = 0;
000004  2300              MOVS     r3,#0
;;;5682     uint32_t tmpcr2 = 0;
000006  2400              MOVS     r4,#0
;;;5683   
;;;5684     /* Disable the Channel 4: Reset the CC4E Bit */
;;;5685     TIMx->CCER &= ~TIM_CCER_CC4E;
000008  6a05              LDR      r5,[r0,#0x20]
00000a  f4255580          BIC      r5,r5,#0x1000
00000e  6205              STR      r5,[r0,#0x20]
;;;5686     
;;;5687     /* Get the TIMx CCER register value */
;;;5688     tmpccer = TIMx->CCER;
000010  6a03              LDR      r3,[r0,#0x20]
;;;5689     /* Get the TIMx CR2 register value */
;;;5690     tmpcr2 = TIMx->CR2;
000012  6844              LDR      r4,[r0,#4]
;;;5691     
;;;5692     /* Get the TIMx CCMR2 register value */
;;;5693     tmpccmrx = TIMx->CCMR2;
000014  69c2              LDR      r2,[r0,#0x1c]
;;;5694       
;;;5695     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;5696     tmpccmrx &= ~TIM_CCMR2_OC4M;
000016  4d10              LDR      r5,|L99.88|
000018  402a              ANDS     r2,r2,r5
;;;5697     tmpccmrx &= ~TIM_CCMR2_CC4S;
00001a  f4227240          BIC      r2,r2,#0x300
;;;5698     
;;;5699     /* Select the Output Compare Mode */
;;;5700     tmpccmrx |= (OC_Config->OCMode << 8);
00001e  680d              LDR      r5,[r1,#0]
000020  ea422205          ORR      r2,r2,r5,LSL #8
;;;5701     
;;;5702     /* Reset the Output Polarity level */
;;;5703     tmpccer &= ~TIM_CCER_CC4P;
000024  f4235300          BIC      r3,r3,#0x2000
;;;5704     /* Set the Output Compare Polarity */
;;;5705     tmpccer |= (OC_Config->OCPolarity << 12);
000028  688d              LDR      r5,[r1,#8]
00002a  ea433305          ORR      r3,r3,r5,LSL #12
;;;5706      
;;;5707     /*if((TIMx == TIM1) || (TIMx == TIM8))*/
;;;5708     if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
00002e  4d0b              LDR      r5,|L99.92|
000030  42a8              CMP      r0,r5
000032  d002              BEQ      |L99.58|
000034  4d0a              LDR      r5,|L99.96|
000036  42a8              CMP      r0,r5
000038  d101              BNE      |L99.62|
                  |L99.58|
00003a  2501              MOVS     r5,#1
00003c  e000              B        |L99.64|
                  |L99.62|
00003e  2500              MOVS     r5,#0
                  |L99.64|
000040  b125              CBZ      r5,|L99.76|
;;;5709     {
;;;5710       assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
;;;5711       /* Reset the Output Compare IDLE State */
;;;5712       tmpcr2 &= ~TIM_CR2_OIS4;
000042  f4244480          BIC      r4,r4,#0x4000
;;;5713       /* Set the Output Idle state */
;;;5714       tmpcr2 |= (OC_Config->OCIdleState << 6);
000046  694d              LDR      r5,[r1,#0x14]
000048  ea441485          ORR      r4,r4,r5,LSL #6
                  |L99.76|
;;;5715     }
;;;5716     /* Write to TIMx CR2 */
;;;5717     TIMx->CR2 = tmpcr2;
00004c  6044              STR      r4,[r0,#4]
;;;5718     
;;;5719     /* Write to TIMx CCMR2 */  
;;;5720     TIMx->CCMR2 = tmpccmrx;
00004e  61c2              STR      r2,[r0,#0x1c]
;;;5721       
;;;5722     /* Set the Capture Compare Register value */
;;;5723     TIMx->CCR4 = OC_Config->Pulse;
000050  684d              LDR      r5,[r1,#4]
000052  6405              STR      r5,[r0,#0x40]
;;;5724     
;;;5725     /* Write to TIMx CCER */
;;;5726     TIMx->CCER = tmpccer;
000054  6203              STR      r3,[r0,#0x20]
;;;5727   }
000056  bd30              POP      {r4,r5,pc}
;;;5728   
                          ENDP

                  |L99.88|
                          DCD      0xfeff8fff
                  |L99.92|
                          DCD      0x40010000
                  |L99.96|
                          DCD      0x40010400

                          AREA ||i.TIM_SlaveTimer_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_SlaveTimer_SetConfig PROC
;;;5735     */
;;;5736   static void TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;5737                                 TIM_SlaveConfigTypeDef * sSlaveConfig)
;;;5738   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;5739     uint32_t tmpsmcr = 0;
000008  2600              MOVS     r6,#0
;;;5740     uint32_t tmpccmr1 = 0;
00000a  2700              MOVS     r7,#0
;;;5741     uint32_t tmpccer = 0;
00000c  46b0              MOV      r8,r6
;;;5742   
;;;5743    /* Get the TIMx SMCR register value */
;;;5744     tmpsmcr = htim->Instance->SMCR;
00000e  6820              LDR      r0,[r4,#0]
000010  6886              LDR      r6,[r0,#8]
;;;5745   
;;;5746     /* Reset the Trigger Selection Bits */
;;;5747     tmpsmcr &= ~TIM_SMCR_TS;
000012  f0260670          BIC      r6,r6,#0x70
;;;5748     /* Set the Input Trigger source */
;;;5749     tmpsmcr |= sSlaveConfig->InputTrigger;
000016  6868              LDR      r0,[r5,#4]
000018  4306              ORRS     r6,r6,r0
;;;5750   
;;;5751     /* Reset the slave mode Bits */
;;;5752     tmpsmcr &= ~TIM_SMCR_SMS;
00001a  4822              LDR      r0,|L100.164|
00001c  4006              ANDS     r6,r6,r0
;;;5753     /* Set the slave mode */
;;;5754     tmpsmcr |= sSlaveConfig->SlaveMode;
00001e  6828              LDR      r0,[r5,#0]
000020  4306              ORRS     r6,r6,r0
;;;5755   
;;;5756     /* Write to TIMx SMCR */
;;;5757     htim->Instance->SMCR = tmpsmcr;
000022  6820              LDR      r0,[r4,#0]
000024  6086              STR      r6,[r0,#8]
;;;5758    
;;;5759     /* Configure the trigger prescaler, filter, and polarity */
;;;5760     switch (sSlaveConfig->InputTrigger)
000026  6868              LDR      r0,[r5,#4]
000028  f000010f          AND      r1,r0,#0xf
00002c  2900              CMP      r1,#0
00002e  d135              BNE      |L100.156|
000030  1100              ASRS     r0,r0,#4
000032  2808              CMP      r0,#8
000034  d232              BCS      |L100.156|
000036  e8dff000          TBB      [pc,r0]
00003a  2d2e              DCB      0x2d,0x2e
00003c  2f300b21          DCB      0x2f,0x30,0x0b,0x21
000040  2704              DCB      0x27,0x04
;;;5761     {
;;;5762     case TIM_TS_ETRF:
;;;5763       {
;;;5764         /* Check the parameters */
;;;5765         assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
;;;5766         assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));
;;;5767         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;5768         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;5769         /* Configure the ETR Trigger source */
;;;5770         TIM_ETR_SetConfig(htim->Instance, 
000042  e9d51303          LDRD     r1,r3,[r5,#0xc]
000046  68aa              LDR      r2,[r5,#8]
000048  6820              LDR      r0,[r4,#0]
00004a  f7fffffe          BL       TIM_ETR_SetConfig
;;;5771                           sSlaveConfig->TriggerPrescaler, 
;;;5772                           sSlaveConfig->TriggerPolarity, 
;;;5773                           sSlaveConfig->TriggerFilter);
;;;5774       }
;;;5775       break;
00004e  e026              B        |L100.158|
;;;5776       
;;;5777     case TIM_TS_TI1F_ED:
;;;5778       {
;;;5779         /* Check the parameters */
;;;5780         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;5781         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;5782         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;5783     
;;;5784         /* Disable the Channel 1: Reset the CC1E Bit */
;;;5785         tmpccer = htim->Instance->CCER;
000050  6820              LDR      r0,[r4,#0]
000052  f8d08020          LDR      r8,[r0,#0x20]
;;;5786         htim->Instance->CCER &= ~TIM_CCER_CC1E;
000056  6820              LDR      r0,[r4,#0]
000058  6a00              LDR      r0,[r0,#0x20]
00005a  f0200001          BIC      r0,r0,#1
00005e  6821              LDR      r1,[r4,#0]
000060  6208              STR      r0,[r1,#0x20]
;;;5787         tmpccmr1 = htim->Instance->CCMR1;    
000062  6820              LDR      r0,[r4,#0]
000064  6987              LDR      r7,[r0,#0x18]
;;;5788         
;;;5789         /* Set the filter */
;;;5790         tmpccmr1 &= ~TIM_CCMR1_IC1F;
000066  f02707f0          BIC      r7,r7,#0xf0
;;;5791         tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4);
00006a  6928              LDR      r0,[r5,#0x10]
00006c  ea471700          ORR      r7,r7,r0,LSL #4
;;;5792         
;;;5793         /* Write to TIMx CCMR1 and CCER registers */
;;;5794         htim->Instance->CCMR1 = tmpccmr1;
000070  6820              LDR      r0,[r4,#0]
000072  6187              STR      r7,[r0,#0x18]
;;;5795         htim->Instance->CCER = tmpccer;                               
000074  6820              LDR      r0,[r4,#0]
000076  f8c08020          STR      r8,[r0,#0x20]
;;;5796                                  
;;;5797       }
;;;5798       break;
00007a  e010              B        |L100.158|
;;;5799       
;;;5800     case TIM_TS_TI1FP1:
;;;5801       {
;;;5802         /* Check the parameters */
;;;5803         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;5804         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;5805         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;5806   
;;;5807         /* Configure TI1 Filter and Polarity */
;;;5808         TIM_TI1_ConfigInputStage(htim->Instance,
00007c  692a              LDR      r2,[r5,#0x10]
00007e  68a9              LDR      r1,[r5,#8]
000080  6820              LDR      r0,[r4,#0]
000082  f7fffffe          BL       TIM_TI1_ConfigInputStage
;;;5809                                  sSlaveConfig->TriggerPolarity,
;;;5810                                  sSlaveConfig->TriggerFilter);
;;;5811       }
;;;5812       break;
000086  e00a              B        |L100.158|
;;;5813       
;;;5814     case TIM_TS_TI2FP2:
;;;5815       {
;;;5816         /* Check the parameters */
;;;5817         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5818         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;5819         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;5820     
;;;5821         /* Configure TI2 Filter and Polarity */
;;;5822         TIM_TI2_ConfigInputStage(htim->Instance,
000088  692a              LDR      r2,[r5,#0x10]
00008a  68a9              LDR      r1,[r5,#8]
00008c  6820              LDR      r0,[r4,#0]
00008e  f7fffffe          BL       TIM_TI2_ConfigInputStage
;;;5823                                   sSlaveConfig->TriggerPolarity,
;;;5824                                   sSlaveConfig->TriggerFilter);
;;;5825       }
;;;5826       break;
000092  e004              B        |L100.158|
;;;5827       
;;;5828     case TIM_TS_ITR0:
;;;5829       {
;;;5830         /* Check the parameter */
;;;5831         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5832       }
;;;5833       break;
000094  e003              B        |L100.158|
;;;5834       
;;;5835     case TIM_TS_ITR1:
;;;5836       {
;;;5837         /* Check the parameter */
;;;5838         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5839       }
;;;5840       break;
000096  e002              B        |L100.158|
;;;5841       
;;;5842     case TIM_TS_ITR2:
;;;5843       {
;;;5844         /* Check the parameter */
;;;5845         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5846       }
;;;5847       break;
000098  e001              B        |L100.158|
;;;5848       
;;;5849     case TIM_TS_ITR3:
;;;5850       {
;;;5851         /* Check the parameter */
;;;5852         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;5853       }
;;;5854       break;
00009a  e000              B        |L100.158|
                  |L100.156|
;;;5855          
;;;5856     default:
;;;5857       break;
00009c  bf00              NOP      
                  |L100.158|
00009e  bf00              NOP                            ;5775
;;;5858     }
;;;5859   }
0000a0  e8bd81f0          POP      {r4-r8,pc}
;;;5860   
                          ENDP

                  |L100.164|
                          DCD      0xfffefff8

                          AREA ||i.TIM_TI1_ConfigInputStage||, CODE, READONLY, ALIGN=1

                  TIM_TI1_ConfigInputStage PROC
;;;5927     */
;;;5928   static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
000000  b530              PUSH     {r4,r5,lr}
;;;5929   {
000002  460b              MOV      r3,r1
000004  4614              MOV      r4,r2
;;;5930     uint32_t tmpccmr1 = 0;
000006  2100              MOVS     r1,#0
;;;5931     uint32_t tmpccer = 0;
000008  2200              MOVS     r2,#0
;;;5932     
;;;5933     /* Disable the Channel 1: Reset the CC1E Bit */
;;;5934     tmpccer = TIMx->CCER;
00000a  6a02              LDR      r2,[r0,#0x20]
;;;5935     TIMx->CCER &= ~TIM_CCER_CC1E;
00000c  6a05              LDR      r5,[r0,#0x20]
00000e  f0250501          BIC      r5,r5,#1
000012  6205              STR      r5,[r0,#0x20]
;;;5936     tmpccmr1 = TIMx->CCMR1;    
000014  6981              LDR      r1,[r0,#0x18]
;;;5937     
;;;5938     /* Set the filter */
;;;5939     tmpccmr1 &= ~TIM_CCMR1_IC1F;
000016  f02101f0          BIC      r1,r1,#0xf0
;;;5940     tmpccmr1 |= (TIM_ICFilter << 4);
00001a  ea411104          ORR      r1,r1,r4,LSL #4
;;;5941     
;;;5942     /* Select the Polarity and set the CC1E Bit */
;;;5943     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
00001e  f022020a          BIC      r2,r2,#0xa
;;;5944     tmpccer |= TIM_ICPolarity;
000022  431a              ORRS     r2,r2,r3
;;;5945     
;;;5946     /* Write to TIMx CCMR1 and CCER registers */
;;;5947     TIMx->CCMR1 = tmpccmr1;
000024  6181              STR      r1,[r0,#0x18]
;;;5948     TIMx->CCER = tmpccer;
000026  6202              STR      r2,[r0,#0x20]
;;;5949   }
000028  bd30              POP      {r4,r5,pc}
;;;5950   
                          ENDP


                          AREA ||i.TIM_TI1_SetConfig||, CODE, READONLY, ALIGN=2

                  TIM_TI1_SetConfig PROC
;;;5880     */
;;;5881   void TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
000000  b570              PUSH     {r4-r6,lr}
;;;5882                          uint32_t TIM_ICFilter)
;;;5883   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;5884     uint32_t tmpccmr1 = 0;
000006  2100              MOVS     r1,#0
;;;5885     uint32_t tmpccer = 0;
000008  2200              MOVS     r2,#0
;;;5886   
;;;5887     /* Disable the Channel 1: Reset the CC1E Bit */
;;;5888     TIMx->CCER &= ~TIM_CCER_CC1E;
00000a  6a06              LDR      r6,[r0,#0x20]
00000c  f0260601          BIC      r6,r6,#1
000010  6206              STR      r6,[r0,#0x20]
;;;5889     tmpccmr1 = TIMx->CCMR1;
000012  6981              LDR      r1,[r0,#0x18]
;;;5890     tmpccer = TIMx->CCER;
000014  6a02              LDR      r2,[r0,#0x20]
;;;5891   
;;;5892     /* Select the Input */
;;;5893     if(IS_TIM_CC2_INSTANCE(TIMx) != RESET)
000016  4e18              LDR      r6,|L102.120|
000018  42b0              CMP      r0,r6
00001a  d014              BEQ      |L102.70|
00001c  f1b04f80          CMP      r0,#0x40000000
000020  d011              BEQ      |L102.70|
000022  4e16              LDR      r6,|L102.124|
000024  42b0              CMP      r0,r6
000026  d00e              BEQ      |L102.70|
000028  4e15              LDR      r6,|L102.128|
00002a  42b0              CMP      r0,r6
00002c  d00b              BEQ      |L102.70|
00002e  4e15              LDR      r6,|L102.132|
000030  42b0              CMP      r0,r6
000032  d008              BEQ      |L102.70|
000034  4e14              LDR      r6,|L102.136|
000036  42b0              CMP      r0,r6
000038  d005              BEQ      |L102.70|
00003a  4e14              LDR      r6,|L102.140|
00003c  42b0              CMP      r0,r6
00003e  d002              BEQ      |L102.70|
000040  4e13              LDR      r6,|L102.144|
000042  42b0              CMP      r0,r6
000044  d101              BNE      |L102.74|
                  |L102.70|
000046  2601              MOVS     r6,#1
000048  e000              B        |L102.76|
                  |L102.74|
00004a  2600              MOVS     r6,#0
                  |L102.76|
00004c  b11e              CBZ      r6,|L102.86|
;;;5894     {
;;;5895       tmpccmr1 &= ~TIM_CCMR1_CC1S;
00004e  f0210103          BIC      r1,r1,#3
;;;5896       tmpccmr1 |= TIM_ICSelection;
000052  4329              ORRS     r1,r1,r5
000054  e001              B        |L102.90|
                  |L102.86|
;;;5897     } 
;;;5898     else
;;;5899     {
;;;5900       tmpccmr1 |= TIM_CCMR1_CC1S_0;
000056  f0410101          ORR      r1,r1,#1
                  |L102.90|
;;;5901     }
;;;5902     
;;;5903     /* Set the filter */
;;;5904     tmpccmr1 &= ~TIM_CCMR1_IC1F;
00005a  f02101f0          BIC      r1,r1,#0xf0
;;;5905     tmpccmr1 |= ((TIM_ICFilter << 4) & TIM_CCMR1_IC1F);
00005e  26f0              MOVS     r6,#0xf0
000060  ea061603          AND      r6,r6,r3,LSL #4
000064  4331              ORRS     r1,r1,r6
;;;5906   
;;;5907     /* Select the Polarity and set the CC1E Bit */
;;;5908     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
000066  f022020a          BIC      r2,r2,#0xa
;;;5909     tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));
00006a  f004060a          AND      r6,r4,#0xa
00006e  4332              ORRS     r2,r2,r6
;;;5910   
;;;5911     /* Write to TIMx CCMR1 and CCER registers */
;;;5912     TIMx->CCMR1 = tmpccmr1;
000070  6181              STR      r1,[r0,#0x18]
;;;5913     TIMx->CCER = tmpccer;
000072  6202              STR      r2,[r0,#0x20]
;;;5914   }
000074  bd70              POP      {r4-r6,pc}
;;;5915   
                          ENDP

000076  0000              DCW      0x0000
                  |L102.120|
                          DCD      0x40010000
                  |L102.124|
                          DCD      0x40000400
                  |L102.128|
                          DCD      0x40000800
                  |L102.132|
                          DCD      0x40000c00
                  |L102.136|
                          DCD      0x40010400
                  |L102.140|
                          DCD      0x40014000
                  |L102.144|
                          DCD      0x40001800

                          AREA ||i.TIM_TI2_ConfigInputStage||, CODE, READONLY, ALIGN=1

                  TIM_TI2_ConfigInputStage PROC
;;;6010     */
;;;6011   static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
000000  b530              PUSH     {r4,r5,lr}
;;;6012   {
000002  460b              MOV      r3,r1
000004  4614              MOV      r4,r2
;;;6013   uint32_t tmpccmr1 = 0;
000006  2100              MOVS     r1,#0
;;;6014     uint32_t tmpccer = 0;
000008  2200              MOVS     r2,#0
;;;6015     
;;;6016     /* Disable the Channel 2: Reset the CC2E Bit */
;;;6017     TIMx->CCER &= ~TIM_CCER_CC2E;
00000a  6a05              LDR      r5,[r0,#0x20]
00000c  f0250510          BIC      r5,r5,#0x10
000010  6205              STR      r5,[r0,#0x20]
;;;6018     tmpccmr1 = TIMx->CCMR1;
000012  6981              LDR      r1,[r0,#0x18]
;;;6019     tmpccer = TIMx->CCER;
000014  6a02              LDR      r2,[r0,#0x20]
;;;6020     
;;;6021     /* Set the filter */
;;;6022     tmpccmr1 &= ~TIM_CCMR1_IC2F;
000016  f4214170          BIC      r1,r1,#0xf000
;;;6023     tmpccmr1 |= (TIM_ICFilter << 12);
00001a  ea413104          ORR      r1,r1,r4,LSL #12
;;;6024   
;;;6025     /* Select the Polarity and set the CC2E Bit */
;;;6026     tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
00001e  f02202a0          BIC      r2,r2,#0xa0
;;;6027     tmpccer |= (TIM_ICPolarity << 4);
000022  ea421203          ORR      r2,r2,r3,LSL #4
;;;6028   
;;;6029     /* Write to TIMx CCMR1 and CCER registers */
;;;6030     TIMx->CCMR1 = tmpccmr1 ;
000026  6181              STR      r1,[r0,#0x18]
;;;6031     TIMx->CCER = tmpccer;
000028  6202              STR      r2,[r0,#0x20]
;;;6032   }
00002a  bd30              POP      {r4,r5,pc}
;;;6033   
                          ENDP


                          AREA ||i.TIM_TI2_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_TI2_SetConfig PROC
;;;5970     */
;;;5971   static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
000000  b570              PUSH     {r4-r6,lr}
;;;5972                          uint32_t TIM_ICFilter)
;;;5973   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;5974     uint32_t tmpccmr1 = 0;
000006  2100              MOVS     r1,#0
;;;5975     uint32_t tmpccer = 0;
000008  2200              MOVS     r2,#0
;;;5976   
;;;5977     /* Disable the Channel 2: Reset the CC2E Bit */
;;;5978     TIMx->CCER &= ~TIM_CCER_CC2E;
00000a  6a06              LDR      r6,[r0,#0x20]
00000c  f0260610          BIC      r6,r6,#0x10
000010  6206              STR      r6,[r0,#0x20]
;;;5979     tmpccmr1 = TIMx->CCMR1;
000012  6981              LDR      r1,[r0,#0x18]
;;;5980     tmpccer = TIMx->CCER;
000014  6a02              LDR      r2,[r0,#0x20]
;;;5981   
;;;5982     /* Select the Input */
;;;5983     tmpccmr1 &= ~TIM_CCMR1_CC2S;
000016  f4217140          BIC      r1,r1,#0x300
;;;5984     tmpccmr1 |= (TIM_ICSelection << 8);
00001a  ea412105          ORR      r1,r1,r5,LSL #8
;;;5985   
;;;5986     /* Set the filter */
;;;5987     tmpccmr1 &= ~TIM_CCMR1_IC2F;
00001e  f4214170          BIC      r1,r1,#0xf000
;;;5988     tmpccmr1 |= ((TIM_ICFilter << 12) & TIM_CCMR1_IC2F);
000022  f44f4670          MOV      r6,#0xf000
000026  ea063603          AND      r6,r6,r3,LSL #12
00002a  4331              ORRS     r1,r1,r6
;;;5989   
;;;5990     /* Select the Polarity and set the CC2E Bit */
;;;5991     tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
00002c  f02202a0          BIC      r2,r2,#0xa0
;;;5992     tmpccer |= ((TIM_ICPolarity << 4) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
000030  26a0              MOVS     r6,#0xa0
000032  ea061604          AND      r6,r6,r4,LSL #4
000036  4332              ORRS     r2,r2,r6
;;;5993   
;;;5994     /* Write to TIMx CCMR1 and CCER registers */
;;;5995     TIMx->CCMR1 = tmpccmr1 ;
000038  6181              STR      r1,[r0,#0x18]
;;;5996     TIMx->CCER = tmpccer;
00003a  6202              STR      r2,[r0,#0x20]
;;;5997   }
00003c  bd70              POP      {r4-r6,pc}
;;;5998   
                          ENDP


                          AREA ||i.TIM_TI3_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_TI3_SetConfig PROC
;;;6053     */
;;;6054   static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
000000  b570              PUSH     {r4-r6,lr}
;;;6055                          uint32_t TIM_ICFilter)
;;;6056   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;6057     uint32_t tmpccmr2 = 0;
000006  2100              MOVS     r1,#0
;;;6058     uint32_t tmpccer = 0;
000008  2200              MOVS     r2,#0
;;;6059   
;;;6060     /* Disable the Channel 3: Reset the CC3E Bit */
;;;6061     TIMx->CCER &= ~TIM_CCER_CC3E;
00000a  6a06              LDR      r6,[r0,#0x20]
00000c  f4267680          BIC      r6,r6,#0x100
000010  6206              STR      r6,[r0,#0x20]
;;;6062     tmpccmr2 = TIMx->CCMR2;
000012  69c1              LDR      r1,[r0,#0x1c]
;;;6063     tmpccer = TIMx->CCER;
000014  6a02              LDR      r2,[r0,#0x20]
;;;6064   
;;;6065     /* Select the Input */
;;;6066     tmpccmr2 &= ~TIM_CCMR2_CC3S;
000016  f0210103          BIC      r1,r1,#3
;;;6067     tmpccmr2 |= TIM_ICSelection;
00001a  4329              ORRS     r1,r1,r5
;;;6068   
;;;6069     /* Set the filter */
;;;6070     tmpccmr2 &= ~TIM_CCMR2_IC3F;
00001c  f02101f0          BIC      r1,r1,#0xf0
;;;6071     tmpccmr2 |= ((TIM_ICFilter << 4) & TIM_CCMR2_IC3F);
000020  26f0              MOVS     r6,#0xf0
000022  ea061603          AND      r6,r6,r3,LSL #4
000026  4331              ORRS     r1,r1,r6
;;;6072   
;;;6073     /* Select the Polarity and set the CC3E Bit */
;;;6074     tmpccer &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
000028  f4226220          BIC      r2,r2,#0xa00
;;;6075     tmpccer |= ((TIM_ICPolarity << 8) & (TIM_CCER_CC3P | TIM_CCER_CC3NP));
00002c  f44f6620          MOV      r6,#0xa00
000030  ea062604          AND      r6,r6,r4,LSL #8
000034  4332              ORRS     r2,r2,r6
;;;6076   
;;;6077     /* Write to TIMx CCMR2 and CCER registers */
;;;6078     TIMx->CCMR2 = tmpccmr2;
000036  61c1              STR      r1,[r0,#0x1c]
;;;6079     TIMx->CCER = tmpccer;
000038  6202              STR      r2,[r0,#0x20]
;;;6080   }
00003a  bd70              POP      {r4-r6,pc}
;;;6081   
                          ENDP


                          AREA ||i.TIM_TI4_SetConfig||, CODE, READONLY, ALIGN=1

                  TIM_TI4_SetConfig PROC
;;;6101     */
;;;6102   static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
000000  b570              PUSH     {r4-r6,lr}
;;;6103                          uint32_t TIM_ICFilter)
;;;6104   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;6105     uint32_t tmpccmr2 = 0;
000006  2100              MOVS     r1,#0
;;;6106     uint32_t tmpccer = 0;
000008  2200              MOVS     r2,#0
;;;6107   
;;;6108     /* Disable the Channel 4: Reset the CC4E Bit */
;;;6109     TIMx->CCER &= ~TIM_CCER_CC4E;
00000a  6a06              LDR      r6,[r0,#0x20]
00000c  f4265680          BIC      r6,r6,#0x1000
000010  6206              STR      r6,[r0,#0x20]
;;;6110     tmpccmr2 = TIMx->CCMR2;
000012  69c1              LDR      r1,[r0,#0x1c]
;;;6111     tmpccer = TIMx->CCER;
000014  6a02              LDR      r2,[r0,#0x20]
;;;6112   
;;;6113     /* Select the Input */
;;;6114     tmpccmr2 &= ~TIM_CCMR2_CC4S;
000016  f4217140          BIC      r1,r1,#0x300
;;;6115     tmpccmr2 |= (TIM_ICSelection << 8);
00001a  ea412105          ORR      r1,r1,r5,LSL #8
;;;6116   
;;;6117     /* Set the filter */
;;;6118     tmpccmr2 &= ~TIM_CCMR2_IC4F;
00001e  f4214170          BIC      r1,r1,#0xf000
;;;6119     tmpccmr2 |= ((TIM_ICFilter << 12) & TIM_CCMR2_IC4F);
000022  f44f4670          MOV      r6,#0xf000
000026  ea063603          AND      r6,r6,r3,LSL #12
00002a  4331              ORRS     r1,r1,r6
;;;6120   
;;;6121     /* Select the Polarity and set the CC4E Bit */
;;;6122     tmpccer &= ~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
00002c  f4224220          BIC      r2,r2,#0xa000
;;;6123     tmpccer |= ((TIM_ICPolarity << 12) & (TIM_CCER_CC4P | TIM_CCER_CC4NP));
000030  f44f4620          MOV      r6,#0xa000
000034  ea063604          AND      r6,r6,r4,LSL #12
000038  4332              ORRS     r2,r2,r6
;;;6124   
;;;6125     /* Write to TIMx CCMR2 and CCER registers */
;;;6126     TIMx->CCMR2 = tmpccmr2;
00003a  61c1              STR      r1,[r0,#0x1c]
;;;6127     TIMx->CCER = tmpccer ;
00003c  6202              STR      r2,[r0,#0x20]
;;;6128   }
00003e  bd70              POP      {r4-r6,pc}
;;;6129   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F7_V1.11.0\\Drivers\\STM32F7xx_HAL_Driver\\Src\\stm32f7xx_hal_tim.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f7xx_hal_tim_c_a9d95b52____REV16|
#line 464 "D:\\Program_Files_x86\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.1.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___19_stm32f7xx_hal_tim_c_a9d95b52____REV16| PROC
#line 465

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f7xx_hal_tim_c_a9d95b52____REVSH|
#line 479
|__asm___19_stm32f7xx_hal_tim_c_a9d95b52____REVSH| PROC
#line 480

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f7xx_hal_tim_c_a9d95b52____RRX|
#line 666
|__asm___19_stm32f7xx_hal_tim_c_a9d95b52____RRX| PROC
#line 667

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
