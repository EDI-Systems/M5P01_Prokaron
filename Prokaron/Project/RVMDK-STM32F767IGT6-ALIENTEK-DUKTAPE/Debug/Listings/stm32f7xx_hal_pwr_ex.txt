; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f7xx_hal_pwr_ex.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f7xx_hal_pwr_ex.d --cpu=Cortex-M7 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Inc -I.\Source -I.\Drivers -I..\..\..\M6P1(D)_Duktape\duktape\src -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6-ALIENTEK-DUKTAPE\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER -DDUK_USE_BYTEORDER=1 --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f7xx_hal_pwr_ex.crf ..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_pwr_ex.c]
                          THUMB

                          AREA ||i.HAL_PWREx_ControlVoltageScaling||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_ControlVoltageScaling PROC
;;;492      */
;;;493    HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling)
000000  b538              PUSH     {r3-r5,lr}
;;;494    {
000002  4605              MOV      r5,r0
;;;495      uint32_t tickstart = 0;
000004  2400              MOVS     r4,#0
;;;496    
;;;497      assert_param(IS_PWR_REGULATOR_VOLTAGE(VoltageScaling));
;;;498    
;;;499      /* Enable Power ctrl clock */
;;;500      __HAL_RCC_PWR_CLK_ENABLE();
000006  bf00              NOP      
000008  4836              LDR      r0,|L1.228|
00000a  6800              LDR      r0,[r0,#0]
00000c  f0405080          ORR      r0,r0,#0x10000000
000010  4934              LDR      r1,|L1.228|
000012  6008              STR      r0,[r1,#0]
000014  4608              MOV      r0,r1
000016  6800              LDR      r0,[r0,#0]
000018  f0005080          AND      r0,r0,#0x10000000
00001c  9000              STR      r0,[sp,#0]
00001e  bf00              NOP      
000020  bf00              NOP      
;;;501    
;;;502      /* Check if the PLL is used as system clock or not */
;;;503      if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
000022  4830              LDR      r0,|L1.228|
000024  3838              SUBS     r0,r0,#0x38
000026  6800              LDR      r0,[r0,#0]
000028  f000000c          AND      r0,r0,#0xc
00002c  2808              CMP      r0,#8
00002e  d055              BEQ      |L1.220|
;;;504      {
;;;505        /* Disable the main PLL */
;;;506        __HAL_RCC_PLL_DISABLE();
000030  482c              LDR      r0,|L1.228|
000032  3840              SUBS     r0,r0,#0x40
000034  6800              LDR      r0,[r0,#0]
000036  f0207080          BIC      r0,r0,#0x1000000
00003a  492a              LDR      r1,|L1.228|
00003c  3940              SUBS     r1,r1,#0x40
00003e  6008              STR      r0,[r1,#0]
;;;507        
;;;508        /* Get Start Tick */
;;;509        tickstart = HAL_GetTick();    
000040  f7fffffe          BL       HAL_GetTick
000044  4604              MOV      r4,r0
;;;510        /* Wait till PLL is disabled */  
;;;511        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
000046  e006              B        |L1.86|
                  |L1.72|
;;;512        {
;;;513          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
000048  f7fffffe          BL       HAL_GetTick
00004c  1b00              SUBS     r0,r0,r4
00004e  2802              CMP      r0,#2
000050  d901              BLS      |L1.86|
;;;514          {
;;;515            return HAL_TIMEOUT;
000052  2003              MOVS     r0,#3
                  |L1.84|
;;;516          }
;;;517        }
;;;518        
;;;519        /* Set Range */
;;;520        __HAL_PWR_VOLTAGESCALING_CONFIG(VoltageScaling);
;;;521        
;;;522        /* Enable the main PLL */
;;;523        __HAL_RCC_PLL_ENABLE();
;;;524        
;;;525        /* Get Start Tick */
;;;526        tickstart = HAL_GetTick();
;;;527        /* Wait till PLL is ready */  
;;;528        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
;;;529        {
;;;530          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
;;;531          {
;;;532            return HAL_TIMEOUT;
;;;533          } 
;;;534        }
;;;535        
;;;536        /* Get Start Tick */
;;;537        tickstart = HAL_GetTick();
;;;538        while((__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY) == RESET))
;;;539        {
;;;540          if((HAL_GetTick() - tickstart ) > PWR_VOSRDY_TIMEOUT_VALUE)
;;;541          {
;;;542            return HAL_TIMEOUT;
;;;543          } 
;;;544        }
;;;545      }
;;;546      else
;;;547      {
;;;548        return HAL_ERROR;
;;;549      }
;;;550      return HAL_OK;
;;;551    }
000054  bd38              POP      {r3-r5,pc}
                  |L1.86|
000056  4823              LDR      r0,|L1.228|
000058  3840              SUBS     r0,r0,#0x40           ;511
00005a  6800              LDR      r0,[r0,#0]            ;511
00005c  f3c06040          UBFX     r0,r0,#25,#1          ;511
000060  2800              CMP      r0,#0                 ;511
000062  d1f1              BNE      |L1.72|
000064  bf00              NOP                            ;520
000066  4820              LDR      r0,|L1.232|
000068  6800              LDR      r0,[r0,#0]            ;520
00006a  f4204040          BIC      r0,r0,#0xc000         ;520
00006e  4328              ORRS     r0,r0,r5              ;520
000070  491d              LDR      r1,|L1.232|
000072  6008              STR      r0,[r1,#0]            ;520
000074  4608              MOV      r0,r1                 ;520
000076  6800              LDR      r0,[r0,#0]            ;520
000078  f4004040          AND      r0,r0,#0xc000         ;520
00007c  9000              STR      r0,[sp,#0]            ;520
00007e  bf00              NOP                            ;520
000080  bf00              NOP                            ;520
000082  4818              LDR      r0,|L1.228|
000084  3840              SUBS     r0,r0,#0x40           ;523
000086  6800              LDR      r0,[r0,#0]            ;523
000088  f0407080          ORR      r0,r0,#0x1000000      ;523
00008c  4915              LDR      r1,|L1.228|
00008e  3940              SUBS     r1,r1,#0x40           ;523
000090  6008              STR      r0,[r1,#0]            ;523
000092  f7fffffe          BL       HAL_GetTick
000096  4604              MOV      r4,r0                 ;526
000098  e006              B        |L1.168|
                  |L1.154|
00009a  f7fffffe          BL       HAL_GetTick
00009e  1b00              SUBS     r0,r0,r4              ;530
0000a0  2802              CMP      r0,#2                 ;530
0000a2  d901              BLS      |L1.168|
0000a4  2003              MOVS     r0,#3                 ;532
0000a6  e7d5              B        |L1.84|
                  |L1.168|
0000a8  480e              LDR      r0,|L1.228|
0000aa  3840              SUBS     r0,r0,#0x40           ;528
0000ac  6800              LDR      r0,[r0,#0]            ;528
0000ae  f3c06040          UBFX     r0,r0,#25,#1          ;528
0000b2  2800              CMP      r0,#0                 ;528
0000b4  d0f1              BEQ      |L1.154|
0000b6  f7fffffe          BL       HAL_GetTick
0000ba  4604              MOV      r4,r0                 ;537
0000bc  e007              B        |L1.206|
                  |L1.190|
0000be  f7fffffe          BL       HAL_GetTick
0000c2  1b00              SUBS     r0,r0,r4              ;540
0000c4  f5b07f7a          CMP      r0,#0x3e8             ;540
0000c8  d901              BLS      |L1.206|
0000ca  2003              MOVS     r0,#3                 ;542
0000cc  e7c2              B        |L1.84|
                  |L1.206|
0000ce  4806              LDR      r0,|L1.232|
0000d0  6840              LDR      r0,[r0,#4]            ;538
0000d2  f3c03080          UBFX     r0,r0,#14,#1          ;538
0000d6  2800              CMP      r0,#0                 ;538
0000d8  d0f1              BEQ      |L1.190|
0000da  e001              B        |L1.224|
                  |L1.220|
0000dc  2001              MOVS     r0,#1                 ;548
0000de  e7b9              B        |L1.84|
                  |L1.224|
0000e0  2000              MOVS     r0,#0                 ;550
0000e2  e7b7              B        |L1.84|
;;;552    
                          ENDP

                  |L1.228|
                          DCD      0x40023840
                  |L1.232|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_DisableBkUpReg||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisableBkUpReg PROC
;;;179      */
;;;180    HAL_StatusTypeDef HAL_PWREx_DisableBkUpReg(void)
000000  b510              PUSH     {r4,lr}
;;;181    {
;;;182      uint32_t tickstart = 0;
000002  2400              MOVS     r4,#0
;;;183      
;;;184      /* Disable Backup regulator */
;;;185      PWR->CSR1 &= (uint32_t)~((uint32_t)PWR_CSR1_BRE);
000004  480f              LDR      r0,|L2.68|
000006  6840              LDR      r0,[r0,#4]
000008  f4207000          BIC      r0,r0,#0x200
00000c  490d              LDR      r1,|L2.68|
00000e  6048              STR      r0,[r1,#4]
;;;186      
;;;187      /* Workaround for the following hardware bug: */
;;;188      /* Id 19: PWR : No STANDBY wake-up when Back-up RAM enabled (ref. Errata Sheet p23) */
;;;189      PWR->CSR1 |= PWR_CSR1_EIWUP;
000010  4608              MOV      r0,r1
000012  6840              LDR      r0,[r0,#4]
000014  f4407080          ORR      r0,r0,#0x100
000018  6048              STR      r0,[r1,#4]
;;;190    
;;;191      /* Get tick */
;;;192      tickstart = HAL_GetTick();
00001a  f7fffffe          BL       HAL_GetTick
00001e  4604              MOV      r4,r0
;;;193    
;;;194      /* Wait till Backup regulator ready flag is set */  
;;;195      while(__HAL_PWR_GET_FLAG(PWR_FLAG_BRR) != RESET)
000020  e007              B        |L2.50|
                  |L2.34|
;;;196      {
;;;197        if((HAL_GetTick() - tickstart ) > PWR_BKPREG_TIMEOUT_VALUE)
000022  f7fffffe          BL       HAL_GetTick
000026  1b00              SUBS     r0,r0,r4
000028  f5b07f7a          CMP      r0,#0x3e8
00002c  d901              BLS      |L2.50|
;;;198        {
;;;199          return HAL_TIMEOUT;
00002e  2003              MOVS     r0,#3
                  |L2.48|
;;;200        } 
;;;201      }
;;;202      return HAL_OK;
;;;203    }
000030  bd10              POP      {r4,pc}
                  |L2.50|
000032  4804              LDR      r0,|L2.68|
000034  6840              LDR      r0,[r0,#4]            ;195
000036  f3c000c0          UBFX     r0,r0,#3,#1           ;195
00003a  2800              CMP      r0,#0                 ;195
00003c  d1f1              BNE      |L2.34|
00003e  bf00              NOP                            ;202
000040  e7f6              B        |L2.48|
;;;204    
                          ENDP

000042  0000              DCW      0x0000
                  |L2.68|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_DisableFlashPowerDown||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisableFlashPowerDown PROC
;;;218      */
;;;219    void HAL_PWREx_DisableFlashPowerDown(void)
000000  4803              LDR      r0,|L3.16|
;;;220    {
;;;221      /* Disable the Flash Power Down */
;;;222      PWR->CR1 &= (uint32_t)~((uint32_t)PWR_CR1_FPDS);
000002  6800              LDR      r0,[r0,#0]
000004  f4207000          BIC      r0,r0,#0x200
000008  4901              LDR      r1,|L3.16|
00000a  6008              STR      r0,[r1,#0]
;;;223    }
00000c  4770              BX       lr
;;;224    
                          ENDP

00000e  0000              DCW      0x0000
                  |L3.16|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_DisableLowRegulatorLowVoltage||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisableLowRegulatorLowVoltage PROC
;;;258      */
;;;259    void HAL_PWREx_DisableLowRegulatorLowVoltage(void)
000000  4803              LDR      r0,|L4.16|
;;;260    {
;;;261      /* Disable low power regulator */
;;;262      PWR->CR1 &= (uint32_t)~((uint32_t)PWR_CR1_LPUDS);
000002  6800              LDR      r0,[r0,#0]
000004  f4206080          BIC      r0,r0,#0x400
000008  4901              LDR      r1,|L4.16|
00000a  6008              STR      r0,[r1,#0]
;;;263    }
00000c  4770              BX       lr
;;;264    
                          ENDP

00000e  0000              DCW      0x0000
                  |L4.16|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_DisableMainRegulatorLowVoltage||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisableMainRegulatorLowVoltage PROC
;;;238      */
;;;239    void HAL_PWREx_DisableMainRegulatorLowVoltage(void)
000000  4803              LDR      r0,|L5.16|
;;;240    {  
;;;241      /* Disable Main regulator low voltage */
;;;242      PWR->CR1 &= (uint32_t)~((uint32_t)PWR_CR1_MRUDS);
000002  6800              LDR      r0,[r0,#0]
000004  f4206000          BIC      r0,r0,#0x800
000008  4901              LDR      r1,|L5.16|
00000a  6008              STR      r0,[r1,#0]
;;;243    }
00000c  4770              BX       lr
;;;244    
                          ENDP

00000e  0000              DCW      0x0000
                  |L5.16|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_DisableOverDrive||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisableOverDrive PROC
;;;320      */
;;;321    HAL_StatusTypeDef HAL_PWREx_DisableOverDrive(void)
000000  b538              PUSH     {r3-r5,lr}
;;;322    {
;;;323      uint32_t tickstart = 0;
000002  2400              MOVS     r4,#0
;;;324      
;;;325      __HAL_RCC_PWR_CLK_ENABLE();
000004  bf00              NOP      
000006  4820              LDR      r0,|L6.136|
000008  6800              LDR      r0,[r0,#0]
00000a  f0405080          ORR      r0,r0,#0x10000000
00000e  491e              LDR      r1,|L6.136|
000010  6008              STR      r0,[r1,#0]
000012  4608              MOV      r0,r1
000014  6800              LDR      r0,[r0,#0]
000016  f0005080          AND      r0,r0,#0x10000000
00001a  9000              STR      r0,[sp,#0]
00001c  bf00              NOP      
00001e  bf00              NOP      
;;;326        
;;;327      /* Disable the Over-drive switch */
;;;328      __HAL_PWR_OVERDRIVESWITCHING_DISABLE();
000020  481a              LDR      r0,|L6.140|
000022  6800              LDR      r0,[r0,#0]
000024  f4203000          BIC      r0,r0,#0x20000
000028  4918              LDR      r1,|L6.140|
00002a  6008              STR      r0,[r1,#0]
;;;329      
;;;330      /* Get tick */
;;;331      tickstart = HAL_GetTick();
00002c  f7fffffe          BL       HAL_GetTick
000030  4604              MOV      r4,r0
;;;332     
;;;333      while(__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
000032  e007              B        |L6.68|
                  |L6.52|
;;;334      {
;;;335        if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
000034  f7fffffe          BL       HAL_GetTick
000038  1b00              SUBS     r0,r0,r4
00003a  f5b07f7a          CMP      r0,#0x3e8
00003e  d901              BLS      |L6.68|
;;;336        {
;;;337          return HAL_TIMEOUT;
000040  2003              MOVS     r0,#3
                  |L6.66|
;;;338        }
;;;339      } 
;;;340      
;;;341      /* Disable the Over-drive */
;;;342      __HAL_PWR_OVERDRIVE_DISABLE();
;;;343    
;;;344      /* Get tick */
;;;345      tickstart = HAL_GetTick();
;;;346    
;;;347      while(__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
;;;348      {
;;;349        if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
;;;350        {
;;;351          return HAL_TIMEOUT;
;;;352        }
;;;353      }
;;;354      
;;;355      return HAL_OK;
;;;356    }
000042  bd38              POP      {r3-r5,pc}
                  |L6.68|
000044  4811              LDR      r0,|L6.140|
000046  6840              LDR      r0,[r0,#4]            ;333
000048  f4003000          AND      r0,r0,#0x20000        ;333
00004c  f5b03f00          CMP      r0,#0x20000           ;333
000050  d0f0              BEQ      |L6.52|
000052  480e              LDR      r0,|L6.140|
000054  6800              LDR      r0,[r0,#0]            ;342
000056  f4203080          BIC      r0,r0,#0x10000        ;342
00005a  490c              LDR      r1,|L6.140|
00005c  6008              STR      r0,[r1,#0]            ;342
00005e  f7fffffe          BL       HAL_GetTick
000062  4604              MOV      r4,r0                 ;345
000064  e007              B        |L6.118|
                  |L6.102|
000066  f7fffffe          BL       HAL_GetTick
00006a  1b00              SUBS     r0,r0,r4              ;349
00006c  f5b07f7a          CMP      r0,#0x3e8             ;349
000070  d901              BLS      |L6.118|
000072  2003              MOVS     r0,#3                 ;351
000074  e7e5              B        |L6.66|
                  |L6.118|
000076  4805              LDR      r0,|L6.140|
000078  6840              LDR      r0,[r0,#4]            ;347
00007a  f4003080          AND      r0,r0,#0x10000        ;347
00007e  f5b03f80          CMP      r0,#0x10000           ;347
000082  d0f0              BEQ      |L6.102|
000084  2000              MOVS     r0,#0                 ;355
000086  e7dc              B        |L6.66|
;;;357    
                          ENDP

                  |L6.136|
                          DCD      0x40023840
                  |L6.140|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnableBkUpReg||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnableBkUpReg PROC
;;;150      */
;;;151    HAL_StatusTypeDef HAL_PWREx_EnableBkUpReg(void)
000000  b510              PUSH     {r4,lr}
;;;152    {
;;;153      uint32_t tickstart = 0;
000002  2400              MOVS     r4,#0
;;;154    
;;;155      /* Enable Backup regulator */
;;;156      PWR->CSR1 |= PWR_CSR1_BRE;
000004  480f              LDR      r0,|L7.68|
000006  6840              LDR      r0,[r0,#4]
000008  f4407000          ORR      r0,r0,#0x200
00000c  490d              LDR      r1,|L7.68|
00000e  6048              STR      r0,[r1,#4]
;;;157        
;;;158      /* Workaround for the following hardware bug: */
;;;159      /* Id 19: PWR : No STANDBY wake-up when Back-up RAM enabled (ref. Errata Sheet p23) */
;;;160      PWR->CSR1 |= PWR_CSR1_EIWUP;
000010  4608              MOV      r0,r1
000012  6840              LDR      r0,[r0,#4]
000014  f4407080          ORR      r0,r0,#0x100
000018  6048              STR      r0,[r1,#4]
;;;161    
;;;162      /* Get tick */
;;;163      tickstart = HAL_GetTick();
00001a  f7fffffe          BL       HAL_GetTick
00001e  4604              MOV      r4,r0
;;;164    
;;;165      /* Wait till Backup regulator ready flag is set */  
;;;166      while(__HAL_PWR_GET_FLAG(PWR_FLAG_BRR) == RESET)
000020  e007              B        |L7.50|
                  |L7.34|
;;;167      {
;;;168        if((HAL_GetTick() - tickstart ) > PWR_BKPREG_TIMEOUT_VALUE)
000022  f7fffffe          BL       HAL_GetTick
000026  1b00              SUBS     r0,r0,r4
000028  f5b07f7a          CMP      r0,#0x3e8
00002c  d901              BLS      |L7.50|
;;;169        {
;;;170          return HAL_TIMEOUT;
00002e  2003              MOVS     r0,#3
                  |L7.48|
;;;171        } 
;;;172      }
;;;173      return HAL_OK;
;;;174    }
000030  bd10              POP      {r4,pc}
                  |L7.50|
000032  4804              LDR      r0,|L7.68|
000034  6840              LDR      r0,[r0,#4]            ;166
000036  f3c000c0          UBFX     r0,r0,#3,#1           ;166
00003a  2800              CMP      r0,#0                 ;166
00003c  d0f1              BEQ      |L7.34|
00003e  2000              MOVS     r0,#0                 ;173
000040  e7f6              B        |L7.48|
;;;175    
                          ENDP

000042  0000              DCW      0x0000
                  |L7.68|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnableFlashPowerDown||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnableFlashPowerDown PROC
;;;208      */
;;;209    void HAL_PWREx_EnableFlashPowerDown(void)
000000  4803              LDR      r0,|L8.16|
;;;210    {
;;;211      /* Enable the Flash Power Down */
;;;212      PWR->CR1 |= PWR_CR1_FPDS;
000002  6800              LDR      r0,[r0,#0]
000004  f4407000          ORR      r0,r0,#0x200
000008  4901              LDR      r1,|L8.16|
00000a  6008              STR      r0,[r1,#0]
;;;213    }
00000c  4770              BX       lr
;;;214    
                          ENDP

00000e  0000              DCW      0x0000
                  |L8.16|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnableLowRegulatorLowVoltage||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnableLowRegulatorLowVoltage PROC
;;;248      */
;;;249    void HAL_PWREx_EnableLowRegulatorLowVoltage(void)
000000  4803              LDR      r0,|L9.16|
;;;250    {
;;;251      /* Enable low power regulator */
;;;252      PWR->CR1 |= PWR_CR1_LPUDS;
000002  6800              LDR      r0,[r0,#0]
000004  f4406080          ORR      r0,r0,#0x400
000008  4901              LDR      r1,|L9.16|
00000a  6008              STR      r0,[r1,#0]
;;;253    }
00000c  4770              BX       lr
;;;254    
                          ENDP

00000e  0000              DCW      0x0000
                  |L9.16|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnableMainRegulatorLowVoltage||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnableMainRegulatorLowVoltage PROC
;;;228      */
;;;229    void HAL_PWREx_EnableMainRegulatorLowVoltage(void)
000000  4803              LDR      r0,|L10.16|
;;;230    {
;;;231      /* Enable Main regulator low voltage */
;;;232      PWR->CR1 |= PWR_CR1_MRUDS;
000002  6800              LDR      r0,[r0,#0]
000004  f4406000          ORR      r0,r0,#0x800
000008  4901              LDR      r1,|L10.16|
00000a  6008              STR      r0,[r1,#0]
;;;233    }
00000c  4770              BX       lr
;;;234    
                          ENDP

00000e  0000              DCW      0x0000
                  |L10.16|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnableOverDrive||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnableOverDrive PROC
;;;274      */
;;;275    HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
000000  b538              PUSH     {r3-r5,lr}
;;;276    {
;;;277      uint32_t tickstart = 0;
000002  2400              MOVS     r4,#0
;;;278    
;;;279      __HAL_RCC_PWR_CLK_ENABLE();
000004  bf00              NOP      
000006  4820              LDR      r0,|L11.136|
000008  6800              LDR      r0,[r0,#0]
00000a  f0405080          ORR      r0,r0,#0x10000000
00000e  491e              LDR      r1,|L11.136|
000010  6008              STR      r0,[r1,#0]
000012  4608              MOV      r0,r1
000014  6800              LDR      r0,[r0,#0]
000016  f0005080          AND      r0,r0,#0x10000000
00001a  9000              STR      r0,[sp,#0]
00001c  bf00              NOP      
00001e  bf00              NOP      
;;;280      
;;;281      /* Enable the Over-drive to extend the clock frequency to 216 MHz */
;;;282      __HAL_PWR_OVERDRIVE_ENABLE();
000020  481a              LDR      r0,|L11.140|
000022  6800              LDR      r0,[r0,#0]
000024  f4403080          ORR      r0,r0,#0x10000
000028  4918              LDR      r1,|L11.140|
00002a  6008              STR      r0,[r1,#0]
;;;283    
;;;284      /* Get tick */
;;;285      tickstart = HAL_GetTick();
00002c  f7fffffe          BL       HAL_GetTick
000030  4604              MOV      r4,r0
;;;286    
;;;287      while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
000032  e007              B        |L11.68|
                  |L11.52|
;;;288      {
;;;289        if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
000034  f7fffffe          BL       HAL_GetTick
000038  1b00              SUBS     r0,r0,r4
00003a  f5b07f7a          CMP      r0,#0x3e8
00003e  d901              BLS      |L11.68|
;;;290        {
;;;291          return HAL_TIMEOUT;
000040  2003              MOVS     r0,#3
                  |L11.66|
;;;292        }
;;;293      }
;;;294      
;;;295      /* Enable the Over-drive switch */
;;;296      __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
;;;297    
;;;298      /* Get tick */
;;;299      tickstart = HAL_GetTick();
;;;300    
;;;301      while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
;;;302      {
;;;303        if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
;;;304        {
;;;305          return HAL_TIMEOUT;
;;;306        }
;;;307      } 
;;;308      return HAL_OK;
;;;309    }
000042  bd38              POP      {r3-r5,pc}
                  |L11.68|
000044  4811              LDR      r0,|L11.140|
000046  6840              LDR      r0,[r0,#4]            ;287
000048  f4003080          AND      r0,r0,#0x10000        ;287
00004c  f5b03f80          CMP      r0,#0x10000           ;287
000050  d1f0              BNE      |L11.52|
000052  480e              LDR      r0,|L11.140|
000054  6800              LDR      r0,[r0,#0]            ;296
000056  f4403000          ORR      r0,r0,#0x20000        ;296
00005a  490c              LDR      r1,|L11.140|
00005c  6008              STR      r0,[r1,#0]            ;296
00005e  f7fffffe          BL       HAL_GetTick
000062  4604              MOV      r4,r0                 ;299
000064  e007              B        |L11.118|
                  |L11.102|
000066  f7fffffe          BL       HAL_GetTick
00006a  1b00              SUBS     r0,r0,r4              ;303
00006c  f5b07f7a          CMP      r0,#0x3e8             ;303
000070  d901              BLS      |L11.118|
000072  2003              MOVS     r0,#3                 ;305
000074  e7e5              B        |L11.66|
                  |L11.118|
000076  4805              LDR      r0,|L11.140|
000078  6840              LDR      r0,[r0,#4]            ;301
00007a  f4003000          AND      r0,r0,#0x20000        ;301
00007e  f5b03f00          CMP      r0,#0x20000           ;301
000082  d1f0              BNE      |L11.102|
000084  2000              MOVS     r0,#0                 ;308
000086  e7dc              B        |L11.66|
;;;310    
                          ENDP

                  |L11.136|
                          DCD      0x40023840
                  |L11.140|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnterUnderDriveSTOPMode||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnterUnderDriveSTOPMode PROC
;;;394      */
;;;395    HAL_StatusTypeDef HAL_PWREx_EnterUnderDriveSTOPMode(uint32_t Regulator, uint8_t STOPEntry)
000000  b5f8              PUSH     {r3-r7,lr}
;;;396    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;397      uint32_t tempreg = 0;
000006  2400              MOVS     r4,#0
;;;398      uint32_t tickstart = 0;
000008  2700              MOVS     r7,#0
;;;399      
;;;400      /* Check the parameters */
;;;401      assert_param(IS_PWR_REGULATOR_UNDERDRIVE(Regulator));
;;;402      assert_param(IS_PWR_STOP_ENTRY(STOPEntry));
;;;403      
;;;404      /* Enable Power ctrl clock */
;;;405      __HAL_RCC_PWR_CLK_ENABLE();
00000a  bf00              NOP      
00000c  4822              LDR      r0,|L12.152|
00000e  6800              LDR      r0,[r0,#0]
000010  f0405080          ORR      r0,r0,#0x10000000
000014  4920              LDR      r1,|L12.152|
000016  6008              STR      r0,[r1,#0]
000018  4608              MOV      r0,r1
00001a  6800              LDR      r0,[r0,#0]
00001c  f0005080          AND      r0,r0,#0x10000000
000020  9000              STR      r0,[sp,#0]
000022  bf00              NOP      
000024  bf00              NOP      
;;;406      /* Enable the Under-drive Mode ---------------------------------------------*/
;;;407      /* Clear Under-drive flag */
;;;408      __HAL_PWR_CLEAR_ODRUDR_FLAG();
000026  481d              LDR      r0,|L12.156|
000028  6840              LDR      r0,[r0,#4]
00002a  f4402040          ORR      r0,r0,#0xc0000
00002e  491b              LDR      r1,|L12.156|
000030  6048              STR      r0,[r1,#4]
;;;409      
;;;410      /* Enable the Under-drive */ 
;;;411      __HAL_PWR_UNDERDRIVE_ENABLE();
000032  4608              MOV      r0,r1
000034  6800              LDR      r0,[r0,#0]
000036  f4402040          ORR      r0,r0,#0xc0000
00003a  6008              STR      r0,[r1,#0]
;;;412    
;;;413      /* Get tick */
;;;414      tickstart = HAL_GetTick();
00003c  f7fffffe          BL       HAL_GetTick
000040  4607              MOV      r7,r0
;;;415    
;;;416      /* Wait for UnderDrive mode is ready */
;;;417      while(__HAL_PWR_GET_FLAG(PWR_FLAG_UDRDY))
000042  e007              B        |L12.84|
                  |L12.68|
;;;418      {
;;;419        if((HAL_GetTick() - tickstart ) > PWR_UDERDRIVE_TIMEOUT_VALUE)
000044  f7fffffe          BL       HAL_GetTick
000048  1bc0              SUBS     r0,r0,r7
00004a  f5b07f7a          CMP      r0,#0x3e8
00004e  d901              BLS      |L12.84|
;;;420        {
;;;421          return HAL_TIMEOUT;
000050  2003              MOVS     r0,#3
                  |L12.82|
;;;422        }
;;;423      }
;;;424      
;;;425      /* Select the regulator state in STOP mode ---------------------------------*/
;;;426      tempreg = PWR->CR1;
;;;427      /* Clear PDDS, LPDS, MRLUDS and LPLUDS bits */
;;;428      tempreg &= (uint32_t)~(PWR_CR1_PDDS | PWR_CR1_LPDS | PWR_CR1_LPUDS | PWR_CR1_MRUDS);
;;;429      
;;;430      /* Set LPDS, MRLUDS and LPLUDS bits according to PWR_Regulator value */
;;;431      tempreg |= Regulator;
;;;432      
;;;433      /* Store the new value */
;;;434      PWR->CR1 = tempreg;
;;;435      
;;;436      /* Set SLEEPDEEP bit of Cortex System Control Register */
;;;437      SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
;;;438      
;;;439      /* Select STOP mode entry --------------------------------------------------*/
;;;440      if(STOPEntry == PWR_SLEEPENTRY_WFI)
;;;441      {   
;;;442        /* Request Wait For Interrupt */
;;;443        __WFI();
;;;444      }
;;;445      else
;;;446      {
;;;447        /* Request Wait For Event */
;;;448        __WFE();
;;;449      }
;;;450      /* Reset SLEEPDEEP bit of Cortex System Control Register */
;;;451      SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);
;;;452    
;;;453      return HAL_OK;  
;;;454    }
000052  bdf8              POP      {r3-r7,pc}
                  |L12.84|
000054  4811              LDR      r0,|L12.156|
000056  6840              LDR      r0,[r0,#4]            ;417
000058  f4002040          AND      r0,r0,#0xc0000        ;417
00005c  f5b02f40          CMP      r0,#0xc0000           ;417
000060  d0f0              BEQ      |L12.68|
000062  480e              LDR      r0,|L12.156|
000064  6804              LDR      r4,[r0,#0]            ;426
000066  f6404003          MOV      r0,#0xc03             ;428
00006a  4384              BICS     r4,r4,r0              ;428
00006c  432c              ORRS     r4,r4,r5              ;431
00006e  480b              LDR      r0,|L12.156|
000070  6004              STR      r4,[r0,#0]            ;434
000072  480b              LDR      r0,|L12.160|
000074  6800              LDR      r0,[r0,#0]            ;437
000076  f0400004          ORR      r0,r0,#4              ;437
00007a  4909              LDR      r1,|L12.160|
00007c  6008              STR      r0,[r1,#0]            ;437
00007e  2e01              CMP      r6,#1                 ;440
000080  d101              BNE      |L12.134|
000082  bf30              WFI                            ;443
000084  e000              B        |L12.136|
                  |L12.134|
000086  bf20              WFE                            ;448
                  |L12.136|
000088  4805              LDR      r0,|L12.160|
00008a  6800              LDR      r0,[r0,#0]            ;451
00008c  f0200004          BIC      r0,r0,#4              ;451
000090  4903              LDR      r1,|L12.160|
000092  6008              STR      r0,[r1,#0]            ;451
000094  2000              MOVS     r0,#0                 ;453
000096  e7dc              B        |L12.82|
;;;455    
                          ENDP

                  |L12.152|
                          DCD      0x40023840
                  |L12.156|
                          DCD      0x40007000
                  |L12.160|
                          DCD      0xe000ed10

                          AREA ||i.HAL_PWREx_GetVoltageRange||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_GetVoltageRange PROC
;;;460      */  
;;;461    uint32_t HAL_PWREx_GetVoltageRange(void)
000000  4802              LDR      r0,|L13.12|
;;;462    {
;;;463      return  (PWR->CR1 & PWR_CR1_VOS);
000002  6800              LDR      r0,[r0,#0]
000004  f4004040          AND      r0,r0,#0xc000
;;;464    }
000008  4770              BX       lr
;;;465    
                          ENDP

00000a  0000              DCW      0x0000
                  |L13.12|
                          DCD      0x40007000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F7_V1.11.0\\Drivers\\STM32F7xx_HAL_Driver\\Src\\stm32f7xx_hal_pwr_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f7xx_hal_pwr_ex_c_1028ebfa____REV16|
#line 464 "D:\\Program_Files_x86\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.1.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___22_stm32f7xx_hal_pwr_ex_c_1028ebfa____REV16| PROC
#line 465

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f7xx_hal_pwr_ex_c_1028ebfa____REVSH|
#line 479
|__asm___22_stm32f7xx_hal_pwr_ex_c_1028ebfa____REVSH| PROC
#line 480

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f7xx_hal_pwr_ex_c_1028ebfa____RRX|
#line 666
|__asm___22_stm32f7xx_hal_pwr_ex_c_1028ebfa____RRX| PROC
#line 667

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
