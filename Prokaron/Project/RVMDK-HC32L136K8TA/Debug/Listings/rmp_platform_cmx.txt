; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\rmp_platform_cmx.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\rmp_platform_cmx.d --cpu=Cortex-M0+ --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\HC32L13X_DDL_V1.0\driver\inc -I..\..\..\M0P0_Library\HC32L13X_DDL_V1.0\mcu\common -I..\..\..\M0P0_Library\HC32L13X_DDL_V1.0\driver\CMSIS\Include -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-HC32L136K8TA\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\HDSC\HC32L13X\1.0.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ --enum_is_int --signed_chars --omf_browse=.\debug\output\rmp_platform_cmx.crf ..\..\MProkaron\Platform\CortexM\rmp_platform_cmx.c]
                          THUMB

                          AREA ||i.RMP_Putchar||, CODE, READONLY, ALIGN=1

                  RMP_Putchar PROC
;;;103    ******************************************************************************/
;;;104    void RMP_Putchar(char Char)
000000  4770              BX       lr
;;;105    {
;;;106        RMP_CMX_PUTCHAR(Char);
;;;107    }
;;;108    /* End Function:RMP_Putchar **************************************************/
                          ENDP


                          AREA ||i._RMP_Low_Level_Init||, CODE, READONLY, ALIGN=2

                  _RMP_Low_Level_Init PROC
;;;77     ******************************************************************************/
;;;78     void _RMP_Low_Level_Init(void)
000000  b510              PUSH     {r4,lr}
;;;79     {    
;;;80         RMP_CMX_LOW_LEVEL_INIT();
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       Sysctrl_SetRCLTrim
000008  2101              MOVS     r1,#1
00000a  2002              MOVS     r0,#2
00000c  f7fffffe          BL       Sysctrl_ClkSourceEnable
000010  2002              MOVS     r0,#2
000012  f7fffffe          BL       Sysctrl_SysClkSwitch
000016  2004              MOVS     r0,#4
000018  f7fffffe          BL       Sysctrl_SetRCHTrim
00001c  2000              MOVS     r0,#0
00001e  f7fffffe          BL       Sysctrl_SysClkSwitch
000022  2100              MOVS     r1,#0
000024  2002              MOVS     r0,#2
000026  f7fffffe          BL       Sysctrl_ClkSourceEnable
00002a  f7fffffe          BL       SystemCoreClockUpdate
00002e  4812              LDR      r0,|L2.120|
000030  69c1              LDR      r1,[r0,#0x1c]
000032  020a              LSLS     r2,r1,#8
000034  0a12              LSRS     r2,r2,#8
000036  2103              MOVS     r1,#3
000038  0789              LSLS     r1,r1,#30
00003a  430a              ORRS     r2,r2,r1
00003c  61c2              STR      r2,[r0,#0x1c]
00003e  1d00              ADDS     r0,r0,#4
000040  69c2              LDR      r2,[r0,#0x1c]
000042  23ff              MOVS     r3,#0xff
000044  041b              LSLS     r3,r3,#16
000046  439a              BICS     r2,r2,r3
000048  0a0b              LSRS     r3,r1,#8
00004a  431a              ORRS     r2,r2,r3
00004c  61c2              STR      r2,[r0,#0x1c]
00004e  69c2              LDR      r2,[r0,#0x1c]
;;;81       
;;;82         RMP_Disable_Int();
;;;83     }
000050  2407              MOVS     r4,#7
000052  0212              LSLS     r2,r2,#8
000054  0a12              LSRS     r2,r2,#8
000056  430a              ORRS     r2,r2,r1
000058  61c2              STR      r2,[r0,#0x1c]
00005a  4a09              LDR      r2,|L2.128|
00005c  4b07              LDR      r3,|L2.124|
00005e  6153              STR      r3,[r2,#0x14]
000060  69c3              LDR      r3,[r0,#0x1c]
000062  021b              LSLS     r3,r3,#8
000064  0a1b              LSRS     r3,r3,#8
000066  430b              ORRS     r3,r3,r1
000068  61c3              STR      r3,[r0,#0x1c]
00006a  2000              MOVS     r0,#0
00006c  6190              STR      r0,[r2,#0x18]
00006e  6114              STR      r4,[r2,#0x10]
000070  f7fffffe          BL       RMP_Disable_Int
000074  bd10              POP      {r4,pc}
;;;84     /* End Function:_RMP_Low_Level_Init ******************************************/
                          ENDP

000076  0000              DCW      0x0000
                  |L2.120|
                          DCD      0xe000ed00
                  |L2.124|
                          DCD      0x00005dbf
                  |L2.128|
                          DCD      0xe000e000

                          AREA ||i._RMP_Plat_Hook||, CODE, READONLY, ALIGN=1

                  _RMP_Plat_Hook PROC
;;;91     ******************************************************************************/
;;;92     void _RMP_Plat_Hook(void)
000000  b510              PUSH     {r4,lr}
;;;93     {
;;;94         RMP_Enable_Int();
000002  f7fffffe          BL       RMP_Enable_Int
;;;95     }
000006  bd10              POP      {r4,pc}
;;;96     /* End Function:_RMP_Plat_Hook ***********************************************/
                          ENDP


                          AREA ||i._RMP_Stack_Init||, CODE, READONLY, ALIGN=1

                  _RMP_Stack_Init PROC
;;;52     ******************************************************************************/
;;;53     void _RMP_Stack_Init(rmp_ptr_t Entry, rmp_ptr_t Stack, rmp_ptr_t Arg)
000000  2302              MOVS     r3,#2
;;;54     {
;;;55         /* This is the LR value indicating that we never used the FPU */
;;;56         ((rmp_ptr_t*)Stack)[0+8]=0xFFFFFFFD;    
000002  43db              MVNS     r3,r3
;;;57         /* Cortex-M:Pass the parameter */                            
;;;58         ((rmp_ptr_t*)Stack)[0+9]=Arg;       
;;;59         /* Cortex-M:Set the process entry */
;;;60         ((rmp_ptr_t*)Stack)[6+9]=Entry;
;;;61         /* Cortex-M:Set the T bit or an INVSTATE will happen; don't set STKALIGN, 
;;;62          * and there is no stack padding. The effect of STKALIGN is, if it is set
;;;63          * and the (hardware-pushed) interrupt stack is 8n byte aligned, it will
;;;64          * pop an extra word (to restore the stack to an previous unaligned state);
;;;65          * if the interrupt stack is 8n+4 byte aligned, even if STKALIGN is set, it
;;;66          * will not pop this extra word. The result is, if STKALIGN is set, we will
;;;67          * never be able to get a 8n byte aligned stack, so we do not set it. */                            
;;;68         ((rmp_ptr_t*)Stack)[7+9]=0x01000000;
000004  620b              STR      r3,[r1,#0x20]
000006  624a              STR      r2,[r1,#0x24]
000008  63c8              STR      r0,[r1,#0x3c]
00000a  2001              MOVS     r0,#1
00000c  0600              LSLS     r0,r0,#24
00000e  6408              STR      r0,[r1,#0x40]
;;;69     }
000010  4770              BX       lr
;;;70     /* End Function:_RMP_Stack_Init **********************************************/
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\MProkaron\\Platform\\CortexM\\rmp_platform_cmx.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_rmp_platform_cmx_c_203ac359____REV16|
#line 388 "..\\..\\..\\M0P0_Library\\HC32L13X_DDL_V1.0\\driver\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___18_rmp_platform_cmx_c_203ac359____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_rmp_platform_cmx_c_203ac359____REVSH|
#line 402
|__asm___18_rmp_platform_cmx_c_203ac359____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
