; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\rmp_kernel.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\rmp_kernel.d --cpu=Cortex-M0+ --apcs=interwork -O3 -Otime --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\HC32L13X_DDL_V1.0\driver\inc -I..\..\..\M0P0_Library\HC32L13X_DDL_V1.0\mcu\common -I..\..\..\M0P0_Library\HC32L13X_DDL_V1.0\driver\CMSIS\Include -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-HC32L136K8TA\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\HDSC\HC32L13X\1.0.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ --enum_is_int --signed_chars --omf_browse=.\debug\output\rmp_kernel.crf ..\..\MProkaron\Kernel\rmp_kernel.c]
                          THUMB

                          AREA ||i.RMP_CRC16||, CODE, READONLY, ALIGN=2

                  RMP_CRC16 PROC
;;;279    #ifdef __RMP_U16_T__
;;;280    rmp_ptr_t RMP_CRC16(const rmp_u8_t* Data, rmp_ptr_t Length)
000000  b570              PUSH     {r4-r6,lr}
;;;281    {
000002  b0c0              SUB      sp,sp,#0x100
000004  460d              MOV      r5,r1
000006  4604              MOV      r4,r0
;;;282        rmp_ptr_t Data_Cnt;
;;;283        rmp_u8_t Index;
;;;284        rmp_u8_t Temp_High;
;;;285        rmp_u8_t Temp_Low;
;;;286        
;;;287        /* CRC16 constants with X^16+X^15+X^2+1 */
;;;288        static const rmp_u8_t CRC16_High[256]=
;;;289        {
;;;290            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;291            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;292            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;293            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;294            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;295            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;296            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;297            0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;298            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;299            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;300            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;301            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;302            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;303            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;304            0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;305            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;306            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;307            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;308            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;309            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;310            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;311            0x00, 0xC1, 0x81, 0x40
;;;312        };
;;;313    
;;;314        const rmp_u8_t CRC16_Low[256]=
000008  22ff              MOVS     r2,#0xff
00000a  3201              ADDS     r2,#1
00000c  490a              LDR      r1,|L1.56|
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       __aeabi_memcpy4
;;;315        {
;;;316            0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7,
;;;317            0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E,
;;;318            0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9,
;;;319            0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC,
;;;320            0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
;;;321            0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32,
;;;322            0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D,
;;;323            0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38,
;;;324            0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF,
;;;325            0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
;;;326            0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1,
;;;327            0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4,
;;;328            0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB,
;;;329            0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA,
;;;330            0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
;;;331            0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0,
;;;332            0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97,
;;;333            0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E,
;;;334            0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89,
;;;335            0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
;;;336            0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83,
;;;337            0x41, 0x81, 0x80, 0x40
;;;338        };
;;;339    
;;;340        Temp_High=0xFF;
000014  23ff              MOVS     r3,#0xff
;;;341        Temp_Low=0xFF;
000016  461a              MOV      r2,r3
;;;342        for(Data_Cnt=0;Data_Cnt<Length;Data_Cnt++)
000018  2d00              CMP      r5,#0
00001a  d009              BEQ      |L1.48|
;;;343        {
;;;344            Index=Temp_Low^Data[Data_Cnt];
;;;345            Temp_Low=(rmp_u8_t)(Temp_High^CRC16_High[Index]);
00001c  4e07              LDR      r6,|L1.60|
00001e  4669              MOV      r1,sp                 ;314
                  |L1.32|
000020  7820              LDRB     r0,[r4,#0]            ;344
;;;346            Temp_High=CRC16_Low[Index];
000022  1c64              ADDS     r4,r4,#1
000024  4050              EORS     r0,r0,r2              ;344
000026  5c32              LDRB     r2,[r6,r0]            ;345
000028  405a              EORS     r2,r2,r3              ;345
00002a  5c0b              LDRB     r3,[r1,r0]
00002c  1e6d              SUBS     r5,r5,#1
00002e  d1f7              BNE      |L1.32|
                  |L1.48|
;;;347        }
;;;348    
;;;349        return (rmp_u16_t)(((rmp_u16_t)Temp_High)<<8|Temp_Low);
000030  0218              LSLS     r0,r3,#8
000032  4310              ORRS     r0,r0,r2
;;;350    }
000034  b040              ADD      sp,sp,#0x100
000036  bd70              POP      {r4-r6,pc}
;;;351    #endif
                          ENDP

                  |L1.56|
                          DCD      ||.constdata||+0x200
                  |L1.60|
                          DCD      ||.constdata||+0x100

                          AREA ||i.RMP_Clear||, CODE, READONLY, ALIGN=1

                  RMP_Clear PROC
;;;66     ******************************************************************************/
;;;67     void RMP_Clear(volatile void* Addr, rmp_ptr_t Size)
000000  2900              CMP      r1,#0
;;;68     {
000002  dd0d              BLE      |L2.32|
;;;69         rmp_u8_t* Ptr;
;;;70         rmp_cnt_t Count;
;;;71        
;;;72         Ptr=(rmp_u8_t*)Addr;
;;;73         for(Count=0;Count<(rmp_cnt_t)Size;Count++)
;;;74             Ptr[Count]=0;
;;;75     }
000004  07cb              LSLS     r3,r1,#31
000006  2200              MOVS     r2,#0
000008  1e40              SUBS     r0,r0,#1
00000a  2b00              CMP      r3,#0
00000c  d001              BEQ      |L2.18|
00000e  7042              STRB     r2,[r0,#1]            ;74
000010  1c40              ADDS     r0,r0,#1              ;74
                  |L2.18|
000012  1049              ASRS     r1,r1,#1              ;73
000014  d004              BEQ      |L2.32|
                  |L2.22|
000016  7042              STRB     r2,[r0,#1]            ;74
000018  7082              STRB     r2,[r0,#2]            ;74
00001a  1c80              ADDS     r0,r0,#2              ;74
00001c  1e49              SUBS     r1,r1,#1              ;74
00001e  d1fa              BNE      |L2.22|
                  |L2.32|
000020  4770              BX       lr
;;;76     /* End Function:RMP_Clear ****************************************************/
                          ENDP


                          AREA ||i.RMP_Free||, CODE, READONLY, ALIGN=1

                  RMP_Free PROC
;;;2517   ******************************************************************************/
;;;2518   void RMP_Free(volatile void* Pool, void* Mem_Ptr)
000000  2800              CMP      r0,#0
;;;2519   {
;;;2520       volatile struct RMP_Mem* Mem;
;;;2521       volatile struct RMP_Mem_Head* Mem_Head;
;;;2522       volatile struct RMP_Mem_Head* Left_Head;
;;;2523       volatile struct RMP_Mem_Head* Right_Head;
;;;2524       rmp_cnt_t Merge_Left;
;;;2525   
;;;2526       /* Check if pointer is null */
;;;2527       if((Pool==0)||(Mem_Ptr==0))
000002  d046              BEQ      |L3.146|
000004  2900              CMP      r1,#0
000006  d044              BEQ      |L3.146|
;;;2528       {
;;;2529           RMP_COVERAGE_MARKER();
;;;2530           return;
;;;2531       }
;;;2532       else
;;;2533           RMP_COVERAGE_MARKER();
;;;2534       
;;;2535       /* See if the address is within the allocatable address range. If not, abort directly. */
;;;2536       Mem=(volatile struct RMP_Mem*)Pool;
;;;2537       if((((rmp_ptr_t)Mem_Ptr)<=((rmp_ptr_t)Mem))||(((rmp_ptr_t)Mem_Ptr)>=(((rmp_ptr_t)Mem)+Mem->Size)))
000008  4281              CMP      r1,r0
00000a  d942              BLS      |L3.146|
00000c  b5f8              PUSH     {r3-r7,lr}            ;2519
00000e  6882              LDR      r2,[r0,#8]
000010  4606              MOV      r6,r0                 ;2519
000012  1990              ADDS     r0,r2,r6
000014  4288              CMP      r0,r1
000016  d929              BLS      |L3.108|
;;;2538       {
;;;2539           RMP_COVERAGE_MARKER();
;;;2540           return;
;;;2541       }
;;;2542       else
;;;2543           RMP_COVERAGE_MARKER();
;;;2544   
;;;2545       Mem_Head=(struct RMP_Mem_Head*)(((rmp_ptr_t)Mem_Ptr)-sizeof(struct RMP_Mem_Head));
000018  460c              MOV      r4,r1
00001a  3c10              SUBS     r4,r4,#0x10
;;;2546       /* See if the block can really be freed */
;;;2547       if(Mem_Head->State==RMP_MEM_FREE)
00001c  68a0              LDR      r0,[r4,#8]
00001e  2800              CMP      r0,#0
000020  d024              BEQ      |L3.108|
;;;2548       {
;;;2549           RMP_COVERAGE_MARKER();
;;;2550           return;
;;;2551       }
;;;2552       else
;;;2553           RMP_COVERAGE_MARKER();
;;;2554   
;;;2555       /* Mark it as free */
;;;2556       Mem_Head->State=RMP_MEM_FREE;
000022  2700              MOVS     r7,#0
000024  60a7              STR      r7,[r4,#8]
;;;2557       
;;;2558       /* Now check if we can merge it with the higher blocks */
;;;2559       Right_Head=(struct RMP_Mem_Head*)(((rmp_ptr_t)(Mem_Head->Tail))+sizeof(struct RMP_Mem_Tail));
000026  68e5              LDR      r5,[r4,#0xc]
;;;2560       if(((rmp_ptr_t)Right_Head)!=(((rmp_ptr_t)Mem)+Mem->Size))
000028  68b1              LDR      r1,[r6,#8]
00002a  1d2d              ADDS     r5,r5,#4
00002c  1988              ADDS     r0,r1,r6
00002e  42a8              CMP      r0,r5
000030  d00f              BEQ      |L3.82|
;;;2561       {
;;;2562           RMP_COVERAGE_MARKER();
;;;2563           /* If this one is unoccupied */
;;;2564           if((Right_Head->State)==RMP_MEM_FREE)
000032  68a8              LDR      r0,[r5,#8]
000034  2800              CMP      r0,#0
000036  d10c              BNE      |L3.82|
;;;2565           {
;;;2566               RMP_COVERAGE_MARKER();
;;;2567               /* Delete, merge */
;;;2568               _RMP_Mem_Del(Pool,Right_Head);
000038  4629              MOV      r1,r5
00003a  4630              MOV      r0,r6
00003c  f7fffffe          BL       _RMP_Mem_Del
;;;2569               _RMP_Mem_Block(Mem_Head,
000040  68e8              LDR      r0,[r5,#0xc]
000042  60a7              STR      r7,[r4,#8]
000044  1b00              SUBS     r0,r0,r4
000046  1d00              ADDS     r0,r0,#4
000048  1820              ADDS     r0,r4,r0
00004a  1f00              SUBS     r0,r0,#4
00004c  60e0              STR      r0,[r4,#0xc]
00004e  68e0              LDR      r0,[r4,#0xc]
000050  6004              STR      r4,[r0,#0]
                  |L3.82|
;;;2570                              ((rmp_ptr_t)(Right_Head->Tail))+sizeof(struct RMP_Mem_Tail)-(rmp_ptr_t)Mem_Head);
;;;2571           }
;;;2572           else
;;;2573               RMP_COVERAGE_MARKER();
;;;2574       }
;;;2575       else
;;;2576           RMP_COVERAGE_MARKER();
;;;2577   
;;;2578       /* Now check if we can merge it with the lower blocks */
;;;2579       Merge_Left=0;
;;;2580       if((rmp_ptr_t)Mem_Head!=Mem->Start)
000052  6870              LDR      r0,[r6,#4]
000054  42a0              CMP      r0,r4
000056  d005              BEQ      |L3.100|
;;;2581       {
;;;2582           RMP_COVERAGE_MARKER();
;;;2583           Left_Head=((struct RMP_Mem_Tail*)(((rmp_ptr_t)Mem_Head)-sizeof(struct RMP_Mem_Tail)))->Head;
000058  4620              MOV      r0,r4
00005a  3880              SUBS     r0,r0,#0x80
;;;2584   
;;;2585           /* If this one is unoccupied */
;;;2586           if(Left_Head->State==RMP_MEM_FREE)
00005c  6fc5              LDR      r5,[r0,#0x7c]
00005e  68a8              LDR      r0,[r5,#8]
000060  2800              CMP      r0,#0
000062  d004              BEQ      |L3.110|
                  |L3.100|
;;;2587           {
;;;2588               RMP_COVERAGE_MARKER();
;;;2589               /* Delete, merge */
;;;2590               _RMP_Mem_Del(Pool, Left_Head);
;;;2591               _RMP_Mem_Block(Left_Head,
;;;2592                              (rmp_ptr_t)((rmp_ptr_t)(Mem_Head->Tail)+sizeof(struct RMP_Mem_Tail)-(rmp_ptr_t)Left_Head));
;;;2593   
;;;2594               /* We have completed the merge here and the original block has destroyed.
;;;2595                * Thus there's no need to insert it into the list again */
;;;2596               Merge_Left=1;
;;;2597           }
;;;2598           else
;;;2599               RMP_COVERAGE_MARKER();
;;;2600       }
;;;2601       else
;;;2602           RMP_COVERAGE_MARKER();
;;;2603   
;;;2604       /* If we did not merge it with the left-side blocks, insert the original pointer's block 
;;;2605        * into the TLSF table(Merging with the right-side one won't disturb this) */
;;;2606       if(Merge_Left==0)
;;;2607       {
;;;2608           RMP_COVERAGE_MARKER();
;;;2609           _RMP_Mem_Ins(Pool, Mem_Head);
000064  4621              MOV      r1,r4
000066  4630              MOV      r0,r6
000068  f7fffffe          BL       _RMP_Mem_Ins
                  |L3.108|
;;;2610       }
;;;2611       else
;;;2612       {
;;;2613           RMP_COVERAGE_MARKER();
;;;2614           _RMP_Mem_Ins(Pool, Left_Head);
;;;2615       }
;;;2616   }
00006c  bdf8              POP      {r3-r7,pc}
                  |L3.110|
00006e  4629              MOV      r1,r5                 ;2590
000070  4630              MOV      r0,r6                 ;2590
000072  f7fffffe          BL       _RMP_Mem_Del
000076  68e0              LDR      r0,[r4,#0xc]          ;2591
000078  60af              STR      r7,[r5,#8]            ;2591
00007a  1b40              SUBS     r0,r0,r5              ;2591
00007c  1d00              ADDS     r0,r0,#4              ;2591
00007e  1828              ADDS     r0,r5,r0              ;2591
000080  1f00              SUBS     r0,r0,#4              ;2591
000082  60e8              STR      r0,[r5,#0xc]          ;2591
000084  68e8              LDR      r0,[r5,#0xc]          ;2591
000086  6005              STR      r5,[r0,#0]            ;2591
000088  4629              MOV      r1,r5                 ;2614
00008a  4630              MOV      r0,r6                 ;2614
00008c  f7fffffe          BL       _RMP_Mem_Ins
000090  bdf8              POP      {r3-r7,pc}
                  |L3.146|
000092  4770              BX       lr
;;;2617   /* End Function:RMP_Free *****************************************************/
                          ENDP


                          AREA ||i.RMP_Init||, CODE, READONLY, ALIGN=2

                  RMP_Init PROC
;;;1970   ******************************************************************************/
;;;1971   void RMP_Init(void)
000000  f7fffffe          BL       RMP_Disable_Int
000004  4807              LDR      r0,|L4.36|
000006  2101              MOVS     r1,#1
000008  6081              STR      r1,[r0,#8]  ; RMP_Sched_Locked
00000a  6841              LDR      r1,[r0,#4]  ; RMP_Sched_Lock_Cnt
00000c  1c49              ADDS     r1,r1,#1
00000e  6041              STR      r1,[r0,#4]  ; RMP_Sched_Lock_Cnt
;;;1972   {
;;;1973       RMP_Lock_Sched();
;;;1974       
;;;1975       /* Platform will use this hook to do something */
;;;1976       _RMP_Plat_Hook();
000010  f7fffffe          BL       _RMP_Plat_Hook
;;;1977       /* Start the second thread here */
;;;1978       RMP_Init_Hook();
000014  f7fffffe          BL       RMP_Init_Hook
;;;1979       
;;;1980       RMP_Unlock_Sched();
000018  f7fffffe          BL       RMP_Unlock_Sched
                  |L4.28|
;;;1981       
;;;1982       while(1)
;;;1983           RMP_Init_Idle();
00001c  f7fffffe          BL       RMP_Init_Idle
000020  e7fc              B        |L4.28|
;;;1984   }
;;;1985   /* End Function:RMP_Init *****************************************************/
                          ENDP

000022  0000              DCW      0x0000
                  |L4.36|
                          DCD      ||.data||

                          AREA ||i.RMP_LSB_Get||, CODE, READONLY, ALIGN=2

                  RMP_LSB_Get PROC
;;;2118   ******************************************************************************/
;;;2119   rmp_ptr_t RMP_LSB_Get(rmp_ptr_t Val)
000000  b510              PUSH     {r4,lr}
000002  4a11              LDR      r2,|L5.72|
;;;2120   {
000004  0e03              LSRS     r3,r0,#24
000006  5cd3              LDRB     r3,[r2,r3]
000008  0a09              LSRS     r1,r1,#8
00000a  0209              LSLS     r1,r1,#8
00000c  4319              ORRS     r1,r1,r3
00000e  0203              LSLS     r3,r0,#8
000010  0e1b              LSRS     r3,r3,#24
000012  5cd3              LDRB     r3,[r2,r3]
000014  24ff              MOVS     r4,#0xff
000016  0224              LSLS     r4,r4,#8
000018  021b              LSLS     r3,r3,#8
00001a  43a1              BICS     r1,r1,r4
00001c  4023              ANDS     r3,r3,r4
00001e  4319              ORRS     r1,r1,r3
000020  0403              LSLS     r3,r0,#16
000022  0e1b              LSRS     r3,r3,#24
000024  5cd3              LDRB     r3,[r2,r3]
000026  0224              LSLS     r4,r4,#8
000028  041b              LSLS     r3,r3,#16
00002a  43a1              BICS     r1,r1,r4
00002c  4023              ANDS     r3,r3,r4
00002e  b2c0              UXTB     r0,r0
000030  4319              ORRS     r1,r1,r3
000032  5c12              LDRB     r2,[r2,r0]
000034  0208              LSLS     r0,r1,#8
000036  0a00              LSRS     r0,r0,#8
000038  0611              LSLS     r1,r2,#24
00003a  4308              ORRS     r0,r0,r1
;;;2121       return RMP_WORD_SIZE-1-RMP_MSB_Get(RMP_RBIT_Get(Val));
00003c  f7fffffe          BL       RMP_MSB_Get
000040  211f              MOVS     r1,#0x1f
000042  1a08              SUBS     r0,r1,r0
;;;2122   }
000044  bd10              POP      {r4,pc}
;;;2123   /* End Function:RMP_LSB_Get **************************************************/
                          ENDP

000046  0000              DCW      0x0000
                  |L5.72|
                          DCD      ||.constdata||

                          AREA ||i.RMP_List_Crt||, CODE, READONLY, ALIGN=1

                  RMP_List_Crt PROC
;;;230    ******************************************************************************/
;;;231    void RMP_List_Crt(volatile struct RMP_List* Head)
000000  6000              STR      r0,[r0,#0]
;;;232    {
;;;233        Head->Prev=(struct RMP_List*)Head;
;;;234        Head->Next=(struct RMP_List*)Head;
000002  6040              STR      r0,[r0,#4]
;;;235    }
000004  4770              BX       lr
;;;236    /* End Function:RMP_List_Crt *************************************************/
                          ENDP


                          AREA ||i.RMP_List_Del||, CODE, READONLY, ALIGN=1

                  RMP_List_Del PROC
;;;244    ******************************************************************************/
;;;245    void RMP_List_Del(volatile struct RMP_List* Prev,volatile struct RMP_List* Next)
000000  6008              STR      r0,[r1,#0]
;;;246    {
;;;247        Next->Prev=(struct RMP_List*)Prev;
;;;248        Prev->Next=(struct RMP_List*)Next;
000002  6041              STR      r1,[r0,#4]
;;;249    }
000004  4770              BX       lr
;;;250    /* End Function:RMP_List_Del *************************************************/
                          ENDP


                          AREA ||i.RMP_List_Ins||, CODE, READONLY, ALIGN=1

                  RMP_List_Ins PROC
;;;259    ******************************************************************************/
;;;260    void RMP_List_Ins(volatile struct RMP_List* New,
000000  6010              STR      r0,[r2,#0]
;;;261                      volatile struct RMP_List* Prev,
;;;262                      volatile struct RMP_List* Next)
;;;263    {
;;;264        Next->Prev=(struct RMP_List*)New;
;;;265        New->Next=(struct RMP_List*)Next;
000002  6042              STR      r2,[r0,#4]
;;;266        New->Prev=(struct RMP_List*)Prev;
000004  6001              STR      r1,[r0,#0]
;;;267        Prev->Next=(struct RMP_List*)New;
000006  6048              STR      r0,[r1,#4]
;;;268    }
000008  4770              BX       lr
;;;269    /* End Function:RMP_List_Ins *************************************************/
                          ENDP


                          AREA ||i.RMP_Load_Ctx||, CODE, READONLY, ALIGN=1

                  RMP_Load_Ctx PROC
;;;1955   #if(RMP_USE_HOOKS==RMP_FALSE)
;;;1956   void RMP_Load_Ctx(void)
000000  4770              BX       lr
;;;1957   {
;;;1958       return;
;;;1959   }
;;;1960   #endif
                          ENDP


                          AREA ||i.RMP_Lock_Sched||, CODE, READONLY, ALIGN=2

                  RMP_Lock_Sched PROC
;;;360    ******************************************************************************/
;;;361    void RMP_Lock_Sched(void)
000000  b510              PUSH     {r4,lr}
;;;362    {
;;;363        RMP_MASK_INT();
000002  f7fffffe          BL       RMP_Disable_Int
;;;364        RMP_Sched_Locked=1;
000006  4803              LDR      r0,|L10.20|
000008  2101              MOVS     r1,#1
00000a  6081              STR      r1,[r0,#8]  ; RMP_Sched_Locked
;;;365        RMP_Sched_Lock_Cnt++;
00000c  6841              LDR      r1,[r0,#4]  ; RMP_Sched_Lock_Cnt
00000e  1c49              ADDS     r1,r1,#1
000010  6041              STR      r1,[r0,#4]  ; RMP_Sched_Lock_Cnt
;;;366    }
000012  bd10              POP      {r4,pc}
;;;367    /* End Function:RMP_Lock_Sched ***********************************************/
                          ENDP

                  |L10.20|
                          DCD      ||.data||

                          AREA ||i.RMP_Malloc||, CODE, READONLY, ALIGN=2

                  RMP_Malloc PROC
;;;2444   ******************************************************************************/
;;;2445   void* RMP_Malloc(volatile void* Pool, rmp_ptr_t Size)
000000  2800              CMP      r0,#0
;;;2446   {    
;;;2447       rmp_cnt_t FLI_Level;
;;;2448       rmp_cnt_t SLI_Level;
;;;2449       volatile struct RMP_Mem* Mem;
;;;2450       rmp_ptr_t Old_Size;
;;;2451       volatile struct RMP_Mem_Head* Mem_Head;
;;;2452       rmp_ptr_t Rounded_Size;
;;;2453       volatile struct RMP_Mem_Head* New_Mem;
;;;2454       rmp_ptr_t New_Size;
;;;2455       
;;;2456       if((Pool==0)||(Size==0))
000002  d001              BEQ      |L11.8|
000004  2900              CMP      r1,#0
000006  d101              BNE      |L11.12|
                  |L11.8|
;;;2457       {
;;;2458           RMP_COVERAGE_MARKER();
;;;2459           return (void*)(0);
000008  2000              MOVS     r0,#0
;;;2460       }
;;;2461       else
;;;2462           RMP_COVERAGE_MARKER();
;;;2463       
;;;2464       /* Round up the size:a multiple of 8 and bigger than 64B */
;;;2465       Rounded_Size=RMP_ROUND_UP(Size,3);
;;;2466       /* See if it is smaller than the smallest block */
;;;2467       Rounded_Size=(Rounded_Size>64)?Rounded_Size:64;
;;;2468   
;;;2469       /* See if such block exists, if not, abort */
;;;2470       if(_RMP_Mem_Search(Pool,Rounded_Size,&FLI_Level,&SLI_Level)!=0)
;;;2471       {
;;;2472           RMP_COVERAGE_MARKER();
;;;2473           return (void*)(0);
;;;2474       }
;;;2475       else
;;;2476           RMP_COVERAGE_MARKER();
;;;2477       
;;;2478       Mem=(volatile struct RMP_Mem*)Pool;
;;;2479       
;;;2480       /* There is such block. Get it and delete it from the TLSF list. */
;;;2481       Mem_Head=(struct RMP_Mem_Head*)(Mem->Table[RMP_MEM_POS(FLI_Level,SLI_Level)].Next);
;;;2482       _RMP_Mem_Del(Pool, Mem_Head);
;;;2483   
;;;2484       /* Allocate and calculate if the space left could be big enough to be a new 
;;;2485        * block. If so, we will put the block back into the TLSF table */
;;;2486       New_Size=((rmp_ptr_t)(Mem_Head->Tail))-((rmp_ptr_t)Mem_Head)-sizeof(struct RMP_Mem_Head)-Rounded_Size;
;;;2487       if(New_Size>=(sizeof(struct RMP_Mem_Head)+64+sizeof(struct RMP_Mem_Tail)))
;;;2488       {
;;;2489           RMP_COVERAGE_MARKER();
;;;2490           Old_Size=sizeof(struct RMP_Mem_Head)+Rounded_Size+sizeof(struct RMP_Mem_Tail);
;;;2491           New_Mem=(volatile struct RMP_Mem_Head*)(((rmp_ptr_t)Mem_Head)+Old_Size);
;;;2492   
;;;2493           _RMP_Mem_Block(Mem_Head, Old_Size);
;;;2494           _RMP_Mem_Block(New_Mem, New_Size);
;;;2495   
;;;2496           /* Put the extra block back */
;;;2497           _RMP_Mem_Ins(Pool, New_Mem);
;;;2498       }
;;;2499       else
;;;2500           RMP_COVERAGE_MARKER();
;;;2501   
;;;2502       /* Mark the block as in use */
;;;2503       Mem_Head->State=RMP_MEM_USED;
;;;2504   
;;;2505       /* Finally, return the start address */
;;;2506       return (void*)(((rmp_ptr_t)Mem_Head)+sizeof(struct RMP_Mem_Head));
;;;2507   }
00000a  4770              BX       lr
                  |L11.12|
00000c  b5f0              PUSH     {r4-r7,lr}            ;2446
00000e  1dc9              ADDS     r1,r1,#7              ;2446
000010  08cc              LSRS     r4,r1,#3              ;2465
000012  00e4              LSLS     r4,r4,#3              ;2465
000014  b083              SUB      sp,sp,#0xc            ;2446
000016  4606              MOV      r6,r0                 ;2446
000018  2c40              CMP      r4,#0x40              ;2467
00001a  d800              BHI      |L11.30|
00001c  2440              MOVS     r4,#0x40              ;2467
                  |L11.30|
00001e  4605              MOV      r5,r0                 ;2470
000020  4620              MOV      r0,r4                 ;2470
000022  f7fffffe          BL       RMP_MSB_Get
000026  1ec2              SUBS     r2,r0,#3              ;2470
000028  4621              MOV      r1,r4                 ;2470
00002a  40d1              LSRS     r1,r1,r2              ;2470
00002c  0749              LSLS     r1,r1,#29             ;2470
00002e  0f49              LSRS     r1,r1,#29             ;2470
000030  460b              MOV      r3,r1                 ;2470
000032  3308              ADDS     r3,r3,#8              ;2470
000034  4093              LSLS     r3,r3,r2              ;2470
000036  1f80              SUBS     r0,r0,#6              ;2470
000038  42a3              CMP      r3,r4                 ;2470
00003a  d004              BEQ      |L11.70|
00003c  1c49              ADDS     r1,r1,#1              ;2470
00003e  2908              CMP      r1,#8                 ;2470
000040  d101              BNE      |L11.70|
000042  2100              MOVS     r1,#0                 ;2470
000044  1c40              ADDS     r0,r0,#1              ;2470
                  |L11.70|
000046  682a              LDR      r2,[r5,#0]            ;2470
000048  4282              CMP      r2,r0                 ;2470
00004a  d97d              BLS      |L11.328|
00004c  00c0              LSLS     r0,r0,#3              ;2470
00004e  1847              ADDS     r7,r0,r1              ;2470
000050  1178              ASRS     r0,r7,#5              ;2470
000052  9001              STR      r0,[sp,#4]            ;2470
000054  0080              LSLS     r0,r0,#2              ;2470
000056  1940              ADDS     r0,r0,r5              ;2470
000058  6900              LDR      r0,[r0,#0x10]         ;2470
00005a  06f9              LSLS     r1,r7,#27             ;2470
00005c  0ec9              LSRS     r1,r1,#27             ;2470
00005e  40c8              LSRS     r0,r0,r1              ;2470
000060  4a49              LDR      r2,|L11.392|
000062  9100              STR      r1,[sp,#0]            ;2470
000064  0e03              LSRS     r3,r0,#24             ;2470
000066  5cd2              LDRB     r2,[r2,r3]            ;2470
000068  0a09              LSRS     r1,r1,#8              ;2470
00006a  0209              LSLS     r1,r1,#8              ;2470
00006c  4311              ORRS     r1,r1,r2              ;2470
00006e  0202              LSLS     r2,r0,#8              ;2470
000070  0e13              LSRS     r3,r2,#24             ;2470
000072  4a45              LDR      r2,|L11.392|
000074  5cd2              LDRB     r2,[r2,r3]            ;2470
000076  23ff              MOVS     r3,#0xff              ;2470
000078  021b              LSLS     r3,r3,#8              ;2470
00007a  0212              LSLS     r2,r2,#8              ;2470
00007c  4399              BICS     r1,r1,r3              ;2470
00007e  401a              ANDS     r2,r2,r3              ;2470
000080  4311              ORRS     r1,r1,r2              ;2470
000082  0402              LSLS     r2,r0,#16             ;2470
000084  0e13              LSRS     r3,r2,#24             ;2470
000086  4a40              LDR      r2,|L11.392|
000088  5cd2              LDRB     r2,[r2,r3]            ;2470
00008a  23ff              MOVS     r3,#0xff              ;2470
00008c  041b              LSLS     r3,r3,#16             ;2470
00008e  0412              LSLS     r2,r2,#16             ;2470
000090  4399              BICS     r1,r1,r3              ;2470
000092  401a              ANDS     r2,r2,r3              ;2470
000094  4311              ORRS     r1,r1,r2              ;2470
000096  b2c2              UXTB     r2,r0                 ;2470
000098  483b              LDR      r0,|L11.392|
00009a  5c82              LDRB     r2,[r0,r2]            ;2470
00009c  0208              LSLS     r0,r1,#8              ;2470
00009e  0a00              LSRS     r0,r0,#8              ;2470
0000a0  0611              LSLS     r1,r2,#24             ;2470
0000a2  4308              ORRS     r0,r0,r1              ;2470
0000a4  f7fffffe          BL       RMP_MSB_Get
0000a8  211f              MOVS     r1,#0x1f              ;2470
0000aa  1a08              SUBS     r0,r1,r0              ;2470
0000ac  2820              CMP      r0,#0x20              ;2470
0000ae  d206              BCS      |L11.190|
0000b0  0979              LSRS     r1,r7,#5              ;2470
0000b2  0149              LSLS     r1,r1,#5              ;2470
0000b4  1809              ADDS     r1,r1,r0              ;2470
0000b6  9800              LDR      r0,[sp,#0]            ;2470
0000b8  1808              ADDS     r0,r1,r0              ;2470
0000ba  10c1              ASRS     r1,r0,#3              ;2470
0000bc  e032              B        |L11.292|
                  |L11.190|
0000be  6828              LDR      r0,[r5,#0]            ;2470
0000c0  9f01              LDR      r7,[sp,#4]            ;2470
0000c2  1cc0              ADDS     r0,r0,#3              ;2470
0000c4  0880              LSRS     r0,r0,#2              ;2470
0000c6  1c7f              ADDS     r7,r7,#1              ;2470
0000c8  4287              CMP      r7,r0                 ;2470
0000ca  da59              BGE      |L11.384|
                  |L11.204|
0000cc  00b9              LSLS     r1,r7,#2              ;2470
0000ce  1949              ADDS     r1,r1,r5              ;2470
0000d0  6909              LDR      r1,[r1,#0x10]         ;2470
0000d2  2900              CMP      r1,#0                 ;2470
0000d4  d051              BEQ      |L11.378|
0000d6  00b8              LSLS     r0,r7,#2              ;2470
0000d8  1940              ADDS     r0,r0,r5              ;2470
0000da  6901              LDR      r1,[r0,#0x10]         ;2470
0000dc  4a2a              LDR      r2,|L11.392|
0000de  0e0b              LSRS     r3,r1,#24             ;2470
0000e0  5cd3              LDRB     r3,[r2,r3]            ;2470
0000e2  0a00              LSRS     r0,r0,#8              ;2470
0000e4  0200              LSLS     r0,r0,#8              ;2470
0000e6  4318              ORRS     r0,r0,r3              ;2470
0000e8  020b              LSLS     r3,r1,#8              ;2470
0000ea  0e1b              LSRS     r3,r3,#24             ;2470
0000ec  5cd3              LDRB     r3,[r2,r3]            ;2470
0000ee  25ff              MOVS     r5,#0xff              ;2470
0000f0  022d              LSLS     r5,r5,#8              ;2470
0000f2  021b              LSLS     r3,r3,#8              ;2470
0000f4  43a8              BICS     r0,r0,r5              ;2470
0000f6  402b              ANDS     r3,r3,r5              ;2470
0000f8  4318              ORRS     r0,r0,r3              ;2470
0000fa  040b              LSLS     r3,r1,#16             ;2470
0000fc  0e1b              LSRS     r3,r3,#24             ;2470
0000fe  5cd3              LDRB     r3,[r2,r3]            ;2470
000100  022d              LSLS     r5,r5,#8              ;2470
000102  041b              LSLS     r3,r3,#16             ;2470
000104  43a8              BICS     r0,r0,r5              ;2470
000106  402b              ANDS     r3,r3,r5              ;2470
000108  b2c9              UXTB     r1,r1                 ;2470
00010a  4318              ORRS     r0,r0,r3              ;2470
00010c  5c51              LDRB     r1,[r2,r1]            ;2470
00010e  0200              LSLS     r0,r0,#8              ;2470
000110  0a00              LSRS     r0,r0,#8              ;2470
000112  0609              LSLS     r1,r1,#24             ;2470
000114  4308              ORRS     r0,r0,r1              ;2470
000116  f7fffffe          BL       RMP_MSB_Get
00011a  211f              MOVS     r1,#0x1f              ;2470
00011c  1a08              SUBS     r0,r1,r0              ;2470
00011e  0179              LSLS     r1,r7,#5              ;2470
000120  1809              ADDS     r1,r1,r0              ;2470
000122  08c9              LSRS     r1,r1,#3              ;2470
                  |L11.292|
000124  0740              LSLS     r0,r0,#29             ;2470
000126  68f2              LDR      r2,[r6,#0xc]          ;2481
000128  0f40              LSRS     r0,r0,#29             ;2481
00012a  00c9              LSLS     r1,r1,#3              ;2481
00012c  1808              ADDS     r0,r1,r0              ;2481
00012e  00c0              LSLS     r0,r0,#3              ;2481
000130  1d00              ADDS     r0,r0,#4              ;2481
000132  5815              LDR      r5,[r2,r0]            ;2481
000134  4630              MOV      r0,r6                 ;2482
000136  4629              MOV      r1,r5                 ;2482
000138  f7fffffe          BL       _RMP_Mem_Del
00013c  68e8              LDR      r0,[r5,#0xc]          ;2486
00013e  1b40              SUBS     r0,r0,r5              ;2486
000140  1b00              SUBS     r0,r0,r4              ;2486
000142  3810              SUBS     r0,r0,#0x10           ;2486
000144  2854              CMP      r0,#0x54              ;2487
000146  e000              B        |L11.330|
                  |L11.328|
000148  e01a              B        |L11.384|
                  |L11.330|
00014a  d310              BCC      |L11.366|
00014c  3414              ADDS     r4,r4,#0x14           ;2487
00014e  1929              ADDS     r1,r5,r4              ;2491
000150  2200              MOVS     r2,#0                 ;2491
000152  60aa              STR      r2,[r5,#8]            ;2491
000154  1f0b              SUBS     r3,r1,#4              ;2491
000156  60eb              STR      r3,[r5,#0xc]          ;2491
000158  68eb              LDR      r3,[r5,#0xc]          ;2491
00015a  601d              STR      r5,[r3,#0]            ;2491
00015c  608a              STR      r2,[r1,#8]            ;2491
00015e  1808              ADDS     r0,r1,r0              ;2491
000160  1f00              SUBS     r0,r0,#4              ;2491
000162  60c8              STR      r0,[r1,#0xc]          ;2491
000164  68c8              LDR      r0,[r1,#0xc]          ;2491
000166  6001              STR      r1,[r0,#0]            ;2491
000168  4630              MOV      r0,r6                 ;2497
00016a  f7fffffe          BL       _RMP_Mem_Ins
                  |L11.366|
00016e  2001              MOVS     r0,#1                 ;2503
000170  60a8              STR      r0,[r5,#8]            ;2503
000172  4628              MOV      r0,r5                 ;2506
000174  3010              ADDS     r0,r0,#0x10           ;2506
000176  b003              ADD      sp,sp,#0xc
000178  bdf0              POP      {r4-r7,pc}
                  |L11.378|
00017a  1c7f              ADDS     r7,r7,#1
00017c  4287              CMP      r7,r0
00017e  dba5              BLT      |L11.204|
                  |L11.384|
000180  2000              MOVS     r0,#0                 ;2473
000182  b003              ADD      sp,sp,#0xc
000184  bdf0              POP      {r4-r7,pc}
;;;2508   /* End Function:RMP_Malloc ***************************************************/
                          ENDP

000186  0000              DCW      0x0000
                  |L11.392|
                          DCD      ||.constdata||

                          AREA ||i.RMP_Mem_Init||, CODE, READONLY, ALIGN=2

                  RMP_Mem_Init PROC
;;;2160   ******************************************************************************/
;;;2161   rmp_ret_t RMP_Mem_Init(volatile void* Pool, rmp_ptr_t Size)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2162   {
000002  0007              MOVS     r7,r0
;;;2163       rmp_cnt_t FLI_Cnt;
;;;2164       rmp_ptr_t Offset;
;;;2165       rmp_ptr_t Bitmap_Size;
;;;2166       volatile struct RMP_Mem* Mem;
;;;2167       
;;;2168       /* See if the memory pool is large enough to enable dynamic allocation - at
;;;2169        * least 1024 machine words or pool initialization will be refused */
;;;2170       if((Pool==0)||(Size<(1024*sizeof(rmp_ptr_t)))||((((rmp_ptr_t)Pool)+Size)<Size))
;;;2171       {
;;;2172           RMP_COVERAGE_MARKER();
;;;2173           return RMP_ERR_MEM;
000004  4839              LDR      r0,|L12.236|
000006  460d              MOV      r5,r1                 ;2162
000008  d06f              BEQ      |L12.234|
00000a  2101              MOVS     r1,#1                 ;2170
00000c  0309              LSLS     r1,r1,#12             ;2170
00000e  428d              CMP      r5,r1                 ;2170
000010  d36b              BCC      |L12.234|
000012  1979              ADDS     r1,r7,r5              ;2170
000014  42a9              CMP      r1,r5                 ;2170
000016  d368              BCC      |L12.234|
000018  4639              MOV      r1,r7                 ;2170
;;;2174       }
;;;2175       else
;;;2176           RMP_COVERAGE_MARKER();
;;;2177       
;;;2178       /* See if the address and size is word-aligned */
;;;2179       if(((((rmp_ptr_t)Pool)&RMP_ALIGN_MASK)!=0)||((Size&RMP_ALIGN_MASK)!=0))
00001a  4329              ORRS     r1,r1,r5
00001c  0789              LSLS     r1,r1,#30
00001e  d164              BNE      |L12.234|
;;;2180       {
;;;2181           RMP_COVERAGE_MARKER();
;;;2182           return RMP_ERR_MEM;
;;;2183       }
;;;2184       else
;;;2185           RMP_COVERAGE_MARKER();
;;;2186   
;;;2187       Mem=(volatile struct RMP_Mem*)Pool;
000020  463c              MOV      r4,r7
;;;2188       Mem->Size=Size;
000022  60bd              STR      r5,[r7,#8]
000024  4628              MOV      r0,r5
000026  3814              SUBS     r0,r0,#0x14
;;;2189       /* Calculate the FLI value needed for this - we always align to 64 byte */
;;;2190       Mem->FLI_Num=RMP_MSB_Get(Size-sizeof(struct RMP_Mem))-6+1;
000028  f7fffffe          BL       RMP_MSB_Get
00002c  1f40              SUBS     r0,r0,#5
00002e  6020              STR      r0,[r4,#0]
;;;2191       
;;;2192       /* Decide the location of the bitmap */
;;;2193       Offset=sizeof(struct RMP_Mem);
;;;2194       Bitmap_Size=RMP_ROUND_UP(Mem->FLI_Num,RMP_ALIGN_ORDER);
000030  6820              LDR      r0,[r4,#0]
000032  1cc0              ADDS     r0,r0,#3
000034  0881              LSRS     r1,r0,#2
000036  0089              LSLS     r1,r1,#2
;;;2195       /* Initialize the bitmap */
;;;2196       for(FLI_Cnt=0;FLI_Cnt<(rmp_cnt_t)(Bitmap_Size>>RMP_ALIGN_ORDER);FLI_Cnt++)
;;;2197           Mem->Bitmap[FLI_Cnt]=0;
000038  0888              LSRS     r0,r1,#2
00003a  d004              BEQ      |L12.70|
00003c  0748              LSLS     r0,r1,#29
00003e  0fc0              LSRS     r0,r0,#31
000040  d001              BEQ      |L12.70|
000042  2200              MOVS     r2,#0
000044  6122              STR      r2,[r4,#0x10]
                  |L12.70|
000046  088e              LSRS     r6,r1,#2              ;2196
000048  4286              CMP      r6,r0                 ;2196
00004a  dd07              BLE      |L12.92|
00004c  2200              MOVS     r2,#0                 ;2196
                  |L12.78|
00004e  0083              LSLS     r3,r0,#2              ;2196
000050  191b              ADDS     r3,r3,r4
000052  611a              STR      r2,[r3,#0x10]
000054  615a              STR      r2,[r3,#0x14]
000056  1c80              ADDS     r0,r0,#2
000058  4286              CMP      r6,r0
00005a  dcf8              BGT      |L12.78|
                  |L12.92|
00005c  3110              ADDS     r1,r1,#0x10
;;;2198       
;;;2199       /* Decide the location of the allocation table - "-sizeof(rmp_ptr_t)" is
;;;2200        * because we defined the length=1 in our struct already */
;;;2201       Offset+=Bitmap_Size-sizeof(rmp_ptr_t);
;;;2202       Mem->Table=(struct RMP_List*)(((rmp_ptr_t)Mem)+Offset);
00005e  1860              ADDS     r0,r4,r1
000060  60e0              STR      r0,[r4,#0xc]
;;;2203       /* Initialize the allocation table */
;;;2204       for(FLI_Cnt=0;FLI_Cnt<(rmp_cnt_t)(Mem->FLI_Num);FLI_Cnt++)
000062  6820              LDR      r0,[r4,#0]
000064  2200              MOVS     r2,#0
000066  4290              CMP      r0,r2
000068  dd2c              BLE      |L12.196|
                  |L12.106|
;;;2205       {
;;;2206           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,0)]));
00006a  68e3              LDR      r3,[r4,#0xc]
00006c  0190              LSLS     r0,r2,#6
00006e  181b              ADDS     r3,r3,r0
000070  601b              STR      r3,[r3,#0]
000072  605b              STR      r3,[r3,#4]
;;;2207           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,1)]));
000074  68e3              LDR      r3,[r4,#0xc]
000076  4606              MOV      r6,r0
000078  3608              ADDS     r6,r6,#8
00007a  199b              ADDS     r3,r3,r6
00007c  601b              STR      r3,[r3,#0]
00007e  605b              STR      r3,[r3,#4]
;;;2208           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,2)]));
000080  68e3              LDR      r3,[r4,#0xc]
000082  3608              ADDS     r6,r6,#8
000084  199b              ADDS     r3,r3,r6
000086  601b              STR      r3,[r3,#0]
000088  605b              STR      r3,[r3,#4]
;;;2209           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,3)]));
00008a  68e3              LDR      r3,[r4,#0xc]
00008c  3608              ADDS     r6,r6,#8
00008e  199b              ADDS     r3,r3,r6
000090  601b              STR      r3,[r3,#0]
000092  605b              STR      r3,[r3,#4]
;;;2210           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,4)]));
000094  68e3              LDR      r3,[r4,#0xc]
000096  3608              ADDS     r6,r6,#8
000098  199b              ADDS     r3,r3,r6
00009a  601b              STR      r3,[r3,#0]
00009c  605b              STR      r3,[r3,#4]
;;;2211           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,5)]));
00009e  68e3              LDR      r3,[r4,#0xc]
0000a0  3608              ADDS     r6,r6,#8
0000a2  199b              ADDS     r3,r3,r6
0000a4  601b              STR      r3,[r3,#0]
0000a6  605b              STR      r3,[r3,#4]
;;;2212           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,6)]));
0000a8  68e3              LDR      r3,[r4,#0xc]
0000aa  3608              ADDS     r6,r6,#8
0000ac  199b              ADDS     r3,r3,r6
0000ae  601b              STR      r3,[r3,#0]
0000b0  605b              STR      r3,[r3,#4]
;;;2213           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,7)]));
0000b2  68e3              LDR      r3,[r4,#0xc]
0000b4  3038              ADDS     r0,r0,#0x38
0000b6  1818              ADDS     r0,r3,r0
0000b8  6000              STR      r0,[r0,#0]
0000ba  6040              STR      r0,[r0,#4]
0000bc  6820              LDR      r0,[r4,#0]
0000be  1c52              ADDS     r2,r2,#1
0000c0  4290              CMP      r0,r2
0000c2  dcd2              BGT      |L12.106|
                  |L12.196|
;;;2214       }
;;;2215       
;;;2216       /* Calculate the offset of the actual allocatable memory - each FLI have
;;;2217        * 8 SLIs, and each SLI has a corresponding table header */
;;;2218       Offset+=sizeof(struct RMP_List)*8*Mem->FLI_Num;
0000c4  6820              LDR      r0,[r4,#0]
0000c6  0180              LSLS     r0,r0,#6
0000c8  1841              ADDS     r1,r0,r1
;;;2219       Mem->Start=((rmp_ptr_t)Mem)+Offset;
0000ca  1860              ADDS     r0,r4,r1
0000cc  6060              STR      r0,[r4,#4]
;;;2220       
;;;2221       /* Initialize the first big block */
;;;2222       _RMP_Mem_Block((struct RMP_Mem_Head*)(Mem->Start),Size-Offset);
0000ce  6860              LDR      r0,[r4,#4]
0000d0  1a69              SUBS     r1,r5,r1
0000d2  2200              MOVS     r2,#0
0000d4  6082              STR      r2,[r0,#8]
0000d6  1841              ADDS     r1,r0,r1
0000d8  1f09              SUBS     r1,r1,#4
0000da  60c1              STR      r1,[r0,#0xc]
0000dc  68c1              LDR      r1,[r0,#0xc]
0000de  6008              STR      r0,[r1,#0]
;;;2223       /* Insert the memory into the corresponding level */
;;;2224       _RMP_Mem_Ins(Pool,(struct RMP_Mem_Head*)(Mem->Start));
0000e0  6861              LDR      r1,[r4,#4]
0000e2  4638              MOV      r0,r7
0000e4  f7fffffe          BL       _RMP_Mem_Ins
;;;2225       
;;;2226       return 0;
0000e8  2000              MOVS     r0,#0
                  |L12.234|
;;;2227   }
0000ea  bdf8              POP      {r3-r7,pc}
;;;2228   /* End Function:RMP_Mem_Init *************************************************/
                          ENDP

                  |L12.236|
                          DCD      0xfffffff9

                          AREA ||i.RMP_Print_Int||, CODE, READONLY, ALIGN=1

                  RMP_Print_Int PROC
;;;84     ******************************************************************************/
;;;85     rmp_cnt_t RMP_Print_Int(rmp_cnt_t Int)
000000  b5f8              PUSH     {r3-r7,lr}
;;;86     {
000002  0006              MOVS     r6,r0
000004  d02b              BEQ      |L13.94|
;;;87         rmp_ptr_t Iter;
;;;88         rmp_cnt_t Count;
;;;89         rmp_cnt_t Num;
;;;90         rmp_ptr_t Div;
;;;91         
;;;92         /* how many digits are there? */
;;;93         if(Int==0)
;;;94         {
;;;95             RMP_Putchar('0');
;;;96             return 1;
;;;97         }
;;;98         else if(Int<0)
000006  2e00              CMP      r6,#0
000008  da2e              BGE      |L13.104|
;;;99         {
;;;100            /* How many digits are there? */
;;;101            Count=0;
00000a  2400              MOVS     r4,#0
;;;102            Div=1;
00000c  2501              MOVS     r5,#1
;;;103            Iter=(rmp_ptr_t)(-Int);
00000e  4240              RSBS     r0,r0,#0
000010  4606              MOV      r6,r0
;;;104            while(Iter!=0)
000012  d007              BEQ      |L13.36|
                  |L13.20|
;;;105            {
;;;106                Iter/=10;
000014  210a              MOVS     r1,#0xa
000016  f7fffffe          BL       __aeabi_uidivmod
;;;107                Count++;
;;;108                Div*=10;
00001a  210a              MOVS     r1,#0xa
00001c  434d              MULS     r5,r1,r5
00001e  1c64              ADDS     r4,r4,#1
000020  2800              CMP      r0,#0                 ;104
000022  d1f7              BNE      |L13.20|
                  |L13.36|
;;;109            }
;;;110            Div/=10;
000024  210a              MOVS     r1,#0xa
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       __aeabi_uidivmod
00002c  4605              MOV      r5,r0
;;;111            
;;;112            RMP_Putchar('-');
00002e  202d              MOVS     r0,#0x2d
000030  f7fffffe          BL       RMP_Putchar
;;;113            Iter=-Int;
;;;114            Num=Count+1;
000034  1c67              ADDS     r7,r4,#1
;;;115            
;;;116            while(Count>0)
000036  2c00              CMP      r4,#0
000038  dd37              BLE      |L13.170|
                  |L13.58|
;;;117            {
;;;118                Count--;
;;;119                RMP_Putchar(Iter/Div+'0');
00003a  4629              MOV      r1,r5
00003c  4630              MOV      r0,r6
00003e  1e64              SUBS     r4,r4,#1
000040  f7fffffe          BL       __aeabi_uidivmod
000044  3030              ADDS     r0,r0,#0x30
000046  460e              MOV      r6,r1
000048  b240              SXTB     r0,r0
00004a  f7fffffe          BL       RMP_Putchar
;;;120                Iter=Iter%Div;
;;;121                Div/=10;
00004e  210a              MOVS     r1,#0xa
000050  4628              MOV      r0,r5
000052  f7fffffe          BL       __aeabi_uidivmod
000056  4605              MOV      r5,r0
000058  2c00              CMP      r4,#0                 ;116
00005a  dcee              BGT      |L13.58|
00005c  e025              B        |L13.170|
                  |L13.94|
00005e  2030              MOVS     r0,#0x30              ;95
000060  f7fffffe          BL       RMP_Putchar
000064  2001              MOVS     r0,#1                 ;96
;;;122            }
;;;123        }
;;;124        else
;;;125        {
;;;126            /* How many digits are there? */
;;;127            Count=0;
;;;128            Div=1;
;;;129            Iter=Int;
;;;130            while(Iter!=0)
;;;131            {
;;;132                Iter/=10;
;;;133                Count++;
;;;134                Div*=10;
;;;135            }
;;;136            Div/=10;
;;;137            
;;;138            Iter=Int;
;;;139            Num=Count;
;;;140            
;;;141            while(Count>0)
;;;142            {
;;;143                Count--;
;;;144                RMP_Putchar(Iter/Div+'0');
;;;145                Iter=Iter%Div;
;;;146                Div/=10;
;;;147            }
;;;148        }
;;;149        
;;;150        return Num;
;;;151    }
000066  bdf8              POP      {r3-r7,pc}
                  |L13.104|
000068  2500              MOVS     r5,#0                 ;127
00006a  2401              MOVS     r4,#1                 ;128
                  |L13.108|
00006c  210a              MOVS     r1,#0xa               ;132
00006e  f7fffffe          BL       __aeabi_uidivmod
000072  210a              MOVS     r1,#0xa               ;134
000074  434c              MULS     r4,r1,r4              ;134
000076  1c6d              ADDS     r5,r5,#1              ;134
000078  2800              CMP      r0,#0                 ;130
00007a  d1f7              BNE      |L13.108|
00007c  4620              MOV      r0,r4                 ;136
00007e  f7fffffe          BL       __aeabi_uidivmod
000082  4604              MOV      r4,r0                 ;136
000084  1e2f              SUBS     r7,r5,#0              ;139
000086  dd10              BLE      |L13.170|
                  |L13.136|
000088  4601              MOV      r1,r0                 ;144
00008a  4630              MOV      r0,r6                 ;144
00008c  1e6d              SUBS     r5,r5,#1              ;144
00008e  f7fffffe          BL       __aeabi_uidivmod
000092  3030              ADDS     r0,r0,#0x30           ;144
000094  460e              MOV      r6,r1                 ;144
000096  b240              SXTB     r0,r0                 ;144
000098  f7fffffe          BL       RMP_Putchar
00009c  210a              MOVS     r1,#0xa               ;146
00009e  4620              MOV      r0,r4                 ;146
0000a0  f7fffffe          BL       __aeabi_uidivmod
0000a4  4604              MOV      r4,r0                 ;146
0000a6  2d00              CMP      r5,#0                 ;141
0000a8  dcee              BGT      |L13.136|
                  |L13.170|
0000aa  4638              MOV      r0,r7                 ;150
0000ac  bdf8              POP      {r3-r7,pc}
;;;152    /* End Function:RMP_Print_Int ************************************************/
                          ENDP


                          AREA ||i.RMP_Print_String||, CODE, READONLY, ALIGN=1

                  RMP_Print_String PROC
;;;207    ******************************************************************************/
;;;208    rmp_cnt_t RMP_Print_String(rmp_s8_t* String)
000000  b570              PUSH     {r4-r6,lr}
;;;209    {
000002  4605              MOV      r5,r0
;;;210        rmp_cnt_t Count;
;;;211        
;;;212        Count=0;
000004  2400              MOVS     r4,#0
                  |L14.6|
;;;213        while(Count<RMP_KERNEL_DEBUG_MAX_STR)
;;;214        {
;;;215            if(String[Count]=='\0')
000006  5728              LDRSB    r0,[r5,r4]
000008  2800              CMP      r0,#0
00000a  d004              BEQ      |L14.22|
00000c  1c64              ADDS     r4,r4,#1
;;;216                break;
;;;217            
;;;218            RMP_Putchar(String[Count++]);
00000e  f7fffffe          BL       RMP_Putchar
000012  2cff              CMP      r4,#0xff              ;213
000014  dbf7              BLT      |L14.6|
                  |L14.22|
;;;219        }
;;;220        
;;;221        return Count;
000016  4620              MOV      r0,r4
;;;222    }
000018  bd70              POP      {r4-r6,pc}
;;;223    /* End Function:RMP_Print_String *********************************************/
                          ENDP


                          AREA ||i.RMP_Print_Uint||, CODE, READONLY, ALIGN=1

                  RMP_Print_Uint PROC
;;;160    ******************************************************************************/
;;;161    rmp_cnt_t RMP_Print_Uint(rmp_ptr_t Uint)
000000  b570              PUSH     {r4-r6,lr}
;;;162    {
000002  0004              MOVS     r4,r0
000004  d003              BEQ      |L15.14|
;;;163        rmp_ptr_t Iter;
;;;164        rmp_cnt_t Count;
;;;165        rmp_cnt_t Num;
;;;166        
;;;167        /* how many digits are there? */
;;;168        if(Uint==0)
;;;169        {
;;;170            RMP_Putchar('0');
;;;171            return 1;
;;;172        }
;;;173        else
;;;174        {
;;;175            /* Filter out all the zeroes */
;;;176            Count=0;
000006  2100              MOVS     r1,#0
;;;177            Iter=Uint;
;;;178            while((Iter>>((sizeof(rmp_ptr_t)*8)-4))==0)
000008  0f02              LSRS     r2,r0,#28
00000a  d005              BEQ      |L15.24|
00000c  e008              B        |L15.32|
                  |L15.14|
00000e  2030              MOVS     r0,#0x30              ;170
000010  f7fffffe          BL       RMP_Putchar
000014  2001              MOVS     r0,#1                 ;171
;;;179            {
;;;180                Iter<<=4;
;;;181                Count++;
;;;182            }
;;;183            /* Count is the number of pts to print */
;;;184            Count=sizeof(rmp_ptr_t)*2-Count;
;;;185            Num=Count;
;;;186            while(Count>0)
;;;187            {
;;;188                Count--;
;;;189                Iter=(Uint>>(Count*4))&0x0F;
;;;190                if(Iter<10)
;;;191                    RMP_Putchar('0'+Iter);
;;;192                else
;;;193                    RMP_Putchar('A'+Iter-10);
;;;194            }
;;;195        }
;;;196        
;;;197        return Num;
;;;198    }
000016  bd70              POP      {r4-r6,pc}
                  |L15.24|
000018  0100              LSLS     r0,r0,#4              ;180
00001a  1c49              ADDS     r1,r1,#1              ;180
00001c  0f02              LSRS     r2,r0,#28             ;178
00001e  d0fb              BEQ      |L15.24|
                  |L15.32|
000020  2008              MOVS     r0,#8                 ;184
000022  1a45              SUBS     r5,r0,r1              ;184
000024  1e2e              SUBS     r6,r5,#0              ;185
000026  dd10              BLE      |L15.74|
                  |L15.40|
000028  4628              MOV      r0,r5                 ;188
00002a  1e6d              SUBS     r5,r5,#1              ;188
00002c  0080              LSLS     r0,r0,#2
00002e  4621              MOV      r1,r4
000030  1f00              SUBS     r0,r0,#4
000032  40c1              LSRS     r1,r1,r0              ;189
000034  0708              LSLS     r0,r1,#28             ;189
000036  0f00              LSRS     r0,r0,#28             ;189
000038  280a              CMP      r0,#0xa               ;190
00003a  d201              BCS      |L15.64|
00003c  3030              ADDS     r0,r0,#0x30           ;190
00003e  e000              B        |L15.66|
                  |L15.64|
000040  3037              ADDS     r0,r0,#0x37           ;191
                  |L15.66|
000042  f7fffffe          BL       RMP_Putchar
000046  2d00              CMP      r5,#0                 ;186
000048  dcee              BGT      |L15.40|
                  |L15.74|
00004a  4630              MOV      r0,r6                 ;197
00004c  bd70              POP      {r4-r6,pc}
;;;199    /* End Function:RMP_Print_Uint ***********************************************/
                          ENDP


                          AREA ||i.RMP_RBIT_Get||, CODE, READONLY, ALIGN=2

                  RMP_RBIT_Get PROC
;;;2077   
;;;2078   rmp_ptr_t RMP_RBIT_Get(rmp_ptr_t Val)
000000  b410              PUSH     {r4}
;;;2079   {
;;;2080       rmp_ptr_t Ret;
;;;2081       rmp_ptr_t Src;
;;;2082       rmp_u8_t* To;
;;;2083       rmp_u8_t* From;
;;;2084       
;;;2085       Src=Val;
;;;2086       To=(rmp_u8_t*)(&Ret);
;;;2087       From=(rmp_u8_t*)(&Src);
;;;2088       
;;;2089   #if(RMP_WORD_ORDER==4)
;;;2090       To[0]=RMP_RBIT_Table[From[1]];
;;;2091       To[1]=RMP_RBIT_Table[From[0]];
;;;2092   #elif(RMP_WORD_ORDER==5)
;;;2093       To[0]=RMP_RBIT_Table[From[3]];
000002  4a0f              LDR      r2,|L16.64|
000004  0e03              LSRS     r3,r0,#24             ;2079
000006  5cd3              LDRB     r3,[r2,r3]
000008  0a09              LSRS     r1,r1,#8
00000a  0209              LSLS     r1,r1,#8
00000c  4319              ORRS     r1,r1,r3
00000e  0203              LSLS     r3,r0,#8
000010  0e1b              LSRS     r3,r3,#24
;;;2094       To[1]=RMP_RBIT_Table[From[2]];
000012  5cd3              LDRB     r3,[r2,r3]
000014  24ff              MOVS     r4,#0xff
000016  0224              LSLS     r4,r4,#8
000018  021b              LSLS     r3,r3,#8
00001a  43a1              BICS     r1,r1,r4
00001c  4023              ANDS     r3,r3,r4
00001e  4319              ORRS     r1,r1,r3
000020  0403              LSLS     r3,r0,#16
000022  0e1b              LSRS     r3,r3,#24
;;;2095       To[2]=RMP_RBIT_Table[From[1]];
000024  5cd3              LDRB     r3,[r2,r3]
000026  0224              LSLS     r4,r4,#8
000028  041b              LSLS     r3,r3,#16
00002a  43a1              BICS     r1,r1,r4
00002c  4023              ANDS     r3,r3,r4
00002e  b2c0              UXTB     r0,r0
;;;2096       To[3]=RMP_RBIT_Table[From[0]];
000030  5c12              LDRB     r2,[r2,r0]
000032  4319              ORRS     r1,r1,r3              ;2095
000034  0208              LSLS     r0,r1,#8
000036  0a00              LSRS     r0,r0,#8
000038  0611              LSLS     r1,r2,#24
;;;2097   #else
;;;2098       To[0]=RMP_RBIT_Table[From[7]];
;;;2099       To[1]=RMP_RBIT_Table[From[6]];
;;;2100       To[2]=RMP_RBIT_Table[From[5]];
;;;2101       To[3]=RMP_RBIT_Table[From[4]];
;;;2102       To[4]=RMP_RBIT_Table[From[3]];
;;;2103       To[5]=RMP_RBIT_Table[From[2]];
;;;2104       To[6]=RMP_RBIT_Table[From[1]];
;;;2105       To[7]=RMP_RBIT_Table[From[0]];
;;;2106   #endif
;;;2107   
;;;2108       return Ret;
;;;2109   }
00003a  bc10              POP      {r4}
00003c  4308              ORRS     r0,r0,r1              ;2096
00003e  4770              BX       lr
;;;2110   /* End Function:RMP_RBIT_Get *************************************************/
                          ENDP

                  |L16.64|
                          DCD      ||.constdata||

                          AREA ||i.RMP_Realloc||, CODE, READONLY, ALIGN=1

                  RMP_Realloc PROC
;;;2629   ******************************************************************************/
;;;2630   void* RMP_Realloc(volatile void* Pool, void* Mem_Ptr, rmp_ptr_t Size)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;2631   {
000002  b082              SUB      sp,sp,#8
;;;2632       /* The size of the original memory block */
;;;2633       rmp_ptr_t Mem_Size;
;;;2634       /* The rounded size of the new memory request */
;;;2635       rmp_ptr_t Rounded_Size;
;;;2636       rmp_ptr_t Count;
;;;2637       /* The pointer to the pool */
;;;2638       volatile struct RMP_Mem* Mem;
;;;2639       /* The head of the old memory */
;;;2640       volatile struct RMP_Mem_Head* Mem_Head;
;;;2641       /* The right-side block head */
;;;2642       volatile struct RMP_Mem_Head* Right_Head;
;;;2643       /* The pointer to the residue memory head */
;;;2644       volatile struct RMP_Mem_Head* Res_Mem;
;;;2645       /* The new memory block */
;;;2646       void* New_Mem;
;;;2647       /* The size of the memory block including the header sizes */
;;;2648       rmp_ptr_t Old_Size;
;;;2649       /* The size of the residue memory block including the header sizes */
;;;2650       rmp_ptr_t Res_Size;
;;;2651       
;;;2652       /* Check if no pool present */
;;;2653       if(Pool==0)
000004  9802              LDR      r0,[sp,#8]
000006  460d              MOV      r5,r1                 ;2631
000008  2800              CMP      r0,#0
00000a  d02a              BEQ      |L17.98|
;;;2654       {
;;;2655           RMP_COVERAGE_MARKER();
;;;2656           return 0;
;;;2657       }
;;;2658       else
;;;2659           RMP_COVERAGE_MARKER();
;;;2660       
;;;2661       /* Are we passing in a NULL pointer? */
;;;2662       if(Mem_Ptr==0)
00000c  2d00              CMP      r5,#0
00000e  d025              BEQ      |L17.92|
;;;2663       {
;;;2664           RMP_COVERAGE_MARKER();
;;;2665           return RMP_Malloc(Pool,Size);
;;;2666       }
;;;2667       else
;;;2668           RMP_COVERAGE_MARKER();
;;;2669       
;;;2670       /* Is the size passed in zero? If yes, we free directly */
;;;2671       if(Size==0)
000010  2a00              CMP      r2,#0
000012  d028              BEQ      |L17.102|
;;;2672       {
;;;2673           RMP_COVERAGE_MARKER();
;;;2674           RMP_Free(Pool,Mem_Ptr);
;;;2675           return 0;
;;;2676       }
;;;2677       else
;;;2678           RMP_COVERAGE_MARKER();
;;;2679       
;;;2680       /* See if the address is within the allocatable address range. If not, abort directly. */
;;;2681       Mem=(volatile struct RMP_Mem*)Pool;
;;;2682       if((((rmp_ptr_t)Mem_Ptr)<=((rmp_ptr_t)Mem))||(((rmp_ptr_t)Mem_Ptr)>=(((rmp_ptr_t)Mem)+Mem->Size)))
000014  4285              CMP      r5,r0
000016  d96d              BLS      |L17.244|
000018  6881              LDR      r1,[r0,#8]
00001a  1809              ADDS     r1,r1,r0
00001c  42a9              CMP      r1,r5
00001e  d969              BLS      |L17.244|
;;;2683       {
;;;2684           RMP_COVERAGE_MARKER();
;;;2685           return 0;
;;;2686       }
;;;2687       else
;;;2688           RMP_COVERAGE_MARKER();
;;;2689   
;;;2690       /* Yes, get the location of the header of the memory */
;;;2691       Mem_Head=(struct RMP_Mem_Head*)(((rmp_ptr_t)Mem_Ptr)-sizeof(struct RMP_Mem_Head));
000020  462c              MOV      r4,r5
000022  3c10              SUBS     r4,r4,#0x10
;;;2692       /* See if the block can really be realloced */
;;;2693       if(Mem_Head->State==RMP_MEM_FREE)
000024  68a1              LDR      r1,[r4,#8]
000026  2900              CMP      r1,#0
000028  d064              BEQ      |L17.244|
00002a  1dd2              ADDS     r2,r2,#7
;;;2694       {
;;;2695           RMP_COVERAGE_MARKER();
;;;2696           return 0;
;;;2697       }
;;;2698       else
;;;2699           RMP_COVERAGE_MARKER();
;;;2700       
;;;2701       /* Round up the size:a multiple of 8 and bigger than 64B */
;;;2702       Rounded_Size=RMP_ROUND_UP(Size,3);
00002c  08d6              LSRS     r6,r2,#3
00002e  00f6              LSLS     r6,r6,#3
;;;2703       /* See if it is smaller than the smallest block */
;;;2704       Rounded_Size=(Rounded_Size>64)?Rounded_Size:64;
000030  2e40              CMP      r6,#0x40
000032  d800              BHI      |L17.54|
000034  2640              MOVS     r6,#0x40
                  |L17.54|
;;;2705       
;;;2706       Mem_Size=((rmp_ptr_t)Mem_Head->Tail)-((rmp_ptr_t)Mem_Ptr);
000036  68e1              LDR      r1,[r4,#0xc]
000038  1b49              SUBS     r1,r1,r5
;;;2707       /* Does the right-side head exist at all? */
;;;2708       Right_Head=(struct RMP_Mem_Head*)(((rmp_ptr_t)(Mem_Head->Tail))+sizeof(struct RMP_Mem_Tail));
00003a  9100              STR      r1,[sp,#0]
00003c  68e7              LDR      r7,[r4,#0xc]
;;;2709       if(((rmp_ptr_t)Right_Head)==(((rmp_ptr_t)Mem)+Mem->Size))
00003e  6881              LDR      r1,[r0,#8]
000040  1d3f              ADDS     r7,r7,#4
000042  1808              ADDS     r0,r1,r0
000044  42b8              CMP      r0,r7
000046  d100              BNE      |L17.74|
;;;2710       {
;;;2711           RMP_COVERAGE_MARKER();
;;;2712           Right_Head=0;
000048  2700              MOVS     r7,#0
                  |L17.74|
;;;2713       }
;;;2714       else
;;;2715           RMP_COVERAGE_MARKER();
;;;2716       
;;;2717       /* Are we gonna expand it? */
;;;2718       if(Mem_Size<Rounded_Size)
00004a  9800              LDR      r0,[sp,#0]
00004c  42b0              CMP      r0,r6
00004e  d254              BCS      |L17.250|
;;;2719       {
;;;2720           /* Expanding */
;;;2721           RMP_COVERAGE_MARKER();
;;;2722           /* Does the right side exist at all? */
;;;2723           if(Right_Head!=0)
000050  2f00              CMP      r7,#0
000052  d029              BEQ      |L17.168|
;;;2724           {
;;;2725               RMP_COVERAGE_MARKER();
;;;2726               /* Is it allocated? */
;;;2727               if(Right_Head->State==RMP_MEM_FREE)
000054  68b8              LDR      r0,[r7,#8]
000056  2800              CMP      r0,#0
000058  d00a              BEQ      |L17.112|
00005a  e025              B        |L17.168|
                  |L17.92|
00005c  4611              MOV      r1,r2                 ;2665
00005e  f7fffffe          BL       RMP_Malloc
                  |L17.98|
;;;2728               {
;;;2729                   RMP_COVERAGE_MARKER();
;;;2730                   /* Right-side exists and is free. How big is its usable size? Is it sufficient for our realloc? */
;;;2731                   if((((rmp_ptr_t)Right_Head->Tail)-((rmp_ptr_t)Mem_Ptr))>=Rounded_Size)
;;;2732                   {
;;;2733                       RMP_COVERAGE_MARKER();
;;;2734                       /* Remove the right-side from the free list so we can operate on it */
;;;2735                       _RMP_Mem_Del(Pool, Right_Head);   
;;;2736                       /* Allocate and calculate if the space left could be big enough to be a new 
;;;2737                        * block. If so, we will put the block back into the TLSF table */
;;;2738                       Res_Size=((rmp_ptr_t)(Right_Head->Tail))-((rmp_ptr_t)Mem_Ptr)-Rounded_Size;
;;;2739                       /* Is the residue big enough to be a block? */
;;;2740                       if(Res_Size>=(sizeof(struct RMP_Mem_Head)+64+sizeof(struct RMP_Mem_Tail)))
;;;2741                       {
;;;2742                           RMP_COVERAGE_MARKER();
;;;2743                           Old_Size=sizeof(struct RMP_Mem_Head)+Rounded_Size+sizeof(struct RMP_Mem_Tail);
;;;2744                           Res_Mem=(volatile struct RMP_Mem_Head*)(((rmp_ptr_t)Mem_Head)+Old_Size);
;;;2745   
;;;2746                           _RMP_Mem_Block(Mem_Head, Old_Size);
;;;2747                           _RMP_Mem_Block(Res_Mem, Res_Size);
;;;2748   
;;;2749                           /* Put the extra block back */
;;;2750                           _RMP_Mem_Ins(Pool, Res_Mem);
;;;2751                       }
;;;2752                       else
;;;2753                       {
;;;2754                           /* Residue too small. Merging the whole thing in is the only option */
;;;2755                           RMP_COVERAGE_MARKER();
;;;2756                           Old_Size=((rmp_ptr_t)(Right_Head->Tail))-((rmp_ptr_t)Mem_Head)+sizeof(struct RMP_Mem_Tail);
;;;2757                           _RMP_Mem_Block(Mem_Head, Old_Size);
;;;2758                       }
;;;2759                       
;;;2760                       /* Mark the block as in use (making new block clears this flag) */
;;;2761                       Mem_Head->State=RMP_MEM_USED;
;;;2762                       /* Return the old pointer because we expanded it */
;;;2763                       return Mem_Ptr;
;;;2764                   }
;;;2765                   /* Right-side not large enough, have to go malloc then memcpy */
;;;2766                   else
;;;2767                       RMP_COVERAGE_MARKER();
;;;2768               }
;;;2769               /* It is allocated, have to go malloc then memcpy */
;;;2770               else
;;;2771                   RMP_COVERAGE_MARKER();
;;;2772           }
;;;2773           /* Right-side doesn't exist, have to go malloc then memcpy */
;;;2774           else
;;;2775               RMP_COVERAGE_MARKER();
;;;2776           
;;;2777           New_Mem=RMP_Malloc(Pool,Rounded_Size);
;;;2778           /* See if we can allocate this much, if we can't at all, exit */
;;;2779           if(New_Mem==0)
;;;2780           {
;;;2781               RMP_COVERAGE_MARKER();
;;;2782               return 0;
;;;2783           }
;;;2784           else
;;;2785               RMP_COVERAGE_MARKER();
;;;2786           
;;;2787           /* Copy old memory to new memory - we know that this is always aligned, so this is fine */
;;;2788           for(Count=0;Count<(Mem_Size>>RMP_ALIGN_ORDER);Count++)
;;;2789               ((rmp_ptr_t*)New_Mem)[Count]=((rmp_ptr_t*)Mem_Ptr)[Count];
;;;2790           
;;;2791           /* Free old memory then return */
;;;2792           RMP_Free(Pool,Mem_Ptr);
;;;2793           return New_Mem;
;;;2794       }
;;;2795       /* Shrinking or keeping */
;;;2796       else
;;;2797           RMP_COVERAGE_MARKER();
;;;2798       
;;;2799       /* Are we keeping the size? */
;;;2800       if(Mem_Size==Rounded_Size)
;;;2801       {
;;;2802           RMP_COVERAGE_MARKER();
;;;2803           return Mem_Ptr;
;;;2804       }
;;;2805       else
;;;2806           RMP_COVERAGE_MARKER();
;;;2807       
;;;2808       /* Does the right side exist at all? */
;;;2809       if(Right_Head!=0)
;;;2810       {
;;;2811           RMP_COVERAGE_MARKER();
;;;2812           /* Is it allocated? */
;;;2813           if(Right_Head->State==RMP_MEM_FREE)
;;;2814           {
;;;2815               /* Right-side not allocated. Need to merge the block */
;;;2816               RMP_COVERAGE_MARKER();
;;;2817               /* Remove the right-side from the allocation list so we can operate on it */
;;;2818               _RMP_Mem_Del(Pool, Right_Head);
;;;2819               Res_Size=((rmp_ptr_t)(Right_Head->Tail))-((rmp_ptr_t)Mem_Ptr)-Rounded_Size;
;;;2820               Old_Size=sizeof(struct RMP_Mem_Head)+Rounded_Size+sizeof(struct RMP_Mem_Tail);
;;;2821               Res_Mem=(volatile struct RMP_Mem_Head*)(((rmp_ptr_t)Mem_Head)+Old_Size);
;;;2822   
;;;2823               _RMP_Mem_Block(Mem_Head, Old_Size);
;;;2824               _RMP_Mem_Block(Res_Mem, Res_Size);
;;;2825   
;;;2826               /* Put the extra block back */
;;;2827               _RMP_Mem_Ins(Pool, Res_Mem);
;;;2828               
;;;2829               /* Mark the block as in use (making new block clears this flag) */
;;;2830               Mem_Head->State=RMP_MEM_USED;
;;;2831               /* Return the old pointer because we shrinked it */
;;;2832               return Mem_Ptr;
;;;2833           }
;;;2834           /* Allocated. Need to see if the residue block itself is large enough to be inserted back */
;;;2835           else
;;;2836               RMP_COVERAGE_MARKER();
;;;2837       }
;;;2838       else
;;;2839           RMP_COVERAGE_MARKER();
;;;2840       
;;;2841       /* The right-side head either does not exist or is allocated. Calculate the resulting residue size */
;;;2842       Res_Size=Mem_Size-Rounded_Size;
;;;2843       if(Res_Size<(sizeof(struct RMP_Mem_Head)+64+sizeof(struct RMP_Mem_Tail)))
;;;2844       {
;;;2845           RMP_COVERAGE_MARKER();
;;;2846           /* The residue block wouldn't even count as a small one. Do nothing and quit */
;;;2847           return Mem_Ptr;
;;;2848       }
;;;2849       else
;;;2850           RMP_COVERAGE_MARKER();
;;;2851       
;;;2852       /* The residue will be big enough to become a standalone block. We need to place it back */ 
;;;2853       Old_Size=sizeof(struct RMP_Mem_Head)+Rounded_Size+sizeof(struct RMP_Mem_Tail);
;;;2854       Res_Mem=(volatile struct RMP_Mem_Head*)(((rmp_ptr_t)Mem_Head)+Old_Size);
;;;2855   
;;;2856       _RMP_Mem_Block(Mem_Head, Old_Size);
;;;2857       _RMP_Mem_Block(Res_Mem, Res_Size);
;;;2858   
;;;2859       /* Put the extra block back */
;;;2860       _RMP_Mem_Ins(Pool, Res_Mem);
;;;2861               
;;;2862       /* Mark the block as in use (making new block clears this flag) */
;;;2863       Mem_Head->State=RMP_MEM_USED;
;;;2864       /* Return the old pointer because we shrinked it */
;;;2865       return Mem_Ptr;
;;;2866   }
000062  b005              ADD      sp,sp,#0x14
000064  bdf0              POP      {r4-r7,pc}
                  |L17.102|
000066  f7fffffe          BL       RMP_Free
00006a  2000              MOVS     r0,#0                 ;2675
00006c  b005              ADD      sp,sp,#0x14
00006e  bdf0              POP      {r4-r7,pc}
                  |L17.112|
000070  68f8              LDR      r0,[r7,#0xc]          ;2731
000072  1b40              SUBS     r0,r0,r5              ;2731
000074  42b0              CMP      r0,r6                 ;2731
000076  d317              BCC      |L17.168|
000078  4639              MOV      r1,r7                 ;2735
00007a  9802              LDR      r0,[sp,#8]            ;2735
00007c  f7fffffe          BL       _RMP_Mem_Del
000080  68f8              LDR      r0,[r7,#0xc]          ;2738
000082  1b40              SUBS     r0,r0,r5              ;2738
000084  1b80              SUBS     r0,r0,r6              ;2738
000086  2854              CMP      r0,#0x54              ;2740
000088  d24c              BCS      |L17.292|
00008a  68f8              LDR      r0,[r7,#0xc]          ;2756
00008c  1b00              SUBS     r0,r0,r4              ;2756
00008e  2100              MOVS     r1,#0                 ;2756
000090  60a1              STR      r1,[r4,#8]            ;2756
000092  1d00              ADDS     r0,r0,#4              ;2756
000094  1820              ADDS     r0,r4,r0              ;2756
000096  1f00              SUBS     r0,r0,#4              ;2756
000098  60e0              STR      r0,[r4,#0xc]          ;2756
00009a  68e0              LDR      r0,[r4,#0xc]          ;2756
00009c  6004              STR      r4,[r0,#0]            ;2756
                  |L17.158|
00009e  2001              MOVS     r0,#1                 ;2761
0000a0  60a0              STR      r0,[r4,#8]            ;2761
0000a2  4628              MOV      r0,r5                 ;2763
0000a4  b005              ADD      sp,sp,#0x14
0000a6  bdf0              POP      {r4-r7,pc}
                  |L17.168|
0000a8  4631              MOV      r1,r6                 ;2777
0000aa  9802              LDR      r0,[sp,#8]            ;2777
0000ac  f7fffffe          BL       RMP_Malloc
0000b0  0006              MOVS     r6,r0                 ;2777
0000b2  d01f              BEQ      |L17.244|
0000b4  9800              LDR      r0,[sp,#0]            ;2788
0000b6  0880              LSRS     r0,r0,#2              ;2788
0000b8  d015              BEQ      |L17.230|
0000ba  9900              LDR      r1,[sp,#0]
0000bc  1f28              SUBS     r0,r5,#4              ;2788
0000be  1f34              SUBS     r4,r6,#4              ;2788
0000c0  0889              LSRS     r1,r1,#2
0000c2  07c9              LSLS     r1,r1,#31
0000c4  d003              BEQ      |L17.206|
0000c6  6841              LDR      r1,[r0,#4]            ;2789
0000c8  1d00              ADDS     r0,r0,#4              ;2789
0000ca  6061              STR      r1,[r4,#4]            ;2789
0000cc  1d24              ADDS     r4,r4,#4              ;2789
                  |L17.206|
0000ce  9900              LDR      r1,[sp,#0]            ;2788
0000d0  08c9              LSRS     r1,r1,#3              ;2788
0000d2  d008              BEQ      |L17.230|
                  |L17.212|
0000d4  6842              LDR      r2,[r0,#4]            ;2789
0000d6  6062              STR      r2,[r4,#4]            ;2789
0000d8  6882              LDR      r2,[r0,#8]            ;2789
0000da  60a2              STR      r2,[r4,#8]            ;2789
0000dc  3008              ADDS     r0,r0,#8              ;2789
0000de  1e49              SUBS     r1,r1,#1              ;2789
0000e0  3408              ADDS     r4,r4,#8              ;2789
0000e2  2900              CMP      r1,#0                 ;2789
0000e4  d1f6              BNE      |L17.212|
                  |L17.230|
0000e6  4629              MOV      r1,r5                 ;2792
0000e8  9802              LDR      r0,[sp,#8]            ;2792
0000ea  f7fffffe          BL       RMP_Free
0000ee  4630              MOV      r0,r6                 ;2793
0000f0  b005              ADD      sp,sp,#0x14
0000f2  bdf0              POP      {r4-r7,pc}
                  |L17.244|
0000f4  2000              MOVS     r0,#0                 ;2782
0000f6  b005              ADD      sp,sp,#0x14
0000f8  bdf0              POP      {r4-r7,pc}
                  |L17.250|
0000fa  42b0              CMP      r0,r6                 ;2800
0000fc  d008              BEQ      |L17.272|
0000fe  2f00              CMP      r7,#0                 ;2809
000100  d002              BEQ      |L17.264|
000102  68b8              LDR      r0,[r7,#8]            ;2813
000104  2800              CMP      r0,#0                 ;2813
000106  d006              BEQ      |L17.278|
                  |L17.264|
000108  9800              LDR      r0,[sp,#0]            ;2842
00010a  1b80              SUBS     r0,r0,r6              ;2842
00010c  2854              CMP      r0,#0x54              ;2843
00010e  d209              BCS      |L17.292|
                  |L17.272|
000110  4628              MOV      r0,r5                 ;2847
000112  b005              ADD      sp,sp,#0x14
000114  bdf0              POP      {r4-r7,pc}
                  |L17.278|
000116  4639              MOV      r1,r7                 ;2818
000118  9802              LDR      r0,[sp,#8]            ;2818
00011a  f7fffffe          BL       _RMP_Mem_Del
00011e  68f8              LDR      r0,[r7,#0xc]          ;2819
000120  1b40              SUBS     r0,r0,r5              ;2819
000122  1b80              SUBS     r0,r0,r6              ;2819
                  |L17.292|
000124  3614              ADDS     r6,r6,#0x14           ;2819
000126  19a1              ADDS     r1,r4,r6              ;2854
000128  2200              MOVS     r2,#0                 ;2854
00012a  60a2              STR      r2,[r4,#8]            ;2854
00012c  1f0b              SUBS     r3,r1,#4              ;2854
00012e  60e3              STR      r3,[r4,#0xc]          ;2854
000130  68e3              LDR      r3,[r4,#0xc]          ;2854
000132  601c              STR      r4,[r3,#0]            ;2854
000134  608a              STR      r2,[r1,#8]            ;2854
000136  1808              ADDS     r0,r1,r0              ;2854
000138  1f00              SUBS     r0,r0,#4              ;2854
00013a  60c8              STR      r0,[r1,#0xc]          ;2854
00013c  68c8              LDR      r0,[r1,#0xc]          ;2854
00013e  6001              STR      r1,[r0,#0]            ;2854
000140  9802              LDR      r0,[sp,#8]            ;2860
000142  f7fffffe          BL       _RMP_Mem_Ins
000146  e7aa              B        |L17.158|
;;;2867   /* End Function:RMP_Realloc **************************************************/
                          ENDP


                          AREA ||i.RMP_Save_Ctx||, CODE, READONLY, ALIGN=1

                  RMP_Save_Ctx PROC
;;;1941   #if(RMP_USE_HOOKS==RMP_FALSE)
;;;1942   void RMP_Save_Ctx(void)
000000  4770              BX       lr
;;;1943   {
;;;1944       return;
;;;1945   }
;;;1946   #endif
                          ENDP


                          AREA ||i.RMP_Sem_Abort||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Abort PROC
;;;1736   ******************************************************************************/
;;;1737   rmp_ret_t RMP_Sem_Abort(volatile struct RMP_Thd* Thread)
000000  b570              PUSH     {r4-r6,lr}
;;;1738   {
;;;1739       /* Check if this thread structure could possibly be in use */
;;;1740       if(Thread==0)
;;;1741       {
;;;1742           RMP_COVERAGE_MARKER();
;;;1743           return RMP_ERR_THD;
000002  4d1e              LDR      r5,|L19.124|
000004  0004              MOVS     r4,r0                 ;1738
000006  d017              BEQ      |L19.56|
000008  f7fffffe          BL       RMP_Disable_Int
00000c  481c              LDR      r0,|L19.128|
00000e  2101              MOVS     r1,#1                 ;1738
000010  6081              STR      r1,[r0,#8]            ;1738  ; RMP_Sched_Locked
000012  6841              LDR      r1,[r0,#4]            ;1738  ; RMP_Sched_Lock_Cnt
000014  1c49              ADDS     r1,r1,#1              ;1738
000016  6041              STR      r1,[r0,#4]            ;1738  ; RMP_Sched_Lock_Cnt
;;;1744       }
;;;1745       else
;;;1746           RMP_COVERAGE_MARKER();
;;;1747   
;;;1748       RMP_Lock_Sched();
;;;1749       
;;;1750       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
000018  69a0              LDR      r0,[r4,#0x18]
00001a  0600              LSLS     r0,r0,#24
00001c  0e00              LSRS     r0,r0,#24
00001e  d00d              BEQ      |L19.60|
;;;1751       {
;;;1752           RMP_COVERAGE_MARKER();
;;;1753           RMP_Unlock_Sched();
;;;1754           return RMP_ERR_THD;
;;;1755       }
;;;1756       else
;;;1757           RMP_COVERAGE_MARKER();
;;;1758       
;;;1759       /* Is it waiting on a semaphore? If no, we abort and return an error code */
;;;1760       if((RMP_THD_STATE(Thread->State)!=RMP_THD_SEMBLK)&&
000020  69a0              LDR      r0,[r4,#0x18]
000022  b2c0              UXTB     r0,r0
000024  2807              CMP      r0,#7
000026  d00d              BEQ      |L19.68|
000028  69a0              LDR      r0,[r4,#0x18]
00002a  b2c0              UXTB     r0,r0
00002c  2808              CMP      r0,#8
00002e  d009              BEQ      |L19.68|
;;;1761          (RMP_THD_STATE(Thread->State)!=RMP_THD_SEMDLY))
;;;1762       {
;;;1763           RMP_COVERAGE_MARKER();
;;;1764           RMP_Unlock_Sched();
000030  f7fffffe          BL       RMP_Unlock_Sched
;;;1765           return RMP_ERR_STATE;
000034  00a8              LSLS     r0,r5,#2
;;;1766       }
;;;1767       else
;;;1768           RMP_COVERAGE_MARKER();
;;;1769   
;;;1770       /* Waiting for a semaphore. We abort it and return */
;;;1771       RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1772       if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1773       {
;;;1774           RMP_COVERAGE_MARKER();
;;;1775           RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1776       }
;;;1777       else
;;;1778           RMP_COVERAGE_MARKER();
;;;1779       
;;;1780       RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1781       /* Set to running if not suspended */
;;;1782       _RMP_Set_Rdy(Thread);
;;;1783       
;;;1784       Thread->Retval=RMP_ERR_OPER;
;;;1785       RMP_Unlock_Sched();
;;;1786       return 0;
;;;1787   }
000036  bd70              POP      {r4-r6,pc}
                  |L19.56|
000038  4628              MOV      r0,r5                 ;1743
00003a  bd70              POP      {r4-r6,pc}
                  |L19.60|
00003c  f7fffffe          BL       RMP_Unlock_Sched
000040  4628              MOV      r0,r5                 ;1754
000042  bd70              POP      {r4-r6,pc}
                  |L19.68|
000044  6820              LDR      r0,[r4,#0]            ;1771
000046  6861              LDR      r1,[r4,#4]            ;1771
000048  6008              STR      r0,[r1,#0]            ;1771
00004a  6041              STR      r1,[r0,#4]            ;1771
00004c  69a0              LDR      r0,[r4,#0x18]         ;1772
00004e  b2c0              UXTB     r0,r0                 ;1772
000050  2808              CMP      r0,#8                 ;1772
000052  d103              BNE      |L19.92|
000054  68a1              LDR      r1,[r4,#8]            ;1775
000056  68e0              LDR      r0,[r4,#0xc]          ;1775
000058  6001              STR      r1,[r0,#0]            ;1775
00005a  6048              STR      r0,[r1,#4]            ;1775
                  |L19.92|
00005c  69a0              LDR      r0,[r4,#0x18]         ;1780
00005e  0a00              LSRS     r0,r0,#8              ;1780
000060  0200              LSLS     r0,r0,#8              ;1780
000062  1c40              ADDS     r0,r0,#1              ;1780
000064  61a0              STR      r0,[r4,#0x18]         ;1780
000066  4620              MOV      r0,r4                 ;1782
000068  f7fffffe          BL       _RMP_Set_Rdy
00006c  2004              MOVS     r0,#4                 ;1784
00006e  43c0              MVNS     r0,r0                 ;1784
000070  63a0              STR      r0,[r4,#0x38]         ;1784
000072  f7fffffe          BL       RMP_Unlock_Sched
000076  2000              MOVS     r0,#0                 ;1786
000078  bd70              POP      {r4-r6,pc}
;;;1788   /* End Function:RMP_Sem_Abort ************************************************/
                          ENDP

00007a  0000              DCW      0x0000
                  |L19.124|
                          DCD      0xffffffff
                  |L19.128|
                          DCD      ||.data||

                          AREA ||i.RMP_Sem_Crt||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Crt PROC
;;;1555   ******************************************************************************/
;;;1556   rmp_ret_t RMP_Sem_Crt(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Number)
000000  b570              PUSH     {r4-r6,lr}
;;;1557   {
;;;1558       /* Check if this semaphore structure could possibly be in use */
;;;1559       if(Semaphore==0)
;;;1560       {
;;;1561           RMP_COVERAGE_MARKER();
;;;1562           return RMP_ERR_SEM;
000002  4e13              LDR      r6,|L20.80|
000004  460d              MOV      r5,r1                 ;1557
000006  0004              MOVS     r4,r0                 ;1557
000008  d00e              BEQ      |L20.40|
00000a  f7fffffe          BL       RMP_Disable_Int
00000e  4811              LDR      r0,|L20.84|
000010  2101              MOVS     r1,#1                 ;1557
000012  6081              STR      r1,[r0,#8]            ;1557  ; RMP_Sched_Locked
000014  6842              LDR      r2,[r0,#4]            ;1557  ; RMP_Sched_Lock_Cnt
000016  1c52              ADDS     r2,r2,#1              ;1557
000018  6042              STR      r2,[r0,#4]            ;1557  ; RMP_Sched_Lock_Cnt
;;;1563       }
;;;1564       else
;;;1565           RMP_COVERAGE_MARKER();
;;;1566       
;;;1567       RMP_Lock_Sched();
;;;1568       
;;;1569       if(Semaphore->State!=RMP_SEM_FREE)
00001a  68a0              LDR      r0,[r4,#8]
00001c  2800              CMP      r0,#0
00001e  d005              BEQ      |L20.44|
;;;1570       {
;;;1571           RMP_COVERAGE_MARKER();
;;;1572           RMP_Unlock_Sched();
000020  f7fffffe          BL       RMP_Unlock_Sched
;;;1573           return RMP_ERR_SEM;
000024  4630              MOV      r0,r6
;;;1574       }
;;;1575       else
;;;1576           RMP_COVERAGE_MARKER();
;;;1577       
;;;1578       /* Is the number too great to initialize? */
;;;1579       if(Number>=RMP_SEM_MAX_NUM)
;;;1580       {
;;;1581           RMP_COVERAGE_MARKER();
;;;1582           RMP_Unlock_Sched();
;;;1583           return RMP_ERR_OPER;
;;;1584       }
;;;1585       else
;;;1586           RMP_COVERAGE_MARKER();
;;;1587   
;;;1588       /* Initialize contents */
;;;1589       Semaphore->Cur_Num=Number;
;;;1590       Semaphore->State=RMP_SEM_USED;
;;;1591       RMP_List_Crt(&(Semaphore->Wait_List));
;;;1592       
;;;1593       RMP_Unlock_Sched();
;;;1594       
;;;1595       return 0;
;;;1596   }
000026  bd70              POP      {r4-r6,pc}
                  |L20.40|
000028  4630              MOV      r0,r6                 ;1562
00002a  bd70              POP      {r4-r6,pc}
                  |L20.44|
00002c  207d              MOVS     r0,#0x7d              ;1579
00002e  00c0              LSLS     r0,r0,#3              ;1579
000030  4285              CMP      r5,r0                 ;1579
000032  d304              BCC      |L20.62|
000034  f7fffffe          BL       RMP_Unlock_Sched
000038  2004              MOVS     r0,#4                 ;1583
00003a  43c0              MVNS     r0,r0                 ;1583
00003c  bd70              POP      {r4-r6,pc}
                  |L20.62|
00003e  60e5              STR      r5,[r4,#0xc]          ;1589
000040  60a1              STR      r1,[r4,#8]            ;1590
000042  6024              STR      r4,[r4,#0]            ;1590
000044  6064              STR      r4,[r4,#4]            ;1590
000046  f7fffffe          BL       RMP_Unlock_Sched
00004a  2000              MOVS     r0,#0                 ;1595
00004c  bd70              POP      {r4-r6,pc}
;;;1597   /* End Function:RMP_Sem_Crt **************************************************/
                          ENDP

00004e  0000              DCW      0x0000
                  |L20.80|
                          DCD      0xfffffffa
                  |L20.84|
                          DCD      ||.data||

                          AREA ||i.RMP_Sem_Del||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Del PROC
;;;1604   ******************************************************************************/
;;;1605   rmp_ret_t RMP_Sem_Del(volatile struct RMP_Sem* Semaphore)
000000  b570              PUSH     {r4-r6,lr}
;;;1606   {
;;;1607       struct RMP_Thd* Thread;
;;;1608       
;;;1609       /* Check if this semaphore structure could possibly be in use */
;;;1610       if(Semaphore==0)
;;;1611       {
;;;1612           RMP_COVERAGE_MARKER();
;;;1613           return RMP_ERR_SEM;
000002  4c1b              LDR      r4,|L21.112|
000004  0005              MOVS     r5,r0                 ;1606
000006  d00e              BEQ      |L21.38|
000008  f7fffffe          BL       RMP_Disable_Int
00000c  4819              LDR      r0,|L21.116|
00000e  2101              MOVS     r1,#1                 ;1606
000010  6081              STR      r1,[r0,#8]            ;1606  ; RMP_Sched_Locked
000012  6841              LDR      r1,[r0,#4]            ;1606  ; RMP_Sched_Lock_Cnt
000014  1c49              ADDS     r1,r1,#1              ;1606
000016  6041              STR      r1,[r0,#4]            ;1606  ; RMP_Sched_Lock_Cnt
;;;1614       }
;;;1615       else
;;;1616           RMP_COVERAGE_MARKER();
;;;1617       
;;;1618       RMP_Lock_Sched();
;;;1619       
;;;1620       if(Semaphore->State!=RMP_SEM_USED)
000018  68a8              LDR      r0,[r5,#8]
00001a  2801              CMP      r0,#1
00001c  d005              BEQ      |L21.42|
;;;1621       {
;;;1622           RMP_COVERAGE_MARKER();
;;;1623           RMP_Unlock_Sched();
00001e  f7fffffe          BL       RMP_Unlock_Sched
;;;1624           return RMP_ERR_SEM;
000022  4620              MOV      r0,r4
;;;1625       }
;;;1626       else
;;;1627           RMP_COVERAGE_MARKER();
;;;1628   
;;;1629       /* Get rid of all guys waiting on it */
;;;1630       while(&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)
;;;1631       {
;;;1632           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
;;;1633           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1634           
;;;1635           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1636           {
;;;1637               RMP_COVERAGE_MARKER();
;;;1638               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1639           }
;;;1640           else
;;;1641               RMP_COVERAGE_MARKER();
;;;1642   
;;;1643           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1644           /* Set to running if not suspended */
;;;1645           _RMP_Set_Rdy(Thread);
;;;1646           Thread->Retval=RMP_ERR_OPER;
;;;1647       }
;;;1648       Semaphore->State=RMP_SEM_FREE;
;;;1649       
;;;1650       RMP_Unlock_Sched();
;;;1651   
;;;1652       return 0;
;;;1653   }
000024  bd70              POP      {r4-r6,pc}
                  |L21.38|
000026  4620              MOV      r0,r4                 ;1613
000028  bd70              POP      {r4-r6,pc}
                  |L21.42|
00002a  6868              LDR      r0,[r5,#4]            ;1630
00002c  42a8              CMP      r0,r5                 ;1630
00002e  d019              BEQ      |L21.100|
000030  2604              MOVS     r6,#4                 ;1646
000032  43f6              MVNS     r6,r6                 ;1646
                  |L21.52|
000034  686c              LDR      r4,[r5,#4]            ;1632
000036  6861              LDR      r1,[r4,#4]            ;1632
000038  6820              LDR      r0,[r4,#0]            ;1632
00003a  6008              STR      r0,[r1,#0]            ;1632
00003c  6041              STR      r1,[r0,#4]            ;1632
00003e  7e20              LDRB     r0,[r4,#0x18]         ;1635
000040  2808              CMP      r0,#8                 ;1635
000042  d103              BNE      |L21.76|
000044  68e1              LDR      r1,[r4,#0xc]          ;1635
000046  68a0              LDR      r0,[r4,#8]            ;1635
000048  6008              STR      r0,[r1,#0]            ;1635
00004a  6041              STR      r1,[r0,#4]            ;1635
                  |L21.76|
00004c  69a0              LDR      r0,[r4,#0x18]         ;1643
00004e  0a00              LSRS     r0,r0,#8              ;1643
000050  0200              LSLS     r0,r0,#8              ;1643
000052  1c40              ADDS     r0,r0,#1              ;1643
000054  61a0              STR      r0,[r4,#0x18]         ;1645
000056  4620              MOV      r0,r4                 ;1645
000058  f7fffffe          BL       _RMP_Set_Rdy
00005c  63a6              STR      r6,[r4,#0x38]         ;1646
00005e  6868              LDR      r0,[r5,#4]            ;1646
000060  42a8              CMP      r0,r5                 ;1646
000062  d1e7              BNE      |L21.52|
                  |L21.100|
000064  2000              MOVS     r0,#0                 ;1648
000066  60a8              STR      r0,[r5,#8]            ;1648
000068  f7fffffe          BL       RMP_Unlock_Sched
00006c  2000              MOVS     r0,#0                 ;1652
00006e  bd70              POP      {r4-r6,pc}
;;;1654   /* End Function:RMP_Sem_Del **************************************************/
                          ENDP

                  |L21.112|
                          DCD      0xfffffffa
                  |L21.116|
                          DCD      ||.data||

                          AREA ||i.RMP_Sem_Pend||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Pend PROC
;;;1662   ******************************************************************************/
;;;1663   rmp_ret_t RMP_Sem_Pend(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Slices)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1664   {
;;;1665       /* Check if this semaphore structure could possibly be in use */
;;;1666       if(Semaphore==0)
;;;1667       {
;;;1668           RMP_COVERAGE_MARKER();
;;;1669           return RMP_ERR_SEM;
000002  4f2f              LDR      r7,|L22.192|
000004  460e              MOV      r6,r1                 ;1664
000006  0005              MOVS     r5,r0                 ;1664
000008  d00e              BEQ      |L22.40|
00000a  f7fffffe          BL       RMP_Disable_Int
00000e  4c2d              LDR      r4,|L22.196|
000010  2001              MOVS     r0,#1                 ;1664
000012  60a0              STR      r0,[r4,#8]            ;1664  ; RMP_Sched_Locked
000014  6860              LDR      r0,[r4,#4]            ;1664  ; RMP_Sched_Lock_Cnt
000016  1c40              ADDS     r0,r0,#1              ;1664
000018  6060              STR      r0,[r4,#4]            ;1664  ; RMP_Sched_Lock_Cnt
;;;1670       }
;;;1671       else
;;;1672           RMP_COVERAGE_MARKER();
;;;1673       
;;;1674       RMP_Lock_Sched();
;;;1675       
;;;1676       if(Semaphore->State!=RMP_SEM_USED)
00001a  68a8              LDR      r0,[r5,#8]
00001c  2801              CMP      r0,#1
00001e  d005              BEQ      |L22.44|
;;;1677       {
;;;1678           RMP_COVERAGE_MARKER();
;;;1679           RMP_Unlock_Sched();
000020  f7fffffe          BL       RMP_Unlock_Sched
;;;1680           return RMP_ERR_SEM;
000024  4638              MOV      r0,r7
;;;1681       }
;;;1682       else
;;;1683           RMP_COVERAGE_MARKER();
;;;1684       
;;;1685       /* Check if we can get one immediately */
;;;1686       if(Semaphore->Cur_Num!=0)
;;;1687       {
;;;1688           RMP_COVERAGE_MARKER();
;;;1689           Semaphore->Cur_Num--;
;;;1690           RMP_Unlock_Sched();
;;;1691           return Semaphore->Cur_Num;
;;;1692       }
;;;1693       else
;;;1694       {
;;;1695           RMP_COVERAGE_MARKER();
;;;1696           /* Cannot get one, we need to block */
;;;1697           if(Slices==0)
;;;1698           {
;;;1699               RMP_COVERAGE_MARKER();
;;;1700               RMP_Unlock_Sched();
;;;1701               return RMP_ERR_OPER;
;;;1702           }
;;;1703           else
;;;1704               RMP_COVERAGE_MARKER();
;;;1705   
;;;1706           /* We must be running - place into waitlist now */
;;;1707           _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1708           RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),Semaphore->Wait_List.Prev,&(Semaphore->Wait_List));
;;;1709           
;;;1710           if(Slices<RMP_MAX_SLICES)
;;;1711           {
;;;1712               RMP_COVERAGE_MARKER();
;;;1713               _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1714               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SEMDLY);
;;;1715           }
;;;1716           else
;;;1717           {
;;;1718               RMP_COVERAGE_MARKER();
;;;1719               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SEMBLK);
;;;1720           }
;;;1721           
;;;1722           RMP_Cur_Thd->Retval=0;
;;;1723       }
;;;1724       
;;;1725       RMP_Unlock_Sched();
;;;1726   
;;;1727       return RMP_Cur_Thd->Retval;
;;;1728   }
000026  bdf8              POP      {r3-r7,pc}
                  |L22.40|
000028  4638              MOV      r0,r7                 ;1669
00002a  bdf8              POP      {r3-r7,pc}
                  |L22.44|
00002c  68e8              LDR      r0,[r5,#0xc]          ;1686
00002e  2800              CMP      r0,#0                 ;1686
000030  d006              BEQ      |L22.64|
000032  68e8              LDR      r0,[r5,#0xc]          ;1689
000034  1e40              SUBS     r0,r0,#1              ;1689
000036  60e8              STR      r0,[r5,#0xc]          ;1689
000038  f7fffffe          BL       RMP_Unlock_Sched
00003c  68e8              LDR      r0,[r5,#0xc]          ;1691
00003e  bdf8              POP      {r3-r7,pc}
                  |L22.64|
000040  2e00              CMP      r6,#0                 ;1697
000042  d030              BEQ      |L22.166|
000044  69a0              LDR      r0,[r4,#0x18]         ;1707  ; RMP_Cur_Thd
000046  f7fffffe          BL       _RMP_Clr_Rdy
00004a  69a0              LDR      r0,[r4,#0x18]         ;1708  ; RMP_Cur_Thd
00004c  6829              LDR      r1,[r5,#0]            ;1708
00004e  6028              STR      r0,[r5,#0]            ;1708
000050  6045              STR      r5,[r0,#4]            ;1708
000052  6001              STR      r1,[r0,#0]            ;1708
000054  6048              STR      r0,[r1,#4]            ;1708
000056  481c              LDR      r0,|L22.200|
000058  4286              CMP      r6,r0                 ;1710
00005a  d229              BCS      |L22.176|
00005c  69a1              LDR      r1,[r4,#0x18]         ;1713  ; RMP_Cur_Thd
00005e  4b1b              LDR      r3,|L22.204|
000060  6858              LDR      r0,[r3,#4]            ;1713  ; RMP_Delay
000062  4298              CMP      r0,r3                 ;1713
000064  d007              BEQ      |L22.118|
                  |L22.102|
000066  6a02              LDR      r2,[r0,#0x20]         ;1713
000068  6965              LDR      r5,[r4,#0x14]         ;1713  ; RMP_Tick
00006a  1b52              SUBS     r2,r2,r5              ;1713
00006c  42b2              CMP      r2,r6                 ;1713
00006e  d802              BHI      |L22.118|
000070  6840              LDR      r0,[r0,#4]            ;1713
000072  4298              CMP      r0,r3                 ;1713
000074  d1f7              BNE      |L22.102|
                  |L22.118|
000076  6962              LDR      r2,[r4,#0x14]         ;1713  ; RMP_Tick
000078  1992              ADDS     r2,r2,r6              ;1713
00007a  628a              STR      r2,[r1,#0x28]         ;1713
00007c  3108              ADDS     r1,r1,#8              ;1713
00007e  6802              LDR      r2,[r0,#0]            ;1713
000080  6001              STR      r1,[r0,#0]            ;1713
000082  6048              STR      r0,[r1,#4]            ;1713
000084  600a              STR      r2,[r1,#0]            ;1713
000086  6051              STR      r1,[r2,#4]            ;1713
000088  69a0              LDR      r0,[r4,#0x18]         ;1714  ; RMP_Cur_Thd
00008a  69a1              LDR      r1,[r4,#0x18]         ;1714  ; RMP_Cur_Thd
00008c  6980              LDR      r0,[r0,#0x18]         ;1714
00008e  0a00              LSRS     r0,r0,#8              ;1714
000090  0200              LSLS     r0,r0,#8              ;1714
000092  3008              ADDS     r0,r0,#8              ;1714
                  |L22.148|
000094  6188              STR      r0,[r1,#0x18]         ;1722
000096  69a1              LDR      r1,[r4,#0x18]         ;1722  ; RMP_Cur_Thd
000098  2000              MOVS     r0,#0                 ;1722
00009a  6388              STR      r0,[r1,#0x38]         ;1725
00009c  f7fffffe          BL       RMP_Unlock_Sched
0000a0  69a0              LDR      r0,[r4,#0x18]         ;1727  ; RMP_Cur_Thd
0000a2  6b80              LDR      r0,[r0,#0x38]         ;1727
0000a4  bdf8              POP      {r3-r7,pc}
                  |L22.166|
0000a6  f7fffffe          BL       RMP_Unlock_Sched
0000aa  2004              MOVS     r0,#4                 ;1701
0000ac  43c0              MVNS     r0,r0                 ;1701
0000ae  bdf8              POP      {r3-r7,pc}
                  |L22.176|
0000b0  69a0              LDR      r0,[r4,#0x18]         ;1719  ; RMP_Cur_Thd
0000b2  69a1              LDR      r1,[r4,#0x18]         ;1719  ; RMP_Cur_Thd
0000b4  6980              LDR      r0,[r0,#0x18]         ;1719
0000b6  0a00              LSRS     r0,r0,#8              ;1719
0000b8  0200              LSLS     r0,r0,#8              ;1719
0000ba  1dc0              ADDS     r0,r0,#7              ;1719
0000bc  e7ea              B        |L22.148|
;;;1729   /* End Function:RMP_Sem_Pend *************************************************/
                          ENDP

0000be  0000              DCW      0x0000
                  |L22.192|
                          DCD      0xfffffffa
                  |L22.196|
                          DCD      ||.data||
                  |L22.200|
                          DCD      0x000186a0
                  |L22.204|
                          DCD      ||.data||+0x20

                          AREA ||i.RMP_Sem_Post||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Post PROC
;;;1796   ******************************************************************************/
;;;1797   rmp_ret_t RMP_Sem_Post(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Number)
000000  b570              PUSH     {r4-r6,lr}
;;;1798   {
;;;1799       struct RMP_Thd* Thread;
;;;1800       
;;;1801       /* Check if this semaphore structure could possibly be in use */
;;;1802       if((Semaphore==0)||(Number==0))
;;;1803       {
;;;1804           RMP_COVERAGE_MARKER();
;;;1805           return RMP_ERR_SEM;
000002  4e24              LDR      r6,|L23.148|
000004  460d              MOV      r5,r1                 ;1798
000006  0004              MOVS     r4,r0                 ;1798
000008  d010              BEQ      |L23.44|
00000a  2d00              CMP      r5,#0                 ;1802
00000c  d00e              BEQ      |L23.44|
00000e  f7fffffe          BL       RMP_Disable_Int
000012  4821              LDR      r0,|L23.152|
000014  2101              MOVS     r1,#1                 ;1802
000016  6081              STR      r1,[r0,#8]            ;1802  ; RMP_Sched_Locked
000018  6841              LDR      r1,[r0,#4]            ;1802  ; RMP_Sched_Lock_Cnt
00001a  1c49              ADDS     r1,r1,#1              ;1802
00001c  6041              STR      r1,[r0,#4]            ;1802  ; RMP_Sched_Lock_Cnt
;;;1806       }
;;;1807       else
;;;1808           RMP_COVERAGE_MARKER();
;;;1809       
;;;1810       RMP_Lock_Sched();
;;;1811       
;;;1812       if(Semaphore->State!=RMP_SEM_USED)
00001e  68a0              LDR      r0,[r4,#8]
000020  2801              CMP      r0,#1
000022  d005              BEQ      |L23.48|
;;;1813       {
;;;1814           RMP_COVERAGE_MARKER();
;;;1815           RMP_Unlock_Sched();
000024  f7fffffe          BL       RMP_Unlock_Sched
;;;1816           return RMP_ERR_SEM;
000028  4630              MOV      r0,r6
;;;1817       }
;;;1818       else
;;;1819           RMP_COVERAGE_MARKER();
;;;1820       
;;;1821       /* Would the maximum value be exceeded if this is posted? */
;;;1822       if((Semaphore->Cur_Num+Number)>=RMP_SEM_MAX_NUM)
;;;1823       {
;;;1824           RMP_COVERAGE_MARKER();
;;;1825           RMP_Unlock_Sched();
;;;1826           return RMP_ERR_OPER;
;;;1827       }
;;;1828       else
;;;1829           RMP_COVERAGE_MARKER();
;;;1830       
;;;1831       Semaphore->Cur_Num+=Number;
;;;1832       /* Is there any thread waiting on it? If there are, clean them up*/
;;;1833       while((&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)&&(Semaphore->Cur_Num!=0))
;;;1834       {
;;;1835           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
;;;1836           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1837           
;;;1838           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1839           {
;;;1840               RMP_COVERAGE_MARKER();
;;;1841               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1842           }
;;;1843           else
;;;1844               RMP_COVERAGE_MARKER();
;;;1845           
;;;1846           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1847           /* Set to running if not suspended */
;;;1848           _RMP_Set_Rdy(Thread);
;;;1849   
;;;1850           /* Finally, return success */
;;;1851           Thread->Retval=0;
;;;1852           Semaphore->Cur_Num--;
;;;1853       }
;;;1854   
;;;1855       RMP_Unlock_Sched();
;;;1856       return 0;
;;;1857   }
00002a  bd70              POP      {r4-r6,pc}
                  |L23.44|
00002c  4630              MOV      r0,r6                 ;1805
00002e  bd70              POP      {r4-r6,pc}
                  |L23.48|
000030  68e0              LDR      r0,[r4,#0xc]          ;1822
000032  217d              MOVS     r1,#0x7d              ;1822
000034  1940              ADDS     r0,r0,r5              ;1822
000036  00c9              LSLS     r1,r1,#3              ;1822
000038  4288              CMP      r0,r1                 ;1822
00003a  d304              BCC      |L23.70|
00003c  f7fffffe          BL       RMP_Unlock_Sched
000040  2004              MOVS     r0,#4                 ;1826
000042  43c0              MVNS     r0,r0                 ;1826
000044  bd70              POP      {r4-r6,pc}
                  |L23.70|
000046  68e0              LDR      r0,[r4,#0xc]          ;1831
000048  1940              ADDS     r0,r0,r5              ;1831
00004a  60e0              STR      r0,[r4,#0xc]          ;1831
00004c  2600              MOVS     r6,#0                 ;1831
00004e  e017              B        |L23.128|
                  |L23.80|
000050  6865              LDR      r5,[r4,#4]            ;1835
000052  6869              LDR      r1,[r5,#4]            ;1835
000054  6828              LDR      r0,[r5,#0]            ;1835
000056  6008              STR      r0,[r1,#0]            ;1835
000058  6041              STR      r1,[r0,#4]            ;1835
00005a  7e28              LDRB     r0,[r5,#0x18]         ;1838
00005c  2808              CMP      r0,#8                 ;1838
00005e  d103              BNE      |L23.104|
000060  68e9              LDR      r1,[r5,#0xc]          ;1838
000062  68a8              LDR      r0,[r5,#8]            ;1838
000064  6008              STR      r0,[r1,#0]            ;1838
000066  6041              STR      r1,[r0,#4]            ;1838
                  |L23.104|
000068  69a8              LDR      r0,[r5,#0x18]         ;1846
00006a  0a00              LSRS     r0,r0,#8              ;1846
00006c  0200              LSLS     r0,r0,#8              ;1846
00006e  1c40              ADDS     r0,r0,#1              ;1846
000070  61a8              STR      r0,[r5,#0x18]         ;1848
000072  4628              MOV      r0,r5                 ;1848
000074  f7fffffe          BL       _RMP_Set_Rdy
000078  63ae              STR      r6,[r5,#0x38]         ;1852
00007a  68e0              LDR      r0,[r4,#0xc]          ;1852
00007c  1e40              SUBS     r0,r0,#1              ;1852
00007e  60e0              STR      r0,[r4,#0xc]          ;1852
                  |L23.128|
000080  6860              LDR      r0,[r4,#4]            ;1852
000082  42a0              CMP      r0,r4                 ;1852
000084  d002              BEQ      |L23.140|
000086  68e0              LDR      r0,[r4,#0xc]          ;1852
000088  2800              CMP      r0,#0                 ;1852
00008a  d1e1              BNE      |L23.80|
                  |L23.140|
00008c  f7fffffe          BL       RMP_Unlock_Sched
000090  2000              MOVS     r0,#0                 ;1856
000092  bd70              POP      {r4-r6,pc}
;;;1858   /* End Function:RMP_Sem_Post *************************************************/
                          ENDP

                  |L23.148|
                          DCD      0xfffffffa
                  |L23.152|
                          DCD      ||.data||

                          AREA ||i.RMP_Sem_Post_ISR||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Post_ISR PROC
;;;1868   ******************************************************************************/
;;;1869   rmp_ret_t RMP_Sem_Post_ISR(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Number)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1870   {
000002  0004              MOVS     r4,r0
;;;1871       struct RMP_Thd* Thread;
;;;1872       /* Check if this semaphore structure could possibly be in use */
;;;1873       if((Semaphore==0)||(Number==0))
;;;1874       {
;;;1875           RMP_COVERAGE_MARKER();
;;;1876           return RMP_ERR_SEM;
000004  481d              LDR      r0,|L24.124|
000006  d00c              BEQ      |L24.34|
000008  2900              CMP      r1,#0                 ;1873
00000a  d00a              BEQ      |L24.34|
;;;1877       }
;;;1878       else
;;;1879           RMP_COVERAGE_MARKER();
;;;1880       
;;;1881       if(Semaphore->State!=RMP_SEM_USED)
00000c  68a2              LDR      r2,[r4,#8]
00000e  2a01              CMP      r2,#1
000010  d107              BNE      |L24.34|
;;;1882       {
;;;1883           RMP_COVERAGE_MARKER();
;;;1884           return RMP_ERR_SEM;
;;;1885       }
;;;1886       else
;;;1887           RMP_COVERAGE_MARKER();
;;;1888   
;;;1889       /* Would the maximum value be exceeded if this is posted? */
;;;1890       if((Semaphore->Cur_Num+Number)>=RMP_SEM_MAX_NUM)
000012  68e0              LDR      r0,[r4,#0xc]
000014  227d              MOVS     r2,#0x7d
000016  1840              ADDS     r0,r0,r1
000018  00d2              LSLS     r2,r2,#3
00001a  4290              CMP      r0,r2
00001c  d302              BCC      |L24.36|
;;;1891       {
;;;1892           RMP_COVERAGE_MARKER();
;;;1893           return RMP_ERR_OPER;
00001e  2004              MOVS     r0,#4
000020  43c0              MVNS     r0,r0
                  |L24.34|
;;;1894       }
;;;1895       else
;;;1896           RMP_COVERAGE_MARKER();
;;;1897       
;;;1898       Semaphore->Cur_Num+=Number;
;;;1899       /* Is there any thread waiting on it? If there are, clean them up*/
;;;1900       while((&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)&&(Semaphore->Cur_Num!=0))
;;;1901       {
;;;1902           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
;;;1903           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1904           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1905           {
;;;1906               RMP_COVERAGE_MARKER();
;;;1907               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1908           }
;;;1909           else
;;;1910               RMP_COVERAGE_MARKER();
;;;1911           
;;;1912           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1913           /* Set to running if not suspended */
;;;1914           _RMP_Set_Rdy(Thread);
;;;1915           
;;;1916           /* If schedule pending, trigger it now because we are in ISR */
;;;1917           if(RMP_Sched_Pend!=0)
;;;1918           {
;;;1919               RMP_COVERAGE_MARKER();
;;;1920               RMP_Sched_Pend=0;
;;;1921               _RMP_Yield();   
;;;1922           }
;;;1923           else
;;;1924               RMP_COVERAGE_MARKER();
;;;1925   
;;;1926           /* Finally, return success */
;;;1927           Thread->Retval=0;
;;;1928           Semaphore->Cur_Num--;
;;;1929       }
;;;1930   
;;;1931       return 0;
;;;1932   }
000022  bdf8              POP      {r3-r7,pc}
                  |L24.36|
000024  68e0              LDR      r0,[r4,#0xc]          ;1898
000026  1840              ADDS     r0,r0,r1              ;1898
000028  60e0              STR      r0,[r4,#0xc]          ;1898
00002a  4e15              LDR      r6,|L24.128|
00002c  2700              MOVS     r7,#0                 ;1917
00002e  e01d              B        |L24.108|
                  |L24.48|
000030  6865              LDR      r5,[r4,#4]            ;1902
000032  6869              LDR      r1,[r5,#4]            ;1902
000034  6828              LDR      r0,[r5,#0]            ;1902
000036  6008              STR      r0,[r1,#0]            ;1902
000038  6041              STR      r1,[r0,#4]            ;1902
00003a  7e28              LDRB     r0,[r5,#0x18]         ;1904
00003c  2808              CMP      r0,#8                 ;1904
00003e  d103              BNE      |L24.72|
000040  68e9              LDR      r1,[r5,#0xc]          ;1904
000042  68a8              LDR      r0,[r5,#8]            ;1904
000044  6008              STR      r0,[r1,#0]            ;1904
000046  6041              STR      r1,[r0,#4]            ;1904
                  |L24.72|
000048  69a8              LDR      r0,[r5,#0x18]         ;1912
00004a  0a00              LSRS     r0,r0,#8              ;1912
00004c  0200              LSLS     r0,r0,#8              ;1912
00004e  1c40              ADDS     r0,r0,#1              ;1912
000050  61a8              STR      r0,[r5,#0x18]         ;1914
000052  4628              MOV      r0,r5                 ;1914
000054  f7fffffe          BL       _RMP_Set_Rdy
000058  68f0              LDR      r0,[r6,#0xc]          ;1917  ; RMP_Sched_Pend
00005a  2800              CMP      r0,#0                 ;1917
00005c  d002              BEQ      |L24.100|
00005e  60f7              STR      r7,[r6,#0xc]          ;1920  ; RMP_Sched_Pend
000060  f7fffffe          BL       _RMP_Yield
                  |L24.100|
000064  63af              STR      r7,[r5,#0x38]         ;1928
000066  68e0              LDR      r0,[r4,#0xc]          ;1928
000068  1e40              SUBS     r0,r0,#1              ;1928
00006a  60e0              STR      r0,[r4,#0xc]          ;1928
                  |L24.108|
00006c  6860              LDR      r0,[r4,#4]            ;1928
00006e  42a0              CMP      r0,r4                 ;1928
000070  d002              BEQ      |L24.120|
000072  68e0              LDR      r0,[r4,#0xc]          ;1928
000074  2800              CMP      r0,#0                 ;1928
000076  d1db              BNE      |L24.48|
                  |L24.120|
000078  2000              MOVS     r0,#0                 ;1931
00007a  bdf8              POP      {r3-r7,pc}
;;;1933   /* End Function:RMP_Sem_Post_ISR *********************************************/
                          ENDP

                  |L24.124|
                          DCD      0xfffffffa
                  |L24.128|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Cancel||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Cancel PROC
;;;1513   ******************************************************************************/
;;;1514   rmp_ret_t RMP_Thd_Cancel(volatile struct RMP_Thd* Thread)
000000  2800              CMP      r0,#0
;;;1515   {
;;;1516       /* Check if this thread structure could possibly be in use */
;;;1517       if(Thread==0)
000002  d101              BNE      |L25.8|
;;;1518       {
;;;1519           RMP_COVERAGE_MARKER();
;;;1520           return RMP_ERR_THD;
000004  1e40              SUBS     r0,r0,#1
;;;1521       }
;;;1522       else
;;;1523           RMP_COVERAGE_MARKER();
;;;1524       
;;;1525       RMP_Lock_Sched();
;;;1526       
;;;1527       /* Is it delayed? */
;;;1528       if(RMP_THD_STATE(Thread->State)!=RMP_THD_DELAYED)
;;;1529       {
;;;1530           RMP_COVERAGE_MARKER();
;;;1531           RMP_Unlock_Sched();
;;;1532           return RMP_ERR_STATE;
;;;1533       }
;;;1534       else
;;;1535           RMP_COVERAGE_MARKER();
;;;1536   
;;;1537       /* Delete it from the delay list */
;;;1538       RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1539       RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1540       /* Set to running if not suspended */
;;;1541       _RMP_Set_Rdy(Thread);
;;;1542       
;;;1543       Thread->Retval=RMP_ERR_OPER;
;;;1544       RMP_Unlock_Sched();
;;;1545       return 0;
;;;1546   }
000006  4770              BX       lr
                  |L25.8|
000008  b510              PUSH     {r4,lr}               ;1515
00000a  4604              MOV      r4,r0                 ;1515
00000c  f7fffffe          BL       RMP_Disable_Int
000010  4810              LDR      r0,|L25.84|
000012  2101              MOVS     r1,#1                 ;1515
000014  6081              STR      r1,[r0,#8]            ;1515  ; RMP_Sched_Locked
000016  6841              LDR      r1,[r0,#4]            ;1515  ; RMP_Sched_Lock_Cnt
000018  1c49              ADDS     r1,r1,#1              ;1515
00001a  6041              STR      r1,[r0,#4]            ;1515  ; RMP_Sched_Lock_Cnt
00001c  69a0              LDR      r0,[r4,#0x18]         ;1528
00001e  b2c0              UXTB     r0,r0                 ;1528
000020  2806              CMP      r0,#6                 ;1528
000022  d004              BEQ      |L25.46|
000024  f7fffffe          BL       RMP_Unlock_Sched
000028  2003              MOVS     r0,#3                 ;1532
00002a  43c0              MVNS     r0,r0                 ;1532
00002c  bd10              POP      {r4,pc}
                  |L25.46|
00002e  68a1              LDR      r1,[r4,#8]            ;1538
000030  68e0              LDR      r0,[r4,#0xc]          ;1538
000032  6001              STR      r1,[r0,#0]            ;1538
000034  6048              STR      r0,[r1,#4]            ;1538
000036  69a0              LDR      r0,[r4,#0x18]         ;1539
000038  0a00              LSRS     r0,r0,#8              ;1539
00003a  0200              LSLS     r0,r0,#8              ;1539
00003c  1c40              ADDS     r0,r0,#1              ;1539
00003e  61a0              STR      r0,[r4,#0x18]         ;1539
000040  4620              MOV      r0,r4                 ;1541
000042  f7fffffe          BL       _RMP_Set_Rdy
000046  2004              MOVS     r0,#4                 ;1543
000048  43c0              MVNS     r0,r0                 ;1543
00004a  63a0              STR      r0,[r4,#0x38]         ;1543
00004c  f7fffffe          BL       RMP_Unlock_Sched
000050  2000              MOVS     r0,#0                 ;1545
000052  bd10              POP      {r4,pc}
;;;1547   /* End Function:RMP_Thd_Cancel ***********************************************/
                          ENDP

                  |L25.84|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Crt||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Crt PROC
;;;765    ******************************************************************************/
;;;766    rmp_ret_t RMP_Thd_Crt(volatile struct RMP_Thd* Thread, void* Entry, void* Stack, void* Arg, rmp_ptr_t Prio, rmp_ptr_t Slices)
000000  b5ff              PUSH     {r0-r7,lr}
;;;767    {
000002  b081              SUB      sp,sp,#4
;;;768        /* Check if the priority and timeslice range is correct */
;;;769        if(Prio>=RMP_MAX_PREEMPT_PRIO)
000004  9f0a              LDR      r7,[sp,#0x28]
000006  9e0b              LDR      r6,[sp,#0x2c]
000008  4604              MOV      r4,r0                 ;767
00000a  2f20              CMP      r7,#0x20
00000c  d303              BCC      |L26.22|
;;;770        {
;;;771            RMP_COVERAGE_MARKER();
;;;772            return RMP_ERR_PRIO;
00000e  2001              MOVS     r0,#1
000010  43c0              MVNS     r0,r0
;;;773        }
;;;774        else
;;;775            RMP_COVERAGE_MARKER();
;;;776        
;;;777        if((Slices==0)||(Slices>=RMP_MAX_SLICES))
;;;778        {
;;;779            RMP_COVERAGE_MARKER();
;;;780            return RMP_ERR_SLICE;
;;;781        }
;;;782        else
;;;783            RMP_COVERAGE_MARKER();
;;;784        
;;;785        /* Check if this thread structure could possibly be in use */
;;;786        if(Thread==0)
;;;787        {
;;;788            RMP_COVERAGE_MARKER();
;;;789            return RMP_ERR_THD;
;;;790        }
;;;791        else
;;;792            RMP_COVERAGE_MARKER();
;;;793        
;;;794        RMP_Lock_Sched();
;;;795        
;;;796        if(RMP_THD_STATE(Thread->State)!=RMP_THD_FREE)
;;;797        {
;;;798            RMP_COVERAGE_MARKER();
;;;799            RMP_Unlock_Sched();
;;;800            return RMP_ERR_THD;
;;;801        }
;;;802        else
;;;803            RMP_COVERAGE_MARKER();
;;;804        
;;;805        /* Create the thread and insert it into the list */
;;;806        Thread->Prio=Prio;
;;;807        Thread->Slices=Slices;
;;;808        Thread->Slices_Left=Slices;
;;;809        Thread->Stack=(rmp_ptr_t)Stack;
;;;810        
;;;811        /* Initialize its stack and sending list */
;;;812        _RMP_Stack_Init((rmp_ptr_t)Entry, (rmp_ptr_t)Stack, (rmp_ptr_t)Arg);
;;;813        RMP_List_Crt(&(Thread->Snd_List));
;;;814        
;;;815        /* Notify the scheduler that we have created something new, also check locks */
;;;816        Thread->State=RMP_THD_RUNNING;
;;;817        _RMP_Set_Rdy(Thread);
;;;818        
;;;819        RMP_Unlock_Sched();
;;;820    
;;;821        return 0;
;;;822    }
000012  b005              ADD      sp,sp,#0x14
000014  bdf0              POP      {r4-r7,pc}
                  |L26.22|
000016  2e00              CMP      r6,#0                 ;777
000018  d002              BEQ      |L26.32|
00001a  481a              LDR      r0,|L26.132|
00001c  4286              CMP      r6,r0                 ;777
00001e  d303              BCC      |L26.40|
                  |L26.32|
000020  2002              MOVS     r0,#2                 ;780
000022  43c0              MVNS     r0,r0                 ;780
000024  b005              ADD      sp,sp,#0x14
000026  bdf0              POP      {r4-r7,pc}
                  |L26.40|
000028  2c00              CMP      r4,#0                 ;786
00002a  d010              BEQ      |L26.78|
00002c  f7fffffe          BL       RMP_Disable_Int
000030  4815              LDR      r0,|L26.136|
000032  2501              MOVS     r5,#1                 ;786
000034  6085              STR      r5,[r0,#8]            ;786  ; RMP_Sched_Locked
000036  6841              LDR      r1,[r0,#4]            ;786  ; RMP_Sched_Lock_Cnt
000038  1c49              ADDS     r1,r1,#1              ;786
00003a  6041              STR      r1,[r0,#4]            ;786  ; RMP_Sched_Lock_Cnt
00003c  69a0              LDR      r0,[r4,#0x18]         ;796
00003e  0600              LSLS     r0,r0,#24             ;796
000040  0e00              LSRS     r0,r0,#24             ;796
000042  d008              BEQ      |L26.86|
000044  f7fffffe          BL       RMP_Unlock_Sched
000048  1ea8              SUBS     r0,r5,#2              ;800
00004a  b005              ADD      sp,sp,#0x14
00004c  bdf0              POP      {r4-r7,pc}
                  |L26.78|
00004e  2000              MOVS     r0,#0                 ;789
000050  43c0              MVNS     r0,r0                 ;789
000052  b005              ADD      sp,sp,#0x14
000054  bdf0              POP      {r4-r7,pc}
                  |L26.86|
000056  6267              STR      r7,[r4,#0x24]         ;806
000058  61e6              STR      r6,[r4,#0x1c]         ;807
00005a  6226              STR      r6,[r4,#0x20]         ;808
00005c  9803              LDR      r0,[sp,#0xc]          ;809
00005e  6360              STR      r0,[r4,#0x34]         ;809
000060  9a04              LDR      r2,[sp,#0x10]         ;812
000062  9903              LDR      r1,[sp,#0xc]          ;812
000064  9802              LDR      r0,[sp,#8]            ;812
000066  f7fffffe          BL       _RMP_Stack_Init
00006a  4620              MOV      r0,r4                 ;813
00006c  3010              ADDS     r0,r0,#0x10           ;813
00006e  6120              STR      r0,[r4,#0x10]         ;813
000070  6160              STR      r0,[r4,#0x14]         ;813
000072  61a5              STR      r5,[r4,#0x18]         ;816
000074  4620              MOV      r0,r4                 ;817
000076  f7fffffe          BL       _RMP_Set_Rdy
00007a  f7fffffe          BL       RMP_Unlock_Sched
00007e  2000              MOVS     r0,#0                 ;821
000080  b005              ADD      sp,sp,#0x14
000082  bdf0              POP      {r4-r7,pc}
;;;823    /* End Function:RMP_Thd_Crt **************************************************/
                          ENDP

                  |L26.132|
                          DCD      0x000186a0
                  |L26.136|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Del||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Del PROC
;;;830    ******************************************************************************/
;;;831    rmp_ret_t RMP_Thd_Del(volatile struct RMP_Thd* Thread)
000000  b5f8              PUSH     {r3-r7,lr}
;;;832    {
;;;833        struct RMP_Thd* Release;
;;;834        
;;;835        /* Check if this thread structure could possibly be in use */
;;;836        if(Thread==0)
;;;837        {
;;;838            RMP_COVERAGE_MARKER();
;;;839            return RMP_ERR_THD;
000002  4d32              LDR      r5,|L27.204|
000004  0004              MOVS     r4,r0                 ;832
000006  d01a              BEQ      |L27.62|
000008  f7fffffe          BL       RMP_Disable_Int
00000c  4830              LDR      r0,|L27.208|
00000e  2101              MOVS     r1,#1                 ;832
000010  6081              STR      r1,[r0,#8]            ;832  ; RMP_Sched_Locked
000012  6841              LDR      r1,[r0,#4]            ;832  ; RMP_Sched_Lock_Cnt
000014  1c49              ADDS     r1,r1,#1              ;832
000016  6041              STR      r1,[r0,#4]            ;832  ; RMP_Sched_Lock_Cnt
;;;840        }
;;;841        else
;;;842            RMP_COVERAGE_MARKER();
;;;843        
;;;844        RMP_Lock_Sched();
;;;845        
;;;846        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
000018  69a0              LDR      r0,[r4,#0x18]
00001a  0600              LSLS     r0,r0,#24
00001c  0e00              LSRS     r0,r0,#24
00001e  d010              BEQ      |L27.66|
;;;847        {
;;;848            RMP_COVERAGE_MARKER();
;;;849            RMP_Unlock_Sched();
;;;850            return RMP_ERR_THD;
;;;851        }
;;;852        else
;;;853            RMP_COVERAGE_MARKER();
;;;854        
;;;855        /* See if anyone waiting to send to this thread. If there is, release all these threads */
;;;856        while(&(Thread->Snd_List)!=Thread->Snd_List.Next)
000020  6960              LDR      r0,[r4,#0x14]
000022  4626              MOV      r6,r4
000024  3610              ADDS     r6,r6,#0x10
;;;857        {
;;;858            Release=(struct RMP_Thd*)(Thread->Snd_List.Next);
;;;859            RMP_List_Del(Release->Run_Head.Prev,Release->Run_Head.Next);
;;;860            if(RMP_THD_STATE(Release->State)==RMP_THD_SNDDLY)
;;;861            {
;;;862                RMP_COVERAGE_MARKER();
;;;863                RMP_List_Del(Release->Dly_Head.Prev,Release->Dly_Head.Next);
;;;864            }
;;;865            else
;;;866                RMP_COVERAGE_MARKER();
;;;867            
;;;868            RMP_THD_STATE_SET(Release->State,RMP_THD_RUNNING);
;;;869            /* Set ready if not suspended */
;;;870            _RMP_Set_Rdy(Release);
;;;871            Release->Retval=RMP_ERR_OPER;
000026  1f2f              SUBS     r7,r5,#4
000028  42b0              CMP      r0,r6                 ;856
00002a  d01e              BEQ      |L27.106|
                  |L27.44|
00002c  6965              LDR      r5,[r4,#0x14]         ;858
00002e  6869              LDR      r1,[r5,#4]            ;858
000030  6828              LDR      r0,[r5,#0]            ;858
000032  6008              STR      r0,[r1,#0]            ;858
000034  6041              STR      r1,[r0,#4]            ;858
000036  7e28              LDRB     r0,[r5,#0x18]         ;860
000038  2803              CMP      r0,#3                 ;860
00003a  d006              BEQ      |L27.74|
00003c  e009              B        |L27.82|
                  |L27.62|
00003e  4628              MOV      r0,r5                 ;839
;;;872        }
;;;873        
;;;874        /* See what is its state */
;;;875        switch(RMP_THD_STATE(Thread->State))
;;;876        {
;;;877            case RMP_THD_RUNNING:
;;;878            {
;;;879                RMP_COVERAGE_MARKER();
;;;880                /* Clear ready if not suspended */
;;;881                _RMP_Clr_Rdy(Thread);
;;;882                break;
;;;883            }
;;;884            
;;;885            /* Do nothing if it is blocked on receive */
;;;886            case RMP_THD_RCVBLK:
;;;887            {
;;;888                RMP_COVERAGE_MARKER();
;;;889                break;
;;;890            }
;;;891            
;;;892            case RMP_THD_SNDBLK:RMP_COVERAGE_MARKER();
;;;893            case RMP_THD_SEMBLK:
;;;894            {
;;;895                RMP_COVERAGE_MARKER();
;;;896                RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;897                break;
;;;898            }
;;;899            
;;;900            case RMP_THD_SNDDLY:RMP_COVERAGE_MARKER();
;;;901            case RMP_THD_SEMDLY:
;;;902            {
;;;903                RMP_COVERAGE_MARKER();
;;;904                RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;905                /* Fall-through case */
;;;906            }
;;;907            case RMP_THD_RCVDLY:RMP_COVERAGE_MARKER();
;;;908            case RMP_THD_DELAYED:
;;;909            {
;;;910                RMP_COVERAGE_MARKER();
;;;911                RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;912                break;
;;;913            }
;;;914            /* Should not get here */
;;;915            default:while(1);
;;;916        }
;;;917        /* Set return value to failure anyway */
;;;918        Thread->Retval=RMP_ERR_OPER;
;;;919        Thread->State=RMP_THD_FREE;
;;;920        /* If we are deleting ourself, pend a yield */
;;;921        if(Thread==RMP_Cur_Thd)
;;;922        {
;;;923            RMP_COVERAGE_MARKER();
;;;924            RMP_Sched_Pend=1;
;;;925        }
;;;926        else
;;;927            RMP_COVERAGE_MARKER();
;;;928        
;;;929        RMP_Unlock_Sched();
;;;930        
;;;931        /* If we are deleting ourself, just stop the execution here */
;;;932        if(Thread==RMP_Cur_Thd)
;;;933            while(1);
;;;934        else
;;;935            RMP_COVERAGE_MARKER();
;;;936    
;;;937        return 0;
;;;938    }
000040  bdf8              POP      {r3-r7,pc}
                  |L27.66|
000042  f7fffffe          BL       RMP_Unlock_Sched
000046  4628              MOV      r0,r5                 ;850
000048  bdf8              POP      {r3-r7,pc}
                  |L27.74|
00004a  68e9              LDR      r1,[r5,#0xc]
00004c  68a8              LDR      r0,[r5,#8]
00004e  6008              STR      r0,[r1,#0]
000050  6041              STR      r1,[r0,#4]
                  |L27.82|
000052  69a8              LDR      r0,[r5,#0x18]         ;868
000054  0a00              LSRS     r0,r0,#8              ;868
000056  0200              LSLS     r0,r0,#8              ;868
000058  1c40              ADDS     r0,r0,#1              ;868
00005a  61a8              STR      r0,[r5,#0x18]         ;870
00005c  4628              MOV      r0,r5                 ;870
00005e  f7fffffe          BL       _RMP_Set_Rdy
000062  63af              STR      r7,[r5,#0x38]         ;871
000064  6960              LDR      r0,[r4,#0x14]         ;871
000066  42b0              CMP      r0,r6                 ;871
000068  d1e0              BNE      |L27.44|
                  |L27.106|
00006a  69a0              LDR      r0,[r4,#0x18]         ;875
00006c  b2c0              UXTB     r0,r0                 ;875
00006e  2809              CMP      r0,#9                 ;875
000070  d229              BCS      |L27.198|
000072  0001              MOVS     r1,r0                 ;875
000074  4479              ADD      r1,r1,pc              ;875
000076  7909              LDRB     r1,[r1,#4]            ;875
000078  1849              ADDS     r1,r1,r1              ;875
00007a  448f              ADD      pc,pc,r1              ;875
00007c  2404080d          DCB      0x24,0x04,0x08,0x0d
000080  15111108          DCB      0x15,0x11,0x11,0x08
000084  0d00              DCB      0x0d,0x00
000086  4620              MOV      r0,r4                 ;881
000088  f7fffffe          BL       _RMP_Clr_Rdy
00008c  e00c              B        |L27.168|
00008e  6820              LDR      r0,[r4,#0]            ;896
000090  6861              LDR      r1,[r4,#4]            ;896
000092  6008              STR      r0,[r1,#0]            ;896
000094  6041              STR      r1,[r0,#4]            ;896
000096  e007              B        |L27.168|
000098  6820              LDR      r0,[r4,#0]            ;904
00009a  6861              LDR      r1,[r4,#4]            ;904
00009c  6008              STR      r0,[r1,#0]            ;904
00009e  6041              STR      r1,[r0,#4]            ;904
0000a0  68a1              LDR      r1,[r4,#8]            ;911
0000a2  68e0              LDR      r0,[r4,#0xc]          ;911
0000a4  6001              STR      r1,[r0,#0]            ;911
0000a6  6048              STR      r0,[r1,#4]            ;911
                  |L27.168|
0000a8  63a7              STR      r7,[r4,#0x38]         ;918
0000aa  2000              MOVS     r0,#0                 ;919
0000ac  61a0              STR      r0,[r4,#0x18]         ;919
0000ae  4d08              LDR      r5,|L27.208|
0000b0  69a8              LDR      r0,[r5,#0x18]         ;921  ; RMP_Cur_Thd
0000b2  4284              CMP      r4,r0                 ;921
0000b4  d101              BNE      |L27.186|
0000b6  2001              MOVS     r0,#1                 ;924
0000b8  60e8              STR      r0,[r5,#0xc]          ;924  ; RMP_Sched_Pend
                  |L27.186|
0000ba  f7fffffe          BL       RMP_Unlock_Sched
0000be  69a8              LDR      r0,[r5,#0x18]         ;932  ; RMP_Cur_Thd
0000c0  4284              CMP      r4,r0                 ;932
0000c2  d101              BNE      |L27.200|
                  |L27.196|
0000c4  e7fe              B        |L27.196|
                  |L27.198|
0000c6  e7fe              B        |L27.198|
                  |L27.200|
0000c8  2000              MOVS     r0,#0                 ;937
0000ca  bdf8              POP      {r3-r7,pc}
;;;939    /* End Function:RMP_Thd_Del **************************************************/
                          ENDP

                  |L27.204|
                          DCD      0xffffffff
                  |L27.208|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Delay||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Delay PROC
;;;1483   ******************************************************************************/
;;;1484   rmp_ret_t RMP_Thd_Delay(rmp_ptr_t Slices)
000000  b570              PUSH     {r4-r6,lr}
;;;1485   {
000002  0005              MOVS     r5,r0
000004  d002              BEQ      |L28.12|
;;;1486       if((Slices==0)||(Slices>=RMP_MAX_SLICES))
000006  481b              LDR      r0,|L28.116|
000008  4285              CMP      r5,r0
00000a  d302              BCC      |L28.18|
                  |L28.12|
;;;1487       {
;;;1488           RMP_COVERAGE_MARKER();
;;;1489           return RMP_ERR_SLICE;
00000c  2002              MOVS     r0,#2
00000e  43c0              MVNS     r0,r0
;;;1490       }
;;;1491       else
;;;1492           RMP_COVERAGE_MARKER();
;;;1493       
;;;1494       RMP_Lock_Sched();
;;;1495   
;;;1496       /* We must be running and not suspended so we will be out of running queue */
;;;1497       _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1498       RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_DELAYED);
;;;1499       _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1500   
;;;1501       RMP_Cur_Thd->Retval=0;
;;;1502       RMP_Unlock_Sched();
;;;1503       /* Need to return if successful or not */
;;;1504       return RMP_Cur_Thd->Retval;
;;;1505   }
000010  bd70              POP      {r4-r6,pc}
                  |L28.18|
000012  f7fffffe          BL       RMP_Disable_Int
000016  4c18              LDR      r4,|L28.120|
000018  2001              MOVS     r0,#1
00001a  60a0              STR      r0,[r4,#8]  ; RMP_Sched_Locked
00001c  6860              LDR      r0,[r4,#4]  ; RMP_Sched_Lock_Cnt
00001e  1c40              ADDS     r0,r0,#1
000020  6060              STR      r0,[r4,#4]  ; RMP_Sched_Lock_Cnt
000022  69a0              LDR      r0,[r4,#0x18]         ;1497  ; RMP_Cur_Thd
000024  f7fffffe          BL       _RMP_Clr_Rdy
000028  69a0              LDR      r0,[r4,#0x18]         ;1498  ; RMP_Cur_Thd
00002a  69a1              LDR      r1,[r4,#0x18]         ;1498  ; RMP_Cur_Thd
00002c  6980              LDR      r0,[r0,#0x18]         ;1498
00002e  0a00              LSRS     r0,r0,#8              ;1498
000030  0200              LSLS     r0,r0,#8              ;1498
000032  1d80              ADDS     r0,r0,#6              ;1498
000034  6188              STR      r0,[r1,#0x18]         ;1499
000036  69a2              LDR      r2,[r4,#0x18]         ;1499  ; RMP_Cur_Thd
000038  4b10              LDR      r3,|L28.124|
00003a  6859              LDR      r1,[r3,#4]            ;1499  ; RMP_Delay
00003c  4299              CMP      r1,r3                 ;1499
00003e  d007              BEQ      |L28.80|
                  |L28.64|
000040  6a08              LDR      r0,[r1,#0x20]         ;1499
000042  6966              LDR      r6,[r4,#0x14]         ;1499  ; RMP_Tick
000044  1b80              SUBS     r0,r0,r6              ;1499
000046  42a8              CMP      r0,r5                 ;1499
000048  d802              BHI      |L28.80|
00004a  6849              LDR      r1,[r1,#4]            ;1499
00004c  4299              CMP      r1,r3                 ;1499
00004e  d1f7              BNE      |L28.64|
                  |L28.80|
000050  6960              LDR      r0,[r4,#0x14]         ;1499  ; RMP_Tick
000052  1940              ADDS     r0,r0,r5              ;1499
000054  6290              STR      r0,[r2,#0x28]         ;1499
000056  3208              ADDS     r2,r2,#8              ;1499
000058  6808              LDR      r0,[r1,#0]            ;1499
00005a  600a              STR      r2,[r1,#0]            ;1499
00005c  6051              STR      r1,[r2,#4]            ;1499
00005e  6010              STR      r0,[r2,#0]            ;1499
000060  6042              STR      r2,[r0,#4]            ;1499
000062  69a1              LDR      r1,[r4,#0x18]         ;1501  ; RMP_Cur_Thd
000064  2000              MOVS     r0,#0                 ;1501
000066  6388              STR      r0,[r1,#0x38]         ;1502
000068  f7fffffe          BL       RMP_Unlock_Sched
00006c  69a0              LDR      r0,[r4,#0x18]         ;1504  ; RMP_Cur_Thd
00006e  6b80              LDR      r0,[r0,#0x38]         ;1504
000070  bd70              POP      {r4-r6,pc}
;;;1506   /* End Function:RMP_Thd_Delay ************************************************/
                          ENDP

000072  0000              DCW      0x0000
                  |L28.116|
                          DCD      0x000186a0
                  |L28.120|
                          DCD      ||.data||
                  |L28.124|
                          DCD      ||.data||+0x20

                          AREA ||i.RMP_Thd_Rcv||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Rcv PROC
;;;1366   ******************************************************************************/
;;;1367   rmp_ret_t RMP_Thd_Rcv(rmp_ptr_t* Data, rmp_ptr_t Slices)
000000  2800              CMP      r0,#0
;;;1368   {
;;;1369       struct RMP_Thd* Sender;
;;;1370       
;;;1371       if(Data==0)
000002  d101              BNE      |L29.8|
;;;1372       {
;;;1373           RMP_COVERAGE_MARKER();
;;;1374           return RMP_ERR_OPER;
000004  1f40              SUBS     r0,r0,#5
;;;1375       }
;;;1376       else
;;;1377           RMP_COVERAGE_MARKER();
;;;1378       
;;;1379       RMP_Lock_Sched();
;;;1380       
;;;1381       /* Is there any other guy waiting on us? If there is, unblock it and set it running */
;;;1382       Sender=0;
;;;1383       if(&(RMP_Cur_Thd->Snd_List)!=RMP_Cur_Thd->Snd_List.Next)
;;;1384       {
;;;1385           RMP_COVERAGE_MARKER();
;;;1386           /* Read the data */
;;;1387           Sender=(struct RMP_Thd*)(RMP_Cur_Thd->Snd_List.Next);
;;;1388           RMP_List_Del(Sender->Run_Head.Prev,Sender->Run_Head.Next);
;;;1389           *Data=Sender->Data;
;;;1390           /* Now we unblock it - what state is it in? */
;;;1391           if((RMP_THD_STATE(Sender->State)==RMP_THD_SNDDLY))
;;;1392           {
;;;1393               RMP_COVERAGE_MARKER();
;;;1394               RMP_List_Del(Sender->Dly_Head.Prev,Sender->Dly_Head.Next);
;;;1395           }
;;;1396           else
;;;1397               RMP_COVERAGE_MARKER();
;;;1398           
;;;1399           RMP_THD_STATE_SET(Sender->State,RMP_THD_RUNNING);
;;;1400           /* Set to running if not suspended */
;;;1401           _RMP_Set_Rdy(Sender);
;;;1402       }
;;;1403   
;;;1404       /* Check if there is a value in our mailbox. If yes, we return with that value */
;;;1405       if((RMP_Cur_Thd->State&RMP_THD_MBOXFUL)!=0)
;;;1406       {
;;;1407           RMP_COVERAGE_MARKER();
;;;1408           /* Get the value from mailbox */
;;;1409           *Data=RMP_Cur_Thd->Mailbox;
;;;1410           /* See if we unblocked a sender. If yes, we place the new value into 
;;;1411            * our mailbox and it is still full */
;;;1412           if(Sender!=0)
;;;1413               RMP_Cur_Thd->Mailbox=Sender->Data;
;;;1414           else
;;;1415               RMP_Cur_Thd->State&=~RMP_THD_MBOXFUL;
;;;1416           
;;;1417           RMP_Unlock_Sched();
;;;1418           return 0;
;;;1419       }
;;;1420       else
;;;1421       {
;;;1422           RMP_COVERAGE_MARKER();
;;;1423           
;;;1424           /* Box empty. Do we have somebody waiting? */
;;;1425           if(Sender!=0)
;;;1426           {
;;;1427               RMP_COVERAGE_MARKER();
;;;1428               RMP_Cur_Thd->Mailbox=Sender->Data;
;;;1429               RMP_Unlock_Sched();
;;;1430               return 0;
;;;1431           }
;;;1432           /* No sender waiting on us and box empty, we need to block */
;;;1433           else
;;;1434           {
;;;1435               RMP_COVERAGE_MARKER();
;;;1436               
;;;1437               if(Slices==0)
;;;1438               {
;;;1439                   RMP_COVERAGE_MARKER();
;;;1440                   RMP_Unlock_Sched();
;;;1441                   return RMP_ERR_OPER;
;;;1442               }
;;;1443               else
;;;1444                   RMP_COVERAGE_MARKER();
;;;1445   
;;;1446               /* We must be running and not suspended so we will surely be deleted from queue */
;;;1447               _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1448   
;;;1449               if(Slices<RMP_MAX_SLICES)
;;;1450               {
;;;1451                   RMP_COVERAGE_MARKER();
;;;1452                   _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1453                   RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_RCVDLY);
;;;1454               }
;;;1455               else
;;;1456               {
;;;1457                   RMP_COVERAGE_MARKER();
;;;1458                   RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_RCVBLK);
;;;1459               }
;;;1460               RMP_Unlock_Sched();
;;;1461               
;;;1462               /* Dummy read - to separate the lock & unlock. If the compiler optimizes these two
;;;1463                * functions(inline them) on some architectures sometimes we never block. */
;;;1464               *Data=RMP_Cur_Thd->Mailbox;
;;;1465               
;;;1466               /* We've been unblocked. There must be something in our mbox, or we should have failed */
;;;1467               RMP_Lock_Sched();
;;;1468               *Data=RMP_Cur_Thd->Mailbox;
;;;1469               RMP_Cur_Thd->State&=~RMP_THD_MBOXFUL;
;;;1470           }
;;;1471       }
;;;1472       
;;;1473       RMP_Unlock_Sched();
;;;1474       return RMP_Cur_Thd->Retval;
;;;1475   }
000006  4770              BX       lr
                  |L29.8|
000008  b5f8              PUSH     {r3-r7,lr}            ;1368
00000a  460c              MOV      r4,r1                 ;1368
00000c  4606              MOV      r6,r0                 ;1368
00000e  f7fffffe          BL       RMP_Disable_Int
000012  4d47              LDR      r5,|L29.304|
000014  2001              MOVS     r0,#1                 ;1368
000016  60a8              STR      r0,[r5,#8]            ;1368  ; RMP_Sched_Locked
000018  6868              LDR      r0,[r5,#4]            ;1368  ; RMP_Sched_Lock_Cnt
00001a  1c40              ADDS     r0,r0,#1              ;1368
00001c  6068              STR      r0,[r5,#4]            ;1368  ; RMP_Sched_Lock_Cnt
00001e  69a8              LDR      r0,[r5,#0x18]         ;1383  ; RMP_Cur_Thd
000020  2700              MOVS     r7,#0                 ;1382
000022  6941              LDR      r1,[r0,#0x14]         ;1383
000024  69a8              LDR      r0,[r5,#0x18]         ;1383  ; RMP_Cur_Thd
000026  3010              ADDS     r0,r0,#0x10           ;1383
000028  4281              CMP      r1,r0                 ;1383
00002a  d016              BEQ      |L29.90|
00002c  69a8              LDR      r0,[r5,#0x18]         ;1387  ; RMP_Cur_Thd
00002e  6947              LDR      r7,[r0,#0x14]         ;1388
000030  6879              LDR      r1,[r7,#4]            ;1388
000032  6838              LDR      r0,[r7,#0]            ;1388
000034  6008              STR      r0,[r1,#0]            ;1388
000036  6041              STR      r1,[r0,#4]            ;1388
000038  6b38              LDR      r0,[r7,#0x30]         ;1389
00003a  6030              STR      r0,[r6,#0]            ;1391
00003c  7e38              LDRB     r0,[r7,#0x18]         ;1391
00003e  2803              CMP      r0,#3                 ;1391
000040  d103              BNE      |L29.74|
000042  68f9              LDR      r1,[r7,#0xc]          ;1391
000044  68b8              LDR      r0,[r7,#8]            ;1391
000046  6008              STR      r0,[r1,#0]            ;1391
000048  6041              STR      r1,[r0,#4]            ;1391
                  |L29.74|
00004a  69b8              LDR      r0,[r7,#0x18]         ;1399
00004c  0a00              LSRS     r0,r0,#8              ;1399
00004e  0200              LSLS     r0,r0,#8              ;1399
000050  1c40              ADDS     r0,r0,#1              ;1399
000052  61b8              STR      r0,[r7,#0x18]         ;1401
000054  4638              MOV      r0,r7                 ;1401
000056  f7fffffe          BL       _RMP_Set_Rdy
                  |L29.90|
00005a  69a8              LDR      r0,[r5,#0x18]         ;1405  ; RMP_Cur_Thd
00005c  8b00              LDRH     r0,[r0,#0x18]         ;1405
00005e  0580              LSLS     r0,r0,#22             ;1405
000060  d512              BPL      |L29.136|
000062  69a8              LDR      r0,[r5,#0x18]         ;1409  ; RMP_Cur_Thd
000064  2f00              CMP      r7,#0                 ;1412
000066  6ac0              LDR      r0,[r0,#0x2c]         ;1409
000068  6030              STR      r0,[r6,#0]            ;1412
00006a  d003              BEQ      |L29.116|
00006c  6b38              LDR      r0,[r7,#0x30]         ;1413
00006e  69a9              LDR      r1,[r5,#0x18]         ;1413  ; RMP_Cur_Thd
000070  62c8              STR      r0,[r1,#0x2c]         ;1413
000072  e005              B        |L29.128|
                  |L29.116|
000074  69a8              LDR      r0,[r5,#0x18]         ;1415  ; RMP_Cur_Thd
000076  2201              MOVS     r2,#1                 ;1415
000078  6981              LDR      r1,[r0,#0x18]         ;1415
00007a  0252              LSLS     r2,r2,#9              ;1415
00007c  4391              BICS     r1,r1,r2              ;1415
00007e  6181              STR      r1,[r0,#0x18]         ;1415
                  |L29.128|
000080  f7fffffe          BL       RMP_Unlock_Sched
000084  2000              MOVS     r0,#0                 ;1418
000086  bdf8              POP      {r3-r7,pc}
                  |L29.136|
000088  2f00              CMP      r7,#0                 ;1425
00008a  d006              BEQ      |L29.154|
00008c  6b38              LDR      r0,[r7,#0x30]         ;1428
00008e  69a9              LDR      r1,[r5,#0x18]         ;1428  ; RMP_Cur_Thd
000090  62c8              STR      r0,[r1,#0x2c]         ;1429
000092  f7fffffe          BL       RMP_Unlock_Sched
000096  2000              MOVS     r0,#0                 ;1430
000098  bdf8              POP      {r3-r7,pc}
                  |L29.154|
00009a  2c00              CMP      r4,#0                 ;1437
00009c  d03c              BEQ      |L29.280|
00009e  69a8              LDR      r0,[r5,#0x18]         ;1447  ; RMP_Cur_Thd
0000a0  f7fffffe          BL       _RMP_Clr_Rdy
0000a4  4823              LDR      r0,|L29.308|
0000a6  4284              CMP      r4,r0                 ;1449
0000a8  d23b              BCS      |L29.290|
0000aa  69ab              LDR      r3,[r5,#0x18]         ;1452  ; RMP_Cur_Thd
0000ac  4f22              LDR      r7,|L29.312|
0000ae  687a              LDR      r2,[r7,#4]            ;1452  ; RMP_Delay
0000b0  42ba              CMP      r2,r7                 ;1452
0000b2  d007              BEQ      |L29.196|
                  |L29.180|
0000b4  6a10              LDR      r0,[r2,#0x20]         ;1452
0000b6  6969              LDR      r1,[r5,#0x14]         ;1452  ; RMP_Tick
0000b8  1a40              SUBS     r0,r0,r1              ;1452
0000ba  42a0              CMP      r0,r4                 ;1452
0000bc  d802              BHI      |L29.196|
0000be  6852              LDR      r2,[r2,#4]            ;1452
0000c0  42ba              CMP      r2,r7                 ;1452
0000c2  d1f7              BNE      |L29.180|
                  |L29.196|
0000c4  6968              LDR      r0,[r5,#0x14]         ;1452  ; RMP_Tick
0000c6  1900              ADDS     r0,r0,r4              ;1452
0000c8  6298              STR      r0,[r3,#0x28]         ;1452
0000ca  3308              ADDS     r3,r3,#8              ;1452
0000cc  6810              LDR      r0,[r2,#0]            ;1452
0000ce  6013              STR      r3,[r2,#0]            ;1452
0000d0  605a              STR      r2,[r3,#4]            ;1452
0000d2  6018              STR      r0,[r3,#0]            ;1452
0000d4  6043              STR      r3,[r0,#4]            ;1452
0000d6  69a8              LDR      r0,[r5,#0x18]         ;1453  ; RMP_Cur_Thd
0000d8  69a9              LDR      r1,[r5,#0x18]         ;1453  ; RMP_Cur_Thd
0000da  6980              LDR      r0,[r0,#0x18]         ;1453
0000dc  0a00              LSRS     r0,r0,#8              ;1453
0000de  0200              LSLS     r0,r0,#8              ;1453
0000e0  1d40              ADDS     r0,r0,#5              ;1453
                  |L29.226|
0000e2  6188              STR      r0,[r1,#0x18]         ;1460
0000e4  f7fffffe          BL       RMP_Unlock_Sched
0000e8  69a8              LDR      r0,[r5,#0x18]         ;1464  ; RMP_Cur_Thd
0000ea  6ac0              LDR      r0,[r0,#0x2c]         ;1464
0000ec  6030              STR      r0,[r6,#0]            ;1464
0000ee  f7fffffe          BL       RMP_Disable_Int
0000f2  2001              MOVS     r0,#1                 ;1464
0000f4  60a8              STR      r0,[r5,#8]            ;1464  ; RMP_Sched_Locked
0000f6  6868              LDR      r0,[r5,#4]            ;1464  ; RMP_Sched_Lock_Cnt
0000f8  1c40              ADDS     r0,r0,#1              ;1464
0000fa  6068              STR      r0,[r5,#4]            ;1464  ; RMP_Sched_Lock_Cnt
0000fc  69a8              LDR      r0,[r5,#0x18]         ;1468  ; RMP_Cur_Thd
0000fe  6ac0              LDR      r0,[r0,#0x2c]         ;1468
000100  6030              STR      r0,[r6,#0]            ;1469
000102  69a8              LDR      r0,[r5,#0x18]         ;1469  ; RMP_Cur_Thd
000104  2101              MOVS     r1,#1                 ;1469
000106  6982              LDR      r2,[r0,#0x18]         ;1469
000108  0249              LSLS     r1,r1,#9              ;1469
00010a  438a              BICS     r2,r2,r1              ;1469
00010c  6182              STR      r2,[r0,#0x18]         ;1473
00010e  f7fffffe          BL       RMP_Unlock_Sched
000112  69a8              LDR      r0,[r5,#0x18]         ;1474  ; RMP_Cur_Thd
000114  6b80              LDR      r0,[r0,#0x38]         ;1474
000116  bdf8              POP      {r3-r7,pc}
                  |L29.280|
000118  f7fffffe          BL       RMP_Unlock_Sched
00011c  2004              MOVS     r0,#4                 ;1441
00011e  43c0              MVNS     r0,r0                 ;1441
000120  bdf8              POP      {r3-r7,pc}
                  |L29.290|
000122  69a8              LDR      r0,[r5,#0x18]         ;1458  ; RMP_Cur_Thd
000124  69a9              LDR      r1,[r5,#0x18]         ;1458  ; RMP_Cur_Thd
000126  6980              LDR      r0,[r0,#0x18]         ;1458
000128  0a00              LSRS     r0,r0,#8              ;1458
00012a  0200              LSLS     r0,r0,#8              ;1458
00012c  1d00              ADDS     r0,r0,#4              ;1458
00012e  e7d8              B        |L29.226|
;;;1476   /* End Function:RMP_Thd_Rcv **************************************************/
                          ENDP

                  |L29.304|
                          DCD      ||.data||
                  |L29.308|
                          DCD      0x000186a0
                  |L29.312|
                          DCD      ||.data||+0x20

                          AREA ||i.RMP_Thd_Resume||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Resume PROC
;;;1110   ******************************************************************************/
;;;1111   rmp_ret_t RMP_Thd_Resume(volatile struct RMP_Thd* Thread)
000000  b570              PUSH     {r4-r6,lr}
;;;1112   {
;;;1113       rmp_ret_t Retval;
;;;1114       
;;;1115       /* Check if this thread structure could possibly be in use */
;;;1116       if(Thread==0)
;;;1117       {
;;;1118           RMP_COVERAGE_MARKER();
;;;1119           return RMP_ERR_THD;
000002  4d16              LDR      r5,|L30.92|
000004  0004              MOVS     r4,r0                 ;1112
000006  d018              BEQ      |L30.58|
000008  f7fffffe          BL       RMP_Disable_Int
00000c  4814              LDR      r0,|L30.96|
00000e  2101              MOVS     r1,#1                 ;1112
000010  6081              STR      r1,[r0,#8]            ;1112  ; RMP_Sched_Locked
000012  6841              LDR      r1,[r0,#4]            ;1112  ; RMP_Sched_Lock_Cnt
000014  1c49              ADDS     r1,r1,#1              ;1112
000016  6041              STR      r1,[r0,#4]            ;1112  ; RMP_Sched_Lock_Cnt
;;;1120       }
;;;1121       else
;;;1122           RMP_COVERAGE_MARKER();
;;;1123   
;;;1124       RMP_Lock_Sched();
;;;1125       
;;;1126       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
000018  69a0              LDR      r0,[r4,#0x18]
00001a  0600              LSLS     r0,r0,#24
00001c  0e00              LSRS     r0,r0,#24
00001e  d00e              BEQ      |L30.62|
;;;1127       {
;;;1128           RMP_COVERAGE_MARKER();
;;;1129           RMP_Unlock_Sched();
;;;1130           return RMP_ERR_THD;
;;;1131       }
;;;1132       else
;;;1133           RMP_COVERAGE_MARKER();
;;;1134       
;;;1135       /* Check if the thread is suspended, if not, then throw an error */
;;;1136       if((Thread->State&RMP_THD_SUSPENDED)!=0)
000020  69a0              LDR      r0,[r4,#0x18]
000022  05c0              LSLS     r0,r0,#23
000024  d514              BPL      |L30.80|
;;;1137       {
;;;1138           RMP_COVERAGE_MARKER();
;;;1139           
;;;1140           /* Suspended */
;;;1141           Thread->State&=~RMP_THD_SUSPENDED;
000026  69a0              LDR      r0,[r4,#0x18]
000028  21ff              MOVS     r1,#0xff
00002a  3101              ADDS     r1,#1
00002c  4388              BICS     r0,r0,r1
00002e  61a0              STR      r0,[r4,#0x18]
;;;1142           /* Only when it is running will we put it back. It can't be suspended here, 
;;;1143            * so the set ready operation will surely put it back */
;;;1144           if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
000030  69a0              LDR      r0,[r4,#0x18]
000032  b2c0              UXTB     r0,r0
000034  2801              CMP      r0,#1
000036  d006              BEQ      |L30.70|
000038  e008              B        |L30.76|
                  |L30.58|
00003a  4628              MOV      r0,r5                 ;1119
;;;1145           {
;;;1146               RMP_COVERAGE_MARKER();
;;;1147               _RMP_Set_Rdy(Thread);
;;;1148           }
;;;1149           else
;;;1150               RMP_COVERAGE_MARKER();
;;;1151           
;;;1152           Retval=0;
;;;1153       }
;;;1154       else
;;;1155       {
;;;1156           RMP_COVERAGE_MARKER();
;;;1157           Retval=RMP_ERR_STATE;
;;;1158       }
;;;1159       
;;;1160       RMP_Unlock_Sched();
;;;1161   
;;;1162       return Retval;
;;;1163   }
00003c  bd70              POP      {r4-r6,pc}
                  |L30.62|
00003e  f7fffffe          BL       RMP_Unlock_Sched
000042  4628              MOV      r0,r5                 ;1130
000044  bd70              POP      {r4-r6,pc}
                  |L30.70|
000046  4620              MOV      r0,r4                 ;1147
000048  f7fffffe          BL       _RMP_Set_Rdy
                  |L30.76|
00004c  2400              MOVS     r4,#0                 ;1152
00004e  e001              B        |L30.84|
                  |L30.80|
000050  2403              MOVS     r4,#3                 ;1157
000052  43e4              MVNS     r4,r4                 ;1157
                  |L30.84|
000054  f7fffffe          BL       RMP_Unlock_Sched
000058  4620              MOV      r0,r4                 ;1162
00005a  bd70              POP      {r4-r6,pc}
;;;1164   /* End Function:RMP_Thd_Resume ***********************************************/
                          ENDP

                  |L30.92|
                          DCD      0xffffffff
                  |L30.96|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Set||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Set PROC
;;;950    ******************************************************************************/
;;;951    rmp_ret_t RMP_Thd_Set(volatile struct RMP_Thd* Thread, rmp_ptr_t Prio, rmp_ptr_t Slices)
000000  2a00              CMP      r2,#0
;;;952    {
;;;953        /* Check if the priority and timeslice range is correct */
;;;954        if(Slices==0)
000002  d101              BNE      |L31.8|
;;;955        {
;;;956            RMP_COVERAGE_MARKER();
;;;957            return RMP_ERR_SLICE;
000004  1ed0              SUBS     r0,r2,#3
;;;958        }
;;;959        else
;;;960            RMP_COVERAGE_MARKER();
;;;961        
;;;962        /* Check if this thread structure could possibly be in use */
;;;963        if(Thread==0)
;;;964        {
;;;965            RMP_COVERAGE_MARKER();
;;;966            return RMP_ERR_THD;
;;;967        }
;;;968        else
;;;969            RMP_COVERAGE_MARKER();
;;;970        
;;;971        RMP_Lock_Sched();
;;;972        
;;;973        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;974        {
;;;975            RMP_COVERAGE_MARKER();
;;;976            RMP_Unlock_Sched();
;;;977            return RMP_ERR_THD;
;;;978        }
;;;979        else
;;;980            RMP_COVERAGE_MARKER();
;;;981        
;;;982        /* See if the thread is in running state */
;;;983        if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
;;;984        {
;;;985            RMP_COVERAGE_MARKER();
;;;986            
;;;987            /* See if we are gonna change one of it or both */
;;;988            if(Prio<RMP_MAX_PREEMPT_PRIO)
;;;989            {
;;;990                RMP_COVERAGE_MARKER();
;;;991                if(Thread->Prio!=Prio)
;;;992                {
;;;993                    RMP_COVERAGE_MARKER();
;;;994                    /* It doesn't matter whether this is suspended or not. 
;;;995                     * If suspended, the operations will not be conducted. */
;;;996                    _RMP_Clr_Rdy(Thread);
;;;997                    Thread->Prio=Prio;
;;;998                    _RMP_Set_Rdy(Thread);
;;;999                }
;;;1000               else
;;;1001                   RMP_COVERAGE_MARKER();
;;;1002           }
;;;1003           else
;;;1004               RMP_COVERAGE_MARKER();
;;;1005           
;;;1006           if(Slices<RMP_MAX_SLICES)
;;;1007           {
;;;1008               RMP_COVERAGE_MARKER();
;;;1009               Thread->Slices=Slices;
;;;1010           }
;;;1011           else
;;;1012               RMP_COVERAGE_MARKER();
;;;1013       }
;;;1014       else
;;;1015       {
;;;1016           RMP_COVERAGE_MARKER();
;;;1017           
;;;1018           if(Prio<RMP_MAX_PREEMPT_PRIO)
;;;1019           {
;;;1020               RMP_COVERAGE_MARKER();
;;;1021               Thread->Prio=Prio;
;;;1022           }
;;;1023           else
;;;1024               RMP_COVERAGE_MARKER();
;;;1025           
;;;1026           if(Slices<RMP_MAX_SLICES)
;;;1027           {
;;;1028               RMP_COVERAGE_MARKER();
;;;1029               Thread->Slices=Slices;
;;;1030           }
;;;1031           else
;;;1032               RMP_COVERAGE_MARKER();
;;;1033       }
;;;1034       
;;;1035       RMP_Unlock_Sched();
;;;1036       return 0;
;;;1037   }
000006  4770              BX       lr
                  |L31.8|
000008  b5f8              PUSH     {r3-r7,lr}            ;952
00000a  4f1a              LDR      r7,|L31.116|
00000c  4615              MOV      r5,r2                 ;952
00000e  460e              MOV      r6,r1                 ;952
000010  0004              MOVS     r4,r0                 ;952
000012  d01a              BEQ      |L31.74|
000014  f7fffffe          BL       RMP_Disable_Int
000018  4817              LDR      r0,|L31.120|
00001a  2101              MOVS     r1,#1                 ;957
00001c  6081              STR      r1,[r0,#8]            ;957  ; RMP_Sched_Locked
00001e  6841              LDR      r1,[r0,#4]            ;957  ; RMP_Sched_Lock_Cnt
000020  1c49              ADDS     r1,r1,#1              ;957
000022  6041              STR      r1,[r0,#4]            ;957  ; RMP_Sched_Lock_Cnt
000024  69a0              LDR      r0,[r4,#0x18]         ;973
000026  0600              LSLS     r0,r0,#24             ;973
000028  0e00              LSRS     r0,r0,#24             ;973
00002a  d010              BEQ      |L31.78|
00002c  69a0              LDR      r0,[r4,#0x18]         ;983
00002e  4f13              LDR      r7,|L31.124|
000030  b2c0              UXTB     r0,r0                 ;983
000032  2801              CMP      r0,#1                 ;983
000034  d00f              BEQ      |L31.86|
000036  2e20              CMP      r6,#0x20              ;1018
000038  d200              BCS      |L31.60|
00003a  6266              STR      r6,[r4,#0x24]         ;1021
                  |L31.60|
00003c  42bd              CMP      r5,r7                 ;1026
00003e  d200              BCS      |L31.66|
                  |L31.64|
000040  61e5              STR      r5,[r4,#0x1c]         ;1029
                  |L31.66|
000042  f7fffffe          BL       RMP_Unlock_Sched
000046  2000              MOVS     r0,#0                 ;1036
000048  bdf8              POP      {r3-r7,pc}
                  |L31.74|
00004a  4638              MOV      r0,r7                 ;966
00004c  bdf8              POP      {r3-r7,pc}
                  |L31.78|
00004e  f7fffffe          BL       RMP_Unlock_Sched
000052  4638              MOV      r0,r7                 ;977
000054  bdf8              POP      {r3-r7,pc}
                  |L31.86|
000056  2e20              CMP      r6,#0x20              ;988
000058  d209              BCS      |L31.110|
00005a  6a60              LDR      r0,[r4,#0x24]         ;991
00005c  42b0              CMP      r0,r6                 ;991
00005e  d006              BEQ      |L31.110|
000060  4620              MOV      r0,r4                 ;996
000062  f7fffffe          BL       _RMP_Clr_Rdy
000066  6266              STR      r6,[r4,#0x24]         ;997
000068  4620              MOV      r0,r4                 ;998
00006a  f7fffffe          BL       _RMP_Set_Rdy
                  |L31.110|
00006e  42bd              CMP      r5,r7                 ;1006
000070  d3e6              BCC      |L31.64|
000072  e7e6              B        |L31.66|
;;;1038   /* End Function:RMP_Thd_Set **************************************************/
                          ENDP

                  |L31.116|
                          DCD      0xffffffff
                  |L31.120|
                          DCD      ||.data||
                  |L31.124|
                          DCD      0x000186a0

                          AREA ||i.RMP_Thd_Snd||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Snd PROC
;;;1174   ******************************************************************************/
;;;1175   rmp_ret_t RMP_Thd_Snd(volatile struct RMP_Thd* Thread, rmp_ptr_t Data, rmp_ptr_t Slices)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1176   {
;;;1177       /* Check if this thread structure could possibly be in use */
;;;1178       if(Thread==0)
;;;1179       {
;;;1180           RMP_COVERAGE_MARKER();
;;;1181           return RMP_ERR_THD;
000002  4d3f              LDR      r5,|L32.256|
000004  4614              MOV      r4,r2                 ;1176
000006  460e              MOV      r6,r1                 ;1176
000008  0007              MOVS     r7,r0                 ;1176
00000a  d044              BEQ      |L32.150|
00000c  f7fffffe          BL       RMP_Disable_Int
000010  483c              LDR      r0,|L32.260|
000012  2101              MOVS     r1,#1                 ;1176
000014  6081              STR      r1,[r0,#8]            ;1176  ; RMP_Sched_Locked
000016  6841              LDR      r1,[r0,#4]            ;1176  ; RMP_Sched_Lock_Cnt
000018  1c49              ADDS     r1,r1,#1              ;1176
00001a  6041              STR      r1,[r0,#4]            ;1176  ; RMP_Sched_Lock_Cnt
;;;1182       }
;;;1183       else
;;;1184           RMP_COVERAGE_MARKER();
;;;1185       
;;;1186       RMP_Lock_Sched();
;;;1187       
;;;1188       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
00001c  69b9              LDR      r1,[r7,#0x18]
00001e  0609              LSLS     r1,r1,#24
000020  0e09              LSRS     r1,r1,#24
000022  d03a              BEQ      |L32.154|
;;;1189       {
;;;1190           RMP_COVERAGE_MARKER();
;;;1191           RMP_Unlock_Sched();
;;;1192           return RMP_ERR_THD;
;;;1193       }
;;;1194       else
;;;1195           RMP_COVERAGE_MARKER();
;;;1196       
;;;1197       /* Are we sending to ourself? This is not allowed */
;;;1198       if(RMP_Cur_Thd==Thread)
000024  6981              LDR      r1,[r0,#0x18]  ; RMP_Cur_Thd
000026  42b9              CMP      r1,r7
000028  d03b              BEQ      |L32.162|
;;;1199       {
;;;1200           RMP_COVERAGE_MARKER();
;;;1201           RMP_Unlock_Sched();
;;;1202           return RMP_ERR_OPER;
;;;1203       }
;;;1204       else
;;;1205           RMP_COVERAGE_MARKER();
;;;1206       
;;;1207       RMP_Cur_Thd->Retval=0;
00002a  4605              MOV      r5,r0
00002c  6980              LDR      r0,[r0,#0x18]  ; RMP_Cur_Thd
00002e  2100              MOVS     r1,#0
;;;1208   
;;;1209       /* See if there is already a value in the mailbox, if yes, we block */
;;;1210       if((Thread->State&RMP_THD_MBOXFUL)!=0)
000030  6381              STR      r1,[r0,#0x38]
000032  69b8              LDR      r0,[r7,#0x18]
000034  0580              LSLS     r0,r0,#22
000036  d540              BPL      |L32.186|
;;;1211       {
;;;1212           RMP_COVERAGE_MARKER();
;;;1213           
;;;1214           /* Mailbox full, we block, and put ourself into the queue */
;;;1215           if(Slices==0)
000038  2c00              CMP      r4,#0
00003a  d032              BEQ      |L32.162|
;;;1216           {
;;;1217               RMP_COVERAGE_MARKER();
;;;1218               RMP_Unlock_Sched();
;;;1219               return RMP_ERR_OPER;
;;;1220           }
;;;1221           else
;;;1222               RMP_COVERAGE_MARKER();
;;;1223   
;;;1224           /* We must be running */
;;;1225           _RMP_Clr_Rdy(RMP_Cur_Thd);
00003c  69a8              LDR      r0,[r5,#0x18]  ; RMP_Cur_Thd
00003e  f7fffffe          BL       _RMP_Clr_Rdy
;;;1226           RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),Thread->Snd_List.Prev,&(Thread->Snd_List));
000042  69a8              LDR      r0,[r5,#0x18]  ; RMP_Cur_Thd
000044  6939              LDR      r1,[r7,#0x10]
000046  6138              STR      r0,[r7,#0x10]
000048  3710              ADDS     r7,r7,#0x10
00004a  6047              STR      r7,[r0,#4]
00004c  6001              STR      r1,[r0,#0]
00004e  6048              STR      r0,[r1,#4]
;;;1227   
;;;1228           if(Slices<RMP_MAX_SLICES)
000050  482d              LDR      r0,|L32.264|
000052  4284              CMP      r4,r0
000054  d22a              BCS      |L32.172|
;;;1229           {
;;;1230               RMP_COVERAGE_MARKER();
;;;1231               _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
000056  69ab              LDR      r3,[r5,#0x18]  ; RMP_Cur_Thd
000058  4f2c              LDR      r7,|L32.268|
00005a  6878              LDR      r0,[r7,#4]  ; RMP_Delay
00005c  42b8              CMP      r0,r7
00005e  d007              BEQ      |L32.112|
                  |L32.96|
000060  6a01              LDR      r1,[r0,#0x20]
000062  696a              LDR      r2,[r5,#0x14]  ; RMP_Tick
000064  1a89              SUBS     r1,r1,r2
000066  42a1              CMP      r1,r4
000068  d802              BHI      |L32.112|
00006a  6840              LDR      r0,[r0,#4]
00006c  42b8              CMP      r0,r7
00006e  d1f7              BNE      |L32.96|
                  |L32.112|
000070  6969              LDR      r1,[r5,#0x14]  ; RMP_Tick
000072  1909              ADDS     r1,r1,r4
000074  6299              STR      r1,[r3,#0x28]
000076  3308              ADDS     r3,r3,#8
000078  6801              LDR      r1,[r0,#0]
00007a  6003              STR      r3,[r0,#0]
00007c  6058              STR      r0,[r3,#4]
00007e  6019              STR      r1,[r3,#0]
000080  604b              STR      r3,[r1,#4]
;;;1232               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SNDDLY);
000082  69a8              LDR      r0,[r5,#0x18]  ; RMP_Cur_Thd
000084  69a9              LDR      r1,[r5,#0x18]  ; RMP_Cur_Thd
000086  6980              LDR      r0,[r0,#0x18]
000088  0a00              LSRS     r0,r0,#8
00008a  0200              LSLS     r0,r0,#8
00008c  1cc0              ADDS     r0,r0,#3
                  |L32.142|
;;;1233           }
;;;1234           else
;;;1235           {
;;;1236               RMP_COVERAGE_MARKER();
;;;1237               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SNDBLK);
;;;1238           }
;;;1239   
;;;1240           RMP_Cur_Thd->Data=Data;
00008e  6188              STR      r0,[r1,#0x18]
000090  69a8              LDR      r0,[r5,#0x18]  ; RMP_Cur_Thd
000092  6306              STR      r6,[r0,#0x30]
000094  e02f              B        |L32.246|
                  |L32.150|
000096  4628              MOV      r0,r5                 ;1181
;;;1241       }
;;;1242       else
;;;1243       {
;;;1244           RMP_COVERAGE_MARKER();
;;;1245           
;;;1246           /* Mailbox not full. We need to check if the receiver is waiting for us */
;;;1247           if((RMP_THD_STATE(Thread->State)==RMP_THD_RCVBLK)||
;;;1248              (RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY))
;;;1249           {
;;;1250               RMP_COVERAGE_MARKER();
;;;1251               
;;;1252               /* The receiver is blocked, wake it up and return the value */
;;;1253               if(RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY)
;;;1254               {
;;;1255                   RMP_COVERAGE_MARKER();
;;;1256                   RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1257               }
;;;1258               else
;;;1259                   RMP_COVERAGE_MARKER();
;;;1260               
;;;1261               RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1262               /* Set to running if not suspended */
;;;1263               _RMP_Set_Rdy(Thread);
;;;1264           }
;;;1265           else
;;;1266               RMP_COVERAGE_MARKER();
;;;1267           
;;;1268           /* Set the mailbox */
;;;1269           Thread->Mailbox=Data;
;;;1270           Thread->State|=RMP_THD_MBOXFUL;
;;;1271       }
;;;1272       
;;;1273       RMP_Unlock_Sched();
;;;1274   
;;;1275       return RMP_Cur_Thd->Retval;
;;;1276   }
000098  bdf8              POP      {r3-r7,pc}
                  |L32.154|
00009a  f7fffffe          BL       RMP_Unlock_Sched
00009e  4628              MOV      r0,r5                 ;1192
0000a0  bdf8              POP      {r3-r7,pc}
                  |L32.162|
0000a2  f7fffffe          BL       RMP_Unlock_Sched
0000a6  2004              MOVS     r0,#4                 ;1219
0000a8  43c0              MVNS     r0,r0                 ;1219
0000aa  bdf8              POP      {r3-r7,pc}
                  |L32.172|
0000ac  69a8              LDR      r0,[r5,#0x18]         ;1237  ; RMP_Cur_Thd
0000ae  69a9              LDR      r1,[r5,#0x18]         ;1237  ; RMP_Cur_Thd
0000b0  6980              LDR      r0,[r0,#0x18]         ;1237
0000b2  0a00              LSRS     r0,r0,#8              ;1237
0000b4  0200              LSLS     r0,r0,#8              ;1237
0000b6  1c80              ADDS     r0,r0,#2              ;1237
0000b8  e7e9              B        |L32.142|
                  |L32.186|
0000ba  69b8              LDR      r0,[r7,#0x18]         ;1247
0000bc  b2c0              UXTB     r0,r0                 ;1247
0000be  2804              CMP      r0,#4                 ;1247
0000c0  d003              BEQ      |L32.202|
0000c2  69b8              LDR      r0,[r7,#0x18]         ;1247
0000c4  b2c0              UXTB     r0,r0                 ;1247
0000c6  2805              CMP      r0,#5                 ;1247
0000c8  d10f              BNE      |L32.234|
                  |L32.202|
0000ca  69b8              LDR      r0,[r7,#0x18]         ;1253
0000cc  b2c0              UXTB     r0,r0                 ;1253
0000ce  2805              CMP      r0,#5                 ;1253
0000d0  d103              BNE      |L32.218|
0000d2  68b9              LDR      r1,[r7,#8]            ;1256
0000d4  68f8              LDR      r0,[r7,#0xc]          ;1256
0000d6  6001              STR      r1,[r0,#0]            ;1256
0000d8  6048              STR      r0,[r1,#4]            ;1256
                  |L32.218|
0000da  69b8              LDR      r0,[r7,#0x18]         ;1261
0000dc  0a00              LSRS     r0,r0,#8              ;1261
0000de  0200              LSLS     r0,r0,#8              ;1261
0000e0  1c40              ADDS     r0,r0,#1              ;1261
0000e2  61b8              STR      r0,[r7,#0x18]         ;1261
0000e4  4638              MOV      r0,r7                 ;1263
0000e6  f7fffffe          BL       _RMP_Set_Rdy
                  |L32.234|
0000ea  62fe              STR      r6,[r7,#0x2c]         ;1269
0000ec  69b8              LDR      r0,[r7,#0x18]         ;1270
0000ee  2101              MOVS     r1,#1                 ;1270
0000f0  0249              LSLS     r1,r1,#9              ;1270
0000f2  4308              ORRS     r0,r0,r1              ;1270
0000f4  61b8              STR      r0,[r7,#0x18]         ;1270
                  |L32.246|
0000f6  f7fffffe          BL       RMP_Unlock_Sched
0000fa  69a8              LDR      r0,[r5,#0x18]         ;1275  ; RMP_Cur_Thd
0000fc  6b80              LDR      r0,[r0,#0x38]         ;1275
0000fe  bdf8              POP      {r3-r7,pc}
;;;1277   /* End Function:RMP_Thd_Snd **************************************************/
                          ENDP

                  |L32.256|
                          DCD      0xffffffff
                  |L32.260|
                          DCD      ||.data||
                  |L32.264|
                          DCD      0x000186a0
                  |L32.268|
                          DCD      ||.data||+0x20

                          AREA ||i.RMP_Thd_Snd_ISR||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Snd_ISR PROC
;;;1289   ******************************************************************************/
;;;1290   rmp_ret_t RMP_Thd_Snd_ISR(volatile struct RMP_Thd* Thread, rmp_ptr_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;1291   {
000002  0004              MOVS     r4,r0
;;;1292       /* Check if this thread structure could possibly be in use */
;;;1293       if(Thread==0)
;;;1294       {
;;;1295           RMP_COVERAGE_MARKER();
;;;1296           return RMP_ERR_THD;
000004  481a              LDR      r0,|L33.112|
000006  460d              MOV      r5,r1                 ;1291
000008  d008              BEQ      |L33.28|
;;;1297       }
;;;1298       else
;;;1299           RMP_COVERAGE_MARKER();
;;;1300       
;;;1301       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
00000a  69a1              LDR      r1,[r4,#0x18]
00000c  0609              LSLS     r1,r1,#24
00000e  0e09              LSRS     r1,r1,#24
000010  d004              BEQ      |L33.28|
;;;1302       {
;;;1303           RMP_COVERAGE_MARKER();
;;;1304           return RMP_ERR_THD;
;;;1305       }
;;;1306       else
;;;1307           RMP_COVERAGE_MARKER();
;;;1308   
;;;1309       /* See if there is already a value in the mailbox, if yes, we abort */
;;;1310       if((Thread->State&RMP_THD_MBOXFUL)!=0)
000012  69a0              LDR      r0,[r4,#0x18]
000014  0580              LSLS     r0,r0,#22
000016  d502              BPL      |L33.30|
;;;1311       {
;;;1312           RMP_COVERAGE_MARKER();
;;;1313           return RMP_ERR_OPER;
000018  2004              MOVS     r0,#4
00001a  43c0              MVNS     r0,r0
                  |L33.28|
;;;1314       }
;;;1315       else
;;;1316       {
;;;1317           RMP_COVERAGE_MARKER();
;;;1318           
;;;1319           /* Mailbox not full. We need to check if the receiver is waiting for us */
;;;1320           if((RMP_THD_STATE(Thread->State)==RMP_THD_RCVBLK)||
;;;1321              (RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY))
;;;1322           {
;;;1323               RMP_COVERAGE_MARKER();
;;;1324   
;;;1325               /* The receiver is blocked, wake it up and return the value */
;;;1326               if(RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY)
;;;1327               {
;;;1328                   RMP_COVERAGE_MARKER();
;;;1329                   RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1330               }
;;;1331               else
;;;1332                   RMP_COVERAGE_MARKER();
;;;1333               
;;;1334               RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1335   
;;;1336               /* Set to running if not suspended */
;;;1337               _RMP_Set_Rdy(Thread);
;;;1338   
;;;1339               /* If schedule pending, trigger it now because we are in ISR */
;;;1340               if(RMP_Sched_Pend!=0)
;;;1341               {
;;;1342                   RMP_COVERAGE_MARKER();
;;;1343                   RMP_Sched_Pend=0;
;;;1344                   _RMP_Yield();
;;;1345               }
;;;1346               else
;;;1347                   RMP_COVERAGE_MARKER();
;;;1348           }
;;;1349           else
;;;1350               RMP_COVERAGE_MARKER();
;;;1351           
;;;1352           /* Set the mailbox */
;;;1353           Thread->Mailbox=Data;
;;;1354           Thread->State|=RMP_THD_MBOXFUL;
;;;1355       }
;;;1356   
;;;1357       return 0;
;;;1358   }
00001c  bd70              POP      {r4-r6,pc}
                  |L33.30|
00001e  69a0              LDR      r0,[r4,#0x18]         ;1320
000020  b2c0              UXTB     r0,r0                 ;1320
000022  2804              CMP      r0,#4                 ;1320
000024  d003              BEQ      |L33.46|
000026  69a0              LDR      r0,[r4,#0x18]         ;1320
000028  b2c0              UXTB     r0,r0                 ;1320
00002a  2805              CMP      r0,#5                 ;1320
00002c  d117              BNE      |L33.94|
                  |L33.46|
00002e  69a0              LDR      r0,[r4,#0x18]         ;1326
000030  b2c0              UXTB     r0,r0                 ;1326
000032  2805              CMP      r0,#5                 ;1326
000034  d103              BNE      |L33.62|
000036  68a2              LDR      r2,[r4,#8]            ;1329
000038  68e0              LDR      r0,[r4,#0xc]          ;1329
00003a  6002              STR      r2,[r0,#0]            ;1329
00003c  6050              STR      r0,[r2,#4]            ;1329
                  |L33.62|
00003e  69a0              LDR      r0,[r4,#0x18]         ;1334
000040  0a00              LSRS     r0,r0,#8              ;1334
000042  0200              LSLS     r0,r0,#8              ;1334
000044  1c40              ADDS     r0,r0,#1              ;1334
000046  61a0              STR      r0,[r4,#0x18]         ;1334
000048  4620              MOV      r0,r4                 ;1337
00004a  f7fffffe          BL       _RMP_Set_Rdy
00004e  4809              LDR      r0,|L33.116|
000050  68c1              LDR      r1,[r0,#0xc]          ;1340  ; RMP_Sched_Pend
000052  2900              CMP      r1,#0                 ;1340
000054  d003              BEQ      |L33.94|
000056  2100              MOVS     r1,#0                 ;1343
000058  60c1              STR      r1,[r0,#0xc]          ;1343  ; RMP_Sched_Pend
00005a  f7fffffe          BL       _RMP_Yield
                  |L33.94|
00005e  62e5              STR      r5,[r4,#0x2c]         ;1353
000060  69a0              LDR      r0,[r4,#0x18]         ;1354
000062  2101              MOVS     r1,#1                 ;1354
000064  0249              LSLS     r1,r1,#9              ;1354
000066  4308              ORRS     r0,r0,r1              ;1354
000068  61a0              STR      r0,[r4,#0x18]         ;1354
00006a  2000              MOVS     r0,#0                 ;1357
00006c  bd70              POP      {r4-r6,pc}
;;;1359   /* End Function:RMP_Thd_Snd_ISR **********************************************/
                          ENDP

00006e  0000              DCW      0x0000
                  |L33.112|
                          DCD      0xffffffff
                  |L33.116|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Suspend||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Suspend PROC
;;;1045   ******************************************************************************/
;;;1046   rmp_ret_t RMP_Thd_Suspend(volatile struct RMP_Thd* Thread)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1047   {
;;;1048       /* Check if this thread structure could possibly be in use */
;;;1049       if(Thread==0)
;;;1050       {
;;;1051           RMP_COVERAGE_MARKER();
;;;1052           return RMP_ERR_THD;
000002  4f18              LDR      r7,|L34.100|
000004  0004              MOVS     r4,r0                 ;1047
000006  d012              BEQ      |L34.46|
000008  f7fffffe          BL       RMP_Disable_Int
00000c  4d16              LDR      r5,|L34.104|
00000e  2601              MOVS     r6,#1                 ;1047
000010  60ae              STR      r6,[r5,#8]            ;1047  ; RMP_Sched_Locked
000012  6868              LDR      r0,[r5,#4]            ;1047  ; RMP_Sched_Lock_Cnt
000014  1c40              ADDS     r0,r0,#1              ;1047
000016  6068              STR      r0,[r5,#4]            ;1047  ; RMP_Sched_Lock_Cnt
;;;1053       }
;;;1054       else
;;;1055           RMP_COVERAGE_MARKER();
;;;1056       
;;;1057       RMP_Lock_Sched();
;;;1058       
;;;1059       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
000018  69a0              LDR      r0,[r4,#0x18]
00001a  0600              LSLS     r0,r0,#24
00001c  0e00              LSRS     r0,r0,#24
00001e  d008              BEQ      |L34.50|
;;;1060       {
;;;1061           RMP_COVERAGE_MARKER();
;;;1062           RMP_Unlock_Sched();
;;;1063           return RMP_ERR_THD;
;;;1064       }
;;;1065       else
;;;1066           RMP_COVERAGE_MARKER();
;;;1067       
;;;1068       /* Suspend it */
;;;1069       if((Thread->State&RMP_THD_SUSPENDED)!=0)
000020  69a0              LDR      r0,[r4,#0x18]
000022  05c0              LSLS     r0,r0,#23
000024  d509              BPL      |L34.58|
;;;1070       {
;;;1071           RMP_COVERAGE_MARKER();
;;;1072           RMP_Unlock_Sched();
000026  f7fffffe          BL       RMP_Unlock_Sched
;;;1073           return RMP_ERR_STATE;
00002a  1f70              SUBS     r0,r6,#5
;;;1074       }
;;;1075       else
;;;1076           RMP_COVERAGE_MARKER();
;;;1077       
;;;1078       /* Only when it is running do we clear this. If we are clearing this, it is not
;;;1079        * suspended, so the running queue removal is guaranteed to succceed */
;;;1080       if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
;;;1081       {
;;;1082           RMP_COVERAGE_MARKER();
;;;1083           _RMP_Clr_Rdy(Thread);
;;;1084       }
;;;1085       else
;;;1086           RMP_COVERAGE_MARKER();
;;;1087       
;;;1088       /* Mark this as suspended */
;;;1089       Thread->State|=RMP_THD_SUSPENDED;
;;;1090       
;;;1091       /* If we are suspending ourself, pend a yield */
;;;1092       if(Thread==RMP_Cur_Thd)
;;;1093       {
;;;1094           RMP_COVERAGE_MARKER();
;;;1095           RMP_Sched_Pend=1;
;;;1096       }
;;;1097       else
;;;1098           RMP_COVERAGE_MARKER();
;;;1099       
;;;1100       RMP_Unlock_Sched();
;;;1101       return 0;
;;;1102   }
00002c  bdf8              POP      {r3-r7,pc}
                  |L34.46|
00002e  4638              MOV      r0,r7                 ;1052
000030  bdf8              POP      {r3-r7,pc}
                  |L34.50|
000032  f7fffffe          BL       RMP_Unlock_Sched
000036  4638              MOV      r0,r7                 ;1063
000038  bdf8              POP      {r3-r7,pc}
                  |L34.58|
00003a  69a0              LDR      r0,[r4,#0x18]         ;1080
00003c  b2c0              UXTB     r0,r0                 ;1080
00003e  2801              CMP      r0,#1                 ;1080
000040  d102              BNE      |L34.72|
000042  4620              MOV      r0,r4                 ;1083
000044  f7fffffe          BL       _RMP_Clr_Rdy
                  |L34.72|
000048  69a0              LDR      r0,[r4,#0x18]         ;1089
00004a  21ff              MOVS     r1,#0xff              ;1089
00004c  3101              ADDS     r1,#1                 ;1089
00004e  4308              ORRS     r0,r0,r1              ;1089
000050  61a0              STR      r0,[r4,#0x18]         ;1089
000052  69a8              LDR      r0,[r5,#0x18]         ;1092  ; RMP_Cur_Thd
000054  4284              CMP      r4,r0                 ;1092
000056  d100              BNE      |L34.90|
000058  60ee              STR      r6,[r5,#0xc]          ;1095  ; RMP_Sched_Pend
                  |L34.90|
00005a  f7fffffe          BL       RMP_Unlock_Sched
00005e  2000              MOVS     r0,#0                 ;1101
000060  bdf8              POP      {r3-r7,pc}
;;;1103   /* End Function:RMP_Thd_Suspend **********************************************/
                          ENDP

000062  0000              DCW      0x0000
                  |L34.100|
                          DCD      0xffffffff
                  |L34.104|
                          DCD      ||.data||

                          AREA ||i.RMP_Unlock_Sched||, CODE, READONLY, ALIGN=2

                  RMP_Unlock_Sched PROC
;;;374    ******************************************************************************/
;;;375    void RMP_Unlock_Sched(void)
000000  b510              PUSH     {r4,lr}
;;;376    {
;;;377        if(RMP_Sched_Lock_Cnt==1)
000002  480c              LDR      r0,|L35.52|
000004  6841              LDR      r1,[r0,#4]  ; RMP_Sched_Lock_Cnt
000006  2901              CMP      r1,#1
000008  d006              BEQ      |L35.24|
;;;378        {
;;;379            RMP_COVERAGE_MARKER();
;;;380            /* Clear the count before enabling */
;;;381            RMP_Sched_Lock_Cnt=0;
;;;382            RMP_Sched_Locked=0;
;;;383            /* Now see if the scheduler scheduling action is pended in the lock-unlock 
;;;384             * period. If yes, perform a schedule now */
;;;385            if(RMP_Sched_Pend!=0)
;;;386            {
;;;387                RMP_COVERAGE_MARKER();
;;;388                /* Reset the count and trigger the context switch */
;;;389                RMP_Sched_Pend=0;
;;;390                _RMP_Yield();
;;;391            }
;;;392            else
;;;393                RMP_COVERAGE_MARKER();
;;;394            
;;;395            RMP_UNMASK_INT();
;;;396        }
;;;397        else if(RMP_Sched_Lock_Cnt>1)
00000a  6841              LDR      r1,[r0,#4]  ; RMP_Sched_Lock_Cnt
00000c  2901              CMP      r1,#1
00000e  d90f              BLS      |L35.48|
;;;398        {
;;;399            RMP_COVERAGE_MARKER();
;;;400            RMP_Sched_Lock_Cnt--;
000010  6841              LDR      r1,[r0,#4]  ; RMP_Sched_Lock_Cnt
000012  1e49              SUBS     r1,r1,#1
000014  6041              STR      r1,[r0,#4]  ; RMP_Sched_Lock_Cnt
;;;401        }
;;;402        /* Trying to unlock a scheduler that is not locked - should never happen */
;;;403        else
;;;404            while(1);
;;;405    }
000016  bd10              POP      {r4,pc}
                  |L35.24|
000018  2100              MOVS     r1,#0                 ;381
00001a  6041              STR      r1,[r0,#4]            ;381  ; RMP_Sched_Lock_Cnt
00001c  6081              STR      r1,[r0,#8]            ;382  ; RMP_Sched_Locked
00001e  68c2              LDR      r2,[r0,#0xc]          ;385  ; RMP_Sched_Pend
000020  2a00              CMP      r2,#0                 ;385
000022  d002              BEQ      |L35.42|
000024  60c1              STR      r1,[r0,#0xc]          ;389  ; RMP_Sched_Pend
000026  f7fffffe          BL       _RMP_Yield
                  |L35.42|
00002a  f7fffffe          BL       RMP_Enable_Int
00002e  bd10              POP      {r4,pc}
                  |L35.48|
000030  e7fe              B        |L35.48|
;;;406    /* End Function:RMP_Unlock_Sched *********************************************/
                          ENDP

000032  0000              DCW      0x0000
                  |L35.52|
                          DCD      ||.data||

                          AREA ||i.RMP_Yield||, CODE, READONLY, ALIGN=2

                  RMP_Yield PROC
;;;413    ******************************************************************************/
;;;414    void RMP_Yield(void)
000000  b510              PUSH     {r4,lr}
;;;415    {
;;;416        if(RMP_Sched_Locked==0)
000002  4805              LDR      r0,|L36.24|
000004  6881              LDR      r1,[r0,#8]  ; RMP_Sched_Locked
000006  2900              CMP      r1,#0
000008  d002              BEQ      |L36.16|
;;;417        {
;;;418            RMP_COVERAGE_MARKER();
;;;419            /* Now see if the scheduler scheduling action is pended in the lock-unlock 
;;;420             * period. If yes, perform a schedule now */
;;;421            _RMP_Yield();
;;;422        }
;;;423        else
;;;424        {
;;;425            RMP_COVERAGE_MARKER();
;;;426            RMP_Sched_Pend=1;
00000a  2101              MOVS     r1,#1
00000c  60c1              STR      r1,[r0,#0xc]  ; RMP_Sched_Pend
;;;427        }
;;;428    }
00000e  bd10              POP      {r4,pc}
                  |L36.16|
000010  f7fffffe          BL       _RMP_Yield
000014  bd10              POP      {r4,pc}
;;;429    /* End Function:RMP_Yield ****************************************************/
                          ENDP

000016  0000              DCW      0x0000
                  |L36.24|
                          DCD      ||.data||

                          AREA ||i._RMP_Clr_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Clr_Rdy PROC
;;;685    ******************************************************************************/
;;;686    void _RMP_Clr_Rdy(volatile struct RMP_Thd* Thread)
000000  b430              PUSH     {r4,r5}
;;;687    {
;;;688        /* Is it suspended? If yes, no need to delete again */
;;;689        if((Thread->State&RMP_THD_SUSPENDED)==0)
000002  6981              LDR      r1,[r0,#0x18]
000004  05c9              LSLS     r1,r1,#23
000006  d41a              BMI      |L37.62|
;;;690        {
;;;691            RMP_COVERAGE_MARKER();
;;;692            /* See if it is the last thread on the priority level */
;;;693            if(Thread->Run_Head.Prev==Thread->Run_Head.Next)
000008  6801              LDR      r1,[r0,#0]
00000a  6843              LDR      r3,[r0,#4]
;;;694            {
;;;695                RMP_COVERAGE_MARKER();
;;;696                RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]&=~(((rmp_ptr_t)1)<<(Thread->Prio&RMP_WORD_MASK));
00000c  2201              MOVS     r2,#1
00000e  4299              CMP      r1,r3                 ;693
000010  d10c              BNE      |L37.44|
000012  6a41              LDR      r1,[r0,#0x24]
000014  4b0b              LDR      r3,|L37.68|
000016  0949              LSRS     r1,r1,#5
000018  0089              LSLS     r1,r1,#2
00001a  18c9              ADDS     r1,r1,r3
00001c  680b              LDR      r3,[r1,#0]
00001e  6a44              LDR      r4,[r0,#0x24]
000020  06e5              LSLS     r5,r4,#27
000022  0eed              LSRS     r5,r5,#27
000024  4614              MOV      r4,r2
000026  40ac              LSLS     r4,r4,r5
000028  43a3              BICS     r3,r3,r4
00002a  600b              STR      r3,[r1,#0]
                  |L37.44|
;;;697            }
;;;698            else
;;;699                RMP_COVERAGE_MARKER();
;;;700            
;;;701            /* Delete this from the corresponding runqueue */
;;;702            RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
00002c  6803              LDR      r3,[r0,#0]
00002e  6841              LDR      r1,[r0,#4]
000030  600b              STR      r3,[r1,#0]
000032  6059              STR      r1,[r3,#4]
;;;703            
;;;704            /* If it is the current thread, request a context switch */
;;;705            if(Thread==RMP_Cur_Thd)
000034  4903              LDR      r1,|L37.68|
000036  698b              LDR      r3,[r1,#0x18]  ; RMP_Cur_Thd
000038  4298              CMP      r0,r3
00003a  d100              BNE      |L37.62|
;;;706            {
;;;707                RMP_COVERAGE_MARKER();
;;;708                RMP_Sched_Pend=1;
00003c  60ca              STR      r2,[r1,#0xc]  ; RMP_Sched_Pend
                  |L37.62|
;;;709            }
;;;710            else
;;;711                RMP_COVERAGE_MARKER();
;;;712        }
;;;713        else
;;;714            RMP_COVERAGE_MARKER();
;;;715    }
00003e  bc30              POP      {r4,r5}
000040  4770              BX       lr
;;;716    /* End Function:_RMP_Clr_Rdy *************************************************/
                          ENDP

000042  0000              DCW      0x0000
                  |L37.68|
                          DCD      ||.data||

                          AREA ||i._RMP_Get_High_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Get_High_Rdy PROC
;;;493    ******************************************************************************/
;;;494    void _RMP_Get_High_Rdy(void)
000000  b570              PUSH     {r4-r6,lr}
;;;495    {
;;;496        rmp_cnt_t Count;
;;;497        
;;;498        /* Write the SP value to thread structure */
;;;499        RMP_Cur_Thd->Stack=RMP_Cur_SP;
000002  4c18              LDR      r4,|L38.100|
000004  69e0              LDR      r0,[r4,#0x1c]  ; RMP_Cur_SP
000006  69a1              LDR      r1,[r4,#0x18]  ; RMP_Cur_Thd
;;;500        
;;;501        /* No need to detect scheduler locks - if this interrupt can be entered, the scheduler is not locked */
;;;502        RMP_Sched_Pend=0;
000008  6348              STR      r0,[r1,#0x34]
00000a  2000              MOVS     r0,#0
00000c  60e0              STR      r0,[r4,#0xc]  ; RMP_Sched_Pend
;;;503        /* See which one is ready, and pick it */
;;;504        for(Count=RMP_BITMAP_SIZE-1;Count>=0;Count--)
;;;505        {
;;;506            if(RMP_Bitmap[Count]==0)
00000e  4620              MOV      r0,r4
000010  6801              LDR      r1,[r0,#0]
000012  2900              CMP      r1,#0
000014  d022              BEQ      |L38.92|
;;;507            {
;;;508                RMP_COVERAGE_MARKER();
;;;509                continue;
;;;510            }
;;;511            else
;;;512                RMP_COVERAGE_MARKER();
;;;513            
;;;514            Count=RMP_MSB_Get(RMP_Bitmap[Count])+(Count<<RMP_WORD_ORDER);
000016  6800              LDR      r0,[r0,#0]
000018  f7fffffe          BL       RMP_MSB_Get
;;;515            
;;;516            /* See if the current thread and the next thread are the same. If yes, place the current at the end of the queue */
;;;517            if(RMP_Cur_Thd==(struct RMP_Thd*)(RMP_Run[Count].Next))
00001c  4912              LDR      r1,|L38.104|
00001e  00c0              LSLS     r0,r0,#3
000020  1842              ADDS     r2,r0,r1
000022  6850              LDR      r0,[r2,#4]
000024  69a3              LDR      r3,[r4,#0x18]  ; RMP_Cur_Thd
000026  4298              CMP      r0,r3
000028  d112              BNE      |L38.80|
;;;518            {
;;;519                RMP_COVERAGE_MARKER();
;;;520                RMP_List_Del(RMP_Cur_Thd->Run_Head.Prev, RMP_Cur_Thd->Run_Head.Next);
00002a  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
00002c  6803              LDR      r3,[r0,#0]
00002e  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
000030  6840              LDR      r0,[r0,#4]
000032  6003              STR      r3,[r0,#0]
000034  6058              STR      r0,[r3,#4]
;;;521                RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),
000036  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
000038  69a3              LDR      r3,[r4,#0x18]  ; RMP_Cur_Thd
00003a  6a5b              LDR      r3,[r3,#0x24]
00003c  00db              LSLS     r3,r3,#3
00003e  58cb              LDR      r3,[r1,r3]
000040  69a5              LDR      r5,[r4,#0x18]  ; RMP_Cur_Thd
000042  6a6d              LDR      r5,[r5,#0x24]
000044  00ed              LSLS     r5,r5,#3
000046  1869              ADDS     r1,r5,r1
000048  6008              STR      r0,[r1,#0]
00004a  6041              STR      r1,[r0,#4]
00004c  6003              STR      r3,[r0,#0]
00004e  6058              STR      r0,[r3,#4]
                  |L38.80|
;;;522                             RMP_Run[RMP_Cur_Thd->Prio].Prev,
;;;523                             &(RMP_Run[RMP_Cur_Thd->Prio]));
;;;524            }
;;;525            else
;;;526                RMP_COVERAGE_MARKER();
;;;527            
;;;528            /* Replenish timeslices */
;;;529            RMP_Cur_Thd->Slices_Left=RMP_Cur_Thd->Slices;
000050  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
000052  69a1              LDR      r1,[r4,#0x18]  ; RMP_Cur_Thd
000054  69c0              LDR      r0,[r0,#0x1c]
;;;530            RMP_Cur_Thd=(struct RMP_Thd*)(RMP_Run[Count].Next);
000056  6208              STR      r0,[r1,#0x20]
000058  6850              LDR      r0,[r2,#4]
00005a  61a0              STR      r0,[r4,#0x18]  ; RMP_Cur_Thd
                  |L38.92|
;;;531            break;
;;;532        }
;;;533        
;;;534        /* Load the SP value from thread structure */
;;;535        RMP_Cur_SP=RMP_Cur_Thd->Stack;
00005c  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
00005e  6b40              LDR      r0,[r0,#0x34]
000060  61e0              STR      r0,[r4,#0x1c]  ; RMP_Cur_SP
;;;536        
;;;537    #if(RMP_USE_HOOKS==RMP_TRUE)
;;;538        RMP_Sched_Hook();
;;;539    #endif
;;;540    }
000062  bd70              POP      {r4-r6,pc}
;;;541    /* End Function:_RMP_Get_High_Rdy ********************************************/
                          ENDP

                  |L38.100|
                          DCD      ||.data||
                  |L38.104|
                          DCD      ||.bss||

                          AREA ||i._RMP_Get_Near_Ticks||, CODE, READONLY, ALIGN=2

                  _RMP_Get_Near_Ticks PROC
;;;611    ******************************************************************************/
;;;612    rmp_ptr_t _RMP_Get_Near_Ticks(void)
000000  4a07              LDR      r2,|L39.32|
;;;613    {
;;;614        rmp_ptr_t Value;
;;;615        struct RMP_Thd* Thread;
;;;616        
;;;617        /* What is the current thread's timeout value? */
;;;618        Value=RMP_Cur_Thd->Slices_Left;
000002  6990              LDR      r0,[r2,#0x18]  ; RMP_Cur_Thd
;;;619        
;;;620        /* What is the nearest timer timeout value? */
;;;621        if((&RMP_Delay)!=RMP_Delay.Next)
000004  4907              LDR      r1,|L39.36|
000006  6a00              LDR      r0,[r0,#0x20]         ;618
000008  684b              LDR      r3,[r1,#4]  ; RMP_Delay
00000a  428b              CMP      r3,r1
00000c  d007              BEQ      |L39.30|
;;;622        {
;;;623            RMP_COVERAGE_MARKER();
;;;624            Thread=RMP_DLY2THD(RMP_Delay.Next);
00000e  6849              LDR      r1,[r1,#4]  ; RMP_Delay
;;;625            /* See if it is nearer - don't worry about the situation that the timer
;;;626             * have overflown, because if that is to happen, it would have been 
;;;627             * already processed by the timeout processing routine just before. */
;;;628            if((Thread->Timeout-RMP_Tick)<Value)
000010  6953              LDR      r3,[r2,#0x14]  ; RMP_Tick
000012  6a09              LDR      r1,[r1,#0x20]
000014  1acb              SUBS     r3,r1,r3
000016  4283              CMP      r3,r0
000018  d201              BCS      |L39.30|
;;;629            {
;;;630                RMP_COVERAGE_MARKER();
;;;631                Value=Thread->Timeout-RMP_Tick;
00001a  6950              LDR      r0,[r2,#0x14]  ; RMP_Tick
00001c  1a08              SUBS     r0,r1,r0
                  |L39.30|
;;;632            }
;;;633            else
;;;634                RMP_COVERAGE_MARKER();
;;;635        }
;;;636        else
;;;637            RMP_COVERAGE_MARKER();
;;;638        
;;;639        return Value;
;;;640    }
00001e  4770              BX       lr
;;;641    /* End Function:_RMP_Get_Near_Ticks ******************************************/
                          ENDP

                  |L39.32|
                          DCD      ||.data||
                  |L39.36|
                          DCD      ||.data||+0x20

                          AREA ||i._RMP_Mem_Del||, CODE, READONLY, ALIGN=1

                  _RMP_Mem_Del PROC
;;;2305   ******************************************************************************/
;;;2306   void _RMP_Mem_Del(volatile void* Pool, volatile struct RMP_Mem_Head* Mem_Head)
000000  b570              PUSH     {r4-r6,lr}
;;;2307   {
;;;2308       rmp_ptr_t FLI_Level;
;;;2309       rmp_ptr_t SLI_Level;
;;;2310       rmp_ptr_t Level;
;;;2311       rmp_ptr_t Size;
;;;2312       volatile struct RMP_Mem* Mem;
;;;2313       volatile struct RMP_List* Slot;    
;;;2314       
;;;2315       /* Get the memory pool and block size */
;;;2316       Mem=(volatile struct RMP_Mem*)Pool;
000002  4605              MOV      r5,r0
;;;2317       Size=(rmp_ptr_t)(Mem_Head->Tail)-((rmp_ptr_t)Mem_Head)-sizeof(struct RMP_Mem_Head);
000004  68c8              LDR      r0,[r1,#0xc]
000006  460c              MOV      r4,r1                 ;2307
000008  1b06              SUBS     r6,r0,r4
00000a  3e10              SUBS     r6,r6,#0x10
;;;2318       
;;;2319       /* Guarantee the Mem_Size is bigger than 64 or a failure will surely occur here */
;;;2320       FLI_Level=RMP_MSB_Get(Size)-6;
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       RMP_MSB_Get
;;;2321       /* Decide the SLI level directly from the FLI level */
;;;2322       SLI_Level=(Size>>(FLI_Level+3))&0x07;
000012  1ec1              SUBS     r1,r0,#3
000014  40ce              LSRS     r6,r6,r1
000016  0771              LSLS     r1,r6,#29
000018  1f80              SUBS     r0,r0,#6
00001a  0f49              LSRS     r1,r1,#29
;;;2323       /* Calculate the bit position */
;;;2324       Level=RMP_MEM_POS(FLI_Level,SLI_Level);
00001c  00c0              LSLS     r0,r0,#3
00001e  1841              ADDS     r1,r0,r1
;;;2325       /* Get the slot */
;;;2326       Slot=&(Mem->Table[Level]);
000020  68e8              LDR      r0,[r5,#0xc]
000022  00ca              LSLS     r2,r1,#3
000024  1880              ADDS     r0,r0,r2
;;;2327   
;;;2328       /* Delete the node now */
;;;2329       RMP_List_Del(Mem_Head->Head.Prev,Mem_Head->Head.Next);
000026  6822              LDR      r2,[r4,#0]
000028  6863              LDR      r3,[r4,#4]
00002a  601a              STR      r2,[r3,#0]
00002c  6053              STR      r3,[r2,#4]
;;;2330   
;;;2331       /* See if there are any blocks in the level, equal means no. So
;;;2332        * what we deleted is the last blockm need to clear the flag */
;;;2333       if(Slot==Slot->Next)
00002e  6842              LDR      r2,[r0,#4]
000030  4282              CMP      r2,r0
000032  d109              BNE      |L40.72|
;;;2334       {
;;;2335           RMP_COVERAGE_MARKER();
;;;2336           /* Clear the corresponding bit in the TLSF bitmap */
;;;2337           Mem->Bitmap[Level>>RMP_WORD_ORDER]&=~RMP_POW2(Level&RMP_WORD_MASK);
000034  0948              LSRS     r0,r1,#5
000036  0080              LSLS     r0,r0,#2
000038  1940              ADDS     r0,r0,r5
00003a  6902              LDR      r2,[r0,#0x10]
00003c  06cb              LSLS     r3,r1,#27
00003e  0edb              LSRS     r3,r3,#27
000040  2101              MOVS     r1,#1
000042  4099              LSLS     r1,r1,r3
000044  438a              BICS     r2,r2,r1
000046  6102              STR      r2,[r0,#0x10]
                  |L40.72|
;;;2338       }
;;;2339       else
;;;2340           RMP_COVERAGE_MARKER();
;;;2341   }
000048  bd70              POP      {r4-r6,pc}
;;;2342   /* End Function:_RMP_Mem_Del *************************************************/
                          ENDP


                          AREA ||i._RMP_Mem_Ins||, CODE, READONLY, ALIGN=1

                  _RMP_Mem_Ins PROC
;;;2260   ******************************************************************************/
;;;2261   void _RMP_Mem_Ins(volatile void* Pool, volatile struct RMP_Mem_Head* Mem_Head)
000000  b570              PUSH     {r4-r6,lr}
;;;2262   {
;;;2263       rmp_ptr_t FLI_Level;
;;;2264       rmp_ptr_t SLI_Level;
;;;2265       rmp_ptr_t Level;
;;;2266       rmp_ptr_t Size;
;;;2267       volatile struct RMP_Mem* Mem;
;;;2268       volatile struct RMP_List* Slot;
;;;2269       
;;;2270       /* Get the memory pool and block size */
;;;2271       Mem=(volatile struct RMP_Mem*)Pool;
000002  4605              MOV      r5,r0
;;;2272       Size=(rmp_ptr_t)(Mem_Head->Tail)-((rmp_ptr_t)Mem_Head)-sizeof(struct RMP_Mem_Head);
000004  68c8              LDR      r0,[r1,#0xc]
000006  460c              MOV      r4,r1                 ;2262
000008  1b06              SUBS     r6,r0,r4
00000a  3e10              SUBS     r6,r6,#0x10
;;;2273   
;;;2274       /* Guarantee the Mem_Size is bigger than 64 or a failure will surely occur here */
;;;2275       FLI_Level=RMP_MSB_Get(Size)-6;
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       RMP_MSB_Get
;;;2276       /* Decide the SLI level directly from the FLI level */
;;;2277       SLI_Level=(Size>>(FLI_Level+3))&0x07;
000012  1ec1              SUBS     r1,r0,#3
000014  40ce              LSRS     r6,r6,r1
000016  0771              LSLS     r1,r6,#29
000018  1f80              SUBS     r0,r0,#6
00001a  0f49              LSRS     r1,r1,#29
;;;2278       /* Calculate the bit position */
;;;2279       Level=RMP_MEM_POS(FLI_Level,SLI_Level);
00001c  00c0              LSLS     r0,r0,#3
00001e  1841              ADDS     r1,r0,r1
;;;2280       /* Get the slot */
;;;2281       Slot=&(Mem->Table[Level]);
000020  68e8              LDR      r0,[r5,#0xc]
000022  00ca              LSLS     r2,r1,#3
000024  1880              ADDS     r0,r0,r2
;;;2282   
;;;2283       /* See if there are any blocks in the level, equal means no. So what we inserted is the first block */
;;;2284       if(Slot==Slot->Next)
000026  6842              LDR      r2,[r0,#4]
000028  4282              CMP      r2,r0
00002a  d109              BNE      |L41.64|
;;;2285       {
;;;2286           RMP_COVERAGE_MARKER();
;;;2287           /* Set the corresponding bit in the TLSF bitmap */
;;;2288           Mem->Bitmap[Level>>RMP_WORD_ORDER]|=RMP_POW2(Level&RMP_WORD_MASK);
00002c  094a              LSRS     r2,r1,#5
00002e  0092              LSLS     r2,r2,#2
000030  1952              ADDS     r2,r2,r5
000032  6913              LDR      r3,[r2,#0x10]
000034  06cd              LSLS     r5,r1,#27
000036  0eed              LSRS     r5,r5,#27
000038  2101              MOVS     r1,#1
00003a  40a9              LSLS     r1,r1,r5
00003c  430b              ORRS     r3,r3,r1
00003e  6113              STR      r3,[r2,#0x10]
                  |L41.64|
;;;2289       }
;;;2290       else
;;;2291           RMP_COVERAGE_MARKER();
;;;2292   
;;;2293       /* Insert the node now */
;;;2294       RMP_List_Ins(&(Mem_Head->Head), Slot, Slot->Next);
000040  6841              LDR      r1,[r0,#4]
000042  600c              STR      r4,[r1,#0]
000044  6061              STR      r1,[r4,#4]
000046  6020              STR      r0,[r4,#0]
000048  6044              STR      r4,[r0,#4]
;;;2295   }
00004a  bd70              POP      {r4-r6,pc}
;;;2296   /* End Function:_RMP_Mem_Ins *************************************************/
                          ENDP


                          AREA ||i._RMP_Set_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Set_Rdy PROC
;;;652    ******************************************************************************/
;;;653    void _RMP_Set_Rdy(volatile struct RMP_Thd* Thread)
000000  6981              LDR      r1,[r0,#0x18]
;;;654    {        
;;;655        /* Is it suspended? If yes, we can't directly set it running */
;;;656        if((Thread->State&RMP_THD_SUSPENDED)==0)
000002  05c9              LSLS     r1,r1,#23
000004  d422              BMI      |L42.76|
000006  b430              PUSH     {r4,r5}               ;654
;;;657        {
;;;658            RMP_COVERAGE_MARKER();
;;;659            /* Insert this into the corresponding runqueue */
;;;660            RMP_List_Ins(&(Thread->Run_Head),RMP_Run[Thread->Prio].Prev,&(RMP_Run[Thread->Prio]));
000008  6a41              LDR      r1,[r0,#0x24]
00000a  4a11              LDR      r2,|L42.80|
00000c  00c9              LSLS     r1,r1,#3
00000e  5851              LDR      r1,[r2,r1]
000010  6a43              LDR      r3,[r0,#0x24]
000012  00db              LSLS     r3,r3,#3
000014  189a              ADDS     r2,r3,r2
000016  6010              STR      r0,[r2,#0]
000018  6042              STR      r2,[r0,#4]
00001a  6001              STR      r1,[r0,#0]
00001c  6048              STR      r0,[r1,#4]
;;;661            /* Set this runlevel as active */
;;;662            RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]|=((rmp_ptr_t)1)<<(Thread->Prio&RMP_WORD_MASK);
00001e  6a41              LDR      r1,[r0,#0x24]
000020  4a0c              LDR      r2,|L42.84|
000022  0949              LSRS     r1,r1,#5
000024  0089              LSLS     r1,r1,#2
000026  188a              ADDS     r2,r1,r2
000028  6813              LDR      r3,[r2,#0]
00002a  6a41              LDR      r1,[r0,#0x24]
00002c  06cd              LSLS     r5,r1,#27
00002e  2101              MOVS     r1,#1
000030  0eed              LSRS     r5,r5,#27
000032  460c              MOV      r4,r1
000034  40ac              LSLS     r4,r4,r5
000036  4323              ORRS     r3,r3,r4
000038  6013              STR      r3,[r2,#0]
;;;663            
;;;664            /* Compare this with the current one to see if we need a context switch */
;;;665            if(Thread->Prio>RMP_Cur_Thd->Prio)
00003a  6a42              LDR      r2,[r0,#0x24]
00003c  4805              LDR      r0,|L42.84|
00003e  6983              LDR      r3,[r0,#0x18]  ; RMP_Cur_Thd
000040  6a5b              LDR      r3,[r3,#0x24]
000042  429a              CMP      r2,r3
000044  d900              BLS      |L42.72|
;;;666            {
;;;667                RMP_COVERAGE_MARKER();
;;;668                RMP_Sched_Pend=1;
000046  60c1              STR      r1,[r0,#0xc]  ; RMP_Sched_Pend
                  |L42.72|
;;;669            }
;;;670            else
;;;671                RMP_COVERAGE_MARKER();
;;;672        }
;;;673        else
;;;674            RMP_COVERAGE_MARKER();
;;;675    }
000048  bc30              POP      {r4,r5}
00004a  4770              BX       lr
                  |L42.76|
00004c  4770              BX       lr
;;;676    /* End Function:_RMP_Set_Rdy *************************************************/
                          ENDP

00004e  0000              DCW      0x0000
                  |L42.80|
                          DCD      ||.bss||
                  |L42.84|
                          DCD      ||.data||

                          AREA ||i._RMP_Tick_Handler||, CODE, READONLY, ALIGN=2

                  _RMP_Tick_Handler PROC
;;;548    ******************************************************************************/
;;;549    void _RMP_Tick_Handler(rmp_ptr_t Ticks)
000000  b5f8              PUSH     {r3-r7,lr}
;;;550    {
;;;551        struct RMP_Thd* Thread;
;;;552        /* Increase the timestamp as always */
;;;553        RMP_Tick+=Ticks;
000002  4d26              LDR      r5,|L43.156|
000004  6969              LDR      r1,[r5,#0x14]  ; RMP_Tick
000006  1809              ADDS     r1,r1,r0
000008  6169              STR      r1,[r5,#0x14]  ; RMP_Tick
;;;554        
;;;555        /* See if the current thread expired. If yes, trigger a scheduler event */
;;;556        if(Ticks>RMP_Cur_Thd->Slices_Left)
00000a  69a9              LDR      r1,[r5,#0x18]  ; RMP_Cur_Thd
00000c  6a09              LDR      r1,[r1,#0x20]
00000e  4281              CMP      r1,r0
000010  d202              BCS      |L43.24|
;;;557        {
;;;558            RMP_COVERAGE_MARKER();
;;;559            RMP_Sched_Pend=1;
000012  2001              MOVS     r0,#1
000014  60e8              STR      r0,[r5,#0xc]  ; RMP_Sched_Pend
000016  e003              B        |L43.32|
                  |L43.24|
;;;560        }
;;;561        else
;;;562        {
;;;563            RMP_COVERAGE_MARKER();
;;;564            RMP_Cur_Thd->Slices_Left-=Ticks;
000018  69a9              LDR      r1,[r5,#0x18]  ; RMP_Cur_Thd
00001a  6a0a              LDR      r2,[r1,#0x20]
00001c  1a10              SUBS     r0,r2,r0
00001e  6208              STR      r0,[r1,#0x20]
                  |L43.32|
;;;565        }
;;;566        
;;;567        /* Check if there are any timer events */
;;;568        if((&RMP_Delay)!=RMP_Delay.Next)
000020  4c1f              LDR      r4,|L43.160|
000022  6860              LDR      r0,[r4,#4]  ; RMP_Delay
000024  42a0              CMP      r0,r4
000026  d031              BEQ      |L43.140|
;;;569        {
;;;570            RMP_COVERAGE_MARKER();
;;;571            Thread=RMP_DLY2THD(RMP_Delay.Next);
000028  6860              LDR      r0,[r4,#4]  ; RMP_Delay
;;;572            /* If the value is less than this, then it means that the time have
;;;573             * already passed and we have to process this */
;;;574            if((RMP_Tick-Thread->Timeout)<=(RMP_ALLBITS>>1))
00002a  6969              LDR      r1,[r5,#0x14]  ; RMP_Tick
00002c  6a00              LDR      r0,[r0,#0x20]
00002e  4e1d              LDR      r6,|L43.164|
000030  1a08              SUBS     r0,r1,r0
000032  42b0              CMP      r0,r6
000034  d82a              BHI      |L43.140|
000036  6860              LDR      r0,[r4,#4]  ; RMP_Delay
000038  42a0              CMP      r0,r4
00003a  d027              BEQ      |L43.140|
00003c  2704              MOVS     r7,#4
00003e  43ff              MVNS     r7,r7
                  |L43.64|
000040  6860              LDR      r0,[r4,#4]  ; RMP_Delay
000042  696a              LDR      r2,[r5,#0x14]  ; RMP_Tick
000044  6a01              LDR      r1,[r0,#0x20]
000046  3808              SUBS     r0,r0,#8
000048  1a51              SUBS     r1,r2,r1
00004a  42b1              CMP      r1,r6
00004c  d81e              BHI      |L43.140|
00004e  68c2              LDR      r2,[r0,#0xc]
000050  6881              LDR      r1,[r0,#8]
000052  6011              STR      r1,[r2,#0]
000054  604a              STR      r2,[r1,#4]
000056  7e01              LDRB     r1,[r0,#0x18]
000058  2903              CMP      r1,#3
00005a  d006              BEQ      |L43.106|
00005c  2905              CMP      r1,#5
00005e  d00a              BEQ      |L43.118|
000060  2906              CMP      r1,#6
000062  d009              BEQ      |L43.120|
000064  2908              CMP      r1,#8
000066  d000              BEQ      |L43.106|
                  |L43.104|
000068  e7fe              B        |L43.104|
                  |L43.106|
00006a  6842              LDR      r2,[r0,#4]
00006c  6801              LDR      r1,[r0,#0]
00006e  6011              STR      r1,[r2,#0]
000070  604a              STR      r2,[r1,#4]
000072  6387              STR      r7,[r0,#0x38]
000074  e000              B        |L43.120|
                  |L43.118|
000076  6387              STR      r7,[r0,#0x38]
                  |L43.120|
000078  6981              LDR      r1,[r0,#0x18]
00007a  0a09              LSRS     r1,r1,#8
00007c  0209              LSLS     r1,r1,#8
00007e  1c49              ADDS     r1,r1,#1
000080  6181              STR      r1,[r0,#0x18]
000082  f7fffffe          BL       _RMP_Set_Rdy
000086  6860              LDR      r0,[r4,#4]  ; RMP_Delay
000088  42a0              CMP      r0,r4
00008a  d1d9              BNE      |L43.64|
                  |L43.140|
;;;575            {
;;;576                RMP_COVERAGE_MARKER();
;;;577                /* No need to care about scheduler locks if this interrupt can be entered
;;;578                 * - we have disabled timer and scheduler interrupts in scheduler lock */
;;;579                _RMP_Timer_Proc();
;;;580            }
;;;581            else
;;;582                RMP_COVERAGE_MARKER();
;;;583        }
;;;584        else
;;;585            RMP_COVERAGE_MARKER();
;;;586        
;;;587        if(RMP_Sched_Pend!=0)
00008c  68e8              LDR      r0,[r5,#0xc]  ; RMP_Sched_Pend
00008e  2800              CMP      r0,#0
000090  d003              BEQ      |L43.154|
;;;588        {
;;;589            RMP_COVERAGE_MARKER();
;;;590            RMP_Sched_Pend=0;
000092  2000              MOVS     r0,#0
000094  60e8              STR      r0,[r5,#0xc]  ; RMP_Sched_Pend
;;;591            _RMP_Yield();
000096  f7fffffe          BL       _RMP_Yield
                  |L43.154|
;;;592        }
;;;593        else
;;;594            RMP_COVERAGE_MARKER();
;;;595        
;;;596    #if(RMP_USE_HOOKS==RMP_TRUE)
;;;597        RMP_Tick_Hook(Ticks);
;;;598    #endif
;;;599    }
00009a  bdf8              POP      {r3-r7,pc}
;;;600    /* End Function:_RMP_Tick_Handler ********************************************/
                          ENDP

                  |L43.156|
                          DCD      ||.data||
                  |L43.160|
                          DCD      ||.data||+0x20
                  |L43.164|
                          DCD      0x7fffffff

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;1993   ******************************************************************************/
;;;1994   int main(void)
000000  b570              PUSH     {r4-r6,lr}
;;;1995   {
;;;1996       rmp_ptr_t Count;
;;;1997       
;;;1998   #ifdef RMP_COVERAGE
;;;1999       /* Initialize coverage markers if coverage enabled */
;;;2000       for(Count=0;Count<RMP_COVERAGE_LINES;Count++)
;;;2001           RMP_Coverage[Count]=0;
;;;2002   #endif
;;;2003       
;;;2004       /* Initialize the kernel data structures first */
;;;2005       _RMP_Low_Level_Init();
000002  f7fffffe          BL       _RMP_Low_Level_Init
;;;2006       
;;;2007   #if(RMP_USE_HOOKS==RMP_TRUE)
;;;2008       RMP_Start_Hook();
;;;2009   #endif
;;;2010       
;;;2011       RMP_Tick=0;
000006  4b1d              LDR      r3,|L44.124|
000008  2000              MOVS     r0,#0
00000a  6158              STR      r0,[r3,#0x14]  ; RMP_Tick
;;;2012       /* Now initialize the kernel data structures */
;;;2013       RMP_Sched_Lock_Cnt=0;
00000c  6058              STR      r0,[r3,#4]  ; RMP_Sched_Lock_Cnt
;;;2014       RMP_Sched_Locked=0;
00000e  6098              STR      r0,[r3,#8]  ; RMP_Sched_Locked
;;;2015       RMP_Sched_Pend=0;
000010  60d8              STR      r0,[r3,#0xc]  ; RMP_Sched_Pend
;;;2016       RMP_Timer_Pend=0;
000012  6118              STR      r0,[r3,#0x10]  ; RMP_Timer_Pend
;;;2017       
;;;2018       /* Linked lists */
;;;2019       RMP_List_Crt(&RMP_Delay);
000014  491a              LDR      r1,|L44.128|
000016  6009              STR      r1,[r1,#0]
000018  6049              STR      r1,[r1,#4]
;;;2020       for(Count=0;Count<RMP_MAX_PREEMPT_PRIO;Count++)
;;;2021           RMP_List_Crt(&RMP_Run[Count]);
00001a  4c1a              LDR      r4,|L44.132|
00001c  4601              MOV      r1,r0                 ;2020
                  |L44.30|
00001e  00ca              LSLS     r2,r1,#3
000020  1912              ADDS     r2,r2,r4
000022  6012              STR      r2,[r2,#0]
000024  6052              STR      r2,[r2,#4]
000026  1c49              ADDS     r1,r1,#1
000028  2920              CMP      r1,#0x20
00002a  d3f8              BCC      |L44.30|
;;;2022       for(Count=0;Count<RMP_BITMAP_SIZE;Count++)
;;;2023           RMP_Bitmap[Count]=0;
00002c  4d13              LDR      r5,|L44.124|
00002e  6028              STR      r0,[r5,#0]  ; RMP_Bitmap
;;;2024           
;;;2025       /* Now boot into the first thread */
;;;2026       RMP_Clear(&RMP_Init_Thd,sizeof(struct RMP_Thd));
000030  4915              LDR      r1,|L44.136|
000032  221e              MOVS     r2,#0x1e
                  |L44.52|
000034  7048              STRB     r0,[r1,#1]
000036  7088              STRB     r0,[r1,#2]
000038  1c89              ADDS     r1,r1,#2
00003a  1e52              SUBS     r2,r2,#1
00003c  d1fa              BNE      |L44.52|
;;;2027       RMP_Init_Thd.Prio=0;
00003e  4913              LDR      r1,|L44.140|
000040  6248              STR      r0,[r1,#0x24]  ; RMP_Init_Thd
;;;2028       RMP_Init_Thd.Slices=10;
000042  200a              MOVS     r0,#0xa
000044  61c8              STR      r0,[r1,#0x1c]  ; RMP_Init_Thd
;;;2029       RMP_Init_Thd.Slices_Left=10;
000046  6208              STR      r0,[r1,#0x20]  ; RMP_Init_Thd
;;;2030       RMP_Init_Thd.State=RMP_THD_RUNNING;
000048  2201              MOVS     r2,#1
00004a  618a              STR      r2,[r1,#0x18]  ; RMP_Init_Thd
;;;2031       RMP_Init_Thd.Stack=RMP_INIT_STACK;
00004c  4810              LDR      r0,|L44.144|
00004e  6348              STR      r0,[r1,#0x34]  ; RMP_Init_Thd
;;;2032       
;;;2033       /* Initialize sending list */
;;;2034       RMP_List_Crt(&(RMP_Init_Thd.Snd_List));
000050  4810              LDR      r0,|L44.148|
000052  6000              STR      r0,[r0,#0]
000054  6040              STR      r0,[r0,#4]
;;;2035       
;;;2036       /* Insert this into the corresponding runqueue */
;;;2037       RMP_List_Ins(&(RMP_Init_Thd.Run_Head),RMP_Run[0].Prev,&(RMP_Run[0]));
000056  6826              LDR      r6,[r4,#0]  ; RMP_Run
000058  3810              SUBS     r0,r0,#0x10
00005a  4c0a              LDR      r4,|L44.132|
00005c  6020              STR      r0,[r4,#0]
00005e  6044              STR      r4,[r0,#4]
000060  6006              STR      r6,[r0,#0]
000062  6070              STR      r0,[r6,#4]
;;;2038       /* Set this runlevel as active - in fact it is always active */
;;;2039       RMP_Bitmap[0]|=1;
000064  6828              LDR      r0,[r5,#0]  ; RMP_Bitmap
000066  4310              ORRS     r0,r0,r2
000068  6028              STR      r0,[r5,#0]  ; RMP_Bitmap
;;;2040       
;;;2041       /* Set current thread and stack */
;;;2042       RMP_Cur_Thd=(struct RMP_Thd*)(&RMP_Init_Thd);
00006a  6199              STR      r1,[r3,#0x18]  ; RMP_Cur_Thd
;;;2043       RMP_Cur_SP=RMP_Init_Thd.Stack;
00006c  6b48              LDR      r0,[r1,#0x34]  ; RMP_Init_Thd
00006e  61d8              STR      r0,[r3,#0x1c]  ; RMP_Cur_SP
;;;2044       
;;;2045       /* Now jump to the user function and will never return. Initialization of stack is not needed */
;;;2046       _RMP_Start((rmp_ptr_t)RMP_Init, (rmp_ptr_t)RMP_Init_Thd.Stack);
000070  6b49              LDR      r1,[r1,#0x34]  ; RMP_Init_Thd
000072  4809              LDR      r0,|L44.152|
000074  f7fffffe          BL       _RMP_Start
;;;2047       
;;;2048       return 0;
000078  2000              MOVS     r0,#0
;;;2049   }
00007a  bd70              POP      {r4-r6,pc}
;;;2050   /* End Function:main *********************************************************/
                          ENDP

                  |L44.124|
                          DCD      ||.data||
                  |L44.128|
                          DCD      ||.data||+0x20
                  |L44.132|
                          DCD      ||.bss||
                  |L44.136|
                          DCD      ||.bss||+0x1ff
                  |L44.140|
                          DCD      ||.bss||+0x200
                  |L44.144|
                          DCD      ||.bss||+0x1bc
                  |L44.148|
                          DCD      ||.bss||+0x210
                  |L44.152|
                          DCD      RMP_Init

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  RMP_Run
                          %        256
                  RMP_Init_Stack
                          %        256
                  RMP_Init_Thd
                          %        60

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  RMP_RBIT_Table
000000  008040c0          DCB      0x00,0x80,0x40,0xc0
000004  20a060e0          DCB      0x20,0xa0,0x60,0xe0
000008  109050d0          DCB      0x10,0x90,0x50,0xd0
00000c  30b070f0          DCB      0x30,0xb0,0x70,0xf0
000010  088848c8          DCB      0x08,0x88,0x48,0xc8
000014  28a868e8          DCB      0x28,0xa8,0x68,0xe8
000018  189858d8          DCB      0x18,0x98,0x58,0xd8
00001c  38b878f8          DCB      0x38,0xb8,0x78,0xf8
000020  048444c4          DCB      0x04,0x84,0x44,0xc4
000024  24a464e4          DCB      0x24,0xa4,0x64,0xe4
000028  149454d4          DCB      0x14,0x94,0x54,0xd4
00002c  34b474f4          DCB      0x34,0xb4,0x74,0xf4
000030  0c8c4ccc          DCB      0x0c,0x8c,0x4c,0xcc
000034  2cac6cec          DCB      0x2c,0xac,0x6c,0xec
000038  1c9c5cdc          DCB      0x1c,0x9c,0x5c,0xdc
00003c  3cbc7cfc          DCB      0x3c,0xbc,0x7c,0xfc
000040  028242c2          DCB      0x02,0x82,0x42,0xc2
000044  22a262e2          DCB      0x22,0xa2,0x62,0xe2
000048  129252d2          DCB      0x12,0x92,0x52,0xd2
00004c  32b272f2          DCB      0x32,0xb2,0x72,0xf2
000050  0a8a4aca          DCB      0x0a,0x8a,0x4a,0xca
000054  2aaa6aea          DCB      0x2a,0xaa,0x6a,0xea
000058  1a9a5ada          DCB      0x1a,0x9a,0x5a,0xda
00005c  3aba7afa          DCB      0x3a,0xba,0x7a,0xfa
000060  068646c6          DCB      0x06,0x86,0x46,0xc6
000064  26a666e6          DCB      0x26,0xa6,0x66,0xe6
000068  169656d6          DCB      0x16,0x96,0x56,0xd6
00006c  36b676f6          DCB      0x36,0xb6,0x76,0xf6
000070  0e8e4ece          DCB      0x0e,0x8e,0x4e,0xce
000074  2eae6eee          DCB      0x2e,0xae,0x6e,0xee
000078  1e9e5ede          DCB      0x1e,0x9e,0x5e,0xde
00007c  3ebe7efe          DCB      0x3e,0xbe,0x7e,0xfe
000080  018141c1          DCB      0x01,0x81,0x41,0xc1
000084  21a161e1          DCB      0x21,0xa1,0x61,0xe1
000088  119151d1          DCB      0x11,0x91,0x51,0xd1
00008c  31b171f1          DCB      0x31,0xb1,0x71,0xf1
000090  098949c9          DCB      0x09,0x89,0x49,0xc9
000094  29a969e9          DCB      0x29,0xa9,0x69,0xe9
000098  199959d9          DCB      0x19,0x99,0x59,0xd9
00009c  39b979f9          DCB      0x39,0xb9,0x79,0xf9
0000a0  058545c5          DCB      0x05,0x85,0x45,0xc5
0000a4  25a565e5          DCB      0x25,0xa5,0x65,0xe5
0000a8  159555d5          DCB      0x15,0x95,0x55,0xd5
0000ac  35b575f5          DCB      0x35,0xb5,0x75,0xf5
0000b0  0d8d4dcd          DCB      0x0d,0x8d,0x4d,0xcd
0000b4  2dad6ded          DCB      0x2d,0xad,0x6d,0xed
0000b8  1d9d5ddd          DCB      0x1d,0x9d,0x5d,0xdd
0000bc  3dbd7dfd          DCB      0x3d,0xbd,0x7d,0xfd
0000c0  038343c3          DCB      0x03,0x83,0x43,0xc3
0000c4  23a363e3          DCB      0x23,0xa3,0x63,0xe3
0000c8  139353d3          DCB      0x13,0x93,0x53,0xd3
0000cc  33b373f3          DCB      0x33,0xb3,0x73,0xf3
0000d0  0b8b4bcb          DCB      0x0b,0x8b,0x4b,0xcb
0000d4  2bab6beb          DCB      0x2b,0xab,0x6b,0xeb
0000d8  1b9b5bdb          DCB      0x1b,0x9b,0x5b,0xdb
0000dc  3bbb7bfb          DCB      0x3b,0xbb,0x7b,0xfb
0000e0  078747c7          DCB      0x07,0x87,0x47,0xc7
0000e4  27a767e7          DCB      0x27,0xa7,0x67,0xe7
0000e8  179757d7          DCB      0x17,0x97,0x57,0xd7
0000ec  37b777f7          DCB      0x37,0xb7,0x77,0xf7
0000f0  0f8f4fcf          DCB      0x0f,0x8f,0x4f,0xcf
0000f4  2faf6fef          DCB      0x2f,0xaf,0x6f,0xef
0000f8  1f9f5fdf          DCB      0x1f,0x9f,0x5f,0xdf
0000fc  3fbf7fff          DCB      0x3f,0xbf,0x7f,0xff
                  CRC16_High
000100  00c18140          DCB      0x00,0xc1,0x81,0x40
000104  01c08041          DCB      0x01,0xc0,0x80,0x41
000108  01c08041          DCB      0x01,0xc0,0x80,0x41
00010c  00c18140          DCB      0x00,0xc1,0x81,0x40
000110  01c08041          DCB      0x01,0xc0,0x80,0x41
000114  00c18140          DCB      0x00,0xc1,0x81,0x40
000118  00c18140          DCB      0x00,0xc1,0x81,0x40
00011c  01c08041          DCB      0x01,0xc0,0x80,0x41
000120  01c08041          DCB      0x01,0xc0,0x80,0x41
000124  00c18140          DCB      0x00,0xc1,0x81,0x40
000128  00c18140          DCB      0x00,0xc1,0x81,0x40
00012c  01c08041          DCB      0x01,0xc0,0x80,0x41
000130  00c18140          DCB      0x00,0xc1,0x81,0x40
000134  01c08041          DCB      0x01,0xc0,0x80,0x41
000138  01c08041          DCB      0x01,0xc0,0x80,0x41
00013c  00c18140          DCB      0x00,0xc1,0x81,0x40
000140  01c08041          DCB      0x01,0xc0,0x80,0x41
000144  00c18140          DCB      0x00,0xc1,0x81,0x40
000148  00c18140          DCB      0x00,0xc1,0x81,0x40
00014c  01c08041          DCB      0x01,0xc0,0x80,0x41
000150  00c18140          DCB      0x00,0xc1,0x81,0x40
000154  01c08041          DCB      0x01,0xc0,0x80,0x41
000158  01c08041          DCB      0x01,0xc0,0x80,0x41
00015c  00c18140          DCB      0x00,0xc1,0x81,0x40
000160  00c18140          DCB      0x00,0xc1,0x81,0x40
000164  01c08041          DCB      0x01,0xc0,0x80,0x41
000168  01c08041          DCB      0x01,0xc0,0x80,0x41
00016c  00c18140          DCB      0x00,0xc1,0x81,0x40
000170  01c08041          DCB      0x01,0xc0,0x80,0x41
000174  00c18140          DCB      0x00,0xc1,0x81,0x40
000178  00c18140          DCB      0x00,0xc1,0x81,0x40
00017c  01c08041          DCB      0x01,0xc0,0x80,0x41
000180  01c08041          DCB      0x01,0xc0,0x80,0x41
000184  00c18140          DCB      0x00,0xc1,0x81,0x40
000188  00c18140          DCB      0x00,0xc1,0x81,0x40
00018c  01c08041          DCB      0x01,0xc0,0x80,0x41
000190  00c18140          DCB      0x00,0xc1,0x81,0x40
000194  01c08041          DCB      0x01,0xc0,0x80,0x41
000198  01c08041          DCB      0x01,0xc0,0x80,0x41
00019c  00c18140          DCB      0x00,0xc1,0x81,0x40
0001a0  00c18140          DCB      0x00,0xc1,0x81,0x40
0001a4  01c08041          DCB      0x01,0xc0,0x80,0x41
0001a8  01c08041          DCB      0x01,0xc0,0x80,0x41
0001ac  00c18140          DCB      0x00,0xc1,0x81,0x40
0001b0  01c08041          DCB      0x01,0xc0,0x80,0x41
0001b4  00c18140          DCB      0x00,0xc1,0x81,0x40
0001b8  00c18140          DCB      0x00,0xc1,0x81,0x40
0001bc  01c08041          DCB      0x01,0xc0,0x80,0x41
0001c0  00c18140          DCB      0x00,0xc1,0x81,0x40
0001c4  01c08041          DCB      0x01,0xc0,0x80,0x41
0001c8  01c08041          DCB      0x01,0xc0,0x80,0x41
0001cc  00c18140          DCB      0x00,0xc1,0x81,0x40
0001d0  01c08041          DCB      0x01,0xc0,0x80,0x41
0001d4  00c18140          DCB      0x00,0xc1,0x81,0x40
0001d8  00c18140          DCB      0x00,0xc1,0x81,0x40
0001dc  01c08041          DCB      0x01,0xc0,0x80,0x41
0001e0  01c08041          DCB      0x01,0xc0,0x80,0x41
0001e4  00c18140          DCB      0x00,0xc1,0x81,0x40
0001e8  00c18140          DCB      0x00,0xc1,0x81,0x40
0001ec  01c08041          DCB      0x01,0xc0,0x80,0x41
0001f0  00c18140          DCB      0x00,0xc1,0x81,0x40
0001f4  01c08041          DCB      0x01,0xc0,0x80,0x41
0001f8  01c08041          DCB      0x01,0xc0,0x80,0x41
0001fc  00c18140          DCB      0x00,0xc1,0x81,0x40
000200  00c0c101          DCB      0x00,0xc0,0xc1,0x01
000204  c30302c2          DCB      0xc3,0x03,0x02,0xc2
000208  c60607c7          DCB      0xc6,0x06,0x07,0xc7
00020c  05c5c404          DCB      0x05,0xc5,0xc4,0x04
000210  cc0c0dcd          DCB      0xcc,0x0c,0x0d,0xcd
000214  0fcfce0e          DCB      0x0f,0xcf,0xce,0x0e
000218  0acacb0b          DCB      0x0a,0xca,0xcb,0x0b
00021c  c90908c8          DCB      0xc9,0x09,0x08,0xc8
000220  d81819d9          DCB      0xd8,0x18,0x19,0xd9
000224  1bdbda1a          DCB      0x1b,0xdb,0xda,0x1a
000228  1ededf1f          DCB      0x1e,0xde,0xdf,0x1f
00022c  dd1d1cdc          DCB      0xdd,0x1d,0x1c,0xdc
000230  14d4d515          DCB      0x14,0xd4,0xd5,0x15
000234  d71716d6          DCB      0xd7,0x17,0x16,0xd6
000238  d21213d3          DCB      0xd2,0x12,0x13,0xd3
00023c  11d1d010          DCB      0x11,0xd1,0xd0,0x10
000240  f03031f1          DCB      0xf0,0x30,0x31,0xf1
000244  33f3f232          DCB      0x33,0xf3,0xf2,0x32
000248  36f6f737          DCB      0x36,0xf6,0xf7,0x37
00024c  f53534f4          DCB      0xf5,0x35,0x34,0xf4
000250  3cfcfd3d          DCB      0x3c,0xfc,0xfd,0x3d
000254  ff3f3efe          DCB      0xff,0x3f,0x3e,0xfe
000258  fa3a3bfb          DCB      0xfa,0x3a,0x3b,0xfb
00025c  39f9f838          DCB      0x39,0xf9,0xf8,0x38
000260  28e8e929          DCB      0x28,0xe8,0xe9,0x29
000264  eb2b2aea          DCB      0xeb,0x2b,0x2a,0xea
000268  ee2e2fef          DCB      0xee,0x2e,0x2f,0xef
00026c  2dedec2c          DCB      0x2d,0xed,0xec,0x2c
000270  e42425e5          DCB      0xe4,0x24,0x25,0xe5
000274  27e7e626          DCB      0x27,0xe7,0xe6,0x26
000278  22e2e323          DCB      0x22,0xe2,0xe3,0x23
00027c  e12120e0          DCB      0xe1,0x21,0x20,0xe0
000280  a06061a1          DCB      0xa0,0x60,0x61,0xa1
000284  63a3a262          DCB      0x63,0xa3,0xa2,0x62
000288  66a6a767          DCB      0x66,0xa6,0xa7,0x67
00028c  a56564a4          DCB      0xa5,0x65,0x64,0xa4
000290  6cacad6d          DCB      0x6c,0xac,0xad,0x6d
000294  af6f6eae          DCB      0xaf,0x6f,0x6e,0xae
000298  aa6a6bab          DCB      0xaa,0x6a,0x6b,0xab
00029c  69a9a868          DCB      0x69,0xa9,0xa8,0x68
0002a0  78b8b979          DCB      0x78,0xb8,0xb9,0x79
0002a4  bb7b7aba          DCB      0xbb,0x7b,0x7a,0xba
0002a8  be7e7fbf          DCB      0xbe,0x7e,0x7f,0xbf
0002ac  7dbdbc7c          DCB      0x7d,0xbd,0xbc,0x7c
0002b0  b47475b5          DCB      0xb4,0x74,0x75,0xb5
0002b4  77b7b676          DCB      0x77,0xb7,0xb6,0x76
0002b8  72b2b373          DCB      0x72,0xb2,0xb3,0x73
0002bc  b17170b0          DCB      0xb1,0x71,0x70,0xb0
0002c0  50909151          DCB      0x50,0x90,0x91,0x51
0002c4  93535292          DCB      0x93,0x53,0x52,0x92
0002c8  96565797          DCB      0x96,0x56,0x57,0x97
0002cc  55959454          DCB      0x55,0x95,0x94,0x54
0002d0  9c5c5d9d          DCB      0x9c,0x5c,0x5d,0x9d
0002d4  5f9f9e5e          DCB      0x5f,0x9f,0x9e,0x5e
0002d8  5a9a9b5b          DCB      0x5a,0x9a,0x9b,0x5b
0002dc  99595898          DCB      0x99,0x59,0x58,0x98
0002e0  88484989          DCB      0x88,0x48,0x49,0x89
0002e4  4b8b8a4a          DCB      0x4b,0x8b,0x8a,0x4a
0002e8  4e8e8f4f          DCB      0x4e,0x8e,0x8f,0x4f
0002ec  8d4d4c8c          DCB      0x8d,0x4d,0x4c,0x8c
0002f0  44848545          DCB      0x44,0x84,0x85,0x45
0002f4  87474686          DCB      0x87,0x47,0x46,0x86
0002f8  82424383          DCB      0x82,0x42,0x43,0x83
0002fc  41818040          DCB      0x41,0x81,0x80,0x40

                          AREA ||.data||, DATA, ALIGN=2

                  RMP_Bitmap
                          DCD      0x00000000
                  RMP_Sched_Lock_Cnt
                          DCD      0x00000000
                  RMP_Sched_Locked
                          DCD      0x00000000
                  RMP_Sched_Pend
                          DCD      0x00000000
                  RMP_Timer_Pend
                          DCD      0x00000000
                  RMP_Tick
                          DCD      0x00000000
                  RMP_Cur_Thd
                          DCD      0x00000000
                  RMP_Cur_SP
                          DCD      0x00000000
                  RMP_Delay
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\..\\MProkaron\\Kernel\\rmp_kernel.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_rmp_kernel_c_346ad0e8____REV16|
#line 388 "..\\..\\..\\M0P0_Library\\HC32L13X_DDL_V1.0\\driver\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___12_rmp_kernel_c_346ad0e8____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_rmp_kernel_c_346ad0e8____REVSH|
#line 402
|__asm___12_rmp_kernel_c_346ad0e8____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
