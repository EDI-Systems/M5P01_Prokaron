L 1 "..\..\MProkaron\Kernel\rmp_kernel.c"
N/******************************************************************************
NFilename    : rmp_kernel.c
NAuthor      : pry
NDate        : 04/02/2018
NLicence     : LGPL v3+; see COPYING for details.
NDescription : The RMP RTOS single-file kernel.
N              This is a single-process kernel that does nothing but simple thread
N              context switches. This operating system's kernel object allocation
N              policy is totally exported, so the user assume full control over this.
N              The white-box coverage of 100% of all kernel branches have been reached.
N              Formal verification in progress.
N******************************************************************************/
N
N/* Includes ******************************************************************/
N#define __HDR_DEFS__
N#include "Platform/rmp_platform.h"
L 1 "..\..\MProkaron\Include\Platform/rmp_platform.h" 1
N/******************************************************************************
NFilename    : rmp_platform.h
NAuthor      : pry 
NDate        : 22/07/2017
NLicence     : LGPL v3+; see COPYING for details.
NDescription : The platform specific types for RMP.
N******************************************************************************/
N
N/* Platform Includes *********************************************************/
N#include "Platform/CortexM/rmp_platform_cmx.h"
L 1 "..\..\MProkaron\Include\Platform/CortexM/rmp_platform_cmx.h" 1
N/******************************************************************************
NFilename    : rmp_platform_cmx.h
NAuthor      : pry
NDate        : 01/04/2017
NLicence     : LGPL v3+; see COPYING for details.
NDescription : The header of "rmp_platform_cmx.c".
N******************************************************************************/
N
N/* Defines *******************************************************************/
N#ifdef __HDR_DEFS__
N#ifndef __RMP_PLATFORM_CMX_H_DEFS__
N#define __RMP_PLATFORM_CMX_H_DEFS__
N/*****************************************************************************/
N/* Basic Types ***************************************************************/
N#ifndef __RMP_S32_T__
N#define __RMP_S32_T__
Ntypedef signed int rmp_s32_t;
N#endif
N
N#ifndef __RMP_S16_T__
N#define __RMP_S16_T__
Ntypedef signed short rmp_s16_t;
N#endif
N
N#ifndef __RMP_S8_T__
N#define __RMP_S8_T__
Ntypedef signed char rmp_s8_t;
N#endif
N
N#ifndef __RMP_U32_T__
N#define __RMP_U32_T__
Ntypedef unsigned int rmp_u32_t;
N#endif
N
N#ifndef __RMP_U16_T__
N#define __RMP_U16_T__
Ntypedef unsigned short rmp_u16_t;
N#endif
N
N#ifndef __RMP_U8_T__
N#define __RMP_U8_T__
Ntypedef unsigned char rmp_u8_t;
N#endif
N/* End Basic Types ***********************************************************/
N
N/* Begin Extended Types ******************************************************/
N#ifndef __RMP_PTR_T__
N#define __RMP_PTR_T__
N/* The typedef for the pointers - This is the raw style. Pointers must be unsigned */
Ntypedef rmp_u32_t rmp_ptr_t;
N#endif
N
N#ifndef __RMP_CNT_T__
N#define __RMP_CNT_T__
N/* The typedef for the count variables */
Ntypedef rmp_s32_t rmp_cnt_t;
N#endif
N
N#ifndef __RMP_RET_T__
N#define __RMP_RET_T__
N/* The type for process return value */
Ntypedef rmp_s32_t rmp_ret_t;
N#endif
N/* End Extended Types ********************************************************/
N
N/* System macros *************************************************************/
N/* Compiler "extern" keyword setting */
N#define EXTERN                   extern
N/* The order of bits in one CPU machine word */
N#define RMP_WORD_ORDER           5
N/* The maximum length of char printing - no need to change this in most cases */
N#define RMP_KERNEL_DEBUG_MAX_STR 255
N/* The offset of the stack when initializing */
N#define RMP_INIT_STACK           RMP_INIT_STACK_TAIL(17)
N
N/* The CPU and application specific macros are here */
N#include "rmp_platform_cmx_conf.h"
L 1 "..\..\MProkaron\Include\Platform/CortexM/rmp_platform_cmx_conf.h" 1
N/******************************************************************************
NFilename    : rmp_platform_cmx_conf.h
NAuthor      : pry
NDate        : 24/06/2017
NLicence     : LGPL v3+; see COPYING for details.
NDescription : The configuration file for Cortex-M HAL.
N******************************************************************************/
N
N/* Config Includes ***********************************************************/
N#include "Platform/CortexM/Chips/HC32L136K8/rmp_platform_HC32L136K8.h"
L 1 "..\..\MProkaron\Include\Platform/CortexM/Chips/HC32L136K8/rmp_platform_HC32L136K8.h" 1
N/******************************************************************************
NFilename   : rmp_platform_HC32L136K8.h
NAuthor     : pry
NDate       : 24/06/2017
NLicence    : LGPL v3+; see COPYING for details.
NDescription: The configuration file for HC32L136K8.
N******************************************************************************/
N
N/* Defines *******************************************************************/
N/* The HAL library */
N#include "HC32L136K8TA.h"
L 1 "..\..\..\M0P0_Library\HC32L13X_DDL_V1.0\mcu\common\HC32L136K8TA.h" 1
N/*******************************************************************************
N* Copyright (C) 2018, Huada Semiconductor Co.,Ltd All rights reserved.
N*
N* This software is owned and published by:
N* Huada Semiconductor Co.,Ltd ("HDSC").
N*
N* BY DOWNLOADING, INSTALLING OR USING THIS SOFTWARE, YOU AGREE TO BE BOUND
N* BY ALL THE TERMS AND CONDITIONS OF THIS AGREEMENT.
N*
N* This software contains source code for use with HDSC
N* components. This software is licensed by HDSC to be adapted only
N* for use in systems utilizing HDSC components. HDSC shall not be
N* responsible for misuse or illegal use of this software for devices not
N* supported herein. HDSC is providing this software "AS IS" and will
N* not be responsible for issues arising from incorrect user implementation
N* of the software.
N*
N* Disclaimer:
N* HDSC MAKES NO WARRANTY, EXPRESS OR IMPLIED, ARISING BY LAW OR OTHERWISE,
N* REGARDING THE SOFTWARE (INCLUDING ANY ACOOMPANYING WRITTEN MATERIALS),
N* ITS PERFORMANCE OR SUITABILITY FOR YOUR INTENDED USE, INCLUDING,
N* WITHOUT LIMITATION, THE IMPLIED WARRANTY OF MERCHANTABILITY, THE IMPLIED
N* WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE OR USE, AND THE IMPLIED
N* WARRANTY OF NONINFRINGEMENT.
N* HDSC SHALL HAVE NO LIABILITY (WHETHER IN CONTRACT, WARRANTY, TORT,
N* NEGLIGENCE OR OTHERWISE) FOR ANY DAMAGES WHATSOEVER (INCLUDING, WITHOUT
N* LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS, BUSINESS INTERRUPTION,
N* LOSS OF BUSINESS INFORMATION, OR OTHER PECUNIARY LOSS) ARISING FROM USE OR
N* INABILITY TO USE THE SOFTWARE, INCLUDING, WITHOUT LIMITATION, ANY DIRECT,
N* INDIRECT, INCIDENTAL, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOSS OF DATA,
N* SAVINGS OR PROFITS,
N* EVEN IF Disclaimer HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
N* YOU ASSUME ALL RESPONSIBILITIES FOR SELECTION OF THE SOFTWARE TO ACHIEVE YOUR
N* INTENDED RESULTS, AND FOR THE INSTALLATION OF, USE OF, AND RESULTS OBTAINED
N* FROM, THE SOFTWARE.
N*
N* This software may be replicated in part or whole for the licensed use,
N* with the restriction that this Disclaimer and Copyright notice must be
N* included with each copy of this software, whether used in part or whole,
N* at all times.
N*/
N/******************************************************************************/
N/** \\file HC32L136K8TA.h
N**
N** Auto generate.
N** Headerfile for HC32L136K8TA series MCU
N**
N** History:
N**
N**   - 2018-05-20  0.1   Lux First version.
N**
N******************************************************************************/
N
N#ifndef __HC32L136K8TA_H__
N#define __HC32L136K8TA_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/******************************************************************************
N* Configuration of the Cortex-M0P Processor and Core Peripherals
N******************************************************************************/
N#define __MPU_PRESENT           0 /* No MPU                                       */
N#define __NVIC_PRIO_BITS        2 /* M0P uses 2 Bits for the Priority Levels      */
N#define __Vendor_SysTickConfig  0 /* Set to 1 if different SysTick Config is used */
N
N#include <stdint.h>
L 1 "D:\Program_Files_x86\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060009
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 69 "..\..\..\M0P0_Library\HC32L13X_DDL_V1.0\mcu\common\HC32L136K8TA.h" 2
Nextern uint32_t SystemCoreClock; 
N
N/******************************************************************************
N* Interrupt Number Definition
N******************************************************************************/
Ntypedef enum IRQn
N{
N    NMI_IRQn            = -14, /*  2 Non Maskable                            */
N    HardFault_IRQn      = -13, /*  3 Hard Fault                              */
N    SVC_IRQn            = -5,  /* 11 SV Call                                 */
N    PendSV_IRQn         = -2,  /* 14 Pend SV                                 */
N    SysTick_IRQn        = -1,  /* 15 System Tick                             */
N    
N    PORTA_IRQn          = 0 ,
N    PORTB_IRQn          = 1 ,
N    PORTC_IRQn          = 2 ,
N    PORTD_IRQn          = 3 ,
N    DMAC_IRQn           = 4 ,
N    TIM3_IRQn           = 5 ,
N    UART0_IRQn          = 6 ,
N    UART1_IRQn          = 7 ,
N    LPUART0_IRQn        = 8 ,
N    LPUART1_IRQn        = 9 ,
N    SPI0_IRQn           = 10,
N    SPI1_IRQn           = 11,
N    I2C0_IRQn           = 12,
N    I2C1_IRQn           = 13,
N    TIM0_IRQn           = 14,
N    TIM1_IRQn           = 15,
N    TIM2_IRQn           = 16,
N    LPTIM_IRQn          = 17,
N    TIM4_IRQn           = 18,
N    TIM5_IRQn           = 19,
N    TIM6_IRQn           = 20,
N    PCA_IRQn            = 21,
N    WDT_IRQn            = 22,
N    RTC_IRQn            = 23,
N    ADC_IRQn            = 24,
N    PCNT_IRQn           = 25,
N    VC0_IRQn            = 26,
N    VC1_IRQn            = 27,
N    LVD_IRQn            = 28,
N    LCD_IRQn            = 29,
N    FLASH_RAM_IRQn      = 30,
N    CLK_TRIM_IRQn       = 31,
N    
N    
N} IRQn_Type;
N
N
N#include <core_cm0plus.h>
L 1 "..\..\..\M0P0_Library\HC32L13X_DDL_V1.0\driver\CMSIS\Include\core_cm0plus.h" 1
N/**************************************************************************//**
N * @file     core_cm0plus.h
N * @brief    CMSIS Cortex-M0+ Core Peripheral Access Layer Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060183 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CM0PLUS_H_GENERIC
N#define __CORE_CM0PLUS_H_GENERIC
N
N#include <stdint.h>
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/**
N  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/**
N  \ingroup Cortex-M0+
N  @{
N */
N
N/*  CMSIS CM0+ definitions */
N#define __CM0PLUS_CMSIS_VERSION_MAIN (0x04U)                                   /*!< [31:16] CMSIS HAL main version */
N#define __CM0PLUS_CMSIS_VERSION_SUB  (0x1EU)                                   /*!< [15:0]  CMSIS HAL sub version */
N#define __CM0PLUS_CMSIS_VERSION      ((__CM0PLUS_CMSIS_VERSION_MAIN << 16U) | \
N                                       __CM0PLUS_CMSIS_VERSION_SUB           ) /*!< CMSIS HAL version number */
X#define __CM0PLUS_CMSIS_VERSION      ((__CM0PLUS_CMSIS_VERSION_MAIN << 16U) |                                        __CM0PLUS_CMSIS_VERSION_SUB           )  
N
N#define __CORTEX_M                (0x00U)                                      /*!< Cortex-M Core */
N
N
N#if   defined ( __CC_ARM )
X#if   1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler */
N  #define __STATIC_INLINE  static __inline
N
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler */
S  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler */
S  #define __STATIC_INLINE  static __inline
S
S#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TMS470__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TI CCS Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __CSMC__ )
S  #define __packed
S  #define __ASM            _asm                                      /*!< asm keyword for COSMIC Compiler */
S  #define __INLINE         inline                                    /*!< inline keyword for COSMIC Compiler. Use -pc99 on compile line */
S  #define __STATIC_INLINE  static inline
S
S#else
S  #error Unknown compiler
N#endif
N
N/** __FPU_USED indicates whether an FPU is used or not.
N    This core does not support an FPU at all
N*/
N#define __FPU_USED       0U
N
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 0L
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N  #endif
N
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #if defined __ARM_PCS_VFP
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TMS470__ )
S  #if defined __TI_VFP_SUPPORT__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __CSMC__ )
S  #if ( __CSMC__ & 0x400U)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
N#endif
N
N#include "core_cmInstr.h"                /* Core Instruction Access */
L 1 "..\..\..\M0P0_Library\HC32L13X_DDL_V1.0\driver\CMSIS\Include\core_cmInstr.h" 1
N/**************************************************************************//**
N * @file     core_cmInstr.h
N * @brief    CMSIS Cortex-M Core Instruction Access Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060183 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CMINSTR_H
N#define __CORE_CMINSTR_H
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/*------------------ RealView Compiler -----------------*/
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
L 1 "..\..\..\M0P0_Library\HC32L13X_DDL_V1.0\driver\CMSIS\Include\cmsis_armcc.h" 1
N/**************************************************************************//**
N * @file     cmsis_armcc.h
N * @brief    CMSIS Cortex-M Core Function/Instruction Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#ifndef __CMSIS_ARMCC_H
N#define __CMSIS_ARMCC_H
N
N
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 400677)
X#if 1L && (5060183 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N/**
N  \brief   Get Control Register
N  \details Returns the content of the Control Register.
N  \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/**
N  \brief   Set Control Register
N  \details Writes the given value to the Control Register.
N  \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/**
N  \brief   Get IPSR Register
N  \details Returns the content of the IPSR Register.
N  \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/**
N  \brief   Get APSR Register
N  \details Returns the content of the APSR Register.
N  \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/**
N  \brief   Get xPSR Register
N  \details Returns the content of the xPSR Register.
N  \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/**
N  \brief   Get Process Stack Pointer
N  \details Returns the current value of the Process Stack Pointer (PSP).
N  \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/**
N  \brief   Set Process Stack Pointer
N  \details Assigns the given value to the Process Stack Pointer (PSP).
N  \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/**
N  \brief   Get Main Stack Pointer
N  \details Returns the current value of the Main Stack Pointer (MSP).
N  \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/**
N  \brief   Set Main Stack Pointer
N  \details Assigns the given value to the Main Stack Pointer (MSP).
N  \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/**
N  \brief   Get Priority Mask
N  \details Returns the current state of the priority mask bit from the Priority Mask Register.
N  \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/**
N  \brief   Set Priority Mask
N  \details Assigns the given value to the Priority Mask Register.
N  \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
X#if       ((0x00U) >= 0x03U) || (__CORTEX_SC >= 300U)
S
S/**
S  \brief   Enable FIQ
S  \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
S           Can only be executed in Privileged modes.
S */
S#define __enable_fault_irq                __enable_fiq
S
S
S/**
S  \brief   Disable FIQ
S  \details Disables FIQ interrupts by setting the F-bit in the CPSR.
S           Can only be executed in Privileged modes.
S */
S#define __disable_fault_irq               __disable_fiq
S
S
S/**
S  \brief   Get Base Priority
S  \details Returns the current value of the Base Priority register.
S  \return               Base Priority register value
S */
S__STATIC_INLINE uint32_t  __get_BASEPRI(void)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  return(__regBasePri);
S}
S
S
S/**
S  \brief   Set Base Priority
S  \details Assigns the given value to the Base Priority register.
S  \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  __regBasePri = (basePri & 0xFFU);
S}
S
S
S/**
S  \brief   Set Base Priority with condition
S  \details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
S           or the new value increases the BASEPRI priority level.
S  \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
S{
S  register uint32_t __regBasePriMax      __ASM("basepri_max");
S  __regBasePriMax = (basePri & 0xFFU);
S}
S
S
S/**
S  \brief   Get Fault Mask
S  \details Returns the current value of the Fault Mask register.
S  \return               Fault Mask register value
S */
S__STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  return(__regFaultMask);
S}
S
S
S/**
S  \brief   Set Fault Mask
S  \details Assigns the given value to the Fault Mask register.
S  \param [in]    faultMask  Fault Mask value to set
S */
S__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  __regFaultMask = (faultMask & (uint32_t)1);
S}
S
N#endif /* (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U) */
N
N
N#if       (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U)
X#if       ((0x00U) == 0x04U) || ((0x00U) == 0x07U)
S
S/**
S  \brief   Get FPSCR
S  \details Returns the current value of the Floating Point Status/Control register.
S  \return               Floating Point Status/Control register value
S */
S__STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
S#else
S   return(0U);
S#endif
S}
S
S
S/**
S  \brief   Set FPSCR
S  \details Assigns the given value to the Floating Point Status/Control register.
S  \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
S#endif
S}
S
N#endif /* (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U) */
N
N
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/**
N  \brief   No Operation
N  \details No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/**
N  \brief   Wait For Interrupt
N  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/**
N  \brief   Wait For Event
N  \details Wait For Event is a hint instruction that permits the processor to enter
N           a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/**
N  \brief   Send Event
N  \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/**
N  \brief   Instruction Synchronization Barrier
N  \details Instruction Synchronization Barrier flushes the pipeline in the processor,
N           so that all instructions following the ISB are fetched from cache or memory,
N           after the instruction has been completed.
N */
N#define __ISB() do {\
N                   __schedule_barrier();\
N                   __isb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __ISB() do {                   __schedule_barrier();                   __isb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Synchronization Barrier
N  \details Acts as a special kind of Data Memory Barrier.
N           It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB() do {\
N                   __schedule_barrier();\
N                   __dsb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DSB() do {                   __schedule_barrier();                   __dsb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Memory Barrier
N  \details Ensures the apparent order of the explicit memory operations before
N           and after the instruction, without ensuring their completion.
N */
N#define __DMB() do {\
N                   __schedule_barrier();\
N                   __dmb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DMB() do {                   __schedule_barrier();                   __dmb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Reverse byte order (32 bit)
N  \details Reverses the byte order in integer value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order in two unsigned short values.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N/**
N  \brief   Reverse byte order in signed short value
N  \details Reverses the byte order in a signed short value with sign extension to integer.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Rotate Right in unsigned value (32 bit)
N  \details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N  \param [in]    value  Value to rotate
N  \param [in]    value  Number of Bits to rotate
N  \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/**
N  \brief   Breakpoint
N  \details Causes the processor to enter Debug state.
N           Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N  \param [in]    value  is ignored by the processor.
N                 If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N/**
N  \brief   Reverse bit order of value
N  \details Reverses the bit order of the given value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
X#if       ((0x00U) >= 0x03U) || (__CORTEX_SC >= 300U)
S  #define __RBIT                          __rbit
N#else
N__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
X__attribute__((always_inline)) static __inline uint32_t __RBIT(uint32_t value)
N{
N  uint32_t result;
N  int32_t s = 4 /*sizeof(v)*/ * 8 - 1; /* extra shift needed at end */
N
N  result = value;                      /* r will be reversed bits of v; first get LSB of v */
N  for (value >>= 1U; value; value >>= 1U)
N  {
N    result <<= 1U;
N    result |= value & 1U;
N    s--;
N  }
N  result <<= s;                        /* shift when v's highest bits are zero */
N  return(result);
N}
N#endif
N
N
N/**
N  \brief   Count leading zeros
N  \details Counts the number of leading zeros of a data value.
N  \param [in]  value  Value to count the leading zeros
N  \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N
N#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
X#if       ((0x00U) >= 0x03U) || (__CORTEX_SC >= 300U)
S
S/**
S  \brief   LDR Exclusive (8 bit)
S  \details Executes a exclusive LDR instruction for 8 bit value.
S  \param [in]    ptr  Pointer to data
S  \return             value of type uint8_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXB(ptr)                                                        ((uint8_t ) __ldrex(ptr))
S#else
S  #define __LDREXB(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint8_t ) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   LDR Exclusive (16 bit)
S  \details Executes a exclusive LDR instruction for 16 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint16_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXH(ptr)                                                        ((uint16_t) __ldrex(ptr))
S#else
S  #define __LDREXH(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint16_t) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   LDR Exclusive (32 bit)
S  \details Executes a exclusive LDR instruction for 32 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint32_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXW(ptr)                                                        ((uint32_t ) __ldrex(ptr))
S#else
S  #define __LDREXW(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint32_t ) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (8 bit)
S  \details Executes a exclusive STR instruction for 8 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXB(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXB(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (16 bit)
S  \details Executes a exclusive STR instruction for 16 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXH(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXH(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (32 bit)
S  \details Executes a exclusive STR instruction for 32 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXW(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXW(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   Remove the exclusive lock
S  \details Removes the exclusive lock which is created by LDREX.
S */
S#define __CLREX                           __clrex
S
S
S/**
S  \brief   Signed Saturate
S  \details Saturates a signed value.
S  \param [in]  value  Value to be saturated
S  \param [in]    sat  Bit position to saturate to (1..32)
S  \return             Saturated value
S */
S#define __SSAT                            __ssat
S
S
S/**
S  \brief   Unsigned Saturate
S  \details Saturates an unsigned value.
S  \param [in]  value  Value to be saturated
S  \param [in]    sat  Bit position to saturate to (0..31)
S  \return             Saturated value
S */
S#define __USAT                            __usat
S
S
S/**
S  \brief   Rotate Right with Extend (32 bit)
S  \details Moves each bit of a bitstring right by one bit.
S           The carry input is shifted in at the left end of the bitstring.
S  \param [in]    value  Value to rotate
S  \return               Rotated value
S */
S#ifndef __NO_EMBEDDED_ASM
S__attribute__((section(".rrx_text"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)
S{
S  rrx r0, r0
S  bx lr
S}
S#endif
S
S
S/**
S  \brief   LDRT Unprivileged (8 bit)
S  \details Executes a Unprivileged LDRT instruction for 8 bit value.
S  \param [in]    ptr  Pointer to data
S  \return             value of type uint8_t at (*ptr)
S */
S#define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))
S
S
S/**
S  \brief   LDRT Unprivileged (16 bit)
S  \details Executes a Unprivileged LDRT instruction for 16 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint16_t at (*ptr)
S */
S#define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))
S
S
S/**
S  \brief   LDRT Unprivileged (32 bit)
S  \details Executes a Unprivileged LDRT instruction for 32 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint32_t at (*ptr)
S */
S#define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))
S
S
S/**
S  \brief   STRT Unprivileged (8 bit)
S  \details Executes a Unprivileged STRT instruction for 8 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRBT(value, ptr)               __strt(value, ptr)
S
S
S/**
S  \brief   STRT Unprivileged (16 bit)
S  \details Executes a Unprivileged STRT instruction for 16 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRHT(value, ptr)               __strt(value, ptr)
S
S
S/**
S  \brief   STRT Unprivileged (32 bit)
S  \details Executes a Unprivileged STRT instruction for 32 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRT(value, ptr)                __strt(value, ptr)
S
N#endif /* (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U) */
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N#if (__CORTEX_M >= 0x04U)  /* only for Cortex-M4 and above */
X#if ((0x00U) >= 0x04U)   
S
S#define __SADD8                           __sadd8
S#define __QADD8                           __qadd8
S#define __SHADD8                          __shadd8
S#define __UADD8                           __uadd8
S#define __UQADD8                          __uqadd8
S#define __UHADD8                          __uhadd8
S#define __SSUB8                           __ssub8
S#define __QSUB8                           __qsub8
S#define __SHSUB8                          __shsub8
S#define __USUB8                           __usub8
S#define __UQSUB8                          __uqsub8
S#define __UHSUB8                          __uhsub8
S#define __SADD16                          __sadd16
S#define __QADD16                          __qadd16
S#define __SHADD16                         __shadd16
S#define __UADD16                          __uadd16
S#define __UQADD16                         __uqadd16
S#define __UHADD16                         __uhadd16
S#define __SSUB16                          __ssub16
S#define __QSUB16                          __qsub16
S#define __SHSUB16                         __shsub16
S#define __USUB16                          __usub16
S#define __UQSUB16                         __uqsub16
S#define __UHSUB16                         __uhsub16
S#define __SASX                            __sasx
S#define __QASX                            __qasx
S#define __SHASX                           __shasx
S#define __UASX                            __uasx
S#define __UQASX                           __uqasx
S#define __UHASX                           __uhasx
S#define __SSAX                            __ssax
S#define __QSAX                            __qsax
S#define __SHSAX                           __shsax
S#define __USAX                            __usax
S#define __UQSAX                           __uqsax
S#define __UHSAX                           __uhsax
S#define __USAD8                           __usad8
S#define __USADA8                          __usada8
S#define __SSAT16                          __ssat16
S#define __USAT16                          __usat16
S#define __UXTB16                          __uxtb16
S#define __UXTAB16                         __uxtab16
S#define __SXTB16                          __sxtb16
S#define __SXTAB16                         __sxtab16
S#define __SMUAD                           __smuad
S#define __SMUADX                          __smuadx
S#define __SMLAD                           __smlad
S#define __SMLADX                          __smladx
S#define __SMLALD                          __smlald
S#define __SMLALDX                         __smlaldx
S#define __SMUSD                           __smusd
S#define __SMUSDX                          __smusdx
S#define __SMLSD                           __smlsd
S#define __SMLSDX                          __smlsdx
S#define __SMLSLD                          __smlsld
S#define __SMLSLDX                         __smlsldx
S#define __SEL                             __sel
S#define __QADD                            __qadd
S#define __QSUB                            __qsub
S
S#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
S                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
X#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |                                             ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
S
S#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
S                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
X#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |                                             ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
S
S#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) + \
S                                                      ((int64_t)(ARG3) << 32U)     ) >> 32U))
X#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) +                                                       ((int64_t)(ARG3) << 32U)     ) >> 32U))
S
N#endif /* (__CORTEX_M >= 0x04) */
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#endif /* __CMSIS_ARMCC_H */
L 54 "..\..\..\M0P0_Library\HC32L13X_DDL_V1.0\driver\CMSIS\Include\core_cmInstr.h" 2
N
N/*------------------ ARM Compiler V6 -------------------*/
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #include "cmsis_armcc_V6.h"
S
S/*------------------ GNU Compiler ----------------------*/
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S/*------------------ ICC Compiler ----------------------*/
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iar.h>
S
S/*------------------ TI CCS Compiler -------------------*/
S#elif defined ( __TMS470__ )
S  #include <cmsis_ccs.h>
S
S/*------------------ TASKING Compiler ------------------*/
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S/*------------------ COSMIC Compiler -------------------*/
S#elif defined ( __CSMC__ )
S  #include <cmsis_csm.h>
S
N#endif
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N#endif /* __CORE_CMINSTR_H */
L 164 "..\..\..\M0P0_Library\HC32L13X_DDL_V1.0\driver\CMSIS\Include\core_cm0plus.h" 2
N#include "core_cmFunc.h"                 /* Core Function Access */
L 1 "..\..\..\M0P0_Library\HC32L13X_DDL_V1.0\driver\CMSIS\Include\core_cmFunc.h" 1
N/**************************************************************************//**
N * @file     core_cmFunc.h
N * @brief    CMSIS Cortex-M Core Function Access Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060183 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CMFUNC_H
N#define __CORE_CMFUNC_H
N
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N*/
N
N/*------------------ RealView Compiler -----------------*/
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
N
N/*------------------ ARM Compiler V6 -------------------*/
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #include "cmsis_armcc_V6.h"
S
S/*------------------ GNU Compiler ----------------------*/
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S/*------------------ ICC Compiler ----------------------*/
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iar.h>
S
S/*------------------ TI CCS Compiler -------------------*/
S#elif defined ( __TMS470__ )
S  #include <cmsis_ccs.h>
S
S/*------------------ TASKING Compiler ------------------*/
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S/*------------------ COSMIC Compiler -------------------*/
S#elif defined ( __CSMC__ )
S  #include <cmsis_csm.h>
S
N#endif
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N#endif /* __CORE_CMFUNC_H */
L 165 "..\..\..\M0P0_Library\HC32L13X_DDL_V1.0\driver\CMSIS\Include\core_cm0plus.h" 2
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM0PLUS_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM0PLUS_H_DEPENDANT
N#define __CORE_CM0PLUS_H_DEPENDANT
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM0PLUS_REV
S    #define __CM0PLUS_REV             0x0000U
S    #warning "__CM0PLUS_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __MPU_PRESENT
S    #define __MPU_PRESENT             0U
S    #warning "__MPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __VTOR_PRESENT
S    #define __VTOR_PRESENT            0U
S    #warning "__VTOR_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          2U
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0U
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions */
N
N/* following defines should be used for structure members */
N#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
N#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
N#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
N
N/*@} end of group Cortex-M0+ */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N  - Core MPU Register
N ******************************************************************************/
N/**
N  \defgroup CMSIS_core_register Defines and Type Definitions
N  \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_CORE  Status and Control Registers
N  \brief      Core Register type definitions.
N  @{
N */
N
N/**
N  \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:28;              /*!< bit:  0..27  Reserved */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} APSR_Type;
N
N/* APSR Register Definitions */
N#define APSR_N_Pos                         31U                                            /*!< APSR: N Position */
N#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
N
N#define APSR_Z_Pos                         30U                                            /*!< APSR: Z Position */
N#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
N
N#define APSR_C_Pos                         29U                                            /*!< APSR: C Position */
N#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
N
N#define APSR_V_Pos                         28U                                            /*!< APSR: V Position */
N#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
N
N
N/**
N  \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} IPSR_Type;
N
N/* IPSR Register Definitions */
N#define IPSR_ISR_Pos                        0U                                            /*!< IPSR: ISR Position */
N#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved */
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
N    uint32_t _reserved1:3;               /*!< bit: 25..27  Reserved */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} xPSR_Type;
N
N/* xPSR Register Definitions */
N#define xPSR_N_Pos                         31U                                            /*!< xPSR: N Position */
N#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
N
N#define xPSR_Z_Pos                         30U                                            /*!< xPSR: Z Position */
N#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
N
N#define xPSR_C_Pos                         29U                                            /*!< xPSR: C Position */
N#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
N
N#define xPSR_V_Pos                         28U                                            /*!< xPSR: V Position */
N#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
N
N#define xPSR_T_Pos                         24U                                            /*!< xPSR: T Position */
N#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
N
N#define xPSR_ISR_Pos                        0U                                            /*!< xPSR: ISR Position */
N#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
N    uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} CONTROL_Type;
N
N/* CONTROL Register Definitions */
N#define CONTROL_SPSEL_Pos                   1U                                            /*!< CONTROL: SPSEL Position */
N#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
N
N#define CONTROL_nPRIV_Pos                   0U                                            /*!< CONTROL: nPRIV Position */
N#define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONTROL: nPRIV Mask */
N
N/*@} end of group CMSIS_CORE */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N  \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IOM uint32_t ISER[1U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
X  volatile uint32_t ISER[1U];                
N        uint32_t RESERVED0[31U];
N  __IOM uint32_t ICER[1U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
X  volatile uint32_t ICER[1U];                
N        uint32_t RSERVED1[31U];
N  __IOM uint32_t ISPR[1U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
X  volatile uint32_t ISPR[1U];                
N        uint32_t RESERVED2[31U];
N  __IOM uint32_t ICPR[1U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
X  volatile uint32_t ICPR[1U];                
N        uint32_t RESERVED3[31U];
N        uint32_t RESERVED4[64U];
N  __IOM uint32_t IP[8U];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register */
X  volatile uint32_t IP[8U];                  
N}  NVIC_Type;
N
N/*@} end of group CMSIS_NVIC */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCB     System Control Block (SCB)
N  \brief    Type definitions for the System Control Block Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
X  volatile const  uint32_t CPUID;                   
N  __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
X  volatile uint32_t ICSR;                    
N#if (__VTOR_PRESENT == 1U)
S  __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
N#else
N        uint32_t RESERVED0;
N#endif
N  __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
X  volatile uint32_t AIRCR;                   
N  __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
X  volatile uint32_t SCR;                     
N  __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
X  volatile uint32_t CCR;                     
N        uint32_t RESERVED1;
N  __IOM uint32_t SHP[2U];                /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED */
X  volatile uint32_t SHP[2U];                 
N  __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
X  volatile uint32_t SHCSR;                   
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
N
N#if (__VTOR_PRESENT == 1U)
S/* SCB Interrupt Control State Register Definitions */
S#define SCB_VTOR_TBLOFF_Pos                 8U                                            /*!< SCB VTOR: TBLOFF Position */
S#define SCB_VTOR_TBLOFF_Msk                (0xFFFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB VTOR: TBLOFF Mask */
N#endif
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N  \brief    Type definitions for the System Timer Registers.
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
X  volatile uint32_t LOAD;                    
N  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
X  volatile uint32_t VAL;                     
N  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
X  volatile const  uint32_t CALIB;                   
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N#if (__MPU_PRESENT == 1U)
X#if (0 == 1U)
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
S  \brief    Type definitions for the Memory Protection Unit (MPU)
S  @{
S */
S
S/**
S  \brief  Structure type to access the Memory Protection Unit (MPU).
S */
Stypedef struct
S{
S  __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
S  __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
S  __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
S  __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register */
S  __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register */
S} MPU_Type;
S
S/* MPU Type Register Definitions */
S#define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU TYPE: IREGION Position */
S#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
S
S#define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU TYPE: DREGION Position */
S#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
S
S#define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU TYPE: SEPARATE Position */
S#define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU TYPE: SEPARATE Mask */
S
S/* MPU Control Register Definitions */
S#define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU CTRL: PRIVDEFENA Position */
S#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
S
S#define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU CTRL: HFNMIENA Position */
S#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
S
S#define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU CTRL: ENABLE Position */
S#define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU CTRL: ENABLE Mask */
S
S/* MPU Region Number Register Definitions */
S#define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU RNR: REGION Position */
S#define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU RNR: REGION Mask */
S
S/* MPU Region Base Address Register Definitions */
S#define MPU_RBAR_ADDR_Pos                   8U                                            /*!< MPU RBAR: ADDR Position */
S#define MPU_RBAR_ADDR_Msk                  (0xFFFFFFUL << MPU_RBAR_ADDR_Pos)              /*!< MPU RBAR: ADDR Mask */
S
S#define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU RBAR: VALID Position */
S#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
S
S#define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU RBAR: REGION Position */
S#define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU RBAR: REGION Mask */
S
S/* MPU Region Attribute and Size Register Definitions */
S#define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU RASR: MPU Region Attribute field Position */
S#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
S
S#define MPU_RASR_XN_Pos                    28U                                            /*!< MPU RASR: ATTRS.XN Position */
S#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
S
S#define MPU_RASR_AP_Pos                    24U                                            /*!< MPU RASR: ATTRS.AP Position */
S#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
S
S#define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU RASR: ATTRS.TEX Position */
S#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
S
S#define MPU_RASR_S_Pos                     18U                                            /*!< MPU RASR: ATTRS.S Position */
S#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
S
S#define MPU_RASR_C_Pos                     17U                                            /*!< MPU RASR: ATTRS.C Position */
S#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
S
S#define MPU_RASR_B_Pos                     16U                                            /*!< MPU RASR: ATTRS.B Position */
S#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
S
S#define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU RASR: Sub-Region Disable Position */
S#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
S
S#define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU RASR: Region Size Field Position */
S#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
S
S#define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU RASR: Region enable bit Position */
S#define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU RASR: Region enable bit Disable Mask */
S
S/*@} end of group CMSIS_MPU */
N#endif
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N  \brief    Cortex-M0+ Core Debug Registers (DCB registers, SHCSR, and DFSR) are only accessible over DAP and not via processor.
N            Therefore they are not covered by the Cortex-M0+ header file.
N  @{
N */
N/*@} end of group CMSIS_CoreDebug */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_bitfield     Core register bit field macros
N  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
N  @{
N */
N
N/**
N  \brief   Mask and shift a bit field value for use in a register bit range.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of the bit field.
N  \return           Masked and shifted value.
N*/
N#define _VAL2FLD(field, value)    ((value << field ## _Pos) & field ## _Msk)
N
N/**
N  \brief     Mask and shift a register value to extract a bit filed value.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of register.
N  \return           Masked and shifted bit field value.
N*/
N#define _FLD2VAL(field, value)    ((value & field ## _Msk) >> field ## _Pos)
N
N/*@} end of group CMSIS_core_bitfield */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_base     Core Definitions
N  \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Cortex-M0+ Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct */
N
N#if (__MPU_PRESENT == 1U)
X#if (0 == 1U)
S  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit */
S  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit */
N#endif
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/**
N  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N  \brief    Functions that manage interrupts and exceptions via the NVIC.
N  @{
N */
N
N/* Interrupt Priorities are WORD accessible only under ARMv6M                   */
N/* The following MACROS handle generation of the register offset and byte masks */
N#define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)
N#define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )
N#define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )
N
N
N/**
N  \brief   Enable External Interrupt
N  \details Enables a device-specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Disable External Interrupt
N  \details Disables a device-specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Get Pending Interrupt
N  \details Reads the pending register in the NVIC and returns the pending bit for the specified interrupt.
N  \param [in]      IRQn  Interrupt number.
N  \return             0  Interrupt status is not pending.
N  \return             1  Interrupt status is pending.
N */
N__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t)(((NVIC->ISPR[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X  return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N}
N
N
N/**
N  \brief   Set Pending Interrupt
N  \details Sets the pending bit of an external interrupt.
N  \param [in]      IRQn  Interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Clear Pending Interrupt
N  \details Clears the pending bit of an external interrupt.
N  \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Set Interrupt Priority
N  \details Sets the priority of an interrupt.
N  \note    The priority cannot be set for every core interrupt.
N  \param [in]      IRQn  Interrupt number.
N  \param [in]  priority  Priority to set.
N */
N__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if ((int32_t)(IRQn) < 0)
N  {
N    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] = ((uint32_t)(((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] & ~(0xFFUL << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL))) |
N       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
X       (((priority << (8U - 2)) & (uint32_t)0xFFUL) << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL)));
N  }
N  else
N  {
N    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )]  = ((uint32_t)(((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )]  & ~(0xFFUL << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL))) |
N       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
X       (((priority << (8U - 2)) & (uint32_t)0xFFUL) << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL)));
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Priority
N  \details Reads the priority of an interrupt.
N           The interrupt number can be positive to specify an external (device specific) interrupt,
N           or negative to specify an internal (core) interrupt.
N  \param [in]   IRQn  Interrupt number.
N  \return             Interrupt Priority.
N                      Value is aligned automatically to the implemented priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if ((int32_t)(IRQn) < 0)
N  {
N    return((uint32_t)(((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
X    return((uint32_t)(((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] >> ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL) ) & (uint32_t)0xFFUL) >> (8U - 2)));
N  }
N  else
N  {
N    return((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[ ( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )] >> ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL) ) & (uint32_t)0xFFUL) >> (8U - 2)));
N  }
N}
N
N
N/**
N  \brief   System Reset
N  \details Initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  __DSB();                                                          /* Ensure all outstanding memory accesses included
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                          
N                                                                       buffered write are completed before reset */
N  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = ((0x5FAUL << 16U) |
N                 SCB_AIRCR_SYSRESETREQ_Msk);
X                 (1UL << 2U));
N  __DSB();                                                          /* Ensure completion of memory access */
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                           
N
N  for(;;)                                                           /* wait until reset */
N  {
N    __NOP();
X    __nop();
N  }
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N  \brief    Functions that configure the System.
N  @{
N */
N
N#if (__Vendor_SysTickConfig == 0U)
X#if (0 == 0U)
N
N/**
N  \brief   System Tick Configuration
N  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
N           Counter is in free running mode to generate periodic interrupts.
N  \param [in]  ticks  Number of ticks between two interrupts.
N  \return          0  Function succeeded.
N  \return          1  Function failed.
N  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N           must contain a vendor-specific implementation of this function.
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
X  if ((ticks - 1UL) > (0xFFFFFFUL ))
N  {
N    return (1UL);                                                   /* Reload value impossible */
N  }
N
N  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (uint32_t)(ticks - 1UL);                          
N  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
X  NVIC_SetPriority (SysTick_IRQn, (1UL << 2) - 1UL);  
N  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0UL;                                              
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2U) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1U)   |
N                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL );                          
N  return (0UL);                                                     /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM0PLUS_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
L 120 "..\..\..\M0P0_Library\HC32L13X_DDL_V1.0\mcu\common\HC32L136K8TA.h" 2
N#include <stdint.h>
N
N#define SUCCESS         (0)
N#define ERROR           (-1)
N
N#ifndef NULL
N#define NULL            (0)
N#endif
N
N
N/******************************************************************************/
N/*                Device Specific Peripheral Registers structures             */
N/******************************************************************************/
N
N#if defined ( __CC_ARM   )
X#if 1L
N#pragma anon_unions
N#endif
N
Ntypedef struct
N{
N    __IO uint32_t EN                        : 1;
X    volatile uint32_t EN                        : 1;
N    uint32_t RESERVED1                      : 1;
N    __IO uint32_t CLKDIV                    : 2;
X    volatile uint32_t CLKDIV                    : 2;
N    __IO uint32_t SGLMUX                    : 5;
X    volatile uint32_t SGLMUX                    : 5;
N    __IO uint32_t REF                       : 2;
X    volatile uint32_t REF                       : 2;
N    __IO uint32_t BUF                       : 1;
X    volatile uint32_t BUF                       : 1;
N    __IO uint32_t SAM                       : 2;
X    volatile uint32_t SAM                       : 2;
N    uint32_t RESERVED14                     : 1;
N    __IO uint32_t IE                        : 1;
X    volatile uint32_t IE                        : 1;
N} stc_adc_cr0_field_t;
N
Ntypedef struct
N{
N    uint32_t RESERVED0                      : 2;
N    __IO uint32_t ALIGN                     : 1;
X    volatile uint32_t ALIGN                     : 1;
N    __IO uint32_t THCH                      : 5;
X    volatile uint32_t THCH                      : 5;
N    __IO uint32_t DMASQR                    : 1;
X    volatile uint32_t DMASQR                    : 1;
N    __IO uint32_t DMAJQR                    : 1;
X    volatile uint32_t DMAJQR                    : 1;
N    __IO uint32_t MODE                      : 1;
X    volatile uint32_t MODE                      : 1;
N    __IO uint32_t RACC_EN                   : 1;
X    volatile uint32_t RACC_EN                   : 1;
N    __IO uint32_t LTCMP                     : 1;
X    volatile uint32_t LTCMP                     : 1;
N    __IO uint32_t HTCMP                     : 1;
X    volatile uint32_t HTCMP                     : 1;
N    __IO uint32_t REGCMP                    : 1;
X    volatile uint32_t REGCMP                    : 1;
N    __IO uint32_t RACCCLR                   : 1;
X    volatile uint32_t RACCCLR                   : 1;
N} stc_adc_cr1_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CH0MUX                    : 5;
X    volatile uint32_t CH0MUX                    : 5;
N    __IO uint32_t CH1MUX                    : 5;
X    volatile uint32_t CH1MUX                    : 5;
N    __IO uint32_t CH2MUX                    : 5;
X    volatile uint32_t CH2MUX                    : 5;
N    __IO uint32_t CH3MUX                    : 5;
X    volatile uint32_t CH3MUX                    : 5;
N    __IO uint32_t CH4MUX                    : 5;
X    volatile uint32_t CH4MUX                    : 5;
N    __IO uint32_t CH5MUX                    : 5;
X    volatile uint32_t CH5MUX                    : 5;
N} stc_adc_sqr0_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CH6MUX                    : 5;
X    volatile uint32_t CH6MUX                    : 5;
N    __IO uint32_t CH7MUX                    : 5;
X    volatile uint32_t CH7MUX                    : 5;
N    __IO uint32_t CH8MUX                    : 5;
X    volatile uint32_t CH8MUX                    : 5;
N    __IO uint32_t CH9MUX                    : 5;
X    volatile uint32_t CH9MUX                    : 5;
N    __IO uint32_t CH10MUX                   : 5;
X    volatile uint32_t CH10MUX                   : 5;
N    __IO uint32_t CH11MUX                   : 5;
X    volatile uint32_t CH11MUX                   : 5;
N} stc_adc_sqr1_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CH12MUX                   : 5;
X    volatile uint32_t CH12MUX                   : 5;
N    __IO uint32_t CH13MUX                   : 5;
X    volatile uint32_t CH13MUX                   : 5;
N    __IO uint32_t CH14MUX                   : 5;
X    volatile uint32_t CH14MUX                   : 5;
N    __IO uint32_t CH15MUX                   : 5;
X    volatile uint32_t CH15MUX                   : 5;
N    __IO uint32_t CNT                       : 4;
X    volatile uint32_t CNT                       : 4;
N} stc_adc_sqr2_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CH0MUX                    : 5;
X    volatile uint32_t CH0MUX                    : 5;
N    __IO uint32_t CH1MUX                    : 5;
X    volatile uint32_t CH1MUX                    : 5;
N    __IO uint32_t CH2MUX                    : 5;
X    volatile uint32_t CH2MUX                    : 5;
N    __IO uint32_t CH3MUX                    : 5;
X    volatile uint32_t CH3MUX                    : 5;
N    __IO uint32_t CNT                       : 2;
X    volatile uint32_t CNT                       : 2;
N} stc_adc_jqr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t RESULT                    :12;
X    volatile uint32_t RESULT                    :12;
N} stc_adc_sqrresult0_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t RESULT                    :12;
X    volatile uint32_t RESULT                    :12;
N} stc_adc_sqrresult1_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t RESULT                    :12;
X    volatile uint32_t RESULT                    :12;
N} stc_adc_sqrresult2_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t RESULT                    :12;
X    volatile uint32_t RESULT                    :12;
N} stc_adc_sqrresult3_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t RESULT                    :12;
X    volatile uint32_t RESULT                    :12;
N} stc_adc_sqrresult4_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t RESULT                    :12;
X    volatile uint32_t RESULT                    :12;
N} stc_adc_sqrresult5_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t RESULT                    :12;
X    volatile uint32_t RESULT                    :12;
N} stc_adc_sqrresult6_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t RESULT                    :12;
X    volatile uint32_t RESULT                    :12;
N} stc_adc_sqrresult7_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t RESULT                    :12;
X    volatile uint32_t RESULT                    :12;
N} stc_adc_sqrresult8_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t RESULT                    :12;
X    volatile uint32_t RESULT                    :12;
N} stc_adc_sqrresult9_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t RESULT                    :12;
X    volatile uint32_t RESULT                    :12;
N} stc_adc_sqrresult10_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t RESULT                    :12;
X    volatile uint32_t RESULT                    :12;
N} stc_adc_sqrresult11_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t RESULT                    :12;
X    volatile uint32_t RESULT                    :12;
N} stc_adc_sqrresult12_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t RESULT                    :12;
X    volatile uint32_t RESULT                    :12;
N} stc_adc_sqr_result13_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t RESULT                    :12;
X    volatile uint32_t RESULT                    :12;
N} stc_adc_sqrresult14_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t RESULT                    :12;
X    volatile uint32_t RESULT                    :12;
N} stc_adc_sqrresult15_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t RESULT                    :12;
X    volatile uint32_t RESULT                    :12;
N} stc_adc_jqrresult0_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t RESULT                    :12;
X    volatile uint32_t RESULT                    :12;
N} stc_adc_jqrresult1_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t RESULT                    :12;
X    volatile uint32_t RESULT                    :12;
N} stc_adc_jqrresult2_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t RESULT                    :12;
X    volatile uint32_t RESULT                    :12;
N} stc_adc_jqrresult3_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t RESULT                    :12;
X    volatile uint32_t RESULT                    :12;
N} stc_adc_result_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t RESULTACC                 :20;
X    volatile uint32_t RESULTACC                 :20;
N} stc_adc_resultacc_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t HT                        :12;
X    volatile uint32_t HT                        :12;
N} stc_adc_ht_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t LT                        :12;
X    volatile uint32_t LT                        :12;
N} stc_adc_lt_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SGLIF                     : 1;
X    volatile uint32_t SGLIF                     : 1;
N    __IO uint32_t LTIF                      : 1;
X    volatile uint32_t LTIF                      : 1;
N    __IO uint32_t HTIF                      : 1;
X    volatile uint32_t HTIF                      : 1;
N    __IO uint32_t REGIF                     : 1;
X    volatile uint32_t REGIF                     : 1;
N    __IO uint32_t SQRIF                     : 1;
X    volatile uint32_t SQRIF                     : 1;
N    __IO uint32_t JQRIF                     : 1;
X    volatile uint32_t JQRIF                     : 1;
N} stc_adc_ifr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SGLIC                     : 1;
X    volatile uint32_t SGLIC                     : 1;
N    __IO uint32_t LTIC                      : 1;
X    volatile uint32_t LTIC                      : 1;
N    __IO uint32_t HTIC                      : 1;
X    volatile uint32_t HTIC                      : 1;
N    __IO uint32_t REGIC                     : 1;
X    volatile uint32_t REGIC                     : 1;
N    __IO uint32_t SQRIC                     : 1;
X    volatile uint32_t SQRIC                     : 1;
N    __IO uint32_t JQRIC                     : 1;
X    volatile uint32_t JQRIC                     : 1;
N} stc_adc_icr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t TIM0                      : 1;
X    volatile uint32_t TIM0                      : 1;
N    __IO uint32_t TIM1                      : 1;
X    volatile uint32_t TIM1                      : 1;
N    __IO uint32_t TIM2                      : 1;
X    volatile uint32_t TIM2                      : 1;
N    __IO uint32_t TIM3                      : 1;
X    volatile uint32_t TIM3                      : 1;
N    __IO uint32_t TIM4                      : 1;
X    volatile uint32_t TIM4                      : 1;
N    __IO uint32_t TIM5                      : 1;
X    volatile uint32_t TIM5                      : 1;
N    __IO uint32_t TIM6                      : 1;
X    volatile uint32_t TIM6                      : 1;
N    __IO uint32_t UART0                     : 1;
X    volatile uint32_t UART0                     : 1;
N    __IO uint32_t UART1                     : 1;
X    volatile uint32_t UART1                     : 1;
N    __IO uint32_t LPUART0                   : 1;
X    volatile uint32_t LPUART0                   : 1;
N    __IO uint32_t LPUART1                   : 1;
X    volatile uint32_t LPUART1                   : 1;
N    __IO uint32_t VC0                       : 1;
X    volatile uint32_t VC0                       : 1;
N    __IO uint32_t VC1                       : 1;
X    volatile uint32_t VC1                       : 1;
N    __IO uint32_t RTC                       : 1;
X    volatile uint32_t RTC                       : 1;
N    __IO uint32_t PCA                       : 1;
X    volatile uint32_t PCA                       : 1;
N    __IO uint32_t SPI0                      : 1;
X    volatile uint32_t SPI0                      : 1;
N    __IO uint32_t SPI1                      : 1;
X    volatile uint32_t SPI1                      : 1;
N    __IO uint32_t DMA                       : 1;
X    volatile uint32_t DMA                       : 1;
N    __IO uint32_t PA03                      : 1;
X    volatile uint32_t PA03                      : 1;
N    __IO uint32_t PB03                      : 1;
X    volatile uint32_t PB03                      : 1;
N    __IO uint32_t PC03                      : 1;
X    volatile uint32_t PC03                      : 1;
N    __IO uint32_t PD03                      : 1;
X    volatile uint32_t PD03                      : 1;
N    __IO uint32_t PA07                      : 1;
X    volatile uint32_t PA07                      : 1;
N    __IO uint32_t PB07                      : 1;
X    volatile uint32_t PB07                      : 1;
N    __IO uint32_t PC07                      : 1;
X    volatile uint32_t PC07                      : 1;
N    __IO uint32_t PD07                      : 1;
X    volatile uint32_t PD07                      : 1;
N    __IO uint32_t PA11                      : 1;
X    volatile uint32_t PA11                      : 1;
N    __IO uint32_t PB11                      : 1;
X    volatile uint32_t PB11                      : 1;
N    __IO uint32_t PC11                      : 1;
X    volatile uint32_t PC11                      : 1;
N    __IO uint32_t PA15                      : 1;
X    volatile uint32_t PA15                      : 1;
N    __IO uint32_t PB15                      : 1;
X    volatile uint32_t PB15                      : 1;
N    __IO uint32_t PC15                      : 1;
X    volatile uint32_t PC15                      : 1;
N} stc_adc_exttrigger0_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t TIM0                      : 1;
X    volatile uint32_t TIM0                      : 1;
N    __IO uint32_t TIM1                      : 1;
X    volatile uint32_t TIM1                      : 1;
N    __IO uint32_t TIM2                      : 1;
X    volatile uint32_t TIM2                      : 1;
N    __IO uint32_t TIM3                      : 1;
X    volatile uint32_t TIM3                      : 1;
N    __IO uint32_t TIM4                      : 1;
X    volatile uint32_t TIM4                      : 1;
N    __IO uint32_t TIM5                      : 1;
X    volatile uint32_t TIM5                      : 1;
N    __IO uint32_t TIM6                      : 1;
X    volatile uint32_t TIM6                      : 1;
N    __IO uint32_t UART0                     : 1;
X    volatile uint32_t UART0                     : 1;
N    __IO uint32_t UART1                     : 1;
X    volatile uint32_t UART1                     : 1;
N    __IO uint32_t LPUART0                   : 1;
X    volatile uint32_t LPUART0                   : 1;
N    __IO uint32_t LPUART1                   : 1;
X    volatile uint32_t LPUART1                   : 1;
N    __IO uint32_t VC0                       : 1;
X    volatile uint32_t VC0                       : 1;
N    __IO uint32_t VC1                       : 1;
X    volatile uint32_t VC1                       : 1;
N    __IO uint32_t RTC                       : 1;
X    volatile uint32_t RTC                       : 1;
N    __IO uint32_t PCA                       : 1;
X    volatile uint32_t PCA                       : 1;
N    __IO uint32_t SPI0                      : 1;
X    volatile uint32_t SPI0                      : 1;
N    __IO uint32_t SPI1                      : 1;
X    volatile uint32_t SPI1                      : 1;
N    __IO uint32_t DMA                       : 1;
X    volatile uint32_t DMA                       : 1;
N    __IO uint32_t PA03                      : 1;
X    volatile uint32_t PA03                      : 1;
N    __IO uint32_t PB03                      : 1;
X    volatile uint32_t PB03                      : 1;
N    __IO uint32_t PC03                      : 1;
X    volatile uint32_t PC03                      : 1;
N    __IO uint32_t PD03                      : 1;
X    volatile uint32_t PD03                      : 1;
N    __IO uint32_t PA07                      : 1;
X    volatile uint32_t PA07                      : 1;
N    __IO uint32_t PB07                      : 1;
X    volatile uint32_t PB07                      : 1;
N    __IO uint32_t PC07                      : 1;
X    volatile uint32_t PC07                      : 1;
N    __IO uint32_t PD07                      : 1;
X    volatile uint32_t PD07                      : 1;
N    __IO uint32_t PA11                      : 1;
X    volatile uint32_t PA11                      : 1;
N    __IO uint32_t PB11                      : 1;
X    volatile uint32_t PB11                      : 1;
N    __IO uint32_t PC11                      : 1;
X    volatile uint32_t PC11                      : 1;
N    __IO uint32_t PA15                      : 1;
X    volatile uint32_t PA15                      : 1;
N    __IO uint32_t PB15                      : 1;
X    volatile uint32_t PB15                      : 1;
N    __IO uint32_t PC15                      : 1;
X    volatile uint32_t PC15                      : 1;
N} stc_adc_exttrigger1_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t START                     : 1;
X    volatile uint32_t START                     : 1;
N} stc_adc_sglstart_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t START                     : 1;
X    volatile uint32_t START                     : 1;
N} stc_adc_sqrstart_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t START                     : 1;
X    volatile uint32_t START                     : 1;
N} stc_adc_jqrstart_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t START                     : 1;
X    volatile uint32_t START                     : 1;
N    __IO uint32_t MODE                      : 1;
X    volatile uint32_t MODE                      : 1;
N} stc_aes_cr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t DATA0                     :32;
X    volatile uint32_t DATA0                     :32;
N} stc_aes_data0_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t DATA0                     :32;
X    volatile uint32_t DATA0                     :32;
N} stc_aes_data1_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t DATA0                     :32;
X    volatile uint32_t DATA0                     :32;
N} stc_aes_data2_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t DATA0                     :32;
X    volatile uint32_t DATA0                     :32;
N} stc_aes_data3_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t KEY0                      :32;
X    volatile uint32_t KEY0                      :32;
N} stc_aes_key0_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t KEY0                      :32;
X    volatile uint32_t KEY0                      :32;
N} stc_aes_key1_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t KEY0                      :32;
X    volatile uint32_t KEY0                      :32;
N} stc_aes_key2_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t KEY0                      :32;
X    volatile uint32_t KEY0                      :32;
N} stc_aes_key3_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t BGR_EN                    : 1;
X    volatile uint32_t BGR_EN                    : 1;
N    __IO uint32_t TS_EN                     : 1;
X    volatile uint32_t TS_EN                     : 1;
N} stc_bgr_cr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t TRIM_START                : 1;
X    volatile uint32_t TRIM_START                : 1;
N    __IO uint32_t REFCLK_SEL                : 3;
X    volatile uint32_t REFCLK_SEL                : 3;
N    __IO uint32_t CALCLK_SEL                : 2;
X    volatile uint32_t CALCLK_SEL                : 2;
N    __IO uint32_t MON_EN                    : 1;
X    volatile uint32_t MON_EN                    : 1;
N    __IO uint32_t IE                        : 1;
X    volatile uint32_t IE                        : 1;
N    __IO uint32_t CALCLK_SEL2               : 1;
X    volatile uint32_t CALCLK_SEL2               : 1;
N} stc_clk_trim_cr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t RCNTVAL                   :32;
X    volatile uint32_t RCNTVAL                   :32;
N} stc_clk_trim_refcon_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t REFCNT                    :32;
X    volatile uint32_t REFCNT                    :32;
N} stc_clk_trim_refcnt_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CALCNT                    :32;
X    volatile uint32_t CALCNT                    :32;
N} stc_clk_trim_calcnt_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t STOP                      : 1;
X    volatile uint32_t STOP                      : 1;
N    __IO uint32_t CALCNT_OF                 : 1;
X    volatile uint32_t CALCNT_OF                 : 1;
N    __IO uint32_t XTL_FAULT                 : 1;
X    volatile uint32_t XTL_FAULT                 : 1;
N    __IO uint32_t XTH_FAULT                 : 1;
X    volatile uint32_t XTH_FAULT                 : 1;
N    __IO uint32_t PLL_FAULT                 : 1;
X    volatile uint32_t PLL_FAULT                 : 1;
N} stc_clk_trim_ifr_field_t;
N
Ntypedef struct
N{
N    uint32_t RESERVED0                      : 2;
N    __IO uint32_t XTL_FAULT_CLR             : 1;
X    volatile uint32_t XTL_FAULT_CLR             : 1;
N    __IO uint32_t XTH_FAULT_CLR             : 1;
X    volatile uint32_t XTH_FAULT_CLR             : 1;
N    __IO uint32_t PLL_FAULT_CLR             : 1;
X    volatile uint32_t PLL_FAULT_CLR             : 1;
N} stc_clk_trim_iclr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CCNTVAL                   :32;
X    volatile uint32_t CCNTVAL                   :32;
N} stc_clk_trim_calcon_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CR                        : 1;
X    volatile uint32_t CR                        : 1;
N    __IO uint32_t FLAG                      : 1;
X    volatile uint32_t FLAG                      : 1;
N} stc_crc_cr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t RESULT                    :32;
X    volatile uint32_t RESULT                    :32;
N} stc_crc_result_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t DATA                      :32;
X    volatile uint32_t DATA                      :32;
N} stc_crc_data_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t TIM0                      : 1;
X    volatile uint32_t TIM0                      : 1;
N    __IO uint32_t TIM1                      : 1;
X    volatile uint32_t TIM1                      : 1;
N    __IO uint32_t TIM2                      : 1;
X    volatile uint32_t TIM2                      : 1;
N    __IO uint32_t LPTIM                     : 1;
X    volatile uint32_t LPTIM                     : 1;
N    __IO uint32_t TIM4                      : 1;
X    volatile uint32_t TIM4                      : 1;
N    __IO uint32_t TIM5                      : 1;
X    volatile uint32_t TIM5                      : 1;
N    __IO uint32_t TIM6                      : 1;
X    volatile uint32_t TIM6                      : 1;
N    __IO uint32_t PCA                       : 1;
X    volatile uint32_t PCA                       : 1;
N    __IO uint32_t WDT                       : 1;
X    volatile uint32_t WDT                       : 1;
N    __IO uint32_t RTC                       : 1;
X    volatile uint32_t RTC                       : 1;
N    uint32_t RESERVED10                     : 1;
N    __IO uint32_t TIM3                      : 1;
X    volatile uint32_t TIM3                      : 1;
N} stc_debug_active_field_t;
N
Ntypedef struct
N{
N    uint32_t RESERVED0                      :24;
N    __IO uint32_t HALT                      : 4;
X    volatile uint32_t HALT                      : 4;
N    __IO uint32_t PRIO                      : 1;
X    volatile uint32_t PRIO                      : 1;
N    uint32_t RESERVED29                     : 1;
N    __IO uint32_t ST                        : 1;
X    volatile uint32_t ST                        : 1;
N    __IO uint32_t EN                        : 1;
X    volatile uint32_t EN                        : 1;
N} stc_dmac_conf_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t TC                        :16;
X    volatile uint32_t TC                        :16;
N    __IO uint32_t BC                        : 4;
X    volatile uint32_t BC                        : 4;
N    uint32_t RESERVED20                     : 3;
N    __IO uint32_t TRI_SEL                   : 6;
X    volatile uint32_t TRI_SEL                   : 6;
N    __IO uint32_t ST                        : 1;
X    volatile uint32_t ST                        : 1;
N    __IO uint32_t PAS                       : 1;
X    volatile uint32_t PAS                       : 1;
N    __IO uint32_t ENS                       : 1;
X    volatile uint32_t ENS                       : 1;
N} stc_dmac_confa0_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t MSK                       : 1;
X    volatile uint32_t MSK                       : 1;
N    uint32_t RESERVED1                      :15;
N    __IO uint32_t STAT                      : 3;
X    volatile uint32_t STAT                      : 3;
N    __IO uint32_t FIS_IE                    : 1;
X    volatile uint32_t FIS_IE                    : 1;
N    __IO uint32_t ERR_IE                    : 1;
X    volatile uint32_t ERR_IE                    : 1;
N    __IO uint32_t RD                        : 1;
X    volatile uint32_t RD                        : 1;
N    __IO uint32_t RS                        : 1;
X    volatile uint32_t RS                        : 1;
N    __IO uint32_t RC                        : 1;
X    volatile uint32_t RC                        : 1;
N    __IO uint32_t FD                        : 1;
X    volatile uint32_t FD                        : 1;
N    __IO uint32_t FS                        : 1;
X    volatile uint32_t FS                        : 1;
N    __IO uint32_t WIDTH                     : 2;
X    volatile uint32_t WIDTH                     : 2;
N    __IO uint32_t MODE                      : 2;
X    volatile uint32_t MODE                      : 2;
N} stc_dmac_confb0_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SRCADR                    :32;
X    volatile uint32_t SRCADR                    :32;
N} stc_dmac_srcadr0_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t DSTADR                    :32;
X    volatile uint32_t DSTADR                    :32;
N} stc_dmac_dstadr0_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t TC                        :16;
X    volatile uint32_t TC                        :16;
N    __IO uint32_t BC                        : 4;
X    volatile uint32_t BC                        : 4;
N    uint32_t RESERVED20                     : 3;
N    __IO uint32_t TRI_SEL                   : 6;
X    volatile uint32_t TRI_SEL                   : 6;
N    __IO uint32_t ST                        : 1;
X    volatile uint32_t ST                        : 1;
N    __IO uint32_t PAS                       : 1;
X    volatile uint32_t PAS                       : 1;
N    __IO uint32_t ENS                       : 1;
X    volatile uint32_t ENS                       : 1;
N} stc_dmac_confa1_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t MSK                       : 1;
X    volatile uint32_t MSK                       : 1;
N    uint32_t RESERVED1                      :15;
N    __IO uint32_t STAT                      : 3;
X    volatile uint32_t STAT                      : 3;
N    __IO uint32_t FIS_IE                    : 1;
X    volatile uint32_t FIS_IE                    : 1;
N    __IO uint32_t ERR_IE                    : 1;
X    volatile uint32_t ERR_IE                    : 1;
N    __IO uint32_t RD                        : 1;
X    volatile uint32_t RD                        : 1;
N    __IO uint32_t RS                        : 1;
X    volatile uint32_t RS                        : 1;
N    __IO uint32_t RC                        : 1;
X    volatile uint32_t RC                        : 1;
N    __IO uint32_t FD                        : 1;
X    volatile uint32_t FD                        : 1;
N    __IO uint32_t FS                        : 1;
X    volatile uint32_t FS                        : 1;
N    __IO uint32_t WIDTH                     : 2;
X    volatile uint32_t WIDTH                     : 2;
N    __IO uint32_t MODE                      : 2;
X    volatile uint32_t MODE                      : 2;
N} stc_dmac_confb1_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SRCADR                    :32;
X    volatile uint32_t SRCADR                    :32;
N} stc_dmac_srcadr1_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t DSTADR                    :32;
X    volatile uint32_t DSTADR                    :32;
N} stc_dmac_dstadr1_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t TNVS                      : 9;
X    volatile uint32_t TNVS                      : 9;
N} stc_flash_tnvs_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t TPGS                      : 8;
X    volatile uint32_t TPGS                      : 8;
N} stc_flash_tpgs_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t TPROG                     : 9;
X    volatile uint32_t TPROG                     : 9;
N} stc_flash_tprog_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t TSERASE                   :18;
X    volatile uint32_t TSERASE                   :18;
N} stc_flash_tserase_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t TMERASE                   :21;
X    volatile uint32_t TMERASE                   :21;
N} stc_flash_tmerase_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t TPRCV                     :12;
X    volatile uint32_t TPRCV                     :12;
N} stc_flash_tprcv_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t TSRCV                     :12;
X    volatile uint32_t TSRCV                     :12;
N} stc_flash_tsrcv_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t TMRCV                     :13;
X    volatile uint32_t TMRCV                     :13;
N} stc_flash_tmrcv_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t OP                        : 2;
X    volatile uint32_t OP                        : 2;
N    __IO uint32_t WAIT                      : 2;
X    volatile uint32_t WAIT                      : 2;
N    __IO uint32_t BUSY                      : 1;
X    volatile uint32_t BUSY                      : 1;
N    __IO uint32_t IE                        : 2;
X    volatile uint32_t IE                        : 2;
N    uint32_t RESERVED7                      : 2;
N    __IO uint32_t DPSTB_EN                  : 1;
X    volatile uint32_t DPSTB_EN                  : 1;
N} stc_flash_cr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t IF0                       : 1;
X    volatile uint32_t IF0                       : 1;
N    __IO uint32_t IF1                       : 1;
X    volatile uint32_t IF1                       : 1;
N} stc_flash_ifr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t ICLR0                     : 1;
X    volatile uint32_t ICLR0                     : 1;
N    __IO uint32_t ICLR1                     : 1;
X    volatile uint32_t ICLR1                     : 1;
N} stc_flash_iclr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t BYSEQ                     :16;
X    volatile uint32_t BYSEQ                     :16;
N} stc_flash_bypass_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SLOCK                     :32;
X    volatile uint32_t SLOCK                     :32;
N} stc_flash_slock_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pa00_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pa01_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pa02_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pa03_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pa04_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pa05_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pa06_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pa07_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pa08_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pa09_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pa10_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pa11_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pa12_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pa13_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pa14_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pa15_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pb00_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pb01_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pb02_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pb03_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pb04_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pb05_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pb06_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pb07_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pb08_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pb09_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pb10_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pb11_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pb12_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pb13_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pb14_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pb15_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pc00_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pc01_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pc02_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pc03_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pc04_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pc05_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pc06_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pc07_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pc08_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pc09_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pc10_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pc11_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pc12_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pc13_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pc14_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pc15_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pd00_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pd01_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pd02_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pd03_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pd04_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pd05_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pd06_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SEL                       : 3;
X    volatile uint32_t SEL                       : 3;
N} stc_gpio_pd07_sel_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PA00                      : 1;
X    volatile uint32_t PA00                      : 1;
N    __IO uint32_t PA01                      : 1;
X    volatile uint32_t PA01                      : 1;
N    __IO uint32_t PA02                      : 1;
X    volatile uint32_t PA02                      : 1;
N    __IO uint32_t PA03                      : 1;
X    volatile uint32_t PA03                      : 1;
N    __IO uint32_t PA04                      : 1;
X    volatile uint32_t PA04                      : 1;
N    __IO uint32_t PA05                      : 1;
X    volatile uint32_t PA05                      : 1;
N    __IO uint32_t PA06                      : 1;
X    volatile uint32_t PA06                      : 1;
N    __IO uint32_t PA07                      : 1;
X    volatile uint32_t PA07                      : 1;
N    __IO uint32_t PA08                      : 1;
X    volatile uint32_t PA08                      : 1;
N    __IO uint32_t PA09                      : 1;
X    volatile uint32_t PA09                      : 1;
N    __IO uint32_t PA10                      : 1;
X    volatile uint32_t PA10                      : 1;
N    __IO uint32_t PA11                      : 1;
X    volatile uint32_t PA11                      : 1;
N    __IO uint32_t PA12                      : 1;
X    volatile uint32_t PA12                      : 1;
N    __IO uint32_t PA13                      : 1;
X    volatile uint32_t PA13                      : 1;
N    __IO uint32_t PA14                      : 1;
X    volatile uint32_t PA14                      : 1;
N    __IO uint32_t PA15                      : 1;
X    volatile uint32_t PA15                      : 1;
N} stc_gpio_padir_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PA00                      : 1;
X    volatile uint32_t PA00                      : 1;
N    __IO uint32_t PA01                      : 1;
X    volatile uint32_t PA01                      : 1;
N    __IO uint32_t PA02                      : 1;
X    volatile uint32_t PA02                      : 1;
N    __IO uint32_t PA03                      : 1;
X    volatile uint32_t PA03                      : 1;
N    __IO uint32_t PA04                      : 1;
X    volatile uint32_t PA04                      : 1;
N    __IO uint32_t PA05                      : 1;
X    volatile uint32_t PA05                      : 1;
N    __IO uint32_t PA06                      : 1;
X    volatile uint32_t PA06                      : 1;
N    __IO uint32_t PA07                      : 1;
X    volatile uint32_t PA07                      : 1;
N    __IO uint32_t PA08                      : 1;
X    volatile uint32_t PA08                      : 1;
N    __IO uint32_t PA09                      : 1;
X    volatile uint32_t PA09                      : 1;
N    __IO uint32_t PA10                      : 1;
X    volatile uint32_t PA10                      : 1;
N    __IO uint32_t PA11                      : 1;
X    volatile uint32_t PA11                      : 1;
N    __IO uint32_t PA12                      : 1;
X    volatile uint32_t PA12                      : 1;
N    __IO uint32_t PA13                      : 1;
X    volatile uint32_t PA13                      : 1;
N    __IO uint32_t PA14                      : 1;
X    volatile uint32_t PA14                      : 1;
N    __IO uint32_t PA15                      : 1;
X    volatile uint32_t PA15                      : 1;
N} stc_gpio_pain_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PA00                      : 1;
X    volatile uint32_t PA00                      : 1;
N    __IO uint32_t PA01                      : 1;
X    volatile uint32_t PA01                      : 1;
N    __IO uint32_t PA02                      : 1;
X    volatile uint32_t PA02                      : 1;
N    __IO uint32_t PA03                      : 1;
X    volatile uint32_t PA03                      : 1;
N    __IO uint32_t PA04                      : 1;
X    volatile uint32_t PA04                      : 1;
N    __IO uint32_t PA05                      : 1;
X    volatile uint32_t PA05                      : 1;
N    __IO uint32_t PA06                      : 1;
X    volatile uint32_t PA06                      : 1;
N    __IO uint32_t PA07                      : 1;
X    volatile uint32_t PA07                      : 1;
N    __IO uint32_t PA08                      : 1;
X    volatile uint32_t PA08                      : 1;
N    __IO uint32_t PA09                      : 1;
X    volatile uint32_t PA09                      : 1;
N    __IO uint32_t PA10                      : 1;
X    volatile uint32_t PA10                      : 1;
N    __IO uint32_t PA11                      : 1;
X    volatile uint32_t PA11                      : 1;
N    __IO uint32_t PA12                      : 1;
X    volatile uint32_t PA12                      : 1;
N    __IO uint32_t PA13                      : 1;
X    volatile uint32_t PA13                      : 1;
N    __IO uint32_t PA14                      : 1;
X    volatile uint32_t PA14                      : 1;
N    __IO uint32_t PA15                      : 1;
X    volatile uint32_t PA15                      : 1;
N} stc_gpio_paout_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PA00                      : 1;
X    volatile uint32_t PA00                      : 1;
N    __IO uint32_t PA01                      : 1;
X    volatile uint32_t PA01                      : 1;
N    __IO uint32_t PA02                      : 1;
X    volatile uint32_t PA02                      : 1;
N    __IO uint32_t PA03                      : 1;
X    volatile uint32_t PA03                      : 1;
N    __IO uint32_t PA04                      : 1;
X    volatile uint32_t PA04                      : 1;
N    __IO uint32_t PA05                      : 1;
X    volatile uint32_t PA05                      : 1;
N    __IO uint32_t PA06                      : 1;
X    volatile uint32_t PA06                      : 1;
N    __IO uint32_t PA07                      : 1;
X    volatile uint32_t PA07                      : 1;
N    __IO uint32_t PA08                      : 1;
X    volatile uint32_t PA08                      : 1;
N    __IO uint32_t PA09                      : 1;
X    volatile uint32_t PA09                      : 1;
N    __IO uint32_t PA10                      : 1;
X    volatile uint32_t PA10                      : 1;
N    __IO uint32_t PA11                      : 1;
X    volatile uint32_t PA11                      : 1;
N    __IO uint32_t PA12                      : 1;
X    volatile uint32_t PA12                      : 1;
N    __IO uint32_t PA13                      : 1;
X    volatile uint32_t PA13                      : 1;
N    __IO uint32_t PA14                      : 1;
X    volatile uint32_t PA14                      : 1;
N    __IO uint32_t PA15                      : 1;
X    volatile uint32_t PA15                      : 1;
N} stc_gpio_paads_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PA00                      : 1;
X    volatile uint32_t PA00                      : 1;
N    __IO uint32_t PA01                      : 1;
X    volatile uint32_t PA01                      : 1;
N    __IO uint32_t PA02                      : 1;
X    volatile uint32_t PA02                      : 1;
N    __IO uint32_t PA03                      : 1;
X    volatile uint32_t PA03                      : 1;
N    __IO uint32_t PA04                      : 1;
X    volatile uint32_t PA04                      : 1;
N    __IO uint32_t PA05                      : 1;
X    volatile uint32_t PA05                      : 1;
N    __IO uint32_t PA06                      : 1;
X    volatile uint32_t PA06                      : 1;
N    __IO uint32_t PA07                      : 1;
X    volatile uint32_t PA07                      : 1;
N    __IO uint32_t PA08                      : 1;
X    volatile uint32_t PA08                      : 1;
N    __IO uint32_t PA09                      : 1;
X    volatile uint32_t PA09                      : 1;
N    __IO uint32_t PA10                      : 1;
X    volatile uint32_t PA10                      : 1;
N    __IO uint32_t PA11                      : 1;
X    volatile uint32_t PA11                      : 1;
N    __IO uint32_t PA12                      : 1;
X    volatile uint32_t PA12                      : 1;
N    __IO uint32_t PA13                      : 1;
X    volatile uint32_t PA13                      : 1;
N    __IO uint32_t PA14                      : 1;
X    volatile uint32_t PA14                      : 1;
N    __IO uint32_t PA15                      : 1;
X    volatile uint32_t PA15                      : 1;
N} stc_gpio_pabset_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PA00                      : 1;
X    volatile uint32_t PA00                      : 1;
N    __IO uint32_t PA01                      : 1;
X    volatile uint32_t PA01                      : 1;
N    __IO uint32_t PA02                      : 1;
X    volatile uint32_t PA02                      : 1;
N    __IO uint32_t PA03                      : 1;
X    volatile uint32_t PA03                      : 1;
N    __IO uint32_t PA04                      : 1;
X    volatile uint32_t PA04                      : 1;
N    __IO uint32_t PA05                      : 1;
X    volatile uint32_t PA05                      : 1;
N    __IO uint32_t PA06                      : 1;
X    volatile uint32_t PA06                      : 1;
N    __IO uint32_t PA07                      : 1;
X    volatile uint32_t PA07                      : 1;
N    __IO uint32_t PA08                      : 1;
X    volatile uint32_t PA08                      : 1;
N    __IO uint32_t PA09                      : 1;
X    volatile uint32_t PA09                      : 1;
N    __IO uint32_t PA10                      : 1;
X    volatile uint32_t PA10                      : 1;
N    __IO uint32_t PA11                      : 1;
X    volatile uint32_t PA11                      : 1;
N    __IO uint32_t PA12                      : 1;
X    volatile uint32_t PA12                      : 1;
N    __IO uint32_t PA13                      : 1;
X    volatile uint32_t PA13                      : 1;
N    __IO uint32_t PA14                      : 1;
X    volatile uint32_t PA14                      : 1;
N    __IO uint32_t PA15                      : 1;
X    volatile uint32_t PA15                      : 1;
N} stc_gpio_pabclr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PABCLR                    :16;
X    volatile uint32_t PABCLR                    :16;
N    __IO uint32_t PABSET                    :16;
X    volatile uint32_t PABSET                    :16;
N} stc_gpio_pabsetclr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PA00                      : 1;
X    volatile uint32_t PA00                      : 1;
N    __IO uint32_t PA01                      : 1;
X    volatile uint32_t PA01                      : 1;
N    __IO uint32_t PA02                      : 1;
X    volatile uint32_t PA02                      : 1;
N    __IO uint32_t PA03                      : 1;
X    volatile uint32_t PA03                      : 1;
N    __IO uint32_t PA04                      : 1;
X    volatile uint32_t PA04                      : 1;
N    __IO uint32_t PA05                      : 1;
X    volatile uint32_t PA05                      : 1;
N    __IO uint32_t PA06                      : 1;
X    volatile uint32_t PA06                      : 1;
N    __IO uint32_t PA07                      : 1;
X    volatile uint32_t PA07                      : 1;
N    __IO uint32_t PA08                      : 1;
X    volatile uint32_t PA08                      : 1;
N    __IO uint32_t PA09                      : 1;
X    volatile uint32_t PA09                      : 1;
N    __IO uint32_t PA10                      : 1;
X    volatile uint32_t PA10                      : 1;
N    __IO uint32_t PA11                      : 1;
X    volatile uint32_t PA11                      : 1;
N    __IO uint32_t PA12                      : 1;
X    volatile uint32_t PA12                      : 1;
N    __IO uint32_t PA13                      : 1;
X    volatile uint32_t PA13                      : 1;
N    __IO uint32_t PA14                      : 1;
X    volatile uint32_t PA14                      : 1;
N    __IO uint32_t PA15                      : 1;
X    volatile uint32_t PA15                      : 1;
N} stc_gpio_padr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PA00                      : 1;
X    volatile uint32_t PA00                      : 1;
N    __IO uint32_t PA01                      : 1;
X    volatile uint32_t PA01                      : 1;
N    __IO uint32_t PA02                      : 1;
X    volatile uint32_t PA02                      : 1;
N    __IO uint32_t PA03                      : 1;
X    volatile uint32_t PA03                      : 1;
N    __IO uint32_t PA04                      : 1;
X    volatile uint32_t PA04                      : 1;
N    __IO uint32_t PA05                      : 1;
X    volatile uint32_t PA05                      : 1;
N    __IO uint32_t PA06                      : 1;
X    volatile uint32_t PA06                      : 1;
N    __IO uint32_t PA07                      : 1;
X    volatile uint32_t PA07                      : 1;
N    __IO uint32_t PA08                      : 1;
X    volatile uint32_t PA08                      : 1;
N    __IO uint32_t PA09                      : 1;
X    volatile uint32_t PA09                      : 1;
N    __IO uint32_t PA10                      : 1;
X    volatile uint32_t PA10                      : 1;
N    __IO uint32_t PA11                      : 1;
X    volatile uint32_t PA11                      : 1;
N    __IO uint32_t PA12                      : 1;
X    volatile uint32_t PA12                      : 1;
N    __IO uint32_t PA13                      : 1;
X    volatile uint32_t PA13                      : 1;
N    __IO uint32_t PA14                      : 1;
X    volatile uint32_t PA14                      : 1;
N    __IO uint32_t PA15                      : 1;
X    volatile uint32_t PA15                      : 1;
N} stc_gpio_papu_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PA00                      : 1;
X    volatile uint32_t PA00                      : 1;
N    __IO uint32_t PA01                      : 1;
X    volatile uint32_t PA01                      : 1;
N    __IO uint32_t PA02                      : 1;
X    volatile uint32_t PA02                      : 1;
N    __IO uint32_t PA03                      : 1;
X    volatile uint32_t PA03                      : 1;
N    __IO uint32_t PA04                      : 1;
X    volatile uint32_t PA04                      : 1;
N    __IO uint32_t PA05                      : 1;
X    volatile uint32_t PA05                      : 1;
N    __IO uint32_t PA06                      : 1;
X    volatile uint32_t PA06                      : 1;
N    __IO uint32_t PA07                      : 1;
X    volatile uint32_t PA07                      : 1;
N    __IO uint32_t PA08                      : 1;
X    volatile uint32_t PA08                      : 1;
N    __IO uint32_t PA09                      : 1;
X    volatile uint32_t PA09                      : 1;
N    __IO uint32_t PA10                      : 1;
X    volatile uint32_t PA10                      : 1;
N    __IO uint32_t PA11                      : 1;
X    volatile uint32_t PA11                      : 1;
N    __IO uint32_t PA12                      : 1;
X    volatile uint32_t PA12                      : 1;
N    __IO uint32_t PA13                      : 1;
X    volatile uint32_t PA13                      : 1;
N    __IO uint32_t PA14                      : 1;
X    volatile uint32_t PA14                      : 1;
N    __IO uint32_t PA15                      : 1;
X    volatile uint32_t PA15                      : 1;
N} stc_gpio_papd_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PA00                      : 1;
X    volatile uint32_t PA00                      : 1;
N    __IO uint32_t PA01                      : 1;
X    volatile uint32_t PA01                      : 1;
N    __IO uint32_t PA02                      : 1;
X    volatile uint32_t PA02                      : 1;
N    __IO uint32_t PA03                      : 1;
X    volatile uint32_t PA03                      : 1;
N    __IO uint32_t PA04                      : 1;
X    volatile uint32_t PA04                      : 1;
N    __IO uint32_t PA05                      : 1;
X    volatile uint32_t PA05                      : 1;
N    __IO uint32_t PA06                      : 1;
X    volatile uint32_t PA06                      : 1;
N    __IO uint32_t PA07                      : 1;
X    volatile uint32_t PA07                      : 1;
N    __IO uint32_t PA08                      : 1;
X    volatile uint32_t PA08                      : 1;
N    __IO uint32_t PA09                      : 1;
X    volatile uint32_t PA09                      : 1;
N    __IO uint32_t PA10                      : 1;
X    volatile uint32_t PA10                      : 1;
N    __IO uint32_t PA11                      : 1;
X    volatile uint32_t PA11                      : 1;
N    __IO uint32_t PA12                      : 1;
X    volatile uint32_t PA12                      : 1;
N    __IO uint32_t PA13                      : 1;
X    volatile uint32_t PA13                      : 1;
N    __IO uint32_t PA14                      : 1;
X    volatile uint32_t PA14                      : 1;
N    __IO uint32_t PA15                      : 1;
X    volatile uint32_t PA15                      : 1;
N} stc_gpio_paod_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PA00                      : 1;
X    volatile uint32_t PA00                      : 1;
N    __IO uint32_t PA01                      : 1;
X    volatile uint32_t PA01                      : 1;
N    __IO uint32_t PA02                      : 1;
X    volatile uint32_t PA02                      : 1;
N    __IO uint32_t PA03                      : 1;
X    volatile uint32_t PA03                      : 1;
N    __IO uint32_t PA04                      : 1;
X    volatile uint32_t PA04                      : 1;
N    __IO uint32_t PA05                      : 1;
X    volatile uint32_t PA05                      : 1;
N    __IO uint32_t PA06                      : 1;
X    volatile uint32_t PA06                      : 1;
N    __IO uint32_t PA07                      : 1;
X    volatile uint32_t PA07                      : 1;
N    __IO uint32_t PA08                      : 1;
X    volatile uint32_t PA08                      : 1;
N    __IO uint32_t PA09                      : 1;
X    volatile uint32_t PA09                      : 1;
N    __IO uint32_t PA10                      : 1;
X    volatile uint32_t PA10                      : 1;
N    __IO uint32_t PA11                      : 1;
X    volatile uint32_t PA11                      : 1;
N    __IO uint32_t PA12                      : 1;
X    volatile uint32_t PA12                      : 1;
N    __IO uint32_t PA13                      : 1;
X    volatile uint32_t PA13                      : 1;
N    __IO uint32_t PA14                      : 1;
X    volatile uint32_t PA14                      : 1;
N    __IO uint32_t PA15                      : 1;
X    volatile uint32_t PA15                      : 1;
N} stc_gpio_pahie_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PA00                      : 1;
X    volatile uint32_t PA00                      : 1;
N    __IO uint32_t PA01                      : 1;
X    volatile uint32_t PA01                      : 1;
N    __IO uint32_t PA02                      : 1;
X    volatile uint32_t PA02                      : 1;
N    __IO uint32_t PA03                      : 1;
X    volatile uint32_t PA03                      : 1;
N    __IO uint32_t PA04                      : 1;
X    volatile uint32_t PA04                      : 1;
N    __IO uint32_t PA05                      : 1;
X    volatile uint32_t PA05                      : 1;
N    __IO uint32_t PA06                      : 1;
X    volatile uint32_t PA06                      : 1;
N    __IO uint32_t PA07                      : 1;
X    volatile uint32_t PA07                      : 1;
N    __IO uint32_t PA08                      : 1;
X    volatile uint32_t PA08                      : 1;
N    __IO uint32_t PA09                      : 1;
X    volatile uint32_t PA09                      : 1;
N    __IO uint32_t PA10                      : 1;
X    volatile uint32_t PA10                      : 1;
N    __IO uint32_t PA11                      : 1;
X    volatile uint32_t PA11                      : 1;
N    __IO uint32_t PA12                      : 1;
X    volatile uint32_t PA12                      : 1;
N    __IO uint32_t PA13                      : 1;
X    volatile uint32_t PA13                      : 1;
N    __IO uint32_t PA14                      : 1;
X    volatile uint32_t PA14                      : 1;
N    __IO uint32_t PA15                      : 1;
X    volatile uint32_t PA15                      : 1;
N} stc_gpio_palie_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PA00                      : 1;
X    volatile uint32_t PA00                      : 1;
N    __IO uint32_t PA01                      : 1;
X    volatile uint32_t PA01                      : 1;
N    __IO uint32_t PA02                      : 1;
X    volatile uint32_t PA02                      : 1;
N    __IO uint32_t PA03                      : 1;
X    volatile uint32_t PA03                      : 1;
N    __IO uint32_t PA04                      : 1;
X    volatile uint32_t PA04                      : 1;
N    __IO uint32_t PA05                      : 1;
X    volatile uint32_t PA05                      : 1;
N    __IO uint32_t PA06                      : 1;
X    volatile uint32_t PA06                      : 1;
N    __IO uint32_t PA07                      : 1;
X    volatile uint32_t PA07                      : 1;
N    __IO uint32_t PA08                      : 1;
X    volatile uint32_t PA08                      : 1;
N    __IO uint32_t PA09                      : 1;
X    volatile uint32_t PA09                      : 1;
N    __IO uint32_t PA10                      : 1;
X    volatile uint32_t PA10                      : 1;
N    __IO uint32_t PA11                      : 1;
X    volatile uint32_t PA11                      : 1;
N    __IO uint32_t PA12                      : 1;
X    volatile uint32_t PA12                      : 1;
N    __IO uint32_t PA13                      : 1;
X    volatile uint32_t PA13                      : 1;
N    __IO uint32_t PA14                      : 1;
X    volatile uint32_t PA14                      : 1;
N    __IO uint32_t PA15                      : 1;
X    volatile uint32_t PA15                      : 1;
N} stc_gpio_parie_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PA00                      : 1;
X    volatile uint32_t PA00                      : 1;
N    __IO uint32_t PA01                      : 1;
X    volatile uint32_t PA01                      : 1;
N    __IO uint32_t PA02                      : 1;
X    volatile uint32_t PA02                      : 1;
N    __IO uint32_t PA03                      : 1;
X    volatile uint32_t PA03                      : 1;
N    __IO uint32_t PA04                      : 1;
X    volatile uint32_t PA04                      : 1;
N    __IO uint32_t PA05                      : 1;
X    volatile uint32_t PA05                      : 1;
N    __IO uint32_t PA06                      : 1;
X    volatile uint32_t PA06                      : 1;
N    __IO uint32_t PA07                      : 1;
X    volatile uint32_t PA07                      : 1;
N    __IO uint32_t PA08                      : 1;
X    volatile uint32_t PA08                      : 1;
N    __IO uint32_t PA09                      : 1;
X    volatile uint32_t PA09                      : 1;
N    __IO uint32_t PA10                      : 1;
X    volatile uint32_t PA10                      : 1;
N    __IO uint32_t PA11                      : 1;
X    volatile uint32_t PA11                      : 1;
N    __IO uint32_t PA12                      : 1;
X    volatile uint32_t PA12                      : 1;
N    __IO uint32_t PA13                      : 1;
X    volatile uint32_t PA13                      : 1;
N    __IO uint32_t PA14                      : 1;
X    volatile uint32_t PA14                      : 1;
N    __IO uint32_t PA15                      : 1;
X    volatile uint32_t PA15                      : 1;
N} stc_gpio_pafie_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PB00                      : 1;
X    volatile uint32_t PB00                      : 1;
N    __IO uint32_t PB01                      : 1;
X    volatile uint32_t PB01                      : 1;
N    __IO uint32_t PB02                      : 1;
X    volatile uint32_t PB02                      : 1;
N    __IO uint32_t PB03                      : 1;
X    volatile uint32_t PB03                      : 1;
N    __IO uint32_t PB04                      : 1;
X    volatile uint32_t PB04                      : 1;
N    __IO uint32_t PB05                      : 1;
X    volatile uint32_t PB05                      : 1;
N    __IO uint32_t PB06                      : 1;
X    volatile uint32_t PB06                      : 1;
N    __IO uint32_t PB07                      : 1;
X    volatile uint32_t PB07                      : 1;
N    __IO uint32_t PB08                      : 1;
X    volatile uint32_t PB08                      : 1;
N    __IO uint32_t PB09                      : 1;
X    volatile uint32_t PB09                      : 1;
N    __IO uint32_t PB10                      : 1;
X    volatile uint32_t PB10                      : 1;
N    __IO uint32_t PB11                      : 1;
X    volatile uint32_t PB11                      : 1;
N    __IO uint32_t PB12                      : 1;
X    volatile uint32_t PB12                      : 1;
N    __IO uint32_t PB13                      : 1;
X    volatile uint32_t PB13                      : 1;
N    __IO uint32_t PB14                      : 1;
X    volatile uint32_t PB14                      : 1;
N    __IO uint32_t PB15                      : 1;
X    volatile uint32_t PB15                      : 1;
N} stc_gpio_pbdir_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PB00                      : 1;
X    volatile uint32_t PB00                      : 1;
N    __IO uint32_t PB01                      : 1;
X    volatile uint32_t PB01                      : 1;
N    __IO uint32_t PB02                      : 1;
X    volatile uint32_t PB02                      : 1;
N    __IO uint32_t PB03                      : 1;
X    volatile uint32_t PB03                      : 1;
N    __IO uint32_t PB04                      : 1;
X    volatile uint32_t PB04                      : 1;
N    __IO uint32_t PB05                      : 1;
X    volatile uint32_t PB05                      : 1;
N    __IO uint32_t PB06                      : 1;
X    volatile uint32_t PB06                      : 1;
N    __IO uint32_t PB07                      : 1;
X    volatile uint32_t PB07                      : 1;
N    __IO uint32_t PB08                      : 1;
X    volatile uint32_t PB08                      : 1;
N    __IO uint32_t PB09                      : 1;
X    volatile uint32_t PB09                      : 1;
N    __IO uint32_t PB10                      : 1;
X    volatile uint32_t PB10                      : 1;
N    __IO uint32_t PB11                      : 1;
X    volatile uint32_t PB11                      : 1;
N    __IO uint32_t PB12                      : 1;
X    volatile uint32_t PB12                      : 1;
N    __IO uint32_t PB13                      : 1;
X    volatile uint32_t PB13                      : 1;
N    __IO uint32_t PB14                      : 1;
X    volatile uint32_t PB14                      : 1;
N    __IO uint32_t PB15                      : 1;
X    volatile uint32_t PB15                      : 1;
N} stc_gpio_pbin_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PB00                      : 1;
X    volatile uint32_t PB00                      : 1;
N    __IO uint32_t PB01                      : 1;
X    volatile uint32_t PB01                      : 1;
N    __IO uint32_t PB02                      : 1;
X    volatile uint32_t PB02                      : 1;
N    __IO uint32_t PB03                      : 1;
X    volatile uint32_t PB03                      : 1;
N    __IO uint32_t PB04                      : 1;
X    volatile uint32_t PB04                      : 1;
N    __IO uint32_t PB05                      : 1;
X    volatile uint32_t PB05                      : 1;
N    __IO uint32_t PB06                      : 1;
X    volatile uint32_t PB06                      : 1;
N    __IO uint32_t PB07                      : 1;
X    volatile uint32_t PB07                      : 1;
N    __IO uint32_t PB08                      : 1;
X    volatile uint32_t PB08                      : 1;
N    __IO uint32_t PB09                      : 1;
X    volatile uint32_t PB09                      : 1;
N    __IO uint32_t PB10                      : 1;
X    volatile uint32_t PB10                      : 1;
N    __IO uint32_t PB11                      : 1;
X    volatile uint32_t PB11                      : 1;
N    __IO uint32_t PB12                      : 1;
X    volatile uint32_t PB12                      : 1;
N    __IO uint32_t PB13                      : 1;
X    volatile uint32_t PB13                      : 1;
N    __IO uint32_t PB14                      : 1;
X    volatile uint32_t PB14                      : 1;
N    __IO uint32_t PB15                      : 1;
X    volatile uint32_t PB15                      : 1;
N} stc_gpio_pbout_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PB00                      : 1;
X    volatile uint32_t PB00                      : 1;
N    __IO uint32_t PB01                      : 1;
X    volatile uint32_t PB01                      : 1;
N    __IO uint32_t PB02                      : 1;
X    volatile uint32_t PB02                      : 1;
N    __IO uint32_t PB03                      : 1;
X    volatile uint32_t PB03                      : 1;
N    __IO uint32_t PB04                      : 1;
X    volatile uint32_t PB04                      : 1;
N    __IO uint32_t PB05                      : 1;
X    volatile uint32_t PB05                      : 1;
N    __IO uint32_t PB06                      : 1;
X    volatile uint32_t PB06                      : 1;
N    __IO uint32_t PB07                      : 1;
X    volatile uint32_t PB07                      : 1;
N    __IO uint32_t PB08                      : 1;
X    volatile uint32_t PB08                      : 1;
N    __IO uint32_t PB09                      : 1;
X    volatile uint32_t PB09                      : 1;
N    __IO uint32_t PB10                      : 1;
X    volatile uint32_t PB10                      : 1;
N    __IO uint32_t PB11                      : 1;
X    volatile uint32_t PB11                      : 1;
N    __IO uint32_t PB12                      : 1;
X    volatile uint32_t PB12                      : 1;
N    __IO uint32_t PB13                      : 1;
X    volatile uint32_t PB13                      : 1;
N    __IO uint32_t PB14                      : 1;
X    volatile uint32_t PB14                      : 1;
N    __IO uint32_t PB15                      : 1;
X    volatile uint32_t PB15                      : 1;
N} stc_gpio_pbads_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PB00                      : 1;
X    volatile uint32_t PB00                      : 1;
N    __IO uint32_t PB01                      : 1;
X    volatile uint32_t PB01                      : 1;
N    __IO uint32_t PB02                      : 1;
X    volatile uint32_t PB02                      : 1;
N    __IO uint32_t PB03                      : 1;
X    volatile uint32_t PB03                      : 1;
N    __IO uint32_t PB04                      : 1;
X    volatile uint32_t PB04                      : 1;
N    __IO uint32_t PB05                      : 1;
X    volatile uint32_t PB05                      : 1;
N    __IO uint32_t PB06                      : 1;
X    volatile uint32_t PB06                      : 1;
N    __IO uint32_t PB07                      : 1;
X    volatile uint32_t PB07                      : 1;
N    __IO uint32_t PB08                      : 1;
X    volatile uint32_t PB08                      : 1;
N    __IO uint32_t PB09                      : 1;
X    volatile uint32_t PB09                      : 1;
N    __IO uint32_t PB10                      : 1;
X    volatile uint32_t PB10                      : 1;
N    __IO uint32_t PB11                      : 1;
X    volatile uint32_t PB11                      : 1;
N    __IO uint32_t PB12                      : 1;
X    volatile uint32_t PB12                      : 1;
N    __IO uint32_t PB13                      : 1;
X    volatile uint32_t PB13                      : 1;
N    __IO uint32_t PB14                      : 1;
X    volatile uint32_t PB14                      : 1;
N    __IO uint32_t PB15                      : 1;
X    volatile uint32_t PB15                      : 1;
N} stc_gpio_pbbset_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PB00                      : 1;
X    volatile uint32_t PB00                      : 1;
N    __IO uint32_t PB01                      : 1;
X    volatile uint32_t PB01                      : 1;
N    __IO uint32_t PB02                      : 1;
X    volatile uint32_t PB02                      : 1;
N    __IO uint32_t PB03                      : 1;
X    volatile uint32_t PB03                      : 1;
N    __IO uint32_t PB04                      : 1;
X    volatile uint32_t PB04                      : 1;
N    __IO uint32_t PB05                      : 1;
X    volatile uint32_t PB05                      : 1;
N    __IO uint32_t PB06                      : 1;
X    volatile uint32_t PB06                      : 1;
N    __IO uint32_t PB07                      : 1;
X    volatile uint32_t PB07                      : 1;
N    __IO uint32_t PB08                      : 1;
X    volatile uint32_t PB08                      : 1;
N    __IO uint32_t PB09                      : 1;
X    volatile uint32_t PB09                      : 1;
N    __IO uint32_t PB10                      : 1;
X    volatile uint32_t PB10                      : 1;
N    __IO uint32_t PB11                      : 1;
X    volatile uint32_t PB11                      : 1;
N    __IO uint32_t PB12                      : 1;
X    volatile uint32_t PB12                      : 1;
N    __IO uint32_t PB13                      : 1;
X    volatile uint32_t PB13                      : 1;
N    __IO uint32_t PB14                      : 1;
X    volatile uint32_t PB14                      : 1;
N    __IO uint32_t PB15                      : 1;
X    volatile uint32_t PB15                      : 1;
N} stc_gpio_pbbclr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PBBCLR                    :16;
X    volatile uint32_t PBBCLR                    :16;
N    __IO uint32_t PBBSET                    :16;
X    volatile uint32_t PBBSET                    :16;
N} stc_gpio_pbbsetclr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PB00                      : 1;
X    volatile uint32_t PB00                      : 1;
N    __IO uint32_t PB01                      : 1;
X    volatile uint32_t PB01                      : 1;
N    __IO uint32_t PB02                      : 1;
X    volatile uint32_t PB02                      : 1;
N    __IO uint32_t PB03                      : 1;
X    volatile uint32_t PB03                      : 1;
N    __IO uint32_t PB04                      : 1;
X    volatile uint32_t PB04                      : 1;
N    __IO uint32_t PB05                      : 1;
X    volatile uint32_t PB05                      : 1;
N    __IO uint32_t PB06                      : 1;
X    volatile uint32_t PB06                      : 1;
N    __IO uint32_t PB07                      : 1;
X    volatile uint32_t PB07                      : 1;
N    __IO uint32_t PB08                      : 1;
X    volatile uint32_t PB08                      : 1;
N    __IO uint32_t PB09                      : 1;
X    volatile uint32_t PB09                      : 1;
N    __IO uint32_t PB10                      : 1;
X    volatile uint32_t PB10                      : 1;
N    __IO uint32_t PB11                      : 1;
X    volatile uint32_t PB11                      : 1;
N    __IO uint32_t PB12                      : 1;
X    volatile uint32_t PB12                      : 1;
N    __IO uint32_t PB13                      : 1;
X    volatile uint32_t PB13                      : 1;
N    __IO uint32_t PB14                      : 1;
X    volatile uint32_t PB14                      : 1;
N    __IO uint32_t PB15                      : 1;
X    volatile uint32_t PB15                      : 1;
N} stc_gpio_pbdr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PB00                      : 1;
X    volatile uint32_t PB00                      : 1;
N    __IO uint32_t PB01                      : 1;
X    volatile uint32_t PB01                      : 1;
N    __IO uint32_t PB02                      : 1;
X    volatile uint32_t PB02                      : 1;
N    __IO uint32_t PB03                      : 1;
X    volatile uint32_t PB03                      : 1;
N    __IO uint32_t PB04                      : 1;
X    volatile uint32_t PB04                      : 1;
N    __IO uint32_t PB05                      : 1;
X    volatile uint32_t PB05                      : 1;
N    __IO uint32_t PB06                      : 1;
X    volatile uint32_t PB06                      : 1;
N    __IO uint32_t PB07                      : 1;
X    volatile uint32_t PB07                      : 1;
N    __IO uint32_t PB08                      : 1;
X    volatile uint32_t PB08                      : 1;
N    __IO uint32_t PB09                      : 1;
X    volatile uint32_t PB09                      : 1;
N    __IO uint32_t PB10                      : 1;
X    volatile uint32_t PB10                      : 1;
N    __IO uint32_t PB11                      : 1;
X    volatile uint32_t PB11                      : 1;
N    __IO uint32_t PB12                      : 1;
X    volatile uint32_t PB12                      : 1;
N    __IO uint32_t PB13                      : 1;
X    volatile uint32_t PB13                      : 1;
N    __IO uint32_t PB14                      : 1;
X    volatile uint32_t PB14                      : 1;
N    __IO uint32_t PB15                      : 1;
X    volatile uint32_t PB15                      : 1;
N} stc_gpio_pbpu_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PB00                      : 1;
X    volatile uint32_t PB00                      : 1;
N    __IO uint32_t PB01                      : 1;
X    volatile uint32_t PB01                      : 1;
N    __IO uint32_t PB02                      : 1;
X    volatile uint32_t PB02                      : 1;
N    __IO uint32_t PB03                      : 1;
X    volatile uint32_t PB03                      : 1;
N    __IO uint32_t PB04                      : 1;
X    volatile uint32_t PB04                      : 1;
N    __IO uint32_t PB05                      : 1;
X    volatile uint32_t PB05                      : 1;
N    __IO uint32_t PB06                      : 1;
X    volatile uint32_t PB06                      : 1;
N    __IO uint32_t PB07                      : 1;
X    volatile uint32_t PB07                      : 1;
N    __IO uint32_t PB08                      : 1;
X    volatile uint32_t PB08                      : 1;
N    __IO uint32_t PB09                      : 1;
X    volatile uint32_t PB09                      : 1;
N    __IO uint32_t PB10                      : 1;
X    volatile uint32_t PB10                      : 1;
N    __IO uint32_t PB11                      : 1;
X    volatile uint32_t PB11                      : 1;
N    __IO uint32_t PB12                      : 1;
X    volatile uint32_t PB12                      : 1;
N    __IO uint32_t PB13                      : 1;
X    volatile uint32_t PB13                      : 1;
N    __IO uint32_t PB14                      : 1;
X    volatile uint32_t PB14                      : 1;
N    __IO uint32_t PB15                      : 1;
X    volatile uint32_t PB15                      : 1;
N} stc_gpio_pbpd_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PB00                      : 1;
X    volatile uint32_t PB00                      : 1;
N    __IO uint32_t PB01                      : 1;
X    volatile uint32_t PB01                      : 1;
N    __IO uint32_t PB02                      : 1;
X    volatile uint32_t PB02                      : 1;
N    __IO uint32_t PB03                      : 1;
X    volatile uint32_t PB03                      : 1;
N    __IO uint32_t PB04                      : 1;
X    volatile uint32_t PB04                      : 1;
N    __IO uint32_t PB05                      : 1;
X    volatile uint32_t PB05                      : 1;
N    __IO uint32_t PB06                      : 1;
X    volatile uint32_t PB06                      : 1;
N    __IO uint32_t PB07                      : 1;
X    volatile uint32_t PB07                      : 1;
N    __IO uint32_t PB08                      : 1;
X    volatile uint32_t PB08                      : 1;
N    __IO uint32_t PB09                      : 1;
X    volatile uint32_t PB09                      : 1;
N    __IO uint32_t PB10                      : 1;
X    volatile uint32_t PB10                      : 1;
N    __IO uint32_t PB11                      : 1;
X    volatile uint32_t PB11                      : 1;
N    __IO uint32_t PB12                      : 1;
X    volatile uint32_t PB12                      : 1;
N    __IO uint32_t PB13                      : 1;
X    volatile uint32_t PB13                      : 1;
N    __IO uint32_t PB14                      : 1;
X    volatile uint32_t PB14                      : 1;
N    __IO uint32_t PB15                      : 1;
X    volatile uint32_t PB15                      : 1;
N} stc_gpio_pbod_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PB00                      : 1;
X    volatile uint32_t PB00                      : 1;
N    __IO uint32_t PB01                      : 1;
X    volatile uint32_t PB01                      : 1;
N    __IO uint32_t PB02                      : 1;
X    volatile uint32_t PB02                      : 1;
N    __IO uint32_t PB03                      : 1;
X    volatile uint32_t PB03                      : 1;
N    __IO uint32_t PB04                      : 1;
X    volatile uint32_t PB04                      : 1;
N    __IO uint32_t PB05                      : 1;
X    volatile uint32_t PB05                      : 1;
N    __IO uint32_t PB06                      : 1;
X    volatile uint32_t PB06                      : 1;
N    __IO uint32_t PB07                      : 1;
X    volatile uint32_t PB07                      : 1;
N    __IO uint32_t PB08                      : 1;
X    volatile uint32_t PB08                      : 1;
N    __IO uint32_t PB09                      : 1;
X    volatile uint32_t PB09                      : 1;
N    __IO uint32_t PB10                      : 1;
X    volatile uint32_t PB10                      : 1;
N    __IO uint32_t PB11                      : 1;
X    volatile uint32_t PB11                      : 1;
N    __IO uint32_t PB12                      : 1;
X    volatile uint32_t PB12                      : 1;
N    __IO uint32_t PB13                      : 1;
X    volatile uint32_t PB13                      : 1;
N    __IO uint32_t PB14                      : 1;
X    volatile uint32_t PB14                      : 1;
N    __IO uint32_t PB15                      : 1;
X    volatile uint32_t PB15                      : 1;
N} stc_gpio_pbhie_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PB00                      : 1;
X    volatile uint32_t PB00                      : 1;
N    __IO uint32_t PB01                      : 1;
X    volatile uint32_t PB01                      : 1;
N    __IO uint32_t PB02                      : 1;
X    volatile uint32_t PB02                      : 1;
N    __IO uint32_t PB03                      : 1;
X    volatile uint32_t PB03                      : 1;
N    __IO uint32_t PB04                      : 1;
X    volatile uint32_t PB04                      : 1;
N    __IO uint32_t PB05                      : 1;
X    volatile uint32_t PB05                      : 1;
N    __IO uint32_t PB06                      : 1;
X    volatile uint32_t PB06                      : 1;
N    __IO uint32_t PB07                      : 1;
X    volatile uint32_t PB07                      : 1;
N    __IO uint32_t PB08                      : 1;
X    volatile uint32_t PB08                      : 1;
N    __IO uint32_t PB09                      : 1;
X    volatile uint32_t PB09                      : 1;
N    __IO uint32_t PB10                      : 1;
X    volatile uint32_t PB10                      : 1;
N    __IO uint32_t PB11                      : 1;
X    volatile uint32_t PB11                      : 1;
N    __IO uint32_t PB12                      : 1;
X    volatile uint32_t PB12                      : 1;
N    __IO uint32_t PB13                      : 1;
X    volatile uint32_t PB13                      : 1;
N    __IO uint32_t PB14                      : 1;
X    volatile uint32_t PB14                      : 1;
N    __IO uint32_t PB15                      : 1;
X    volatile uint32_t PB15                      : 1;
N} stc_gpio_pblie_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PB00                      : 1;
X    volatile uint32_t PB00                      : 1;
N    __IO uint32_t PB01                      : 1;
X    volatile uint32_t PB01                      : 1;
N    __IO uint32_t PB02                      : 1;
X    volatile uint32_t PB02                      : 1;
N    __IO uint32_t PB03                      : 1;
X    volatile uint32_t PB03                      : 1;
N    __IO uint32_t PB04                      : 1;
X    volatile uint32_t PB04                      : 1;
N    __IO uint32_t PB05                      : 1;
X    volatile uint32_t PB05                      : 1;
N    __IO uint32_t PB06                      : 1;
X    volatile uint32_t PB06                      : 1;
N    __IO uint32_t PB07                      : 1;
X    volatile uint32_t PB07                      : 1;
N    __IO uint32_t PB08                      : 1;
X    volatile uint32_t PB08                      : 1;
N    __IO uint32_t PB09                      : 1;
X    volatile uint32_t PB09                      : 1;
N    __IO uint32_t PB10                      : 1;
X    volatile uint32_t PB10                      : 1;
N    __IO uint32_t PB11                      : 1;
X    volatile uint32_t PB11                      : 1;
N    __IO uint32_t PB12                      : 1;
X    volatile uint32_t PB12                      : 1;
N    __IO uint32_t PB13                      : 1;
X    volatile uint32_t PB13                      : 1;
N    __IO uint32_t PB14                      : 1;
X    volatile uint32_t PB14                      : 1;
N    __IO uint32_t PB15                      : 1;
X    volatile uint32_t PB15                      : 1;
N} stc_gpio_pbrie_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PB00                      : 1;
X    volatile uint32_t PB00                      : 1;
N    __IO uint32_t PB01                      : 1;
X    volatile uint32_t PB01                      : 1;
N    __IO uint32_t PB02                      : 1;
X    volatile uint32_t PB02                      : 1;
N    __IO uint32_t PB03                      : 1;
X    volatile uint32_t PB03                      : 1;
N    __IO uint32_t PB04                      : 1;
X    volatile uint32_t PB04                      : 1;
N    __IO uint32_t PB05                      : 1;
X    volatile uint32_t PB05                      : 1;
N    __IO uint32_t PB06                      : 1;
X    volatile uint32_t PB06                      : 1;
N    __IO uint32_t PB07                      : 1;
X    volatile uint32_t PB07                      : 1;
N    __IO uint32_t PB08                      : 1;
X    volatile uint32_t PB08                      : 1;
N    __IO uint32_t PB09                      : 1;
X    volatile uint32_t PB09                      : 1;
N    __IO uint32_t PB10                      : 1;
X    volatile uint32_t PB10                      : 1;
N    __IO uint32_t PB11                      : 1;
X    volatile uint32_t PB11                      : 1;
N    __IO uint32_t PB12                      : 1;
X    volatile uint32_t PB12                      : 1;
N    __IO uint32_t PB13                      : 1;
X    volatile uint32_t PB13                      : 1;
N    __IO uint32_t PB14                      : 1;
X    volatile uint32_t PB14                      : 1;
N    __IO uint32_t PB15                      : 1;
X    volatile uint32_t PB15                      : 1;
N} stc_gpio_pbfie_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PC00                      : 1;
X    volatile uint32_t PC00                      : 1;
N    __IO uint32_t PC01                      : 1;
X    volatile uint32_t PC01                      : 1;
N    __IO uint32_t PC02                      : 1;
X    volatile uint32_t PC02                      : 1;
N    __IO uint32_t PC03                      : 1;
X    volatile uint32_t PC03                      : 1;
N    __IO uint32_t PC04                      : 1;
X    volatile uint32_t PC04                      : 1;
N    __IO uint32_t PC05                      : 1;
X    volatile uint32_t PC05                      : 1;
N    __IO uint32_t PC06                      : 1;
X    volatile uint32_t PC06                      : 1;
N    __IO uint32_t PC07                      : 1;
X    volatile uint32_t PC07                      : 1;
N    __IO uint32_t PC08                      : 1;
X    volatile uint32_t PC08                      : 1;
N    __IO uint32_t PC09                      : 1;
X    volatile uint32_t PC09                      : 1;
N    __IO uint32_t PC10                      : 1;
X    volatile uint32_t PC10                      : 1;
N    __IO uint32_t PC11                      : 1;
X    volatile uint32_t PC11                      : 1;
N    __IO uint32_t PC12                      : 1;
X    volatile uint32_t PC12                      : 1;
N    __IO uint32_t PC13                      : 1;
X    volatile uint32_t PC13                      : 1;
N    __IO uint32_t PC14                      : 1;
X    volatile uint32_t PC14                      : 1;
N    __IO uint32_t PC15                      : 1;
X    volatile uint32_t PC15                      : 1;
N} stc_gpio_pcdir_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PC00                      : 1;
X    volatile uint32_t PC00                      : 1;
N    __IO uint32_t PC01                      : 1;
X    volatile uint32_t PC01                      : 1;
N    __IO uint32_t PC02                      : 1;
X    volatile uint32_t PC02                      : 1;
N    __IO uint32_t PC03                      : 1;
X    volatile uint32_t PC03                      : 1;
N    __IO uint32_t PC04                      : 1;
X    volatile uint32_t PC04                      : 1;
N    __IO uint32_t PC05                      : 1;
X    volatile uint32_t PC05                      : 1;
N    __IO uint32_t PC06                      : 1;
X    volatile uint32_t PC06                      : 1;
N    __IO uint32_t PC07                      : 1;
X    volatile uint32_t PC07                      : 1;
N    __IO uint32_t PC08                      : 1;
X    volatile uint32_t PC08                      : 1;
N    __IO uint32_t PC09                      : 1;
X    volatile uint32_t PC09                      : 1;
N    __IO uint32_t PC10                      : 1;
X    volatile uint32_t PC10                      : 1;
N    __IO uint32_t PC11                      : 1;
X    volatile uint32_t PC11                      : 1;
N    __IO uint32_t PC12                      : 1;
X    volatile uint32_t PC12                      : 1;
N    __IO uint32_t PC13                      : 1;
X    volatile uint32_t PC13                      : 1;
N    __IO uint32_t PC14                      : 1;
X    volatile uint32_t PC14                      : 1;
N    __IO uint32_t PC15                      : 1;
X    volatile uint32_t PC15                      : 1;
N} stc_gpio_pcin_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PC00                      : 1;
X    volatile uint32_t PC00                      : 1;
N    __IO uint32_t PC01                      : 1;
X    volatile uint32_t PC01                      : 1;
N    __IO uint32_t PC02                      : 1;
X    volatile uint32_t PC02                      : 1;
N    __IO uint32_t PC03                      : 1;
X    volatile uint32_t PC03                      : 1;
N    __IO uint32_t PC04                      : 1;
X    volatile uint32_t PC04                      : 1;
N    __IO uint32_t PC05                      : 1;
X    volatile uint32_t PC05                      : 1;
N    __IO uint32_t PC06                      : 1;
X    volatile uint32_t PC06                      : 1;
N    __IO uint32_t PC07                      : 1;
X    volatile uint32_t PC07                      : 1;
N    __IO uint32_t PC08                      : 1;
X    volatile uint32_t PC08                      : 1;
N    __IO uint32_t PC09                      : 1;
X    volatile uint32_t PC09                      : 1;
N    __IO uint32_t PC10                      : 1;
X    volatile uint32_t PC10                      : 1;
N    __IO uint32_t PC11                      : 1;
X    volatile uint32_t PC11                      : 1;
N    __IO uint32_t PC12                      : 1;
X    volatile uint32_t PC12                      : 1;
N    __IO uint32_t PC13                      : 1;
X    volatile uint32_t PC13                      : 1;
N    __IO uint32_t PC14                      : 1;
X    volatile uint32_t PC14                      : 1;
N    __IO uint32_t PC15                      : 1;
X    volatile uint32_t PC15                      : 1;
N} stc_gpio_pcout_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PC00                      : 1;
X    volatile uint32_t PC00                      : 1;
N    __IO uint32_t PC01                      : 1;
X    volatile uint32_t PC01                      : 1;
N    __IO uint32_t PC02                      : 1;
X    volatile uint32_t PC02                      : 1;
N    __IO uint32_t PC03                      : 1;
X    volatile uint32_t PC03                      : 1;
N    __IO uint32_t PC04                      : 1;
X    volatile uint32_t PC04                      : 1;
N    __IO uint32_t PC05                      : 1;
X    volatile uint32_t PC05                      : 1;
N    __IO uint32_t PC06                      : 1;
X    volatile uint32_t PC06                      : 1;
N    __IO uint32_t PC07                      : 1;
X    volatile uint32_t PC07                      : 1;
N    __IO uint32_t PC08                      : 1;
X    volatile uint32_t PC08                      : 1;
N    __IO uint32_t PC09                      : 1;
X    volatile uint32_t PC09                      : 1;
N    __IO uint32_t PC10                      : 1;
X    volatile uint32_t PC10                      : 1;
N    __IO uint32_t PC11                      : 1;
X    volatile uint32_t PC11                      : 1;
N    __IO uint32_t PC12                      : 1;
X    volatile uint32_t PC12                      : 1;
N    __IO uint32_t PC13                      : 1;
X    volatile uint32_t PC13                      : 1;
N    __IO uint32_t PC14                      : 1;
X    volatile uint32_t PC14                      : 1;
N    __IO uint32_t PC15                      : 1;
X    volatile uint32_t PC15                      : 1;
N} stc_gpio_pcads_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PC00                      : 1;
X    volatile uint32_t PC00                      : 1;
N    __IO uint32_t PC01                      : 1;
X    volatile uint32_t PC01                      : 1;
N    __IO uint32_t PC02                      : 1;
X    volatile uint32_t PC02                      : 1;
N    __IO uint32_t PC03                      : 1;
X    volatile uint32_t PC03                      : 1;
N    __IO uint32_t PC04                      : 1;
X    volatile uint32_t PC04                      : 1;
N    __IO uint32_t PC05                      : 1;
X    volatile uint32_t PC05                      : 1;
N    __IO uint32_t PC06                      : 1;
X    volatile uint32_t PC06                      : 1;
N    __IO uint32_t PC07                      : 1;
X    volatile uint32_t PC07                      : 1;
N    __IO uint32_t PC08                      : 1;
X    volatile uint32_t PC08                      : 1;
N    __IO uint32_t PC09                      : 1;
X    volatile uint32_t PC09                      : 1;
N    __IO uint32_t PC10                      : 1;
X    volatile uint32_t PC10                      : 1;
N    __IO uint32_t PC11                      : 1;
X    volatile uint32_t PC11                      : 1;
N    __IO uint32_t PC12                      : 1;
X    volatile uint32_t PC12                      : 1;
N    __IO uint32_t PC13                      : 1;
X    volatile uint32_t PC13                      : 1;
N    __IO uint32_t PC14                      : 1;
X    volatile uint32_t PC14                      : 1;
N    __IO uint32_t PC15                      : 1;
X    volatile uint32_t PC15                      : 1;
N} stc_gpio_pcbset_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PC00                      : 1;
X    volatile uint32_t PC00                      : 1;
N    __IO uint32_t PC01                      : 1;
X    volatile uint32_t PC01                      : 1;
N    __IO uint32_t PC02                      : 1;
X    volatile uint32_t PC02                      : 1;
N    __IO uint32_t PC03                      : 1;
X    volatile uint32_t PC03                      : 1;
N    __IO uint32_t PC04                      : 1;
X    volatile uint32_t PC04                      : 1;
N    __IO uint32_t PC05                      : 1;
X    volatile uint32_t PC05                      : 1;
N    __IO uint32_t PC06                      : 1;
X    volatile uint32_t PC06                      : 1;
N    __IO uint32_t PC07                      : 1;
X    volatile uint32_t PC07                      : 1;
N    __IO uint32_t PC08                      : 1;
X    volatile uint32_t PC08                      : 1;
N    __IO uint32_t PC09                      : 1;
X    volatile uint32_t PC09                      : 1;
N    __IO uint32_t PC10                      : 1;
X    volatile uint32_t PC10                      : 1;
N    __IO uint32_t PC11                      : 1;
X    volatile uint32_t PC11                      : 1;
N    __IO uint32_t PC12                      : 1;
X    volatile uint32_t PC12                      : 1;
N    __IO uint32_t PC13                      : 1;
X    volatile uint32_t PC13                      : 1;
N    __IO uint32_t PC14                      : 1;
X    volatile uint32_t PC14                      : 1;
N    __IO uint32_t PC15                      : 1;
X    volatile uint32_t PC15                      : 1;
N} stc_gpio_pcbclr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PCBCLR                    :16;
X    volatile uint32_t PCBCLR                    :16;
N    __IO uint32_t PCBSET                    :16;
X    volatile uint32_t PCBSET                    :16;
N} stc_gpio_pcbsetclr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PC00                      : 1;
X    volatile uint32_t PC00                      : 1;
N    __IO uint32_t PC01                      : 1;
X    volatile uint32_t PC01                      : 1;
N    __IO uint32_t PC02                      : 1;
X    volatile uint32_t PC02                      : 1;
N    __IO uint32_t PC03                      : 1;
X    volatile uint32_t PC03                      : 1;
N    __IO uint32_t PC04                      : 1;
X    volatile uint32_t PC04                      : 1;
N    __IO uint32_t PC05                      : 1;
X    volatile uint32_t PC05                      : 1;
N    __IO uint32_t PC06                      : 1;
X    volatile uint32_t PC06                      : 1;
N    __IO uint32_t PC07                      : 1;
X    volatile uint32_t PC07                      : 1;
N    __IO uint32_t PC08                      : 1;
X    volatile uint32_t PC08                      : 1;
N    __IO uint32_t PC09                      : 1;
X    volatile uint32_t PC09                      : 1;
N    __IO uint32_t PC10                      : 1;
X    volatile uint32_t PC10                      : 1;
N    __IO uint32_t PC11                      : 1;
X    volatile uint32_t PC11                      : 1;
N    __IO uint32_t PC12                      : 1;
X    volatile uint32_t PC12                      : 1;
N    __IO uint32_t PC13                      : 1;
X    volatile uint32_t PC13                      : 1;
N    __IO uint32_t PC14                      : 1;
X    volatile uint32_t PC14                      : 1;
N    __IO uint32_t PC15                      : 1;
X    volatile uint32_t PC15                      : 1;
N} stc_gpio_pcdr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PC00                      : 1;
X    volatile uint32_t PC00                      : 1;
N    __IO uint32_t PC01                      : 1;
X    volatile uint32_t PC01                      : 1;
N    __IO uint32_t PC02                      : 1;
X    volatile uint32_t PC02                      : 1;
N    __IO uint32_t PC03                      : 1;
X    volatile uint32_t PC03                      : 1;
N    __IO uint32_t PC04                      : 1;
X    volatile uint32_t PC04                      : 1;
N    __IO uint32_t PC05                      : 1;
X    volatile uint32_t PC05                      : 1;
N    __IO uint32_t PC06                      : 1;
X    volatile uint32_t PC06                      : 1;
N    __IO uint32_t PC07                      : 1;
X    volatile uint32_t PC07                      : 1;
N    __IO uint32_t PC08                      : 1;
X    volatile uint32_t PC08                      : 1;
N    __IO uint32_t PC09                      : 1;
X    volatile uint32_t PC09                      : 1;
N    __IO uint32_t PC10                      : 1;
X    volatile uint32_t PC10                      : 1;
N    __IO uint32_t PC11                      : 1;
X    volatile uint32_t PC11                      : 1;
N    __IO uint32_t PC12                      : 1;
X    volatile uint32_t PC12                      : 1;
N    __IO uint32_t PC13                      : 1;
X    volatile uint32_t PC13                      : 1;
N    __IO uint32_t PC14                      : 1;
X    volatile uint32_t PC14                      : 1;
N    __IO uint32_t PC15                      : 1;
X    volatile uint32_t PC15                      : 1;
N} stc_gpio_pcpu_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PC00                      : 1;
X    volatile uint32_t PC00                      : 1;
N    __IO uint32_t PC01                      : 1;
X    volatile uint32_t PC01                      : 1;
N    __IO uint32_t PC02                      : 1;
X    volatile uint32_t PC02                      : 1;
N    __IO uint32_t PC03                      : 1;
X    volatile uint32_t PC03                      : 1;
N    __IO uint32_t PC04                      : 1;
X    volatile uint32_t PC04                      : 1;
N    __IO uint32_t PC05                      : 1;
X    volatile uint32_t PC05                      : 1;
N    __IO uint32_t PC06                      : 1;
X    volatile uint32_t PC06                      : 1;
N    __IO uint32_t PC07                      : 1;
X    volatile uint32_t PC07                      : 1;
N    __IO uint32_t PC08                      : 1;
X    volatile uint32_t PC08                      : 1;
N    __IO uint32_t PC09                      : 1;
X    volatile uint32_t PC09                      : 1;
N    __IO uint32_t PC10                      : 1;
X    volatile uint32_t PC10                      : 1;
N    __IO uint32_t PC11                      : 1;
X    volatile uint32_t PC11                      : 1;
N    __IO uint32_t PC12                      : 1;
X    volatile uint32_t PC12                      : 1;
N    __IO uint32_t PC13                      : 1;
X    volatile uint32_t PC13                      : 1;
N    __IO uint32_t PC14                      : 1;
X    volatile uint32_t PC14                      : 1;
N    __IO uint32_t PC15                      : 1;
X    volatile uint32_t PC15                      : 1;
N} stc_gpio_pcpd_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PC00                      : 1;
X    volatile uint32_t PC00                      : 1;
N    __IO uint32_t PC01                      : 1;
X    volatile uint32_t PC01                      : 1;
N    __IO uint32_t PC02                      : 1;
X    volatile uint32_t PC02                      : 1;
N    __IO uint32_t PC03                      : 1;
X    volatile uint32_t PC03                      : 1;
N    __IO uint32_t PC04                      : 1;
X    volatile uint32_t PC04                      : 1;
N    __IO uint32_t PC05                      : 1;
X    volatile uint32_t PC05                      : 1;
N    __IO uint32_t PC06                      : 1;
X    volatile uint32_t PC06                      : 1;
N    __IO uint32_t PC07                      : 1;
X    volatile uint32_t PC07                      : 1;
N    __IO uint32_t PC08                      : 1;
X    volatile uint32_t PC08                      : 1;
N    __IO uint32_t PC09                      : 1;
X    volatile uint32_t PC09                      : 1;
N    __IO uint32_t PC10                      : 1;
X    volatile uint32_t PC10                      : 1;
N    __IO uint32_t PC11                      : 1;
X    volatile uint32_t PC11                      : 1;
N    __IO uint32_t PC12                      : 1;
X    volatile uint32_t PC12                      : 1;
N    __IO uint32_t PC13                      : 1;
X    volatile uint32_t PC13                      : 1;
N    __IO uint32_t PC14                      : 1;
X    volatile uint32_t PC14                      : 1;
N    __IO uint32_t PC15                      : 1;
X    volatile uint32_t PC15                      : 1;
N} stc_gpio_pcod_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PC00                      : 1;
X    volatile uint32_t PC00                      : 1;
N    __IO uint32_t PC01                      : 1;
X    volatile uint32_t PC01                      : 1;
N    __IO uint32_t PC02                      : 1;
X    volatile uint32_t PC02                      : 1;
N    __IO uint32_t PC03                      : 1;
X    volatile uint32_t PC03                      : 1;
N    __IO uint32_t PC04                      : 1;
X    volatile uint32_t PC04                      : 1;
N    __IO uint32_t PC05                      : 1;
X    volatile uint32_t PC05                      : 1;
N    __IO uint32_t PC06                      : 1;
X    volatile uint32_t PC06                      : 1;
N    __IO uint32_t PC07                      : 1;
X    volatile uint32_t PC07                      : 1;
N    __IO uint32_t PC08                      : 1;
X    volatile uint32_t PC08                      : 1;
N    __IO uint32_t PC09                      : 1;
X    volatile uint32_t PC09                      : 1;
N    __IO uint32_t PC10                      : 1;
X    volatile uint32_t PC10                      : 1;
N    __IO uint32_t PC11                      : 1;
X    volatile uint32_t PC11                      : 1;
N    __IO uint32_t PC12                      : 1;
X    volatile uint32_t PC12                      : 1;
N    __IO uint32_t PC13                      : 1;
X    volatile uint32_t PC13                      : 1;
N    __IO uint32_t PC14                      : 1;
X    volatile uint32_t PC14                      : 1;
N    __IO uint32_t PC15                      : 1;
X    volatile uint32_t PC15                      : 1;
N} stc_gpio_pchie_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PC00                      : 1;
X    volatile uint32_t PC00                      : 1;
N    __IO uint32_t PC01                      : 1;
X    volatile uint32_t PC01                      : 1;
N    __IO uint32_t PC02                      : 1;
X    volatile uint32_t PC02                      : 1;
N    __IO uint32_t PC03                      : 1;
X    volatile uint32_t PC03                      : 1;
N    __IO uint32_t PC04                      : 1;
X    volatile uint32_t PC04                      : 1;
N    __IO uint32_t PC05                      : 1;
X    volatile uint32_t PC05                      : 1;
N    __IO uint32_t PC06                      : 1;
X    volatile uint32_t PC06                      : 1;
N    __IO uint32_t PC07                      : 1;
X    volatile uint32_t PC07                      : 1;
N    __IO uint32_t PC08                      : 1;
X    volatile uint32_t PC08                      : 1;
N    __IO uint32_t PC09                      : 1;
X    volatile uint32_t PC09                      : 1;
N    __IO uint32_t PC10                      : 1;
X    volatile uint32_t PC10                      : 1;
N    __IO uint32_t PC11                      : 1;
X    volatile uint32_t PC11                      : 1;
N    __IO uint32_t PC12                      : 1;
X    volatile uint32_t PC12                      : 1;
N    __IO uint32_t PC13                      : 1;
X    volatile uint32_t PC13                      : 1;
N    __IO uint32_t PC14                      : 1;
X    volatile uint32_t PC14                      : 1;
N    __IO uint32_t PC15                      : 1;
X    volatile uint32_t PC15                      : 1;
N} stc_gpio_pclie_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PC00                      : 1;
X    volatile uint32_t PC00                      : 1;
N    __IO uint32_t PC01                      : 1;
X    volatile uint32_t PC01                      : 1;
N    __IO uint32_t PC02                      : 1;
X    volatile uint32_t PC02                      : 1;
N    __IO uint32_t PC03                      : 1;
X    volatile uint32_t PC03                      : 1;
N    __IO uint32_t PC04                      : 1;
X    volatile uint32_t PC04                      : 1;
N    __IO uint32_t PC05                      : 1;
X    volatile uint32_t PC05                      : 1;
N    __IO uint32_t PC06                      : 1;
X    volatile uint32_t PC06                      : 1;
N    __IO uint32_t PC07                      : 1;
X    volatile uint32_t PC07                      : 1;
N    __IO uint32_t PC08                      : 1;
X    volatile uint32_t PC08                      : 1;
N    __IO uint32_t PC09                      : 1;
X    volatile uint32_t PC09                      : 1;
N    __IO uint32_t PC10                      : 1;
X    volatile uint32_t PC10                      : 1;
N    __IO uint32_t PC11                      : 1;
X    volatile uint32_t PC11                      : 1;
N    __IO uint32_t PC12                      : 1;
X    volatile uint32_t PC12                      : 1;
N    __IO uint32_t PC13                      : 1;
X    volatile uint32_t PC13                      : 1;
N    __IO uint32_t PC14                      : 1;
X    volatile uint32_t PC14                      : 1;
N    __IO uint32_t PC15                      : 1;
X    volatile uint32_t PC15                      : 1;
N} stc_gpio_pcrie_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PC00                      : 1;
X    volatile uint32_t PC00                      : 1;
N    __IO uint32_t PC01                      : 1;
X    volatile uint32_t PC01                      : 1;
N    __IO uint32_t PC02                      : 1;
X    volatile uint32_t PC02                      : 1;
N    __IO uint32_t PC03                      : 1;
X    volatile uint32_t PC03                      : 1;
N    __IO uint32_t PC04                      : 1;
X    volatile uint32_t PC04                      : 1;
N    __IO uint32_t PC05                      : 1;
X    volatile uint32_t PC05                      : 1;
N    __IO uint32_t PC06                      : 1;
X    volatile uint32_t PC06                      : 1;
N    __IO uint32_t PC07                      : 1;
X    volatile uint32_t PC07                      : 1;
N    __IO uint32_t PC08                      : 1;
X    volatile uint32_t PC08                      : 1;
N    __IO uint32_t PC09                      : 1;
X    volatile uint32_t PC09                      : 1;
N    __IO uint32_t PC10                      : 1;
X    volatile uint32_t PC10                      : 1;
N    __IO uint32_t PC11                      : 1;
X    volatile uint32_t PC11                      : 1;
N    __IO uint32_t PC12                      : 1;
X    volatile uint32_t PC12                      : 1;
N    __IO uint32_t PC13                      : 1;
X    volatile uint32_t PC13                      : 1;
N    __IO uint32_t PC14                      : 1;
X    volatile uint32_t PC14                      : 1;
N    __IO uint32_t PC15                      : 1;
X    volatile uint32_t PC15                      : 1;
N} stc_gpio_pcfie_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PD00                      : 1;
X    volatile uint32_t PD00                      : 1;
N    __IO uint32_t PD01                      : 1;
X    volatile uint32_t PD01                      : 1;
N    __IO uint32_t PD02                      : 1;
X    volatile uint32_t PD02                      : 1;
N    __IO uint32_t PD03                      : 1;
X    volatile uint32_t PD03                      : 1;
N    __IO uint32_t PD04                      : 1;
X    volatile uint32_t PD04                      : 1;
N    __IO uint32_t PD05                      : 1;
X    volatile uint32_t PD05                      : 1;
N    __IO uint32_t PD06                      : 1;
X    volatile uint32_t PD06                      : 1;
N    __IO uint32_t PD07                      : 1;
X    volatile uint32_t PD07                      : 1;
N} stc_gpio_pddir_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PD00                      : 1;
X    volatile uint32_t PD00                      : 1;
N    __IO uint32_t PD01                      : 1;
X    volatile uint32_t PD01                      : 1;
N    __IO uint32_t PD02                      : 1;
X    volatile uint32_t PD02                      : 1;
N    __IO uint32_t PD03                      : 1;
X    volatile uint32_t PD03                      : 1;
N    __IO uint32_t PD04                      : 1;
X    volatile uint32_t PD04                      : 1;
N    __IO uint32_t PD05                      : 1;
X    volatile uint32_t PD05                      : 1;
N    __IO uint32_t PD06                      : 1;
X    volatile uint32_t PD06                      : 1;
N    __IO uint32_t PD07                      : 1;
X    volatile uint32_t PD07                      : 1;
N} stc_gpio_pdin_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PD00                      : 1;
X    volatile uint32_t PD00                      : 1;
N    __IO uint32_t PD01                      : 1;
X    volatile uint32_t PD01                      : 1;
N    __IO uint32_t PD02                      : 1;
X    volatile uint32_t PD02                      : 1;
N    __IO uint32_t PD03                      : 1;
X    volatile uint32_t PD03                      : 1;
N    __IO uint32_t PD04                      : 1;
X    volatile uint32_t PD04                      : 1;
N    __IO uint32_t PD05                      : 1;
X    volatile uint32_t PD05                      : 1;
N    __IO uint32_t PD06                      : 1;
X    volatile uint32_t PD06                      : 1;
N    __IO uint32_t PD07                      : 1;
X    volatile uint32_t PD07                      : 1;
N} stc_gpio_pdout_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PD00                      : 1;
X    volatile uint32_t PD00                      : 1;
N    __IO uint32_t PD01                      : 1;
X    volatile uint32_t PD01                      : 1;
N    __IO uint32_t PD02                      : 1;
X    volatile uint32_t PD02                      : 1;
N    __IO uint32_t PD03                      : 1;
X    volatile uint32_t PD03                      : 1;
N    __IO uint32_t PD04                      : 1;
X    volatile uint32_t PD04                      : 1;
N    __IO uint32_t PD05                      : 1;
X    volatile uint32_t PD05                      : 1;
N    __IO uint32_t PD06                      : 1;
X    volatile uint32_t PD06                      : 1;
N    __IO uint32_t PD07                      : 1;
X    volatile uint32_t PD07                      : 1;
N} stc_gpio_pdads_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PD00                      : 1;
X    volatile uint32_t PD00                      : 1;
N    __IO uint32_t PD01                      : 1;
X    volatile uint32_t PD01                      : 1;
N    __IO uint32_t PD02                      : 1;
X    volatile uint32_t PD02                      : 1;
N    __IO uint32_t PD03                      : 1;
X    volatile uint32_t PD03                      : 1;
N    __IO uint32_t PD04                      : 1;
X    volatile uint32_t PD04                      : 1;
N    __IO uint32_t PD05                      : 1;
X    volatile uint32_t PD05                      : 1;
N    __IO uint32_t PD06                      : 1;
X    volatile uint32_t PD06                      : 1;
N    __IO uint32_t PD07                      : 1;
X    volatile uint32_t PD07                      : 1;
N} stc_gpio_pdbset_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PD00                      : 1;
X    volatile uint32_t PD00                      : 1;
N    __IO uint32_t PD01                      : 1;
X    volatile uint32_t PD01                      : 1;
N    __IO uint32_t PD02                      : 1;
X    volatile uint32_t PD02                      : 1;
N    __IO uint32_t PD03                      : 1;
X    volatile uint32_t PD03                      : 1;
N    __IO uint32_t PD04                      : 1;
X    volatile uint32_t PD04                      : 1;
N    __IO uint32_t PD05                      : 1;
X    volatile uint32_t PD05                      : 1;
N    __IO uint32_t PD06                      : 1;
X    volatile uint32_t PD06                      : 1;
N    __IO uint32_t PD07                      : 1;
X    volatile uint32_t PD07                      : 1;
N} stc_gpio_pdbclr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PDBCLR                    : 8;
X    volatile uint32_t PDBCLR                    : 8;
N    uint32_t RESERVED8                      : 8;
N    __IO uint32_t PDBSET                    : 8;
X    volatile uint32_t PDBSET                    : 8;
N} stc_gpio_pdbsetclr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PD00                      : 1;
X    volatile uint32_t PD00                      : 1;
N    __IO uint32_t PD01                      : 1;
X    volatile uint32_t PD01                      : 1;
N    __IO uint32_t PD02                      : 1;
X    volatile uint32_t PD02                      : 1;
N    __IO uint32_t PD03                      : 1;
X    volatile uint32_t PD03                      : 1;
N    __IO uint32_t PD04                      : 1;
X    volatile uint32_t PD04                      : 1;
N    __IO uint32_t PD05                      : 1;
X    volatile uint32_t PD05                      : 1;
N    __IO uint32_t PD06                      : 1;
X    volatile uint32_t PD06                      : 1;
N    __IO uint32_t PD07                      : 1;
X    volatile uint32_t PD07                      : 1;
N} stc_gpio_pddr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PD00                      : 1;
X    volatile uint32_t PD00                      : 1;
N    __IO uint32_t PD01                      : 1;
X    volatile uint32_t PD01                      : 1;
N    __IO uint32_t PD02                      : 1;
X    volatile uint32_t PD02                      : 1;
N    __IO uint32_t PD03                      : 1;
X    volatile uint32_t PD03                      : 1;
N    __IO uint32_t PD04                      : 1;
X    volatile uint32_t PD04                      : 1;
N    __IO uint32_t PD05                      : 1;
X    volatile uint32_t PD05                      : 1;
N    __IO uint32_t PD06                      : 1;
X    volatile uint32_t PD06                      : 1;
N    __IO uint32_t PD07                      : 1;
X    volatile uint32_t PD07                      : 1;
N} stc_gpio_pdpu_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PD00                      : 1;
X    volatile uint32_t PD00                      : 1;
N    __IO uint32_t PD01                      : 1;
X    volatile uint32_t PD01                      : 1;
N    __IO uint32_t PD02                      : 1;
X    volatile uint32_t PD02                      : 1;
N    __IO uint32_t PD03                      : 1;
X    volatile uint32_t PD03                      : 1;
N    __IO uint32_t PD04                      : 1;
X    volatile uint32_t PD04                      : 1;
N    __IO uint32_t PD05                      : 1;
X    volatile uint32_t PD05                      : 1;
N    __IO uint32_t PD06                      : 1;
X    volatile uint32_t PD06                      : 1;
N    __IO uint32_t PD07                      : 1;
X    volatile uint32_t PD07                      : 1;
N} stc_gpio_pdpd_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PD00                      : 1;
X    volatile uint32_t PD00                      : 1;
N    __IO uint32_t PD01                      : 1;
X    volatile uint32_t PD01                      : 1;
N    __IO uint32_t PD02                      : 1;
X    volatile uint32_t PD02                      : 1;
N    __IO uint32_t PD03                      : 1;
X    volatile uint32_t PD03                      : 1;
N    __IO uint32_t PD04                      : 1;
X    volatile uint32_t PD04                      : 1;
N    __IO uint32_t PD05                      : 1;
X    volatile uint32_t PD05                      : 1;
N    __IO uint32_t PD06                      : 1;
X    volatile uint32_t PD06                      : 1;
N    __IO uint32_t PD07                      : 1;
X    volatile uint32_t PD07                      : 1;
N} stc_gpio_pdod_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PD00                      : 1;
X    volatile uint32_t PD00                      : 1;
N    __IO uint32_t PD01                      : 1;
X    volatile uint32_t PD01                      : 1;
N    __IO uint32_t PD02                      : 1;
X    volatile uint32_t PD02                      : 1;
N    __IO uint32_t PD03                      : 1;
X    volatile uint32_t PD03                      : 1;
N    __IO uint32_t PD04                      : 1;
X    volatile uint32_t PD04                      : 1;
N    __IO uint32_t PD05                      : 1;
X    volatile uint32_t PD05                      : 1;
N    __IO uint32_t PD06                      : 1;
X    volatile uint32_t PD06                      : 1;
N    __IO uint32_t PD07                      : 1;
X    volatile uint32_t PD07                      : 1;
N} stc_gpio_pdhie_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PD00                      : 1;
X    volatile uint32_t PD00                      : 1;
N    __IO uint32_t PD01                      : 1;
X    volatile uint32_t PD01                      : 1;
N    __IO uint32_t PD02                      : 1;
X    volatile uint32_t PD02                      : 1;
N    __IO uint32_t PD03                      : 1;
X    volatile uint32_t PD03                      : 1;
N    __IO uint32_t PD04                      : 1;
X    volatile uint32_t PD04                      : 1;
N    __IO uint32_t PD05                      : 1;
X    volatile uint32_t PD05                      : 1;
N    __IO uint32_t PD06                      : 1;
X    volatile uint32_t PD06                      : 1;
N    __IO uint32_t PD07                      : 1;
X    volatile uint32_t PD07                      : 1;
N} stc_gpio_pdlie_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PD00                      : 1;
X    volatile uint32_t PD00                      : 1;
N    __IO uint32_t PD01                      : 1;
X    volatile uint32_t PD01                      : 1;
N    __IO uint32_t PD02                      : 1;
X    volatile uint32_t PD02                      : 1;
N    __IO uint32_t PD03                      : 1;
X    volatile uint32_t PD03                      : 1;
N    __IO uint32_t PD04                      : 1;
X    volatile uint32_t PD04                      : 1;
N    __IO uint32_t PD05                      : 1;
X    volatile uint32_t PD05                      : 1;
N    __IO uint32_t PD06                      : 1;
X    volatile uint32_t PD06                      : 1;
N    __IO uint32_t PD07                      : 1;
X    volatile uint32_t PD07                      : 1;
N} stc_gpio_pdrie_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PD00                      : 1;
X    volatile uint32_t PD00                      : 1;
N    __IO uint32_t PD01                      : 1;
X    volatile uint32_t PD01                      : 1;
N    __IO uint32_t PD02                      : 1;
X    volatile uint32_t PD02                      : 1;
N    __IO uint32_t PD03                      : 1;
X    volatile uint32_t PD03                      : 1;
N    __IO uint32_t PD04                      : 1;
X    volatile uint32_t PD04                      : 1;
N    __IO uint32_t PD05                      : 1;
X    volatile uint32_t PD05                      : 1;
N    __IO uint32_t PD06                      : 1;
X    volatile uint32_t PD06                      : 1;
N    __IO uint32_t PD07                      : 1;
X    volatile uint32_t PD07                      : 1;
N} stc_gpio_pdfie_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PA00                      : 1;
X    volatile uint32_t PA00                      : 1;
N    __IO uint32_t PA01                      : 1;
X    volatile uint32_t PA01                      : 1;
N    __IO uint32_t PA02                      : 1;
X    volatile uint32_t PA02                      : 1;
N    __IO uint32_t PA03                      : 1;
X    volatile uint32_t PA03                      : 1;
N    __IO uint32_t PA04                      : 1;
X    volatile uint32_t PA04                      : 1;
N    __IO uint32_t PA05                      : 1;
X    volatile uint32_t PA05                      : 1;
N    __IO uint32_t PA06                      : 1;
X    volatile uint32_t PA06                      : 1;
N    __IO uint32_t PA07                      : 1;
X    volatile uint32_t PA07                      : 1;
N    __IO uint32_t PA08                      : 1;
X    volatile uint32_t PA08                      : 1;
N    __IO uint32_t PA09                      : 1;
X    volatile uint32_t PA09                      : 1;
N    __IO uint32_t PA10                      : 1;
X    volatile uint32_t PA10                      : 1;
N    __IO uint32_t PA11                      : 1;
X    volatile uint32_t PA11                      : 1;
N    __IO uint32_t PA12                      : 1;
X    volatile uint32_t PA12                      : 1;
N    __IO uint32_t PA13                      : 1;
X    volatile uint32_t PA13                      : 1;
N    __IO uint32_t PA14                      : 1;
X    volatile uint32_t PA14                      : 1;
N    __IO uint32_t PA15                      : 1;
X    volatile uint32_t PA15                      : 1;
N} stc_gpio_pa_stat_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PA00                      : 1;
X    volatile uint32_t PA00                      : 1;
N    __IO uint32_t PA01                      : 1;
X    volatile uint32_t PA01                      : 1;
N    __IO uint32_t PA02                      : 1;
X    volatile uint32_t PA02                      : 1;
N    __IO uint32_t PA03                      : 1;
X    volatile uint32_t PA03                      : 1;
N    __IO uint32_t PA04                      : 1;
X    volatile uint32_t PA04                      : 1;
N    __IO uint32_t PA05                      : 1;
X    volatile uint32_t PA05                      : 1;
N    __IO uint32_t PA06                      : 1;
X    volatile uint32_t PA06                      : 1;
N    __IO uint32_t PA07                      : 1;
X    volatile uint32_t PA07                      : 1;
N    __IO uint32_t PA08                      : 1;
X    volatile uint32_t PA08                      : 1;
N    __IO uint32_t PA09                      : 1;
X    volatile uint32_t PA09                      : 1;
N    __IO uint32_t PA10                      : 1;
X    volatile uint32_t PA10                      : 1;
N    __IO uint32_t PA11                      : 1;
X    volatile uint32_t PA11                      : 1;
N    __IO uint32_t PA12                      : 1;
X    volatile uint32_t PA12                      : 1;
N    __IO uint32_t PA13                      : 1;
X    volatile uint32_t PA13                      : 1;
N    __IO uint32_t PA14                      : 1;
X    volatile uint32_t PA14                      : 1;
N    __IO uint32_t PA15                      : 1;
X    volatile uint32_t PA15                      : 1;
N} stc_gpio_pa_iclr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PB00                      : 1;
X    volatile uint32_t PB00                      : 1;
N    __IO uint32_t PB01                      : 1;
X    volatile uint32_t PB01                      : 1;
N    __IO uint32_t PB02                      : 1;
X    volatile uint32_t PB02                      : 1;
N    __IO uint32_t PB03                      : 1;
X    volatile uint32_t PB03                      : 1;
N    __IO uint32_t PB04                      : 1;
X    volatile uint32_t PB04                      : 1;
N    __IO uint32_t PB05                      : 1;
X    volatile uint32_t PB05                      : 1;
N    __IO uint32_t PB06                      : 1;
X    volatile uint32_t PB06                      : 1;
N    __IO uint32_t PB07                      : 1;
X    volatile uint32_t PB07                      : 1;
N    __IO uint32_t PB08                      : 1;
X    volatile uint32_t PB08                      : 1;
N    __IO uint32_t PB09                      : 1;
X    volatile uint32_t PB09                      : 1;
N    __IO uint32_t PB10                      : 1;
X    volatile uint32_t PB10                      : 1;
N    __IO uint32_t PB11                      : 1;
X    volatile uint32_t PB11                      : 1;
N    __IO uint32_t PB12                      : 1;
X    volatile uint32_t PB12                      : 1;
N    __IO uint32_t PB13                      : 1;
X    volatile uint32_t PB13                      : 1;
N    __IO uint32_t PB14                      : 1;
X    volatile uint32_t PB14                      : 1;
N    __IO uint32_t PB15                      : 1;
X    volatile uint32_t PB15                      : 1;
N} stc_gpio_pb_stat_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PB00                      : 1;
X    volatile uint32_t PB00                      : 1;
N    __IO uint32_t PB01                      : 1;
X    volatile uint32_t PB01                      : 1;
N    __IO uint32_t PB02                      : 1;
X    volatile uint32_t PB02                      : 1;
N    __IO uint32_t PB03                      : 1;
X    volatile uint32_t PB03                      : 1;
N    __IO uint32_t PB04                      : 1;
X    volatile uint32_t PB04                      : 1;
N    __IO uint32_t PB05                      : 1;
X    volatile uint32_t PB05                      : 1;
N    __IO uint32_t PB06                      : 1;
X    volatile uint32_t PB06                      : 1;
N    __IO uint32_t PB07                      : 1;
X    volatile uint32_t PB07                      : 1;
N    __IO uint32_t PB08                      : 1;
X    volatile uint32_t PB08                      : 1;
N    __IO uint32_t PB09                      : 1;
X    volatile uint32_t PB09                      : 1;
N    __IO uint32_t PB10                      : 1;
X    volatile uint32_t PB10                      : 1;
N    __IO uint32_t PB11                      : 1;
X    volatile uint32_t PB11                      : 1;
N    __IO uint32_t PB12                      : 1;
X    volatile uint32_t PB12                      : 1;
N    __IO uint32_t PB13                      : 1;
X    volatile uint32_t PB13                      : 1;
N    __IO uint32_t PB14                      : 1;
X    volatile uint32_t PB14                      : 1;
N    __IO uint32_t PB15                      : 1;
X    volatile uint32_t PB15                      : 1;
N} stc_gpio_pb_iclr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PC00                      : 1;
X    volatile uint32_t PC00                      : 1;
N    __IO uint32_t PC01                      : 1;
X    volatile uint32_t PC01                      : 1;
N    __IO uint32_t PC02                      : 1;
X    volatile uint32_t PC02                      : 1;
N    __IO uint32_t PC03                      : 1;
X    volatile uint32_t PC03                      : 1;
N    __IO uint32_t PC04                      : 1;
X    volatile uint32_t PC04                      : 1;
N    __IO uint32_t PC05                      : 1;
X    volatile uint32_t PC05                      : 1;
N    __IO uint32_t PC06                      : 1;
X    volatile uint32_t PC06                      : 1;
N    __IO uint32_t PC07                      : 1;
X    volatile uint32_t PC07                      : 1;
N    __IO uint32_t PC08                      : 1;
X    volatile uint32_t PC08                      : 1;
N    __IO uint32_t PC09                      : 1;
X    volatile uint32_t PC09                      : 1;
N    __IO uint32_t PC10                      : 1;
X    volatile uint32_t PC10                      : 1;
N    __IO uint32_t PC11                      : 1;
X    volatile uint32_t PC11                      : 1;
N    __IO uint32_t PC12                      : 1;
X    volatile uint32_t PC12                      : 1;
N    __IO uint32_t PC13                      : 1;
X    volatile uint32_t PC13                      : 1;
N    __IO uint32_t PC14                      : 1;
X    volatile uint32_t PC14                      : 1;
N    __IO uint32_t PC15                      : 1;
X    volatile uint32_t PC15                      : 1;
N} stc_gpio_pc_stat_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PC00                      : 1;
X    volatile uint32_t PC00                      : 1;
N    __IO uint32_t PC01                      : 1;
X    volatile uint32_t PC01                      : 1;
N    __IO uint32_t PC02                      : 1;
X    volatile uint32_t PC02                      : 1;
N    __IO uint32_t PC03                      : 1;
X    volatile uint32_t PC03                      : 1;
N    __IO uint32_t PC04                      : 1;
X    volatile uint32_t PC04                      : 1;
N    __IO uint32_t PC05                      : 1;
X    volatile uint32_t PC05                      : 1;
N    __IO uint32_t PC06                      : 1;
X    volatile uint32_t PC06                      : 1;
N    __IO uint32_t PC07                      : 1;
X    volatile uint32_t PC07                      : 1;
N    __IO uint32_t PC08                      : 1;
X    volatile uint32_t PC08                      : 1;
N    __IO uint32_t PC09                      : 1;
X    volatile uint32_t PC09                      : 1;
N    __IO uint32_t PC10                      : 1;
X    volatile uint32_t PC10                      : 1;
N    __IO uint32_t PC11                      : 1;
X    volatile uint32_t PC11                      : 1;
N    __IO uint32_t PC12                      : 1;
X    volatile uint32_t PC12                      : 1;
N    __IO uint32_t PC13                      : 1;
X    volatile uint32_t PC13                      : 1;
N    __IO uint32_t PC14                      : 1;
X    volatile uint32_t PC14                      : 1;
N    __IO uint32_t PC15                      : 1;
X    volatile uint32_t PC15                      : 1;
N} stc_gpio_pc_iclr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PD00                      : 1;
X    volatile uint32_t PD00                      : 1;
N    __IO uint32_t PD01                      : 1;
X    volatile uint32_t PD01                      : 1;
N    __IO uint32_t PD02                      : 1;
X    volatile uint32_t PD02                      : 1;
N    __IO uint32_t PD03                      : 1;
X    volatile uint32_t PD03                      : 1;
N    __IO uint32_t PD04                      : 1;
X    volatile uint32_t PD04                      : 1;
N    __IO uint32_t PD05                      : 1;
X    volatile uint32_t PD05                      : 1;
N    __IO uint32_t PD06                      : 1;
X    volatile uint32_t PD06                      : 1;
N    __IO uint32_t PD07                      : 1;
X    volatile uint32_t PD07                      : 1;
N} stc_gpio_pd_stat_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PD00                      : 1;
X    volatile uint32_t PD00                      : 1;
N    __IO uint32_t PD01                      : 1;
X    volatile uint32_t PD01                      : 1;
N    __IO uint32_t PD02                      : 1;
X    volatile uint32_t PD02                      : 1;
N    __IO uint32_t PD03                      : 1;
X    volatile uint32_t PD03                      : 1;
N    __IO uint32_t PD04                      : 1;
X    volatile uint32_t PD04                      : 1;
N    __IO uint32_t PD05                      : 1;
X    volatile uint32_t PD05                      : 1;
N    __IO uint32_t PD06                      : 1;
X    volatile uint32_t PD06                      : 1;
N    __IO uint32_t PD07                      : 1;
X    volatile uint32_t PD07                      : 1;
N} stc_gpio_pd_iclr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t IESEL                     : 1;
X    volatile uint32_t IESEL                     : 1;
N} stc_gpio_ctrl0_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t EXT_CLK_SEL               : 4;
X    volatile uint32_t EXT_CLK_SEL               : 4;
N    __IO uint32_t SSN0_SEL                  : 4;
X    volatile uint32_t SSN0_SEL                  : 4;
N    __IO uint32_t PCLK_SEL                  : 2;
X    volatile uint32_t PCLK_SEL                  : 2;
N    __IO uint32_t HCLK_SEL                  : 2;
X    volatile uint32_t HCLK_SEL                  : 2;
N    __IO uint32_t PCLK_EN                   : 1;
X    volatile uint32_t PCLK_EN                   : 1;
N    __IO uint32_t HCLK_EN                   : 1;
X    volatile uint32_t HCLK_EN                   : 1;
N    __IO uint32_t IR_POL                    : 1;
X    volatile uint32_t IR_POL                    : 1;
N} stc_gpio_ctrl1_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SSN1_SEL                  : 4;
X    volatile uint32_t SSN1_SEL                  : 4;
N} stc_gpio_ctrl2_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t TIM0_G                    : 3;
X    volatile uint32_t TIM0_G                    : 3;
N    __IO uint32_t TIM1_G                    : 3;
X    volatile uint32_t TIM1_G                    : 3;
N    __IO uint32_t TIM2_G                    : 3;
X    volatile uint32_t TIM2_G                    : 3;
N    __IO uint32_t TIM3_G                    : 3;
X    volatile uint32_t TIM3_G                    : 3;
N    __IO uint32_t LPTIM_G                   : 3;
X    volatile uint32_t LPTIM_G                   : 3;
N} stc_gpio_timgs_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t TIM0_E                    : 3;
X    volatile uint32_t TIM0_E                    : 3;
N    __IO uint32_t TIM1_E                    : 3;
X    volatile uint32_t TIM1_E                    : 3;
N    __IO uint32_t TIM2_E                    : 3;
X    volatile uint32_t TIM2_E                    : 3;
N    __IO uint32_t TIM3_E                    : 3;
X    volatile uint32_t TIM3_E                    : 3;
N    __IO uint32_t LPTIM_E                   : 3;
X    volatile uint32_t LPTIM_E                   : 3;
N} stc_gpio_times_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t TIM0_CA                   : 3;
X    volatile uint32_t TIM0_CA                   : 3;
N    __IO uint32_t TIM1_CA                   : 3;
X    volatile uint32_t TIM1_CA                   : 3;
N    __IO uint32_t TIM2_CA                   : 3;
X    volatile uint32_t TIM2_CA                   : 3;
N    __IO uint32_t TIM3_CA                   : 3;
X    volatile uint32_t TIM3_CA                   : 3;
N    __IO uint32_t TIM3_CB                   : 3;
X    volatile uint32_t TIM3_CB                   : 3;
N} stc_gpio_timcps_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PCA_CH0                   : 3;
X    volatile uint32_t PCA_CH0                   : 3;
N    __IO uint32_t PCA_ECI                   : 3;
X    volatile uint32_t PCA_ECI                   : 3;
N} stc_gpio_pcas_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t DIVIDEND                  :32;
X    volatile uint32_t DIVIDEND                  :32;
N} stc_hdiv_dividend_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t DIVISOR                   :16;
X    volatile uint32_t DIVISOR                   :16;
N} stc_hdiv_divisor_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t QUOTIENT                  :32;
X    volatile uint32_t QUOTIENT                  :32;
N} stc_hdiv_quotient_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t REMAINDER                 :32;
X    volatile uint32_t REMAINDER                 :32;
N} stc_hdiv_remainder_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SIGN                      : 1;
X    volatile uint32_t SIGN                      : 1;
N} stc_hdiv_sign_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t END                       : 1;
X    volatile uint32_t END                       : 1;
N    __IO uint32_t ZERO                      : 1;
X    volatile uint32_t ZERO                      : 1;
N} stc_hdiv_stat_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t TME                       : 1;
X    volatile uint32_t TME                       : 1;
N} stc_i2c_tmrun_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t TM                        : 8;
X    volatile uint32_t TM                        : 8;
N} stc_i2c_tm_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t H1M                       : 1;
X    volatile uint32_t H1M                       : 1;
N    uint32_t RESERVED1                      : 1;
N    __IO uint32_t AA                        : 1;
X    volatile uint32_t AA                        : 1;
N    __IO uint32_t SI                        : 1;
X    volatile uint32_t SI                        : 1;
N    __IO uint32_t STO                       : 1;
X    volatile uint32_t STO                       : 1;
N    __IO uint32_t STA                       : 1;
X    volatile uint32_t STA                       : 1;
N    __IO uint32_t ENS                       : 1;
X    volatile uint32_t ENS                       : 1;
N} stc_i2c_cr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t DAT                       : 8;
X    volatile uint32_t DAT                       : 8;
N} stc_i2c_data_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t GC                        : 1;
X    volatile uint32_t GC                        : 1;
N    __IO uint32_t ADR                       : 7;
X    volatile uint32_t ADR                       : 7;
N} stc_i2c_addr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t STA                       : 8;
X    volatile uint32_t STA                       : 8;
N} stc_i2c_stat_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t EN                        : 1;
X    volatile uint32_t EN                        : 1;
N    __IO uint32_t LCDCLK                    : 2;
X    volatile uint32_t LCDCLK                    : 2;
N    __IO uint32_t CPCLK                     : 2;
X    volatile uint32_t CPCLK                     : 2;
N    __IO uint32_t BIAS                      : 1;
X    volatile uint32_t BIAS                      : 1;
N    __IO uint32_t DUTY                      : 3;
X    volatile uint32_t DUTY                      : 3;
N    __IO uint32_t BSEL                      : 3;
X    volatile uint32_t BSEL                      : 3;
N    __IO uint32_t CONTRAST                  : 4;
X    volatile uint32_t CONTRAST                  : 4;
N} stc_lcd_cr0_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t BLINKCNT                  : 6;
X    volatile uint32_t BLINKCNT                  : 6;
N    __IO uint32_t BLINKEN                   : 1;
X    volatile uint32_t BLINKEN                   : 1;
N    __IO uint32_t CLKSRC                    : 1;
X    volatile uint32_t CLKSRC                    : 1;
N    __IO uint32_t MODE                      : 1;
X    volatile uint32_t MODE                      : 1;
N    __IO uint32_t IE                        : 1;
X    volatile uint32_t IE                        : 1;
N    __IO uint32_t DMAEN                     : 1;
X    volatile uint32_t DMAEN                     : 1;
N    __IO uint32_t INTF                      : 1;
X    volatile uint32_t INTF                      : 1;
N} stc_lcd_cr1_field_t;
N
Ntypedef struct
N{
N    uint32_t RESERVED0                      :10;
N    __IO uint32_t INTF                      : 1;
X    volatile uint32_t INTF                      : 1;
N} stc_lcd_intclr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t S0                        : 1;
X    volatile uint32_t S0                        : 1;
N    __IO uint32_t S1                        : 1;
X    volatile uint32_t S1                        : 1;
N    __IO uint32_t S2                        : 1;
X    volatile uint32_t S2                        : 1;
N    __IO uint32_t S3                        : 1;
X    volatile uint32_t S3                        : 1;
N    __IO uint32_t S4                        : 1;
X    volatile uint32_t S4                        : 1;
N    __IO uint32_t S5                        : 1;
X    volatile uint32_t S5                        : 1;
N    __IO uint32_t S6                        : 1;
X    volatile uint32_t S6                        : 1;
N    __IO uint32_t S7                        : 1;
X    volatile uint32_t S7                        : 1;
N    __IO uint32_t S8                        : 1;
X    volatile uint32_t S8                        : 1;
N    __IO uint32_t S9                        : 1;
X    volatile uint32_t S9                        : 1;
N    __IO uint32_t S10                       : 1;
X    volatile uint32_t S10                       : 1;
N    __IO uint32_t S11                       : 1;
X    volatile uint32_t S11                       : 1;
N    __IO uint32_t S12                       : 1;
X    volatile uint32_t S12                       : 1;
N    __IO uint32_t S13                       : 1;
X    volatile uint32_t S13                       : 1;
N    __IO uint32_t S14                       : 1;
X    volatile uint32_t S14                       : 1;
N    __IO uint32_t S15                       : 1;
X    volatile uint32_t S15                       : 1;
N    __IO uint32_t S16                       : 1;
X    volatile uint32_t S16                       : 1;
N    __IO uint32_t S17                       : 1;
X    volatile uint32_t S17                       : 1;
N    __IO uint32_t S18                       : 1;
X    volatile uint32_t S18                       : 1;
N    __IO uint32_t S19                       : 1;
X    volatile uint32_t S19                       : 1;
N    __IO uint32_t S20                       : 1;
X    volatile uint32_t S20                       : 1;
N    __IO uint32_t S21                       : 1;
X    volatile uint32_t S21                       : 1;
N    __IO uint32_t S22                       : 1;
X    volatile uint32_t S22                       : 1;
N    __IO uint32_t S23                       : 1;
X    volatile uint32_t S23                       : 1;
N    __IO uint32_t S24                       : 1;
X    volatile uint32_t S24                       : 1;
N    __IO uint32_t S25                       : 1;
X    volatile uint32_t S25                       : 1;
N    __IO uint32_t S26                       : 1;
X    volatile uint32_t S26                       : 1;
N    __IO uint32_t S27                       : 1;
X    volatile uint32_t S27                       : 1;
N    __IO uint32_t S28                       : 1;
X    volatile uint32_t S28                       : 1;
N    __IO uint32_t S29                       : 1;
X    volatile uint32_t S29                       : 1;
N    __IO uint32_t S30                       : 1;
X    volatile uint32_t S30                       : 1;
N    __IO uint32_t S31                       : 1;
X    volatile uint32_t S31                       : 1;
N} stc_lcd_poen0_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t S32                       : 1;
X    volatile uint32_t S32                       : 1;
N    __IO uint32_t S33                       : 1;
X    volatile uint32_t S33                       : 1;
N    __IO uint32_t S34                       : 1;
X    volatile uint32_t S34                       : 1;
N    __IO uint32_t S35                       : 1;
X    volatile uint32_t S35                       : 1;
N    __IO uint32_t S36C7                     : 1;
X    volatile uint32_t S36C7                     : 1;
N    __IO uint32_t S37C6                     : 1;
X    volatile uint32_t S37C6                     : 1;
N    __IO uint32_t S38C5                     : 1;
X    volatile uint32_t S38C5                     : 1;
N    __IO uint32_t S39C4                     : 1;
X    volatile uint32_t S39C4                     : 1;
N    __IO uint32_t C0                        : 1;
X    volatile uint32_t C0                        : 1;
N    __IO uint32_t C1                        : 1;
X    volatile uint32_t C1                        : 1;
N    __IO uint32_t C2                        : 1;
X    volatile uint32_t C2                        : 1;
N    __IO uint32_t C3                        : 1;
X    volatile uint32_t C3                        : 1;
N    __IO uint32_t MUX                       : 1;
X    volatile uint32_t MUX                       : 1;
N} stc_lcd_poen1_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t D0                        : 1;
X    volatile uint32_t D0                        : 1;
N    __IO uint32_t D1                        : 1;
X    volatile uint32_t D1                        : 1;
N    __IO uint32_t D2                        : 1;
X    volatile uint32_t D2                        : 1;
N    __IO uint32_t D3                        : 1;
X    volatile uint32_t D3                        : 1;
N    __IO uint32_t D4                        : 1;
X    volatile uint32_t D4                        : 1;
N    __IO uint32_t D5                        : 1;
X    volatile uint32_t D5                        : 1;
N    __IO uint32_t D6                        : 1;
X    volatile uint32_t D6                        : 1;
N    __IO uint32_t D7                        : 1;
X    volatile uint32_t D7                        : 1;
N    __IO uint32_t D8                        : 1;
X    volatile uint32_t D8                        : 1;
N    __IO uint32_t D9                        : 1;
X    volatile uint32_t D9                        : 1;
N    __IO uint32_t D10                       : 1;
X    volatile uint32_t D10                       : 1;
N    __IO uint32_t D11                       : 1;
X    volatile uint32_t D11                       : 1;
N    __IO uint32_t D12                       : 1;
X    volatile uint32_t D12                       : 1;
N    __IO uint32_t D13                       : 1;
X    volatile uint32_t D13                       : 1;
N    __IO uint32_t D14                       : 1;
X    volatile uint32_t D14                       : 1;
N    __IO uint32_t D15                       : 1;
X    volatile uint32_t D15                       : 1;
N    __IO uint32_t D16                       : 1;
X    volatile uint32_t D16                       : 1;
N    __IO uint32_t D17                       : 1;
X    volatile uint32_t D17                       : 1;
N    __IO uint32_t D18                       : 1;
X    volatile uint32_t D18                       : 1;
N    __IO uint32_t D19                       : 1;
X    volatile uint32_t D19                       : 1;
N    __IO uint32_t D20                       : 1;
X    volatile uint32_t D20                       : 1;
N    __IO uint32_t D21                       : 1;
X    volatile uint32_t D21                       : 1;
N    __IO uint32_t D22                       : 1;
X    volatile uint32_t D22                       : 1;
N    __IO uint32_t D23                       : 1;
X    volatile uint32_t D23                       : 1;
N    __IO uint32_t D24                       : 1;
X    volatile uint32_t D24                       : 1;
N    __IO uint32_t D25                       : 1;
X    volatile uint32_t D25                       : 1;
N    __IO uint32_t D26                       : 1;
X    volatile uint32_t D26                       : 1;
N    __IO uint32_t D27                       : 1;
X    volatile uint32_t D27                       : 1;
N    __IO uint32_t D28                       : 1;
X    volatile uint32_t D28                       : 1;
N    __IO uint32_t D29                       : 1;
X    volatile uint32_t D29                       : 1;
N    __IO uint32_t D30                       : 1;
X    volatile uint32_t D30                       : 1;
N    __IO uint32_t D31                       : 1;
X    volatile uint32_t D31                       : 1;
N} stc_lcd_ram0_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t D0                        : 1;
X    volatile uint32_t D0                        : 1;
N    __IO uint32_t D1                        : 1;
X    volatile uint32_t D1                        : 1;
N    __IO uint32_t D2                        : 1;
X    volatile uint32_t D2                        : 1;
N    __IO uint32_t D3                        : 1;
X    volatile uint32_t D3                        : 1;
N    __IO uint32_t D4                        : 1;
X    volatile uint32_t D4                        : 1;
N    __IO uint32_t D5                        : 1;
X    volatile uint32_t D5                        : 1;
N    __IO uint32_t D6                        : 1;
X    volatile uint32_t D6                        : 1;
N    __IO uint32_t D7                        : 1;
X    volatile uint32_t D7                        : 1;
N    __IO uint32_t D8                        : 1;
X    volatile uint32_t D8                        : 1;
N    __IO uint32_t D9                        : 1;
X    volatile uint32_t D9                        : 1;
N    __IO uint32_t D10                       : 1;
X    volatile uint32_t D10                       : 1;
N    __IO uint32_t D11                       : 1;
X    volatile uint32_t D11                       : 1;
N    __IO uint32_t D12                       : 1;
X    volatile uint32_t D12                       : 1;
N    __IO uint32_t D13                       : 1;
X    volatile uint32_t D13                       : 1;
N    __IO uint32_t D14                       : 1;
X    volatile uint32_t D14                       : 1;
N    __IO uint32_t D15                       : 1;
X    volatile uint32_t D15                       : 1;
N    __IO uint32_t D16                       : 1;
X    volatile uint32_t D16                       : 1;
N    __IO uint32_t D17                       : 1;
X    volatile uint32_t D17                       : 1;
N    __IO uint32_t D18                       : 1;
X    volatile uint32_t D18                       : 1;
N    __IO uint32_t D19                       : 1;
X    volatile uint32_t D19                       : 1;
N    __IO uint32_t D20                       : 1;
X    volatile uint32_t D20                       : 1;
N    __IO uint32_t D21                       : 1;
X    volatile uint32_t D21                       : 1;
N    __IO uint32_t D22                       : 1;
X    volatile uint32_t D22                       : 1;
N    __IO uint32_t D23                       : 1;
X    volatile uint32_t D23                       : 1;
N    __IO uint32_t D24                       : 1;
X    volatile uint32_t D24                       : 1;
N    __IO uint32_t D25                       : 1;
X    volatile uint32_t D25                       : 1;
N    __IO uint32_t D26                       : 1;
X    volatile uint32_t D26                       : 1;
N    __IO uint32_t D27                       : 1;
X    volatile uint32_t D27                       : 1;
N    __IO uint32_t D28                       : 1;
X    volatile uint32_t D28                       : 1;
N    __IO uint32_t D29                       : 1;
X    volatile uint32_t D29                       : 1;
N    __IO uint32_t D30                       : 1;
X    volatile uint32_t D30                       : 1;
N    __IO uint32_t D31                       : 1;
X    volatile uint32_t D31                       : 1;
N} stc_lcd_ram1_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t D0                        : 1;
X    volatile uint32_t D0                        : 1;
N    __IO uint32_t D1                        : 1;
X    volatile uint32_t D1                        : 1;
N    __IO uint32_t D2                        : 1;
X    volatile uint32_t D2                        : 1;
N    __IO uint32_t D3                        : 1;
X    volatile uint32_t D3                        : 1;
N    __IO uint32_t D4                        : 1;
X    volatile uint32_t D4                        : 1;
N    __IO uint32_t D5                        : 1;
X    volatile uint32_t D5                        : 1;
N    __IO uint32_t D6                        : 1;
X    volatile uint32_t D6                        : 1;
N    __IO uint32_t D7                        : 1;
X    volatile uint32_t D7                        : 1;
N    __IO uint32_t D8                        : 1;
X    volatile uint32_t D8                        : 1;
N    __IO uint32_t D9                        : 1;
X    volatile uint32_t D9                        : 1;
N    __IO uint32_t D10                       : 1;
X    volatile uint32_t D10                       : 1;
N    __IO uint32_t D11                       : 1;
X    volatile uint32_t D11                       : 1;
N    __IO uint32_t D12                       : 1;
X    volatile uint32_t D12                       : 1;
N    __IO uint32_t D13                       : 1;
X    volatile uint32_t D13                       : 1;
N    __IO uint32_t D14                       : 1;
X    volatile uint32_t D14                       : 1;
N    __IO uint32_t D15                       : 1;
X    volatile uint32_t D15                       : 1;
N    __IO uint32_t D16                       : 1;
X    volatile uint32_t D16                       : 1;
N    __IO uint32_t D17                       : 1;
X    volatile uint32_t D17                       : 1;
N    __IO uint32_t D18                       : 1;
X    volatile uint32_t D18                       : 1;
N    __IO uint32_t D19                       : 1;
X    volatile uint32_t D19                       : 1;
N    __IO uint32_t D20                       : 1;
X    volatile uint32_t D20                       : 1;
N    __IO uint32_t D21                       : 1;
X    volatile uint32_t D21                       : 1;
N    __IO uint32_t D22                       : 1;
X    volatile uint32_t D22                       : 1;
N    __IO uint32_t D23                       : 1;
X    volatile uint32_t D23                       : 1;
N    __IO uint32_t D24                       : 1;
X    volatile uint32_t D24                       : 1;
N    __IO uint32_t D25                       : 1;
X    volatile uint32_t D25                       : 1;
N    __IO uint32_t D26                       : 1;
X    volatile uint32_t D26                       : 1;
N    __IO uint32_t D27                       : 1;
X    volatile uint32_t D27                       : 1;
N    __IO uint32_t D28                       : 1;
X    volatile uint32_t D28                       : 1;
N    __IO uint32_t D29                       : 1;
X    volatile uint32_t D29                       : 1;
N    __IO uint32_t D30                       : 1;
X    volatile uint32_t D30                       : 1;
N    __IO uint32_t D31                       : 1;
X    volatile uint32_t D31                       : 1;
N} stc_lcd_ram2_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t D0                        : 1;
X    volatile uint32_t D0                        : 1;
N    __IO uint32_t D1                        : 1;
X    volatile uint32_t D1                        : 1;
N    __IO uint32_t D2                        : 1;
X    volatile uint32_t D2                        : 1;
N    __IO uint32_t D3                        : 1;
X    volatile uint32_t D3                        : 1;
N    __IO uint32_t D4                        : 1;
X    volatile uint32_t D4                        : 1;
N    __IO uint32_t D5                        : 1;
X    volatile uint32_t D5                        : 1;
N    __IO uint32_t D6                        : 1;
X    volatile uint32_t D6                        : 1;
N    __IO uint32_t D7                        : 1;
X    volatile uint32_t D7                        : 1;
N    __IO uint32_t D8                        : 1;
X    volatile uint32_t D8                        : 1;
N    __IO uint32_t D9                        : 1;
X    volatile uint32_t D9                        : 1;
N    __IO uint32_t D10                       : 1;
X    volatile uint32_t D10                       : 1;
N    __IO uint32_t D11                       : 1;
X    volatile uint32_t D11                       : 1;
N    __IO uint32_t D12                       : 1;
X    volatile uint32_t D12                       : 1;
N    __IO uint32_t D13                       : 1;
X    volatile uint32_t D13                       : 1;
N    __IO uint32_t D14                       : 1;
X    volatile uint32_t D14                       : 1;
N    __IO uint32_t D15                       : 1;
X    volatile uint32_t D15                       : 1;
N    __IO uint32_t D16                       : 1;
X    volatile uint32_t D16                       : 1;
N    __IO uint32_t D17                       : 1;
X    volatile uint32_t D17                       : 1;
N    __IO uint32_t D18                       : 1;
X    volatile uint32_t D18                       : 1;
N    __IO uint32_t D19                       : 1;
X    volatile uint32_t D19                       : 1;
N    __IO uint32_t D20                       : 1;
X    volatile uint32_t D20                       : 1;
N    __IO uint32_t D21                       : 1;
X    volatile uint32_t D21                       : 1;
N    __IO uint32_t D22                       : 1;
X    volatile uint32_t D22                       : 1;
N    __IO uint32_t D23                       : 1;
X    volatile uint32_t D23                       : 1;
N    __IO uint32_t D24                       : 1;
X    volatile uint32_t D24                       : 1;
N    __IO uint32_t D25                       : 1;
X    volatile uint32_t D25                       : 1;
N    __IO uint32_t D26                       : 1;
X    volatile uint32_t D26                       : 1;
N    __IO uint32_t D27                       : 1;
X    volatile uint32_t D27                       : 1;
N    __IO uint32_t D28                       : 1;
X    volatile uint32_t D28                       : 1;
N    __IO uint32_t D29                       : 1;
X    volatile uint32_t D29                       : 1;
N    __IO uint32_t D30                       : 1;
X    volatile uint32_t D30                       : 1;
N    __IO uint32_t D31                       : 1;
X    volatile uint32_t D31                       : 1;
N} stc_lcd_ram3_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t D0                        : 1;
X    volatile uint32_t D0                        : 1;
N    __IO uint32_t D1                        : 1;
X    volatile uint32_t D1                        : 1;
N    __IO uint32_t D2                        : 1;
X    volatile uint32_t D2                        : 1;
N    __IO uint32_t D3                        : 1;
X    volatile uint32_t D3                        : 1;
N    __IO uint32_t D4                        : 1;
X    volatile uint32_t D4                        : 1;
N    __IO uint32_t D5                        : 1;
X    volatile uint32_t D5                        : 1;
N    __IO uint32_t D6                        : 1;
X    volatile uint32_t D6                        : 1;
N    __IO uint32_t D7                        : 1;
X    volatile uint32_t D7                        : 1;
N    __IO uint32_t D8                        : 1;
X    volatile uint32_t D8                        : 1;
N    __IO uint32_t D9                        : 1;
X    volatile uint32_t D9                        : 1;
N    __IO uint32_t D10                       : 1;
X    volatile uint32_t D10                       : 1;
N    __IO uint32_t D11                       : 1;
X    volatile uint32_t D11                       : 1;
N    __IO uint32_t D12                       : 1;
X    volatile uint32_t D12                       : 1;
N    __IO uint32_t D13                       : 1;
X    volatile uint32_t D13                       : 1;
N    __IO uint32_t D14                       : 1;
X    volatile uint32_t D14                       : 1;
N    __IO uint32_t D15                       : 1;
X    volatile uint32_t D15                       : 1;
N    __IO uint32_t D16                       : 1;
X    volatile uint32_t D16                       : 1;
N    __IO uint32_t D17                       : 1;
X    volatile uint32_t D17                       : 1;
N    __IO uint32_t D18                       : 1;
X    volatile uint32_t D18                       : 1;
N    __IO uint32_t D19                       : 1;
X    volatile uint32_t D19                       : 1;
N    __IO uint32_t D20                       : 1;
X    volatile uint32_t D20                       : 1;
N    __IO uint32_t D21                       : 1;
X    volatile uint32_t D21                       : 1;
N    __IO uint32_t D22                       : 1;
X    volatile uint32_t D22                       : 1;
N    __IO uint32_t D23                       : 1;
X    volatile uint32_t D23                       : 1;
N    __IO uint32_t D24                       : 1;
X    volatile uint32_t D24                       : 1;
N    __IO uint32_t D25                       : 1;
X    volatile uint32_t D25                       : 1;
N    __IO uint32_t D26                       : 1;
X    volatile uint32_t D26                       : 1;
N    __IO uint32_t D27                       : 1;
X    volatile uint32_t D27                       : 1;
N    __IO uint32_t D28                       : 1;
X    volatile uint32_t D28                       : 1;
N    __IO uint32_t D29                       : 1;
X    volatile uint32_t D29                       : 1;
N    __IO uint32_t D30                       : 1;
X    volatile uint32_t D30                       : 1;
N    __IO uint32_t D31                       : 1;
X    volatile uint32_t D31                       : 1;
N} stc_lcd_ram4_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t D0                        : 1;
X    volatile uint32_t D0                        : 1;
N    __IO uint32_t D1                        : 1;
X    volatile uint32_t D1                        : 1;
N    __IO uint32_t D2                        : 1;
X    volatile uint32_t D2                        : 1;
N    __IO uint32_t D3                        : 1;
X    volatile uint32_t D3                        : 1;
N    __IO uint32_t D4                        : 1;
X    volatile uint32_t D4                        : 1;
N    __IO uint32_t D5                        : 1;
X    volatile uint32_t D5                        : 1;
N    __IO uint32_t D6                        : 1;
X    volatile uint32_t D6                        : 1;
N    __IO uint32_t D7                        : 1;
X    volatile uint32_t D7                        : 1;
N    __IO uint32_t D8                        : 1;
X    volatile uint32_t D8                        : 1;
N    __IO uint32_t D9                        : 1;
X    volatile uint32_t D9                        : 1;
N    __IO uint32_t D10                       : 1;
X    volatile uint32_t D10                       : 1;
N    __IO uint32_t D11                       : 1;
X    volatile uint32_t D11                       : 1;
N    __IO uint32_t D12                       : 1;
X    volatile uint32_t D12                       : 1;
N    __IO uint32_t D13                       : 1;
X    volatile uint32_t D13                       : 1;
N    __IO uint32_t D14                       : 1;
X    volatile uint32_t D14                       : 1;
N    __IO uint32_t D15                       : 1;
X    volatile uint32_t D15                       : 1;
N    __IO uint32_t D16                       : 1;
X    volatile uint32_t D16                       : 1;
N    __IO uint32_t D17                       : 1;
X    volatile uint32_t D17                       : 1;
N    __IO uint32_t D18                       : 1;
X    volatile uint32_t D18                       : 1;
N    __IO uint32_t D19                       : 1;
X    volatile uint32_t D19                       : 1;
N    __IO uint32_t D20                       : 1;
X    volatile uint32_t D20                       : 1;
N    __IO uint32_t D21                       : 1;
X    volatile uint32_t D21                       : 1;
N    __IO uint32_t D22                       : 1;
X    volatile uint32_t D22                       : 1;
N    __IO uint32_t D23                       : 1;
X    volatile uint32_t D23                       : 1;
N    __IO uint32_t D24                       : 1;
X    volatile uint32_t D24                       : 1;
N    __IO uint32_t D25                       : 1;
X    volatile uint32_t D25                       : 1;
N    __IO uint32_t D26                       : 1;
X    volatile uint32_t D26                       : 1;
N    __IO uint32_t D27                       : 1;
X    volatile uint32_t D27                       : 1;
N    __IO uint32_t D28                       : 1;
X    volatile uint32_t D28                       : 1;
N    __IO uint32_t D29                       : 1;
X    volatile uint32_t D29                       : 1;
N    __IO uint32_t D30                       : 1;
X    volatile uint32_t D30                       : 1;
N    __IO uint32_t D31                       : 1;
X    volatile uint32_t D31                       : 1;
N} stc_lcd_ram5_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t D0                        : 1;
X    volatile uint32_t D0                        : 1;
N    __IO uint32_t D1                        : 1;
X    volatile uint32_t D1                        : 1;
N    __IO uint32_t D2                        : 1;
X    volatile uint32_t D2                        : 1;
N    __IO uint32_t D3                        : 1;
X    volatile uint32_t D3                        : 1;
N    __IO uint32_t D4                        : 1;
X    volatile uint32_t D4                        : 1;
N    __IO uint32_t D5                        : 1;
X    volatile uint32_t D5                        : 1;
N    __IO uint32_t D6                        : 1;
X    volatile uint32_t D6                        : 1;
N    __IO uint32_t D7                        : 1;
X    volatile uint32_t D7                        : 1;
N    __IO uint32_t D8                        : 1;
X    volatile uint32_t D8                        : 1;
N    __IO uint32_t D9                        : 1;
X    volatile uint32_t D9                        : 1;
N    __IO uint32_t D10                       : 1;
X    volatile uint32_t D10                       : 1;
N    __IO uint32_t D11                       : 1;
X    volatile uint32_t D11                       : 1;
N    __IO uint32_t D12                       : 1;
X    volatile uint32_t D12                       : 1;
N    __IO uint32_t D13                       : 1;
X    volatile uint32_t D13                       : 1;
N    __IO uint32_t D14                       : 1;
X    volatile uint32_t D14                       : 1;
N    __IO uint32_t D15                       : 1;
X    volatile uint32_t D15                       : 1;
N    __IO uint32_t D16                       : 1;
X    volatile uint32_t D16                       : 1;
N    __IO uint32_t D17                       : 1;
X    volatile uint32_t D17                       : 1;
N    __IO uint32_t D18                       : 1;
X    volatile uint32_t D18                       : 1;
N    __IO uint32_t D19                       : 1;
X    volatile uint32_t D19                       : 1;
N    __IO uint32_t D20                       : 1;
X    volatile uint32_t D20                       : 1;
N    __IO uint32_t D21                       : 1;
X    volatile uint32_t D21                       : 1;
N    __IO uint32_t D22                       : 1;
X    volatile uint32_t D22                       : 1;
N    __IO uint32_t D23                       : 1;
X    volatile uint32_t D23                       : 1;
N    __IO uint32_t D24                       : 1;
X    volatile uint32_t D24                       : 1;
N    __IO uint32_t D25                       : 1;
X    volatile uint32_t D25                       : 1;
N    __IO uint32_t D26                       : 1;
X    volatile uint32_t D26                       : 1;
N    __IO uint32_t D27                       : 1;
X    volatile uint32_t D27                       : 1;
N    __IO uint32_t D28                       : 1;
X    volatile uint32_t D28                       : 1;
N    __IO uint32_t D29                       : 1;
X    volatile uint32_t D29                       : 1;
N    __IO uint32_t D30                       : 1;
X    volatile uint32_t D30                       : 1;
N    __IO uint32_t D31                       : 1;
X    volatile uint32_t D31                       : 1;
N} stc_lcd_ram6_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t D0                        : 1;
X    volatile uint32_t D0                        : 1;
N    __IO uint32_t D1                        : 1;
X    volatile uint32_t D1                        : 1;
N    __IO uint32_t D2                        : 1;
X    volatile uint32_t D2                        : 1;
N    __IO uint32_t D3                        : 1;
X    volatile uint32_t D3                        : 1;
N    __IO uint32_t D4                        : 1;
X    volatile uint32_t D4                        : 1;
N    __IO uint32_t D5                        : 1;
X    volatile uint32_t D5                        : 1;
N    __IO uint32_t D6                        : 1;
X    volatile uint32_t D6                        : 1;
N    __IO uint32_t D7                        : 1;
X    volatile uint32_t D7                        : 1;
N    __IO uint32_t D8                        : 1;
X    volatile uint32_t D8                        : 1;
N    __IO uint32_t D9                        : 1;
X    volatile uint32_t D9                        : 1;
N    __IO uint32_t D10                       : 1;
X    volatile uint32_t D10                       : 1;
N    __IO uint32_t D11                       : 1;
X    volatile uint32_t D11                       : 1;
N    __IO uint32_t D12                       : 1;
X    volatile uint32_t D12                       : 1;
N    __IO uint32_t D13                       : 1;
X    volatile uint32_t D13                       : 1;
N    __IO uint32_t D14                       : 1;
X    volatile uint32_t D14                       : 1;
N    __IO uint32_t D15                       : 1;
X    volatile uint32_t D15                       : 1;
N    __IO uint32_t D16                       : 1;
X    volatile uint32_t D16                       : 1;
N    __IO uint32_t D17                       : 1;
X    volatile uint32_t D17                       : 1;
N    __IO uint32_t D18                       : 1;
X    volatile uint32_t D18                       : 1;
N    __IO uint32_t D19                       : 1;
X    volatile uint32_t D19                       : 1;
N    __IO uint32_t D20                       : 1;
X    volatile uint32_t D20                       : 1;
N    __IO uint32_t D21                       : 1;
X    volatile uint32_t D21                       : 1;
N    __IO uint32_t D22                       : 1;
X    volatile uint32_t D22                       : 1;
N    __IO uint32_t D23                       : 1;
X    volatile uint32_t D23                       : 1;
N    __IO uint32_t D24                       : 1;
X    volatile uint32_t D24                       : 1;
N    __IO uint32_t D25                       : 1;
X    volatile uint32_t D25                       : 1;
N    __IO uint32_t D26                       : 1;
X    volatile uint32_t D26                       : 1;
N    __IO uint32_t D27                       : 1;
X    volatile uint32_t D27                       : 1;
N    __IO uint32_t D28                       : 1;
X    volatile uint32_t D28                       : 1;
N    __IO uint32_t D29                       : 1;
X    volatile uint32_t D29                       : 1;
N    __IO uint32_t D30                       : 1;
X    volatile uint32_t D30                       : 1;
N    __IO uint32_t D31                       : 1;
X    volatile uint32_t D31                       : 1;
N} stc_lcd_ram7_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t D0                        : 1;
X    volatile uint32_t D0                        : 1;
N    __IO uint32_t D1                        : 1;
X    volatile uint32_t D1                        : 1;
N    __IO uint32_t D2                        : 1;
X    volatile uint32_t D2                        : 1;
N    __IO uint32_t D3                        : 1;
X    volatile uint32_t D3                        : 1;
N    __IO uint32_t D4                        : 1;
X    volatile uint32_t D4                        : 1;
N    __IO uint32_t D5                        : 1;
X    volatile uint32_t D5                        : 1;
N    __IO uint32_t D6                        : 1;
X    volatile uint32_t D6                        : 1;
N    __IO uint32_t D7                        : 1;
X    volatile uint32_t D7                        : 1;
N} stc_lcd_ram8_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t D0                        : 1;
X    volatile uint32_t D0                        : 1;
N    __IO uint32_t D1                        : 1;
X    volatile uint32_t D1                        : 1;
N    __IO uint32_t D2                        : 1;
X    volatile uint32_t D2                        : 1;
N    __IO uint32_t D3                        : 1;
X    volatile uint32_t D3                        : 1;
N    __IO uint32_t D4                        : 1;
X    volatile uint32_t D4                        : 1;
N    __IO uint32_t D5                        : 1;
X    volatile uint32_t D5                        : 1;
N    __IO uint32_t D6                        : 1;
X    volatile uint32_t D6                        : 1;
N    __IO uint32_t D7                        : 1;
X    volatile uint32_t D7                        : 1;
N} stc_lcd_ram9_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t D0                        : 1;
X    volatile uint32_t D0                        : 1;
N    __IO uint32_t D1                        : 1;
X    volatile uint32_t D1                        : 1;
N    __IO uint32_t D2                        : 1;
X    volatile uint32_t D2                        : 1;
N    __IO uint32_t D3                        : 1;
X    volatile uint32_t D3                        : 1;
N    __IO uint32_t D4                        : 1;
X    volatile uint32_t D4                        : 1;
N    __IO uint32_t D5                        : 1;
X    volatile uint32_t D5                        : 1;
N    __IO uint32_t D6                        : 1;
X    volatile uint32_t D6                        : 1;
N    __IO uint32_t D7                        : 1;
X    volatile uint32_t D7                        : 1;
N} stc_lcd_rama_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t D0                        : 1;
X    volatile uint32_t D0                        : 1;
N    __IO uint32_t D1                        : 1;
X    volatile uint32_t D1                        : 1;
N    __IO uint32_t D2                        : 1;
X    volatile uint32_t D2                        : 1;
N    __IO uint32_t D3                        : 1;
X    volatile uint32_t D3                        : 1;
N    __IO uint32_t D4                        : 1;
X    volatile uint32_t D4                        : 1;
N    __IO uint32_t D5                        : 1;
X    volatile uint32_t D5                        : 1;
N    __IO uint32_t D6                        : 1;
X    volatile uint32_t D6                        : 1;
N    __IO uint32_t D7                        : 1;
X    volatile uint32_t D7                        : 1;
N} stc_lcd_ramb_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t D0                        : 1;
X    volatile uint32_t D0                        : 1;
N    __IO uint32_t D1                        : 1;
X    volatile uint32_t D1                        : 1;
N    __IO uint32_t D2                        : 1;
X    volatile uint32_t D2                        : 1;
N    __IO uint32_t D3                        : 1;
X    volatile uint32_t D3                        : 1;
N    __IO uint32_t D4                        : 1;
X    volatile uint32_t D4                        : 1;
N    __IO uint32_t D5                        : 1;
X    volatile uint32_t D5                        : 1;
N    __IO uint32_t D6                        : 1;
X    volatile uint32_t D6                        : 1;
N    __IO uint32_t D7                        : 1;
X    volatile uint32_t D7                        : 1;
N} stc_lcd_ramc_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t D0                        : 1;
X    volatile uint32_t D0                        : 1;
N    __IO uint32_t D1                        : 1;
X    volatile uint32_t D1                        : 1;
N    __IO uint32_t D2                        : 1;
X    volatile uint32_t D2                        : 1;
N    __IO uint32_t D3                        : 1;
X    volatile uint32_t D3                        : 1;
N    __IO uint32_t D4                        : 1;
X    volatile uint32_t D4                        : 1;
N    __IO uint32_t D5                        : 1;
X    volatile uint32_t D5                        : 1;
N    __IO uint32_t D6                        : 1;
X    volatile uint32_t D6                        : 1;
N    __IO uint32_t D7                        : 1;
X    volatile uint32_t D7                        : 1;
N} stc_lcd_ramd_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t D0                        : 1;
X    volatile uint32_t D0                        : 1;
N    __IO uint32_t D1                        : 1;
X    volatile uint32_t D1                        : 1;
N    __IO uint32_t D2                        : 1;
X    volatile uint32_t D2                        : 1;
N    __IO uint32_t D3                        : 1;
X    volatile uint32_t D3                        : 1;
N    __IO uint32_t D4                        : 1;
X    volatile uint32_t D4                        : 1;
N    __IO uint32_t D5                        : 1;
X    volatile uint32_t D5                        : 1;
N    __IO uint32_t D6                        : 1;
X    volatile uint32_t D6                        : 1;
N    __IO uint32_t D7                        : 1;
X    volatile uint32_t D7                        : 1;
N} stc_lcd_rame_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t D0                        : 1;
X    volatile uint32_t D0                        : 1;
N    __IO uint32_t D1                        : 1;
X    volatile uint32_t D1                        : 1;
N    __IO uint32_t D2                        : 1;
X    volatile uint32_t D2                        : 1;
N    __IO uint32_t D3                        : 1;
X    volatile uint32_t D3                        : 1;
N    __IO uint32_t D4                        : 1;
X    volatile uint32_t D4                        : 1;
N    __IO uint32_t D5                        : 1;
X    volatile uint32_t D5                        : 1;
N    __IO uint32_t D6                        : 1;
X    volatile uint32_t D6                        : 1;
N    __IO uint32_t D7                        : 1;
X    volatile uint32_t D7                        : 1;
N} stc_lcd_ramf_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CNT                       :16;
X    volatile uint32_t CNT                       :16;
N} stc_lptimer_cnt_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t ARR                       :16;
X    volatile uint32_t ARR                       :16;
N} stc_lptimer_arr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t TR                        : 1;
X    volatile uint32_t TR                        : 1;
N    __IO uint32_t MD                        : 1;
X    volatile uint32_t MD                        : 1;
N    __IO uint32_t CT                        : 1;
X    volatile uint32_t CT                        : 1;
N    __IO uint32_t TOG_EN                    : 1;
X    volatile uint32_t TOG_EN                    : 1;
N    __IO uint32_t TCK_SEL                   : 2;
X    volatile uint32_t TCK_SEL                   : 2;
N    uint32_t RESERVED6                      : 1;
N    __IO uint32_t WT_FLAG                   : 1;
X    volatile uint32_t WT_FLAG                   : 1;
N    __IO uint32_t GATE                      : 1;
X    volatile uint32_t GATE                      : 1;
N    __IO uint32_t GATE_P                    : 1;
X    volatile uint32_t GATE_P                    : 1;
N    __IO uint32_t IE                        : 1;
X    volatile uint32_t IE                        : 1;
N} stc_lptimer_cr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t TF                        : 1;
X    volatile uint32_t TF                        : 1;
N} stc_lptimer_ifr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t TFC                       : 1;
X    volatile uint32_t TFC                       : 1;
N} stc_lptimer_iclr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t DATA                      : 8;
X    volatile uint32_t DATA                      : 8;
N    __IO uint32_t DATA8                     : 1;
X    volatile uint32_t DATA8                     : 1;
N} stc_lpuart_sbuf_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t RCIE                      : 1;
X    volatile uint32_t RCIE                      : 1;
N    __IO uint32_t TCIE                      : 1;
X    volatile uint32_t TCIE                      : 1;
N    __IO uint32_t B8CONT                    : 2;
X    volatile uint32_t B8CONT                    : 2;
N    __IO uint32_t REN                       : 1;
X    volatile uint32_t REN                       : 1;
N    __IO uint32_t ADRDET                    : 1;
X    volatile uint32_t ADRDET                    : 1;
N    __IO uint32_t SM                        : 2;
X    volatile uint32_t SM                        : 2;
N    __IO uint32_t TXEIE                     : 1;
X    volatile uint32_t TXEIE                     : 1;
N    __IO uint32_t OVER                      : 2;
X    volatile uint32_t OVER                      : 2;
N    __IO uint32_t SCLKSEL                   : 2;
X    volatile uint32_t SCLKSEL                   : 2;
N    __IO uint32_t PEIE                      : 1;
X    volatile uint32_t PEIE                      : 1;
N    __IO uint32_t STOPBIT                   : 2;
X    volatile uint32_t STOPBIT                   : 2;
N    __IO uint32_t DMARXEN                   : 1;
X    volatile uint32_t DMARXEN                   : 1;
N    __IO uint32_t DMATXEN                   : 1;
X    volatile uint32_t DMATXEN                   : 1;
N    __IO uint32_t RTSEN                     : 1;
X    volatile uint32_t RTSEN                     : 1;
N    __IO uint32_t CTSEN                     : 1;
X    volatile uint32_t CTSEN                     : 1;
N    __IO uint32_t CTSIE                     : 1;
X    volatile uint32_t CTSIE                     : 1;
N    __IO uint32_t FEIE                      : 1;
X    volatile uint32_t FEIE                      : 1;
N} stc_lpuart_scon_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SADDR                     : 8;
X    volatile uint32_t SADDR                     : 8;
N} stc_lpuart_saddr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SADEN                     : 8;
X    volatile uint32_t SADEN                     : 8;
N} stc_lpuart_saden_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t RC                        : 1;
X    volatile uint32_t RC                        : 1;
N    __IO uint32_t TC                        : 1;
X    volatile uint32_t TC                        : 1;
N    __IO uint32_t FE                        : 1;
X    volatile uint32_t FE                        : 1;
N    __IO uint32_t TXE                       : 1;
X    volatile uint32_t TXE                       : 1;
N    __IO uint32_t PE                        : 1;
X    volatile uint32_t PE                        : 1;
N    __IO uint32_t CTSIF                     : 1;
X    volatile uint32_t CTSIF                     : 1;
N    __IO uint32_t CTS                       : 1;
X    volatile uint32_t CTS                       : 1;
N} stc_lpuart_isr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t RCCF                      : 1;
X    volatile uint32_t RCCF                      : 1;
N    __IO uint32_t TCCF                      : 1;
X    volatile uint32_t TCCF                      : 1;
N    __IO uint32_t FECF                      : 1;
X    volatile uint32_t FECF                      : 1;
N    uint32_t RESERVED3                      : 1;
N    __IO uint32_t PECF                      : 1;
X    volatile uint32_t PECF                      : 1;
N    __IO uint32_t CTSIFCF                   : 1;
X    volatile uint32_t CTSIFCF                   : 1;
N} stc_lpuart_icr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SCNT                      :16;
X    volatile uint32_t SCNT                      :16;
N} stc_lpuart_scnt_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t LVDEN                     : 1;
X    volatile uint32_t LVDEN                     : 1;
N    __IO uint32_t ACT                       : 1;
X    volatile uint32_t ACT                       : 1;
N    __IO uint32_t SOURCE_SEL                : 2;
X    volatile uint32_t SOURCE_SEL                : 2;
N    __IO uint32_t VTDS                      : 4;
X    volatile uint32_t VTDS                      : 4;
N    __IO uint32_t FLTEN                     : 1;
X    volatile uint32_t FLTEN                     : 1;
N    __IO uint32_t DEBOUNCE_TIME             : 3;
X    volatile uint32_t DEBOUNCE_TIME             : 3;
N    __IO uint32_t FTEN                      : 1;
X    volatile uint32_t FTEN                      : 1;
N    __IO uint32_t RTEN                      : 1;
X    volatile uint32_t RTEN                      : 1;
N    __IO uint32_t HTEN                      : 1;
X    volatile uint32_t HTEN                      : 1;
N    __IO uint32_t IE                        : 1;
X    volatile uint32_t IE                        : 1;
N} stc_lvd_cr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t INTF                      : 1;
X    volatile uint32_t INTF                      : 1;
N} stc_lvd_ifr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t EN                        : 1;
X    volatile uint32_t EN                        : 1;
N    __IO uint32_t AZEN                      : 1;
X    volatile uint32_t AZEN                      : 1;
N    __IO uint32_t MODE                      : 1;
X    volatile uint32_t MODE                      : 1;
N    __IO uint32_t UBUFSEL                   : 1;
X    volatile uint32_t UBUFSEL                   : 1;
N    __IO uint32_t RESSEL                    : 1;
X    volatile uint32_t RESSEL                    : 1;
N    __IO uint32_t BIASSEL                   : 3;
X    volatile uint32_t BIASSEL                   : 3;
N    __IO uint32_t NEGSEL                    : 2;
X    volatile uint32_t NEGSEL                    : 2;
N    __IO uint32_t POSSEL                    : 2;
X    volatile uint32_t POSSEL                    : 2;
N    __IO uint32_t PGAGAIN                   : 3;
X    volatile uint32_t PGAGAIN                   : 3;
N    __IO uint32_t POEN                      : 1;
X    volatile uint32_t POEN                      : 1;
N    __IO uint32_t RESINMUX                  : 2;
X    volatile uint32_t RESINMUX                  : 2;
N} stc_opa_cr0_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t EN                        : 1;
X    volatile uint32_t EN                        : 1;
N    __IO uint32_t AZEN                      : 1;
X    volatile uint32_t AZEN                      : 1;
N    __IO uint32_t MODE                      : 1;
X    volatile uint32_t MODE                      : 1;
N    __IO uint32_t UBUFSEL                   : 1;
X    volatile uint32_t UBUFSEL                   : 1;
N    __IO uint32_t RESSEL                    : 1;
X    volatile uint32_t RESSEL                    : 1;
N    __IO uint32_t BIASSEL                   : 3;
X    volatile uint32_t BIASSEL                   : 3;
N    __IO uint32_t NEGSEL                    : 2;
X    volatile uint32_t NEGSEL                    : 2;
N    __IO uint32_t POSSEL                    : 2;
X    volatile uint32_t POSSEL                    : 2;
N    __IO uint32_t PGAGAIN                   : 3;
X    volatile uint32_t PGAGAIN                   : 3;
N    __IO uint32_t POEN                      : 1;
X    volatile uint32_t POEN                      : 1;
N    __IO uint32_t RESINMUX                  : 2;
X    volatile uint32_t RESINMUX                  : 2;
N} stc_opa_cr1_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t EN                        : 1;
X    volatile uint32_t EN                        : 1;
N    __IO uint32_t AZEN                      : 1;
X    volatile uint32_t AZEN                      : 1;
N    __IO uint32_t MODE                      : 1;
X    volatile uint32_t MODE                      : 1;
N    __IO uint32_t UBUFSEL                   : 1;
X    volatile uint32_t UBUFSEL                   : 1;
N    __IO uint32_t RESSEL                    : 1;
X    volatile uint32_t RESSEL                    : 1;
N    __IO uint32_t BIASSEL                   : 3;
X    volatile uint32_t BIASSEL                   : 3;
N    __IO uint32_t NEGSEL                    : 2;
X    volatile uint32_t NEGSEL                    : 2;
N    __IO uint32_t POSSEL                    : 2;
X    volatile uint32_t POSSEL                    : 2;
N    __IO uint32_t PGAGAIN                   : 3;
X    volatile uint32_t PGAGAIN                   : 3;
N    __IO uint32_t POEN                      : 1;
X    volatile uint32_t POEN                      : 1;
N    __IO uint32_t RESINMUX                  : 2;
X    volatile uint32_t RESINMUX                  : 2;
N} stc_opa_cr2_field_t;
N
Ntypedef struct
N{
N    __IO uint8_t ADCTR_EN                   : 1;
X    volatile uint8_t ADCTR_EN                   : 1;
N    __IO uint8_t TRIGGER                    : 1;
X    volatile uint8_t TRIGGER                    : 1;
N    __IO uint8_t AZ_PULSE                   : 1;
X    volatile uint8_t AZ_PULSE                   : 1;
N    __IO uint8_t CLK_SW_SET                 : 1;
X    volatile uint8_t CLK_SW_SET                 : 1;
N    __IO uint8_t CLK_SEL                    : 4;
X    volatile uint8_t CLK_SEL                    : 4;
N} stc_opa_cr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CCF0                      : 1;
X    volatile uint32_t CCF0                      : 1;
N    __IO uint32_t CCF1                      : 1;
X    volatile uint32_t CCF1                      : 1;
N    __IO uint32_t CCF2                      : 1;
X    volatile uint32_t CCF2                      : 1;
N    __IO uint32_t CCF3                      : 1;
X    volatile uint32_t CCF3                      : 1;
N    __IO uint32_t CCF4                      : 1;
X    volatile uint32_t CCF4                      : 1;
N    uint32_t RESERVED5                      : 1;
N    __IO uint32_t CR                        : 1;
X    volatile uint32_t CR                        : 1;
N    __IO uint32_t CF                        : 1;
X    volatile uint32_t CF                        : 1;
N} stc_pca_ccon_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CFIE                      : 1;
X    volatile uint32_t CFIE                      : 1;
N    __IO uint32_t CPS                       : 3;
X    volatile uint32_t CPS                       : 3;
N    uint32_t RESERVED4                      : 2;
N    __IO uint32_t WDTE                      : 1;
X    volatile uint32_t WDTE                      : 1;
N    __IO uint32_t CIDL                      : 1;
X    volatile uint32_t CIDL                      : 1;
N} stc_pca_cmod_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CNT                       :16;
X    volatile uint32_t CNT                       :16;
N} stc_pca_cnt_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CCF0                      : 1;
X    volatile uint32_t CCF0                      : 1;
N    __IO uint32_t CCF1                      : 1;
X    volatile uint32_t CCF1                      : 1;
N    __IO uint32_t CCF2                      : 1;
X    volatile uint32_t CCF2                      : 1;
N    __IO uint32_t CCF3                      : 1;
X    volatile uint32_t CCF3                      : 1;
N    __IO uint32_t CCF4                      : 1;
X    volatile uint32_t CCF4                      : 1;
N    uint32_t RESERVED5                      : 2;
N    __IO uint32_t CF                        : 1;
X    volatile uint32_t CF                        : 1;
N} stc_pca_iclr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CCIE                      : 1;
X    volatile uint32_t CCIE                      : 1;
N    __IO uint32_t PWM                       : 1;
X    volatile uint32_t PWM                       : 1;
N    __IO uint32_t TOG                       : 1;
X    volatile uint32_t TOG                       : 1;
N    __IO uint32_t MAT                       : 1;
X    volatile uint32_t MAT                       : 1;
N    __IO uint32_t CAPN                      : 1;
X    volatile uint32_t CAPN                      : 1;
N    __IO uint32_t CAPP                      : 1;
X    volatile uint32_t CAPP                      : 1;
N    __IO uint32_t ECOM                      : 1;
X    volatile uint32_t ECOM                      : 1;
N} stc_pca_ccapm0_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CCIE                      : 1;
X    volatile uint32_t CCIE                      : 1;
N    __IO uint32_t PWM                       : 1;
X    volatile uint32_t PWM                       : 1;
N    __IO uint32_t TOG                       : 1;
X    volatile uint32_t TOG                       : 1;
N    __IO uint32_t MAT                       : 1;
X    volatile uint32_t MAT                       : 1;
N    __IO uint32_t CAPN                      : 1;
X    volatile uint32_t CAPN                      : 1;
N    __IO uint32_t CAPP                      : 1;
X    volatile uint32_t CAPP                      : 1;
N    __IO uint32_t ECOM                      : 1;
X    volatile uint32_t ECOM                      : 1;
N} stc_pca_ccapm1_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CCIE                      : 1;
X    volatile uint32_t CCIE                      : 1;
N    __IO uint32_t PWM                       : 1;
X    volatile uint32_t PWM                       : 1;
N    __IO uint32_t TOG                       : 1;
X    volatile uint32_t TOG                       : 1;
N    __IO uint32_t MAT                       : 1;
X    volatile uint32_t MAT                       : 1;
N    __IO uint32_t CAPN                      : 1;
X    volatile uint32_t CAPN                      : 1;
N    __IO uint32_t CAPP                      : 1;
X    volatile uint32_t CAPP                      : 1;
N    __IO uint32_t ECOM                      : 1;
X    volatile uint32_t ECOM                      : 1;
N} stc_pca_ccapm2_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CCIE                      : 1;
X    volatile uint32_t CCIE                      : 1;
N    __IO uint32_t PWM                       : 1;
X    volatile uint32_t PWM                       : 1;
N    __IO uint32_t TOG                       : 1;
X    volatile uint32_t TOG                       : 1;
N    __IO uint32_t MAT                       : 1;
X    volatile uint32_t MAT                       : 1;
N    __IO uint32_t CAPN                      : 1;
X    volatile uint32_t CAPN                      : 1;
N    __IO uint32_t CAPP                      : 1;
X    volatile uint32_t CAPP                      : 1;
N    __IO uint32_t ECOM                      : 1;
X    volatile uint32_t ECOM                      : 1;
N} stc_pca_ccapm3_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CCIE                      : 1;
X    volatile uint32_t CCIE                      : 1;
N    __IO uint32_t PWM                       : 1;
X    volatile uint32_t PWM                       : 1;
N    __IO uint32_t TOG                       : 1;
X    volatile uint32_t TOG                       : 1;
N    __IO uint32_t MAT                       : 1;
X    volatile uint32_t MAT                       : 1;
N    __IO uint32_t CAPN                      : 1;
X    volatile uint32_t CAPN                      : 1;
N    __IO uint32_t CAPP                      : 1;
X    volatile uint32_t CAPP                      : 1;
N    __IO uint32_t ECOM                      : 1;
X    volatile uint32_t ECOM                      : 1;
N} stc_pca_ccapm4_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CCAP0                     : 8;
X    volatile uint32_t CCAP0                     : 8;
N} stc_pca_ccap0h_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CCAP0                     : 8;
X    volatile uint32_t CCAP0                     : 8;
N} stc_pca_ccap0l_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CCAP1                     : 8;
X    volatile uint32_t CCAP1                     : 8;
N} stc_pca_ccap1h_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CCAP1                     : 8;
X    volatile uint32_t CCAP1                     : 8;
N} stc_pca_ccap1l_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CCAP2                     : 8;
X    volatile uint32_t CCAP2                     : 8;
N} stc_pca_ccap2h_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CCAP2                     : 8;
X    volatile uint32_t CCAP2                     : 8;
N} stc_pca_ccap2l_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CCAP3                     : 8;
X    volatile uint32_t CCAP3                     : 8;
N} stc_pca_ccap3h_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CCAP3                     : 8;
X    volatile uint32_t CCAP3                     : 8;
N} stc_pca_ccap3l_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CCAP4                     : 8;
X    volatile uint32_t CCAP4                     : 8;
N} stc_pca_ccap4h_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CCAP4                     : 8;
X    volatile uint32_t CCAP4                     : 8;
N} stc_pca_ccap4l_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CCAPO0                    : 1;
X    volatile uint32_t CCAPO0                    : 1;
N    __IO uint32_t CCAPO1                    : 1;
X    volatile uint32_t CCAPO1                    : 1;
N    __IO uint32_t CCAPO2                    : 1;
X    volatile uint32_t CCAPO2                    : 1;
N    __IO uint32_t CCAPO3                    : 1;
X    volatile uint32_t CCAPO3                    : 1;
N    __IO uint32_t CCAPO4                    : 1;
X    volatile uint32_t CCAPO4                    : 1;
N} stc_pca_ccapo_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CCAP0                     :16;
X    volatile uint32_t CCAP0                     :16;
N} stc_pca_ccap0_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CCAP1                     :16;
X    volatile uint32_t CCAP1                     :16;
N} stc_pca_ccap1_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CCAP2                     :16;
X    volatile uint32_t CCAP2                     :16;
N} stc_pca_ccap2_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CCAP3                     :16;
X    volatile uint32_t CCAP3                     :16;
N} stc_pca_ccap3_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CCAP4                     :16;
X    volatile uint32_t CCAP4                     :16;
N} stc_pca_ccap4_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CARR                      :16;
X    volatile uint32_t CARR                      :16;
N} stc_pca_carr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t EPWM                      : 1;
X    volatile uint32_t EPWM                      : 1;
N} stc_pca_epwm_field_t;
N
Ntypedef struct
N{
N    __IO uint8_t RUN                        : 1;
X    volatile uint8_t RUN                        : 1;
N} stc_pcnt_run_field_t;
N
Ntypedef struct
N{
N    __IO uint8_t MODE                       : 2;
X    volatile uint8_t MODE                       : 2;
N    __IO uint8_t CLKSEL                     : 2;
X    volatile uint8_t CLKSEL                     : 2;
N    __IO uint8_t DIR                        : 1;
X    volatile uint8_t DIR                        : 1;
N    __IO uint8_t S0P                        : 1;
X    volatile uint8_t S0P                        : 1;
N    __IO uint8_t S1P                        : 1;
X    volatile uint8_t S1P                        : 1;
N} stc_pcnt_cr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CLKDIV                    :13;
X    volatile uint32_t CLKDIV                    :13;
N    __IO uint32_t DEBTOP                    : 3;
X    volatile uint32_t DEBTOP                    : 3;
N    __IO uint32_t EN                        : 1;
X    volatile uint32_t EN                        : 1;
N} stc_pcnt_flt_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t TH                        :12;
X    volatile uint32_t TH                        :12;
N    uint32_t RESERVED12                     : 4;
N    __IO uint32_t EN                        : 1;
X    volatile uint32_t EN                        : 1;
N} stc_pcnt_tocr_field_t;
N
Ntypedef struct
N{
N    __IO uint8_t T2C                        : 1;
X    volatile uint8_t T2C                        : 1;
N    __IO uint8_t B2T                        : 1;
X    volatile uint8_t B2T                        : 1;
N    __IO uint8_t B2C                        : 1;
X    volatile uint8_t B2C                        : 1;
N} stc_pcnt_cmd_field_t;
N
Ntypedef struct
N{
N    __IO uint8_t DIR                        : 1;
X    volatile uint8_t DIR                        : 1;
N} stc_pcnt_sr1_field_t;
N
Ntypedef struct
N{
N    __IO uint16_t CNT                       :16;
X    volatile uint16_t CNT                       :16;
N} stc_pcnt_cnt_field_t;
N
Ntypedef struct
N{
N    __IO uint16_t TOP                       :16;
X    volatile uint16_t TOP                       :16;
N} stc_pcnt_top_field_t;
N
Ntypedef struct
N{
N    __IO uint16_t BUF                       :16;
X    volatile uint16_t BUF                       :16;
N} stc_pcnt_buf_field_t;
N
Ntypedef struct
N{
N    __IO uint8_t UF                         : 1;
X    volatile uint8_t UF                         : 1;
N    __IO uint8_t OV                         : 1;
X    volatile uint8_t OV                         : 1;
N    __IO uint8_t TO                         : 1;
X    volatile uint8_t TO                         : 1;
N    __IO uint8_t DIR                        : 1;
X    volatile uint8_t DIR                        : 1;
N    __IO uint8_t FE                         : 1;
X    volatile uint8_t FE                         : 1;
N    __IO uint8_t BB                         : 1;
X    volatile uint8_t BB                         : 1;
N    __IO uint8_t S0E                        : 1;
X    volatile uint8_t S0E                        : 1;
N    __IO uint8_t S1E                        : 1;
X    volatile uint8_t S1E                        : 1;
N} stc_pcnt_ifr_field_t;
N
Ntypedef struct
N{
N    __IO uint8_t UF                         : 1;
X    volatile uint8_t UF                         : 1;
N    __IO uint8_t OV                         : 1;
X    volatile uint8_t OV                         : 1;
N    __IO uint8_t TO                         : 1;
X    volatile uint8_t TO                         : 1;
N    __IO uint8_t DIR                        : 1;
X    volatile uint8_t DIR                        : 1;
N    __IO uint8_t FE                         : 1;
X    volatile uint8_t FE                         : 1;
N    __IO uint8_t BB                         : 1;
X    volatile uint8_t BB                         : 1;
N    __IO uint8_t S0E                        : 1;
X    volatile uint8_t S0E                        : 1;
N    __IO uint8_t S1E                        : 1;
X    volatile uint8_t S1E                        : 1;
N} stc_pcnt_icr_field_t;
N
Ntypedef struct
N{
N    __IO uint8_t UF                         : 1;
X    volatile uint8_t UF                         : 1;
N    __IO uint8_t OV                         : 1;
X    volatile uint8_t OV                         : 1;
N    __IO uint8_t TO                         : 1;
X    volatile uint8_t TO                         : 1;
N    __IO uint8_t DIR                        : 1;
X    volatile uint8_t DIR                        : 1;
N    __IO uint8_t FE                         : 1;
X    volatile uint8_t FE                         : 1;
N    __IO uint8_t BB                         : 1;
X    volatile uint8_t BB                         : 1;
N    __IO uint8_t S0E                        : 1;
X    volatile uint8_t S0E                        : 1;
N    __IO uint8_t S1E                        : 1;
X    volatile uint8_t S1E                        : 1;
N} stc_pcnt_ien_field_t;
N
Ntypedef struct
N{
N    __IO uint8_t T2C                        : 1;
X    volatile uint8_t T2C                        : 1;
N    __IO uint8_t B2T                        : 1;
X    volatile uint8_t B2T                        : 1;
N    __IO uint8_t B2C                        : 1;
X    volatile uint8_t B2C                        : 1;
N} stc_pcnt_sr2_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CHKEN                     : 1;
X    volatile uint32_t CHKEN                     : 1;
N    __IO uint32_t IE                        : 1;
X    volatile uint32_t IE                        : 1;
N} stc_ram_cr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t ERRADDR                   :13;
X    volatile uint32_t ERRADDR                   :13;
N} stc_ram_erraddr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t ERR                       : 1;
X    volatile uint32_t ERR                       : 1;
N} stc_ram_ifr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t ERRCLR                    : 1;
X    volatile uint32_t ERRCLR                    : 1;
N} stc_ram_iclr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t POR5V                     : 1;
X    volatile uint32_t POR5V                     : 1;
N    __IO uint32_t POR15                     : 1;
X    volatile uint32_t POR15                     : 1;
N    __IO uint32_t LVD                       : 1;
X    volatile uint32_t LVD                       : 1;
N    __IO uint32_t WDT                       : 1;
X    volatile uint32_t WDT                       : 1;
N    __IO uint32_t PCA                       : 1;
X    volatile uint32_t PCA                       : 1;
N    __IO uint32_t LOCKUP                    : 1;
X    volatile uint32_t LOCKUP                    : 1;
N    __IO uint32_t SYSREQ                    : 1;
X    volatile uint32_t SYSREQ                    : 1;
N    __IO uint32_t RSTB                      : 1;
X    volatile uint32_t RSTB                      : 1;
N} stc_reset_flag_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t UART0                     : 1;
X    volatile uint32_t UART0                     : 1;
N    __IO uint32_t UART1                     : 1;
X    volatile uint32_t UART1                     : 1;
N    __IO uint32_t LPUART0                   : 1;
X    volatile uint32_t LPUART0                   : 1;
N    __IO uint32_t LPUART1                   : 1;
X    volatile uint32_t LPUART1                   : 1;
N    __IO uint32_t I2C0                      : 1;
X    volatile uint32_t I2C0                      : 1;
N    __IO uint32_t I2C1                      : 1;
X    volatile uint32_t I2C1                      : 1;
N    __IO uint32_t SPI0                      : 1;
X    volatile uint32_t SPI0                      : 1;
N    __IO uint32_t SPI1                      : 1;
X    volatile uint32_t SPI1                      : 1;
N    __IO uint32_t BASETIM                   : 1;
X    volatile uint32_t BASETIM                   : 1;
N    __IO uint32_t LPTIM                     : 1;
X    volatile uint32_t LPTIM                     : 1;
N    __IO uint32_t ADVTIM                    : 1;
X    volatile uint32_t ADVTIM                    : 1;
N    __IO uint32_t TIM3                      : 1;
X    volatile uint32_t TIM3                      : 1;
N    uint32_t RESERVED12                     : 1;
N    __IO uint32_t OPA                       : 1;
X    volatile uint32_t OPA                       : 1;
N    __IO uint32_t PCA                       : 1;
X    volatile uint32_t PCA                       : 1;
N    uint32_t RESERVED15                     : 1;
N    __IO uint32_t ADC                       : 1;
X    volatile uint32_t ADC                       : 1;
N    __IO uint32_t VC                        : 1;
X    volatile uint32_t VC                        : 1;
N    __IO uint32_t RNG                       : 1;
X    volatile uint32_t RNG                       : 1;
N    __IO uint32_t PCNT                      : 1;
X    volatile uint32_t PCNT                      : 1;
N    __IO uint32_t RTC                       : 1;
X    volatile uint32_t RTC                       : 1;
N    __IO uint32_t TRIM                      : 1;
X    volatile uint32_t TRIM                      : 1;
N    __IO uint32_t LCD                       : 1;
X    volatile uint32_t LCD                       : 1;
N    uint32_t RESERVED23                     : 1;
N    __IO uint32_t TICK                      : 1;
X    volatile uint32_t TICK                      : 1;
N    __IO uint32_t SWD                       : 1;
X    volatile uint32_t SWD                       : 1;
N    __IO uint32_t CRC                       : 1;
X    volatile uint32_t CRC                       : 1;
N    __IO uint32_t AES                       : 1;
X    volatile uint32_t AES                       : 1;
N    __IO uint32_t GPIO                      : 1;
X    volatile uint32_t GPIO                      : 1;
N    __IO uint32_t DMA                       : 1;
X    volatile uint32_t DMA                       : 1;
N    __IO uint32_t DIV                       : 1;
X    volatile uint32_t DIV                       : 1;
N} stc_reset_prei_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t RNGCIR_EN                 : 1;
X    volatile uint32_t RNGCIR_EN                 : 1;
N    __IO uint32_t RNG_RUN                   : 1;
X    volatile uint32_t RNG_RUN                   : 1;
N} stc_rng_cr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t LOAD                      : 1;
X    volatile uint32_t LOAD                      : 1;
N    __IO uint32_t FDBK                      : 1;
X    volatile uint32_t FDBK                      : 1;
N    __IO uint32_t CNT                       : 3;
X    volatile uint32_t CNT                       : 3;
N} stc_rng_mode_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t DATA0                     :32;
X    volatile uint32_t DATA0                     :32;
N} stc_rng_data0_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t DATA1                     :32;
X    volatile uint32_t DATA1                     :32;
N} stc_rng_data1_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PRDS                      : 3;
X    volatile uint32_t PRDS                      : 3;
N    __IO uint32_t AMPM                      : 1;
X    volatile uint32_t AMPM                      : 1;
N    uint32_t RESERVED4                      : 1;
N    __IO uint32_t HZ1OE                     : 1;
X    volatile uint32_t HZ1OE                     : 1;
N    __IO uint32_t HZ1SEL                    : 1;
X    volatile uint32_t HZ1SEL                    : 1;
N    __IO uint32_t START                     : 1;
X    volatile uint32_t START                     : 1;
N    __IO uint32_t PRDX                      : 6;
X    volatile uint32_t PRDX                      : 6;
N    __IO uint32_t PRDSEL                    : 1;
X    volatile uint32_t PRDSEL                    : 1;
N} stc_rtc_cr0_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t WAIT                      : 1;
X    volatile uint32_t WAIT                      : 1;
N    __IO uint32_t WAITF                     : 1;
X    volatile uint32_t WAITF                     : 1;
N    uint32_t RESERVED2                      : 1;
N    __IO uint32_t PRDF                      : 1;
X    volatile uint32_t PRDF                      : 1;
N    __IO uint32_t ALMF                      : 1;
X    volatile uint32_t ALMF                      : 1;
N    uint32_t RESERVED5                      : 1;
N    __IO uint32_t ALMIE                     : 1;
X    volatile uint32_t ALMIE                     : 1;
N    __IO uint32_t ALMEN                     : 1;
X    volatile uint32_t ALMEN                     : 1;
N    __IO uint32_t CKSEL                     : 3;
X    volatile uint32_t CKSEL                     : 3;
N} stc_rtc_cr1_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SECL                      : 4;
X    volatile uint32_t SECL                      : 4;
N    __IO uint32_t SECH                      : 3;
X    volatile uint32_t SECH                      : 3;
N} stc_rtc_sec_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t MINL                      : 4;
X    volatile uint32_t MINL                      : 4;
N    __IO uint32_t MINH                      : 3;
X    volatile uint32_t MINH                      : 3;
N} stc_rtc_min_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t HOURL                     : 4;
X    volatile uint32_t HOURL                     : 4;
N    __IO uint32_t HOURH                     : 2;
X    volatile uint32_t HOURH                     : 2;
N} stc_rtc_hour_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t WEEK                      : 3;
X    volatile uint32_t WEEK                      : 3;
N} stc_rtc_week_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t DAYL                      : 4;
X    volatile uint32_t DAYL                      : 4;
N    __IO uint32_t DAYH                      : 2;
X    volatile uint32_t DAYH                      : 2;
N} stc_rtc_day_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t MON                       : 5;
X    volatile uint32_t MON                       : 5;
N} stc_rtc_mon_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t YEARL                     : 4;
X    volatile uint32_t YEARL                     : 4;
N    __IO uint32_t YEARH                     : 4;
X    volatile uint32_t YEARH                     : 4;
N} stc_rtc_year_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t ALMMINL                   : 4;
X    volatile uint32_t ALMMINL                   : 4;
N    __IO uint32_t ALMMINH                   : 3;
X    volatile uint32_t ALMMINH                   : 3;
N} stc_rtc_almmin_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t ALMHOURL                  : 4;
X    volatile uint32_t ALMHOURL                  : 4;
N    __IO uint32_t ALMHOURH                  : 2;
X    volatile uint32_t ALMHOURH                  : 2;
N} stc_rtc_almhour_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t ALMWEEK                   : 7;
X    volatile uint32_t ALMWEEK                   : 7;
N} stc_rtc_almweek_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CR                        : 9;
X    volatile uint32_t CR                        : 9;
N    uint32_t RESERVED9                      : 6;
N    __IO uint32_t EN                        : 1;
X    volatile uint32_t EN                        : 1;
N} stc_rtc_compen_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SPR0                      : 1;
X    volatile uint32_t SPR0                      : 1;
N    __IO uint32_t SPR1                      : 1;
X    volatile uint32_t SPR1                      : 1;
N    __IO uint32_t CPHA                      : 1;
X    volatile uint32_t CPHA                      : 1;
N    __IO uint32_t CPOL                      : 1;
X    volatile uint32_t CPOL                      : 1;
N    __IO uint32_t MSTR                      : 1;
X    volatile uint32_t MSTR                      : 1;
N    uint32_t RESERVED5                      : 1;
N    __IO uint32_t SPEN                      : 1;
X    volatile uint32_t SPEN                      : 1;
N    __IO uint32_t SPR2                      : 1;
X    volatile uint32_t SPR2                      : 1;
N} stc_spi_cr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SSN                       : 1;
X    volatile uint32_t SSN                       : 1;
N} stc_spi_ssn_field_t;
N
Ntypedef struct
N{
N    uint32_t RESERVED0                      : 1;
N    __IO uint32_t RXNE                      : 1;
X    volatile uint32_t RXNE                      : 1;
N    __IO uint32_t TXE                       : 1;
X    volatile uint32_t TXE                       : 1;
N    __IO uint32_t BUSY                      : 1;
X    volatile uint32_t BUSY                      : 1;
N    __IO uint32_t MDF                       : 1;
X    volatile uint32_t MDF                       : 1;
N    __IO uint32_t SSERR                     : 1;
X    volatile uint32_t SSERR                     : 1;
N    uint32_t RESERVED6                      : 1;
N    __IO uint32_t SPIF                      : 1;
X    volatile uint32_t SPIF                      : 1;
N} stc_spi_stat_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t DAT                       : 8;
X    volatile uint32_t DAT                       : 8;
N} stc_spi_data_field_t;
N
Ntypedef struct
N{
N    uint32_t RESERVED0                      : 2;
N    __IO uint32_t INT_EN                    : 1;
X    volatile uint32_t INT_EN                    : 1;
N    __IO uint32_t HDMA_RX                   : 1;
X    volatile uint32_t HDMA_RX                   : 1;
N    __IO uint32_t HDMA_TX                   : 1;
X    volatile uint32_t HDMA_TX                   : 1;
N    __IO uint32_t TXEIE                     : 1;
X    volatile uint32_t TXEIE                     : 1;
N    __IO uint32_t RXNEIE                    : 1;
X    volatile uint32_t RXNEIE                    : 1;
N} stc_spi_cr2_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t INT_CLR                   : 1;
X    volatile uint32_t INT_CLR                   : 1;
N} stc_spi_iclr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t RCH_EN                    : 1;
X    volatile uint32_t RCH_EN                    : 1;
N    __IO uint32_t XTH_EN                    : 1;
X    volatile uint32_t XTH_EN                    : 1;
N    __IO uint32_t RCL_EN                    : 1;
X    volatile uint32_t RCL_EN                    : 1;
N    __IO uint32_t XTL_EN                    : 1;
X    volatile uint32_t XTL_EN                    : 1;
N    __IO uint32_t PLL_EN                    : 1;
X    volatile uint32_t PLL_EN                    : 1;
N    __IO uint32_t CLK_SW5_SEL               : 3;
X    volatile uint32_t CLK_SW5_SEL               : 3;
N    __IO uint32_t HCLK_PRS                  : 3;
X    volatile uint32_t HCLK_PRS                  : 3;
N    __IO uint32_t PCLK_PRS                  : 2;
X    volatile uint32_t PCLK_PRS                  : 2;
N    uint32_t RESERVED13                     : 2;
N    __IO uint32_t WAKEUP_BYRCH              : 1;
X    volatile uint32_t WAKEUP_BYRCH              : 1;
N} stc_sysctrl_sysctrl0_field_t;
N
Ntypedef struct
N{
N    uint32_t RESERVED0                      : 1;
N    __IO uint32_t EXTH_EN                   : 1;
X    volatile uint32_t EXTH_EN                   : 1;
N    __IO uint32_t EXTL_EN                   : 1;
X    volatile uint32_t EXTL_EN                   : 1;
N    __IO uint32_t XTL_ALWAYS_ON             : 1;
X    volatile uint32_t XTL_ALWAYS_ON             : 1;
N    uint32_t RESERVED4                      : 1;
N    __IO uint32_t RTC_LPW                   : 1;
X    volatile uint32_t RTC_LPW                   : 1;
N    __IO uint32_t LOCKUP_EN                 : 1;
X    volatile uint32_t LOCKUP_EN                 : 1;
N    uint32_t RESERVED7                      : 1;
N    __IO uint32_t SWD_USE_IO                : 1;
X    volatile uint32_t SWD_USE_IO                : 1;
N    __IO uint32_t RTC_FREQ_ADJUST           : 3;
X    volatile uint32_t RTC_FREQ_ADJUST           : 3;
N} stc_sysctrl_sysctrl1_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SYSCTRL2                  :16;
X    volatile uint32_t SYSCTRL2                  :16;
N} stc_sysctrl_sysctrl2_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t TRIM                      :11;
X    volatile uint32_t TRIM                      :11;
N    __IO uint32_t STABLE                    : 1;
X    volatile uint32_t STABLE                    : 1;
N} stc_sysctrl_rch_cr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t DRIVER                    : 2;
X    volatile uint32_t DRIVER                    : 2;
N    __IO uint32_t XTH_FSEL                  : 2;
X    volatile uint32_t XTH_FSEL                  : 2;
N    __IO uint32_t STARTUP                   : 2;
X    volatile uint32_t STARTUP                   : 2;
N    __IO uint32_t STABLE                    : 1;
X    volatile uint32_t STABLE                    : 1;
N} stc_sysctrl_xth_cr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t TRIM                      :10;
X    volatile uint32_t TRIM                      :10;
N    __IO uint32_t STARTUP                   : 2;
X    volatile uint32_t STARTUP                   : 2;
N    __IO uint32_t STABLE                    : 1;
X    volatile uint32_t STABLE                    : 1;
N} stc_sysctrl_rcl_cr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t DRIVER                    : 2;
X    volatile uint32_t DRIVER                    : 2;
N    __IO uint32_t AMP_SEL                   : 2;
X    volatile uint32_t AMP_SEL                   : 2;
N    __IO uint32_t STARTUP                   : 2;
X    volatile uint32_t STARTUP                   : 2;
N    __IO uint32_t STABLE                    : 1;
X    volatile uint32_t STABLE                    : 1;
N} stc_sysctrl_xtl_cr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t UART0                     : 1;
X    volatile uint32_t UART0                     : 1;
N    __IO uint32_t UART1                     : 1;
X    volatile uint32_t UART1                     : 1;
N    __IO uint32_t LPUART0                   : 1;
X    volatile uint32_t LPUART0                   : 1;
N    __IO uint32_t LPUART1                   : 1;
X    volatile uint32_t LPUART1                   : 1;
N    __IO uint32_t I2C0                      : 1;
X    volatile uint32_t I2C0                      : 1;
N    __IO uint32_t I2C1                      : 1;
X    volatile uint32_t I2C1                      : 1;
N    __IO uint32_t SPI0                      : 1;
X    volatile uint32_t SPI0                      : 1;
N    __IO uint32_t SPI1                      : 1;
X    volatile uint32_t SPI1                      : 1;
N    __IO uint32_t BASETIM                   : 1;
X    volatile uint32_t BASETIM                   : 1;
N    __IO uint32_t LPTIM                     : 1;
X    volatile uint32_t LPTIM                     : 1;
N    __IO uint32_t ADVTIM                    : 1;
X    volatile uint32_t ADVTIM                    : 1;
N    __IO uint32_t TIM3                      : 1;
X    volatile uint32_t TIM3                      : 1;
N    uint32_t RESERVED12                     : 1;
N    __IO uint32_t OPA                       : 1;
X    volatile uint32_t OPA                       : 1;
N    __IO uint32_t PCA                       : 1;
X    volatile uint32_t PCA                       : 1;
N    __IO uint32_t WDT                       : 1;
X    volatile uint32_t WDT                       : 1;
N    __IO uint32_t ADC                       : 1;
X    volatile uint32_t ADC                       : 1;
N    __IO uint32_t VC                        : 1;
X    volatile uint32_t VC                        : 1;
N    __IO uint32_t RNG                       : 1;
X    volatile uint32_t RNG                       : 1;
N    __IO uint32_t PCNT                      : 1;
X    volatile uint32_t PCNT                      : 1;
N    __IO uint32_t RTC                       : 1;
X    volatile uint32_t RTC                       : 1;
N    __IO uint32_t TRIM                      : 1;
X    volatile uint32_t TRIM                      : 1;
N    __IO uint32_t LCD                       : 1;
X    volatile uint32_t LCD                       : 1;
N    uint32_t RESERVED23                     : 1;
N    __IO uint32_t TICK                      : 1;
X    volatile uint32_t TICK                      : 1;
N    __IO uint32_t SWD                       : 1;
X    volatile uint32_t SWD                       : 1;
N    __IO uint32_t CRC                       : 1;
X    volatile uint32_t CRC                       : 1;
N    __IO uint32_t AES                       : 1;
X    volatile uint32_t AES                       : 1;
N    __IO uint32_t GPIO                      : 1;
X    volatile uint32_t GPIO                      : 1;
N    __IO uint32_t DMA                       : 1;
X    volatile uint32_t DMA                       : 1;
N    __IO uint32_t DIV                       : 1;
X    volatile uint32_t DIV                       : 1;
N    __IO uint32_t FLASH                     : 1;
X    volatile uint32_t FLASH                     : 1;
N} stc_sysctrl_peri_clken_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t REFSEL                    : 2;
X    volatile uint32_t REFSEL                    : 2;
N    __IO uint32_t FOSC                      : 3;
X    volatile uint32_t FOSC                      : 3;
N    __IO uint32_t DIVN                      : 4;
X    volatile uint32_t DIVN                      : 4;
N    __IO uint32_t IBSEL                     : 2;
X    volatile uint32_t IBSEL                     : 2;
N    __IO uint32_t LFSEL                     : 2;
X    volatile uint32_t LFSEL                     : 2;
N    __IO uint32_t FRSEL                     : 2;
X    volatile uint32_t FRSEL                     : 2;
N    __IO uint32_t STARTUP                   : 3;
X    volatile uint32_t STARTUP                   : 3;
N    __IO uint32_t STABLE                    : 1;
X    volatile uint32_t STABLE                    : 1;
N} stc_sysctrl_pll_cr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t ARR                       :16;
X    volatile uint32_t ARR                       :16;
N} stc_tim0_mode0_arr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CNT                       :16;
X    volatile uint32_t CNT                       :16;
N} stc_tim0_mode0_cnt_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CNT32                     :32;
X    volatile uint32_t CNT32                     :32;
N} stc_tim0_mode0_cnt32_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CTEN                      : 1;
X    volatile uint32_t CTEN                      : 1;
N    __IO uint32_t MD                        : 1;
X    volatile uint32_t MD                        : 1;
N    __IO uint32_t CT                        : 1;
X    volatile uint32_t CT                        : 1;
N    __IO uint32_t TOGEN                     : 1;
X    volatile uint32_t TOGEN                     : 1;
N    __IO uint32_t PRS                       : 3;
X    volatile uint32_t PRS                       : 3;
N    uint32_t RESERVED7                      : 1;
N    __IO uint32_t GATE                      : 1;
X    volatile uint32_t GATE                      : 1;
N    __IO uint32_t GATEP                     : 1;
X    volatile uint32_t GATEP                     : 1;
N    __IO uint32_t UIE                       : 1;
X    volatile uint32_t UIE                       : 1;
N    uint32_t RESERVED11                     : 1;
N    __IO uint32_t MODE                      : 2;
X    volatile uint32_t MODE                      : 2;
N} stc_tim0_mode0_m0cr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t UIF                       : 1;
X    volatile uint32_t UIF                       : 1;
N} stc_tim0_mode0_ifr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t UIF                       : 1;
X    volatile uint32_t UIF                       : 1;
N} stc_tim0_mode0_iclr_field_t;
N
Ntypedef struct
N{
N    uint32_t RESERVED0                      :12;
N    __IO uint32_t MOE                       : 1;
X    volatile uint32_t MOE                       : 1;
N} stc_tim0_mode0_dtr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CNT                       :16;
X    volatile uint32_t CNT                       :16;
N} stc_tim0_mode1_cnt_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CTEN                      : 1;
X    volatile uint32_t CTEN                      : 1;
N    uint32_t RESERVED1                      : 1;
N    __IO uint32_t CT                        : 1;
X    volatile uint32_t CT                        : 1;
N    uint32_t RESERVED3                      : 1;
N    __IO uint32_t PRS                       : 3;
X    volatile uint32_t PRS                       : 3;
N    uint32_t RESERVED7                      : 1;
N    __IO uint32_t EDG1ST                    : 1;
X    volatile uint32_t EDG1ST                    : 1;
N    __IO uint32_t EDG2ND                    : 1;
X    volatile uint32_t EDG2ND                    : 1;
N    __IO uint32_t UIE                       : 1;
X    volatile uint32_t UIE                       : 1;
N    uint32_t RESERVED11                     : 1;
N    __IO uint32_t MODE                      : 2;
X    volatile uint32_t MODE                      : 2;
N    __IO uint32_t ONESHOT                   : 1;
X    volatile uint32_t ONESHOT                   : 1;
N} stc_tim0_mode1_m1cr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t UIF                       : 1;
X    volatile uint32_t UIF                       : 1;
N    uint32_t RESERVED1                      : 1;
N    __IO uint32_t CA0F                      : 1;
X    volatile uint32_t CA0F                      : 1;
N} stc_tim0_mode1_ifr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t UIF                       : 1;
X    volatile uint32_t UIF                       : 1;
N    uint32_t RESERVED1                      : 1;
N    __IO uint32_t CA0F                      : 1;
X    volatile uint32_t CA0F                      : 1;
N} stc_tim0_mode1_iclr_field_t;
N
Ntypedef struct
N{
N    uint32_t RESERVED0                      : 5;
N    __IO uint32_t TS                        : 3;
X    volatile uint32_t TS                        : 3;
N    uint32_t RESERVED8                      : 3;
N    __IO uint32_t IA0S                      : 1;
X    volatile uint32_t IA0S                      : 1;
N    __IO uint32_t IB0S                      : 1;
X    volatile uint32_t IB0S                      : 1;
N} stc_tim0_mode1_mscr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t FLTA0                     : 3;
X    volatile uint32_t FLTA0                     : 3;
N    uint32_t RESERVED3                      : 1;
N    __IO uint32_t FLTB0                     : 3;
X    volatile uint32_t FLTB0                     : 3;
N    uint32_t RESERVED7                      :21;
N    __IO uint32_t FLTET                     : 3;
X    volatile uint32_t FLTET                     : 3;
N    __IO uint32_t ETP                       : 1;
X    volatile uint32_t ETP                       : 1;
N} stc_tim0_mode1_fltr_field_t;
N
Ntypedef struct
N{
N    uint32_t RESERVED0                      : 8;
N    __IO uint32_t CIEA                      : 1;
X    volatile uint32_t CIEA                      : 1;
N} stc_tim0_mode1_cr0_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CCR0A                     :16;
X    volatile uint32_t CCR0A                     :16;
N} stc_tim0_mode1_ccr0a_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t ARR                       :16;
X    volatile uint32_t ARR                       :16;
N} stc_tim0_mode23_arr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CNT                       :16;
X    volatile uint32_t CNT                       :16;
N} stc_tim0_mode23_cnt_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CTEN                      : 1;
X    volatile uint32_t CTEN                      : 1;
N    __IO uint32_t COMP                      : 1;
X    volatile uint32_t COMP                      : 1;
N    __IO uint32_t CT                        : 1;
X    volatile uint32_t CT                        : 1;
N    __IO uint32_t PWM2S                     : 1;
X    volatile uint32_t PWM2S                     : 1;
N    __IO uint32_t PRS                       : 3;
X    volatile uint32_t PRS                       : 3;
N    __IO uint32_t BUFPEN                    : 1;
X    volatile uint32_t BUFPEN                    : 1;
N    __IO uint32_t CRG                       : 1;
X    volatile uint32_t CRG                       : 1;
N    __IO uint32_t CFG                       : 1;
X    volatile uint32_t CFG                       : 1;
N    __IO uint32_t UIE                       : 1;
X    volatile uint32_t UIE                       : 1;
N    __IO uint32_t UDE                       : 1;
X    volatile uint32_t UDE                       : 1;
N    __IO uint32_t MODE                      : 2;
X    volatile uint32_t MODE                      : 2;
N    __IO uint32_t ONESHOT                   : 1;
X    volatile uint32_t ONESHOT                   : 1;
N    __IO uint32_t CSG                       : 1;
X    volatile uint32_t CSG                       : 1;
N    __IO uint32_t OCCS                      : 1;
X    volatile uint32_t OCCS                      : 1;
N    __IO uint32_t URS                       : 1;
X    volatile uint32_t URS                       : 1;
N    __IO uint32_t TDE                       : 1;
X    volatile uint32_t TDE                       : 1;
N    __IO uint32_t TIE                       : 1;
X    volatile uint32_t TIE                       : 1;
N    __IO uint32_t BIE                       : 1;
X    volatile uint32_t BIE                       : 1;
N    __IO uint32_t CIS                       : 2;
X    volatile uint32_t CIS                       : 2;
N    __IO uint32_t OCCE                      : 1;
X    volatile uint32_t OCCE                      : 1;
N    __IO uint32_t TG                        : 1;
X    volatile uint32_t TG                        : 1;
N    __IO uint32_t UG                        : 1;
X    volatile uint32_t UG                        : 1;
N    __IO uint32_t BG                        : 1;
X    volatile uint32_t BG                        : 1;
N    __IO uint32_t DIR                       : 1;
X    volatile uint32_t DIR                       : 1;
N} stc_tim0_mode23_m23cr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t UIF                       : 1;
X    volatile uint32_t UIF                       : 1;
N    uint32_t RESERVED1                      : 1;
N    __IO uint32_t CA0F                      : 1;
X    volatile uint32_t CA0F                      : 1;
N    uint32_t RESERVED3                      : 2;
N    __IO uint32_t CB0F                      : 1;
X    volatile uint32_t CB0F                      : 1;
N    uint32_t RESERVED6                      : 2;
N    __IO uint32_t CA0E                      : 1;
X    volatile uint32_t CA0E                      : 1;
N    uint32_t RESERVED9                      : 2;
N    __IO uint32_t CB0E                      : 1;
X    volatile uint32_t CB0E                      : 1;
N    uint32_t RESERVED12                     : 2;
N    __IO uint32_t BIF                       : 1;
X    volatile uint32_t BIF                       : 1;
N    __IO uint32_t TIF                       : 1;
X    volatile uint32_t TIF                       : 1;
N} stc_tim0_mode23_ifr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t UIF                       : 1;
X    volatile uint32_t UIF                       : 1;
N    uint32_t RESERVED1                      : 1;
N    __IO uint32_t CA0F                      : 1;
X    volatile uint32_t CA0F                      : 1;
N    uint32_t RESERVED3                      : 2;
N    __IO uint32_t CB0F                      : 1;
X    volatile uint32_t CB0F                      : 1;
N    uint32_t RESERVED6                      : 2;
N    __IO uint32_t CA0E                      : 1;
X    volatile uint32_t CA0E                      : 1;
N    uint32_t RESERVED9                      : 2;
N    __IO uint32_t CB0E                      : 1;
X    volatile uint32_t CB0E                      : 1;
N    uint32_t RESERVED12                     : 2;
N    __IO uint32_t BIF                       : 1;
X    volatile uint32_t BIF                       : 1;
N    __IO uint32_t TIF                       : 1;
X    volatile uint32_t TIF                       : 1;
N} stc_tim0_mode23_iclr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t MMS                       : 3;
X    volatile uint32_t MMS                       : 3;
N    __IO uint32_t CCDS                      : 1;
X    volatile uint32_t CCDS                      : 1;
N    __IO uint32_t MSM                       : 1;
X    volatile uint32_t MSM                       : 1;
N    __IO uint32_t TS                        : 3;
X    volatile uint32_t TS                        : 3;
N    __IO uint32_t SMS                       : 3;
X    volatile uint32_t SMS                       : 3;
N    __IO uint32_t IA0S                      : 1;
X    volatile uint32_t IA0S                      : 1;
N    __IO uint32_t IB0S                      : 1;
X    volatile uint32_t IB0S                      : 1;
N} stc_tim0_mode23_mscr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t OCMA0_FLTA0               : 3;
X    volatile uint32_t OCMA0_FLTA0               : 3;
N    __IO uint32_t CCPA0                     : 1;
X    volatile uint32_t CCPA0                     : 1;
N    __IO uint32_t OCMB0_FLTB0               : 3;
X    volatile uint32_t OCMB0_FLTB0               : 3;
N    __IO uint32_t CCPB0                     : 1;
X    volatile uint32_t CCPB0                     : 1;
N    uint32_t RESERVED8                      :16;
N    __IO uint32_t FLTBK                     : 3;
X    volatile uint32_t FLTBK                     : 3;
N    __IO uint32_t BKP                       : 1;
X    volatile uint32_t BKP                       : 1;
N    __IO uint32_t FLTET                     : 3;
X    volatile uint32_t FLTET                     : 3;
N    __IO uint32_t ETP                       : 1;
X    volatile uint32_t ETP                       : 1;
N} stc_tim0_mode23_fltr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t UEVE                      : 1;
X    volatile uint32_t UEVE                      : 1;
N    __IO uint32_t CMA0E                     : 1;
X    volatile uint32_t CMA0E                     : 1;
N    uint32_t RESERVED2                      : 2;
N    __IO uint32_t CMB0E                     : 1;
X    volatile uint32_t CMB0E                     : 1;
N    uint32_t RESERVED5                      : 2;
N    __IO uint32_t ADTE                      : 1;
X    volatile uint32_t ADTE                      : 1;
N} stc_tim0_mode23_adtr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CFA_CRA_BKSA              : 2;
X    volatile uint32_t CFA_CRA_BKSA              : 2;
N    __IO uint32_t CFB_CRB_BKSB              : 2;
X    volatile uint32_t CFB_CRB_BKSB              : 2;
N    __IO uint32_t CSA                       : 1;
X    volatile uint32_t CSA                       : 1;
N    __IO uint32_t CSB                       : 1;
X    volatile uint32_t CSB                       : 1;
N    __IO uint32_t BUFEA                     : 1;
X    volatile uint32_t BUFEA                     : 1;
N    __IO uint32_t BUFEB                     : 1;
X    volatile uint32_t BUFEB                     : 1;
N    __IO uint32_t CIEA                      : 1;
X    volatile uint32_t CIEA                      : 1;
N    __IO uint32_t CIEB                      : 1;
X    volatile uint32_t CIEB                      : 1;
N    __IO uint32_t CDEA                      : 1;
X    volatile uint32_t CDEA                      : 1;
N    __IO uint32_t CDEB                      : 1;
X    volatile uint32_t CDEB                      : 1;
N    __IO uint32_t CISB                      : 2;
X    volatile uint32_t CISB                      : 2;
N    __IO uint32_t CCGA                      : 1;
X    volatile uint32_t CCGA                      : 1;
N    __IO uint32_t CCGB                      : 1;
X    volatile uint32_t CCGB                      : 1;
N} stc_tim0_mode23_crch0_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t DTR                       : 8;
X    volatile uint32_t DTR                       : 8;
N    __IO uint32_t BKSEL                     : 1;
X    volatile uint32_t BKSEL                     : 1;
N    __IO uint32_t DTEN                      : 1;
X    volatile uint32_t DTEN                      : 1;
N    __IO uint32_t BKE                       : 1;
X    volatile uint32_t BKE                       : 1;
N    __IO uint32_t AOE                       : 1;
X    volatile uint32_t AOE                       : 1;
N    __IO uint32_t MOE                       : 1;
X    volatile uint32_t MOE                       : 1;
N    __IO uint32_t SAFEEN                    : 1;
X    volatile uint32_t SAFEEN                    : 1;
N    __IO uint32_t VC0E                      : 1;
X    volatile uint32_t VC0E                      : 1;
N    __IO uint32_t VC1E                      : 1;
X    volatile uint32_t VC1E                      : 1;
N} stc_tim0_mode23_dtr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t RCR                       : 8;
X    volatile uint32_t RCR                       : 8;
N} stc_tim0_mode23_rcr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t ARRDM                     :16;
X    volatile uint32_t ARRDM                     :16;
N} stc_tim0_mode23_arrdm_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CCR0A                     :16;
X    volatile uint32_t CCR0A                     :16;
N} stc_tim0_mode23_ccr0a_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CCR0B                     :16;
X    volatile uint32_t CCR0B                     :16;
N} stc_tim0_mode23_ccr0b_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t ARR                       :16;
X    volatile uint32_t ARR                       :16;
N} stc_tim1_mode0_arr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CNT                       :16;
X    volatile uint32_t CNT                       :16;
N} stc_tim1_mode0_cnt_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CNT32                     :32;
X    volatile uint32_t CNT32                     :32;
N} stc_tim1_mode0_cnt32_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CTEN                      : 1;
X    volatile uint32_t CTEN                      : 1;
N    __IO uint32_t MD                        : 1;
X    volatile uint32_t MD                        : 1;
N    __IO uint32_t CT                        : 1;
X    volatile uint32_t CT                        : 1;
N    __IO uint32_t TOGEN                     : 1;
X    volatile uint32_t TOGEN                     : 1;
N    __IO uint32_t PRS                       : 3;
X    volatile uint32_t PRS                       : 3;
N    uint32_t RESERVED7                      : 1;
N    __IO uint32_t GATE                      : 1;
X    volatile uint32_t GATE                      : 1;
N    __IO uint32_t GATEP                     : 1;
X    volatile uint32_t GATEP                     : 1;
N    __IO uint32_t UIE                       : 1;
X    volatile uint32_t UIE                       : 1;
N    uint32_t RESERVED11                     : 1;
N    __IO uint32_t MODE                      : 2;
X    volatile uint32_t MODE                      : 2;
N} stc_tim1_mode0_m0cr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t UIF                       : 1;
X    volatile uint32_t UIF                       : 1;
N} stc_tim1_mode0_ifr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t UIF                       : 1;
X    volatile uint32_t UIF                       : 1;
N} stc_tim1_mode0_iclr_field_t;
N
Ntypedef struct
N{
N    uint32_t RESERVED0                      :12;
N    __IO uint32_t MOE                       : 1;
X    volatile uint32_t MOE                       : 1;
N} stc_tim1_mode0_dtr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CNT                       :16;
X    volatile uint32_t CNT                       :16;
N} stc_tim1_mode1_cnt_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CTEN                      : 1;
X    volatile uint32_t CTEN                      : 1;
N    uint32_t RESERVED1                      : 1;
N    __IO uint32_t CT                        : 1;
X    volatile uint32_t CT                        : 1;
N    uint32_t RESERVED3                      : 1;
N    __IO uint32_t PRS                       : 3;
X    volatile uint32_t PRS                       : 3;
N    uint32_t RESERVED7                      : 1;
N    __IO uint32_t EDG1ST                    : 1;
X    volatile uint32_t EDG1ST                    : 1;
N    __IO uint32_t EDG2ND                    : 1;
X    volatile uint32_t EDG2ND                    : 1;
N    __IO uint32_t UIE                       : 1;
X    volatile uint32_t UIE                       : 1;
N    uint32_t RESERVED11                     : 1;
N    __IO uint32_t MODE                      : 2;
X    volatile uint32_t MODE                      : 2;
N    __IO uint32_t ONESHOT                   : 1;
X    volatile uint32_t ONESHOT                   : 1;
N} stc_tim1_mode1_m1cr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t UIF                       : 1;
X    volatile uint32_t UIF                       : 1;
N    uint32_t RESERVED1                      : 1;
N    __IO uint32_t CA0F                      : 1;
X    volatile uint32_t CA0F                      : 1;
N} stc_tim1_mode1_ifr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t UIF                       : 1;
X    volatile uint32_t UIF                       : 1;
N    uint32_t RESERVED1                      : 1;
N    __IO uint32_t CA0F                      : 1;
X    volatile uint32_t CA0F                      : 1;
N} stc_tim1_mode1_iclr_field_t;
N
Ntypedef struct
N{
N    uint32_t RESERVED0                      : 5;
N    __IO uint32_t TS                        : 3;
X    volatile uint32_t TS                        : 3;
N    uint32_t RESERVED8                      : 3;
N    __IO uint32_t IA0S                      : 1;
X    volatile uint32_t IA0S                      : 1;
N    __IO uint32_t IB0S                      : 1;
X    volatile uint32_t IB0S                      : 1;
N} stc_tim1_mode1_mscr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t FLTA0                     : 3;
X    volatile uint32_t FLTA0                     : 3;
N    uint32_t RESERVED3                      : 1;
N    __IO uint32_t FLTB0                     : 3;
X    volatile uint32_t FLTB0                     : 3;
N    uint32_t RESERVED7                      :21;
N    __IO uint32_t FLTET                     : 3;
X    volatile uint32_t FLTET                     : 3;
N    __IO uint32_t ETP                       : 1;
X    volatile uint32_t ETP                       : 1;
N} stc_tim1_mode1_fltr_field_t;
N
Ntypedef struct
N{
N    uint32_t RESERVED0                      : 8;
N    __IO uint32_t CIEA                      : 1;
X    volatile uint32_t CIEA                      : 1;
N} stc_tim1_mode1_cr0_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CCR0A                     :16;
X    volatile uint32_t CCR0A                     :16;
N} stc_tim1_mode1_ccr0a_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t ARR                       :16;
X    volatile uint32_t ARR                       :16;
N} stc_tim1_mode23_arr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CNT                       :16;
X    volatile uint32_t CNT                       :16;
N} stc_tim1_mode23_cnt_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CTEN                      : 1;
X    volatile uint32_t CTEN                      : 1;
N    __IO uint32_t COMP                      : 1;
X    volatile uint32_t COMP                      : 1;
N    __IO uint32_t CT                        : 1;
X    volatile uint32_t CT                        : 1;
N    __IO uint32_t PWM2S                     : 1;
X    volatile uint32_t PWM2S                     : 1;
N    __IO uint32_t PRS                       : 3;
X    volatile uint32_t PRS                       : 3;
N    __IO uint32_t BUFPEN                    : 1;
X    volatile uint32_t BUFPEN                    : 1;
N    __IO uint32_t CRG                       : 1;
X    volatile uint32_t CRG                       : 1;
N    __IO uint32_t CFG                       : 1;
X    volatile uint32_t CFG                       : 1;
N    __IO uint32_t UIE                       : 1;
X    volatile uint32_t UIE                       : 1;
N    __IO uint32_t UDE                       : 1;
X    volatile uint32_t UDE                       : 1;
N    __IO uint32_t MODE                      : 2;
X    volatile uint32_t MODE                      : 2;
N    __IO uint32_t ONESHOT                   : 1;
X    volatile uint32_t ONESHOT                   : 1;
N    __IO uint32_t CSG                       : 1;
X    volatile uint32_t CSG                       : 1;
N    __IO uint32_t OCCS                      : 1;
X    volatile uint32_t OCCS                      : 1;
N    __IO uint32_t URS                       : 1;
X    volatile uint32_t URS                       : 1;
N    __IO uint32_t TDE                       : 1;
X    volatile uint32_t TDE                       : 1;
N    __IO uint32_t TIE                       : 1;
X    volatile uint32_t TIE                       : 1;
N    __IO uint32_t BIE                       : 1;
X    volatile uint32_t BIE                       : 1;
N    __IO uint32_t CIS                       : 2;
X    volatile uint32_t CIS                       : 2;
N    __IO uint32_t OCCE                      : 1;
X    volatile uint32_t OCCE                      : 1;
N    __IO uint32_t TG                        : 1;
X    volatile uint32_t TG                        : 1;
N    __IO uint32_t UG                        : 1;
X    volatile uint32_t UG                        : 1;
N    __IO uint32_t BG                        : 1;
X    volatile uint32_t BG                        : 1;
N    __IO uint32_t DIR                       : 1;
X    volatile uint32_t DIR                       : 1;
N} stc_tim1_mode23_m23cr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t UIF                       : 1;
X    volatile uint32_t UIF                       : 1;
N    uint32_t RESERVED1                      : 1;
N    __IO uint32_t CA0F                      : 1;
X    volatile uint32_t CA0F                      : 1;
N    uint32_t RESERVED3                      : 2;
N    __IO uint32_t CB0F                      : 1;
X    volatile uint32_t CB0F                      : 1;
N    uint32_t RESERVED6                      : 2;
N    __IO uint32_t CA0E                      : 1;
X    volatile uint32_t CA0E                      : 1;
N    uint32_t RESERVED9                      : 2;
N    __IO uint32_t CB0E                      : 1;
X    volatile uint32_t CB0E                      : 1;
N    uint32_t RESERVED12                     : 2;
N    __IO uint32_t BIF                       : 1;
X    volatile uint32_t BIF                       : 1;
N    __IO uint32_t TIF                       : 1;
X    volatile uint32_t TIF                       : 1;
N} stc_tim1_mode23_ifr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t UIF                       : 1;
X    volatile uint32_t UIF                       : 1;
N    uint32_t RESERVED1                      : 1;
N    __IO uint32_t CA0F                      : 1;
X    volatile uint32_t CA0F                      : 1;
N    uint32_t RESERVED3                      : 2;
N    __IO uint32_t CB0F                      : 1;
X    volatile uint32_t CB0F                      : 1;
N    uint32_t RESERVED6                      : 2;
N    __IO uint32_t CA0E                      : 1;
X    volatile uint32_t CA0E                      : 1;
N    uint32_t RESERVED9                      : 2;
N    __IO uint32_t CB0E                      : 1;
X    volatile uint32_t CB0E                      : 1;
N    uint32_t RESERVED12                     : 2;
N    __IO uint32_t BIF                       : 1;
X    volatile uint32_t BIF                       : 1;
N    __IO uint32_t TIF                       : 1;
X    volatile uint32_t TIF                       : 1;
N} stc_tim1_mode23_iclr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t MMS                       : 3;
X    volatile uint32_t MMS                       : 3;
N    __IO uint32_t CCDS                      : 1;
X    volatile uint32_t CCDS                      : 1;
N    __IO uint32_t MSM                       : 1;
X    volatile uint32_t MSM                       : 1;
N    __IO uint32_t TS                        : 3;
X    volatile uint32_t TS                        : 3;
N    __IO uint32_t SMS                       : 3;
X    volatile uint32_t SMS                       : 3;
N    __IO uint32_t IA0S                      : 1;
X    volatile uint32_t IA0S                      : 1;
N    __IO uint32_t IB0S                      : 1;
X    volatile uint32_t IB0S                      : 1;
N} stc_tim1_mode23_mscr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t OCMA0_FLTA0               : 3;
X    volatile uint32_t OCMA0_FLTA0               : 3;
N    __IO uint32_t CCPA0                     : 1;
X    volatile uint32_t CCPA0                     : 1;
N    __IO uint32_t OCMB0_FLTB0               : 3;
X    volatile uint32_t OCMB0_FLTB0               : 3;
N    __IO uint32_t CCPB0                     : 1;
X    volatile uint32_t CCPB0                     : 1;
N    uint32_t RESERVED8                      :16;
N    __IO uint32_t FLTBK                     : 3;
X    volatile uint32_t FLTBK                     : 3;
N    __IO uint32_t BKP                       : 1;
X    volatile uint32_t BKP                       : 1;
N    __IO uint32_t FLTET                     : 3;
X    volatile uint32_t FLTET                     : 3;
N    __IO uint32_t ETP                       : 1;
X    volatile uint32_t ETP                       : 1;
N} stc_tim1_mode23_fltr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t UEVE                      : 1;
X    volatile uint32_t UEVE                      : 1;
N    __IO uint32_t CMA0E                     : 1;
X    volatile uint32_t CMA0E                     : 1;
N    uint32_t RESERVED2                      : 2;
N    __IO uint32_t CMB0E                     : 1;
X    volatile uint32_t CMB0E                     : 1;
N    uint32_t RESERVED5                      : 2;
N    __IO uint32_t ADTE                      : 1;
X    volatile uint32_t ADTE                      : 1;
N} stc_tim1_mode23_adtr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CFA_CRA_BKSA              : 2;
X    volatile uint32_t CFA_CRA_BKSA              : 2;
N    __IO uint32_t CFB_CRB_BKSB              : 2;
X    volatile uint32_t CFB_CRB_BKSB              : 2;
N    __IO uint32_t CSA                       : 1;
X    volatile uint32_t CSA                       : 1;
N    __IO uint32_t CSB                       : 1;
X    volatile uint32_t CSB                       : 1;
N    __IO uint32_t BUFEA                     : 1;
X    volatile uint32_t BUFEA                     : 1;
N    __IO uint32_t BUFEB                     : 1;
X    volatile uint32_t BUFEB                     : 1;
N    __IO uint32_t CIEA                      : 1;
X    volatile uint32_t CIEA                      : 1;
N    __IO uint32_t CIEB                      : 1;
X    volatile uint32_t CIEB                      : 1;
N    __IO uint32_t CDEA                      : 1;
X    volatile uint32_t CDEA                      : 1;
N    __IO uint32_t CDEB                      : 1;
X    volatile uint32_t CDEB                      : 1;
N    __IO uint32_t CISB                      : 2;
X    volatile uint32_t CISB                      : 2;
N    __IO uint32_t CCGA                      : 1;
X    volatile uint32_t CCGA                      : 1;
N    __IO uint32_t CCGB                      : 1;
X    volatile uint32_t CCGB                      : 1;
N} stc_tim1_mode23_crch0_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t DTR                       : 8;
X    volatile uint32_t DTR                       : 8;
N    __IO uint32_t BKSEL                     : 1;
X    volatile uint32_t BKSEL                     : 1;
N    __IO uint32_t DTEN                      : 1;
X    volatile uint32_t DTEN                      : 1;
N    __IO uint32_t BKE                       : 1;
X    volatile uint32_t BKE                       : 1;
N    __IO uint32_t AOE                       : 1;
X    volatile uint32_t AOE                       : 1;
N    __IO uint32_t MOE                       : 1;
X    volatile uint32_t MOE                       : 1;
N    __IO uint32_t SAFEEN                    : 1;
X    volatile uint32_t SAFEEN                    : 1;
N    __IO uint32_t VC0E                      : 1;
X    volatile uint32_t VC0E                      : 1;
N    __IO uint32_t VC1E                      : 1;
X    volatile uint32_t VC1E                      : 1;
N} stc_tim1_mode23_dtr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t RCR                       : 8;
X    volatile uint32_t RCR                       : 8;
N} stc_tim1_mode23_rcr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t ARRDM                     :16;
X    volatile uint32_t ARRDM                     :16;
N} stc_tim1_mode23_arrdm_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CCR0A                     :16;
X    volatile uint32_t CCR0A                     :16;
N} stc_tim1_mode23_ccr0a_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CCR0B                     :16;
X    volatile uint32_t CCR0B                     :16;
N} stc_tim1_mode23_ccr0b_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t ARR                       :16;
X    volatile uint32_t ARR                       :16;
N} stc_tim2_mode0_arr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CNT                       :16;
X    volatile uint32_t CNT                       :16;
N} stc_tim2_mode0_cnt_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CNT32                     :32;
X    volatile uint32_t CNT32                     :32;
N} stc_tim2_mode0_cnt32_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CTEN                      : 1;
X    volatile uint32_t CTEN                      : 1;
N    __IO uint32_t MD                        : 1;
X    volatile uint32_t MD                        : 1;
N    __IO uint32_t CT                        : 1;
X    volatile uint32_t CT                        : 1;
N    __IO uint32_t TOGEN                     : 1;
X    volatile uint32_t TOGEN                     : 1;
N    __IO uint32_t PRS                       : 3;
X    volatile uint32_t PRS                       : 3;
N    uint32_t RESERVED7                      : 1;
N    __IO uint32_t GATE                      : 1;
X    volatile uint32_t GATE                      : 1;
N    __IO uint32_t GATEP                     : 1;
X    volatile uint32_t GATEP                     : 1;
N    __IO uint32_t UIE                       : 1;
X    volatile uint32_t UIE                       : 1;
N    uint32_t RESERVED11                     : 1;
N    __IO uint32_t MODE                      : 2;
X    volatile uint32_t MODE                      : 2;
N} stc_tim2_mode0_m0cr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t UIF                       : 1;
X    volatile uint32_t UIF                       : 1;
N} stc_tim2_mode0_ifr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t UIF                       : 1;
X    volatile uint32_t UIF                       : 1;
N} stc_tim2_mode0_iclr_field_t;
N
Ntypedef struct
N{
N    uint32_t RESERVED0                      :12;
N    __IO uint32_t MOE                       : 1;
X    volatile uint32_t MOE                       : 1;
N} stc_tim2_mode0_dtr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CNT                       :16;
X    volatile uint32_t CNT                       :16;
N} stc_tim2_mode1_cnt_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CTEN                      : 1;
X    volatile uint32_t CTEN                      : 1;
N    uint32_t RESERVED1                      : 1;
N    __IO uint32_t CT                        : 1;
X    volatile uint32_t CT                        : 1;
N    uint32_t RESERVED3                      : 1;
N    __IO uint32_t PRS                       : 3;
X    volatile uint32_t PRS                       : 3;
N    uint32_t RESERVED7                      : 1;
N    __IO uint32_t EDG1ST                    : 1;
X    volatile uint32_t EDG1ST                    : 1;
N    __IO uint32_t EDG2ND                    : 1;
X    volatile uint32_t EDG2ND                    : 1;
N    __IO uint32_t UIE                       : 1;
X    volatile uint32_t UIE                       : 1;
N    uint32_t RESERVED11                     : 1;
N    __IO uint32_t MODE                      : 2;
X    volatile uint32_t MODE                      : 2;
N    __IO uint32_t ONESHOT                   : 1;
X    volatile uint32_t ONESHOT                   : 1;
N} stc_tim2_mode1_m1cr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t UIF                       : 1;
X    volatile uint32_t UIF                       : 1;
N    uint32_t RESERVED1                      : 1;
N    __IO uint32_t CA0F                      : 1;
X    volatile uint32_t CA0F                      : 1;
N} stc_tim2_mode1_ifr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t UIF                       : 1;
X    volatile uint32_t UIF                       : 1;
N    uint32_t RESERVED1                      : 1;
N    __IO uint32_t CA0F                      : 1;
X    volatile uint32_t CA0F                      : 1;
N} stc_tim2_mode1_iclr_field_t;
N
Ntypedef struct
N{
N    uint32_t RESERVED0                      : 5;
N    __IO uint32_t TS                        : 3;
X    volatile uint32_t TS                        : 3;
N    uint32_t RESERVED8                      : 3;
N    __IO uint32_t IA0S                      : 1;
X    volatile uint32_t IA0S                      : 1;
N    __IO uint32_t IB0S                      : 1;
X    volatile uint32_t IB0S                      : 1;
N} stc_tim2_mode1_mscr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t FLTA0                     : 3;
X    volatile uint32_t FLTA0                     : 3;
N    uint32_t RESERVED3                      : 1;
N    __IO uint32_t FLTB0                     : 3;
X    volatile uint32_t FLTB0                     : 3;
N    uint32_t RESERVED7                      :21;
N    __IO uint32_t FLTET                     : 3;
X    volatile uint32_t FLTET                     : 3;
N    __IO uint32_t ETP                       : 1;
X    volatile uint32_t ETP                       : 1;
N} stc_tim2_mode1_fltr_field_t;
N
Ntypedef struct
N{
N    uint32_t RESERVED0                      : 8;
N    __IO uint32_t CIEA                      : 1;
X    volatile uint32_t CIEA                      : 1;
N} stc_tim2_mode1_cr0_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CCR0A                     :16;
X    volatile uint32_t CCR0A                     :16;
N} stc_tim2_mode1_ccr0a_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t ARR                       :16;
X    volatile uint32_t ARR                       :16;
N} stc_tim2_mode23_arr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CNT                       :16;
X    volatile uint32_t CNT                       :16;
N} stc_tim2_mode23_cnt_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CTEN                      : 1;
X    volatile uint32_t CTEN                      : 1;
N    __IO uint32_t COMP                      : 1;
X    volatile uint32_t COMP                      : 1;
N    __IO uint32_t CT                        : 1;
X    volatile uint32_t CT                        : 1;
N    __IO uint32_t PWM2S                     : 1;
X    volatile uint32_t PWM2S                     : 1;
N    __IO uint32_t PRS                       : 3;
X    volatile uint32_t PRS                       : 3;
N    __IO uint32_t BUFPEN                    : 1;
X    volatile uint32_t BUFPEN                    : 1;
N    __IO uint32_t CRG                       : 1;
X    volatile uint32_t CRG                       : 1;
N    __IO uint32_t CFG                       : 1;
X    volatile uint32_t CFG                       : 1;
N    __IO uint32_t UIE                       : 1;
X    volatile uint32_t UIE                       : 1;
N    __IO uint32_t UDE                       : 1;
X    volatile uint32_t UDE                       : 1;
N    __IO uint32_t MODE                      : 2;
X    volatile uint32_t MODE                      : 2;
N    __IO uint32_t ONESHOT                   : 1;
X    volatile uint32_t ONESHOT                   : 1;
N    __IO uint32_t CSG                       : 1;
X    volatile uint32_t CSG                       : 1;
N    __IO uint32_t OCCS                      : 1;
X    volatile uint32_t OCCS                      : 1;
N    __IO uint32_t URS                       : 1;
X    volatile uint32_t URS                       : 1;
N    __IO uint32_t TDE                       : 1;
X    volatile uint32_t TDE                       : 1;
N    __IO uint32_t TIE                       : 1;
X    volatile uint32_t TIE                       : 1;
N    __IO uint32_t BIE                       : 1;
X    volatile uint32_t BIE                       : 1;
N    __IO uint32_t CIS                       : 2;
X    volatile uint32_t CIS                       : 2;
N    __IO uint32_t OCCE                      : 1;
X    volatile uint32_t OCCE                      : 1;
N    __IO uint32_t TG                        : 1;
X    volatile uint32_t TG                        : 1;
N    __IO uint32_t UG                        : 1;
X    volatile uint32_t UG                        : 1;
N    __IO uint32_t BG                        : 1;
X    volatile uint32_t BG                        : 1;
N    __IO uint32_t DIR                       : 1;
X    volatile uint32_t DIR                       : 1;
N} stc_tim2_mode23_m23cr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t UIF                       : 1;
X    volatile uint32_t UIF                       : 1;
N    uint32_t RESERVED1                      : 1;
N    __IO uint32_t CA0F                      : 1;
X    volatile uint32_t CA0F                      : 1;
N    uint32_t RESERVED3                      : 2;
N    __IO uint32_t CB0F                      : 1;
X    volatile uint32_t CB0F                      : 1;
N    uint32_t RESERVED6                      : 2;
N    __IO uint32_t CA0E                      : 1;
X    volatile uint32_t CA0E                      : 1;
N    uint32_t RESERVED9                      : 2;
N    __IO uint32_t CB0E                      : 1;
X    volatile uint32_t CB0E                      : 1;
N    uint32_t RESERVED12                     : 2;
N    __IO uint32_t BIF                       : 1;
X    volatile uint32_t BIF                       : 1;
N    __IO uint32_t TIF                       : 1;
X    volatile uint32_t TIF                       : 1;
N} stc_tim2_mode23_ifr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t UIF                       : 1;
X    volatile uint32_t UIF                       : 1;
N    uint32_t RESERVED1                      : 1;
N    __IO uint32_t CA0F                      : 1;
X    volatile uint32_t CA0F                      : 1;
N    uint32_t RESERVED3                      : 2;
N    __IO uint32_t CB0F                      : 1;
X    volatile uint32_t CB0F                      : 1;
N    uint32_t RESERVED6                      : 2;
N    __IO uint32_t CA0E                      : 1;
X    volatile uint32_t CA0E                      : 1;
N    uint32_t RESERVED9                      : 2;
N    __IO uint32_t CB0E                      : 1;
X    volatile uint32_t CB0E                      : 1;
N    uint32_t RESERVED12                     : 2;
N    __IO uint32_t BIF                       : 1;
X    volatile uint32_t BIF                       : 1;
N    __IO uint32_t TIF                       : 1;
X    volatile uint32_t TIF                       : 1;
N} stc_tim2_mode23_iclr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t MMS                       : 3;
X    volatile uint32_t MMS                       : 3;
N    __IO uint32_t CCDS                      : 1;
X    volatile uint32_t CCDS                      : 1;
N    __IO uint32_t MSM                       : 1;
X    volatile uint32_t MSM                       : 1;
N    __IO uint32_t TS                        : 3;
X    volatile uint32_t TS                        : 3;
N    __IO uint32_t SMS                       : 3;
X    volatile uint32_t SMS                       : 3;
N    __IO uint32_t IA0S                      : 1;
X    volatile uint32_t IA0S                      : 1;
N    __IO uint32_t IB0S                      : 1;
X    volatile uint32_t IB0S                      : 1;
N} stc_tim2_mode23_mscr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t OCMA0_FLTA0               : 3;
X    volatile uint32_t OCMA0_FLTA0               : 3;
N    __IO uint32_t CCPA0                     : 1;
X    volatile uint32_t CCPA0                     : 1;
N    __IO uint32_t OCMB0_FLTB0               : 3;
X    volatile uint32_t OCMB0_FLTB0               : 3;
N    __IO uint32_t CCPB0                     : 1;
X    volatile uint32_t CCPB0                     : 1;
N    uint32_t RESERVED8                      :16;
N    __IO uint32_t FLTBK                     : 3;
X    volatile uint32_t FLTBK                     : 3;
N    __IO uint32_t BKP                       : 1;
X    volatile uint32_t BKP                       : 1;
N    __IO uint32_t FLTET                     : 3;
X    volatile uint32_t FLTET                     : 3;
N    __IO uint32_t ETP                       : 1;
X    volatile uint32_t ETP                       : 1;
N} stc_tim2_mode23_fltr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t UEVE                      : 1;
X    volatile uint32_t UEVE                      : 1;
N    __IO uint32_t CMA0E                     : 1;
X    volatile uint32_t CMA0E                     : 1;
N    uint32_t RESERVED2                      : 2;
N    __IO uint32_t CMB0E                     : 1;
X    volatile uint32_t CMB0E                     : 1;
N    uint32_t RESERVED5                      : 2;
N    __IO uint32_t ADTE                      : 1;
X    volatile uint32_t ADTE                      : 1;
N} stc_tim2_mode23_adtr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CFA_CRA_BKSA              : 2;
X    volatile uint32_t CFA_CRA_BKSA              : 2;
N    __IO uint32_t CFB_CRB_BKSB              : 2;
X    volatile uint32_t CFB_CRB_BKSB              : 2;
N    __IO uint32_t CSA                       : 1;
X    volatile uint32_t CSA                       : 1;
N    __IO uint32_t CSB                       : 1;
X    volatile uint32_t CSB                       : 1;
N    __IO uint32_t BUFEA                     : 1;
X    volatile uint32_t BUFEA                     : 1;
N    __IO uint32_t BUFEB                     : 1;
X    volatile uint32_t BUFEB                     : 1;
N    __IO uint32_t CIEA                      : 1;
X    volatile uint32_t CIEA                      : 1;
N    __IO uint32_t CIEB                      : 1;
X    volatile uint32_t CIEB                      : 1;
N    __IO uint32_t CDEA                      : 1;
X    volatile uint32_t CDEA                      : 1;
N    __IO uint32_t CDEB                      : 1;
X    volatile uint32_t CDEB                      : 1;
N    __IO uint32_t CISB                      : 2;
X    volatile uint32_t CISB                      : 2;
N    __IO uint32_t CCGA                      : 1;
X    volatile uint32_t CCGA                      : 1;
N    __IO uint32_t CCGB                      : 1;
X    volatile uint32_t CCGB                      : 1;
N} stc_tim2_mode23_crch0_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t DTR                       : 8;
X    volatile uint32_t DTR                       : 8;
N    __IO uint32_t BKSEL                     : 1;
X    volatile uint32_t BKSEL                     : 1;
N    __IO uint32_t DTEN                      : 1;
X    volatile uint32_t DTEN                      : 1;
N    __IO uint32_t BKE                       : 1;
X    volatile uint32_t BKE                       : 1;
N    __IO uint32_t AOE                       : 1;
X    volatile uint32_t AOE                       : 1;
N    __IO uint32_t MOE                       : 1;
X    volatile uint32_t MOE                       : 1;
N    __IO uint32_t SAFEEN                    : 1;
X    volatile uint32_t SAFEEN                    : 1;
N    __IO uint32_t VC0E                      : 1;
X    volatile uint32_t VC0E                      : 1;
N    __IO uint32_t VC1E                      : 1;
X    volatile uint32_t VC1E                      : 1;
N} stc_tim2_mode23_dtr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t RCR                       : 8;
X    volatile uint32_t RCR                       : 8;
N} stc_tim2_mode23_rcr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t ARRDM                     :16;
X    volatile uint32_t ARRDM                     :16;
N} stc_tim2_mode23_arrdm_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CCR0A                     :16;
X    volatile uint32_t CCR0A                     :16;
N} stc_tim2_mode23_ccr0a_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CCR0B                     :16;
X    volatile uint32_t CCR0B                     :16;
N} stc_tim2_mode23_ccr0b_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t ARR                       :16;
X    volatile uint32_t ARR                       :16;
N} stc_tim3_mode0_arr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CNT                       :16;
X    volatile uint32_t CNT                       :16;
N} stc_tim3_mode0_cnt_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CNT32                     :32;
X    volatile uint32_t CNT32                     :32;
N} stc_tim3_mode0_cnt32_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CTEN                      : 1;
X    volatile uint32_t CTEN                      : 1;
N    __IO uint32_t MD                        : 1;
X    volatile uint32_t MD                        : 1;
N    __IO uint32_t CT                        : 1;
X    volatile uint32_t CT                        : 1;
N    __IO uint32_t TOGEN                     : 1;
X    volatile uint32_t TOGEN                     : 1;
N    __IO uint32_t PRS                       : 3;
X    volatile uint32_t PRS                       : 3;
N    uint32_t RESERVED7                      : 1;
N    __IO uint32_t GATE                      : 1;
X    volatile uint32_t GATE                      : 1;
N    __IO uint32_t GATEP                     : 1;
X    volatile uint32_t GATEP                     : 1;
N    __IO uint32_t UIE                       : 1;
X    volatile uint32_t UIE                       : 1;
N    uint32_t RESERVED11                     : 1;
N    __IO uint32_t MODE                      : 2;
X    volatile uint32_t MODE                      : 2;
N} stc_tim3_mode0_m0cr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t UIF                       : 1;
X    volatile uint32_t UIF                       : 1;
N} stc_tim3_mode0_ifr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t UIF                       : 1;
X    volatile uint32_t UIF                       : 1;
N} stc_tim3_mode0_iclr_field_t;
N
Ntypedef struct
N{
N    uint32_t RESERVED0                      :12;
N    __IO uint32_t MOE                       : 1;
X    volatile uint32_t MOE                       : 1;
N} stc_tim3_mode0_dtr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CNT                       :16;
X    volatile uint32_t CNT                       :16;
N} stc_tim3_mode1_cnt_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CTEN                      : 1;
X    volatile uint32_t CTEN                      : 1;
N    uint32_t RESERVED1                      : 1;
N    __IO uint32_t CT                        : 1;
X    volatile uint32_t CT                        : 1;
N    uint32_t RESERVED3                      : 1;
N    __IO uint32_t PRS                       : 3;
X    volatile uint32_t PRS                       : 3;
N    uint32_t RESERVED7                      : 1;
N    __IO uint32_t EDG1ST                    : 1;
X    volatile uint32_t EDG1ST                    : 1;
N    __IO uint32_t EDG2ND                    : 1;
X    volatile uint32_t EDG2ND                    : 1;
N    __IO uint32_t UIE                       : 1;
X    volatile uint32_t UIE                       : 1;
N    uint32_t RESERVED11                     : 1;
N    __IO uint32_t MODE                      : 2;
X    volatile uint32_t MODE                      : 2;
N    __IO uint32_t ONESHOT                   : 1;
X    volatile uint32_t ONESHOT                   : 1;
N} stc_tim3_mode1_m1cr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t UIF                       : 1;
X    volatile uint32_t UIF                       : 1;
N    uint32_t RESERVED1                      : 1;
N    __IO uint32_t CA0F                      : 1;
X    volatile uint32_t CA0F                      : 1;
N} stc_tim3_mode1_ifr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t UIF                       : 1;
X    volatile uint32_t UIF                       : 1;
N    uint32_t RESERVED1                      : 1;
N    __IO uint32_t CA0F                      : 1;
X    volatile uint32_t CA0F                      : 1;
N} stc_tim3_mode1_iclr_field_t;
N
Ntypedef struct
N{
N    uint32_t RESERVED0                      : 5;
N    __IO uint32_t TS                        : 3;
X    volatile uint32_t TS                        : 3;
N    uint32_t RESERVED8                      : 3;
N    __IO uint32_t IA0S                      : 1;
X    volatile uint32_t IA0S                      : 1;
N    __IO uint32_t IB0S                      : 1;
X    volatile uint32_t IB0S                      : 1;
N} stc_tim3_mode1_mscr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t FLTA0                     : 3;
X    volatile uint32_t FLTA0                     : 3;
N    uint32_t RESERVED3                      : 1;
N    __IO uint32_t FLTB0                     : 3;
X    volatile uint32_t FLTB0                     : 3;
N    uint32_t RESERVED7                      :21;
N    __IO uint32_t FLTET                     : 3;
X    volatile uint32_t FLTET                     : 3;
N    __IO uint32_t ETP                       : 1;
X    volatile uint32_t ETP                       : 1;
N} stc_tim3_mode1_fltr_field_t;
N
Ntypedef struct
N{
N    uint32_t RESERVED0                      : 8;
N    __IO uint32_t CIEA                      : 1;
X    volatile uint32_t CIEA                      : 1;
N} stc_tim3_mode1_cr0_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CCR0A                     :16;
X    volatile uint32_t CCR0A                     :16;
N} stc_tim3_mode1_ccr0a_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t ARR                       :16;
X    volatile uint32_t ARR                       :16;
N} stc_tim3_mode23_arr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CNT                       :16;
X    volatile uint32_t CNT                       :16;
N} stc_tim3_mode23_cnt_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CTEN                      : 1;
X    volatile uint32_t CTEN                      : 1;
N    __IO uint32_t COMP                      : 1;
X    volatile uint32_t COMP                      : 1;
N    __IO uint32_t CT                        : 1;
X    volatile uint32_t CT                        : 1;
N    __IO uint32_t PWM2S                     : 1;
X    volatile uint32_t PWM2S                     : 1;
N    __IO uint32_t PRS                       : 3;
X    volatile uint32_t PRS                       : 3;
N    __IO uint32_t BUFPEN                    : 1;
X    volatile uint32_t BUFPEN                    : 1;
N    __IO uint32_t CRG                       : 1;
X    volatile uint32_t CRG                       : 1;
N    __IO uint32_t CFG                       : 1;
X    volatile uint32_t CFG                       : 1;
N    __IO uint32_t UIE                       : 1;
X    volatile uint32_t UIE                       : 1;
N    __IO uint32_t UDE                       : 1;
X    volatile uint32_t UDE                       : 1;
N    __IO uint32_t MODE                      : 2;
X    volatile uint32_t MODE                      : 2;
N    __IO uint32_t ONESHOT                   : 1;
X    volatile uint32_t ONESHOT                   : 1;
N    __IO uint32_t CSG                       : 1;
X    volatile uint32_t CSG                       : 1;
N    __IO uint32_t OCCS                      : 1;
X    volatile uint32_t OCCS                      : 1;
N    __IO uint32_t URS                       : 1;
X    volatile uint32_t URS                       : 1;
N    __IO uint32_t TDE                       : 1;
X    volatile uint32_t TDE                       : 1;
N    __IO uint32_t TIE                       : 1;
X    volatile uint32_t TIE                       : 1;
N    __IO uint32_t BIE                       : 1;
X    volatile uint32_t BIE                       : 1;
N    __IO uint32_t CIS                       : 2;
X    volatile uint32_t CIS                       : 2;
N    __IO uint32_t OCCE                      : 1;
X    volatile uint32_t OCCE                      : 1;
N    __IO uint32_t TG                        : 1;
X    volatile uint32_t TG                        : 1;
N    __IO uint32_t UG                        : 1;
X    volatile uint32_t UG                        : 1;
N    __IO uint32_t BG                        : 1;
X    volatile uint32_t BG                        : 1;
N    __IO uint32_t DIR                       : 1;
X    volatile uint32_t DIR                       : 1;
N} stc_tim3_mode23_m23cr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t UIF                       : 1;
X    volatile uint32_t UIF                       : 1;
N    uint32_t RESERVED1                      : 1;
N    __IO uint32_t CA0F                      : 1;
X    volatile uint32_t CA0F                      : 1;
N    __IO uint32_t CA1F                      : 1;
X    volatile uint32_t CA1F                      : 1;
N    __IO uint32_t CA2F                      : 1;
X    volatile uint32_t CA2F                      : 1;
N    __IO uint32_t CB0F                      : 1;
X    volatile uint32_t CB0F                      : 1;
N    __IO uint32_t CB1F                      : 1;
X    volatile uint32_t CB1F                      : 1;
N    __IO uint32_t CB2F                      : 1;
X    volatile uint32_t CB2F                      : 1;
N    __IO uint32_t CA0E                      : 1;
X    volatile uint32_t CA0E                      : 1;
N    __IO uint32_t CA1E                      : 1;
X    volatile uint32_t CA1E                      : 1;
N    __IO uint32_t CA2E                      : 1;
X    volatile uint32_t CA2E                      : 1;
N    __IO uint32_t CB0E                      : 1;
X    volatile uint32_t CB0E                      : 1;
N    __IO uint32_t CB1E                      : 1;
X    volatile uint32_t CB1E                      : 1;
N    __IO uint32_t CB2E                      : 1;
X    volatile uint32_t CB2E                      : 1;
N    __IO uint32_t BIF                       : 1;
X    volatile uint32_t BIF                       : 1;
N    __IO uint32_t TIF                       : 1;
X    volatile uint32_t TIF                       : 1;
N} stc_tim3_mode23_ifr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t UIF                       : 1;
X    volatile uint32_t UIF                       : 1;
N    uint32_t RESERVED1                      : 1;
N    __IO uint32_t CA0F                      : 1;
X    volatile uint32_t CA0F                      : 1;
N    __IO uint32_t CA1F                      : 1;
X    volatile uint32_t CA1F                      : 1;
N    __IO uint32_t CA2F                      : 1;
X    volatile uint32_t CA2F                      : 1;
N    __IO uint32_t CB0F                      : 1;
X    volatile uint32_t CB0F                      : 1;
N    __IO uint32_t CB1F                      : 1;
X    volatile uint32_t CB1F                      : 1;
N    __IO uint32_t CB2F                      : 1;
X    volatile uint32_t CB2F                      : 1;
N    __IO uint32_t CA0E                      : 1;
X    volatile uint32_t CA0E                      : 1;
N    __IO uint32_t CA1E                      : 1;
X    volatile uint32_t CA1E                      : 1;
N    __IO uint32_t CA2E                      : 1;
X    volatile uint32_t CA2E                      : 1;
N    __IO uint32_t CB0E                      : 1;
X    volatile uint32_t CB0E                      : 1;
N    __IO uint32_t CB1E                      : 1;
X    volatile uint32_t CB1E                      : 1;
N    __IO uint32_t CB2E                      : 1;
X    volatile uint32_t CB2E                      : 1;
N    __IO uint32_t BIF                       : 1;
X    volatile uint32_t BIF                       : 1;
N    __IO uint32_t TIF                       : 1;
X    volatile uint32_t TIF                       : 1;
N} stc_tim3_mode23_iclr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t MMS                       : 3;
X    volatile uint32_t MMS                       : 3;
N    __IO uint32_t CCDS                      : 1;
X    volatile uint32_t CCDS                      : 1;
N    __IO uint32_t MSM                       : 1;
X    volatile uint32_t MSM                       : 1;
N    __IO uint32_t TS                        : 3;
X    volatile uint32_t TS                        : 3;
N    __IO uint32_t SMS                       : 3;
X    volatile uint32_t SMS                       : 3;
N    __IO uint32_t IA0S                      : 1;
X    volatile uint32_t IA0S                      : 1;
N    __IO uint32_t IB0S                      : 1;
X    volatile uint32_t IB0S                      : 1;
N} stc_tim3_mode23_mscr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t OCMA0_FLTA0               : 3;
X    volatile uint32_t OCMA0_FLTA0               : 3;
N    __IO uint32_t CCPA0                     : 1;
X    volatile uint32_t CCPA0                     : 1;
N    __IO uint32_t OCMB0_FLTB0               : 3;
X    volatile uint32_t OCMB0_FLTB0               : 3;
N    __IO uint32_t CCPB0                     : 1;
X    volatile uint32_t CCPB0                     : 1;
N    __IO uint32_t OCMA1_FLTA1               : 3;
X    volatile uint32_t OCMA1_FLTA1               : 3;
N    __IO uint32_t CCPA1                     : 1;
X    volatile uint32_t CCPA1                     : 1;
N    __IO uint32_t OCMB1_FLTB1               : 3;
X    volatile uint32_t OCMB1_FLTB1               : 3;
N    __IO uint32_t CCPB1                     : 1;
X    volatile uint32_t CCPB1                     : 1;
N    __IO uint32_t OCMA2_FLTA2               : 3;
X    volatile uint32_t OCMA2_FLTA2               : 3;
N    __IO uint32_t CCPA2                     : 1;
X    volatile uint32_t CCPA2                     : 1;
N    __IO uint32_t OCMB2_FLTB2               : 3;
X    volatile uint32_t OCMB2_FLTB2               : 3;
N    __IO uint32_t CCPB2                     : 1;
X    volatile uint32_t CCPB2                     : 1;
N    __IO uint32_t FLTBK                     : 3;
X    volatile uint32_t FLTBK                     : 3;
N    __IO uint32_t BKP                       : 1;
X    volatile uint32_t BKP                       : 1;
N    __IO uint32_t FLTET                     : 3;
X    volatile uint32_t FLTET                     : 3;
N    __IO uint32_t ETP                       : 1;
X    volatile uint32_t ETP                       : 1;
N} stc_tim3_mode23_fltr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t UEVE                      : 1;
X    volatile uint32_t UEVE                      : 1;
N    __IO uint32_t CMA0E                     : 1;
X    volatile uint32_t CMA0E                     : 1;
N    __IO uint32_t CMA1E                     : 1;
X    volatile uint32_t CMA1E                     : 1;
N    __IO uint32_t CMA2E                     : 1;
X    volatile uint32_t CMA2E                     : 1;
N    __IO uint32_t CMB0E                     : 1;
X    volatile uint32_t CMB0E                     : 1;
N    __IO uint32_t CMB1E                     : 1;
X    volatile uint32_t CMB1E                     : 1;
N    __IO uint32_t CMB2E                     : 1;
X    volatile uint32_t CMB2E                     : 1;
N    __IO uint32_t ADTE                      : 1;
X    volatile uint32_t ADTE                      : 1;
N} stc_tim3_mode23_adtr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CFA_CRA_BKSA              : 2;
X    volatile uint32_t CFA_CRA_BKSA              : 2;
N    __IO uint32_t CFB_CRB_BKSB              : 2;
X    volatile uint32_t CFB_CRB_BKSB              : 2;
N    __IO uint32_t CSA                       : 1;
X    volatile uint32_t CSA                       : 1;
N    __IO uint32_t CSB                       : 1;
X    volatile uint32_t CSB                       : 1;
N    __IO uint32_t BUFEA                     : 1;
X    volatile uint32_t BUFEA                     : 1;
N    __IO uint32_t BUFEB                     : 1;
X    volatile uint32_t BUFEB                     : 1;
N    __IO uint32_t CIEA                      : 1;
X    volatile uint32_t CIEA                      : 1;
N    __IO uint32_t CIEB                      : 1;
X    volatile uint32_t CIEB                      : 1;
N    __IO uint32_t CDEA                      : 1;
X    volatile uint32_t CDEA                      : 1;
N    __IO uint32_t CDEB                      : 1;
X    volatile uint32_t CDEB                      : 1;
N    __IO uint32_t CISB                      : 2;
X    volatile uint32_t CISB                      : 2;
N    __IO uint32_t CCGA                      : 1;
X    volatile uint32_t CCGA                      : 1;
N    __IO uint32_t CCGB                      : 1;
X    volatile uint32_t CCGB                      : 1;
N} stc_tim3_mode23_crch0_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CFA_CRA_BKSA              : 2;
X    volatile uint32_t CFA_CRA_BKSA              : 2;
N    __IO uint32_t CFB_CRB_BKSB              : 2;
X    volatile uint32_t CFB_CRB_BKSB              : 2;
N    __IO uint32_t CSA                       : 1;
X    volatile uint32_t CSA                       : 1;
N    __IO uint32_t CSB                       : 1;
X    volatile uint32_t CSB                       : 1;
N    __IO uint32_t BUFEA                     : 1;
X    volatile uint32_t BUFEA                     : 1;
N    __IO uint32_t BUFEB                     : 1;
X    volatile uint32_t BUFEB                     : 1;
N    __IO uint32_t CIEA                      : 1;
X    volatile uint32_t CIEA                      : 1;
N    __IO uint32_t CIEB                      : 1;
X    volatile uint32_t CIEB                      : 1;
N    __IO uint32_t CDEA                      : 1;
X    volatile uint32_t CDEA                      : 1;
N    __IO uint32_t CDEB                      : 1;
X    volatile uint32_t CDEB                      : 1;
N    __IO uint32_t CISB                      : 2;
X    volatile uint32_t CISB                      : 2;
N    __IO uint32_t CCGA                      : 1;
X    volatile uint32_t CCGA                      : 1;
N    __IO uint32_t CCGB                      : 1;
X    volatile uint32_t CCGB                      : 1;
N} stc_tim3_mode23_crch1_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CFA_CRA_BKSA              : 2;
X    volatile uint32_t CFA_CRA_BKSA              : 2;
N    __IO uint32_t CFB_CRB_BKSB              : 2;
X    volatile uint32_t CFB_CRB_BKSB              : 2;
N    __IO uint32_t CSA                       : 1;
X    volatile uint32_t CSA                       : 1;
N    __IO uint32_t CSB                       : 1;
X    volatile uint32_t CSB                       : 1;
N    __IO uint32_t BUFEA                     : 1;
X    volatile uint32_t BUFEA                     : 1;
N    __IO uint32_t BUFEB                     : 1;
X    volatile uint32_t BUFEB                     : 1;
N    __IO uint32_t CIEA                      : 1;
X    volatile uint32_t CIEA                      : 1;
N    __IO uint32_t CIEB                      : 1;
X    volatile uint32_t CIEB                      : 1;
N    __IO uint32_t CDEA                      : 1;
X    volatile uint32_t CDEA                      : 1;
N    __IO uint32_t CDEB                      : 1;
X    volatile uint32_t CDEB                      : 1;
N    __IO uint32_t CISB                      : 2;
X    volatile uint32_t CISB                      : 2;
N    __IO uint32_t CCGA                      : 1;
X    volatile uint32_t CCGA                      : 1;
N    __IO uint32_t CCGB                      : 1;
X    volatile uint32_t CCGB                      : 1;
N} stc_tim3_mode23_crch2_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t DTR                       : 8;
X    volatile uint32_t DTR                       : 8;
N    __IO uint32_t BKSEL                     : 1;
X    volatile uint32_t BKSEL                     : 1;
N    __IO uint32_t DTEN                      : 1;
X    volatile uint32_t DTEN                      : 1;
N    __IO uint32_t BKE                       : 1;
X    volatile uint32_t BKE                       : 1;
N    __IO uint32_t AOE                       : 1;
X    volatile uint32_t AOE                       : 1;
N    __IO uint32_t MOE                       : 1;
X    volatile uint32_t MOE                       : 1;
N    __IO uint32_t SAFEEN                    : 1;
X    volatile uint32_t SAFEEN                    : 1;
N    __IO uint32_t VC0E                      : 1;
X    volatile uint32_t VC0E                      : 1;
N    __IO uint32_t VC1E                      : 1;
X    volatile uint32_t VC1E                      : 1;
N} stc_tim3_mode23_dtr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t RCR                       : 8;
X    volatile uint32_t RCR                       : 8;
N} stc_tim3_mode23_rcr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t ARRDM                     :16;
X    volatile uint32_t ARRDM                     :16;
N} stc_tim3_mode23_arrdm_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CCR0A                     :16;
X    volatile uint32_t CCR0A                     :16;
N} stc_tim3_mode23_ccr0a_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CCR0B                     :16;
X    volatile uint32_t CCR0B                     :16;
N} stc_tim3_mode23_ccr0b_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CCR1A                     :16;
X    volatile uint32_t CCR1A                     :16;
N} stc_tim3_mode23_ccr1a_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CCR1B                     :16;
X    volatile uint32_t CCR1B                     :16;
N} stc_tim3_mode23_ccr1b_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CCR2A                     :16;
X    volatile uint32_t CCR2A                     :16;
N} stc_tim3_mode23_ccr2a_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CCR2B                     :16;
X    volatile uint32_t CCR2B                     :16;
N} stc_tim3_mode23_ccr2b_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CNT                       :16;
X    volatile uint32_t CNT                       :16;
N} stc_tim4_cnter_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PERA                      :16;
X    volatile uint32_t PERA                      :16;
N} stc_tim4_perar_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PERB                      :16;
X    volatile uint32_t PERB                      :16;
N} stc_tim4_perbr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t GCMA                      :16;
X    volatile uint32_t GCMA                      :16;
N} stc_tim4_gcmar_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t GCMB                      :16;
X    volatile uint32_t GCMB                      :16;
N} stc_tim4_gcmbr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t GCMC                      :16;
X    volatile uint32_t GCMC                      :16;
N} stc_tim4_gcmcr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t GCMD                      :16;
X    volatile uint32_t GCMD                      :16;
N} stc_tim4_gcmdr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SCMA                      :16;
X    volatile uint32_t SCMA                      :16;
N} stc_tim4_scmar_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SCMB                      :16;
X    volatile uint32_t SCMB                      :16;
N} stc_tim4_scmbr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t DTUA                      :16;
X    volatile uint32_t DTUA                      :16;
N} stc_tim4_dtuar_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t DTDA                      :16;
X    volatile uint32_t DTDA                      :16;
N} stc_tim4_dtdar_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t START                     : 1;
X    volatile uint32_t START                     : 1;
N    __IO uint32_t MODE                      : 3;
X    volatile uint32_t MODE                      : 3;
N    __IO uint32_t CKDIV                     : 3;
X    volatile uint32_t CKDIV                     : 3;
N    uint32_t RESERVED7                      : 1;
N    __IO uint32_t DIR                       : 1;
X    volatile uint32_t DIR                       : 1;
N    uint32_t RESERVED9                      : 7;
N    __IO uint32_t ZMSKREV                   : 1;
X    volatile uint32_t ZMSKREV                   : 1;
N    __IO uint32_t ZMSKPOS                   : 1;
X    volatile uint32_t ZMSKPOS                   : 1;
N    __IO uint32_t ZMSK                      : 2;
X    volatile uint32_t ZMSK                      : 2;
N} stc_tim4_gconr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t INTENA                    : 1;
X    volatile uint32_t INTENA                    : 1;
N    __IO uint32_t INTENB                    : 1;
X    volatile uint32_t INTENB                    : 1;
N    __IO uint32_t INTENC                    : 1;
X    volatile uint32_t INTENC                    : 1;
N    __IO uint32_t INTEND                    : 1;
X    volatile uint32_t INTEND                    : 1;
N    uint32_t RESERVED4                      : 2;
N    __IO uint32_t INTENOVF                  : 1;
X    volatile uint32_t INTENOVF                  : 1;
N    __IO uint32_t INTENUDF                  : 1;
X    volatile uint32_t INTENUDF                  : 1;
N    __IO uint32_t INTENDE                   : 1;
X    volatile uint32_t INTENDE                   : 1;
N    uint32_t RESERVED9                      : 5;
N    __IO uint32_t INTENSAML                 : 1;
X    volatile uint32_t INTENSAML                 : 1;
N    __IO uint32_t INTENSAMH                 : 1;
X    volatile uint32_t INTENSAMH                 : 1;
N    __IO uint32_t INTENSAU                  : 1;
X    volatile uint32_t INTENSAU                  : 1;
N    __IO uint32_t INTENSAD                  : 1;
X    volatile uint32_t INTENSAD                  : 1;
N    __IO uint32_t INTENSBU                  : 1;
X    volatile uint32_t INTENSBU                  : 1;
N    __IO uint32_t INTENSBD                  : 1;
X    volatile uint32_t INTENSBD                  : 1;
N} stc_tim4_iconr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CAPCA                     : 1;
X    volatile uint32_t CAPCA                     : 1;
N    __IO uint32_t STACA                     : 1;
X    volatile uint32_t STACA                     : 1;
N    __IO uint32_t STPCA                     : 1;
X    volatile uint32_t STPCA                     : 1;
N    __IO uint32_t STASTPSA                  : 1;
X    volatile uint32_t STASTPSA                  : 1;
N    __IO uint32_t CMPCA                     : 2;
X    volatile uint32_t CMPCA                     : 2;
N    __IO uint32_t PERCA                     : 2;
X    volatile uint32_t PERCA                     : 2;
N    __IO uint32_t OUTENA                    : 1;
X    volatile uint32_t OUTENA                    : 1;
N    __IO uint32_t DISSELA                   : 2;
X    volatile uint32_t DISSELA                   : 2;
N    __IO uint32_t DISVALA                   : 2;
X    volatile uint32_t DISVALA                   : 2;
N    uint32_t RESERVED13                     : 3;
N    __IO uint32_t CAPCB                     : 1;
X    volatile uint32_t CAPCB                     : 1;
N    __IO uint32_t STACB                     : 1;
X    volatile uint32_t STACB                     : 1;
N    __IO uint32_t STPCB                     : 1;
X    volatile uint32_t STPCB                     : 1;
N    __IO uint32_t STASTPSB                  : 1;
X    volatile uint32_t STASTPSB                  : 1;
N    __IO uint32_t CMPCB                     : 2;
X    volatile uint32_t CMPCB                     : 2;
N    __IO uint32_t PERCB                     : 2;
X    volatile uint32_t PERCB                     : 2;
N    __IO uint32_t OUTENB                    : 1;
X    volatile uint32_t OUTENB                    : 1;
N    __IO uint32_t DISSELB                   : 2;
X    volatile uint32_t DISSELB                   : 2;
N    __IO uint32_t DISVALB                   : 2;
X    volatile uint32_t DISVALB                   : 2;
N} stc_tim4_pconr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t BENA                      : 1;
X    volatile uint32_t BENA                      : 1;
N    uint32_t RESERVED1                      : 1;
N    __IO uint32_t BENB                      : 1;
X    volatile uint32_t BENB                      : 1;
N    uint32_t RESERVED3                      : 5;
N    __IO uint32_t BENP                      : 1;
X    volatile uint32_t BENP                      : 1;
N} stc_tim4_bconr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t DTCEN                     : 1;
X    volatile uint32_t DTCEN                     : 1;
N    uint32_t RESERVED1                      : 7;
N    __IO uint32_t SEPA                      : 1;
X    volatile uint32_t SEPA                      : 1;
N} stc_tim4_dconr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t NOFIENGA                  : 1;
X    volatile uint32_t NOFIENGA                  : 1;
N    __IO uint32_t NOFICKGA                  : 2;
X    volatile uint32_t NOFICKGA                  : 2;
N    uint32_t RESERVED3                      : 1;
N    __IO uint32_t NOFIENGB                  : 1;
X    volatile uint32_t NOFIENGB                  : 1;
N    __IO uint32_t NOFICKGB                  : 2;
X    volatile uint32_t NOFICKGB                  : 2;
N    uint32_t RESERVED7                      : 9;
N    __IO uint32_t NOFIENTA                  : 1;
X    volatile uint32_t NOFIENTA                  : 1;
N    __IO uint32_t NOFICKTA                  : 2;
X    volatile uint32_t NOFICKTA                  : 2;
N    uint32_t RESERVED19                     : 1;
N    __IO uint32_t NOFIENTB                  : 1;
X    volatile uint32_t NOFIENTB                  : 1;
N    __IO uint32_t NOFICKTB                  : 2;
X    volatile uint32_t NOFICKTB                  : 2;
N    uint32_t RESERVED23                     : 1;
N    __IO uint32_t NOFIENTC                  : 1;
X    volatile uint32_t NOFIENTC                  : 1;
N    __IO uint32_t NOFICKTC                  : 2;
X    volatile uint32_t NOFICKTC                  : 2;
N    uint32_t RESERVED27                     : 1;
N    __IO uint32_t NOFIENTD                  : 1;
X    volatile uint32_t NOFIENTD                  : 1;
N    __IO uint32_t NOFICKTD                  : 2;
X    volatile uint32_t NOFICKTD                  : 2;
N} stc_tim4_fconr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t GEPERIA                   : 1;
X    volatile uint32_t GEPERIA                   : 1;
N    __IO uint32_t GEPERIB                   : 1;
X    volatile uint32_t GEPERIB                   : 1;
N    __IO uint32_t GEPERIC                   : 1;
X    volatile uint32_t GEPERIC                   : 1;
N    __IO uint32_t GEPERID                   : 1;
X    volatile uint32_t GEPERID                   : 1;
N    uint32_t RESERVED4                      :12;
N    __IO uint32_t PCNTE                     : 2;
X    volatile uint32_t PCNTE                     : 2;
N    __IO uint32_t PCNTS                     : 3;
X    volatile uint32_t PCNTS                     : 3;
N} stc_tim4_vperr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CMAF                      : 1;
X    volatile uint32_t CMAF                      : 1;
N    __IO uint32_t CMBF                      : 1;
X    volatile uint32_t CMBF                      : 1;
N    __IO uint32_t CMCF                      : 1;
X    volatile uint32_t CMCF                      : 1;
N    __IO uint32_t CMDF                      : 1;
X    volatile uint32_t CMDF                      : 1;
N    uint32_t RESERVED4                      : 2;
N    __IO uint32_t OVFF                      : 1;
X    volatile uint32_t OVFF                      : 1;
N    __IO uint32_t UDFF                      : 1;
X    volatile uint32_t UDFF                      : 1;
N    __IO uint32_t DTEF                      : 1;
X    volatile uint32_t DTEF                      : 1;
N    __IO uint32_t CMSAUF                    : 1;
X    volatile uint32_t CMSAUF                    : 1;
N    __IO uint32_t CMSADF                    : 1;
X    volatile uint32_t CMSADF                    : 1;
N    __IO uint32_t CMSBUF                    : 1;
X    volatile uint32_t CMSBUF                    : 1;
N    __IO uint32_t CMSBDF                    : 1;
X    volatile uint32_t CMSBDF                    : 1;
N    uint32_t RESERVED13                     : 8;
N    __IO uint32_t VPERNUM                   : 3;
X    volatile uint32_t VPERNUM                   : 3;
N    uint32_t RESERVED24                     : 7;
N    __IO uint32_t DIRF                      : 1;
X    volatile uint32_t DIRF                      : 1;
N} stc_tim4_stflr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t HSTA0                     : 1;
X    volatile uint32_t HSTA0                     : 1;
N    __IO uint32_t HSTA1                     : 1;
X    volatile uint32_t HSTA1                     : 1;
N    __IO uint32_t HSTA2                     : 1;
X    volatile uint32_t HSTA2                     : 1;
N    __IO uint32_t HSTA3                     : 1;
X    volatile uint32_t HSTA3                     : 1;
N    __IO uint32_t HSTA4                     : 1;
X    volatile uint32_t HSTA4                     : 1;
N    __IO uint32_t HSTA5                     : 1;
X    volatile uint32_t HSTA5                     : 1;
N    __IO uint32_t HSTA6                     : 1;
X    volatile uint32_t HSTA6                     : 1;
N    __IO uint32_t HSTA7                     : 1;
X    volatile uint32_t HSTA7                     : 1;
N    __IO uint32_t HSTA8                     : 1;
X    volatile uint32_t HSTA8                     : 1;
N    __IO uint32_t HSTA9                     : 1;
X    volatile uint32_t HSTA9                     : 1;
N    __IO uint32_t HSTA10                    : 1;
X    volatile uint32_t HSTA10                    : 1;
N    __IO uint32_t HSTA11                    : 1;
X    volatile uint32_t HSTA11                    : 1;
N    __IO uint32_t HSTA12                    : 1;
X    volatile uint32_t HSTA12                    : 1;
N    __IO uint32_t HSTA13                    : 1;
X    volatile uint32_t HSTA13                    : 1;
N    __IO uint32_t HSTA14                    : 1;
X    volatile uint32_t HSTA14                    : 1;
N    __IO uint32_t HSTA15                    : 1;
X    volatile uint32_t HSTA15                    : 1;
N    uint32_t RESERVED16                     :15;
N    __IO uint32_t STARTS                    : 1;
X    volatile uint32_t STARTS                    : 1;
N} stc_tim4_hstar_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t HSTP0                     : 1;
X    volatile uint32_t HSTP0                     : 1;
N    __IO uint32_t HSTP1                     : 1;
X    volatile uint32_t HSTP1                     : 1;
N    __IO uint32_t HSTP2                     : 1;
X    volatile uint32_t HSTP2                     : 1;
N    __IO uint32_t HSTP3                     : 1;
X    volatile uint32_t HSTP3                     : 1;
N    __IO uint32_t HSTP4                     : 1;
X    volatile uint32_t HSTP4                     : 1;
N    __IO uint32_t HSTP5                     : 1;
X    volatile uint32_t HSTP5                     : 1;
N    __IO uint32_t HSTP6                     : 1;
X    volatile uint32_t HSTP6                     : 1;
N    __IO uint32_t HSTP7                     : 1;
X    volatile uint32_t HSTP7                     : 1;
N    __IO uint32_t HSTP8                     : 1;
X    volatile uint32_t HSTP8                     : 1;
N    __IO uint32_t HSTP9                     : 1;
X    volatile uint32_t HSTP9                     : 1;
N    __IO uint32_t HSTP10                    : 1;
X    volatile uint32_t HSTP10                    : 1;
N    __IO uint32_t HSTP11                    : 1;
X    volatile uint32_t HSTP11                    : 1;
N    __IO uint32_t HSTP12                    : 1;
X    volatile uint32_t HSTP12                    : 1;
N    __IO uint32_t HSTP13                    : 1;
X    volatile uint32_t HSTP13                    : 1;
N    __IO uint32_t HSTP14                    : 1;
X    volatile uint32_t HSTP14                    : 1;
N    __IO uint32_t HSTP15                    : 1;
X    volatile uint32_t HSTP15                    : 1;
N    uint32_t RESERVED16                     :15;
N    __IO uint32_t STOPS                     : 1;
X    volatile uint32_t STOPS                     : 1;
N} stc_tim4_hstpr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t HCEL0                     : 1;
X    volatile uint32_t HCEL0                     : 1;
N    __IO uint32_t HCEL1                     : 1;
X    volatile uint32_t HCEL1                     : 1;
N    __IO uint32_t HCEL2                     : 1;
X    volatile uint32_t HCEL2                     : 1;
N    __IO uint32_t HCEL3                     : 1;
X    volatile uint32_t HCEL3                     : 1;
N    __IO uint32_t HCEL4                     : 1;
X    volatile uint32_t HCEL4                     : 1;
N    __IO uint32_t HCEL5                     : 1;
X    volatile uint32_t HCEL5                     : 1;
N    __IO uint32_t HCEL6                     : 1;
X    volatile uint32_t HCEL6                     : 1;
N    __IO uint32_t HCEL7                     : 1;
X    volatile uint32_t HCEL7                     : 1;
N    __IO uint32_t HCEL8                     : 1;
X    volatile uint32_t HCEL8                     : 1;
N    __IO uint32_t HCEL9                     : 1;
X    volatile uint32_t HCEL9                     : 1;
N    __IO uint32_t HCEL10                    : 1;
X    volatile uint32_t HCEL10                    : 1;
N    __IO uint32_t HCEL11                    : 1;
X    volatile uint32_t HCEL11                    : 1;
N    __IO uint32_t HCEL12                    : 1;
X    volatile uint32_t HCEL12                    : 1;
N    __IO uint32_t HCEL13                    : 1;
X    volatile uint32_t HCEL13                    : 1;
N    __IO uint32_t HCEL14                    : 1;
X    volatile uint32_t HCEL14                    : 1;
N    __IO uint32_t HCEL15                    : 1;
X    volatile uint32_t HCEL15                    : 1;
N    uint32_t RESERVED16                     :15;
N    __IO uint32_t STARTS                    : 1;
X    volatile uint32_t STARTS                    : 1;
N} stc_tim4_hcelr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t HCPA0                     : 1;
X    volatile uint32_t HCPA0                     : 1;
N    __IO uint32_t HCPA1                     : 1;
X    volatile uint32_t HCPA1                     : 1;
N    __IO uint32_t HCPA2                     : 1;
X    volatile uint32_t HCPA2                     : 1;
N    __IO uint32_t HCPA3                     : 1;
X    volatile uint32_t HCPA3                     : 1;
N    __IO uint32_t HCPA4                     : 1;
X    volatile uint32_t HCPA4                     : 1;
N    __IO uint32_t HCPA5                     : 1;
X    volatile uint32_t HCPA5                     : 1;
N    __IO uint32_t HCPA6                     : 1;
X    volatile uint32_t HCPA6                     : 1;
N    __IO uint32_t HCPA7                     : 1;
X    volatile uint32_t HCPA7                     : 1;
N    __IO uint32_t HCPA8                     : 1;
X    volatile uint32_t HCPA8                     : 1;
N    __IO uint32_t HCPA9                     : 1;
X    volatile uint32_t HCPA9                     : 1;
N    __IO uint32_t HCPA10                    : 1;
X    volatile uint32_t HCPA10                    : 1;
N    __IO uint32_t HCPA11                    : 1;
X    volatile uint32_t HCPA11                    : 1;
N    __IO uint32_t HCPA12                    : 1;
X    volatile uint32_t HCPA12                    : 1;
N    __IO uint32_t HCPA13                    : 1;
X    volatile uint32_t HCPA13                    : 1;
N    __IO uint32_t HCPA14                    : 1;
X    volatile uint32_t HCPA14                    : 1;
N    __IO uint32_t HCPA15                    : 1;
X    volatile uint32_t HCPA15                    : 1;
N} stc_tim4_hcpar_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t HCPB0                     : 1;
X    volatile uint32_t HCPB0                     : 1;
N    __IO uint32_t HCPB1                     : 1;
X    volatile uint32_t HCPB1                     : 1;
N    __IO uint32_t HCPB2                     : 1;
X    volatile uint32_t HCPB2                     : 1;
N    __IO uint32_t HCPB3                     : 1;
X    volatile uint32_t HCPB3                     : 1;
N    __IO uint32_t HCPB4                     : 1;
X    volatile uint32_t HCPB4                     : 1;
N    __IO uint32_t HCPB5                     : 1;
X    volatile uint32_t HCPB5                     : 1;
N    __IO uint32_t HCPB6                     : 1;
X    volatile uint32_t HCPB6                     : 1;
N    __IO uint32_t HCPB7                     : 1;
X    volatile uint32_t HCPB7                     : 1;
N    __IO uint32_t HCPB8                     : 1;
X    volatile uint32_t HCPB8                     : 1;
N    __IO uint32_t HCPB9                     : 1;
X    volatile uint32_t HCPB9                     : 1;
N    __IO uint32_t HCPB10                    : 1;
X    volatile uint32_t HCPB10                    : 1;
N    __IO uint32_t HCPB11                    : 1;
X    volatile uint32_t HCPB11                    : 1;
N    __IO uint32_t HCPB12                    : 1;
X    volatile uint32_t HCPB12                    : 1;
N    __IO uint32_t HCPB13                    : 1;
X    volatile uint32_t HCPB13                    : 1;
N    __IO uint32_t HCPB14                    : 1;
X    volatile uint32_t HCPB14                    : 1;
N    __IO uint32_t HCPB15                    : 1;
X    volatile uint32_t HCPB15                    : 1;
N} stc_tim4_hcpbr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t HCUP0                     : 1;
X    volatile uint32_t HCUP0                     : 1;
N    __IO uint32_t HCUP1                     : 1;
X    volatile uint32_t HCUP1                     : 1;
N    __IO uint32_t HCUP2                     : 1;
X    volatile uint32_t HCUP2                     : 1;
N    __IO uint32_t HCUP3                     : 1;
X    volatile uint32_t HCUP3                     : 1;
N    __IO uint32_t HCUP4                     : 1;
X    volatile uint32_t HCUP4                     : 1;
N    __IO uint32_t HCUP5                     : 1;
X    volatile uint32_t HCUP5                     : 1;
N    __IO uint32_t HCUP6                     : 1;
X    volatile uint32_t HCUP6                     : 1;
N    __IO uint32_t HCUP7                     : 1;
X    volatile uint32_t HCUP7                     : 1;
N    __IO uint32_t HCUP8                     : 1;
X    volatile uint32_t HCUP8                     : 1;
N    __IO uint32_t HCUP9                     : 1;
X    volatile uint32_t HCUP9                     : 1;
N    __IO uint32_t HCUP10                    : 1;
X    volatile uint32_t HCUP10                    : 1;
N    __IO uint32_t HCUP11                    : 1;
X    volatile uint32_t HCUP11                    : 1;
N    __IO uint32_t HCUP12                    : 1;
X    volatile uint32_t HCUP12                    : 1;
N    __IO uint32_t HCUP13                    : 1;
X    volatile uint32_t HCUP13                    : 1;
N    __IO uint32_t HCUP14                    : 1;
X    volatile uint32_t HCUP14                    : 1;
N    __IO uint32_t HCUP15                    : 1;
X    volatile uint32_t HCUP15                    : 1;
N    __IO uint32_t HCUP16                    : 1;
X    volatile uint32_t HCUP16                    : 1;
N    __IO uint32_t HCUP17                    : 1;
X    volatile uint32_t HCUP17                    : 1;
N    __IO uint32_t HCUP18                    : 1;
X    volatile uint32_t HCUP18                    : 1;
N    __IO uint32_t HCUP19                    : 1;
X    volatile uint32_t HCUP19                    : 1;
N} stc_tim4_hcupr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t HCDO0                     : 1;
X    volatile uint32_t HCDO0                     : 1;
N    __IO uint32_t HCDO1                     : 1;
X    volatile uint32_t HCDO1                     : 1;
N    __IO uint32_t HCDO2                     : 1;
X    volatile uint32_t HCDO2                     : 1;
N    __IO uint32_t HCDO3                     : 1;
X    volatile uint32_t HCDO3                     : 1;
N    __IO uint32_t HCDO4                     : 1;
X    volatile uint32_t HCDO4                     : 1;
N    __IO uint32_t HCDO5                     : 1;
X    volatile uint32_t HCDO5                     : 1;
N    __IO uint32_t HCDO6                     : 1;
X    volatile uint32_t HCDO6                     : 1;
N    __IO uint32_t HCDO7                     : 1;
X    volatile uint32_t HCDO7                     : 1;
N    __IO uint32_t HCDO8                     : 1;
X    volatile uint32_t HCDO8                     : 1;
N    __IO uint32_t HCDO9                     : 1;
X    volatile uint32_t HCDO9                     : 1;
N    __IO uint32_t HCDO10                    : 1;
X    volatile uint32_t HCDO10                    : 1;
N    __IO uint32_t HCDO11                    : 1;
X    volatile uint32_t HCDO11                    : 1;
N    __IO uint32_t HCDO12                    : 1;
X    volatile uint32_t HCDO12                    : 1;
N    __IO uint32_t HCDO13                    : 1;
X    volatile uint32_t HCDO13                    : 1;
N    __IO uint32_t HCDO14                    : 1;
X    volatile uint32_t HCDO14                    : 1;
N    __IO uint32_t HCDO15                    : 1;
X    volatile uint32_t HCDO15                    : 1;
N    __IO uint32_t HCDO16                    : 1;
X    volatile uint32_t HCDO16                    : 1;
N    __IO uint32_t HCDO17                    : 1;
X    volatile uint32_t HCDO17                    : 1;
N    __IO uint32_t HCDO18                    : 1;
X    volatile uint32_t HCDO18                    : 1;
N    __IO uint32_t HCDO19                    : 1;
X    volatile uint32_t HCDO19                    : 1;
N} stc_tim4_hcdor_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CMAF                      : 1;
X    volatile uint32_t CMAF                      : 1;
N    __IO uint32_t CMBF                      : 1;
X    volatile uint32_t CMBF                      : 1;
N    __IO uint32_t CMCF                      : 1;
X    volatile uint32_t CMCF                      : 1;
N    __IO uint32_t CMDF                      : 1;
X    volatile uint32_t CMDF                      : 1;
N    uint32_t RESERVED4                      : 2;
N    __IO uint32_t OVFF                      : 1;
X    volatile uint32_t OVFF                      : 1;
N    __IO uint32_t UDFF                      : 1;
X    volatile uint32_t UDFF                      : 1;
N    __IO uint32_t DTEF                      : 1;
X    volatile uint32_t DTEF                      : 1;
N    uint32_t RESERVED9                      : 5;
N    __IO uint32_t SAMLF                     : 1;
X    volatile uint32_t SAMLF                     : 1;
N    __IO uint32_t SAMHF                     : 1;
X    volatile uint32_t SAMHF                     : 1;
N} stc_tim4_ifr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CMAC                      : 1;
X    volatile uint32_t CMAC                      : 1;
N    __IO uint32_t CMBC                      : 1;
X    volatile uint32_t CMBC                      : 1;
N    __IO uint32_t CMCC                      : 1;
X    volatile uint32_t CMCC                      : 1;
N    __IO uint32_t CMDC                      : 1;
X    volatile uint32_t CMDC                      : 1;
N    uint32_t RESERVED4                      : 2;
N    __IO uint32_t OVFC                      : 1;
X    volatile uint32_t OVFC                      : 1;
N    __IO uint32_t UDFC                      : 1;
X    volatile uint32_t UDFC                      : 1;
N    __IO uint32_t DTEC                      : 1;
X    volatile uint32_t DTEC                      : 1;
N    uint32_t RESERVED9                      : 5;
N    __IO uint32_t SAMLC                     : 1;
X    volatile uint32_t SAMLC                     : 1;
N    __IO uint32_t SAMHC                     : 1;
X    volatile uint32_t SAMHC                     : 1;
N} stc_tim4_iclr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CMAE                      : 1;
X    volatile uint32_t CMAE                      : 1;
N    __IO uint32_t CMBE                      : 1;
X    volatile uint32_t CMBE                      : 1;
N    __IO uint32_t CMCE                      : 1;
X    volatile uint32_t CMCE                      : 1;
N    __IO uint32_t CMDE                      : 1;
X    volatile uint32_t CMDE                      : 1;
N    uint32_t RESERVED4                      : 2;
N    __IO uint32_t OVFE                      : 1;
X    volatile uint32_t OVFE                      : 1;
N    __IO uint32_t UDFE                      : 1;
X    volatile uint32_t UDFE                      : 1;
N    __IO uint32_t DITENA                    : 1;
X    volatile uint32_t DITENA                    : 1;
N    __IO uint32_t DITENB                    : 1;
X    volatile uint32_t DITENB                    : 1;
N    __IO uint32_t DITENS                    : 1;
X    volatile uint32_t DITENS                    : 1;
N    __IO uint32_t CMSAE                     : 1;
X    volatile uint32_t CMSAE                     : 1;
N    __IO uint32_t CMSBE                     : 1;
X    volatile uint32_t CMSBE                     : 1;
N    __IO uint32_t DMA_G_CMA                 : 1;
X    volatile uint32_t DMA_G_CMA                 : 1;
N    __IO uint32_t DMA_G_CMB                 : 1;
X    volatile uint32_t DMA_G_CMB                 : 1;
N    __IO uint32_t DMA_G_CMC                 : 1;
X    volatile uint32_t DMA_G_CMC                 : 1;
N    __IO uint32_t DMA_G_CMD                 : 1;
X    volatile uint32_t DMA_G_CMD                 : 1;
N    uint32_t RESERVED17                     : 2;
N    __IO uint32_t DMA_G_OVF                 : 1;
X    volatile uint32_t DMA_G_OVF                 : 1;
N    __IO uint32_t DMA_G_UDF                 : 1;
X    volatile uint32_t DMA_G_UDF                 : 1;
N    __IO uint32_t DMA_S_CMA                 : 1;
X    volatile uint32_t DMA_S_CMA                 : 1;
N    __IO uint32_t DMA_S_CMB                 : 1;
X    volatile uint32_t DMA_S_CMB                 : 1;
N} stc_tim4_cr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t FBRAKE                    : 1;
X    volatile uint32_t FBRAKE                    : 1;
N    __IO uint32_t FSAME                     : 1;
X    volatile uint32_t FSAME                     : 1;
N    __IO uint32_t BFILTS                    : 2;
X    volatile uint32_t BFILTS                    : 2;
N    __IO uint32_t BFILTEN                   : 1;
X    volatile uint32_t BFILTEN                   : 1;
N    uint32_t RESERVED5                      : 2;
N    __IO uint32_t SOFTBK                    : 1;
X    volatile uint32_t SOFTBK                    : 1;
N    __IO uint32_t SML0                      : 1;
X    volatile uint32_t SML0                      : 1;
N    __IO uint32_t SML1                      : 1;
X    volatile uint32_t SML1                      : 1;
N    __IO uint32_t SML2                      : 1;
X    volatile uint32_t SML2                      : 1;
N    __IO uint32_t SMH0                      : 1;
X    volatile uint32_t SMH0                      : 1;
N    __IO uint32_t SMH1                      : 1;
X    volatile uint32_t SMH1                      : 1;
N    __IO uint32_t SMH2                      : 1;
X    volatile uint32_t SMH2                      : 1;
N} stc_tim4_aossr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t FBRAKE                    : 1;
X    volatile uint32_t FBRAKE                    : 1;
N    __IO uint32_t FSAME                     : 1;
X    volatile uint32_t FSAME                     : 1;
N} stc_tim4_aoscl_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t EN0                       : 1;
X    volatile uint32_t EN0                       : 1;
N    __IO uint32_t EN1                       : 1;
X    volatile uint32_t EN1                       : 1;
N    __IO uint32_t EN2                       : 1;
X    volatile uint32_t EN2                       : 1;
N    __IO uint32_t EN3                       : 1;
X    volatile uint32_t EN3                       : 1;
N    __IO uint32_t EN4                       : 1;
X    volatile uint32_t EN4                       : 1;
N    __IO uint32_t EN5                       : 1;
X    volatile uint32_t EN5                       : 1;
N    __IO uint32_t EN6                       : 1;
X    volatile uint32_t EN6                       : 1;
N    __IO uint32_t EN7                       : 1;
X    volatile uint32_t EN7                       : 1;
N    __IO uint32_t EN8                       : 1;
X    volatile uint32_t EN8                       : 1;
N    __IO uint32_t EN9                       : 1;
X    volatile uint32_t EN9                       : 1;
N    __IO uint32_t EN10                      : 1;
X    volatile uint32_t EN10                      : 1;
N    __IO uint32_t EN11                      : 1;
X    volatile uint32_t EN11                      : 1;
N    __IO uint32_t EN12                      : 1;
X    volatile uint32_t EN12                      : 1;
N    __IO uint32_t EN13                      : 1;
X    volatile uint32_t EN13                      : 1;
N    __IO uint32_t EN14                      : 1;
X    volatile uint32_t EN14                      : 1;
N    __IO uint32_t EN15                      : 1;
X    volatile uint32_t EN15                      : 1;
N} stc_tim4_ptbks_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t TRIGAS                    : 4;
X    volatile uint32_t TRIGAS                    : 4;
N    __IO uint32_t TRIGBS                    : 4;
X    volatile uint32_t TRIGBS                    : 4;
N    __IO uint32_t TRIGCS                    : 4;
X    volatile uint32_t TRIGCS                    : 4;
N    __IO uint32_t TRIGDS                    : 4;
X    volatile uint32_t TRIGDS                    : 4;
N} stc_tim4_ttrig_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t IAOS0S                    : 4;
X    volatile uint32_t IAOS0S                    : 4;
N    __IO uint32_t IAOS1S                    : 4;
X    volatile uint32_t IAOS1S                    : 4;
N    __IO uint32_t IAOS2S                    : 4;
X    volatile uint32_t IAOS2S                    : 4;
N    __IO uint32_t IAOS3S                    : 4;
X    volatile uint32_t IAOS3S                    : 4;
N} stc_tim4_itrig_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t POL0                      : 1;
X    volatile uint32_t POL0                      : 1;
N    __IO uint32_t POL1                      : 1;
X    volatile uint32_t POL1                      : 1;
N    __IO uint32_t POL2                      : 1;
X    volatile uint32_t POL2                      : 1;
N    __IO uint32_t POL3                      : 1;
X    volatile uint32_t POL3                      : 1;
N    __IO uint32_t POL4                      : 1;
X    volatile uint32_t POL4                      : 1;
N    __IO uint32_t POL5                      : 1;
X    volatile uint32_t POL5                      : 1;
N    __IO uint32_t POL6                      : 1;
X    volatile uint32_t POL6                      : 1;
N    __IO uint32_t POL7                      : 1;
X    volatile uint32_t POL7                      : 1;
N    __IO uint32_t POL8                      : 1;
X    volatile uint32_t POL8                      : 1;
N    __IO uint32_t POL9                      : 1;
X    volatile uint32_t POL9                      : 1;
N    __IO uint32_t POL10                     : 1;
X    volatile uint32_t POL10                     : 1;
N    __IO uint32_t POL11                     : 1;
X    volatile uint32_t POL11                     : 1;
N    __IO uint32_t POL12                     : 1;
X    volatile uint32_t POL12                     : 1;
N    __IO uint32_t POL13                     : 1;
X    volatile uint32_t POL13                     : 1;
N    __IO uint32_t POL14                     : 1;
X    volatile uint32_t POL14                     : 1;
N    __IO uint32_t POL15                     : 1;
X    volatile uint32_t POL15                     : 1;
N} stc_tim4_ptbkp_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SSTA0                     : 1;
X    volatile uint32_t SSTA0                     : 1;
N    __IO uint32_t SSTA1                     : 1;
X    volatile uint32_t SSTA1                     : 1;
N    __IO uint32_t SSTA2                     : 1;
X    volatile uint32_t SSTA2                     : 1;
N} stc_tim4_sstar_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SSTP0                     : 1;
X    volatile uint32_t SSTP0                     : 1;
N    __IO uint32_t SSTP1                     : 1;
X    volatile uint32_t SSTP1                     : 1;
N    __IO uint32_t SSTP2                     : 1;
X    volatile uint32_t SSTP2                     : 1;
N} stc_tim4_sstpr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SCLR0                     : 1;
X    volatile uint32_t SCLR0                     : 1;
N    __IO uint32_t SCLR1                     : 1;
X    volatile uint32_t SCLR1                     : 1;
N    __IO uint32_t SCLR2                     : 1;
X    volatile uint32_t SCLR2                     : 1;
N} stc_tim4_sclrr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CNT                       :16;
X    volatile uint32_t CNT                       :16;
N} stc_tim5_cnter_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PERA                      :16;
X    volatile uint32_t PERA                      :16;
N} stc_tim5_perar_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PERB                      :16;
X    volatile uint32_t PERB                      :16;
N} stc_tim5_perbr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t GCMA                      :16;
X    volatile uint32_t GCMA                      :16;
N} stc_tim5_gcmar_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t GCMB                      :16;
X    volatile uint32_t GCMB                      :16;
N} stc_tim5_gcmbr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t GCMC                      :16;
X    volatile uint32_t GCMC                      :16;
N} stc_tim5_gcmcr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t GCMD                      :16;
X    volatile uint32_t GCMD                      :16;
N} stc_tim5_gcmdr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SCMA                      :16;
X    volatile uint32_t SCMA                      :16;
N} stc_tim5_scmar_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SCMB                      :16;
X    volatile uint32_t SCMB                      :16;
N} stc_tim5_scmbr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t DTUA                      :16;
X    volatile uint32_t DTUA                      :16;
N} stc_tim5_dtuar_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t DTDA                      :16;
X    volatile uint32_t DTDA                      :16;
N} stc_tim5_dtdar_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t START                     : 1;
X    volatile uint32_t START                     : 1;
N    __IO uint32_t MODE                      : 3;
X    volatile uint32_t MODE                      : 3;
N    __IO uint32_t CKDIV                     : 3;
X    volatile uint32_t CKDIV                     : 3;
N    uint32_t RESERVED7                      : 1;
N    __IO uint32_t DIR                       : 1;
X    volatile uint32_t DIR                       : 1;
N    uint32_t RESERVED9                      : 7;
N    __IO uint32_t ZMSKREV                   : 1;
X    volatile uint32_t ZMSKREV                   : 1;
N    __IO uint32_t ZMSKPOS                   : 1;
X    volatile uint32_t ZMSKPOS                   : 1;
N    __IO uint32_t ZMSK                      : 2;
X    volatile uint32_t ZMSK                      : 2;
N} stc_tim5_gconr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t INTENA                    : 1;
X    volatile uint32_t INTENA                    : 1;
N    __IO uint32_t INTENB                    : 1;
X    volatile uint32_t INTENB                    : 1;
N    __IO uint32_t INTENC                    : 1;
X    volatile uint32_t INTENC                    : 1;
N    __IO uint32_t INTEND                    : 1;
X    volatile uint32_t INTEND                    : 1;
N    uint32_t RESERVED4                      : 2;
N    __IO uint32_t INTENOVF                  : 1;
X    volatile uint32_t INTENOVF                  : 1;
N    __IO uint32_t INTENUDF                  : 1;
X    volatile uint32_t INTENUDF                  : 1;
N    __IO uint32_t INTENDE                   : 1;
X    volatile uint32_t INTENDE                   : 1;
N    uint32_t RESERVED9                      : 5;
N    __IO uint32_t INTENSAML                 : 1;
X    volatile uint32_t INTENSAML                 : 1;
N    __IO uint32_t INTENSAMH                 : 1;
X    volatile uint32_t INTENSAMH                 : 1;
N    __IO uint32_t INTENSAU                  : 1;
X    volatile uint32_t INTENSAU                  : 1;
N    __IO uint32_t INTENSAD                  : 1;
X    volatile uint32_t INTENSAD                  : 1;
N    __IO uint32_t INTENSBU                  : 1;
X    volatile uint32_t INTENSBU                  : 1;
N    __IO uint32_t INTENSBD                  : 1;
X    volatile uint32_t INTENSBD                  : 1;
N} stc_tim5_iconr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CAPCA                     : 1;
X    volatile uint32_t CAPCA                     : 1;
N    __IO uint32_t STACA                     : 1;
X    volatile uint32_t STACA                     : 1;
N    __IO uint32_t STPCA                     : 1;
X    volatile uint32_t STPCA                     : 1;
N    __IO uint32_t STASTPSA                  : 1;
X    volatile uint32_t STASTPSA                  : 1;
N    __IO uint32_t CMPCA                     : 2;
X    volatile uint32_t CMPCA                     : 2;
N    __IO uint32_t PERCA                     : 2;
X    volatile uint32_t PERCA                     : 2;
N    __IO uint32_t OUTENA                    : 1;
X    volatile uint32_t OUTENA                    : 1;
N    __IO uint32_t DISSELA                   : 2;
X    volatile uint32_t DISSELA                   : 2;
N    __IO uint32_t DISVALA                   : 2;
X    volatile uint32_t DISVALA                   : 2;
N    uint32_t RESERVED13                     : 3;
N    __IO uint32_t CAPCB                     : 1;
X    volatile uint32_t CAPCB                     : 1;
N    __IO uint32_t STACB                     : 1;
X    volatile uint32_t STACB                     : 1;
N    __IO uint32_t STPCB                     : 1;
X    volatile uint32_t STPCB                     : 1;
N    __IO uint32_t STASTPSB                  : 1;
X    volatile uint32_t STASTPSB                  : 1;
N    __IO uint32_t CMPCB                     : 2;
X    volatile uint32_t CMPCB                     : 2;
N    __IO uint32_t PERCB                     : 2;
X    volatile uint32_t PERCB                     : 2;
N    __IO uint32_t OUTENB                    : 1;
X    volatile uint32_t OUTENB                    : 1;
N    __IO uint32_t DISSELB                   : 2;
X    volatile uint32_t DISSELB                   : 2;
N    __IO uint32_t DISVALB                   : 2;
X    volatile uint32_t DISVALB                   : 2;
N} stc_tim5_pconr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t BENA                      : 1;
X    volatile uint32_t BENA                      : 1;
N    uint32_t RESERVED1                      : 1;
N    __IO uint32_t BENB                      : 1;
X    volatile uint32_t BENB                      : 1;
N    uint32_t RESERVED3                      : 5;
N    __IO uint32_t BENP                      : 1;
X    volatile uint32_t BENP                      : 1;
N} stc_tim5_bconr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t DTCEN                     : 1;
X    volatile uint32_t DTCEN                     : 1;
N    uint32_t RESERVED1                      : 7;
N    __IO uint32_t SEPA                      : 1;
X    volatile uint32_t SEPA                      : 1;
N} stc_tim5_dconr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t NOFIENGA                  : 1;
X    volatile uint32_t NOFIENGA                  : 1;
N    __IO uint32_t NOFICKGA                  : 2;
X    volatile uint32_t NOFICKGA                  : 2;
N    uint32_t RESERVED3                      : 1;
N    __IO uint32_t NOFIENGB                  : 1;
X    volatile uint32_t NOFIENGB                  : 1;
N    __IO uint32_t NOFICKGB                  : 2;
X    volatile uint32_t NOFICKGB                  : 2;
N    uint32_t RESERVED7                      : 9;
N    __IO uint32_t NOFIENTA                  : 1;
X    volatile uint32_t NOFIENTA                  : 1;
N    __IO uint32_t NOFICKTA                  : 2;
X    volatile uint32_t NOFICKTA                  : 2;
N    uint32_t RESERVED19                     : 1;
N    __IO uint32_t NOFIENTB                  : 1;
X    volatile uint32_t NOFIENTB                  : 1;
N    __IO uint32_t NOFICKTB                  : 2;
X    volatile uint32_t NOFICKTB                  : 2;
N    uint32_t RESERVED23                     : 1;
N    __IO uint32_t NOFIENTC                  : 1;
X    volatile uint32_t NOFIENTC                  : 1;
N    __IO uint32_t NOFICKTC                  : 2;
X    volatile uint32_t NOFICKTC                  : 2;
N    uint32_t RESERVED27                     : 1;
N    __IO uint32_t NOFIENTD                  : 1;
X    volatile uint32_t NOFIENTD                  : 1;
N    __IO uint32_t NOFICKTD                  : 2;
X    volatile uint32_t NOFICKTD                  : 2;
N} stc_tim5_fconr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t GEPERIA                   : 1;
X    volatile uint32_t GEPERIA                   : 1;
N    __IO uint32_t GEPERIB                   : 1;
X    volatile uint32_t GEPERIB                   : 1;
N    __IO uint32_t GEPERIC                   : 1;
X    volatile uint32_t GEPERIC                   : 1;
N    __IO uint32_t GEPERID                   : 1;
X    volatile uint32_t GEPERID                   : 1;
N    uint32_t RESERVED4                      :12;
N    __IO uint32_t PCNTE                     : 2;
X    volatile uint32_t PCNTE                     : 2;
N    __IO uint32_t PCNTS                     : 3;
X    volatile uint32_t PCNTS                     : 3;
N} stc_tim5_vperr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CMAF                      : 1;
X    volatile uint32_t CMAF                      : 1;
N    __IO uint32_t CMBF                      : 1;
X    volatile uint32_t CMBF                      : 1;
N    __IO uint32_t CMCF                      : 1;
X    volatile uint32_t CMCF                      : 1;
N    __IO uint32_t CMDF                      : 1;
X    volatile uint32_t CMDF                      : 1;
N    uint32_t RESERVED4                      : 2;
N    __IO uint32_t OVFF                      : 1;
X    volatile uint32_t OVFF                      : 1;
N    __IO uint32_t UDFF                      : 1;
X    volatile uint32_t UDFF                      : 1;
N    __IO uint32_t DTEF                      : 1;
X    volatile uint32_t DTEF                      : 1;
N    __IO uint32_t CMSAUF                    : 1;
X    volatile uint32_t CMSAUF                    : 1;
N    __IO uint32_t CMSADF                    : 1;
X    volatile uint32_t CMSADF                    : 1;
N    __IO uint32_t CMSBUF                    : 1;
X    volatile uint32_t CMSBUF                    : 1;
N    __IO uint32_t CMSBDF                    : 1;
X    volatile uint32_t CMSBDF                    : 1;
N    uint32_t RESERVED13                     : 8;
N    __IO uint32_t VPERNUM                   : 3;
X    volatile uint32_t VPERNUM                   : 3;
N    uint32_t RESERVED24                     : 7;
N    __IO uint32_t DIRF                      : 1;
X    volatile uint32_t DIRF                      : 1;
N} stc_tim5_stflr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t HSTA0                     : 1;
X    volatile uint32_t HSTA0                     : 1;
N    __IO uint32_t HSTA1                     : 1;
X    volatile uint32_t HSTA1                     : 1;
N    __IO uint32_t HSTA2                     : 1;
X    volatile uint32_t HSTA2                     : 1;
N    __IO uint32_t HSTA3                     : 1;
X    volatile uint32_t HSTA3                     : 1;
N    __IO uint32_t HSTA4                     : 1;
X    volatile uint32_t HSTA4                     : 1;
N    __IO uint32_t HSTA5                     : 1;
X    volatile uint32_t HSTA5                     : 1;
N    __IO uint32_t HSTA6                     : 1;
X    volatile uint32_t HSTA6                     : 1;
N    __IO uint32_t HSTA7                     : 1;
X    volatile uint32_t HSTA7                     : 1;
N    __IO uint32_t HSTA8                     : 1;
X    volatile uint32_t HSTA8                     : 1;
N    __IO uint32_t HSTA9                     : 1;
X    volatile uint32_t HSTA9                     : 1;
N    __IO uint32_t HSTA10                    : 1;
X    volatile uint32_t HSTA10                    : 1;
N    __IO uint32_t HSTA11                    : 1;
X    volatile uint32_t HSTA11                    : 1;
N    __IO uint32_t HSTA12                    : 1;
X    volatile uint32_t HSTA12                    : 1;
N    __IO uint32_t HSTA13                    : 1;
X    volatile uint32_t HSTA13                    : 1;
N    __IO uint32_t HSTA14                    : 1;
X    volatile uint32_t HSTA14                    : 1;
N    __IO uint32_t HSTA15                    : 1;
X    volatile uint32_t HSTA15                    : 1;
N    uint32_t RESERVED16                     :15;
N    __IO uint32_t STARTS                    : 1;
X    volatile uint32_t STARTS                    : 1;
N} stc_tim5_hstar_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t HSTP0                     : 1;
X    volatile uint32_t HSTP0                     : 1;
N    __IO uint32_t HSTP1                     : 1;
X    volatile uint32_t HSTP1                     : 1;
N    __IO uint32_t HSTP2                     : 1;
X    volatile uint32_t HSTP2                     : 1;
N    __IO uint32_t HSTP3                     : 1;
X    volatile uint32_t HSTP3                     : 1;
N    __IO uint32_t HSTP4                     : 1;
X    volatile uint32_t HSTP4                     : 1;
N    __IO uint32_t HSTP5                     : 1;
X    volatile uint32_t HSTP5                     : 1;
N    __IO uint32_t HSTP6                     : 1;
X    volatile uint32_t HSTP6                     : 1;
N    __IO uint32_t HSTP7                     : 1;
X    volatile uint32_t HSTP7                     : 1;
N    __IO uint32_t HSTP8                     : 1;
X    volatile uint32_t HSTP8                     : 1;
N    __IO uint32_t HSTP9                     : 1;
X    volatile uint32_t HSTP9                     : 1;
N    __IO uint32_t HSTP10                    : 1;
X    volatile uint32_t HSTP10                    : 1;
N    __IO uint32_t HSTP11                    : 1;
X    volatile uint32_t HSTP11                    : 1;
N    __IO uint32_t HSTP12                    : 1;
X    volatile uint32_t HSTP12                    : 1;
N    __IO uint32_t HSTP13                    : 1;
X    volatile uint32_t HSTP13                    : 1;
N    __IO uint32_t HSTP14                    : 1;
X    volatile uint32_t HSTP14                    : 1;
N    __IO uint32_t HSTP15                    : 1;
X    volatile uint32_t HSTP15                    : 1;
N    uint32_t RESERVED16                     :15;
N    __IO uint32_t STOPS                     : 1;
X    volatile uint32_t STOPS                     : 1;
N} stc_tim5_hstpr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t HCEL0                     : 1;
X    volatile uint32_t HCEL0                     : 1;
N    __IO uint32_t HCEL1                     : 1;
X    volatile uint32_t HCEL1                     : 1;
N    __IO uint32_t HCEL2                     : 1;
X    volatile uint32_t HCEL2                     : 1;
N    __IO uint32_t HCEL3                     : 1;
X    volatile uint32_t HCEL3                     : 1;
N    __IO uint32_t HCEL4                     : 1;
X    volatile uint32_t HCEL4                     : 1;
N    __IO uint32_t HCEL5                     : 1;
X    volatile uint32_t HCEL5                     : 1;
N    __IO uint32_t HCEL6                     : 1;
X    volatile uint32_t HCEL6                     : 1;
N    __IO uint32_t HCEL7                     : 1;
X    volatile uint32_t HCEL7                     : 1;
N    __IO uint32_t HCEL8                     : 1;
X    volatile uint32_t HCEL8                     : 1;
N    __IO uint32_t HCEL9                     : 1;
X    volatile uint32_t HCEL9                     : 1;
N    __IO uint32_t HCEL10                    : 1;
X    volatile uint32_t HCEL10                    : 1;
N    __IO uint32_t HCEL11                    : 1;
X    volatile uint32_t HCEL11                    : 1;
N    __IO uint32_t HCEL12                    : 1;
X    volatile uint32_t HCEL12                    : 1;
N    __IO uint32_t HCEL13                    : 1;
X    volatile uint32_t HCEL13                    : 1;
N    __IO uint32_t HCEL14                    : 1;
X    volatile uint32_t HCEL14                    : 1;
N    __IO uint32_t HCEL15                    : 1;
X    volatile uint32_t HCEL15                    : 1;
N    uint32_t RESERVED16                     :15;
N    __IO uint32_t STARTS                    : 1;
X    volatile uint32_t STARTS                    : 1;
N} stc_tim5_hcelr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t HCPA0                     : 1;
X    volatile uint32_t HCPA0                     : 1;
N    __IO uint32_t HCPA1                     : 1;
X    volatile uint32_t HCPA1                     : 1;
N    __IO uint32_t HCPA2                     : 1;
X    volatile uint32_t HCPA2                     : 1;
N    __IO uint32_t HCPA3                     : 1;
X    volatile uint32_t HCPA3                     : 1;
N    __IO uint32_t HCPA4                     : 1;
X    volatile uint32_t HCPA4                     : 1;
N    __IO uint32_t HCPA5                     : 1;
X    volatile uint32_t HCPA5                     : 1;
N    __IO uint32_t HCPA6                     : 1;
X    volatile uint32_t HCPA6                     : 1;
N    __IO uint32_t HCPA7                     : 1;
X    volatile uint32_t HCPA7                     : 1;
N    __IO uint32_t HCPA8                     : 1;
X    volatile uint32_t HCPA8                     : 1;
N    __IO uint32_t HCPA9                     : 1;
X    volatile uint32_t HCPA9                     : 1;
N    __IO uint32_t HCPA10                    : 1;
X    volatile uint32_t HCPA10                    : 1;
N    __IO uint32_t HCPA11                    : 1;
X    volatile uint32_t HCPA11                    : 1;
N    __IO uint32_t HCPA12                    : 1;
X    volatile uint32_t HCPA12                    : 1;
N    __IO uint32_t HCPA13                    : 1;
X    volatile uint32_t HCPA13                    : 1;
N    __IO uint32_t HCPA14                    : 1;
X    volatile uint32_t HCPA14                    : 1;
N    __IO uint32_t HCPA15                    : 1;
X    volatile uint32_t HCPA15                    : 1;
N} stc_tim5_hcpar_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t HCPB0                     : 1;
X    volatile uint32_t HCPB0                     : 1;
N    __IO uint32_t HCPB1                     : 1;
X    volatile uint32_t HCPB1                     : 1;
N    __IO uint32_t HCPB2                     : 1;
X    volatile uint32_t HCPB2                     : 1;
N    __IO uint32_t HCPB3                     : 1;
X    volatile uint32_t HCPB3                     : 1;
N    __IO uint32_t HCPB4                     : 1;
X    volatile uint32_t HCPB4                     : 1;
N    __IO uint32_t HCPB5                     : 1;
X    volatile uint32_t HCPB5                     : 1;
N    __IO uint32_t HCPB6                     : 1;
X    volatile uint32_t HCPB6                     : 1;
N    __IO uint32_t HCPB7                     : 1;
X    volatile uint32_t HCPB7                     : 1;
N    __IO uint32_t HCPB8                     : 1;
X    volatile uint32_t HCPB8                     : 1;
N    __IO uint32_t HCPB9                     : 1;
X    volatile uint32_t HCPB9                     : 1;
N    __IO uint32_t HCPB10                    : 1;
X    volatile uint32_t HCPB10                    : 1;
N    __IO uint32_t HCPB11                    : 1;
X    volatile uint32_t HCPB11                    : 1;
N    __IO uint32_t HCPB12                    : 1;
X    volatile uint32_t HCPB12                    : 1;
N    __IO uint32_t HCPB13                    : 1;
X    volatile uint32_t HCPB13                    : 1;
N    __IO uint32_t HCPB14                    : 1;
X    volatile uint32_t HCPB14                    : 1;
N    __IO uint32_t HCPB15                    : 1;
X    volatile uint32_t HCPB15                    : 1;
N} stc_tim5_hcpbr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t HCUP0                     : 1;
X    volatile uint32_t HCUP0                     : 1;
N    __IO uint32_t HCUP1                     : 1;
X    volatile uint32_t HCUP1                     : 1;
N    __IO uint32_t HCUP2                     : 1;
X    volatile uint32_t HCUP2                     : 1;
N    __IO uint32_t HCUP3                     : 1;
X    volatile uint32_t HCUP3                     : 1;
N    __IO uint32_t HCUP4                     : 1;
X    volatile uint32_t HCUP4                     : 1;
N    __IO uint32_t HCUP5                     : 1;
X    volatile uint32_t HCUP5                     : 1;
N    __IO uint32_t HCUP6                     : 1;
X    volatile uint32_t HCUP6                     : 1;
N    __IO uint32_t HCUP7                     : 1;
X    volatile uint32_t HCUP7                     : 1;
N    __IO uint32_t HCUP8                     : 1;
X    volatile uint32_t HCUP8                     : 1;
N    __IO uint32_t HCUP9                     : 1;
X    volatile uint32_t HCUP9                     : 1;
N    __IO uint32_t HCUP10                    : 1;
X    volatile uint32_t HCUP10                    : 1;
N    __IO uint32_t HCUP11                    : 1;
X    volatile uint32_t HCUP11                    : 1;
N    __IO uint32_t HCUP12                    : 1;
X    volatile uint32_t HCUP12                    : 1;
N    __IO uint32_t HCUP13                    : 1;
X    volatile uint32_t HCUP13                    : 1;
N    __IO uint32_t HCUP14                    : 1;
X    volatile uint32_t HCUP14                    : 1;
N    __IO uint32_t HCUP15                    : 1;
X    volatile uint32_t HCUP15                    : 1;
N    __IO uint32_t HCUP16                    : 1;
X    volatile uint32_t HCUP16                    : 1;
N    __IO uint32_t HCUP17                    : 1;
X    volatile uint32_t HCUP17                    : 1;
N    __IO uint32_t HCUP18                    : 1;
X    volatile uint32_t HCUP18                    : 1;
N    __IO uint32_t HCUP19                    : 1;
X    volatile uint32_t HCUP19                    : 1;
N} stc_tim5_hcupr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t HCDO0                     : 1;
X    volatile uint32_t HCDO0                     : 1;
N    __IO uint32_t HCDO1                     : 1;
X    volatile uint32_t HCDO1                     : 1;
N    __IO uint32_t HCDO2                     : 1;
X    volatile uint32_t HCDO2                     : 1;
N    __IO uint32_t HCDO3                     : 1;
X    volatile uint32_t HCDO3                     : 1;
N    __IO uint32_t HCDO4                     : 1;
X    volatile uint32_t HCDO4                     : 1;
N    __IO uint32_t HCDO5                     : 1;
X    volatile uint32_t HCDO5                     : 1;
N    __IO uint32_t HCDO6                     : 1;
X    volatile uint32_t HCDO6                     : 1;
N    __IO uint32_t HCDO7                     : 1;
X    volatile uint32_t HCDO7                     : 1;
N    __IO uint32_t HCDO8                     : 1;
X    volatile uint32_t HCDO8                     : 1;
N    __IO uint32_t HCDO9                     : 1;
X    volatile uint32_t HCDO9                     : 1;
N    __IO uint32_t HCDO10                    : 1;
X    volatile uint32_t HCDO10                    : 1;
N    __IO uint32_t HCDO11                    : 1;
X    volatile uint32_t HCDO11                    : 1;
N    __IO uint32_t HCDO12                    : 1;
X    volatile uint32_t HCDO12                    : 1;
N    __IO uint32_t HCDO13                    : 1;
X    volatile uint32_t HCDO13                    : 1;
N    __IO uint32_t HCDO14                    : 1;
X    volatile uint32_t HCDO14                    : 1;
N    __IO uint32_t HCDO15                    : 1;
X    volatile uint32_t HCDO15                    : 1;
N    __IO uint32_t HCDO16                    : 1;
X    volatile uint32_t HCDO16                    : 1;
N    __IO uint32_t HCDO17                    : 1;
X    volatile uint32_t HCDO17                    : 1;
N    __IO uint32_t HCDO18                    : 1;
X    volatile uint32_t HCDO18                    : 1;
N    __IO uint32_t HCDO19                    : 1;
X    volatile uint32_t HCDO19                    : 1;
N} stc_tim5_hcdor_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CMAF                      : 1;
X    volatile uint32_t CMAF                      : 1;
N    __IO uint32_t CMBF                      : 1;
X    volatile uint32_t CMBF                      : 1;
N    __IO uint32_t CMCF                      : 1;
X    volatile uint32_t CMCF                      : 1;
N    __IO uint32_t CMDF                      : 1;
X    volatile uint32_t CMDF                      : 1;
N    uint32_t RESERVED4                      : 2;
N    __IO uint32_t OVFF                      : 1;
X    volatile uint32_t OVFF                      : 1;
N    __IO uint32_t UDFF                      : 1;
X    volatile uint32_t UDFF                      : 1;
N    __IO uint32_t DTEF                      : 1;
X    volatile uint32_t DTEF                      : 1;
N    uint32_t RESERVED9                      : 5;
N    __IO uint32_t SAMLF                     : 1;
X    volatile uint32_t SAMLF                     : 1;
N    __IO uint32_t SAMHF                     : 1;
X    volatile uint32_t SAMHF                     : 1;
N} stc_tim5_ifr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CMAC                      : 1;
X    volatile uint32_t CMAC                      : 1;
N    __IO uint32_t CMBC                      : 1;
X    volatile uint32_t CMBC                      : 1;
N    __IO uint32_t CMCC                      : 1;
X    volatile uint32_t CMCC                      : 1;
N    __IO uint32_t CMDC                      : 1;
X    volatile uint32_t CMDC                      : 1;
N    uint32_t RESERVED4                      : 2;
N    __IO uint32_t OVFC                      : 1;
X    volatile uint32_t OVFC                      : 1;
N    __IO uint32_t UDFC                      : 1;
X    volatile uint32_t UDFC                      : 1;
N    __IO uint32_t DTEC                      : 1;
X    volatile uint32_t DTEC                      : 1;
N    uint32_t RESERVED9                      : 5;
N    __IO uint32_t SAMLC                     : 1;
X    volatile uint32_t SAMLC                     : 1;
N    __IO uint32_t SAMHC                     : 1;
X    volatile uint32_t SAMHC                     : 1;
N} stc_tim5_iclr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CMAE                      : 1;
X    volatile uint32_t CMAE                      : 1;
N    __IO uint32_t CMBE                      : 1;
X    volatile uint32_t CMBE                      : 1;
N    __IO uint32_t CMCE                      : 1;
X    volatile uint32_t CMCE                      : 1;
N    __IO uint32_t CMDE                      : 1;
X    volatile uint32_t CMDE                      : 1;
N    uint32_t RESERVED4                      : 2;
N    __IO uint32_t OVFE                      : 1;
X    volatile uint32_t OVFE                      : 1;
N    __IO uint32_t UDFE                      : 1;
X    volatile uint32_t UDFE                      : 1;
N    __IO uint32_t DITENA                    : 1;
X    volatile uint32_t DITENA                    : 1;
N    __IO uint32_t DITENB                    : 1;
X    volatile uint32_t DITENB                    : 1;
N    __IO uint32_t DITENS                    : 1;
X    volatile uint32_t DITENS                    : 1;
N    __IO uint32_t CMSAE                     : 1;
X    volatile uint32_t CMSAE                     : 1;
N    __IO uint32_t CMSBE                     : 1;
X    volatile uint32_t CMSBE                     : 1;
N    __IO uint32_t DMA_G_CMA                 : 1;
X    volatile uint32_t DMA_G_CMA                 : 1;
N    __IO uint32_t DMA_G_CMB                 : 1;
X    volatile uint32_t DMA_G_CMB                 : 1;
N    __IO uint32_t DMA_G_CMC                 : 1;
X    volatile uint32_t DMA_G_CMC                 : 1;
N    __IO uint32_t DMA_G_CMD                 : 1;
X    volatile uint32_t DMA_G_CMD                 : 1;
N    uint32_t RESERVED17                     : 2;
N    __IO uint32_t DMA_G_OVF                 : 1;
X    volatile uint32_t DMA_G_OVF                 : 1;
N    __IO uint32_t DMA_G_UDF                 : 1;
X    volatile uint32_t DMA_G_UDF                 : 1;
N    __IO uint32_t DMA_S_CMA                 : 1;
X    volatile uint32_t DMA_S_CMA                 : 1;
N    __IO uint32_t DMA_S_CMB                 : 1;
X    volatile uint32_t DMA_S_CMB                 : 1;
N} stc_tim5_cr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t FBRAKE                    : 1;
X    volatile uint32_t FBRAKE                    : 1;
N    __IO uint32_t FSAME                     : 1;
X    volatile uint32_t FSAME                     : 1;
N    __IO uint32_t BFILTS                    : 2;
X    volatile uint32_t BFILTS                    : 2;
N    __IO uint32_t BFILTEN                   : 1;
X    volatile uint32_t BFILTEN                   : 1;
N    uint32_t RESERVED5                      : 2;
N    __IO uint32_t SOFTBK                    : 1;
X    volatile uint32_t SOFTBK                    : 1;
N    __IO uint32_t SML0                      : 1;
X    volatile uint32_t SML0                      : 1;
N    __IO uint32_t SML1                      : 1;
X    volatile uint32_t SML1                      : 1;
N    __IO uint32_t SML2                      : 1;
X    volatile uint32_t SML2                      : 1;
N    __IO uint32_t SMH0                      : 1;
X    volatile uint32_t SMH0                      : 1;
N    __IO uint32_t SMH1                      : 1;
X    volatile uint32_t SMH1                      : 1;
N    __IO uint32_t SMH2                      : 1;
X    volatile uint32_t SMH2                      : 1;
N} stc_tim5_aossr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t FBRAKE                    : 1;
X    volatile uint32_t FBRAKE                    : 1;
N    __IO uint32_t FSAME                     : 1;
X    volatile uint32_t FSAME                     : 1;
N} stc_tim5_aoscl_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t EN0                       : 1;
X    volatile uint32_t EN0                       : 1;
N    __IO uint32_t EN1                       : 1;
X    volatile uint32_t EN1                       : 1;
N    __IO uint32_t EN2                       : 1;
X    volatile uint32_t EN2                       : 1;
N    __IO uint32_t EN3                       : 1;
X    volatile uint32_t EN3                       : 1;
N    __IO uint32_t EN4                       : 1;
X    volatile uint32_t EN4                       : 1;
N    __IO uint32_t EN5                       : 1;
X    volatile uint32_t EN5                       : 1;
N    __IO uint32_t EN6                       : 1;
X    volatile uint32_t EN6                       : 1;
N    __IO uint32_t EN7                       : 1;
X    volatile uint32_t EN7                       : 1;
N    __IO uint32_t EN8                       : 1;
X    volatile uint32_t EN8                       : 1;
N    __IO uint32_t EN9                       : 1;
X    volatile uint32_t EN9                       : 1;
N    __IO uint32_t EN10                      : 1;
X    volatile uint32_t EN10                      : 1;
N    __IO uint32_t EN11                      : 1;
X    volatile uint32_t EN11                      : 1;
N    __IO uint32_t EN12                      : 1;
X    volatile uint32_t EN12                      : 1;
N    __IO uint32_t EN13                      : 1;
X    volatile uint32_t EN13                      : 1;
N    __IO uint32_t EN14                      : 1;
X    volatile uint32_t EN14                      : 1;
N    __IO uint32_t EN15                      : 1;
X    volatile uint32_t EN15                      : 1;
N} stc_tim5_ptbks_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t TRIGAS                    : 4;
X    volatile uint32_t TRIGAS                    : 4;
N    __IO uint32_t TRIGBS                    : 4;
X    volatile uint32_t TRIGBS                    : 4;
N    __IO uint32_t TRIGCS                    : 4;
X    volatile uint32_t TRIGCS                    : 4;
N    __IO uint32_t TRIGDS                    : 4;
X    volatile uint32_t TRIGDS                    : 4;
N} stc_tim5_ttrig_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t IAOS0S                    : 4;
X    volatile uint32_t IAOS0S                    : 4;
N    __IO uint32_t IAOS1S                    : 4;
X    volatile uint32_t IAOS1S                    : 4;
N    __IO uint32_t IAOS2S                    : 4;
X    volatile uint32_t IAOS2S                    : 4;
N    __IO uint32_t IAOS3S                    : 4;
X    volatile uint32_t IAOS3S                    : 4;
N} stc_tim5_itrig_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t POL0                      : 1;
X    volatile uint32_t POL0                      : 1;
N    __IO uint32_t POL1                      : 1;
X    volatile uint32_t POL1                      : 1;
N    __IO uint32_t POL2                      : 1;
X    volatile uint32_t POL2                      : 1;
N    __IO uint32_t POL3                      : 1;
X    volatile uint32_t POL3                      : 1;
N    __IO uint32_t POL4                      : 1;
X    volatile uint32_t POL4                      : 1;
N    __IO uint32_t POL5                      : 1;
X    volatile uint32_t POL5                      : 1;
N    __IO uint32_t POL6                      : 1;
X    volatile uint32_t POL6                      : 1;
N    __IO uint32_t POL7                      : 1;
X    volatile uint32_t POL7                      : 1;
N    __IO uint32_t POL8                      : 1;
X    volatile uint32_t POL8                      : 1;
N    __IO uint32_t POL9                      : 1;
X    volatile uint32_t POL9                      : 1;
N    __IO uint32_t POL10                     : 1;
X    volatile uint32_t POL10                     : 1;
N    __IO uint32_t POL11                     : 1;
X    volatile uint32_t POL11                     : 1;
N    __IO uint32_t POL12                     : 1;
X    volatile uint32_t POL12                     : 1;
N    __IO uint32_t POL13                     : 1;
X    volatile uint32_t POL13                     : 1;
N    __IO uint32_t POL14                     : 1;
X    volatile uint32_t POL14                     : 1;
N    __IO uint32_t POL15                     : 1;
X    volatile uint32_t POL15                     : 1;
N} stc_tim5_ptbkp_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SSTA0                     : 1;
X    volatile uint32_t SSTA0                     : 1;
N    __IO uint32_t SSTA1                     : 1;
X    volatile uint32_t SSTA1                     : 1;
N    __IO uint32_t SSTA2                     : 1;
X    volatile uint32_t SSTA2                     : 1;
N} stc_tim5_sstar_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SSTP0                     : 1;
X    volatile uint32_t SSTP0                     : 1;
N    __IO uint32_t SSTP1                     : 1;
X    volatile uint32_t SSTP1                     : 1;
N    __IO uint32_t SSTP2                     : 1;
X    volatile uint32_t SSTP2                     : 1;
N} stc_tim5_sstpr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SCLR0                     : 1;
X    volatile uint32_t SCLR0                     : 1;
N    __IO uint32_t SCLR1                     : 1;
X    volatile uint32_t SCLR1                     : 1;
N    __IO uint32_t SCLR2                     : 1;
X    volatile uint32_t SCLR2                     : 1;
N} stc_tim5_sclrr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CNT                       :16;
X    volatile uint32_t CNT                       :16;
N} stc_tim6_cnter_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PERA                      :16;
X    volatile uint32_t PERA                      :16;
N} stc_tim6_perar_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t PERB                      :16;
X    volatile uint32_t PERB                      :16;
N} stc_tim6_perbr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t GCMA                      :16;
X    volatile uint32_t GCMA                      :16;
N} stc_tim6_gcmar_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t GCMB                      :16;
X    volatile uint32_t GCMB                      :16;
N} stc_tim6_gcmbr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t GCMC                      :16;
X    volatile uint32_t GCMC                      :16;
N} stc_tim6_gcmcr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t GCMD                      :16;
X    volatile uint32_t GCMD                      :16;
N} stc_tim6_gcmdr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SCMA                      :16;
X    volatile uint32_t SCMA                      :16;
N} stc_tim6_scmar_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SCMB                      :16;
X    volatile uint32_t SCMB                      :16;
N} stc_tim6_scmbr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t DTUA                      :16;
X    volatile uint32_t DTUA                      :16;
N} stc_tim6_dtuar_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t DTDA                      :16;
X    volatile uint32_t DTDA                      :16;
N} stc_tim6_dtdar_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t START                     : 1;
X    volatile uint32_t START                     : 1;
N    __IO uint32_t MODE                      : 3;
X    volatile uint32_t MODE                      : 3;
N    __IO uint32_t CKDIV                     : 3;
X    volatile uint32_t CKDIV                     : 3;
N    uint32_t RESERVED7                      : 1;
N    __IO uint32_t DIR                       : 1;
X    volatile uint32_t DIR                       : 1;
N    uint32_t RESERVED9                      : 7;
N    __IO uint32_t ZMSKREV                   : 1;
X    volatile uint32_t ZMSKREV                   : 1;
N    __IO uint32_t ZMSKPOS                   : 1;
X    volatile uint32_t ZMSKPOS                   : 1;
N    __IO uint32_t ZMSK                      : 2;
X    volatile uint32_t ZMSK                      : 2;
N} stc_tim6_gconr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t INTENA                    : 1;
X    volatile uint32_t INTENA                    : 1;
N    __IO uint32_t INTENB                    : 1;
X    volatile uint32_t INTENB                    : 1;
N    __IO uint32_t INTENC                    : 1;
X    volatile uint32_t INTENC                    : 1;
N    __IO uint32_t INTEND                    : 1;
X    volatile uint32_t INTEND                    : 1;
N    uint32_t RESERVED4                      : 2;
N    __IO uint32_t INTENOVF                  : 1;
X    volatile uint32_t INTENOVF                  : 1;
N    __IO uint32_t INTENUDF                  : 1;
X    volatile uint32_t INTENUDF                  : 1;
N    __IO uint32_t INTENDE                   : 1;
X    volatile uint32_t INTENDE                   : 1;
N    uint32_t RESERVED9                      : 5;
N    __IO uint32_t INTENSAML                 : 1;
X    volatile uint32_t INTENSAML                 : 1;
N    __IO uint32_t INTENSAMH                 : 1;
X    volatile uint32_t INTENSAMH                 : 1;
N    __IO uint32_t INTENSAU                  : 1;
X    volatile uint32_t INTENSAU                  : 1;
N    __IO uint32_t INTENSAD                  : 1;
X    volatile uint32_t INTENSAD                  : 1;
N    __IO uint32_t INTENSBU                  : 1;
X    volatile uint32_t INTENSBU                  : 1;
N    __IO uint32_t INTENSBD                  : 1;
X    volatile uint32_t INTENSBD                  : 1;
N} stc_tim6_iconr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CAPCA                     : 1;
X    volatile uint32_t CAPCA                     : 1;
N    __IO uint32_t STACA                     : 1;
X    volatile uint32_t STACA                     : 1;
N    __IO uint32_t STPCA                     : 1;
X    volatile uint32_t STPCA                     : 1;
N    __IO uint32_t STASTPSA                  : 1;
X    volatile uint32_t STASTPSA                  : 1;
N    __IO uint32_t CMPCA                     : 2;
X    volatile uint32_t CMPCA                     : 2;
N    __IO uint32_t PERCA                     : 2;
X    volatile uint32_t PERCA                     : 2;
N    __IO uint32_t OUTENA                    : 1;
X    volatile uint32_t OUTENA                    : 1;
N    __IO uint32_t DISSELA                   : 2;
X    volatile uint32_t DISSELA                   : 2;
N    __IO uint32_t DISVALA                   : 2;
X    volatile uint32_t DISVALA                   : 2;
N    uint32_t RESERVED13                     : 3;
N    __IO uint32_t CAPCB                     : 1;
X    volatile uint32_t CAPCB                     : 1;
N    __IO uint32_t STACB                     : 1;
X    volatile uint32_t STACB                     : 1;
N    __IO uint32_t STPCB                     : 1;
X    volatile uint32_t STPCB                     : 1;
N    __IO uint32_t STASTPSB                  : 1;
X    volatile uint32_t STASTPSB                  : 1;
N    __IO uint32_t CMPCB                     : 2;
X    volatile uint32_t CMPCB                     : 2;
N    __IO uint32_t PERCB                     : 2;
X    volatile uint32_t PERCB                     : 2;
N    __IO uint32_t OUTENB                    : 1;
X    volatile uint32_t OUTENB                    : 1;
N    __IO uint32_t DISSELB                   : 2;
X    volatile uint32_t DISSELB                   : 2;
N    __IO uint32_t DISVALB                   : 2;
X    volatile uint32_t DISVALB                   : 2;
N} stc_tim6_pconr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t BENA                      : 1;
X    volatile uint32_t BENA                      : 1;
N    uint32_t RESERVED1                      : 1;
N    __IO uint32_t BENB                      : 1;
X    volatile uint32_t BENB                      : 1;
N    uint32_t RESERVED3                      : 5;
N    __IO uint32_t BENP                      : 1;
X    volatile uint32_t BENP                      : 1;
N} stc_tim6_bconr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t DTCEN                     : 1;
X    volatile uint32_t DTCEN                     : 1;
N    uint32_t RESERVED1                      : 7;
N    __IO uint32_t SEPA                      : 1;
X    volatile uint32_t SEPA                      : 1;
N} stc_tim6_dconr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t NOFIENGA                  : 1;
X    volatile uint32_t NOFIENGA                  : 1;
N    __IO uint32_t NOFICKGA                  : 2;
X    volatile uint32_t NOFICKGA                  : 2;
N    uint32_t RESERVED3                      : 1;
N    __IO uint32_t NOFIENGB                  : 1;
X    volatile uint32_t NOFIENGB                  : 1;
N    __IO uint32_t NOFICKGB                  : 2;
X    volatile uint32_t NOFICKGB                  : 2;
N    uint32_t RESERVED7                      : 9;
N    __IO uint32_t NOFIENTA                  : 1;
X    volatile uint32_t NOFIENTA                  : 1;
N    __IO uint32_t NOFICKTA                  : 2;
X    volatile uint32_t NOFICKTA                  : 2;
N    uint32_t RESERVED19                     : 1;
N    __IO uint32_t NOFIENTB                  : 1;
X    volatile uint32_t NOFIENTB                  : 1;
N    __IO uint32_t NOFICKTB                  : 2;
X    volatile uint32_t NOFICKTB                  : 2;
N    uint32_t RESERVED23                     : 1;
N    __IO uint32_t NOFIENTC                  : 1;
X    volatile uint32_t NOFIENTC                  : 1;
N    __IO uint32_t NOFICKTC                  : 2;
X    volatile uint32_t NOFICKTC                  : 2;
N    uint32_t RESERVED27                     : 1;
N    __IO uint32_t NOFIENTD                  : 1;
X    volatile uint32_t NOFIENTD                  : 1;
N    __IO uint32_t NOFICKTD                  : 2;
X    volatile uint32_t NOFICKTD                  : 2;
N} stc_tim6_fconr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t GEPERIA                   : 1;
X    volatile uint32_t GEPERIA                   : 1;
N    __IO uint32_t GEPERIB                   : 1;
X    volatile uint32_t GEPERIB                   : 1;
N    __IO uint32_t GEPERIC                   : 1;
X    volatile uint32_t GEPERIC                   : 1;
N    __IO uint32_t GEPERID                   : 1;
X    volatile uint32_t GEPERID                   : 1;
N    uint32_t RESERVED4                      :12;
N    __IO uint32_t PCNTE                     : 2;
X    volatile uint32_t PCNTE                     : 2;
N    __IO uint32_t PCNTS                     : 3;
X    volatile uint32_t PCNTS                     : 3;
N} stc_tim6_vperr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CMAF                      : 1;
X    volatile uint32_t CMAF                      : 1;
N    __IO uint32_t CMBF                      : 1;
X    volatile uint32_t CMBF                      : 1;
N    __IO uint32_t CMCF                      : 1;
X    volatile uint32_t CMCF                      : 1;
N    __IO uint32_t CMDF                      : 1;
X    volatile uint32_t CMDF                      : 1;
N    uint32_t RESERVED4                      : 2;
N    __IO uint32_t OVFF                      : 1;
X    volatile uint32_t OVFF                      : 1;
N    __IO uint32_t UDFF                      : 1;
X    volatile uint32_t UDFF                      : 1;
N    __IO uint32_t DTEF                      : 1;
X    volatile uint32_t DTEF                      : 1;
N    __IO uint32_t CMSAUF                    : 1;
X    volatile uint32_t CMSAUF                    : 1;
N    __IO uint32_t CMSADF                    : 1;
X    volatile uint32_t CMSADF                    : 1;
N    __IO uint32_t CMSBUF                    : 1;
X    volatile uint32_t CMSBUF                    : 1;
N    __IO uint32_t CMSBDF                    : 1;
X    volatile uint32_t CMSBDF                    : 1;
N    uint32_t RESERVED13                     : 8;
N    __IO uint32_t VPERNUM                   : 3;
X    volatile uint32_t VPERNUM                   : 3;
N    uint32_t RESERVED24                     : 7;
N    __IO uint32_t DIRF                      : 1;
X    volatile uint32_t DIRF                      : 1;
N} stc_tim6_stflr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t HSTA0                     : 1;
X    volatile uint32_t HSTA0                     : 1;
N    __IO uint32_t HSTA1                     : 1;
X    volatile uint32_t HSTA1                     : 1;
N    __IO uint32_t HSTA2                     : 1;
X    volatile uint32_t HSTA2                     : 1;
N    __IO uint32_t HSTA3                     : 1;
X    volatile uint32_t HSTA3                     : 1;
N    __IO uint32_t HSTA4                     : 1;
X    volatile uint32_t HSTA4                     : 1;
N    __IO uint32_t HSTA5                     : 1;
X    volatile uint32_t HSTA5                     : 1;
N    __IO uint32_t HSTA6                     : 1;
X    volatile uint32_t HSTA6                     : 1;
N    __IO uint32_t HSTA7                     : 1;
X    volatile uint32_t HSTA7                     : 1;
N    __IO uint32_t HSTA8                     : 1;
X    volatile uint32_t HSTA8                     : 1;
N    __IO uint32_t HSTA9                     : 1;
X    volatile uint32_t HSTA9                     : 1;
N    __IO uint32_t HSTA10                    : 1;
X    volatile uint32_t HSTA10                    : 1;
N    __IO uint32_t HSTA11                    : 1;
X    volatile uint32_t HSTA11                    : 1;
N    __IO uint32_t HSTA12                    : 1;
X    volatile uint32_t HSTA12                    : 1;
N    __IO uint32_t HSTA13                    : 1;
X    volatile uint32_t HSTA13                    : 1;
N    __IO uint32_t HSTA14                    : 1;
X    volatile uint32_t HSTA14                    : 1;
N    __IO uint32_t HSTA15                    : 1;
X    volatile uint32_t HSTA15                    : 1;
N    uint32_t RESERVED16                     :15;
N    __IO uint32_t STARTS                    : 1;
X    volatile uint32_t STARTS                    : 1;
N} stc_tim6_hstar_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t HSTP0                     : 1;
X    volatile uint32_t HSTP0                     : 1;
N    __IO uint32_t HSTP1                     : 1;
X    volatile uint32_t HSTP1                     : 1;
N    __IO uint32_t HSTP2                     : 1;
X    volatile uint32_t HSTP2                     : 1;
N    __IO uint32_t HSTP3                     : 1;
X    volatile uint32_t HSTP3                     : 1;
N    __IO uint32_t HSTP4                     : 1;
X    volatile uint32_t HSTP4                     : 1;
N    __IO uint32_t HSTP5                     : 1;
X    volatile uint32_t HSTP5                     : 1;
N    __IO uint32_t HSTP6                     : 1;
X    volatile uint32_t HSTP6                     : 1;
N    __IO uint32_t HSTP7                     : 1;
X    volatile uint32_t HSTP7                     : 1;
N    __IO uint32_t HSTP8                     : 1;
X    volatile uint32_t HSTP8                     : 1;
N    __IO uint32_t HSTP9                     : 1;
X    volatile uint32_t HSTP9                     : 1;
N    __IO uint32_t HSTP10                    : 1;
X    volatile uint32_t HSTP10                    : 1;
N    __IO uint32_t HSTP11                    : 1;
X    volatile uint32_t HSTP11                    : 1;
N    __IO uint32_t HSTP12                    : 1;
X    volatile uint32_t HSTP12                    : 1;
N    __IO uint32_t HSTP13                    : 1;
X    volatile uint32_t HSTP13                    : 1;
N    __IO uint32_t HSTP14                    : 1;
X    volatile uint32_t HSTP14                    : 1;
N    __IO uint32_t HSTP15                    : 1;
X    volatile uint32_t HSTP15                    : 1;
N    uint32_t RESERVED16                     :15;
N    __IO uint32_t STOPS                     : 1;
X    volatile uint32_t STOPS                     : 1;
N} stc_tim6_hstpr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t HCEL0                     : 1;
X    volatile uint32_t HCEL0                     : 1;
N    __IO uint32_t HCEL1                     : 1;
X    volatile uint32_t HCEL1                     : 1;
N    __IO uint32_t HCEL2                     : 1;
X    volatile uint32_t HCEL2                     : 1;
N    __IO uint32_t HCEL3                     : 1;
X    volatile uint32_t HCEL3                     : 1;
N    __IO uint32_t HCEL4                     : 1;
X    volatile uint32_t HCEL4                     : 1;
N    __IO uint32_t HCEL5                     : 1;
X    volatile uint32_t HCEL5                     : 1;
N    __IO uint32_t HCEL6                     : 1;
X    volatile uint32_t HCEL6                     : 1;
N    __IO uint32_t HCEL7                     : 1;
X    volatile uint32_t HCEL7                     : 1;
N    __IO uint32_t HCEL8                     : 1;
X    volatile uint32_t HCEL8                     : 1;
N    __IO uint32_t HCEL9                     : 1;
X    volatile uint32_t HCEL9                     : 1;
N    __IO uint32_t HCEL10                    : 1;
X    volatile uint32_t HCEL10                    : 1;
N    __IO uint32_t HCEL11                    : 1;
X    volatile uint32_t HCEL11                    : 1;
N    __IO uint32_t HCEL12                    : 1;
X    volatile uint32_t HCEL12                    : 1;
N    __IO uint32_t HCEL13                    : 1;
X    volatile uint32_t HCEL13                    : 1;
N    __IO uint32_t HCEL14                    : 1;
X    volatile uint32_t HCEL14                    : 1;
N    __IO uint32_t HCEL15                    : 1;
X    volatile uint32_t HCEL15                    : 1;
N    uint32_t RESERVED16                     :15;
N    __IO uint32_t STARTS                    : 1;
X    volatile uint32_t STARTS                    : 1;
N} stc_tim6_hcelr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t HCPA0                     : 1;
X    volatile uint32_t HCPA0                     : 1;
N    __IO uint32_t HCPA1                     : 1;
X    volatile uint32_t HCPA1                     : 1;
N    __IO uint32_t HCPA2                     : 1;
X    volatile uint32_t HCPA2                     : 1;
N    __IO uint32_t HCPA3                     : 1;
X    volatile uint32_t HCPA3                     : 1;
N    __IO uint32_t HCPA4                     : 1;
X    volatile uint32_t HCPA4                     : 1;
N    __IO uint32_t HCPA5                     : 1;
X    volatile uint32_t HCPA5                     : 1;
N    __IO uint32_t HCPA6                     : 1;
X    volatile uint32_t HCPA6                     : 1;
N    __IO uint32_t HCPA7                     : 1;
X    volatile uint32_t HCPA7                     : 1;
N    __IO uint32_t HCPA8                     : 1;
X    volatile uint32_t HCPA8                     : 1;
N    __IO uint32_t HCPA9                     : 1;
X    volatile uint32_t HCPA9                     : 1;
N    __IO uint32_t HCPA10                    : 1;
X    volatile uint32_t HCPA10                    : 1;
N    __IO uint32_t HCPA11                    : 1;
X    volatile uint32_t HCPA11                    : 1;
N    __IO uint32_t HCPA12                    : 1;
X    volatile uint32_t HCPA12                    : 1;
N    __IO uint32_t HCPA13                    : 1;
X    volatile uint32_t HCPA13                    : 1;
N    __IO uint32_t HCPA14                    : 1;
X    volatile uint32_t HCPA14                    : 1;
N    __IO uint32_t HCPA15                    : 1;
X    volatile uint32_t HCPA15                    : 1;
N} stc_tim6_hcpar_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t HCPB0                     : 1;
X    volatile uint32_t HCPB0                     : 1;
N    __IO uint32_t HCPB1                     : 1;
X    volatile uint32_t HCPB1                     : 1;
N    __IO uint32_t HCPB2                     : 1;
X    volatile uint32_t HCPB2                     : 1;
N    __IO uint32_t HCPB3                     : 1;
X    volatile uint32_t HCPB3                     : 1;
N    __IO uint32_t HCPB4                     : 1;
X    volatile uint32_t HCPB4                     : 1;
N    __IO uint32_t HCPB5                     : 1;
X    volatile uint32_t HCPB5                     : 1;
N    __IO uint32_t HCPB6                     : 1;
X    volatile uint32_t HCPB6                     : 1;
N    __IO uint32_t HCPB7                     : 1;
X    volatile uint32_t HCPB7                     : 1;
N    __IO uint32_t HCPB8                     : 1;
X    volatile uint32_t HCPB8                     : 1;
N    __IO uint32_t HCPB9                     : 1;
X    volatile uint32_t HCPB9                     : 1;
N    __IO uint32_t HCPB10                    : 1;
X    volatile uint32_t HCPB10                    : 1;
N    __IO uint32_t HCPB11                    : 1;
X    volatile uint32_t HCPB11                    : 1;
N    __IO uint32_t HCPB12                    : 1;
X    volatile uint32_t HCPB12                    : 1;
N    __IO uint32_t HCPB13                    : 1;
X    volatile uint32_t HCPB13                    : 1;
N    __IO uint32_t HCPB14                    : 1;
X    volatile uint32_t HCPB14                    : 1;
N    __IO uint32_t HCPB15                    : 1;
X    volatile uint32_t HCPB15                    : 1;
N} stc_tim6_hcpbr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t HCUP0                     : 1;
X    volatile uint32_t HCUP0                     : 1;
N    __IO uint32_t HCUP1                     : 1;
X    volatile uint32_t HCUP1                     : 1;
N    __IO uint32_t HCUP2                     : 1;
X    volatile uint32_t HCUP2                     : 1;
N    __IO uint32_t HCUP3                     : 1;
X    volatile uint32_t HCUP3                     : 1;
N    __IO uint32_t HCUP4                     : 1;
X    volatile uint32_t HCUP4                     : 1;
N    __IO uint32_t HCUP5                     : 1;
X    volatile uint32_t HCUP5                     : 1;
N    __IO uint32_t HCUP6                     : 1;
X    volatile uint32_t HCUP6                     : 1;
N    __IO uint32_t HCUP7                     : 1;
X    volatile uint32_t HCUP7                     : 1;
N    __IO uint32_t HCUP8                     : 1;
X    volatile uint32_t HCUP8                     : 1;
N    __IO uint32_t HCUP9                     : 1;
X    volatile uint32_t HCUP9                     : 1;
N    __IO uint32_t HCUP10                    : 1;
X    volatile uint32_t HCUP10                    : 1;
N    __IO uint32_t HCUP11                    : 1;
X    volatile uint32_t HCUP11                    : 1;
N    __IO uint32_t HCUP12                    : 1;
X    volatile uint32_t HCUP12                    : 1;
N    __IO uint32_t HCUP13                    : 1;
X    volatile uint32_t HCUP13                    : 1;
N    __IO uint32_t HCUP14                    : 1;
X    volatile uint32_t HCUP14                    : 1;
N    __IO uint32_t HCUP15                    : 1;
X    volatile uint32_t HCUP15                    : 1;
N    __IO uint32_t HCUP16                    : 1;
X    volatile uint32_t HCUP16                    : 1;
N    __IO uint32_t HCUP17                    : 1;
X    volatile uint32_t HCUP17                    : 1;
N    __IO uint32_t HCUP18                    : 1;
X    volatile uint32_t HCUP18                    : 1;
N    __IO uint32_t HCUP19                    : 1;
X    volatile uint32_t HCUP19                    : 1;
N} stc_tim6_hcupr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t HCDO0                     : 1;
X    volatile uint32_t HCDO0                     : 1;
N    __IO uint32_t HCDO1                     : 1;
X    volatile uint32_t HCDO1                     : 1;
N    __IO uint32_t HCDO2                     : 1;
X    volatile uint32_t HCDO2                     : 1;
N    __IO uint32_t HCDO3                     : 1;
X    volatile uint32_t HCDO3                     : 1;
N    __IO uint32_t HCDO4                     : 1;
X    volatile uint32_t HCDO4                     : 1;
N    __IO uint32_t HCDO5                     : 1;
X    volatile uint32_t HCDO5                     : 1;
N    __IO uint32_t HCDO6                     : 1;
X    volatile uint32_t HCDO6                     : 1;
N    __IO uint32_t HCDO7                     : 1;
X    volatile uint32_t HCDO7                     : 1;
N    __IO uint32_t HCDO8                     : 1;
X    volatile uint32_t HCDO8                     : 1;
N    __IO uint32_t HCDO9                     : 1;
X    volatile uint32_t HCDO9                     : 1;
N    __IO uint32_t HCDO10                    : 1;
X    volatile uint32_t HCDO10                    : 1;
N    __IO uint32_t HCDO11                    : 1;
X    volatile uint32_t HCDO11                    : 1;
N    __IO uint32_t HCDO12                    : 1;
X    volatile uint32_t HCDO12                    : 1;
N    __IO uint32_t HCDO13                    : 1;
X    volatile uint32_t HCDO13                    : 1;
N    __IO uint32_t HCDO14                    : 1;
X    volatile uint32_t HCDO14                    : 1;
N    __IO uint32_t HCDO15                    : 1;
X    volatile uint32_t HCDO15                    : 1;
N    __IO uint32_t HCDO16                    : 1;
X    volatile uint32_t HCDO16                    : 1;
N    __IO uint32_t HCDO17                    : 1;
X    volatile uint32_t HCDO17                    : 1;
N    __IO uint32_t HCDO18                    : 1;
X    volatile uint32_t HCDO18                    : 1;
N    __IO uint32_t HCDO19                    : 1;
X    volatile uint32_t HCDO19                    : 1;
N} stc_tim6_hcdor_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CMAF                      : 1;
X    volatile uint32_t CMAF                      : 1;
N    __IO uint32_t CMBF                      : 1;
X    volatile uint32_t CMBF                      : 1;
N    __IO uint32_t CMCF                      : 1;
X    volatile uint32_t CMCF                      : 1;
N    __IO uint32_t CMDF                      : 1;
X    volatile uint32_t CMDF                      : 1;
N    uint32_t RESERVED4                      : 2;
N    __IO uint32_t OVFF                      : 1;
X    volatile uint32_t OVFF                      : 1;
N    __IO uint32_t UDFF                      : 1;
X    volatile uint32_t UDFF                      : 1;
N    __IO uint32_t DTEF                      : 1;
X    volatile uint32_t DTEF                      : 1;
N    uint32_t RESERVED9                      : 5;
N    __IO uint32_t SAMLF                     : 1;
X    volatile uint32_t SAMLF                     : 1;
N    __IO uint32_t SAMHF                     : 1;
X    volatile uint32_t SAMHF                     : 1;
N} stc_tim6_ifr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CMAC                      : 1;
X    volatile uint32_t CMAC                      : 1;
N    __IO uint32_t CMBC                      : 1;
X    volatile uint32_t CMBC                      : 1;
N    __IO uint32_t CMCC                      : 1;
X    volatile uint32_t CMCC                      : 1;
N    __IO uint32_t CMDC                      : 1;
X    volatile uint32_t CMDC                      : 1;
N    uint32_t RESERVED4                      : 2;
N    __IO uint32_t OVFC                      : 1;
X    volatile uint32_t OVFC                      : 1;
N    __IO uint32_t UDFC                      : 1;
X    volatile uint32_t UDFC                      : 1;
N    __IO uint32_t DTEC                      : 1;
X    volatile uint32_t DTEC                      : 1;
N    uint32_t RESERVED9                      : 5;
N    __IO uint32_t SAMLC                     : 1;
X    volatile uint32_t SAMLC                     : 1;
N    __IO uint32_t SAMHC                     : 1;
X    volatile uint32_t SAMHC                     : 1;
N} stc_tim6_iclr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t CMAE                      : 1;
X    volatile uint32_t CMAE                      : 1;
N    __IO uint32_t CMBE                      : 1;
X    volatile uint32_t CMBE                      : 1;
N    __IO uint32_t CMCE                      : 1;
X    volatile uint32_t CMCE                      : 1;
N    __IO uint32_t CMDE                      : 1;
X    volatile uint32_t CMDE                      : 1;
N    uint32_t RESERVED4                      : 2;
N    __IO uint32_t OVFE                      : 1;
X    volatile uint32_t OVFE                      : 1;
N    __IO uint32_t UDFE                      : 1;
X    volatile uint32_t UDFE                      : 1;
N    __IO uint32_t DITENA                    : 1;
X    volatile uint32_t DITENA                    : 1;
N    __IO uint32_t DITENB                    : 1;
X    volatile uint32_t DITENB                    : 1;
N    __IO uint32_t DITENS                    : 1;
X    volatile uint32_t DITENS                    : 1;
N    __IO uint32_t CMSAE                     : 1;
X    volatile uint32_t CMSAE                     : 1;
N    __IO uint32_t CMSBE                     : 1;
X    volatile uint32_t CMSBE                     : 1;
N    __IO uint32_t DMA_G_CMA                 : 1;
X    volatile uint32_t DMA_G_CMA                 : 1;
N    __IO uint32_t DMA_G_CMB                 : 1;
X    volatile uint32_t DMA_G_CMB                 : 1;
N    __IO uint32_t DMA_G_CMC                 : 1;
X    volatile uint32_t DMA_G_CMC                 : 1;
N    __IO uint32_t DMA_G_CMD                 : 1;
X    volatile uint32_t DMA_G_CMD                 : 1;
N    uint32_t RESERVED17                     : 2;
N    __IO uint32_t DMA_G_OVF                 : 1;
X    volatile uint32_t DMA_G_OVF                 : 1;
N    __IO uint32_t DMA_G_UDF                 : 1;
X    volatile uint32_t DMA_G_UDF                 : 1;
N    __IO uint32_t DMA_S_CMA                 : 1;
X    volatile uint32_t DMA_S_CMA                 : 1;
N    __IO uint32_t DMA_S_CMB                 : 1;
X    volatile uint32_t DMA_S_CMB                 : 1;
N} stc_tim6_cr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t FBRAKE                    : 1;
X    volatile uint32_t FBRAKE                    : 1;
N    __IO uint32_t FSAME                     : 1;
X    volatile uint32_t FSAME                     : 1;
N    __IO uint32_t BFILTS                    : 2;
X    volatile uint32_t BFILTS                    : 2;
N    __IO uint32_t BFILTEN                   : 1;
X    volatile uint32_t BFILTEN                   : 1;
N    uint32_t RESERVED5                      : 2;
N    __IO uint32_t SOFTBK                    : 1;
X    volatile uint32_t SOFTBK                    : 1;
N    __IO uint32_t SML0                      : 1;
X    volatile uint32_t SML0                      : 1;
N    __IO uint32_t SML1                      : 1;
X    volatile uint32_t SML1                      : 1;
N    __IO uint32_t SML2                      : 1;
X    volatile uint32_t SML2                      : 1;
N    __IO uint32_t SMH0                      : 1;
X    volatile uint32_t SMH0                      : 1;
N    __IO uint32_t SMH1                      : 1;
X    volatile uint32_t SMH1                      : 1;
N    __IO uint32_t SMH2                      : 1;
X    volatile uint32_t SMH2                      : 1;
N} stc_tim6_aossr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t FBRAKE                    : 1;
X    volatile uint32_t FBRAKE                    : 1;
N    __IO uint32_t FSAME                     : 1;
X    volatile uint32_t FSAME                     : 1;
N} stc_tim6_aoscl_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t EN0                       : 1;
X    volatile uint32_t EN0                       : 1;
N    __IO uint32_t EN1                       : 1;
X    volatile uint32_t EN1                       : 1;
N    __IO uint32_t EN2                       : 1;
X    volatile uint32_t EN2                       : 1;
N    __IO uint32_t EN3                       : 1;
X    volatile uint32_t EN3                       : 1;
N    __IO uint32_t EN4                       : 1;
X    volatile uint32_t EN4                       : 1;
N    __IO uint32_t EN5                       : 1;
X    volatile uint32_t EN5                       : 1;
N    __IO uint32_t EN6                       : 1;
X    volatile uint32_t EN6                       : 1;
N    __IO uint32_t EN7                       : 1;
X    volatile uint32_t EN7                       : 1;
N    __IO uint32_t EN8                       : 1;
X    volatile uint32_t EN8                       : 1;
N    __IO uint32_t EN9                       : 1;
X    volatile uint32_t EN9                       : 1;
N    __IO uint32_t EN10                      : 1;
X    volatile uint32_t EN10                      : 1;
N    __IO uint32_t EN11                      : 1;
X    volatile uint32_t EN11                      : 1;
N    __IO uint32_t EN12                      : 1;
X    volatile uint32_t EN12                      : 1;
N    __IO uint32_t EN13                      : 1;
X    volatile uint32_t EN13                      : 1;
N    __IO uint32_t EN14                      : 1;
X    volatile uint32_t EN14                      : 1;
N    __IO uint32_t EN15                      : 1;
X    volatile uint32_t EN15                      : 1;
N} stc_tim6_ptbks_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t TRIGAS                    : 4;
X    volatile uint32_t TRIGAS                    : 4;
N    __IO uint32_t TRIGBS                    : 4;
X    volatile uint32_t TRIGBS                    : 4;
N    __IO uint32_t TRIGCS                    : 4;
X    volatile uint32_t TRIGCS                    : 4;
N    __IO uint32_t TRIGDS                    : 4;
X    volatile uint32_t TRIGDS                    : 4;
N} stc_tim6_ttrig_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t IAOS0S                    : 4;
X    volatile uint32_t IAOS0S                    : 4;
N    __IO uint32_t IAOS1S                    : 4;
X    volatile uint32_t IAOS1S                    : 4;
N    __IO uint32_t IAOS2S                    : 4;
X    volatile uint32_t IAOS2S                    : 4;
N    __IO uint32_t IAOS3S                    : 4;
X    volatile uint32_t IAOS3S                    : 4;
N} stc_tim6_itrig_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t POL0                      : 1;
X    volatile uint32_t POL0                      : 1;
N    __IO uint32_t POL1                      : 1;
X    volatile uint32_t POL1                      : 1;
N    __IO uint32_t POL2                      : 1;
X    volatile uint32_t POL2                      : 1;
N    __IO uint32_t POL3                      : 1;
X    volatile uint32_t POL3                      : 1;
N    __IO uint32_t POL4                      : 1;
X    volatile uint32_t POL4                      : 1;
N    __IO uint32_t POL5                      : 1;
X    volatile uint32_t POL5                      : 1;
N    __IO uint32_t POL6                      : 1;
X    volatile uint32_t POL6                      : 1;
N    __IO uint32_t POL7                      : 1;
X    volatile uint32_t POL7                      : 1;
N    __IO uint32_t POL8                      : 1;
X    volatile uint32_t POL8                      : 1;
N    __IO uint32_t POL9                      : 1;
X    volatile uint32_t POL9                      : 1;
N    __IO uint32_t POL10                     : 1;
X    volatile uint32_t POL10                     : 1;
N    __IO uint32_t POL11                     : 1;
X    volatile uint32_t POL11                     : 1;
N    __IO uint32_t POL12                     : 1;
X    volatile uint32_t POL12                     : 1;
N    __IO uint32_t POL13                     : 1;
X    volatile uint32_t POL13                     : 1;
N    __IO uint32_t POL14                     : 1;
X    volatile uint32_t POL14                     : 1;
N    __IO uint32_t POL15                     : 1;
X    volatile uint32_t POL15                     : 1;
N} stc_tim6_ptbkp_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SSTA0                     : 1;
X    volatile uint32_t SSTA0                     : 1;
N    __IO uint32_t SSTA1                     : 1;
X    volatile uint32_t SSTA1                     : 1;
N    __IO uint32_t SSTA2                     : 1;
X    volatile uint32_t SSTA2                     : 1;
N} stc_tim6_sstar_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SSTP0                     : 1;
X    volatile uint32_t SSTP0                     : 1;
N    __IO uint32_t SSTP1                     : 1;
X    volatile uint32_t SSTP1                     : 1;
N    __IO uint32_t SSTP2                     : 1;
X    volatile uint32_t SSTP2                     : 1;
N} stc_tim6_sstpr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SCLR0                     : 1;
X    volatile uint32_t SCLR0                     : 1;
N    __IO uint32_t SCLR1                     : 1;
X    volatile uint32_t SCLR1                     : 1;
N    __IO uint32_t SCLR2                     : 1;
X    volatile uint32_t SCLR2                     : 1;
N} stc_tim6_sclrr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t DATA                      : 8;
X    volatile uint32_t DATA                      : 8;
N    __IO uint32_t DATA8                     : 1;
X    volatile uint32_t DATA8                     : 1;
N} stc_uart_sbuf_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t RCIE                      : 1;
X    volatile uint32_t RCIE                      : 1;
N    __IO uint32_t TCIE                      : 1;
X    volatile uint32_t TCIE                      : 1;
N    __IO uint32_t B8CONT                    : 2;
X    volatile uint32_t B8CONT                    : 2;
N    __IO uint32_t REN                       : 1;
X    volatile uint32_t REN                       : 1;
N    __IO uint32_t ADRDET                    : 1;
X    volatile uint32_t ADRDET                    : 1;
N    __IO uint32_t SM                        : 2;
X    volatile uint32_t SM                        : 2;
N    __IO uint32_t TXEIE                     : 1;
X    volatile uint32_t TXEIE                     : 1;
N    __IO uint32_t OVER                      : 1;
X    volatile uint32_t OVER                      : 1;
N    uint32_t RESERVED10                     : 3;
N    __IO uint32_t PEIE                      : 1;
X    volatile uint32_t PEIE                      : 1;
N    __IO uint32_t STOPBIT                   : 2;
X    volatile uint32_t STOPBIT                   : 2;
N    __IO uint32_t DMARXEN                   : 1;
X    volatile uint32_t DMARXEN                   : 1;
N    __IO uint32_t DMATXEN                   : 1;
X    volatile uint32_t DMATXEN                   : 1;
N    __IO uint32_t RTSEN                     : 1;
X    volatile uint32_t RTSEN                     : 1;
N    __IO uint32_t CTSEN                     : 1;
X    volatile uint32_t CTSEN                     : 1;
N    __IO uint32_t CTSIE                     : 1;
X    volatile uint32_t CTSIE                     : 1;
N    __IO uint32_t FEIE                      : 1;
X    volatile uint32_t FEIE                      : 1;
N} stc_uart_scon_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SADDR                     : 8;
X    volatile uint32_t SADDR                     : 8;
N} stc_uart_saddr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SADEN                     : 8;
X    volatile uint32_t SADEN                     : 8;
N} stc_uart_saden_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t RC                        : 1;
X    volatile uint32_t RC                        : 1;
N    __IO uint32_t TC                        : 1;
X    volatile uint32_t TC                        : 1;
N    __IO uint32_t FE                        : 1;
X    volatile uint32_t FE                        : 1;
N    __IO uint32_t TXE                       : 1;
X    volatile uint32_t TXE                       : 1;
N    __IO uint32_t PE                        : 1;
X    volatile uint32_t PE                        : 1;
N    __IO uint32_t CTSIF                     : 1;
X    volatile uint32_t CTSIF                     : 1;
N    __IO uint32_t CTS                       : 1;
X    volatile uint32_t CTS                       : 1;
N} stc_uart_isr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t RCCF                      : 1;
X    volatile uint32_t RCCF                      : 1;
N    __IO uint32_t TCCF                      : 1;
X    volatile uint32_t TCCF                      : 1;
N    __IO uint32_t FECF                      : 1;
X    volatile uint32_t FECF                      : 1;
N    uint32_t RESERVED3                      : 1;
N    __IO uint32_t PECF                      : 1;
X    volatile uint32_t PECF                      : 1;
N    __IO uint32_t CTSIFCF                   : 1;
X    volatile uint32_t CTSIFCF                   : 1;
N} stc_uart_icr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t SCNT                      :16;
X    volatile uint32_t SCNT                      :16;
N} stc_uart_scnt_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t DIV                       : 6;
X    volatile uint32_t DIV                       : 6;
N    __IO uint32_t DIV_EN                    : 1;
X    volatile uint32_t DIV_EN                    : 1;
N    __IO uint32_t REF2P5_SEL                : 1;
X    volatile uint32_t REF2P5_SEL                : 1;
N    __IO uint32_t VC0_BIAS_SEL              : 2;
X    volatile uint32_t VC0_BIAS_SEL              : 2;
N    __IO uint32_t VC0_HYS_SEL               : 2;
X    volatile uint32_t VC0_HYS_SEL               : 2;
N    __IO uint32_t VC1_BIAS_SEL              : 2;
X    volatile uint32_t VC1_BIAS_SEL              : 2;
N    __IO uint32_t VC1_HYS_SEL               : 2;
X    volatile uint32_t VC1_HYS_SEL               : 2;
N} stc_vc_cr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t P_SEL                     : 4;
X    volatile uint32_t P_SEL                     : 4;
N    __IO uint32_t N_SEL                     : 4;
X    volatile uint32_t N_SEL                     : 4;
N    __IO uint32_t FLTEN                     : 1;
X    volatile uint32_t FLTEN                     : 1;
N    __IO uint32_t DEBOUNCE_TIME             : 3;
X    volatile uint32_t DEBOUNCE_TIME             : 3;
N    __IO uint32_t FALLING                   : 1;
X    volatile uint32_t FALLING                   : 1;
N    __IO uint32_t RISING                    : 1;
X    volatile uint32_t RISING                    : 1;
N    __IO uint32_t LEVEL                     : 1;
X    volatile uint32_t LEVEL                     : 1;
N    __IO uint32_t IE                        : 1;
X    volatile uint32_t IE                        : 1;
N    __IO uint32_t EN                        : 1;
X    volatile uint32_t EN                        : 1;
N} stc_vc_vc0_cr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t P_SEL                     : 4;
X    volatile uint32_t P_SEL                     : 4;
N    __IO uint32_t N_SEL                     : 4;
X    volatile uint32_t N_SEL                     : 4;
N    __IO uint32_t FLTEN                     : 1;
X    volatile uint32_t FLTEN                     : 1;
N    __IO uint32_t DEBOUNCE_TIME             : 3;
X    volatile uint32_t DEBOUNCE_TIME             : 3;
N    __IO uint32_t FALLING                   : 1;
X    volatile uint32_t FALLING                   : 1;
N    __IO uint32_t RISING                    : 1;
X    volatile uint32_t RISING                    : 1;
N    __IO uint32_t LEVEL                     : 1;
X    volatile uint32_t LEVEL                     : 1;
N    __IO uint32_t IE                        : 1;
X    volatile uint32_t IE                        : 1;
N    __IO uint32_t EN                        : 1;
X    volatile uint32_t EN                        : 1;
N} stc_vc_vc1_cr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t INV_TIMER                 : 1;
X    volatile uint32_t INV_TIMER                 : 1;
N    __IO uint32_t TIM0RCLR                  : 1;
X    volatile uint32_t TIM0RCLR                  : 1;
N    __IO uint32_t TIM1RCLR                  : 1;
X    volatile uint32_t TIM1RCLR                  : 1;
N    __IO uint32_t TIM2RCLR                  : 1;
X    volatile uint32_t TIM2RCLR                  : 1;
N    __IO uint32_t TIM3RCLR                  : 1;
X    volatile uint32_t TIM3RCLR                  : 1;
N    __IO uint32_t TIMBK                     : 1;
X    volatile uint32_t TIMBK                     : 1;
N    uint32_t RESERVED6                      : 3;
N    __IO uint32_t INV_TIM4                  : 1;
X    volatile uint32_t INV_TIM4                  : 1;
N    __IO uint32_t TIM4                      : 1;
X    volatile uint32_t TIM4                      : 1;
N    __IO uint32_t INV_TIM5                  : 1;
X    volatile uint32_t INV_TIM5                  : 1;
N    __IO uint32_t TIM5                      : 1;
X    volatile uint32_t TIM5                      : 1;
N    __IO uint32_t INV_TIM6                  : 1;
X    volatile uint32_t INV_TIM6                  : 1;
N    __IO uint32_t TIM6                      : 1;
X    volatile uint32_t TIM6                      : 1;
N    __IO uint32_t BRAKE                     : 1;
X    volatile uint32_t BRAKE                     : 1;
N} stc_vc_vc0_out_cfg_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t INV_TIMER                 : 1;
X    volatile uint32_t INV_TIMER                 : 1;
N    __IO uint32_t TIM0RCLR                  : 1;
X    volatile uint32_t TIM0RCLR                  : 1;
N    __IO uint32_t TIM1RCLR                  : 1;
X    volatile uint32_t TIM1RCLR                  : 1;
N    __IO uint32_t TIM2RCLR                  : 1;
X    volatile uint32_t TIM2RCLR                  : 1;
N    __IO uint32_t TIM3RCLR                  : 1;
X    volatile uint32_t TIM3RCLR                  : 1;
N    __IO uint32_t TIMBK                     : 1;
X    volatile uint32_t TIMBK                     : 1;
N    uint32_t RESERVED6                      : 3;
N    __IO uint32_t INV_TIM4                  : 1;
X    volatile uint32_t INV_TIM4                  : 1;
N    __IO uint32_t TIM4                      : 1;
X    volatile uint32_t TIM4                      : 1;
N    __IO uint32_t INV_TIM5                  : 1;
X    volatile uint32_t INV_TIM5                  : 1;
N    __IO uint32_t TIM5                      : 1;
X    volatile uint32_t TIM5                      : 1;
N    __IO uint32_t INV_TIM6                  : 1;
X    volatile uint32_t INV_TIM6                  : 1;
N    __IO uint32_t TIM6                      : 1;
X    volatile uint32_t TIM6                      : 1;
N    __IO uint32_t BRAKE                     : 1;
X    volatile uint32_t BRAKE                     : 1;
N} stc_vc_vc1_out_cfg_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t VC0_INTF                  : 1;
X    volatile uint32_t VC0_INTF                  : 1;
N    __IO uint32_t VC1_INTF                  : 1;
X    volatile uint32_t VC1_INTF                  : 1;
N    __IO uint32_t VC0_FILTER                : 1;
X    volatile uint32_t VC0_FILTER                : 1;
N    __IO uint32_t VC1_FILTER                : 1;
X    volatile uint32_t VC1_FILTER                : 1;
N} stc_vc_ifr_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t RST                       : 8;
X    volatile uint32_t RST                       : 8;
N} stc_wdt_rst_field_t;
N
Ntypedef struct
N{
N    __IO uint32_t WOV                       : 4;
X    volatile uint32_t WOV                       : 4;
N    __IO uint32_t WDTR                      : 1;
X    volatile uint32_t WDTR                      : 1;
N    __IO uint32_t WINT_EN                   : 1;
X    volatile uint32_t WINT_EN                   : 1;
N    uint32_t RESERVED6                      : 1;
N    __IO uint32_t WDINT                     : 1;
X    volatile uint32_t WDINT                     : 1;
N    __IO uint32_t WCNTL                     : 8;
X    volatile uint32_t WCNTL                     : 8;
N} stc_wdt_con_field_t;
N
N
Ntypedef struct
N{
N    uint8_t RESERVED0[4];
N    union
N    {
N        __IO uint32_t CR0;
X        volatile uint32_t CR0;
N        stc_adc_cr0_field_t CR0_f;
N    };
N    union
N    {
N        __IO uint32_t CR1;
X        volatile uint32_t CR1;
N        stc_adc_cr1_field_t CR1_f;
N    };
N    uint8_t RESERVED2[52];
N    union
N    {
N        __IO uint32_t SQR0;
X        volatile uint32_t SQR0;
N        stc_adc_sqr0_field_t SQR0_f;
N    };
N    union
N    {
N        __IO uint32_t SQR1;
X        volatile uint32_t SQR1;
N        stc_adc_sqr1_field_t SQR1_f;
N    };
N    union
N    {
N        __IO uint32_t SQR2;
X        volatile uint32_t SQR2;
N        stc_adc_sqr2_field_t SQR2_f;
N    };
N    union
N    {
N        __IO uint32_t JQR;
X        volatile uint32_t JQR;
N        stc_adc_jqr_field_t JQR_f;
N    };
N    union
N    {
N        __IO uint32_t SQRRESULT0;
X        volatile uint32_t SQRRESULT0;
N        stc_adc_sqrresult0_field_t SQRRESULT0_f;
N    };
N    union
N    {
N        __IO uint32_t SQRRESULT1;
X        volatile uint32_t SQRRESULT1;
N        stc_adc_sqrresult1_field_t SQRRESULT1_f;
N    };
N    union
N    {
N        __IO uint32_t SQRRESULT2;
X        volatile uint32_t SQRRESULT2;
N        stc_adc_sqrresult2_field_t SQRRESULT2_f;
N    };
N    union
N    {
N        __IO uint32_t SQRRESULT3;
X        volatile uint32_t SQRRESULT3;
N        stc_adc_sqrresult3_field_t SQRRESULT3_f;
N    };
N    union
N    {
N        __IO uint32_t SQRRESULT4;
X        volatile uint32_t SQRRESULT4;
N        stc_adc_sqrresult4_field_t SQRRESULT4_f;
N    };
N    union
N    {
N        __IO uint32_t SQRRESULT5;
X        volatile uint32_t SQRRESULT5;
N        stc_adc_sqrresult5_field_t SQRRESULT5_f;
N    };
N    union
N    {
N        __IO uint32_t SQRRESULT6;
X        volatile uint32_t SQRRESULT6;
N        stc_adc_sqrresult6_field_t SQRRESULT6_f;
N    };
N    union
N    {
N        __IO uint32_t SQRRESULT7;
X        volatile uint32_t SQRRESULT7;
N        stc_adc_sqrresult7_field_t SQRRESULT7_f;
N    };
N    union
N    {
N        __IO uint32_t SQRRESULT8;
X        volatile uint32_t SQRRESULT8;
N        stc_adc_sqrresult8_field_t SQRRESULT8_f;
N    };
N    union
N    {
N        __IO uint32_t SQRRESULT9;
X        volatile uint32_t SQRRESULT9;
N        stc_adc_sqrresult9_field_t SQRRESULT9_f;
N    };
N    union
N    {
N        __IO uint32_t SQRRESULT10;
X        volatile uint32_t SQRRESULT10;
N        stc_adc_sqrresult10_field_t SQRRESULT10_f;
N    };
N    union
N    {
N        __IO uint32_t SQRRESULT11;
X        volatile uint32_t SQRRESULT11;
N        stc_adc_sqrresult11_field_t SQRRESULT11_f;
N    };
N    union
N    {
N        __IO uint32_t SQRRESULT12;
X        volatile uint32_t SQRRESULT12;
N        stc_adc_sqrresult12_field_t SQRRESULT12_f;
N    };
N    union
N    {
N        __IO uint32_t SQR_RESULT13;
X        volatile uint32_t SQR_RESULT13;
N        stc_adc_sqr_result13_field_t SQR_RESULT13_f;
N    };
N    union
N    {
N        __IO uint32_t SQRRESULT14;
X        volatile uint32_t SQRRESULT14;
N        stc_adc_sqrresult14_field_t SQRRESULT14_f;
N    };
N    union
N    {
N        __IO uint32_t SQRRESULT15;
X        volatile uint32_t SQRRESULT15;
N        stc_adc_sqrresult15_field_t SQRRESULT15_f;
N    };
N    union
N    {
N        __IO uint32_t JQRRESULT0;
X        volatile uint32_t JQRRESULT0;
N        stc_adc_jqrresult0_field_t JQRRESULT0_f;
N    };
N    union
N    {
N        __IO uint32_t JQRRESULT1;
X        volatile uint32_t JQRRESULT1;
N        stc_adc_jqrresult1_field_t JQRRESULT1_f;
N    };
N    union
N    {
N        __IO uint32_t JQRRESULT2;
X        volatile uint32_t JQRRESULT2;
N        stc_adc_jqrresult2_field_t JQRRESULT2_f;
N    };
N    union
N    {
N        __IO uint32_t JQRRESULT3;
X        volatile uint32_t JQRRESULT3;
N        stc_adc_jqrresult3_field_t JQRRESULT3_f;
N    };
N    union
N    {
N        __IO uint32_t RESULT;
X        volatile uint32_t RESULT;
N        stc_adc_result_field_t RESULT_f;
N    };
N    union
N    {
N        __IO uint32_t RESULTACC;
X        volatile uint32_t RESULTACC;
N        stc_adc_resultacc_field_t RESULTACC_f;
N    };
N    union
N    {
N        __IO uint32_t HT;
X        volatile uint32_t HT;
N        stc_adc_ht_field_t HT_f;
N    };
N    union
N    {
N        __IO uint32_t LT;
X        volatile uint32_t LT;
N        stc_adc_lt_field_t LT_f;
N    };
N    union
N    {
N        __IO uint32_t IFR;
X        volatile uint32_t IFR;
N        stc_adc_ifr_field_t IFR_f;
N    };
N    union
N    {
N        __IO uint32_t ICR;
X        volatile uint32_t ICR;
N        stc_adc_icr_field_t ICR_f;
N    };
N    union
N    {
N        __IO uint32_t EXTTRIGGER0;
X        volatile uint32_t EXTTRIGGER0;
N        stc_adc_exttrigger0_field_t EXTTRIGGER0_f;
N    };
N    union
N    {
N        __IO uint32_t EXTTRIGGER1;
X        volatile uint32_t EXTTRIGGER1;
N        stc_adc_exttrigger1_field_t EXTTRIGGER1_f;
N    };
N    union
N    {
N        __IO uint32_t SGLSTART;
X        volatile uint32_t SGLSTART;
N        stc_adc_sglstart_field_t SGLSTART_f;
N    };
N    union
N    {
N        __IO uint32_t SQRSTART;
X        volatile uint32_t SQRSTART;
N        stc_adc_sqrstart_field_t SQRSTART_f;
N    };
N    union
N    {
N        __IO uint32_t JQRSTART;
X        volatile uint32_t JQRSTART;
N        stc_adc_jqrstart_field_t JQRSTART_f;
N    };
N}M0P_ADC_TypeDef;
N
Ntypedef struct
N{
N    union
N    {
N        __IO uint32_t CR;
X        volatile uint32_t CR;
N        stc_aes_cr_field_t CR_f;
N    };
N    uint8_t RESERVED1[12];
N    union
N    {
N        __IO uint32_t DATA0;
X        volatile uint32_t DATA0;
N        stc_aes_data0_field_t DATA0_f;
N    };
N    union
N    {
N        __IO uint32_t DATA1;
X        volatile uint32_t DATA1;
N        stc_aes_data1_field_t DATA1_f;
N    };
N    union
N    {
N        __IO uint32_t DATA2;
X        volatile uint32_t DATA2;
N        stc_aes_data2_field_t DATA2_f;
N    };
N    union
N    {
N        __IO uint32_t DATA3;
X        volatile uint32_t DATA3;
N        stc_aes_data3_field_t DATA3_f;
N    };
N    union
N    {
N        __IO uint32_t KEY0;
X        volatile uint32_t KEY0;
N        stc_aes_key0_field_t KEY0_f;
N    };
N    union
N    {
N        __IO uint32_t KEY1;
X        volatile uint32_t KEY1;
N        stc_aes_key1_field_t KEY1_f;
N    };
N    union
N    {
N        __IO uint32_t KEY2;
X        volatile uint32_t KEY2;
N        stc_aes_key2_field_t KEY2_f;
N    };
N    union
N    {
N        __IO uint32_t KEY3;
X        volatile uint32_t KEY3;
N        stc_aes_key3_field_t KEY3_f;
N    };
N}M0P_AES_TypeDef;
N
Ntypedef struct
N{
N    union
N    {
N        __IO uint32_t CR;
X        volatile uint32_t CR;
N        stc_bgr_cr_field_t CR_f;
N    };
N}M0P_BGR_TypeDef;
N
Ntypedef struct
N{
N    union
N    {
N        __IO uint32_t CR;
X        volatile uint32_t CR;
N        stc_clk_trim_cr_field_t CR_f;
N    };
N    union
N    {
N        __IO uint32_t REFCON;
X        volatile uint32_t REFCON;
N        stc_clk_trim_refcon_field_t REFCON_f;
N    };
N    union
N    {
N        __IO uint32_t REFCNT;
X        volatile uint32_t REFCNT;
N        stc_clk_trim_refcnt_field_t REFCNT_f;
N    };
N    union
N    {
N        __IO uint32_t CALCNT;
X        volatile uint32_t CALCNT;
N        stc_clk_trim_calcnt_field_t CALCNT_f;
N    };
N    union
N    {
N        __IO uint32_t IFR;
X        volatile uint32_t IFR;
N        stc_clk_trim_ifr_field_t IFR_f;
N    };
N    union
N    {
N        __IO uint32_t ICLR;
X        volatile uint32_t ICLR;
N        stc_clk_trim_iclr_field_t ICLR_f;
N    };
N    union
N    {
N        __IO uint32_t CALCON;
X        volatile uint32_t CALCON;
N        stc_clk_trim_calcon_field_t CALCON_f;
N    };
N}M0P_CLK_TRIM_TypeDef;
N
Ntypedef struct
N{
N    union
N    {
N        __IO uint32_t CR;
X        volatile uint32_t CR;
N        stc_crc_cr_field_t CR_f;
N    };
N    union
N    {
N        __IO uint32_t RESULT;
X        volatile uint32_t RESULT;
N        stc_crc_result_field_t RESULT_f;
N    };
N    uint8_t RESERVED2[120];
N    union
N    {
N        __IO uint32_t DATA;
X        volatile uint32_t DATA;
N        stc_crc_data_field_t DATA_f;
N    };
N}M0P_CRC_TypeDef;
N
Ntypedef struct
N{
N    union
N    {
N        __IO uint32_t DEBUG_ACTIVE;
X        volatile uint32_t DEBUG_ACTIVE;
N        stc_debug_active_field_t DEBUG_ACTIVE_f;
N    };
N}M0P_DEBUG_ACTIVE_TypeDef;
N
Ntypedef struct
N{
N    union
N    {
N        __IO uint32_t CONF;
X        volatile uint32_t CONF;
N        stc_dmac_conf_field_t CONF_f;
N    };
N    uint8_t RESERVED1[12];
N    union
N    {
N        __IO uint32_t CONFA0;
X        volatile uint32_t CONFA0;
N        stc_dmac_confa0_field_t CONFA0_f;
N    };
N    union
N    {
N        __IO uint32_t CONFB0;
X        volatile uint32_t CONFB0;
N        stc_dmac_confb0_field_t CONFB0_f;
N    };
N    union
N    {
N        __IO uint32_t SRCADR0;
X        volatile uint32_t SRCADR0;
N        stc_dmac_srcadr0_field_t SRCADR0_f;
N    };
N    union
N    {
N        __IO uint32_t DSTADR0;
X        volatile uint32_t DSTADR0;
N        stc_dmac_dstadr0_field_t DSTADR0_f;
N    };
N    union
N    {
N        __IO uint32_t CONFA1;
X        volatile uint32_t CONFA1;
N        stc_dmac_confa1_field_t CONFA1_f;
N    };
N    union
N    {
N        __IO uint32_t CONFB1;
X        volatile uint32_t CONFB1;
N        stc_dmac_confb1_field_t CONFB1_f;
N    };
N    union
N    {
N        __IO uint32_t SRCADR1;
X        volatile uint32_t SRCADR1;
N        stc_dmac_srcadr1_field_t SRCADR1_f;
N    };
N    union
N    {
N        __IO uint32_t DSTADR1;
X        volatile uint32_t DSTADR1;
N        stc_dmac_dstadr1_field_t DSTADR1_f;
N    };
N}M0P_DMAC_TypeDef;
N
Ntypedef struct
N{
N    union
N    {
N        __IO uint32_t TNVS;
X        volatile uint32_t TNVS;
N        stc_flash_tnvs_field_t TNVS_f;
N    };
N    union
N    {
N        __IO uint32_t TPGS;
X        volatile uint32_t TPGS;
N        stc_flash_tpgs_field_t TPGS_f;
N    };
N    union
N    {
N        __IO uint32_t TPROG;
X        volatile uint32_t TPROG;
N        stc_flash_tprog_field_t TPROG_f;
N    };
N    union
N    {
N        __IO uint32_t TSERASE;
X        volatile uint32_t TSERASE;
N        stc_flash_tserase_field_t TSERASE_f;
N    };
N    union
N    {
N        __IO uint32_t TMERASE;
X        volatile uint32_t TMERASE;
N        stc_flash_tmerase_field_t TMERASE_f;
N    };
N    union
N    {
N        __IO uint32_t TPRCV;
X        volatile uint32_t TPRCV;
N        stc_flash_tprcv_field_t TPRCV_f;
N    };
N    union
N    {
N        __IO uint32_t TSRCV;
X        volatile uint32_t TSRCV;
N        stc_flash_tsrcv_field_t TSRCV_f;
N    };
N    union
N    {
N        __IO uint32_t TMRCV;
X        volatile uint32_t TMRCV;
N        stc_flash_tmrcv_field_t TMRCV_f;
N    };
N    union
N    {
N        __IO uint32_t CR;
X        volatile uint32_t CR;
N        stc_flash_cr_field_t CR_f;
N    };
N    union
N    {
N        __IO uint32_t IFR;
X        volatile uint32_t IFR;
N        stc_flash_ifr_field_t IFR_f;
N    };
N    union
N    {
N        __IO uint32_t ICLR;
X        volatile uint32_t ICLR;
N        stc_flash_iclr_field_t ICLR_f;
N    };
N    union
N    {
N        __IO uint32_t BYPASS;
X        volatile uint32_t BYPASS;
N        stc_flash_bypass_field_t BYPASS_f;
N    };
N    union
N    {
N        __IO uint32_t SLOCK;
X        volatile uint32_t SLOCK;
N        stc_flash_slock_field_t SLOCK_f;
N    };
N}M0P_FLASH_TypeDef;
N
Ntypedef struct
N{
N    union
N    {
N        __IO uint32_t PA00_SEL;
X        volatile uint32_t PA00_SEL;
N        stc_gpio_pa00_sel_field_t PA00_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PA01_SEL;
X        volatile uint32_t PA01_SEL;
N        stc_gpio_pa01_sel_field_t PA01_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PA02_SEL;
X        volatile uint32_t PA02_SEL;
N        stc_gpio_pa02_sel_field_t PA02_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PA03_SEL;
X        volatile uint32_t PA03_SEL;
N        stc_gpio_pa03_sel_field_t PA03_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PA04_SEL;
X        volatile uint32_t PA04_SEL;
N        stc_gpio_pa04_sel_field_t PA04_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PA05_SEL;
X        volatile uint32_t PA05_SEL;
N        stc_gpio_pa05_sel_field_t PA05_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PA06_SEL;
X        volatile uint32_t PA06_SEL;
N        stc_gpio_pa06_sel_field_t PA06_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PA07_SEL;
X        volatile uint32_t PA07_SEL;
N        stc_gpio_pa07_sel_field_t PA07_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PA08_SEL;
X        volatile uint32_t PA08_SEL;
N        stc_gpio_pa08_sel_field_t PA08_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PA09_SEL;
X        volatile uint32_t PA09_SEL;
N        stc_gpio_pa09_sel_field_t PA09_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PA10_SEL;
X        volatile uint32_t PA10_SEL;
N        stc_gpio_pa10_sel_field_t PA10_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PA11_SEL;
X        volatile uint32_t PA11_SEL;
N        stc_gpio_pa11_sel_field_t PA11_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PA12_SEL;
X        volatile uint32_t PA12_SEL;
N        stc_gpio_pa12_sel_field_t PA12_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PA13_SEL;
X        volatile uint32_t PA13_SEL;
N        stc_gpio_pa13_sel_field_t PA13_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PA14_SEL;
X        volatile uint32_t PA14_SEL;
N        stc_gpio_pa14_sel_field_t PA14_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PA15_SEL;
X        volatile uint32_t PA15_SEL;
N        stc_gpio_pa15_sel_field_t PA15_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PB00_SEL;
X        volatile uint32_t PB00_SEL;
N        stc_gpio_pb00_sel_field_t PB00_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PB01_SEL;
X        volatile uint32_t PB01_SEL;
N        stc_gpio_pb01_sel_field_t PB01_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PB02_SEL;
X        volatile uint32_t PB02_SEL;
N        stc_gpio_pb02_sel_field_t PB02_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PB03_SEL;
X        volatile uint32_t PB03_SEL;
N        stc_gpio_pb03_sel_field_t PB03_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PB04_SEL;
X        volatile uint32_t PB04_SEL;
N        stc_gpio_pb04_sel_field_t PB04_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PB05_SEL;
X        volatile uint32_t PB05_SEL;
N        stc_gpio_pb05_sel_field_t PB05_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PB06_SEL;
X        volatile uint32_t PB06_SEL;
N        stc_gpio_pb06_sel_field_t PB06_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PB07_SEL;
X        volatile uint32_t PB07_SEL;
N        stc_gpio_pb07_sel_field_t PB07_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PB08_SEL;
X        volatile uint32_t PB08_SEL;
N        stc_gpio_pb08_sel_field_t PB08_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PB09_SEL;
X        volatile uint32_t PB09_SEL;
N        stc_gpio_pb09_sel_field_t PB09_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PB10_SEL;
X        volatile uint32_t PB10_SEL;
N        stc_gpio_pb10_sel_field_t PB10_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PB11_SEL;
X        volatile uint32_t PB11_SEL;
N        stc_gpio_pb11_sel_field_t PB11_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PB12_SEL;
X        volatile uint32_t PB12_SEL;
N        stc_gpio_pb12_sel_field_t PB12_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PB13_SEL;
X        volatile uint32_t PB13_SEL;
N        stc_gpio_pb13_sel_field_t PB13_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PB14_SEL;
X        volatile uint32_t PB14_SEL;
N        stc_gpio_pb14_sel_field_t PB14_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PB15_SEL;
X        volatile uint32_t PB15_SEL;
N        stc_gpio_pb15_sel_field_t PB15_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PC00_SEL;
X        volatile uint32_t PC00_SEL;
N        stc_gpio_pc00_sel_field_t PC00_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PC01_SEL;
X        volatile uint32_t PC01_SEL;
N        stc_gpio_pc01_sel_field_t PC01_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PC02_SEL;
X        volatile uint32_t PC02_SEL;
N        stc_gpio_pc02_sel_field_t PC02_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PC03_SEL;
X        volatile uint32_t PC03_SEL;
N        stc_gpio_pc03_sel_field_t PC03_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PC04_SEL;
X        volatile uint32_t PC04_SEL;
N        stc_gpio_pc04_sel_field_t PC04_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PC05_SEL;
X        volatile uint32_t PC05_SEL;
N        stc_gpio_pc05_sel_field_t PC05_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PC06_SEL;
X        volatile uint32_t PC06_SEL;
N        stc_gpio_pc06_sel_field_t PC06_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PC07_SEL;
X        volatile uint32_t PC07_SEL;
N        stc_gpio_pc07_sel_field_t PC07_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PC08_SEL;
X        volatile uint32_t PC08_SEL;
N        stc_gpio_pc08_sel_field_t PC08_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PC09_SEL;
X        volatile uint32_t PC09_SEL;
N        stc_gpio_pc09_sel_field_t PC09_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PC10_SEL;
X        volatile uint32_t PC10_SEL;
N        stc_gpio_pc10_sel_field_t PC10_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PC11_SEL;
X        volatile uint32_t PC11_SEL;
N        stc_gpio_pc11_sel_field_t PC11_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PC12_SEL;
X        volatile uint32_t PC12_SEL;
N        stc_gpio_pc12_sel_field_t PC12_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PC13_SEL;
X        volatile uint32_t PC13_SEL;
N        stc_gpio_pc13_sel_field_t PC13_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PC14_SEL;
X        volatile uint32_t PC14_SEL;
N        stc_gpio_pc14_sel_field_t PC14_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PC15_SEL;
X        volatile uint32_t PC15_SEL;
N        stc_gpio_pc15_sel_field_t PC15_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PD00_SEL;
X        volatile uint32_t PD00_SEL;
N        stc_gpio_pd00_sel_field_t PD00_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PD01_SEL;
X        volatile uint32_t PD01_SEL;
N        stc_gpio_pd01_sel_field_t PD01_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PD02_SEL;
X        volatile uint32_t PD02_SEL;
N        stc_gpio_pd02_sel_field_t PD02_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PD03_SEL;
X        volatile uint32_t PD03_SEL;
N        stc_gpio_pd03_sel_field_t PD03_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PD04_SEL;
X        volatile uint32_t PD04_SEL;
N        stc_gpio_pd04_sel_field_t PD04_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PD05_SEL;
X        volatile uint32_t PD05_SEL;
N        stc_gpio_pd05_sel_field_t PD05_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PD06_SEL;
X        volatile uint32_t PD06_SEL;
N        stc_gpio_pd06_sel_field_t PD06_SEL_f;
N    };
N    union
N    {
N        __IO uint32_t PD07_SEL;
X        volatile uint32_t PD07_SEL;
N        stc_gpio_pd07_sel_field_t PD07_SEL_f;
N    };
N    uint8_t RESERVED56[32];
N    union
N    {
N        __IO uint32_t PADIR;
X        volatile uint32_t PADIR;
N        stc_gpio_padir_field_t PADIR_f;
N    };
N    union
N    {
N        __IO uint32_t PAIN;
X        volatile uint32_t PAIN;
N        stc_gpio_pain_field_t PAIN_f;
N    };
N    union
N    {
N        __IO uint32_t PAOUT;
X        volatile uint32_t PAOUT;
N        stc_gpio_paout_field_t PAOUT_f;
N    };
N    union
N    {
N        __IO uint32_t PAADS;
X        volatile uint32_t PAADS;
N        stc_gpio_paads_field_t PAADS_f;
N    };
N    union
N    {
N        __IO uint32_t PABSET;
X        volatile uint32_t PABSET;
N        stc_gpio_pabset_field_t PABSET_f;
N    };
N    union
N    {
N        __IO uint32_t PABCLR;
X        volatile uint32_t PABCLR;
N        stc_gpio_pabclr_field_t PABCLR_f;
N    };
N    union
N    {
N        __IO uint32_t PABSETCLR;
X        volatile uint32_t PABSETCLR;
N        stc_gpio_pabsetclr_field_t PABSETCLR_f;
N    };
N    union
N    {
N        __IO uint32_t PADR;
X        volatile uint32_t PADR;
N        stc_gpio_padr_field_t PADR_f;
N    };
N    union
N    {
N        __IO uint32_t PAPU;
X        volatile uint32_t PAPU;
N        stc_gpio_papu_field_t PAPU_f;
N    };
N    union
N    {
N        __IO uint32_t PAPD;
X        volatile uint32_t PAPD;
N        stc_gpio_papd_field_t PAPD_f;
N    };
N    uint8_t RESERVED66[4];
N    union
N    {
N        __IO uint32_t PAOD;
X        volatile uint32_t PAOD;
N        stc_gpio_paod_field_t PAOD_f;
N    };
N    union
N    {
N        __IO uint32_t PAHIE;
X        volatile uint32_t PAHIE;
N        stc_gpio_pahie_field_t PAHIE_f;
N    };
N    union
N    {
N        __IO uint32_t PALIE;
X        volatile uint32_t PALIE;
N        stc_gpio_palie_field_t PALIE_f;
N    };
N    union
N    {
N        __IO uint32_t PARIE;
X        volatile uint32_t PARIE;
N        stc_gpio_parie_field_t PARIE_f;
N    };
N    union
N    {
N        __IO uint32_t PAFIE;
X        volatile uint32_t PAFIE;
N        stc_gpio_pafie_field_t PAFIE_f;
N    };
N    union
N    {
N        __IO uint32_t PBDIR;
X        volatile uint32_t PBDIR;
N        stc_gpio_pbdir_field_t PBDIR_f;
N    };
N    union
N    {
N        __IO uint32_t PBIN;
X        volatile uint32_t PBIN;
N        stc_gpio_pbin_field_t PBIN_f;
N    };
N    union
N    {
N        __IO uint32_t PBOUT;
X        volatile uint32_t PBOUT;
N        stc_gpio_pbout_field_t PBOUT_f;
N    };
N    union
N    {
N        __IO uint32_t PBADS;
X        volatile uint32_t PBADS;
N        stc_gpio_pbads_field_t PBADS_f;
N    };
N    union
N    {
N        __IO uint32_t PBBSET;
X        volatile uint32_t PBBSET;
N        stc_gpio_pbbset_field_t PBBSET_f;
N    };
N    union
N    {
N        __IO uint32_t PBBCLR;
X        volatile uint32_t PBBCLR;
N        stc_gpio_pbbclr_field_t PBBCLR_f;
N    };
N    union
N    {
N        __IO uint32_t PBBSETCLR;
X        volatile uint32_t PBBSETCLR;
N        stc_gpio_pbbsetclr_field_t PBBSETCLR_f;
N    };
N    union
N    {
N        __IO uint32_t PBDR;
X        volatile uint32_t PBDR;
N        stc_gpio_pbdr_field_t PBDR_f;
N    };
N    union
N    {
N        __IO uint32_t PBPU;
X        volatile uint32_t PBPU;
N        stc_gpio_pbpu_field_t PBPU_f;
N    };
N    union
N    {
N        __IO uint32_t PBPD;
X        volatile uint32_t PBPD;
N        stc_gpio_pbpd_field_t PBPD_f;
N    };
N    uint8_t RESERVED81[4];
N    union
N    {
N        __IO uint32_t PBOD;
X        volatile uint32_t PBOD;
N        stc_gpio_pbod_field_t PBOD_f;
N    };
N    union
N    {
N        __IO uint32_t PBHIE;
X        volatile uint32_t PBHIE;
N        stc_gpio_pbhie_field_t PBHIE_f;
N    };
N    union
N    {
N        __IO uint32_t PBLIE;
X        volatile uint32_t PBLIE;
N        stc_gpio_pblie_field_t PBLIE_f;
N    };
N    union
N    {
N        __IO uint32_t PBRIE;
X        volatile uint32_t PBRIE;
N        stc_gpio_pbrie_field_t PBRIE_f;
N    };
N    union
N    {
N        __IO uint32_t PBFIE;
X        volatile uint32_t PBFIE;
N        stc_gpio_pbfie_field_t PBFIE_f;
N    };
N    union
N    {
N        __IO uint32_t PCDIR;
X        volatile uint32_t PCDIR;
N        stc_gpio_pcdir_field_t PCDIR_f;
N    };
N    union
N    {
N        __IO uint32_t PCIN;
X        volatile uint32_t PCIN;
N        stc_gpio_pcin_field_t PCIN_f;
N    };
N    union
N    {
N        __IO uint32_t PCOUT;
X        volatile uint32_t PCOUT;
N        stc_gpio_pcout_field_t PCOUT_f;
N    };
N    union
N    {
N        __IO uint32_t PCADS;
X        volatile uint32_t PCADS;
N        stc_gpio_pcads_field_t PCADS_f;
N    };
N    union
N    {
N        __IO uint32_t PCBSET;
X        volatile uint32_t PCBSET;
N        stc_gpio_pcbset_field_t PCBSET_f;
N    };
N    union
N    {
N        __IO uint32_t PCBCLR;
X        volatile uint32_t PCBCLR;
N        stc_gpio_pcbclr_field_t PCBCLR_f;
N    };
N    union
N    {
N        __IO uint32_t PCBSETCLR;
X        volatile uint32_t PCBSETCLR;
N        stc_gpio_pcbsetclr_field_t PCBSETCLR_f;
N    };
N    union
N    {
N        __IO uint32_t PCDR;
X        volatile uint32_t PCDR;
N        stc_gpio_pcdr_field_t PCDR_f;
N    };
N    union
N    {
N        __IO uint32_t PCPU;
X        volatile uint32_t PCPU;
N        stc_gpio_pcpu_field_t PCPU_f;
N    };
N    union
N    {
N        __IO uint32_t PCPD;
X        volatile uint32_t PCPD;
N        stc_gpio_pcpd_field_t PCPD_f;
N    };
N    uint8_t RESERVED96[4];
N    union
N    {
N        __IO uint32_t PCOD;
X        volatile uint32_t PCOD;
N        stc_gpio_pcod_field_t PCOD_f;
N    };
N    union
N    {
N        __IO uint32_t PCHIE;
X        volatile uint32_t PCHIE;
N        stc_gpio_pchie_field_t PCHIE_f;
N    };
N    union
N    {
N        __IO uint32_t PCLIE;
X        volatile uint32_t PCLIE;
N        stc_gpio_pclie_field_t PCLIE_f;
N    };
N    union
N    {
N        __IO uint32_t PCRIE;
X        volatile uint32_t PCRIE;
N        stc_gpio_pcrie_field_t PCRIE_f;
N    };
N    union
N    {
N        __IO uint32_t PCFIE;
X        volatile uint32_t PCFIE;
N        stc_gpio_pcfie_field_t PCFIE_f;
N    };
N    union
N    {
N        __IO uint32_t PDDIR;
X        volatile uint32_t PDDIR;
N        stc_gpio_pddir_field_t PDDIR_f;
N    };
N    union
N    {
N        __IO uint32_t PDIN;
X        volatile uint32_t PDIN;
N        stc_gpio_pdin_field_t PDIN_f;
N    };
N    union
N    {
N        __IO uint32_t PDOUT;
X        volatile uint32_t PDOUT;
N        stc_gpio_pdout_field_t PDOUT_f;
N    };
N    union
N    {
N        __IO uint32_t PDADS;
X        volatile uint32_t PDADS;
N        stc_gpio_pdads_field_t PDADS_f;
N    };
N    union
N    {
N        __IO uint32_t PDBSET;
X        volatile uint32_t PDBSET;
N        stc_gpio_pdbset_field_t PDBSET_f;
N    };
N    union
N    {
N        __IO uint32_t PDBCLR;
X        volatile uint32_t PDBCLR;
N        stc_gpio_pdbclr_field_t PDBCLR_f;
N    };
N    union
N    {
N        __IO uint32_t PDBSETCLR;
X        volatile uint32_t PDBSETCLR;
N        stc_gpio_pdbsetclr_field_t PDBSETCLR_f;
N    };
N    union
N    {
N        __IO uint32_t PDDR;
X        volatile uint32_t PDDR;
N        stc_gpio_pddr_field_t PDDR_f;
N    };
N    union
N    {
N        __IO uint32_t PDPU;
X        volatile uint32_t PDPU;
N        stc_gpio_pdpu_field_t PDPU_f;
N    };
N    union
N    {
N        __IO uint32_t PDPD;
X        volatile uint32_t PDPD;
N        stc_gpio_pdpd_field_t PDPD_f;
N    };
N    uint8_t RESERVED111[4];
N    union
N    {
N        __IO uint32_t PDOD;
X        volatile uint32_t PDOD;
N        stc_gpio_pdod_field_t PDOD_f;
N    };
N    union
N    {
N        __IO uint32_t PDHIE;
X        volatile uint32_t PDHIE;
N        stc_gpio_pdhie_field_t PDHIE_f;
N    };
N    union
N    {
N        __IO uint32_t PDLIE;
X        volatile uint32_t PDLIE;
N        stc_gpio_pdlie_field_t PDLIE_f;
N    };
N    union
N    {
N        __IO uint32_t PDRIE;
X        volatile uint32_t PDRIE;
N        stc_gpio_pdrie_field_t PDRIE_f;
N    };
N    union
N    {
N        __IO uint32_t PDFIE;
X        volatile uint32_t PDFIE;
N        stc_gpio_pdfie_field_t PDFIE_f;
N    };
N    union
N    {
N        __IO uint32_t PA_STAT;
X        volatile uint32_t PA_STAT;
N        stc_gpio_pa_stat_field_t PA_STAT_f;
N    };
N    uint8_t RESERVED117[12];
N    union
N    {
N        __IO uint32_t PA_ICLR;
X        volatile uint32_t PA_ICLR;
N        stc_gpio_pa_iclr_field_t PA_ICLR_f;
N    };
N    uint8_t RESERVED118[44];
N    union
N    {
N        __IO uint32_t PB_STAT;
X        volatile uint32_t PB_STAT;
N        stc_gpio_pb_stat_field_t PB_STAT_f;
N    };
N    uint8_t RESERVED119[12];
N    union
N    {
N        __IO uint32_t PB_ICLR;
X        volatile uint32_t PB_ICLR;
N        stc_gpio_pb_iclr_field_t PB_ICLR_f;
N    };
N    uint8_t RESERVED120[44];
N    union
N    {
N        __IO uint32_t PC_STAT;
X        volatile uint32_t PC_STAT;
N        stc_gpio_pc_stat_field_t PC_STAT_f;
N    };
N    uint8_t RESERVED121[12];
N    union
N    {
N        __IO uint32_t PC_ICLR;
X        volatile uint32_t PC_ICLR;
N        stc_gpio_pc_iclr_field_t PC_ICLR_f;
N    };
N    uint8_t RESERVED122[44];
N    union
N    {
N        __IO uint32_t PD_STAT;
X        volatile uint32_t PD_STAT;
N        stc_gpio_pd_stat_field_t PD_STAT_f;
N    };
N    uint8_t RESERVED123[12];
N    union
N    {
N        __IO uint32_t PD_ICLR;
X        volatile uint32_t PD_ICLR;
N        stc_gpio_pd_iclr_field_t PD_ICLR_f;
N    };
N    uint8_t RESERVED124[44];
N    union
N    {
N        __IO uint32_t CTRL0;
X        volatile uint32_t CTRL0;
N        stc_gpio_ctrl0_field_t CTRL0_f;
N    };
N    union
N    {
N        __IO uint32_t CTRL1;
X        volatile uint32_t CTRL1;
N        stc_gpio_ctrl1_field_t CTRL1_f;
N    };
N    union
N    {
N        __IO uint32_t CTRL2;
X        volatile uint32_t CTRL2;
N        stc_gpio_ctrl2_field_t CTRL2_f;
N    };
N    union
N    {
N        __IO uint32_t TIMGS;
X        volatile uint32_t TIMGS;
N        stc_gpio_timgs_field_t TIMGS_f;
N    };
N    union
N    {
N        __IO uint32_t TIMES;
X        volatile uint32_t TIMES;
N        stc_gpio_times_field_t TIMES_f;
N    };
N    union
N    {
N        __IO uint32_t TIMCPS;
X        volatile uint32_t TIMCPS;
N        stc_gpio_timcps_field_t TIMCPS_f;
N    };
N    union
N    {
N        __IO uint32_t PCAS;
X        volatile uint32_t PCAS;
N        stc_gpio_pcas_field_t PCAS_f;
N    };
N}M0P_GPIO_TypeDef;
N
Ntypedef struct
N{
N    union
N    {
N        __IO uint32_t DIVIDEND;
X        volatile uint32_t DIVIDEND;
N        stc_hdiv_dividend_field_t DIVIDEND_f;
N    };
N    union
N    {
N        __IO uint32_t DIVISOR;
X        volatile uint32_t DIVISOR;
N        stc_hdiv_divisor_field_t DIVISOR_f;
N    };
N    union
N    {
N        __IO uint32_t QUOTIENT;
X        volatile uint32_t QUOTIENT;
N        stc_hdiv_quotient_field_t QUOTIENT_f;
N    };
N    union
N    {
N        __IO uint32_t REMAINDER;
X        volatile uint32_t REMAINDER;
N        stc_hdiv_remainder_field_t REMAINDER_f;
N    };
N    union
N    {
N        __IO uint32_t SIGN;
X        volatile uint32_t SIGN;
N        stc_hdiv_sign_field_t SIGN_f;
N    };
N    union
N    {
N        __IO uint32_t STAT;
X        volatile uint32_t STAT;
N        stc_hdiv_stat_field_t STAT_f;
N    };
N}M0P_HDIV_TypeDef;
N
Ntypedef struct
N{
N    union
N    {
N        __IO uint32_t TMRUN;
X        volatile uint32_t TMRUN;
N        stc_i2c_tmrun_field_t TMRUN_f;
N    };
N    union
N    {
N        __IO uint32_t TM;
X        volatile uint32_t TM;
N        stc_i2c_tm_field_t TM_f;
N    };
N    union
N    {
N        __IO uint32_t CR;
X        volatile uint32_t CR;
N        stc_i2c_cr_field_t CR_f;
N    };
N    union
N    {
N        __IO uint32_t DATA;
X        volatile uint32_t DATA;
N        stc_i2c_data_field_t DATA_f;
N    };
N    union
N    {
N        __IO uint32_t ADDR;
X        volatile uint32_t ADDR;
N        stc_i2c_addr_field_t ADDR_f;
N    };
N    union
N    {
N        __IO uint32_t STAT;
X        volatile uint32_t STAT;
N        stc_i2c_stat_field_t STAT_f;
N    };
N}M0P_I2C_TypeDef;
N
Ntypedef struct
N{
N    union
N    {
N        __IO uint32_t CR0;
X        volatile uint32_t CR0;
N        stc_lcd_cr0_field_t CR0_f;
N    };
N    union
N    {
N        __IO uint32_t CR1;
X        volatile uint32_t CR1;
N        stc_lcd_cr1_field_t CR1_f;
N    };
N    union
N    {
N        __IO uint32_t INTCLR;
X        volatile uint32_t INTCLR;
N        stc_lcd_intclr_field_t INTCLR_f;
N    };
N    union
N    {
N        __IO uint32_t POEN0;
X        volatile uint32_t POEN0;
N        stc_lcd_poen0_field_t POEN0_f;
N    };
N    union
N    {
N        __IO uint32_t POEN1;
X        volatile uint32_t POEN1;
N        stc_lcd_poen1_field_t POEN1_f;
N    };
N    uint8_t RESERVED5[44];
N    union
N    {
N        __IO uint32_t RAM0;
X        volatile uint32_t RAM0;
N        stc_lcd_ram0_field_t RAM0_f;
N    };
N    union
N    {
N        __IO uint32_t RAM1;
X        volatile uint32_t RAM1;
N        stc_lcd_ram1_field_t RAM1_f;
N    };
N    union
N    {
N        __IO uint32_t RAM2;
X        volatile uint32_t RAM2;
N        stc_lcd_ram2_field_t RAM2_f;
N    };
N    union
N    {
N        __IO uint32_t RAM3;
X        volatile uint32_t RAM3;
N        stc_lcd_ram3_field_t RAM3_f;
N    };
N    union
N    {
N        __IO uint32_t RAM4;
X        volatile uint32_t RAM4;
N        stc_lcd_ram4_field_t RAM4_f;
N    };
N    union
N    {
N        __IO uint32_t RAM5;
X        volatile uint32_t RAM5;
N        stc_lcd_ram5_field_t RAM5_f;
N    };
N    union
N    {
N        __IO uint32_t RAM6;
X        volatile uint32_t RAM6;
N        stc_lcd_ram6_field_t RAM6_f;
N    };
N    union
N    {
N        __IO uint32_t RAM7;
X        volatile uint32_t RAM7;
N        stc_lcd_ram7_field_t RAM7_f;
N    };
N    union
N    {
N        __IO uint32_t RAM8;
X        volatile uint32_t RAM8;
N        stc_lcd_ram8_field_t RAM8_f;
N    };
N    union
N    {
N        __IO uint32_t RAM9;
X        volatile uint32_t RAM9;
N        stc_lcd_ram9_field_t RAM9_f;
N    };
N    union
N    {
N        __IO uint32_t RAMA;
X        volatile uint32_t RAMA;
N        stc_lcd_rama_field_t RAMA_f;
N    };
N    union
N    {
N        __IO uint32_t RAMB;
X        volatile uint32_t RAMB;
N        stc_lcd_ramb_field_t RAMB_f;
N    };
N    union
N    {
N        __IO uint32_t RAMC;
X        volatile uint32_t RAMC;
N        stc_lcd_ramc_field_t RAMC_f;
N    };
N    union
N    {
N        __IO uint32_t RAMD;
X        volatile uint32_t RAMD;
N        stc_lcd_ramd_field_t RAMD_f;
N    };
N    union
N    {
N        __IO uint32_t RAME;
X        volatile uint32_t RAME;
N        stc_lcd_rame_field_t RAME_f;
N    };
N    union
N    {
N        __IO uint32_t RAMF;
X        volatile uint32_t RAMF;
N        stc_lcd_ramf_field_t RAMF_f;
N    };
N}M0P_LCD_TypeDef;
N
Ntypedef struct
N{
N    union
N    {
N        __IO uint32_t CNT;
X        volatile uint32_t CNT;
N        stc_lptimer_cnt_field_t CNT_f;
N    };
N    union
N    {
N        __IO uint32_t ARR;
X        volatile uint32_t ARR;
N        stc_lptimer_arr_field_t ARR_f;
N    };
N    uint8_t RESERVED2[4];
N    union
N    {
N        __IO uint32_t CR;
X        volatile uint32_t CR;
N        stc_lptimer_cr_field_t CR_f;
N    };
N    union
N    {
N        __IO uint32_t IFR;
X        volatile uint32_t IFR;
N        stc_lptimer_ifr_field_t IFR_f;
N    };
N    union
N    {
N        __IO uint32_t ICLR;
X        volatile uint32_t ICLR;
N        stc_lptimer_iclr_field_t ICLR_f;
N    };
N}M0P_LPTIMER_TypeDef;
N
Ntypedef struct
N{
N    union
N    {
N        __IO uint32_t SBUF;
X        volatile uint32_t SBUF;
N        stc_lpuart_sbuf_field_t SBUF_f;
N    };
N    union
N    {
N        __IO uint32_t SCON;
X        volatile uint32_t SCON;
N        stc_lpuart_scon_field_t SCON_f;
N    };
N    union
N    {
N        __IO uint32_t SADDR;
X        volatile uint32_t SADDR;
N        stc_lpuart_saddr_field_t SADDR_f;
N    };
N    union
N    {
N        __IO uint32_t SADEN;
X        volatile uint32_t SADEN;
N        stc_lpuart_saden_field_t SADEN_f;
N    };
N    union
N    {
N        __IO uint32_t ISR;
X        volatile uint32_t ISR;
N        stc_lpuart_isr_field_t ISR_f;
N    };
N    union
N    {
N        __IO uint32_t ICR;
X        volatile uint32_t ICR;
N        stc_lpuart_icr_field_t ICR_f;
N    };
N    union
N    {
N        __IO uint32_t SCNT;
X        volatile uint32_t SCNT;
N        stc_lpuart_scnt_field_t SCNT_f;
N    };
N}M0P_LPUART_TypeDef;
N
Ntypedef struct
N{
N    uint8_t RESERVED0[40];
N    union
N    {
N        __IO uint32_t CR;
X        volatile uint32_t CR;
N        stc_lvd_cr_field_t CR_f;
N    };
N    union
N    {
N        __IO uint32_t IFR;
X        volatile uint32_t IFR;
N        stc_lvd_ifr_field_t IFR_f;
N    };
N}M0P_LVD_TypeDef;
N
Ntypedef struct
N{
N    uint8_t RESERVED0[48];
N    union
N    {
N        __IO uint32_t CR0;
X        volatile uint32_t CR0;
N        stc_opa_cr0_field_t CR0_f;
N    };
N    union
N    {
N        __IO uint32_t CR1;
X        volatile uint32_t CR1;
N        stc_opa_cr1_field_t CR1_f;
N    };
N    union
N    {
N        __IO uint32_t CR2;
X        volatile uint32_t CR2;
N        stc_opa_cr2_field_t CR2_f;
N    };
N    union
N    {
N        __IO uint8_t CR;
X        volatile uint8_t CR;
N        stc_opa_cr_field_t CR_f;
N    };
N}M0P_OPA_TypeDef;
N
Ntypedef struct
N{
N    union
N    {
N        __IO uint32_t CCON;
X        volatile uint32_t CCON;
N        stc_pca_ccon_field_t CCON_f;
N    };
N    union
N    {
N        __IO uint32_t CMOD;
X        volatile uint32_t CMOD;
N        stc_pca_cmod_field_t CMOD_f;
N    };
N    union
N    {
N        __IO uint32_t CNT;
X        volatile uint32_t CNT;
N        stc_pca_cnt_field_t CNT_f;
N    };
N    union
N    {
N        __IO uint32_t ICLR;
X        volatile uint32_t ICLR;
N        stc_pca_iclr_field_t ICLR_f;
N    };
N    union
N    {
N        __IO uint32_t CCAPM0;
X        volatile uint32_t CCAPM0;
N        stc_pca_ccapm0_field_t CCAPM0_f;
N    };
N    union
N    {
N        __IO uint32_t CCAPM1;
X        volatile uint32_t CCAPM1;
N        stc_pca_ccapm1_field_t CCAPM1_f;
N    };
N    union
N    {
N        __IO uint32_t CCAPM2;
X        volatile uint32_t CCAPM2;
N        stc_pca_ccapm2_field_t CCAPM2_f;
N    };
N    union
N    {
N        __IO uint32_t CCAPM3;
X        volatile uint32_t CCAPM3;
N        stc_pca_ccapm3_field_t CCAPM3_f;
N    };
N    union
N    {
N        __IO uint32_t CCAPM4;
X        volatile uint32_t CCAPM4;
N        stc_pca_ccapm4_field_t CCAPM4_f;
N    };
N    union
N    {
N        __IO uint32_t CCAP0H;
X        volatile uint32_t CCAP0H;
N        stc_pca_ccap0h_field_t CCAP0H_f;
N    };
N    union
N    {
N        __IO uint32_t CCAP0L;
X        volatile uint32_t CCAP0L;
N        stc_pca_ccap0l_field_t CCAP0L_f;
N    };
N    union
N    {
N        __IO uint32_t CCAP1H;
X        volatile uint32_t CCAP1H;
N        stc_pca_ccap1h_field_t CCAP1H_f;
N    };
N    union
N    {
N        __IO uint32_t CCAP1L;
X        volatile uint32_t CCAP1L;
N        stc_pca_ccap1l_field_t CCAP1L_f;
N    };
N    union
N    {
N        __IO uint32_t CCAP2H;
X        volatile uint32_t CCAP2H;
N        stc_pca_ccap2h_field_t CCAP2H_f;
N    };
N    union
N    {
N        __IO uint32_t CCAP2L;
X        volatile uint32_t CCAP2L;
N        stc_pca_ccap2l_field_t CCAP2L_f;
N    };
N    union
N    {
N        __IO uint32_t CCAP3H;
X        volatile uint32_t CCAP3H;
N        stc_pca_ccap3h_field_t CCAP3H_f;
N    };
N    union
N    {
N        __IO uint32_t CCAP3L;
X        volatile uint32_t CCAP3L;
N        stc_pca_ccap3l_field_t CCAP3L_f;
N    };
N    union
N    {
N        __IO uint32_t CCAP4H;
X        volatile uint32_t CCAP4H;
N        stc_pca_ccap4h_field_t CCAP4H_f;
N    };
N    union
N    {
N        __IO uint32_t CCAP4L;
X        volatile uint32_t CCAP4L;
N        stc_pca_ccap4l_field_t CCAP4L_f;
N    };
N    union
N    {
N        __IO uint32_t CCAPO;
X        volatile uint32_t CCAPO;
N        stc_pca_ccapo_field_t CCAPO_f;
N    };
N    union
N    {
N        __IO uint32_t CCAP0;
X        volatile uint32_t CCAP0;
N        stc_pca_ccap0_field_t CCAP0_f;
N    };
N    union
N    {
N        __IO uint32_t CCAP1;
X        volatile uint32_t CCAP1;
N        stc_pca_ccap1_field_t CCAP1_f;
N    };
N    union
N    {
N        __IO uint32_t CCAP2;
X        volatile uint32_t CCAP2;
N        stc_pca_ccap2_field_t CCAP2_f;
N    };
N    union
N    {
N        __IO uint32_t CCAP3;
X        volatile uint32_t CCAP3;
N        stc_pca_ccap3_field_t CCAP3_f;
N    };
N    union
N    {
N        __IO uint32_t CCAP4;
X        volatile uint32_t CCAP4;
N        stc_pca_ccap4_field_t CCAP4_f;
N    };
N    union
N    {
N        __IO uint32_t CARR;
X        volatile uint32_t CARR;
N        stc_pca_carr_field_t CARR_f;
N    };
N    union
N    {
N        __IO uint32_t EPWM;
X        volatile uint32_t EPWM;
N        stc_pca_epwm_field_t EPWM_f;
N    };
N}M0P_PCA_TypeDef;
N
Ntypedef struct
N{
N    union
N    {
N        __IO uint8_t RUN;
X        volatile uint8_t RUN;
N        stc_pcnt_run_field_t RUN_f;
N    };
N    uint8_t RESERVED1[3];
N    union
N    {
N        __IO uint8_t CR;
X        volatile uint8_t CR;
N        stc_pcnt_cr_field_t CR_f;
N    };
N    uint8_t RESERVED2[3];
N    union
N    {
N        __IO uint32_t FLT;
X        volatile uint32_t FLT;
N        stc_pcnt_flt_field_t FLT_f;
N    };
N    union
N    {
N        __IO uint32_t TOCR;
X        volatile uint32_t TOCR;
N        stc_pcnt_tocr_field_t TOCR_f;
N    };
N    union
N    {
N        __IO uint8_t CMD;
X        volatile uint8_t CMD;
N        stc_pcnt_cmd_field_t CMD_f;
N    };
N    uint8_t RESERVED5[3];
N    union
N    {
N        __IO uint8_t SR1;
X        volatile uint8_t SR1;
N        stc_pcnt_sr1_field_t SR1_f;
N    };
N    uint8_t RESERVED6[3];
N    union
N    {
N        __IO uint16_t CNT;
X        volatile uint16_t CNT;
N        stc_pcnt_cnt_field_t CNT_f;
N    };
N    uint8_t RESERVED7[2];
N    union
N    {
N        __IO uint16_t TOP;
X        volatile uint16_t TOP;
N        stc_pcnt_top_field_t TOP_f;
N    };
N    uint8_t RESERVED8[2];
N    union
N    {
N        __IO uint16_t BUF;
X        volatile uint16_t BUF;
N        stc_pcnt_buf_field_t BUF_f;
N    };
N    uint8_t RESERVED9[2];
N    union
N    {
N        __IO uint8_t IFR;
X        volatile uint8_t IFR;
N        stc_pcnt_ifr_field_t IFR_f;
N    };
N    uint8_t RESERVED10[3];
N    union
N    {
N        __IO uint8_t ICR;
X        volatile uint8_t ICR;
N        stc_pcnt_icr_field_t ICR_f;
N    };
N    uint8_t RESERVED11[3];
N    union
N    {
N        __IO uint8_t IEN;
X        volatile uint8_t IEN;
N        stc_pcnt_ien_field_t IEN_f;
N    };
N    uint8_t RESERVED12[3];
N    union
N    {
N        __IO uint8_t SR2;
X        volatile uint8_t SR2;
N        stc_pcnt_sr2_field_t SR2_f;
N    };
N}M0P_PCNT_TypeDef;
N
Ntypedef struct
N{
N    union
N    {
N        __IO uint32_t CR;
X        volatile uint32_t CR;
N        stc_ram_cr_field_t CR_f;
N    };
N    union
N    {
N        __IO uint32_t ERRADDR;
X        volatile uint32_t ERRADDR;
N        stc_ram_erraddr_field_t ERRADDR_f;
N    };
N    union
N    {
N        __IO uint32_t IFR;
X        volatile uint32_t IFR;
N        stc_ram_ifr_field_t IFR_f;
N    };
N    union
N    {
N        __IO uint32_t ICLR;
X        volatile uint32_t ICLR;
N        stc_ram_iclr_field_t ICLR_f;
N    };
N}M0P_RAM_TypeDef;
N
Ntypedef struct
N{
N    union
N    {
N        __IO uint32_t RESET_FLAG;
X        volatile uint32_t RESET_FLAG;
N        stc_reset_flag_field_t RESET_FLAG_f;
N    };
N    uint8_t RESERVED1[8];
N    union
N    {
N        __IO uint32_t PREI_RESET;
X        volatile uint32_t PREI_RESET;
N        stc_reset_prei_field_t PREI_RESET_f;
N    };
N}M0P_RESET_TypeDef;
N
Ntypedef struct
N{
N    union
N    {
N        __IO uint32_t CR;
X        volatile uint32_t CR;
N        stc_rng_cr_field_t CR_f;
N    };
N    union
N    {
N        __IO uint32_t MODE;
X        volatile uint32_t MODE;
N        stc_rng_mode_field_t MODE_f;
N    };
N    uint8_t RESERVED2[4];
N    union
N    {
N        __IO uint32_t DATA0;
X        volatile uint32_t DATA0;
N        stc_rng_data0_field_t DATA0_f;
N    };
N    union
N    {
N        __IO uint32_t DATA1;
X        volatile uint32_t DATA1;
N        stc_rng_data1_field_t DATA1_f;
N    };
N}M0P_RNG_TypeDef;
N
Ntypedef struct
N{
N    union
N    {
N        __IO uint32_t CR0;
X        volatile uint32_t CR0;
N        stc_rtc_cr0_field_t CR0_f;
N    };
N    union
N    {
N        __IO uint32_t CR1;
X        volatile uint32_t CR1;
N        stc_rtc_cr1_field_t CR1_f;
N    };
N    union
N    {
N        __IO uint32_t SEC;
X        volatile uint32_t SEC;
N        stc_rtc_sec_field_t SEC_f;
N    };
N    union
N    {
N        __IO uint32_t MIN;
X        volatile uint32_t MIN;
N        stc_rtc_min_field_t MIN_f;
N    };
N    union
N    {
N        __IO uint32_t HOUR;
X        volatile uint32_t HOUR;
N        stc_rtc_hour_field_t HOUR_f;
N    };
N    union
N    {
N        __IO uint32_t WEEK;
X        volatile uint32_t WEEK;
N        stc_rtc_week_field_t WEEK_f;
N    };
N    union
N    {
N        __IO uint32_t DAY;
X        volatile uint32_t DAY;
N        stc_rtc_day_field_t DAY_f;
N    };
N    union
N    {
N        __IO uint32_t MON;
X        volatile uint32_t MON;
N        stc_rtc_mon_field_t MON_f;
N    };
N    union
N    {
N        __IO uint32_t YEAR;
X        volatile uint32_t YEAR;
N        stc_rtc_year_field_t YEAR_f;
N    };
N    union
N    {
N        __IO uint32_t ALMMIN;
X        volatile uint32_t ALMMIN;
N        stc_rtc_almmin_field_t ALMMIN_f;
N    };
N    union
N    {
N        __IO uint32_t ALMHOUR;
X        volatile uint32_t ALMHOUR;
N        stc_rtc_almhour_field_t ALMHOUR_f;
N    };
N    union
N    {
N        __IO uint32_t ALMWEEK;
X        volatile uint32_t ALMWEEK;
N        stc_rtc_almweek_field_t ALMWEEK_f;
N    };
N    union
N    {
N        __IO uint32_t COMPEN;
X        volatile uint32_t COMPEN;
N        stc_rtc_compen_field_t COMPEN_f;
N    };
N}M0P_RTC_TypeDef;
N
Ntypedef struct
N{
N    union
N    {
N        __IO uint32_t CR;
X        volatile uint32_t CR;
N        stc_spi_cr_field_t CR_f;
N    };
N    union
N    {
N        __IO uint32_t SSN;
X        volatile uint32_t SSN;
N        stc_spi_ssn_field_t SSN_f;
N    };
N    union
N    {
N        __IO uint32_t STAT;
X        volatile uint32_t STAT;
N        stc_spi_stat_field_t STAT_f;
N    };
N    union
N    {
N        __IO uint32_t DATA;
X        volatile uint32_t DATA;
N        stc_spi_data_field_t DATA_f;
N    };
N    union
N    {
N        __IO uint32_t CR2;
X        volatile uint32_t CR2;
N        stc_spi_cr2_field_t CR2_f;
N    };
N    union
N    {
N        __IO uint32_t ICLR;
X        volatile uint32_t ICLR;
N        stc_spi_iclr_field_t ICLR_f;
N    };
N}M0P_SPI_TypeDef;
N
Ntypedef struct
N{
N    union
N    {
N        __IO uint32_t SYSCTRL0;
X        volatile uint32_t SYSCTRL0;
N        stc_sysctrl_sysctrl0_field_t SYSCTRL0_f;
N    };
N    union
N    {
N        __IO uint32_t SYSCTRL1;
X        volatile uint32_t SYSCTRL1;
N        stc_sysctrl_sysctrl1_field_t SYSCTRL1_f;
N    };
N    union
N    {
N        __IO uint32_t SYSCTRL2;
X        volatile uint32_t SYSCTRL2;
N        stc_sysctrl_sysctrl2_field_t SYSCTRL2_f;
N    };
N    union
N    {
N        __IO uint32_t RCH_CR;
X        volatile uint32_t RCH_CR;
N        stc_sysctrl_rch_cr_field_t RCH_CR_f;
N    };
N    union
N    {
N        __IO uint32_t XTH_CR;
X        volatile uint32_t XTH_CR;
N        stc_sysctrl_xth_cr_field_t XTH_CR_f;
N    };
N    union
N    {
N        __IO uint32_t RCL_CR;
X        volatile uint32_t RCL_CR;
N        stc_sysctrl_rcl_cr_field_t RCL_CR_f;
N    };
N    union
N    {
N        __IO uint32_t XTL_CR;
X        volatile uint32_t XTL_CR;
N        stc_sysctrl_xtl_cr_field_t XTL_CR_f;
N    };
N    uint8_t RESERVED7[4];
N    union
N    {
N        __IO uint32_t PERI_CLKEN;
X        volatile uint32_t PERI_CLKEN;
N        stc_sysctrl_peri_clken_field_t PERI_CLKEN_f;
N    };
N    uint8_t RESERVED8[24];
N    union
N    {
N        __IO uint32_t PLL_CR;
X        volatile uint32_t PLL_CR;
N        stc_sysctrl_pll_cr_field_t PLL_CR_f;
N    };
N}M0P_SYSCTRL_TypeDef;
N
Ntypedef struct
N{
N    union
N    {
N        __IO uint32_t ARR;
X        volatile uint32_t ARR;
N        stc_tim0_mode0_arr_field_t ARR_f;
N    };
N    union
N    {
N        __IO uint32_t CNT;
X        volatile uint32_t CNT;
N        stc_tim0_mode0_cnt_field_t CNT_f;
N    };
N    union
N    {
N        __IO uint32_t CNT32;
X        volatile uint32_t CNT32;
N        stc_tim0_mode0_cnt32_field_t CNT32_f;
N    };
N    union
N    {
N        __IO uint32_t M0CR;
X        volatile uint32_t M0CR;
N        stc_tim0_mode0_m0cr_field_t M0CR_f;
N    };
N    union
N    {
N        __IO uint32_t IFR;
X        volatile uint32_t IFR;
N        stc_tim0_mode0_ifr_field_t IFR_f;
N    };
N    union
N    {
N        __IO uint32_t ICLR;
X        volatile uint32_t ICLR;
N        stc_tim0_mode0_iclr_field_t ICLR_f;
N    };
N    uint8_t RESERVED6[24];
N    union
N    {
N        __IO uint32_t DTR;
X        volatile uint32_t DTR;
N        stc_tim0_mode0_dtr_field_t DTR_f;
N    };
N}M0P_TIM0_MODE0_TypeDef;
N
Ntypedef struct
N{
N    uint8_t RESERVED0[4];
N    union
N    {
N        __IO uint32_t CNT;
X        volatile uint32_t CNT;
N        stc_tim0_mode1_cnt_field_t CNT_f;
N    };
N    uint8_t RESERVED1[4];
N    union
N    {
N        __IO uint32_t M1CR;
X        volatile uint32_t M1CR;
N        stc_tim0_mode1_m1cr_field_t M1CR_f;
N    };
N    union
N    {
N        __IO uint32_t IFR;
X        volatile uint32_t IFR;
N        stc_tim0_mode1_ifr_field_t IFR_f;
N    };
N    union
N    {
N        __IO uint32_t ICLR;
X        volatile uint32_t ICLR;
N        stc_tim0_mode1_iclr_field_t ICLR_f;
N    };
N    union
N    {
N        __IO uint32_t MSCR;
X        volatile uint32_t MSCR;
N        stc_tim0_mode1_mscr_field_t MSCR_f;
N    };
N    union
N    {
N        __IO uint32_t FLTR;
X        volatile uint32_t FLTR;
N        stc_tim0_mode1_fltr_field_t FLTR_f;
N    };
N    uint8_t RESERVED6[4];
N    union
N    {
N        __IO uint32_t CR0;
X        volatile uint32_t CR0;
N        stc_tim0_mode1_cr0_field_t CR0_f;
N    };
N    uint8_t RESERVED7[20];
N    union
N    {
N        __IO uint32_t CCR0A;
X        volatile uint32_t CCR0A;
N        stc_tim0_mode1_ccr0a_field_t CCR0A_f;
N    };
N}M0P_TIM0_MODE1_TypeDef;
N
Ntypedef struct
N{
N    union
N    {
N        __IO uint32_t ARR;
X        volatile uint32_t ARR;
N        stc_tim0_mode23_arr_field_t ARR_f;
N    };
N    union
N    {
N        __IO uint32_t CNT;
X        volatile uint32_t CNT;
N        stc_tim0_mode23_cnt_field_t CNT_f;
N    };
N    uint8_t RESERVED2[4];
N    union
N    {
N        __IO uint32_t M23CR;
X        volatile uint32_t M23CR;
N        stc_tim0_mode23_m23cr_field_t M23CR_f;
N    };
N    union
N    {
N        __IO uint32_t IFR;
X        volatile uint32_t IFR;
N        stc_tim0_mode23_ifr_field_t IFR_f;
N    };
N    union
N    {
N        __IO uint32_t ICLR;
X        volatile uint32_t ICLR;
N        stc_tim0_mode23_iclr_field_t ICLR_f;
N    };
N    union
N    {
N        __IO uint32_t MSCR;
X        volatile uint32_t MSCR;
N        stc_tim0_mode23_mscr_field_t MSCR_f;
N    };
N    union
N    {
N        __IO uint32_t FLTR;
X        volatile uint32_t FLTR;
N        stc_tim0_mode23_fltr_field_t FLTR_f;
N    };
N    union
N    {
N        __IO uint32_t ADTR;
X        volatile uint32_t ADTR;
N        stc_tim0_mode23_adtr_field_t ADTR_f;
N    };
N    union
N    {
N        __IO uint32_t CRCH0;
X        volatile uint32_t CRCH0;
N        stc_tim0_mode23_crch0_field_t CRCH0_f;
N    };
N    uint8_t RESERVED9[8];
N    union
N    {
N        __IO uint32_t DTR;
X        volatile uint32_t DTR;
N        stc_tim0_mode23_dtr_field_t DTR_f;
N    };
N    union
N    {
N        __IO uint32_t RCR;
X        volatile uint32_t RCR;
N        stc_tim0_mode23_rcr_field_t RCR_f;
N    };
N    union
N    {
N        __IO uint32_t ARRDM;
X        volatile uint32_t ARRDM;
N        stc_tim0_mode23_arrdm_field_t ARRDM_f;
N    };
N    union
N    {
N        __IO uint32_t CCR0A;
X        volatile uint32_t CCR0A;
N        stc_tim0_mode23_ccr0a_field_t CCR0A_f;
N    };
N    union
N    {
N        __IO uint32_t CCR0B;
X        volatile uint32_t CCR0B;
N        stc_tim0_mode23_ccr0b_field_t CCR0B_f;
N    };
N}M0P_TIM0_MODE23_TypeDef;
N
Ntypedef struct
N{
N    union
N    {
N        __IO uint32_t ARR;
X        volatile uint32_t ARR;
N        stc_tim1_mode0_arr_field_t ARR_f;
N    };
N    union
N    {
N        __IO uint32_t CNT;
X        volatile uint32_t CNT;
N        stc_tim1_mode0_cnt_field_t CNT_f;
N    };
N    union
N    {
N        __IO uint32_t CNT32;
X        volatile uint32_t CNT32;
N        stc_tim1_mode0_cnt32_field_t CNT32_f;
N    };
N    union
N    {
N        __IO uint32_t M0CR;
X        volatile uint32_t M0CR;
N        stc_tim1_mode0_m0cr_field_t M0CR_f;
N    };
N    union
N    {
N        __IO uint32_t IFR;
X        volatile uint32_t IFR;
N        stc_tim1_mode0_ifr_field_t IFR_f;
N    };
N    union
N    {
N        __IO uint32_t ICLR;
X        volatile uint32_t ICLR;
N        stc_tim1_mode0_iclr_field_t ICLR_f;
N    };
N    uint8_t RESERVED6[24];
N    union
N    {
N        __IO uint32_t DTR;
X        volatile uint32_t DTR;
N        stc_tim1_mode0_dtr_field_t DTR_f;
N    };
N}M0P_TIM1_MODE0_TypeDef;
N
Ntypedef struct
N{
N    uint8_t RESERVED0[4];
N    union
N    {
N        __IO uint32_t CNT;
X        volatile uint32_t CNT;
N        stc_tim1_mode1_cnt_field_t CNT_f;
N    };
N    uint8_t RESERVED1[4];
N    union
N    {
N        __IO uint32_t M1CR;
X        volatile uint32_t M1CR;
N        stc_tim1_mode1_m1cr_field_t M1CR_f;
N    };
N    union
N    {
N        __IO uint32_t IFR;
X        volatile uint32_t IFR;
N        stc_tim1_mode1_ifr_field_t IFR_f;
N    };
N    union
N    {
N        __IO uint32_t ICLR;
X        volatile uint32_t ICLR;
N        stc_tim1_mode1_iclr_field_t ICLR_f;
N    };
N    union
N    {
N        __IO uint32_t MSCR;
X        volatile uint32_t MSCR;
N        stc_tim1_mode1_mscr_field_t MSCR_f;
N    };
N    union
N    {
N        __IO uint32_t FLTR;
X        volatile uint32_t FLTR;
N        stc_tim1_mode1_fltr_field_t FLTR_f;
N    };
N    uint8_t RESERVED6[4];
N    union
N    {
N        __IO uint32_t CR0;
X        volatile uint32_t CR0;
N        stc_tim1_mode1_cr0_field_t CR0_f;
N    };
N    uint8_t RESERVED7[20];
N    union
N    {
N        __IO uint32_t CCR0A;
X        volatile uint32_t CCR0A;
N        stc_tim1_mode1_ccr0a_field_t CCR0A_f;
N    };
N}M0P_TIM1_MODE1_TypeDef;
N
Ntypedef struct
N{
N    union
N    {
N        __IO uint32_t ARR;
X        volatile uint32_t ARR;
N        stc_tim1_mode23_arr_field_t ARR_f;
N    };
N    union
N    {
N        __IO uint32_t CNT;
X        volatile uint32_t CNT;
N        stc_tim1_mode23_cnt_field_t CNT_f;
N    };
N    uint8_t RESERVED2[4];
N    union
N    {
N        __IO uint32_t M23CR;
X        volatile uint32_t M23CR;
N        stc_tim1_mode23_m23cr_field_t M23CR_f;
N    };
N    union
N    {
N        __IO uint32_t IFR;
X        volatile uint32_t IFR;
N        stc_tim1_mode23_ifr_field_t IFR_f;
N    };
N    union
N    {
N        __IO uint32_t ICLR;
X        volatile uint32_t ICLR;
N        stc_tim1_mode23_iclr_field_t ICLR_f;
N    };
N    union
N    {
N        __IO uint32_t MSCR;
X        volatile uint32_t MSCR;
N        stc_tim1_mode23_mscr_field_t MSCR_f;
N    };
N    union
N    {
N        __IO uint32_t FLTR;
X        volatile uint32_t FLTR;
N        stc_tim1_mode23_fltr_field_t FLTR_f;
N    };
N    union
N    {
N        __IO uint32_t ADTR;
X        volatile uint32_t ADTR;
N        stc_tim1_mode23_adtr_field_t ADTR_f;
N    };
N    union
N    {
N        __IO uint32_t CRCH0;
X        volatile uint32_t CRCH0;
N        stc_tim1_mode23_crch0_field_t CRCH0_f;
N    };
N    uint8_t RESERVED9[8];
N    union
N    {
N        __IO uint32_t DTR;
X        volatile uint32_t DTR;
N        stc_tim1_mode23_dtr_field_t DTR_f;
N    };
N    union
N    {
N        __IO uint32_t RCR;
X        volatile uint32_t RCR;
N        stc_tim1_mode23_rcr_field_t RCR_f;
N    };
N    union
N    {
N        __IO uint32_t ARRDM;
X        volatile uint32_t ARRDM;
N        stc_tim1_mode23_arrdm_field_t ARRDM_f;
N    };
N    union
N    {
N        __IO uint32_t CCR0A;
X        volatile uint32_t CCR0A;
N        stc_tim1_mode23_ccr0a_field_t CCR0A_f;
N    };
N    union
N    {
N        __IO uint32_t CCR0B;
X        volatile uint32_t CCR0B;
N        stc_tim1_mode23_ccr0b_field_t CCR0B_f;
N    };
N}M0P_TIM1_MODE23_TypeDef;
N
Ntypedef struct
N{
N    union
N    {
N        __IO uint32_t ARR;
X        volatile uint32_t ARR;
N        stc_tim2_mode0_arr_field_t ARR_f;
N    };
N    union
N    {
N        __IO uint32_t CNT;
X        volatile uint32_t CNT;
N        stc_tim2_mode0_cnt_field_t CNT_f;
N    };
N    union
N    {
N        __IO uint32_t CNT32;
X        volatile uint32_t CNT32;
N        stc_tim2_mode0_cnt32_field_t CNT32_f;
N    };
N    union
N    {
N        __IO uint32_t M0CR;
X        volatile uint32_t M0CR;
N        stc_tim2_mode0_m0cr_field_t M0CR_f;
N    };
N    union
N    {
N        __IO uint32_t IFR;
X        volatile uint32_t IFR;
N        stc_tim2_mode0_ifr_field_t IFR_f;
N    };
N    union
N    {
N        __IO uint32_t ICLR;
X        volatile uint32_t ICLR;
N        stc_tim2_mode0_iclr_field_t ICLR_f;
N    };
N    uint8_t RESERVED6[24];
N    union
N    {
N        __IO uint32_t DTR;
X        volatile uint32_t DTR;
N        stc_tim2_mode0_dtr_field_t DTR_f;
N    };
N}M0P_TIM2_MODE0_TypeDef;
N
Ntypedef struct
N{
N    uint8_t RESERVED0[4];
N    union
N    {
N        __IO uint32_t CNT;
X        volatile uint32_t CNT;
N        stc_tim2_mode1_cnt_field_t CNT_f;
N    };
N    uint8_t RESERVED1[4];
N    union
N    {
N        __IO uint32_t M1CR;
X        volatile uint32_t M1CR;
N        stc_tim2_mode1_m1cr_field_t M1CR_f;
N    };
N    union
N    {
N        __IO uint32_t IFR;
X        volatile uint32_t IFR;
N        stc_tim2_mode1_ifr_field_t IFR_f;
N    };
N    union
N    {
N        __IO uint32_t ICLR;
X        volatile uint32_t ICLR;
N        stc_tim2_mode1_iclr_field_t ICLR_f;
N    };
N    union
N    {
N        __IO uint32_t MSCR;
X        volatile uint32_t MSCR;
N        stc_tim2_mode1_mscr_field_t MSCR_f;
N    };
N    union
N    {
N        __IO uint32_t FLTR;
X        volatile uint32_t FLTR;
N        stc_tim2_mode1_fltr_field_t FLTR_f;
N    };
N    uint8_t RESERVED6[4];
N    union
N    {
N        __IO uint32_t CR0;
X        volatile uint32_t CR0;
N        stc_tim2_mode1_cr0_field_t CR0_f;
N    };
N    uint8_t RESERVED7[20];
N    union
N    {
N        __IO uint32_t CCR0A;
X        volatile uint32_t CCR0A;
N        stc_tim2_mode1_ccr0a_field_t CCR0A_f;
N    };
N}M0P_TIM2_MODE1_TypeDef;
N
Ntypedef struct
N{
N    union
N    {
N        __IO uint32_t ARR;
X        volatile uint32_t ARR;
N        stc_tim2_mode23_arr_field_t ARR_f;
N    };
N    union
N    {
N        __IO uint32_t CNT;
X        volatile uint32_t CNT;
N        stc_tim2_mode23_cnt_field_t CNT_f;
N    };
N    uint8_t RESERVED2[4];
N    union
N    {
N        __IO uint32_t M23CR;
X        volatile uint32_t M23CR;
N        stc_tim2_mode23_m23cr_field_t M23CR_f;
N    };
N    union
N    {
N        __IO uint32_t IFR;
X        volatile uint32_t IFR;
N        stc_tim2_mode23_ifr_field_t IFR_f;
N    };
N    union
N    {
N        __IO uint32_t ICLR;
X        volatile uint32_t ICLR;
N        stc_tim2_mode23_iclr_field_t ICLR_f;
N    };
N    union
N    {
N        __IO uint32_t MSCR;
X        volatile uint32_t MSCR;
N        stc_tim2_mode23_mscr_field_t MSCR_f;
N    };
N    union
N    {
N        __IO uint32_t FLTR;
X        volatile uint32_t FLTR;
N        stc_tim2_mode23_fltr_field_t FLTR_f;
N    };
N    union
N    {
N        __IO uint32_t ADTR;
X        volatile uint32_t ADTR;
N        stc_tim2_mode23_adtr_field_t ADTR_f;
N    };
N    union
N    {
N        __IO uint32_t CRCH0;
X        volatile uint32_t CRCH0;
N        stc_tim2_mode23_crch0_field_t CRCH0_f;
N    };
N    uint8_t RESERVED9[8];
N    union
N    {
N        __IO uint32_t DTR;
X        volatile uint32_t DTR;
N        stc_tim2_mode23_dtr_field_t DTR_f;
N    };
N    union
N    {
N        __IO uint32_t RCR;
X        volatile uint32_t RCR;
N        stc_tim2_mode23_rcr_field_t RCR_f;
N    };
N    union
N    {
N        __IO uint32_t ARRDM;
X        volatile uint32_t ARRDM;
N        stc_tim2_mode23_arrdm_field_t ARRDM_f;
N    };
N    union
N    {
N        __IO uint32_t CCR0A;
X        volatile uint32_t CCR0A;
N        stc_tim2_mode23_ccr0a_field_t CCR0A_f;
N    };
N    union
N    {
N        __IO uint32_t CCR0B;
X        volatile uint32_t CCR0B;
N        stc_tim2_mode23_ccr0b_field_t CCR0B_f;
N    };
N}M0P_TIM2_MODE23_TypeDef;
N
Ntypedef struct
N{
N    union
N    {
N        __IO uint32_t ARR;
X        volatile uint32_t ARR;
N        stc_tim3_mode0_arr_field_t ARR_f;
N    };
N    union
N    {
N        __IO uint32_t CNT;
X        volatile uint32_t CNT;
N        stc_tim3_mode0_cnt_field_t CNT_f;
N    };
N    union
N    {
N        __IO uint32_t CNT32;
X        volatile uint32_t CNT32;
N        stc_tim3_mode0_cnt32_field_t CNT32_f;
N    };
N    union
N    {
N        __IO uint32_t M0CR;
X        volatile uint32_t M0CR;
N        stc_tim3_mode0_m0cr_field_t M0CR_f;
N    };
N    union
N    {
N        __IO uint32_t IFR;
X        volatile uint32_t IFR;
N        stc_tim3_mode0_ifr_field_t IFR_f;
N    };
N    union
N    {
N        __IO uint32_t ICLR;
X        volatile uint32_t ICLR;
N        stc_tim3_mode0_iclr_field_t ICLR_f;
N    };
N    uint8_t RESERVED6[24];
N    union
N    {
N        __IO uint32_t DTR;
X        volatile uint32_t DTR;
N        stc_tim3_mode0_dtr_field_t DTR_f;
N    };
N}M0P_TIM3_MODE0_TypeDef;
N
Ntypedef struct
N{
N    uint8_t RESERVED0[4];
N    union
N    {
N        __IO uint32_t CNT;
X        volatile uint32_t CNT;
N        stc_tim3_mode1_cnt_field_t CNT_f;
N    };
N    uint8_t RESERVED1[4];
N    union
N    {
N        __IO uint32_t M1CR;
X        volatile uint32_t M1CR;
N        stc_tim3_mode1_m1cr_field_t M1CR_f;
N    };
N    union
N    {
N        __IO uint32_t IFR;
X        volatile uint32_t IFR;
N        stc_tim3_mode1_ifr_field_t IFR_f;
N    };
N    union
N    {
N        __IO uint32_t ICLR;
X        volatile uint32_t ICLR;
N        stc_tim3_mode1_iclr_field_t ICLR_f;
N    };
N    union
N    {
N        __IO uint32_t MSCR;
X        volatile uint32_t MSCR;
N        stc_tim3_mode1_mscr_field_t MSCR_f;
N    };
N    union
N    {
N        __IO uint32_t FLTR;
X        volatile uint32_t FLTR;
N        stc_tim3_mode1_fltr_field_t FLTR_f;
N    };
N    uint8_t RESERVED6[4];
N    union
N    {
N        __IO uint32_t CR0;
X        volatile uint32_t CR0;
N        stc_tim3_mode1_cr0_field_t CR0_f;
N    };
N    uint8_t RESERVED7[20];
N    union
N    {
N        __IO uint32_t CCR0A;
X        volatile uint32_t CCR0A;
N        stc_tim3_mode1_ccr0a_field_t CCR0A_f;
N    };
N}M0P_TIM3_MODE1_TypeDef;
N
Ntypedef struct
N{
N    union
N    {
N        __IO uint32_t ARR;
X        volatile uint32_t ARR;
N        stc_tim3_mode23_arr_field_t ARR_f;
N    };
N    union
N    {
N        __IO uint32_t CNT;
X        volatile uint32_t CNT;
N        stc_tim3_mode23_cnt_field_t CNT_f;
N    };
N    uint8_t RESERVED2[4];
N    union
N    {
N        __IO uint32_t M23CR;
X        volatile uint32_t M23CR;
N        stc_tim3_mode23_m23cr_field_t M23CR_f;
N    };
N    union
N    {
N        __IO uint32_t IFR;
X        volatile uint32_t IFR;
N        stc_tim3_mode23_ifr_field_t IFR_f;
N    };
N    union
N    {
N        __IO uint32_t ICLR;
X        volatile uint32_t ICLR;
N        stc_tim3_mode23_iclr_field_t ICLR_f;
N    };
N    union
N    {
N        __IO uint32_t MSCR;
X        volatile uint32_t MSCR;
N        stc_tim3_mode23_mscr_field_t MSCR_f;
N    };
N    union
N    {
N        __IO uint32_t FLTR;
X        volatile uint32_t FLTR;
N        stc_tim3_mode23_fltr_field_t FLTR_f;
N    };
N    union
N    {
N        __IO uint32_t ADTR;
X        volatile uint32_t ADTR;
N        stc_tim3_mode23_adtr_field_t ADTR_f;
N    };
N    union
N    {
N        __IO uint32_t CRCH0;
X        volatile uint32_t CRCH0;
N        stc_tim3_mode23_crch0_field_t CRCH0_f;
N    };
N    union
N    {
N        __IO uint32_t CRCH1;
X        volatile uint32_t CRCH1;
N        stc_tim3_mode23_crch1_field_t CRCH1_f;
N    };
N    union
N    {
N        __IO uint32_t CRCH2;
X        volatile uint32_t CRCH2;
N        stc_tim3_mode23_crch2_field_t CRCH2_f;
N    };
N    union
N    {
N        __IO uint32_t DTR;
X        volatile uint32_t DTR;
N        stc_tim3_mode23_dtr_field_t DTR_f;
N    };
N    union
N    {
N        __IO uint32_t RCR;
X        volatile uint32_t RCR;
N        stc_tim3_mode23_rcr_field_t RCR_f;
N    };
N    union
N    {
N        __IO uint32_t ARRDM;
X        volatile uint32_t ARRDM;
N        stc_tim3_mode23_arrdm_field_t ARRDM_f;
N    };
N    union
N    {
N        __IO uint32_t CCR0A;
X        volatile uint32_t CCR0A;
N        stc_tim3_mode23_ccr0a_field_t CCR0A_f;
N    };
N    union
N    {
N        __IO uint32_t CCR0B;
X        volatile uint32_t CCR0B;
N        stc_tim3_mode23_ccr0b_field_t CCR0B_f;
N    };
N    union
N    {
N        __IO uint32_t CCR1A;
X        volatile uint32_t CCR1A;
N        stc_tim3_mode23_ccr1a_field_t CCR1A_f;
N    };
N    union
N    {
N        __IO uint32_t CCR1B;
X        volatile uint32_t CCR1B;
N        stc_tim3_mode23_ccr1b_field_t CCR1B_f;
N    };
N    union
N    {
N        __IO uint32_t CCR2A;
X        volatile uint32_t CCR2A;
N        stc_tim3_mode23_ccr2a_field_t CCR2A_f;
N    };
N    union
N    {
N        __IO uint32_t CCR2B;
X        volatile uint32_t CCR2B;
N        stc_tim3_mode23_ccr2b_field_t CCR2B_f;
N    };
N}M0P_TIM3_MODE23_TypeDef;
N
Ntypedef struct
N{
N    union
N    {
N        __IO uint32_t CNTER;
X        volatile uint32_t CNTER;
N        stc_tim4_cnter_field_t CNTER_f;
N    };
N    union
N    {
N        __IO uint32_t PERAR;
X        volatile uint32_t PERAR;
N        stc_tim4_perar_field_t PERAR_f;
N    };
N    union
N    {
N        __IO uint32_t PERBR;
X        volatile uint32_t PERBR;
N        stc_tim4_perbr_field_t PERBR_f;
N    };
N    uint8_t RESERVED3[4];
N    union
N    {
N        __IO uint32_t GCMAR;
X        volatile uint32_t GCMAR;
N        stc_tim4_gcmar_field_t GCMAR_f;
N    };
N    union
N    {
N        __IO uint32_t GCMBR;
X        volatile uint32_t GCMBR;
N        stc_tim4_gcmbr_field_t GCMBR_f;
N    };
N    union
N    {
N        __IO uint32_t GCMCR;
X        volatile uint32_t GCMCR;
N        stc_tim4_gcmcr_field_t GCMCR_f;
N    };
N    union
N    {
N        __IO uint32_t GCMDR;
X        volatile uint32_t GCMDR;
N        stc_tim4_gcmdr_field_t GCMDR_f;
N    };
N    uint8_t RESERVED7[8];
N    union
N    {
N        __IO uint32_t SCMAR;
X        volatile uint32_t SCMAR;
N        stc_tim4_scmar_field_t SCMAR_f;
N    };
N    union
N    {
N        __IO uint32_t SCMBR;
X        volatile uint32_t SCMBR;
N        stc_tim4_scmbr_field_t SCMBR_f;
N    };
N    uint8_t RESERVED9[16];
N    union
N    {
N        __IO uint32_t DTUAR;
X        volatile uint32_t DTUAR;
N        stc_tim4_dtuar_field_t DTUAR_f;
N    };
N    union
N    {
N        __IO uint32_t DTDAR;
X        volatile uint32_t DTDAR;
N        stc_tim4_dtdar_field_t DTDAR_f;
N    };
N    uint8_t RESERVED11[8];
N    union
N    {
N        __IO uint32_t GCONR;
X        volatile uint32_t GCONR;
N        stc_tim4_gconr_field_t GCONR_f;
N    };
N    union
N    {
N        __IO uint32_t ICONR;
X        volatile uint32_t ICONR;
N        stc_tim4_iconr_field_t ICONR_f;
N    };
N    union
N    {
N        __IO uint32_t PCONR;
X        volatile uint32_t PCONR;
N        stc_tim4_pconr_field_t PCONR_f;
N    };
N    union
N    {
N        __IO uint32_t BCONR;
X        volatile uint32_t BCONR;
N        stc_tim4_bconr_field_t BCONR_f;
N    };
N    union
N    {
N        __IO uint32_t DCONR;
X        volatile uint32_t DCONR;
N        stc_tim4_dconr_field_t DCONR_f;
N    };
N    uint8_t RESERVED16[4];
N    union
N    {
N        __IO uint32_t FCONR;
X        volatile uint32_t FCONR;
N        stc_tim4_fconr_field_t FCONR_f;
N    };
N    union
N    {
N        __IO uint32_t VPERR;
X        volatile uint32_t VPERR;
N        stc_tim4_vperr_field_t VPERR_f;
N    };
N    union
N    {
N        __IO uint32_t STFLR;
X        volatile uint32_t STFLR;
N        stc_tim4_stflr_field_t STFLR_f;
N    };
N    union
N    {
N        __IO uint32_t HSTAR;
X        volatile uint32_t HSTAR;
N        stc_tim4_hstar_field_t HSTAR_f;
N    };
N    union
N    {
N        __IO uint32_t HSTPR;
X        volatile uint32_t HSTPR;
N        stc_tim4_hstpr_field_t HSTPR_f;
N    };
N    union
N    {
N        __IO uint32_t HCELR;
X        volatile uint32_t HCELR;
N        stc_tim4_hcelr_field_t HCELR_f;
N    };
N    union
N    {
N        __IO uint32_t HCPAR;
X        volatile uint32_t HCPAR;
N        stc_tim4_hcpar_field_t HCPAR_f;
N    };
N    union
N    {
N        __IO uint32_t HCPBR;
X        volatile uint32_t HCPBR;
N        stc_tim4_hcpbr_field_t HCPBR_f;
N    };
N    union
N    {
N        __IO uint32_t HCUPR;
X        volatile uint32_t HCUPR;
N        stc_tim4_hcupr_field_t HCUPR_f;
N    };
N    union
N    {
N        __IO uint32_t HCDOR;
X        volatile uint32_t HCDOR;
N        stc_tim4_hcdor_field_t HCDOR_f;
N    };
N    uint8_t RESERVED26[112];
N    union
N    {
N        __IO uint32_t IFR;
X        volatile uint32_t IFR;
N        stc_tim4_ifr_field_t IFR_f;
N    };
N    union
N    {
N        __IO uint32_t ICLR;
X        volatile uint32_t ICLR;
N        stc_tim4_iclr_field_t ICLR_f;
N    };
N    union
N    {
N        __IO uint32_t CR;
X        volatile uint32_t CR;
N        stc_tim4_cr_field_t CR_f;
N    };
N    uint8_t RESERVED29[4];
N    union
N    {
N        __IO uint32_t AOSSR;
X        volatile uint32_t AOSSR;
N        stc_tim4_aossr_field_t AOSSR_f;
N    };
N    union
N    {
N        __IO uint32_t AOSCL;
X        volatile uint32_t AOSCL;
N        stc_tim4_aoscl_field_t AOSCL_f;
N    };
N    union
N    {
N        __IO uint32_t PTBKS;
X        volatile uint32_t PTBKS;
N        stc_tim4_ptbks_field_t PTBKS_f;
N    };
N    union
N    {
N        __IO uint32_t TTRIG;
X        volatile uint32_t TTRIG;
N        stc_tim4_ttrig_field_t TTRIG_f;
N    };
N    union
N    {
N        __IO uint32_t ITRIG;
X        volatile uint32_t ITRIG;
N        stc_tim4_itrig_field_t ITRIG_f;
N    };
N    union
N    {
N        __IO uint32_t PTBKP;
X        volatile uint32_t PTBKP;
N        stc_tim4_ptbkp_field_t PTBKP_f;
N    };
N    uint8_t RESERVED35[716];
N    union
N    {
N        __IO uint32_t SSTAR;
X        volatile uint32_t SSTAR;
N        stc_tim4_sstar_field_t SSTAR_f;
N    };
N    union
N    {
N        __IO uint32_t SSTPR;
X        volatile uint32_t SSTPR;
N        stc_tim4_sstpr_field_t SSTPR_f;
N    };
N    union
N    {
N        __IO uint32_t SCLRR;
X        volatile uint32_t SCLRR;
N        stc_tim4_sclrr_field_t SCLRR_f;
N    };
N}M0P_TIM4_TypeDef;
N
Ntypedef struct
N{
N    union
N    {
N        __IO uint32_t CNTER;
X        volatile uint32_t CNTER;
N        stc_tim5_cnter_field_t CNTER_f;
N    };
N    union
N    {
N        __IO uint32_t PERAR;
X        volatile uint32_t PERAR;
N        stc_tim5_perar_field_t PERAR_f;
N    };
N    union
N    {
N        __IO uint32_t PERBR;
X        volatile uint32_t PERBR;
N        stc_tim5_perbr_field_t PERBR_f;
N    };
N    uint8_t RESERVED3[4];
N    union
N    {
N        __IO uint32_t GCMAR;
X        volatile uint32_t GCMAR;
N        stc_tim5_gcmar_field_t GCMAR_f;
N    };
N    union
N    {
N        __IO uint32_t GCMBR;
X        volatile uint32_t GCMBR;
N        stc_tim5_gcmbr_field_t GCMBR_f;
N    };
N    union
N    {
N        __IO uint32_t GCMCR;
X        volatile uint32_t GCMCR;
N        stc_tim5_gcmcr_field_t GCMCR_f;
N    };
N    union
N    {
N        __IO uint32_t GCMDR;
X        volatile uint32_t GCMDR;
N        stc_tim5_gcmdr_field_t GCMDR_f;
N    };
N    uint8_t RESERVED7[8];
N    union
N    {
N        __IO uint32_t SCMAR;
X        volatile uint32_t SCMAR;
N        stc_tim5_scmar_field_t SCMAR_f;
N    };
N    union
N    {
N        __IO uint32_t SCMBR;
X        volatile uint32_t SCMBR;
N        stc_tim5_scmbr_field_t SCMBR_f;
N    };
N    uint8_t RESERVED9[16];
N    union
N    {
N        __IO uint32_t DTUAR;
X        volatile uint32_t DTUAR;
N        stc_tim5_dtuar_field_t DTUAR_f;
N    };
N    union
N    {
N        __IO uint32_t DTDAR;
X        volatile uint32_t DTDAR;
N        stc_tim5_dtdar_field_t DTDAR_f;
N    };
N    uint8_t RESERVED11[8];
N    union
N    {
N        __IO uint32_t GCONR;
X        volatile uint32_t GCONR;
N        stc_tim5_gconr_field_t GCONR_f;
N    };
N    union
N    {
N        __IO uint32_t ICONR;
X        volatile uint32_t ICONR;
N        stc_tim5_iconr_field_t ICONR_f;
N    };
N    union
N    {
N        __IO uint32_t PCONR;
X        volatile uint32_t PCONR;
N        stc_tim5_pconr_field_t PCONR_f;
N    };
N    union
N    {
N        __IO uint32_t BCONR;
X        volatile uint32_t BCONR;
N        stc_tim5_bconr_field_t BCONR_f;
N    };
N    union
N    {
N        __IO uint32_t DCONR;
X        volatile uint32_t DCONR;
N        stc_tim5_dconr_field_t DCONR_f;
N    };
N    uint8_t RESERVED16[4];
N    union
N    {
N        __IO uint32_t FCONR;
X        volatile uint32_t FCONR;
N        stc_tim5_fconr_field_t FCONR_f;
N    };
N    union
N    {
N        __IO uint32_t VPERR;
X        volatile uint32_t VPERR;
N        stc_tim5_vperr_field_t VPERR_f;
N    };
N    union
N    {
N        __IO uint32_t STFLR;
X        volatile uint32_t STFLR;
N        stc_tim5_stflr_field_t STFLR_f;
N    };
N    union
N    {
N        __IO uint32_t HSTAR;
X        volatile uint32_t HSTAR;
N        stc_tim5_hstar_field_t HSTAR_f;
N    };
N    union
N    {
N        __IO uint32_t HSTPR;
X        volatile uint32_t HSTPR;
N        stc_tim5_hstpr_field_t HSTPR_f;
N    };
N    union
N    {
N        __IO uint32_t HCELR;
X        volatile uint32_t HCELR;
N        stc_tim5_hcelr_field_t HCELR_f;
N    };
N    union
N    {
N        __IO uint32_t HCPAR;
X        volatile uint32_t HCPAR;
N        stc_tim5_hcpar_field_t HCPAR_f;
N    };
N    union
N    {
N        __IO uint32_t HCPBR;
X        volatile uint32_t HCPBR;
N        stc_tim5_hcpbr_field_t HCPBR_f;
N    };
N    union
N    {
N        __IO uint32_t HCUPR;
X        volatile uint32_t HCUPR;
N        stc_tim5_hcupr_field_t HCUPR_f;
N    };
N    union
N    {
N        __IO uint32_t HCDOR;
X        volatile uint32_t HCDOR;
N        stc_tim5_hcdor_field_t HCDOR_f;
N    };
N    uint8_t RESERVED26[112];
N    union
N    {
N        __IO uint32_t IFR;
X        volatile uint32_t IFR;
N        stc_tim5_ifr_field_t IFR_f;
N    };
N    union
N    {
N        __IO uint32_t ICLR;
X        volatile uint32_t ICLR;
N        stc_tim5_iclr_field_t ICLR_f;
N    };
N    union
N    {
N        __IO uint32_t CR;
X        volatile uint32_t CR;
N        stc_tim5_cr_field_t CR_f;
N    };
N    uint8_t RESERVED29[4];
N    union
N    {
N        __IO uint32_t AOSSR;
X        volatile uint32_t AOSSR;
N        stc_tim5_aossr_field_t AOSSR_f;
N    };
N    union
N    {
N        __IO uint32_t AOSCL;
X        volatile uint32_t AOSCL;
N        stc_tim5_aoscl_field_t AOSCL_f;
N    };
N    union
N    {
N        __IO uint32_t PTBKS;
X        volatile uint32_t PTBKS;
N        stc_tim5_ptbks_field_t PTBKS_f;
N    };
N    union
N    {
N        __IO uint32_t TTRIG;
X        volatile uint32_t TTRIG;
N        stc_tim5_ttrig_field_t TTRIG_f;
N    };
N    union
N    {
N        __IO uint32_t ITRIG;
X        volatile uint32_t ITRIG;
N        stc_tim5_itrig_field_t ITRIG_f;
N    };
N    union
N    {
N        __IO uint32_t PTBKP;
X        volatile uint32_t PTBKP;
N        stc_tim5_ptbkp_field_t PTBKP_f;
N    };
N    uint8_t RESERVED35[716];
N    union
N    {
N        __IO uint32_t SSTAR;
X        volatile uint32_t SSTAR;
N        stc_tim5_sstar_field_t SSTAR_f;
N    };
N    union
N    {
N        __IO uint32_t SSTPR;
X        volatile uint32_t SSTPR;
N        stc_tim5_sstpr_field_t SSTPR_f;
N    };
N    union
N    {
N        __IO uint32_t SCLRR;
X        volatile uint32_t SCLRR;
N        stc_tim5_sclrr_field_t SCLRR_f;
N    };
N}M0P_TIM5_TypeDef;
N
Ntypedef struct
N{
N    union
N    {
N        __IO uint32_t CNTER;
X        volatile uint32_t CNTER;
N        stc_tim6_cnter_field_t CNTER_f;
N    };
N    union
N    {
N        __IO uint32_t PERAR;
X        volatile uint32_t PERAR;
N        stc_tim6_perar_field_t PERAR_f;
N    };
N    union
N    {
N        __IO uint32_t PERBR;
X        volatile uint32_t PERBR;
N        stc_tim6_perbr_field_t PERBR_f;
N    };
N    uint8_t RESERVED3[4];
N    union
N    {
N        __IO uint32_t GCMAR;
X        volatile uint32_t GCMAR;
N        stc_tim6_gcmar_field_t GCMAR_f;
N    };
N    union
N    {
N        __IO uint32_t GCMBR;
X        volatile uint32_t GCMBR;
N        stc_tim6_gcmbr_field_t GCMBR_f;
N    };
N    union
N    {
N        __IO uint32_t GCMCR;
X        volatile uint32_t GCMCR;
N        stc_tim6_gcmcr_field_t GCMCR_f;
N    };
N    union
N    {
N        __IO uint32_t GCMDR;
X        volatile uint32_t GCMDR;
N        stc_tim6_gcmdr_field_t GCMDR_f;
N    };
N    uint8_t RESERVED7[8];
N    union
N    {
N        __IO uint32_t SCMAR;
X        volatile uint32_t SCMAR;
N        stc_tim6_scmar_field_t SCMAR_f;
N    };
N    union
N    {
N        __IO uint32_t SCMBR;
X        volatile uint32_t SCMBR;
N        stc_tim6_scmbr_field_t SCMBR_f;
N    };
N    uint8_t RESERVED9[16];
N    union
N    {
N        __IO uint32_t DTUAR;
X        volatile uint32_t DTUAR;
N        stc_tim6_dtuar_field_t DTUAR_f;
N    };
N    union
N    {
N        __IO uint32_t DTDAR;
X        volatile uint32_t DTDAR;
N        stc_tim6_dtdar_field_t DTDAR_f;
N    };
N    uint8_t RESERVED11[8];
N    union
N    {
N        __IO uint32_t GCONR;
X        volatile uint32_t GCONR;
N        stc_tim6_gconr_field_t GCONR_f;
N    };
N    union
N    {
N        __IO uint32_t ICONR;
X        volatile uint32_t ICONR;
N        stc_tim6_iconr_field_t ICONR_f;
N    };
N    union
N    {
N        __IO uint32_t PCONR;
X        volatile uint32_t PCONR;
N        stc_tim6_pconr_field_t PCONR_f;
N    };
N    union
N    {
N        __IO uint32_t BCONR;
X        volatile uint32_t BCONR;
N        stc_tim6_bconr_field_t BCONR_f;
N    };
N    union
N    {
N        __IO uint32_t DCONR;
X        volatile uint32_t DCONR;
N        stc_tim6_dconr_field_t DCONR_f;
N    };
N    uint8_t RESERVED16[4];
N    union
N    {
N        __IO uint32_t FCONR;
X        volatile uint32_t FCONR;
N        stc_tim6_fconr_field_t FCONR_f;
N    };
N    union
N    {
N        __IO uint32_t VPERR;
X        volatile uint32_t VPERR;
N        stc_tim6_vperr_field_t VPERR_f;
N    };
N    union
N    {
N        __IO uint32_t STFLR;
X        volatile uint32_t STFLR;
N        stc_tim6_stflr_field_t STFLR_f;
N    };
N    union
N    {
N        __IO uint32_t HSTAR;
X        volatile uint32_t HSTAR;
N        stc_tim6_hstar_field_t HSTAR_f;
N    };
N    union
N    {
N        __IO uint32_t HSTPR;
X        volatile uint32_t HSTPR;
N        stc_tim6_hstpr_field_t HSTPR_f;
N    };
N    union
N    {
N        __IO uint32_t HCELR;
X        volatile uint32_t HCELR;
N        stc_tim6_hcelr_field_t HCELR_f;
N    };
N    union
N    {
N        __IO uint32_t HCPAR;
X        volatile uint32_t HCPAR;
N        stc_tim6_hcpar_field_t HCPAR_f;
N    };
N    union
N    {
N        __IO uint32_t HCPBR;
X        volatile uint32_t HCPBR;
N        stc_tim6_hcpbr_field_t HCPBR_f;
N    };
N    union
N    {
N        __IO uint32_t HCUPR;
X        volatile uint32_t HCUPR;
N        stc_tim6_hcupr_field_t HCUPR_f;
N    };
N    union
N    {
N        __IO uint32_t HCDOR;
X        volatile uint32_t HCDOR;
N        stc_tim6_hcdor_field_t HCDOR_f;
N    };
N    uint8_t RESERVED26[112];
N    union
N    {
N        __IO uint32_t IFR;
X        volatile uint32_t IFR;
N        stc_tim6_ifr_field_t IFR_f;
N    };
N    union
N    {
N        __IO uint32_t ICLR;
X        volatile uint32_t ICLR;
N        stc_tim6_iclr_field_t ICLR_f;
N    };
N    union
N    {
N        __IO uint32_t CR;
X        volatile uint32_t CR;
N        stc_tim6_cr_field_t CR_f;
N    };
N    uint8_t RESERVED29[4];
N    union
N    {
N        __IO uint32_t AOSSR;
X        volatile uint32_t AOSSR;
N        stc_tim6_aossr_field_t AOSSR_f;
N    };
N    union
N    {
N        __IO uint32_t AOSCL;
X        volatile uint32_t AOSCL;
N        stc_tim6_aoscl_field_t AOSCL_f;
N    };
N    union
N    {
N        __IO uint32_t PTBKS;
X        volatile uint32_t PTBKS;
N        stc_tim6_ptbks_field_t PTBKS_f;
N    };
N    union
N    {
N        __IO uint32_t TTRIG;
X        volatile uint32_t TTRIG;
N        stc_tim6_ttrig_field_t TTRIG_f;
N    };
N    union
N    {
N        __IO uint32_t ITRIG;
X        volatile uint32_t ITRIG;
N        stc_tim6_itrig_field_t ITRIG_f;
N    };
N    union
N    {
N        __IO uint32_t PTBKP;
X        volatile uint32_t PTBKP;
N        stc_tim6_ptbkp_field_t PTBKP_f;
N    };
N    uint8_t RESERVED35[716];
N    union
N    {
N        __IO uint32_t SSTAR;
X        volatile uint32_t SSTAR;
N        stc_tim6_sstar_field_t SSTAR_f;
N    };
N    union
N    {
N        __IO uint32_t SSTPR;
X        volatile uint32_t SSTPR;
N        stc_tim6_sstpr_field_t SSTPR_f;
N    };
N    union
N    {
N        __IO uint32_t SCLRR;
X        volatile uint32_t SCLRR;
N        stc_tim6_sclrr_field_t SCLRR_f;
N    };
N}M0P_TIM6_TypeDef;
N
Ntypedef struct
N{
N    union
N    {
N        __IO uint32_t SBUF;
X        volatile uint32_t SBUF;
N        stc_uart_sbuf_field_t SBUF_f;
N    };
N    union
N    {
N        __IO uint32_t SCON;
X        volatile uint32_t SCON;
N        stc_uart_scon_field_t SCON_f;
N    };
N    union
N    {
N        __IO uint32_t SADDR;
X        volatile uint32_t SADDR;
N        stc_uart_saddr_field_t SADDR_f;
N    };
N    union
N    {
N        __IO uint32_t SADEN;
X        volatile uint32_t SADEN;
N        stc_uart_saden_field_t SADEN_f;
N    };
N    union
N    {
N        __IO uint32_t ISR;
X        volatile uint32_t ISR;
N        stc_uart_isr_field_t ISR_f;
N    };
N    union
N    {
N        __IO uint32_t ICR;
X        volatile uint32_t ICR;
N        stc_uart_icr_field_t ICR_f;
N    };
N    union
N    {
N        __IO uint32_t SCNT;
X        volatile uint32_t SCNT;
N        stc_uart_scnt_field_t SCNT_f;
N    };
N}M0P_UART_TypeDef;
N
Ntypedef struct
N{
N    uint8_t RESERVED0[16];
N    union
N    {
N        __IO uint32_t CR;
X        volatile uint32_t CR;
N        stc_vc_cr_field_t CR_f;
N    };
N    union
N    {
N        __IO uint32_t VC0_CR;
X        volatile uint32_t VC0_CR;
N        stc_vc_vc0_cr_field_t VC0_CR_f;
N    };
N    union
N    {
N        __IO uint32_t VC1_CR;
X        volatile uint32_t VC1_CR;
N        stc_vc_vc1_cr_field_t VC1_CR_f;
N    };
N    union
N    {
N        __IO uint32_t VC0_OUT_CFG;
X        volatile uint32_t VC0_OUT_CFG;
N        stc_vc_vc0_out_cfg_field_t VC0_OUT_CFG_f;
N    };
N    union
N    {
N        __IO uint32_t VC1_OUT_CFG;
X        volatile uint32_t VC1_OUT_CFG;
N        stc_vc_vc1_out_cfg_field_t VC1_OUT_CFG_f;
N    };
N    union
N    {
N        __IO uint32_t IFR;
X        volatile uint32_t IFR;
N        stc_vc_ifr_field_t IFR_f;
N    };
N}M0P_VC_TypeDef;
N
Ntypedef struct
N{
N    uint8_t RESERVED0[128];
N    union
N    {
N        __IO uint32_t RST;
X        volatile uint32_t RST;
N        stc_wdt_rst_field_t RST_f;
N    };
N    union
N    {
N        __IO uint32_t CON;
X        volatile uint32_t CON;
N        stc_wdt_con_field_t CON_f;
N    };
N}M0P_WDT_TypeDef;
N
N
N
N#define M0P_PERIPH_BASE                        (0x40000000UL)
N#define M0P_ADC_BASE                           (M0P_PERIPH_BASE + 0x00002400UL)
N#define M0P_AES_BASE                           (M0P_PERIPH_BASE + 0x00021400UL)
N#define M0P_BGR_BASE                           (M0P_PERIPH_BASE + 0x00002400UL)
N#define M0P_CLK_TRIM_BASE                      (M0P_PERIPH_BASE + 0x00001800UL)
N#define M0P_CRC_BASE                           (M0P_PERIPH_BASE + 0x00020900UL)
N#define M0P_DEBUG_ACTIVE_BASE                  (M0P_PERIPH_BASE + 0x00002438UL)
N#define M0P_DMAC_BASE                          (M0P_PERIPH_BASE + 0x00021000UL)
N#define M0P_FLASH_BASE                         (M0P_PERIPH_BASE + 0x00020000UL)
N#define M0P_GPIO_BASE                          (M0P_PERIPH_BASE + 0x00020C00UL)
N#define M0P_HDIV_BASE                          (M0P_PERIPH_BASE + 0x00021800UL)
N#define M0P_I2C0_BASE                          (M0P_PERIPH_BASE + 0x00000400UL)
N#define M0P_I2C1_BASE                          (M0P_PERIPH_BASE + 0x00004400UL)
N#define M0P_LCD_BASE                           (M0P_PERIPH_BASE + 0x00005C00UL)
N#define M0P_LPTIMER_BASE                       (M0P_PERIPH_BASE + 0x00000F00UL)
N#define M0P_LPUART0_BASE                       (M0P_PERIPH_BASE + 0x00000200UL)
N#define M0P_LPUART1_BASE                       (M0P_PERIPH_BASE + 0x00004000UL)
N#define M0P_LVD_BASE                           (M0P_PERIPH_BASE + 0x00002400UL)
N#define M0P_OPA_BASE                           (M0P_PERIPH_BASE + 0x00002400UL)
N#define M0P_PCA_BASE                           (M0P_PERIPH_BASE + 0x00001000UL)
N#define M0P_PCNT_BASE                          (M0P_PERIPH_BASE + 0x00005400UL)
N#define M0P_RAM_BASE                           (M0P_PERIPH_BASE + 0x00020400UL)
N#define M0P_RESET_BASE                         (M0P_PERIPH_BASE + 0x0000201CUL)
N#define M0P_RNG_BASE                           (M0P_PERIPH_BASE + 0x00004C00UL)
N#define M0P_RTC_BASE                           (M0P_PERIPH_BASE + 0x00001400UL)
N#define M0P_SPI0_BASE                          (M0P_PERIPH_BASE + 0x00000800UL)
N#define M0P_SPI1_BASE                          (M0P_PERIPH_BASE + 0x00004800UL)
N#define M0P_SYSCTRL_BASE                       (M0P_PERIPH_BASE + 0x00002000UL)
N#define M0P_TIM0_MODE0_BASE                    (M0P_PERIPH_BASE + 0x00000C00UL)
N#define M0P_TIM0_MODE1_BASE                    (M0P_PERIPH_BASE + 0x00000C00UL)
N#define M0P_TIM0_MODE23_BASE                   (M0P_PERIPH_BASE + 0x00000C00UL)
N#define M0P_TIM1_MODE0_BASE                    (M0P_PERIPH_BASE + 0x00000D00UL)
N#define M0P_TIM1_MODE1_BASE                    (M0P_PERIPH_BASE + 0x00000D00UL)
N#define M0P_TIM1_MODE23_BASE                   (M0P_PERIPH_BASE + 0x00000D00UL)
N#define M0P_TIM2_MODE0_BASE                    (M0P_PERIPH_BASE + 0x00000E00UL)
N#define M0P_TIM2_MODE1_BASE                    (M0P_PERIPH_BASE + 0x00000E00UL)
N#define M0P_TIM2_MODE23_BASE                   (M0P_PERIPH_BASE + 0x00000E00UL)
N#define M0P_TIM3_MODE0_BASE                    (M0P_PERIPH_BASE + 0x00005800UL)
N#define M0P_TIM3_MODE1_BASE                    (M0P_PERIPH_BASE + 0x00005800UL)
N#define M0P_TIM3_MODE23_BASE                   (M0P_PERIPH_BASE + 0x00005800UL)
N#define M0P_TIM4_BASE                          (M0P_PERIPH_BASE + 0x00003000UL)
N#define M0P_TIM5_BASE                          (M0P_PERIPH_BASE + 0x00003400UL)
N#define M0P_TIM6_BASE                          (M0P_PERIPH_BASE + 0x00003800UL)
N#define M0P_UART0_BASE                         (M0P_PERIPH_BASE + 0x00000000UL)
N#define M0P_UART1_BASE                         (M0P_PERIPH_BASE + 0x00000100UL)
N#define M0P_VC_BASE                            (M0P_PERIPH_BASE + 0x00002400UL)
N#define M0P_WDT_BASE                           (M0P_PERIPH_BASE + 0x00000F00UL)
N
N
N#define M0P_ADC                                ((M0P_ADC_TypeDef *)0x40002400UL)
N#define M0P_AES                                ((M0P_AES_TypeDef *)0x40021400UL)
N#define M0P_BGR                                ((M0P_BGR_TypeDef *)0x40002400UL)
N#define M0P_CLK_TRIM                           ((M0P_CLK_TRIM_TypeDef *)0x40001800UL)
N#define M0P_CRC                                ((M0P_CRC_TypeDef *)0x40020900UL)
N#define M0P_DEBUG_ACTIVE                       ((M0P_DEBUG_ACTIVE_TypeDef *)0x40002438UL)
N#define M0P_DMAC                               ((M0P_DMAC_TypeDef *)0x40021000UL)
N#define M0P_FLASH                              ((M0P_FLASH_TypeDef *)0x40020000UL)
N#define M0P_GPIO                               ((M0P_GPIO_TypeDef *)0x40020C00UL)
N#define M0P_HDIV                               ((M0P_HDIV_TypeDef *)0x40021800UL)
N#define M0P_I2C0                               ((M0P_I2C_TypeDef *)0x40000400UL)
N#define M0P_I2C1                               ((M0P_I2C_TypeDef *)0x40004400UL)
N#define M0P_LCD                                ((M0P_LCD_TypeDef *)0x40005C00UL)
N#define M0P_LPTIMER                            ((M0P_LPTIMER_TypeDef *)0x40000F00UL)
N#define M0P_LPUART0                            ((M0P_LPUART_TypeDef *)0x40000200UL)
N#define M0P_LPUART1                            ((M0P_LPUART_TypeDef *)0x40004000UL)
N#define M0P_LVD                                ((M0P_LVD_TypeDef *)0x40002400UL)
N#define M0P_OPA                                ((M0P_OPA_TypeDef *)0x40002400UL)
N#define M0P_PCA                                ((M0P_PCA_TypeDef *)0x40001000UL)
N#define M0P_PCNT                               ((M0P_PCNT_TypeDef *)0x40005400UL)
N#define M0P_RAM                                ((M0P_RAM_TypeDef *)0x40020400UL)
N#define M0P_RESET                              ((M0P_RESET_TypeDef *)0x4000201CUL)
N#define M0P_RNG                                ((M0P_RNG_TypeDef *)0x40004C00UL)
N#define M0P_RTC                                ((M0P_RTC_TypeDef *)0x40001400UL)
N#define M0P_SPI0                               ((M0P_SPI_TypeDef *)0x40000800UL)
N#define M0P_SPI1                               ((M0P_SPI_TypeDef *)0x40004800UL)
N#define M0P_SYSCTRL                            ((M0P_SYSCTRL_TypeDef *)0x40002000UL)
N#define M0P_TIM0_MODE0                         ((M0P_TIM0_MODE0_TypeDef *)0x40000C00UL)
N#define M0P_TIM0_MODE1                         ((M0P_TIM0_MODE1_TypeDef *)0x40000C00UL)
N#define M0P_TIM0_MODE23                        ((M0P_TIM0_MODE23_TypeDef *)0x40000C00UL)
N#define M0P_TIM1_MODE0                         ((M0P_TIM1_MODE0_TypeDef *)0x40000D00UL)
N#define M0P_TIM1_MODE1                         ((M0P_TIM1_MODE1_TypeDef *)0x40000D00UL)
N#define M0P_TIM1_MODE23                        ((M0P_TIM1_MODE23_TypeDef *)0x40000D00UL)
N#define M0P_TIM2_MODE0                         ((M0P_TIM2_MODE0_TypeDef *)0x40000E00UL)
N#define M0P_TIM2_MODE1                         ((M0P_TIM2_MODE1_TypeDef *)0x40000E00UL)
N#define M0P_TIM2_MODE23                        ((M0P_TIM2_MODE23_TypeDef *)0x40000E00UL)
N#define M0P_TIM3_MODE0                         ((M0P_TIM3_MODE0_TypeDef *)0x40005800UL)
N#define M0P_TIM3_MODE1                         ((M0P_TIM3_MODE1_TypeDef *)0x40005800UL)
N#define M0P_TIM3_MODE23                        ((M0P_TIM3_MODE23_TypeDef *)0x40005800UL)
N#define M0P_TIM4                               ((M0P_TIM4_TypeDef *)0x40003000UL)
N#define M0P_TIM5                               ((M0P_TIM5_TypeDef *)0x40003400UL)
N#define M0P_TIM6                               ((M0P_TIM6_TypeDef *)0x40003800UL)
N#define M0P_UART0                              ((M0P_UART_TypeDef *)0x40000000UL)
N#define M0P_UART1                              ((M0P_UART_TypeDef *)0x40000100UL)
N#define M0P_VC                                 ((M0P_VC_TypeDef *)0x40002400UL)
N#define M0P_WDT                                ((M0P_WDT_TypeDef *)0x40000F00UL)
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __HC32L136K8TA_H__ */
N
L 12 "..\..\MProkaron\Include\Platform/CortexM/Chips/HC32L136K8/rmp_platform_HC32L136K8.h" 2
N#include "system_hc32l13x.h"
L 1 "..\..\..\M0P0_Library\HC32L13X_DDL_V1.0\mcu\common\system_hc32l13x.h" 1
N/*******************************************************************************
N* Copyright (C) 2018, Huada Semiconductor Co.,Ltd All rights reserved.
N*
N* This software is owned and published by:
N* Huada Semiconductor Co.,Ltd ("HDSC").
N*
N* BY DOWNLOADING, INSTALLING OR USING THIS SOFTWARE, YOU AGREE TO BE BOUND
N* BY ALL THE TERMS AND CONDITIONS OF THIS AGREEMENT.
N*
N* This software contains source code for use with HDSC
N* components. This software is licensed by HDSC to be adapted only
N* for use in systems utilizing HDSC components. HDSC shall not be
N* responsible for misuse or illegal use of this software for devices not
N* supported herein. HDSC is providing this software "AS IS" and will
N* not be responsible for issues arising from incorrect user implementation
N* of the software.
N*
N* Disclaimer:
N* HDSC MAKES NO WARRANTY, EXPRESS OR IMPLIED, ARISING BY LAW OR OTHERWISE,
N* REGARDING THE SOFTWARE (INCLUDING ANY ACOOMPANYING WRITTEN MATERIALS),
N* ITS PERFORMANCE OR SUITABILITY FOR YOUR INTENDED USE, INCLUDING,
N* WITHOUT LIMITATION, THE IMPLIED WARRANTY OF MERCHANTABILITY, THE IMPLIED
N* WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE OR USE, AND THE IMPLIED
N* WARRANTY OF NONINFRINGEMENT.
N* HDSC SHALL HAVE NO LIABILITY (WHETHER IN CONTRACT, WARRANTY, TORT,
N* NEGLIGENCE OR OTHERWISE) FOR ANY DAMAGES WHATSOEVER (INCLUDING, WITHOUT
N* LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS, BUSINESS INTERRUPTION,
N* LOSS OF BUSINESS INFORMATION, OR OTHER PECUNIARY LOSS) ARISING FROM USE OR
N* INABILITY TO USE THE SOFTWARE, INCLUDING, WITHOUT LIMITATION, ANY DIRECT,
N* INDIRECT, INCIDENTAL, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOSS OF DATA,
N* SAVINGS OR PROFITS,
N* EVEN IF Disclaimer HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
N* YOU ASSUME ALL RESPONSIBILITIES FOR SELECTION OF THE SOFTWARE TO ACHIEVE YOUR
N* INTENDED RESULTS, AND FOR THE INSTALLATION OF, USE OF, AND RESULTS OBTAINED
N* FROM, THE SOFTWARE.
N*
N* This software may be replicated in part or whole for the licensed use,
N* with the restriction that this Disclaimer and Copyright notice must be
N* included with each copy of this software, whether used in part or whole,
N* at all times.
N*/
N/******************************************************************************/
N/** \file system_hc32l13x.h
N **
N ** A detailed description is available at
N ** @link SampleGroup Some description @endlink
N **
N **   - 2018-03-09  1.0  Lux First version.
N **
N ******************************************************************************/
N
N#ifndef __SYSTEM_HC32L13X_H__
N#define __SYSTEM_HC32L13X_H__
N
N/******************************************************************************/
N/* Include files                                                              */
N/******************************************************************************/
N#include <stdint.h>
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/******************************************************************************/
N/* Global pre-processor symbols/macros ('define')                             */
N/******************************************************************************/
N#define HWWD_DISABLE        (1)
N
N
N
N/**
N ******************************************************************************
N ** \brief Clock Setup macro definition
N **
N ** - 0: CLOCK_SETTING_NONE  - User provides own clock setting in application
N ** - 1: CLOCK_SETTING_CMSIS - 
N ******************************************************************************/
N#define CLOCK_SETTING_NONE  0u
N#define CLOCK_SETTING_CMSIS 1u
N
N
N/******************************************************************************/
N/*                                                                            */
N/*                      START OF USER SETTINGS HERE                           */
N/*                      ===========================                           */
N/*                                                                            */
N/*                 All lines with '<<<' can be set by user.                   */
N/*                                                                            */
N/******************************************************************************/
N
N/******************************************************************************/
N/* Global function prototypes ('extern', definition in C source)              */
N/******************************************************************************/
N
N
Nextern uint32_t SystemCoreClock;          // System Clock Frequency (Core Clock)
Nextern void SystemInit (void);            // Initialize the system
Nextern void SystemCoreClockUpdate (void); // Update SystemCoreClock variable
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __SYSTEM_HC32L13X_H__ */
N
N
N
L 13 "..\..\MProkaron\Include\Platform/CortexM/Chips/HC32L136K8/rmp_platform_HC32L136K8.h" 2
N#include "ddl.h"
L 1 "..\..\..\M0P0_Library\HC32L13X_DDL_V1.0\driver\inc\ddl.h" 1
N/*******************************************************************************
N* Copyright (C) 2018, Huada Semiconductor Co.,Ltd All rights reserved.
N*
N* This software is owned and published by:
N* Huada Semiconductor Co.,Ltd ("HDSC").
N*
N* BY DOWNLOADING, INSTALLING OR USING THIS SOFTWARE, YOU AGREE TO BE BOUND
N* BY ALL THE TERMS AND CONDITIONS OF THIS AGREEMENT.
N*
N* This software contains source code for use with HDSC
N* components. This software is licensed by HDSC to be adapted only
N* for use in systems utilizing HDSC components. HDSC shall not be
N* responsible for misuse or illegal use of this software for devices not
N* supported herein. HDSC is providing this software "AS IS" and will
N* not be responsible for issues arising from incorrect user implementation
N* of the software.
N*
N* Disclaimer:
N* HDSC MAKES NO WARRANTY, EXPRESS OR IMPLIED, ARISING BY LAW OR OTHERWISE,
N* REGARDING THE SOFTWARE (INCLUDING ANY ACOOMPANYING WRITTEN MATERIALS),
N* ITS PERFORMANCE OR SUITABILITY FOR YOUR INTENDED USE, INCLUDING,
N* WITHOUT LIMITATION, THE IMPLIED WARRANTY OF MERCHANTABILITY, THE IMPLIED
N* WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE OR USE, AND THE IMPLIED
N* WARRANTY OF NONINFRINGEMENT.
N* HDSC SHALL HAVE NO LIABILITY (WHETHER IN CONTRACT, WARRANTY, TORT,
N* NEGLIGENCE OR OTHERWISE) FOR ANY DAMAGES WHATSOEVER (INCLUDING, WITHOUT
N* LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS, BUSINESS INTERRUPTION,
N* LOSS OF BUSINESS INFORMATION, OR OTHER PECUNIARY LOSS) ARISING FROM USE OR
N* INABILITY TO USE THE SOFTWARE, INCLUDING, WITHOUT LIMITATION, ANY DIRECT,
N* INDIRECT, INCIDENTAL, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOSS OF DATA,
N* SAVINGS OR PROFITS,
N* EVEN IF Disclaimer HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
N* YOU ASSUME ALL RESPONSIBILITIES FOR SELECTION OF THE SOFTWARE TO ACHIEVE YOUR
N* INTENDED RESULTS, AND FOR THE INSTALLATION OF, USE OF, AND RESULTS OBTAINED
N* FROM, THE SOFTWARE.
N*
N* This software may be replicated in part or whole for the licensed use,
N* with the restriction that this Disclaimer and Copyright notice must be
N* included with each copy of this software, whether used in part or whole,
N* at all times.
N*/
N/******************************************************************************/
N/** \file ddl.h
N **
N ** DDL common define.
N ** @link SampleGroup Some description @endlink
N **
N **   - 2018-04-15  1.0  Lux     First version.
N **
N ******************************************************************************/
N
N#ifndef __DDL_H__
N#define __DDL_H__
N
N/******************************************************************************/
N/* Include files                                                              */
N/******************************************************************************/
N#include "base_types.h"
L 1 "..\..\..\M0P0_Library\HC32L13X_DDL_V1.0\mcu\common\base_types.h" 1
N/******************************************************************************
N* Copyright (C) 2017, Huada Semiconductor Co.,Ltd All rights reserved.    
N*
N* This software is owned and published by: 
N* Huada Semiconductor Co.,Ltd ("HDSC").
N*
N* BY DOWNLOADING, INSTALLING OR USING THIS SOFTWARE, YOU AGREE TO BE BOUND 
N* BY ALL THE TERMS AND CONDITIONS OF THIS AGREEMENT.
N*
N* This software contains source code for use with HDSC 
N* components. This software is licensed by HDSC to be adapted only 
N* for use in systems utilizing HDSC components. HDSC shall not be 
N* responsible for misuse or illegal use of this software for devices not 
N* supported herein. HDSC is providing this software "AS IS" and will 
N* not be responsible for issues arising from incorrect user implementation 
N* of the software.  
N*
N* Disclaimer:
N* HDSC MAKES NO WARRANTY, EXPRESS OR IMPLIED, ARISING BY LAW OR OTHERWISE,
N* REGARDING THE SOFTWARE (INCLUDING ANY ACOOMPANYING WRITTEN MATERIALS), 
N* ITS PERFORMANCE OR SUITABILITY FOR YOUR INTENDED USE, INCLUDING, 
N* WITHOUT LIMITATION, THE IMPLIED WARRANTY OF MERCHANTABILITY, THE IMPLIED 
N* WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE OR USE, AND THE IMPLIED 
N* WARRANTY OF NONINFRINGEMENT.  
N* HDSC SHALL HAVE NO LIABILITY (WHETHER IN CONTRACT, WARRANTY, TORT, 
N* NEGLIGENCE OR OTHERWISE) FOR ANY DAMAGES WHATSOEVER (INCLUDING, WITHOUT 
N* LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS, BUSINESS INTERRUPTION, 
N* LOSS OF BUSINESS INFORMATION, OR OTHER PECUNIARY LOSS) ARISING FROM USE OR 
N* INABILITY TO USE THE SOFTWARE, INCLUDING, WITHOUT LIMITATION, ANY DIRECT, 
N* INDIRECT, INCIDENTAL, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOSS OF DATA, 
N* SAVINGS OR PROFITS, 
N* EVEN IF Disclaimer HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. 
N* YOU ASSUME ALL RESPONSIBILITIES FOR SELECTION OF THE SOFTWARE TO ACHIEVE YOUR
N* INTENDED RESULTS, AND FOR THE INSTALLATION OF, USE OF, AND RESULTS OBTAINED 
N* FROM, THE SOFTWARE.  
N*
N* This software may be replicated in part or whole for the licensed use, 
N* with the restriction that this Disclaimer and Copyright notice must be 
N* included with each copy of this software, whether used in part or whole, 
N* at all times.
N*/
N/******************************************************************************/
N/** \file base_types.h
N **
N ** base type common define.
N ** @link SampleGroup Some description @endlink
N **
N **   - 2018-03-09  1.0  Lux First version.
N **
N ******************************************************************************/
N
N#ifndef __BASE_TYPES_H__
N#define __BASE_TYPES_H__
N
N/*****************************************************************************/
N/* Include files                                                             */
N/*****************************************************************************/
N#include <stdio.h>
L 1 "D:\Program_Files_x86\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060009
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 59 "..\..\..\M0P0_Library\HC32L13X_DDL_V1.0\mcu\common\base_types.h" 2
N#include <string.h>
L 1 "D:\Program_Files_x86\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060009
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 60 "..\..\..\M0P0_Library\HC32L13X_DDL_V1.0\mcu\common\base_types.h" 2
N#include <stddef.h>
L 1 "D:\Program_Files_x86\Keil_v5\ARM\ARMCC\Bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5060009
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef signed long ptrdiff_t;
N#else
N  typedef signed int ptrdiff_t;
N#endif
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N  /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #else
N      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
N  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
N#else
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N#endif
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 201112L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 201112L <= 199409L) || (0L && 201103L <= __cplusplus)
N  typedef long double max_align_t;
N#endif
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
S    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S      #if !defined(__STRICT_ANSI__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S        using ::std::max_align_t;
S      #endif
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 61 "..\..\..\M0P0_Library\HC32L13X_DDL_V1.0\mcu\common\base_types.h" 2
N#include <stdint.h>
N#include <assert.h>
L 1 "D:\Program_Files_x86\Keil_v5\ARM\ARMCC\Bin\..\include\assert.h" 1
N/* assert.h: ANSI 'C' (X3J11 Oct 88) library header section 4.2 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.        */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: drodgman $
N */
N
N/*
N * The assert macro puts diagnostics into programs. When it is executed,
N * if its argument expression is false, it writes information about the
N * call that failed (including the text of the argument, the name of the
N * source file, and the source line number - the latter are respectively
N * the values of the preprocessing macros __FILE__ and __LINE__) on the
N * standard error stream. It then calls the abort function.
N * If its argument expression is true, the assert macro returns no value.
N */
N
N/*
N * Note that <assert.h> may be included more that once in a program with
N * different setting of NDEBUG. Hence the slightly unusual first-time
N * only flag.
N */
N
N#ifndef __assert_h
N#   define __assert_h
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define __ARMCLIB_VERSION 5060009
N#   ifndef __ARM_PROMISE
N#      define __ARM_PROMISE __promise
N#   endif
N#   undef __CLIBNS
N#   ifdef __cplusplus
S        namespace std {
S#           define __CLIBNS ::std::
S            extern "C" {
N#   else
N#       define __CLIBNS
N#   endif  /* __cplusplus */
N    extern _ARMABI_NORETURN void abort(void);
X    extern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N    extern _ARMABI_NORETURN void __aeabi_assert(const char *, const char *, int) __attribute__((__nonnull__(1,2)));
X    extern __declspec(__nothrow) __declspec(__noreturn) void __aeabi_assert(const char *, const char *, int) __attribute__((__nonnull__(1,2)));
N#   ifdef __cplusplus
S            }  /* extern "C" */
S        }  /* namespace std */
N#   endif
N#else
S#   undef assert
S#   undef __promise
N#endif
N
N#ifdef NDEBUG
S#   define assert(ignore) ((void)0)
S#   define __promise(e) ((__ARM_PROMISE)((e)?1:0))
N#else
N#   if defined __DO_NOT_LINK_PROMISE_WITH_ASSERT
X#   if 0L
S#      if defined __OPT_SMALL_ASSERT && !defined __ASSERT_MSG && !defined __STRICT_ANSI__ && !(_AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0))
S#          define assert(e) ((e) ? (void)0 : __CLIBNS abort())
S#      elif defined __STDC__
S#          define assert(e) ((e) ? (void)0 : __CLIBNS __aeabi_assert(#e, __FILE__, __LINE__))
S#      else
S#          define assert(e) ((e) ? (void)0 : __CLIBNS __aeabi_assert("e", __FILE__, __LINE__))
S#      endif
S#      define __promise(e) ((__ARM_PROMISE)((e)?1:0))
N#   else
N#      if defined __OPT_SMALL_ASSERT && !defined __ASSERT_MSG && !defined __STRICT_ANSI__ && !(_AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0))
X#      if 1L && !0L && !0L && !(_AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0))
N#undef __promise
N#          define assert(e) ((e) ? (void)0 : __CLIBNS abort(), (__ARM_PROMISE)((e)?1:0))
N#      else
S#          define assert(e) ((e) ? (void)0 : __CLIBNS __aeabi_assert(#e, __FILE__, __LINE__), (__ARM_PROMISE)((e)?1:0))
N#      endif
N#      define __promise(e) assert(e)
N#   endif
N#endif
N
N#if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X#if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S  #define _AEABI_PORTABLE
N#endif
N
N/* end of assert.h */
N
L 63 "..\..\..\M0P0_Library\HC32L13X_DDL_V1.0\mcu\common\base_types.h" 2
N
N
N/*****************************************************************************/
N/* Global pre-processor symbols/macros ('#define')                           */
N/*****************************************************************************/
N#ifndef TRUE
N  /** Value is true (boolean_t type) */
N  #define TRUE        ((boolean_t) 1u)
N#endif
N
N#ifndef FALSE
N  /** Value is false (boolean_t type) */
N  #define FALSE       ((boolean_t) 0u)
N#endif  
N
N#if defined (__ICCARM__)
X#if 0L
S#define __WEAKDEF            __WEAK __ATTRIBUTES
N#elif defined (__CC_ARM)
X#elif 1L
N#define __WEAKDEF            __weak
N#else
S#error	"unsupported compiler!!"
N#endif
N
N/** Returns the minimum value out of two values */
N#define MINIMUM( X, Y )  ((X) < (Y) ? (X) : (Y))
N
N/** Returns the maximum value out of two values */
N#define MAXIMUM( X, Y )  ((X) > (Y) ? (X) : (Y))
N
N/** Returns the dimension of an array */
N#define ARRAY_SZ( X )  (sizeof(X) / sizeof((X)[0]))
N
N#define ASSERT(x)       do{  assert((x)> 0u) ; }while(0);
N/******************************************************************************
N * Global type definitions
N ******************************************************************************/
N
N/** logical datatype (only values are TRUE and FALSE) */
Ntypedef uint8_t      boolean_t;
N  
N/** single precision floating point number (4 byte) */
Ntypedef float        float32_t;
N
N/** double precision floating point number (8 byte) */
Ntypedef double       float64_t;
N
N/** ASCII character for string generation (8 bit) */
Ntypedef char         char_t;
N
N/** function pointer type to void/void function */
Ntypedef void         (*func_ptr_t)(void);
N
N/** function pointer type to void/uint8_t function */
Ntypedef void         (*func_ptr_arg1_t)(uint8_t u8Param);
N
N/** generic error codes */
Ntypedef enum en_result
N{
N    Ok                          = 0u,  ///< No error
N    Error                       = 1u,  ///< Non-specific error code
N    ErrorAddressAlignment       = 2u,  ///< Address alignment does not match
N    ErrorAccessRights           = 3u,  ///< Wrong mode (e.g. user/system) mode is set
N    ErrorInvalidParameter       = 4u,  ///< Provided parameter is not valid
N    ErrorOperationInProgress    = 5u,  ///< A conflicting or requested operation is still in progress
N    ErrorInvalidMode            = 6u,  ///< Operation not allowed in current mode
N    ErrorUninitialized          = 7u,  ///< Module (or part of it) was not initialized properly
N    ErrorBufferFull             = 8u,  ///< Circular buffer can not be written because the buffer is full
N    ErrorTimeout                = 9u,  ///< Time Out error occurred (e.g. I2C arbitration lost, Flash time-out, etc.)
N    ErrorNotReady               = 10u, ///< A requested final state is not reached
N    OperationInProgress         = 11u  ///< Indicator for operation in progress
N} en_result_t;
N
N
N/*****************************************************************************/
N/* Global variable declarations ('extern', definition in C source)           */
N/*****************************************************************************/
N
N/*****************************************************************************/
N/* Global function prototypes ('extern', definition in C source)             */
N/*****************************************************************************/
N
N#endif /* __BASE_TYPES_H__ */
N
N/******************************************************************************/
N/* EOF (not truncated)                                                        */
N/******************************************************************************/
N
N
N
L 59 "..\..\..\M0P0_Library\HC32L13X_DDL_V1.0\driver\inc\ddl.h" 2
N#include "system_hc32l13x.h"
N#include "sysctrl.h"
L 1 "..\..\..\M0P0_Library\HC32L13X_DDL_V1.0\driver\inc\sysctrl.h" 1
N/*******************************************************************************
N* Copyright (C) 2018, Huada Semiconductor Co.,Ltd All rights reserved.
N*
N* This software is owned and published by:
N* Huada Semiconductor Co.,Ltd ("HDSC").
N*
N* BY DOWNLOADING, INSTALLING OR USING THIS SOFTWARE, YOU AGREE TO BE BOUND
N* BY ALL THE TERMS AND CONDITIONS OF THIS AGREEMENT.
N*
N* This software contains source code for use with HDSC
N* components. This software is licensed by HDSC to be adapted only
N* for use in systems utilizing HDSC components. HDSC shall not be
N* responsible for misuse or illegal use of this software for devices not
N* supported herein. HDSC is providing this software "AS IS" and will
N* not be responsible for issues arising from incorrect user implementation
N* of the software.
N*
N* Disclaimer: 
N* HDSC MAKES NO WARRANTY, EXPRESS OR IMPLIED, ARISING BY LAW OR OTHERWISE,
N* REGARDING THE SOFTWARE (INCLUDING ANY ACOOMPANYING WRITTEN MATERIALS),
N* ITS PERFORMANCE OR SUITABILITY FOR YOUR INTENDED USE, INCLUDING,
N* WITHOUT LIMITATION, THE IMPLIED WARRANTY OF MERCHANTABILITY, THE IMPLIED
N* WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE OR USE, AND THE IMPLIED
N* WARRANTY OF NONINFRINGEMENT.
N* HDSC SHALL HAVE NO LIABILITY (WHETHER IN CONTRACT, WARRANTY, TORT,
N* NEGLIGENCE OR OTHERWISE) FOR ANY DAMAGES WHATSOEVER (INCLUDING, WITHOUT
N* LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS, BUSINESS INTERRUPTION,
N* LOSS OF BUSINESS INFORMATION, OR OTHER PECUNIARY LOSS) ARISING FROM USE OR
N* INABILITY TO USE THE SOFTWARE, INCLUDING, WITHOUT LIMITATION, ANY DIRECT,
N* INDIRECT, INCIDENTAL, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOSS OF DATA,
N* SAVINGS OR PROFITS,
N* EVEN IF Disclaimer HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
N* YOU ASSUME ALL RESPONSIBILITIES FOR SELECTION OF THE SOFTWARE TO ACHIEVE YOUR
N* INTENDED RESULTS, AND FOR THE INSTALLATION OF, USE OF, AND RESULTS OBTAINED
N* FROM, THE SOFTWARE.
N*
N* This software may be replicated in part or whole for the licensed use,
N* with the restriction that this Disclaimer and Copyright notice must be
N* included with each copy of this software, whether used in part or whole,
N* at all times.
N*/
N/******************************************************************************/
N/** \file sysctrl.h
N **
N ** Headerfile for SYSCTRL functions
N ** @link SYSCTRL Group Some description @endlink 
N **
N ** History:
N **   - 2018-04-15   Lux     First Version
N **
N ******************************************************************************/
N
N#ifndef __SYSCTRL_H__
N#define __SYSCTRL_H__
N
N/*******************************************************************************
N * Include files
N ******************************************************************************/
N#include "ddl.h"
L 1 "..\..\..\M0P0_Library\HC32L13X_DDL_V1.0\driver\inc\ddl.h" 1
N/*******************************************************************************
N* Copyright (C) 2018, Huada Semiconductor Co.,Ltd All rights reserved.
N*
N* This software is owned and published by:
N* Huada Semiconductor Co.,Ltd ("HDSC").
N*
N* BY DOWNLOADING, INSTALLING OR USING THIS SOFTWARE, YOU AGREE TO BE BOUND
N* BY ALL THE TERMS AND CONDITIONS OF THIS AGREEMENT.
N*
N* This software contains source code for use with HDSC
N* components. This software is licensed by HDSC to be adapted only
N* for use in systems utilizing HDSC components. HDSC shall not be
N* responsible for misuse or illegal use of this software for devices not
N* supported herein. HDSC is providing this software "AS IS" and will
N* not be responsible for issues arising from incorrect user implementation
N* of the software.
N*
N* Disclaimer:
N* HDSC MAKES NO WARRANTY, EXPRESS OR IMPLIED, ARISING BY LAW OR OTHERWISE,
N* REGARDING THE SOFTWARE (INCLUDING ANY ACOOMPANYING WRITTEN MATERIALS),
N* ITS PERFORMANCE OR SUITABILITY FOR YOUR INTENDED USE, INCLUDING,
N* WITHOUT LIMITATION, THE IMPLIED WARRANTY OF MERCHANTABILITY, THE IMPLIED
N* WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE OR USE, AND THE IMPLIED
N* WARRANTY OF NONINFRINGEMENT.
N* HDSC SHALL HAVE NO LIABILITY (WHETHER IN CONTRACT, WARRANTY, TORT,
N* NEGLIGENCE OR OTHERWISE) FOR ANY DAMAGES WHATSOEVER (INCLUDING, WITHOUT
N* LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS, BUSINESS INTERRUPTION,
N* LOSS OF BUSINESS INFORMATION, OR OTHER PECUNIARY LOSS) ARISING FROM USE OR
N* INABILITY TO USE THE SOFTWARE, INCLUDING, WITHOUT LIMITATION, ANY DIRECT,
N* INDIRECT, INCIDENTAL, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOSS OF DATA,
N* SAVINGS OR PROFITS,
N* EVEN IF Disclaimer HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
N* YOU ASSUME ALL RESPONSIBILITIES FOR SELECTION OF THE SOFTWARE TO ACHIEVE YOUR
N* INTENDED RESULTS, AND FOR THE INSTALLATION OF, USE OF, AND RESULTS OBTAINED
N* FROM, THE SOFTWARE.
N*
N* This software may be replicated in part or whole for the licensed use,
N* with the restriction that this Disclaimer and Copyright notice must be
N* included with each copy of this software, whether used in part or whole,
N* at all times.
N*/
N/******************************************************************************/
N/** \file ddl.h
N **
N ** DDL common define.
N ** @link SampleGroup Some description @endlink
N **
N **   - 2018-04-15  1.0  Lux     First version.
N **
N ******************************************************************************/
N
N#ifndef __DDL_H__
S#define __DDL_H__
S
S/******************************************************************************/
S/* Include files                                                              */
S/******************************************************************************/
S#include "base_types.h"
S#include "system_hc32l13x.h"
S#include "sysctrl.h"
S
S/* C binding of definitions if building with C++ compiler                     */
S#ifdef __cplusplus
Sextern "C"
S{
S#endif
S
S/******************************************************************************/
S/* Global pre-processor symbols/macros ('#define')                            */
S/* Macro for initializing local structures to zero                            */
S/******************************************************************************/
S#define DDL_ZERO_STRUCT(x)          ddl_memclr((uint8_t*)&(x), (uint32_t)(sizeof(x)))
S
S#define DEC2BCD(x)                  ((((x)/10)<<4) + ((x)%10))
S#define BCD2DEC(x)                  ((((x)>>4)*10) + ((x)&0x0F))
S
S#define setBit(addr,offset,flag)    {   if( (flag) > 0u){\
S                                            *((volatile uint32_t *)(addr)) |= ((1UL)<<(offset));\
S                                        }else{\
S                                            *((volatile uint32_t *)(addr)) &= (~(1UL<<(offset)));\
S                                        }\
S                                    }
X#define setBit(addr,offset,flag)    {   if( (flag) > 0u){                                            *((volatile uint32_t *)(addr)) |= ((1UL)<<(offset));                                        }else{                                            *((volatile uint32_t *)(addr)) &= (~(1UL<<(offset)));                                        }                                    }
S
S#define getBit(addr,offset)         ((((*((volatile uint32_t *)(addr))) >> (offset)) & 1u)>0?1u:0)
S
S/**
S ******************************************************************************
S ** Global Device Series List
S ******************************************************************************/
S#define DDL_DEVICE_SERIES_HC32L13X       (0u)
S
S/**
S ******************************************************************************
S ** Global Device Package List
S ******************************************************************************/
S// package definitions of HC device.
S#define DDL_DEVICE_PACKAGE_HC_C         (0x00u)
S#define DDL_DEVICE_PACKAGE_HC_F         (0x10u)
S#define DDL_DEVICE_PACKAGE_HC_J         (0x20u)
S#define DDL_DEVICE_PACKAGE_HC_K         (0x30u)
S
S/******************************************************************************/
S/* User Device Setting Include file                                           */
S/******************************************************************************/
S#include "ddl_device.h"  // MUST be included here!
S
S/**
S ******************************************************************************
S ** \brief IRQ name definition for all type MCUs
S ******************************************************************************/
S    
S    #define PORTA_IRQHandler(void)              IRQ000_Handler(void)
S    #define PORTB_IRQHandler(void)              IRQ001_Handler(void)
S    #define PORTC_IRQHandler(void)              IRQ002_Handler(void)
S    #define PORTD_IRQHandler(void)              IRQ003_Handler(void)
S    #define DMAC_IRQHandler(void)               IRQ004_Handler(void)
S    #define TIM3_IRQHandler(void)               IRQ005_Handler(void)
S    #define UART0_IRQHandler(void)              IRQ006_Handler(void)
S    #define UART1_IRQHandler(void)              IRQ007_Handler(void)
S    #define LPUART0_IRQHandler(void)            IRQ008_Handler(void)
S    #define LPUART1_IRQHandler(void)            IRQ009_Handler(void)
S    #define SPI0_IRQHandler(void)               IRQ010_Handler(void)
S    #define SPI1_IRQHandler(void)               IRQ011_Handler(void)
S    #define I2C0_IRQHandler(void)               IRQ012_Handler(void)
S    #define I2C1_IRQHandler(void)               IRQ013_Handler(void)
S    #define TIM0_IRQHandler(void)               IRQ014_Handler(void)
S    #define TIM1_IRQHandler(void)               IRQ015_Handler(void)
S    #define TIM2_IRQHandler(void)               IRQ016_Handler(void)
S    #define LPTIM_IRQHandler(void)              IRQ017_Handler(void)
S    #define TIM4_IRQHandler(void)               IRQ018_Handler(void)
S    #define TIM5_IRQHandler(void)               IRQ019_Handler(void)
S    #define TIM6_IRQHandler(void)               IRQ020_Handler(void)
S    #define PCA_IRQHandler(void)                IRQ021_Handler(void)
S    #define WDT_IRQHandler(void)                IRQ022_Handler(void)
S    #define RTC_IRQHandler(void)                IRQ023_Handler(void)
S    #define ADC_IRQHandler(void)                IRQ024_Handler(void)
S    #define PCNT_IRQHandler(void)               IRQ025_Handler(void)
S    #define VC0_IRQHandler(void)                IRQ026_Handler(void)
S    #define VC1_IRQHandler(void)                IRQ027_Handler(void)
S    #define LVD_IRQHandler(void)                IRQ028_Handler(void)
S    #define LCD_IRQHandler(void)                IRQ029_Handler(void)
S    #define EF_RAM_IRQHandler(void)             IRQ030_Handler(void)
S    #define CLKTRIM_IRQHandler(void)            IRQ031_Handler(void)
S
S/******************************************************************************/
S/* Global type definitions ('typedef')                                        */
S/******************************************************************************/
S/**
S ******************************************************************************
S ** \brief Level
S **
S ** Specifies levels.
S **
S ******************************************************************************/
Stypedef enum en_level
S{
S    DdlLow      = 0u,  ///< Low level  '0'
S    DdlHigh     = 1u   ///< High level '1'
S} en_level_t;
S
S/**
S ******************************************************************************
S ** \brief Generic Flag Code
S **
S ** Specifies flags.
S **
S ******************************************************************************/
Stypedef enum en_flag
S{
S    DdlClr = 0u,       ///< Flag clr '0'
S    DdlSet = 1u        ///< Flag set '1'
S} en_stat_flag_t, en_irq_flag_t;
S/******************************************************************************/
S/* Global variable declarations ('extern', definition in C source)            */
S/******************************************************************************/
S
S/******************************************************************************/
S/* Global function prototypes ('extern', definition in C source)              */
S/******************************************************************************/
S
S/*******************************************************************************
S * Global function prototypes
S ******************************************************************************/
Sextern void ddl_memclr(void* pu8Address, uint32_t u32Count);
Suint32_t Log2(uint32_t u32Val);
S/**
S *******************************************************************************
S ** This hook is part of wait loops.
S ******************************************************************************/
Sextern void DDL_WAIT_LOOP_HOOK(void);
S
Svoid Debug_UartInit(void);
S
Svoid delay1ms(uint32_t u32Cnt);
Svoid delay100us(uint32_t u32Cnt);
Svoid delay10us(uint32_t u32Cnt);
S#ifdef __cplusplus
S}
S#endif
S
N#endif /* __DDL_H__ */
N
N/******************************************************************************/
N/* EOF (not truncated)                                                        */
N/******************************************************************************/
N
L 60 "..\..\..\M0P0_Library\HC32L13X_DDL_V1.0\driver\inc\sysctrl.h" 2
N#include "interrupts_hc32l13x.h"
L 1 "..\..\..\M0P0_Library\HC32L13X_DDL_V1.0\driver\inc\interrupts_hc32l13x.h" 1
N/*******************************************************************************
N* Copyright (C) 2018, Huada Semiconductor Co.,Ltd All rights reserved.
N*
N* This software is owned and published by:
N* Huada Semiconductor Co.,Ltd ("HDSC").
N*
N* BY DOWNLOADING, INSTALLING OR USING THIS SOFTWARE, YOU AGREE TO BE BOUND
N* BY ALL THE TERMS AND CONDITIONS OF THIS AGREEMENT.
N*
N* This software contains source code for use with HDSC
N* components. This software is licensed by HDSC to be adapted only
N* for use in systems utilizing HDSC components. HDSC shall not be
N* responsible for misuse or illegal use of this software for devices not
N* supported herein. HDSC is providing this software "AS IS" and will
N* not be responsible for issues arising from incorrect user implementation
N* of the software.
N*
N* Disclaimer:
N* HDSC MAKES NO WARRANTY, EXPRESS OR IMPLIED, ARISING BY LAW OR OTHERWISE,
N* REGARDING THE SOFTWARE (INCLUDING ANY ACOOMPANYING WRITTEN MATERIALS),
N* ITS PERFORMANCE OR SUITABILITY FOR YOUR INTENDED USE, INCLUDING,
N* WITHOUT LIMITATION, THE IMPLIED WARRANTY OF MERCHANTABILITY, THE IMPLIED
N* WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE OR USE, AND THE IMPLIED
N* WARRANTY OF NONINFRINGEMENT.
N* HDSC SHALL HAVE NO LIABILITY (WHETHER IN CONTRACT, WARRANTY, TORT,
N* NEGLIGENCE OR OTHERWISE) FOR ANY DAMAGES WHATSOEVER (INCLUDING, WITHOUT
N* LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS, BUSINESS INTERRUPTION,
N* LOSS OF BUSINESS INFORMATION, OR OTHER PECUNIARY LOSS) ARISING FROM USE OR
N* INABILITY TO USE THE SOFTWARE, INCLUDING, WITHOUT LIMITATION, ANY DIRECT,
N* INDIRECT, INCIDENTAL, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOSS OF DATA,
N* SAVINGS OR PROFITS,
N* EVEN IF Disclaimer HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
N* YOU ASSUME ALL RESPONSIBILITIES FOR SELECTION OF THE SOFTWARE TO ACHIEVE YOUR
N* INTENDED RESULTS, AND FOR THE INSTALLATION OF, USE OF, AND RESULTS OBTAINED
N* FROM, THE SOFTWARE.
N*
N* This software may be replicated in part or whole for the licensed use,
N* with the restriction that this Disclaimer and Copyright notice must be
N* included with each copy of this software, whether used in part or whole,
N* at all times.
N*/
N/******************************************************************************/
N/** \file interrupts_hc32l13x.h
N **
N ** Interrupt common define.
N ** @link IRQGroup Some description @endlink
N **
N **   - 2018-04-15  1.0  Lux     First version.
N **
N ******************************************************************************/
N#ifndef __INTERRUPTS_HC32L13X_H__
N#define __INTERRUPTS_HC32L13X_H__
N
N/******************************************************************************/
N/* Include files                                                              */
N/******************************************************************************/
N#include "HC32L136K8TA.h"
N
N/* C binding of definitions if building with C++ compiler */
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/******************************************************************************/
N/* Global pre-processor symbols/macros ('#define')                            */
N/******************************************************************************/
N
N#define DDL_IRQ_LEVEL_DEFAULT                   3u
N
N/******************************************************************************
N * Global type definitions
N ******************************************************************************/
N/**
N *******************************************************************************
N ** \brief 中断优先级数据类型定义
N ** \note
N ******************************************************************************/
Ntypedef enum en_irq_level
N{
N    IrqLevel0  = 0u,               ///< 优先级0
N    IrqLevel1  = 1u,               ///< 优先级1
N    IrqLevel2  = 2u,               ///< 优先级2
N    IrqLevel3  = 3u,               ///< 优先级3
N} en_irq_level_t; 
N
N
N/******************************************************************************
N * Global function prototypes (definition in C source)
N ******************************************************************************/
N///< 系统中断使能开关
Nvoid EnableNvic(IRQn_Type enIrq, en_irq_level_t enLevel, boolean_t bEn);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif /* __INTERRUPTS_HC32L13X_H__ */
N
N/******************************************************************************
N * EOF (not truncated)
N ******************************************************************************/
L 61 "..\..\..\M0P0_Library\HC32L13X_DDL_V1.0\driver\inc\sysctrl.h" 2
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/**
N ******************************************************************************
N ** \defgroup SysCtrlGroup (SYSCTRL)
N  **
N ******************************************************************************/
N//@{
N
N/**
N *******************************************************************************
N ** function prototypes.
N ******************************************************************************/
N
N/******************************************************************************
N * Global type definitions
N ******************************************************************************/
N#define SYSTEM_XTH            32*1000*1000u     //默认32MHz,具体值应根据实际系统修改
N#define SYSTEM_XTL            32768u            //默认32768Hz,具体值应根据实际系统修改
N 
N/**
N *******************************************************************************
N ** \brief 系统时钟输入源类型定义
N ** \note
N ******************************************************************************/
Ntypedef enum en_sysctrl_clk_source
N{
N    SysctrlClkRCH  = 0u,               ///< 内部高速时钟
N    SysctrlClkXTH  = 1u,               ///< 外部高速时钟
N    SysctrlClkRCL  = 2u,               ///< 内部低速时钟
N    SysctrlClkXTL  = 3u,               ///< 外部低速时钟
N    SysctrlClkPLL  = 4u,               ///< PLL时钟
N}en_sysctrl_clk_source_t;
N
N/**
N *******************************************************************************
N ** \brief RCH频率值枚举类型定义
N ******************************************************************************/
Ntypedef enum en_sysctrl_rch_freq
N{
N    SysctrlRchFreq4MHz     = 0u,               ///< 4MHz
N    SysctrlRchFreq8MHz     = 1u,               ///< 8MHz
N    SysctrlRchFreq16MHz    = 2u,               ///< 16MHz
N    SysctrlRchFreq22_12MHz = 3u,               ///< 22.12MHz
N    SysctrlRchFreq24MHz    = 4u,               ///< 24MHz
N}en_sysctrl_rch_freq_t;
N
N/**
N *******************************************************************************
N ** \brief XTAL驱动能力类型定义
N ******************************************************************************/
Ntypedef enum en_sysctrl_xtal_driver
N{
N    SysctrlXtalDriver0 = 0u,                ///< 最弱驱动能力
N    SysctrlXtalDriver1 = 1u,                ///< 弱驱动能力
N    SysctrlXtalDriver2 = 3u,                ///< 一般驱动能力
N    SysctrlXtalDriver3 = 3u,                ///< 最强驱动能力
N}en_sysctrl_xtal_driver_t;
N
N/**
N *******************************************************************************
N ** \brief XTH频率值范围选择类型定义
N ******************************************************************************/
Ntypedef enum en_sysctrl_xth_freq
N{
N    SysctrlXthFreq4_6MHz   = 0u,                ///< 4~6MHz
N    SysctrlXthFreq6_12MHz  = 1u,                ///< 6~12MHz
N    SysctrlXthFreq12_20MHz = 2u,                ///< 12~20MHz
N    SysctrlXthFreq20_32MHz = 3u,                ///< 20~32MHz
N}en_sysctrl_xth_freq_t;
N
N/**
N *******************************************************************************
N ** \brief XTH时钟稳定周期数类型定义
N ******************************************************************************/
Ntypedef enum en_sysctrl_xth_cycle
N{
N    SysctrlXthStableCycle256   = 0u,              ///< 256 个周期数
N    SysctrlXthStableCycle1024  = 1u,              ///< 1024 个周期数
N    SysctrlXthStableCycle4096  = 2u,              ///< 4096 个周期数
N    SysctrlXthStableCycle16384 = 3u,              ///< 16384 个周期数
N}en_sysctrl_xth_cycle_t;
N
N/**
N *******************************************************************************
N ** \brief RCL频率值枚举类型定义
N ******************************************************************************/
Ntypedef enum en_sysctrl_rcl_freq
N{
N    SysctrlRclFreq32768    = 0u,               ///< 32.768KHz
N    SysctrlRclFreq38400    = 1u,               ///< 38.4KHz
N}en_sysctrl_rcl_freq_t;
N
N/**
N *******************************************************************************
N ** \brief RCL时钟稳定周期数类型定义
N ******************************************************************************/
Ntypedef enum en_sysctrl_rcl_cycle
N{
N    SysctrlRclStableCycle4   = 0u,                  ///< 4 个周期数
N    SysctrlRclStableCycle16  = 1u,                  ///< 16 个周期数
N    SysctrlRclStableCycle64  = 2u,                  ///< 64 个周期数
N    SysctrlRclStableCycle256 = 3u,                  ///< 256 个周期数
N}en_sysctrl_rcl_cycle_t;
N
N/**
N *******************************************************************************
N ** \brief XTL时钟稳定周期数类型定义
N ******************************************************************************/
Ntypedef enum en_sysctrl_xtl_cycle
N{
N    SysctrlXtlStableCycle256   = 0u,                  ///< 256 个周期数
N    SysctrlXtlStableCycle1024  = 1u,                  ///< 1024 个周期数
N    SysctrlXtlStableCycle4096  = 2u,                  ///< 4096 个周期数
N    SysctrlXtlStableCycle16384 = 3u,                  ///< 16384 个周期数
N}en_sysctrl_xtl_cycle_t;
N
N/**
N *******************************************************************************
N ** \brief XTL晶体振幅枚举类型定义
N ******************************************************************************/
Ntypedef enum en_sysctrl_xtl_amp
N{
N    SysctrlXtlAmp0 = 0u,                ///< 最小振幅
N    SysctrlXtlAmp1 = 1u,                ///< 小振幅
N    SysctrlXtlAmp2 = 2u,                ///< 一般振幅
N    SysctrlXtlAmp3 = 3u,                ///< 最大振幅
N}en_sysctrl_xtl_amp_t;
N
N/**
N *******************************************************************************
N ** \brief PLL时钟稳定周期数类型定义
N ******************************************************************************/
Ntypedef enum en_sysctrl_pll_cycle
N{
N    SysctrlPllStableCycle128   = 0u,                  ///< 128个周期数
N    SysctrlPllStableCycle256   = 1u,                  ///< 256个周期数
N    SysctrlPllStableCycle512   = 2u,                  ///< 512个周期数
N    SysctrlPllStableCycle1024  = 3u,                  ///< 1024个周期数
N    SysctrlPllStableCycle2048  = 4u,                  ///< 2048个周期数
N    SysctrlPllStableCycle4096  = 5u,                  ///< 4096个周期数
N    SysctrlPllStableCycle8192  = 6u,                  ///< 8192个周期数
N    SysctrlPllStableCycle16384 = 7u,                  ///< 16384个周期数    
N}en_sysctrl_pll_cycle_t;
N
N/**
N *******************************************************************************
N ** \brief PLL输入频率范围类型定义
N ******************************************************************************/
Ntypedef enum en_sysctrl_pll_infreq
N{
N    SysctrlPllInFreq4_6MHz   = 0u,                  ///< 4~16MHz
N    SysctrlPllInFreq6_12MHz  = 1u,                  ///< 6~12MHz
N    SysctrlPllInFreq12_20MHz = 2u,                  ///< 12~20MHz
N    SysctrlPllInFreq20_24MHz = 3u,                  ///< 20~24MHz  
N}en_sysctrl_pll_infreq_t;
N
N/**
N *******************************************************************************
N ** \brief PLL输出频率范围类型定义
N ******************************************************************************/
Ntypedef enum en_sysctrl_pll_outfreq
N{
N    SysctrlPllOutFreq8_12MHz  = 0u,                 ///< 8~12MHz
N    SysctrlPllOutFreq12_18MHz = 1u,                 ///< 12~18MHz
N    SysctrlPllOutFreq18_24MHz = 2u,                 ///< 18~24MHz
N    SysctrlPllOutFreq24_36MHz = 3u,                 ///< 24~36MHz
N    SysctrlPllOutFreq36_48MHz = 4u,                 ///< 36~48MHz
N}en_sysctrl_pll_outfreq_t;
N
N/**
N *******************************************************************************
N ** \brief PLL输入时钟源类型定义
N ******************************************************************************/
Ntypedef enum en_sysctrl_pll_clksource
N{
N    SysctrlPllXthXtal   = 0u,                  ///< XTH晶振输入的时钟
N    SysctrlPllXthPd00In = 2u,                  ///< XTH从端口PD00输入的时钟
N    SysctrlPllRch       = 3u,                  ///< RCH时钟
N}en_sysctrl_pll_clksource_t;
N
N/**
N *******************************************************************************
N ** \brief PLL输入时钟源类型定义
N ******************************************************************************/
Ntypedef enum en_sysctrl_pll_mul
N{
N    SysctrlPllMul1  = 1u,                   ///< 1倍频
N    SysctrlPllMul2  = 2u,                   ///< 2倍频
N    SysctrlPllMul3  = 3u,                   ///< 3倍频
N    SysctrlPllMul4  = 4u,                   ///< 4倍频
N    SysctrlPllMul5  = 5u,                   ///< 5倍频
N    SysctrlPllMul6  = 6u,                   ///< 6倍频
N    SysctrlPllMul7  = 7u,                   ///< 7倍频
N    SysctrlPllMul8  = 8u,                   ///< 8倍频
N    SysctrlPllMul9  = 9u,                   ///< 9倍频
N    SysctrlPllMul10 = 10u,                  ///< 10倍频
N    SysctrlPllMul11 = 11u,                  ///< 11倍频
N    SysctrlPllMul12 = 12u,                  ///< 12倍频
N}en_sysctrl_pll_mul_t;
N
N/**
N *******************************************************************************
N ** \brief HCLK时钟分频系数类型定义
N ******************************************************************************/
Ntypedef enum en_sysctrl_hclk_div
N{
N    SysctrlHclkDiv1   = 0u,              ///< SystemClk
N    SysctrlHclkDiv2   = 1u,              ///< SystemClk/2
N    SysctrlHclkDiv4   = 2u,              ///< SystemClk/4
N    SysctrlHclkDiv8   = 3u,              ///< SystemClk/8
N    SysctrlHclkDiv16  = 4u,              ///< SystemClk/16
N    SysctrlHclkDiv32  = 5u,              ///< SystemClk/32
N    SysctrlHclkDiv64  = 6u,              ///< SystemClk/64
N    SysctrlHclkDiv128 = 7u,              ///< SystemClk/128
N}en_sysctrl_hclk_div_t;
N
N/**
N *******************************************************************************
N ** \brief PCLK分频系数
N ******************************************************************************/
Ntypedef enum en_sysctrl_pclk_div
N{
N    SysctrlPclkDiv1 = 0u,                ///< HCLK
N    SysctrlPclkDiv2 = 1u,                ///< HCLK/2
N    SysctrlPclkDiv4 = 2u,                ///< HCLK/4
N    SysctrlPclkDiv8 = 3u,                ///< HCLK/8
N}en_sysctrl_pclk_div_t;
N
N/**
N *******************************************************************************
N ** \brief RTC高速时钟补偿时钟频率数据类型定义
N ******************************************************************************/
Ntypedef enum en_sysctrl_rtc_adjust
N{
N    SysctrlRTC4MHz  = 0u,                ///< 4MHz
N    SysctrlRTC6MHz  = 1u,                ///< 6MHz
N    SysctrlRTC8MHz  = 2u,                ///< 8MHz
N    SysctrlRTC12MHz = 3u,                ///< 12MHz
N    SysctrlRTC16MHz = 4u,                ///< 16MHz
N    SysctrlRTC20MHz = 5u,                ///< 20MHz
N    SysctrlRTC24MHz = 6u,                ///< 24MHz
N    SysctrlRTC32MHz = 7u,                ///< 32MHz
N}en_sysctrl_rtc_adjust_t;
N
N/**
N *******************************************************************************
N ** \brief 系统控制模块其他功能数据类型定义
N ******************************************************************************/
Ntypedef enum en_sysctrl_func
N{
N    SysctrlWkupByRCHEn      =0u,                    ///< 唤醒时使用RCH时钟
N    SysctrlEXTHEn           =1u,                    ///< 使能外部高速时钟从输入引脚PD00输入
N    SysctrlEXTLEn           =2u,                    ///< 使能外部低速速时钟从输入引脚PC14输入
N    SysctrlXTLAlwaysOnEn    =3u,                    ///< 使能后XTL_EN只可置位
N    SysctrlClkFuncRTCLpmEn  =4u,                    ///< 使能RTC低功耗模式
N    SysctrlCMLockUpEn       =5u,                    ///< 使能后CPU执行无效指令会复位MCU
N    SysctrlSWDUseIOEn       =6u,                    ///< SWD端口设为IO功能
N}en_sysctrl_func_t;
N
N/**
N *******************************************************************************
N ** \brief 外设时钟门控开关类型枚举
N ******************************************************************************/
Ntypedef enum en_sysctrl_peripheral_gate
N{
N    SysctrlPeripheralUart0      = 0u,       ///< 串口0
N    SysctrlPeripheralUart1      = 1u,       ///< 串口1
N    SysctrlPeripheralLpUart0    = 2u,       ///< 低功耗串口0
N    SysctrlPeripheralLpUart1    = 3u,       ///< 低功耗串口1
N    SysctrlPeripheralI2c0       = 4u,       ///< I2C0
N    SysctrlPeripheralI2c1       = 5u,       ///< I2C1
N    SysctrlPeripheralSpi0       = 6u,       ///< SPI0
N    SysctrlPeripheralSpi1       = 7u,       ///< SPI1
N    SysctrlPeripheralBTim       = 8u,       ///< 基础定时器
N    SysctrlPeripheralLpTim      = 9u,       ///< 低功耗定时器
N    SysctrlPeripheralAdvTim     = 10u,      ///< 高级定时器
N    SysctrlPeripheralTim3       = 11u,      ///< 定时器3
N    SysctrlPeripheralOpa        = 13u,      ///< OPA
N    SysctrlPeripheralPca        = 14u,      ///< 可编程计数阵列
N    SysctrlPeripheralWdt        = 15u,      ///< 看门狗
N    SysctrlPeripheralAdcBgr     = 16u,      ///< ADC&BGR
N    SysctrlPeripheralVcLvd      = 17u,      ///< 电压比较和低电压检测
N    SysctrlPeripheralRng        = 18u,      ///< RNG
N    SysctrlPeripheralPcnt       = 19u,      ///< PCNT
N    SysctrlPeripheralRtc        = 20u,      ///< RTC
N    SysctrlPeripheralTrim       = 21u,      ///< 时钟校准
N    SysctrlPeripheralLcd        = 22u,      ///< LCD
N    SysctrlPeripheralTick       = 24u,      ///< 系统定时器
N    SysctrlPeripheralSwd        = 25u,      ///< SWD
N    SysctrlPeripheralCrc        = 26u,      ///< CRC
N    SysctrlPeripheralAes        = 27u,      ///< AES
N    SysctrlPeripheralGpio       = 28u,      ///< GPIO
N    SysctrlPeripheralDma        = 29u,      ///< DMA
N    SysctrlPeripheralDiv        = 30u,      ///< 除法器
N    SysctrlPeripheralFlash      = 31u,      ///< Flash
N}en_sysctrl_peripheral_gate_t;
N
N/**
N *******************************************************************************
N ** \brief 时钟初始化配置结构体定义
N ******************************************************************************/
Ntypedef struct
N{
N    en_sysctrl_clk_source_t  enClkSrc;       ///< 时钟源选择
N    en_sysctrl_hclk_div_t    enHClkDiv;      ///< HCLK分频系数
N    en_sysctrl_pclk_div_t    enPClkDiv;      ///< PCLK分频系数
N}stc_sysctrl_clk_config_t;
N
N/**
N *******************************************************************************
N ** \brief 时钟初始化配置结构体定义
N ******************************************************************************/
Ntypedef struct
N{
N    en_sysctrl_pll_infreq_t    enInFreq;        ///< PLL输入时钟频率范围选择
N    en_sysctrl_pll_outfreq_t   enOutFreq;       ///< PLL输出时钟频率范围选择
N    en_sysctrl_pll_clksource_t enPllClkSrc;     ///< PLL输入时钟源选择
N    en_sysctrl_pll_mul_t       enPllMul;        ///< PLL倍频系数选择
N}stc_sysctrl_pll_config_t;
N
N/******************************************************************************
N * Global variable declarations ('extern', definition in C source)
N ******************************************************************************/
N
N/******************************************************************************
N * Global function prototypes (definition in C source)
N ******************************************************************************/
N///< 系统时钟初始化API:用于上电后，系统工作之前对主频及外设时钟进行初始化； 
N///< 注意1：使用该初始化函数前需要根据系统，必须优先设置目标内部时钟源的TRIM值或外部时钟源的频率范围，
N///< 注意2：XTH、XTL的频率范围设定，需要根据外部晶振决定，
N///< 注意3：本驱动默认宏定义：SYSTEM_XTH=32MHz,SYSTEM_XTL=32768Hz,如使用其它外部晶振，必须修改这两个宏定义的值。
Nen_result_t Sysctrl_ClkInit(stc_sysctrl_clk_config_t *pstcCfg);
N
N///< 系统时钟去初始化API:恢复为上电默认状态->PCLK=HCLK=SystemClk=RCH4MHz
Nen_result_t Sysctrl_ClkDeInit(void);
N
N///< 系统时钟模块的基本功能设置
N///< 注意：使能需要使用的时钟源之前，必须优先设置目标内部时钟源的TRIM值或外部时钟源的频率范围
Nen_result_t Sysctrl_ClkSourceEnable(en_sysctrl_clk_source_t enSource, boolean_t bFlag);
N
N///<外部晶振驱动配置：系统初始化Sysctrl_ClkInit()之后，可根据需要配置外部晶振的驱动能力，时钟初始化Sysctrl_ClkInit()默认为最大值;
Nen_result_t Sysctrl_XTHDriverConfig(en_sysctrl_xtal_driver_t enDriver);
Nen_result_t Sysctrl_XTLDriverConfig(en_sysctrl_xtl_amp_t enAmp, en_sysctrl_xtal_driver_t enDriver);
N
N///<时钟稳定周期设置:系统初始化Sysctrl_ClkInit()之后，可根据需要配置时钟开启后的稳定之间，默认为最大值;
Nen_result_t Sysctrl_SetXTHStableTime(en_sysctrl_xth_cycle_t enCycle);
Nen_result_t Sysctrl_SetRCLStableTime(en_sysctrl_rcl_cycle_t enCycle);
Nen_result_t Sysctrl_SetXTLStableTime(en_sysctrl_xtl_cycle_t enCycle);
Nen_result_t Sysctrl_SetPLLStableTime(en_sysctrl_pll_cycle_t enCycle);
N
N///<系统时钟源切换并更新系统时钟：如果需要在系统时钟初始化Sysctrl_ClkInit()之后切换主频时钟源，则使用该函数；
N///< 时钟切换前后，必须根据目标频率值设置Flash读等待周期，可配置插入周期为0、1、2，
N///< 注意!!!：当HCLK大于24MHz时，FLASH等待周期插入必须至少为1,否则程序运行可能产生未知错误
Nen_result_t Sysctrl_SysClkSwitch(en_sysctrl_clk_source_t enSource);
N
N///< 时钟源频率设定：根据系统情况，单独设置不同时钟源的频率值;
N///< 时钟频率设置前，必须根据目标频率值设置Flash读等待周期，可配置插入周期为0、1、2，
N///< 其中XTL的时钟由外部晶振决定，无需设置。
Nen_result_t Sysctrl_SetRCHTrim(en_sysctrl_rch_freq_t enRCHFreq);
Nen_result_t Sysctrl_SetRCLTrim(en_sysctrl_rcl_freq_t enRCLFreq);
Nen_result_t Sysctrl_SetXTHFreq(en_sysctrl_xth_freq_t enXTHFreq);
Nen_result_t Sysctrl_SetPLLFreq(stc_sysctrl_pll_config_t *pstcPLLCfg);
N
N///< 时钟分频设置:根据系统情况，单独设置HCLK、PCLK的分配值;
Nen_result_t Sysctrl_SetHCLKDiv(en_sysctrl_hclk_div_t enHCLKDiv);
Nen_result_t Sysctrl_SetPCLKDiv(en_sysctrl_pclk_div_t enPCLKDiv);
N
N///< 时钟频率获取：根据系统需要，获取当前HCLK及PCLK的频率值
Nuint32_t Sysctrl_GetHClkFreq(void);
Nuint32_t Sysctrl_GetPClkFreq(void);
N
N///< 外设门控开关/状态获取：用于控制外设模块的使能，使用该模块的功能之前，必须使能该模块的门控时钟；
Nen_result_t Sysctrl_SetPeripheralGate(en_sysctrl_peripheral_gate_t enPeripheral, boolean_t bFlag);
Nboolean_t   Sysctrl_GetPeripheralGate(en_sysctrl_peripheral_gate_t enPeripheral);
N
N///< 系统功能配置：用于设置其他系统相关特殊功能；
Nen_result_t Sysctrl_SetFunc(en_sysctrl_func_t enFunc, boolean_t bFlag);
N
N///< RTC高速时钟补偿:用于设置RTC高速时钟下的频率补偿
Nen_result_t Sysctrl_SetRTCAdjustClkFreq(en_sysctrl_rtc_adjust_t enRtcAdj);
N
N//@} // Sysctrl Group
N
N#ifdef __cplusplus
N#endif
N
N#endif /* __SYSCTRL_H__ */
N/*******************************************************************************
N * EOF (not truncated)
N ******************************************************************************/
N
N
L 61 "..\..\..\M0P0_Library\HC32L13X_DDL_V1.0\driver\inc\ddl.h" 2
N
N/* C binding of definitions if building with C++ compiler                     */
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/******************************************************************************/
N/* Global pre-processor symbols/macros ('#define')                            */
N/* Macro for initializing local structures to zero                            */
N/******************************************************************************/
N#define DDL_ZERO_STRUCT(x)          ddl_memclr((uint8_t*)&(x), (uint32_t)(sizeof(x)))
N
N#define DEC2BCD(x)                  ((((x)/10)<<4) + ((x)%10))
N#define BCD2DEC(x)                  ((((x)>>4)*10) + ((x)&0x0F))
N
N#define setBit(addr,offset,flag)    {   if( (flag) > 0u){\
N                                            *((volatile uint32_t *)(addr)) |= ((1UL)<<(offset));\
N                                        }else{\
N                                            *((volatile uint32_t *)(addr)) &= (~(1UL<<(offset)));\
N                                        }\
N                                    }
X#define setBit(addr,offset,flag)    {   if( (flag) > 0u){                                            *((volatile uint32_t *)(addr)) |= ((1UL)<<(offset));                                        }else{                                            *((volatile uint32_t *)(addr)) &= (~(1UL<<(offset)));                                        }                                    }
N
N#define getBit(addr,offset)         ((((*((volatile uint32_t *)(addr))) >> (offset)) & 1u)>0?1u:0)
N
N/**
N ******************************************************************************
N ** Global Device Series List
N ******************************************************************************/
N#define DDL_DEVICE_SERIES_HC32L13X       (0u)
N
N/**
N ******************************************************************************
N ** Global Device Package List
N ******************************************************************************/
N// package definitions of HC device.
N#define DDL_DEVICE_PACKAGE_HC_C         (0x00u)
N#define DDL_DEVICE_PACKAGE_HC_F         (0x10u)
N#define DDL_DEVICE_PACKAGE_HC_J         (0x20u)
N#define DDL_DEVICE_PACKAGE_HC_K         (0x30u)
N
N/******************************************************************************/
N/* User Device Setting Include file                                           */
N/******************************************************************************/
N#include "ddl_device.h"  // MUST be included here!
L 1 "..\..\..\M0P0_Library\HC32L13X_DDL_V1.0\mcu\common\ddl_device.h" 1
N/*******************************************************************************
N* Copyright (C) 2018, Huada Semiconductor Co.,Ltd All rights reserved.
N*
N* This software is owned and published by:
N* Huada Semiconductor Co.,Ltd ("HDSC").
N*
N* BY DOWNLOADING, INSTALLING OR USING THIS SOFTWARE, YOU AGREE TO BE BOUND
N* BY ALL THE TERMS AND CONDITIONS OF THIS AGREEMENT.
N*
N* This software contains source code for use with HDSC
N* components. This software is licensed by HDSC to be adapted only
N* for use in systems utilizing HDSC components. HDSC shall not be
N* responsible for misuse or illegal use of this software for devices not
N* supported herein. HDSC is providing this software "AS IS" and will
N* not be responsible for issues arising from incorrect user implementation
N* of the software.
N*
N* Disclaimer:
N* HDSC MAKES NO WARRANTY, EXPRESS OR IMPLIED, ARISING BY LAW OR OTHERWISE,
N* REGARDING THE SOFTWARE (INCLUDING ANY ACOOMPANYING WRITTEN MATERIALS),
N* ITS PERFORMANCE OR SUITABILITY FOR YOUR INTENDED USE, INCLUDING,
N* WITHOUT LIMITATION, THE IMPLIED WARRANTY OF MERCHANTABILITY, THE IMPLIED
N* WARRANTY OF FITNESS FOR A PARTICULAR PURPOSE OR USE, AND THE IMPLIED
N* WARRANTY OF NONINFRINGEMENT.
N* HDSC SHALL HAVE NO LIABILITY (WHETHER IN CONTRACT, WARRANTY, TORT,
N* NEGLIGENCE OR OTHERWISE) FOR ANY DAMAGES WHATSOEVER (INCLUDING, WITHOUT
N* LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS, BUSINESS INTERRUPTION,
N* LOSS OF BUSINESS INFORMATION, OR OTHER PECUNIARY LOSS) ARISING FROM USE OR
N* INABILITY TO USE THE SOFTWARE, INCLUDING, WITHOUT LIMITATION, ANY DIRECT,
N* INDIRECT, INCIDENTAL, SPECIAL OR CONSEQUENTIAL DAMAGES OR LOSS OF DATA,
N* SAVINGS OR PROFITS,
N* EVEN IF Disclaimer HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
N* YOU ASSUME ALL RESPONSIBILITIES FOR SELECTION OF THE SOFTWARE TO ACHIEVE YOUR
N* INTENDED RESULTS, AND FOR THE INSTALLATION OF, USE OF, AND RESULTS OBTAINED
N* FROM, THE SOFTWARE.
N*
N* This software may be replicated in part or whole for the licensed use,
N* with the restriction that this Disclaimer and Copyright notice must be
N* included with each copy of this software, whether used in part or whole,
N* at all times.
N*/
N/******************************************************************************/
N/** \file ddl_device.h
N **
N ** Device define
N ** @link SampleGroup Some description @endlink
N **
N **   - 2018-04-15
N **
N *****************************************************************************/
N
N#ifndef  __DDL_DEVICE_H__
N#define  __DDL_DEVICE_H__
N
N/**
N *******************************************************************************
N ** \brief Global device series definition
N **
N ** \note 
N ******************************************************************************/
N#define DDL_MCU_SERIES       DDL_DEVICE_SERIES_HC32L13X
N
N
N/**
N *******************************************************************************
N ** \brief Global package definition
N **
N ** \note This definition is used for device package settings
N ******************************************************************************/
N#define DDL_MCU_PACKAGE      DDL_DEVICE_PACKAGE_HC_K
N
N#endif /* __DDL_DEVICE_H__ */
N
N/*******************************************************************************
N * EOF (not truncated)                                                        
N ******************************************************************************/
L 106 "..\..\..\M0P0_Library\HC32L13X_DDL_V1.0\driver\inc\ddl.h" 2
N
N/**
N ******************************************************************************
N ** \brief IRQ name definition for all type MCUs
N ******************************************************************************/
N    
N    #define PORTA_IRQHandler(void)              IRQ000_Handler(void)
N    #define PORTB_IRQHandler(void)              IRQ001_Handler(void)
N    #define PORTC_IRQHandler(void)              IRQ002_Handler(void)
N    #define PORTD_IRQHandler(void)              IRQ003_Handler(void)
N    #define DMAC_IRQHandler(void)               IRQ004_Handler(void)
N    #define TIM3_IRQHandler(void)               IRQ005_Handler(void)
N    #define UART0_IRQHandler(void)              IRQ006_Handler(void)
N    #define UART1_IRQHandler(void)              IRQ007_Handler(void)
N    #define LPUART0_IRQHandler(void)            IRQ008_Handler(void)
N    #define LPUART1_IRQHandler(void)            IRQ009_Handler(void)
N    #define SPI0_IRQHandler(void)               IRQ010_Handler(void)
N    #define SPI1_IRQHandler(void)               IRQ011_Handler(void)
N    #define I2C0_IRQHandler(void)               IRQ012_Handler(void)
N    #define I2C1_IRQHandler(void)               IRQ013_Handler(void)
N    #define TIM0_IRQHandler(void)               IRQ014_Handler(void)
N    #define TIM1_IRQHandler(void)               IRQ015_Handler(void)
N    #define TIM2_IRQHandler(void)               IRQ016_Handler(void)
N    #define LPTIM_IRQHandler(void)              IRQ017_Handler(void)
N    #define TIM4_IRQHandler(void)               IRQ018_Handler(void)
N    #define TIM5_IRQHandler(void)               IRQ019_Handler(void)
N    #define TIM6_IRQHandler(void)               IRQ020_Handler(void)
N    #define PCA_IRQHandler(void)                IRQ021_Handler(void)
N    #define WDT_IRQHandler(void)                IRQ022_Handler(void)
N    #define RTC_IRQHandler(void)                IRQ023_Handler(void)
N    #define ADC_IRQHandler(void)                IRQ024_Handler(void)
N    #define PCNT_IRQHandler(void)               IRQ025_Handler(void)
N    #define VC0_IRQHandler(void)                IRQ026_Handler(void)
N    #define VC1_IRQHandler(void)                IRQ027_Handler(void)
N    #define LVD_IRQHandler(void)                IRQ028_Handler(void)
N    #define LCD_IRQHandler(void)                IRQ029_Handler(void)
N    #define EF_RAM_IRQHandler(void)             IRQ030_Handler(void)
N    #define CLKTRIM_IRQHandler(void)            IRQ031_Handler(void)
N
N/******************************************************************************/
N/* Global type definitions ('typedef')                                        */
N/******************************************************************************/
N/**
N ******************************************************************************
N ** \brief Level
N **
N ** Specifies levels.
N **
N ******************************************************************************/
Ntypedef enum en_level
N{
N    DdlLow      = 0u,  ///< Low level  '0'
N    DdlHigh     = 1u   ///< High level '1'
N} en_level_t;
N
N/**
N ******************************************************************************
N ** \brief Generic Flag Code
N **
N ** Specifies flags.
N **
N ******************************************************************************/
Ntypedef enum en_flag
N{
N    DdlClr = 0u,       ///< Flag clr '0'
N    DdlSet = 1u        ///< Flag set '1'
N} en_stat_flag_t, en_irq_flag_t;
N/******************************************************************************/
N/* Global variable declarations ('extern', definition in C source)            */
N/******************************************************************************/
N
N/******************************************************************************/
N/* Global function prototypes ('extern', definition in C source)              */
N/******************************************************************************/
N
N/*******************************************************************************
N * Global function prototypes
N ******************************************************************************/
Nextern void ddl_memclr(void* pu8Address, uint32_t u32Count);
Nuint32_t Log2(uint32_t u32Val);
N/**
N *******************************************************************************
N ** This hook is part of wait loops.
N ******************************************************************************/
Nextern void DDL_WAIT_LOOP_HOOK(void);
N
Nvoid Debug_UartInit(void);
N
Nvoid delay1ms(uint32_t u32Cnt);
Nvoid delay100us(uint32_t u32Cnt);
Nvoid delay10us(uint32_t u32Cnt);
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __DDL_H__ */
N
N/******************************************************************************/
N/* EOF (not truncated)                                                        */
N/******************************************************************************/
N
L 14 "..\..\MProkaron\Include\Platform/CortexM/Chips/HC32L136K8/rmp_platform_HC32L136K8.h" 2
N#include "core_cm0plus.h"
L 1 "..\..\..\M0P0_Library\HC32L13X_DDL_V1.0\driver\CMSIS\Include\core_cm0plus.h" 1
N/**************************************************************************//**
N * @file     core_cm0plus.h
N * @brief    CMSIS Cortex-M0+ Core Peripheral Access Layer Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060183 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CM0PLUS_H_GENERIC
S#define __CORE_CM0PLUS_H_GENERIC
S
S#include <stdint.h>
S
S#ifdef __cplusplus
S extern "C" {
S#endif
S
S/**
S  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
S  CMSIS violates the following MISRA-C:2004 rules:
S
S   \li Required Rule 8.5, object/function definition in header file.<br>
S     Function definitions in header files are used to allow 'inlining'.
S
S   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
S     Unions are used for effective representation of core registers.
S
S   \li Advisory Rule 19.7, Function-like macro defined.<br>
S     Function-like macros are used to allow more efficient code.
S */
S
S
S/*******************************************************************************
S *                 CMSIS definitions
S ******************************************************************************/
S/**
S  \ingroup Cortex-M0+
S  @{
S */
S
S/*  CMSIS CM0+ definitions */
S#define __CM0PLUS_CMSIS_VERSION_MAIN (0x04U)                                   /*!< [31:16] CMSIS HAL main version */
S#define __CM0PLUS_CMSIS_VERSION_SUB  (0x1EU)                                   /*!< [15:0]  CMSIS HAL sub version */
S#define __CM0PLUS_CMSIS_VERSION      ((__CM0PLUS_CMSIS_VERSION_MAIN << 16U) | \
S                                       __CM0PLUS_CMSIS_VERSION_SUB           ) /*!< CMSIS HAL version number */
X#define __CM0PLUS_CMSIS_VERSION      ((__CM0PLUS_CMSIS_VERSION_MAIN << 16U) |                                        __CM0PLUS_CMSIS_VERSION_SUB           )  
S
S#define __CORTEX_M                (0x00U)                                      /*!< Cortex-M Core */
S
S
S#if   defined ( __CC_ARM )
S  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler */
S  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler */
S  #define __STATIC_INLINE  static __inline
S
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler */
S  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler */
S  #define __STATIC_INLINE  static __inline
S
S#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TMS470__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TI CCS Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __CSMC__ )
S  #define __packed
S  #define __ASM            _asm                                      /*!< asm keyword for COSMIC Compiler */
S  #define __INLINE         inline                                    /*!< inline keyword for COSMIC Compiler. Use -pc99 on compile line */
S  #define __STATIC_INLINE  static inline
S
S#else
S  #error Unknown compiler
S#endif
S
S/** __FPU_USED indicates whether an FPU is used or not.
S    This core does not support an FPU at all
S*/
S#define __FPU_USED       0U
S
S#if defined ( __CC_ARM )
S  #if defined __TARGET_FPU_VFP
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #if defined __ARM_PCS_VFP
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TMS470__ )
S  #if defined __TI_VFP_SUPPORT__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __CSMC__ )
S  #if ( __CSMC__ & 0x400U)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#endif
S
S#include "core_cmInstr.h"                /* Core Instruction Access */
S#include "core_cmFunc.h"                 /* Core Function Access */
S
S#ifdef __cplusplus
S}
S#endif
S
N#endif /* __CORE_CM0PLUS_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM0PLUS_H_DEPENDANT
S#define __CORE_CM0PLUS_H_DEPENDANT
S
S#ifdef __cplusplus
S extern "C" {
S#endif
S
S/* check device defines and use defaults */
S#if defined __CHECK_DEVICE_DEFINES
S  #ifndef __CM0PLUS_REV
S    #define __CM0PLUS_REV             0x0000U
S    #warning "__CM0PLUS_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __MPU_PRESENT
S    #define __MPU_PRESENT             0U
S    #warning "__MPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __VTOR_PRESENT
S    #define __VTOR_PRESENT            0U
S    #warning "__VTOR_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          2U
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0U
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
S#endif
S
S/* IO definitions (access restrictions to peripheral registers) */
S/**
S    \defgroup CMSIS_glob_defs CMSIS Global Defines
S
S    <strong>IO Type Qualifiers</strong> are used
S    \li to specify the access to peripheral variables.
S    \li for automatic generation of peripheral register debug information.
S*/
S#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions */
S#else
S  #define   __I     volatile const       /*!< Defines 'read only' permissions */
S#endif
S#define     __O     volatile             /*!< Defines 'write only' permissions */
S#define     __IO    volatile             /*!< Defines 'read / write' permissions */
S
S/* following defines should be used for structure members */
S#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
S#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
S#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
S
S/*@} end of group Cortex-M0+ */
S
S
S
S/*******************************************************************************
S *                 Register Abstraction
S  Core Register contain:
S  - Core Register
S  - Core NVIC Register
S  - Core SCB Register
S  - Core SysTick Register
S  - Core MPU Register
S ******************************************************************************/
S/**
S  \defgroup CMSIS_core_register Defines and Type Definitions
S  \brief Type definitions and defines for Cortex-M processor based devices.
S*/
S
S/**
S  \ingroup    CMSIS_core_register
S  \defgroup   CMSIS_CORE  Status and Control Registers
S  \brief      Core Register type definitions.
S  @{
S */
S
S/**
S  \brief  Union type to access the Application Program Status Register (APSR).
S */
Stypedef union
S{
S  struct
S  {
S    uint32_t _reserved0:28;              /*!< bit:  0..27  Reserved */
S    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
S    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
S    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
S    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
S  } b;                                   /*!< Structure used for bit  access */
S  uint32_t w;                            /*!< Type      used for word access */
S} APSR_Type;
S
S/* APSR Register Definitions */
S#define APSR_N_Pos                         31U                                            /*!< APSR: N Position */
S#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
S
S#define APSR_Z_Pos                         30U                                            /*!< APSR: Z Position */
S#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
S
S#define APSR_C_Pos                         29U                                            /*!< APSR: C Position */
S#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
S
S#define APSR_V_Pos                         28U                                            /*!< APSR: V Position */
S#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
S
S
S/**
S  \brief  Union type to access the Interrupt Program Status Register (IPSR).
S */
Stypedef union
S{
S  struct
S  {
S    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
S    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
S  } b;                                   /*!< Structure used for bit  access */
S  uint32_t w;                            /*!< Type      used for word access */
S} IPSR_Type;
S
S/* IPSR Register Definitions */
S#define IPSR_ISR_Pos                        0U                                            /*!< IPSR: ISR Position */
S#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
S
S
S/**
S  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
S */
Stypedef union
S{
S  struct
S  {
S    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
S    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved */
S    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
S    uint32_t _reserved1:3;               /*!< bit: 25..27  Reserved */
S    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
S    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
S    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
S    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
S  } b;                                   /*!< Structure used for bit  access */
S  uint32_t w;                            /*!< Type      used for word access */
S} xPSR_Type;
S
S/* xPSR Register Definitions */
S#define xPSR_N_Pos                         31U                                            /*!< xPSR: N Position */
S#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
S
S#define xPSR_Z_Pos                         30U                                            /*!< xPSR: Z Position */
S#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
S
S#define xPSR_C_Pos                         29U                                            /*!< xPSR: C Position */
S#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
S
S#define xPSR_V_Pos                         28U                                            /*!< xPSR: V Position */
S#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
S
S#define xPSR_T_Pos                         24U                                            /*!< xPSR: T Position */
S#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
S
S#define xPSR_ISR_Pos                        0U                                            /*!< xPSR: ISR Position */
S#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
S
S
S/**
S  \brief  Union type to access the Control Registers (CONTROL).
S */
Stypedef union
S{
S  struct
S  {
S    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
S    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
S    uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
S  } b;                                   /*!< Structure used for bit  access */
S  uint32_t w;                            /*!< Type      used for word access */
S} CONTROL_Type;
S
S/* CONTROL Register Definitions */
S#define CONTROL_SPSEL_Pos                   1U                                            /*!< CONTROL: SPSEL Position */
S#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
S
S#define CONTROL_nPRIV_Pos                   0U                                            /*!< CONTROL: nPRIV Position */
S#define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONTROL: nPRIV Mask */
S
S/*@} end of group CMSIS_CORE */
S
S
S/**
S  \ingroup    CMSIS_core_register
S  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
S  \brief      Type definitions for the NVIC Registers
S  @{
S */
S
S/**
S  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
S */
Stypedef struct
S{
S  __IOM uint32_t ISER[1U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
S        uint32_t RESERVED0[31U];
S  __IOM uint32_t ICER[1U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
S        uint32_t RSERVED1[31U];
S  __IOM uint32_t ISPR[1U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
S        uint32_t RESERVED2[31U];
S  __IOM uint32_t ICPR[1U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
S        uint32_t RESERVED3[31U];
S        uint32_t RESERVED4[64U];
S  __IOM uint32_t IP[8U];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register */
S}  NVIC_Type;
S
S/*@} end of group CMSIS_NVIC */
S
S
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_SCB     System Control Block (SCB)
S  \brief    Type definitions for the System Control Block Registers
S  @{
S */
S
S/**
S  \brief  Structure type to access the System Control Block (SCB).
S */
Stypedef struct
S{
S  __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
S  __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
S#if (__VTOR_PRESENT == 1U)
S  __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
S#else
S        uint32_t RESERVED0;
S#endif
S  __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
S  __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
S  __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
S        uint32_t RESERVED1;
S  __IOM uint32_t SHP[2U];                /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED */
S  __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
S} SCB_Type;
S
S/* SCB CPUID Register Definitions */
S#define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB CPUID: IMPLEMENTER Position */
S#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
S
S#define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB CPUID: VARIANT Position */
S#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
S
S#define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB CPUID: ARCHITECTURE Position */
S#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
S
S#define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB CPUID: PARTNO Position */
S#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
S
S#define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB CPUID: REVISION Position */
S#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
S
S/* SCB Interrupt Control State Register Definitions */
S#define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB ICSR: NMIPENDSET Position */
S#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
S
S#define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB ICSR: PENDSVSET Position */
S#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
S
S#define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB ICSR: PENDSVCLR Position */
S#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
S
S#define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB ICSR: PENDSTSET Position */
S#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
S
S#define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB ICSR: PENDSTCLR Position */
S#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
S
S#define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB ICSR: ISRPREEMPT Position */
S#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
S
S#define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB ICSR: ISRPENDING Position */
S#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
S
S#define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB ICSR: VECTPENDING Position */
S#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
S
S#define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB ICSR: VECTACTIVE Position */
S#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
S
S#if (__VTOR_PRESENT == 1U)
S/* SCB Interrupt Control State Register Definitions */
S#define SCB_VTOR_TBLOFF_Pos                 8U                                            /*!< SCB VTOR: TBLOFF Position */
S#define SCB_VTOR_TBLOFF_Msk                (0xFFFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB VTOR: TBLOFF Mask */
S#endif
S
S/* SCB Application Interrupt and Reset Control Register Definitions */
S#define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB AIRCR: VECTKEY Position */
S#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
S
S#define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB AIRCR: VECTKEYSTAT Position */
S#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
S
S#define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB AIRCR: ENDIANESS Position */
S#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
S
S#define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB AIRCR: SYSRESETREQ Position */
S#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
S
S#define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB AIRCR: VECTCLRACTIVE Position */
S#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
S
S/* SCB System Control Register Definitions */
S#define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB SCR: SEVONPEND Position */
S#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
S
S#define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB SCR: SLEEPDEEP Position */
S#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
S
S#define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB SCR: SLEEPONEXIT Position */
S#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
S
S/* SCB Configuration Control Register Definitions */
S#define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB CCR: STKALIGN Position */
S#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
S
S#define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB CCR: UNALIGN_TRP Position */
S#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
S
S/* SCB System Handler Control and State Register Definitions */
S#define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB SHCSR: SVCALLPENDED Position */
S#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
S
S/*@} end of group CMSIS_SCB */
S
S
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
S  \brief    Type definitions for the System Timer Registers.
S  @{
S */
S
S/**
S  \brief  Structure type to access the System Timer (SysTick).
S */
Stypedef struct
S{
S  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
S  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
S  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
S  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
S} SysTick_Type;
S
S/* SysTick Control / Status Register Definitions */
S#define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysTick CTRL: COUNTFLAG Position */
S#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
S
S#define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysTick CTRL: CLKSOURCE Position */
S#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
S
S#define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysTick CTRL: TICKINT Position */
S#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
S
S#define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysTick CTRL: ENABLE Position */
S#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
S
S/* SysTick Reload Register Definitions */
S#define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysTick LOAD: RELOAD Position */
S#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
S
S/* SysTick Current Register Definitions */
S#define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysTick VAL: CURRENT Position */
S#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
S
S/* SysTick Calibration Register Definitions */
S#define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysTick CALIB: NOREF Position */
S#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
S
S#define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysTick CALIB: SKEW Position */
S#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
S
S#define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysTick CALIB: TENMS Position */
S#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
S
S/*@} end of group CMSIS_SysTick */
S
S#if (__MPU_PRESENT == 1U)
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
S  \brief    Type definitions for the Memory Protection Unit (MPU)
S  @{
S */
S
S/**
S  \brief  Structure type to access the Memory Protection Unit (MPU).
S */
Stypedef struct
S{
S  __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
S  __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
S  __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
S  __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register */
S  __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register */
S} MPU_Type;
S
S/* MPU Type Register Definitions */
S#define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU TYPE: IREGION Position */
S#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
S
S#define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU TYPE: DREGION Position */
S#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
S
S#define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU TYPE: SEPARATE Position */
S#define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU TYPE: SEPARATE Mask */
S
S/* MPU Control Register Definitions */
S#define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU CTRL: PRIVDEFENA Position */
S#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
S
S#define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU CTRL: HFNMIENA Position */
S#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
S
S#define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU CTRL: ENABLE Position */
S#define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU CTRL: ENABLE Mask */
S
S/* MPU Region Number Register Definitions */
S#define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU RNR: REGION Position */
S#define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU RNR: REGION Mask */
S
S/* MPU Region Base Address Register Definitions */
S#define MPU_RBAR_ADDR_Pos                   8U                                            /*!< MPU RBAR: ADDR Position */
S#define MPU_RBAR_ADDR_Msk                  (0xFFFFFFUL << MPU_RBAR_ADDR_Pos)              /*!< MPU RBAR: ADDR Mask */
S
S#define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU RBAR: VALID Position */
S#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
S
S#define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU RBAR: REGION Position */
S#define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU RBAR: REGION Mask */
S
S/* MPU Region Attribute and Size Register Definitions */
S#define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU RASR: MPU Region Attribute field Position */
S#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
S
S#define MPU_RASR_XN_Pos                    28U                                            /*!< MPU RASR: ATTRS.XN Position */
S#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
S
S#define MPU_RASR_AP_Pos                    24U                                            /*!< MPU RASR: ATTRS.AP Position */
S#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
S
S#define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU RASR: ATTRS.TEX Position */
S#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
S
S#define MPU_RASR_S_Pos                     18U                                            /*!< MPU RASR: ATTRS.S Position */
S#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
S
S#define MPU_RASR_C_Pos                     17U                                            /*!< MPU RASR: ATTRS.C Position */
S#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
S
S#define MPU_RASR_B_Pos                     16U                                            /*!< MPU RASR: ATTRS.B Position */
S#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
S
S#define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU RASR: Sub-Region Disable Position */
S#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
S
S#define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU RASR: Region Size Field Position */
S#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
S
S#define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU RASR: Region enable bit Position */
S#define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU RASR: Region enable bit Disable Mask */
S
S/*@} end of group CMSIS_MPU */
S#endif
S
S
S/**
S  \ingroup  CMSIS_core_register
S  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
S  \brief    Cortex-M0+ Core Debug Registers (DCB registers, SHCSR, and DFSR) are only accessible over DAP and not via processor.
S            Therefore they are not covered by the Cortex-M0+ header file.
S  @{
S */
S/*@} end of group CMSIS_CoreDebug */
S
S
S/**
S  \ingroup    CMSIS_core_register
S  \defgroup   CMSIS_core_bitfield     Core register bit field macros
S  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
S  @{
S */
S
S/**
S  \brief   Mask and shift a bit field value for use in a register bit range.
S  \param[in] field  Name of the register bit field.
S  \param[in] value  Value of the bit field.
S  \return           Masked and shifted value.
S*/
S#define _VAL2FLD(field, value)    ((value << field ## _Pos) & field ## _Msk)
S
S/**
S  \brief     Mask and shift a register value to extract a bit filed value.
S  \param[in] field  Name of the register bit field.
S  \param[in] value  Value of register.
S  \return           Masked and shifted bit field value.
S*/
S#define _FLD2VAL(field, value)    ((value & field ## _Msk) >> field ## _Pos)
S
S/*@} end of group CMSIS_core_bitfield */
S
S
S/**
S  \ingroup    CMSIS_core_register
S  \defgroup   CMSIS_core_base     Core Definitions
S  \brief      Definitions for base addresses, unions, and structures.
S  @{
S */
S
S/* Memory mapping of Cortex-M0+ Hardware */
S#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
S#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
S#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
S#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
S
S#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct */
S#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct */
S#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct */
S
S#if (__MPU_PRESENT == 1U)
S  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit */
S  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit */
S#endif
S
S/*@} */
S
S
S
S/*******************************************************************************
S *                Hardware Abstraction Layer
S  Core Function Interface contains:
S  - Core NVIC Functions
S  - Core SysTick Functions
S  - Core Register Access Functions
S ******************************************************************************/
S/**
S  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
S*/
S
S
S
S/* ##########################   NVIC functions  #################################### */
S/**
S  \ingroup  CMSIS_Core_FunctionInterface
S  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
S  \brief    Functions that manage interrupts and exceptions via the NVIC.
S  @{
S */
S
S/* Interrupt Priorities are WORD accessible only under ARMv6M                   */
S/* The following MACROS handle generation of the register offset and byte masks */
S#define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)
S#define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )
S#define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )
S
S
S/**
S  \brief   Enable External Interrupt
S  \details Enables a device-specific interrupt in the NVIC interrupt controller.
S  \param [in]      IRQn  External interrupt number. Value cannot be negative.
S */
S__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
S{
S  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
S}
S
S
S/**
S  \brief   Disable External Interrupt
S  \details Disables a device-specific interrupt in the NVIC interrupt controller.
S  \param [in]      IRQn  External interrupt number. Value cannot be negative.
S */
S__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
S{
S  NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
S}
S
S
S/**
S  \brief   Get Pending Interrupt
S  \details Reads the pending register in the NVIC and returns the pending bit for the specified interrupt.
S  \param [in]      IRQn  Interrupt number.
S  \return             0  Interrupt status is not pending.
S  \return             1  Interrupt status is pending.
S */
S__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
S{
S  return((uint32_t)(((NVIC->ISPR[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
S}
S
S
S/**
S  \brief   Set Pending Interrupt
S  \details Sets the pending bit of an external interrupt.
S  \param [in]      IRQn  Interrupt number. Value cannot be negative.
S */
S__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
S{
S  NVIC->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
S}
S
S
S/**
S  \brief   Clear Pending Interrupt
S  \details Clears the pending bit of an external interrupt.
S  \param [in]      IRQn  External interrupt number. Value cannot be negative.
S */
S__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
S{
S  NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
S}
S
S
S/**
S  \brief   Set Interrupt Priority
S  \details Sets the priority of an interrupt.
S  \note    The priority cannot be set for every core interrupt.
S  \param [in]      IRQn  Interrupt number.
S  \param [in]  priority  Priority to set.
S */
S__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
S{
S  if ((int32_t)(IRQn) < 0)
S  {
S    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
S       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
S  }
S  else
S  {
S    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
S       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
S  }
S}
S
S
S/**
S  \brief   Get Interrupt Priority
S  \details Reads the priority of an interrupt.
S           The interrupt number can be positive to specify an external (device specific) interrupt,
S           or negative to specify an internal (core) interrupt.
S  \param [in]   IRQn  Interrupt number.
S  \return             Interrupt Priority.
S                      Value is aligned automatically to the implemented priority bits of the microcontroller.
S */
S__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
S{
S
S  if ((int32_t)(IRQn) < 0)
S  {
S    return((uint32_t)(((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
S  }
S  else
S  {
S    return((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
S  }
S}
S
S
S/**
S  \brief   System Reset
S  \details Initiates a system reset request to reset the MCU.
S */
S__STATIC_INLINE void NVIC_SystemReset(void)
S{
S  __DSB();                                                          /* Ensure all outstanding memory accesses included
S                                                                       buffered write are completed before reset */
S  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
S                 SCB_AIRCR_SYSRESETREQ_Msk);
S  __DSB();                                                          /* Ensure completion of memory access */
S
S  for(;;)                                                           /* wait until reset */
S  {
S    __NOP();
S  }
S}
S
S/*@} end of CMSIS_Core_NVICFunctions */
S
S
S
S/* ##################################    SysTick function  ############################################ */
S/**
S  \ingroup  CMSIS_Core_FunctionInterface
S  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
S  \brief    Functions that configure the System.
S  @{
S */
S
S#if (__Vendor_SysTickConfig == 0U)
S
S/**
S  \brief   System Tick Configuration
S  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
S           Counter is in free running mode to generate periodic interrupts.
S  \param [in]  ticks  Number of ticks between two interrupts.
S  \return          0  Function succeeded.
S  \return          1  Function failed.
S  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
S           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
S           must contain a vendor-specific implementation of this function.
S */
S__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
S{
S  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
S  {
S    return (1UL);                                                   /* Reload value impossible */
S  }
S
S  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
S  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
S  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
S  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
S                   SysTick_CTRL_TICKINT_Msk   |
S                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
S  return (0UL);                                                     /* Function successful */
S}
S
S#endif
S
S/*@} end of CMSIS_Core_SysTickFunctions */
S
S
S
S
S#ifdef __cplusplus
S}
S#endif
S
N#endif /* __CORE_CM0PLUS_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
L 15 "..\..\MProkaron\Include\Platform/CortexM/Chips/HC32L136K8/rmp_platform_HC32L136K8.h" 2
N/* The maximum number of preemption priority levels in the system.
N * This parameter must be divisible by the word length - 32 is usually sufficient */
N#define RMP_MAX_PREEMPT_PRIO         32
N/* The maximum number of slices allowed */
N#define RMP_MAX_SLICES               100000
N/* The maximum number of semaphore counts allowed */
N#define RMP_SEM_MAX_NUM              1000
N/* Are we using custom hooks? */
N#define RMP_USE_HOOKS                RMP_FALSE
N/* The stzck size of the init thread */
N#define RMP_INIT_STACK_SIZE          256
N/* The mask/unmask interrupt operations */
N#define RMP_MASK_INT()               RMP_Disable_Int()
N#define RMP_UNMASK_INT()             RMP_Enable_Int()
N
N/* What is the NVIC priority grouping? */
N#define RMP_CMX_NVIC_GROUPING        RMP_CMX_NVIC_GROUPING_P2S6
N/* What is the Systick value? */
N#define RMP_CMX_SYSTICK_VAL          24000
N
N/* Other low-level initialization stuff - clock and serial
N * This device requires that you switch from low to high frequency.
N * The manufacturer have defined their own delay functions - do not use
N * them, because they are not OS agnostic and will reprogram the systick 
N * to something that you possibly don't want. 
N * This is the default initialization sequence. If you wish to supply
N * your own, just redirect this macro to a custom function, or do your
N * initialization stuff in the initialization hook (RMP_Start_Hook). */
N#define RMP_CMX_LOW_LEVEL_INIT() \
Ndo \
N{ \
N    /* Switch to the target clock frequency */ \
N    Sysctrl_SetRCLTrim(SysctrlRclFreq32768); \
N    Sysctrl_ClkSourceEnable(SysctrlClkRCL, TRUE); \
N    Sysctrl_SysClkSwitch(SysctrlClkRCL); \
N    Sysctrl_SetRCHTrim(SysctrlRchFreq24MHz); \
N	Sysctrl_SysClkSwitch(SysctrlClkRCH); \
N    /* Turn off the low speed RC oscillator and update core clock */ \
N	Sysctrl_ClkSourceEnable(SysctrlClkRCL, FALSE); \
N    SystemCoreClockUpdate(); \
N    \
N    /* Set the priority of timer, svc and faults to the lowest */ \
N    NVIC_SetPriority(SVC_IRQn, 0xFF); \
N    NVIC_SetPriority(PendSV_IRQn, 0xFF); \
N    NVIC_SetPriority(SysTick_IRQn, 0xFF); \
N    /* Configure systick */ \
N    SysTick_Config(RMP_CMX_SYSTICK_VAL); \
N} \
Nwhile(0)
X#define RMP_CMX_LOW_LEVEL_INIT() do {           Sysctrl_SetRCLTrim(SysctrlRclFreq32768);     Sysctrl_ClkSourceEnable(SysctrlClkRCL, TRUE);     Sysctrl_SysClkSwitch(SysctrlClkRCL);     Sysctrl_SetRCHTrim(SysctrlRchFreq24MHz); 	Sysctrl_SysClkSwitch(SysctrlClkRCH);       	Sysctrl_ClkSourceEnable(SysctrlClkRCL, FALSE);     SystemCoreClockUpdate();               NVIC_SetPriority(SVC_IRQn, 0xFF);     NVIC_SetPriority(PendSV_IRQn, 0xFF);     NVIC_SetPriority(SysTick_IRQn, 0xFF);           SysTick_Config(RMP_CMX_SYSTICK_VAL); } while(0)
N
N/* This is for debugging output */
N#define RMP_CMX_PUTCHAR(CHAR) \
Ndo \
N{ \
N} \
Nwhile(0)
X#define RMP_CMX_PUTCHAR(CHAR) do { } while(0)
N/* End Defines ***************************************************************/
N
N/* End Of File ***************************************************************/
N
N/* Copyright (C) Evo-Devo Instrum. All rights reserved ***********************/
L 11 "..\..\MProkaron\Include\Platform/CortexM/rmp_platform_cmx_conf.h" 2
N/* End Config Includes *******************************************************/
N
N/* End Of File ***************************************************************/
N
N/* Copyright (C) Evo-Devo Instrum. All rights reserved ***********************/
L 78 "..\..\MProkaron\Include\Platform/CortexM/rmp_platform_cmx.h" 2
N/* End System macros *********************************************************/
N
N/* Cortex-M specific macros **************************************************/
N/* MPU operation flag */
N#define RMP_CMX_MPU_CLR                 (0)
N#define RMP_CMX_MPU_UPD                 (1)
N/* MPU definitions */
N/* Extract address for/from MPU */
N#define RMP_CMX_MPU_ADDR(X)             ((X)&0xFFFFFFE0)
N/* Get info from MPU */
N#define RMP_CMX_MPU_SZORD(X)            ((((X)&0x3F)>>1)-2)
N/* Write info to MPU */
N#define RMP_CMX_MPU_VALID               (1<<4)
N#define RMP_CMX_MPU_SRDCLR              (0x0000FF00)
N#define RMP_CMX_MPU_XN                  (1<<28)
N#define RMP_CMX_MPU_RO                  (2<<24)
N#define RMP_CMX_MPU_RW                  (3<<24)
N#define RMP_CMX_MPU_CACHEABLE           (1<<17)
N#define RMP_CMX_MPU_BUFFERABLE          (1<<16)
N#define RMP_CMX_MPU_REGIONSIZE(X)       ((X+2)<<1)
N#define RMP_CMX_MPU_SZENABLE            (1)
N/* Cortex-M (ARMv8) EXC_RETURN values */
N#define RMP_CMX_EXC_RET_BASE            (0xFFFFFF80)
N/* Whether we are returning to secure stack. 1 means yes, 0 means no */
N#define RMP_CMX_EXC_RET_SECURE_STACK    (1<<6)
N/* Whether the callee registers are automatically pushed to user stack. 1 means yes, 0 means no */
N#define RMP_CMX_EXC_RET_CALLEE_SAVE     (1<<5)
N/* Whether the stack frame is standard(contains no FPU data). 1 means yes, 0 means no */
N#define RMP_CMX_EXC_RET_STD_FRAME       (1<<4)
N/* Are we returning to user mode? 1 means yes, 0 means no */
N#define RMP_CMX_EXC_RET_RET_USER        (1<<3)
N/* Are we returning to PSP? 1 means yes, 0 means no */
N#define RMP_CMX_EXC_RET_RET_PSP         (1<<2)
N/* Is this interrupt taken to a secured domain? 1 means yes, 0 means no */
N#define RMP_CMX_EXC_INT_SECURE_DOMAIN   (1<<0)
N/* FPU type definitions */
N#define RMP_CMX_FPU_NONE                (0)
N#define RMP_CMX_FPU_VFPV4               (1)
N#define RMP_CMX_FPU_FPV5_SP             (2)
N#define RMP_CMX_FPU_FPV5_DP             (3)
N
N/* Some useful SCB definitions */
N#define RMP_CMX_SHCSR_USGFAULTENA       (1<<18)
N#define RMP_CMX_SHCSR_BUSFAULTENA       (1<<17)
N#define RMP_CMX_SHCSR_MEMFAULTENA       (1<<16)
N/* MPU definitions */
N#define RMP_CMX_MPU_PRIVDEF             0x00000004
N/* NVIC definitions */
N#define RMP_CMX_NVIC_GROUPING_P7S1      0
N#define RMP_CMX_NVIC_GROUPING_P6S2      1
N#define RMP_CMX_NVIC_GROUPING_P5S3      2
N#define RMP_CMX_NVIC_GROUPING_P4S4      3
N#define RMP_CMX_NVIC_GROUPING_P3S5      4
N#define RMP_CMX_NVIC_GROUPING_P2S6      5
N#define RMP_CMX_NVIC_GROUPING_P1S7      6
N#define RMP_CMX_NVIC_GROUPING_P0S8      7
N/* Fault definitions */
N/* The NMI is active */
N#define RMP_CMX_ICSR_NMIPENDSET         (((rmp_ptr_t)1)<<31)
N/* Debug event has occurred. The Debug Fault Status Register has been updated */
N#define RMP_CMX_HFSR_DEBUGEVT           (((rmp_ptr_t)1)<<31)
N/* Processor has escalated a configurable-priority exception to HardFault */
N#define RMP_CMX_HFSR_FORCED             (1<<30)
N/* Vector table read fault has occurred */
N#define RMP_CMX_HFSR_VECTTBL            (1<<1)
N/* Divide by zero */
N#define RMP_CMX_UFSR_DIVBYZERO          (1<<25)
N/* Unaligned load/store access */
N#define RMP_CMX_UFSR_UNALIGNED          (1<<24)
N/* No such coprocessor */
N#define RMP_CMX_UFSR_NOCP               (1<<19)
N/* Invalid vector return LR or PC value */
N#define RMP_CMX_UFSR_INVPC              (1<<18)
N/* Invalid IT instruction or related instructions */
N#define RMP_CMX_UFSR_INVSTATE           (1<<17)
N/* Invalid IT instruction or related instructions */
N#define RMP_CMX_UFSR_UNDEFINSTR         (1<<16)
N/* The Bus Fault Address Register is valid */
N#define RMP_CMX_BFSR_BFARVALID          (1<<15)
N/* The bus fault happened during FP lazy stacking */
N#define RMP_CMX_BFSR_LSPERR             (1<<13)
N/* A derived bus fault has occurred on exception entry */
N#define RMP_CMX_BFSR_STKERR             (1<<12)
N/* A derived bus fault has occurred on exception return */
N#define RMP_CMX_BFSR_UNSTKERR           (1<<11)
N/* Imprecise data access error has occurred */
N#define RMP_CMX_BFSR_IMPRECISERR        (1<<10)
N/* A precise data access error has occurred, and the processor 
N * has written the faulting address to the BFAR */
N#define RMP_CMX_BFSR_PRECISERR          (1<<9)
N/* A bus fault on an instruction prefetch has occurred. The 
N * fault is signaled only if the instruction is issued */
N#define RMP_CMX_BFSR_IBUSERR            (1<<8)
N/* The Memory Mnagement Fault Address Register have valid contents */
N#define RMP_CMX_MFSR_MMARVALID          (1<<7)
N/* A MemManage fault occurred during FP lazy state preservation */
N#define RMP_CMX_MFSR_MLSPERR            (1<<5)
N/* A derived MemManage fault occurred on exception entry */
N#define RMP_CMX_MFSR_MSTKERR            (1<<4)
N/* A derived MemManage fault occurred on exception return */
N#define RMP_CMX_MFSR_MUNSTKERR          (1<<3)
N/* Data access violation. The MMFAR shows the data address that
N * the load or store tried to access */
N#define RMP_CMX_MFSR_DACCVIOL           (1<<1)
N/* MPU or Execute Never (XN) default memory map access violation on an
N * instruction fetch has occurred. The fault is signalled only if the
N * instruction is issued */
N#define RMP_CMX_MFSR_IACCVIOL           (1<<0)
N
N/* These faults cannot be recovered and will lead to termination immediately */
N#define RMP_CMX_FAULT_FATAL             (RMP_CMX_UFSR_DIVBYZERO|RMP_CMX_UFSR_UNALIGNED| \
N                                         RMP_CMX_UFSR_NOCP|RMP_CMX_UFSR_INVPC| \
N                                         RMP_CMX_UFSR_INVSTATE|RMP_CMX_UFSR_UNDEFINSTR| \
N                                         RMP_CMX_BFSR_LSPERR|RMP_CMX_BFSR_STKERR| \
N                                         RMP_CMX_BFSR_UNSTKERR|RMP_CMX_BFSR_IMPRECISERR| \
N                                         RMP_CMX_BFSR_PRECISERR|RMP_CMX_BFSR_IBUSERR)
X#define RMP_CMX_FAULT_FATAL             (RMP_CMX_UFSR_DIVBYZERO|RMP_CMX_UFSR_UNALIGNED|                                          RMP_CMX_UFSR_NOCP|RMP_CMX_UFSR_INVPC|                                          RMP_CMX_UFSR_INVSTATE|RMP_CMX_UFSR_UNDEFINSTR|                                          RMP_CMX_BFSR_LSPERR|RMP_CMX_BFSR_STKERR|                                          RMP_CMX_BFSR_UNSTKERR|RMP_CMX_BFSR_IMPRECISERR|                                          RMP_CMX_BFSR_PRECISERR|RMP_CMX_BFSR_IBUSERR)
N/*****************************************************************************/
N/* __RMP_PLATFORM_CMX_H_DEFS__ */
N#endif
N/* __HDR_DEFS__ */
N#endif
N/* End Defines ***************************************************************/
N
N/* Structs *******************************************************************/
N#ifdef __HDR_STRUCTS__
S#ifndef __RMP_PLATFORM_CMX_H_STRUCTS__
S#define __RMP_PLATFORM_CMX_H_STRUCTS__
S/* We used structs in the header */
S
S/* Use defines in these headers */
S#define __HDR_DEFS__
S#undef __HDR_DEFS__
S/*****************************************************************************/
S
S/*****************************************************************************/
S/* __RMP_PLATFORM_CMX_H_STRUCTS__ */
S#endif
S/* __HDR_STRUCTS__ */
N#endif
N/* End Structs ***************************************************************/
N
N/* Private Global Variables **************************************************/
N#if(!(defined __HDR_DEFS__||defined __HDR_STRUCTS__))
X#if(!(1L||0L))
S#ifndef __RMP_PLATFORM_CMX_MEMBERS__
S#define __RMP_PLATFORM_CMX_MEMBERS__
S
S/* In this way we can use the data structures and definitions in the headers */
S#define __HDR_DEFS__
S
S#undef __HDR_DEFS__
S
S#define __HDR_STRUCTS__
S
S#undef __HDR_STRUCTS__
S
S/* If the header is not used in the public mode */
S#ifndef __HDR_PUBLIC_MEMBERS__
S/*****************************************************************************/
S
S/*****************************************************************************/
S/* End Private Global Variables **********************************************/
S
S/* Private C Function Prototypes *********************************************/ 
S/*****************************************************************************/
S
S/*****************************************************************************/
S#define __EXTERN__
S/* End Private C Function Prototypes *****************************************/
S
S/* Public Global Variables ***************************************************/
S/* __HDR_PUBLIC_MEMBERS__ */
S#else
S#define __EXTERN__ EXTERN 
S/* __HDR_PUBLIC_MEMBERS__ */
S#endif
S
S/*****************************************************************************/
S
S/*****************************************************************************/
S
S/* End Public Global Variables ***********************************************/
S
S/* Public C Function Prototypes **********************************************/
S/*****************************************************************************/
S/* Interrupts */
SEXTERN void RMP_Disable_Int(void);
SEXTERN void RMP_Enable_Int(void);
SEXTERN void RMP_Mask_Int(rmp_ptr_t Level);
S
SEXTERN rmp_ptr_t RMP_MSB_Get(rmp_ptr_t Val);
SEXTERN void _RMP_Start(rmp_ptr_t Entry, rmp_ptr_t Stack);
SEXTERN void _RMP_Yield(void);
S
S/* Initialization */
S__EXTERN__ void _RMP_Stack_Init(rmp_ptr_t Entry, rmp_ptr_t Stack, rmp_ptr_t Arg);
S__EXTERN__ void _RMP_Low_Level_Init(void);
S__EXTERN__ void RMP_Putchar(char Char);
S__EXTERN__ void _RMP_Plat_Hook(void);
S/*****************************************************************************/
S/* Undefine "__EXTERN__" to avoid redefinition */
S#undef __EXTERN__
S/* __RMP_PLATFORM_CMX_MEMBERS__ */
S#endif
S/* !(defined __HDR_DEFS__||defined __HDR_STRUCTS__) */
N#endif
N/* End Public C Function Prototypes ******************************************/
N
N/* End Of File ***************************************************************/
N
N/* Copyright (C) Evo-Devo Instrum. All rights reserved ***********************/
L 11 "..\..\MProkaron\Include\Platform/rmp_platform.h" 2
N/* End Platform Includes *****************************************************/
N
N/* End Of File ***************************************************************/
N
N/* Copyright (C) Evo-Devo Instrum. All rights reserved ***********************/
L 17 "..\..\MProkaron\Kernel\rmp_kernel.c" 2
N#include "Kernel/rmp_kernel.h"
L 1 "..\..\MProkaron\Include\Kernel/rmp_kernel.h" 1
N/******************************************************************************
NFilename    : rmp_kernel.h
NAuthor      : pry
NDate        : 01/04/2017
NLicence     : LGPL v3+; see COPYING for details.
NDescription : The header file for the kernel.
N******************************************************************************/
N
N/* Defines *******************************************************************/
N#ifdef __HDR_DEFS__
N#ifndef __RMP_KERNEL_H_DEFS__
N#define __RMP_KERNEL_H_DEFS__
N/*****************************************************************************/
N/* Constants */
N#define RMP_TRUE                    1
N#define RMP_FALSE                   0
N/* States of threads */
N#define RMP_THD_STATE(X)            ((X)&0xFF)
N#define RMP_THD_FLAG(X)             ((X)&~0xFF)
N#define RMP_THD_STATE_SET(X,S)      ((X)=(RMP_THD_FLAG(X)|(S)))
N
N/* Memory pool position lookup */
N#define RMP_MEM_POS(FLI,SLI)        ((SLI)+((FLI)<<3))
N
N/* This thread is currently unused */
N#define RMP_THD_FREE                (0)
N/* This thread is currently running */
N#define RMP_THD_RUNNING             (1)
N/* Blocked on a send endpoint */
N#define RMP_THD_SNDBLK              (2)
N/* Blocked on a send endpoint with a timeout */
N#define RMP_THD_SNDDLY              (3)
N/* Blocked on its own receive endpoint */
N#define RMP_THD_RCVBLK              (4)
N/* Blocked on its own receive endpoint with a timeout */
N#define RMP_THD_RCVDLY              (5)
N/* Just on the timer delay */
N#define RMP_THD_DELAYED             (6)
N/* Blocked on a semaphore */
N#define RMP_THD_SEMBLK              (7)
N/* Blocked on a semaphore with a timeout */
N#define RMP_THD_SEMDLY              (8)
N/* Suspended */
N#define RMP_THD_SUSPENDED           (1<<8)
N/* Mailbox valid */
N#define RMP_THD_MBOXFUL             (RMP_THD_SUSPENDED<<1)
N    
N/* States of semaphores */
N#define RMP_SEM_FREE                (0)
N#define RMP_SEM_USED                (1)
N
N/* States of memory blocks */
N#define RMP_MEM_FREE                (0)
N#define RMP_MEM_USED                (1)
N
N/* Error codes */
N/* This error is thread related */
N#define RMP_ERR_THD                 (-1)
N/* This error is priority related */
N#define RMP_ERR_PRIO                (-2)
N/* This error is timeslice related */
N#define RMP_ERR_SLICE               (-3)
N/* This error is thread state related */
N#define RMP_ERR_STATE               (-4)
N/* This error is operation related */
N#define RMP_ERR_OPER                (-5)
N/* This error is semaphore related */
N#define RMP_ERR_SEM                 (-6)
N/* This error is memory related */
N#define RMP_ERR_MEM                 (-7)
N
N/* Power and rounding */
N#define RMP_POW2(POW)               (((rmp_ptr_t)1)<<(POW))
N#define RMP_ROUND_DOWN(NUM,POW)     (((NUM)>>(POW))<<(POW))
N#define RMP_ROUND_UP(NUM,POW)       RMP_ROUND_DOWN((NUM)+RMP_POW2(POW)-1,POW)
N
N/* Word sizes settings */
N#define RMP_ALLBITS                 ((rmp_ptr_t)(-1))
N#define RMP_WORD_SIZE               RMP_POW2(RMP_WORD_ORDER)
N#define RMP_WORD_MASK               (~(RMP_ALLBITS<<RMP_WORD_ORDER))
N#define RMP_ALIGN_ORDER             (RMP_WORD_ORDER-3)
N#define RMP_ALIGN_MASK              (~(RMP_ALLBITS<<RMP_ALIGN_ORDER))
N#define RMP_BITMAP_SIZE             ((RMP_MAX_PREEMPT_PRIO-1)/RMP_WORD_SIZE+1)
N
N/* Stack offset macros */
N/* Head offset, for ascending stacks */
N#define RMP_INIT_STACK_HEAD(X)      (((rmp_ptr_t)RMP_Init_Stack)+(X)*sizeof(rmp_ptr_t))
N/* Tail offset, for descending stacks */
N#define RMP_INIT_STACK_TAIL(X)      (((rmp_ptr_t)RMP_Init_Stack)+RMP_INIT_STACK_SIZE-(X)*sizeof(rmp_ptr_t))
N
N/* Get the thread from delay list */
N#define RMP_DLY2THD(X)              ((struct RMP_Thd*)(((rmp_ptr_t)(X))-sizeof(struct RMP_List)))
N
N/* Printk macros */
N#define RMP_PRINTK_I(INT)           RMP_Print_Int((INT))
N#define RMP_PRINTK_U(UINT)          RMP_Print_Uint((UINT))
N#define RMP_PRINTK_S(STR)           RMP_Print_String((rmp_s8_t*)(STR))
N
N/* Built-in graphics */
N#ifdef RMP_POINT
S#define RMP_TRANS                   (0x01)
S#define RMP_MAT_SMALL               (0)
S#define RMP_MAT_BIG                 (1)
S#define RMP_MAT_BPOS(MAT,POS)       ((MAT)[(POS)>>3]&(1<<(7-((POS)&0x07))))
S#define RMP_MAT_SPOS(MAT,POS)       ((MAT)[(POS)>>3]&(1<<((POS)&0x07)))
S#define RMP_CBOX_CHECK              (1)
S#define RMP_CBTN_DOWN               (1)
S#define RMP_RBTN_SEL                (1)
S#define RMP_PBAR_L2R                (0)
S#define RMP_PBAR_D2U                (1)
S#define RMP_PBAR_R2L                (2)
S#define RMP_PBAR_U2D                (3)
S
S#define RMP_CUR_NORM                (0)
S#define RMP_CUR_BUSY                (1)
S#define RMP_CUR_QUESTION            (2)
S#define RMP_CUR_HAND                (3)
S#define RMP_CUR_TEXT                (4)
S#define RMP_CUR_STOP                (5)
S#define RMP_CUR_MOVE                (6)
S#define RMP_CUR_LR                  (7)
S#define RMP_CUR_UD                  (8)
S#define RMP_CUR_ULBR                (9)
S#define RMP_CUR_URBL                (10)
S#define RMP_CUR_CROSS               (11)
N#endif
N    
N/* Assert macro */
N#define RMP_ASSERT(X) \
Ndo \
N{ \
N    if((X)==0) \
N    { \
N        RMP_PRINTK_S("\r\n***\r\nKernel panic - not syncing:\r\n"); \
N        RMP_PRINTK_S(__FILE__); \
N        RMP_PRINTK_S(" , Line "); \
N        RMP_PRINTK_I(__LINE__); \
N        RMP_PRINTK_S("\r\n"); \
N        RMP_PRINTK_S(__DATE__); \
N        RMP_PRINTK_S(" , "); \
N        RMP_PRINTK_S(__TIME__); \
N        RMP_PRINTK_S("\r\n"); \
N        while(1); \
N    } \
N} \
Nwhile(0)
X#define RMP_ASSERT(X) do {     if((X)==0)     {         RMP_PRINTK_S("\r\n***\r\nKernel panic - not syncing:\r\n");         RMP_PRINTK_S(__FILE__);         RMP_PRINTK_S(" , Line ");         RMP_PRINTK_I(__LINE__);         RMP_PRINTK_S("\r\n");         RMP_PRINTK_S(__DATE__);         RMP_PRINTK_S(" , ");         RMP_PRINTK_S(__TIME__);         RMP_PRINTK_S("\r\n");         while(1);     } } while(0)
N    
N/* Coverage switch - not to be enabled in most cases; user should not touch this */
N/* #define RMP_COVERAGE */
N
N/* Test marker macro */
N#ifdef RMP_COVERAGE
S#define RMP_COVERAGE_LINES          (6144)
S#define RMP_COVERAGE_MARKER() \
Sdo \
S{ \
S    RMP_Coverage[__LINE__]++; \
S    RMP_Coverage[0]=RMP_Coverage[__LINE__]; \
S} \
Swhile(0)
X#define RMP_COVERAGE_MARKER() do {     RMP_Coverage[__LINE__]++;     RMP_Coverage[0]=RMP_Coverage[__LINE__]; } while(0)
N#else
N#define RMP_COVERAGE_MARKER() \
Ndo \
N{ \
N    \
N} \
Nwhile(0)
X#define RMP_COVERAGE_MARKER() do {     } while(0)
N#endif
N/*****************************************************************************/
N/* __RMP_KERNEL_H_DEFS__ */
N#endif
N/* __HDR_DEFS__ */
N#endif
N/* End Defines ***************************************************************/
N
N/* Structs *******************************************************************/
N#ifdef __HDR_STRUCTS__
S#ifndef __RMP_KERNEL_H_STRUCTS__
S#define __RMP_KERNEL_H_STRUCTS__
S/* We used structs in the header */
S
S/* Use defines in these headers */
S#define __HDR_DEFS__
S#undef __HDR_DEFS__
S/*****************************************************************************/
S/* The list head structure */
Sstruct RMP_List
S{
S    volatile struct RMP_List* Prev;
S    volatile struct RMP_List* Next;
S};
S
S/* Thread structure - 15 words */
Sstruct RMP_Thd
S{
S    /* The head to insert into the status queue */
S    struct RMP_List Run_Head;
S    /* This is exclusively for the timer queue */
S    struct RMP_List Dly_Head;
S    /* The list of threads suspended on it because of sending */
S    struct RMP_List Snd_List;
S    /* The state of this thread */
S    rmp_ptr_t State;
S    /* If it is running, how many timeslices it have */
S    rmp_ptr_t Slices;
S    /* If it is running, how many ticks does it have remaining */
S    rmp_ptr_t Slices_Left;
S    /* What priority it is running at */
S    rmp_ptr_t Prio;
S    /* The timeout time */
S    rmp_ptr_t Timeout;
S    /* The mailbox value */
S    rmp_ptr_t Mailbox;
S    /* The data to send */  
S    rmp_ptr_t Data;
S    /* The stack address */
S    rmp_ptr_t Stack;
S    /* The return value of certain function calls */
S    rmp_ret_t Retval;
S};
S
S/* The semaphore structure */
Sstruct RMP_Sem
S{
S    /* The waiting queue */
S    struct RMP_List Wait_List;
S    /* The state of the semaphore */
S    rmp_ptr_t State;
S    /* The current number of semaphore */
S    rmp_ptr_t Cur_Num;
S};
S
S
S/* The head struct of a memory block */
Sstruct RMP_Mem_Head
S{
S    /* This is what is used in TLSF LUT */
S    struct RMP_List Head;
S    /* Is this block used at the moment? */
S    rmp_ptr_t State;
S    /* The pointer to the tail */
S    volatile struct RMP_Mem_Tail* Tail;
S};
S
S/* The tail struct of a memory block */
Sstruct RMP_Mem_Tail
S{
S    /* This is for tailing the memory */
S    volatile struct RMP_Mem_Head* Head;
S};
S
S/* The memory control header block structure */
Sstruct RMP_Mem
S{
S    /* The number of FLIs in the system */
S    rmp_ptr_t FLI_Num;
S    /* The start address of the actual memory pool */
S    rmp_ptr_t Start;
S    /* The size of this pool, including the header, bitmap and list table */
S    rmp_ptr_t Size;
S    /* The location of the list table itself */
S    struct RMP_List* Table;
S    /* The bitmap - This is actually an array that have an indefinite length, and will
S     * be decided at runtime. Don't fuss if lint says that this can overflow; it is safe. */
S    rmp_ptr_t Bitmap[1];
S};
S/*****************************************************************************/
S/* __RMP_KERNEL_H_STRUCTS__ */
S#endif
S/* __HDR_STRUCTS__ */
N#endif
N/* End Structs ***************************************************************/
N
N/* Private Global Variables **************************************************/
N#if(!(defined __HDR_DEFS__||defined __HDR_STRUCTS__))
X#if(!(1L||0L))
S#ifndef __KERNEL_MEMBERS__
S#define __KERNEL_MEMBERS__
S
S/* In this way we can use the data structures and definitions in the headers */
S#define __HDR_DEFS__
S
S#undef __HDR_DEFS__
S
S#define __HDR_STRUCTS__
S
S#undef __HDR_STRUCTS__
S
S/* If the header is not used in the public mode */
S#ifndef __HDR_PUBLIC_MEMBERS__
S/*****************************************************************************/
S#ifdef RMP_COVERAGE
S/* For coverage use only */
Sstatic volatile rmp_ptr_t RMP_Coverage[RMP_COVERAGE_LINES];
S#endif
S/* The scheduler bitmap */
Sstatic volatile rmp_ptr_t RMP_Bitmap[RMP_BITMAP_SIZE];
Sstatic volatile struct RMP_List RMP_Run[RMP_MAX_PREEMPT_PRIO];
Sstatic volatile struct RMP_List RMP_Delay;
S
S/* Scheduler lock */
Sstatic volatile rmp_ptr_t RMP_Sched_Lock_Cnt;
Sstatic volatile rmp_ptr_t RMP_Sched_Locked;
S/* Scheduler pending */
Sstatic volatile rmp_ptr_t RMP_Sched_Pend;
S/* Timer events pending */
Sstatic volatile rmp_ptr_t RMP_Timer_Pend;
S
S/* Init thread */
Sstatic volatile rmp_ptr_t RMP_Init_Stack[RMP_INIT_STACK_SIZE>>(RMP_WORD_ORDER-3)];
Sstatic volatile struct RMP_Thd RMP_Init_Thd;
S/*****************************************************************************/
S/* End Private Global Variables **********************************************/
S
S/* Private C Function Prototypes *********************************************/ 
S/*****************************************************************************/
Sstatic void _RMP_Set_Rdy(volatile struct RMP_Thd* Thread);
Sstatic void _RMP_Clr_Rdy(volatile struct RMP_Thd* Thread);
Sstatic void _RMP_Dly_Ins(volatile struct RMP_Thd* Thread, rmp_ptr_t Slices);
Sstatic void _RMP_Timer_Proc(void);
Sstatic void _RMP_Mem_Block(volatile struct RMP_Mem_Head* Addr, rmp_ptr_t Size);
Sstatic void _RMP_Mem_Ins(volatile void* Pool, volatile struct RMP_Mem_Head* Mem_Head);
Sstatic void _RMP_Mem_Del(volatile void* Pool, volatile struct RMP_Mem_Head* Mem_Head);
Sstatic rmp_ret_t _RMP_Mem_Search(volatile void* Pool, rmp_ptr_t Size, rmp_cnt_t* FLI_Level, rmp_cnt_t* SLI_Level);
S
S#ifdef RMP_CTL_WHITE
S#ifdef RMP_CTL_LGREY
S#ifdef RMP_CTL_GREY
S#ifdef RMP_CTL_DGREY
S#ifdef RMP_CTL_DARK
S#ifdef RMP_CTL_DDARK
S#ifdef RMP_CTL_BLACK
Sstatic void RMP_Radiobtn_Circle(rmp_cnt_t Coord_X,rmp_cnt_t Coord_Y,rmp_cnt_t Length);
Sstatic void RMP_Progbar_Prog(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width,
S                             rmp_cnt_t Style, rmp_cnt_t Prog, rmp_ptr_t Fore, rmp_ptr_t Back);
S#endif
S#endif
S#endif
S#endif
S#endif
S#endif
S#endif
S/*****************************************************************************/
S#define __EXTERN__
S/* End Private C Function Prototypes *****************************************/
S
S/* Public Global Variables ***************************************************/
S/* __HDR_PUBLIC_MEMBERS__ */
S#else
S#define __EXTERN__ EXTERN 
S/* __HDR_PUBLIC_MEMBERS__ */
S#endif
S
S/*****************************************************************************/
S/* The current tick counter value - can be read by the application to determine their time */
S__EXTERN__ volatile rmp_ptr_t RMP_Tick;
S/* The current thread - the pointer itself is volatile but not its contents */
S__EXTERN__ struct RMP_Thd* volatile RMP_Cur_Thd;
S__EXTERN__ volatile rmp_ptr_t RMP_Cur_SP;
S/*****************************************************************************/
S
S/* End Public Global Variables ***********************************************/
S
S/* Public C Function Prototypes **********************************************/
S/*****************************************************************************/
S/* This is the entry of user applications */
SEXTERN void RMP_Init(void);
S__EXTERN__ void _RMP_Get_High_Rdy(void);
S__EXTERN__ void _RMP_Tick_Handler(rmp_ptr_t Ticks);
S__EXTERN__ rmp_ptr_t _RMP_Get_Near_Ticks(void);
S__EXTERN__ void RMP_Clear(volatile void* Addr, rmp_ptr_t Size);
S
S/* Some helpers */
S__EXTERN__ rmp_ptr_t RMP_RBIT_Get(rmp_ptr_t Val);
S__EXTERN__ rmp_ptr_t RMP_LSB_Get(rmp_ptr_t Val);
S
S/* Scheduler locking & unlocking */
S__EXTERN__ void RMP_Lock_Sched(void);
S__EXTERN__ void RMP_Unlock_Sched(void);
S
S/* Debug printing functions */
S__EXTERN__ rmp_cnt_t RMP_Print_Int(rmp_cnt_t Int);
S__EXTERN__ rmp_cnt_t RMP_Print_Uint(rmp_ptr_t Uint);
S__EXTERN__ rmp_cnt_t RMP_Print_String(rmp_s8_t* String);
S
S/* List operation functions */
S__EXTERN__ void RMP_List_Crt(volatile struct RMP_List* Head);
S__EXTERN__ void RMP_List_Del(volatile struct RMP_List* Prev,volatile struct RMP_List* Next);
S__EXTERN__ void RMP_List_Ins(volatile struct RMP_List* New,
S                             volatile struct RMP_List* Prev,
S                             volatile struct RMP_List* Next);
S
S/* System interfaces */
S__EXTERN__ void RMP_Yield(void);
S__EXTERN__ rmp_ret_t RMP_Thd_Crt(volatile struct RMP_Thd* Thread, 
S                             void* Entry, void* Stack, void* Arg, 
S                             rmp_ptr_t Prio, rmp_ptr_t Slices);
S__EXTERN__ rmp_ret_t RMP_Thd_Del(volatile struct RMP_Thd* Thread);
S__EXTERN__ rmp_ret_t RMP_Thd_Set(volatile struct RMP_Thd* Thread, rmp_ptr_t Prio, rmp_ptr_t Slices);
S__EXTERN__ rmp_ret_t RMP_Thd_Suspend(volatile struct RMP_Thd* Thread);
S__EXTERN__ rmp_ret_t RMP_Thd_Resume(volatile struct RMP_Thd* Thread);
S
S__EXTERN__ rmp_ret_t RMP_Thd_Delay(rmp_ptr_t Slices);
S__EXTERN__ rmp_ret_t RMP_Thd_Cancel(volatile struct RMP_Thd* Thread);
S
S__EXTERN__ rmp_ret_t RMP_Thd_Snd(volatile struct RMP_Thd* Thread, rmp_ptr_t Data, rmp_ptr_t Slices);
S__EXTERN__ rmp_ret_t RMP_Thd_Snd_ISR(volatile struct RMP_Thd* Thread, rmp_ptr_t Data);
S__EXTERN__ rmp_ret_t RMP_Thd_Rcv(rmp_ptr_t* Data, rmp_ptr_t Slices);
S
S__EXTERN__ rmp_ret_t RMP_Sem_Crt(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Number);
S__EXTERN__ rmp_ret_t RMP_Sem_Del(volatile struct RMP_Sem* Semaphore);
S__EXTERN__ rmp_ret_t RMP_Sem_Pend(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Slices);
S__EXTERN__ rmp_ret_t RMP_Sem_Abort(volatile struct RMP_Thd* Thread);
S__EXTERN__ rmp_ret_t RMP_Sem_Post(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Number);
S__EXTERN__ rmp_ret_t RMP_Sem_Post_ISR(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Number);
S                             
S/* Memory interfaces */
S__EXTERN__ rmp_ret_t RMP_Mem_Init(volatile void* Pool, rmp_ptr_t Size);
S__EXTERN__ void* RMP_Malloc(volatile void* Pool, rmp_ptr_t Size);
S__EXTERN__ void RMP_Free(volatile void* Pool, void* Mem_Ptr);
S__EXTERN__ void* RMP_Realloc(volatile void* Pool, void* Mem_Ptr, rmp_ptr_t Size);
S
S/* Built-in graphics */
S#ifdef RMP_POINT
SEXTERN void RMP_POINT(rmp_cnt_t,rmp_cnt_t,rmp_ptr_t);
S__EXTERN__ void RMP_Line(rmp_cnt_t Start_X, rmp_cnt_t Start_Y, rmp_cnt_t End_X, rmp_cnt_t End_Y, rmp_ptr_t Color);
S__EXTERN__ void RMP_Dot_Line(rmp_cnt_t Start_X, rmp_cnt_t Start_Y, rmp_cnt_t End_X,rmp_cnt_t End_Y, rmp_ptr_t Dot, rmp_ptr_t Space);
S__EXTERN__ void RMP_Rectangle(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width, rmp_ptr_t Border, rmp_ptr_t Fill);
S__EXTERN__ void RMP_Round_Rect(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y,
S                               rmp_cnt_t Length, rmp_cnt_t Width, rmp_cnt_t Round, rmp_ptr_t Color);
S__EXTERN__ void RMP_Circle(rmp_cnt_t Center_X, rmp_cnt_t Center_Y, rmp_cnt_t Radius, rmp_ptr_t Border, rmp_ptr_t Fill);
S__EXTERN__ void RMP_Matrix(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, const rmp_u8_t* Matrix,
S                           rmp_cnt_t Bit_Order, rmp_cnt_t Length, rmp_cnt_t Width, rmp_ptr_t Color);
S/* This is only exported when color mixing macros available */
S#ifdef RMP_COLOR_25P
S#ifdef RMP_COLOR_50P
S#ifdef RMP_COLOR_75P
S__EXTERN__ void RMP_Matrix_AA(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, const rmp_u8_t* Matrix,
S                              rmp_cnt_t Bit_Order, rmp_cnt_t Length, rmp_cnt_t Width, rmp_ptr_t Color, rmp_ptr_t Back);
S#endif
S#endif
S#endif
S/* These are only provided when all used colors are predefined */
S#ifdef RMP_CTL_WHITE
S#ifdef RMP_CTL_LGREY
S#ifdef RMP_CTL_GREY
S#ifdef RMP_CTL_DGREY
S#ifdef RMP_CTL_DARK
S#ifdef RMP_CTL_DDARK
S#ifdef RMP_CTL_BLACK
S/* Built-in easy controls */
S__EXTERN__ void RMP_Cursor(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_ptr_t Style);
S__EXTERN__ void RMP_Checkbox_Set(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length);
S__EXTERN__ void RMP_Checkbox_Clr(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length);
S__EXTERN__ void RMP_Checkbox(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_ptr_t Status);
S
S__EXTERN__ void RMP_Cmdbtn_Down(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width);
S__EXTERN__ void RMP_Cmdbtn_Up(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width);
S__EXTERN__ void RMP_Cmdbtn(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width, rmp_ptr_t Status);
S
S__EXTERN__ void RMP_Lineedit_Clr(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length,
S                                 rmp_cnt_t Width, rmp_cnt_t Clr_X, rmp_cnt_t Clr_Len);
S__EXTERN__ void RMP_Lineedit(rmp_cnt_t Coord_X,rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width);
S
S__EXTERN__ void RMP_Radiobtn_Set(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length);
S__EXTERN__ void RMP_Radiobtn_Clr(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length);
S__EXTERN__ void RMP_Radiobtn(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_ptr_t Status);
S
S__EXTERN__ void RMP_Progbar_Set(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width,
S                                rmp_cnt_t Style, rmp_cnt_t Old_Prog, rmp_cnt_t New_Prog, rmp_ptr_t Fore, rmp_ptr_t Back);
S__EXTERN__ void RMP_Progbar(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width,
S                            rmp_cnt_t Style, rmp_cnt_t Prog, rmp_ptr_t Fore, rmp_ptr_t Back);
S#endif
S#endif
S#endif
S#endif
S#endif
S#endif
S#endif
S#endif
S
S/* Other utilities */
S#ifdef __RMP_U8_T__
S#ifdef __RMP_U16_T__
S__EXTERN__ rmp_ptr_t RMP_CRC16(const rmp_u8_t* Data, rmp_ptr_t Length);
S#endif
S#endif
S
S/* Hook functions */
S#if(RMP_USE_HOOKS==RMP_TRUE)
S    EXTERN void RMP_Start_Hook(void);
S    EXTERN void RMP_Save_Ctx(void);
S    EXTERN void RMP_Load_Ctx(void);
S    EXTERN void RMP_Sched_Hook(void);
S    EXTERN void RMP_Tick_Hook(rmp_ptr_t Ticks);
S#else
S    __EXTERN__ void RMP_Save_Ctx(void);
S    __EXTERN__ void RMP_Load_Ctx(void);
S#endif
S
SEXTERN void RMP_Init_Hook(void);
SEXTERN void RMP_Init_Idle(void);
S
S/* Coverage test */
S#ifdef RMP_COVERAGE
S__EXTERN__ void RMP_Print_Coverage(void);
S#endif
S/*****************************************************************************/
S/* Undefine "__EXTERN__" to avoid redefinition */
S#undef __EXTERN__
S/* __KERNEL_MEMBERS__ */
S#endif
S/* !(defined __HDR_DEFS__||defined __HDR_STRUCTS__) */
N#endif
N/* End Public C Function Prototypes ******************************************/
N
N/* End Of File ***************************************************************/
N
N/* Copyright (C) Evo-Devo Instrum. All rights reserved ***********************/
L 18 "..\..\MProkaron\Kernel\rmp_kernel.c" 2
N#undef __HDR_DEFS__
N
N#define __HDR_STRUCTS__
N#include "Platform/rmp_platform.h"
L 1 "..\..\MProkaron\Include\Platform/rmp_platform.h" 1
N/******************************************************************************
NFilename    : rmp_platform.h
NAuthor      : pry 
NDate        : 22/07/2017
NLicence     : LGPL v3+; see COPYING for details.
NDescription : The platform specific types for RMP.
N******************************************************************************/
N
N/* Platform Includes *********************************************************/
N#include "Platform/CortexM/rmp_platform_cmx.h"
L 1 "..\..\MProkaron\Include\Platform/CortexM/rmp_platform_cmx.h" 1
N/******************************************************************************
NFilename    : rmp_platform_cmx.h
NAuthor      : pry
NDate        : 01/04/2017
NLicence     : LGPL v3+; see COPYING for details.
NDescription : The header of "rmp_platform_cmx.c".
N******************************************************************************/
N
N/* Defines *******************************************************************/
N#ifdef __HDR_DEFS__
S#ifndef __RMP_PLATFORM_CMX_H_DEFS__
S#define __RMP_PLATFORM_CMX_H_DEFS__
S/*****************************************************************************/
S/* Basic Types ***************************************************************/
S#ifndef __RMP_S32_T__
S#define __RMP_S32_T__
Stypedef signed int rmp_s32_t;
S#endif
S
S#ifndef __RMP_S16_T__
S#define __RMP_S16_T__
Stypedef signed short rmp_s16_t;
S#endif
S
S#ifndef __RMP_S8_T__
S#define __RMP_S8_T__
Stypedef signed char rmp_s8_t;
S#endif
S
S#ifndef __RMP_U32_T__
S#define __RMP_U32_T__
Stypedef unsigned int rmp_u32_t;
S#endif
S
S#ifndef __RMP_U16_T__
S#define __RMP_U16_T__
Stypedef unsigned short rmp_u16_t;
S#endif
S
S#ifndef __RMP_U8_T__
S#define __RMP_U8_T__
Stypedef unsigned char rmp_u8_t;
S#endif
S/* End Basic Types ***********************************************************/
S
S/* Begin Extended Types ******************************************************/
S#ifndef __RMP_PTR_T__
S#define __RMP_PTR_T__
S/* The typedef for the pointers - This is the raw style. Pointers must be unsigned */
Stypedef rmp_u32_t rmp_ptr_t;
S#endif
S
S#ifndef __RMP_CNT_T__
S#define __RMP_CNT_T__
S/* The typedef for the count variables */
Stypedef rmp_s32_t rmp_cnt_t;
S#endif
S
S#ifndef __RMP_RET_T__
S#define __RMP_RET_T__
S/* The type for process return value */
Stypedef rmp_s32_t rmp_ret_t;
S#endif
S/* End Extended Types ********************************************************/
S
S/* System macros *************************************************************/
S/* Compiler "extern" keyword setting */
S#define EXTERN                   extern
S/* The order of bits in one CPU machine word */
S#define RMP_WORD_ORDER           5
S/* The maximum length of char printing - no need to change this in most cases */
S#define RMP_KERNEL_DEBUG_MAX_STR 255
S/* The offset of the stack when initializing */
S#define RMP_INIT_STACK           RMP_INIT_STACK_TAIL(17)
S
S/* The CPU and application specific macros are here */
S#include "rmp_platform_cmx_conf.h"
S/* End System macros *********************************************************/
S
S/* Cortex-M specific macros **************************************************/
S/* MPU operation flag */
S#define RMP_CMX_MPU_CLR                 (0)
S#define RMP_CMX_MPU_UPD                 (1)
S/* MPU definitions */
S/* Extract address for/from MPU */
S#define RMP_CMX_MPU_ADDR(X)             ((X)&0xFFFFFFE0)
S/* Get info from MPU */
S#define RMP_CMX_MPU_SZORD(X)            ((((X)&0x3F)>>1)-2)
S/* Write info to MPU */
S#define RMP_CMX_MPU_VALID               (1<<4)
S#define RMP_CMX_MPU_SRDCLR              (0x0000FF00)
S#define RMP_CMX_MPU_XN                  (1<<28)
S#define RMP_CMX_MPU_RO                  (2<<24)
S#define RMP_CMX_MPU_RW                  (3<<24)
S#define RMP_CMX_MPU_CACHEABLE           (1<<17)
S#define RMP_CMX_MPU_BUFFERABLE          (1<<16)
S#define RMP_CMX_MPU_REGIONSIZE(X)       ((X+2)<<1)
S#define RMP_CMX_MPU_SZENABLE            (1)
S/* Cortex-M (ARMv8) EXC_RETURN values */
S#define RMP_CMX_EXC_RET_BASE            (0xFFFFFF80)
S/* Whether we are returning to secure stack. 1 means yes, 0 means no */
S#define RMP_CMX_EXC_RET_SECURE_STACK    (1<<6)
S/* Whether the callee registers are automatically pushed to user stack. 1 means yes, 0 means no */
S#define RMP_CMX_EXC_RET_CALLEE_SAVE     (1<<5)
S/* Whether the stack frame is standard(contains no FPU data). 1 means yes, 0 means no */
S#define RMP_CMX_EXC_RET_STD_FRAME       (1<<4)
S/* Are we returning to user mode? 1 means yes, 0 means no */
S#define RMP_CMX_EXC_RET_RET_USER        (1<<3)
S/* Are we returning to PSP? 1 means yes, 0 means no */
S#define RMP_CMX_EXC_RET_RET_PSP         (1<<2)
S/* Is this interrupt taken to a secured domain? 1 means yes, 0 means no */
S#define RMP_CMX_EXC_INT_SECURE_DOMAIN   (1<<0)
S/* FPU type definitions */
S#define RMP_CMX_FPU_NONE                (0)
S#define RMP_CMX_FPU_VFPV4               (1)
S#define RMP_CMX_FPU_FPV5_SP             (2)
S#define RMP_CMX_FPU_FPV5_DP             (3)
S
S/* Some useful SCB definitions */
S#define RMP_CMX_SHCSR_USGFAULTENA       (1<<18)
S#define RMP_CMX_SHCSR_BUSFAULTENA       (1<<17)
S#define RMP_CMX_SHCSR_MEMFAULTENA       (1<<16)
S/* MPU definitions */
S#define RMP_CMX_MPU_PRIVDEF             0x00000004
S/* NVIC definitions */
S#define RMP_CMX_NVIC_GROUPING_P7S1      0
S#define RMP_CMX_NVIC_GROUPING_P6S2      1
S#define RMP_CMX_NVIC_GROUPING_P5S3      2
S#define RMP_CMX_NVIC_GROUPING_P4S4      3
S#define RMP_CMX_NVIC_GROUPING_P3S5      4
S#define RMP_CMX_NVIC_GROUPING_P2S6      5
S#define RMP_CMX_NVIC_GROUPING_P1S7      6
S#define RMP_CMX_NVIC_GROUPING_P0S8      7
S/* Fault definitions */
S/* The NMI is active */
S#define RMP_CMX_ICSR_NMIPENDSET         (((rmp_ptr_t)1)<<31)
S/* Debug event has occurred. The Debug Fault Status Register has been updated */
S#define RMP_CMX_HFSR_DEBUGEVT           (((rmp_ptr_t)1)<<31)
S/* Processor has escalated a configurable-priority exception to HardFault */
S#define RMP_CMX_HFSR_FORCED             (1<<30)
S/* Vector table read fault has occurred */
S#define RMP_CMX_HFSR_VECTTBL            (1<<1)
S/* Divide by zero */
S#define RMP_CMX_UFSR_DIVBYZERO          (1<<25)
S/* Unaligned load/store access */
S#define RMP_CMX_UFSR_UNALIGNED          (1<<24)
S/* No such coprocessor */
S#define RMP_CMX_UFSR_NOCP               (1<<19)
S/* Invalid vector return LR or PC value */
S#define RMP_CMX_UFSR_INVPC              (1<<18)
S/* Invalid IT instruction or related instructions */
S#define RMP_CMX_UFSR_INVSTATE           (1<<17)
S/* Invalid IT instruction or related instructions */
S#define RMP_CMX_UFSR_UNDEFINSTR         (1<<16)
S/* The Bus Fault Address Register is valid */
S#define RMP_CMX_BFSR_BFARVALID          (1<<15)
S/* The bus fault happened during FP lazy stacking */
S#define RMP_CMX_BFSR_LSPERR             (1<<13)
S/* A derived bus fault has occurred on exception entry */
S#define RMP_CMX_BFSR_STKERR             (1<<12)
S/* A derived bus fault has occurred on exception return */
S#define RMP_CMX_BFSR_UNSTKERR           (1<<11)
S/* Imprecise data access error has occurred */
S#define RMP_CMX_BFSR_IMPRECISERR        (1<<10)
S/* A precise data access error has occurred, and the processor 
S * has written the faulting address to the BFAR */
S#define RMP_CMX_BFSR_PRECISERR          (1<<9)
S/* A bus fault on an instruction prefetch has occurred. The 
S * fault is signaled only if the instruction is issued */
S#define RMP_CMX_BFSR_IBUSERR            (1<<8)
S/* The Memory Mnagement Fault Address Register have valid contents */
S#define RMP_CMX_MFSR_MMARVALID          (1<<7)
S/* A MemManage fault occurred during FP lazy state preservation */
S#define RMP_CMX_MFSR_MLSPERR            (1<<5)
S/* A derived MemManage fault occurred on exception entry */
S#define RMP_CMX_MFSR_MSTKERR            (1<<4)
S/* A derived MemManage fault occurred on exception return */
S#define RMP_CMX_MFSR_MUNSTKERR          (1<<3)
S/* Data access violation. The MMFAR shows the data address that
S * the load or store tried to access */
S#define RMP_CMX_MFSR_DACCVIOL           (1<<1)
S/* MPU or Execute Never (XN) default memory map access violation on an
S * instruction fetch has occurred. The fault is signalled only if the
S * instruction is issued */
S#define RMP_CMX_MFSR_IACCVIOL           (1<<0)
S
S/* These faults cannot be recovered and will lead to termination immediately */
S#define RMP_CMX_FAULT_FATAL             (RMP_CMX_UFSR_DIVBYZERO|RMP_CMX_UFSR_UNALIGNED| \
S                                         RMP_CMX_UFSR_NOCP|RMP_CMX_UFSR_INVPC| \
S                                         RMP_CMX_UFSR_INVSTATE|RMP_CMX_UFSR_UNDEFINSTR| \
S                                         RMP_CMX_BFSR_LSPERR|RMP_CMX_BFSR_STKERR| \
S                                         RMP_CMX_BFSR_UNSTKERR|RMP_CMX_BFSR_IMPRECISERR| \
S                                         RMP_CMX_BFSR_PRECISERR|RMP_CMX_BFSR_IBUSERR)
X#define RMP_CMX_FAULT_FATAL             (RMP_CMX_UFSR_DIVBYZERO|RMP_CMX_UFSR_UNALIGNED|                                          RMP_CMX_UFSR_NOCP|RMP_CMX_UFSR_INVPC|                                          RMP_CMX_UFSR_INVSTATE|RMP_CMX_UFSR_UNDEFINSTR|                                          RMP_CMX_BFSR_LSPERR|RMP_CMX_BFSR_STKERR|                                          RMP_CMX_BFSR_UNSTKERR|RMP_CMX_BFSR_IMPRECISERR|                                          RMP_CMX_BFSR_PRECISERR|RMP_CMX_BFSR_IBUSERR)
S/*****************************************************************************/
S/* __RMP_PLATFORM_CMX_H_DEFS__ */
S#endif
S/* __HDR_DEFS__ */
N#endif
N/* End Defines ***************************************************************/
N
N/* Structs *******************************************************************/
N#ifdef __HDR_STRUCTS__
N#ifndef __RMP_PLATFORM_CMX_H_STRUCTS__
N#define __RMP_PLATFORM_CMX_H_STRUCTS__
N/* We used structs in the header */
N
N/* Use defines in these headers */
N#define __HDR_DEFS__
N#undef __HDR_DEFS__
N/*****************************************************************************/
N
N/*****************************************************************************/
N/* __RMP_PLATFORM_CMX_H_STRUCTS__ */
N#endif
N/* __HDR_STRUCTS__ */
N#endif
N/* End Structs ***************************************************************/
N
N/* Private Global Variables **************************************************/
N#if(!(defined __HDR_DEFS__||defined __HDR_STRUCTS__))
X#if(!(0L||1L))
S#ifndef __RMP_PLATFORM_CMX_MEMBERS__
S#define __RMP_PLATFORM_CMX_MEMBERS__
S
S/* In this way we can use the data structures and definitions in the headers */
S#define __HDR_DEFS__
S
S#undef __HDR_DEFS__
S
S#define __HDR_STRUCTS__
S
S#undef __HDR_STRUCTS__
S
S/* If the header is not used in the public mode */
S#ifndef __HDR_PUBLIC_MEMBERS__
S/*****************************************************************************/
S
S/*****************************************************************************/
S/* End Private Global Variables **********************************************/
S
S/* Private C Function Prototypes *********************************************/ 
S/*****************************************************************************/
S
S/*****************************************************************************/
S#define __EXTERN__
S/* End Private C Function Prototypes *****************************************/
S
S/* Public Global Variables ***************************************************/
S/* __HDR_PUBLIC_MEMBERS__ */
S#else
S#define __EXTERN__ EXTERN 
S/* __HDR_PUBLIC_MEMBERS__ */
S#endif
S
S/*****************************************************************************/
S
S/*****************************************************************************/
S
S/* End Public Global Variables ***********************************************/
S
S/* Public C Function Prototypes **********************************************/
S/*****************************************************************************/
S/* Interrupts */
SEXTERN void RMP_Disable_Int(void);
SEXTERN void RMP_Enable_Int(void);
SEXTERN void RMP_Mask_Int(rmp_ptr_t Level);
S
SEXTERN rmp_ptr_t RMP_MSB_Get(rmp_ptr_t Val);
SEXTERN void _RMP_Start(rmp_ptr_t Entry, rmp_ptr_t Stack);
SEXTERN void _RMP_Yield(void);
S
S/* Initialization */
S__EXTERN__ void _RMP_Stack_Init(rmp_ptr_t Entry, rmp_ptr_t Stack, rmp_ptr_t Arg);
S__EXTERN__ void _RMP_Low_Level_Init(void);
S__EXTERN__ void RMP_Putchar(char Char);
S__EXTERN__ void _RMP_Plat_Hook(void);
S/*****************************************************************************/
S/* Undefine "__EXTERN__" to avoid redefinition */
S#undef __EXTERN__
S/* __RMP_PLATFORM_CMX_MEMBERS__ */
S#endif
S/* !(defined __HDR_DEFS__||defined __HDR_STRUCTS__) */
N#endif
N/* End Public C Function Prototypes ******************************************/
N
N/* End Of File ***************************************************************/
N
N/* Copyright (C) Evo-Devo Instrum. All rights reserved ***********************/
L 11 "..\..\MProkaron\Include\Platform/rmp_platform.h" 2
N/* End Platform Includes *****************************************************/
N
N/* End Of File ***************************************************************/
N
N/* Copyright (C) Evo-Devo Instrum. All rights reserved ***********************/
L 22 "..\..\MProkaron\Kernel\rmp_kernel.c" 2
N#include "Kernel/rmp_kernel.h"
L 1 "..\..\MProkaron\Include\Kernel/rmp_kernel.h" 1
N/******************************************************************************
NFilename    : rmp_kernel.h
NAuthor      : pry
NDate        : 01/04/2017
NLicence     : LGPL v3+; see COPYING for details.
NDescription : The header file for the kernel.
N******************************************************************************/
N
N/* Defines *******************************************************************/
N#ifdef __HDR_DEFS__
S#ifndef __RMP_KERNEL_H_DEFS__
S#define __RMP_KERNEL_H_DEFS__
S/*****************************************************************************/
S/* Constants */
S#define RMP_TRUE                    1
S#define RMP_FALSE                   0
S/* States of threads */
S#define RMP_THD_STATE(X)            ((X)&0xFF)
S#define RMP_THD_FLAG(X)             ((X)&~0xFF)
S#define RMP_THD_STATE_SET(X,S)      ((X)=(RMP_THD_FLAG(X)|(S)))
S
S/* Memory pool position lookup */
S#define RMP_MEM_POS(FLI,SLI)        ((SLI)+((FLI)<<3))
S
S/* This thread is currently unused */
S#define RMP_THD_FREE                (0)
S/* This thread is currently running */
S#define RMP_THD_RUNNING             (1)
S/* Blocked on a send endpoint */
S#define RMP_THD_SNDBLK              (2)
S/* Blocked on a send endpoint with a timeout */
S#define RMP_THD_SNDDLY              (3)
S/* Blocked on its own receive endpoint */
S#define RMP_THD_RCVBLK              (4)
S/* Blocked on its own receive endpoint with a timeout */
S#define RMP_THD_RCVDLY              (5)
S/* Just on the timer delay */
S#define RMP_THD_DELAYED             (6)
S/* Blocked on a semaphore */
S#define RMP_THD_SEMBLK              (7)
S/* Blocked on a semaphore with a timeout */
S#define RMP_THD_SEMDLY              (8)
S/* Suspended */
S#define RMP_THD_SUSPENDED           (1<<8)
S/* Mailbox valid */
S#define RMP_THD_MBOXFUL             (RMP_THD_SUSPENDED<<1)
S    
S/* States of semaphores */
S#define RMP_SEM_FREE                (0)
S#define RMP_SEM_USED                (1)
S
S/* States of memory blocks */
S#define RMP_MEM_FREE                (0)
S#define RMP_MEM_USED                (1)
S
S/* Error codes */
S/* This error is thread related */
S#define RMP_ERR_THD                 (-1)
S/* This error is priority related */
S#define RMP_ERR_PRIO                (-2)
S/* This error is timeslice related */
S#define RMP_ERR_SLICE               (-3)
S/* This error is thread state related */
S#define RMP_ERR_STATE               (-4)
S/* This error is operation related */
S#define RMP_ERR_OPER                (-5)
S/* This error is semaphore related */
S#define RMP_ERR_SEM                 (-6)
S/* This error is memory related */
S#define RMP_ERR_MEM                 (-7)
S
S/* Power and rounding */
S#define RMP_POW2(POW)               (((rmp_ptr_t)1)<<(POW))
S#define RMP_ROUND_DOWN(NUM,POW)     (((NUM)>>(POW))<<(POW))
S#define RMP_ROUND_UP(NUM,POW)       RMP_ROUND_DOWN((NUM)+RMP_POW2(POW)-1,POW)
S
S/* Word sizes settings */
S#define RMP_ALLBITS                 ((rmp_ptr_t)(-1))
S#define RMP_WORD_SIZE               RMP_POW2(RMP_WORD_ORDER)
S#define RMP_WORD_MASK               (~(RMP_ALLBITS<<RMP_WORD_ORDER))
S#define RMP_ALIGN_ORDER             (RMP_WORD_ORDER-3)
S#define RMP_ALIGN_MASK              (~(RMP_ALLBITS<<RMP_ALIGN_ORDER))
S#define RMP_BITMAP_SIZE             ((RMP_MAX_PREEMPT_PRIO-1)/RMP_WORD_SIZE+1)
S
S/* Stack offset macros */
S/* Head offset, for ascending stacks */
S#define RMP_INIT_STACK_HEAD(X)      (((rmp_ptr_t)RMP_Init_Stack)+(X)*sizeof(rmp_ptr_t))
S/* Tail offset, for descending stacks */
S#define RMP_INIT_STACK_TAIL(X)      (((rmp_ptr_t)RMP_Init_Stack)+RMP_INIT_STACK_SIZE-(X)*sizeof(rmp_ptr_t))
S
S/* Get the thread from delay list */
S#define RMP_DLY2THD(X)              ((struct RMP_Thd*)(((rmp_ptr_t)(X))-sizeof(struct RMP_List)))
S
S/* Printk macros */
S#define RMP_PRINTK_I(INT)           RMP_Print_Int((INT))
S#define RMP_PRINTK_U(UINT)          RMP_Print_Uint((UINT))
S#define RMP_PRINTK_S(STR)           RMP_Print_String((rmp_s8_t*)(STR))
S
S/* Built-in graphics */
S#ifdef RMP_POINT
S#define RMP_TRANS                   (0x01)
S#define RMP_MAT_SMALL               (0)
S#define RMP_MAT_BIG                 (1)
S#define RMP_MAT_BPOS(MAT,POS)       ((MAT)[(POS)>>3]&(1<<(7-((POS)&0x07))))
S#define RMP_MAT_SPOS(MAT,POS)       ((MAT)[(POS)>>3]&(1<<((POS)&0x07)))
S#define RMP_CBOX_CHECK              (1)
S#define RMP_CBTN_DOWN               (1)
S#define RMP_RBTN_SEL                (1)
S#define RMP_PBAR_L2R                (0)
S#define RMP_PBAR_D2U                (1)
S#define RMP_PBAR_R2L                (2)
S#define RMP_PBAR_U2D                (3)
S
S#define RMP_CUR_NORM                (0)
S#define RMP_CUR_BUSY                (1)
S#define RMP_CUR_QUESTION            (2)
S#define RMP_CUR_HAND                (3)
S#define RMP_CUR_TEXT                (4)
S#define RMP_CUR_STOP                (5)
S#define RMP_CUR_MOVE                (6)
S#define RMP_CUR_LR                  (7)
S#define RMP_CUR_UD                  (8)
S#define RMP_CUR_ULBR                (9)
S#define RMP_CUR_URBL                (10)
S#define RMP_CUR_CROSS               (11)
S#endif
S    
S/* Assert macro */
S#define RMP_ASSERT(X) \
Sdo \
S{ \
S    if((X)==0) \
S    { \
S        RMP_PRINTK_S("\r\n***\r\nKernel panic - not syncing:\r\n"); \
S        RMP_PRINTK_S(__FILE__); \
S        RMP_PRINTK_S(" , Line "); \
S        RMP_PRINTK_I(__LINE__); \
S        RMP_PRINTK_S("\r\n"); \
S        RMP_PRINTK_S(__DATE__); \
S        RMP_PRINTK_S(" , "); \
S        RMP_PRINTK_S(__TIME__); \
S        RMP_PRINTK_S("\r\n"); \
S        while(1); \
S    } \
S} \
Swhile(0)
X#define RMP_ASSERT(X) do {     if((X)==0)     {         RMP_PRINTK_S("\r\n***\r\nKernel panic - not syncing:\r\n");         RMP_PRINTK_S(__FILE__);         RMP_PRINTK_S(" , Line ");         RMP_PRINTK_I(__LINE__);         RMP_PRINTK_S("\r\n");         RMP_PRINTK_S(__DATE__);         RMP_PRINTK_S(" , ");         RMP_PRINTK_S(__TIME__);         RMP_PRINTK_S("\r\n");         while(1);     } } while(0)
S    
S/* Coverage switch - not to be enabled in most cases; user should not touch this */
S/* #define RMP_COVERAGE */
S
S/* Test marker macro */
S#ifdef RMP_COVERAGE
S#define RMP_COVERAGE_LINES          (6144)
S#define RMP_COVERAGE_MARKER() \
Sdo \
S{ \
S    RMP_Coverage[__LINE__]++; \
S    RMP_Coverage[0]=RMP_Coverage[__LINE__]; \
S} \
Swhile(0)
X#define RMP_COVERAGE_MARKER() do {     RMP_Coverage[__LINE__]++;     RMP_Coverage[0]=RMP_Coverage[__LINE__]; } while(0)
S#else
S#define RMP_COVERAGE_MARKER() \
Sdo \
S{ \
S    \
S} \
Swhile(0)
X#define RMP_COVERAGE_MARKER() do {     } while(0)
S#endif
S/*****************************************************************************/
S/* __RMP_KERNEL_H_DEFS__ */
S#endif
S/* __HDR_DEFS__ */
N#endif
N/* End Defines ***************************************************************/
N
N/* Structs *******************************************************************/
N#ifdef __HDR_STRUCTS__
N#ifndef __RMP_KERNEL_H_STRUCTS__
N#define __RMP_KERNEL_H_STRUCTS__
N/* We used structs in the header */
N
N/* Use defines in these headers */
N#define __HDR_DEFS__
N#undef __HDR_DEFS__
N/*****************************************************************************/
N/* The list head structure */
Nstruct RMP_List
N{
N    volatile struct RMP_List* Prev;
N    volatile struct RMP_List* Next;
N};
N
N/* Thread structure - 15 words */
Nstruct RMP_Thd
N{
N    /* The head to insert into the status queue */
N    struct RMP_List Run_Head;
N    /* This is exclusively for the timer queue */
N    struct RMP_List Dly_Head;
N    /* The list of threads suspended on it because of sending */
N    struct RMP_List Snd_List;
N    /* The state of this thread */
N    rmp_ptr_t State;
N    /* If it is running, how many timeslices it have */
N    rmp_ptr_t Slices;
N    /* If it is running, how many ticks does it have remaining */
N    rmp_ptr_t Slices_Left;
N    /* What priority it is running at */
N    rmp_ptr_t Prio;
N    /* The timeout time */
N    rmp_ptr_t Timeout;
N    /* The mailbox value */
N    rmp_ptr_t Mailbox;
N    /* The data to send */  
N    rmp_ptr_t Data;
N    /* The stack address */
N    rmp_ptr_t Stack;
N    /* The return value of certain function calls */
N    rmp_ret_t Retval;
N};
N
N/* The semaphore structure */
Nstruct RMP_Sem
N{
N    /* The waiting queue */
N    struct RMP_List Wait_List;
N    /* The state of the semaphore */
N    rmp_ptr_t State;
N    /* The current number of semaphore */
N    rmp_ptr_t Cur_Num;
N};
N
N
N/* The head struct of a memory block */
Nstruct RMP_Mem_Head
N{
N    /* This is what is used in TLSF LUT */
N    struct RMP_List Head;
N    /* Is this block used at the moment? */
N    rmp_ptr_t State;
N    /* The pointer to the tail */
N    volatile struct RMP_Mem_Tail* Tail;
N};
N
N/* The tail struct of a memory block */
Nstruct RMP_Mem_Tail
N{
N    /* This is for tailing the memory */
N    volatile struct RMP_Mem_Head* Head;
N};
N
N/* The memory control header block structure */
Nstruct RMP_Mem
N{
N    /* The number of FLIs in the system */
N    rmp_ptr_t FLI_Num;
N    /* The start address of the actual memory pool */
N    rmp_ptr_t Start;
N    /* The size of this pool, including the header, bitmap and list table */
N    rmp_ptr_t Size;
N    /* The location of the list table itself */
N    struct RMP_List* Table;
N    /* The bitmap - This is actually an array that have an indefinite length, and will
N     * be decided at runtime. Don't fuss if lint says that this can overflow; it is safe. */
N    rmp_ptr_t Bitmap[1];
N};
N/*****************************************************************************/
N/* __RMP_KERNEL_H_STRUCTS__ */
N#endif
N/* __HDR_STRUCTS__ */
N#endif
N/* End Structs ***************************************************************/
N
N/* Private Global Variables **************************************************/
N#if(!(defined __HDR_DEFS__||defined __HDR_STRUCTS__))
X#if(!(0L||1L))
S#ifndef __KERNEL_MEMBERS__
S#define __KERNEL_MEMBERS__
S
S/* In this way we can use the data structures and definitions in the headers */
S#define __HDR_DEFS__
S
S#undef __HDR_DEFS__
S
S#define __HDR_STRUCTS__
S
S#undef __HDR_STRUCTS__
S
S/* If the header is not used in the public mode */
S#ifndef __HDR_PUBLIC_MEMBERS__
S/*****************************************************************************/
S#ifdef RMP_COVERAGE
S/* For coverage use only */
Sstatic volatile rmp_ptr_t RMP_Coverage[RMP_COVERAGE_LINES];
S#endif
S/* The scheduler bitmap */
Sstatic volatile rmp_ptr_t RMP_Bitmap[RMP_BITMAP_SIZE];
Sstatic volatile struct RMP_List RMP_Run[RMP_MAX_PREEMPT_PRIO];
Sstatic volatile struct RMP_List RMP_Delay;
S
S/* Scheduler lock */
Sstatic volatile rmp_ptr_t RMP_Sched_Lock_Cnt;
Sstatic volatile rmp_ptr_t RMP_Sched_Locked;
S/* Scheduler pending */
Sstatic volatile rmp_ptr_t RMP_Sched_Pend;
S/* Timer events pending */
Sstatic volatile rmp_ptr_t RMP_Timer_Pend;
S
S/* Init thread */
Sstatic volatile rmp_ptr_t RMP_Init_Stack[RMP_INIT_STACK_SIZE>>(RMP_WORD_ORDER-3)];
Sstatic volatile struct RMP_Thd RMP_Init_Thd;
S/*****************************************************************************/
S/* End Private Global Variables **********************************************/
S
S/* Private C Function Prototypes *********************************************/ 
S/*****************************************************************************/
Sstatic void _RMP_Set_Rdy(volatile struct RMP_Thd* Thread);
Sstatic void _RMP_Clr_Rdy(volatile struct RMP_Thd* Thread);
Sstatic void _RMP_Dly_Ins(volatile struct RMP_Thd* Thread, rmp_ptr_t Slices);
Sstatic void _RMP_Timer_Proc(void);
Sstatic void _RMP_Mem_Block(volatile struct RMP_Mem_Head* Addr, rmp_ptr_t Size);
Sstatic void _RMP_Mem_Ins(volatile void* Pool, volatile struct RMP_Mem_Head* Mem_Head);
Sstatic void _RMP_Mem_Del(volatile void* Pool, volatile struct RMP_Mem_Head* Mem_Head);
Sstatic rmp_ret_t _RMP_Mem_Search(volatile void* Pool, rmp_ptr_t Size, rmp_cnt_t* FLI_Level, rmp_cnt_t* SLI_Level);
S
S#ifdef RMP_CTL_WHITE
S#ifdef RMP_CTL_LGREY
S#ifdef RMP_CTL_GREY
S#ifdef RMP_CTL_DGREY
S#ifdef RMP_CTL_DARK
S#ifdef RMP_CTL_DDARK
S#ifdef RMP_CTL_BLACK
Sstatic void RMP_Radiobtn_Circle(rmp_cnt_t Coord_X,rmp_cnt_t Coord_Y,rmp_cnt_t Length);
Sstatic void RMP_Progbar_Prog(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width,
S                             rmp_cnt_t Style, rmp_cnt_t Prog, rmp_ptr_t Fore, rmp_ptr_t Back);
S#endif
S#endif
S#endif
S#endif
S#endif
S#endif
S#endif
S/*****************************************************************************/
S#define __EXTERN__
S/* End Private C Function Prototypes *****************************************/
S
S/* Public Global Variables ***************************************************/
S/* __HDR_PUBLIC_MEMBERS__ */
S#else
S#define __EXTERN__ EXTERN 
S/* __HDR_PUBLIC_MEMBERS__ */
S#endif
S
S/*****************************************************************************/
S/* The current tick counter value - can be read by the application to determine their time */
S__EXTERN__ volatile rmp_ptr_t RMP_Tick;
S/* The current thread - the pointer itself is volatile but not its contents */
S__EXTERN__ struct RMP_Thd* volatile RMP_Cur_Thd;
S__EXTERN__ volatile rmp_ptr_t RMP_Cur_SP;
S/*****************************************************************************/
S
S/* End Public Global Variables ***********************************************/
S
S/* Public C Function Prototypes **********************************************/
S/*****************************************************************************/
S/* This is the entry of user applications */
SEXTERN void RMP_Init(void);
S__EXTERN__ void _RMP_Get_High_Rdy(void);
S__EXTERN__ void _RMP_Tick_Handler(rmp_ptr_t Ticks);
S__EXTERN__ rmp_ptr_t _RMP_Get_Near_Ticks(void);
S__EXTERN__ void RMP_Clear(volatile void* Addr, rmp_ptr_t Size);
S
S/* Some helpers */
S__EXTERN__ rmp_ptr_t RMP_RBIT_Get(rmp_ptr_t Val);
S__EXTERN__ rmp_ptr_t RMP_LSB_Get(rmp_ptr_t Val);
S
S/* Scheduler locking & unlocking */
S__EXTERN__ void RMP_Lock_Sched(void);
S__EXTERN__ void RMP_Unlock_Sched(void);
S
S/* Debug printing functions */
S__EXTERN__ rmp_cnt_t RMP_Print_Int(rmp_cnt_t Int);
S__EXTERN__ rmp_cnt_t RMP_Print_Uint(rmp_ptr_t Uint);
S__EXTERN__ rmp_cnt_t RMP_Print_String(rmp_s8_t* String);
S
S/* List operation functions */
S__EXTERN__ void RMP_List_Crt(volatile struct RMP_List* Head);
S__EXTERN__ void RMP_List_Del(volatile struct RMP_List* Prev,volatile struct RMP_List* Next);
S__EXTERN__ void RMP_List_Ins(volatile struct RMP_List* New,
S                             volatile struct RMP_List* Prev,
S                             volatile struct RMP_List* Next);
S
S/* System interfaces */
S__EXTERN__ void RMP_Yield(void);
S__EXTERN__ rmp_ret_t RMP_Thd_Crt(volatile struct RMP_Thd* Thread, 
S                             void* Entry, void* Stack, void* Arg, 
S                             rmp_ptr_t Prio, rmp_ptr_t Slices);
S__EXTERN__ rmp_ret_t RMP_Thd_Del(volatile struct RMP_Thd* Thread);
S__EXTERN__ rmp_ret_t RMP_Thd_Set(volatile struct RMP_Thd* Thread, rmp_ptr_t Prio, rmp_ptr_t Slices);
S__EXTERN__ rmp_ret_t RMP_Thd_Suspend(volatile struct RMP_Thd* Thread);
S__EXTERN__ rmp_ret_t RMP_Thd_Resume(volatile struct RMP_Thd* Thread);
S
S__EXTERN__ rmp_ret_t RMP_Thd_Delay(rmp_ptr_t Slices);
S__EXTERN__ rmp_ret_t RMP_Thd_Cancel(volatile struct RMP_Thd* Thread);
S
S__EXTERN__ rmp_ret_t RMP_Thd_Snd(volatile struct RMP_Thd* Thread, rmp_ptr_t Data, rmp_ptr_t Slices);
S__EXTERN__ rmp_ret_t RMP_Thd_Snd_ISR(volatile struct RMP_Thd* Thread, rmp_ptr_t Data);
S__EXTERN__ rmp_ret_t RMP_Thd_Rcv(rmp_ptr_t* Data, rmp_ptr_t Slices);
S
S__EXTERN__ rmp_ret_t RMP_Sem_Crt(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Number);
S__EXTERN__ rmp_ret_t RMP_Sem_Del(volatile struct RMP_Sem* Semaphore);
S__EXTERN__ rmp_ret_t RMP_Sem_Pend(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Slices);
S__EXTERN__ rmp_ret_t RMP_Sem_Abort(volatile struct RMP_Thd* Thread);
S__EXTERN__ rmp_ret_t RMP_Sem_Post(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Number);
S__EXTERN__ rmp_ret_t RMP_Sem_Post_ISR(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Number);
S                             
S/* Memory interfaces */
S__EXTERN__ rmp_ret_t RMP_Mem_Init(volatile void* Pool, rmp_ptr_t Size);
S__EXTERN__ void* RMP_Malloc(volatile void* Pool, rmp_ptr_t Size);
S__EXTERN__ void RMP_Free(volatile void* Pool, void* Mem_Ptr);
S__EXTERN__ void* RMP_Realloc(volatile void* Pool, void* Mem_Ptr, rmp_ptr_t Size);
S
S/* Built-in graphics */
S#ifdef RMP_POINT
SEXTERN void RMP_POINT(rmp_cnt_t,rmp_cnt_t,rmp_ptr_t);
S__EXTERN__ void RMP_Line(rmp_cnt_t Start_X, rmp_cnt_t Start_Y, rmp_cnt_t End_X, rmp_cnt_t End_Y, rmp_ptr_t Color);
S__EXTERN__ void RMP_Dot_Line(rmp_cnt_t Start_X, rmp_cnt_t Start_Y, rmp_cnt_t End_X,rmp_cnt_t End_Y, rmp_ptr_t Dot, rmp_ptr_t Space);
S__EXTERN__ void RMP_Rectangle(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width, rmp_ptr_t Border, rmp_ptr_t Fill);
S__EXTERN__ void RMP_Round_Rect(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y,
S                               rmp_cnt_t Length, rmp_cnt_t Width, rmp_cnt_t Round, rmp_ptr_t Color);
S__EXTERN__ void RMP_Circle(rmp_cnt_t Center_X, rmp_cnt_t Center_Y, rmp_cnt_t Radius, rmp_ptr_t Border, rmp_ptr_t Fill);
S__EXTERN__ void RMP_Matrix(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, const rmp_u8_t* Matrix,
S                           rmp_cnt_t Bit_Order, rmp_cnt_t Length, rmp_cnt_t Width, rmp_ptr_t Color);
S/* This is only exported when color mixing macros available */
S#ifdef RMP_COLOR_25P
S#ifdef RMP_COLOR_50P
S#ifdef RMP_COLOR_75P
S__EXTERN__ void RMP_Matrix_AA(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, const rmp_u8_t* Matrix,
S                              rmp_cnt_t Bit_Order, rmp_cnt_t Length, rmp_cnt_t Width, rmp_ptr_t Color, rmp_ptr_t Back);
S#endif
S#endif
S#endif
S/* These are only provided when all used colors are predefined */
S#ifdef RMP_CTL_WHITE
S#ifdef RMP_CTL_LGREY
S#ifdef RMP_CTL_GREY
S#ifdef RMP_CTL_DGREY
S#ifdef RMP_CTL_DARK
S#ifdef RMP_CTL_DDARK
S#ifdef RMP_CTL_BLACK
S/* Built-in easy controls */
S__EXTERN__ void RMP_Cursor(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_ptr_t Style);
S__EXTERN__ void RMP_Checkbox_Set(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length);
S__EXTERN__ void RMP_Checkbox_Clr(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length);
S__EXTERN__ void RMP_Checkbox(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_ptr_t Status);
S
S__EXTERN__ void RMP_Cmdbtn_Down(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width);
S__EXTERN__ void RMP_Cmdbtn_Up(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width);
S__EXTERN__ void RMP_Cmdbtn(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width, rmp_ptr_t Status);
S
S__EXTERN__ void RMP_Lineedit_Clr(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length,
S                                 rmp_cnt_t Width, rmp_cnt_t Clr_X, rmp_cnt_t Clr_Len);
S__EXTERN__ void RMP_Lineedit(rmp_cnt_t Coord_X,rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width);
S
S__EXTERN__ void RMP_Radiobtn_Set(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length);
S__EXTERN__ void RMP_Radiobtn_Clr(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length);
S__EXTERN__ void RMP_Radiobtn(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_ptr_t Status);
S
S__EXTERN__ void RMP_Progbar_Set(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width,
S                                rmp_cnt_t Style, rmp_cnt_t Old_Prog, rmp_cnt_t New_Prog, rmp_ptr_t Fore, rmp_ptr_t Back);
S__EXTERN__ void RMP_Progbar(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width,
S                            rmp_cnt_t Style, rmp_cnt_t Prog, rmp_ptr_t Fore, rmp_ptr_t Back);
S#endif
S#endif
S#endif
S#endif
S#endif
S#endif
S#endif
S#endif
S
S/* Other utilities */
S#ifdef __RMP_U8_T__
S#ifdef __RMP_U16_T__
S__EXTERN__ rmp_ptr_t RMP_CRC16(const rmp_u8_t* Data, rmp_ptr_t Length);
S#endif
S#endif
S
S/* Hook functions */
S#if(RMP_USE_HOOKS==RMP_TRUE)
S    EXTERN void RMP_Start_Hook(void);
S    EXTERN void RMP_Save_Ctx(void);
S    EXTERN void RMP_Load_Ctx(void);
S    EXTERN void RMP_Sched_Hook(void);
S    EXTERN void RMP_Tick_Hook(rmp_ptr_t Ticks);
S#else
S    __EXTERN__ void RMP_Save_Ctx(void);
S    __EXTERN__ void RMP_Load_Ctx(void);
S#endif
S
SEXTERN void RMP_Init_Hook(void);
SEXTERN void RMP_Init_Idle(void);
S
S/* Coverage test */
S#ifdef RMP_COVERAGE
S__EXTERN__ void RMP_Print_Coverage(void);
S#endif
S/*****************************************************************************/
S/* Undefine "__EXTERN__" to avoid redefinition */
S#undef __EXTERN__
S/* __KERNEL_MEMBERS__ */
S#endif
S/* !(defined __HDR_DEFS__||defined __HDR_STRUCTS__) */
N#endif
N/* End Public C Function Prototypes ******************************************/
N
N/* End Of File ***************************************************************/
N
N/* Copyright (C) Evo-Devo Instrum. All rights reserved ***********************/
L 23 "..\..\MProkaron\Kernel\rmp_kernel.c" 2
N#undef __HDR_STRUCTS__
N
N/* Private include */
N#include "Kernel/rmp_kernel.h"
L 1 "..\..\MProkaron\Include\Kernel/rmp_kernel.h" 1
N/******************************************************************************
NFilename    : rmp_kernel.h
NAuthor      : pry
NDate        : 01/04/2017
NLicence     : LGPL v3+; see COPYING for details.
NDescription : The header file for the kernel.
N******************************************************************************/
N
N/* Defines *******************************************************************/
N#ifdef __HDR_DEFS__
S#ifndef __RMP_KERNEL_H_DEFS__
S#define __RMP_KERNEL_H_DEFS__
S/*****************************************************************************/
S/* Constants */
S#define RMP_TRUE                    1
S#define RMP_FALSE                   0
S/* States of threads */
S#define RMP_THD_STATE(X)            ((X)&0xFF)
S#define RMP_THD_FLAG(X)             ((X)&~0xFF)
S#define RMP_THD_STATE_SET(X,S)      ((X)=(RMP_THD_FLAG(X)|(S)))
S
S/* Memory pool position lookup */
S#define RMP_MEM_POS(FLI,SLI)        ((SLI)+((FLI)<<3))
S
S/* This thread is currently unused */
S#define RMP_THD_FREE                (0)
S/* This thread is currently running */
S#define RMP_THD_RUNNING             (1)
S/* Blocked on a send endpoint */
S#define RMP_THD_SNDBLK              (2)
S/* Blocked on a send endpoint with a timeout */
S#define RMP_THD_SNDDLY              (3)
S/* Blocked on its own receive endpoint */
S#define RMP_THD_RCVBLK              (4)
S/* Blocked on its own receive endpoint with a timeout */
S#define RMP_THD_RCVDLY              (5)
S/* Just on the timer delay */
S#define RMP_THD_DELAYED             (6)
S/* Blocked on a semaphore */
S#define RMP_THD_SEMBLK              (7)
S/* Blocked on a semaphore with a timeout */
S#define RMP_THD_SEMDLY              (8)
S/* Suspended */
S#define RMP_THD_SUSPENDED           (1<<8)
S/* Mailbox valid */
S#define RMP_THD_MBOXFUL             (RMP_THD_SUSPENDED<<1)
S    
S/* States of semaphores */
S#define RMP_SEM_FREE                (0)
S#define RMP_SEM_USED                (1)
S
S/* States of memory blocks */
S#define RMP_MEM_FREE                (0)
S#define RMP_MEM_USED                (1)
S
S/* Error codes */
S/* This error is thread related */
S#define RMP_ERR_THD                 (-1)
S/* This error is priority related */
S#define RMP_ERR_PRIO                (-2)
S/* This error is timeslice related */
S#define RMP_ERR_SLICE               (-3)
S/* This error is thread state related */
S#define RMP_ERR_STATE               (-4)
S/* This error is operation related */
S#define RMP_ERR_OPER                (-5)
S/* This error is semaphore related */
S#define RMP_ERR_SEM                 (-6)
S/* This error is memory related */
S#define RMP_ERR_MEM                 (-7)
S
S/* Power and rounding */
S#define RMP_POW2(POW)               (((rmp_ptr_t)1)<<(POW))
S#define RMP_ROUND_DOWN(NUM,POW)     (((NUM)>>(POW))<<(POW))
S#define RMP_ROUND_UP(NUM,POW)       RMP_ROUND_DOWN((NUM)+RMP_POW2(POW)-1,POW)
S
S/* Word sizes settings */
S#define RMP_ALLBITS                 ((rmp_ptr_t)(-1))
S#define RMP_WORD_SIZE               RMP_POW2(RMP_WORD_ORDER)
S#define RMP_WORD_MASK               (~(RMP_ALLBITS<<RMP_WORD_ORDER))
S#define RMP_ALIGN_ORDER             (RMP_WORD_ORDER-3)
S#define RMP_ALIGN_MASK              (~(RMP_ALLBITS<<RMP_ALIGN_ORDER))
S#define RMP_BITMAP_SIZE             ((RMP_MAX_PREEMPT_PRIO-1)/RMP_WORD_SIZE+1)
S
S/* Stack offset macros */
S/* Head offset, for ascending stacks */
S#define RMP_INIT_STACK_HEAD(X)      (((rmp_ptr_t)RMP_Init_Stack)+(X)*sizeof(rmp_ptr_t))
S/* Tail offset, for descending stacks */
S#define RMP_INIT_STACK_TAIL(X)      (((rmp_ptr_t)RMP_Init_Stack)+RMP_INIT_STACK_SIZE-(X)*sizeof(rmp_ptr_t))
S
S/* Get the thread from delay list */
S#define RMP_DLY2THD(X)              ((struct RMP_Thd*)(((rmp_ptr_t)(X))-sizeof(struct RMP_List)))
S
S/* Printk macros */
S#define RMP_PRINTK_I(INT)           RMP_Print_Int((INT))
S#define RMP_PRINTK_U(UINT)          RMP_Print_Uint((UINT))
S#define RMP_PRINTK_S(STR)           RMP_Print_String((rmp_s8_t*)(STR))
S
S/* Built-in graphics */
S#ifdef RMP_POINT
S#define RMP_TRANS                   (0x01)
S#define RMP_MAT_SMALL               (0)
S#define RMP_MAT_BIG                 (1)
S#define RMP_MAT_BPOS(MAT,POS)       ((MAT)[(POS)>>3]&(1<<(7-((POS)&0x07))))
S#define RMP_MAT_SPOS(MAT,POS)       ((MAT)[(POS)>>3]&(1<<((POS)&0x07)))
S#define RMP_CBOX_CHECK              (1)
S#define RMP_CBTN_DOWN               (1)
S#define RMP_RBTN_SEL                (1)
S#define RMP_PBAR_L2R                (0)
S#define RMP_PBAR_D2U                (1)
S#define RMP_PBAR_R2L                (2)
S#define RMP_PBAR_U2D                (3)
S
S#define RMP_CUR_NORM                (0)
S#define RMP_CUR_BUSY                (1)
S#define RMP_CUR_QUESTION            (2)
S#define RMP_CUR_HAND                (3)
S#define RMP_CUR_TEXT                (4)
S#define RMP_CUR_STOP                (5)
S#define RMP_CUR_MOVE                (6)
S#define RMP_CUR_LR                  (7)
S#define RMP_CUR_UD                  (8)
S#define RMP_CUR_ULBR                (9)
S#define RMP_CUR_URBL                (10)
S#define RMP_CUR_CROSS               (11)
S#endif
S    
S/* Assert macro */
S#define RMP_ASSERT(X) \
Sdo \
S{ \
S    if((X)==0) \
S    { \
S        RMP_PRINTK_S("\r\n***\r\nKernel panic - not syncing:\r\n"); \
S        RMP_PRINTK_S(__FILE__); \
S        RMP_PRINTK_S(" , Line "); \
S        RMP_PRINTK_I(__LINE__); \
S        RMP_PRINTK_S("\r\n"); \
S        RMP_PRINTK_S(__DATE__); \
S        RMP_PRINTK_S(" , "); \
S        RMP_PRINTK_S(__TIME__); \
S        RMP_PRINTK_S("\r\n"); \
S        while(1); \
S    } \
S} \
Swhile(0)
X#define RMP_ASSERT(X) do {     if((X)==0)     {         RMP_PRINTK_S("\r\n***\r\nKernel panic - not syncing:\r\n");         RMP_PRINTK_S(__FILE__);         RMP_PRINTK_S(" , Line ");         RMP_PRINTK_I(__LINE__);         RMP_PRINTK_S("\r\n");         RMP_PRINTK_S(__DATE__);         RMP_PRINTK_S(" , ");         RMP_PRINTK_S(__TIME__);         RMP_PRINTK_S("\r\n");         while(1);     } } while(0)
S    
S/* Coverage switch - not to be enabled in most cases; user should not touch this */
S/* #define RMP_COVERAGE */
S
S/* Test marker macro */
S#ifdef RMP_COVERAGE
S#define RMP_COVERAGE_LINES          (6144)
S#define RMP_COVERAGE_MARKER() \
Sdo \
S{ \
S    RMP_Coverage[__LINE__]++; \
S    RMP_Coverage[0]=RMP_Coverage[__LINE__]; \
S} \
Swhile(0)
X#define RMP_COVERAGE_MARKER() do {     RMP_Coverage[__LINE__]++;     RMP_Coverage[0]=RMP_Coverage[__LINE__]; } while(0)
S#else
S#define RMP_COVERAGE_MARKER() \
Sdo \
S{ \
S    \
S} \
Swhile(0)
X#define RMP_COVERAGE_MARKER() do {     } while(0)
S#endif
S/*****************************************************************************/
S/* __RMP_KERNEL_H_DEFS__ */
S#endif
S/* __HDR_DEFS__ */
N#endif
N/* End Defines ***************************************************************/
N
N/* Structs *******************************************************************/
N#ifdef __HDR_STRUCTS__
S#ifndef __RMP_KERNEL_H_STRUCTS__
S#define __RMP_KERNEL_H_STRUCTS__
S/* We used structs in the header */
S
S/* Use defines in these headers */
S#define __HDR_DEFS__
S#undef __HDR_DEFS__
S/*****************************************************************************/
S/* The list head structure */
Sstruct RMP_List
S{
S    volatile struct RMP_List* Prev;
S    volatile struct RMP_List* Next;
S};
S
S/* Thread structure - 15 words */
Sstruct RMP_Thd
S{
S    /* The head to insert into the status queue */
S    struct RMP_List Run_Head;
S    /* This is exclusively for the timer queue */
S    struct RMP_List Dly_Head;
S    /* The list of threads suspended on it because of sending */
S    struct RMP_List Snd_List;
S    /* The state of this thread */
S    rmp_ptr_t State;
S    /* If it is running, how many timeslices it have */
S    rmp_ptr_t Slices;
S    /* If it is running, how many ticks does it have remaining */
S    rmp_ptr_t Slices_Left;
S    /* What priority it is running at */
S    rmp_ptr_t Prio;
S    /* The timeout time */
S    rmp_ptr_t Timeout;
S    /* The mailbox value */
S    rmp_ptr_t Mailbox;
S    /* The data to send */  
S    rmp_ptr_t Data;
S    /* The stack address */
S    rmp_ptr_t Stack;
S    /* The return value of certain function calls */
S    rmp_ret_t Retval;
S};
S
S/* The semaphore structure */
Sstruct RMP_Sem
S{
S    /* The waiting queue */
S    struct RMP_List Wait_List;
S    /* The state of the semaphore */
S    rmp_ptr_t State;
S    /* The current number of semaphore */
S    rmp_ptr_t Cur_Num;
S};
S
S
S/* The head struct of a memory block */
Sstruct RMP_Mem_Head
S{
S    /* This is what is used in TLSF LUT */
S    struct RMP_List Head;
S    /* Is this block used at the moment? */
S    rmp_ptr_t State;
S    /* The pointer to the tail */
S    volatile struct RMP_Mem_Tail* Tail;
S};
S
S/* The tail struct of a memory block */
Sstruct RMP_Mem_Tail
S{
S    /* This is for tailing the memory */
S    volatile struct RMP_Mem_Head* Head;
S};
S
S/* The memory control header block structure */
Sstruct RMP_Mem
S{
S    /* The number of FLIs in the system */
S    rmp_ptr_t FLI_Num;
S    /* The start address of the actual memory pool */
S    rmp_ptr_t Start;
S    /* The size of this pool, including the header, bitmap and list table */
S    rmp_ptr_t Size;
S    /* The location of the list table itself */
S    struct RMP_List* Table;
S    /* The bitmap - This is actually an array that have an indefinite length, and will
S     * be decided at runtime. Don't fuss if lint says that this can overflow; it is safe. */
S    rmp_ptr_t Bitmap[1];
S};
S/*****************************************************************************/
S/* __RMP_KERNEL_H_STRUCTS__ */
S#endif
S/* __HDR_STRUCTS__ */
N#endif
N/* End Structs ***************************************************************/
N
N/* Private Global Variables **************************************************/
N#if(!(defined __HDR_DEFS__||defined __HDR_STRUCTS__))
X#if(!(0L||0L))
N#ifndef __KERNEL_MEMBERS__
N#define __KERNEL_MEMBERS__
N
N/* In this way we can use the data structures and definitions in the headers */
N#define __HDR_DEFS__
N
N#undef __HDR_DEFS__
N
N#define __HDR_STRUCTS__
N
N#undef __HDR_STRUCTS__
N
N/* If the header is not used in the public mode */
N#ifndef __HDR_PUBLIC_MEMBERS__
N/*****************************************************************************/
N#ifdef RMP_COVERAGE
S/* For coverage use only */
Sstatic volatile rmp_ptr_t RMP_Coverage[RMP_COVERAGE_LINES];
N#endif
N/* The scheduler bitmap */
Nstatic volatile rmp_ptr_t RMP_Bitmap[RMP_BITMAP_SIZE];
Xstatic volatile rmp_ptr_t RMP_Bitmap[((32-1)/(((rmp_ptr_t)1)<<(5))+1)];
Nstatic volatile struct RMP_List RMP_Run[RMP_MAX_PREEMPT_PRIO];
Xstatic volatile struct RMP_List RMP_Run[32];
Nstatic volatile struct RMP_List RMP_Delay;
N
N/* Scheduler lock */
Nstatic volatile rmp_ptr_t RMP_Sched_Lock_Cnt;
Nstatic volatile rmp_ptr_t RMP_Sched_Locked;
N/* Scheduler pending */
Nstatic volatile rmp_ptr_t RMP_Sched_Pend;
N/* Timer events pending */
Nstatic volatile rmp_ptr_t RMP_Timer_Pend;
N
N/* Init thread */
Nstatic volatile rmp_ptr_t RMP_Init_Stack[RMP_INIT_STACK_SIZE>>(RMP_WORD_ORDER-3)];
Xstatic volatile rmp_ptr_t RMP_Init_Stack[256>>(5-3)];
Nstatic volatile struct RMP_Thd RMP_Init_Thd;
N/*****************************************************************************/
N/* End Private Global Variables **********************************************/
N
N/* Private C Function Prototypes *********************************************/ 
N/*****************************************************************************/
Nstatic void _RMP_Set_Rdy(volatile struct RMP_Thd* Thread);
Nstatic void _RMP_Clr_Rdy(volatile struct RMP_Thd* Thread);
Nstatic void _RMP_Dly_Ins(volatile struct RMP_Thd* Thread, rmp_ptr_t Slices);
Nstatic void _RMP_Timer_Proc(void);
Nstatic void _RMP_Mem_Block(volatile struct RMP_Mem_Head* Addr, rmp_ptr_t Size);
Nstatic void _RMP_Mem_Ins(volatile void* Pool, volatile struct RMP_Mem_Head* Mem_Head);
Nstatic void _RMP_Mem_Del(volatile void* Pool, volatile struct RMP_Mem_Head* Mem_Head);
Nstatic rmp_ret_t _RMP_Mem_Search(volatile void* Pool, rmp_ptr_t Size, rmp_cnt_t* FLI_Level, rmp_cnt_t* SLI_Level);
N
N#ifdef RMP_CTL_WHITE
S#ifdef RMP_CTL_LGREY
S#ifdef RMP_CTL_GREY
S#ifdef RMP_CTL_DGREY
S#ifdef RMP_CTL_DARK
S#ifdef RMP_CTL_DDARK
S#ifdef RMP_CTL_BLACK
Sstatic void RMP_Radiobtn_Circle(rmp_cnt_t Coord_X,rmp_cnt_t Coord_Y,rmp_cnt_t Length);
Sstatic void RMP_Progbar_Prog(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width,
S                             rmp_cnt_t Style, rmp_cnt_t Prog, rmp_ptr_t Fore, rmp_ptr_t Back);
S#endif
S#endif
S#endif
S#endif
S#endif
S#endif
N#endif
N/*****************************************************************************/
N#define __EXTERN__
N/* End Private C Function Prototypes *****************************************/
N
N/* Public Global Variables ***************************************************/
N/* __HDR_PUBLIC_MEMBERS__ */
N#else
S#define __EXTERN__ EXTERN 
S/* __HDR_PUBLIC_MEMBERS__ */
N#endif
N
N/*****************************************************************************/
N/* The current tick counter value - can be read by the application to determine their time */
N__EXTERN__ volatile rmp_ptr_t RMP_Tick;
X volatile rmp_ptr_t RMP_Tick;
N/* The current thread - the pointer itself is volatile but not its contents */
N__EXTERN__ struct RMP_Thd* volatile RMP_Cur_Thd;
X struct RMP_Thd* volatile RMP_Cur_Thd;
N__EXTERN__ volatile rmp_ptr_t RMP_Cur_SP;
X volatile rmp_ptr_t RMP_Cur_SP;
N/*****************************************************************************/
N
N/* End Public Global Variables ***********************************************/
N
N/* Public C Function Prototypes **********************************************/
N/*****************************************************************************/
N/* This is the entry of user applications */
NEXTERN void RMP_Init(void);
Xextern void RMP_Init(void);
N__EXTERN__ void _RMP_Get_High_Rdy(void);
X void _RMP_Get_High_Rdy(void);
N__EXTERN__ void _RMP_Tick_Handler(rmp_ptr_t Ticks);
X void _RMP_Tick_Handler(rmp_ptr_t Ticks);
N__EXTERN__ rmp_ptr_t _RMP_Get_Near_Ticks(void);
X rmp_ptr_t _RMP_Get_Near_Ticks(void);
N__EXTERN__ void RMP_Clear(volatile void* Addr, rmp_ptr_t Size);
X void RMP_Clear(volatile void* Addr, rmp_ptr_t Size);
N
N/* Some helpers */
N__EXTERN__ rmp_ptr_t RMP_RBIT_Get(rmp_ptr_t Val);
X rmp_ptr_t RMP_RBIT_Get(rmp_ptr_t Val);
N__EXTERN__ rmp_ptr_t RMP_LSB_Get(rmp_ptr_t Val);
X rmp_ptr_t RMP_LSB_Get(rmp_ptr_t Val);
N
N/* Scheduler locking & unlocking */
N__EXTERN__ void RMP_Lock_Sched(void);
X void RMP_Lock_Sched(void);
N__EXTERN__ void RMP_Unlock_Sched(void);
X void RMP_Unlock_Sched(void);
N
N/* Debug printing functions */
N__EXTERN__ rmp_cnt_t RMP_Print_Int(rmp_cnt_t Int);
X rmp_cnt_t RMP_Print_Int(rmp_cnt_t Int);
N__EXTERN__ rmp_cnt_t RMP_Print_Uint(rmp_ptr_t Uint);
X rmp_cnt_t RMP_Print_Uint(rmp_ptr_t Uint);
N__EXTERN__ rmp_cnt_t RMP_Print_String(rmp_s8_t* String);
X rmp_cnt_t RMP_Print_String(rmp_s8_t* String);
N
N/* List operation functions */
N__EXTERN__ void RMP_List_Crt(volatile struct RMP_List* Head);
X void RMP_List_Crt(volatile struct RMP_List* Head);
N__EXTERN__ void RMP_List_Del(volatile struct RMP_List* Prev,volatile struct RMP_List* Next);
X void RMP_List_Del(volatile struct RMP_List* Prev,volatile struct RMP_List* Next);
N__EXTERN__ void RMP_List_Ins(volatile struct RMP_List* New,
X void RMP_List_Ins(volatile struct RMP_List* New,
N                             volatile struct RMP_List* Prev,
N                             volatile struct RMP_List* Next);
N
N/* System interfaces */
N__EXTERN__ void RMP_Yield(void);
X void RMP_Yield(void);
N__EXTERN__ rmp_ret_t RMP_Thd_Crt(volatile struct RMP_Thd* Thread, 
X rmp_ret_t RMP_Thd_Crt(volatile struct RMP_Thd* Thread, 
N                             void* Entry, void* Stack, void* Arg, 
N                             rmp_ptr_t Prio, rmp_ptr_t Slices);
N__EXTERN__ rmp_ret_t RMP_Thd_Del(volatile struct RMP_Thd* Thread);
X rmp_ret_t RMP_Thd_Del(volatile struct RMP_Thd* Thread);
N__EXTERN__ rmp_ret_t RMP_Thd_Set(volatile struct RMP_Thd* Thread, rmp_ptr_t Prio, rmp_ptr_t Slices);
X rmp_ret_t RMP_Thd_Set(volatile struct RMP_Thd* Thread, rmp_ptr_t Prio, rmp_ptr_t Slices);
N__EXTERN__ rmp_ret_t RMP_Thd_Suspend(volatile struct RMP_Thd* Thread);
X rmp_ret_t RMP_Thd_Suspend(volatile struct RMP_Thd* Thread);
N__EXTERN__ rmp_ret_t RMP_Thd_Resume(volatile struct RMP_Thd* Thread);
X rmp_ret_t RMP_Thd_Resume(volatile struct RMP_Thd* Thread);
N
N__EXTERN__ rmp_ret_t RMP_Thd_Delay(rmp_ptr_t Slices);
X rmp_ret_t RMP_Thd_Delay(rmp_ptr_t Slices);
N__EXTERN__ rmp_ret_t RMP_Thd_Cancel(volatile struct RMP_Thd* Thread);
X rmp_ret_t RMP_Thd_Cancel(volatile struct RMP_Thd* Thread);
N
N__EXTERN__ rmp_ret_t RMP_Thd_Snd(volatile struct RMP_Thd* Thread, rmp_ptr_t Data, rmp_ptr_t Slices);
X rmp_ret_t RMP_Thd_Snd(volatile struct RMP_Thd* Thread, rmp_ptr_t Data, rmp_ptr_t Slices);
N__EXTERN__ rmp_ret_t RMP_Thd_Snd_ISR(volatile struct RMP_Thd* Thread, rmp_ptr_t Data);
X rmp_ret_t RMP_Thd_Snd_ISR(volatile struct RMP_Thd* Thread, rmp_ptr_t Data);
N__EXTERN__ rmp_ret_t RMP_Thd_Rcv(rmp_ptr_t* Data, rmp_ptr_t Slices);
X rmp_ret_t RMP_Thd_Rcv(rmp_ptr_t* Data, rmp_ptr_t Slices);
N
N__EXTERN__ rmp_ret_t RMP_Sem_Crt(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Number);
X rmp_ret_t RMP_Sem_Crt(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Number);
N__EXTERN__ rmp_ret_t RMP_Sem_Del(volatile struct RMP_Sem* Semaphore);
X rmp_ret_t RMP_Sem_Del(volatile struct RMP_Sem* Semaphore);
N__EXTERN__ rmp_ret_t RMP_Sem_Pend(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Slices);
X rmp_ret_t RMP_Sem_Pend(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Slices);
N__EXTERN__ rmp_ret_t RMP_Sem_Abort(volatile struct RMP_Thd* Thread);
X rmp_ret_t RMP_Sem_Abort(volatile struct RMP_Thd* Thread);
N__EXTERN__ rmp_ret_t RMP_Sem_Post(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Number);
X rmp_ret_t RMP_Sem_Post(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Number);
N__EXTERN__ rmp_ret_t RMP_Sem_Post_ISR(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Number);
X rmp_ret_t RMP_Sem_Post_ISR(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Number);
N                             
N/* Memory interfaces */
N__EXTERN__ rmp_ret_t RMP_Mem_Init(volatile void* Pool, rmp_ptr_t Size);
X rmp_ret_t RMP_Mem_Init(volatile void* Pool, rmp_ptr_t Size);
N__EXTERN__ void* RMP_Malloc(volatile void* Pool, rmp_ptr_t Size);
X void* RMP_Malloc(volatile void* Pool, rmp_ptr_t Size);
N__EXTERN__ void RMP_Free(volatile void* Pool, void* Mem_Ptr);
X void RMP_Free(volatile void* Pool, void* Mem_Ptr);
N__EXTERN__ void* RMP_Realloc(volatile void* Pool, void* Mem_Ptr, rmp_ptr_t Size);
X void* RMP_Realloc(volatile void* Pool, void* Mem_Ptr, rmp_ptr_t Size);
N
N/* Built-in graphics */
N#ifdef RMP_POINT
SEXTERN void RMP_POINT(rmp_cnt_t,rmp_cnt_t,rmp_ptr_t);
S__EXTERN__ void RMP_Line(rmp_cnt_t Start_X, rmp_cnt_t Start_Y, rmp_cnt_t End_X, rmp_cnt_t End_Y, rmp_ptr_t Color);
S__EXTERN__ void RMP_Dot_Line(rmp_cnt_t Start_X, rmp_cnt_t Start_Y, rmp_cnt_t End_X,rmp_cnt_t End_Y, rmp_ptr_t Dot, rmp_ptr_t Space);
S__EXTERN__ void RMP_Rectangle(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width, rmp_ptr_t Border, rmp_ptr_t Fill);
S__EXTERN__ void RMP_Round_Rect(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y,
S                               rmp_cnt_t Length, rmp_cnt_t Width, rmp_cnt_t Round, rmp_ptr_t Color);
S__EXTERN__ void RMP_Circle(rmp_cnt_t Center_X, rmp_cnt_t Center_Y, rmp_cnt_t Radius, rmp_ptr_t Border, rmp_ptr_t Fill);
S__EXTERN__ void RMP_Matrix(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, const rmp_u8_t* Matrix,
S                           rmp_cnt_t Bit_Order, rmp_cnt_t Length, rmp_cnt_t Width, rmp_ptr_t Color);
S/* This is only exported when color mixing macros available */
S#ifdef RMP_COLOR_25P
S#ifdef RMP_COLOR_50P
S#ifdef RMP_COLOR_75P
S__EXTERN__ void RMP_Matrix_AA(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, const rmp_u8_t* Matrix,
S                              rmp_cnt_t Bit_Order, rmp_cnt_t Length, rmp_cnt_t Width, rmp_ptr_t Color, rmp_ptr_t Back);
S#endif
S#endif
S#endif
S/* These are only provided when all used colors are predefined */
S#ifdef RMP_CTL_WHITE
S#ifdef RMP_CTL_LGREY
S#ifdef RMP_CTL_GREY
S#ifdef RMP_CTL_DGREY
S#ifdef RMP_CTL_DARK
S#ifdef RMP_CTL_DDARK
S#ifdef RMP_CTL_BLACK
S/* Built-in easy controls */
S__EXTERN__ void RMP_Cursor(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_ptr_t Style);
S__EXTERN__ void RMP_Checkbox_Set(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length);
S__EXTERN__ void RMP_Checkbox_Clr(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length);
S__EXTERN__ void RMP_Checkbox(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_ptr_t Status);
S
S__EXTERN__ void RMP_Cmdbtn_Down(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width);
S__EXTERN__ void RMP_Cmdbtn_Up(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width);
S__EXTERN__ void RMP_Cmdbtn(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width, rmp_ptr_t Status);
S
S__EXTERN__ void RMP_Lineedit_Clr(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length,
S                                 rmp_cnt_t Width, rmp_cnt_t Clr_X, rmp_cnt_t Clr_Len);
S__EXTERN__ void RMP_Lineedit(rmp_cnt_t Coord_X,rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width);
S
S__EXTERN__ void RMP_Radiobtn_Set(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length);
S__EXTERN__ void RMP_Radiobtn_Clr(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length);
S__EXTERN__ void RMP_Radiobtn(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_ptr_t Status);
S
S__EXTERN__ void RMP_Progbar_Set(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width,
S                                rmp_cnt_t Style, rmp_cnt_t Old_Prog, rmp_cnt_t New_Prog, rmp_ptr_t Fore, rmp_ptr_t Back);
S__EXTERN__ void RMP_Progbar(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width,
S                            rmp_cnt_t Style, rmp_cnt_t Prog, rmp_ptr_t Fore, rmp_ptr_t Back);
S#endif
S#endif
S#endif
S#endif
S#endif
S#endif
S#endif
N#endif
N
N/* Other utilities */
N#ifdef __RMP_U8_T__
N#ifdef __RMP_U16_T__
N__EXTERN__ rmp_ptr_t RMP_CRC16(const rmp_u8_t* Data, rmp_ptr_t Length);
X rmp_ptr_t RMP_CRC16(const rmp_u8_t* Data, rmp_ptr_t Length);
N#endif
N#endif
N
N/* Hook functions */
N#if(RMP_USE_HOOKS==RMP_TRUE)
X#if(0==1)
S    EXTERN void RMP_Start_Hook(void);
S    EXTERN void RMP_Save_Ctx(void);
S    EXTERN void RMP_Load_Ctx(void);
S    EXTERN void RMP_Sched_Hook(void);
S    EXTERN void RMP_Tick_Hook(rmp_ptr_t Ticks);
N#else
N    __EXTERN__ void RMP_Save_Ctx(void);
X     void RMP_Save_Ctx(void);
N    __EXTERN__ void RMP_Load_Ctx(void);
X     void RMP_Load_Ctx(void);
N#endif
N
NEXTERN void RMP_Init_Hook(void);
Xextern void RMP_Init_Hook(void);
NEXTERN void RMP_Init_Idle(void);
Xextern void RMP_Init_Idle(void);
N
N/* Coverage test */
N#ifdef RMP_COVERAGE
S__EXTERN__ void RMP_Print_Coverage(void);
N#endif
N/*****************************************************************************/
N/* Undefine "__EXTERN__" to avoid redefinition */
N#undef __EXTERN__
N/* __KERNEL_MEMBERS__ */
N#endif
N/* !(defined __HDR_DEFS__||defined __HDR_STRUCTS__) */
N#endif
N/* End Public C Function Prototypes ******************************************/
N
N/* End Of File ***************************************************************/
N
N/* Copyright (C) Evo-Devo Instrum. All rights reserved ***********************/
L 27 "..\..\MProkaron\Kernel\rmp_kernel.c" 2
N
N#define __HDR_PUBLIC_MEMBERS__
N#include "Platform/rmp_platform.h"
L 1 "..\..\MProkaron\Include\Platform/rmp_platform.h" 1
N/******************************************************************************
NFilename    : rmp_platform.h
NAuthor      : pry 
NDate        : 22/07/2017
NLicence     : LGPL v3+; see COPYING for details.
NDescription : The platform specific types for RMP.
N******************************************************************************/
N
N/* Platform Includes *********************************************************/
N#include "Platform/CortexM/rmp_platform_cmx.h"
L 1 "..\..\MProkaron\Include\Platform/CortexM/rmp_platform_cmx.h" 1
N/******************************************************************************
NFilename    : rmp_platform_cmx.h
NAuthor      : pry
NDate        : 01/04/2017
NLicence     : LGPL v3+; see COPYING for details.
NDescription : The header of "rmp_platform_cmx.c".
N******************************************************************************/
N
N/* Defines *******************************************************************/
N#ifdef __HDR_DEFS__
S#ifndef __RMP_PLATFORM_CMX_H_DEFS__
S#define __RMP_PLATFORM_CMX_H_DEFS__
S/*****************************************************************************/
S/* Basic Types ***************************************************************/
S#ifndef __RMP_S32_T__
S#define __RMP_S32_T__
Stypedef signed int rmp_s32_t;
S#endif
S
S#ifndef __RMP_S16_T__
S#define __RMP_S16_T__
Stypedef signed short rmp_s16_t;
S#endif
S
S#ifndef __RMP_S8_T__
S#define __RMP_S8_T__
Stypedef signed char rmp_s8_t;
S#endif
S
S#ifndef __RMP_U32_T__
S#define __RMP_U32_T__
Stypedef unsigned int rmp_u32_t;
S#endif
S
S#ifndef __RMP_U16_T__
S#define __RMP_U16_T__
Stypedef unsigned short rmp_u16_t;
S#endif
S
S#ifndef __RMP_U8_T__
S#define __RMP_U8_T__
Stypedef unsigned char rmp_u8_t;
S#endif
S/* End Basic Types ***********************************************************/
S
S/* Begin Extended Types ******************************************************/
S#ifndef __RMP_PTR_T__
S#define __RMP_PTR_T__
S/* The typedef for the pointers - This is the raw style. Pointers must be unsigned */
Stypedef rmp_u32_t rmp_ptr_t;
S#endif
S
S#ifndef __RMP_CNT_T__
S#define __RMP_CNT_T__
S/* The typedef for the count variables */
Stypedef rmp_s32_t rmp_cnt_t;
S#endif
S
S#ifndef __RMP_RET_T__
S#define __RMP_RET_T__
S/* The type for process return value */
Stypedef rmp_s32_t rmp_ret_t;
S#endif
S/* End Extended Types ********************************************************/
S
S/* System macros *************************************************************/
S/* Compiler "extern" keyword setting */
S#define EXTERN                   extern
S/* The order of bits in one CPU machine word */
S#define RMP_WORD_ORDER           5
S/* The maximum length of char printing - no need to change this in most cases */
S#define RMP_KERNEL_DEBUG_MAX_STR 255
S/* The offset of the stack when initializing */
S#define RMP_INIT_STACK           RMP_INIT_STACK_TAIL(17)
S
S/* The CPU and application specific macros are here */
S#include "rmp_platform_cmx_conf.h"
S/* End System macros *********************************************************/
S
S/* Cortex-M specific macros **************************************************/
S/* MPU operation flag */
S#define RMP_CMX_MPU_CLR                 (0)
S#define RMP_CMX_MPU_UPD                 (1)
S/* MPU definitions */
S/* Extract address for/from MPU */
S#define RMP_CMX_MPU_ADDR(X)             ((X)&0xFFFFFFE0)
S/* Get info from MPU */
S#define RMP_CMX_MPU_SZORD(X)            ((((X)&0x3F)>>1)-2)
S/* Write info to MPU */
S#define RMP_CMX_MPU_VALID               (1<<4)
S#define RMP_CMX_MPU_SRDCLR              (0x0000FF00)
S#define RMP_CMX_MPU_XN                  (1<<28)
S#define RMP_CMX_MPU_RO                  (2<<24)
S#define RMP_CMX_MPU_RW                  (3<<24)
S#define RMP_CMX_MPU_CACHEABLE           (1<<17)
S#define RMP_CMX_MPU_BUFFERABLE          (1<<16)
S#define RMP_CMX_MPU_REGIONSIZE(X)       ((X+2)<<1)
S#define RMP_CMX_MPU_SZENABLE            (1)
S/* Cortex-M (ARMv8) EXC_RETURN values */
S#define RMP_CMX_EXC_RET_BASE            (0xFFFFFF80)
S/* Whether we are returning to secure stack. 1 means yes, 0 means no */
S#define RMP_CMX_EXC_RET_SECURE_STACK    (1<<6)
S/* Whether the callee registers are automatically pushed to user stack. 1 means yes, 0 means no */
S#define RMP_CMX_EXC_RET_CALLEE_SAVE     (1<<5)
S/* Whether the stack frame is standard(contains no FPU data). 1 means yes, 0 means no */
S#define RMP_CMX_EXC_RET_STD_FRAME       (1<<4)
S/* Are we returning to user mode? 1 means yes, 0 means no */
S#define RMP_CMX_EXC_RET_RET_USER        (1<<3)
S/* Are we returning to PSP? 1 means yes, 0 means no */
S#define RMP_CMX_EXC_RET_RET_PSP         (1<<2)
S/* Is this interrupt taken to a secured domain? 1 means yes, 0 means no */
S#define RMP_CMX_EXC_INT_SECURE_DOMAIN   (1<<0)
S/* FPU type definitions */
S#define RMP_CMX_FPU_NONE                (0)
S#define RMP_CMX_FPU_VFPV4               (1)
S#define RMP_CMX_FPU_FPV5_SP             (2)
S#define RMP_CMX_FPU_FPV5_DP             (3)
S
S/* Some useful SCB definitions */
S#define RMP_CMX_SHCSR_USGFAULTENA       (1<<18)
S#define RMP_CMX_SHCSR_BUSFAULTENA       (1<<17)
S#define RMP_CMX_SHCSR_MEMFAULTENA       (1<<16)
S/* MPU definitions */
S#define RMP_CMX_MPU_PRIVDEF             0x00000004
S/* NVIC definitions */
S#define RMP_CMX_NVIC_GROUPING_P7S1      0
S#define RMP_CMX_NVIC_GROUPING_P6S2      1
S#define RMP_CMX_NVIC_GROUPING_P5S3      2
S#define RMP_CMX_NVIC_GROUPING_P4S4      3
S#define RMP_CMX_NVIC_GROUPING_P3S5      4
S#define RMP_CMX_NVIC_GROUPING_P2S6      5
S#define RMP_CMX_NVIC_GROUPING_P1S7      6
S#define RMP_CMX_NVIC_GROUPING_P0S8      7
S/* Fault definitions */
S/* The NMI is active */
S#define RMP_CMX_ICSR_NMIPENDSET         (((rmp_ptr_t)1)<<31)
S/* Debug event has occurred. The Debug Fault Status Register has been updated */
S#define RMP_CMX_HFSR_DEBUGEVT           (((rmp_ptr_t)1)<<31)
S/* Processor has escalated a configurable-priority exception to HardFault */
S#define RMP_CMX_HFSR_FORCED             (1<<30)
S/* Vector table read fault has occurred */
S#define RMP_CMX_HFSR_VECTTBL            (1<<1)
S/* Divide by zero */
S#define RMP_CMX_UFSR_DIVBYZERO          (1<<25)
S/* Unaligned load/store access */
S#define RMP_CMX_UFSR_UNALIGNED          (1<<24)
S/* No such coprocessor */
S#define RMP_CMX_UFSR_NOCP               (1<<19)
S/* Invalid vector return LR or PC value */
S#define RMP_CMX_UFSR_INVPC              (1<<18)
S/* Invalid IT instruction or related instructions */
S#define RMP_CMX_UFSR_INVSTATE           (1<<17)
S/* Invalid IT instruction or related instructions */
S#define RMP_CMX_UFSR_UNDEFINSTR         (1<<16)
S/* The Bus Fault Address Register is valid */
S#define RMP_CMX_BFSR_BFARVALID          (1<<15)
S/* The bus fault happened during FP lazy stacking */
S#define RMP_CMX_BFSR_LSPERR             (1<<13)
S/* A derived bus fault has occurred on exception entry */
S#define RMP_CMX_BFSR_STKERR             (1<<12)
S/* A derived bus fault has occurred on exception return */
S#define RMP_CMX_BFSR_UNSTKERR           (1<<11)
S/* Imprecise data access error has occurred */
S#define RMP_CMX_BFSR_IMPRECISERR        (1<<10)
S/* A precise data access error has occurred, and the processor 
S * has written the faulting address to the BFAR */
S#define RMP_CMX_BFSR_PRECISERR          (1<<9)
S/* A bus fault on an instruction prefetch has occurred. The 
S * fault is signaled only if the instruction is issued */
S#define RMP_CMX_BFSR_IBUSERR            (1<<8)
S/* The Memory Mnagement Fault Address Register have valid contents */
S#define RMP_CMX_MFSR_MMARVALID          (1<<7)
S/* A MemManage fault occurred during FP lazy state preservation */
S#define RMP_CMX_MFSR_MLSPERR            (1<<5)
S/* A derived MemManage fault occurred on exception entry */
S#define RMP_CMX_MFSR_MSTKERR            (1<<4)
S/* A derived MemManage fault occurred on exception return */
S#define RMP_CMX_MFSR_MUNSTKERR          (1<<3)
S/* Data access violation. The MMFAR shows the data address that
S * the load or store tried to access */
S#define RMP_CMX_MFSR_DACCVIOL           (1<<1)
S/* MPU or Execute Never (XN) default memory map access violation on an
S * instruction fetch has occurred. The fault is signalled only if the
S * instruction is issued */
S#define RMP_CMX_MFSR_IACCVIOL           (1<<0)
S
S/* These faults cannot be recovered and will lead to termination immediately */
S#define RMP_CMX_FAULT_FATAL             (RMP_CMX_UFSR_DIVBYZERO|RMP_CMX_UFSR_UNALIGNED| \
S                                         RMP_CMX_UFSR_NOCP|RMP_CMX_UFSR_INVPC| \
S                                         RMP_CMX_UFSR_INVSTATE|RMP_CMX_UFSR_UNDEFINSTR| \
S                                         RMP_CMX_BFSR_LSPERR|RMP_CMX_BFSR_STKERR| \
S                                         RMP_CMX_BFSR_UNSTKERR|RMP_CMX_BFSR_IMPRECISERR| \
S                                         RMP_CMX_BFSR_PRECISERR|RMP_CMX_BFSR_IBUSERR)
X#define RMP_CMX_FAULT_FATAL             (RMP_CMX_UFSR_DIVBYZERO|RMP_CMX_UFSR_UNALIGNED|                                          RMP_CMX_UFSR_NOCP|RMP_CMX_UFSR_INVPC|                                          RMP_CMX_UFSR_INVSTATE|RMP_CMX_UFSR_UNDEFINSTR|                                          RMP_CMX_BFSR_LSPERR|RMP_CMX_BFSR_STKERR|                                          RMP_CMX_BFSR_UNSTKERR|RMP_CMX_BFSR_IMPRECISERR|                                          RMP_CMX_BFSR_PRECISERR|RMP_CMX_BFSR_IBUSERR)
S/*****************************************************************************/
S/* __RMP_PLATFORM_CMX_H_DEFS__ */
S#endif
S/* __HDR_DEFS__ */
N#endif
N/* End Defines ***************************************************************/
N
N/* Structs *******************************************************************/
N#ifdef __HDR_STRUCTS__
S#ifndef __RMP_PLATFORM_CMX_H_STRUCTS__
S#define __RMP_PLATFORM_CMX_H_STRUCTS__
S/* We used structs in the header */
S
S/* Use defines in these headers */
S#define __HDR_DEFS__
S#undef __HDR_DEFS__
S/*****************************************************************************/
S
S/*****************************************************************************/
S/* __RMP_PLATFORM_CMX_H_STRUCTS__ */
S#endif
S/* __HDR_STRUCTS__ */
N#endif
N/* End Structs ***************************************************************/
N
N/* Private Global Variables **************************************************/
N#if(!(defined __HDR_DEFS__||defined __HDR_STRUCTS__))
X#if(!(0L||0L))
N#ifndef __RMP_PLATFORM_CMX_MEMBERS__
N#define __RMP_PLATFORM_CMX_MEMBERS__
N
N/* In this way we can use the data structures and definitions in the headers */
N#define __HDR_DEFS__
N
N#undef __HDR_DEFS__
N
N#define __HDR_STRUCTS__
N
N#undef __HDR_STRUCTS__
N
N/* If the header is not used in the public mode */
N#ifndef __HDR_PUBLIC_MEMBERS__
S/*****************************************************************************/
S
S/*****************************************************************************/
S/* End Private Global Variables **********************************************/
S
S/* Private C Function Prototypes *********************************************/ 
S/*****************************************************************************/
S
S/*****************************************************************************/
S#define __EXTERN__
S/* End Private C Function Prototypes *****************************************/
S
S/* Public Global Variables ***************************************************/
S/* __HDR_PUBLIC_MEMBERS__ */
N#else
N#define __EXTERN__ EXTERN 
N/* __HDR_PUBLIC_MEMBERS__ */
N#endif
N
N/*****************************************************************************/
N
N/*****************************************************************************/
N
N/* End Public Global Variables ***********************************************/
N
N/* Public C Function Prototypes **********************************************/
N/*****************************************************************************/
N/* Interrupts */
NEXTERN void RMP_Disable_Int(void);
Xextern void RMP_Disable_Int(void);
NEXTERN void RMP_Enable_Int(void);
Xextern void RMP_Enable_Int(void);
NEXTERN void RMP_Mask_Int(rmp_ptr_t Level);
Xextern void RMP_Mask_Int(rmp_ptr_t Level);
N
NEXTERN rmp_ptr_t RMP_MSB_Get(rmp_ptr_t Val);
Xextern rmp_ptr_t RMP_MSB_Get(rmp_ptr_t Val);
NEXTERN void _RMP_Start(rmp_ptr_t Entry, rmp_ptr_t Stack);
Xextern void _RMP_Start(rmp_ptr_t Entry, rmp_ptr_t Stack);
NEXTERN void _RMP_Yield(void);
Xextern void _RMP_Yield(void);
N
N/* Initialization */
N__EXTERN__ void _RMP_Stack_Init(rmp_ptr_t Entry, rmp_ptr_t Stack, rmp_ptr_t Arg);
Xextern void _RMP_Stack_Init(rmp_ptr_t Entry, rmp_ptr_t Stack, rmp_ptr_t Arg);
N__EXTERN__ void _RMP_Low_Level_Init(void);
Xextern void _RMP_Low_Level_Init(void);
N__EXTERN__ void RMP_Putchar(char Char);
Xextern void RMP_Putchar(char Char);
N__EXTERN__ void _RMP_Plat_Hook(void);
Xextern void _RMP_Plat_Hook(void);
N/*****************************************************************************/
N/* Undefine "__EXTERN__" to avoid redefinition */
N#undef __EXTERN__
N/* __RMP_PLATFORM_CMX_MEMBERS__ */
N#endif
N/* !(defined __HDR_DEFS__||defined __HDR_STRUCTS__) */
N#endif
N/* End Public C Function Prototypes ******************************************/
N
N/* End Of File ***************************************************************/
N
N/* Copyright (C) Evo-Devo Instrum. All rights reserved ***********************/
L 11 "..\..\MProkaron\Include\Platform/rmp_platform.h" 2
N/* End Platform Includes *****************************************************/
N
N/* End Of File ***************************************************************/
N
N/* Copyright (C) Evo-Devo Instrum. All rights reserved ***********************/
L 30 "..\..\MProkaron\Kernel\rmp_kernel.c" 2
N#undef __HDR_PUBLIC_MEMBERS__
N/* End Includes **************************************************************/
N
N/* Begin Function:RMP_Print_Coverage ******************************************
NDescription : The coverage data printer. Should always be disabled for all cases
N              except where a kernel coverage test is needed. This should never
N              be called ny any user application; for EDI coverage testing only.
NInput       : None.
NOutput      : None.
NReturn      : None.
N******************************************************************************/
N#ifdef RMP_COVERAGE
Svoid RMP_Print_Coverage(void)
S{
S    rmp_cnt_t Count;
S    
S    for(Count=1;Count<RMP_COVERAGE_LINES;Count++)
S    {
S        if(RMP_Coverage[Count]!=0)
S        {
S            RMP_PRINTK_I(Count);
S            RMP_PRINTK_S(":");
S            RMP_PRINTK_I(RMP_Coverage[Count]);
S            RMP_PRINTK_S("\r\n");
S        }
S    }
S}
N#endif
N/* End Function:RMP_Print_Coverage *******************************************/
N
N/* Begin Function:RMP_Clear ***************************************************
NDescription : Memset a memory area to zero.
NInput       : volatile void* Addr - The address to clear.
N              rmp_ptr_t Size - The size to clear.
NOutput      : None.
NReturn      : None.
N******************************************************************************/
Nvoid RMP_Clear(volatile void* Addr, rmp_ptr_t Size)
N{
N    rmp_u8_t* Ptr;
N    rmp_cnt_t Count;
N   
N    Ptr=(rmp_u8_t*)Addr;
N    for(Count=0;Count<(rmp_cnt_t)Size;Count++)
N        Ptr[Count]=0;
N}
N/* End Function:RMP_Clear ****************************************************/
N
N/* Begin Function:RMP_Print_Int ***********************************************
NDescription : Print a signed integer on the debugging console. This integer is
N              printed as decimal with sign.
NInput       : rmp_cnt_t Int - The integer to print.
NOutput      : None.
NReturn      : rmp_cnt_t - The length of the string printed.
N******************************************************************************/
Nrmp_cnt_t RMP_Print_Int(rmp_cnt_t Int)
N{
N    rmp_ptr_t Iter;
N    rmp_cnt_t Count;
N    rmp_cnt_t Num;
N    rmp_ptr_t Div;
N    
N    /* how many digits are there? */
N    if(Int==0)
N    {
N        RMP_Putchar('0');
N        return 1;
N    }
N    else if(Int<0)
N    {
N        /* How many digits are there? */
N        Count=0;
N        Div=1;
N        Iter=(rmp_ptr_t)(-Int);
N        while(Iter!=0)
N        {
N            Iter/=10;
N            Count++;
N            Div*=10;
N        }
N        Div/=10;
N        
N        RMP_Putchar('-');
N        Iter=-Int;
N        Num=Count+1;
N        
N        while(Count>0)
N        {
N            Count--;
N            RMP_Putchar(Iter/Div+'0');
N            Iter=Iter%Div;
N            Div/=10;
N        }
N    }
N    else
N    {
N        /* How many digits are there? */
N        Count=0;
N        Div=1;
N        Iter=Int;
N        while(Iter!=0)
N        {
N            Iter/=10;
N            Count++;
N            Div*=10;
N        }
N        Div/=10;
N        
N        Iter=Int;
N        Num=Count;
N        
N        while(Count>0)
N        {
N            Count--;
N            RMP_Putchar(Iter/Div+'0');
N            Iter=Iter%Div;
N            Div/=10;
N        }
N    }
N    
N    return Num;
N}
N/* End Function:RMP_Print_Int ************************************************/
N
N/* Begin Function:RMP_Print_Uint **********************************************
NDescription : Print a unsigned integer on the debugging console. This integer is
N              printed as hexadecimal.
NInput       : rmp_ptr_t Uint - The unsigned integer to print.
NOutput      : None.
NReturn      : rmp_cnt_t - The length of the string printed.
N******************************************************************************/
Nrmp_cnt_t RMP_Print_Uint(rmp_ptr_t Uint)
N{
N    rmp_ptr_t Iter;
N    rmp_cnt_t Count;
N    rmp_cnt_t Num;
N    
N    /* how many digits are there? */
N    if(Uint==0)
N    {
N        RMP_Putchar('0');
N        return 1;
N    }
N    else
N    {
N        /* Filter out all the zeroes */
N        Count=0;
N        Iter=Uint;
N        while((Iter>>((sizeof(rmp_ptr_t)*8)-4))==0)
N        {
N            Iter<<=4;
N            Count++;
N        }
N        /* Count is the number of pts to print */
N        Count=sizeof(rmp_ptr_t)*2-Count;
N        Num=Count;
N        while(Count>0)
N        {
N            Count--;
N            Iter=(Uint>>(Count*4))&0x0F;
N            if(Iter<10)
N                RMP_Putchar('0'+Iter);
N            else
N                RMP_Putchar('A'+Iter-10);
N        }
N    }
N    
N    return Num;
N}
N/* End Function:RMP_Print_Uint ***********************************************/
N
N/* Begin Function:RMP_Print_String ********************************************
NDescription : Print a string the kernel console.
N              This is only used for kernel-level debugging.
NInput       : rmp_s8_t* String - The string to print
NOutput      : None.
NReturn      : rmp_cnt_t - The length of the string printed, the '\0' is not included.
N******************************************************************************/
Nrmp_cnt_t RMP_Print_String(rmp_s8_t* String)
N{
N    rmp_cnt_t Count;
N    
N    Count=0;
N    while(Count<RMP_KERNEL_DEBUG_MAX_STR)
X    while(Count<255)
N    {
N        if(String[Count]=='\0')
N            break;
N        
N        RMP_Putchar(String[Count++]);
N    }
N    
N    return Count;
N}
N/* End Function:RMP_Print_String *********************************************/
N
N/* Begin Function:RMP_List_Crt ************************************************
NDescription : Create a doubly linkled list.
NInput       : volatile struct RMP_List* Head - The pointer to the list head.
NOutput      : None.
NReturn      : None.
N******************************************************************************/
Nvoid RMP_List_Crt(volatile struct RMP_List* Head)
N{
N    Head->Prev=(struct RMP_List*)Head;
N    Head->Next=(struct RMP_List*)Head;
N}
N/* End Function:RMP_List_Crt *************************************************/
N
N/* Begin Function:RMP_List_Del ************************************************
NDescription : Delete a node from the doubly-linked list.
NInput       : volatile struct RMP_List* Prev - The prevoius node of the target node.
N              volatile struct RMP_List* Next - The next node of the target node.
NOutput      : None.
NReturn      : None.
N******************************************************************************/
Nvoid RMP_List_Del(volatile struct RMP_List* Prev,volatile struct RMP_List* Next)
N{
N    Next->Prev=(struct RMP_List*)Prev;
N    Prev->Next=(struct RMP_List*)Next;
N}
N/* End Function:RMP_List_Del *************************************************/
N
N/* Begin Function:RMP_List_Ins ************************************************
NDescription : Insert a node to the doubly-linked list.
NInput       : volatile struct RMP_List* New - The new node to insert.
N              volatile struct RMP_List* Prev - The previous node.
N              volatile struct RMP_List* Next - The next node.
NOutput      : None.
NReturn      : None.
N******************************************************************************/
Nvoid RMP_List_Ins(volatile struct RMP_List* New,
N                  volatile struct RMP_List* Prev,
N                  volatile struct RMP_List* Next)
N{
N    Next->Prev=(struct RMP_List*)New;
N    New->Next=(struct RMP_List*)Next;
N    New->Prev=(struct RMP_List*)Prev;
N    Prev->Next=(struct RMP_List*)New;
N}
N/* End Function:RMP_List_Ins *************************************************/
N
N/* Begin Function:RMP_CRC16 ***************************************************
NDescription    : CRC16 checksum calculation. Polynomial=0xA001.
NInput          : const rmp_u8_t* Data - The pointer to the dataset.
N                 rmp_ptr_t Length - The length of the data in bytes.
NOutput         : None.
NReturn         : rmp_ptr_t - The CRC16 value calculated.
N******************************************************************************/
N#ifdef __RMP_U8_T__
N#ifdef __RMP_U16_T__
Nrmp_ptr_t RMP_CRC16(const rmp_u8_t* Data, rmp_ptr_t Length)
N{
N    rmp_ptr_t Data_Cnt;
N    rmp_u8_t Index;
N    rmp_u8_t Temp_High;
N    rmp_u8_t Temp_Low;
N    
N    /* CRC16 constants with X^16+X^15+X^2+1 */
N    static const rmp_u8_t CRC16_High[256]=
N    {
N        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
N        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
N        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
N        0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
N        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
N        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
N        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
N        0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
N        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
N        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
N        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
N        0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
N        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
N        0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
N        0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
N        0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
N        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
N        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
N        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
N        0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
N        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
N        0x00, 0xC1, 0x81, 0x40
N    };
N
N    const rmp_u8_t CRC16_Low[256]=
N    {
N        0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7,
N        0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E,
N        0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9,
N        0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC,
N        0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
N        0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32,
N        0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D,
N        0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38,
N        0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF,
N        0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
N        0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1,
N        0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4,
N        0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB,
N        0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA,
N        0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
N        0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0,
N        0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97,
N        0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E,
N        0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89,
N        0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
N        0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83,
N        0x41, 0x81, 0x80, 0x40
N    };
N
N    Temp_High=0xFF;
N    Temp_Low=0xFF;
N    for(Data_Cnt=0;Data_Cnt<Length;Data_Cnt++)
N    {
N        Index=Temp_Low^Data[Data_Cnt];
N        Temp_Low=(rmp_u8_t)(Temp_High^CRC16_High[Index]);
N        Temp_High=CRC16_Low[Index];
N    }
N
N    return (rmp_u16_t)(((rmp_u16_t)Temp_High)<<8|Temp_Low);
N}
N#endif
N#endif
N/* End Function:RMP_CRC16 ****************************************************/
N
N/* Begin Function:RMP_Lock_Sched **********************************************
NDescription : The function locks the scheduler. The locking can be stacked.
NInput       : None.
NOutput      : None.
NReturn      : None.
N******************************************************************************/
Nvoid RMP_Lock_Sched(void)
N{
N    RMP_MASK_INT();
X    RMP_Disable_Int();
N    RMP_Sched_Locked=1;
N    RMP_Sched_Lock_Cnt++;
N}
N/* End Function:RMP_Lock_Sched ***********************************************/
N
N/* Begin Function:RMP_Unlock_Sched ********************************************
NDescription : The function unlocks the scheduler. The unlocking can be stacked.
NInput       : None.
NOutput      : None.
NReturn      : None.
N******************************************************************************/
Nvoid RMP_Unlock_Sched(void)
N{
N    if(RMP_Sched_Lock_Cnt==1)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        /* Clear the count before enabling */
N        RMP_Sched_Lock_Cnt=0;
N        RMP_Sched_Locked=0;
N        /* Now see if the scheduler scheduling action is pended in the lock-unlock 
N         * period. If yes, perform a schedule now */
N        if(RMP_Sched_Pend!=0)
N        {
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N            /* Reset the count and trigger the context switch */
N            RMP_Sched_Pend=0;
N            _RMP_Yield();
N        }
N        else
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N        
N        RMP_UNMASK_INT();
X        RMP_Enable_Int();
N    }
N    else if(RMP_Sched_Lock_Cnt>1)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        RMP_Sched_Lock_Cnt--;
N    }
N    /* Trying to unlock a scheduler that is not locked - should never happen */
N    else
N        while(1);
N}
N/* End Function:RMP_Unlock_Sched *********************************************/
N
N/* Begin Function:RMP_Yield ***************************************************
NDescription : Yield to another thread.
NInput       : None.
NOutput      : None.
NReturn      : None.
N******************************************************************************/
Nvoid RMP_Yield(void)
N{
N    if(RMP_Sched_Locked==0)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        /* Now see if the scheduler scheduling action is pended in the lock-unlock 
N         * period. If yes, perform a schedule now */
N        _RMP_Yield();
N    }
N    else
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        RMP_Sched_Pend=1;
N    }
N}
N/* End Function:RMP_Yield ****************************************************/
N
N/* Begin Function:_RMP_Timer_Proc *********************************************
NDescription : Process RMP timer events.
NInput       : None.
NOutput      : None.
NReturn      : None.
N******************************************************************************/
Nvoid _RMP_Timer_Proc(void)
N{
N    struct RMP_Thd* Thread;
N    
N    /* Process the timer events, if there are any of them */
N    while((&RMP_Delay)!=RMP_Delay.Next)
N    {
N        Thread=RMP_DLY2THD(RMP_Delay.Next);
X        Thread=((struct RMP_Thd*)(((rmp_ptr_t)(RMP_Delay . Next))-sizeof(struct RMP_List)));
N        /* If the value is more than this, then it means that the time have
N         * already passed and we have to process this */
N        if((RMP_Tick-Thread->Timeout)>(RMP_ALLBITS>>1))
X        if((RMP_Tick-Thread->Timeout)>(((rmp_ptr_t)(-1))>>1))
N        {
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N            break;
N        }
N        else
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N        
N        /* This thread should be processed */
N        RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
N        switch(RMP_THD_STATE(Thread->State))
X        switch(((Thread->State)&0xFF))
N        {
N            case RMP_THD_SNDDLY:RMP_COVERAGE_MARKER();
X            case (3):do { } while(0);
N            case RMP_THD_SEMDLY:
X            case (8):
N            {
N                RMP_COVERAGE_MARKER();
X                do { } while(0);
N                RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
N                Thread->Retval=RMP_ERR_OPER;
X                Thread->Retval=(-5);
N                break;
N            }
N            
N            case RMP_THD_RCVDLY:
X            case (5):
N            {
N                RMP_COVERAGE_MARKER();
X                do { } while(0);
N                Thread->Retval=RMP_ERR_OPER;
X                Thread->Retval=(-5);
N                break;
N            }
N            
N            case RMP_THD_DELAYED:RMP_COVERAGE_MARKER();break;
X            case (6):do { } while(0);break;
N            /* Should not get here */
N            default:while(1);
N        }
N
N        RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
X        ((Thread->State)=(((Thread->State)&~0xFF)|((1))));
N        /* Set to ready if not suspended */
N        _RMP_Set_Rdy(Thread);
N    }
N}
N/* Begin Function:_RMP_Timer_Proc ********************************************/
N
N/* Begin Function:_RMP_Get_High_Rdy *******************************************
NDescription : Get the highest priority ready thread. The return value will be
N              written into the global variables.
NInput       : None.
NOutput      : None.
NReturn      : None.
N******************************************************************************/
Nvoid _RMP_Get_High_Rdy(void)
N{
N    rmp_cnt_t Count;
N    
N    /* Write the SP value to thread structure */
N    RMP_Cur_Thd->Stack=RMP_Cur_SP;
N    
N    /* No need to detect scheduler locks - if this interrupt can be entered, the scheduler is not locked */
N    RMP_Sched_Pend=0;
N    /* See which one is ready, and pick it */
N    for(Count=RMP_BITMAP_SIZE-1;Count>=0;Count--)
X    for(Count=((32-1)/(((rmp_ptr_t)1)<<(5))+1)-1;Count>=0;Count--)
N    {
N        if(RMP_Bitmap[Count]==0)
N        {
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N            continue;
N        }
N        else
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N        
N        Count=RMP_MSB_Get(RMP_Bitmap[Count])+(Count<<RMP_WORD_ORDER);
X        Count=RMP_MSB_Get(RMP_Bitmap[Count])+(Count<<5);
N        
N        /* See if the current thread and the next thread are the same. If yes, place the current at the end of the queue */
N        if(RMP_Cur_Thd==(struct RMP_Thd*)(RMP_Run[Count].Next))
N        {
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N            RMP_List_Del(RMP_Cur_Thd->Run_Head.Prev, RMP_Cur_Thd->Run_Head.Next);
N            RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),
N                         RMP_Run[RMP_Cur_Thd->Prio].Prev,
N                         &(RMP_Run[RMP_Cur_Thd->Prio]));
N        }
N        else
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N        
N        /* Replenish timeslices */
N        RMP_Cur_Thd->Slices_Left=RMP_Cur_Thd->Slices;
N        RMP_Cur_Thd=(struct RMP_Thd*)(RMP_Run[Count].Next);
N        break;
N    }
N    
N    /* Load the SP value from thread structure */
N    RMP_Cur_SP=RMP_Cur_Thd->Stack;
N    
N#if(RMP_USE_HOOKS==RMP_TRUE)
X#if(0==1)
S    RMP_Sched_Hook();
N#endif
N}
N/* End Function:_RMP_Get_High_Rdy ********************************************/
N
N/* Begin Function:_RMP_Tick_Handler *******************************************
NDescription : The system tick timer interrupt routine.
NInput       : rmp_ptr_t Ticks - How many ticks have passed.
NOutput      : None.
NReturn      : None.
N******************************************************************************/
Nvoid _RMP_Tick_Handler(rmp_ptr_t Ticks)
N{
N    struct RMP_Thd* Thread;
N    /* Increase the timestamp as always */
N    RMP_Tick+=Ticks;
N    
N    /* See if the current thread expired. If yes, trigger a scheduler event */
N    if(Ticks>RMP_Cur_Thd->Slices_Left)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        RMP_Sched_Pend=1;
N    }
N    else
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        RMP_Cur_Thd->Slices_Left-=Ticks;
N    }
N    
N    /* Check if there are any timer events */
N    if((&RMP_Delay)!=RMP_Delay.Next)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        Thread=RMP_DLY2THD(RMP_Delay.Next);
X        Thread=((struct RMP_Thd*)(((rmp_ptr_t)(RMP_Delay . Next))-sizeof(struct RMP_List)));
N        /* If the value is less than this, then it means that the time have
N         * already passed and we have to process this */
N        if((RMP_Tick-Thread->Timeout)<=(RMP_ALLBITS>>1))
X        if((RMP_Tick-Thread->Timeout)<=(((rmp_ptr_t)(-1))>>1))
N        {
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N            /* No need to care about scheduler locks if this interrupt can be entered
N             * - we have disabled timer and scheduler interrupts in scheduler lock */
N            _RMP_Timer_Proc();
N        }
N        else
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    if(RMP_Sched_Pend!=0)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        RMP_Sched_Pend=0;
N        _RMP_Yield();
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N#if(RMP_USE_HOOKS==RMP_TRUE)
X#if(0==1)
S    RMP_Tick_Hook(Ticks);
N#endif
N}
N/* End Function:_RMP_Tick_Handler ********************************************/
N
N/* Begin Function:_RMP_Get_Near_Ticks *****************************************
NDescription : Get the nearest timer interrupt arrival time. This is used to set
N              the timer after the body of tick handler have been executed. This
N              can be called in the ticker hook and scheduler hook to set the next
N              timeout value to implement a tickless kernel. If a tickless kernel
N              is not desired, this function can be ignored.
NInput       : None.
NOutput      : None.
NReturn      : rmp_ptr_t Ticks - How many ticks until the next timeout.
N******************************************************************************/
Nrmp_ptr_t _RMP_Get_Near_Ticks(void)
N{
N    rmp_ptr_t Value;
N    struct RMP_Thd* Thread;
N    
N    /* What is the current thread's timeout value? */
N    Value=RMP_Cur_Thd->Slices_Left;
N    
N    /* What is the nearest timer timeout value? */
N    if((&RMP_Delay)!=RMP_Delay.Next)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        Thread=RMP_DLY2THD(RMP_Delay.Next);
X        Thread=((struct RMP_Thd*)(((rmp_ptr_t)(RMP_Delay . Next))-sizeof(struct RMP_List)));
N        /* See if it is nearer - don't worry about the situation that the timer
N         * have overflown, because if that is to happen, it would have been 
N         * already processed by the timeout processing routine just before. */
N        if((Thread->Timeout-RMP_Tick)<Value)
N        {
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N            Value=Thread->Timeout-RMP_Tick;
N        }
N        else
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    return Value;
N}
N/* End Function:_RMP_Get_Near_Ticks ******************************************/
N
N/* Begin Function:_RMP_Set_Rdy ************************************************
NDescription : Set the thread as ready to schedule. That means, put the thread into
N              the runqueue. When this is called, please make sure that the scheduler
N              is locked.
N              This function will also try to identify if this thread is currently 
N              suspended. If yes, it will not be placed into the queue.
NInput       : volatile struct RMP_Thd* Thread - The thread to put into the runqueue.
NOutput      : None.
NReturn      : None.
N******************************************************************************/
Nvoid _RMP_Set_Rdy(volatile struct RMP_Thd* Thread)
N{        
N    /* Is it suspended? If yes, we can't directly set it running */
N    if((Thread->State&RMP_THD_SUSPENDED)==0)
X    if((Thread->State&(1<<8))==0)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        /* Insert this into the corresponding runqueue */
N        RMP_List_Ins(&(Thread->Run_Head),RMP_Run[Thread->Prio].Prev,&(RMP_Run[Thread->Prio]));
N        /* Set this runlevel as active */
N        RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]|=((rmp_ptr_t)1)<<(Thread->Prio&RMP_WORD_MASK);
X        RMP_Bitmap[Thread->Prio>>5]|=((rmp_ptr_t)1)<<(Thread->Prio&(~(((rmp_ptr_t)(-1))<<5)));
N        
N        /* Compare this with the current one to see if we need a context switch */
N        if(Thread->Prio>RMP_Cur_Thd->Prio)
N        {
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N            RMP_Sched_Pend=1;
N        }
N        else
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N}
N/* End Function:_RMP_Set_Rdy *************************************************/
N
N/* Begin Function:_RMP_Clr_Rdy ************************************************
NDescription : Clear the thread from the runqueue. When this is called, please 
N              make sure that the scheduler is locked. This function also checks whether
N              the thread is suspended. If yes, it will not remove it from the queue.
NInput       : volatile struct RMP_Thd* Thread - The thread to clear from the runqueue.
NOutput      : None.
NReturn      : None.
N******************************************************************************/
Nvoid _RMP_Clr_Rdy(volatile struct RMP_Thd* Thread)
N{
N    /* Is it suspended? If yes, no need to delete again */
N    if((Thread->State&RMP_THD_SUSPENDED)==0)
X    if((Thread->State&(1<<8))==0)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        /* See if it is the last thread on the priority level */
N        if(Thread->Run_Head.Prev==Thread->Run_Head.Next)
N        {
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N            RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]&=~(((rmp_ptr_t)1)<<(Thread->Prio&RMP_WORD_MASK));
X            RMP_Bitmap[Thread->Prio>>5]&=~(((rmp_ptr_t)1)<<(Thread->Prio&(~(((rmp_ptr_t)(-1))<<5))));
N        }
N        else
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N        
N        /* Delete this from the corresponding runqueue */
N        RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
N        
N        /* If it is the current thread, request a context switch */
N        if(Thread==RMP_Cur_Thd)
N        {
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N            RMP_Sched_Pend=1;
N        }
N        else
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N}
N/* End Function:_RMP_Clr_Rdy *************************************************/
N
N/* Begin Function:_RMP_Dly_Ins ************************************************
NDescription : Insert the thread into the delay queue, given some timeslices into the
N              future. The thread must not be in the run queue any more.
NInput       : volatile struct RMP_Thd* Thread - The thread to put into the delay queue.
N              rmp_ptr_t - The timeslices to delay.
NOutput      : None.
NReturn      : None.
N******************************************************************************/
Nvoid _RMP_Dly_Ins(volatile struct RMP_Thd* Thread, rmp_ptr_t Slices)
N{
N    struct RMP_List* Trav_Ptr;
N    struct RMP_Thd* Trav_Thd;
N    
N    /* Find a place to insert this timer */
N    Trav_Ptr=(struct RMP_List*)RMP_Delay.Next;
N    while(Trav_Ptr!=&(RMP_Delay))
N    {
N        Trav_Thd=RMP_DLY2THD(Trav_Ptr);
X        Trav_Thd=((struct RMP_Thd*)(((rmp_ptr_t)(Trav_Ptr))-sizeof(struct RMP_List)));
N        if((Trav_Thd->Timeout-RMP_Tick)>Slices)
N        {
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N            break;
N        }
N        else
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N        
N        Trav_Ptr=(struct RMP_List*)(Trav_Ptr->Next);
N    }
N
N    /* Insert this into the list */
N    Thread->Timeout=RMP_Tick+Slices;
N    RMP_List_Ins(&Thread->Dly_Head,Trav_Ptr->Prev,Trav_Ptr);
N}
N/* End Function:_RMP_Dly_Ins *************************************************/
N
N/* Begin Function:RMP_Thd_Crt *************************************************
NDescription : Create a real-time thread.
NInput       : volatile struct RMP_Thd* Thread - The thread structure provided. The user 
N                                                should make this allocation according to
N                                                his or her needs.
N              void* Entry - The entry of the thread.
N              void* Stack - The stack of this thread.
N              void* Arg - The argument to pass to the thread.
N              rmp_ptr_t Prio - The priority of the thread.
N              rmp_ptr_t Slices - The number of timeslices to assign to the thread.
NOutput      : None.
NReturn      : rmp_ret_t - If successful, 0. on error, return an error code.
N******************************************************************************/
Nrmp_ret_t RMP_Thd_Crt(volatile struct RMP_Thd* Thread, void* Entry, void* Stack, void* Arg, rmp_ptr_t Prio, rmp_ptr_t Slices)
N{
N    /* Check if the priority and timeslice range is correct */
N    if(Prio>=RMP_MAX_PREEMPT_PRIO)
X    if(Prio>=32)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        return RMP_ERR_PRIO;
X        return (-2);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    if((Slices==0)||(Slices>=RMP_MAX_SLICES))
X    if((Slices==0)||(Slices>=100000))
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        return RMP_ERR_SLICE;
X        return (-3);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    /* Check if this thread structure could possibly be in use */
N    if(Thread==0)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        return RMP_ERR_THD;
X        return (-1);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    RMP_Lock_Sched();
N    
N    if(RMP_THD_STATE(Thread->State)!=RMP_THD_FREE)
X    if(((Thread->State)&0xFF)!=(0))
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        RMP_Unlock_Sched();
N        return RMP_ERR_THD;
X        return (-1);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    /* Create the thread and insert it into the list */
N    Thread->Prio=Prio;
N    Thread->Slices=Slices;
N    Thread->Slices_Left=Slices;
N    Thread->Stack=(rmp_ptr_t)Stack;
N    
N    /* Initialize its stack and sending list */
N    _RMP_Stack_Init((rmp_ptr_t)Entry, (rmp_ptr_t)Stack, (rmp_ptr_t)Arg);
N    RMP_List_Crt(&(Thread->Snd_List));
N    
N    /* Notify the scheduler that we have created something new, also check locks */
N    Thread->State=RMP_THD_RUNNING;
X    Thread->State=(1);
N    _RMP_Set_Rdy(Thread);
N    
N    RMP_Unlock_Sched();
N
N    return 0;
N}
N/* End Function:RMP_Thd_Crt **************************************************/
N
N/* Begin Function:RMP_Thd_Del *************************************************
NDescription : Delete a real-time thread.
NInput       : volatile struct RMP_Thd* Thread - The thread structure of the thread.
NOutput      : None.
NReturn      : rmp_ret_t - If successful, 0; or an error code.
N******************************************************************************/
Nrmp_ret_t RMP_Thd_Del(volatile struct RMP_Thd* Thread)
N{
N    struct RMP_Thd* Release;
N    
N    /* Check if this thread structure could possibly be in use */
N    if(Thread==0)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        return RMP_ERR_THD;
X        return (-1);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    RMP_Lock_Sched();
N    
N    if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
X    if(((Thread->State)&0xFF)==(0))
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        RMP_Unlock_Sched();
N        return RMP_ERR_THD;
X        return (-1);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    /* See if anyone waiting to send to this thread. If there is, release all these threads */
N    while(&(Thread->Snd_List)!=Thread->Snd_List.Next)
N    {
N        Release=(struct RMP_Thd*)(Thread->Snd_List.Next);
N        RMP_List_Del(Release->Run_Head.Prev,Release->Run_Head.Next);
N        if(RMP_THD_STATE(Release->State)==RMP_THD_SNDDLY)
X        if(((Release ->State)&0xFF)==(3))
N        {
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N            RMP_List_Del(Release->Dly_Head.Prev,Release->Dly_Head.Next);
N        }
N        else
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N        
N        RMP_THD_STATE_SET(Release->State,RMP_THD_RUNNING);
X        ((Release ->State)=(((Release ->State)&~0xFF)|((1))));
N        /* Set ready if not suspended */
N        _RMP_Set_Rdy(Release);
N        Release->Retval=RMP_ERR_OPER;
X        Release->Retval=(-5);
N    }
N    
N    /* See what is its state */
N    switch(RMP_THD_STATE(Thread->State))
X    switch(((Thread->State)&0xFF))
N    {
N        case RMP_THD_RUNNING:
X        case (1):
N        {
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N            /* Clear ready if not suspended */
N            _RMP_Clr_Rdy(Thread);
N            break;
N        }
N        
N        /* Do nothing if it is blocked on receive */
N        case RMP_THD_RCVBLK:
X        case (4):
N        {
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N            break;
N        }
N        
N        case RMP_THD_SNDBLK:RMP_COVERAGE_MARKER();
X        case (2):do { } while(0);
N        case RMP_THD_SEMBLK:
X        case (7):
N        {
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N            RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
N            break;
N        }
N        
N        case RMP_THD_SNDDLY:RMP_COVERAGE_MARKER();
X        case (3):do { } while(0);
N        case RMP_THD_SEMDLY:
X        case (8):
N        {
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N            RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
N            /* Fall-through case */
N        }
N        case RMP_THD_RCVDLY:RMP_COVERAGE_MARKER();
X        case (5):do { } while(0);
N        case RMP_THD_DELAYED:
X        case (6):
N        {
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N            RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
N            break;
N        }
N        /* Should not get here */
N        default:while(1);
N    }
N    /* Set return value to failure anyway */
N    Thread->Retval=RMP_ERR_OPER;
X    Thread->Retval=(-5);
N    Thread->State=RMP_THD_FREE;
X    Thread->State=(0);
N    /* If we are deleting ourself, pend a yield */
N    if(Thread==RMP_Cur_Thd)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        RMP_Sched_Pend=1;
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    RMP_Unlock_Sched();
N    
N    /* If we are deleting ourself, just stop the execution here */
N    if(Thread==RMP_Cur_Thd)
N        while(1);
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N
N    return 0;
N}
N/* End Function:RMP_Thd_Del **************************************************/
N
N/* Begin Function:RMP_Thd_Set *************************************************
NDescription : Change the priority or timeslice of a real-time thread. If one of
N              the changes is not desired, just leave it to RMP_MAX_PREEMPT_PRIO
N              or RMP_MAX_SLICES.
NInput       : volatile struct RMP_Thd* Thread - The thread structure of the thread.
N              rmp_ptr_t Prio - The priority of the thread.
N              rmp_ptr_t Slices - The new timeslice value for this thread.
NOutput      : None.
NReturn      : rmp_ret_t - If successful, 0; else error code.
N******************************************************************************/
Nrmp_ret_t RMP_Thd_Set(volatile struct RMP_Thd* Thread, rmp_ptr_t Prio, rmp_ptr_t Slices)
N{
N    /* Check if the priority and timeslice range is correct */
N    if(Slices==0)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        return RMP_ERR_SLICE;
X        return (-3);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    /* Check if this thread structure could possibly be in use */
N    if(Thread==0)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        return RMP_ERR_THD;
X        return (-1);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    RMP_Lock_Sched();
N    
N    if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
X    if(((Thread->State)&0xFF)==(0))
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        RMP_Unlock_Sched();
N        return RMP_ERR_THD;
X        return (-1);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    /* See if the thread is in running state */
N    if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
X    if(((Thread->State)&0xFF)==(1))
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        
N        /* See if we are gonna change one of it or both */
N        if(Prio<RMP_MAX_PREEMPT_PRIO)
X        if(Prio<32)
N        {
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N            if(Thread->Prio!=Prio)
N            {
N                RMP_COVERAGE_MARKER();
X                do { } while(0);
N                /* It doesn't matter whether this is suspended or not. 
N                 * If suspended, the operations will not be conducted. */
N                _RMP_Clr_Rdy(Thread);
N                Thread->Prio=Prio;
N                _RMP_Set_Rdy(Thread);
N            }
N            else
N                RMP_COVERAGE_MARKER();
X                do { } while(0);
N        }
N        else
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N        
N        if(Slices<RMP_MAX_SLICES)
X        if(Slices<100000)
N        {
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N            Thread->Slices=Slices;
N        }
N        else
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N    }
N    else
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        
N        if(Prio<RMP_MAX_PREEMPT_PRIO)
X        if(Prio<32)
N        {
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N            Thread->Prio=Prio;
N        }
N        else
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N        
N        if(Slices<RMP_MAX_SLICES)
X        if(Slices<100000)
N        {
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N            Thread->Slices=Slices;
N        }
N        else
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N    }
N    
N    RMP_Unlock_Sched();
N    return 0;
N}
N/* End Function:RMP_Thd_Set **************************************************/
N
N/* Begin Function:RMP_Thd_Suspend *********************************************
NDescription : Suspend the execution of a real-time thread.
NInput       : volatile struct RMP_Thd* Thread - The thread structure of the thread.
NOutput      : None.
NReturn      : rmp_ret_t - If successful, 0; else error code.
N******************************************************************************/
Nrmp_ret_t RMP_Thd_Suspend(volatile struct RMP_Thd* Thread)
N{
N    /* Check if this thread structure could possibly be in use */
N    if(Thread==0)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        return RMP_ERR_THD;
X        return (-1);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    RMP_Lock_Sched();
N    
N    if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
X    if(((Thread->State)&0xFF)==(0))
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        RMP_Unlock_Sched();
N        return RMP_ERR_THD;
X        return (-1);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    /* Suspend it */
N    if((Thread->State&RMP_THD_SUSPENDED)!=0)
X    if((Thread->State&(1<<8))!=0)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        RMP_Unlock_Sched();
N        return RMP_ERR_STATE;
X        return (-4);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    /* Only when it is running do we clear this. If we are clearing this, it is not
N     * suspended, so the running queue removal is guaranteed to succceed */
N    if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
X    if(((Thread->State)&0xFF)==(1))
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        _RMP_Clr_Rdy(Thread);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    /* Mark this as suspended */
N    Thread->State|=RMP_THD_SUSPENDED;
X    Thread->State|=(1<<8);
N    
N    /* If we are suspending ourself, pend a yield */
N    if(Thread==RMP_Cur_Thd)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        RMP_Sched_Pend=1;
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    RMP_Unlock_Sched();
N    return 0;
N}
N/* End Function:RMP_Thd_Suspend **********************************************/
N
N/* Begin Function:RMP_Thd_Resume **********************************************
NDescription : Resume the execution of a real-time thread.
NInput       : volatile struct RMP_Thd* Thread - The thread structure of the thread.
NOutput      : None.
NReturn      : rmp_ret_t - If successful, 0; else error code.
N******************************************************************************/
Nrmp_ret_t RMP_Thd_Resume(volatile struct RMP_Thd* Thread)
N{
N    rmp_ret_t Retval;
N    
N    /* Check if this thread structure could possibly be in use */
N    if(Thread==0)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        return RMP_ERR_THD;
X        return (-1);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N
N    RMP_Lock_Sched();
N    
N    if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
X    if(((Thread->State)&0xFF)==(0))
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        RMP_Unlock_Sched();
N        return RMP_ERR_THD;
X        return (-1);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    /* Check if the thread is suspended, if not, then throw an error */
N    if((Thread->State&RMP_THD_SUSPENDED)!=0)
X    if((Thread->State&(1<<8))!=0)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        
N        /* Suspended */
N        Thread->State&=~RMP_THD_SUSPENDED;
X        Thread->State&=~(1<<8);
N        /* Only when it is running will we put it back. It can't be suspended here, 
N         * so the set ready operation will surely put it back */
N        if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
X        if(((Thread->State)&0xFF)==(1))
N        {
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N            _RMP_Set_Rdy(Thread);
N        }
N        else
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N        
N        Retval=0;
N    }
N    else
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        Retval=RMP_ERR_STATE;
X        Retval=(-4);
N    }
N    
N    RMP_Unlock_Sched();
N
N    return Retval;
N}
N/* End Function:RMP_Thd_Resume ***********************************************/
N
N/* Begin Function:RMP_Thd_Snd *************************************************
NDescription : Send to a real-time thread's mailbox. If the mailbox is full, then
N              this operation can potentially block.
NInput       : volatile struct RMP_Thd* Thread - The thread structure of the thread to send to.
N              rmp_ptr_t Data - The data to send to that thread.
N              rmp_ptr_t Slices - The timeslice to wait, if the mailbox is already full.
NOutput      : None.
NReturn      : rmp_ret_t - If successful,0; or an error code.
N******************************************************************************/
Nrmp_ret_t RMP_Thd_Snd(volatile struct RMP_Thd* Thread, rmp_ptr_t Data, rmp_ptr_t Slices)
N{
N    /* Check if this thread structure could possibly be in use */
N    if(Thread==0)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        return RMP_ERR_THD;
X        return (-1);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    RMP_Lock_Sched();
N    
N    if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
X    if(((Thread->State)&0xFF)==(0))
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        RMP_Unlock_Sched();
N        return RMP_ERR_THD;
X        return (-1);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    /* Are we sending to ourself? This is not allowed */
N    if(RMP_Cur_Thd==Thread)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        RMP_Unlock_Sched();
N        return RMP_ERR_OPER;
X        return (-5);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    RMP_Cur_Thd->Retval=0;
N
N    /* See if there is already a value in the mailbox, if yes, we block */
N    if((Thread->State&RMP_THD_MBOXFUL)!=0)
X    if((Thread->State&((1<<8)<<1))!=0)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        
N        /* Mailbox full, we block, and put ourself into the queue */
N        if(Slices==0)
N        {
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N            RMP_Unlock_Sched();
N            return RMP_ERR_OPER;
X            return (-5);
N        }
N        else
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N
N        /* We must be running */
N        _RMP_Clr_Rdy(RMP_Cur_Thd);
N        RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),Thread->Snd_List.Prev,&(Thread->Snd_List));
N
N        if(Slices<RMP_MAX_SLICES)
X        if(Slices<100000)
N        {
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N            _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
N            RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SNDDLY);
X            ((RMP_Cur_Thd->State)=(((RMP_Cur_Thd->State)&~0xFF)|((3))));
N        }
N        else
N        {
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N            RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SNDBLK);
X            ((RMP_Cur_Thd->State)=(((RMP_Cur_Thd->State)&~0xFF)|((2))));
N        }
N
N        RMP_Cur_Thd->Data=Data;
N    }
N    else
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        
N        /* Mailbox not full. We need to check if the receiver is waiting for us */
N        if((RMP_THD_STATE(Thread->State)==RMP_THD_RCVBLK)||
X        if((((Thread->State)&0xFF)==(4))||
N           (RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY))
X           (((Thread->State)&0xFF)==(5)))
N        {
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N            
N            /* The receiver is blocked, wake it up and return the value */
N            if(RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY)
X            if(((Thread->State)&0xFF)==(5))
N            {
N                RMP_COVERAGE_MARKER();
X                do { } while(0);
N                RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
N            }
N            else
N                RMP_COVERAGE_MARKER();
X                do { } while(0);
N            
N            RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
X            ((Thread->State)=(((Thread->State)&~0xFF)|((1))));
N            /* Set to running if not suspended */
N            _RMP_Set_Rdy(Thread);
N        }
N        else
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N        
N        /* Set the mailbox */
N        Thread->Mailbox=Data;
N        Thread->State|=RMP_THD_MBOXFUL;
X        Thread->State|=((1<<8)<<1);
N    }
N    
N    RMP_Unlock_Sched();
N
N    return RMP_Cur_Thd->Retval;
N}
N/* End Function:RMP_Thd_Snd **************************************************/
N
N/* Begin Function:RMP_Thd_Snd_ISR *********************************************
NDescription : Send to a real-time thread's mailbox. If the mailbox is full, then
N              this operation will just fail. This function can only be called from
N              an ISR whose priority is below or equal to the context switch handler's.
N              We do not check whether the scheduler is locked; if we are calling this
N              function, we're pretty sure that it's not.
NInput       : volatile struct RMP_Thd* Thread - The thread structure of the thread to send to.
N              rmp_ptr_t Data - The data to send to that thread.
NOutput      : None.
NReturn      : rmp_ret_t - If successful,0; or an error code.
N******************************************************************************/
Nrmp_ret_t RMP_Thd_Snd_ISR(volatile struct RMP_Thd* Thread, rmp_ptr_t Data)
N{
N    /* Check if this thread structure could possibly be in use */
N    if(Thread==0)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        return RMP_ERR_THD;
X        return (-1);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
X    if(((Thread->State)&0xFF)==(0))
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        return RMP_ERR_THD;
X        return (-1);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N
N    /* See if there is already a value in the mailbox, if yes, we abort */
N    if((Thread->State&RMP_THD_MBOXFUL)!=0)
X    if((Thread->State&((1<<8)<<1))!=0)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        return RMP_ERR_OPER;
X        return (-5);
N    }
N    else
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        
N        /* Mailbox not full. We need to check if the receiver is waiting for us */
N        if((RMP_THD_STATE(Thread->State)==RMP_THD_RCVBLK)||
X        if((((Thread->State)&0xFF)==(4))||
N           (RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY))
X           (((Thread->State)&0xFF)==(5)))
N        {
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N
N            /* The receiver is blocked, wake it up and return the value */
N            if(RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY)
X            if(((Thread->State)&0xFF)==(5))
N            {
N                RMP_COVERAGE_MARKER();
X                do { } while(0);
N                RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
N            }
N            else
N                RMP_COVERAGE_MARKER();
X                do { } while(0);
N            
N            RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
X            ((Thread->State)=(((Thread->State)&~0xFF)|((1))));
N
N            /* Set to running if not suspended */
N            _RMP_Set_Rdy(Thread);
N
N            /* If schedule pending, trigger it now because we are in ISR */
N            if(RMP_Sched_Pend!=0)
N            {
N                RMP_COVERAGE_MARKER();
X                do { } while(0);
N                RMP_Sched_Pend=0;
N                _RMP_Yield();
N            }
N            else
N                RMP_COVERAGE_MARKER();
X                do { } while(0);
N        }
N        else
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N        
N        /* Set the mailbox */
N        Thread->Mailbox=Data;
N        Thread->State|=RMP_THD_MBOXFUL;
X        Thread->State|=((1<<8)<<1);
N    }
N
N    return 0;
N}
N/* End Function:RMP_Thd_Snd_ISR **********************************************/
N
N/* Begin Function:RMP_Thd_Rcv *************************************************
NDescription : Receive a message from our own mailbox, and this is blocking.
NInput       : rmp_ptr_t Slices - The timeslices to wait, if the mailbox is empty.
NOutput      : rmp_ptr_t* Data - The pointer to put the data to.
NReturn      : rmp_ret_t - If successful,0; or an error code.
N******************************************************************************/
Nrmp_ret_t RMP_Thd_Rcv(rmp_ptr_t* Data, rmp_ptr_t Slices)
N{
N    struct RMP_Thd* Sender;
N    
N    if(Data==0)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        return RMP_ERR_OPER;
X        return (-5);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    RMP_Lock_Sched();
N    
N    /* Is there any other guy waiting on us? If there is, unblock it and set it running */
N    Sender=0;
N    if(&(RMP_Cur_Thd->Snd_List)!=RMP_Cur_Thd->Snd_List.Next)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        /* Read the data */
N        Sender=(struct RMP_Thd*)(RMP_Cur_Thd->Snd_List.Next);
N        RMP_List_Del(Sender->Run_Head.Prev,Sender->Run_Head.Next);
N        *Data=Sender->Data;
N        /* Now we unblock it - what state is it in? */
N        if((RMP_THD_STATE(Sender->State)==RMP_THD_SNDDLY))
X        if((((Sender->State)&0xFF)==(3)))
N        {
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N            RMP_List_Del(Sender->Dly_Head.Prev,Sender->Dly_Head.Next);
N        }
N        else
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N        
N        RMP_THD_STATE_SET(Sender->State,RMP_THD_RUNNING);
X        ((Sender->State)=(((Sender->State)&~0xFF)|((1))));
N        /* Set to running if not suspended */
N        _RMP_Set_Rdy(Sender);
N    }
N
N    /* Check if there is a value in our mailbox. If yes, we return with that value */
N    if((RMP_Cur_Thd->State&RMP_THD_MBOXFUL)!=0)
X    if((RMP_Cur_Thd->State&((1<<8)<<1))!=0)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        /* Get the value from mailbox */
N        *Data=RMP_Cur_Thd->Mailbox;
N        /* See if we unblocked a sender. If yes, we place the new value into 
N         * our mailbox and it is still full */
N        if(Sender!=0)
N            RMP_Cur_Thd->Mailbox=Sender->Data;
N        else
N            RMP_Cur_Thd->State&=~RMP_THD_MBOXFUL;
X            RMP_Cur_Thd->State&=~((1<<8)<<1);
N        
N        RMP_Unlock_Sched();
N        return 0;
N    }
N    else
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        
N        /* Box empty. Do we have somebody waiting? */
N        if(Sender!=0)
N        {
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N            RMP_Cur_Thd->Mailbox=Sender->Data;
N            RMP_Unlock_Sched();
N            return 0;
N        }
N        /* No sender waiting on us and box empty, we need to block */
N        else
N        {
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N            
N            if(Slices==0)
N            {
N                RMP_COVERAGE_MARKER();
X                do { } while(0);
N                RMP_Unlock_Sched();
N                return RMP_ERR_OPER;
X                return (-5);
N            }
N            else
N                RMP_COVERAGE_MARKER();
X                do { } while(0);
N
N            /* We must be running and not suspended so we will surely be deleted from queue */
N            _RMP_Clr_Rdy(RMP_Cur_Thd);
N
N            if(Slices<RMP_MAX_SLICES)
X            if(Slices<100000)
N            {
N                RMP_COVERAGE_MARKER();
X                do { } while(0);
N                _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
N                RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_RCVDLY);
X                ((RMP_Cur_Thd->State)=(((RMP_Cur_Thd->State)&~0xFF)|((5))));
N            }
N            else
N            {
N                RMP_COVERAGE_MARKER();
X                do { } while(0);
N                RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_RCVBLK);
X                ((RMP_Cur_Thd->State)=(((RMP_Cur_Thd->State)&~0xFF)|((4))));
N            }
N            RMP_Unlock_Sched();
N            
N            /* Dummy read - to separate the lock & unlock. If the compiler optimizes these two
N             * functions(inline them) on some architectures sometimes we never block. */
N            *Data=RMP_Cur_Thd->Mailbox;
N            
N            /* We've been unblocked. There must be something in our mbox, or we should have failed */
N            RMP_Lock_Sched();
N            *Data=RMP_Cur_Thd->Mailbox;
N            RMP_Cur_Thd->State&=~RMP_THD_MBOXFUL;
X            RMP_Cur_Thd->State&=~((1<<8)<<1);
N        }
N    }
N    
N    RMP_Unlock_Sched();
N    return RMP_Cur_Thd->Retval;
N}
N/* End Function:RMP_Thd_Rcv **************************************************/
N
N/* Begin Function:RMP_Thd_Delay ***********************************************
NDescription : Delay the execution of a real-time thread.
NInput       : rmp_ptr_t Slices - The number of timeslices to delay.
NOutput      : None.
NReturn      : rmp_ret_t - If successful, 0; or an error code.
N******************************************************************************/
Nrmp_ret_t RMP_Thd_Delay(rmp_ptr_t Slices)
N{
N    if((Slices==0)||(Slices>=RMP_MAX_SLICES))
X    if((Slices==0)||(Slices>=100000))
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        return RMP_ERR_SLICE;
X        return (-3);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    RMP_Lock_Sched();
N
N    /* We must be running and not suspended so we will be out of running queue */
N    _RMP_Clr_Rdy(RMP_Cur_Thd);
N    RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_DELAYED);
X    ((RMP_Cur_Thd->State)=(((RMP_Cur_Thd->State)&~0xFF)|((6))));
N    _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
N
N    RMP_Cur_Thd->Retval=0;
N    RMP_Unlock_Sched();
N    /* Need to return if successful or not */
N    return RMP_Cur_Thd->Retval;
N}
N/* End Function:RMP_Thd_Delay ************************************************/
N
N/* Begin Function:RMP_Thd_Cancel **********************************************
NDescription : Cancel the real-time thread from a previous delay.
NInput       : volatile struct RMP_Thd* Thread - The thread structure of the thread.
NOutput      : None.
NReturn      : rmp_ret_t - If successful, 0; or an error code.
N******************************************************************************/
Nrmp_ret_t RMP_Thd_Cancel(volatile struct RMP_Thd* Thread)
N{
N    /* Check if this thread structure could possibly be in use */
N    if(Thread==0)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        return RMP_ERR_THD;
X        return (-1);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    RMP_Lock_Sched();
N    
N    /* Is it delayed? */
N    if(RMP_THD_STATE(Thread->State)!=RMP_THD_DELAYED)
X    if(((Thread->State)&0xFF)!=(6))
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        RMP_Unlock_Sched();
N        return RMP_ERR_STATE;
X        return (-4);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N
N    /* Delete it from the delay list */
N    RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
N    RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
X    ((Thread->State)=(((Thread->State)&~0xFF)|((1))));
N    /* Set to running if not suspended */
N    _RMP_Set_Rdy(Thread);
N    
N    Thread->Retval=RMP_ERR_OPER;
X    Thread->Retval=(-5);
N    RMP_Unlock_Sched();
N    return 0;
N}
N/* End Function:RMP_Thd_Cancel ***********************************************/
N
N/* Begin Function:RMP_Sem_Crt *************************************************
NDescription : Create a semaphore in the system.
NInput       : volatile struct RMP_Sem* Semaphore - The pointer to the semaphore structure.
N              rmp_ptr_t Number - The initial number of this semaphore.
NOutput      : None.
NReturn      : rmp_ret_t - If successful, 0; or an error code.
N******************************************************************************/
Nrmp_ret_t RMP_Sem_Crt(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Number)
N{
N    /* Check if this semaphore structure could possibly be in use */
N    if(Semaphore==0)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        return RMP_ERR_SEM;
X        return (-6);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    RMP_Lock_Sched();
N    
N    if(Semaphore->State!=RMP_SEM_FREE)
X    if(Semaphore->State!=(0))
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        RMP_Unlock_Sched();
N        return RMP_ERR_SEM;
X        return (-6);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    /* Is the number too great to initialize? */
N    if(Number>=RMP_SEM_MAX_NUM)
X    if(Number>=1000)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        RMP_Unlock_Sched();
N        return RMP_ERR_OPER;
X        return (-5);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N
N    /* Initialize contents */
N    Semaphore->Cur_Num=Number;
N    Semaphore->State=RMP_SEM_USED;
X    Semaphore->State=(1);
N    RMP_List_Crt(&(Semaphore->Wait_List));
N    
N    RMP_Unlock_Sched();
N    
N    return 0;
N}
N/* End Function:RMP_Sem_Crt **************************************************/
N
N/* Begin Function:RMP_Sem_Del *************************************************
NDescription : Delete a semaphore in the system.
NInput       : volatile struct RMP_Sem* Semaphore - The pointer to the semaphore structure.
NOutput      : None.
NReturn      : rmp_ret_t - If successful, 0; or an error code.
N******************************************************************************/
Nrmp_ret_t RMP_Sem_Del(volatile struct RMP_Sem* Semaphore)
N{
N    struct RMP_Thd* Thread;
N    
N    /* Check if this semaphore structure could possibly be in use */
N    if(Semaphore==0)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        return RMP_ERR_SEM;
X        return (-6);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    RMP_Lock_Sched();
N    
N    if(Semaphore->State!=RMP_SEM_USED)
X    if(Semaphore->State!=(1))
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        RMP_Unlock_Sched();
N        return RMP_ERR_SEM;
X        return (-6);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N
N    /* Get rid of all guys waiting on it */
N    while(&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)
N    {
N        Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
N        RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
N        
N        if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
X        if(((Thread->State)&0xFF)==(8))
N        {
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N            RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
N        }
N        else
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N
N        RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
X        ((Thread->State)=(((Thread->State)&~0xFF)|((1))));
N        /* Set to running if not suspended */
N        _RMP_Set_Rdy(Thread);
N        Thread->Retval=RMP_ERR_OPER;
X        Thread->Retval=(-5);
N    }
N    Semaphore->State=RMP_SEM_FREE;
X    Semaphore->State=(0);
N    
N    RMP_Unlock_Sched();
N
N    return 0;
N}
N/* End Function:RMP_Sem_Del **************************************************/
N
N/* Begin Function:RMP_Sem_Pend ************************************************
NDescription : Pend on the semaphore, trying to get one.
NInput       : volatile struct RMP_Sem* Semaphore - The pointer to the semaphore structure.
N              rmp_ptr_t Slices - The number of slices to wait.
NOutput      : None.
NReturn      : rmp_ret_t - If successful, the current semaphore number; or an error code.
N******************************************************************************/
Nrmp_ret_t RMP_Sem_Pend(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Slices)
N{
N    /* Check if this semaphore structure could possibly be in use */
N    if(Semaphore==0)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        return RMP_ERR_SEM;
X        return (-6);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    RMP_Lock_Sched();
N    
N    if(Semaphore->State!=RMP_SEM_USED)
X    if(Semaphore->State!=(1))
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        RMP_Unlock_Sched();
N        return RMP_ERR_SEM;
X        return (-6);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    /* Check if we can get one immediately */
N    if(Semaphore->Cur_Num!=0)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        Semaphore->Cur_Num--;
N        RMP_Unlock_Sched();
N        return Semaphore->Cur_Num;
N    }
N    else
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        /* Cannot get one, we need to block */
N        if(Slices==0)
N        {
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N            RMP_Unlock_Sched();
N            return RMP_ERR_OPER;
X            return (-5);
N        }
N        else
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N
N        /* We must be running - place into waitlist now */
N        _RMP_Clr_Rdy(RMP_Cur_Thd);
N        RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),Semaphore->Wait_List.Prev,&(Semaphore->Wait_List));
N        
N        if(Slices<RMP_MAX_SLICES)
X        if(Slices<100000)
N        {
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N            _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
N            RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SEMDLY);
X            ((RMP_Cur_Thd->State)=(((RMP_Cur_Thd->State)&~0xFF)|((8))));
N        }
N        else
N        {
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N            RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SEMBLK);
X            ((RMP_Cur_Thd->State)=(((RMP_Cur_Thd->State)&~0xFF)|((7))));
N        }
N        
N        RMP_Cur_Thd->Retval=0;
N    }
N    
N    RMP_Unlock_Sched();
N
N    return RMP_Cur_Thd->Retval;
N}
N/* End Function:RMP_Sem_Pend *************************************************/
N
N/* Begin Function:RMP_Sem_Abort ***********************************************
NDescription : Abort the waiting of one thread on a semaphore.
NInput       : volatile struct RMP_Thd* Thread - The thread structure of the thread.
NOutput      : None.
NReturn      : rmp_ret_t - If successful, 0; or an error code.
N******************************************************************************/
Nrmp_ret_t RMP_Sem_Abort(volatile struct RMP_Thd* Thread)
N{
N    /* Check if this thread structure could possibly be in use */
N    if(Thread==0)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        return RMP_ERR_THD;
X        return (-1);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N
N    RMP_Lock_Sched();
N    
N    if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
X    if(((Thread->State)&0xFF)==(0))
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        RMP_Unlock_Sched();
N        return RMP_ERR_THD;
X        return (-1);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    /* Is it waiting on a semaphore? If no, we abort and return an error code */
N    if((RMP_THD_STATE(Thread->State)!=RMP_THD_SEMBLK)&&
X    if((((Thread->State)&0xFF)!=(7))&&
N       (RMP_THD_STATE(Thread->State)!=RMP_THD_SEMDLY))
X       (((Thread->State)&0xFF)!=(8)))
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        RMP_Unlock_Sched();
N        return RMP_ERR_STATE;
X        return (-4);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N
N    /* Waiting for a semaphore. We abort it and return */
N    RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
N    if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
X    if(((Thread->State)&0xFF)==(8))
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
X    ((Thread->State)=(((Thread->State)&~0xFF)|((1))));
N    /* Set to running if not suspended */
N    _RMP_Set_Rdy(Thread);
N    
N    Thread->Retval=RMP_ERR_OPER;
X    Thread->Retval=(-5);
N    RMP_Unlock_Sched();
N    return 0;
N}
N/* End Function:RMP_Sem_Abort ************************************************/
N
N/* Begin Function:RMP_Sem_Post ************************************************
NDescription : Post a number of semaphores to the list.
NInput       : volatile struct RMP_Sem* Semaphore - The pointer to the semaphore structure.
N              rmp_ptr_t Number - The number to post.
NOutput      : None.
NReturn      : rmp_ret_t - If successful, 0; or an error code.
N******************************************************************************/
Nrmp_ret_t RMP_Sem_Post(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Number)
N{
N    struct RMP_Thd* Thread;
N    
N    /* Check if this semaphore structure could possibly be in use */
N    if((Semaphore==0)||(Number==0))
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        return RMP_ERR_SEM;
X        return (-6);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    RMP_Lock_Sched();
N    
N    if(Semaphore->State!=RMP_SEM_USED)
X    if(Semaphore->State!=(1))
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        RMP_Unlock_Sched();
N        return RMP_ERR_SEM;
X        return (-6);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    /* Would the maximum value be exceeded if this is posted? */
N    if((Semaphore->Cur_Num+Number)>=RMP_SEM_MAX_NUM)
X    if((Semaphore->Cur_Num+Number)>=1000)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        RMP_Unlock_Sched();
N        return RMP_ERR_OPER;
X        return (-5);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    Semaphore->Cur_Num+=Number;
N    /* Is there any thread waiting on it? If there are, clean them up*/
N    while((&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)&&(Semaphore->Cur_Num!=0))
N    {
N        Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
N        RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
N        
N        if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
X        if(((Thread->State)&0xFF)==(8))
N        {
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N            RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
N        }
N        else
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N        
N        RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
X        ((Thread->State)=(((Thread->State)&~0xFF)|((1))));
N        /* Set to running if not suspended */
N        _RMP_Set_Rdy(Thread);
N
N        /* Finally, return success */
N        Thread->Retval=0;
N        Semaphore->Cur_Num--;
N    }
N
N    RMP_Unlock_Sched();
N    return 0;
N}
N/* End Function:RMP_Sem_Post *************************************************/
N
N/* Begin Function:RMP_Sem_Post_ISR ********************************************
NDescription : Post a number of semaphores to the list.
N              We do not check whether the scheduler is locked; if we are calling this
N              function, we're pretty sure that it's not.
NInput       : volatile struct RMP_Sem* Semaphore - The pointer to the semaphore structure.
N              rmp_ptr_t Number - The number to post.
NOutput      : None.
NReturn      : rmp_ret_t - If successful, 0; or an error code.
N******************************************************************************/
Nrmp_ret_t RMP_Sem_Post_ISR(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Number)
N{
N    struct RMP_Thd* Thread;
N    /* Check if this semaphore structure could possibly be in use */
N    if((Semaphore==0)||(Number==0))
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        return RMP_ERR_SEM;
X        return (-6);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    if(Semaphore->State!=RMP_SEM_USED)
X    if(Semaphore->State!=(1))
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        return RMP_ERR_SEM;
X        return (-6);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N
N    /* Would the maximum value be exceeded if this is posted? */
N    if((Semaphore->Cur_Num+Number)>=RMP_SEM_MAX_NUM)
X    if((Semaphore->Cur_Num+Number)>=1000)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        return RMP_ERR_OPER;
X        return (-5);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    Semaphore->Cur_Num+=Number;
N    /* Is there any thread waiting on it? If there are, clean them up*/
N    while((&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)&&(Semaphore->Cur_Num!=0))
N    {
N        Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
N        RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
N        if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
X        if(((Thread->State)&0xFF)==(8))
N        {
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N            RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
N        }
N        else
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N        
N        RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
X        ((Thread->State)=(((Thread->State)&~0xFF)|((1))));
N        /* Set to running if not suspended */
N        _RMP_Set_Rdy(Thread);
N        
N        /* If schedule pending, trigger it now because we are in ISR */
N        if(RMP_Sched_Pend!=0)
N        {
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N            RMP_Sched_Pend=0;
N            _RMP_Yield();   
N        }
N        else
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N
N        /* Finally, return success */
N        Thread->Retval=0;
N        Semaphore->Cur_Num--;
N    }
N
N    return 0;
N}
N/* End Function:RMP_Sem_Post_ISR *********************************************/
N
N/* Begin Function:RMP_Save_Ctx ************************************************
NDescription : Save hook for extra context, such as FPU, peripherals and MPU.
NInput       : None.
NOutput      : None.
NReturn      : None.
N******************************************************************************/
N#if(RMP_USE_HOOKS==RMP_FALSE)
X#if(0==0)
Nvoid RMP_Save_Ctx(void)
N{
N    return;
N}
N#endif
N/* End Function:RMP_Save_Ctx *************************************************/
N
N/* Begin Function:RMP_Load_Ctx ************************************************
NDescription : Load hook for extra context, such as FPU, peripherals and MPU.
NInput       : None.
NOutput      : None.
NReturn      : None.
N******************************************************************************/
N#if(RMP_USE_HOOKS==RMP_FALSE)
X#if(0==0)
Nvoid RMP_Load_Ctx(void)
N{
N    return;
N}
N#endif
N/* End Function:RMP_Load_Ctx *************************************************/
N
N/* Begin Function:RMP_Init ****************************************************
NDescription : The entry of the user thread. This is the first user thread that
N              will be created.
N              The user threads should never return.
NInput       : None.
NOutput      : None.
NReturn      : int - This function never returns.
N******************************************************************************/
Nvoid RMP_Init(void)
N{
N    RMP_Lock_Sched();
N    
N    /* Platform will use this hook to do something */
N    _RMP_Plat_Hook();
N    /* Start the second thread here */
N    RMP_Init_Hook();
N    
N    RMP_Unlock_Sched();
N    
N    while(1)
N        RMP_Init_Idle();
N}
N/* End Function:RMP_Init *****************************************************/
N
N/* Begin Function:main ********************************************************
NDescription : The entry of the operating system. This function is for 
N              compatibility with the toolchains.
NInput       : None.
NOutput      : None.
NReturn      : int - This function never returns.
N******************************************************************************/
Nint main(void)
N{
N    rmp_ptr_t Count;
N    
N#ifdef RMP_COVERAGE
S    /* Initialize coverage markers if coverage enabled */
S    for(Count=0;Count<RMP_COVERAGE_LINES;Count++)
S        RMP_Coverage[Count]=0;
N#endif
N    
N    /* Initialize the kernel data structures first */
N    _RMP_Low_Level_Init();
N    
N#if(RMP_USE_HOOKS==RMP_TRUE)
X#if(0==1)
S    RMP_Start_Hook();
N#endif
N    
N    RMP_Tick=0;
N    /* Now initialize the kernel data structures */
N    RMP_Sched_Lock_Cnt=0;
N    RMP_Sched_Locked=0;
N    RMP_Sched_Pend=0;
N    RMP_Timer_Pend=0;
N    
N    /* Linked lists */
N    RMP_List_Crt(&RMP_Delay);
N    for(Count=0;Count<RMP_MAX_PREEMPT_PRIO;Count++)
X    for(Count=0;Count<32;Count++)
N        RMP_List_Crt(&RMP_Run[Count]);
N    for(Count=0;Count<RMP_BITMAP_SIZE;Count++)
X    for(Count=0;Count<((32-1)/(((rmp_ptr_t)1)<<(5))+1);Count++)
N        RMP_Bitmap[Count]=0;
N        
N    /* Now boot into the first thread */
N    RMP_Clear(&RMP_Init_Thd,sizeof(struct RMP_Thd));
N    RMP_Init_Thd.Prio=0;
N    RMP_Init_Thd.Slices=10;
N    RMP_Init_Thd.Slices_Left=10;
N    RMP_Init_Thd.State=RMP_THD_RUNNING;
X    RMP_Init_Thd.State=(1);
N    RMP_Init_Thd.Stack=RMP_INIT_STACK;
X    RMP_Init_Thd.Stack=(((rmp_ptr_t)RMP_Init_Stack)+256-(17)*sizeof(rmp_ptr_t));
N    
N    /* Initialize sending list */
N    RMP_List_Crt(&(RMP_Init_Thd.Snd_List));
N    
N    /* Insert this into the corresponding runqueue */
N    RMP_List_Ins(&(RMP_Init_Thd.Run_Head),RMP_Run[0].Prev,&(RMP_Run[0]));
N    /* Set this runlevel as active - in fact it is always active */
N    RMP_Bitmap[0]|=1;
N    
N    /* Set current thread and stack */
N    RMP_Cur_Thd=(struct RMP_Thd*)(&RMP_Init_Thd);
N    RMP_Cur_SP=RMP_Init_Thd.Stack;
N    
N    /* Now jump to the user function and will never return. Initialization of stack is not needed */
N    _RMP_Start((rmp_ptr_t)RMP_Init, (rmp_ptr_t)RMP_Init_Thd.Stack);
N    
N    return 0;
N}
N/* End Function:main *********************************************************/
N
N/* Begin Function:RMP_RBIT_Get ************************************************
NDescription : Reverse the bit order in a word.
NInput       : rmp_ptr_t Val - The input value.
NOutput      : None.
NReturn      : rmp_ptr_t - The result.
N******************************************************************************/
Nstatic const rmp_u8_t RMP_RBIT_Table[256]=
N{
N    0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0, 0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0,
N    0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8, 0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8,
N    0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4, 0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4,
N    0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC, 0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC,
N    0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2, 0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2,
N    0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA, 0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,
N    0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6, 0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6,
N    0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE, 0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,
N    0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1, 0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1,
N    0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9, 0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9,
N    0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5, 0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5,
N    0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED, 0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,
N    0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3, 0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3,
N    0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB, 0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,
N    0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7, 0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7,
N    0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF, 0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF
N};
N
Nrmp_ptr_t RMP_RBIT_Get(rmp_ptr_t Val)
N{
N    rmp_ptr_t Ret;
N    rmp_ptr_t Src;
N    rmp_u8_t* To;
N    rmp_u8_t* From;
N    
N    Src=Val;
N    To=(rmp_u8_t*)(&Ret);
N    From=(rmp_u8_t*)(&Src);
N    
N#if(RMP_WORD_ORDER==4)
X#if(5==4)
S    To[0]=RMP_RBIT_Table[From[1]];
S    To[1]=RMP_RBIT_Table[From[0]];
N#elif(RMP_WORD_ORDER==5)
X#elif(5==5)
N    To[0]=RMP_RBIT_Table[From[3]];
N    To[1]=RMP_RBIT_Table[From[2]];
N    To[2]=RMP_RBIT_Table[From[1]];
N    To[3]=RMP_RBIT_Table[From[0]];
N#else
S    To[0]=RMP_RBIT_Table[From[7]];
S    To[1]=RMP_RBIT_Table[From[6]];
S    To[2]=RMP_RBIT_Table[From[5]];
S    To[3]=RMP_RBIT_Table[From[4]];
S    To[4]=RMP_RBIT_Table[From[3]];
S    To[5]=RMP_RBIT_Table[From[2]];
S    To[6]=RMP_RBIT_Table[From[1]];
S    To[7]=RMP_RBIT_Table[From[0]];
N#endif
N
N    return Ret;
N}
N/* End Function:RMP_RBIT_Get *************************************************/
N
N/* Begin Function:RMP_LSB_Get *************************************************
NDescription : Get the LSB in a word. If the word is all zero, a value that is 
N              equal to the processor word size will be returned.
NInput       : rmp_ptr_t Val - The input value.
NOutput      : None.
NReturn      : rmp_ptr_t - The LSB found.
N******************************************************************************/
Nrmp_ptr_t RMP_LSB_Get(rmp_ptr_t Val)
N{
N    return RMP_WORD_SIZE-1-RMP_MSB_Get(RMP_RBIT_Get(Val));
X    return (((rmp_ptr_t)1)<<(5))-1-RMP_MSB_Get(RMP_RBIT_Get(Val));
N}
N/* End Function:RMP_LSB_Get **************************************************/
N
N/* Begin Function:RMP_Mem_Init ************************************************
NDescription : Initialize a trunk of memory as the memory pool. The TLSF allocator's
N              FLI will be decided upon the memory block size. Memory allocation does
N              not lock the scheduler by itself; it is up to you to decide whether a
N              scheduler lock is needed.
N              The TLSF memory allocator consists of FLI, SLI and allocatable memory. 
N              The FLI is grouped by 2^n, and the SLI segregates the FLI section by a
N              power of 2, i.e. 8 or 16. Thus, when we need a memory block, we will 
N              try to find it in the corresponding FLI, and then the SLI. (You can 
N              consider the FLI-SLI segregation as a two-dimensional matrix.) Then 
N              (1) If the SLI has no allocatable blocks, we will allocate some
N                  from the nearest bigger block.
N              (2) If there is some block from the SLI block, allocate the memory
N                  size and put the residue memory into the corresponding FLI and
N                  SLI area.
N              When freeing memory, the adjacent free memory blocks will automatically
N              merge.
N              In the system, the FLI is variable and the SLI is fixed to 8.
N              The FLI has a miniumum block size of 64 Byte(If the allocated size
N              is always smaller than 64 bits, then there's no need to use DSA.)
N              To make sure that it is like this, we set the smallest allocatable
N              size to 64B. In addition, we set the alignment to 8.
N              [FLI]:
N              .....    6       5      4       3         2        1         0
N                     8K-4K   4K-2K  2K-1K  1K-512B  511-256B  255-128B  127-64B
N              For example, when a memory block is 720 byte, then it should be in
N              FLI=3,SLI=3.
N              When a lower FLI has no blocks for allocation, it will "borrow"
N              a block from the nearest FLI block that is big enough.
NInput       : volatile void* Pool - The start address of the memory pool, word-aligned.
N              rmp_ptr_t Size - The size of the memory pool, word-aligned. Must be 
N                               more than 1024 machine words, or pool creation will not
N                               be successful.
NOutput      : None.
NReturn      : rmp_ret_t - If successful, 0; else an error code.
N******************************************************************************/
Nrmp_ret_t RMP_Mem_Init(volatile void* Pool, rmp_ptr_t Size)
N{
N    rmp_cnt_t FLI_Cnt;
N    rmp_ptr_t Offset;
N    rmp_ptr_t Bitmap_Size;
N    volatile struct RMP_Mem* Mem;
N    
N    /* See if the memory pool is large enough to enable dynamic allocation - at
N     * least 1024 machine words or pool initialization will be refused */
N    if((Pool==0)||(Size<(1024*sizeof(rmp_ptr_t)))||((((rmp_ptr_t)Pool)+Size)<Size))
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        return RMP_ERR_MEM;
X        return (-7);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    /* See if the address and size is word-aligned */
N    if(((((rmp_ptr_t)Pool)&RMP_ALIGN_MASK)!=0)||((Size&RMP_ALIGN_MASK)!=0))
X    if(((((rmp_ptr_t)Pool)&(~(((rmp_ptr_t)(-1))<<(5-3))))!=0)||((Size&(~(((rmp_ptr_t)(-1))<<(5-3))))!=0))
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        return RMP_ERR_MEM;
X        return (-7);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N
N    Mem=(volatile struct RMP_Mem*)Pool;
N    Mem->Size=Size;
N    /* Calculate the FLI value needed for this - we always align to 64 byte */
N    Mem->FLI_Num=RMP_MSB_Get(Size-sizeof(struct RMP_Mem))-6+1;
N    
N    /* Decide the location of the bitmap */
N    Offset=sizeof(struct RMP_Mem);
N    Bitmap_Size=RMP_ROUND_UP(Mem->FLI_Num,RMP_ALIGN_ORDER);
X    Bitmap_Size=((((Mem->FLI_Num)+(((rmp_ptr_t)1)<<((5-3)))-1)>>((5-3)))<<((5-3)));
N    /* Initialize the bitmap */
N    for(FLI_Cnt=0;FLI_Cnt<(rmp_cnt_t)(Bitmap_Size>>RMP_ALIGN_ORDER);FLI_Cnt++)
X    for(FLI_Cnt=0;FLI_Cnt<(rmp_cnt_t)(Bitmap_Size>>(5-3));FLI_Cnt++)
N        Mem->Bitmap[FLI_Cnt]=0;
N    
N    /* Decide the location of the allocation table - "-sizeof(rmp_ptr_t)" is
N     * because we defined the length=1 in our struct already */
N    Offset+=Bitmap_Size-sizeof(rmp_ptr_t);
N    Mem->Table=(struct RMP_List*)(((rmp_ptr_t)Mem)+Offset);
N    /* Initialize the allocation table */
N    for(FLI_Cnt=0;FLI_Cnt<(rmp_cnt_t)(Mem->FLI_Num);FLI_Cnt++)
N    {
N        RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,0)]));
X        RMP_List_Crt(&(Mem->Table[((0)+((FLI_Cnt)<<3))]));
N        RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,1)]));
X        RMP_List_Crt(&(Mem->Table[((1)+((FLI_Cnt)<<3))]));
N        RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,2)]));
X        RMP_List_Crt(&(Mem->Table[((2)+((FLI_Cnt)<<3))]));
N        RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,3)]));
X        RMP_List_Crt(&(Mem->Table[((3)+((FLI_Cnt)<<3))]));
N        RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,4)]));
X        RMP_List_Crt(&(Mem->Table[((4)+((FLI_Cnt)<<3))]));
N        RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,5)]));
X        RMP_List_Crt(&(Mem->Table[((5)+((FLI_Cnt)<<3))]));
N        RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,6)]));
X        RMP_List_Crt(&(Mem->Table[((6)+((FLI_Cnt)<<3))]));
N        RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,7)]));
X        RMP_List_Crt(&(Mem->Table[((7)+((FLI_Cnt)<<3))]));
N    }
N    
N    /* Calculate the offset of the actual allocatable memory - each FLI have
N     * 8 SLIs, and each SLI has a corresponding table header */
N    Offset+=sizeof(struct RMP_List)*8*Mem->FLI_Num;
N    Mem->Start=((rmp_ptr_t)Mem)+Offset;
N    
N    /* Initialize the first big block */
N    _RMP_Mem_Block((struct RMP_Mem_Head*)(Mem->Start),Size-Offset);
N    /* Insert the memory into the corresponding level */
N    _RMP_Mem_Ins(Pool,(struct RMP_Mem_Head*)(Mem->Start));
N    
N    return 0;
N}
N/* End Function:RMP_Mem_Init *************************************************/
N
N/* Begin Function:_RMP_Mem_Block **********************************************
NDescription : Make a memory block from the memory trunk. The memory block is always
N              free when created. No parameter check performed here.
NInput       : volatile struct RMP_Mem_Head* Addr - The start address of the
N                                                   memory block, word-aligned.
N              rmp_ptr_t Size - The size of the memory block, word-aligned.
NOutput      : None.
NReturn      : None.
N******************************************************************************/
Nvoid _RMP_Mem_Block(volatile struct RMP_Mem_Head* Addr, rmp_ptr_t Size)
N{
N    volatile struct RMP_Mem_Head* Mem_Head;
N    
N    /* Get the big memory block's size and position */
N    Mem_Head=(struct RMP_Mem_Head*)Addr;
N    
N    /* Initialize the big memory block */
N    Mem_Head->State=RMP_MEM_FREE;
X    Mem_Head->State=(0);
N    Mem_Head->Tail=(struct RMP_Mem_Tail*)(((rmp_ptr_t)Mem_Head)+Size-sizeof(struct RMP_Mem_Tail));
N    Mem_Head->Tail->Head=Mem_Head;
N}
N/* End Function:_RMP_Mem_Block ***********************************************/
N
N/* Begin Function:_RMP_Mem_Ins ************************************************
NDescription : The memory insertion function, to insert a certain memory block
N              into the corresponding FLI and SLI slot.
NInput       : volatile void* Pool - The memory pool.
N              volatile struct RMP_Mem_Head* Mem_Head - The pointer to the memory block.
NOutput      : None.
NReturn      : None.
N******************************************************************************/
Nvoid _RMP_Mem_Ins(volatile void* Pool, volatile struct RMP_Mem_Head* Mem_Head)
N{
N    rmp_ptr_t FLI_Level;
N    rmp_ptr_t SLI_Level;
N    rmp_ptr_t Level;
N    rmp_ptr_t Size;
N    volatile struct RMP_Mem* Mem;
N    volatile struct RMP_List* Slot;
N    
N    /* Get the memory pool and block size */
N    Mem=(volatile struct RMP_Mem*)Pool;
N    Size=(rmp_ptr_t)(Mem_Head->Tail)-((rmp_ptr_t)Mem_Head)-sizeof(struct RMP_Mem_Head);
N
N    /* Guarantee the Mem_Size is bigger than 64 or a failure will surely occur here */
N    FLI_Level=RMP_MSB_Get(Size)-6;
N    /* Decide the SLI level directly from the FLI level */
N    SLI_Level=(Size>>(FLI_Level+3))&0x07;
N    /* Calculate the bit position */
N    Level=RMP_MEM_POS(FLI_Level,SLI_Level);
X    Level=((SLI_Level)+((FLI_Level)<<3));
N    /* Get the slot */
N    Slot=&(Mem->Table[Level]);
N
N    /* See if there are any blocks in the level, equal means no. So what we inserted is the first block */
N    if(Slot==Slot->Next)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        /* Set the corresponding bit in the TLSF bitmap */
N        Mem->Bitmap[Level>>RMP_WORD_ORDER]|=RMP_POW2(Level&RMP_WORD_MASK);
X        Mem->Bitmap[Level>>5]|=(((rmp_ptr_t)1)<<(Level&(~(((rmp_ptr_t)(-1))<<5))));
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N
N    /* Insert the node now */
N    RMP_List_Ins(&(Mem_Head->Head), Slot, Slot->Next);
N}
N/* End Function:_RMP_Mem_Ins *************************************************/
N
N/* Begin Function:_RMP_Mem_Del ************************************************
NDescription : The memory deletion function, to delete a certain memory block
N              from the corresponding FLI and SLI class.
NInput       : volatile void* Pool - The memory pool.
N              volatile struct RMP_Mem_Head* Mem_Head - The pointer to the memory block.
NOutput      : None.
NReturn      : None.
N******************************************************************************/
Nvoid _RMP_Mem_Del(volatile void* Pool, volatile struct RMP_Mem_Head* Mem_Head)
N{
N    rmp_ptr_t FLI_Level;
N    rmp_ptr_t SLI_Level;
N    rmp_ptr_t Level;
N    rmp_ptr_t Size;
N    volatile struct RMP_Mem* Mem;
N    volatile struct RMP_List* Slot;    
N    
N    /* Get the memory pool and block size */
N    Mem=(volatile struct RMP_Mem*)Pool;
N    Size=(rmp_ptr_t)(Mem_Head->Tail)-((rmp_ptr_t)Mem_Head)-sizeof(struct RMP_Mem_Head);
N    
N    /* Guarantee the Mem_Size is bigger than 64 or a failure will surely occur here */
N    FLI_Level=RMP_MSB_Get(Size)-6;
N    /* Decide the SLI level directly from the FLI level */
N    SLI_Level=(Size>>(FLI_Level+3))&0x07;
N    /* Calculate the bit position */
N    Level=RMP_MEM_POS(FLI_Level,SLI_Level);
X    Level=((SLI_Level)+((FLI_Level)<<3));
N    /* Get the slot */
N    Slot=&(Mem->Table[Level]);
N
N    /* Delete the node now */
N    RMP_List_Del(Mem_Head->Head.Prev,Mem_Head->Head.Next);
N
N    /* See if there are any blocks in the level, equal means no. So
N     * what we deleted is the last blockm need to clear the flag */
N    if(Slot==Slot->Next)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        /* Clear the corresponding bit in the TLSF bitmap */
N        Mem->Bitmap[Level>>RMP_WORD_ORDER]&=~RMP_POW2(Level&RMP_WORD_MASK);
X        Mem->Bitmap[Level>>5]&=~(((rmp_ptr_t)1)<<(Level&(~(((rmp_ptr_t)(-1))<<5))));
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N}
N/* End Function:_RMP_Mem_Del *************************************************/
N
N/* Begin Function:_RMP_Mem_Search *********************************************
NDescription : The TLSF memory searcher.
NInput       : rmp_ptr_t Size - The memory size, must be bigger than 64. This must be
N                               guaranteed before calling this function or an error
N                               will unavoidably occur.
NOutput      : rmp_cnt_t* FLI_Level - The FLI level found.
N              rmp_cnt_t* SLI_Level - The SLI level found.
NReturn      : rmp_ret_t - If successful, 0; else -1 for failure.
N******************************************************************************/
Nrmp_ret_t _RMP_Mem_Search(volatile void* Pool, rmp_ptr_t Size, rmp_cnt_t* FLI_Level, rmp_cnt_t* SLI_Level)
N{
N    rmp_ptr_t FLI_Level_Temp;
N    rmp_ptr_t SLI_Level_Temp;
N    rmp_cnt_t Level;
N    rmp_cnt_t Word;
N    rmp_cnt_t Limit;
N    rmp_ptr_t LSB;
N    volatile struct RMP_Mem* Mem;
N
N    /* Make sure that it is bigger than 64. 64=2^6 */
N    FLI_Level_Temp=RMP_MSB_Get(Size)-6;
N    
N    /* Decide the SLI level directly from the FLI level. We plus the number by one here
N     * so that we can avoid the list search. However, when the allocated memory is just
N     * one of the levels, then we don't need to jump to the next level and can fit directly */
N    SLI_Level_Temp=(Size>>(FLI_Level_Temp+3))&0x07;
N    if(Size!=(RMP_POW2(FLI_Level_Temp+3)*(SLI_Level_Temp+8)))
X    if(Size!=((((rmp_ptr_t)1)<<(FLI_Level_Temp+3))*(SLI_Level_Temp+8)))
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        SLI_Level_Temp++;
N        
N        /* If the SLI level is the largest of the SLI level, then jump to the next FLI level */
N        if(SLI_Level_Temp==8)
N        {
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N            FLI_Level_Temp+=1;
N            SLI_Level_Temp=0;
N        }
N        else
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    /* Check if the FLI level is over the boundary */
N    Mem=(volatile struct RMP_Mem*)Pool;
N    if(FLI_Level_Temp>=Mem->FLI_Num)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        return -1;
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    /* Try to find one position on this processor word level */
N    Level=RMP_MEM_POS(FLI_Level_Temp,SLI_Level_Temp);
X    Level=((SLI_Level_Temp)+((FLI_Level_Temp)<<3));
N    LSB=RMP_LSB_Get(Mem->Bitmap[Level>>RMP_WORD_ORDER]>>(Level&RMP_WORD_MASK));
X    LSB=RMP_LSB_Get(Mem->Bitmap[Level>>5]>>(Level&(~(((rmp_ptr_t)(-1))<<5))));
N    /* If there's at least one block that matches the query, return the level */
N    if(LSB<RMP_WORD_SIZE)
X    if(LSB<(((rmp_ptr_t)1)<<(5)))
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        Level=(Level&(~RMP_WORD_MASK))+LSB+(Level&RMP_WORD_MASK);
X        Level=(Level&(~(~(((rmp_ptr_t)(-1))<<5))))+LSB+(Level&(~(((rmp_ptr_t)(-1))<<5)));
N        *FLI_Level=Level>>3;
N        *SLI_Level=Level&0x07;
N        return 0;
N    }
N    /* No one exactly fits */
N    else
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        Limit=RMP_ROUND_UP(Mem->FLI_Num,RMP_ALIGN_ORDER)>>RMP_ALIGN_ORDER;
X        Limit=((((Mem->FLI_Num)+(((rmp_ptr_t)1)<<((5-3)))-1)>>((5-3)))<<((5-3)))>>(5-3);
N        /* From the next word, query one by one */
N        for(Word=(Level>>RMP_WORD_ORDER)+1;Word<Limit;Word++)
X        for(Word=(Level>>5)+1;Word<Limit;Word++)
N        {
N            /* If the level has blocks of one FLI level */
N            if(Mem->Bitmap[Word]!=0)
N            {
N                RMP_COVERAGE_MARKER();
X                do { } while(0);
N                /* Find the actual level */ 
N                LSB=RMP_LSB_Get(Mem->Bitmap[Word]);
N                *FLI_Level=((Word<<RMP_WORD_ORDER)+LSB)>>3;
X                *FLI_Level=((Word<<5)+LSB)>>3;
N                *SLI_Level=LSB&0x07;
N                return 0;
N            }
N            else
N                RMP_COVERAGE_MARKER();
X                do { } while(0);
N        }
N    }
N
N    /* Search failed */
N    return -1;
N}
N/* End Function:_RMP_Mem_Search **********************************************/
N
N/* Begin Function:RMP_Malloc **************************************************
NDescription : Allocate some memory from a designated memory pool.
NInput       : volatile void* Pool - The pool to allocate from.
N              rmp_ptr_t Size - The size of the RAM needed to allocate.
NOutput      : None.
NReturn      : void* - The pointer to the memory. If no memory available, 0 is returned.
N******************************************************************************/
Nvoid* RMP_Malloc(volatile void* Pool, rmp_ptr_t Size)
N{    
N    rmp_cnt_t FLI_Level;
N    rmp_cnt_t SLI_Level;
N    volatile struct RMP_Mem* Mem;
N    rmp_ptr_t Old_Size;
N    volatile struct RMP_Mem_Head* Mem_Head;
N    rmp_ptr_t Rounded_Size;
N    volatile struct RMP_Mem_Head* New_Mem;
N    rmp_ptr_t New_Size;
N    
N    if((Pool==0)||(Size==0))
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        return (void*)(0);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    /* Round up the size:a multiple of 8 and bigger than 64B */
N    Rounded_Size=RMP_ROUND_UP(Size,3);
X    Rounded_Size=((((Size)+(((rmp_ptr_t)1)<<(3))-1)>>(3))<<(3));
N    /* See if it is smaller than the smallest block */
N    Rounded_Size=(Rounded_Size>64)?Rounded_Size:64;
N
N    /* See if such block exists, if not, abort */
N    if(_RMP_Mem_Search(Pool,Rounded_Size,&FLI_Level,&SLI_Level)!=0)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        return (void*)(0);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    Mem=(volatile struct RMP_Mem*)Pool;
N    
N    /* There is such block. Get it and delete it from the TLSF list. */
N    Mem_Head=(struct RMP_Mem_Head*)(Mem->Table[RMP_MEM_POS(FLI_Level,SLI_Level)].Next);
X    Mem_Head=(struct RMP_Mem_Head*)(Mem->Table[((SLI_Level)+((FLI_Level)<<3))].Next);
N    _RMP_Mem_Del(Pool, Mem_Head);
N
N    /* Allocate and calculate if the space left could be big enough to be a new 
N     * block. If so, we will put the block back into the TLSF table */
N    New_Size=((rmp_ptr_t)(Mem_Head->Tail))-((rmp_ptr_t)Mem_Head)-sizeof(struct RMP_Mem_Head)-Rounded_Size;
N    if(New_Size>=(sizeof(struct RMP_Mem_Head)+64+sizeof(struct RMP_Mem_Tail)))
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        Old_Size=sizeof(struct RMP_Mem_Head)+Rounded_Size+sizeof(struct RMP_Mem_Tail);
N        New_Mem=(volatile struct RMP_Mem_Head*)(((rmp_ptr_t)Mem_Head)+Old_Size);
N
N        _RMP_Mem_Block(Mem_Head, Old_Size);
N        _RMP_Mem_Block(New_Mem, New_Size);
N
N        /* Put the extra block back */
N        _RMP_Mem_Ins(Pool, New_Mem);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N
N    /* Mark the block as in use */
N    Mem_Head->State=RMP_MEM_USED;
X    Mem_Head->State=(1);
N
N    /* Finally, return the start address */
N    return (void*)(((rmp_ptr_t)Mem_Head)+sizeof(struct RMP_Mem_Head));
N}
N/* End Function:RMP_Malloc ***************************************************/
N
N/* Begin Function:RMP_Free ****************************************************
NDescription : Free allocated memory, for system use mainly. It will free memory 
N              in the name of a certain process, specified by the PID.
NInput       : volatile void* Pool - The pool to free to.
N              void* Mem_Ptr - The pointer returned by "RMP_Malloc".
NOutput      : None.
NReturn      : None.
N******************************************************************************/
Nvoid RMP_Free(volatile void* Pool, void* Mem_Ptr)
N{
N    volatile struct RMP_Mem* Mem;
N    volatile struct RMP_Mem_Head* Mem_Head;
N    volatile struct RMP_Mem_Head* Left_Head;
N    volatile struct RMP_Mem_Head* Right_Head;
N    rmp_cnt_t Merge_Left;
N
N    /* Check if pointer is null */
N    if((Pool==0)||(Mem_Ptr==0))
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        return;
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    /* See if the address is within the allocatable address range. If not, abort directly. */
N    Mem=(volatile struct RMP_Mem*)Pool;
N    if((((rmp_ptr_t)Mem_Ptr)<=((rmp_ptr_t)Mem))||(((rmp_ptr_t)Mem_Ptr)>=(((rmp_ptr_t)Mem)+Mem->Size)))
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        return;
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N
N    Mem_Head=(struct RMP_Mem_Head*)(((rmp_ptr_t)Mem_Ptr)-sizeof(struct RMP_Mem_Head));
N    /* See if the block can really be freed */
N    if(Mem_Head->State==RMP_MEM_FREE)
X    if(Mem_Head->State==(0))
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        return;
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N
N    /* Mark it as free */
N    Mem_Head->State=RMP_MEM_FREE;
X    Mem_Head->State=(0);
N    
N    /* Now check if we can merge it with the higher blocks */
N    Right_Head=(struct RMP_Mem_Head*)(((rmp_ptr_t)(Mem_Head->Tail))+sizeof(struct RMP_Mem_Tail));
N    if(((rmp_ptr_t)Right_Head)!=(((rmp_ptr_t)Mem)+Mem->Size))
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        /* If this one is unoccupied */
N        if((Right_Head->State)==RMP_MEM_FREE)
X        if((Right_Head->State)==(0))
N        {
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N            /* Delete, merge */
N            _RMP_Mem_Del(Pool,Right_Head);
N            _RMP_Mem_Block(Mem_Head,
N                           ((rmp_ptr_t)(Right_Head->Tail))+sizeof(struct RMP_Mem_Tail)-(rmp_ptr_t)Mem_Head);
N        }
N        else
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N
N    /* Now check if we can merge it with the lower blocks */
N    Merge_Left=0;
N    if((rmp_ptr_t)Mem_Head!=Mem->Start)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        Left_Head=((struct RMP_Mem_Tail*)(((rmp_ptr_t)Mem_Head)-sizeof(struct RMP_Mem_Tail)))->Head;
N
N        /* If this one is unoccupied */
N        if(Left_Head->State==RMP_MEM_FREE)
X        if(Left_Head->State==(0))
N        {
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N            /* Delete, merge */
N            _RMP_Mem_Del(Pool, Left_Head);
N            _RMP_Mem_Block(Left_Head,
N                           (rmp_ptr_t)((rmp_ptr_t)(Mem_Head->Tail)+sizeof(struct RMP_Mem_Tail)-(rmp_ptr_t)Left_Head));
N
N            /* We have completed the merge here and the original block has destroyed.
N             * Thus there's no need to insert it into the list again */
N            Merge_Left=1;
N        }
N        else
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N
N    /* If we did not merge it with the left-side blocks, insert the original pointer's block 
N     * into the TLSF table(Merging with the right-side one won't disturb this) */
N    if(Merge_Left==0)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        _RMP_Mem_Ins(Pool, Mem_Head);
N    }
N    else
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        _RMP_Mem_Ins(Pool, Left_Head);
N    }
N}
N/* End Function:RMP_Free *****************************************************/
N
N/* Begin Function:RMP_Realloc *************************************************
NDescription : Expand or shrink an allocation to the desired size. The behavior
N              of this function equals RMP_Malloc if the Mem_Ptr passed in is 0,
N              or RMP_Free if the Size passed in is 0.
NInput       : volatile void* Pool - The pool to allocate from.
N              void* Mem_Ptr - The old memory block to expand.
N              rmp_ptr_t Size - The size of the RAM needed to resize to.
NOutput      : None.
NReturn      : void* - The pointer to the memory. If no memory available or an
N                      error occurred, 0 is returned.
N******************************************************************************/
Nvoid* RMP_Realloc(volatile void* Pool, void* Mem_Ptr, rmp_ptr_t Size)
N{
N    /* The size of the original memory block */
N    rmp_ptr_t Mem_Size;
N    /* The rounded size of the new memory request */
N    rmp_ptr_t Rounded_Size;
N    rmp_ptr_t Count;
N    /* The pointer to the pool */
N    volatile struct RMP_Mem* Mem;
N    /* The head of the old memory */
N    volatile struct RMP_Mem_Head* Mem_Head;
N    /* The right-side block head */
N    volatile struct RMP_Mem_Head* Right_Head;
N    /* The pointer to the residue memory head */
N    volatile struct RMP_Mem_Head* Res_Mem;
N    /* The new memory block */
N    void* New_Mem;
N    /* The size of the memory block including the header sizes */
N    rmp_ptr_t Old_Size;
N    /* The size of the residue memory block including the header sizes */
N    rmp_ptr_t Res_Size;
N    
N    /* Check if no pool present */
N    if(Pool==0)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        return 0;
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    /* Are we passing in a NULL pointer? */
N    if(Mem_Ptr==0)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        return RMP_Malloc(Pool,Size);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    /* Is the size passed in zero? If yes, we free directly */
N    if(Size==0)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        RMP_Free(Pool,Mem_Ptr);
N        return 0;
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    /* See if the address is within the allocatable address range. If not, abort directly. */
N    Mem=(volatile struct RMP_Mem*)Pool;
N    if((((rmp_ptr_t)Mem_Ptr)<=((rmp_ptr_t)Mem))||(((rmp_ptr_t)Mem_Ptr)>=(((rmp_ptr_t)Mem)+Mem->Size)))
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        return 0;
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N
N    /* Yes, get the location of the header of the memory */
N    Mem_Head=(struct RMP_Mem_Head*)(((rmp_ptr_t)Mem_Ptr)-sizeof(struct RMP_Mem_Head));
N    /* See if the block can really be realloced */
N    if(Mem_Head->State==RMP_MEM_FREE)
X    if(Mem_Head->State==(0))
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        return 0;
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    /* Round up the size:a multiple of 8 and bigger than 64B */
N    Rounded_Size=RMP_ROUND_UP(Size,3);
X    Rounded_Size=((((Size)+(((rmp_ptr_t)1)<<(3))-1)>>(3))<<(3));
N    /* See if it is smaller than the smallest block */
N    Rounded_Size=(Rounded_Size>64)?Rounded_Size:64;
N    
N    Mem_Size=((rmp_ptr_t)Mem_Head->Tail)-((rmp_ptr_t)Mem_Ptr);
N    /* Does the right-side head exist at all? */
N    Right_Head=(struct RMP_Mem_Head*)(((rmp_ptr_t)(Mem_Head->Tail))+sizeof(struct RMP_Mem_Tail));
N    if(((rmp_ptr_t)Right_Head)==(((rmp_ptr_t)Mem)+Mem->Size))
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        Right_Head=0;
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    /* Are we gonna expand it? */
N    if(Mem_Size<Rounded_Size)
N    {
N        /* Expanding */
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        /* Does the right side exist at all? */
N        if(Right_Head!=0)
N        {
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N            /* Is it allocated? */
N            if(Right_Head->State==RMP_MEM_FREE)
X            if(Right_Head->State==(0))
N            {
N                RMP_COVERAGE_MARKER();
X                do { } while(0);
N                /* Right-side exists and is free. How big is its usable size? Is it sufficient for our realloc? */
N                if((((rmp_ptr_t)Right_Head->Tail)-((rmp_ptr_t)Mem_Ptr))>=Rounded_Size)
N                {
N                    RMP_COVERAGE_MARKER();
X                    do { } while(0);
N                    /* Remove the right-side from the free list so we can operate on it */
N                    _RMP_Mem_Del(Pool, Right_Head);   
N                    /* Allocate and calculate if the space left could be big enough to be a new 
N                     * block. If so, we will put the block back into the TLSF table */
N                    Res_Size=((rmp_ptr_t)(Right_Head->Tail))-((rmp_ptr_t)Mem_Ptr)-Rounded_Size;
N                    /* Is the residue big enough to be a block? */
N                    if(Res_Size>=(sizeof(struct RMP_Mem_Head)+64+sizeof(struct RMP_Mem_Tail)))
N                    {
N                        RMP_COVERAGE_MARKER();
X                        do { } while(0);
N                        Old_Size=sizeof(struct RMP_Mem_Head)+Rounded_Size+sizeof(struct RMP_Mem_Tail);
N                        Res_Mem=(volatile struct RMP_Mem_Head*)(((rmp_ptr_t)Mem_Head)+Old_Size);
N
N                        _RMP_Mem_Block(Mem_Head, Old_Size);
N                        _RMP_Mem_Block(Res_Mem, Res_Size);
N
N                        /* Put the extra block back */
N                        _RMP_Mem_Ins(Pool, Res_Mem);
N                    }
N                    else
N                    {
N                        /* Residue too small. Merging the whole thing in is the only option */
N                        RMP_COVERAGE_MARKER();
X                        do { } while(0);
N                        Old_Size=((rmp_ptr_t)(Right_Head->Tail))-((rmp_ptr_t)Mem_Head)+sizeof(struct RMP_Mem_Tail);
N                        _RMP_Mem_Block(Mem_Head, Old_Size);
N                    }
N                    
N                    /* Mark the block as in use (making new block clears this flag) */
N                    Mem_Head->State=RMP_MEM_USED;
X                    Mem_Head->State=(1);
N                    /* Return the old pointer because we expanded it */
N                    return Mem_Ptr;
N                }
N                /* Right-side not large enough, have to go malloc then memcpy */
N                else
N                    RMP_COVERAGE_MARKER();
X                    do { } while(0);
N            }
N            /* It is allocated, have to go malloc then memcpy */
N            else
N                RMP_COVERAGE_MARKER();
X                do { } while(0);
N        }
N        /* Right-side doesn't exist, have to go malloc then memcpy */
N        else
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N        
N        New_Mem=RMP_Malloc(Pool,Rounded_Size);
N        /* See if we can allocate this much, if we can't at all, exit */
N        if(New_Mem==0)
N        {
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N            return 0;
N        }
N        else
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N        
N        /* Copy old memory to new memory - we know that this is always aligned, so this is fine */
N        for(Count=0;Count<(Mem_Size>>RMP_ALIGN_ORDER);Count++)
X        for(Count=0;Count<(Mem_Size>>(5-3));Count++)
N            ((rmp_ptr_t*)New_Mem)[Count]=((rmp_ptr_t*)Mem_Ptr)[Count];
N        
N        /* Free old memory then return */
N        RMP_Free(Pool,Mem_Ptr);
N        return New_Mem;
N    }
N    /* Shrinking or keeping */
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    /* Are we keeping the size? */
N    if(Mem_Size==Rounded_Size)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        return Mem_Ptr;
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    /* Does the right side exist at all? */
N    if(Right_Head!=0)
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        /* Is it allocated? */
N        if(Right_Head->State==RMP_MEM_FREE)
X        if(Right_Head->State==(0))
N        {
N            /* Right-side not allocated. Need to merge the block */
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N            /* Remove the right-side from the allocation list so we can operate on it */
N            _RMP_Mem_Del(Pool, Right_Head);
N            Res_Size=((rmp_ptr_t)(Right_Head->Tail))-((rmp_ptr_t)Mem_Ptr)-Rounded_Size;
N            Old_Size=sizeof(struct RMP_Mem_Head)+Rounded_Size+sizeof(struct RMP_Mem_Tail);
N            Res_Mem=(volatile struct RMP_Mem_Head*)(((rmp_ptr_t)Mem_Head)+Old_Size);
N
N            _RMP_Mem_Block(Mem_Head, Old_Size);
N            _RMP_Mem_Block(Res_Mem, Res_Size);
N
N            /* Put the extra block back */
N            _RMP_Mem_Ins(Pool, Res_Mem);
N            
N            /* Mark the block as in use (making new block clears this flag) */
N            Mem_Head->State=RMP_MEM_USED;
X            Mem_Head->State=(1);
N            /* Return the old pointer because we shrinked it */
N            return Mem_Ptr;
N        }
N        /* Allocated. Need to see if the residue block itself is large enough to be inserted back */
N        else
N            RMP_COVERAGE_MARKER();
X            do { } while(0);
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    /* The right-side head either does not exist or is allocated. Calculate the resulting residue size */
N    Res_Size=Mem_Size-Rounded_Size;
N    if(Res_Size<(sizeof(struct RMP_Mem_Head)+64+sizeof(struct RMP_Mem_Tail)))
N    {
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N        /* The residue block wouldn't even count as a small one. Do nothing and quit */
N        return Mem_Ptr;
N    }
N    else
N        RMP_COVERAGE_MARKER();
X        do { } while(0);
N    
N    /* The residue will be big enough to become a standalone block. We need to place it back */ 
N    Old_Size=sizeof(struct RMP_Mem_Head)+Rounded_Size+sizeof(struct RMP_Mem_Tail);
N    Res_Mem=(volatile struct RMP_Mem_Head*)(((rmp_ptr_t)Mem_Head)+Old_Size);
N
N    _RMP_Mem_Block(Mem_Head, Old_Size);
N    _RMP_Mem_Block(Res_Mem, Res_Size);
N
N    /* Put the extra block back */
N    _RMP_Mem_Ins(Pool, Res_Mem);
N            
N    /* Mark the block as in use (making new block clears this flag) */
N    Mem_Head->State=RMP_MEM_USED;
X    Mem_Head->State=(1);
N    /* Return the old pointer because we shrinked it */
N    return Mem_Ptr;
N}
N/* End Function:RMP_Realloc **************************************************/
N
N/* Begin Function:RMP_Line ****************************************************
NDescription : Draw a line given the start and end coordinates.
NInput       : rmp_cnt_t Start_X - The start point X coordinate.
N              rmp_cnt_t Start_Y - The start point Y coordinate.
N              rmp_cnt_t End_X - The end point X coordinate.
N              rmp_cnt_t End_Y - The end point Y coordinate.
N              rmp_ptr_t Color - The color of the line.
NOutput      : None.
NReturn      : None.
N******************************************************************************/
N#ifdef RMP_POINT
Svoid RMP_Line(rmp_cnt_t Start_X, rmp_cnt_t Start_Y, rmp_cnt_t End_X, rmp_cnt_t End_Y, rmp_ptr_t Color)
S{
S    rmp_cnt_t Trav_X;
S    rmp_cnt_t Trav_Y;
S    rmp_cnt_t Dir_X;
S    rmp_cnt_t Dir_Y;
S    rmp_cnt_t Error;
S    rmp_cnt_t Cur_X;
S    rmp_cnt_t Cur_Y;
S    
S    /* See if this line is horizontal or vertical. If so we speed it up */
S    if(Start_X==End_X)
S    {
S        /* Vertical */
S        if(Start_Y>End_Y)
S        {
S            Dir_Y=End_Y;
S            Trav_Y=Start_Y;
S        }
S        else
S        {
S            Dir_Y=Start_Y;
S            Trav_Y=End_Y;
S        }
S        
S        for(Cur_Y=Dir_Y;Cur_Y<=Trav_Y;Cur_Y++)
S            RMP_POINT(Start_X,Cur_Y,Color);
S        return;
S    }
S    else if(Start_Y==End_Y)
S    {
S        /* Horizontal */
S        if(Start_X>End_X)
S        {
S            Dir_X=End_X;
S            Trav_X=Start_X;
S        }
S        else
S        {
S            Dir_X=Start_X;
S            Trav_X=End_X;
S        }
S        
S        for(Cur_X=Dir_X;Cur_X<=Trav_X;Cur_X++)
S            RMP_POINT(Cur_X,Start_Y,Color);
S        return;
S    }
S
S    Error=0;
S    /* Get their absolute value, and then draw the line */
S    Trav_X=(Start_X>End_X)?(Start_X-End_X):(End_X-Start_X);
S    Trav_Y=(Start_Y>End_Y)?(Start_Y-End_Y):(End_Y-Start_Y);
S
S    /* Decide the increment direction */
S    if(End_X-Start_X>0)
S        Dir_X=1;
S    else
S        Dir_X=-1;
S
S    if(End_Y-Start_Y>0)
S        Dir_Y=1;
S    else
S        Dir_Y=-1;
S
S    if(Trav_X>Trav_Y)
S    {
S        Cur_Y=Start_Y;
S        for(Cur_X=Start_X;Cur_X!=End_X+Dir_X;Cur_X+=Dir_X)
S        {
S            RMP_POINT(Cur_X,Cur_Y,Color);
S            Error+=Trav_Y;
S            if((Error<<1)>=Trav_X)
S            {
S                Cur_Y+=Dir_Y;
S                Error-=Trav_X;
S            }
S        }
S    }
S    else
S    {
S        Cur_X=Start_X;
S        for(Cur_Y=Start_Y;Cur_Y!=End_Y+Dir_Y;Cur_Y+=Dir_Y)
S        {
S            RMP_POINT(Cur_X,Cur_Y,Color);
S            Error+=Trav_X;
S            if((Error<<1)>=Trav_Y)
S            {
S                Cur_X+=Dir_X;
S                Error-=Trav_Y;
S            }
S        }
S    }
S}
S/* End Function:RMP_Line *****************************************************/
S
S/* Begin Function:RMP_Dot_Line ************************************************
SDescription : Draw a dotted line given the start and end coordinates.
SInput       : rmp_cnt_t Start_X - The start point X coordinate.
S              rmp_cnt_t Start_Y - The start point Y coordinate.
S              rmp_cnt_t End_X - The end point X coordinate.
S              rmp_cnt_t End_Y - The end point Y coordinate.
S              rmp_ptr_t Dot - The color of the dotted line.
S              rmp_ptr_t Space - The color of the white space. "RMP_TRANS" for nothing.
SOutput      : None.
SReturn      : None.
S******************************************************************************/
Svoid RMP_Dot_Line(rmp_cnt_t Start_X, rmp_cnt_t Start_Y, rmp_cnt_t End_X,rmp_cnt_t End_Y, rmp_ptr_t Dot, rmp_ptr_t Space)
S{
S    rmp_cnt_t Trav_X;
S    rmp_cnt_t Trav_Y;
S    rmp_cnt_t Dir_X;
S    rmp_cnt_t Dir_Y;
S    rmp_cnt_t Error;
S    rmp_cnt_t Cur_X;
S    rmp_cnt_t Cur_Y;
S
S    Error=0;
S    /* Get their absolute value, and then draw the line */
S    Trav_X=(Start_X>End_X)?(Start_X-End_X):(End_X-Start_X);
S    Trav_Y=(Start_Y>End_Y)?(Start_Y-End_Y):(End_Y-Start_Y);
S
S    /* Decide the increment direction */
S    if(End_X-Start_X>0)
S        Dir_X=1;
S    else
S        Dir_X=-1;
S
S    if(End_Y-Start_Y>0)
S        Dir_Y=1;
S    else
S        Dir_Y=-1;
S
S    if(Trav_X>Trav_Y)
S    {
S        Cur_Y=Start_Y;
S        for(Cur_X=Start_X;Cur_X!=End_X+Dir_X;Cur_X+=Dir_X)
S        {
S            /* Draw the dot and the white space alternatively */
S            if((Cur_X&0x01)!=0)
S                RMP_POINT(Cur_X,Cur_Y,Dot);
S            else
S            {
S                if(Space!=RMP_TRANS)
S                    RMP_POINT(Cur_X,Cur_Y,Space);
S            }
S            Error+=Trav_Y;
S            if((Error<<1)>=Trav_X)
S            {
S                Cur_Y+=Dir_Y;
S                Error-=Trav_X;
S            }
S        }
S    }
S    else
S    {
S        Cur_X=Start_X;
S        for(Cur_Y=Start_Y;Cur_Y!=End_Y+Dir_Y;Cur_Y+=Dir_Y)
S        {
S            /* Draw the dot and the white space alternatively */
S            if((Cur_Y&0x01)!=0)
S                RMP_POINT(Cur_X,Cur_Y,Dot);
S            else
S            {
S                if(Space!=RMP_TRANS)
S                    RMP_POINT(Cur_X,Cur_Y,Space);
S            }
S
S            Error+=Trav_X;
S            if((Error<<1)>=Trav_Y)
S            {
S                Cur_X+=Dir_X;
S                Error-=Trav_Y;
S            }
S        }
S    }
S}
S/* End Function:RMP_Dot_Line *************************************************/
S
S/*Begin Function:RMP_Rectangle ************************************************
SDescription : Draw a rectangle on the screen. You can choose whether the rectangle 
S              is filled or not. By setting the fill color to "RMP_TRANS", the 
S              rectangle is not filled.
S              The border can also be transparent.
SInput       : rmp_cnt_t Coord_X - The X position of The top-left corner.
S              rmp_cnt_t Coord_Y - The Y position of The top-left corner.
S               rmp_cnt_t Length - The length of the rectangle.
S              rmp_cnt_t Width - The width of the rectangle. 
S              rmp_ptr_t Border - The color of its boundary.
S              rmp_ptr_t Fill - The color filled within its boundary.
SOutput      : None.
SReturn      : None.
S******************************************************************************/
Svoid RMP_Rectangle(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width, rmp_ptr_t Border, rmp_ptr_t Fill)
S{
S    rmp_cnt_t Line_Cnt;
S    
S    if(Fill!=RMP_TRANS)
S    {
S        for(Line_Cnt=0;Line_Cnt<Width;Line_Cnt++)
S            RMP_Line(Coord_X,Coord_Y+Line_Cnt,Coord_X+Length-1,Coord_Y+Line_Cnt,Fill);
S    }
S
S    if(Border!=RMP_TRANS)
S    {
S        RMP_Line(Coord_X,Coord_Y,Coord_X+Length-1,Coord_Y,Border);
S        RMP_Line(Coord_X+Length-1,Coord_Y,Coord_X+Length-1,Coord_Y+Width-1,Border);
S        RMP_Line(Coord_X+Length-1,Coord_Y+Width-1,Coord_X,Coord_Y+Width-1,Border);
S        RMP_Line(Coord_X,Coord_Y+Width-1,Coord_X,Coord_Y,Border);
S    }
S}
S/* End Function:RMP_Rectangle ************************************************/
S
S/* Begin Function:RMP_Round_Rect **********************************************
SDescription : Draw a rectangle with rounded corners.
SInput       : rmp_cnt_t Coord_X - The X position of The top-left corner.
S              rmp_cnt_t Coord_Y - The Y position of The top-left corner.
S              rmp_cnt_t Length - The length of the rectangle.
S              rmp_cnt_t Width - The width of the rectangle. 
S              rmp_cnt_t Round - The radius of the round corner. 
S              rmp_ptr_t Color - The color of the rectangle.
SOutput      : None.
SReturn      : None.
S******************************************************************************/
Svoid RMP_Round_Rect(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y,
S                    rmp_cnt_t Length, rmp_cnt_t Width, rmp_cnt_t Round, rmp_ptr_t Color)
S{
S    rmp_cnt_t Cir_X_0;
S    rmp_cnt_t Cir_X_1;
S    rmp_cnt_t Cir_Y_0;
S    rmp_cnt_t Cir_Y_1;
S    
S    Cir_X_0=Coord_X+Round+1;
S    Cir_X_1=Coord_X+Length-Round-1;
S    Cir_Y_0=Coord_Y+Round+1;
S    Cir_Y_1=Coord_Y+Width-Round-1;
S    
S    /* Draw the innermost one rectangle */
S    RMP_Rectangle(Coord_X+Round+1,Coord_Y+Round+1,Length-Round-Round-2,Width-Round-Round-2,Color,Color);
S
S    /* Draw 4 small side rectangles */
S    RMP_Rectangle(Coord_X,Cir_Y_0,Round+1,Width-Round-Round-2,Color,Color);
S    RMP_Rectangle(Cir_X_1,Cir_Y_0,Round+1,Width-Round-Round-2,Color,Color);
S    RMP_Rectangle(Cir_X_0,Cir_Y_1,Length-Round-Round-2,Round+1,Color,Color);
S    RMP_Rectangle(Cir_X_0,Coord_Y,Length-Round-Round-2,Round+1,Color,Color);
S    
S    /* Draw 4 circles */
S    RMP_Circle(Cir_X_0,Cir_Y_0,Round,Color,Color);
S    RMP_Circle(Cir_X_1,Cir_Y_0,Round,Color,Color);
S    RMP_Circle(Cir_X_0,Cir_Y_1,Round,Color,Color);
S    RMP_Circle(Cir_X_1,Cir_Y_1,Round,Color,Color);
S}
S/* End Function:RMP_Round_Rect ***********************************************/
S
S/* Begin Function:RMP_Circle **************************************************
SDescription : Draw a circle on the screen. You can choose whether the circle 
S              is filled or not. By setting the fill color to "RMP_TRANS", the 
S              circle is not filled. Here, the arc function is not supported.
S              Here we utilize the Bresenham algorithm to draw the circle.
S              In this algorithm, we draw a 1/8 circle first, then we make use of
S              the symmetry of the circle to get the rest of the circle.
SInput       : rmp_cnt_t Center_X - The circle center's X coordinate.
S              rmp_cnt_t Center_Y - The circle center's Y coordinate.
S              rmp_cnt_t Radius - The radius of the circle.
S              rmp_ptr_t Border -The color of its boundary.
S              rmp_ptr_t Fill - The color filled within its boundary.
SOutput      : None.
SReturn      : None.
S******************************************************************************/
Svoid RMP_Circle(rmp_cnt_t Center_X, rmp_cnt_t Center_Y, rmp_cnt_t Radius, rmp_ptr_t Border, rmp_ptr_t Fill)
S{
S    rmp_cnt_t Cur_X;
S    rmp_cnt_t Cur_Y;
S    rmp_cnt_t Fill_Y;
S    rmp_cnt_t Error;  
S    rmp_cnt_t Quick;
S
S    Cur_X=0;
S    Cur_Y=Radius;
S    Error=3-(Radius<<1);
S
S    if(Fill!=RMP_TRANS)
S    {  
S        /* When we are filling the circle, we can try not to fill the areas that have been filled
S         * using the rectangle fill method to increase fill speed.
S         * Square 2 is 1.414. Here we let the condition to be 1.5. */
S        Quick=(Radius<<1)/3;
S        /* First, fill the square hole using the fast direct-fill method */
S        RMP_Rectangle(Center_X-Quick,Center_Y-Quick, (Quick<<1)+1,(Quick<<1)+1, Fill, Fill);  
S
S        while(Cur_X<=Cur_Y) 
S        {  
S            if(Cur_X<Quick)
S            {
S                for(Fill_Y=Cur_X;Fill_Y<=Cur_Y;Fill_Y++)  
S                {
S                    if(Fill_Y<Quick)
S                        continue;
S                    
S                    RMP_POINT(Center_X+Cur_X,Center_Y+Fill_Y,Fill);  
S                    RMP_POINT(Center_X-Cur_X,Center_Y+Fill_Y,Fill);  
S                    RMP_POINT(Center_X+Cur_X,Center_Y-Fill_Y,Fill); 
S                    RMP_POINT(Center_X-Cur_X,Center_Y-Fill_Y,Fill);  
S                    RMP_POINT(Center_X+Fill_Y,Center_Y+Cur_X,Fill); 
S                    RMP_POINT(Center_X-Fill_Y,Center_Y+Cur_X,Fill);  
S                    RMP_POINT(Center_X+Fill_Y,Center_Y-Cur_X,Fill);  
S                    RMP_POINT(Center_X-Fill_Y,Center_Y-Cur_X,Fill);
S                }
S            }
S            /* Here the "Cur_X" is already out of range. We do not check the conditions anymore */
S            else
S            {
S                for(Fill_Y=Cur_X;Fill_Y<=Cur_Y;Fill_Y++)  
S                {                   
S                    RMP_POINT(Center_X+Cur_X,Center_Y+Fill_Y,Fill);  
S                    RMP_POINT(Center_X-Cur_X,Center_Y+Fill_Y,Fill);  
S                    RMP_POINT(Center_X+Cur_X,Center_Y-Fill_Y,Fill); 
S                    RMP_POINT(Center_X-Cur_X,Center_Y-Fill_Y,Fill);  
S                    RMP_POINT(Center_X+Fill_Y,Center_Y+Cur_X,Fill); 
S                    RMP_POINT(Center_X-Fill_Y,Center_Y+Cur_X,Fill);  
S                    RMP_POINT(Center_X+Fill_Y,Center_Y-Cur_X,Fill);  
S                    RMP_POINT(Center_X-Fill_Y,Center_Y-Cur_X,Fill);
S                }
S            }
S            RMP_POINT(Center_X+Cur_X,Center_Y+Cur_Y,Border);  
S            RMP_POINT(Center_X-Cur_X,Center_Y+Cur_Y,Border);  
S            RMP_POINT(Center_X+Cur_X,Center_Y-Cur_Y,Border); 
S            RMP_POINT(Center_X-Cur_X,Center_Y-Cur_Y,Border);  
S            RMP_POINT(Center_X+Cur_Y,Center_Y+Cur_X,Border); 
S            RMP_POINT(Center_X-Cur_Y,Center_Y+Cur_X,Border);  
S            RMP_POINT(Center_X+Cur_Y,Center_Y-Cur_X,Border);  
S            RMP_POINT(Center_X-Cur_Y,Center_Y-Cur_X,Border);
S
S            if(Error<0) 
S                Error=Error+(Cur_X<<2)+6;
S            else 
S            {  
S                Error=Error+((Cur_X-Cur_Y)<<2)+10;  
S                Cur_Y--;  
S            }  
S            Cur_X++;  
S        }
S    }
S    else 
S    {  
S        /* Border only */ 
S        while(Cur_X<=Cur_Y) 
S        {
S            RMP_POINT(Center_X+Cur_X,Center_Y+Cur_Y,Border);  
S            RMP_POINT(Center_X-Cur_X,Center_Y+Cur_Y,Border);  
S            RMP_POINT(Center_X+Cur_X,Center_Y-Cur_Y,Border); 
S            RMP_POINT(Center_X-Cur_X,Center_Y-Cur_Y,Border);  
S            RMP_POINT(Center_X+Cur_Y,Center_Y+Cur_X,Border); 
S            RMP_POINT(Center_X-Cur_Y,Center_Y+Cur_X,Border);  
S            RMP_POINT(Center_X+Cur_Y,Center_Y-Cur_X,Border);  
S            RMP_POINT(Center_X-Cur_Y,Center_Y-Cur_X,Border);
S
S            if(Error<0)
S                Error=Error+(Cur_X<<2)+6;
S            else 
S            {
S                Error=Error+((Cur_X-Cur_Y)<<2);
S                Cur_Y--;
S            }
S            Cur_X++;  
S        }  
S    }
S}
S/* End Function:RMP_Circle ***************************************************/
S
S/* Begin Function:RMP_Matrix **************************************************
SDescription : Display a monochrome bit map in the given color.
SInput       : rmp_cnt_t Coord_X - The X coordinate.
S              rmp_cnt_t Coord_Y - The Y coordinate.
S              const rmp_u8_t* Matrix - The data matrix.
S              rmp_cnt_t Length - The length of the picture.
S              rmp_cnt_t Width - The width of the picture.
S              rmp_ptr_t Color - The color to display this with.
SOutput      : None.
SReturn      : None.
S******************************************************************************/
Svoid RMP_Matrix(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, const rmp_u8_t* Matrix,
S                rmp_cnt_t Bit_Order, rmp_cnt_t Length, rmp_cnt_t Width, rmp_ptr_t Color)
S{
S    rmp_cnt_t Len_Cnt;
S    rmp_cnt_t Wid_Cnt;
S    rmp_cnt_t Mat_Pos;
S    
S    if((Matrix==0)||((Length&0x07)!=0)||(Length==0)||(Width==0))
S        return;
S    
S    Mat_Pos=0;
S    /* Natural order */
S    if(Bit_Order==RMP_MAT_BIG)
S    {
S        for(Wid_Cnt=Coord_Y;Wid_Cnt<Width+Coord_Y;Wid_Cnt++)
S        {
S            for(Len_Cnt=Coord_X;Len_Cnt<Length+Coord_X;Len_Cnt++)
S            {
S                if(RMP_MAT_BPOS(Matrix,Mat_Pos)!=0)
S                    RMP_Point(Len_Cnt,Wid_Cnt,Color);
S                Mat_Pos++;
S            }
S        }
S    }
S    /* Small order */
S    else
S    {
S        for(Wid_Cnt=Coord_Y;Wid_Cnt<Width+Coord_Y;Wid_Cnt++)
S        {
S            for(Len_Cnt=Coord_X;Len_Cnt<Length+Coord_X;Len_Cnt++)
S            {
S                if(RMP_MAT_SPOS(Matrix,Mat_Pos)!=0)
S                    RMP_Point(Len_Cnt,Wid_Cnt,Color);
S                Mat_Pos++;
S            }
S        }
S    }
S}
S/* End Function:RMP_Matrix ***************************************************/
S
S/* Begin Function:RMP_Matrix_AA ***********************************************
SDescription : Display a monochrome bit map in the given color, with simple 
S              anti-aliasing (FXAA algorithm).
S              When using this, three color mixing macros must be provided.
S           
SInput       : rmp_cnt_t Coord_X - The X coordinate.
S              rmp_cnt_t Coord_Y - The Y coordinate.
S              const rmp_u8_t* Matrix - The data matrix.
S              rmp_cnt_t Length - The length of the picture.
S              rmp_cnt_t Width - The width of the picture.
S              rmp_ptr_t Color - The color to display this with.
S              rmp_ptr_t Back - The background color, for anti-aliasing.
SOutput      : None.
SReturn      : None.
S******************************************************************************/
S#ifdef RMP_COLOR_25P
S#ifdef RMP_COLOR_50P
S#ifdef RMP_COLOR_75P
Svoid RMP_Matrix_AA(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, const rmp_u8_t* Matrix,
S                   rmp_cnt_t Bit_Order, rmp_cnt_t Length, rmp_cnt_t Width, rmp_ptr_t Color, rmp_ptr_t Back)
S{
S    rmp_cnt_t Len_Cnt;
S    rmp_cnt_t Wid_Cnt;
S    rmp_cnt_t Mat_Pos;
S    rmp_cnt_t Anti_Alias;
S    rmp_ptr_t Color_25;
S    rmp_ptr_t Color_50;
S    rmp_ptr_t Color_75;
S    rmp_ptr_t Total;
S    
S    if((Matrix==0)||((Length&0x07)!=0)||(Length==0)||(Width==0))
S        return;
S    
S    Mat_Pos=0;
S    Total=Length*Width;
S    Color_25=RMP_COLOR_25P(Color,Back);
S    Color_50=RMP_COLOR_50P(Color,Back);
S    Color_75=RMP_COLOR_75P(Color,Back);
S    
S    /* Natural order */
S    if(Bit_Order==RMP_MAT_BIG)
S    {
S        for(Wid_Cnt=Coord_Y;Wid_Cnt<Width+Coord_Y;Wid_Cnt++)
S        {
S            for(Len_Cnt=Coord_X;Len_Cnt<Length+Coord_X;Len_Cnt++)
S            {
S                if(RMP_MAT_BPOS(Matrix,Mat_Pos)!=0)
S                    RMP_Point(Len_Cnt,Wid_Cnt,Color);
S                else
S                {
S                    /* Anti-aliasing */
S                    Anti_Alias=0;
S                    
S                    if(Mat_Pos-1>=0)
S                    {
S                        if((Len_Cnt!=Coord_X)&&(RMP_MAT_BPOS(Matrix,Mat_Pos-1)!=0))
S                            Anti_Alias++;
S                        if((Mat_Pos-Length>=0)&&(RMP_MAT_BPOS(Matrix,Mat_Pos-Length)!=0))
S                            Anti_Alias++;
S                    }
S                    
S                    if(Mat_Pos+1<Total)
S                    {
S                        if((Len_Cnt!=Coord_X+Length-1)&&(RMP_MAT_BPOS(Matrix,Mat_Pos+1)!=0))
S                            Anti_Alias++;
S                        if((Mat_Pos+Length<Total)&&(RMP_MAT_BPOS(Matrix,Mat_Pos+Length)!=0))
S                            Anti_Alias++;
S                    }
S                    
S                    switch(Anti_Alias)
S                    {
S                        case 1:RMP_Point(Len_Cnt,Wid_Cnt,Color_25);break;
S                        case 2:RMP_Point(Len_Cnt,Wid_Cnt,Color_50);break;
S                        case 3:RMP_Point(Len_Cnt,Wid_Cnt,Color_75);break;
S                        default:break;
S                    }
S                }
S                
S                Mat_Pos++;
S            }
S        }
S    }
S    /* Small order */
S    else
S    {
S        for(Wid_Cnt=Coord_Y;Wid_Cnt<Width+Coord_Y;Wid_Cnt++)
S        {
S            for(Len_Cnt=Coord_X;Len_Cnt<Length+Coord_X;Len_Cnt++)
S            {
S                if(RMP_MAT_SPOS(Matrix,Mat_Pos)!=0)
S                    RMP_Point(Len_Cnt,Wid_Cnt,Color);
S                else
S                {
S                    /* Anti-aliasing */
S                    Anti_Alias=0;
S                    
S                    if(Mat_Pos-1>=0)
S                    {
S                        if((Len_Cnt!=Coord_X)&&(RMP_MAT_SPOS(Matrix,Mat_Pos-1)!=0))
S                            Anti_Alias++;
S                        if((Mat_Pos-Length>=0)&&(RMP_MAT_SPOS(Matrix,Mat_Pos-Length)!=0))
S                            Anti_Alias++;
S                    }
S                    
S                    if(Mat_Pos+1<Total)
S                    {
S                        if((Len_Cnt!=Coord_X+Length-1)&&(RMP_MAT_SPOS(Matrix,Mat_Pos+1)!=0))
S                            Anti_Alias++;
S                        if((Mat_Pos+Length<Total)&&(RMP_MAT_SPOS(Matrix,Mat_Pos+Length)!=0))
S                            Anti_Alias++;
S                    }
S                    
S                    switch(Anti_Alias)
S                    {
S                        case 1:RMP_Point(Len_Cnt,Wid_Cnt,Color_25);break;
S                        case 2:RMP_Point(Len_Cnt,Wid_Cnt,Color_50);break;
S                        case 3:RMP_Point(Len_Cnt,Wid_Cnt,Color_75);break;
S                        default:break;
S                    }
S                }
S                
S                Mat_Pos++;
S            }
S        }
S    }
S}
S#endif
S#endif
S#endif
N#endif
N/* End Function:RMP_Matrix_AA ************************************************/
N
N/* Begin Function:RMP_Cursor **************************************************
NDescription : Draw a cursor (size 16x16) on the screen.
NInput       : rmp_cnt_t Coord_X - The X coordinate of the cursor.
N              rmp_cnt_t Coord_Y - The Y coordinate of the cursor.
N              rmp_ptr_t Style - The style of the mouse. Can be one of the following:
N              RMP_CUR_NORM         [0x00]    The normal arrow cursor.
N              RMP_CUR_BUSY         [0x01]    The cursor with a busy mark.
N              RMP_CUR_QUESTION     [0x02]    The cursor with a question mark.
N              RMP_CUR_HAND         [0x03]    The cursor for hyperlinks.
N              RMP_CUR_TEXT         [0x04]    The text editing cursor.
N              RMP_CUR_STOP         [0x05]    The "not available" cursor.
N              RMP_CUR_MOVE         [0x06]    The cursor for moving the window.
N              RMP_CUR_LR           [0x07]    Left-to-right double arrow.
N              RMP_CUR_UD           [0x08]    Up-to-down double arrow.
N              RMP_CUR_ULBR         [0x09]    Upper-left-to-bottom-right double arrow.
N              RMP_CUR_URBL         [0x0A]    Upper-right-to-bottom-left double arrow.
N              RMP_CUR_CROSS        [0x0B]    Crosshair cursor.
NOutput      : None.
NReturn      : None.
N******************************************************************************/
N#ifdef RMP_POINT
S#ifdef RMP_CTL_WHITE
S#ifdef RMP_CTL_LGREY
S#ifdef RMP_CTL_GREY
S#ifdef RMP_CTL_DGREY
S#ifdef RMP_CTL_DARK
S#ifdef RMP_CTL_DDARK
S#ifdef RMP_CTL_BLACK
Svoid RMP_Cursor(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_ptr_t Style)
S{
S    rmp_cnt_t Count;
S    rmp_cnt_t Size_B;
S    rmp_cnt_t Size_W;
S    const rmp_u8_t* Black;
S    const rmp_u8_t* White;
S
S    /* Normal Mouse - all matrix encoded in (Y,X) */
S    static const rmp_u8_t Arrow_B[]=
S    {
S        0x00,0x10,0x11,0x20,0x22,0x30,0x33,0x40,0x44,0x50,0x55,0x60,0x66,0x70,0x77,0x80,
S        0x88,0x90,0x95,0x96,0x97,0x98,0x99,0xA0,0xA2,0xA3,0xA5,0xB0,0xB1,0xB3,0xB6,0xC0,
S        0xC1,0xC4,0xC6,0xD0,0xD4,0xD7,0xE5,0xE7,0xF5,0xF6
S    };
S    static const rmp_u8_t Arrow_W[]=
S    {
S        0x21,0x31,0x32,0x41,0x42,0x43,0x51,0x52,0x53,0x54,0x61,0x62,0x63,0x64,0x65,0x71,
S        0x72,0x73,0x74,0x75,0x76,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x91,0x92,0x93,0x94,
S        0xA1,0xA4,0xB4,0xB5,0xC5,0xD5,0xD6,0xE6
S    };
S    /* Busy mark - no white part */
S    static const rmp_u8_t Busy_B[]=
S    {
S        0x0A,0x0B,0x0C,0x0D,0x0E,0x1A,0x1B,0x1D,0x1E,0x2A,0x2C,0x2E,0x3B,0x3D,0x4C,0x5B,
S        0x5D,0x6A,0x6E,0x7A,0x7C,0x7E,0x8A,0x8B,0x8C,0x8D,0x8E
S    };
S    static const rmp_u8_t Busy_W[]=
S    {
S        0x1C,0x2B,0x2D,0x3C,0x5C,0x6B,0x6C,0x6D,0x7B,0x7D
S    };
S    /* Question mark - no white part */
S    static const rmp_u8_t Question[]=
S    {
S        0x0B,0x0C,0x0D,0x1A,0x1B,0x1C,0x1D,0x1E,0x29,0x2A,0x2B,0x2D,0x2E,0x2F,0x39,0x3A,
S        0x3E,0x3F,0x4A,0x4D,0x4E,0x4F,0x5C,0x5D,0x5E,0x6C,0x6D,0x8D,0x8E,0x9D,0x9E
S    };
S    /* Hand-shaped cursor */
S    static const rmp_u8_t Hand_B[]=
S    {
S        0x05,0x06,0x14,0x17,0x24,0x27,0x34,0x37,0x39,0x44,0x47,0x48,0x4A,0x4C,0x51,0x52,
S        0x54,0x57,0x5A,0x5B,0x5D,0x5E,0x60,0x63,0x64,0x67,0x6A,0x6D,0x6F,0x70,0x74,0x77,
S        0x7A,0x7D,0x7F,0x80,0x8F,0x90,0x9F,0xA0,0xAF,0xB0,0xBF,0xC1,0xCE,0xD1,0xD2,0xD3,
S        0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xE1,0xEE,0xF2,0xF3,0xF4,
S        0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD
S    };
S    static const rmp_u8_t Hand_W[]=
S    {
S        0x15,0x16,0x25,0x26,0x35,0x36,0x45,0x46,0x49,0x55,0x56,0x58,0x59,0x5C,0x61,0x62,
S        0x65,0x66,0x68,0x69,0x6B,0x6C,0x6E,0x71,0x72,0x73,0x75,0x76,0x78,0x79,0x7B,0x7C,
S        0x7E,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x91,
S        0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0xA1,0xA2,0xA3,
S        0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xB1,0xB2,0xB3,0xB4,0xB5,
S        0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,
S        0xC9,0xCA,0xCB,0xCC,0xCD,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,
S        0xED
S    };
S    /* The cursor for text editing - no white part */
S    static const rmp_u8_t Text[]=
S    {
S        0x00,0x01,0x02,0x04,0x05,0x06,0x13,0x23,0x33,0x43,0x53,0x63,0x73,0x83,0x93,0xA3,
S        0xB3,0xC3,0xD3,0xE3,0xF0,0xF1,0xF2,0xF4,0xF5,0xF6
S    };
S    /* The stop cursor */
S    static const rmp_u8_t Stop_B[]=
S    {
S        0x05,0x06,0x07,0x08,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x22,0x23,0x24,0x29,
S        0x2A,0x2B,0x31,0x32,0x33,0x34,0x3A,0x3B,0x3C,0x41,0x42,0x43,0x44,0x45,0x4B,0x4C,
S        0x50,0x51,0x54,0x55,0x56,0x5C,0x5D,0x60,0x61,0x65,0x66,0x67,0x6C,0x6D,0x70,0x71,
S        0x76,0x77,0x78,0x7C,0x7D,0x80,0x81,0x87,0x88,0x89,0x8C,0x8D,0x91,0x92,0x98,0x99,
S        0x9A,0x9B,0x9C,0xA1,0xA2,0xA3,0xA9,0xAA,0xAB,0xAC,0xB2,0xB3,0xB4,0xB9,0xBA,0xBB,
S        0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xD5,0xD6,0xD7,0xD8
S    };
S    static const rmp_u8_t Stop_W[]=
S    {
S        0x25,0x26,0x27,0x28,0x35,0x36,0x37,0x38,0x39,0x46,0x47,0x48,0x49,0x4A,0x52,0x53,
S        0x57,0x58,0x59,0x5A,0x5B,0x62,0x63,0x64,0x68,0x69,0x6A,0x6B,0x72,0x73,0x74,0x75,
S        0x79,0x7A,0x7B,0x82,0x83,0x84,0x85,0x86,0x8A,0x8B,0x93,0x94,0x95,0x96,0x97,0xA4,
S        0xA5,0xA6,0xA7,0xA8,0xB5,0xB6,0xB7,0xB8
S    };
S       /* Cross arrow - no white part  */
S    static const rmp_u8_t Adj_ALL[]=
S    {
S        0x07,0x16,0x17,0x18,0x25,0x26,0x27,0x28,0x29,0x37,0x47,0x52,0x57,0x5C,0x61,0x62,
S        0x67,0x6C,0x6D,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7A,0x7B,0x7C,
S        0x7D,0x7E,0x81,0x82,0x87,0x8C,0x8D,0x92,0x97,0x9C,0xA7,0xB7,0xC5,0xC6,0xC7,0xC8,
S        0xC9,0xD6,0xD7,0xD8,0xE7
S    };    
S    /* Left to right arrow - no white part */
S    static const rmp_u8_t Adj_LR[]=
S    {
S        0x52,0x5D,0x61,0x62,0x6D,0x6E,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,
S        0x7A,0x7B,0x7C,0x7D,0x7E,0x7F,0x81,0x82,0x8D,0x8E,0x92,0x9D
S    };
S    /* Up to down arrow - no white part */
S    static const rmp_u8_t Adj_UD[]=
S    {
S        0x07,0x16,0x17,0x18,0x25,0x26,0x27,0x28,0x29,0x37,0x47,0x57,0x67,0x77,0x87,0x97,
S        0xA7,0xB7,0xC7,0xD5,0xD6,0xD7,0xD8,0xD9,0xE6,0xE7,0xE8,0xF7
S
S    };
S    /* Bottom-right to top-left arrow - no white part */
S    static const rmp_u8_t Adj_BRUL[]=
S    {
S        0x00,0x01,0x02,0x03,0x04,0x10,0x11,0x12,0x13,0x20,0x21,0x22,0x30,0x31,0x33,0x40,
S        0x44,0x55,0x66,0x77,0x88,0x99,0xAA,0xBB,0xBF,0xCC,0xCE,0xCF,0xDD,0xDE,0xDF,0xEC,
S        0xED,0xEE,0xEF,0xFB,0xFC,0xFD,0xFE,0xFF
S    };
S    /* Bottom-left to top-right arrow - no white part */
S    static const rmp_u8_t Adj_BLUR[]=
S    {
S        0x0B,0x0C,0x0D,0x0E,0x0F,0x1C,0x1D,0x1E,0x1F,0x2D,0x2E,0x2F,0x3C,0x3E,0x3F,0x4B,
S        0x4F,0x5A,0x69,0x78,0x87,0x96,0xA5,0xB0,0xB4,0xC0,0xC1,0xC3,0xD0,0xD1,0xD2,0xE0,
S        0xE1,0xE2,0xE3,0xF0,0xF1,0xF2,0xF3,0xF4
S    };
S    /* The crosshair cursor - no white part */
S    static const rmp_u8_t Cross[]=
S    {
S        0x07,0x17,0x27,0x37,0x46,0x47,0x48,0x55,0x57,0x59,0x64,0x6A,0x70,0x71,0x72,0x73,
S        0x74,0x75,0x77,0x79,0x7A,0x7B,0x7C,0x7D,0x7E,0x84,0x8A,0x95,0x97,0x99,0xA6,0xA7,
S        0xA8,0xB7,0xC7,0xD7,0xE7
S    };
S    
S    /* Draw them */
S    switch(Style)
S    {
S        case RMP_CUR_NORM:{Size_B=sizeof(Arrow_B);Size_W=sizeof(Arrow_W);Black=Arrow_B;White=Arrow_W;break;}
S        case RMP_CUR_BUSY:case RMP_CUR_QUESTION:
S        {
S            for(Count=0;Count<sizeof(Arrow_B);Count++)                                                              
S                RMP_POINT(Coord_X+(Arrow_B[Count]&0x0F),Coord_Y+(Arrow_B[Count]>>4),RMP_CTL_BLACK);
S            for(Count=0;Count<sizeof(Arrow_W);Count++)                                                              
S                RMP_POINT(Coord_X+(Arrow_W[Count]&0x0F),Coord_Y+(Arrow_W[Count]>>4),RMP_CTL_WHITE);
S            
S            if(Style==RMP_CUR_BUSY)
S            {
S                Size_B=sizeof(Busy_B);
S                Size_W=sizeof(Busy_W);
S                Black=Busy_B;
S                White=Busy_W;
S            }
S            else
S            {
S                Size_B=sizeof(Question);
S                Size_W=0;
S                Black=Question;
S                White=0;
S            }
S            break;
S        }       
S        case RMP_CUR_HAND:{Size_B=sizeof(Hand_B);Size_W=sizeof(Hand_W);Black=Hand_B;White=Hand_W;break;}
S        case RMP_CUR_TEXT:{Size_B=sizeof(Text);Size_W=0;Black=Text;White=0;break;}
S        case RMP_CUR_STOP:{Size_B=sizeof(Stop_B);Size_W=sizeof(Stop_W);Black=Stop_B;White=Stop_W;break;}
S        case RMP_CUR_MOVE:{Size_B=sizeof(Adj_ALL);Size_W=0;Black=Adj_ALL;White=0;break;}
S        case RMP_CUR_LR:{Size_B=sizeof(Adj_LR);Size_W=0;Black=Adj_LR;White=0;break;}
S        case RMP_CUR_UD:{Size_B=sizeof(Adj_UD);Size_W=0;Black=Adj_UD;White=0;break;}
S        case RMP_CUR_ULBR:{Size_B=sizeof(Adj_BRUL);Size_W=0;Black=Adj_BRUL;White=0;break;}
S        case RMP_CUR_URBL:{Size_B=sizeof(Adj_BLUR);Size_W=0;Black=Adj_BLUR;White=0;break;}
S        case RMP_CUR_CROSS:{Size_B=sizeof(Cross);Size_W=0;Black=Cross;White=0;break;}
S        default:return;
S    }
S    
S    for(Count=0;Count<Size_B;Count++)                                                              
S        RMP_POINT(Coord_X+(Black[Count]&0x0F),Coord_Y+(Black[Count]>>4),RMP_CTL_BLACK);
S    for(Count=0;Count<Size_W;Count++)                                                              
S        RMP_POINT(Coord_X+(White[Count]&0x0F),Coord_Y+(White[Count]>>4),RMP_CTL_WHITE);
S}
S/* End Function: RMP_Cursor **************************************************/
S
S/* Begin Function:RMP_Checkbox_Set ********************************************
SDescription : Set the checbox (tick it).
SInput       : rmp_cnt_t Coord_X - The X coordinate.
S              rmp_cnt_t Coord_Y - The Y coordinate.
S              rmp_cnt_t Length - The length of the checkbox(also the width).
SOutput      : None.
SReturn      : None.
S******************************************************************************/
Svoid RMP_Checkbox_Set(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length)
S{
S    rmp_cnt_t Count;
S    
S    /* Draw a tick inside */
S    for(Count=0;Count<=2*Length/13;Count++)
S    {
S        RMP_Line(Coord_X+4*Length/13+Count,Coord_Y+6*Length/13+Count,
S                 Coord_X+4*Length/13+Count,Coord_Y+8*Length/13+Count,RMP_CTL_BLACK);
S    }
S    for(Count=0;Count<=4*Length/13;Count++)
S    {
S        RMP_Line(Coord_X+6*Length/13+Count,Coord_Y+8*Length/13-Count,
S                 Coord_X+6*Length/13+Count,Coord_Y+10*Length/13-Count,RMP_CTL_BLACK);
S    }
S}
S/* End Function:RMP_Checkbox_Set *********************************************/
S
S/* Begin Function:RMP_Checkbox_Clr ********************************************
SDescription : Clear the checbox (reset it).
SInput       : rmp_cnt_t Coord_X - The X coordinate.
S              rmp_cnt_t Coord_Y - The Y coordinate.
S              rmp_cnt_t Length - The length of the checkbox(also the width).
SOutput      : None.
SReturn      : None.
S******************************************************************************/
Svoid RMP_Checkbox_Clr(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length)
S{
S    rmp_cnt_t Count;
S    
S    /* Erase the tick inside */
S    for(Count=0;Count<=2*Length/13;Count++)
S    {
S        RMP_Line(Coord_X+4*Length/13+Count,Coord_Y+6*Length/13+Count,
S                 Coord_X+4*Length/13+Count,Coord_Y+8*Length/13+Count,RMP_CTL_WHITE);
S    }
S    for(Count=0;Count<=4*Length/13;Count++)
S    {
S        RMP_Line(Coord_X+6*Length/13+Count,Coord_Y+8*Length/13-Count,
S                 Coord_X+6*Length/13+Count,Coord_Y+10*Length/13-Count,RMP_CTL_WHITE);
S    }
S}
S/* End Function:RMP_Checkbox_Clr *********************************************/
S
S/* Begin Function:RMP_Checkbox ************************************************
SDescription : Draw the checkbox according to the parameters.
SInput       : rmp_cnt_t Coord_X - The X coordinate.
S              rmp_cnt_t Coord_Y - The Y coordinate.
S              rmp_cnt_t Length - The length of the checkbox(also the width).
S              rmp_ptr_t Status - The checkbox status.
SOutput      : None.
SReturn      : None.
S******************************************************************************/
Svoid RMP_Checkbox(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_ptr_t Status)    
S{   
S    /* Clear the area */
S    RMP_Rectangle(Coord_X,Coord_Y,Length,Length,RMP_CTL_WHITE,RMP_CTL_WHITE);
S                                                                     
S    /* Draw checkbox outline */
S    RMP_Line(Coord_X,Coord_Y,Coord_X+Length-1,Coord_Y,RMP_CTL_DARK);                 
S    RMP_Line(Coord_X+Length-1,Coord_Y,Coord_X+Length-1,Coord_Y+Length-1,RMP_CTL_WHITE);
S    RMP_Line(Coord_X+Length-1,Coord_Y+Length-1,Coord_X,Coord_Y+Length-1,RMP_CTL_WHITE);
S    RMP_Line(Coord_X,Coord_Y+Length-1,Coord_X,Coord_Y,RMP_CTL_DARK);
S
S    RMP_Line(Coord_X+1,Coord_Y+1,Coord_X+Length-2,Coord_Y+1,RMP_CTL_BLACK);
S    RMP_Line(Coord_X+Length-2,Coord_Y+1,Coord_X+Length-2,Coord_Y+Length-2,RMP_CTL_DARK);
S    RMP_Line(Coord_X+Length-2,Coord_Y+Length-2,Coord_X,Coord_Y+Length-2,RMP_CTL_DARK);
S    RMP_Line(Coord_X+1,Coord_Y+Length-2,Coord_X+1,Coord_Y+1,RMP_CTL_BLACK);
S    
S    if(Status!=0)
S        RMP_Checkbox_Set(Coord_X, Coord_Y, Length);
S}
S/* End Function:RMP_Checkbox *************************************************/
S
S/* Begin Function:RMP_Cmdbtn_Down *********************************************
SDescription : Turn the command button to a pushed-down version.
SInput       : rmp_cnt_t Coord_X - The X coordinate of its top-left corner.
S              rmp_cnt_t Coord_Y - The Y coordinate of its top-left corner.
S              rmp_cnt_t Length - The length of the button.
S              rmp_cnt_t Width - The width of the button.
SOutput      : None.
SReturn      : None.
S******************************************************************************/
Svoid RMP_Cmdbtn_Down(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width)
S{
S    RMP_Line(Coord_X,Coord_Y,Coord_X+Length-1,Coord_Y,RMP_CTL_BLACK);
S    RMP_Line(Coord_X+Length-1,Coord_Y,Coord_X+Length-1,Coord_Y+Width-1,RMP_CTL_WHITE);
S    RMP_Line(Coord_X+Length-1,Coord_Y+Width-1,Coord_X,Coord_Y+Width-1,RMP_CTL_WHITE);
S    RMP_Line(Coord_X,Coord_Y+Width-1,Coord_X,Coord_Y,RMP_CTL_BLACK);
S    /* Clear the old shadow */
S    RMP_Line(Coord_X+Length-2,Coord_Y+Width-2,Coord_X+1,Coord_Y+Width-2,RMP_CTL_GREY);    
S    RMP_Line(Coord_X+Length-2,Coord_Y+1,Coord_X+Length-2,Coord_Y+Width-2,RMP_CTL_GREY);    
S    /* The shadow */                            
S    RMP_Line(Coord_X+1,Coord_Y+Width-2,Coord_X+1,Coord_Y+1,RMP_CTL_DARK);    
S    RMP_Line(Coord_X+1,Coord_Y+1,Coord_X+Length-2,Coord_Y+1,RMP_CTL_DARK);    
S}
S/* End Function:RMP_Cmdbtn_Down **********************************************/
S
S/* Begin Function:RMP_Cmdbtn_Up ***********************************************
SDescription : Turn the command button to a popped-up version.
SInput       : rmp_cnt_t Coord_X - The X coordinate of its top-left corner.
S              rmp_cnt_t Coord_Y - The Y coordinate of its top-left corner.
S              rmp_cnt_t Length - The length of the button.
S              rmp_cnt_t Width - The width of the button.
SOutput      : None.
SReturn      : None.
S******************************************************************************/
Svoid RMP_Cmdbtn_Up(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width)
S{
S    RMP_Line(Coord_X,Coord_Y,Coord_X+Length-1,Coord_Y,RMP_CTL_WHITE);
S    RMP_Line(Coord_X+Length-1,Coord_Y,Coord_X+Length-1,Coord_Y+Width-1,RMP_CTL_BLACK);
S    RMP_Line(Coord_X+Length-1,Coord_Y+Width-1,Coord_X,Coord_Y+Width-1,RMP_CTL_BLACK);
S    RMP_Line(Coord_X,Coord_Y+Width-1,Coord_X,Coord_Y,RMP_CTL_WHITE);
S    /* Clear the old shadow */
S    RMP_Line(Coord_X+1,Coord_Y+Width-2,Coord_X+1,Coord_Y+1,RMP_CTL_GREY);    
S    RMP_Line(Coord_X+1,Coord_Y+1,Coord_X+Length-2,Coord_Y+1,RMP_CTL_GREY);    
S    /* The shadow */
S    RMP_Line(Coord_X+Length-2,Coord_Y+Width-2,Coord_X+1,Coord_Y+Width-2,RMP_CTL_DARK);    
S    RMP_Line(Coord_X+Length-2,Coord_Y+1,Coord_X+Length-2,Coord_Y+Width-2,RMP_CTL_DARK);    
S}
S/* End Function:RMP_Cmdbtn_Up ************************************************/
S
S/* Begin Function:RMP_Cmdbtn **************************************************
SDescription : Draw a command button.
SInput       : rmp_cnt_t Coord_X - The X coordinate of its top-left corner.
S              rmp_cnt_t Coord_Y - The Y coordinate of its top-left corner.
S              rmp_cnt_t Length - The length of the button.
S              rmp_cnt_t Width - The width of the button.
S              rmp_ptr_t Status - The status of the command button.
SOutput      : None.
SReturn      : None.
S******************************************************************************/
Svoid RMP_Cmdbtn(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width, rmp_ptr_t Status)
S{
S    RMP_Rectangle(Coord_X,Coord_Y,Length,Width,RMP_CTL_GREY,RMP_CTL_GREY);
S
S    if(Status!=0)
S        RMP_Cmdbtn_Down(Coord_X, Coord_Y, Length, Width);
S    else
S        RMP_Cmdbtn_Up(Coord_X, Coord_Y, Length, Width);
S}
S/* End Function:RMP_Cmdbtn ***************************************************/
S
S/* Begin Function:RMP_Lineedit_Clr ********************************************
SDescription : Clear a portion of the line edit box.
SInput       : rmp_cnt_t Coord_X - The X coordinate of its top-left corner.
S              rmp_cnt_t Coord_Y - The Y coordinate of its top-left corner.
S              rmp_cnt_t Length - The length of the line edit box.
S              rmp_cnt_t Width - The width of the line edit box.
S              rmp_cnt_t Clr_X - The X coordinate to start clearing.
S              rmp_cnt_t Clr_Len - The length to clear.
SOutput      : None.
SReturn      : None.
S******************************************************************************/
Svoid RMP_Lineedit_Clr(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length,
S                      rmp_cnt_t Width, rmp_cnt_t Clr_X, rmp_cnt_t Clr_Len)
S{
S    RMP_Rectangle(Clr_X,Coord_Y+1,Clr_Len,Width-2,RMP_CTL_WHITE,RMP_CTL_WHITE);
S}
S/* End Function:RMP_Lineedit_Clr *********************************************/
S
S/* Begin Function:RMP_Lineedit ************************************************
SDescription : Draw a line edit box with string on it.
SInput       : rmp_cnt_t Coord_X - The X coordinate of its top-left corner.
S              rmp_cnt_t Coord_Y - The Y coordinate of its top-left corner.
S              rmp_cnt_t Length - The length of the line edit box.
S              rmp_cnt_t Width - The width of the line edit box.
SOutput      : None.
SReturn      : None.
S******************************************************************************/
Svoid RMP_Lineedit(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width)
S{
S    RMP_Rectangle(Coord_X,Coord_Y,Length,Width,RMP_CTL_WHITE,RMP_CTL_WHITE);
S    
S    /* Now draw the border */
S    RMP_Line(Coord_X,Coord_Y,Coord_X+Length-1,Coord_Y,RMP_CTL_DARK);
S    RMP_Line(Coord_X+Length-1,Coord_Y,Coord_X+Length-1,Coord_Y+Width-1,RMP_CTL_WHITE);
S    RMP_Line(Coord_X+Length-1,Coord_Y+Width-1,Coord_X,Coord_Y+Width-1,RMP_CTL_WHITE);
S    RMP_Line(Coord_X,Coord_Y+Width-1,Coord_X,Coord_Y,RMP_CTL_DARK);
S    /* The shadow */
S    RMP_Line(Coord_X+1,Coord_Y+Width-2,Coord_X+1,Coord_Y+1,RMP_CTL_BLACK);    
S    RMP_Line(Coord_X+1,Coord_Y+1,Coord_X+Length-2,Coord_Y+1,RMP_CTL_BLACK);
S}
S/* End Function:RMP_Lineedit *************************************************/
S
S/* Begin Function:RMP_Radiobtn_Circle *****************************************
SDescription : Draw the radio button outside circle according to the parameters.
SInput       : rmp_cnt_t Coord_X - The X coordinate.
S              rmp_cnt_t Coord_Y - The Y coordinate.
S              rmp_cnt_t Length - The length of the radio button(also the width).         
SOutput      : None.
SReturn      : None.
S******************************************************************************/
Svoid RMP_Radiobtn_Circle(rmp_cnt_t Coord_X,rmp_cnt_t Coord_Y,rmp_cnt_t Length)
S{   
S    rmp_cnt_t Radius;
S    rmp_cnt_t Center_X;
S    rmp_cnt_t Center_Y;
S    rmp_cnt_t Cur_X;
S    rmp_cnt_t Cur_Y;
S    rmp_cnt_t Error;
S    
S    /* The radius is the length/2 */
S    Radius=Length>>1;
S    Center_X=Coord_X+Radius;
S    Center_Y=Coord_Y+Radius;
S    
S    /* Now we begin to draw the inner halfcircle */
S    Cur_X=0;
S    Cur_Y=Radius-1;
S    Error=3-((Radius-1)<<1);  
S    
S    while(Cur_X<=Cur_Y) 
S    {  
S        /* This is the upper-left part */
S        RMP_POINT(Center_X+Cur_X,Center_Y-Cur_Y,RMP_CTL_DDARK);
S        RMP_POINT(Center_X-Cur_X,Center_Y-Cur_Y,RMP_CTL_DDARK);
S        RMP_POINT(Center_X-Cur_Y,Center_Y-Cur_X,RMP_CTL_DDARK);
S        RMP_POINT(Center_X-Cur_Y,Center_Y+Cur_X,RMP_CTL_DDARK);
S        
S        /* This is the lower-right part */
S        RMP_POINT(Center_X+Cur_X,Center_Y+Cur_Y,RMP_CTL_LGREY);
S        RMP_POINT(Center_X-Cur_X,Center_Y+Cur_Y,RMP_CTL_LGREY);  
S        RMP_POINT(Center_X+Cur_Y,Center_Y+Cur_X,RMP_CTL_LGREY); 
S        RMP_POINT(Center_X+Cur_Y,Center_Y-Cur_X,RMP_CTL_LGREY);  
S        
S        if(Error<0) 
S        {
S            Error=Error+(Cur_X<<2)+6;
S        }
S        else 
S        {
S            Error=Error+((Cur_X-Cur_Y)<<2);
S            Cur_Y--;
S        }
S        Cur_X++;
S    } 
S    
S    /* Now we begin to draw the outer halfcircle */
S    Cur_X=0;
S    Cur_Y=Radius;
S    Error=3-(Radius<<1);  
S    
S    while(Cur_X<=Cur_Y) 
S    {  
S        /* This is the upper-left part */
S        RMP_POINT(Center_X+Cur_X,Center_Y-Cur_Y,RMP_CTL_DGREY);
S        RMP_POINT(Center_X-Cur_X,Center_Y-Cur_Y,RMP_CTL_DGREY);
S        RMP_POINT(Center_X-Cur_Y,Center_Y-Cur_X,RMP_CTL_DGREY);
S        RMP_POINT(Center_X-Cur_Y,Center_Y+Cur_X,RMP_CTL_DGREY);
S        
S        /* This is the lower-right part */
S        RMP_POINT(Center_X+Cur_X,Center_Y+Cur_Y,RMP_CTL_WHITE);
S        RMP_POINT(Center_X-Cur_X,Center_Y+Cur_Y,RMP_CTL_WHITE);  
S        RMP_POINT(Center_X+Cur_Y,Center_Y+Cur_X,RMP_CTL_WHITE); 
S        RMP_POINT(Center_X+Cur_Y,Center_Y-Cur_X,RMP_CTL_WHITE);  
S        
S        if(Error<0) 
S        {  
S            Error=Error+(Cur_X<<2)+6;  
S        } 
S        else 
S        {  
S            Error=Error+((Cur_X-Cur_Y)<<2);  
S            Cur_Y--;  
S        }  
S        Cur_X++;  
S    } 
S}
S/* End Function:RMP_Radiobtn_Circle ******************************************/
S
S/* Begin Function:RMP_Radiobtn_Set ********************************************
SDescription : Set the radio button (select it).
SInput       : rmp_cnt_t Coord_X - The X coordinate.
S              rmp_cnt_t Coord_Y - The Y coordinate.
S              rmp_cnt_t Length - The length of the radio button(also the width).
SOutput      : None.
SReturn      : None.
S******************************************************************************/
Svoid RMP_Radiobtn_Set(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length)
S{
S    RMP_Circle(Coord_X+Length/2,Coord_Y+Length/2,Length/6,RMP_CTL_BLACK,RMP_CTL_BLACK);
S}
S/* End Function:RMP_Radiobtn_Set *********************************************/
S
S/* Begin Function:RMP_Radiobtn_Clr ********************************************
SDescription : Set the radio button (reset it).
SInput       : rmp_cnt_t Coord_X - The X coordinate.
S              rmp_cnt_t Coord_Y - The Y coordinate.
S              rmp_cnt_t Length - The length of the radio button(also the width).
SOutput      : None.
SReturn      : None.
S******************************************************************************/
Svoid RMP_Radiobtn_Clr(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length)
S{
S    RMP_Circle(Coord_X+Length/2,Coord_Y+Length/2,Length/6,RMP_CTL_GREY,RMP_CTL_GREY);
S}
S/* End Function:RMP_Radiobtn_Clr *********************************************/
S
S/* Begin Function:RMP_Radiobtn ************************************************
SDescription : Draw the radio button according to the parameters.
SInput       : rmp_cnt_t Coord_X - The X coordinate.
S              rmp_cnt_t Coord_Y - The Y coordinate.
S              rmp_cnt_t Length - The length of the radio button(also the width).
S              rmp_ptr_t Status - The radio button status.
SOutput      : None.
SReturn      : None.
S******************************************************************************/
Svoid RMP_Radiobtn(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_ptr_t Status)
S{   
S    /* Fill the area with rect */
S    RMP_Rectangle(Coord_X,Coord_Y,Length,Length,RMP_CTL_GREY,RMP_CTL_GREY);
S    
S    /* Draw the circle first */
S    RMP_Radiobtn_Circle(Coord_X,Coord_Y,Length);
S    
S    /* See if the radio button is selected */
S    if(Status==RMP_RBTN_SEL)
S        RMP_Radiobtn_Set(Coord_X, Coord_Y, Length);
S}
S/* End Function:RMP_Radiobtn *************************************************/
S
S/* Begin Function:RMP_Progbar_Set ********************************************
SDescription : Set the progress of a progress bar.
SInput       : rmp_cnt_t Coord_X - The X coordinate of its top-left corner.
S              rmp_cnt_t Coord_Y - The Y coordinate of its top-left corner.
S              rmp_cnt_t Length - The length of the button.
S              rmp_cnt_t Width - The width of the button.
S              rmp_cnt_t Style - The style of the progress.
S              rmp_cnt_t Old_Prog - The old progress of this bar. 
S              rmp_cnt_t New_Prog - The new progress of this bar. 
S              rmp_ptr_t Fore - The foreground color.
S              rmp_ptr_t Back - The background color.      
SOutput      : None.
SReturn      : None.
S******************************************************************************/
Svoid RMP_Progbar_Set(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width,
S                     rmp_cnt_t Style, rmp_cnt_t Old_Prog, rmp_cnt_t New_Prog, rmp_ptr_t Fore, rmp_ptr_t Back)
S{
S    /* The critical values for drawing the bar */
S    rmp_ptr_t Old_Pivot;
S    rmp_ptr_t New_Pivot;
S    
S    /* If things does not change, return to save time */
S    if(Old_Prog==New_Prog)
S        return;
S    
S    switch(Style)
S    {
S        case RMP_PBAR_L2R:
S        {
S            Old_Pivot=(Length-2)*Old_Prog/100;
S            New_Pivot=(Length-2)*New_Prog/100;
S            /* Progress decreased */
S            if(Old_Pivot>New_Pivot)
S                RMP_Rectangle(Coord_X+1+New_Pivot,Coord_Y+1,Old_Pivot-New_Pivot,Width-2,Back,Back);
S            /* Progress increased */
S            else
S                RMP_Rectangle(Coord_X+1+Old_Pivot,Coord_Y+1,New_Pivot-Old_Pivot,Width-2,Fore,Fore);
S            break;
S        }
S        case RMP_PBAR_D2U:
S        {
S            Old_Pivot=(Width-2)*Old_Prog/100;
S            New_Pivot=(Width-2)*New_Prog/100;
S            /* Progress decreased */
S            if(Old_Pivot>New_Pivot)
S                RMP_Rectangle(Coord_X+1,Coord_Y-1+Width-Old_Pivot,Length-2,Old_Pivot-New_Pivot,Back,Back);
S            /* Progress increased */
S            else
S                RMP_Rectangle(Coord_X+1,Coord_Y-1+Width-New_Pivot,Length-2,New_Pivot-Old_Pivot,Fore,Fore);
S            break;
S        }
S        case RMP_PBAR_R2L:
S        {
S            Old_Pivot=(Length-2)*Old_Prog/100;
S            New_Pivot=(Length-2)*New_Prog/100;
S            /* Progress decreased */
S            if(Old_Pivot>New_Pivot)
S                RMP_Rectangle(Coord_X-1+Length-Old_Pivot,Coord_Y+1,Old_Pivot-New_Pivot,Width-2,Back,Back);
S            /* Progress increased */
S            else
S                RMP_Rectangle(Coord_X-1+Length-New_Pivot,Coord_Y+1,New_Pivot-Old_Pivot,Width-2,Fore,Fore);
S            break;
S        }
S        case RMP_PBAR_U2D:
S        {
S            Old_Pivot=(Width-2)*Old_Prog/100;
S            New_Pivot=(Width-2)*New_Prog/100;
S            /* Progress decreased */
S            if(Old_Pivot>New_Pivot)
S                RMP_Rectangle(Coord_X+1,Coord_Y+1+New_Pivot,Length-2,Old_Pivot-New_Pivot,Back,Back);
S            /* Progress increased */
S            else
S                RMP_Rectangle(Coord_X+1,Coord_Y+1+Old_Pivot,Length-2,New_Pivot-Old_Pivot,Fore,Fore);
S            break;
S        }
S        default: break;
S    }
S}
S/* End Function:RMP_Progbar_Set **********************************************/
S
S/* Begin Function:RMP_Progbar_Prog ********************************************
SDescription : Draw a progress bar's progress part.
SInput       : rmp_cnt_t Coord_X - The X coordinate of its top-left corner.
S              rmp_cnt_t Coord_Y - The Y coordinate of its top-left corner.
S              rmp_cnt_t Length - The length of the button.
S              rmp_cnt_t Width - The width of the button.
S              rmp_cnt_t Style - The style of the progress.
S              rmp_cnt_t Prog - The progress of the progress bar.    
S              rmp_ptr_t Fore - The foreground color.
S              rmp_ptr_t Back - The background color.   
SOutput      : None.
SReturn      : None.
S******************************************************************************/
Svoid RMP_Progbar_Prog(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width,
S                      rmp_cnt_t Style, rmp_cnt_t Prog, rmp_ptr_t Fore, rmp_ptr_t Back)
S{
S    /* The critical value for drawing the bar */
S    rmp_ptr_t Pivot;
S    
S    switch(Style)
S    {
S        case RMP_PBAR_L2R:
S        {
S            Pivot=Length*Prog/100;
S            if(Prog!=0)
S                RMP_Rectangle(Coord_X,Coord_Y,Pivot,Width,Fore,Fore);
S            if(Prog!=100)
S                RMP_Rectangle(Coord_X+Pivot,Coord_Y,Length-Pivot,Width,Back,Back);
S            break;
S        }
S        case RMP_PBAR_D2U:
S        {
S            Pivot=Width*Prog/100;
S            if(Prog!=0)
S                RMP_Rectangle(Coord_X,Coord_Y+Width-Pivot,Length,Pivot,Fore,Fore);
S            if(Prog!=100)
S                RMP_Rectangle(Coord_X,Coord_Y,Length,Width-Pivot,Back,Back);
S            break;
S        }
S        case RMP_PBAR_R2L:
S        {
S            Pivot=Length*Prog/100;
S            if(Prog!=0)
S                RMP_Rectangle(Coord_X+Length-Pivot,Coord_Y,Pivot,Width,Fore,Fore);
S            if(Prog!=100)
S                RMP_Rectangle(Coord_X,Coord_Y,Length-Pivot,Width,Back,Back);
S            break;
S        }
S        case RMP_PBAR_U2D:
S        {
S            Pivot=Width*Prog/100;
S            if(Prog!=0)
S                RMP_Rectangle(Coord_X,Coord_Y,Length,Pivot,Fore,Fore);
S            if(Prog!=100)
S                RMP_Rectangle(Coord_X,Coord_Y+Pivot,Length,Width-Pivot,Back,Back);
S            break;
S        }
S        default: break;
S    }
S}
S/* End Function:RMP_Progbar_Prog *********************************************/
S
S/* Begin Function:RMP_Progbar *************************************************
SDescription : Draw a progress bar with string on it.
SInput       : rmp_cnt_t Coord_X - The X coordinate of its top-left corner.
S              rmp_cnt_t Coord_Y - The Y coordinate of its top-left corner.
S              rmp_cnt_t Length - The length of the button.
S              rmp_cnt_t Width - The width of the button.
S              rmp_cnt_t Style - The style of the progress.
S              rmp_cnt_t Prog - The progress of the progress bar. 
S              rmp_ptr_t Fore - The foreground color.
S              rmp_ptr_t Back - The background color.
SOutput      : None.
SReturn      : None.
S******************************************************************************/
Svoid RMP_Progbar(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width,
S                 rmp_cnt_t Style, rmp_cnt_t Prog, rmp_ptr_t Fore, rmp_ptr_t Back)
S{
S    /* Draw the progress bar according to the style of the progress bar */
S    RMP_Progbar_Prog(Coord_X,Coord_Y,Length,Width,Style,Prog,Fore,Back);
S    /* Now draw the border */
S    RMP_Line(Coord_X,Coord_Y,Coord_X+Length-1,Coord_Y,RMP_CTL_BLACK);
S    RMP_Line(Coord_X+Length-1,Coord_Y,Coord_X+Length-1,Coord_Y+Width-1,RMP_CTL_BLACK);
S    RMP_Line(Coord_X+Length-1,Coord_Y+Width-1,Coord_X,Coord_Y+Width-1,RMP_CTL_BLACK);
S    RMP_Line(Coord_X,Coord_Y+Width-1,Coord_X,Coord_Y,RMP_CTL_BLACK);
S}
S#endif
S#endif
S#endif
S#endif
S#endif
S#endif
S#endif
N#endif
N/* End Function:RMP_Progbar **************************************************/
N
N/* End Of File ***************************************************************/
N
N/* Copyright (C) Evo-Devo Instrum. All rights reserved ***********************/
