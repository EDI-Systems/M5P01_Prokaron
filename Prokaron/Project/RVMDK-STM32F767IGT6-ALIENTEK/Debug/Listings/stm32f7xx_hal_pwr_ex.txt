; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f7xx_hal_pwr_ex.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f7xx_hal_pwr_ex.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Core -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Inc -I.\Source -I.\Drivers -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6-ALIENTEK\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f7xx_hal_pwr_ex.crf ..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_pwr_ex.c]
                          THUMB

                          AREA ||i.HAL_PWREx_ControlVoltageScaling||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_ControlVoltageScaling PROC
;;;492      */
;;;493    HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling)
000000  4929              LDR      r1,|L1.168|
;;;494    {
000002  b5f8              PUSH     {r3-r7,lr}
000004  4605              MOV      r5,r0
;;;495      uint32_t tickstart = 0;
;;;496    
;;;497      assert_param(IS_PWR_REGULATOR_VOLTAGE(VoltageScaling));
;;;498    
;;;499      /* Enable Power ctrl clock */
;;;500      __HAL_RCC_PWR_CLK_ENABLE();
000006  6808              LDR      r0,[r1,#0]
000008  f0405080          ORR      r0,r0,#0x10000000
00000c  6008              STR      r0,[r1,#0]
00000e  6808              LDR      r0,[r1,#0]
000010  f0005080          AND      r0,r0,#0x10000000
;;;501    
;;;502      /* Check if the PLL is used as system clock or not */
;;;503      if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
000014  9000              STR      r0,[sp,#0]
000016  4824              LDR      r0,|L1.168|
000018  3838              SUBS     r0,r0,#0x38
00001a  6800              LDR      r0,[r0,#0]
00001c  f3c00081          UBFX     r0,r0,#2,#2
000020  2802              CMP      r0,#2
000022  d03e              BEQ      |L1.162|
;;;504      {
;;;505        /* Disable the main PLL */
;;;506        __HAL_RCC_PLL_DISABLE();
000024  4c20              LDR      r4,|L1.168|
000026  3c40              SUBS     r4,r4,#0x40
000028  6820              LDR      r0,[r4,#0]
00002a  f0207080          BIC      r0,r0,#0x1000000
00002e  6020              STR      r0,[r4,#0]
;;;507        
;;;508        /* Get Start Tick */
;;;509        tickstart = HAL_GetTick();    
000030  f7fffffe          BL       HAL_GetTick
000034  4606              MOV      r6,r0
;;;510        /* Wait till PLL is disabled */  
;;;511        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
000036  e004              B        |L1.66|
                  |L1.56|
;;;512        {
;;;513          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
000038  f7fffffe          BL       HAL_GetTick
00003c  1b80              SUBS     r0,r0,r6
00003e  2802              CMP      r0,#2
000040  d827              BHI      |L1.146|
                  |L1.66|
000042  6820              LDR      r0,[r4,#0]            ;511
000044  0180              LSLS     r0,r0,#6              ;511
000046  d4f7              BMI      |L1.56|
;;;514          {
;;;515            return HAL_TIMEOUT;
;;;516          }
;;;517        }
;;;518        
;;;519        /* Set Range */
;;;520        __HAL_PWR_VOLTAGESCALING_CONFIG(VoltageScaling);
000048  4e18              LDR      r6,|L1.172|
00004a  6830              LDR      r0,[r6,#0]
00004c  f4204040          BIC      r0,r0,#0xc000
000050  4328              ORRS     r0,r0,r5
000052  6030              STR      r0,[r6,#0]
000054  6830              LDR      r0,[r6,#0]
000056  f4004040          AND      r0,r0,#0xc000
;;;521        
;;;522        /* Enable the main PLL */
;;;523        __HAL_RCC_PLL_ENABLE();
00005a  9000              STR      r0,[sp,#0]
00005c  6820              LDR      r0,[r4,#0]
00005e  f0407080          ORR      r0,r0,#0x1000000
000062  6020              STR      r0,[r4,#0]
;;;524        
;;;525        /* Get Start Tick */
;;;526        tickstart = HAL_GetTick();
000064  f7fffffe          BL       HAL_GetTick
000068  4605              MOV      r5,r0
;;;527        /* Wait till PLL is ready */  
;;;528        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
00006a  e004              B        |L1.118|
                  |L1.108|
;;;529        {
;;;530          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
00006c  f7fffffe          BL       HAL_GetTick
000070  1b40              SUBS     r0,r0,r5
000072  2802              CMP      r0,#2
000074  d80d              BHI      |L1.146|
                  |L1.118|
000076  6820              LDR      r0,[r4,#0]            ;528
000078  0180              LSLS     r0,r0,#6              ;528
00007a  d5f7              BPL      |L1.108|
;;;531          {
;;;532            return HAL_TIMEOUT;
;;;533          } 
;;;534        }
;;;535        
;;;536        /* Get Start Tick */
;;;537        tickstart = HAL_GetTick();
00007c  f7fffffe          BL       HAL_GetTick
;;;538        while((__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY) == RESET))
;;;539        {
;;;540          if((HAL_GetTick() - tickstart ) > PWR_VOSRDY_TIMEOUT_VALUE)
000080  f44f757a          MOV      r5,#0x3e8
000084  4604              MOV      r4,r0                 ;537
000086  e006              B        |L1.150|
                  |L1.136|
000088  f7fffffe          BL       HAL_GetTick
00008c  1b00              SUBS     r0,r0,r4
00008e  42a8              CMP      r0,r5
000090  d901              BLS      |L1.150|
                  |L1.146|
;;;541          {
;;;542            return HAL_TIMEOUT;
000092  2003              MOVS     r0,#3
;;;543          } 
;;;544        }
;;;545      }
;;;546      else
;;;547      {
;;;548        return HAL_ERROR;
;;;549      }
;;;550      return HAL_OK;
;;;551    }
000094  bdf8              POP      {r3-r7,pc}
                  |L1.150|
000096  6870              LDR      r0,[r6,#4]            ;538
000098  43c0              MVNS     r0,r0                 ;538
00009a  0440              LSLS     r0,r0,#17             ;538
00009c  d4f4              BMI      |L1.136|
00009e  2000              MOVS     r0,#0                 ;550
0000a0  bdf8              POP      {r3-r7,pc}
                  |L1.162|
0000a2  2001              MOVS     r0,#1                 ;548
0000a4  bdf8              POP      {r3-r7,pc}
;;;552    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L1.168|
                          DCD      0x40023840
                  |L1.172|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_DisableBkUpReg||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisableBkUpReg PROC
;;;179      */
;;;180    HAL_StatusTypeDef HAL_PWREx_DisableBkUpReg(void)
000000  b570              PUSH     {r4-r6,lr}
;;;181    {
;;;182      uint32_t tickstart = 0;
;;;183      
;;;184      /* Disable Backup regulator */
;;;185      PWR->CSR1 &= (uint32_t)~((uint32_t)PWR_CSR1_BRE);
000002  4c0e              LDR      r4,|L2.60|
000004  6860              LDR      r0,[r4,#4]
000006  f4207000          BIC      r0,r0,#0x200
00000a  6060              STR      r0,[r4,#4]
;;;186      
;;;187      /* Workaround for the following hardware bug: */
;;;188      /* Id 19: PWR : No STANDBY wake-up when Back-up RAM enabled (ref. Errata Sheet p23) */
;;;189      PWR->CSR1 |= PWR_CSR1_EIWUP;
00000c  6860              LDR      r0,[r4,#4]
00000e  f4407080          ORR      r0,r0,#0x100
000012  6060              STR      r0,[r4,#4]
;;;190    
;;;191      /* Get tick */
;;;192      tickstart = HAL_GetTick();
000014  f7fffffe          BL       HAL_GetTick
;;;193    
;;;194      /* Wait till Backup regulator ready flag is set */  
;;;195      while(__HAL_PWR_GET_FLAG(PWR_FLAG_BRR) != RESET)
;;;196      {
;;;197        if((HAL_GetTick() - tickstart ) > PWR_BKPREG_TIMEOUT_VALUE)
000018  f44f767a          MOV      r6,#0x3e8
00001c  4605              MOV      r5,r0                 ;192
00001e  e006              B        |L2.46|
                  |L2.32|
000020  f7fffffe          BL       HAL_GetTick
000024  1b40              SUBS     r0,r0,r5
000026  42b0              CMP      r0,r6
000028  d901              BLS      |L2.46|
;;;198        {
;;;199          return HAL_TIMEOUT;
00002a  2003              MOVS     r0,#3
;;;200        } 
;;;201      }
;;;202      return HAL_OK;
;;;203    }
00002c  bd70              POP      {r4-r6,pc}
                  |L2.46|
00002e  6860              LDR      r0,[r4,#4]            ;195
000030  43c0              MVNS     r0,r0                 ;195
000032  0700              LSLS     r0,r0,#28             ;195
000034  d5f4              BPL      |L2.32|
000036  2000              MOVS     r0,#0                 ;202
000038  bd70              POP      {r4-r6,pc}
;;;204    
                          ENDP

00003a  0000              DCW      0x0000
                  |L2.60|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_DisableFlashPowerDown||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisableFlashPowerDown PROC
;;;218      */
;;;219    void HAL_PWREx_DisableFlashPowerDown(void)
000000  4802              LDR      r0,|L3.12|
;;;220    {
;;;221      /* Disable the Flash Power Down */
;;;222      PWR->CR1 &= (uint32_t)~((uint32_t)PWR_CR1_FPDS);
000002  6801              LDR      r1,[r0,#0]
000004  f4217100          BIC      r1,r1,#0x200
000008  6001              STR      r1,[r0,#0]
;;;223    }
00000a  4770              BX       lr
;;;224    
                          ENDP

                  |L3.12|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_DisableLowRegulatorLowVoltage||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisableLowRegulatorLowVoltage PROC
;;;258      */
;;;259    void HAL_PWREx_DisableLowRegulatorLowVoltage(void)
000000  4802              LDR      r0,|L4.12|
;;;260    {
;;;261      /* Disable low power regulator */
;;;262      PWR->CR1 &= (uint32_t)~((uint32_t)PWR_CR1_LPUDS);
000002  6801              LDR      r1,[r0,#0]
000004  f4216180          BIC      r1,r1,#0x400
000008  6001              STR      r1,[r0,#0]
;;;263    }
00000a  4770              BX       lr
;;;264    
                          ENDP

                  |L4.12|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_DisableMainRegulatorLowVoltage||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisableMainRegulatorLowVoltage PROC
;;;238      */
;;;239    void HAL_PWREx_DisableMainRegulatorLowVoltage(void)
000000  4802              LDR      r0,|L5.12|
;;;240    {  
;;;241      /* Disable Main regulator low voltage */
;;;242      PWR->CR1 &= (uint32_t)~((uint32_t)PWR_CR1_MRUDS);
000002  6801              LDR      r1,[r0,#0]
000004  f4216100          BIC      r1,r1,#0x800
000008  6001              STR      r1,[r0,#0]
;;;243    }
00000a  4770              BX       lr
;;;244    
                          ENDP

                  |L5.12|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_DisableOverDrive||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisableOverDrive PROC
;;;320      */
;;;321    HAL_StatusTypeDef HAL_PWREx_DisableOverDrive(void)
000000  4818              LDR      r0,|L6.100|
;;;322    {
000002  b5f8              PUSH     {r3-r7,lr}
;;;323      uint32_t tickstart = 0;
;;;324      
;;;325      __HAL_RCC_PWR_CLK_ENABLE();
000004  6801              LDR      r1,[r0,#0]
000006  f0415180          ORR      r1,r1,#0x10000000
00000a  6001              STR      r1,[r0,#0]
00000c  6800              LDR      r0,[r0,#0]
;;;326        
;;;327      /* Disable the Over-drive switch */
;;;328      __HAL_PWR_OVERDRIVESWITCHING_DISABLE();
00000e  4c16              LDR      r4,|L6.104|
000010  f0005080          AND      r0,r0,#0x10000000     ;325
000014  9000              STR      r0,[sp,#0]
000016  6820              LDR      r0,[r4,#0]
000018  f4203000          BIC      r0,r0,#0x20000
00001c  6020              STR      r0,[r4,#0]
;;;329      
;;;330      /* Get tick */
;;;331      tickstart = HAL_GetTick();
00001e  f7fffffe          BL       HAL_GetTick
;;;332     
;;;333      while(__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
;;;334      {
;;;335        if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
000022  f44f767a          MOV      r6,#0x3e8
000026  4605              MOV      r5,r0                 ;331
000028  e005              B        |L6.54|
00002a  bf00              NOP      
                  |L6.44|
00002c  f7fffffe          BL       HAL_GetTick
000030  1b40              SUBS     r0,r0,r5
000032  42b0              CMP      r0,r6
000034  d80f              BHI      |L6.86|
                  |L6.54|
000036  6860              LDR      r0,[r4,#4]            ;333
000038  0380              LSLS     r0,r0,#14             ;333
00003a  d4f7              BMI      |L6.44|
;;;336        {
;;;337          return HAL_TIMEOUT;
;;;338        }
;;;339      } 
;;;340      
;;;341      /* Disable the Over-drive */
;;;342      __HAL_PWR_OVERDRIVE_DISABLE();
00003c  6820              LDR      r0,[r4,#0]
00003e  f4203080          BIC      r0,r0,#0x10000
000042  6020              STR      r0,[r4,#0]
;;;343    
;;;344      /* Get tick */
;;;345      tickstart = HAL_GetTick();
000044  f7fffffe          BL       HAL_GetTick
000048  4605              MOV      r5,r0
;;;346    
;;;347      while(__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
00004a  e006              B        |L6.90|
                  |L6.76|
;;;348      {
;;;349        if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
00004c  f7fffffe          BL       HAL_GetTick
000050  1b40              SUBS     r0,r0,r5
000052  42b0              CMP      r0,r6
000054  d901              BLS      |L6.90|
                  |L6.86|
;;;350        {
;;;351          return HAL_TIMEOUT;
000056  2003              MOVS     r0,#3
;;;352        }
;;;353      }
;;;354      
;;;355      return HAL_OK;
;;;356    }
000058  bdf8              POP      {r3-r7,pc}
                  |L6.90|
00005a  6860              LDR      r0,[r4,#4]            ;347
00005c  03c0              LSLS     r0,r0,#15             ;347
00005e  d4f5              BMI      |L6.76|
000060  2000              MOVS     r0,#0                 ;355
000062  bdf8              POP      {r3-r7,pc}
;;;357    
                          ENDP

                  |L6.100|
                          DCD      0x40023840
                  |L6.104|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnableBkUpReg||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnableBkUpReg PROC
;;;150      */
;;;151    HAL_StatusTypeDef HAL_PWREx_EnableBkUpReg(void)
000000  b570              PUSH     {r4-r6,lr}
;;;152    {
;;;153      uint32_t tickstart = 0;
;;;154    
;;;155      /* Enable Backup regulator */
;;;156      PWR->CSR1 |= PWR_CSR1_BRE;
000002  4c0e              LDR      r4,|L7.60|
000004  6860              LDR      r0,[r4,#4]
000006  f4407000          ORR      r0,r0,#0x200
00000a  6060              STR      r0,[r4,#4]
;;;157        
;;;158      /* Workaround for the following hardware bug: */
;;;159      /* Id 19: PWR : No STANDBY wake-up when Back-up RAM enabled (ref. Errata Sheet p23) */
;;;160      PWR->CSR1 |= PWR_CSR1_EIWUP;
00000c  6860              LDR      r0,[r4,#4]
00000e  f4407080          ORR      r0,r0,#0x100
000012  6060              STR      r0,[r4,#4]
;;;161    
;;;162      /* Get tick */
;;;163      tickstart = HAL_GetTick();
000014  f7fffffe          BL       HAL_GetTick
;;;164    
;;;165      /* Wait till Backup regulator ready flag is set */  
;;;166      while(__HAL_PWR_GET_FLAG(PWR_FLAG_BRR) == RESET)
;;;167      {
;;;168        if((HAL_GetTick() - tickstart ) > PWR_BKPREG_TIMEOUT_VALUE)
000018  f44f767a          MOV      r6,#0x3e8
00001c  4605              MOV      r5,r0                 ;163
00001e  e006              B        |L7.46|
                  |L7.32|
000020  f7fffffe          BL       HAL_GetTick
000024  1b40              SUBS     r0,r0,r5
000026  42b0              CMP      r0,r6
000028  d901              BLS      |L7.46|
;;;169        {
;;;170          return HAL_TIMEOUT;
00002a  2003              MOVS     r0,#3
;;;171        } 
;;;172      }
;;;173      return HAL_OK;
;;;174    }
00002c  bd70              POP      {r4-r6,pc}
                  |L7.46|
00002e  6860              LDR      r0,[r4,#4]            ;166
000030  43c0              MVNS     r0,r0                 ;166
000032  0700              LSLS     r0,r0,#28             ;166
000034  d4f4              BMI      |L7.32|
000036  2000              MOVS     r0,#0                 ;173
000038  bd70              POP      {r4-r6,pc}
;;;175    
                          ENDP

00003a  0000              DCW      0x0000
                  |L7.60|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnableFlashPowerDown||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnableFlashPowerDown PROC
;;;208      */
;;;209    void HAL_PWREx_EnableFlashPowerDown(void)
000000  4802              LDR      r0,|L8.12|
;;;210    {
;;;211      /* Enable the Flash Power Down */
;;;212      PWR->CR1 |= PWR_CR1_FPDS;
000002  6801              LDR      r1,[r0,#0]
000004  f4417100          ORR      r1,r1,#0x200
000008  6001              STR      r1,[r0,#0]
;;;213    }
00000a  4770              BX       lr
;;;214    
                          ENDP

                  |L8.12|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnableLowRegulatorLowVoltage||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnableLowRegulatorLowVoltage PROC
;;;248      */
;;;249    void HAL_PWREx_EnableLowRegulatorLowVoltage(void)
000000  4802              LDR      r0,|L9.12|
;;;250    {
;;;251      /* Enable low power regulator */
;;;252      PWR->CR1 |= PWR_CR1_LPUDS;
000002  6801              LDR      r1,[r0,#0]
000004  f4416180          ORR      r1,r1,#0x400
000008  6001              STR      r1,[r0,#0]
;;;253    }
00000a  4770              BX       lr
;;;254    
                          ENDP

                  |L9.12|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnableMainRegulatorLowVoltage||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnableMainRegulatorLowVoltage PROC
;;;228      */
;;;229    void HAL_PWREx_EnableMainRegulatorLowVoltage(void)
000000  4802              LDR      r0,|L10.12|
;;;230    {
;;;231      /* Enable Main regulator low voltage */
;;;232      PWR->CR1 |= PWR_CR1_MRUDS;
000002  6801              LDR      r1,[r0,#0]
000004  f4416100          ORR      r1,r1,#0x800
000008  6001              STR      r1,[r0,#0]
;;;233    }
00000a  4770              BX       lr
;;;234    
                          ENDP

                  |L10.12|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnableOverDrive||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnableOverDrive PROC
;;;274      */
;;;275    HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
000000  4818              LDR      r0,|L11.100|
;;;276    {
000002  b5f8              PUSH     {r3-r7,lr}
;;;277      uint32_t tickstart = 0;
;;;278    
;;;279      __HAL_RCC_PWR_CLK_ENABLE();
000004  6801              LDR      r1,[r0,#0]
000006  f0415180          ORR      r1,r1,#0x10000000
00000a  6001              STR      r1,[r0,#0]
00000c  6800              LDR      r0,[r0,#0]
;;;280      
;;;281      /* Enable the Over-drive to extend the clock frequency to 216 MHz */
;;;282      __HAL_PWR_OVERDRIVE_ENABLE();
00000e  4c16              LDR      r4,|L11.104|
000010  f0005080          AND      r0,r0,#0x10000000     ;279
000014  9000              STR      r0,[sp,#0]
000016  6820              LDR      r0,[r4,#0]
000018  f4403080          ORR      r0,r0,#0x10000
00001c  6020              STR      r0,[r4,#0]
;;;283    
;;;284      /* Get tick */
;;;285      tickstart = HAL_GetTick();
00001e  f7fffffe          BL       HAL_GetTick
;;;286    
;;;287      while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
;;;288      {
;;;289        if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
000022  f44f767a          MOV      r6,#0x3e8
000026  4605              MOV      r5,r0                 ;285
000028  e005              B        |L11.54|
00002a  bf00              NOP      
                  |L11.44|
00002c  f7fffffe          BL       HAL_GetTick
000030  1b40              SUBS     r0,r0,r5
000032  42b0              CMP      r0,r6
000034  d80f              BHI      |L11.86|
                  |L11.54|
000036  6860              LDR      r0,[r4,#4]            ;287
000038  03c0              LSLS     r0,r0,#15             ;287
00003a  d5f7              BPL      |L11.44|
;;;290        {
;;;291          return HAL_TIMEOUT;
;;;292        }
;;;293      }
;;;294      
;;;295      /* Enable the Over-drive switch */
;;;296      __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
00003c  6820              LDR      r0,[r4,#0]
00003e  f4403000          ORR      r0,r0,#0x20000
000042  6020              STR      r0,[r4,#0]
;;;297    
;;;298      /* Get tick */
;;;299      tickstart = HAL_GetTick();
000044  f7fffffe          BL       HAL_GetTick
000048  4605              MOV      r5,r0
;;;300    
;;;301      while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
00004a  e006              B        |L11.90|
                  |L11.76|
;;;302      {
;;;303        if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
00004c  f7fffffe          BL       HAL_GetTick
000050  1b40              SUBS     r0,r0,r5
000052  42b0              CMP      r0,r6
000054  d901              BLS      |L11.90|
                  |L11.86|
;;;304        {
;;;305          return HAL_TIMEOUT;
000056  2003              MOVS     r0,#3
;;;306        }
;;;307      } 
;;;308      return HAL_OK;
;;;309    }
000058  bdf8              POP      {r3-r7,pc}
                  |L11.90|
00005a  6860              LDR      r0,[r4,#4]            ;301
00005c  0380              LSLS     r0,r0,#14             ;301
00005e  d5f5              BPL      |L11.76|
000060  2000              MOVS     r0,#0                 ;308
000062  bdf8              POP      {r3-r7,pc}
;;;310    
                          ENDP

                  |L11.100|
                          DCD      0x40023840
                  |L11.104|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnterUnderDriveSTOPMode||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnterUnderDriveSTOPMode PROC
;;;394      */
;;;395    HAL_StatusTypeDef HAL_PWREx_EnterUnderDriveSTOPMode(uint32_t Regulator, uint8_t STOPEntry)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;396    {
000004  4680              MOV      r8,r0
;;;397      uint32_t tempreg = 0;
;;;398      uint32_t tickstart = 0;
;;;399      
;;;400      /* Check the parameters */
;;;401      assert_param(IS_PWR_REGULATOR_UNDERDRIVE(Regulator));
;;;402      assert_param(IS_PWR_STOP_ENTRY(STOPEntry));
;;;403      
;;;404      /* Enable Power ctrl clock */
;;;405      __HAL_RCC_PWR_CLK_ENABLE();
000006  481f              LDR      r0,|L12.132|
000008  460d              MOV      r5,r1                 ;396
00000a  6801              LDR      r1,[r0,#0]
00000c  f0415180          ORR      r1,r1,#0x10000000
000010  6001              STR      r1,[r0,#0]
000012  6800              LDR      r0,[r0,#0]
;;;406      /* Enable the Under-drive Mode ---------------------------------------------*/
;;;407      /* Clear Under-drive flag */
;;;408      __HAL_PWR_CLEAR_ODRUDR_FLAG();
000014  4c1c              LDR      r4,|L12.136|
000016  f0005080          AND      r0,r0,#0x10000000     ;405
00001a  9000              STR      r0,[sp,#0]
00001c  6860              LDR      r0,[r4,#4]
00001e  f4402040          ORR      r0,r0,#0xc0000
000022  6060              STR      r0,[r4,#4]
;;;409      
;;;410      /* Enable the Under-drive */ 
;;;411      __HAL_PWR_UNDERDRIVE_ENABLE();
000024  6820              LDR      r0,[r4,#0]
000026  f4402040          ORR      r0,r0,#0xc0000
00002a  6020              STR      r0,[r4,#0]
;;;412    
;;;413      /* Get tick */
;;;414      tickstart = HAL_GetTick();
00002c  f7fffffe          BL       HAL_GetTick
;;;415    
;;;416      /* Wait for UnderDrive mode is ready */
;;;417      while(__HAL_PWR_GET_FLAG(PWR_FLAG_UDRDY))
;;;418      {
;;;419        if((HAL_GetTick() - tickstart ) > PWR_UDERDRIVE_TIMEOUT_VALUE)
000030  f44f777a          MOV      r7,#0x3e8
000034  4606              MOV      r6,r0                 ;414
000036  e007              B        |L12.72|
                  |L12.56|
000038  f7fffffe          BL       HAL_GetTick
00003c  1b80              SUBS     r0,r0,r6
00003e  42b8              CMP      r0,r7
000040  d902              BLS      |L12.72|
;;;420        {
;;;421          return HAL_TIMEOUT;
000042  2003              MOVS     r0,#3
                  |L12.68|
;;;422        }
;;;423      }
;;;424      
;;;425      /* Select the regulator state in STOP mode ---------------------------------*/
;;;426      tempreg = PWR->CR1;
;;;427      /* Clear PDDS, LPDS, MRLUDS and LPLUDS bits */
;;;428      tempreg &= (uint32_t)~(PWR_CR1_PDDS | PWR_CR1_LPDS | PWR_CR1_LPUDS | PWR_CR1_MRUDS);
;;;429      
;;;430      /* Set LPDS, MRLUDS and LPLUDS bits according to PWR_Regulator value */
;;;431      tempreg |= Regulator;
;;;432      
;;;433      /* Store the new value */
;;;434      PWR->CR1 = tempreg;
;;;435      
;;;436      /* Set SLEEPDEEP bit of Cortex System Control Register */
;;;437      SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
;;;438      
;;;439      /* Select STOP mode entry --------------------------------------------------*/
;;;440      if(STOPEntry == PWR_SLEEPENTRY_WFI)
;;;441      {   
;;;442        /* Request Wait For Interrupt */
;;;443        __WFI();
;;;444      }
;;;445      else
;;;446      {
;;;447        /* Request Wait For Event */
;;;448        __WFE();
;;;449      }
;;;450      /* Reset SLEEPDEEP bit of Cortex System Control Register */
;;;451      SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);
;;;452    
;;;453      return HAL_OK;  
;;;454    }
000044  e8bd83f8          POP      {r3-r9,pc}
                  |L12.72|
000048  6860              LDR      r0,[r4,#4]            ;417
00004a  f3c04081          UBFX     r0,r0,#18,#2          ;417
00004e  2803              CMP      r0,#3                 ;417
000050  d0f2              BEQ      |L12.56|
000052  480e              LDR      r0,|L12.140|
000054  f6404203          MOV      r2,#0xc03             ;428
000058  6821              LDR      r1,[r4,#0]            ;426
00005a  2d01              CMP      r5,#1                 ;440
00005c  ea210102          BIC      r1,r1,r2              ;428
000060  ea410108          ORR      r1,r1,r8              ;431
000064  6021              STR      r1,[r4,#0]            ;434
000066  6801              LDR      r1,[r0,#0]            ;437
000068  f0410104          ORR      r1,r1,#4              ;437
00006c  6001              STR      r1,[r0,#0]            ;437
00006e  d006              BEQ      |L12.126|
000070  bf20              WFE                            ;448
                  |L12.114|
000072  6801              LDR      r1,[r0,#0]            ;451
000074  f0210104          BIC      r1,r1,#4              ;451
000078  6001              STR      r1,[r0,#0]            ;451
00007a  2000              MOVS     r0,#0                 ;453
00007c  e7e2              B        |L12.68|
                  |L12.126|
00007e  bf30              WFI                            ;443
000080  e7f7              B        |L12.114|
;;;455    
                          ENDP

000082  0000              DCW      0x0000
                  |L12.132|
                          DCD      0x40023840
                  |L12.136|
                          DCD      0x40007000
                  |L12.140|
                          DCD      0xe000ed10

                          AREA ||i.HAL_PWREx_GetVoltageRange||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_GetVoltageRange PROC
;;;460      */  
;;;461    uint32_t HAL_PWREx_GetVoltageRange(void)
000000  4802              LDR      r0,|L13.12|
;;;462    {
;;;463      return  (PWR->CR1 & PWR_CR1_VOS);
000002  6800              LDR      r0,[r0,#0]
000004  f4004040          AND      r0,r0,#0xc000
;;;464    }
000008  4770              BX       lr
;;;465    
                          ENDP

00000a  0000              DCW      0x0000
                  |L13.12|
                          DCD      0x40007000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F7_V1.11.0\\Drivers\\STM32F7xx_HAL_Driver\\Src\\stm32f7xx_hal_pwr_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f7xx_hal_pwr_ex_c_1028ebfa____REV16|
#line 468 "D:\\Program_Files_x86\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.3.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___22_stm32f7xx_hal_pwr_ex_c_1028ebfa____REV16| PROC
#line 469

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f7xx_hal_pwr_ex_c_1028ebfa____REVSH|
#line 483
|__asm___22_stm32f7xx_hal_pwr_ex_c_1028ebfa____REVSH| PROC
#line 484

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f7xx_hal_pwr_ex_c_1028ebfa____RRX|
#line 670
|__asm___22_stm32f7xx_hal_pwr_ex_c_1028ebfa____RRX| PROC
#line 671

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
