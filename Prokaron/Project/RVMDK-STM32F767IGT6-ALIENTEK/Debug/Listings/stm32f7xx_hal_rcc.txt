; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f7xx_hal_rcc.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f7xx_hal_rcc.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Core -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Inc -I.\Source -I.\Drivers -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6-ALIENTEK\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f7xx_hal_rcc.crf ..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_rcc.c]
                          THUMB

                          AREA ||i.HAL_RCC_CSSCallback||, CODE, READONLY, ALIGN=1

                  HAL_RCC_CSSCallback PROC
;;;1212     */
;;;1213   __weak void HAL_RCC_CSSCallback(void)
000000  4770              BX       lr
;;;1214   {
;;;1215     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1216               the HAL_RCC_CSSCallback could be implemented in the user file
;;;1217      */
;;;1218   }
;;;1219   
                          ENDP


                          AREA ||i.HAL_RCC_ClockConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_ClockConfig PROC
;;;718      */
;;;719    HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;720    {
000004  0005              MOVS     r5,r0
000006  460f              MOV      r7,r1
000008  d063              BEQ      |L2.210|
;;;721      uint32_t tickstart = 0;
;;;722    
;;;723      /* Check Null pointer */
;;;724      if(RCC_ClkInitStruct == NULL)
;;;725      {
;;;726        return HAL_ERROR;
;;;727      }
;;;728    
;;;729      /* Check the parameters */
;;;730      assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
;;;731      assert_param(IS_FLASH_LATENCY(FLatency));
;;;732    
;;;733      /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
;;;734         must be correctly programmed according to the frequency of the CPU clock
;;;735         (HCLK) and the supply voltage of the device. */
;;;736    
;;;737      /* Increasing the CPU frequency */
;;;738      if(FLatency > __HAL_FLASH_GET_LATENCY())
00000a  4e44              LDR      r6,|L2.284|
00000c  6830              LDR      r0,[r6,#0]
00000e  f000000f          AND      r0,r0,#0xf
000012  42b8              CMP      r0,r7
000014  d209              BCS      |L2.42|
;;;739      {
;;;740        /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
;;;741        __HAL_FLASH_SET_LATENCY(FLatency);
000016  6830              LDR      r0,[r6,#0]
000018  f020000f          BIC      r0,r0,#0xf
00001c  4338              ORRS     r0,r0,r7
00001e  6030              STR      r0,[r6,#0]
;;;742    
;;;743        /* Check that the new number of wait states is taken into account to access the Flash
;;;744        memory by reading the FLASH_ACR register */
;;;745        if(__HAL_FLASH_GET_LATENCY() != FLatency)
000020  6830              LDR      r0,[r6,#0]
000022  f000000f          AND      r0,r0,#0xf
000026  42b8              CMP      r0,r7
000028  d153              BNE      |L2.210|
                  |L2.42|
;;;746        {
;;;747          return HAL_ERROR;
;;;748        }
;;;749      }
;;;750    
;;;751      /*-------------------------- HCLK Configuration --------------------------*/
;;;752      if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
00002a  6828              LDR      r0,[r5,#0]
;;;753      {
;;;754        /* Set the highest APBx dividers in order to ensure that we do not go through
;;;755           a non-spec phase whatever we decrease or increase HCLK. */
;;;756        if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
;;;757        {
;;;758          MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
00002c  4c3c              LDR      r4,|L2.288|
00002e  0781              LSLS     r1,r0,#30             ;752
000030  d512              BPL      |L2.88|
000032  0740              LSLS     r0,r0,#29             ;756
000034  d503              BPL      |L2.62|
000036  6820              LDR      r0,[r4,#0]
000038  f44050e0          ORR      r0,r0,#0x1c00
00003c  6020              STR      r0,[r4,#0]
                  |L2.62|
;;;759        }
;;;760    
;;;761        if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
00003e  7828              LDRB     r0,[r5,#0]
000040  0700              LSLS     r0,r0,#28
000042  d503              BPL      |L2.76|
;;;762        {
;;;763          MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
000044  6820              LDR      r0,[r4,#0]
000046  f4404060          ORR      r0,r0,#0xe000
00004a  6020              STR      r0,[r4,#0]
                  |L2.76|
;;;764        }
;;;765    
;;;766        /* Set the new HCLK clock divider */
;;;767        assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
;;;768        MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
00004c  68a9              LDR      r1,[r5,#8]
00004e  6820              LDR      r0,[r4,#0]
000050  f02000f0          BIC      r0,r0,#0xf0
000054  4308              ORRS     r0,r0,r1
000056  6020              STR      r0,[r4,#0]
                  |L2.88|
;;;769      }
;;;770    
;;;771      /*------------------------- SYSCLK Configuration ---------------------------*/
;;;772      if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
000058  7828              LDRB     r0,[r5,#0]
00005a  07c0              LSLS     r0,r0,#31
00005c  d02a              BEQ      |L2.180|
;;;773      {
;;;774        assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
;;;775    
;;;776        /* HSE is selected as System Clock Source */
;;;777        if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
;;;778        {
;;;779          /* Check the HSE ready flag */
;;;780          if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
00005e  4930              LDR      r1,|L2.288|
000060  6868              LDR      r0,[r5,#4]            ;777
000062  3908              SUBS     r1,r1,#8
000064  2801              CMP      r0,#1                 ;777
000066  d010              BEQ      |L2.138|
;;;781          {
;;;782            return HAL_ERROR;
;;;783          }
;;;784        }
;;;785        /* PLL is selected as System Clock Source */
;;;786        else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
;;;787        {
;;;788          /* Check the PLL ready flag */
;;;789          if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
;;;790          {
;;;791            return HAL_ERROR;
;;;792          }
;;;793        }
;;;794        /* HSI is selected as System Clock Source */
;;;795        else
;;;796        {
;;;797          /* Check the HSI ready flag */
;;;798          if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
000068  6809              LDR      r1,[r1,#0]
00006a  2802              CMP      r0,#2                 ;786
00006c  d010              BEQ      |L2.144|
00006e  0789              LSLS     r1,r1,#30
                  |L2.112|
000070  2900              CMP      r1,#0
000072  da2e              BGE      |L2.210|
;;;799          {
;;;800            return HAL_ERROR;
;;;801          }
;;;802        }
;;;803    
;;;804        __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
000074  6821              LDR      r1,[r4,#0]
000076  f0210103          BIC      r1,r1,#3
00007a  4301              ORRS     r1,r1,r0
00007c  6021              STR      r1,[r4,#0]
;;;805    
;;;806        /* Get Start Tick*/
;;;807        tickstart = HAL_GetTick();
00007e  f7fffffe          BL       HAL_GetTick
000082  4680              MOV      r8,r0
;;;808    
;;;809        while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
;;;810        {
;;;811          if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
000084  f2413988          MOV      r9,#0x1388
000088  e00d              B        |L2.166|
                  |L2.138|
00008a  6809              LDR      r1,[r1,#0]            ;780
00008c  0389              LSLS     r1,r1,#14             ;780
00008e  e7ef              B        |L2.112|
                  |L2.144|
000090  0189              LSLS     r1,r1,#6              ;789
000092  e7ed              B        |L2.112|
                  |L2.148|
000094  f7fffffe          BL       HAL_GetTick
000098  eba00108          SUB      r1,r0,r8
00009c  4549              CMP      r1,r9
00009e  d902              BLS      |L2.166|
;;;812          {
;;;813            return HAL_TIMEOUT;
0000a0  2003              MOVS     r0,#3
                  |L2.162|
;;;814          }
;;;815        }
;;;816      }
;;;817    
;;;818      /* Decreasing the number of wait states because of lower CPU frequency */
;;;819      if(FLatency < __HAL_FLASH_GET_LATENCY())
;;;820      {
;;;821        /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
;;;822        __HAL_FLASH_SET_LATENCY(FLatency);
;;;823    
;;;824        /* Check that the new number of wait states is taken into account to access the Flash
;;;825        memory by reading the FLASH_ACR register */
;;;826        if(__HAL_FLASH_GET_LATENCY() != FLatency)
;;;827        {
;;;828          return HAL_ERROR;
;;;829        }
;;;830      }
;;;831    
;;;832      /*-------------------------- PCLK1 Configuration ---------------------------*/
;;;833      if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
;;;834      {
;;;835        assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
;;;836        MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
;;;837      }
;;;838    
;;;839      /*-------------------------- PCLK2 Configuration ---------------------------*/
;;;840      if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
;;;841      {
;;;842        assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
;;;843        MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
;;;844      }
;;;845    
;;;846      /* Update the SystemCoreClock global variable */
;;;847      SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
;;;848    
;;;849      /* Configure the source of time base considering new system clocks settings*/
;;;850      HAL_InitTick (TICK_INT_PRIORITY);
;;;851    
;;;852      return HAL_OK;
;;;853    }
0000a2  e8bd87f0          POP      {r4-r10,pc}
                  |L2.166|
0000a6  6868              LDR      r0,[r5,#4]            ;809
0000a8  6821              LDR      r1,[r4,#0]            ;809
0000aa  f001010c          AND      r1,r1,#0xc            ;809
0000ae  ebb10f80          CMP      r1,r0,LSL #2          ;809
0000b2  d1ef              BNE      |L2.148|
                  |L2.180|
0000b4  6830              LDR      r0,[r6,#0]            ;819
0000b6  f000000f          AND      r0,r0,#0xf            ;819
0000ba  42b8              CMP      r0,r7                 ;819
0000bc  d90b              BLS      |L2.214|
0000be  6830              LDR      r0,[r6,#0]            ;822
0000c0  f020000f          BIC      r0,r0,#0xf            ;822
0000c4  4338              ORRS     r0,r0,r7              ;822
0000c6  6030              STR      r0,[r6,#0]            ;822
0000c8  6830              LDR      r0,[r6,#0]            ;826
0000ca  f000000f          AND      r0,r0,#0xf            ;826
0000ce  42b8              CMP      r0,r7                 ;826
0000d0  d001              BEQ      |L2.214|
                  |L2.210|
0000d2  2001              MOVS     r0,#1                 ;828
0000d4  e7e5              B        |L2.162|
                  |L2.214|
0000d6  7828              LDRB     r0,[r5,#0]            ;833
0000d8  0740              LSLS     r0,r0,#29             ;833
0000da  d505              BPL      |L2.232|
0000dc  68e9              LDR      r1,[r5,#0xc]          ;836
0000de  6820              LDR      r0,[r4,#0]            ;836
0000e0  f42050e0          BIC      r0,r0,#0x1c00         ;836
0000e4  4308              ORRS     r0,r0,r1              ;836
0000e6  6020              STR      r0,[r4,#0]            ;836
                  |L2.232|
0000e8  7828              LDRB     r0,[r5,#0]            ;840
0000ea  0700              LSLS     r0,r0,#28             ;840
0000ec  d506              BPL      |L2.252|
0000ee  6928              LDR      r0,[r5,#0x10]         ;843
0000f0  6821              LDR      r1,[r4,#0]            ;843
0000f2  f4214160          BIC      r1,r1,#0xe000         ;843
0000f6  ea4100c0          ORR      r0,r1,r0,LSL #3       ;843
0000fa  6020              STR      r0,[r4,#0]            ;843
                  |L2.252|
0000fc  f7fffffe          BL       HAL_RCC_GetSysClockFreq
000100  6821              LDR      r1,[r4,#0]            ;847
000102  4a08              LDR      r2,|L2.292|
000104  f3c11103          UBFX     r1,r1,#4,#4           ;847
000108  5c51              LDRB     r1,[r2,r1]            ;847
00010a  40c8              LSRS     r0,r0,r1              ;847
00010c  4906              LDR      r1,|L2.296|
00010e  6008              STR      r0,[r1,#0]            ;850  ; SystemCoreClock
000110  200f              MOVS     r0,#0xf               ;850
000112  f7fffffe          BL       HAL_InitTick
000116  2000              MOVS     r0,#0                 ;852
000118  e7c3              B        |L2.162|
;;;854    
                          ENDP

00011a  0000              DCW      0x0000
                  |L2.284|
                          DCD      0x40023c00
                  |L2.288|
                          DCD      0x40023808
                  |L2.292|
                          DCD      AHBPrescTable
                  |L2.296|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_RCC_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_RCC_DeInit PROC
;;;213      */
;;;214    HAL_StatusTypeDef HAL_RCC_DeInit(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;215    {
;;;216      uint32_t tickstart;
;;;217    
;;;218      /* Get Start Tick */
;;;219      tickstart = HAL_GetTick();
000004  f7fffffe          BL       HAL_GetTick
;;;220    
;;;221      /* Set HSION bit to the reset value */
;;;222      SET_BIT(RCC->CR, RCC_CR_HSION);
000008  4c49              LDR      r4,|L3.304|
00000a  4605              MOV      r5,r0                 ;219
00000c  6820              LDR      r0,[r4,#0]
00000e  f0400001          ORR      r0,r0,#1
000012  6020              STR      r0,[r4,#0]
;;;223    
;;;224      /* Wait till HSI is ready */
;;;225      while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == RESET)
000014  e005              B        |L3.34|
;;;226      {
;;;227        if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
000016  bf00              NOP      
                  |L3.24|
000018  f7fffffe          BL       HAL_GetTick
00001c  1b40              SUBS     r0,r0,r5
00001e  2802              CMP      r0,#2
000020  d857              BHI      |L3.210|
                  |L3.34|
000022  6820              LDR      r0,[r4,#0]            ;225
000024  0780              LSLS     r0,r0,#30             ;225
000026  d5f7              BPL      |L3.24|
;;;228        {
;;;229          return HAL_TIMEOUT;
;;;230        }
;;;231      }
;;;232    
;;;233      /* Set HSITRIM[4:0] bits to the reset value */
;;;234      SET_BIT(RCC->CR, RCC_CR_HSITRIM_4);
000028  6820              LDR      r0,[r4,#0]
00002a  f0400080          ORR      r0,r0,#0x80
00002e  6020              STR      r0,[r4,#0]
;;;235    
;;;236      /* Get Start Tick */
;;;237      tickstart = HAL_GetTick();
000030  f7fffffe          BL       HAL_GetTick
;;;238    
;;;239      /* Reset CFGR register */
;;;240      CLEAR_REG(RCC->CFGR);
000034  4e3e              LDR      r6,|L3.304|
000036  4605              MOV      r5,r0                 ;237
000038  3608              ADDS     r6,r6,#8
00003a  2000              MOVS     r0,#0
00003c  6030              STR      r0,[r6,#0]
;;;241    
;;;242      /* Wait till clock switch is ready */
;;;243      while (READ_BIT(RCC->CFGR, RCC_CFGR_SWS) != RESET)
;;;244      {
;;;245        if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
00003e  f2413788          MOV      r7,#0x1388
000042  e004              B        |L3.78|
                  |L3.68|
000044  f7fffffe          BL       HAL_GetTick
000048  1b40              SUBS     r0,r0,r5
00004a  42b8              CMP      r0,r7
00004c  d841              BHI      |L3.210|
                  |L3.78|
00004e  6830              LDR      r0,[r6,#0]            ;243
000050  f0100f0c          TST      r0,#0xc               ;243
000054  d1f6              BNE      |L3.68|
;;;246        {
;;;247          return HAL_TIMEOUT;
;;;248        }
;;;249      }
;;;250    
;;;251      /* Get Start Tick */
;;;252      tickstart = HAL_GetTick();
000056  f7fffffe          BL       HAL_GetTick
00005a  4605              MOV      r5,r0
;;;253    
;;;254      /* Clear HSEON, HSEBYP and CSSON bits */
;;;255      CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_HSEBYP | RCC_CR_CSSON);
00005c  6820              LDR      r0,[r4,#0]
00005e  f4202050          BIC      r0,r0,#0xd0000
000062  6020              STR      r0,[r4,#0]
;;;256    
;;;257      /* Wait till HSE is disabled */
;;;258      while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != RESET)
000064  e005              B        |L3.114|
;;;259      {
;;;260        if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
000066  bf00              NOP      
                  |L3.104|
000068  f7fffffe          BL       HAL_GetTick
00006c  1b40              SUBS     r0,r0,r5
00006e  2864              CMP      r0,#0x64
000070  d82f              BHI      |L3.210|
                  |L3.114|
000072  6820              LDR      r0,[r4,#0]            ;258
000074  0380              LSLS     r0,r0,#14             ;258
000076  d4f7              BMI      |L3.104|
;;;261        {
;;;262          return HAL_TIMEOUT;
;;;263        }
;;;264      }
;;;265    
;;;266      /* Get Start Tick */
;;;267      tickstart = HAL_GetTick();
000078  f7fffffe          BL       HAL_GetTick
00007c  4605              MOV      r5,r0
;;;268    
;;;269      /* Clear PLLON bit */
;;;270      CLEAR_BIT(RCC->CR, RCC_CR_PLLON);
00007e  6820              LDR      r0,[r4,#0]
000080  f0207080          BIC      r0,r0,#0x1000000
000084  6020              STR      r0,[r4,#0]
;;;271    
;;;272      /* Wait till PLL is disabled */
;;;273      while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != RESET)
000086  e004              B        |L3.146|
                  |L3.136|
;;;274      {
;;;275        if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
000088  f7fffffe          BL       HAL_GetTick
00008c  1b40              SUBS     r0,r0,r5
00008e  2802              CMP      r0,#2
000090  d81f              BHI      |L3.210|
                  |L3.146|
000092  6820              LDR      r0,[r4,#0]            ;273
000094  0180              LSLS     r0,r0,#6              ;273
000096  d4f7              BMI      |L3.136|
;;;276        {
;;;277          return HAL_TIMEOUT;
;;;278        }
;;;279      }
;;;280    
;;;281      /* Get Start Tick */
;;;282      tickstart = HAL_GetTick();
000098  f7fffffe          BL       HAL_GetTick
00009c  4605              MOV      r5,r0
;;;283    
;;;284      /* Reset PLLI2SON bit */
;;;285      CLEAR_BIT(RCC->CR, RCC_CR_PLLI2SON);
00009e  6820              LDR      r0,[r4,#0]
0000a0  f0206080          BIC      r0,r0,#0x4000000
0000a4  6020              STR      r0,[r4,#0]
;;;286    
;;;287      /* Wait till PLLI2S is disabled */
;;;288      while (READ_BIT(RCC->CR, RCC_CR_PLLI2SRDY) != RESET)
0000a6  e004              B        |L3.178|
                  |L3.168|
;;;289      {
;;;290        if ((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
0000a8  f7fffffe          BL       HAL_GetTick
0000ac  1b40              SUBS     r0,r0,r5
0000ae  2864              CMP      r0,#0x64
0000b0  d80f              BHI      |L3.210|
                  |L3.178|
0000b2  6820              LDR      r0,[r4,#0]            ;288
0000b4  0100              LSLS     r0,r0,#4              ;288
0000b6  d4f7              BMI      |L3.168|
;;;291        {
;;;292          return HAL_TIMEOUT;
;;;293        }
;;;294      }
;;;295    
;;;296      /* Get Start Tick */
;;;297      tickstart = HAL_GetTick();
0000b8  f7fffffe          BL       HAL_GetTick
0000bc  4605              MOV      r5,r0
;;;298    
;;;299      /* Reset PLLSAI bit */
;;;300      CLEAR_BIT(RCC->CR, RCC_CR_PLLSAION);
0000be  6820              LDR      r0,[r4,#0]
0000c0  f0205080          BIC      r0,r0,#0x10000000
0000c4  6020              STR      r0,[r4,#0]
;;;301    
;;;302      /* Wait till PLLSAI is disabled */
;;;303      while (READ_BIT(RCC->CR, RCC_CR_PLLSAIRDY) != RESET)
0000c6  e007              B        |L3.216|
                  |L3.200|
;;;304      {
;;;305        if ((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
0000c8  f7fffffe          BL       HAL_GetTick
0000cc  1b40              SUBS     r0,r0,r5
0000ce  2864              CMP      r0,#0x64
0000d0  d902              BLS      |L3.216|
                  |L3.210|
;;;306        {
;;;307          return HAL_TIMEOUT;
0000d2  2003              MOVS     r0,#3
                  |L3.212|
;;;308        }
;;;309      }
;;;310    
;;;311      /* Once PLL, PLLI2S and PLLSAI are OFF, reset PLLCFGR register to default value */
;;;312      RCC->PLLCFGR = RCC_PLLCFGR_PLLM_4 | RCC_PLLCFGR_PLLN_6 | RCC_PLLCFGR_PLLN_7 | RCC_PLLCFGR_PLLQ_2 | 0x20000000U;
;;;313    
;;;314      /* Reset PLLI2SCFGR register to default value */
;;;315      RCC->PLLI2SCFGR = RCC_PLLI2SCFGR_PLLI2SN_6 | RCC_PLLI2SCFGR_PLLI2SN_7 | RCC_PLLI2SCFGR_PLLI2SQ_2 | RCC_PLLI2SCFGR_PLLI2SR_1;
;;;316    
;;;317      /* Reset PLLSAICFGR register to default value */
;;;318      RCC->PLLSAICFGR = RCC_PLLSAICFGR_PLLSAIN_6 | RCC_PLLSAICFGR_PLLSAIN_7 | RCC_PLLSAICFGR_PLLSAIQ_2 | 0x20000000U;
;;;319    
;;;320      /* Disable all interrupts */
;;;321      CLEAR_BIT(RCC->CIR, RCC_CIR_LSIRDYIE | RCC_CIR_LSERDYIE | RCC_CIR_HSIRDYIE | RCC_CIR_HSERDYIE | RCC_CIR_PLLRDYIE | RCC_CIR_PLLI2SRDYIE | RCC_CIR_PLLSAIRDYIE);
;;;322    
;;;323      /* Clear all interrupt flags */
;;;324      SET_BIT(RCC->CIR, RCC_CIR_LSIRDYC | RCC_CIR_LSERDYC | RCC_CIR_HSIRDYC | RCC_CIR_HSERDYC | RCC_CIR_PLLRDYC | RCC_CIR_PLLI2SRDYC | RCC_CIR_PLLSAIRDYC | RCC_CIR_CSSC);
;;;325    
;;;326      /* Clear LSION bit */
;;;327      CLEAR_BIT(RCC->CSR, RCC_CSR_LSION);
;;;328    
;;;329      /* Reset all CSR flags */
;;;330      SET_BIT(RCC->CSR, RCC_CSR_RMVF);
;;;331    
;;;332      /* Update the SystemCoreClock global variable */
;;;333      SystemCoreClock = HSI_VALUE;
;;;334    
;;;335      /* Adapt Systick interrupt period */
;;;336      if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
;;;337      {
;;;338        return HAL_ERROR;
;;;339      }
;;;340      else
;;;341      {
;;;342        return HAL_OK;
;;;343      }
;;;344    }
0000d4  e8bd81f0          POP      {r4-r8,pc}
                  |L3.216|
0000d8  6820              LDR      r0,[r4,#0]            ;303
0000da  0080              LSLS     r0,r0,#2              ;303
0000dc  d4f4              BMI      |L3.200|
0000de  4b14              LDR      r3,|L3.304|
0000e0  4913              LDR      r1,|L3.304|
0000e2  4a14              LDR      r2,|L3.308|
0000e4  1d1b              ADDS     r3,r3,#4              ;312
0000e6  4c12              LDR      r4,|L3.304|
0000e8  310c              ADDS     r1,r1,#0xc            ;321
0000ea  4812              LDR      r0,|L3.308|
0000ec  3210              ADDS     r2,r2,#0x10           ;312
0000ee  3484              ADDS     r4,r4,#0x84           ;315
0000f0  601a              STR      r2,[r3,#0]            ;312
0000f2  1d25              ADDS     r5,r4,#4              ;318
0000f4  6020              STR      r0,[r4,#0]            ;315
0000f6  6028              STR      r0,[r5,#0]            ;318
0000f8  680a              LDR      r2,[r1,#0]            ;321
0000fa  480d              LDR      r0,|L3.304|
0000fc  f42242fe          BIC      r2,r2,#0x7f00         ;321
000100  600a              STR      r2,[r1,#0]            ;321
000102  3074              ADDS     r0,r0,#0x74           ;327
000104  680a              LDR      r2,[r1,#0]            ;324
000106  4b0c              LDR      r3,|L3.312|
000108  f442027f          ORR      r2,r2,#0xff0000       ;324
00010c  600a              STR      r2,[r1,#0]            ;324
00010e  6801              LDR      r1,[r0,#0]            ;327
000110  f0210101          BIC      r1,r1,#1              ;327
000114  6001              STR      r1,[r0,#0]            ;327
000116  6801              LDR      r1,[r0,#0]            ;330
000118  f0417180          ORR      r1,r1,#0x1000000      ;330
00011c  6001              STR      r1,[r0,#0]            ;330
00011e  4807              LDR      r0,|L3.316|
000120  6003              STR      r3,[r0,#0]            ;336  ; SystemCoreClock
000122  200f              MOVS     r0,#0xf               ;336
000124  f7fffffe          BL       HAL_InitTick
000128  2800              CMP      r0,#0                 ;336
00012a  d0d3              BEQ      |L3.212|
00012c  2001              MOVS     r0,#1                 ;338
00012e  e7d1              B        |L3.212|
;;;345    
                          ENDP

                  |L3.304|
                          DCD      0x40023800
                  |L3.308|
                          DCD      0x24003000
                  |L3.312|
                          DCD      0x00f42400
                  |L3.316|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_RCC_DisableCSS||, CODE, READONLY, ALIGN=2

                  HAL_RCC_DisableCSS PROC
;;;962      */
;;;963    void HAL_RCC_DisableCSS(void)
000000  4802              LDR      r0,|L4.12|
;;;964    {
;;;965      CLEAR_BIT(RCC->CR, RCC_CR_CSSON);
000002  6801              LDR      r1,[r0,#0]
000004  f4212100          BIC      r1,r1,#0x80000
000008  6001              STR      r1,[r0,#0]
;;;966    }
00000a  4770              BX       lr
;;;967    
                          ENDP

                  |L4.12|
                          DCD      0x40023800

                          AREA ||i.HAL_RCC_EnableCSS||, CODE, READONLY, ALIGN=2

                  HAL_RCC_EnableCSS PROC
;;;953      */
;;;954    void HAL_RCC_EnableCSS(void)
000000  4802              LDR      r0,|L5.12|
;;;955    {
;;;956      SET_BIT(RCC->CR, RCC_CR_CSSON);
000002  6801              LDR      r1,[r0,#0]
000004  f4412100          ORR      r1,r1,#0x80000
000008  6001              STR      r1,[r0,#0]
;;;957    }
00000a  4770              BX       lr
;;;958    
                          ENDP

                  |L5.12|
                          DCD      0x40023800

                          AREA ||i.HAL_RCC_GetClockConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetClockConfig PROC
;;;1169     */
;;;1170   void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
000000  4a0d              LDR      r2,|L6.56|
;;;1171   {
;;;1172     /* Set all possible values for the Clock type parameter --------------------*/
;;;1173     RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
000002  230f              MOVS     r3,#0xf
000004  b530              PUSH     {r4,r5,lr}            ;1171
;;;1174   
;;;1175     /* Get the SYSCLK configuration --------------------------------------------*/
;;;1176     RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
;;;1177   
;;;1178     /* Get the HCLK configuration ----------------------------------------------*/
;;;1179     RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE);
;;;1180   
;;;1181     /* Get the APB1 configuration ----------------------------------------------*/
;;;1182     RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);
;;;1183   
;;;1184     /* Get the APB2 configuration ----------------------------------------------*/
;;;1185     RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);
;;;1186   
;;;1187     /* Get the Flash Wait State (Latency) configuration ------------------------*/
;;;1188     *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
000006  6003              STR      r3,[r0,#0]
;;;1189   }
000008  f44f54e0          MOV      r4,#0x1c00
00000c  4b0b              LDR      r3,|L6.60|
00000e  6815              LDR      r5,[r2,#0]            ;1176
000010  f0050503          AND      r5,r5,#3              ;1176
000014  6045              STR      r5,[r0,#4]            ;1179
000016  6815              LDR      r5,[r2,#0]            ;1179
000018  f00505f0          AND      r5,r5,#0xf0           ;1179
00001c  6085              STR      r5,[r0,#8]            ;1182
00001e  6815              LDR      r5,[r2,#0]            ;1182
000020  f40555e0          AND      r5,r5,#0x1c00         ;1182
000024  60c5              STR      r5,[r0,#0xc]          ;1185
000026  6812              LDR      r2,[r2,#0]            ;1185
000028  ea0402d2          AND      r2,r4,r2,LSR #3
00002c  6102              STR      r2,[r0,#0x10]         ;1188
00002e  6818              LDR      r0,[r3,#0]            ;1188
000030  f000000f          AND      r0,r0,#0xf            ;1188
000034  6008              STR      r0,[r1,#0]            ;1188
000036  bd30              POP      {r4,r5,pc}
;;;1190   
                          ENDP

                  |L6.56|
                          DCD      0x40023808
                  |L6.60|
                          DCD      0x40023c00

                          AREA ||i.HAL_RCC_GetHCLKFreq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetHCLKFreq PROC
;;;1051     */
;;;1052   uint32_t HAL_RCC_GetHCLKFreq(void)
000000  4801              LDR      r0,|L7.8|
;;;1053   {
;;;1054     return SystemCoreClock;
000002  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;1055   }
000004  4770              BX       lr
;;;1056   
                          ENDP

000006  0000              DCW      0x0000
                  |L7.8|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_RCC_GetOscConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetOscConfig PROC
;;;1087     */
;;;1088   void HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
000000  4b2f              LDR      r3,|L8.192|
;;;1089   {
;;;1090     /* Set all possible values for the Oscillator type parameter ---------------*/
;;;1091     RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_LSI;
000002  210f              MOVS     r1,#0xf
000004  b530              PUSH     {r4,r5,lr}            ;1089
000006  6001              STR      r1,[r0,#0]
000008  2100              MOVS     r1,#0
;;;1092   
;;;1093     /* Get the HSE configuration -----------------------------------------------*/
;;;1094     if((RCC->CR &RCC_CR_HSEBYP) == RCC_CR_HSEBYP)
00000a  681a              LDR      r2,[r3,#0]
00000c  0352              LSLS     r2,r2,#13
00000e  d502              BPL      |L8.22|
;;;1095     {
;;;1096       RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;
000010  f44f22a0          MOV      r2,#0x50000
000014  e004              B        |L8.32|
                  |L8.22|
;;;1097     }
;;;1098     else if((RCC->CR &RCC_CR_HSEON) == RCC_CR_HSEON)
000016  681a              LDR      r2,[r3,#0]
000018  03d2              LSLS     r2,r2,#15
00001a  d503              BPL      |L8.36|
;;;1099     {
;;;1100       RCC_OscInitStruct->HSEState = RCC_HSE_ON;
00001c  f44f3280          MOV      r2,#0x10000
                  |L8.32|
000020  6042              STR      r2,[r0,#4]
000022  e000              B        |L8.38|
                  |L8.36|
;;;1101     }
;;;1102     else
;;;1103     {
;;;1104       RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
000024  6041              STR      r1,[r0,#4]
                  |L8.38|
;;;1105     }
;;;1106   
;;;1107     /* Get the HSI configuration -----------------------------------------------*/
;;;1108     if((RCC->CR &RCC_CR_HSION) == RCC_CR_HSION)
;;;1109     {
;;;1110       RCC_OscInitStruct->HSIState = RCC_HSI_ON;
000026  2201              MOVS     r2,#1
000028  681c              LDR      r4,[r3,#0]            ;1108
00002a  07e4              LSLS     r4,r4,#31             ;1108
00002c  d001              BEQ      |L8.50|
00002e  60c2              STR      r2,[r0,#0xc]
000030  e000              B        |L8.52|
                  |L8.50|
;;;1111     }
;;;1112     else
;;;1113     {
;;;1114       RCC_OscInitStruct->HSIState = RCC_HSI_OFF;
000032  60c1              STR      r1,[r0,#0xc]
                  |L8.52|
;;;1115     }
;;;1116   
;;;1117     RCC_OscInitStruct->HSICalibrationValue = (uint32_t)((RCC->CR &RCC_CR_HSITRIM) >> RCC_CR_HSITRIM_Pos);
;;;1118   
;;;1119     /* Get the LSE configuration -----------------------------------------------*/
;;;1120     if((RCC->BDCR &RCC_BDCR_LSEBYP) == RCC_BDCR_LSEBYP)
000034  4c22              LDR      r4,|L8.192|
000036  681d              LDR      r5,[r3,#0]            ;1117
000038  3470              ADDS     r4,r4,#0x70
00003a  f3c505c4          UBFX     r5,r5,#3,#5           ;1117
00003e  6105              STR      r5,[r0,#0x10]
000040  6825              LDR      r5,[r4,#0]
000042  076d              LSLS     r5,r5,#29
000044  d502              BPL      |L8.76|
;;;1121     {
;;;1122       RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;
000046  2405              MOVS     r4,#5
000048  6084              STR      r4,[r0,#8]
00004a  e005              B        |L8.88|
                  |L8.76|
;;;1123     }
;;;1124     else if((RCC->BDCR &RCC_BDCR_LSEON) == RCC_BDCR_LSEON)
00004c  6824              LDR      r4,[r4,#0]
00004e  07e4              LSLS     r4,r4,#31
000050  d001              BEQ      |L8.86|
;;;1125     {
;;;1126       RCC_OscInitStruct->LSEState = RCC_LSE_ON;
000052  6082              STR      r2,[r0,#8]
000054  e000              B        |L8.88|
                  |L8.86|
;;;1127     }
;;;1128     else
;;;1129     {
;;;1130       RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
000056  6081              STR      r1,[r0,#8]
                  |L8.88|
;;;1131     }
;;;1132   
;;;1133     /* Get the LSI configuration -----------------------------------------------*/
;;;1134     if((RCC->CSR &RCC_CSR_LSION) == RCC_CSR_LSION)
000058  4c19              LDR      r4,|L8.192|
00005a  3474              ADDS     r4,r4,#0x74
00005c  6824              LDR      r4,[r4,#0]
00005e  07e4              LSLS     r4,r4,#31
000060  d001              BEQ      |L8.102|
;;;1135     {
;;;1136       RCC_OscInitStruct->LSIState = RCC_LSI_ON;
000062  6142              STR      r2,[r0,#0x14]
000064  e000              B        |L8.104|
                  |L8.102|
;;;1137     }
;;;1138     else
;;;1139     {
;;;1140       RCC_OscInitStruct->LSIState = RCC_LSI_OFF;
000066  6141              STR      r1,[r0,#0x14]
                  |L8.104|
;;;1141     }
;;;1142   
;;;1143     /* Get the PLL configuration -----------------------------------------------*/
;;;1144     if((RCC->CR &RCC_CR_PLLON) == RCC_CR_PLLON)
000068  6819              LDR      r1,[r3,#0]
00006a  01c9              LSLS     r1,r1,#7
00006c  d502              BPL      |L8.116|
;;;1145     {
;;;1146       RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;
00006e  2102              MOVS     r1,#2
000070  6181              STR      r1,[r0,#0x18]
000072  e000              B        |L8.118|
                  |L8.116|
;;;1147     }
;;;1148     else
;;;1149     {
;;;1150       RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;
000074  6182              STR      r2,[r0,#0x18]
                  |L8.118|
;;;1151     }
;;;1152     RCC_OscInitStruct->PLL.PLLSource = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
;;;1153     RCC_OscInitStruct->PLL.PLLM = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM);
;;;1154     RCC_OscInitStruct->PLL.PLLN = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
;;;1155     RCC_OscInitStruct->PLL.PLLP = (uint32_t)((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) + RCC_PLLCFGR_PLLP_0) << 1) >> RCC_PLLCFGR_PLLP_Pos);
;;;1156     RCC_OscInitStruct->PLL.PLLQ = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLQ) >> RCC_PLLCFGR_PLLQ_Pos);
;;;1157   #if defined (RCC_PLLCFGR_PLLR)
;;;1158     RCC_OscInitStruct->PLL.PLLR = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> POSITION_VAL(RCC_PLLCFGR_PLLR));
000076  f04f42e0          MOV      r2,#0x70000000
00007a  4911              LDR      r1,|L8.192|
00007c  1d09              ADDS     r1,r1,#4              ;1152
00007e  680b              LDR      r3,[r1,#0]            ;1152
000080  fa92f2a2          RBIT     r2,r2
000084  f4030380          AND      r3,r3,#0x400000       ;1152
000088  61c3              STR      r3,[r0,#0x1c]
00008a  fab2f382          CLZ      r3,r2
00008e  680a              LDR      r2,[r1,#0]            ;1153
000090  f002023f          AND      r2,r2,#0x3f           ;1153
000094  6202              STR      r2,[r0,#0x20]         ;1154
000096  680a              LDR      r2,[r1,#0]            ;1154
000098  f3c21288          UBFX     r2,r2,#6,#9           ;1154
00009c  6242              STR      r2,[r0,#0x24]         ;1155
00009e  680a              LDR      r2,[r1,#0]            ;1155
0000a0  f4023240          AND      r2,r2,#0x30000        ;1155
0000a4  f5023280          ADD      r2,r2,#0x10000        ;1155
0000a8  0bd2              LSRS     r2,r2,#15             ;1155
0000aa  6282              STR      r2,[r0,#0x28]         ;1156
0000ac  680a              LDR      r2,[r1,#0]            ;1156
0000ae  f3c26203          UBFX     r2,r2,#24,#4          ;1156
0000b2  62c2              STR      r2,[r0,#0x2c]
0000b4  6809              LDR      r1,[r1,#0]
0000b6  f00141e0          AND      r1,r1,#0x70000000
0000ba  40d9              LSRS     r1,r1,r3
0000bc  6301              STR      r1,[r0,#0x30]
;;;1159   #endif
;;;1160   }
0000be  bd30              POP      {r4,r5,pc}
;;;1161   
                          ENDP

                  |L8.192|
                          DCD      0x40023800

                          AREA ||i.HAL_RCC_GetPCLK1Freq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetPCLK1Freq PROC
;;;1062     */
;;;1063   uint32_t HAL_RCC_GetPCLK1Freq(void)
000000  4904              LDR      r1,|L9.20|
000002  4805              LDR      r0,|L9.24|
;;;1064   {
;;;1065     /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
;;;1066     return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> RCC_CFGR_PPRE1_Pos]);
000004  6809              LDR      r1,[r1,#0]
000006  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000008  4a04              LDR      r2,|L9.28|
00000a  f3c12182          UBFX     r1,r1,#10,#3
00000e  5c51              LDRB     r1,[r2,r1]
000010  40c8              LSRS     r0,r0,r1
;;;1067   }
000012  4770              BX       lr
;;;1068   
                          ENDP

                  |L9.20|
                          DCD      0x40023808
                  |L9.24|
                          DCD      SystemCoreClock
                  |L9.28|
                          DCD      APBPrescTable

                          AREA ||i.HAL_RCC_GetPCLK2Freq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetPCLK2Freq PROC
;;;1074     */
;;;1075   uint32_t HAL_RCC_GetPCLK2Freq(void)
000000  4904              LDR      r1,|L10.20|
000002  4805              LDR      r0,|L10.24|
;;;1076   {
;;;1077     /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
;;;1078     return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> RCC_CFGR_PPRE2_Pos]);
000004  6809              LDR      r1,[r1,#0]
000006  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000008  4a04              LDR      r2,|L10.28|
00000a  f3c13142          UBFX     r1,r1,#13,#3
00000e  5c51              LDRB     r1,[r2,r1]
000010  40c8              LSRS     r0,r0,r1
;;;1079   }
000012  4770              BX       lr
;;;1080   
                          ENDP

                  |L10.20|
                          DCD      0x40023808
                  |L10.24|
                          DCD      SystemCoreClock
                  |L10.28|
                          DCD      APBPrescTable

                          AREA ||i.HAL_RCC_GetSysClockFreq||, CODE, READONLY, ALIGN=2

                  HAL_RCC_GetSysClockFreq PROC
;;;997      */
;;;998    uint32_t HAL_RCC_GetSysClockFreq(void)
000000  4915              LDR      r1,|L11.88|
;;;999    {
000002  b510              PUSH     {r4,lr}
;;;1000     uint32_t pllm = 0, pllvco = 0, pllp = 0;
;;;1001     uint32_t sysclockfreq = 0;
;;;1002   
;;;1003     /* Get SYSCLK source -------------------------------------------------------*/
;;;1004     switch (RCC->CFGR & RCC_CFGR_SWS)
;;;1005     {
;;;1006       case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
;;;1007       {
;;;1008         sysclockfreq = HSI_VALUE;
000004  4815              LDR      r0,|L11.92|
000006  6809              LDR      r1,[r1,#0]            ;1004
000008  f011020c          ANDS     r2,r1,#0xc            ;1004
00000c  d013              BEQ      |L11.54|
;;;1009          break;
;;;1010       }
;;;1011       case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock  source */
;;;1012       {
;;;1013         sysclockfreq = HSE_VALUE;
00000e  4914              LDR      r1,|L11.96|
000010  2a04              CMP      r2,#4                 ;1004
000012  d00f              BEQ      |L11.52|
000014  2a08              CMP      r2,#8                 ;1004
000016  d10e              BNE      |L11.54|
;;;1014         break;
;;;1015       }
;;;1016       case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock  source */
;;;1017       {
;;;1018         /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
;;;1019         SYSCLK = PLL_VCO / PLLP */
;;;1020         pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
000018  4c0f              LDR      r4,|L11.88|
00001a  1f24              SUBS     r4,r4,#4
00001c  6822              LDR      r2,[r4,#0]
;;;1021         if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
00001e  6823              LDR      r3,[r4,#0]
000020  f002023f          AND      r2,r2,#0x3f           ;1020
000024  025b              LSLS     r3,r3,#9
000026  d507              BPL      |L11.56|
;;;1022         {
;;;1023           /* HSE used as PLL clock source */
;;;1024           pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
000028  6820              LDR      r0,[r4,#0]
00002a  f3c01088          UBFX     r0,r0,#6,#9
00002e  fba00101          UMULL    r0,r1,r0,r1
000032  e006              B        |L11.66|
                  |L11.52|
000034  4608              MOV      r0,r1                 ;1013
                  |L11.54|
;;;1025         }
;;;1026         else
;;;1027         {
;;;1028           /* HSI used as PLL clock source */
;;;1029           pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
;;;1030         }
;;;1031         pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1 ) *2);
;;;1032   
;;;1033         sysclockfreq = pllvco/pllp;
;;;1034         break;
;;;1035       }
;;;1036       default:
;;;1037       {
;;;1038         sysclockfreq = HSI_VALUE;
;;;1039         break;
;;;1040       }
;;;1041     }
;;;1042     return sysclockfreq;
;;;1043   }
000036  bd10              POP      {r4,pc}
                  |L11.56|
000038  6821              LDR      r1,[r4,#0]            ;1029
00003a  f3c11188          UBFX     r1,r1,#6,#9           ;1029
00003e  fba10100          UMULL    r0,r1,r1,r0           ;1029
                  |L11.66|
000042  2300              MOVS     r3,#0                 ;1029
000044  f7fffffe          BL       __aeabi_uldivmod
000048  6821              LDR      r1,[r4,#0]            ;1031
00004a  f3c14101          UBFX     r1,r1,#16,#2          ;1031
00004e  1c49              ADDS     r1,r1,#1              ;1031
000050  0049              LSLS     r1,r1,#1              ;1031
000052  fbb0f0f1          UDIV     r0,r0,r1              ;1033
000056  bd10              POP      {r4,pc}
;;;1044   
                          ENDP

                  |L11.88|
                          DCD      0x40023808
                  |L11.92|
                          DCD      0x00f42400
                  |L11.96|
                          DCD      0x017d7840

                          AREA ||i.HAL_RCC_MCOConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_MCOConfig PROC
;;;899      */
;;;900    void HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
000000  b5f0              PUSH     {r4-r7,lr}
;;;901    {
000002  460d              MOV      r5,r1
;;;902      GPIO_InitTypeDef GPIO_InitStruct;
;;;903      /* Check the parameters */
;;;904      assert_param(IS_RCC_MCO(RCC_MCOx));
;;;905      assert_param(IS_RCC_MCODIV(RCC_MCODiv));
;;;906      /* RCC_MCO1 */
;;;907      if(RCC_MCOx == RCC_MCO1)
;;;908      {
;;;909        assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));
;;;910    
;;;911        /* MCO1 Clock Enable */
;;;912        MCO1_CLK_ENABLE();
000004  491f              LDR      r1,|L12.132|
;;;913    
;;;914        /* Configure the MCO1 pin in alternate function mode */
;;;915        GPIO_InitStruct.Pin = MCO1_PIN;
;;;916        GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
;;;917        GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
;;;918        GPIO_InitStruct.Pull = GPIO_NOPULL;
;;;919        GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
;;;920        HAL_GPIO_Init(MCO1_GPIO_PORT, &GPIO_InitStruct);
;;;921    
;;;922        /* Mask MCO1 and MCO1PRE[2:0] bits then Select MCO1 clock source and prescaler */
;;;923        MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO1 | RCC_CFGR_MCO1PRE), (RCC_MCOSource | RCC_MCODiv));
000006  4c20              LDR      r4,|L12.136|
000008  2800              CMP      r0,#0                 ;907
00000a  b087              SUB      sp,sp,#0x1c           ;901
00000c  4616              MOV      r6,r2                 ;901
00000e  f04f0000          MOV      r0,#0                 ;907
000012  f04f0202          MOV      r2,#2                 ;916
;;;924      }
;;;925      else
;;;926      {
;;;927        assert_param(IS_RCC_MCO2SOURCE(RCC_MCOSource));
;;;928    
;;;929        /* MCO2 Clock Enable */
;;;930        MCO2_CLK_ENABLE();
000016  680f              LDR      r7,[r1,#0]
000018  f04f0303          MOV      r3,#3                 ;917
00001c  d019              BEQ      |L12.82|
00001e  f0470704          ORR      r7,r7,#4
000022  600f              STR      r7,[r1,#0]
000024  6809              LDR      r1,[r1,#0]
000026  f0010104          AND      r1,r1,#4
;;;931    
;;;932        /* Configure the MCO2 pin in alternate function mode */
;;;933        GPIO_InitStruct.Pin = MCO2_PIN;
00002a  9105              STR      r1,[sp,#0x14]
00002c  0211              LSLS     r1,r2,#8
00002e  9100              STR      r1,[sp,#0]
000030  e9cd2001          STRD     r2,r0,[sp,#4]
;;;934        GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
;;;935        GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
;;;936        GPIO_InitStruct.Pull = GPIO_NOPULL;
;;;937        GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
;;;938        HAL_GPIO_Init(MCO2_GPIO_PORT, &GPIO_InitStruct);
000034  e9cd3003          STRD     r3,r0,[sp,#0xc]
000038  4814              LDR      r0,|L12.140|
00003a  4669              MOV      r1,sp
00003c  f7fffffe          BL       HAL_GPIO_Init
;;;939    
;;;940        /* Mask MCO2 and MCO2PRE[2:0] bits then Select MCO2 clock source and prescaler */
;;;941        MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO2 | RCC_CFGR_MCO2PRE), (RCC_MCOSource | (RCC_MCODiv << 3)));
000040  6820              LDR      r0,[r4,#0]
000042  ea4501c6          ORR      r1,r5,r6,LSL #3
000046  f0204078          BIC      r0,r0,#0xf8000000
00004a  4308              ORRS     r0,r0,r1
                  |L12.76|
00004c  6020              STR      r0,[r4,#0]            ;923
;;;942      }
;;;943    }
00004e  b007              ADD      sp,sp,#0x1c
000050  bdf0              POP      {r4-r7,pc}
                  |L12.82|
000052  f0470701          ORR      r7,r7,#1              ;912
000056  600f              STR      r7,[r1,#0]            ;912
000058  6809              LDR      r1,[r1,#0]            ;912
00005a  f0010101          AND      r1,r1,#1              ;912
00005e  9105              STR      r1,[sp,#0x14]         ;915
000060  f44f7180          MOV      r1,#0x100             ;915
000064  9100              STR      r1,[sp,#0]            ;915
000066  e9cd2001          STRD     r2,r0,[sp,#4]         ;915
00006a  e9cd3003          STRD     r3,r0,[sp,#0xc]       ;920
00006e  4808              LDR      r0,|L12.144|
000070  4669              MOV      r1,sp                 ;920
000072  f7fffffe          BL       HAL_GPIO_Init
000076  6820              LDR      r0,[r4,#0]            ;923
000078  4335              ORRS     r5,r5,r6              ;923
00007a  f02060ec          BIC      r0,r0,#0x7600000      ;923
00007e  4328              ORRS     r0,r0,r5              ;923
000080  e7e4              B        |L12.76|
;;;944    
                          ENDP

000082  0000              DCW      0x0000
                  |L12.132|
                          DCD      0x40023830
                  |L12.136|
                          DCD      0x40023808
                  |L12.140|
                          DCD      0x40020800
                  |L12.144|
                          DCD      0x40020000

                          AREA ||i.HAL_RCC_NMI_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_RCC_NMI_IRQHandler PROC
;;;1195     */
;;;1196   void HAL_RCC_NMI_IRQHandler(void)
000000  4805              LDR      r0,|L13.24|
;;;1197   {
000002  b510              PUSH     {r4,lr}
;;;1198     /* Check RCC CSSF flag  */
;;;1199     if(__HAL_RCC_GET_IT(RCC_IT_CSS))
000004  6800              LDR      r0,[r0,#0]
000006  0600              LSLS     r0,r0,#24
000008  d505              BPL      |L13.22|
;;;1200     {
;;;1201       /* RCC Clock Security System interrupt user callback */
;;;1202       HAL_RCC_CSSCallback();
00000a  f7fffffe          BL       HAL_RCC_CSSCallback
;;;1203   
;;;1204       /* Clear RCC CSS pending bit */
;;;1205       __HAL_RCC_CLEAR_IT(RCC_IT_CSS);
00000e  4902              LDR      r1,|L13.24|
000010  2080              MOVS     r0,#0x80
000012  1c89              ADDS     r1,r1,#2
000014  7008              STRB     r0,[r1,#0]
                  |L13.22|
;;;1206     }
;;;1207   }
000016  bd10              POP      {r4,pc}
;;;1208   
                          ENDP

                  |L13.24|
                          DCD      0x4002380c

                          AREA ||i.HAL_RCC_OscConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCC_OscConfig PROC
;;;359      */
;;;360    HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;361    {
000004  0005              MOVS     r5,r0
;;;362      uint32_t tickstart;
;;;363      FlagStatus pwrclkchanged = RESET;
000006  f04f0700          MOV      r7,#0
                  |L14.10|
00000a  d06e              BEQ      |L14.234|
;;;364    
;;;365      /* Check Null pointer */
;;;366      if(RCC_OscInitStruct == NULL)
;;;367      {
;;;368        return HAL_ERROR;
;;;369      }
;;;370    
;;;371      /* Check the parameters */
;;;372      assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
;;;373    
;;;374      /*------------------------------- HSE Configuration ------------------------*/
;;;375      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
00000c  7828              LDRB     r0,[r5,#0]
;;;376      {
;;;377        /* Check the parameters */
;;;378        assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
;;;379        /* When the HSE is used as system clock or clock source for PLL, It can not be disabled */
;;;380        if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE)
00000e  f8df9320          LDR      r9,|L14.816|
;;;381           || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
000012  f1a90a04          SUB      r10,r9,#4
000016  07c0              LSLS     r0,r0,#31             ;375
;;;382        {
;;;383          if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
000018  f1aa0404          SUB      r4,r10,#4
00001c  d04c              BEQ      |L14.184|
00001e  f8d91000          LDR      r1,[r9,#0]            ;380
000022  4648              MOV      r0,r9                 ;380
000024  f3c10181          UBFX     r1,r1,#2,#2           ;380
000028  2901              CMP      r1,#1                 ;380
00002a  d008              BEQ      |L14.62|
00002c  6800              LDR      r0,[r0,#0]            ;381
00002e  f3c00081          UBFX     r0,r0,#2,#2           ;381
000032  2802              CMP      r0,#2                 ;381
000034  d10a              BNE      |L14.76|
000036  f8da0000          LDR      r0,[r10,#0]           ;381
00003a  0240              LSLS     r0,r0,#9              ;381
00003c  d506              BPL      |L14.76|
                  |L14.62|
00003e  6820              LDR      r0,[r4,#0]
000040  0380              LSLS     r0,r0,#14
000042  d539              BPL      |L14.184|
000044  6868              LDR      r0,[r5,#4]
000046  2800              CMP      r0,#0
000048  d0df              BEQ      |L14.10|
00004a  e035              B        |L14.184|
                  |L14.76|
;;;384          {
;;;385            return HAL_ERROR;
;;;386          }
;;;387        }
;;;388        else
;;;389        {
;;;390          /* Set the new HSE configuration ---------------------------------------*/
;;;391          __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
00004c  6868              LDR      r0,[r5,#4]
00004e  f5b03f80          CMP      r0,#0x10000
000052  d00b              BEQ      |L14.108|
000054  b110              CBZ      r0,|L14.92|
000056  f5b02fa0          CMP      r0,#0x50000
00005a  d011              BEQ      |L14.128|
                  |L14.92|
00005c  6820              LDR      r0,[r4,#0]
00005e  f4203080          BIC      r0,r0,#0x10000
000062  6020              STR      r0,[r4,#0]
000064  6820              LDR      r0,[r4,#0]
000066  f4202080          BIC      r0,r0,#0x40000
00006a  e002              B        |L14.114|
                  |L14.108|
00006c  6820              LDR      r0,[r4,#0]
00006e  f4403080          ORR      r0,r0,#0x10000
                  |L14.114|
000072  6020              STR      r0,[r4,#0]
;;;392    
;;;393          /* Check the HSE State */
;;;394          if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
000074  6868              LDR      r0,[r5,#4]
000076  b190              CBZ      r0,|L14.158|
;;;395          {
;;;396            /* Get Start Tick*/
;;;397            tickstart = HAL_GetTick();
000078  f7fffffe          BL       HAL_GetTick
00007c  4606              MOV      r6,r0
;;;398    
;;;399            /* Wait till HSE is ready */
;;;400            while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
00007e  e00a              B        |L14.150|
                  |L14.128|
000080  6820              LDR      r0,[r4,#0]            ;391
000082  f4402080          ORR      r0,r0,#0x40000        ;391
000086  6020              STR      r0,[r4,#0]            ;391
000088  e7f0              B        |L14.108|
;;;401            {
;;;402              if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
00008a  bf00              NOP      
                  |L14.140|
00008c  f7fffffe          BL       HAL_GetTick
000090  1b80              SUBS     r0,r0,r6
000092  2864              CMP      r0,#0x64
                  |L14.148|
000094  d872              BHI      |L14.380|
                  |L14.150|
000096  6820              LDR      r0,[r4,#0]            ;400
000098  0380              LSLS     r0,r0,#14             ;400
00009a  d5f7              BPL      |L14.140|
00009c  e00c              B        |L14.184|
                  |L14.158|
;;;403              {
;;;404                return HAL_TIMEOUT;
;;;405              }
;;;406            }
;;;407          }
;;;408          else
;;;409          {
;;;410            /* Get Start Tick*/
;;;411            tickstart = HAL_GetTick();
00009e  f7fffffe          BL       HAL_GetTick
0000a2  4606              MOV      r6,r0
;;;412    
;;;413            /* Wait till HSE is bypassed or disabled */
;;;414            while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
0000a4  e005              B        |L14.178|
;;;415            {
;;;416               if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
0000a6  bf00              NOP      
                  |L14.168|
0000a8  f7fffffe          BL       HAL_GetTick
0000ac  1b80              SUBS     r0,r0,r6
0000ae  2864              CMP      r0,#0x64
0000b0  d8f0              BHI      |L14.148|
                  |L14.178|
0000b2  6820              LDR      r0,[r4,#0]            ;414
0000b4  0380              LSLS     r0,r0,#14             ;414
0000b6  d4f7              BMI      |L14.168|
                  |L14.184|
;;;417              {
;;;418                return HAL_TIMEOUT;
;;;419              }
;;;420            }
;;;421          }
;;;422        }
;;;423      }
;;;424      /*----------------------------- HSI Configuration --------------------------*/
;;;425      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
0000b8  7828              LDRB     r0,[r5,#0]
0000ba  0780              LSLS     r0,r0,#30
0000bc  d542              BPL      |L14.324|
;;;426      {
;;;427        /* Check the parameters */
;;;428        assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
;;;429        assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
;;;430    
;;;431        /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
;;;432        if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI)
0000be  f8d91000          LDR      r1,[r9,#0]
0000c2  4648              MOV      r0,r9
0000c4  f0110f0c          TST      r1,#0xc
0000c8  d008              BEQ      |L14.220|
;;;433           || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
0000ca  6800              LDR      r0,[r0,#0]
0000cc  f3c00081          UBFX     r0,r0,#2,#2
0000d0  2802              CMP      r0,#2
0000d2  d10b              BNE      |L14.236|
0000d4  f8da0000          LDR      r0,[r10,#0]
0000d8  0240              LSLS     r0,r0,#9
0000da  d407              BMI      |L14.236|
                  |L14.220|
;;;434        {
;;;435          /* When HSI is used as system clock it will not disabled */
;;;436          if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
0000dc  6820              LDR      r0,[r4,#0]
0000de  0780              LSLS     r0,r0,#30
0000e0  d518              BPL      |L14.276|
0000e2  68e8              LDR      r0,[r5,#0xc]
0000e4  2801              CMP      r0,#1
0000e6  d100              BNE      |L14.234|
0000e8  e014              B        |L14.276|
                  |L14.234|
0000ea  e11e              B        |L14.810|
                  |L14.236|
;;;437          {
;;;438            return HAL_ERROR;
;;;439          }
;;;440          /* Otherwise, just the calibration is allowed */
;;;441          else
;;;442          {
;;;443            /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
;;;444            __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
;;;445          }
;;;446        }
;;;447        else
;;;448        {
;;;449          /* Check the HSI State */
;;;450          if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
0000ec  68e8              LDR      r0,[r5,#0xc]
0000ee  2800              CMP      r0,#0
;;;451          {
;;;452            /* Enable the Internal High Speed oscillator (HSI). */
;;;453            __HAL_RCC_HSI_ENABLE();
;;;454    
;;;455            /* Get Start Tick*/
;;;456            tickstart = HAL_GetTick();
;;;457    
;;;458            /* Wait till HSI is ready */
;;;459            while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
;;;460            {
;;;461              if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
;;;462              {
;;;463                return HAL_TIMEOUT;
;;;464              }
;;;465            }
;;;466    
;;;467            /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
;;;468            __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
;;;469          }
;;;470          else
;;;471          {
;;;472            /* Disable the Internal High Speed oscillator (HSI). */
;;;473            __HAL_RCC_HSI_DISABLE();
0000f0  6820              LDR      r0,[r4,#0]
0000f2  d017              BEQ      |L14.292|
0000f4  f0400001          ORR      r0,r0,#1              ;453
0000f8  6020              STR      r0,[r4,#0]            ;453
0000fa  f7fffffe          BL       HAL_GetTick
0000fe  4606              MOV      r6,r0                 ;456
000100  e005              B        |L14.270|
000102  bf00              NOP                            ;461
                  |L14.260|
000104  f7fffffe          BL       HAL_GetTick
000108  1b80              SUBS     r0,r0,r6              ;461
00010a  2802              CMP      r0,#2                 ;461
00010c  d8c2              BHI      |L14.148|
                  |L14.270|
00010e  6820              LDR      r0,[r4,#0]            ;459
000110  0780              LSLS     r0,r0,#30             ;459
000112  d5f7              BPL      |L14.260|
                  |L14.276|
000114  6928              LDR      r0,[r5,#0x10]         ;468
000116  6821              LDR      r1,[r4,#0]            ;468
000118  f02101f8          BIC      r1,r1,#0xf8           ;468
00011c  ea4100c0          ORR      r0,r1,r0,LSL #3       ;468
000120  6020              STR      r0,[r4,#0]            ;468
000122  e00f              B        |L14.324|
                  |L14.292|
000124  f0200001          BIC      r0,r0,#1
000128  6020              STR      r0,[r4,#0]
;;;474    
;;;475            /* Get Start Tick*/
;;;476            tickstart = HAL_GetTick();
00012a  f7fffffe          BL       HAL_GetTick
00012e  4606              MOV      r6,r0
;;;477    
;;;478            /* Wait till HSI is ready */
;;;479            while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
000130  e005              B        |L14.318|
;;;480            {
;;;481              if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
000132  bf00              NOP      
                  |L14.308|
000134  f7fffffe          BL       HAL_GetTick
000138  1b80              SUBS     r0,r0,r6
00013a  2802              CMP      r0,#2
00013c  d81e              BHI      |L14.380|
                  |L14.318|
00013e  6820              LDR      r0,[r4,#0]            ;479
000140  0780              LSLS     r0,r0,#30             ;479
000142  d4f7              BMI      |L14.308|
                  |L14.324|
;;;482              {
;;;483                return HAL_TIMEOUT;
;;;484              }
;;;485            }
;;;486          }
;;;487        }
;;;488      }
;;;489      /*------------------------------ LSI Configuration -------------------------*/
;;;490      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
000144  7828              LDRB     r0,[r5,#0]
000146  0700              LSLS     r0,r0,#28
000148  d529              BPL      |L14.414|
;;;491      {
;;;492        /* Check the parameters */
;;;493        assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
;;;494    
;;;495        /* Check the LSI State */
;;;496        if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
;;;497        {
;;;498          /* Enable the Internal Low Speed oscillator (LSI). */
;;;499          __HAL_RCC_LSI_ENABLE();
00014a  4879              LDR      r0,|L14.816|
00014c  6969              LDR      r1,[r5,#0x14]         ;496
00014e  306c              ADDS     r0,r0,#0x6c
000150  2900              CMP      r1,#0                 ;496
;;;500    
;;;501          /* Get Start Tick*/
;;;502          tickstart = HAL_GetTick();
;;;503    
;;;504          /* Wait till LSI is ready */
;;;505          while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
;;;506          {
;;;507            if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
;;;508            {
;;;509              return HAL_TIMEOUT;
;;;510            }
;;;511          }
;;;512        }
;;;513        else
;;;514        {
;;;515          /* Disable the Internal Low Speed oscillator (LSI). */
;;;516          __HAL_RCC_LSI_DISABLE();
000152  4680              MOV      r8,r0
000154  6801              LDR      r1,[r0,#0]
000156  d012              BEQ      |L14.382|
000158  f0410101          ORR      r1,r1,#1              ;499
00015c  6001              STR      r1,[r0,#0]            ;499
00015e  f7fffffe          BL       HAL_GetTick
000162  4606              MOV      r6,r0                 ;502
000164  e005              B        |L14.370|
000166  bf00              NOP                            ;507
                  |L14.360|
000168  f7fffffe          BL       HAL_GetTick
00016c  1b80              SUBS     r0,r0,r6              ;507
00016e  2802              CMP      r0,#2                 ;507
000170  d804              BHI      |L14.380|
                  |L14.370|
000172  f8d80000          LDR      r0,[r8,#0]            ;505
000176  0780              LSLS     r0,r0,#30             ;505
000178  d5f6              BPL      |L14.360|
00017a  e010              B        |L14.414|
                  |L14.380|
00017c  e089              B        |L14.658|
                  |L14.382|
00017e  f0210101          BIC      r1,r1,#1
000182  6001              STR      r1,[r0,#0]
;;;517    
;;;518          /* Get Start Tick*/
;;;519          tickstart = HAL_GetTick();
000184  f7fffffe          BL       HAL_GetTick
000188  4606              MOV      r6,r0
;;;520    
;;;521          /* Wait till LSI is ready */
;;;522          while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
00018a  e004              B        |L14.406|
                  |L14.396|
;;;523          {
;;;524            if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
00018c  f7fffffe          BL       HAL_GetTick
000190  1b80              SUBS     r0,r0,r6
000192  2802              CMP      r0,#2
000194  d87d              BHI      |L14.658|
                  |L14.406|
000196  f8d80000          LDR      r0,[r8,#0]            ;522
00019a  0780              LSLS     r0,r0,#30             ;522
00019c  d4f6              BMI      |L14.396|
                  |L14.414|
;;;525            {
;;;526              return HAL_TIMEOUT;
;;;527            }
;;;528          }
;;;529        }
;;;530      }
;;;531      /*------------------------------ LSE Configuration -------------------------*/
;;;532      if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
00019e  7828              LDRB     r0,[r5,#0]
0001a0  0740              LSLS     r0,r0,#29
0001a2  d56b              BPL      |L14.636|
;;;533      {
;;;534        /* Check the parameters */
;;;535        assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
;;;536    
;;;537        /* Update LSE configuration in Backup Domain control register    */
;;;538        /* Requires to enable write access to Backup Domain of necessary */
;;;539        if(__HAL_RCC_PWR_IS_CLK_DISABLED())
0001a4  f8df8188          LDR      r8,|L14.816|
0001a8  f1080838          ADD      r8,r8,#0x38
0001ac  f8d80000          LDR      r0,[r8,#0]
0001b0  00c0              LSLS     r0,r0,#3
0001b2  d40b              BMI      |L14.460|
;;;540        {
;;;541          /* Enable Power Clock*/
;;;542          __HAL_RCC_PWR_CLK_ENABLE();
0001b4  f8d81000          LDR      r1,[r8,#0]
0001b8  f0415180          ORR      r1,r1,#0x10000000
0001bc  f8c81000          STR      r1,[r8,#0]
0001c0  f8d80000          LDR      r0,[r8,#0]
;;;543          pwrclkchanged = SET;
0001c4  2701              MOVS     r7,#1
0001c6  f0005080          AND      r0,r0,#0x10000000     ;542
0001ca  9000              STR      r0,[sp,#0]
                  |L14.460|
;;;544        }
;;;545    
;;;546        if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
0001cc  4859              LDR      r0,|L14.820|
0001ce  6801              LDR      r1,[r0,#0]
0001d0  05c9              LSLS     r1,r1,#23
0001d2  d412              BMI      |L14.506|
;;;547        {
;;;548          /* Enable write access to Backup domain */
;;;549          PWR->CR1 |= PWR_CR1_DBP;
0001d4  6801              LDR      r1,[r0,#0]
0001d6  4683              MOV      r11,r0
0001d8  f4417180          ORR      r1,r1,#0x100
0001dc  6001              STR      r1,[r0,#0]
;;;550    
;;;551          /* Wait for Backup domain Write protection disable */
;;;552          tickstart = HAL_GetTick();
0001de  f7fffffe          BL       HAL_GetTick
0001e2  4606              MOV      r6,r0
;;;553    
;;;554          while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
0001e4  e005              B        |L14.498|
;;;555          {
;;;556            if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
0001e6  bf00              NOP      
                  |L14.488|
0001e8  f7fffffe          BL       HAL_GetTick
0001ec  1b80              SUBS     r0,r0,r6
0001ee  2864              CMP      r0,#0x64
0001f0  d84f              BHI      |L14.658|
                  |L14.498|
0001f2  f8db0000          LDR      r0,[r11,#0]           ;554
0001f6  05c0              LSLS     r0,r0,#23             ;554
0001f8  d5f6              BPL      |L14.488|
                  |L14.506|
;;;557            {
;;;558              return HAL_TIMEOUT;
;;;559            }
;;;560          }
;;;561        }
;;;562    
;;;563        /* Set the new LSE configuration -----------------------------------------*/
;;;564        __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
0001fa  4e4d              LDR      r6,|L14.816|
0001fc  68a8              LDR      r0,[r5,#8]
0001fe  3668              ADDS     r6,r6,#0x68
000200  2801              CMP      r0,#1
000202  d00a              BEQ      |L14.538|
000204  b108              CBZ      r0,|L14.522|
000206  2805              CMP      r0,#5
000208  d011              BEQ      |L14.558|
                  |L14.522|
00020a  6830              LDR      r0,[r6,#0]
00020c  f0200001          BIC      r0,r0,#1
000210  6030              STR      r0,[r6,#0]
000212  6830              LDR      r0,[r6,#0]
000214  f0200004          BIC      r0,r0,#4
000218  e002              B        |L14.544|
                  |L14.538|
00021a  6830              LDR      r0,[r6,#0]
00021c  f0400001          ORR      r0,r0,#1
                  |L14.544|
000220  6030              STR      r0,[r6,#0]
;;;565        /* Check the LSE State */
;;;566        if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
000222  68a8              LDR      r0,[r5,#8]
000224  b1a0              CBZ      r0,|L14.592|
;;;567        {
;;;568          /* Get Start Tick*/
;;;569          tickstart = HAL_GetTick();
000226  f7fffffe          BL       HAL_GetTick
00022a  4683              MOV      r11,r0
;;;570    
;;;571          /* Wait till LSE is ready */
;;;572          while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
00022c  e00c              B        |L14.584|
                  |L14.558|
00022e  6830              LDR      r0,[r6,#0]            ;564
000230  f0400004          ORR      r0,r0,#4              ;564
000234  6030              STR      r0,[r6,#0]            ;564
000236  e7f0              B        |L14.538|
                  |L14.568|
;;;573          {
;;;574            if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
000238  f7fffffe          BL       HAL_GetTick
00023c  eba0010b          SUB      r1,r0,r11
000240  f2413088          MOV      r0,#0x1388
000244  4281              CMP      r1,r0
000246  d868              BHI      |L14.794|
                  |L14.584|
000248  6830              LDR      r0,[r6,#0]            ;572
00024a  0780              LSLS     r0,r0,#30             ;572
00024c  d5f4              BPL      |L14.568|
00024e  e00e              B        |L14.622|
                  |L14.592|
;;;575            {
;;;576              return HAL_TIMEOUT;
;;;577            }
;;;578          }
;;;579        }
;;;580        else
;;;581        {
;;;582          /* Get Start Tick*/
;;;583          tickstart = HAL_GetTick();
000250  f7fffffe          BL       HAL_GetTick
000254  4683              MOV      r11,r0
;;;584    
;;;585          /* Wait till LSE is ready */
;;;586          while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
000256  e007              B        |L14.616|
                  |L14.600|
;;;587          {
;;;588            if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
000258  f7fffffe          BL       HAL_GetTick
00025c  eba0010b          SUB      r1,r0,r11
000260  f2413088          MOV      r0,#0x1388
000264  4281              CMP      r1,r0
000266  d858              BHI      |L14.794|
                  |L14.616|
000268  6830              LDR      r0,[r6,#0]            ;586
00026a  0780              LSLS     r0,r0,#30             ;586
00026c  d4f4              BMI      |L14.600|
                  |L14.622|
;;;589            {
;;;590              return HAL_TIMEOUT;
;;;591            }
;;;592          }
;;;593        }
;;;594    
;;;595        /* Restore clock configuration if changed */
;;;596        if(pwrclkchanged == SET)
00026e  b12f              CBZ      r7,|L14.636|
;;;597        {
;;;598          __HAL_RCC_PWR_CLK_DISABLE();
000270  f8d81000          LDR      r1,[r8,#0]
000274  f0215180          BIC      r1,r1,#0x10000000
000278  f8c81000          STR      r1,[r8,#0]
                  |L14.636|
;;;599        }
;;;600      }
;;;601      /*-------------------------------- PLL Configuration -----------------------*/
;;;602      /* Check the parameters */
;;;603      assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
;;;604      if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
00027c  69a8              LDR      r0,[r5,#0x18]
00027e  b3e0              CBZ      r0,|L14.762|
;;;605      {
;;;606        /* Check if the PLL is used as system clock or not */
;;;607        if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
000280  f8d91000          LDR      r1,[r9,#0]
000284  f3c10181          UBFX     r1,r1,#2,#2
000288  2902              CMP      r1,#2
00028a  d04e              BEQ      |L14.810|
;;;608        {
;;;609          if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
00028c  2802              CMP      r0,#2
;;;610          {
;;;611            /* Check the parameters */
;;;612            assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
;;;613            assert_param(IS_RCC_PLLM_VALUE(RCC_OscInitStruct->PLL.PLLM));
;;;614            assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
;;;615            assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
;;;616            assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
;;;617    #if defined (RCC_PLLCFGR_PLLR)
;;;618            assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
;;;619    #endif
;;;620    
;;;621            /* Disable the main PLL. */
;;;622            __HAL_RCC_PLL_DISABLE();
;;;623    
;;;624            /* Get Start Tick*/
;;;625            tickstart = HAL_GetTick();
;;;626    
;;;627            /* Wait till PLL is ready */
;;;628            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
;;;629            {
;;;630              if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
;;;631              {
;;;632                return HAL_TIMEOUT;
;;;633              }
;;;634            }
;;;635    
;;;636            /* Configure the main PLL clock source, multiplication and division factors. */
;;;637    #if defined (RCC_PLLCFGR_PLLR)
;;;638            __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
;;;639                                 RCC_OscInitStruct->PLL.PLLM,
;;;640                                 RCC_OscInitStruct->PLL.PLLN,
;;;641                                 RCC_OscInitStruct->PLL.PLLP,
;;;642                                 RCC_OscInitStruct->PLL.PLLQ,
;;;643                                 RCC_OscInitStruct->PLL.PLLR);
;;;644    #else
;;;645            __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
;;;646                                 RCC_OscInitStruct->PLL.PLLM,
;;;647                                 RCC_OscInitStruct->PLL.PLLN,
;;;648                                 RCC_OscInitStruct->PLL.PLLP,
;;;649                                 RCC_OscInitStruct->PLL.PLLQ);
;;;650    #endif
;;;651    
;;;652            /* Enable the main PLL. */
;;;653            __HAL_RCC_PLL_ENABLE();
;;;654    
;;;655            /* Get Start Tick*/
;;;656            tickstart = HAL_GetTick();
;;;657    
;;;658            /* Wait till PLL is ready */
;;;659            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
;;;660            {
;;;661              if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
;;;662              {
;;;663                return HAL_TIMEOUT;
;;;664              }
;;;665            }
;;;666          }
;;;667          else
;;;668          {
;;;669            /* Disable the main PLL. */
;;;670            __HAL_RCC_PLL_DISABLE();
00028e  6820              LDR      r0,[r4,#0]
000290  e000              B        |L14.660|
                  |L14.658|
000292  e042              B        |L14.794|
                  |L14.660|
000294  f0207080          BIC      r0,r0,#0x1000000
000298  6020              STR      r0,[r4,#0]
00029a  d003              BEQ      |L14.676|
;;;671    
;;;672            /* Get Start Tick*/
;;;673            tickstart = HAL_GetTick();
00029c  f7fffffe          BL       HAL_GetTick
0002a0  4605              MOV      r5,r0
;;;674    
;;;675            /* Wait till PLL is ready */
;;;676            while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
0002a2  e03d              B        |L14.800|
                  |L14.676|
0002a4  f7fffffe          BL       HAL_GetTick
0002a8  4606              MOV      r6,r0                 ;625
0002aa  e004              B        |L14.694|
                  |L14.684|
0002ac  f7fffffe          BL       HAL_GetTick
0002b0  1b80              SUBS     r0,r0,r6              ;630
0002b2  2802              CMP      r0,#2                 ;630
0002b4  d831              BHI      |L14.794|
                  |L14.694|
0002b6  6820              LDR      r0,[r4,#0]            ;628
0002b8  0180              LSLS     r0,r0,#6              ;628
0002ba  d4f7              BMI      |L14.684|
0002bc  e9d52109          LDRD     r2,r1,[r5,#0x24]      ;638
0002c0  f8dfc074          LDR      r12,|L14.824|
0002c4  e9d50607          LDRD     r0,r6,[r5,#0x1c]      ;638
0002c8  f8953030          LDRB     r3,[r5,#0x30]         ;638
0002cc  084f              LSRS     r7,r1,#1              ;638
0002ce  f895102c          LDRB     r1,[r5,#0x2c]         ;638
0002d2  4330              ORRS     r0,r0,r6              ;638
0002d4  eb0c4507          ADD      r5,r12,r7,LSL #16     ;638
0002d8  ea451282          ORR      r2,r5,r2,LSL #6       ;638
0002dc  4310              ORRS     r0,r0,r2              ;638
0002de  ea406001          ORR      r0,r0,r1,LSL #24      ;638
0002e2  ea407003          ORR      r0,r0,r3,LSL #28      ;638
0002e6  f8ca0000          STR      r0,[r10,#0]           ;638
0002ea  6820              LDR      r0,[r4,#0]            ;653
0002ec  f0407080          ORR      r0,r0,#0x1000000      ;653
0002f0  6020              STR      r0,[r4,#0]            ;653
0002f2  f7fffffe          BL       HAL_GetTick
0002f6  4605              MOV      r5,r0                 ;656
0002f8  e005              B        |L14.774|
                  |L14.762|
0002fa  e014              B        |L14.806|
                  |L14.764|
0002fc  f7fffffe          BL       HAL_GetTick
000300  1b40              SUBS     r0,r0,r5              ;661
000302  2802              CMP      r0,#2                 ;661
000304  d809              BHI      |L14.794|
                  |L14.774|
000306  6820              LDR      r0,[r4,#0]            ;659
000308  0180              LSLS     r0,r0,#6              ;659
00030a  d5f7              BPL      |L14.764|
00030c  e00b              B        |L14.806|
;;;677            {
;;;678              if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
00030e  bf00              NOP      
                  |L14.784|
000310  f7fffffe          BL       HAL_GetTick
000314  1b40              SUBS     r0,r0,r5
000316  2802              CMP      r0,#2
000318  d902              BLS      |L14.800|
                  |L14.794|
;;;679              {
;;;680                return HAL_TIMEOUT;
00031a  2003              MOVS     r0,#3
                  |L14.796|
;;;681              }
;;;682            }
;;;683          }
;;;684        }
;;;685        else
;;;686        {
;;;687          return HAL_ERROR;
;;;688        }
;;;689      }
;;;690      return HAL_OK;
;;;691    }
00031c  e8bd8ff8          POP      {r3-r11,pc}
                  |L14.800|
000320  6820              LDR      r0,[r4,#0]            ;676
000322  0180              LSLS     r0,r0,#6              ;676
000324  d4f4              BMI      |L14.784|
                  |L14.806|
000326  2000              MOVS     r0,#0                 ;690
000328  e7f8              B        |L14.796|
                  |L14.810|
00032a  2001              MOVS     r0,#1                 ;687
00032c  e7f6              B        |L14.796|
;;;692    
                          ENDP

00032e  0000              DCW      0x0000
                  |L14.816|
                          DCD      0x40023808
                  |L14.820|
                          DCD      0x40007000
                  |L14.824|
                          DCD      0xffff0000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F7_V1.11.0\\Drivers\\STM32F7xx_HAL_Driver\\Src\\stm32f7xx_hal_rcc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f7xx_hal_rcc_c_b7071a4b____REV16|
#line 468 "D:\\Program_Files_x86\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.3.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___19_stm32f7xx_hal_rcc_c_b7071a4b____REV16| PROC
#line 469

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f7xx_hal_rcc_c_b7071a4b____REVSH|
#line 483
|__asm___19_stm32f7xx_hal_rcc_c_b7071a4b____REVSH| PROC
#line 484

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f7xx_hal_rcc_c_b7071a4b____RRX|
#line 670
|__asm___19_stm32f7xx_hal_rcc_c_b7071a4b____RRX| PROC
#line 671

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
