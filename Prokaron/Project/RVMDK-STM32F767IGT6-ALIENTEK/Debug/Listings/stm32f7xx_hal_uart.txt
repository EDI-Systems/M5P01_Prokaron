; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f7xx_hal_uart.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f7xx_hal_uart.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Core -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Inc -I.\Source -I.\Drivers -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6-ALIENTEK\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f7xx_hal_uart.crf ..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_uart.c]
                          THUMB

                          AREA ||i.HAL_HalfDuplex_EnableReceiver||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableReceiver PROC
;;;2070     */
;;;2071   HAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;2072   {
;;;2073     /* Process Locked */
;;;2074     __HAL_LOCK(huart);
000002  6e81              LDR      r1,[r0,#0x68]
000004  2901              CMP      r1,#1
000006  d013              BEQ      |L1.48|
000008  2201              MOVS     r2,#1
;;;2075     huart->gState = HAL_UART_STATE_BUSY;
;;;2076   
;;;2077     /* Clear TE and RE bits */
;;;2078     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TE | USART_CR1_RE));
;;;2079     /* Enable the USART's receive interface by setting the RE bit in the USART CR1 register */
;;;2080     SET_BIT(huart->Instance->CR1, USART_CR1_RE);
;;;2081   
;;;2082     huart->gState = HAL_UART_STATE_READY;
00000a  6682              STR      r2,[r0,#0x68]
00000c  2124              MOVS     r1,#0x24              ;2075
00000e  66c1              STR      r1,[r0,#0x6c]         ;2075
000010  2220              MOVS     r2,#0x20
;;;2083     /* Process Unlocked */
;;;2084     __HAL_UNLOCK(huart);
000012  2300              MOVS     r3,#0
000014  6801              LDR      r1,[r0,#0]            ;2078
000016  680c              LDR      r4,[r1,#0]            ;2078
000018  f024040c          BIC      r4,r4,#0xc            ;2078
00001c  600c              STR      r4,[r1,#0]            ;2078
00001e  6801              LDR      r1,[r0,#0]            ;2080
000020  680c              LDR      r4,[r1,#0]            ;2080
000022  f0440404          ORR      r4,r4,#4              ;2080
000026  600c              STR      r4,[r1,#0]            ;2080
000028  66c2              STR      r2,[r0,#0x6c]         ;2082
;;;2085   
;;;2086     return HAL_OK;
00002a  6683              STR      r3,[r0,#0x68]
00002c  4618              MOV      r0,r3
;;;2087   }
00002e  bd10              POP      {r4,pc}
                  |L1.48|
000030  2002              MOVS     r0,#2                 ;2074
000032  bd10              POP      {r4,pc}
;;;2088   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_EnableTransmitter||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableTransmitter PROC
;;;2047     */
;;;2048   HAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;2049   {
;;;2050     /* Process Locked */
;;;2051     __HAL_LOCK(huart);
000002  6e81              LDR      r1,[r0,#0x68]
000004  2901              CMP      r1,#1
000006  d013              BEQ      |L2.48|
000008  2201              MOVS     r2,#1
;;;2052     huart->gState = HAL_UART_STATE_BUSY;
;;;2053   
;;;2054     /* Clear TE and RE bits */
;;;2055     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TE | USART_CR1_RE));
;;;2056     /* Enable the USART's transmit interface by setting the TE bit in the USART CR1 register */
;;;2057     SET_BIT(huart->Instance->CR1, USART_CR1_TE);
;;;2058   
;;;2059     huart->gState= HAL_UART_STATE_READY;
00000a  6682              STR      r2,[r0,#0x68]
00000c  2124              MOVS     r1,#0x24              ;2052
00000e  66c1              STR      r1,[r0,#0x6c]         ;2052
000010  2220              MOVS     r2,#0x20
;;;2060     /* Process Unlocked */
;;;2061     __HAL_UNLOCK(huart);
000012  2300              MOVS     r3,#0
000014  6801              LDR      r1,[r0,#0]            ;2055
000016  680c              LDR      r4,[r1,#0]            ;2055
000018  f024040c          BIC      r4,r4,#0xc            ;2055
00001c  600c              STR      r4,[r1,#0]            ;2055
00001e  6801              LDR      r1,[r0,#0]            ;2057
000020  680c              LDR      r4,[r1,#0]            ;2057
000022  f0440408          ORR      r4,r4,#8              ;2057
000026  600c              STR      r4,[r1,#0]            ;2057
000028  66c2              STR      r2,[r0,#0x6c]         ;2059
;;;2062   
;;;2063     return HAL_OK;
00002a  6683              STR      r3,[r0,#0x68]
00002c  4618              MOV      r0,r3
;;;2064   }
00002e  bd10              POP      {r4,pc}
                  |L2.48|
000030  2002              MOVS     r0,#2                 ;2051
000032  bd10              POP      {r4,pc}
;;;2065   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_Init||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_Init PROC
;;;303      */
;;;304    HAL_StatusTypeDef HAL_HalfDuplex_Init(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;305    {
000002  0004              MOVS     r4,r0
000004  d002              BEQ      |L3.12|
;;;306      /* Check the UART handle allocation */
;;;307      if(huart == NULL)
;;;308      {
;;;309        return HAL_ERROR;
;;;310      }
;;;311    
;;;312      if(huart->gState == HAL_UART_STATE_RESET)
000006  6ee0              LDR      r0,[r4,#0x6c]
000008  b110              CBZ      r0,|L3.16|
00000a  e006              B        |L3.26|
                  |L3.12|
00000c  2001              MOVS     r0,#1                 ;309
                  |L3.14|
;;;313      {
;;;314        /* Allocate lock resource and initialize it */
;;;315        huart->Lock = HAL_UNLOCKED;
;;;316    
;;;317        /* Init the low level hardware : GPIO, CLOCK */
;;;318        HAL_UART_MspInit(huart);
;;;319      }
;;;320    
;;;321      huart->gState = HAL_UART_STATE_BUSY;
;;;322    
;;;323      /* Disable the Peripheral */
;;;324      __HAL_UART_DISABLE(huart);
;;;325    
;;;326      /* Set the UART Communication parameters */
;;;327      if (UART_SetConfig(huart) == HAL_ERROR)
;;;328      {
;;;329        return HAL_ERROR;
;;;330      }
;;;331    
;;;332      if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;333      {
;;;334        UART_AdvFeatureConfig(huart);
;;;335      }
;;;336    
;;;337      /* In half-duplex mode, the following bits must be kept cleared:
;;;338      - LINEN and CLKEN bits in the USART_CR2 register,
;;;339      - SCEN and IREN bits in the USART_CR3 register.*/
;;;340      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;341      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_IREN | USART_CR3_SCEN));
;;;342    
;;;343      /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;344      SET_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
;;;345    
;;;346      /* Enable the Peripheral */
;;;347      __HAL_UART_ENABLE(huart);
;;;348    
;;;349      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;350      return (UART_CheckIdleState(huart));
;;;351    }
00000e  bd10              POP      {r4,pc}
                  |L3.16|
000010  2000              MOVS     r0,#0                 ;315
000012  66a0              STR      r0,[r4,#0x68]         ;318
000014  4620              MOV      r0,r4                 ;318
000016  f7fffffe          BL       HAL_UART_MspInit
                  |L3.26|
00001a  2024              MOVS     r0,#0x24              ;321
00001c  66e0              STR      r0,[r4,#0x6c]         ;321
00001e  6820              LDR      r0,[r4,#0]            ;324
000020  6801              LDR      r1,[r0,#0]            ;324
000022  f0210101          BIC      r1,r1,#1              ;324
000026  6001              STR      r1,[r0,#0]            ;324
000028  4620              MOV      r0,r4                 ;327
00002a  f7fffffe          BL       UART_SetConfig
00002e  2801              CMP      r0,#1                 ;327
000030  d0ed              BEQ      |L3.14|
000032  6a60              LDR      r0,[r4,#0x24]         ;332
000034  b110              CBZ      r0,|L3.60|
000036  4620              MOV      r0,r4                 ;334
000038  f7fffffe          BL       UART_AdvFeatureConfig
                  |L3.60|
00003c  6820              LDR      r0,[r4,#0]            ;340
00003e  6841              LDR      r1,[r0,#4]            ;340
000040  f4214190          BIC      r1,r1,#0x4800         ;340
000044  6041              STR      r1,[r0,#4]            ;340
000046  6820              LDR      r0,[r4,#0]            ;341
000048  6881              LDR      r1,[r0,#8]            ;341
00004a  f0210122          BIC      r1,r1,#0x22           ;341
00004e  6081              STR      r1,[r0,#8]            ;341
000050  6820              LDR      r0,[r4,#0]            ;344
000052  6881              LDR      r1,[r0,#8]            ;344
000054  f0410108          ORR      r1,r1,#8              ;344
000058  6081              STR      r1,[r0,#8]            ;344
00005a  6820              LDR      r0,[r4,#0]            ;347
00005c  6801              LDR      r1,[r0,#0]            ;347
00005e  f0410101          ORR      r1,r1,#1              ;347
000062  6001              STR      r1,[r0,#0]            ;347
000064  4620              MOV      r0,r4                 ;350
000066  e8bd4010          POP      {r4,lr}               ;350
00006a  f7ffbffe          B.W      UART_CheckIdleState
;;;352    
                          ENDP


                          AREA ||i.HAL_LIN_Init||, CODE, READONLY, ALIGN=1

                  HAL_LIN_Init PROC
;;;363      */
;;;364    HAL_StatusTypeDef HAL_LIN_Init(UART_HandleTypeDef *huart, uint32_t BreakDetectLength)
000000  b570              PUSH     {r4-r6,lr}
;;;365    {
000002  0004              MOVS     r4,r0
000004  460d              MOV      r5,r1
000006  d002              BEQ      |L4.14|
;;;366      /* Check the UART handle allocation */
;;;367      if(huart == NULL)
;;;368      {
;;;369        return HAL_ERROR;
;;;370      }
;;;371    
;;;372      /* Check the parameters */
;;;373      assert_param(IS_UART_INSTANCE(huart->Instance));
;;;374      assert_param(IS_UART_LIN_BREAK_DETECT_LENGTH(BreakDetectLength));
;;;375      assert_param(IS_LIN_WORD_LENGTH(huart->Init.WordLength));
;;;376    
;;;377      if(huart->gState == HAL_UART_STATE_RESET)
000008  6ee0              LDR      r0,[r4,#0x6c]
00000a  b110              CBZ      r0,|L4.18|
00000c  e006              B        |L4.28|
                  |L4.14|
00000e  2001              MOVS     r0,#1                 ;369
                  |L4.16|
;;;378      {
;;;379        /* Allocate lock resource and initialize it */
;;;380        huart->Lock = HAL_UNLOCKED;
;;;381    
;;;382        /* Init the low level hardware : GPIO, CLOCK */
;;;383        HAL_UART_MspInit(huart);
;;;384      }
;;;385    
;;;386      huart->gState = HAL_UART_STATE_BUSY;
;;;387    
;;;388      /* Disable the Peripheral */
;;;389      __HAL_UART_DISABLE(huart);
;;;390    
;;;391      /* Set the UART Communication parameters */
;;;392      if (UART_SetConfig(huart) == HAL_ERROR)
;;;393      {
;;;394        return HAL_ERROR;
;;;395      }
;;;396    
;;;397      if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;398      {
;;;399        UART_AdvFeatureConfig(huart);
;;;400      }
;;;401    
;;;402      /* In LIN mode, the following bits must be kept cleared:
;;;403      - LINEN and CLKEN bits in the USART_CR2 register,
;;;404      - SCEN and IREN bits in the USART_CR3 register.*/
;;;405      CLEAR_BIT(huart->Instance->CR2, USART_CR2_CLKEN);
;;;406      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_HDSEL | USART_CR3_IREN | USART_CR3_SCEN));
;;;407    
;;;408      /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;409      SET_BIT(huart->Instance->CR2, USART_CR2_LINEN);
;;;410    
;;;411      /* Set the USART LIN Break detection length. */
;;;412      MODIFY_REG(huart->Instance->CR2, USART_CR2_LBDL, BreakDetectLength);
;;;413    
;;;414      /* Enable the Peripheral */
;;;415      __HAL_UART_ENABLE(huart);
;;;416    
;;;417      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;418      return (UART_CheckIdleState(huart));
;;;419    }
000010  bd70              POP      {r4-r6,pc}
                  |L4.18|
000012  2000              MOVS     r0,#0                 ;380
000014  66a0              STR      r0,[r4,#0x68]         ;383
000016  4620              MOV      r0,r4                 ;383
000018  f7fffffe          BL       HAL_UART_MspInit
                  |L4.28|
00001c  2024              MOVS     r0,#0x24              ;386
00001e  66e0              STR      r0,[r4,#0x6c]         ;386
000020  6820              LDR      r0,[r4,#0]            ;389
000022  6801              LDR      r1,[r0,#0]            ;389
000024  f0210101          BIC      r1,r1,#1              ;389
000028  6001              STR      r1,[r0,#0]            ;389
00002a  4620              MOV      r0,r4                 ;392
00002c  f7fffffe          BL       UART_SetConfig
000030  2801              CMP      r0,#1                 ;392
000032  d0ed              BEQ      |L4.16|
000034  6a60              LDR      r0,[r4,#0x24]         ;397
000036  b110              CBZ      r0,|L4.62|
000038  4620              MOV      r0,r4                 ;399
00003a  f7fffffe          BL       UART_AdvFeatureConfig
                  |L4.62|
00003e  6820              LDR      r0,[r4,#0]            ;405
000040  6841              LDR      r1,[r0,#4]            ;405
000042  f4216100          BIC      r1,r1,#0x800          ;405
000046  6041              STR      r1,[r0,#4]            ;405
000048  6820              LDR      r0,[r4,#0]            ;406
00004a  6881              LDR      r1,[r0,#8]            ;406
00004c  f021012a          BIC      r1,r1,#0x2a           ;406
000050  6081              STR      r1,[r0,#8]            ;406
000052  6820              LDR      r0,[r4,#0]            ;409
000054  6841              LDR      r1,[r0,#4]            ;409
000056  f4414180          ORR      r1,r1,#0x4000         ;409
00005a  6041              STR      r1,[r0,#4]            ;409
00005c  6820              LDR      r0,[r4,#0]            ;412
00005e  6841              LDR      r1,[r0,#4]            ;412
000060  f0210120          BIC      r1,r1,#0x20           ;412
000064  4329              ORRS     r1,r1,r5              ;412
000066  6041              STR      r1,[r0,#4]            ;412
000068  6820              LDR      r0,[r4,#0]            ;415
00006a  6801              LDR      r1,[r0,#0]            ;415
00006c  f0410101          ORR      r1,r1,#1              ;415
000070  6001              STR      r1,[r0,#0]            ;415
000072  4620              MOV      r0,r4                 ;418
000074  e8bd4070          POP      {r4-r6,lr}            ;418
000078  f7ffbffe          B.W      UART_CheckIdleState
;;;420    
                          ENDP


                          AREA ||i.HAL_LIN_SendBreak||, CODE, READONLY, ALIGN=1

                  HAL_LIN_SendBreak PROC
;;;2094     */
;;;2095   HAL_StatusTypeDef HAL_LIN_SendBreak(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;2096   {
;;;2097     /* Check the parameters */
;;;2098     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;2099   
;;;2100     /* Process Locked */
;;;2101     __HAL_LOCK(huart);
000002  6e81              LDR      r1,[r0,#0x68]
000004  2901              CMP      r1,#1
000006  d00e              BEQ      |L5.38|
000008  2201              MOVS     r2,#1
;;;2102   
;;;2103     huart->gState = HAL_UART_STATE_BUSY;
;;;2104   
;;;2105     /* Send break characters */
;;;2106     SET_BIT(huart->Instance->RQR, UART_SENDBREAK_REQUEST);
;;;2107   
;;;2108     huart->gState = HAL_UART_STATE_READY;
;;;2109   
;;;2110     /* Process Unlocked */
;;;2111     __HAL_UNLOCK(huart);
00000a  6682              STR      r2,[r0,#0x68]
00000c  2124              MOVS     r1,#0x24              ;2103
00000e  66c1              STR      r1,[r0,#0x6c]         ;2103
000010  2320              MOVS     r3,#0x20              ;2108
000012  2200              MOVS     r2,#0
000014  6801              LDR      r1,[r0,#0]            ;2106
000016  698c              LDR      r4,[r1,#0x18]         ;2106
000018  f0440402          ORR      r4,r4,#2              ;2106
00001c  618c              STR      r4,[r1,#0x18]         ;2106
00001e  66c3              STR      r3,[r0,#0x6c]         ;2108
;;;2112   
;;;2113     return HAL_OK;
000020  6682              STR      r2,[r0,#0x68]
000022  4610              MOV      r0,r2
;;;2114   }
000024  bd10              POP      {r4,pc}
                  |L5.38|
000026  2002              MOVS     r0,#2                 ;2101
000028  bd10              POP      {r4,pc}
;;;2115   
                          ENDP


                          AREA ||i.HAL_MultiProcessorEx_AddressLength_Set||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessorEx_AddressLength_Set PROC
;;;2128     */
;;;2129   HAL_StatusTypeDef HAL_MultiProcessorEx_AddressLength_Set(UART_HandleTypeDef *huart, uint32_t AddressLength)
000000  b198              CBZ      r0,|L6.42|
;;;2130   {
;;;2131     /* Check the UART handle allocation */
;;;2132     if(huart == NULL)
;;;2133     {
;;;2134       return HAL_ERROR;
;;;2135     }
;;;2136   
;;;2137     /* Check the address length parameter */
;;;2138     assert_param(IS_UART_ADDRESSLENGTH_DETECT(AddressLength));
;;;2139   
;;;2140     huart->gState = HAL_UART_STATE_BUSY;
000002  2224              MOVS     r2,#0x24
000004  66c2              STR      r2,[r0,#0x6c]
;;;2141   
;;;2142     /* Disable the Peripheral */
;;;2143     __HAL_UART_DISABLE(huart);
000006  6802              LDR      r2,[r0,#0]
000008  6813              LDR      r3,[r2,#0]
00000a  f0230301          BIC      r3,r3,#1
00000e  6013              STR      r3,[r2,#0]
;;;2144   
;;;2145     /* Set the address length */
;;;2146     MODIFY_REG(huart->Instance->CR2, USART_CR2_ADDM7, AddressLength);
000010  6802              LDR      r2,[r0,#0]
000012  6853              LDR      r3,[r2,#4]
000014  f0230310          BIC      r3,r3,#0x10
000018  430b              ORRS     r3,r3,r1
00001a  6053              STR      r3,[r2,#4]
;;;2147   
;;;2148     /* Enable the Peripheral */
;;;2149     __HAL_UART_ENABLE(huart);
00001c  6801              LDR      r1,[r0,#0]
00001e  680a              LDR      r2,[r1,#0]
000020  f0420201          ORR      r2,r2,#1
000024  600a              STR      r2,[r1,#0]
;;;2150   
;;;2151     /* TEACK and/or REACK to check before moving huart->gState to Ready */
;;;2152     return (UART_CheckIdleState(huart));
000026  f7ffbffe          B.W      UART_CheckIdleState
                  |L6.42|
00002a  2001              MOVS     r0,#1                 ;2134
;;;2153   }
00002c  4770              BX       lr
;;;2154   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_DisableMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_DisableMuteMode PROC
;;;1766     */
;;;1767   HAL_StatusTypeDef HAL_MultiProcessor_DisableMuteMode(UART_HandleTypeDef *huart)
000000  6e81              LDR      r1,[r0,#0x68]
;;;1768   {
;;;1769     /* Process Locked */
;;;1770     __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  d00c              BEQ      |L7.32|
000006  2201              MOVS     r2,#1
;;;1771   
;;;1772     huart->gState = HAL_UART_STATE_BUSY;
;;;1773   
;;;1774      /* Disable USART mute mode by clearing the MME bit in the CR1 register */
;;;1775     CLEAR_BIT(huart->Instance->CR1, USART_CR1_MME);
;;;1776   
;;;1777     huart->gState = HAL_UART_STATE_READY;
000008  6682              STR      r2,[r0,#0x68]
00000a  2124              MOVS     r1,#0x24              ;1772
00000c  66c1              STR      r1,[r0,#0x6c]         ;1772
00000e  2220              MOVS     r2,#0x20
000010  6801              LDR      r1,[r0,#0]            ;1775
000012  680b              LDR      r3,[r1,#0]            ;1775
000014  f4235300          BIC      r3,r3,#0x2000         ;1775
000018  600b              STR      r3,[r1,#0]            ;1775
00001a  66c2              STR      r2,[r0,#0x6c]
;;;1778   
;;;1779     return (UART_CheckIdleState(huart));
00001c  f7ffbffe          B.W      UART_CheckIdleState
                  |L7.32|
000020  2002              MOVS     r0,#2                 ;1770
;;;1780   }
000022  4770              BX       lr
;;;1781   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_EnableMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_EnableMuteMode PROC
;;;1745     */
;;;1746   HAL_StatusTypeDef HAL_MultiProcessor_EnableMuteMode(UART_HandleTypeDef *huart)
000000  6e81              LDR      r1,[r0,#0x68]
;;;1747   {
;;;1748     /* Process Locked */
;;;1749     __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  d00c              BEQ      |L8.32|
000006  2201              MOVS     r2,#1
;;;1750   
;;;1751     huart->gState = HAL_UART_STATE_BUSY;
;;;1752   
;;;1753     /* Enable USART mute mode by setting the MME bit in the CR1 register */
;;;1754     SET_BIT(huart->Instance->CR1, USART_CR1_MME);
;;;1755   
;;;1756     huart->gState = HAL_UART_STATE_READY;
000008  6682              STR      r2,[r0,#0x68]
00000a  2124              MOVS     r1,#0x24              ;1751
00000c  66c1              STR      r1,[r0,#0x6c]         ;1751
00000e  2220              MOVS     r2,#0x20
000010  6801              LDR      r1,[r0,#0]            ;1754
000012  680b              LDR      r3,[r1,#0]            ;1754
000014  f4435300          ORR      r3,r3,#0x2000         ;1754
000018  600b              STR      r3,[r1,#0]            ;1754
00001a  66c2              STR      r2,[r0,#0x6c]
;;;1757   
;;;1758     return (UART_CheckIdleState(huart));
00001c  f7ffbffe          B.W      UART_CheckIdleState
                  |L8.32|
000020  2002              MOVS     r0,#2                 ;1749
;;;1759   }
000022  4770              BX       lr
;;;1760   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_EnterMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_EnterMuteMode PROC
;;;1787     */
;;;1788   void HAL_MultiProcessor_EnterMuteMode(UART_HandleTypeDef *huart)
000000  6800              LDR      r0,[r0,#0]
;;;1789   {
;;;1790     __HAL_UART_SEND_REQ(huart, UART_MUTE_MODE_REQUEST);
000002  6981              LDR      r1,[r0,#0x18]
000004  f0410104          ORR      r1,r1,#4
000008  6181              STR      r1,[r0,#0x18]
;;;1791   }
00000a  4770              BX       lr
;;;1792   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_Init||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_Init PROC
;;;437      */
;;;438    HAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod)
000000  b570              PUSH     {r4-r6,lr}
;;;439    {
000002  0004              MOVS     r4,r0
000004  4615              MOV      r5,r2
000006  460e              MOV      r6,r1
000008  d002              BEQ      |L10.16|
;;;440      /* Check the UART handle allocation */
;;;441      if(huart == NULL)
;;;442      {
;;;443        return HAL_ERROR;
;;;444      }
;;;445    
;;;446      /* Check the wake up method parameter */
;;;447      assert_param(IS_UART_WAKEUPMETHOD(WakeUpMethod));
;;;448    
;;;449      if(huart->gState == HAL_UART_STATE_RESET)
00000a  6ee0              LDR      r0,[r4,#0x6c]
00000c  b110              CBZ      r0,|L10.20|
00000e  e006              B        |L10.30|
                  |L10.16|
000010  2001              MOVS     r0,#1                 ;443
                  |L10.18|
;;;450      {
;;;451        /* Allocate lock resource and initialize it */
;;;452        huart->Lock = HAL_UNLOCKED;
;;;453    
;;;454        /* Init the low level hardware : GPIO, CLOCK */
;;;455        HAL_UART_MspInit(huart);
;;;456      }
;;;457    
;;;458      huart->gState = HAL_UART_STATE_BUSY;
;;;459    
;;;460      /* Disable the Peripheral */
;;;461      __HAL_UART_DISABLE(huart);
;;;462    
;;;463      /* Set the UART Communication parameters */
;;;464      if (UART_SetConfig(huart) == HAL_ERROR)
;;;465      {
;;;466        return HAL_ERROR;
;;;467      }
;;;468    
;;;469      if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;470      {
;;;471        UART_AdvFeatureConfig(huart);
;;;472      }
;;;473    
;;;474      /* In multiprocessor mode, the following bits must be kept cleared:
;;;475      - LINEN and CLKEN bits in the USART_CR2 register,
;;;476      - SCEN, HDSEL and IREN  bits in the USART_CR3 register. */
;;;477      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;478      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;479    
;;;480      if (WakeUpMethod == UART_WAKEUPMETHOD_ADDRESSMARK)
;;;481      {
;;;482        /* If address mark wake up method is chosen, set the USART address node */
;;;483        MODIFY_REG(huart->Instance->CR2, USART_CR2_ADD, ((uint32_t)Address << UART_CR2_ADDRESS_LSB_POS));
;;;484      }
;;;485    
;;;486      /* Set the wake up method by setting the WAKE bit in the CR1 register */
;;;487      MODIFY_REG(huart->Instance->CR1, USART_CR1_WAKE, WakeUpMethod);
;;;488    
;;;489      /* Enable the Peripheral */
;;;490      __HAL_UART_ENABLE(huart);
;;;491    
;;;492      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;493      return (UART_CheckIdleState(huart));
;;;494    }
000012  bd70              POP      {r4-r6,pc}
                  |L10.20|
000014  2000              MOVS     r0,#0                 ;452
000016  66a0              STR      r0,[r4,#0x68]         ;455
000018  4620              MOV      r0,r4                 ;455
00001a  f7fffffe          BL       HAL_UART_MspInit
                  |L10.30|
00001e  2024              MOVS     r0,#0x24              ;458
000020  66e0              STR      r0,[r4,#0x6c]         ;458
000022  6820              LDR      r0,[r4,#0]            ;461
000024  6801              LDR      r1,[r0,#0]            ;461
000026  f0210101          BIC      r1,r1,#1              ;461
00002a  6001              STR      r1,[r0,#0]            ;461
00002c  4620              MOV      r0,r4                 ;464
00002e  f7fffffe          BL       UART_SetConfig
000032  2801              CMP      r0,#1                 ;464
000034  d0ed              BEQ      |L10.18|
000036  6a60              LDR      r0,[r4,#0x24]         ;469
000038  b110              CBZ      r0,|L10.64|
00003a  4620              MOV      r0,r4                 ;471
00003c  f7fffffe          BL       UART_AdvFeatureConfig
                  |L10.64|
000040  6820              LDR      r0,[r4,#0]            ;480
000042  f5b56f00          CMP      r5,#0x800             ;480
000046  6841              LDR      r1,[r0,#4]            ;477
000048  f4214190          BIC      r1,r1,#0x4800         ;477
00004c  6041              STR      r1,[r0,#4]            ;477
00004e  6820              LDR      r0,[r4,#0]            ;478
000050  6881              LDR      r1,[r0,#8]            ;478
000052  f021012a          BIC      r1,r1,#0x2a           ;478
000056  6081              STR      r1,[r0,#8]            ;478
000058  d104              BNE      |L10.100|
00005a  6820              LDR      r0,[r4,#0]            ;483
00005c  6841              LDR      r1,[r0,#4]            ;483
00005e  f366611f          BFI      r1,r6,#24,#8          ;483
000062  6041              STR      r1,[r0,#4]            ;483
                  |L10.100|
000064  6820              LDR      r0,[r4,#0]            ;487
000066  6801              LDR      r1,[r0,#0]            ;487
000068  f4216100          BIC      r1,r1,#0x800          ;487
00006c  4329              ORRS     r1,r1,r5              ;487
00006e  6001              STR      r1,[r0,#0]            ;487
000070  6820              LDR      r0,[r4,#0]            ;490
000072  6801              LDR      r1,[r0,#0]            ;490
000074  f0410101          ORR      r1,r1,#1              ;490
000078  6001              STR      r1,[r0,#0]            ;490
00007a  4620              MOV      r0,r4                 ;493
00007c  e8bd4070          POP      {r4-r6,lr}            ;493
000080  f7ffbffe          B.W      UART_CheckIdleState
;;;495    
                          ENDP


                          AREA ||i.HAL_RS485Ex_Init||, CODE, READONLY, ALIGN=2

                  HAL_RS485Ex_Init PROC
;;;515      */
;;;516    HAL_StatusTypeDef HAL_RS485Ex_Init(UART_HandleTypeDef *huart, uint32_t Polarity, uint32_t AssertionTime, uint32_t DeassertionTime)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;517    {
000004  0004              MOVS     r4,r0
000006  461d              MOV      r5,r3
000008  4616              MOV      r6,r2
00000a  460f              MOV      r7,r1
00000c  d002              BEQ      |L11.20|
;;;518      uint32_t temp = 0x0;
;;;519    
;;;520      /* Check the UART handle allocation */
;;;521      if(huart == NULL)
;;;522      {
;;;523        return HAL_ERROR;
;;;524      }
;;;525      /* Check the Driver Enable UART instance */
;;;526      assert_param(IS_UART_DRIVER_ENABLE_INSTANCE(huart->Instance));
;;;527    
;;;528      /* Check the Driver Enable polarity */
;;;529      assert_param(IS_UART_DE_POLARITY(Polarity));
;;;530    
;;;531      /* Check the Driver Enable assertion time */
;;;532      assert_param(IS_UART_ASSERTIONTIME(AssertionTime));
;;;533    
;;;534      /* Check the Driver Enable deassertion time */
;;;535      assert_param(IS_UART_DEASSERTIONTIME(DeassertionTime));
;;;536    
;;;537      if(huart->gState == HAL_UART_STATE_RESET)
00000e  6ee0              LDR      r0,[r4,#0x6c]
000010  b118              CBZ      r0,|L11.26|
000012  e007              B        |L11.36|
                  |L11.20|
000014  2001              MOVS     r0,#1                 ;523
                  |L11.22|
;;;538      {
;;;539        /* Allocate lock resource and initialize it */
;;;540        huart->Lock = HAL_UNLOCKED;
;;;541    
;;;542        /* Init the low level hardware : GPIO, CLOCK, CORTEX */
;;;543        HAL_UART_MspInit(huart);
;;;544      }
;;;545    
;;;546      huart->gState = HAL_UART_STATE_BUSY;
;;;547    
;;;548      /* Disable the Peripheral */
;;;549      __HAL_UART_DISABLE(huart);
;;;550    
;;;551      /* Set the UART Communication parameters */
;;;552      if (UART_SetConfig(huart) == HAL_ERROR)
;;;553      {
;;;554        return HAL_ERROR;
;;;555      }
;;;556    
;;;557      if(huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;558      {
;;;559        UART_AdvFeatureConfig(huart);
;;;560      }
;;;561    
;;;562      /* Enable the Driver Enable mode by setting the DEM bit in the CR3 register */
;;;563      SET_BIT(huart->Instance->CR3, USART_CR3_DEM);
;;;564    
;;;565      /* Set the Driver Enable polarity */
;;;566      MODIFY_REG(huart->Instance->CR3, USART_CR3_DEP, Polarity);
;;;567    
;;;568      /* Set the Driver Enable assertion and deassertion times */
;;;569      temp = (AssertionTime << UART_CR1_DEAT_ADDRESS_LSB_POS);
;;;570      temp |= (DeassertionTime << UART_CR1_DEDT_ADDRESS_LSB_POS);
;;;571      MODIFY_REG(huart->Instance->CR1, (USART_CR1_DEDT|USART_CR1_DEAT), temp);
;;;572    
;;;573      /* Enable the Peripheral */
;;;574      __HAL_UART_ENABLE(huart);
;;;575    
;;;576      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;577      return (UART_CheckIdleState(huart));
;;;578    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L11.26|
00001a  2000              MOVS     r0,#0                 ;540
00001c  66a0              STR      r0,[r4,#0x68]         ;543
00001e  4620              MOV      r0,r4                 ;543
000020  f7fffffe          BL       HAL_UART_MspInit
                  |L11.36|
000024  2024              MOVS     r0,#0x24              ;546
000026  66e0              STR      r0,[r4,#0x6c]         ;546
000028  6820              LDR      r0,[r4,#0]            ;549
00002a  6801              LDR      r1,[r0,#0]            ;549
00002c  f0210101          BIC      r1,r1,#1              ;549
000030  6001              STR      r1,[r0,#0]            ;549
000032  4620              MOV      r0,r4                 ;552
000034  f7fffffe          BL       UART_SetConfig
000038  2801              CMP      r0,#1                 ;552
00003a  d0ec              BEQ      |L11.22|
00003c  6a60              LDR      r0,[r4,#0x24]         ;557
00003e  b110              CBZ      r0,|L11.70|
000040  4620              MOV      r0,r4                 ;559
000042  f7fffffe          BL       UART_AdvFeatureConfig
                  |L11.70|
000046  6820              LDR      r0,[r4,#0]            ;563
000048  0571              LSLS     r1,r6,#21             ;569
00004a  4a0e              LDR      r2,|L11.132|
00004c  ea414105          ORR      r1,r1,r5,LSL #16      ;570
000050  6883              LDR      r3,[r0,#8]            ;563
000052  f4434380          ORR      r3,r3,#0x4000         ;563
000056  6083              STR      r3,[r0,#8]            ;563
000058  6820              LDR      r0,[r4,#0]            ;566
00005a  6883              LDR      r3,[r0,#8]            ;566
00005c  f4234300          BIC      r3,r3,#0x8000         ;566
000060  433b              ORRS     r3,r3,r7              ;566
000062  6083              STR      r3,[r0,#8]            ;566
000064  6820              LDR      r0,[r4,#0]            ;571
000066  6803              LDR      r3,[r0,#0]            ;571
000068  4013              ANDS     r3,r3,r2              ;571
00006a  430b              ORRS     r3,r3,r1              ;571
00006c  6003              STR      r3,[r0,#0]            ;571
00006e  6820              LDR      r0,[r4,#0]            ;574
000070  6801              LDR      r1,[r0,#0]            ;574
000072  f0410101          ORR      r1,r1,#1              ;574
000076  6001              STR      r1,[r0,#0]            ;574
000078  4620              MOV      r0,r4                 ;577
00007a  e8bd41f0          POP      {r4-r8,lr}            ;577
00007e  f7ffbffe          B.W      UART_CheckIdleState
;;;579    
                          ENDP

000082  0000              DCW      0x0000
                  |L11.132|
                          DCD      0xfc00ffff

                          AREA ||i.HAL_UART_DMAPause||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAPause PROC
;;;1071     */
;;;1072   HAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart)
000000  6e81              LDR      r1,[r0,#0x68]
;;;1073   {
;;;1074     /* Process Locked */
;;;1075     __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  d005              BEQ      |L12.18|
;;;1076   
;;;1077     if ((huart->gState == HAL_UART_STATE_BUSY_TX) &&
000006  6ec2              LDR      r2,[r0,#0x6c]
000008  2101              MOVS     r1,#1                 ;1075
00000a  6681              STR      r1,[r0,#0x68]
00000c  2a21              CMP      r2,#0x21
00000e  d002              BEQ      |L12.22|
000010  e009              B        |L12.38|
                  |L12.18|
000012  2002              MOVS     r0,#2                 ;1075
;;;1078         (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)))
;;;1079     {
;;;1080       /* Disable the UART DMA Tx request */
;;;1081       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1082     }
;;;1083     if ((huart->RxState == HAL_UART_STATE_BUSY_RX) &&
;;;1084         (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)))
;;;1085     {
;;;1086       /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1087       CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1088       CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1089   
;;;1090       /* Disable the UART DMA Rx request */
;;;1091       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1092     }
;;;1093   
;;;1094     /* Process Unlocked */
;;;1095     __HAL_UNLOCK(huart);
;;;1096   
;;;1097     return HAL_OK;
;;;1098   }
000014  4770              BX       lr
                  |L12.22|
000016  6801              LDR      r1,[r0,#0]            ;1078
000018  688a              LDR      r2,[r1,#8]            ;1078
00001a  0612              LSLS     r2,r2,#24             ;1078
00001c  d503              BPL      |L12.38|
00001e  688a              LDR      r2,[r1,#8]            ;1081
000020  f0220280          BIC      r2,r2,#0x80           ;1081
000024  608a              STR      r2,[r1,#8]            ;1081
                  |L12.38|
000026  6f01              LDR      r1,[r0,#0x70]         ;1083
000028  2922              CMP      r1,#0x22              ;1083
00002a  d111              BNE      |L12.80|
00002c  6801              LDR      r1,[r0,#0]            ;1084
00002e  688a              LDR      r2,[r1,#8]            ;1084
000030  0652              LSLS     r2,r2,#25             ;1084
000032  d50d              BPL      |L12.80|
000034  680a              LDR      r2,[r1,#0]            ;1087
000036  f4227280          BIC      r2,r2,#0x100          ;1087
00003a  600a              STR      r2,[r1,#0]            ;1087
00003c  6801              LDR      r1,[r0,#0]            ;1088
00003e  688a              LDR      r2,[r1,#8]            ;1088
000040  f0220201          BIC      r2,r2,#1              ;1088
000044  608a              STR      r2,[r1,#8]            ;1088
000046  6801              LDR      r1,[r0,#0]            ;1091
000048  688a              LDR      r2,[r1,#8]            ;1091
00004a  f0220240          BIC      r2,r2,#0x40           ;1091
00004e  608a              STR      r2,[r1,#8]            ;1091
                  |L12.80|
000050  2100              MOVS     r1,#0                 ;1095
000052  6681              STR      r1,[r0,#0x68]         ;1097
000054  4608              MOV      r0,r1                 ;1097
000056  4770              BX       lr
;;;1099   
                          ENDP


                          AREA ||i.HAL_UART_DMAResume||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAResume PROC
;;;1104     */
;;;1105   HAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart)
000000  6e81              LDR      r1,[r0,#0x68]
;;;1106   {
;;;1107     /* Process Locked */
;;;1108     __HAL_LOCK(huart);
000002  2901              CMP      r1,#1
000004  d005              BEQ      |L13.18|
;;;1109   
;;;1110     if(huart->gState == HAL_UART_STATE_BUSY_TX)
000006  6ec2              LDR      r2,[r0,#0x6c]
000008  2101              MOVS     r1,#1                 ;1108
00000a  6681              STR      r1,[r0,#0x68]
00000c  2a21              CMP      r2,#0x21
00000e  d002              BEQ      |L13.22|
000010  e006              B        |L13.32|
                  |L13.18|
000012  2002              MOVS     r0,#2                 ;1108
;;;1111     {
;;;1112       /* Enable the UART DMA Tx request */
;;;1113       SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1114     }
;;;1115     if(huart->RxState == HAL_UART_STATE_BUSY_RX)
;;;1116     {
;;;1117       /* Clear the Overrun flag before resuming the Rx transfer*/
;;;1118       __HAL_UART_CLEAR_IT(huart, UART_CLEAR_OREF);
;;;1119   
;;;1120       /* Reenable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1121       SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1122       SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1123   
;;;1124       /* Enable the UART DMA Rx request */
;;;1125       SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1126     }
;;;1127   
;;;1128     /* If the UART peripheral is still not enabled, enable it */
;;;1129     if ((huart->Instance->CR1 & USART_CR1_UE) == 0U)
;;;1130     {
;;;1131       /* Enable UART peripheral */
;;;1132       __HAL_UART_ENABLE(huart);
;;;1133     }
;;;1134   
;;;1135     return HAL_OK;
;;;1136   }
000014  4770              BX       lr
                  |L13.22|
000016  6801              LDR      r1,[r0,#0]            ;1113
000018  688a              LDR      r2,[r1,#8]            ;1113
00001a  f0420280          ORR      r2,r2,#0x80           ;1113
00001e  608a              STR      r2,[r1,#8]            ;1113
                  |L13.32|
000020  6f01              LDR      r1,[r0,#0x70]         ;1115
000022  2922              CMP      r1,#0x22              ;1115
000024  d111              BNE      |L13.74|
000026  6802              LDR      r2,[r0,#0]            ;1118
000028  2108              MOVS     r1,#8                 ;1118
00002a  6211              STR      r1,[r2,#0x20]         ;1118
00002c  6801              LDR      r1,[r0,#0]            ;1121
00002e  680a              LDR      r2,[r1,#0]            ;1121
000030  f4427280          ORR      r2,r2,#0x100          ;1121
000034  600a              STR      r2,[r1,#0]            ;1121
000036  6801              LDR      r1,[r0,#0]            ;1122
000038  688a              LDR      r2,[r1,#8]            ;1122
00003a  f0420201          ORR      r2,r2,#1              ;1122
00003e  608a              STR      r2,[r1,#8]            ;1122
000040  6801              LDR      r1,[r0,#0]            ;1125
000042  688a              LDR      r2,[r1,#8]            ;1125
000044  f0420240          ORR      r2,r2,#0x40           ;1125
000048  608a              STR      r2,[r1,#8]            ;1125
                  |L13.74|
00004a  6800              LDR      r0,[r0,#0]            ;1129
00004c  6801              LDR      r1,[r0,#0]            ;1129
00004e  07c9              LSLS     r1,r1,#31             ;1129
000050  d103              BNE      |L13.90|
000052  6801              LDR      r1,[r0,#0]            ;1132
000054  f0410101          ORR      r1,r1,#1              ;1132
000058  6001              STR      r1,[r0,#0]            ;1132
                  |L13.90|
00005a  2000              MOVS     r0,#0                 ;1135
00005c  4770              BX       lr
;;;1137   
                          ENDP


                          AREA ||i.HAL_UART_DMAStop||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAStop PROC
;;;1142     */
;;;1143   HAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1144   {
000002  4604              MOV      r4,r0
;;;1145     /* The Lock is not implemented on this API to allow the user application
;;;1146        to call the HAL UART API under callbacks HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback() /
;;;1147        HAL_UART_TxHalfCpltCallback / HAL_UART_RxHalfCpltCallback:
;;;1148        indeed, when HAL_DMA_Abort() API is called, the DMA TX/RX Transfer or Half Transfer complete
;;;1149        interrupt is generated if the DMA transfer interruption occurs at the middle or at the end of
;;;1150        the stream and the corresponding call back is executed. */
;;;1151   
;;;1152     /* Stop UART DMA Tx request if ongoing */
;;;1153     if ((huart->gState == HAL_UART_STATE_BUSY_TX) &&
000004  6ec0              LDR      r0,[r0,#0x6c]
000006  2821              CMP      r0,#0x21
000008  d10e              BNE      |L14.40|
;;;1154         (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)))
00000a  6820              LDR      r0,[r4,#0]
00000c  6881              LDR      r1,[r0,#8]
00000e  0609              LSLS     r1,r1,#24
000010  d50a              BPL      |L14.40|
;;;1155     {
;;;1156       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000012  6881              LDR      r1,[r0,#8]
000014  f0210180          BIC      r1,r1,#0x80
000018  6081              STR      r1,[r0,#8]
;;;1157   
;;;1158       /* Abort the UART DMA Tx channel */
;;;1159       if(huart->hdmatx != NULL)
00001a  6e20              LDR      r0,[r4,#0x60]
00001c  b108              CBZ      r0,|L14.34|
;;;1160       {
;;;1161         HAL_DMA_Abort(huart->hdmatx);
00001e  f7fffffe          BL       HAL_DMA_Abort
                  |L14.34|
;;;1162       }
;;;1163   
;;;1164       UART_EndTxTransfer(huart);
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       UART_EndTxTransfer
                  |L14.40|
;;;1165     }
;;;1166   
;;;1167     /* Stop UART DMA Rx request if ongoing */
;;;1168     if ((huart->RxState == HAL_UART_STATE_BUSY_RX) &&
000028  6f20              LDR      r0,[r4,#0x70]
00002a  2822              CMP      r0,#0x22
00002c  d10e              BNE      |L14.76|
;;;1169         (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)))
00002e  6820              LDR      r0,[r4,#0]
000030  6881              LDR      r1,[r0,#8]
000032  0649              LSLS     r1,r1,#25
000034  d50a              BPL      |L14.76|
;;;1170     {
;;;1171       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000036  6881              LDR      r1,[r0,#8]
000038  f0210140          BIC      r1,r1,#0x40
00003c  6081              STR      r1,[r0,#8]
;;;1172   
;;;1173       /* Abort the UART DMA Rx channel */
;;;1174       if(huart->hdmarx != NULL)
00003e  6e60              LDR      r0,[r4,#0x64]
000040  b108              CBZ      r0,|L14.70|
;;;1175       {
;;;1176         HAL_DMA_Abort(huart->hdmarx);
000042  f7fffffe          BL       HAL_DMA_Abort
                  |L14.70|
;;;1177       }
;;;1178   
;;;1179       UART_EndRxTransfer(huart);
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       UART_EndRxTransfer
                  |L14.76|
;;;1180     }
;;;1181   
;;;1182     return HAL_OK;
00004c  2000              MOVS     r0,#0
;;;1183   }
00004e  bd10              POP      {r4,pc}
;;;1184   
                          ENDP


                          AREA ||i.HAL_UART_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_DeInit PROC
;;;584      */
;;;585    HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;586    {
000002  0004              MOVS     r4,r0
000004  d016              BEQ      |L15.52|
;;;587      /* Check the UART handle allocation */
;;;588      if(huart == NULL)
;;;589      {
;;;590        return HAL_ERROR;
;;;591      }
;;;592    
;;;593      /* Check the parameters */
;;;594      assert_param(IS_UART_INSTANCE(huart->Instance));
;;;595    
;;;596      huart->gState = HAL_UART_STATE_BUSY;
000006  2024              MOVS     r0,#0x24
000008  66e0              STR      r0,[r4,#0x6c]
;;;597    
;;;598      /* Disable the Peripheral */
;;;599      __HAL_UART_DISABLE(huart);
;;;600    
;;;601      huart->Instance->CR1 = 0x0U;
00000a  2500              MOVS     r5,#0
00000c  6820              LDR      r0,[r4,#0]            ;599
00000e  6801              LDR      r1,[r0,#0]            ;599
000010  f0210101          BIC      r1,r1,#1              ;599
000014  6001              STR      r1,[r0,#0]            ;599
000016  6820              LDR      r0,[r4,#0]
000018  6005              STR      r5,[r0,#0]
;;;602      huart->Instance->CR2 = 0x0U;
00001a  6820              LDR      r0,[r4,#0]
00001c  6045              STR      r5,[r0,#4]
;;;603      huart->Instance->CR3 = 0x0U;
00001e  6820              LDR      r0,[r4,#0]
000020  6085              STR      r5,[r0,#8]
;;;604    
;;;605      /* DeInit the low level hardware */
;;;606      HAL_UART_MspDeInit(huart);
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       HAL_UART_MspDeInit
;;;607    
;;;608      huart->ErrorCode = HAL_UART_ERROR_NONE;
000028  6765              STR      r5,[r4,#0x74]
;;;609      huart->gState    = HAL_UART_STATE_RESET;
00002a  66e5              STR      r5,[r4,#0x6c]
;;;610      huart->RxState   = HAL_UART_STATE_RESET;
00002c  6725              STR      r5,[r4,#0x70]
;;;611    
;;;612      /* Process Unlock */
;;;613      __HAL_UNLOCK(huart);
;;;614    
;;;615      return HAL_OK;
00002e  2000              MOVS     r0,#0
000030  66a5              STR      r5,[r4,#0x68]
;;;616    }
000032  bd70              POP      {r4-r6,pc}
                  |L15.52|
000034  2001              MOVS     r0,#1                 ;590
000036  bd70              POP      {r4-r6,pc}
;;;617    
                          ENDP


                          AREA ||i.HAL_UART_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_ErrorCallback PROC
;;;1547     */
;;;1548    __weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1549   {
;;;1550     /* Prevent unused argument(s) compilation warning */
;;;1551     UNUSED(huart);
;;;1552   
;;;1553     /* NOTE : This function should not be modified, when the callback is needed,
;;;1554               the HAL_UART_ErrorCallback can be implemented in the user file
;;;1555      */
;;;1556   }
;;;1557   
                          ENDP


                          AREA ||i.HAL_UART_GetError||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetError PROC
;;;1814   */
;;;1815   uint32_t HAL_UART_GetError(UART_HandleTypeDef *huart)
000000  6f40              LDR      r0,[r0,#0x74]
;;;1816   {
;;;1817     return huart->ErrorCode;
;;;1818   }
000002  4770              BX       lr
;;;1819   
                          ENDP


                          AREA ||i.HAL_UART_GetState||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetState PROC
;;;1799     */
;;;1800   HAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;1801   {
;;;1802     uint32_t temp1= 0x00U, temp2 = 0x00U;
;;;1803     temp1 = huart->gState;
000002  6ec0              LDR      r0,[r0,#0x6c]
;;;1804     temp2 = huart->RxState;
000004  6f09              LDR      r1,[r1,#0x70]
;;;1805   
;;;1806     return (HAL_UART_StateTypeDef)(temp1 | temp2);
000006  4308              ORRS     r0,r0,r1
;;;1807   }
000008  4770              BX       lr
;;;1808   
                          ENDP


                          AREA ||i.HAL_UART_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_UART_IRQHandler PROC
;;;1189     */
;;;1190   void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1191   {
;;;1192     uint32_t isrflags   = READ_REG(huart->Instance->ISR);
000002  6801              LDR      r1,[r0,#0]
000004  4604              MOV      r4,r0                 ;1191
000006  69c8              LDR      r0,[r1,#0x1c]
;;;1193     uint32_t cr1its     = READ_REG(huart->Instance->CR1);
000008  680a              LDR      r2,[r1,#0]
;;;1194     uint32_t cr3its     = READ_REG(huart->Instance->CR3);
00000a  688b              LDR      r3,[r1,#8]
;;;1195     uint32_t errorflags;
;;;1196   
;;;1197     /* If no error occurs */
;;;1198     errorflags = (isrflags & (uint32_t)(USART_ISR_PE | USART_ISR_FE | USART_ISR_ORE | USART_ISR_NE));
00000c  f0100f0f          TST      r0,#0xf
000010  d05c              BEQ      |L19.204|
;;;1199     if (errorflags == RESET)
;;;1200     {
;;;1201       /* UART in mode Receiver ---------------------------------------------------*/
;;;1202       if(((isrflags & USART_ISR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
;;;1203       {
;;;1204         UART_Receive_IT(huart);
;;;1205         return;
;;;1206       }
;;;1207     }
;;;1208   
;;;1209     /* If some errors occur */
;;;1210     if(   (errorflags != RESET)
;;;1211        && (   ((cr3its & USART_CR3_EIE) != RESET)
000012  f0030501          AND      r5,r3,#1
000016  f4027690          AND      r6,r2,#0x120
00001a  432e              ORRS     r6,r6,r5
00001c  d069              BEQ      |L19.242|
;;;1212            || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)) )
;;;1213     {
;;;1214   
;;;1215       /* UART parity error interrupt occurred -------------------------------------*/
;;;1216       if(((isrflags & USART_ISR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
00001e  07c6              LSLS     r6,r0,#31
000020  d007              BEQ      |L19.50|
000022  05d6              LSLS     r6,r2,#23
000024  d505              BPL      |L19.50|
;;;1217       {
;;;1218         __HAL_UART_CLEAR_IT(huart, UART_CLEAR_PEF);
000026  2601              MOVS     r6,#1
000028  620e              STR      r6,[r1,#0x20]
;;;1219   
;;;1220         huart->ErrorCode |= HAL_UART_ERROR_PE;
00002a  6f61              LDR      r1,[r4,#0x74]
00002c  f0410101          ORR      r1,r1,#1
000030  6761              STR      r1,[r4,#0x74]
                  |L19.50|
;;;1221       }
;;;1222   
;;;1223       /* UART frame error interrupt occurred --------------------------------------*/
;;;1224       if(((isrflags & USART_ISR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
000032  0781              LSLS     r1,r0,#30
000034  d508              BPL      |L19.72|
000036  07d9              LSLS     r1,r3,#31
000038  d006              BEQ      |L19.72|
;;;1225       {
;;;1226         __HAL_UART_CLEAR_IT(huart, UART_CLEAR_FEF);
00003a  6826              LDR      r6,[r4,#0]
00003c  2102              MOVS     r1,#2
00003e  6231              STR      r1,[r6,#0x20]
;;;1227   
;;;1228         huart->ErrorCode |= HAL_UART_ERROR_FE;
000040  6f61              LDR      r1,[r4,#0x74]
000042  f0410104          ORR      r1,r1,#4
000046  6761              STR      r1,[r4,#0x74]
                  |L19.72|
;;;1229       }
;;;1230   
;;;1231       /* UART noise error interrupt occurred --------------------------------------*/
;;;1232       if(((isrflags & USART_ISR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
000048  0741              LSLS     r1,r0,#29
00004a  d508              BPL      |L19.94|
00004c  07d9              LSLS     r1,r3,#31
00004e  d006              BEQ      |L19.94|
;;;1233       {
;;;1234         __HAL_UART_CLEAR_IT(huart, UART_CLEAR_NEF);
000050  6823              LDR      r3,[r4,#0]
000052  2104              MOVS     r1,#4
000054  6219              STR      r1,[r3,#0x20]
;;;1235   
;;;1236         huart->ErrorCode |= HAL_UART_ERROR_NE;
000056  6f61              LDR      r1,[r4,#0x74]
000058  f0410102          ORR      r1,r1,#2
00005c  6761              STR      r1,[r4,#0x74]
                  |L19.94|
;;;1237       }
;;;1238       
;;;1239       /* UART Over-Run interrupt occurred -----------------------------------------*/
;;;1240       if(((isrflags & USART_ISR_ORE) != RESET) &&
00005e  0701              LSLS     r1,r0,#28
000060  d50a              BPL      |L19.120|
;;;1241          (((cr1its & USART_CR1_RXNEIE) != RESET) || ((cr3its & USART_CR3_EIE) != RESET)))
000062  f0020120          AND      r1,r2,#0x20
000066  4329              ORRS     r1,r1,r5
000068  d006              BEQ      |L19.120|
;;;1242       {
;;;1243         __HAL_UART_CLEAR_IT(huart, UART_CLEAR_OREF);
00006a  6823              LDR      r3,[r4,#0]
00006c  2108              MOVS     r1,#8
00006e  6219              STR      r1,[r3,#0x20]
;;;1244   
;;;1245         huart->ErrorCode |= HAL_UART_ERROR_ORE;
000070  6f61              LDR      r1,[r4,#0x74]
000072  f0410108          ORR      r1,r1,#8
000076  6761              STR      r1,[r4,#0x74]
                  |L19.120|
;;;1246       }
;;;1247   
;;;1248       /* Call UART Error Call back function if need be --------------------------*/
;;;1249       if(huart->ErrorCode != HAL_UART_ERROR_NONE)
000078  6f61              LDR      r1,[r4,#0x74]
00007a  2900              CMP      r1,#0
00007c  d032              BEQ      |L19.228|
;;;1250       {
;;;1251         /* UART in mode Receiver ---------------------------------------------------*/
;;;1252         if(((isrflags & USART_ISR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
00007e  0680              LSLS     r0,r0,#26
000080  d504              BPL      |L19.140|
000082  0690              LSLS     r0,r2,#26
000084  d502              BPL      |L19.140|
;;;1253         {
;;;1254           UART_Receive_IT(huart);
000086  4620              MOV      r0,r4
000088  f7fffffe          BL       UART_Receive_IT
                  |L19.140|
;;;1255         }
;;;1256   
;;;1257         /* If Overrun error occurs, or if any error occurs in DMA mode reception,
;;;1258            consider error as blocking */
;;;1259         if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) ||
00008c  6f60              LDR      r0,[r4,#0x74]
00008e  0700              LSLS     r0,r0,#28
000090  d403              BMI      |L19.154|
;;;1260             (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)))
000092  6820              LDR      r0,[r4,#0]
000094  6880              LDR      r0,[r0,#8]
000096  0640              LSLS     r0,r0,#25
000098  d525              BPL      |L19.230|
                  |L19.154|
;;;1261         {
;;;1262           /* Blocking error : transfer is aborted
;;;1263              Set the UART state ready to be able to start again the process,
;;;1264              Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
;;;1265           UART_EndRxTransfer(huart);
00009a  4620              MOV      r0,r4
00009c  f7fffffe          BL       UART_EndRxTransfer
;;;1266   
;;;1267           /* Disable the UART DMA Rx request if enabled */
;;;1268           if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
0000a0  6820              LDR      r0,[r4,#0]
0000a2  6881              LDR      r1,[r0,#8]
0000a4  0649              LSLS     r1,r1,#25
0000a6  d51a              BPL      |L19.222|
;;;1269           {
;;;1270             CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
0000a8  6881              LDR      r1,[r0,#8]
0000aa  f0210140          BIC      r1,r1,#0x40
0000ae  6081              STR      r1,[r0,#8]
;;;1271   
;;;1272             /* Abort the UART DMA Rx channel */
;;;1273             if(huart->hdmarx != NULL)
0000b0  6e60              LDR      r0,[r4,#0x64]
0000b2  b1a0              CBZ      r0,|L19.222|
;;;1274             {
;;;1275               /* Set the UART DMA Abort callback :
;;;1276               will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
;;;1277               huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
0000b4  492e              LDR      r1,|L19.368|
;;;1278   
;;;1279               /* Abort DMA RX */
;;;1280               if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
0000b6  6541              STR      r1,[r0,#0x54]
0000b8  6e60              LDR      r0,[r4,#0x64]
0000ba  f7fffffe          BL       HAL_DMA_Abort_IT
0000be  2800              CMP      r0,#0
0000c0  d010              BEQ      |L19.228|
;;;1281               {
;;;1282                 /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */
;;;1283                 huart->hdmarx->XferAbortCallback(huart->hdmarx);
0000c2  6e60              LDR      r0,[r4,#0x64]
0000c4  6d41              LDR      r1,[r0,#0x54]
0000c6  e8bd4070          POP      {r4-r6,lr}
0000ca  4708              BX       r1
                  |L19.204|
0000cc  0683              LSLS     r3,r0,#26             ;1202
0000ce  d510              BPL      |L19.242|
0000d0  0693              LSLS     r3,r2,#26             ;1202
0000d2  d50e              BPL      |L19.242|
0000d4  4620              MOV      r0,r4                 ;1204
0000d6  e8bd4070          POP      {r4-r6,lr}            ;1204
0000da  f7ffbffe          B.W      UART_Receive_IT
                  |L19.222|
;;;1284               }
;;;1285             }
;;;1286             else
;;;1287             {
;;;1288               /* Call user error callback */
;;;1289               HAL_UART_ErrorCallback(huart);
;;;1290             }
;;;1291           }
;;;1292           else
;;;1293           {
;;;1294             /* Call user error callback */
;;;1295             HAL_UART_ErrorCallback(huart);
0000de  4620              MOV      r0,r4
0000e0  f7fffffe          BL       HAL_UART_ErrorCallback
                  |L19.228|
;;;1296           }
;;;1297         }
;;;1298         else
;;;1299         {
;;;1300           /* Non Blocking error : transfer could go on.
;;;1301              Error is notified to user through user error callback */
;;;1302           HAL_UART_ErrorCallback(huart);
;;;1303           huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1304         }
;;;1305       }
;;;1306       return;
;;;1307   
;;;1308     } /* End if some error occurs */
;;;1309   
;;;1310     /* UART in mode Transmitter ------------------------------------------------*/
;;;1311     if(((isrflags & USART_ISR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
;;;1312     {
;;;1313       UART_Transmit_IT(huart);
;;;1314       return;
;;;1315     }
;;;1316   
;;;1317     /* UART in mode Transmitter (transmission end) -----------------------------*/
;;;1318     if(((isrflags & USART_ISR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
;;;1319     {
;;;1320       UART_EndTransmit_IT(huart);
;;;1321       return;
;;;1322     }
;;;1323   
;;;1324   }
0000e4  bd70              POP      {r4-r6,pc}
                  |L19.230|
0000e6  4620              MOV      r0,r4                 ;1302
0000e8  f7fffffe          BL       HAL_UART_ErrorCallback
0000ec  2000              MOVS     r0,#0                 ;1303
0000ee  6760              STR      r0,[r4,#0x74]         ;1303
                  |L19.240|
0000f0  bd70              POP      {r4-r6,pc}
                  |L19.242|
0000f2  0603              LSLS     r3,r0,#24             ;1311
0000f4  d52d              BPL      |L19.338|
0000f6  0613              LSLS     r3,r2,#24             ;1311
0000f8  d52b              BPL      |L19.338|
0000fa  6ee0              LDR      r0,[r4,#0x6c]         ;1311
0000fc  2821              CMP      r0,#0x21              ;1311
0000fe  d1f7              BNE      |L19.240|
000100  f8b40052          LDRH     r0,[r4,#0x52]         ;1311
000104  b120              CBZ      r0,|L19.272|
000106  68a0              LDR      r0,[r4,#8]            ;1311
000108  f5b05f80          CMP      r0,#0x1000            ;1311
00010c  d00a              BEQ      |L19.292|
00010e  e00b              B        |L19.296|
                  |L19.272|
000110  6808              LDR      r0,[r1,#0]            ;1311
000112  f0200080          BIC      r0,r0,#0x80           ;1311
000116  6008              STR      r0,[r1,#0]            ;1311
000118  6820              LDR      r0,[r4,#0]            ;1311
00011a  6801              LDR      r1,[r0,#0]            ;1311
00011c  f0410140          ORR      r1,r1,#0x40           ;1311
000120  6001              STR      r1,[r0,#0]            ;1311
000122  bd70              POP      {r4-r6,pc}
                  |L19.292|
000124  6920              LDR      r0,[r4,#0x10]
000126  b158              CBZ      r0,|L19.320|
                  |L19.296|
000128  6ce0              LDR      r0,[r4,#0x4c]
00012a  1c41              ADDS     r1,r0,#1
00012c  64e1              STR      r1,[r4,#0x4c]
00012e  6821              LDR      r1,[r4,#0]
000130  7800              LDRB     r0,[r0,#0]
000132  6288              STR      r0,[r1,#0x28]
                  |L19.308|
000134  f8b40052          LDRH     r0,[r4,#0x52]
000138  1e40              SUBS     r0,r0,#1
00013a  f8a40052          STRH     r0,[r4,#0x52]
                  |L19.318|
00013e  bd70              POP      {r4-r6,pc}
                  |L19.320|
000140  6ce0              LDR      r0,[r4,#0x4c]
000142  8800              LDRH     r0,[r0,#0]
000144  f3c00008          UBFX     r0,r0,#0,#9
000148  6288              STR      r0,[r1,#0x28]
00014a  6ce0              LDR      r0,[r4,#0x4c]
00014c  1c80              ADDS     r0,r0,#2
00014e  64e0              STR      r0,[r4,#0x4c]
000150  e7f0              B        |L19.308|
                  |L19.338|
000152  0640              LSLS     r0,r0,#25             ;1318
000154  d5f3              BPL      |L19.318|
000156  0650              LSLS     r0,r2,#25             ;1318
000158  d5f1              BPL      |L19.318|
00015a  680b              LDR      r3,[r1,#0]            ;1318
00015c  2220              MOVS     r2,#0x20              ;1318
00015e  4620              MOV      r0,r4                 ;1320
000160  f0230340          BIC      r3,r3,#0x40           ;1320
000164  600b              STR      r3,[r1,#0]            ;1320
000166  66e2              STR      r2,[r4,#0x6c]         ;1320
000168  f7fffffe          BL       HAL_UART_TxCpltCallback
00016c  bd70              POP      {r4-r6,pc}
;;;1325   
                          ENDP

00016e  0000              DCW      0x0000
                  |L19.368|
                          DCD      UART_DMAAbortOnError

                          AREA ||i.HAL_UART_Init||, CODE, READONLY, ALIGN=1

                  HAL_UART_Init PROC
;;;240      */
;;;241    HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;242    {
000002  0004              MOVS     r4,r0
000004  d002              BEQ      |L20.12|
;;;243      /* Check the UART handle allocation */
;;;244      if(huart == NULL)
;;;245      {
;;;246        return HAL_ERROR;
;;;247      }
;;;248    
;;;249      if(huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
;;;250      {
;;;251        /* Check the parameters */
;;;252        assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
;;;253      }
;;;254      else
;;;255      {
;;;256        /* Check the parameters */
;;;257        assert_param(IS_UART_INSTANCE(huart->Instance));
;;;258      }
;;;259    
;;;260      if(huart->gState == HAL_UART_STATE_RESET)
000006  6ee0              LDR      r0,[r4,#0x6c]
000008  b110              CBZ      r0,|L20.16|
00000a  e006              B        |L20.26|
                  |L20.12|
00000c  2001              MOVS     r0,#1                 ;246
                  |L20.14|
;;;261      {
;;;262        /* Allocate lock resource and initialize it */
;;;263        huart->Lock = HAL_UNLOCKED;
;;;264    
;;;265        /* Init the low level hardware : GPIO, CLOCK */
;;;266        HAL_UART_MspInit(huart);
;;;267      }
;;;268    
;;;269      huart->gState = HAL_UART_STATE_BUSY;
;;;270    
;;;271      /* Disable the Peripheral */
;;;272      __HAL_UART_DISABLE(huart);
;;;273    
;;;274      /* Set the UART Communication parameters */
;;;275      if (UART_SetConfig(huart) == HAL_ERROR)
;;;276      {
;;;277        return HAL_ERROR;
;;;278      }
;;;279    
;;;280      if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;281      {
;;;282        UART_AdvFeatureConfig(huart);
;;;283      }
;;;284    
;;;285      /* In asynchronous mode, the following bits must be kept cleared:
;;;286      - LINEN and CLKEN bits in the USART_CR2 register,
;;;287      - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
;;;288      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;289      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;290    
;;;291      /* Enable the Peripheral */
;;;292      __HAL_UART_ENABLE(huart);
;;;293    
;;;294      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;295      return (UART_CheckIdleState(huart));
;;;296    }
00000e  bd10              POP      {r4,pc}
                  |L20.16|
000010  2000              MOVS     r0,#0                 ;263
000012  66a0              STR      r0,[r4,#0x68]         ;266
000014  4620              MOV      r0,r4                 ;266
000016  f7fffffe          BL       HAL_UART_MspInit
                  |L20.26|
00001a  2024              MOVS     r0,#0x24              ;269
00001c  66e0              STR      r0,[r4,#0x6c]         ;269
00001e  6820              LDR      r0,[r4,#0]            ;272
000020  6801              LDR      r1,[r0,#0]            ;272
000022  f0210101          BIC      r1,r1,#1              ;272
000026  6001              STR      r1,[r0,#0]            ;272
000028  4620              MOV      r0,r4                 ;275
00002a  f7fffffe          BL       UART_SetConfig
00002e  2801              CMP      r0,#1                 ;275
000030  d0ed              BEQ      |L20.14|
000032  6a60              LDR      r0,[r4,#0x24]         ;280
000034  b110              CBZ      r0,|L20.60|
000036  4620              MOV      r0,r4                 ;282
000038  f7fffffe          BL       UART_AdvFeatureConfig
                  |L20.60|
00003c  6820              LDR      r0,[r4,#0]            ;288
00003e  6841              LDR      r1,[r0,#4]            ;288
000040  f4214190          BIC      r1,r1,#0x4800         ;288
000044  6041              STR      r1,[r0,#4]            ;288
000046  6820              LDR      r0,[r4,#0]            ;289
000048  6881              LDR      r1,[r0,#8]            ;289
00004a  f021012a          BIC      r1,r1,#0x2a           ;289
00004e  6081              STR      r1,[r0,#8]            ;289
000050  6820              LDR      r0,[r4,#0]            ;292
000052  6801              LDR      r1,[r0,#0]            ;292
000054  f0410101          ORR      r1,r1,#1              ;292
000058  6001              STR      r1,[r0,#0]            ;292
00005a  4620              MOV      r0,r4                 ;295
00005c  e8bd4010          POP      {r4,lr}               ;295
000060  f7ffbffe          B.W      UART_CheckIdleState
;;;297    
                          ENDP


                          AREA ||i.HAL_UART_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspDeInit PROC
;;;637      */
;;;638    __weak void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;639    {
;;;640      /* Prevent unused argument(s) compilation warning */
;;;641      UNUSED(huart);
;;;642    
;;;643      /* NOTE : This function should not be modified, when the callback is needed,
;;;644                the HAL_UART_MspDeInit can be implemented in the user file
;;;645       */
;;;646    }
;;;647    
                          ENDP


                          AREA ||i.HAL_UART_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspInit PROC
;;;622      */
;;;623    __weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;624    {
;;;625      /* Prevent unused argument(s) compilation warning */
;;;626      UNUSED(huart);
;;;627    
;;;628      /* NOTE : This function should not be modified, when the callback is needed,
;;;629                the HAL_UART_MspInit can be implemented in the user file
;;;630       */
;;;631    }
;;;632    
                          ENDP


                          AREA ||i.HAL_UART_Receive||, CODE, READONLY, ALIGN=2

                  HAL_UART_Receive PROC
;;;784      */
;;;785    HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;786    {
000004  4604              MOV      r4,r0
;;;787      uint16_t* tmp;
;;;788      uint16_t uhMask;
;;;789      uint32_t tickstart = 0U;
;;;790    
;;;791      /* Check that a Rx process is not already ongoing */
;;;792      if(huart->RxState == HAL_UART_STATE_READY)
000006  6f00              LDR      r0,[r0,#0x70]
000008  469a              MOV      r10,r3                ;786
00000a  4616              MOV      r6,r2                 ;786
00000c  460d              MOV      r5,r1                 ;786
00000e  2820              CMP      r0,#0x20
000010  d162              BNE      |L23.216|
;;;793      {
;;;794        if((pData == NULL ) || (Size == 0U))
000012  b1cd              CBZ      r5,|L23.72|
000014  b1c6              CBZ      r6,|L23.72|
;;;795        {
;;;796          return  HAL_ERROR;
;;;797        }
;;;798    
;;;799        /* Process Locked */
;;;800        __HAL_LOCK(huart);
000016  6ea0              LDR      r0,[r4,#0x68]
000018  2801              CMP      r0,#1
00001a  d05d              BEQ      |L23.216|
;;;801    
;;;802        huart->ErrorCode = HAL_UART_ERROR_NONE;
00001c  2700              MOVS     r7,#0
00001e  6767              STR      r7,[r4,#0x74]
000020  2101              MOVS     r1,#1                 ;800
000022  66a1              STR      r1,[r4,#0x68]
;;;803        huart->RxState = HAL_UART_STATE_BUSY_RX;
000024  2022              MOVS     r0,#0x22
000026  6720              STR      r0,[r4,#0x70]
;;;804    
;;;805        /* Init tickstart for timeout managment*/
;;;806        tickstart = HAL_GetTick();
000028  f7fffffe          BL       HAL_GetTick
00002c  4681              MOV      r9,r0
;;;807    
;;;808        huart->RxXferSize = Size;
00002e  68a0              LDR      r0,[r4,#8]
000030  f8a46058          STRH     r6,[r4,#0x58]
;;;809        huart->RxXferCount = Size;
;;;810    
;;;811        /* Computation of UART mask to apply to RDR register */
;;;812        UART_MASK_COMPUTATION(huart);
000034  f44f5880          MOV      r8,#0x1000
000038  f8a4605a          STRH     r6,[r4,#0x5a]         ;809
00003c  21ff              MOVS     r1,#0xff
00003e  4540              CMP      r0,r8
000040  d108              BNE      |L23.84|
000042  6920              LDR      r0,[r4,#0x10]
000044  b118              CBZ      r0,|L23.78|
000046  e00e              B        |L23.102|
                  |L23.72|
000048  2001              MOVS     r0,#1                 ;796
                  |L23.74|
;;;813        uhMask = huart->Mask;
;;;814    
;;;815        /* as long as data have to be received */
;;;816        while(huart->RxXferCount > 0U)
;;;817        {
;;;818          huart->RxXferCount--;
;;;819          if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;820          {
;;;821            return HAL_TIMEOUT;
;;;822          }
;;;823          if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;824          {
;;;825            tmp = (uint16_t*) pData ;
;;;826            *tmp = (uint16_t)(huart->Instance->RDR & uhMask);
;;;827            pData +=2U;
;;;828          }
;;;829          else
;;;830          {
;;;831            *pData++ = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask);
;;;832          }
;;;833        }
;;;834    
;;;835        /* At end of Rx process, restore huart->RxState to Ready */
;;;836        huart->RxState = HAL_UART_STATE_READY;
;;;837    
;;;838        /* Process Unlocked */
;;;839        __HAL_UNLOCK(huart);
;;;840    
;;;841        return HAL_OK;
;;;842      }
;;;843      else
;;;844      {
;;;845        return HAL_BUSY;
;;;846      }
;;;847    }
00004a  e8bd8ff8          POP      {r3-r11,pc}
                  |L23.78|
00004e  f24010ff          MOV      r0,#0x1ff             ;812
000052  e00e              B        |L23.114|
                  |L23.84|
000054  f04f027f          MOV      r2,#0x7f              ;812
000058  b118              CBZ      r0,|L23.98|
00005a  f1b05f80          CMP      r0,#0x10000000        ;812
00005e  d005              BEQ      |L23.108|
000060  e009              B        |L23.118|
                  |L23.98|
000062  6920              LDR      r0,[r4,#0x10]         ;812
000064  b950              CBNZ     r0,|L23.124|
                  |L23.102|
000066  f8a4105c          STRH     r1,[r4,#0x5c]         ;812
00006a  e004              B        |L23.118|
                  |L23.108|
00006c  6920              LDR      r0,[r4,#0x10]         ;812
00006e  b128              CBZ      r0,|L23.124|
000070  203f              MOVS     r0,#0x3f              ;812
                  |L23.114|
000072  f8a4005c          STRH     r0,[r4,#0x5c]         ;812
                  |L23.118|
000076  f8b4605c          LDRH     r6,[r4,#0x5c]         ;813
00007a  e01d              B        |L23.184|
                  |L23.124|
00007c  f8a4205c          STRH     r2,[r4,#0x5c]         ;812
000080  e7f9              B        |L23.118|
000082  bf00              NOP                            ;818
                  |L23.132|
000084  f8b4005a          LDRH     r0,[r4,#0x5a]         ;818
000088  1e40              SUBS     r0,r0,#1              ;818
00008a  f8a4005a          STRH     r0,[r4,#0x5a]         ;818
00008e  2200              MOVS     r2,#0                 ;819
000090  464b              MOV      r3,r9                 ;819
000092  2120              MOVS     r1,#0x20              ;819
000094  4620              MOV      r0,r4                 ;819
000096  f8cda000          STR      r10,[sp,#0]           ;819
00009a  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
00009e  b108              CBZ      r0,|L23.164|
0000a0  2003              MOVS     r0,#3                 ;821
0000a2  e7d2              B        |L23.74|
                  |L23.164|
0000a4  68a0              LDR      r0,[r4,#8]            ;823
0000a6  4540              CMP      r0,r8                 ;823
0000a8  d101              BNE      |L23.174|
0000aa  6920              LDR      r0,[r4,#0x10]         ;823
0000ac  b168              CBZ      r0,|L23.202|
                  |L23.174|
0000ae  6820              LDR      r0,[r4,#0]            ;831
0000b0  6a40              LDR      r0,[r0,#0x24]         ;831
0000b2  4030              ANDS     r0,r0,r6              ;831
0000b4  f8050b01          STRB     r0,[r5],#1            ;831
                  |L23.184|
0000b8  f8b4005a          LDRH     r0,[r4,#0x5a]         ;816
0000bc  2800              CMP      r0,#0                 ;816
0000be  d1e1              BNE      |L23.132|
0000c0  2020              MOVS     r0,#0x20              ;836
0000c2  6720              STR      r0,[r4,#0x70]         ;836
0000c4  2000              MOVS     r0,#0                 ;841
0000c6  66a7              STR      r7,[r4,#0x68]         ;841
0000c8  e7bf              B        |L23.74|
                  |L23.202|
0000ca  6821              LDR      r1,[r4,#0]            ;826
0000cc  4628              MOV      r0,r5                 ;825
0000ce  1cad              ADDS     r5,r5,#2              ;827
0000d0  6a49              LDR      r1,[r1,#0x24]         ;826
0000d2  4031              ANDS     r1,r1,r6              ;826
0000d4  8001              STRH     r1,[r0,#0]            ;826
0000d6  e7ef              B        |L23.184|
                  |L23.216|
0000d8  2002              MOVS     r0,#2                 ;845
0000da  e7b6              B        |L23.74|
;;;848    
                          ENDP


                          AREA ||i.HAL_UART_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Receive_DMA PROC
;;;1008     */
;;;1009   HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;1010   {
000002  4604              MOV      r4,r0
;;;1011     uint32_t *tmp;
;;;1012   
;;;1013     /* Check that a Rx process is not already ongoing */
;;;1014     if(huart->RxState == HAL_UART_STATE_READY)
000004  6f00              LDR      r0,[r0,#0x70]
000006  2820              CMP      r0,#0x20
000008  d136              BNE      |L24.120|
;;;1015     {
;;;1016       if((pData == NULL ) || (Size == 0U))
00000a  b391              CBZ      r1,|L24.114|
00000c  b38a              CBZ      r2,|L24.114|
;;;1017       {
;;;1018         return HAL_ERROR;
;;;1019       }
;;;1020   
;;;1021       /* Process Locked */
;;;1022       __HAL_LOCK(huart);
00000e  6ea0              LDR      r0,[r4,#0x68]
000010  2801              CMP      r0,#1
000012  d031              BEQ      |L24.120|
000014  2301              MOVS     r3,#1
;;;1023   
;;;1024       huart->pRxBuffPtr = pData;
;;;1025       huart->RxXferSize = Size;
000016  66a3              STR      r3,[r4,#0x68]
000018  6561              STR      r1,[r4,#0x54]
;;;1026   
;;;1027       huart->ErrorCode = HAL_UART_ERROR_NONE;
00001a  2500              MOVS     r5,#0
00001c  f8a42058          STRH     r2,[r4,#0x58]         ;1025
;;;1028       huart->RxState = HAL_UART_STATE_BUSY_RX;
000020  2022              MOVS     r0,#0x22
000022  6765              STR      r5,[r4,#0x74]         ;1027
000024  6720              STR      r0,[r4,#0x70]
;;;1029   
;;;1030       /* Set the UART DMA transfer complete callback */
;;;1031       huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
000026  6e63              LDR      r3,[r4,#0x64]
000028  4814              LDR      r0,|L24.124|
;;;1032   
;;;1033       /* Set the UART DMA Half transfer complete callback */
;;;1034       huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
00002a  6418              STR      r0,[r3,#0x40]
00002c  6e63              LDR      r3,[r4,#0x64]
00002e  4814              LDR      r0,|L24.128|
;;;1035   
;;;1036       /* Set the DMA error callback */
;;;1037       huart->hdmarx->XferErrorCallback = UART_DMAError;
000030  6458              STR      r0,[r3,#0x44]
000032  6e63              LDR      r3,[r4,#0x64]
000034  4813              LDR      r0,|L24.132|
;;;1038   
;;;1039       /* Set the DMA abort callback */
;;;1040       huart->hdmarx->XferAbortCallback = NULL;
000036  6518              STR      r0,[r3,#0x50]
;;;1041   
;;;1042       /* Enable the DMA channel */
;;;1043       tmp = (uint32_t*)&pData;
;;;1044       HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->RDR, *(uint32_t*)tmp, Size);
000038  4613              MOV      r3,r2
00003a  6e60              LDR      r0,[r4,#0x64]         ;1040
00003c  6545              STR      r5,[r0,#0x54]         ;1040
00003e  4608              MOV      r0,r1                 ;1040
000040  6e66              LDR      r6,[r4,#0x64]
000042  4602              MOV      r2,r0
000044  6821              LDR      r1,[r4,#0]
000046  4630              MOV      r0,r6
000048  3124              ADDS     r1,r1,#0x24
00004a  f7fffffe          BL       HAL_DMA_Start_IT
;;;1045   
;;;1046       /* Process Unlocked */
;;;1047       __HAL_UNLOCK(huart);
;;;1048   
;;;1049       /* Enable the UART Parity Error Interrupt */
;;;1050       SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
00004e  66a5              STR      r5,[r4,#0x68]
000050  6820              LDR      r0,[r4,#0]
000052  6801              LDR      r1,[r0,#0]
000054  f4417180          ORR      r1,r1,#0x100
000058  6001              STR      r1,[r0,#0]
;;;1051   
;;;1052       /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1053       SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
00005a  6820              LDR      r0,[r4,#0]
00005c  6881              LDR      r1,[r0,#8]
00005e  f0410101          ORR      r1,r1,#1
000062  6081              STR      r1,[r0,#8]
;;;1054   
;;;1055       /* Enable the DMA transfer for the receiver request by setting the DMAR bit
;;;1056       in the UART CR3 register */
;;;1057       SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000064  6820              LDR      r0,[r4,#0]
000066  6881              LDR      r1,[r0,#8]
000068  f0410140          ORR      r1,r1,#0x40
00006c  6081              STR      r1,[r0,#8]
;;;1058   
;;;1059       return HAL_OK;
00006e  2000              MOVS     r0,#0
                  |L24.112|
;;;1060     }
;;;1061     else
;;;1062     {
;;;1063       return HAL_BUSY;
;;;1064     }
;;;1065   }
000070  bd70              POP      {r4-r6,pc}
                  |L24.114|
000072  e7ff              B        |L24.116|
                  |L24.116|
000074  2001              MOVS     r0,#1                 ;1018
000076  e7fb              B        |L24.112|
                  |L24.120|
000078  2002              MOVS     r0,#2                 ;1063
00007a  e7f9              B        |L24.112|
;;;1066   
                          ENDP

                  |L24.124|
                          DCD      UART_DMAReceiveCplt
                  |L24.128|
                          DCD      UART_DMARxHalfCplt
                  |L24.132|
                          DCD      UART_DMAError

                          AREA ||i.HAL_UART_Receive_IT||, CODE, READONLY, ALIGN=1

                  HAL_UART_Receive_IT PROC
;;;896      */
;;;897    HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b510              PUSH     {r4,lr}
;;;898    {
;;;899      /* Check that a Rx process is not already ongoing */
;;;900      if(huart->RxState == HAL_UART_STATE_READY)
000002  6f03              LDR      r3,[r0,#0x70]
000004  2b20              CMP      r3,#0x20
000006  d13b              BNE      |L25.128|
;;;901      {
;;;902        if((pData == NULL ) || (Size == 0U))
000008  b1b9              CBZ      r1,|L25.58|
00000a  b1b2              CBZ      r2,|L25.58|
;;;903        {
;;;904          return HAL_ERROR;
;;;905        }
;;;906    
;;;907        /* Process Locked */
;;;908        __HAL_LOCK(huart);
00000c  6e83              LDR      r3,[r0,#0x68]
00000e  2b01              CMP      r3,#1
000010  d036              BEQ      |L25.128|
;;;909    
;;;910        huart->pRxBuffPtr = pData;
000012  6883              LDR      r3,[r0,#8]
000014  2401              MOVS     r4,#1                 ;908
;;;911        huart->RxXferSize = Size;
000016  6684              STR      r4,[r0,#0x68]
000018  6541              STR      r1,[r0,#0x54]
00001a  f8a02058          STRH     r2,[r0,#0x58]
;;;912        huart->RxXferCount = Size;
00001e  f8a0205a          STRH     r2,[r0,#0x5a]
;;;913    
;;;914        /* Computation of UART mask to apply to RDR register */
;;;915        UART_MASK_COMPUTATION(huart);
000022  f5b35f80          CMP      r3,#0x1000
000026  f04f01ff          MOV      r1,#0xff
00002a  d008              BEQ      |L25.62|
00002c  f04f027f          MOV      r2,#0x7f
000030  b153              CBZ      r3,|L25.72|
000032  f1b35f80          CMP      r3,#0x10000000
000036  d00c              BEQ      |L25.82|
000038  e011              B        |L25.94|
                  |L25.58|
00003a  2001              MOVS     r0,#1                 ;904
;;;916    
;;;917        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;918        huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;919    
;;;920        /* Process Unlocked */
;;;921        __HAL_UNLOCK(huart);
;;;922    
;;;923        /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;924        SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;925    
;;;926        /* Enable the UART Parity Error and Data Register not empty Interrupts */
;;;927        SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE);
;;;928    
;;;929        return HAL_OK;
;;;930      }
;;;931      else
;;;932      {
;;;933        return HAL_BUSY;
;;;934      }
;;;935    }
00003c  bd10              POP      {r4,pc}
                  |L25.62|
00003e  6902              LDR      r2,[r0,#0x10]         ;915
000040  b922              CBNZ     r2,|L25.76|
000042  f24011ff          MOV      r1,#0x1ff             ;915
000046  e001              B        |L25.76|
                  |L25.72|
000048  6903              LDR      r3,[r0,#0x10]         ;915
00004a  b933              CBNZ     r3,|L25.90|
                  |L25.76|
00004c  f8a0105c          STRH     r1,[r0,#0x5c]         ;915
000050  e005              B        |L25.94|
                  |L25.82|
000052  6901              LDR      r1,[r0,#0x10]         ;915
000054  b109              CBZ      r1,|L25.90|
000056  213f              MOVS     r1,#0x3f              ;915
000058  e7f8              B        |L25.76|
                  |L25.90|
00005a  f8a0205c          STRH     r2,[r0,#0x5c]         ;915
                  |L25.94|
00005e  2100              MOVS     r1,#0                 ;917
000060  2222              MOVS     r2,#0x22              ;918
000062  6741              STR      r1,[r0,#0x74]         ;917
000064  6702              STR      r2,[r0,#0x70]         ;918
000066  6681              STR      r1,[r0,#0x68]         ;924
000068  6801              LDR      r1,[r0,#0]            ;924
00006a  688a              LDR      r2,[r1,#8]            ;924
00006c  f0420201          ORR      r2,r2,#1              ;924
000070  608a              STR      r2,[r1,#8]            ;924
000072  6800              LDR      r0,[r0,#0]            ;927
000074  6801              LDR      r1,[r0,#0]            ;927
000076  f4417190          ORR      r1,r1,#0x120          ;927
00007a  6001              STR      r1,[r0,#0]            ;927
00007c  2000              MOVS     r0,#0                 ;929
00007e  bd10              POP      {r4,pc}
                  |L25.128|
000080  2002              MOVS     r0,#2                 ;933
000082  bd10              POP      {r4,pc}
;;;936    
                          ENDP


                          AREA ||i.HAL_UART_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxCpltCallback PROC
;;;1517     */
;;;1518   __weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1519   {
;;;1520     /* Prevent unused argument(s) compilation warning */
;;;1521     UNUSED(huart);
;;;1522   
;;;1523     /* NOTE : This function should not be modified, when the callback is needed,
;;;1524               the HAL_UART_RxCpltCallback can be implemented in the user file
;;;1525      */
;;;1526   }
;;;1527   
                          ENDP


                          AREA ||i.HAL_UART_RxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxHalfCpltCallback PROC
;;;1532     */
;;;1533   __weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1534   {
;;;1535     /* Prevent unused argument(s) compilation warning */
;;;1536     UNUSED(huart);
;;;1537   
;;;1538     /* NOTE: This function should not be modified, when the callback is needed,
;;;1539              the HAL_UART_RxHalfCpltCallback can be implemented in the user file
;;;1540      */
;;;1541   }
;;;1542   
                          ENDP


                          AREA ||i.HAL_UART_Transmit||, CODE, READONLY, ALIGN=2

                  HAL_UART_Transmit PROC
;;;715      */
;;;716    HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;717    {
000004  4604              MOV      r4,r0
;;;718      uint16_t* tmp;
;;;719      uint32_t tickstart = 0U;
;;;720    
;;;721      /* Check that a Tx process is not already ongoing */
;;;722      if(huart->gState == HAL_UART_STATE_READY)
000006  6ec0              LDR      r0,[r0,#0x6c]
000008  461f              MOV      r7,r3                 ;717
00000a  4616              MOV      r6,r2                 ;717
00000c  460d              MOV      r5,r1                 ;717
00000e  2820              CMP      r0,#0x20
000010  d14a              BNE      |L28.168|
;;;723      {
;;;724        if((pData == NULL ) || (Size == 0U))
000012  b1ad              CBZ      r5,|L28.64|
000014  b1a6              CBZ      r6,|L28.64|
;;;725        {
;;;726          return  HAL_ERROR;
;;;727        }
;;;728    
;;;729        /* Process Locked */
;;;730        __HAL_LOCK(huart);
000016  6ea0              LDR      r0,[r4,#0x68]
000018  2801              CMP      r0,#1
00001a  d045              BEQ      |L28.168|
00001c  2201              MOVS     r2,#1
;;;731    
;;;732        huart->ErrorCode = HAL_UART_ERROR_NONE;
00001e  f04f0800          MOV      r8,#0
000022  f8c48074          STR      r8,[r4,#0x74]
;;;733        huart->gState = HAL_UART_STATE_BUSY_TX;
000026  2121              MOVS     r1,#0x21
000028  66a2              STR      r2,[r4,#0x68]         ;732
00002a  66e1              STR      r1,[r4,#0x6c]
;;;734    
;;;735        /* Init tickstart for timeout managment*/
;;;736        tickstart = HAL_GetTick();
00002c  f7fffffe          BL       HAL_GetTick
;;;737    
;;;738        huart->TxXferSize = Size;
000030  f8a46050          STRH     r6,[r4,#0x50]
000034  4681              MOV      r9,r0                 ;736
;;;739        huart->TxXferCount = Size;
000036  f8a46052          STRH     r6,[r4,#0x52]
;;;740        while(huart->TxXferCount > 0U)
;;;741        {
;;;742          huart->TxXferCount--;
;;;743          if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;744          {
;;;745            return HAL_TIMEOUT;
;;;746          }
;;;747          if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
00003a  f44f5680          MOV      r6,#0x1000
00003e  e019              B        |L28.116|
                  |L28.64|
000040  2001              MOVS     r0,#1                 ;726
                  |L28.66|
;;;748          {
;;;749            tmp = (uint16_t*) pData;
;;;750            huart->Instance->TDR = (*tmp & (uint16_t)0x01FFU);
;;;751            pData += 2;
;;;752          }
;;;753          else
;;;754          {
;;;755            huart->Instance->TDR = (*pData++ & (uint8_t)0xFFU);
;;;756          }
;;;757        }
;;;758        if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
;;;759        {
;;;760          return HAL_TIMEOUT;
;;;761        }
;;;762    
;;;763        /* At end of Tx process, restore huart->gState to Ready */
;;;764        huart->gState = HAL_UART_STATE_READY;
;;;765    
;;;766        /* Process Unlocked */
;;;767        __HAL_UNLOCK(huart);
;;;768    
;;;769        return HAL_OK;
;;;770      }
;;;771      else
;;;772      {
;;;773        return HAL_BUSY;
;;;774      }
;;;775    }
000042  e8bd83f8          POP      {r3-r9,pc}
000046  bf00              NOP                            ;742
                  |L28.72|
000048  f8b40052          LDRH     r0,[r4,#0x52]         ;742
00004c  1e40              SUBS     r0,r0,#1              ;742
00004e  f8a40052          STRH     r0,[r4,#0x52]         ;742
000052  2200              MOVS     r2,#0                 ;743
000054  464b              MOV      r3,r9                 ;743
000056  2180              MOVS     r1,#0x80              ;743
000058  4620              MOV      r0,r4                 ;743
00005a  9700              STR      r7,[sp,#0]            ;743
00005c  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
000060  b9a0              CBNZ     r0,|L28.140|
000062  68a0              LDR      r0,[r4,#8]            ;747
000064  42b0              CMP      r0,r6                 ;747
000066  d101              BNE      |L28.108|
000068  6920              LDR      r0,[r4,#0x10]         ;747
00006a  b188              CBZ      r0,|L28.144|
                  |L28.108|
00006c  f8150b01          LDRB     r0,[r5],#1            ;755
000070  6821              LDR      r1,[r4,#0]            ;755
                  |L28.114|
000072  6288              STR      r0,[r1,#0x28]         ;750
                  |L28.116|
000074  f8b40052          LDRH     r0,[r4,#0x52]         ;740
000078  2800              CMP      r0,#0                 ;740
00007a  d1e5              BNE      |L28.72|
00007c  2200              MOVS     r2,#0                 ;758
00007e  464b              MOV      r3,r9                 ;758
000080  2140              MOVS     r1,#0x40              ;758
000082  4620              MOV      r0,r4                 ;758
000084  9700              STR      r7,[sp,#0]            ;758
000086  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
00008a  b138              CBZ      r0,|L28.156|
                  |L28.140|
00008c  2003              MOVS     r0,#3                 ;760
00008e  e7d8              B        |L28.66|
                  |L28.144|
000090  f8350b02          LDRH     r0,[r5],#2            ;750
000094  6821              LDR      r1,[r4,#0]            ;751
000096  f3c00008          UBFX     r0,r0,#0,#9           ;750
00009a  e7ea              B        |L28.114|
                  |L28.156|
00009c  2120              MOVS     r1,#0x20              ;764
00009e  66e1              STR      r1,[r4,#0x6c]         ;764
0000a0  2000              MOVS     r0,#0                 ;769
0000a2  f8c48068          STR      r8,[r4,#0x68]         ;769
0000a6  e7cc              B        |L28.66|
                  |L28.168|
0000a8  2002              MOVS     r0,#2                 ;773
0000aa  e7ca              B        |L28.66|
;;;776    
                          ENDP


                          AREA ||i.HAL_UART_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Transmit_DMA PROC
;;;943      */
;;;944    HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;945    {
000002  4604              MOV      r4,r0
;;;946      uint32_t *tmp;
;;;947    
;;;948      /* Check that a Tx process is not already ongoing */
;;;949      if(huart->gState == HAL_UART_STATE_READY)
000004  6ec0              LDR      r0,[r0,#0x6c]
000006  2820              CMP      r0,#0x20
000008  d12f              BNE      |L29.106|
;;;950      {
;;;951        if((pData == NULL ) || (Size == 0U))
00000a  b361              CBZ      r1,|L29.102|
00000c  b35a              CBZ      r2,|L29.102|
;;;952        {
;;;953          return HAL_ERROR;
;;;954        }
;;;955    
;;;956        /* Process Locked */
;;;957        __HAL_LOCK(huart);
00000e  6ea0              LDR      r0,[r4,#0x68]
000010  2801              CMP      r0,#1
000012  d02a              BEQ      |L29.106|
000014  2301              MOVS     r3,#1
;;;958    
;;;959        huart->pTxBuffPtr = pData;
;;;960        huart->TxXferSize = Size;
000016  66a3              STR      r3,[r4,#0x68]
000018  64e1              STR      r1,[r4,#0x4c]
;;;961        huart->TxXferCount = Size;
;;;962    
;;;963        huart->ErrorCode = HAL_UART_ERROR_NONE;
00001a  2500              MOVS     r5,#0
00001c  f8a42050          STRH     r2,[r4,#0x50]         ;960
;;;964        huart->gState = HAL_UART_STATE_BUSY_TX;
000020  2021              MOVS     r0,#0x21
000022  f8a42052          STRH     r2,[r4,#0x52]         ;961
000026  6765              STR      r5,[r4,#0x74]         ;963
000028  66e0              STR      r0,[r4,#0x6c]
;;;965    
;;;966        /* Set the UART DMA transfer complete callback */
;;;967        huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
00002a  6e23              LDR      r3,[r4,#0x60]
00002c  4810              LDR      r0,|L29.112|
;;;968    
;;;969        /* Set the UART DMA Half transfer complete callback */
;;;970        huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
00002e  6418              STR      r0,[r3,#0x40]
000030  6e23              LDR      r3,[r4,#0x60]
000032  4810              LDR      r0,|L29.116|
;;;971    
;;;972        /* Set the DMA error callback */
;;;973        huart->hdmatx->XferErrorCallback = UART_DMAError;
000034  6458              STR      r0,[r3,#0x44]
000036  6e23              LDR      r3,[r4,#0x60]
000038  480f              LDR      r0,|L29.120|
;;;974    
;;;975        /* Set the DMA abort callback */
;;;976        huart->hdmatx->XferAbortCallback = NULL;
00003a  6518              STR      r0,[r3,#0x50]
;;;977    
;;;978        /* Enable the UART transmit DMA channel */
;;;979        tmp = (uint32_t*)&pData;
;;;980        HAL_DMA_Start_IT(huart->hdmatx, *(uint32_t*)tmp, (uint32_t)&huart->Instance->TDR, Size);
00003c  4613              MOV      r3,r2
00003e  6e20              LDR      r0,[r4,#0x60]         ;976
000040  6545              STR      r5,[r0,#0x54]
000042  6820              LDR      r0,[r4,#0]
000044  6e26              LDR      r6,[r4,#0x60]
000046  f1000228          ADD      r2,r0,#0x28
00004a  4630              MOV      r0,r6
00004c  f7fffffe          BL       HAL_DMA_Start_IT
;;;981    
;;;982        /* Clear the TC flag in the SR register by writing 0 to it */
;;;983        __HAL_UART_CLEAR_IT(huart, UART_FLAG_TC);
000050  6821              LDR      r1,[r4,#0]
000052  2040              MOVS     r0,#0x40
000054  6208              STR      r0,[r1,#0x20]
;;;984    
;;;985        /* Process Unlocked */
;;;986        __HAL_UNLOCK(huart);
;;;987    
;;;988        /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;989           in the UART CR3 register */
;;;990        SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000056  66a5              STR      r5,[r4,#0x68]
000058  6820              LDR      r0,[r4,#0]
00005a  6881              LDR      r1,[r0,#8]
00005c  f0410180          ORR      r1,r1,#0x80
000060  6081              STR      r1,[r0,#8]
;;;991    
;;;992        return HAL_OK;
000062  2000              MOVS     r0,#0
;;;993      }
;;;994      else
;;;995      {
;;;996        return HAL_BUSY;
;;;997      }
;;;998    }
000064  bd70              POP      {r4-r6,pc}
                  |L29.102|
000066  2001              MOVS     r0,#1                 ;953
000068  bd70              POP      {r4-r6,pc}
                  |L29.106|
00006a  2002              MOVS     r0,#2                 ;996
00006c  bd70              POP      {r4-r6,pc}
;;;999    
                          ENDP

00006e  0000              DCW      0x0000
                  |L29.112|
                          DCD      UART_DMATransmitCplt
                  |L29.116|
                          DCD      UART_DMATxHalfCplt
                  |L29.120|
                          DCD      UART_DMAError

                          AREA ||i.HAL_UART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  HAL_UART_Transmit_IT PROC
;;;855      */
;;;856    HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  6ec3              LDR      r3,[r0,#0x6c]
;;;857    {
;;;858      /* Check that a Tx process is not already ongoing */
;;;859      if(huart->gState == HAL_UART_STATE_READY)
000002  2b20              CMP      r3,#0x20
000004  d117              BNE      |L30.54|
;;;860      {
;;;861        if((pData == NULL ) || (Size == 0U))
000006  b1a1              CBZ      r1,|L30.50|
000008  b19a              CBZ      r2,|L30.50|
;;;862        {
;;;863          return HAL_ERROR;
;;;864        }
;;;865    
;;;866        /* Process Locked */
;;;867        __HAL_LOCK(huart);
00000a  6e83              LDR      r3,[r0,#0x68]
00000c  2b01              CMP      r3,#1
00000e  d012              BEQ      |L30.54|
;;;868    
;;;869        huart->pTxBuffPtr = pData;
;;;870        huart->TxXferSize = Size;
000010  64c1              STR      r1,[r0,#0x4c]
;;;871        huart->TxXferCount = Size;
;;;872    
;;;873        huart->ErrorCode = HAL_UART_ERROR_NONE;
000012  2100              MOVS     r1,#0
000014  f8a02050          STRH     r2,[r0,#0x50]         ;870
;;;874        huart->gState = HAL_UART_STATE_BUSY_TX;
000018  2321              MOVS     r3,#0x21
00001a  f8a02052          STRH     r2,[r0,#0x52]         ;871
00001e  6741              STR      r1,[r0,#0x74]         ;873
000020  66c3              STR      r3,[r0,#0x6c]
;;;875    
;;;876        /* Process Unlocked */
;;;877        __HAL_UNLOCK(huart);
;;;878    
;;;879        /* Enable the UART Transmit Data Register Empty Interrupt */
;;;880        SET_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
000022  6681              STR      r1,[r0,#0x68]
000024  6800              LDR      r0,[r0,#0]
000026  6801              LDR      r1,[r0,#0]
000028  f0410180          ORR      r1,r1,#0x80
00002c  6001              STR      r1,[r0,#0]
;;;881    
;;;882        return HAL_OK;
00002e  2000              MOVS     r0,#0
;;;883      }
;;;884      else
;;;885      {
;;;886        return HAL_BUSY;
;;;887      }
;;;888    }
000030  4770              BX       lr
                  |L30.50|
000032  2001              MOVS     r0,#1                 ;863
000034  4770              BX       lr
                  |L30.54|
000036  2002              MOVS     r0,#2                 ;886
000038  4770              BX       lr
;;;889    
                          ENDP


                          AREA ||i.HAL_UART_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxCpltCallback PROC
;;;1487     */
;;;1488    __weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1489   {
;;;1490     /* Prevent unused argument(s) compilation warning */
;;;1491     UNUSED(huart);
;;;1492   
;;;1493     /* NOTE : This function should not be modified, when the callback is needed,
;;;1494               the HAL_UART_TxCpltCallback can be implemented in the user file
;;;1495      */
;;;1496   }
;;;1497   
                          ENDP


                          AREA ||i.HAL_UART_TxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxHalfCpltCallback PROC
;;;1502     */
;;;1503    __weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1504   {
;;;1505     /* Prevent unused argument(s) compilation warning */
;;;1506     UNUSED(huart);
;;;1507   
;;;1508     /* NOTE: This function should not be modified, when the callback is needed,
;;;1509              the HAL_UART_TxHalfCpltCallback can be implemented in the user file
;;;1510      */
;;;1511   }
;;;1512   
                          ENDP


                          AREA ||i.UART_AdvFeatureConfig||, CODE, READONLY, ALIGN=1

                  UART_AdvFeatureConfig PROC
;;;1935     */
;;;1936   void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
000000  f8901024          LDRB     r1,[r0,#0x24]
;;;1937   {
;;;1938     /* Check whether the set of advanced features to configure is properly set */
;;;1939     assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));
;;;1940   
;;;1941     /* if required, configure TX pin active level inversion */
;;;1942     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
000004  07c9              LSLS     r1,r1,#31
000006  d006              BEQ      |L33.22|
;;;1943     {
;;;1944       assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
;;;1945       MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
000008  6801              LDR      r1,[r0,#0]
00000a  6a83              LDR      r3,[r0,#0x28]
00000c  684a              LDR      r2,[r1,#4]
00000e  f4223200          BIC      r2,r2,#0x20000
000012  431a              ORRS     r2,r2,r3
000014  604a              STR      r2,[r1,#4]
                  |L33.22|
;;;1946     }
;;;1947   
;;;1948     /* if required, configure RX pin active level inversion */
;;;1949     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
000016  f8901024          LDRB     r1,[r0,#0x24]
00001a  0789              LSLS     r1,r1,#30
00001c  d506              BPL      |L33.44|
;;;1950     {
;;;1951       assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
;;;1952       MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
00001e  6801              LDR      r1,[r0,#0]
000020  6ac3              LDR      r3,[r0,#0x2c]
000022  684a              LDR      r2,[r1,#4]
000024  f4223280          BIC      r2,r2,#0x10000
000028  431a              ORRS     r2,r2,r3
00002a  604a              STR      r2,[r1,#4]
                  |L33.44|
;;;1953     }
;;;1954   
;;;1955     /* if required, configure data inversion */
;;;1956     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
00002c  f8901024          LDRB     r1,[r0,#0x24]
000030  0749              LSLS     r1,r1,#29
000032  d506              BPL      |L33.66|
;;;1957     {
;;;1958       assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
;;;1959       MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
000034  6801              LDR      r1,[r0,#0]
000036  6b03              LDR      r3,[r0,#0x30]
000038  684a              LDR      r2,[r1,#4]
00003a  f4222280          BIC      r2,r2,#0x40000
00003e  431a              ORRS     r2,r2,r3
000040  604a              STR      r2,[r1,#4]
                  |L33.66|
;;;1960     }
;;;1961   
;;;1962     /* if required, configure RX/TX pins swap */
;;;1963     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
000042  f8901024          LDRB     r1,[r0,#0x24]
000046  0709              LSLS     r1,r1,#28
000048  d506              BPL      |L33.88|
;;;1964     {
;;;1965       assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
;;;1966       MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
00004a  6801              LDR      r1,[r0,#0]
00004c  6b43              LDR      r3,[r0,#0x34]
00004e  684a              LDR      r2,[r1,#4]
000050  f4224200          BIC      r2,r2,#0x8000
000054  431a              ORRS     r2,r2,r3
000056  604a              STR      r2,[r1,#4]
                  |L33.88|
;;;1967     }
;;;1968   
;;;1969     /* if required, configure RX overrun detection disabling */
;;;1970     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
000058  f8901024          LDRB     r1,[r0,#0x24]
00005c  06c9              LSLS     r1,r1,#27
00005e  d506              BPL      |L33.110|
;;;1971     {
;;;1972       assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
;;;1973       MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
000060  6801              LDR      r1,[r0,#0]
000062  6b83              LDR      r3,[r0,#0x38]
000064  688a              LDR      r2,[r1,#8]
000066  f4225280          BIC      r2,r2,#0x1000
00006a  431a              ORRS     r2,r2,r3
00006c  608a              STR      r2,[r1,#8]
                  |L33.110|
;;;1974     }
;;;1975   
;;;1976     /* if required, configure DMA disabling on reception error */
;;;1977     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
00006e  f8901024          LDRB     r1,[r0,#0x24]
000072  0689              LSLS     r1,r1,#26
000074  d506              BPL      |L33.132|
;;;1978     {
;;;1979       assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
;;;1980       MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
000076  6801              LDR      r1,[r0,#0]
000078  6bc3              LDR      r3,[r0,#0x3c]
00007a  688a              LDR      r2,[r1,#8]
00007c  f4225200          BIC      r2,r2,#0x2000
000080  431a              ORRS     r2,r2,r3
000082  608a              STR      r2,[r1,#8]
                  |L33.132|
;;;1981     }
;;;1982   
;;;1983     /* if required, configure auto Baud rate detection scheme */
;;;1984     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
000084  f8901024          LDRB     r1,[r0,#0x24]
000088  0649              LSLS     r1,r1,#25
00008a  d511              BPL      |L33.176|
;;;1985     {
;;;1986       assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
;;;1987       MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
00008c  6801              LDR      r1,[r0,#0]
00008e  6c03              LDR      r3,[r0,#0x40]
000090  684a              LDR      r2,[r1,#4]
000092  f4221280          BIC      r2,r2,#0x100000
000096  431a              ORRS     r2,r2,r3
000098  604a              STR      r2,[r1,#4]
;;;1988       /* set auto Baudrate detection parameters if detection is enabled */
;;;1989       if(huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
00009a  6c01              LDR      r1,[r0,#0x40]
00009c  f5b11f80          CMP      r1,#0x100000
0000a0  d106              BNE      |L33.176|
;;;1990       {
;;;1991         assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
;;;1992         MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
0000a2  6801              LDR      r1,[r0,#0]
0000a4  6c43              LDR      r3,[r0,#0x44]
0000a6  684a              LDR      r2,[r1,#4]
0000a8  f42202c0          BIC      r2,r2,#0x600000
0000ac  431a              ORRS     r2,r2,r3
0000ae  604a              STR      r2,[r1,#4]
                  |L33.176|
;;;1993       }
;;;1994     }
;;;1995   
;;;1996     /* if required, configure MSB first on communication line */
;;;1997     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
0000b0  f8901024          LDRB     r1,[r0,#0x24]
0000b4  0609              LSLS     r1,r1,#24
0000b6  d506              BPL      |L33.198|
;;;1998     {
;;;1999       assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
;;;2000       MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
0000b8  6801              LDR      r1,[r0,#0]
0000ba  6c82              LDR      r2,[r0,#0x48]
0000bc  6848              LDR      r0,[r1,#4]
0000be  f4202000          BIC      r0,r0,#0x80000
0000c2  4310              ORRS     r0,r0,r2
0000c4  6048              STR      r0,[r1,#4]
                  |L33.198|
;;;2001     }
;;;2002   }
0000c6  4770              BX       lr
;;;2003   
                          ENDP


                          AREA ||i.UART_CheckIdleState||, CODE, READONLY, ALIGN=1

                  UART_CheckIdleState PROC
;;;2010     */
;;;2011   HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
000000  b538              PUSH     {r3-r5,lr}
;;;2012   {
;;;2013     uint32_t tickstart = 0U;
;;;2014   
;;;2015     /* Initialize the UART ErrorCode */
;;;2016     huart->ErrorCode = HAL_UART_ERROR_NONE;
000002  2500              MOVS     r5,#0
000004  4604              MOV      r4,r0                 ;2012
000006  6745              STR      r5,[r0,#0x74]
;;;2017   
;;;2018     /* Init tickstart for timeout managment*/
;;;2019     tickstart = HAL_GetTick();
000008  f7fffffe          BL       HAL_GetTick
00000c  4603              MOV      r3,r0
;;;2020   
;;;2021     /* Check if the Transmitter is enabled */
;;;2022     if((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
00000e  6820              LDR      r0,[r4,#0]
000010  6800              LDR      r0,[r0,#0]
000012  0700              LSLS     r0,r0,#28
000014  d50b              BPL      |L34.46|
;;;2023     {
;;;2024       /* Wait until TEACK flag is set */
;;;2025       if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
000016  f06f407e          MVN      r0,#0xfe000000
00001a  9000              STR      r0,[sp,#0]
00001c  2200              MOVS     r2,#0
00001e  4620              MOV      r0,r4
000020  f44f1100          MOV      r1,#0x200000
000024  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
000028  b108              CBZ      r0,|L34.46|
;;;2026       {
;;;2027         /* Timeout Occurred */
;;;2028         return HAL_TIMEOUT;
00002a  2003              MOVS     r0,#3
;;;2029       }
;;;2030     }
;;;2031   
;;;2032     /* Initialize the UART State */
;;;2033     huart->gState= HAL_UART_STATE_READY;
;;;2034     huart->RxState= HAL_UART_STATE_READY;
;;;2035   
;;;2036     /* Process Unlocked */
;;;2037     __HAL_UNLOCK(huart);
;;;2038   
;;;2039     return HAL_OK;
;;;2040   }
00002c  bd38              POP      {r3-r5,pc}
                  |L34.46|
00002e  2020              MOVS     r0,#0x20              ;2033
000030  66e0              STR      r0,[r4,#0x6c]         ;2033
000032  66a5              STR      r5,[r4,#0x68]         ;2034
000034  6720              STR      r0,[r4,#0x70]         ;2034
000036  2000              MOVS     r0,#0                 ;2039
000038  bd38              POP      {r3-r5,pc}
;;;2041   
                          ENDP


                          AREA ||i.UART_DMAAbortOnError||, CODE, READONLY, ALIGN=1

                  UART_DMAAbortOnError PROC
;;;1473     */
;;;1474   static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1475   {
;;;1476     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)(hdma->Parent);
000002  6bc0              LDR      r0,[r0,#0x3c]
;;;1477     huart->RxXferCount = 0U;
000004  2100              MOVS     r1,#0
000006  f8a0105a          STRH     r1,[r0,#0x5a]
;;;1478     huart->TxXferCount = 0U;
00000a  f8a01052          STRH     r1,[r0,#0x52]
;;;1479   
;;;1480     HAL_UART_ErrorCallback(huart);
00000e  f7fffffe          BL       HAL_UART_ErrorCallback
;;;1481   }
000012  bd10              POP      {r4,pc}
;;;1482   
                          ENDP


                          AREA ||i.UART_DMAError||, CODE, READONLY, ALIGN=1

                  UART_DMAError PROC
;;;1445     */
;;;1446   static void UART_DMAError(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1447   {
;;;1448     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
;;;1449     huart->RxXferCount = 0U;
000002  6bc4              LDR      r4,[r0,#0x3c]
000004  2100              MOVS     r1,#0
000006  f8a4105a          STRH     r1,[r4,#0x5a]
;;;1450     huart->TxXferCount = 0U;
00000a  f8a41052          STRH     r1,[r4,#0x52]
;;;1451     /* Stop UART DMA Tx request if ongoing */
;;;1452     if (  (huart->gState == HAL_UART_STATE_BUSY_TX)
00000e  6ee0              LDR      r0,[r4,#0x6c]
000010  2821              CMP      r0,#0x21
000012  d106              BNE      |L36.34|
;;;1453         &&(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) )
000014  6820              LDR      r0,[r4,#0]
000016  6880              LDR      r0,[r0,#8]
000018  0600              LSLS     r0,r0,#24
00001a  d502              BPL      |L36.34|
;;;1454     {
;;;1455       UART_EndTxTransfer(huart);
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       UART_EndTxTransfer
                  |L36.34|
;;;1456     }
;;;1457   
;;;1458     /* Stop UART DMA Rx request if ongoing */
;;;1459     if (  (huart->RxState == HAL_UART_STATE_BUSY_RX)
000022  6f20              LDR      r0,[r4,#0x70]
000024  2822              CMP      r0,#0x22
000026  d106              BNE      |L36.54|
;;;1460         &&(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) )
000028  6820              LDR      r0,[r4,#0]
00002a  6880              LDR      r0,[r0,#8]
00002c  0640              LSLS     r0,r0,#25
00002e  d502              BPL      |L36.54|
;;;1461     {
;;;1462       UART_EndRxTransfer(huart);
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       UART_EndRxTransfer
                  |L36.54|
;;;1463     }
;;;1464     SET_BIT(huart->ErrorCode, HAL_UART_ERROR_DMA);
000036  6f60              LDR      r0,[r4,#0x74]
000038  f0400010          ORR      r0,r0,#0x10
00003c  6760              STR      r0,[r4,#0x74]
;;;1465     HAL_UART_ErrorCallback(huart);
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       HAL_UART_ErrorCallback
;;;1466   }
000044  bd10              POP      {r4,pc}
;;;1467   
                          ENDP


                          AREA ||i.UART_DMAReceiveCplt||, CODE, READONLY, ALIGN=1

                  UART_DMAReceiveCplt PROC
;;;1405     */
;;;1406   static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1407   {
;;;1408     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
;;;1409   
;;;1410     /* DMA Normal mode */
;;;1411     if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
000002  6801              LDR      r1,[r0,#0]
000004  6809              LDR      r1,[r1,#0]
000006  6bc0              LDR      r0,[r0,#0x3c]         ;1408
000008  05c9              LSLS     r1,r1,#23
00000a  d413              BMI      |L37.52|
;;;1412     {
;;;1413       huart->RxXferCount = 0U;
00000c  2100              MOVS     r1,#0
00000e  f8a0105a          STRH     r1,[r0,#0x5a]
;;;1414   
;;;1415       /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1416       CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1417       CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1418   
;;;1419       /* Disable the DMA transfer for the receiver request by setting the DMAR bit
;;;1420       in the UART CR3 register */
;;;1421       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1422   
;;;1423   	/* At end of Rx process, restore huart->RxState to Ready */
;;;1424       huart->RxState = HAL_UART_STATE_READY;
000012  2220              MOVS     r2,#0x20
000014  6801              LDR      r1,[r0,#0]            ;1416
000016  680b              LDR      r3,[r1,#0]            ;1416
000018  f4237380          BIC      r3,r3,#0x100          ;1416
00001c  600b              STR      r3,[r1,#0]            ;1416
00001e  6801              LDR      r1,[r0,#0]            ;1417
000020  688b              LDR      r3,[r1,#8]            ;1417
000022  f0230301          BIC      r3,r3,#1              ;1417
000026  608b              STR      r3,[r1,#8]            ;1417
000028  6801              LDR      r1,[r0,#0]            ;1421
00002a  688b              LDR      r3,[r1,#8]            ;1421
00002c  f0230340          BIC      r3,r3,#0x40           ;1421
000030  608b              STR      r3,[r1,#8]            ;1421
000032  6702              STR      r2,[r0,#0x70]
                  |L37.52|
;;;1425     }
;;;1426     HAL_UART_RxCpltCallback(huart);
000034  f7fffffe          BL       HAL_UART_RxCpltCallback
;;;1427   }
000038  bd10              POP      {r4,pc}
;;;1428   
                          ENDP


                          AREA ||i.UART_DMARxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMARxHalfCplt PROC
;;;1433     */
;;;1434   static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1435   {
;;;1436     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000002  6bc0              LDR      r0,[r0,#0x3c]
;;;1437   
;;;1438     HAL_UART_RxHalfCpltCallback(huart);
000004  f7fffffe          BL       HAL_UART_RxHalfCpltCallback
;;;1439   }
000008  bd10              POP      {r4,pc}
;;;1440   
                          ENDP


                          AREA ||i.UART_DMATransmitCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATransmitCplt PROC
;;;1365     */
;;;1366   static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1367   {
;;;1368     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
;;;1369   
;;;1370     /* DMA Normal mode*/
;;;1371     if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
000002  6801              LDR      r1,[r0,#0]
000004  6809              LDR      r1,[r1,#0]
000006  6bc0              LDR      r0,[r0,#0x3c]         ;1368
000008  05c9              LSLS     r1,r1,#23
00000a  d40d              BMI      |L39.40|
;;;1372     {
;;;1373       huart->TxXferCount = 0U;
00000c  2100              MOVS     r1,#0
00000e  f8a01052          STRH     r1,[r0,#0x52]
;;;1374   
;;;1375       /* Disable the DMA transfer for transmit request by setting the DMAT bit
;;;1376          in the UART CR3 register */
;;;1377       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000012  6801              LDR      r1,[r0,#0]
000014  688a              LDR      r2,[r1,#8]
000016  f0220280          BIC      r2,r2,#0x80
00001a  608a              STR      r2,[r1,#8]
;;;1378   
;;;1379       /* Enable the UART Transmit Complete Interrupt */
;;;1380       SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
00001c  6800              LDR      r0,[r0,#0]
00001e  6801              LDR      r1,[r0,#0]
000020  f0410140          ORR      r1,r1,#0x40
000024  6001              STR      r1,[r0,#0]
;;;1381     }
;;;1382     /* DMA Circular mode */
;;;1383     else
;;;1384     {
;;;1385       HAL_UART_TxCpltCallback(huart);
;;;1386     }
;;;1387   }
000026  bd10              POP      {r4,pc}
                  |L39.40|
000028  f7fffffe          BL       HAL_UART_TxCpltCallback
00002c  bd10              POP      {r4,pc}
;;;1388   
                          ENDP


                          AREA ||i.UART_DMATxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATxHalfCplt PROC
;;;1393     */
;;;1394   static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;1395   {
;;;1396     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000002  6bc0              LDR      r0,[r0,#0x3c]
;;;1397   
;;;1398     HAL_UART_TxHalfCpltCallback(huart);
000004  f7fffffe          BL       HAL_UART_TxHalfCpltCallback
;;;1399   }
000008  bd10              POP      {r4,pc}
;;;1400   
                          ENDP


                          AREA ||i.UART_EndRxTransfer||, CODE, READONLY, ALIGN=1

                  UART_EndRxTransfer PROC
;;;1699     */
;;;1700   static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
000000  6801              LDR      r1,[r0,#0]
;;;1701   {
;;;1702     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1703     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
;;;1704     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1705   
;;;1706     /* At end of Rx process, restore huart->RxState to Ready */
;;;1707     huart->RxState = HAL_UART_STATE_READY;
000002  2220              MOVS     r2,#0x20
000004  680b              LDR      r3,[r1,#0]            ;1703
000006  f4237390          BIC      r3,r3,#0x120          ;1703
00000a  600b              STR      r3,[r1,#0]            ;1703
00000c  6801              LDR      r1,[r0,#0]            ;1704
00000e  688b              LDR      r3,[r1,#8]            ;1704
000010  f0230301          BIC      r3,r3,#1              ;1704
000014  608b              STR      r3,[r1,#8]            ;1704
000016  6702              STR      r2,[r0,#0x70]
;;;1708   }
000018  4770              BX       lr
;;;1709   
                          ENDP


                          AREA ||i.UART_EndTxTransfer||, CODE, READONLY, ALIGN=1

                  UART_EndTxTransfer PROC
;;;1684     */
;;;1685   static void UART_EndTxTransfer(UART_HandleTypeDef *huart)
000000  6801              LDR      r1,[r0,#0]
;;;1686   {
;;;1687     /* Disable TXEIE and TCIE interrupts */
;;;1688     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
;;;1689   
;;;1690     /* At end of Tx process, restore huart->gState to Ready */
;;;1691     huart->gState = HAL_UART_STATE_READY;
000002  2220              MOVS     r2,#0x20
000004  680b              LDR      r3,[r1,#0]            ;1688
000006  f02303c0          BIC      r3,r3,#0xc0           ;1688
00000a  600b              STR      r3,[r1,#0]            ;1688
00000c  66c2              STR      r2,[r0,#0x6c]
;;;1692   }
00000e  4770              BX       lr
;;;1693   
                          ENDP


                          AREA ||i.UART_Receive_IT||, CODE, READONLY, ALIGN=2

                  UART_Receive_IT PROC
;;;1632     */
;;;1633   static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1634   {
;;;1635     uint16_t* tmp;
;;;1636     uint16_t uhMask = huart->Mask;
;;;1637   
;;;1638     /* Check that a Rx process is ongoing */
;;;1639     if(huart->RxState == HAL_UART_STATE_BUSY_RX)
000002  6f01              LDR      r1,[r0,#0x70]
000004  f8b0205c          LDRH     r2,[r0,#0x5c]         ;1636
000008  2922              CMP      r1,#0x22
00000a  6801              LDR      r1,[r0,#0]            ;1634
00000c  d005              BEQ      |L43.26|
;;;1640     {
;;;1641   
;;;1642       if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;1643       {
;;;1644         tmp = (uint16_t*) huart->pRxBuffPtr ;
;;;1645         *tmp = (uint16_t)(huart->Instance->RDR & uhMask);
;;;1646         huart->pRxBuffPtr +=2;
;;;1647       }
;;;1648       else
;;;1649       {
;;;1650         *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask);
;;;1651       }
;;;1652   
;;;1653       if(--huart->RxXferCount == 0)
;;;1654       {
;;;1655         /* Disable the UART Parity Error Interrupt and RXNE interrupt*/
;;;1656         CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
;;;1657   
;;;1658         /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1659         CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1660   
;;;1661         /* Rx process is completed, restore huart->RxState to Ready */
;;;1662         huart->RxState = HAL_UART_STATE_READY;
;;;1663   
;;;1664         HAL_UART_RxCpltCallback(huart);
;;;1665   
;;;1666         return HAL_OK;
;;;1667       }
;;;1668   
;;;1669       return HAL_OK;
;;;1670     }
;;;1671     else
;;;1672     {
;;;1673       /* Clear RXNE interrupt flag */
;;;1674       __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
00000e  6988              LDR      r0,[r1,#0x18]
000010  f0400008          ORR      r0,r0,#8
000014  6188              STR      r0,[r1,#0x18]
;;;1675   
;;;1676       return HAL_BUSY;
000016  2002              MOVS     r0,#2
;;;1677     }
;;;1678   }
000018  bd10              POP      {r4,pc}
                  |L43.26|
00001a  6883              LDR      r3,[r0,#8]            ;1642
00001c  f5b35f80          CMP      r3,#0x1000            ;1642
000020  d101              BNE      |L43.38|
000022  6903              LDR      r3,[r0,#0x10]         ;1642
000024  b17b              CBZ      r3,|L43.70|
                  |L43.38|
000026  6a4b              LDR      r3,[r1,#0x24]         ;1650
000028  6d41              LDR      r1,[r0,#0x54]         ;1650
00002a  4013              ANDS     r3,r3,r2              ;1650
00002c  1c4a              ADDS     r2,r1,#1              ;1650
00002e  6542              STR      r2,[r0,#0x54]         ;1650
000030  f8813000          STRB.W   r3,[r1,#0]            ;1650
                  |L43.52|
000034  f8b0105a          LDRH     r1,[r0,#0x5a]         ;1653
000038  1e49              SUBS     r1,r1,#1              ;1653
00003a  0409              LSLS     r1,r1,#16             ;1653
00003c  0c09              LSRS     r1,r1,#16             ;1653
00003e  f8a0105a          STRH     r1,[r0,#0x5a]         ;1653
000042  d008              BEQ      |L43.86|
000044  e015              B        |L43.114|
                  |L43.70|
000046  6a4b              LDR      r3,[r1,#0x24]         ;1645
000048  6d41              LDR      r1,[r0,#0x54]         ;1645
00004a  4013              ANDS     r3,r3,r2              ;1645
00004c  800b              STRH     r3,[r1,#0]            ;1645
00004e  6d41              LDR      r1,[r0,#0x54]         ;1646
000050  1c89              ADDS     r1,r1,#2              ;1646
000052  6541              STR      r1,[r0,#0x54]         ;1646
000054  e7ee              B        |L43.52|
                  |L43.86|
000056  6801              LDR      r1,[r0,#0]            ;1656
000058  2220              MOVS     r2,#0x20              ;1662
00005a  680b              LDR      r3,[r1,#0]            ;1656
00005c  f4237390          BIC      r3,r3,#0x120          ;1656
000060  600b              STR      r3,[r1,#0]            ;1656
000062  6801              LDR      r1,[r0,#0]            ;1659
000064  688b              LDR      r3,[r1,#8]            ;1659
000066  f0230301          BIC      r3,r3,#1              ;1659
00006a  608b              STR      r3,[r1,#8]            ;1659
00006c  6702              STR      r2,[r0,#0x70]         ;1662
00006e  f7fffffe          BL       HAL_UART_RxCpltCallback
                  |L43.114|
000072  2000              MOVS     r0,#0                 ;1669
000074  bd10              POP      {r4,pc}
;;;1679   
                          ENDP


                          AREA ||i.UART_SetConfig||, CODE, READONLY, ALIGN=2

                  UART_SetConfig PROC
;;;1824     */
;;;1825   HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1826   {
000004  4604              MOV      r4,r0
;;;1827     uint32_t tmpreg                     = 0x00000000U;
;;;1828     UART_ClockSourceTypeDef clocksource = UART_CLOCKSOURCE_UNDEFINED;
;;;1829     uint16_t brrtemp                    = 0x0000U;
;;;1830     uint16_t usartdiv                   = 0x0000U;
;;;1831     HAL_StatusTypeDef ret               = HAL_OK;
;;;1832   
;;;1833     /* Check the parameters */
;;;1834     assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
;;;1835     assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;1836     assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
;;;1837     assert_param(IS_UART_PARITY(huart->Init.Parity));
;;;1838     assert_param(IS_UART_MODE(huart->Init.Mode));
;;;1839     assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
;;;1840     assert_param(IS_UART_ONE_BIT_SAMPLE(huart->Init.OneBitSampling));
;;;1841   
;;;1842   
;;;1843     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;1844     /* Clear M, PCE, PS, TE, RE and OVER8 bits and configure
;;;1845      *  the UART Word Length, Parity, Mode and oversampling:
;;;1846      *  set the M bits according to huart->Init.WordLength value
;;;1847      *  set PCE and PS bits according to huart->Init.Parity value
;;;1848      *  set TE and RE bits according to huart->Init.Mode value
;;;1849      *  set OVER8 bit according to huart->Init.OverSampling value */
;;;1850     tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
000006  6880              LDR      r0,[r0,#8]
;;;1851     MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
000008  4b87              LDR      r3,|L44.552|
;;;1852   
;;;1853     /*-------------------------- USART CR2 Configuration -----------------------*/
;;;1854     /* Configure the UART Stop Bits: Set STOP[13:12] bits according
;;;1855      * to huart->Init.StopBits value */
;;;1856     MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
;;;1857   
;;;1858     /*-------------------------- USART CR3 Configuration -----------------------*/
;;;1859     /* Configure
;;;1860      * - UART HardWare Flow Control: set CTSE and RTSE bits according
;;;1861      *   to huart->Init.HwFlowCtl value
;;;1862      * - one-bit sampling method versus three samples' majority rule according
;;;1863      *   to huart->Init.OneBitSampling */
;;;1864     tmpreg = (uint32_t)huart->Init.HwFlowCtl | huart->Init.OneBitSampling ;
;;;1865     MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);
;;;1866   
;;;1867     /*-------------------------- USART BRR Configuration -----------------------*/
;;;1868     UART_GETCLOCKSOURCE(huart, clocksource);
00000a  4f88              LDR      r7,|L44.556|
00000c  6826              LDR      r6,[r4,#0]            ;1851
00000e  e9d41504          LDRD     r1,r5,[r4,#0x10]
000012  69e2              LDR      r2,[r4,#0x1c]         ;1851
000014  4308              ORRS     r0,r0,r1              ;1850
000016  f8d6c000          LDR      r12,[r6,#0]           ;1851
00001a  2110              MOVS     r1,#0x10              ;1828
00001c  4315              ORRS     r5,r5,r2              ;1850
00001e  2200              MOVS     r2,#0                 ;1830
000020  4328              ORRS     r0,r0,r5              ;1850
000022  4615              MOV      r5,r2                 ;1831
000024  ea0c0c03          AND      r12,r12,r3            ;1851
000028  4b81              LDR      r3,|L44.560|
00002a  ea4c0c00          ORR      r12,r12,r0            ;1851
00002e  f8c6c000          STR      r12,[r6,#0]           ;1851
000032  f44f4900          MOV      r9,#0x8000
000036  6820              LDR      r0,[r4,#0]            ;1856
000038  f8d4c00c          LDR      r12,[r4,#0xc]         ;1856
00003c  6846              LDR      r6,[r0,#4]            ;1856
00003e  f4265640          BIC      r6,r6,#0x3000         ;1856
000042  ea46060c          ORR      r6,r6,r12             ;1856
000046  6046              STR      r6,[r0,#4]            ;1856
000048  6826              LDR      r6,[r4,#0]            ;1865
00004a  f8d48020          LDR      r8,[r4,#0x20]         ;1864
00004e  69a0              LDR      r0,[r4,#0x18]         ;1865
000050  f8d6c008          LDR      r12,[r6,#8]           ;1865
000054  ea400008          ORR      r0,r0,r8              ;1864
000058  f42c6c30          BIC      r12,r12,#0xb00        ;1865
00005c  ea4c0c00          ORR      r12,r12,r0            ;1865
000060  f8c6c008          STR      r12,[r6,#8]           ;1865
000064  6820              LDR      r0,[r4,#0]
000066  42b8              CMP      r0,r7
000068  d10a              BNE      |L44.128|
00006a  681b              LDR      r3,[r3,#0]
00006c  f0130303          ANDS     r3,r3,#3
000070  d052              BEQ      |L44.280|
000072  2b01              CMP      r3,#1
000074  d07a              BEQ      |L44.364|
000076  2b02              CMP      r3,#2
000078  d076              BEQ      |L44.360|
00007a  2b03              CMP      r3,#3
00007c  d179              BNE      |L44.370|
00007e  e077              B        |L44.368|
                  |L44.128|
000080  4e6c              LDR      r6,|L44.564|
000082  42b0              CMP      r0,r6
000084  d10a              BNE      |L44.156|
000086  681b              LDR      r3,[r3,#0]
000088  f013030c          ANDS     r3,r3,#0xc
00008c  d06a              BEQ      |L44.356|
00008e  2b04              CMP      r3,#4
000090  d06c              BEQ      |L44.364|
000092  2b08              CMP      r3,#8
000094  d068              BEQ      |L44.360|
000096  2b0c              CMP      r3,#0xc
000098  d16b              BNE      |L44.370|
00009a  e069              B        |L44.368|
                  |L44.156|
00009c  4e66              LDR      r6,|L44.568|
00009e  42b0              CMP      r0,r6
0000a0  d10a              BNE      |L44.184|
0000a2  681b              LDR      r3,[r3,#0]
0000a4  f0130330          ANDS     r3,r3,#0x30
0000a8  d05c              BEQ      |L44.356|
0000aa  2b10              CMP      r3,#0x10
0000ac  d05e              BEQ      |L44.364|
0000ae  2b20              CMP      r3,#0x20
0000b0  d05a              BEQ      |L44.360|
0000b2  2b30              CMP      r3,#0x30
0000b4  d15d              BNE      |L44.370|
0000b6  e05b              B        |L44.368|
                  |L44.184|
0000b8  4e60              LDR      r6,|L44.572|
0000ba  42b0              CMP      r0,r6
0000bc  d10a              BNE      |L44.212|
0000be  681b              LDR      r3,[r3,#0]
0000c0  f01303c0          ANDS     r3,r3,#0xc0
0000c4  d04e              BEQ      |L44.356|
0000c6  2b40              CMP      r3,#0x40
0000c8  d050              BEQ      |L44.364|
0000ca  2b80              CMP      r3,#0x80
0000cc  d04c              BEQ      |L44.360|
0000ce  2bc0              CMP      r3,#0xc0
0000d0  d14f              BNE      |L44.370|
0000d2  e04d              B        |L44.368|
                  |L44.212|
0000d4  4e5a              LDR      r6,|L44.576|
0000d6  42b0              CMP      r0,r6
0000d8  d10d              BNE      |L44.246|
0000da  681b              LDR      r3,[r3,#0]
0000dc  f4137340          ANDS     r3,r3,#0x300
0000e0  d040              BEQ      |L44.356|
0000e2  f5b37f80          CMP      r3,#0x100
0000e6  d041              BEQ      |L44.364|
0000e8  f5b37f00          CMP      r3,#0x200
0000ec  d03c              BEQ      |L44.360|
0000ee  f5b37f40          CMP      r3,#0x300
0000f2  d13e              BNE      |L44.370|
0000f4  e03c              B        |L44.368|
                  |L44.246|
0000f6  4e53              LDR      r6,|L44.580|
0000f8  42b0              CMP      r0,r6
0000fa  d10f              BNE      |L44.284|
0000fc  681b              LDR      r3,[r3,#0]
0000fe  f4136340          ANDS     r3,r3,#0xc00
000102  d009              BEQ      |L44.280|
000104  f5b36f80          CMP      r3,#0x400
000108  d030              BEQ      |L44.364|
00010a  f5b36f00          CMP      r3,#0x800
00010e  d02b              BEQ      |L44.360|
000110  f5b36f40          CMP      r3,#0xc00
000114  d12d              BNE      |L44.370|
000116  e02b              B        |L44.368|
                  |L44.280|
000118  2101              MOVS     r1,#1
00011a  e02a              B        |L44.370|
                  |L44.284|
00011c  4e4a              LDR      r6,|L44.584|
00011e  42b0              CMP      r0,r6
000120  d10d              BNE      |L44.318|
000122  681b              LDR      r3,[r3,#0]
000124  f4135340          ANDS     r3,r3,#0x3000
000128  d01c              BEQ      |L44.356|
00012a  f5b35f80          CMP      r3,#0x1000
00012e  d01d              BEQ      |L44.364|
000130  f5b35f00          CMP      r3,#0x2000
000134  d018              BEQ      |L44.360|
000136  f5b35f40          CMP      r3,#0x3000
00013a  d11a              BNE      |L44.370|
00013c  e018              B        |L44.368|
                  |L44.318|
00013e  4e43              LDR      r6,|L44.588|
000140  42b0              CMP      r0,r6
000142  d116              BNE      |L44.370|
000144  681b              LDR      r3,[r3,#0]
000146  f4134340          ANDS     r3,r3,#0xc000
00014a  d00b              BEQ      |L44.356|
00014c  f5b34f80          CMP      r3,#0x4000
000150  d00c              BEQ      |L44.364|
000152  454b              CMP      r3,r9
000154  d008              BEQ      |L44.360|
000156  f5b34f40          CMP      r3,#0xc000
00015a  d10a              BNE      |L44.370|
00015c  e008              B        |L44.368|
00015e  e005              B        |L44.364|
000160  e002              B        |L44.360|
000162  e7ff              B        |L44.356|
                  |L44.356|
000164  2100              MOVS     r1,#0
000166  e004              B        |L44.370|
                  |L44.360|
000168  2102              MOVS     r1,#2
00016a  e002              B        |L44.370|
                  |L44.364|
00016c  2104              MOVS     r1,#4
00016e  e000              B        |L44.370|
                  |L44.368|
000170  2108              MOVS     r1,#8
                  |L44.370|
;;;1869   
;;;1870     /* Check UART Over Sampling to set Baud Rate Register */
;;;1871     if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
000172  69e6              LDR      r6,[r4,#0x1c]
000174  454e              CMP      r6,r9
000176  d12a              BNE      |L44.462|
;;;1872     {
;;;1873       switch (clocksource)
000178  2909              CMP      r1,#9
00017a  d21f              BCS      |L44.444|
00017c  e8dff001          TBB      [pc,r1]
000180  0508141e          DCB      0x05,0x08,0x14,0x1e
000184  171e1e1e          DCB      0x17,0x1e,0x1e,0x1e
000188  1a00              DCB      0x1a,0x00
;;;1874       {
;;;1875       case UART_CLOCKSOURCE_PCLK1:
;;;1876           usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
00018a  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
;;;1877         break;
00018e  e001              B        |L44.404|
;;;1878       case UART_CLOCKSOURCE_PCLK2:
;;;1879           usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
000190  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
                  |L44.404|
000194  4601              MOV      r1,r0                 ;1876
000196  f8d40004          LDR.W    r0,[r4,#4]            ;1876
00019a  0049              LSLS     r1,r1,#1              ;1876
                  |L44.412|
00019c  eb010150          ADD      r1,r1,r0,LSR #1       ;1876
0001a0  fbb1f0f0          UDIV     r0,r1,r0              ;1876
0001a4  b282              UXTH     r2,r0                 ;1876
0001a6  e00a              B        |L44.446|
;;;1880         break;
;;;1881       case UART_CLOCKSOURCE_HSI:
;;;1882           usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate));
0001a8  4929              LDR      r1,|L44.592|
;;;1883         break;
0001aa  6860              LDR      r0,[r4,#4]
0001ac  e7f6              B        |L44.412|
;;;1884       case UART_CLOCKSOURCE_SYSCLK:
;;;1885           usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
0001ae  f7fffffe          BL       HAL_RCC_GetSysClockFreq
;;;1886         break;
0001b2  e7ef              B        |L44.404|
;;;1887       case UART_CLOCKSOURCE_LSE:
;;;1888           usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
;;;1889         break;
0001b4  6860              LDR      r0,[r4,#4]
0001b6  f44f3180          MOV      r1,#0x10000           ;1888
0001ba  e7ef              B        |L44.412|
                  |L44.444|
;;;1890         case UART_CLOCKSOURCE_UNDEFINED:
;;;1891       default:
;;;1892           ret = HAL_ERROR;
0001bc  2501              MOVS     r5,#1
                  |L44.446|
;;;1893         break;
;;;1894       }
;;;1895   
;;;1896       brrtemp = usartdiv & 0xFFF0U;
;;;1897       brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
;;;1898       huart->Instance->BRR = brrtemp;
0001be  6821              LDR      r1,[r4,#0]
0001c0  f022000f          BIC      r0,r2,#0xf            ;1896
0001c4  f3c20242          UBFX     r2,r2,#1,#3           ;1897
0001c8  4310              ORRS     r0,r0,r2              ;1897
0001ca  60c8              STR      r0,[r1,#0xc]
0001cc  e028              B        |L44.544|
                  |L44.462|
;;;1899     }
;;;1900     else
;;;1901     {
;;;1902       switch (clocksource)
0001ce  2909              CMP      r1,#9
0001d0  d225              BCS      |L44.542|
0001d2  e8dff001          TBB      [pc,r1]
0001d6  0508              DCB      0x05,0x08
0001d8  0b241024          DCB      0x0b,0x24,0x10,0x24
0001dc  24241c00          DCB      0x24,0x24,0x1c,0x00
;;;1903       {
;;;1904       case UART_CLOCKSOURCE_PCLK1:
;;;1905           huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
0001e0  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
;;;1906         break;
0001e4  e009              B        |L44.506|
;;;1907       case UART_CLOCKSOURCE_PCLK2:
;;;1908           huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
0001e6  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
;;;1909         break;
0001ea  e006              B        |L44.506|
;;;1910       case UART_CLOCKSOURCE_HSI:
;;;1911           huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate));
0001ec  6861              LDR      r1,[r4,#4]
0001ee  4a19              LDR      r2,|L44.596|
0001f0  eb020251          ADD      r2,r2,r1,LSR #1
;;;1912         break;
0001f4  e00e              B        |L44.532|
;;;1913       case UART_CLOCKSOURCE_SYSCLK:
;;;1914           huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
0001f6  f7fffffe          BL       HAL_RCC_GetSysClockFreq
                  |L44.506|
0001fa  4601              MOV      r1,r0
0001fc  e9d42000          LDRD     r2,r0,[r4,#0]
000200  eb010150          ADD      r1,r1,r0,LSR #1
000204  fbb1f0f0          UDIV     r0,r1,r0
000208  b280              UXTH     r0,r0
00020a  60d0              STR      r0,[r2,#0xc]
00020c  e008              B        |L44.544|
;;;1915         break;
;;;1916       case UART_CLOCKSOURCE_LSE:
;;;1917           huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
00020e  6861              LDR      r1,[r4,#4]
000210  eb090251          ADD      r2,r9,r1,LSR #1
                  |L44.532|
000214  fbb2f1f1          UDIV     r1,r2,r1
000218  b289              UXTH     r1,r1
00021a  60c1              STR      r1,[r0,#0xc]
00021c  e000              B        |L44.544|
                  |L44.542|
;;;1918         break;
;;;1919         case UART_CLOCKSOURCE_UNDEFINED:
;;;1920       default:
;;;1921           ret = HAL_ERROR;
00021e  2501              MOVS     r5,#1
                  |L44.544|
;;;1922         break;
;;;1923       }
;;;1924     }
;;;1925   
;;;1926     return ret;
000220  4628              MOV      r0,r5
;;;1927   
;;;1928   }
000222  e8bd87f0          POP      {r4-r10,pc}
;;;1929   
                          ENDP

000226  0000              DCW      0x0000
                  |L44.552|
                          DCD      0xefff69f3
                  |L44.556|
                          DCD      0x40011000
                  |L44.560|
                          DCD      0x40023890
                  |L44.564|
                          DCD      0x40004400
                  |L44.568|
                          DCD      0x40004800
                  |L44.572|
                          DCD      0x40004c00
                  |L44.576|
                          DCD      0x40005000
                  |L44.580|
                          DCD      0x40011400
                  |L44.584|
                          DCD      0x40007800
                  |L44.588|
                          DCD      0x40007c00
                  |L44.592|
                          DCD      0x01e84800
                  |L44.596|
                          DCD      0x00f42400

                          AREA ||i.UART_WaitOnFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  UART_WaitOnFlagUntilTimeout PROC
;;;1334     */
;;;1335   HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1336   {
000004  4698              MOV      r8,r3
000006  4617              MOV      r7,r2
000008  460e              MOV      r6,r1
00000a  4604              MOV      r4,r0
;;;1337     /* Wait until flag is set */
;;;1338     while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
;;;1339     {
;;;1340       /* Check for the Timeout */
;;;1341       if(Timeout != HAL_MAX_DELAY)
;;;1342       {
;;;1343         if((Timeout == 0U)||((HAL_GetTick()-Tickstart) >=  Timeout))
;;;1344         {
;;;1345           /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
;;;1346           CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
;;;1347           CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1348   
;;;1349           huart->gState = HAL_UART_STATE_READY;
;;;1350           huart->RxState = HAL_UART_STATE_READY;
;;;1351   
;;;1352           /* Process Unlocked */
;;;1353           __HAL_UNLOCK(huart);
;;;1354           return HAL_TIMEOUT;
00000c  9d06              LDR      r5,[sp,#0x18]
00000e  e01a              B        |L45.70|
                  |L45.16|
000010  1c68              ADDS     r0,r5,#1              ;1341
000012  d018              BEQ      |L45.70|
000014  b12d              CBZ      r5,|L45.34|
000016  f7fffffe          BL       HAL_GetTick
00001a  eba00008          SUB      r0,r0,r8              ;1343
00001e  42a8              CMP      r0,r5                 ;1343
000020  d311              BCC      |L45.70|
                  |L45.34|
000022  6821              LDR      r1,[r4,#0]            ;1346
000024  2020              MOVS     r0,#0x20              ;1349
000026  2200              MOVS     r2,#0                 ;1353
000028  680b              LDR      r3,[r1,#0]            ;1346
00002a  f42373d0          BIC      r3,r3,#0x1a0          ;1346
00002e  600b              STR      r3,[r1,#0]            ;1346
000030  6821              LDR      r1,[r4,#0]            ;1347
000032  688b              LDR      r3,[r1,#8]            ;1347
000034  f0230301          BIC      r3,r3,#1              ;1347
000038  608b              STR      r3,[r1,#8]            ;1347
00003a  66e0              STR      r0,[r4,#0x6c]         ;1349
00003c  6720              STR      r0,[r4,#0x70]         ;1350
00003e  2003              MOVS     r0,#3
000040  66a2              STR      r2,[r4,#0x68]
                  |L45.66|
;;;1355         }
;;;1356       }
;;;1357     }
;;;1358     return HAL_OK;
;;;1359   }
000042  e8bd81f0          POP      {r4-r8,pc}
                  |L45.70|
000046  6820              LDR      r0,[r4,#0]            ;1338
000048  69c0              LDR      r0,[r0,#0x1c]         ;1338
00004a  ea360000          BICS     r0,r6,r0              ;1338
00004e  d004              BEQ      |L45.90|
000050  2000              MOVS     r0,#0                 ;1338
                  |L45.82|
000052  42b8              CMP      r0,r7                 ;1338
000054  d0dc              BEQ      |L45.16|
000056  2000              MOVS     r0,#0                 ;1358
000058  e7f3              B        |L45.66|
                  |L45.90|
00005a  2001              MOVS     r0,#1                 ;1338
00005c  e7f9              B        |L45.82|
;;;1360   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F7_V1.11.0\\Drivers\\STM32F7xx_HAL_Driver\\Src\\stm32f7xx_hal_uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f7xx_hal_uart_c_d497114f____REV16|
#line 468 "D:\\Program_Files_x86\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.3.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___20_stm32f7xx_hal_uart_c_d497114f____REV16| PROC
#line 469

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f7xx_hal_uart_c_d497114f____REVSH|
#line 483
|__asm___20_stm32f7xx_hal_uart_c_d497114f____REVSH| PROC
#line 484

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f7xx_hal_uart_c_d497114f____RRX|
#line 670
|__asm___20_stm32f7xx_hal_uart_c_d497114f____RRX| PROC
#line 671

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
