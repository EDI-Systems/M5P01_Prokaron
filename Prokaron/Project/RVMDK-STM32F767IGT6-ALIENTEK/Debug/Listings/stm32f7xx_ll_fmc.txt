; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f7xx_ll_fmc.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f7xx_ll_fmc.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Core -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Inc -I.\Source -I.\Drivers -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6-ALIENTEK\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f7xx_ll_fmc.crf ..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_ll_fmc.c]
                          THUMB

                          AREA ||i.FMC_NAND_AttributeSpace_Timing_Init||, CODE, READONLY, ALIGN=1

                  FMC_NAND_AttributeSpace_Timing_Init PROC
;;;554      */
;;;555    HAL_StatusTypeDef FMC_NAND_AttributeSpace_Timing_Init(FMC_NAND_TypeDef *Device, FMC_NAND_PCC_TimingTypeDef *Timing, uint32_t Bank)
000000  b530              PUSH     {r4,r5,lr}
;;;556    {
;;;557      uint32_t tmpr = 0;  
;;;558      
;;;559      /* Check the parameters */ 
;;;560      assert_param(IS_FMC_NAND_DEVICE(Device)); 
;;;561      assert_param(IS_FMC_SETUP_TIME(Timing->SetupTime));
;;;562      assert_param(IS_FMC_WAIT_TIME(Timing->WaitSetupTime));
;;;563      assert_param(IS_FMC_HOLD_TIME(Timing->HoldSetupTime));
;;;564      assert_param(IS_FMC_HIZ_TIME(Timing->HiZSetupTime));
;;;565      assert_param(IS_FMC_NAND_BANK(Bank));
;;;566      
;;;567      /* Get the NAND bank 3 register value */
;;;568      tmpr = Device->PATT;
;;;569    
;;;570      /* Clear ATTSETx, ATTWAITx, ATTHOLDx and ATTHIZx bits */
;;;571      tmpr &= ((uint32_t)~(FMC_PATT_ATTSET3  | FMC_PATT_ATTWAIT3 | FMC_PATT_ATTHOLD3 | \
;;;572                           FMC_PATT_ATTHIZ3));
;;;573      /* Set FMC_NAND device timing parameters */
;;;574      tmpr |= (uint32_t)(Timing->SetupTime                  |\
000002  890c              LDRH     r4,[r1,#8]
000004  e9d12300          LDRD     r2,r3,[r1,#0]
000008  7b0d              LDRB     r5,[r1,#0xc]
00000a  68c1              LDR      r1,[r0,#0xc]          ;568
00000c  0424              LSLS     r4,r4,#16
00000e  ea422103          ORR      r1,r2,r3,LSL #8
000012  ea446205          ORR      r2,r4,r5,LSL #24
000016  4311              ORRS     r1,r1,r2
;;;575                       ((Timing->WaitSetupTime) << 8)     |\
;;;576                       ((Timing->HoldSetupTime) << 16)    |\
;;;577                       ((Timing->HiZSetupTime) << 24));
;;;578                           
;;;579        /* NAND bank 3 registers configuration */
;;;580        Device->PATT = tmpr;
000018  60c1              STR      r1,[r0,#0xc]
;;;581      
;;;582      return HAL_OK;
00001a  2000              MOVS     r0,#0
;;;583    }
00001c  bd30              POP      {r4,r5,pc}
;;;584    
                          ENDP


                          AREA ||i.FMC_NAND_CommonSpace_Timing_Init||, CODE, READONLY, ALIGN=1

                  FMC_NAND_CommonSpace_Timing_Init PROC
;;;515      */
;;;516    HAL_StatusTypeDef FMC_NAND_CommonSpace_Timing_Init(FMC_NAND_TypeDef *Device, FMC_NAND_PCC_TimingTypeDef *Timing, uint32_t Bank)
000000  b530              PUSH     {r4,r5,lr}
;;;517    {
;;;518      uint32_t tmpr = 0;  
;;;519      
;;;520      /* Check the parameters */
;;;521      assert_param(IS_FMC_NAND_DEVICE(Device));
;;;522      assert_param(IS_FMC_SETUP_TIME(Timing->SetupTime));
;;;523      assert_param(IS_FMC_WAIT_TIME(Timing->WaitSetupTime));
;;;524      assert_param(IS_FMC_HOLD_TIME(Timing->HoldSetupTime));
;;;525      assert_param(IS_FMC_HIZ_TIME(Timing->HiZSetupTime));
;;;526      assert_param(IS_FMC_NAND_BANK(Bank));
;;;527      
;;;528      /* Get the NAND bank 3 register value */
;;;529      tmpr = Device->PMEM;
;;;530    
;;;531      /* Clear MEMSETx, MEMWAITx, MEMHOLDx and MEMHIZx bits */
;;;532      tmpr &= ((uint32_t)~(FMC_PMEM_MEMSET3  | FMC_PMEM_MEMWAIT3 | FMC_PMEM_MEMHOLD3 | \
;;;533                           FMC_PMEM_MEMHIZ3)); 
;;;534      /* Set FMC_NAND device timing parameters */
;;;535      tmpr |= (uint32_t)(Timing->SetupTime                  |\
000002  890c              LDRH     r4,[r1,#8]
000004  e9d12300          LDRD     r2,r3,[r1,#0]
000008  7b0d              LDRB     r5,[r1,#0xc]
00000a  6881              LDR      r1,[r0,#8]            ;529
00000c  0424              LSLS     r4,r4,#16
00000e  ea422103          ORR      r1,r2,r3,LSL #8
000012  ea446205          ORR      r2,r4,r5,LSL #24
000016  4311              ORRS     r1,r1,r2
;;;536                           ((Timing->WaitSetupTime) << 8)     |\
;;;537                           ((Timing->HoldSetupTime) << 16)    |\
;;;538                           ((Timing->HiZSetupTime) << 24)
;;;539                           );
;;;540                                
;;;541        /* NAND bank 3 registers configuration */
;;;542        Device->PMEM = tmpr;
000018  6081              STR      r1,[r0,#8]
;;;543      
;;;544      return HAL_OK;  
00001a  2000              MOVS     r0,#0
;;;545    }
00001c  bd30              POP      {r4,r5,pc}
;;;546    
                          ENDP


                          AREA ||i.FMC_NAND_DeInit||, CODE, READONLY, ALIGN=1

                  FMC_NAND_DeInit PROC
;;;590      */
;;;591    HAL_StatusTypeDef FMC_NAND_DeInit(FMC_NAND_TypeDef *Device, uint32_t Bank)
000000  b510              PUSH     {r4,lr}
;;;592    {
;;;593      /* Check the parameters */ 
;;;594      assert_param(IS_FMC_NAND_DEVICE(Device)); 
;;;595      assert_param(IS_FMC_NAND_BANK(Bank));
;;;596          
;;;597      /* Disable the NAND Bank */
;;;598      __FMC_NAND_DISABLE(Device);
000002  6804              LDR      r4,[r0,#0]
;;;599     
;;;600        /* Set the FMC_NAND_BANK3 registers to their reset values */
;;;601        Device->PCR  = 0x00000018U;
000004  2318              MOVS     r3,#0x18
;;;602        Device->SR   = 0x00000040U;
000006  2240              MOVS     r2,#0x40
;;;603        Device->PMEM = 0xFCFCFCFCU;
000008  f04f31fc          MOV      r1,#0xfcfcfcfc
00000c  f0240404          BIC      r4,r4,#4              ;598
000010  6004              STR      r4,[r0,#0]            ;598
000012  6003              STR      r3,[r0,#0]            ;601
000014  6042              STR      r2,[r0,#4]            ;602
000016  6081              STR      r1,[r0,#8]
;;;604        Device->PATT = 0xFCFCFCFCU; 
000018  60c1              STR      r1,[r0,#0xc]
;;;605      
;;;606      return HAL_OK;
00001a  2000              MOVS     r0,#0
;;;607    }
00001c  bd10              POP      {r4,pc}
;;;608    
                          ENDP


                          AREA ||i.FMC_NAND_ECC_Disable||, CODE, READONLY, ALIGN=1

                  FMC_NAND_ECC_Disable PROC
;;;653      */  
;;;654    HAL_StatusTypeDef FMC_NAND_ECC_Disable(FMC_NAND_TypeDef *Device, uint32_t Bank)  
000000  6801              LDR      r1,[r0,#0]
;;;655    {  
;;;656      /* Check the parameters */ 
;;;657      assert_param(IS_FMC_NAND_DEVICE(Device)); 
;;;658      assert_param(IS_FMC_NAND_BANK(Bank));
;;;659        
;;;660      /* Disable ECC feature */
;;;661        Device->PCR &= ~FMC_PCR_ECCEN;
000002  f0210140          BIC      r1,r1,#0x40
000006  6001              STR      r1,[r0,#0]
;;;662    
;;;663      return HAL_OK;  
000008  2000              MOVS     r0,#0
;;;664    }
00000a  4770              BX       lr
;;;665    
                          ENDP


                          AREA ||i.FMC_NAND_ECC_Enable||, CODE, READONLY, ALIGN=1

                  FMC_NAND_ECC_Enable PROC
;;;634      */    
;;;635    HAL_StatusTypeDef FMC_NAND_ECC_Enable(FMC_NAND_TypeDef *Device, uint32_t Bank)
000000  6801              LDR      r1,[r0,#0]
;;;636    {
;;;637      /* Check the parameters */ 
;;;638      assert_param(IS_FMC_NAND_DEVICE(Device)); 
;;;639      assert_param(IS_FMC_NAND_BANK(Bank));
;;;640        
;;;641      /* Enable ECC feature */
;;;642        Device->PCR |= FMC_PCR_ECCEN;
000002  f0410140          ORR      r1,r1,#0x40
000006  6001              STR      r1,[r0,#0]
;;;643      
;;;644      return HAL_OK;  
000008  2000              MOVS     r0,#0
;;;645    }
00000a  4770              BX       lr
;;;646    
                          ENDP


                          AREA ||i.FMC_NAND_GetECC||, CODE, READONLY, ALIGN=1

                  FMC_NAND_GetECC PROC
;;;673      */
;;;674    HAL_StatusTypeDef FMC_NAND_GetECC(FMC_NAND_TypeDef *Device, uint32_t *ECCval, uint32_t Bank, uint32_t Timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;675    {
000004  461c              MOV      r4,r3
000006  460f              MOV      r7,r1
000008  4605              MOV      r5,r0
;;;676      uint32_t tickstart = 0;
;;;677    
;;;678      /* Check the parameters */ 
;;;679      assert_param(IS_FMC_NAND_DEVICE(Device)); 
;;;680      assert_param(IS_FMC_NAND_BANK(Bank));
;;;681    
;;;682      /* Get tick */ 
;;;683      tickstart = HAL_GetTick();
00000a  f7fffffe          BL       HAL_GetTick
00000e  4606              MOV      r6,r0
;;;684    
;;;685      /* Wait until FIFO is empty */
;;;686      while(__FMC_NAND_GET_FLAG(Device, Bank, FMC_FLAG_FEMPT) == RESET)
000010  e00a              B        |L6.40|
                  |L6.18|
;;;687      {
;;;688        /* Check for the Timeout */
;;;689        if(Timeout != HAL_MAX_DELAY)
000012  1c60              ADDS     r0,r4,#1
000014  d008              BEQ      |L6.40|
;;;690        {
;;;691          if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
000016  b124              CBZ      r4,|L6.34|
000018  f7fffffe          BL       HAL_GetTick
00001c  1b80              SUBS     r0,r0,r6
00001e  42a0              CMP      r0,r4
000020  d902              BLS      |L6.40|
                  |L6.34|
;;;692          {
;;;693            return HAL_TIMEOUT;
000022  2003              MOVS     r0,#3
                  |L6.36|
;;;694          }
;;;695        }  
;;;696      }
;;;697     
;;;698      /* Get the ECCR register value */
;;;699      *ECCval = (uint32_t)Device->ECCR;
;;;700    
;;;701      return HAL_OK;  
;;;702    }
000024  e8bd81f0          POP      {r4-r8,pc}
                  |L6.40|
000028  6868              LDR      r0,[r5,#4]            ;686
00002a  43c0              MVNS     r0,r0                 ;686
00002c  0640              LSLS     r0,r0,#25             ;686
00002e  d4f0              BMI      |L6.18|
000030  6968              LDR      r0,[r5,#0x14]         ;699
000032  6038              STR      r0,[r7,#0]            ;701
000034  2000              MOVS     r0,#0                 ;701
000036  e7f5              B        |L6.36|
;;;703    
                          ENDP


                          AREA ||i.FMC_NAND_Init||, CODE, READONLY, ALIGN=2

                  FMC_NAND_Init PROC
;;;470      */
;;;471    HAL_StatusTypeDef FMC_NAND_Init(FMC_NAND_TypeDef *Device, FMC_NAND_InitTypeDef *Init)
000000  b570              PUSH     {r4-r6,lr}
;;;472    {
000002  e9d12501          LDRD     r2,r5,[r1,#4]
;;;473      uint32_t tmpr  = 0; 
;;;474        
;;;475      /* Check the parameters */
;;;476      assert_param(IS_FMC_NAND_DEVICE(Device));
;;;477      assert_param(IS_FMC_NAND_BANK(Init->NandBank));
;;;478      assert_param(IS_FMC_WAIT_FEATURE(Init->Waitfeature));
;;;479      assert_param(IS_FMC_NAND_MEMORY_WIDTH(Init->MemoryDataWidth));
;;;480      assert_param(IS_FMC_ECC_STATE(Init->EccComputation));
;;;481      assert_param(IS_FMC_ECCPAGE_SIZE(Init->ECCPageSize));
;;;482      assert_param(IS_FMC_TCLR_TIME(Init->TCLRSetupTime));
;;;483      assert_param(IS_FMC_TAR_TIME(Init->TARSetupTime));   
;;;484    
;;;485      /* Get the NAND bank 3 register value */
;;;486      tmpr = Device->PCR;
;;;487    
;;;488      /* Clear PWAITEN, PBKEN, PTYP, PWID, ECCEN, TCLR, TAR and ECCPS bits */
;;;489      tmpr &= ((uint32_t)~(FMC_PCR_PWAITEN  | FMC_PCR_PBKEN | FMC_PCR_PTYP | \
;;;490                           FMC_PCR_PWID | FMC_PCR_ECCEN | FMC_PCR_TCLR | \
;;;491                           FMC_PCR_TAR | FMC_PCR_ECCPS));  
;;;492      /* Set NAND device control parameters */
;;;493      tmpr |= (uint32_t)(Init->Waitfeature                |\
000006  e9d13603          LDRD     r3,r6,[r1,#0xc]
00000a  432a              ORRS     r2,r2,r5
00000c  e9d14505          LDRD     r4,r5,[r1,#0x14]
000010  6801              LDR      r1,[r0,#0]            ;486
000012  4333              ORRS     r3,r3,r6
000014  431a              ORRS     r2,r2,r3
000016  4b06              LDR      r3,|L7.48|
000018  ea422244          ORR      r2,r2,r4,LSL #9
00001c  4019              ANDS     r1,r1,r3              ;489
00001e  ea423245          ORR      r2,r2,r5,LSL #13
000022  430a              ORRS     r2,r2,r1
000024  f0420108          ORR      r1,r2,#8
;;;494                          FMC_PCR_MEMORY_TYPE_NAND         |\
;;;495                          Init->MemoryDataWidth            |\
;;;496                          Init->EccComputation             |\
;;;497                          Init->ECCPageSize                |\
;;;498                          ((Init->TCLRSetupTime) << 9)     |\
;;;499                          ((Init->TARSetupTime) << 13));   
;;;500      
;;;501        /* NAND bank 3 registers configuration */
;;;502        Device->PCR  = tmpr;
000028  6001              STR      r1,[r0,#0]
;;;503      
;;;504      return HAL_OK;
00002a  2000              MOVS     r0,#0
;;;505    
;;;506    }
00002c  bd70              POP      {r4-r6,pc}
;;;507    
                          ENDP

00002e  0000              DCW      0x0000
                  |L7.48|
                          DCD      0xfff00181

                          AREA ||i.FMC_NORSRAM_DeInit||, CODE, READONLY, ALIGN=2

                  FMC_NORSRAM_DeInit PROC
;;;224      */
;;;225    HAL_StatusTypeDef FMC_NORSRAM_DeInit(FMC_NORSRAM_TypeDef *Device, FMC_NORSRAM_EXTENDED_TypeDef *ExDevice, uint32_t Bank)
000000  f8503022          LDR      r3,[r0,r2,LSL #2]
;;;226    {
;;;227      /* Check the parameters */
;;;228      assert_param(IS_FMC_NORSRAM_DEVICE(Device));
;;;229      assert_param(IS_FMC_NORSRAM_EXTENDED_DEVICE(ExDevice));
;;;230      assert_param(IS_FMC_NORSRAM_BANK(Bank));
;;;231      
;;;232      /* Disable the FMC_NORSRAM device */
;;;233      __FMC_NORSRAM_DISABLE(Device, Bank);
000004  f0230301          BIC      r3,r3,#1
000008  f8403022          STR      r3,[r0,r2,LSL #2]
00000c  b16a              CBZ      r2,|L8.42|
;;;234      
;;;235      /* De-initialize the FMC_NORSRAM device */
;;;236      /* FMC_NORSRAM_BANK1 */
;;;237      if(Bank == FMC_NORSRAM_BANK1)
;;;238      {
;;;239        Device->BTCR[Bank] = 0x000030DB;    
;;;240      }
;;;241      /* FMC_NORSRAM_BANK2, FMC_NORSRAM_BANK3 or FMC_NORSRAM_BANK4 */
;;;242      else
;;;243      {   
;;;244        Device->BTCR[Bank] = 0x000030D2; 
00000e  f24303d2          MOV      r3,#0x30d2
000012  f8403022          STR      r3,[r0,r2,LSL #2]
;;;245      }
;;;246      
;;;247      Device->BTCR[Bank + 1] = 0x0FFFFFFF;
000016  bf00              NOP      
                  |L8.24|
000018  eb000082          ADD      r0,r0,r2,LSL #2
00001c  f06f4370          MVN      r3,#0xf0000000
000020  6043              STR      r3,[r0,#4]
;;;248      ExDevice->BWTR[Bank]   = 0x0FFFFFFF;
000022  f8413022          STR      r3,[r1,r2,LSL #2]
;;;249       
;;;250      return HAL_OK;
000026  2000              MOVS     r0,#0
;;;251    }
000028  4770              BX       lr
                  |L8.42|
00002a  f24303db          MOV      r3,#0x30db            ;239
00002e  6003              STR      r3,[r0,#0]            ;239
000030  e7f2              B        |L8.24|
;;;252    
                          ENDP


                          AREA ||i.FMC_NORSRAM_Extended_Timing_Init||, CODE, READONLY, ALIGN=2

                  FMC_NORSRAM_Extended_Timing_Init PROC
;;;315      */
;;;316    HAL_StatusTypeDef  FMC_NORSRAM_Extended_Timing_Init(FMC_NORSRAM_EXTENDED_TypeDef *Device, FMC_NORSRAM_TimingTypeDef *Timing, uint32_t Bank, uint32_t ExtendedMode)
000000  b5f0              PUSH     {r4-r7,lr}
;;;317    {  
;;;318      uint32_t tmpr = 0;
;;;319     
;;;320      /* Check the parameters */
;;;321      assert_param(IS_FMC_EXTENDED_MODE(ExtendedMode));
;;;322      
;;;323      /* Set NORSRAM device timing register for write configuration, if extended mode is used */
;;;324      if(ExtendedMode == FMC_EXTENDED_MODE_ENABLE)
000002  f5b34f80          CMP      r3,#0x4000
000006  d005              BEQ      |L9.20|
;;;325      {
;;;326        /* Check the parameters */
;;;327        assert_param(IS_FMC_NORSRAM_EXTENDED_DEVICE(Device));  
;;;328        assert_param(IS_FMC_ADDRESS_SETUP_TIME(Timing->AddressSetupTime));
;;;329        assert_param(IS_FMC_ADDRESS_HOLD_TIME(Timing->AddressHoldTime));
;;;330        assert_param(IS_FMC_DATASETUP_TIME(Timing->DataSetupTime));
;;;331        assert_param(IS_FMC_TURNAROUND_TIME(Timing->BusTurnAroundDuration));
;;;332        assert_param(IS_FMC_CLK_DIV(Timing->CLKDivision));
;;;333        assert_param(IS_FMC_DATA_LATENCY(Timing->DataLatency));
;;;334        assert_param(IS_FMC_ACCESS_MODE(Timing->AccessMode));
;;;335        assert_param(IS_FMC_NORSRAM_BANK(Bank));  
;;;336        
;;;337        /* Get the BWTR register value */
;;;338        tmpr = Device->BWTR[Bank];
;;;339    
;;;340        /* Clear ADDSET, ADDHLD, DATAST, BUSTURN, CLKDIV, DATLAT and ACCMOD bits */
;;;341        tmpr &= ((uint32_t)~(FMC_BWTR1_ADDSET  | FMC_BWTR1_ADDHLD | FMC_BWTR1_DATAST | \
;;;342                             FMC_BWTR1_BUSTURN | FMC_BWTR1_ACCMOD));
;;;343        
;;;344        tmpr |= (uint32_t)(Timing->AddressSetupTime                 |\
;;;345                          ((Timing->AddressHoldTime) << 4)          |\
;;;346                          ((Timing->DataSetupTime) << 8)            |\
;;;347                          ((Timing->BusTurnAroundDuration) << 16)   |\
;;;348                          (Timing->AccessMode));
;;;349    
;;;350        Device->BWTR[Bank] = tmpr;
;;;351      }
;;;352      else
;;;353      {
;;;354        Device->BWTR[Bank] = 0x0FFFFFFF;
000008  f06f4170          MVN      r1,#0xf0000000
00000c  f8401022          STR      r1,[r0,r2,LSL #2]
                  |L9.16|
;;;355      }   
;;;356      
;;;357      return HAL_OK;  
000010  2000              MOVS     r0,#0
;;;358    }
000012  bdf0              POP      {r4-r7,pc}
                  |L9.20|
000014  688c              LDR      r4,[r1,#8]            ;344
000016  898e              LDRH     r6,[r1,#0xc]          ;344
000018  e9d13700          LDRD     r3,r7,[r1,#0]         ;344
00001c  0225              LSLS     r5,r4,#8              ;344
00001e  698c              LDR      r4,[r1,#0x18]         ;338
000020  f8501022          LDR      r1,[r0,r2,LSL #2]     ;338
000024  ea454506          ORR      r5,r5,r6,LSL #16      ;344
000028  ea431307          ORR      r3,r3,r7,LSL #4       ;344
00002c  4f03              LDR      r7,|L9.60|
00002e  432b              ORRS     r3,r3,r5              ;344
000030  4039              ANDS     r1,r1,r7              ;341
000032  4323              ORRS     r3,r3,r4              ;344
000034  430b              ORRS     r3,r3,r1              ;344
000036  f8403022          STR      r3,[r0,r2,LSL #2]     ;350
00003a  e7e9              B        |L9.16|
;;;359    /**
                          ENDP

                  |L9.60|
                          DCD      0xcff00000

                          AREA ||i.FMC_NORSRAM_Init||, CODE, READONLY, ALIGN=2

                  FMC_NORSRAM_Init PROC
;;;147      */
;;;148    HAL_StatusTypeDef  FMC_NORSRAM_Init(FMC_NORSRAM_TypeDef *Device, FMC_NORSRAM_InitTypeDef* Init)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;149    { 
;;;150      uint32_t tmpr = 0;
;;;151        
;;;152      /* Check the parameters */
;;;153      assert_param(IS_FMC_NORSRAM_DEVICE(Device));
;;;154      assert_param(IS_FMC_NORSRAM_BANK(Init->NSBank));
;;;155      assert_param(IS_FMC_MUX(Init->DataAddressMux));
;;;156      assert_param(IS_FMC_MEMORY(Init->MemoryType));
;;;157      assert_param(IS_FMC_NORSRAM_MEMORY_WIDTH(Init->MemoryDataWidth));
;;;158      assert_param(IS_FMC_BURSTMODE(Init->BurstAccessMode));
;;;159      assert_param(IS_FMC_WAIT_POLARITY(Init->WaitSignalPolarity));
;;;160      assert_param(IS_FMC_WAIT_SIGNAL_ACTIVE(Init->WaitSignalActive));
;;;161      assert_param(IS_FMC_WRITE_OPERATION(Init->WriteOperation));
;;;162      assert_param(IS_FMC_WAITE_SIGNAL(Init->WaitSignal));
;;;163      assert_param(IS_FMC_EXTENDED_MODE(Init->ExtendedMode));
;;;164      assert_param(IS_FMC_ASYNWAIT(Init->AsynchronousWait));
;;;165      assert_param(IS_FMC_WRITE_BURST(Init->WriteBurst));
;;;166      assert_param(IS_FMC_CONTINOUS_CLOCK(Init->ContinuousClock)); 
;;;167      assert_param(IS_FMC_WRITE_FIFO(Init->WriteFifo));
;;;168      assert_param(IS_FMC_PAGESIZE(Init->PageSize));
;;;169    
;;;170      /* Get the BTCR register value */
;;;171      tmpr = Device->BTCR[Init->NSBank];
;;;172      
;;;173      /* Clear MBKEN, MUXEN, MTYP, MWID, FACCEN, BURSTEN, WAITPOL, WAITCFG, WREN,
;;;174               WAITEN, EXTMOD, ASYNCWAIT, CBURSTRW and CCLKEN bits */
;;;175      tmpr &= ((uint32_t)~(FMC_BCR1_MBKEN     | FMC_BCR1_MUXEN    | FMC_BCR1_MTYP     | \
;;;176                           FMC_BCR1_MWID      | FMC_BCR1_FACCEN   | FMC_BCR1_BURSTEN  | \
;;;177                           FMC_BCR1_WAITPOL   | FMC_BCR1_CPSIZE    | FMC_BCR1_WAITCFG  | \
;;;178                           FMC_BCR1_WREN      | FMC_BCR1_WAITEN   | FMC_BCR1_EXTMOD   | \
;;;179                           FMC_BCR1_ASYNCWAIT | FMC_BCR1_CBURSTRW | FMC_BCR1_CCLKEN | FMC_BCR1_WFDIS));
;;;180      
;;;181      /* Set NORSRAM device control parameters */
;;;182      tmpr |= (uint32_t)(Init->DataAddressMux       |\
000004  e9d1c802          LDRD     r12,r8,[r1,#8]
000008  684a              LDR      r2,[r1,#4]
00000a  e9d15304          LDRD     r5,r3,[r1,#0x10]
00000e  ea42020c          ORR      r2,r2,r12
000012  ea480805          ORR      r8,r8,r5
000016  ea420208          ORR      r2,r2,r8
00001a  ea420203          ORR      r2,r2,r3
00001e  f8513b18          LDR      r3,[r1],#0x18         ;171
;;;183                        Init->MemoryType           |\
;;;184                        Init->MemoryDataWidth      |\
;;;185                        Init->BurstAccessMode      |\
;;;186                        Init->WaitSignalPolarity   |\
;;;187                        Init->WaitSignalActive     |\
;;;188                        Init->WriteOperation       |\
;;;189                        Init->WaitSignal           |\
;;;190                        Init->ExtendedMode         |\
;;;191                        Init->AsynchronousWait     |\
;;;192                        Init->WriteBurst           |\
;;;193                        Init->ContinuousClock      |\
;;;194                        Init->PageSize             |\
;;;195                        Init->WriteFifo);
;;;196                        
;;;197      if(Init->MemoryType == FMC_MEMORY_TYPE_NOR)
000022  f1bc0f08          CMP      r12,#8
000026  4699              MOV      r9,r3                 ;171
000028  e89111f0          LDM      r1,{r4-r8,r12}        ;171
00002c  f8503023          LDR      r3,[r0,r3,LSL #2]     ;171
000030  ea420204          ORR      r2,r2,r4              ;182
000034  698c              LDR      r4,[r1,#0x18]         ;171
000036  ea420205          ORR      r2,r2,r5              ;182
00003a  6a0d              LDR      r5,[r1,#0x20]         ;171
00003c  ea420206          ORR      r2,r2,r6              ;182
000040  69ce              LDR      r6,[r1,#0x1c]         ;182
000042  ea420207          ORR      r2,r2,r7              ;182
000046  4f14              LDR      r7,|L10.152|
000048  ea420208          ORR      r2,r2,r8              ;182
00004c  ea42020c          ORR      r2,r2,r12             ;182
000050  ea420204          ORR      r2,r2,r4              ;182
000054  ea420205          ORR      r2,r2,r5              ;182
000058  ea030307          AND      r3,r3,r7              ;175
00005c  ea420206          ORR      r2,r2,r6              ;182
000060  ea420203          ORR      r2,r2,r3              ;182
000064  f1a10118          SUB      r1,r1,#0x18           ;182
000068  d101              BNE      |L10.110|
;;;198      {
;;;199        tmpr |= (uint32_t)FMC_NORSRAM_FLASH_ACCESS_ENABLE;
00006a  f0420240          ORR      r2,r2,#0x40
                  |L10.110|
;;;200      }
;;;201      
;;;202      Device->BTCR[Init->NSBank] = tmpr;
00006e  f8402029          STR      r2,[r0,r9,LSL #2]
;;;203    
;;;204      /* Configure synchronous mode when Continuous clock is enabled for bank2..4 */
;;;205      if((Init->ContinuousClock == FMC_CONTINUOUS_CLOCK_SYNC_ASYNC) && (Init->NSBank != FMC_NORSRAM_BANK1))
000072  6b0a              LDR      r2,[r1,#0x30]
000074  f5b21f80          CMP      r2,#0x100000
000078  d105              BNE      |L10.134|
00007a  680a              LDR      r2,[r1,#0]
00007c  b14a              CBZ      r2,|L10.146|
;;;206      { 
;;;207        Device->BTCR[FMC_NORSRAM_BANK1] |= (uint32_t)(Init->ContinuousClock);
00007e  6802              LDR      r2,[r0,#0]
000080  f4421280          ORR      r2,r2,#0x100000
000084  6002              STR      r2,[r0,#0]
                  |L10.134|
;;;208      }
;;;209      if(Init->NSBank != FMC_NORSRAM_BANK1)
000086  680a              LDR      r2,[r1,#0]
000088  b11a              CBZ      r2,|L10.146|
;;;210      {
;;;211        Device->BTCR[FMC_NORSRAM_BANK1] |= (uint32_t)(Init->WriteFifo);              
00008a  6802              LDR      r2,[r0,#0]
00008c  6b49              LDR      r1,[r1,#0x34]
00008e  430a              ORRS     r2,r2,r1
000090  6002              STR      r2,[r0,#0]
                  |L10.146|
;;;212      }
;;;213      
;;;214      return HAL_OK;
000092  2000              MOVS     r0,#0
;;;215    }
000094  e8bd83f0          POP      {r4-r9,pc}
;;;216    
                          ENDP

                  |L10.152|
                          DCD      0xffc00480

                          AREA ||i.FMC_NORSRAM_Timing_Init||, CODE, READONLY, ALIGN=2

                  FMC_NORSRAM_Timing_Init PROC
;;;261      */
;;;262    HAL_StatusTypeDef FMC_NORSRAM_Timing_Init(FMC_NORSRAM_TypeDef *Device, FMC_NORSRAM_TimingTypeDef *Timing, uint32_t Bank)
000000  b5f0              PUSH     {r4-r7,lr}
;;;263    {
;;;264      uint32_t tmpr = 0;
;;;265      
;;;266      /* Check the parameters */
;;;267      assert_param(IS_FMC_NORSRAM_DEVICE(Device));
;;;268      assert_param(IS_FMC_ADDRESS_SETUP_TIME(Timing->AddressSetupTime));
;;;269      assert_param(IS_FMC_ADDRESS_HOLD_TIME(Timing->AddressHoldTime));
;;;270      assert_param(IS_FMC_DATASETUP_TIME(Timing->DataSetupTime));
;;;271      assert_param(IS_FMC_TURNAROUND_TIME(Timing->BusTurnAroundDuration));
;;;272      assert_param(IS_FMC_CLK_DIV(Timing->CLKDivision));
;;;273      assert_param(IS_FMC_DATA_LATENCY(Timing->DataLatency));
;;;274      assert_param(IS_FMC_ACCESS_MODE(Timing->AccessMode));
;;;275      assert_param(IS_FMC_NORSRAM_BANK(Bank));
;;;276      
;;;277      /* Get the BTCR register value */
;;;278      tmpr = Device->BTCR[Bank + 1];
;;;279    
;;;280      /* Clear ADDSET, ADDHLD, DATAST, BUSTURN, CLKDIV, DATLAT and ACCMOD bits */
;;;281      tmpr &= ((uint32_t)~(FMC_BTR1_ADDSET  | FMC_BTR1_ADDHLD | FMC_BTR1_DATAST | \
;;;282                           FMC_BTR1_BUSTURN | FMC_BTR1_CLKDIV | FMC_BTR1_DATLAT | \
;;;283                           FMC_BTR1_ACCMOD));
;;;284      
;;;285      /* Set FMC_NORSRAM device timing parameters */  
;;;286      tmpr |= (uint32_t)(Timing->AddressSetupTime                  |\
000002  688c              LDR      r4,[r1,#8]
000004  eb000282          ADD      r2,r0,r2,LSL #2       ;278
000008  f8b1c00c          LDRH     r12,[r1,#0xc]
00000c  e9d13600          LDRD     r3,r6,[r1,#0]
000010  8a0d              LDRH     r5,[r1,#0x10]
000012  0227              LSLS     r7,r4,#8
000014  4c12              LDR      r4,|L11.96|
000016  ea47470c          ORR      r7,r7,r12,LSL #16
00001a  ea431306          ORR      r3,r3,r6,LSL #4
00001e  7d0e              LDRB     r6,[r1,#0x14]
000020  433b              ORRS     r3,r3,r7
000022  eb045c05          ADD      r12,r4,r5,LSL #20
000026  6855              LDR      r5,[r2,#4]            ;278
000028  0167              LSLS     r7,r4,#5
00002a  f8d1e018          LDR      lr,[r1,#0x18]
00002e  ea43030c          ORR      r3,r3,r12
000032  eb076606          ADD      r6,r7,r6,LSL #24
000036  4333              ORRS     r3,r3,r6
000038  f0054540          AND      r5,r5,#0xc0000000     ;281
00003c  ea43030e          ORR      r3,r3,lr
000040  432b              ORRS     r3,r3,r5
;;;287                       ((Timing->AddressHoldTime) << 4)          |\
;;;288                       ((Timing->DataSetupTime) << 8)            |\
;;;289                       ((Timing->BusTurnAroundDuration) << 16)   |\
;;;290                       (((Timing->CLKDivision)-1) << 20)         |\
;;;291                       (((Timing->DataLatency)-2) << 24)         |\
;;;292                        (Timing->AccessMode)
;;;293                        );
;;;294      
;;;295      Device->BTCR[Bank + 1] = tmpr;
000042  6053              STR      r3,[r2,#4]
;;;296      
;;;297      /* Configure Clock division value (in NORSRAM bank 1) when continuous clock is enabled */
;;;298      if(HAL_IS_BIT_SET(Device->BTCR[FMC_NORSRAM_BANK1], FMC_BCR1_CCLKEN))
000044  6802              LDR      r2,[r0,#0]
000046  02d2              LSLS     r2,r2,#11
000048  d507              BPL      |L11.90|
;;;299      {
;;;300        tmpr = (uint32_t)(Device->BTCR[FMC_NORSRAM_BANK1 + 1] & ~(((uint32_t)0x0F) << 20)); 
;;;301        tmpr |= (uint32_t)(((Timing->CLKDivision)-1) << 20);
00004a  8a09              LDRH     r1,[r1,#0x10]
00004c  6842              LDR      r2,[r0,#4]            ;300
00004e  eb045101          ADD      r1,r4,r1,LSL #20
000052  f4220270          BIC      r2,r2,#0xf00000       ;300
000056  4311              ORRS     r1,r1,r2
;;;302        Device->BTCR[FMC_NORSRAM_BANK1 + 1] = tmpr;
000058  6041              STR      r1,[r0,#4]
                  |L11.90|
;;;303      }  
;;;304      
;;;305      return HAL_OK;   
00005a  2000              MOVS     r0,#0
;;;306    }
00005c  bdf0              POP      {r4-r7,pc}
;;;307    
                          ENDP

00005e  0000              DCW      0x0000
                  |L11.96|
                          DCD      0xfff00000

                          AREA ||i.FMC_NORSRAM_WriteOperation_Disable||, CODE, READONLY, ALIGN=1

                  FMC_NORSRAM_WriteOperation_Disable PROC
;;;401      */
;;;402    HAL_StatusTypeDef FMC_NORSRAM_WriteOperation_Disable(FMC_NORSRAM_TypeDef *Device, uint32_t Bank)
000000  f8502021          LDR      r2,[r0,r1,LSL #2]
;;;403    { 
;;;404      /* Check the parameters */
;;;405      assert_param(IS_FMC_NORSRAM_DEVICE(Device));
;;;406      assert_param(IS_FMC_NORSRAM_BANK(Bank));
;;;407        
;;;408      /* Disable write operation */
;;;409      Device->BTCR[Bank] &= ~FMC_WRITE_OPERATION_ENABLE; 
000004  f4225280          BIC      r2,r2,#0x1000
000008  f8402021          STR      r2,[r0,r1,LSL #2]
;;;410    
;;;411      return HAL_OK;  
00000c  2000              MOVS     r0,#0
;;;412    }
00000e  4770              BX       lr
;;;413    
                          ENDP


                          AREA ||i.FMC_NORSRAM_WriteOperation_Enable||, CODE, READONLY, ALIGN=1

                  FMC_NORSRAM_WriteOperation_Enable PROC
;;;383      */
;;;384    HAL_StatusTypeDef FMC_NORSRAM_WriteOperation_Enable(FMC_NORSRAM_TypeDef *Device, uint32_t Bank)
000000  f8502021          LDR      r2,[r0,r1,LSL #2]
;;;385    {
;;;386      /* Check the parameters */
;;;387      assert_param(IS_FMC_NORSRAM_DEVICE(Device));
;;;388      assert_param(IS_FMC_NORSRAM_BANK(Bank));
;;;389      
;;;390      /* Enable write operation */
;;;391      Device->BTCR[Bank] |= FMC_WRITE_OPERATION_ENABLE; 
000004  f4425280          ORR      r2,r2,#0x1000
000008  f8402021          STR      r2,[r0,r1,LSL #2]
;;;392    
;;;393      return HAL_OK;  
00000c  2000              MOVS     r0,#0
;;;394    }
00000e  4770              BX       lr
;;;395    
                          ENDP


                          AREA ||i.FMC_SDRAM_DeInit||, CODE, READONLY, ALIGN=1

                  FMC_SDRAM_DeInit PROC
;;;908      */
;;;909    HAL_StatusTypeDef FMC_SDRAM_DeInit(FMC_SDRAM_TypeDef *Device, uint32_t Bank)
000000  b530              PUSH     {r4,r5,lr}
;;;910    {
;;;911      /* Check the parameters */
;;;912      assert_param(IS_FMC_SDRAM_DEVICE(Device));
;;;913      assert_param(IS_FMC_SDRAM_BANK(Bank));
;;;914      
;;;915      /* De-initialize the SDRAM device */
;;;916      Device->SDCR[Bank] = 0x000002D0;
000002  f44f7334          MOV      r3,#0x2d0
;;;917      Device->SDTR[Bank] = 0x0FFFFFFF;    
;;;918      Device->SDCMR      = 0x00000000;
000006  2200              MOVS     r2,#0
000008  f06f4470          MVN      r4,#0xf0000000        ;917
00000c  eb000581          ADD      r5,r0,r1,LSL #2       ;917
000010  f8403021          STR      r3,[r0,r1,LSL #2]     ;916
000014  60ac              STR      r4,[r5,#8]            ;917
000016  6102              STR      r2,[r0,#0x10]
;;;919      Device->SDRTR      = 0x00000000;
000018  6142              STR      r2,[r0,#0x14]
;;;920      Device->SDSR       = 0x00000000;
00001a  6182              STR      r2,[r0,#0x18]
;;;921    
;;;922      return HAL_OK;
00001c  4610              MOV      r0,r2
;;;923    }
00001e  bd30              POP      {r4,r5,pc}
;;;924    
                          ENDP


                          AREA ||i.FMC_SDRAM_GetModeStatus||, CODE, READONLY, ALIGN=1

                  FMC_SDRAM_GetModeStatus PROC
;;;1054     */
;;;1055   uint32_t FMC_SDRAM_GetModeStatus(FMC_SDRAM_TypeDef *Device, uint32_t Bank)
000000  6980              LDR      r0,[r0,#0x18]
;;;1056   {
000002  b119              CBZ      r1,|L15.12|
;;;1057     uint32_t tmpreg = 0;
;;;1058     
;;;1059     /* Check the parameters */
;;;1060     assert_param(IS_FMC_SDRAM_DEVICE(Device));
;;;1061     assert_param(IS_FMC_SDRAM_BANK(Bank));
;;;1062   
;;;1063     /* Get the corresponding bank mode */
;;;1064     if(Bank == FMC_SDRAM_BANK1)
;;;1065     {
;;;1066       tmpreg = (uint32_t)(Device->SDSR & FMC_SDSR_MODES1); 
;;;1067     }
;;;1068     else
;;;1069     {
;;;1070       tmpreg = ((uint32_t)(Device->SDSR & FMC_SDSR_MODES2) >> 2);
000004  f0000018          AND      r0,r0,#0x18
000008  0880              LSRS     r0,r0,#2
;;;1071     }
;;;1072     
;;;1073     /* Return the mode status */
;;;1074     return tmpreg;
;;;1075   }
00000a  4770              BX       lr
                  |L15.12|
00000c  f0000006          AND      r0,r0,#6              ;1066
000010  4770              BX       lr
;;;1076   
                          ENDP


                          AREA ||i.FMC_SDRAM_Init||, CODE, READONLY, ALIGN=1

                  FMC_SDRAM_Init PROC
;;;757      */
;;;758    HAL_StatusTypeDef FMC_SDRAM_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_InitTypeDef *Init)
000000  b5f0              PUSH     {r4-r7,lr}
;;;759    {
;;;760      uint32_t tmpr1 = 0;
;;;761      uint32_t tmpr2 = 0;
;;;762        
;;;763      /* Check the parameters */
;;;764      assert_param(IS_FMC_SDRAM_DEVICE(Device));
;;;765      assert_param(IS_FMC_SDRAM_BANK(Init->SDBank));
;;;766      assert_param(IS_FMC_COLUMNBITS_NUMBER(Init->ColumnBitsNumber));
;;;767      assert_param(IS_FMC_ROWBITS_NUMBER(Init->RowBitsNumber));
;;;768      assert_param(IS_FMC_SDMEMORY_WIDTH(Init->MemoryDataWidth));
;;;769      assert_param(IS_FMC_INTERNALBANK_NUMBER(Init->InternalBankNumber));
;;;770      assert_param(IS_FMC_CAS_LATENCY(Init->CASLatency));
;;;771      assert_param(IS_FMC_WRITE_PROTECTION(Init->WriteProtection));
;;;772      assert_param(IS_FMC_SDCLOCK_PERIOD(Init->SDClockPeriod));
;;;773      assert_param(IS_FMC_READ_BURST(Init->ReadBurst));
;;;774      assert_param(IS_FMC_READPIPE_DELAY(Init->ReadPipeDelay));   
;;;775    
;;;776      /* Set SDRAM bank configuration parameters */
;;;777      if (Init->SDBank != FMC_SDRAM_BANK2) 
000002  e9d12501          LDRD     r2,r5,[r1,#4]
000006  e9d14303          LDRD     r4,r3,[r1,#0xc]
;;;778      {
;;;779        tmpr1 = Device->SDCR[FMC_SDRAM_BANK1];
;;;780        
;;;781        /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
;;;782        tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
;;;783                              FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP   | \
;;;784                              FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));
;;;785    
;;;786        tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
00000a  e9d17605          LDRD     r7,r6,[r1,#0x14]
00000e  432a              ORRS     r2,r2,r5
000010  f8d1c000          LDR      r12,[r1,#0]           ;777
000014  ea440403          ORR      r4,r4,r3
000018  e9d13507          LDRD     r3,r5,[r1,#0x1c]
00001c  ea420204          ORR      r2,r2,r4
000020  6a49              LDR      r1,[r1,#0x24]
000022  ea420207          ORR      r2,r2,r7
000026  f1bc0f01          CMP      r12,#1                ;777
00002a  ea420206          ORR      r2,r2,r6
00002e  d008              BEQ      |L16.66|
000030  6804              LDR      r4,[r0,#0]            ;779
000032  431a              ORRS     r2,r2,r3
000034  432a              ORRS     r2,r2,r5
000036  430a              ORRS     r2,r2,r1
000038  0be3              LSRS     r3,r4,#15             ;782
00003a  03db              LSLS     r3,r3,#15             ;782
00003c  431a              ORRS     r2,r2,r3
;;;787                            Init->RowBitsNumber      |\
;;;788                            Init->MemoryDataWidth    |\
;;;789                            Init->InternalBankNumber |\
;;;790                            Init->CASLatency         |\
;;;791                            Init->WriteProtection    |\
;;;792                            Init->SDClockPeriod      |\
;;;793                            Init->ReadBurst          |\
;;;794                            Init->ReadPipeDelay
;;;795                            );                                      
;;;796        Device->SDCR[FMC_SDRAM_BANK1] = tmpr1;
00003e  6002              STR      r2,[r0,#0]
000040  e00b              B        |L16.90|
                  |L16.66|
;;;797      }
;;;798      else /* FMC_Bank2_SDRAM */                      
;;;799      {
;;;800        tmpr1 = Device->SDCR[FMC_SDRAM_BANK1];
000042  6806              LDR      r6,[r0,#0]
;;;801        
;;;802        /* Clear SDCLK, RBURST, and RPIPE bits */
;;;803        tmpr1 &= ((uint32_t)~(FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));
;;;804        
;;;805        tmpr1 |= (uint32_t)(Init->SDClockPeriod      |\
;;;806                            Init->ReadBurst          |\
;;;807                            Init->ReadPipeDelay);
;;;808        
;;;809        tmpr2 = Device->SDCR[FMC_SDRAM_BANK2];
000044  6844              LDR      r4,[r0,#4]
000046  432b              ORRS     r3,r3,r5              ;805
000048  f42645f8          BIC      r5,r6,#0x7c00         ;803
00004c  4329              ORRS     r1,r1,r5              ;805
00004e  430b              ORRS     r3,r3,r1              ;805
;;;810        
;;;811        /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
;;;812        tmpr2 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
;;;813                              FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP   | \
;;;814                              FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));
;;;815    
;;;816        tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
;;;817                           Init->RowBitsNumber       |\
;;;818                           Init->MemoryDataWidth     |\
;;;819                           Init->InternalBankNumber  |\
;;;820                           Init->CASLatency          |\
;;;821                           Init->WriteProtection);
;;;822    
;;;823        Device->SDCR[FMC_SDRAM_BANK1] = tmpr1;
000050  6003              STR      r3,[r0,#0]
000052  f36f040e          BFC      r4,#0,#15             ;812
000056  4322              ORRS     r2,r2,r4              ;816
;;;824        Device->SDCR[FMC_SDRAM_BANK2] = tmpr2;
000058  6042              STR      r2,[r0,#4]
                  |L16.90|
;;;825      }
;;;826      
;;;827      return HAL_OK;
00005a  2000              MOVS     r0,#0
;;;828    }
00005c  bdf0              POP      {r4-r7,pc}
;;;829    
                          ENDP


                          AREA ||i.FMC_SDRAM_ProgramRefreshRate||, CODE, READONLY, ALIGN=1

                  FMC_SDRAM_ProgramRefreshRate PROC
;;;1015     */
;;;1016   HAL_StatusTypeDef FMC_SDRAM_ProgramRefreshRate(FMC_SDRAM_TypeDef *Device, uint32_t RefreshRate)
000000  6942              LDR      r2,[r0,#0x14]
;;;1017   {
;;;1018     /* Check the parameters */
;;;1019     assert_param(IS_FMC_SDRAM_DEVICE(Device));
;;;1020     assert_param(IS_FMC_REFRESH_RATE(RefreshRate));
;;;1021     
;;;1022     /* Set the refresh rate in command register */
;;;1023     Device->SDRTR |= (RefreshRate<<1);
000002  ea420141          ORR      r1,r2,r1,LSL #1
000006  6141              STR      r1,[r0,#0x14]
;;;1024     
;;;1025     return HAL_OK;   
000008  2000              MOVS     r0,#0
;;;1026   }
00000a  4770              BX       lr
;;;1027   
                          ENDP


                          AREA ||i.FMC_SDRAM_SendCommand||, CODE, READONLY, ALIGN=1

                  FMC_SDRAM_SendCommand PROC
;;;986      */  
;;;987    HAL_StatusTypeDef FMC_SDRAM_SendCommand(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
000000  b538              PUSH     {r3-r5,lr}
;;;988    {
;;;989      __IO uint32_t tmpr = 0;
;;;990      
;;;991      /* Check the parameters */
;;;992      assert_param(IS_FMC_SDRAM_DEVICE(Device));
;;;993      assert_param(IS_FMC_COMMAND_MODE(Command->CommandMode));
;;;994      assert_param(IS_FMC_COMMAND_TARGET(Command->CommandTarget));
;;;995      assert_param(IS_FMC_AUTOREFRESH_NUMBER(Command->AutoRefreshNumber));
;;;996      assert_param(IS_FMC_MODE_REGISTER(Command->ModeRegisterDefinition));  
;;;997    
;;;998      /* Set command register */
;;;999      tmpr = (uint32_t)((Command->CommandMode)                  |\
000002  e891001c          LDM      r1,{r2-r4}
000006  68c9              LDR      r1,[r1,#0xc]
000008  f06f051f          MVN      r5,#0x1f
00000c  431a              ORRS     r2,r2,r3
00000e  eb051444          ADD      r4,r5,r4,LSL #5
000012  ea442141          ORR      r1,r4,r1,LSL #9
000016  430a              ORRS     r2,r2,r1
;;;1000                       (Command->CommandTarget)                |\
;;;1001                       (((Command->AutoRefreshNumber)-1) << 5) |\
;;;1002                       ((Command->ModeRegisterDefinition) << 9)
;;;1003                       );
;;;1004       
;;;1005     Device->SDCMR = tmpr;
000018  9200              STR      r2,[sp,#0]
00001a  6102              STR      r2,[r0,#0x10]
;;;1006     
;;;1007     return HAL_OK;  
00001c  2000              MOVS     r0,#0
;;;1008   }
00001e  bd38              POP      {r3-r5,pc}
;;;1009   
                          ENDP


                          AREA ||i.FMC_SDRAM_SetAutoRefreshNumber||, CODE, READONLY, ALIGN=1

                  FMC_SDRAM_SetAutoRefreshNumber PROC
;;;1033     */
;;;1034   HAL_StatusTypeDef FMC_SDRAM_SetAutoRefreshNumber(FMC_SDRAM_TypeDef *Device, uint32_t AutoRefreshNumber)
000000  6902              LDR      r2,[r0,#0x10]
;;;1035   {
;;;1036     /* Check the parameters */
;;;1037     assert_param(IS_FMC_SDRAM_DEVICE(Device));
;;;1038     assert_param(IS_FMC_AUTOREFRESH_NUMBER(AutoRefreshNumber));
;;;1039     
;;;1040     /* Set the Auto-refresh number in command register */
;;;1041     Device->SDCMR |= (AutoRefreshNumber << 5); 
000002  ea421141          ORR      r1,r2,r1,LSL #5
000006  6101              STR      r1,[r0,#0x10]
;;;1042   
;;;1043     return HAL_OK;  
000008  2000              MOVS     r0,#0
;;;1044   }
00000a  4770              BX       lr
;;;1045   
                          ENDP


                          AREA ||i.FMC_SDRAM_Timing_Init||, CODE, READONLY, ALIGN=2

                  FMC_SDRAM_Timing_Init PROC
;;;838      */
;;;839    HAL_StatusTypeDef FMC_SDRAM_Timing_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_TimingTypeDef *Timing, uint32_t Bank)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;840    {
000004  4691              MOV      r9,r2
;;;841      uint32_t tmpr1 = 0;
;;;842      uint32_t tmpr2 = 0;
;;;843        
;;;844      /* Check the parameters */
;;;845      assert_param(IS_FMC_SDRAM_DEVICE(Device));
;;;846      assert_param(IS_FMC_LOADTOACTIVE_DELAY(Timing->LoadToActiveDelay));
;;;847      assert_param(IS_FMC_EXITSELFREFRESH_DELAY(Timing->ExitSelfRefreshDelay));
;;;848      assert_param(IS_FMC_SELFREFRESH_TIME(Timing->SelfRefreshTime));
;;;849      assert_param(IS_FMC_ROWCYCLE_DELAY(Timing->RowCycleDelay));
;;;850      assert_param(IS_FMC_WRITE_RECOVERY_TIME(Timing->WriteRecoveryTime));
;;;851      assert_param(IS_FMC_RP_DELAY(Timing->RPDelay));
;;;852      assert_param(IS_FMC_RCD_DELAY(Timing->RCDDelay));
;;;853      assert_param(IS_FMC_SDRAM_BANK(Bank));
;;;854      
;;;855      /* Set SDRAM device timing parameters */ 
;;;856      if (Bank != FMC_SDRAM_BANK2) 
;;;857      {
;;;858        tmpr1 = Device->SDTR[FMC_SDRAM_BANK1];
;;;859        
;;;860        /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
;;;861        tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
;;;862                              FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
;;;863                              FMC_SDTR1_TRCD));
;;;864        
;;;865        tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
000006  e891001c          LDM      r1,{r2-r4}
00000a  f06f050f          MVN      r5,#0xf
00000e  1e52              SUBS     r2,r2,#1
000010  012e              LSLS     r6,r5,#4
000012  eb051303          ADD      r3,r5,r3,LSL #4
000016  431a              ORRS     r2,r2,r3
000018  7e0b              LDRB     r3,[r1,#0x18]
00001a  eb062604          ADD      r6,r6,r4,LSL #8
00001e  8a8c              LDRH     r4,[r1,#0x14]
000020  032f              LSLS     r7,r5,#12
000022  ea4f4c05          LSL      r12,r5,#16
000026  8a0d              LDRH     r5,[r1,#0x10]
000028  4332              ORRS     r2,r2,r6
00002a  f04f487f          MOV      r8,#0xff000000
00002e  eb086603          ADD      r6,r8,r3,LSL #24
000032  68cb              LDR      r3,[r1,#0xc]          ;856
000034  f1b90f01          CMP      r9,#1                 ;856
000038  eb074505          ADD      r5,r7,r5,LSL #16
00003c  eb0c5404          ADD      r4,r12,r4,LSL #20
000040  d00c              BEQ      |L20.92|
000042  6881              LDR      r1,[r0,#8]            ;858
000044  113f              ASRS     r7,r7,#4
000046  eb073303          ADD      r3,r7,r3,LSL #12
00004a  431a              ORRS     r2,r2,r3
00004c  432a              ORRS     r2,r2,r5
00004e  4322              ORRS     r2,r2,r4
000050  4332              ORRS     r2,r2,r6
000052  f0014170          AND      r1,r1,#0xf0000000     ;861
000056  430a              ORRS     r2,r2,r1
;;;866                           (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
;;;867                           (((Timing->SelfRefreshTime)-1) << 8)      |\
;;;868                           (((Timing->RowCycleDelay)-1) << 12)       |\
;;;869                           (((Timing->WriteRecoveryTime)-1) <<16)    |\
;;;870                           (((Timing->RPDelay)-1) << 20)             |\
;;;871                           (((Timing->RCDDelay)-1) << 24));
;;;872        Device->SDTR[FMC_SDRAM_BANK1] = tmpr1;
000058  6082              STR      r2,[r0,#8]
00005a  e011              B        |L20.128|
                  |L20.92|
;;;873      }
;;;874      else /* FMC_Bank2_SDRAM */
;;;875      {
;;;876        tmpr1 = Device->SDTR[FMC_SDRAM_BANK1];
00005c  6881              LDR      r1,[r0,#8]
;;;877        
;;;878        /* Clear TRC and TRP bits */
;;;879        tmpr1 &= ((uint32_t)~(FMC_SDTR1_TRC | FMC_SDTR1_TRP));
00005e  f8dfc028          LDR      r12,|L20.136|
;;;880        
;;;881        tmpr1 |= (uint32_t)((((Timing->RowCycleDelay)-1) << 12)       |\
;;;882                            (((Timing->RPDelay)-1) << 20)); 
;;;883        
;;;884        tmpr2 = Device->SDTR[FMC_SDRAM_BANK2];
000062  68c7              LDR      r7,[r0,#0xc]
000064  031b              LSLS     r3,r3,#12             ;881
000066  f5a35380          SUB      r3,r3,#0x1000         ;879
00006a  4323              ORRS     r3,r3,r4              ;881
;;;885        
;;;886        /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
;;;887        tmpr2 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
;;;888                              FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
;;;889                              FMC_SDTR1_TRCD));
;;;890        
;;;891        tmpr2 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
00006c  432a              ORRS     r2,r2,r5
00006e  ea01010c          AND      r1,r1,r12             ;879
000072  4332              ORRS     r2,r2,r6
000074  430b              ORRS     r3,r3,r1              ;881
;;;892                           (((Timing->ExitSelfRefreshDelay)-1) << 4)  |\
;;;893                           (((Timing->SelfRefreshTime)-1) << 8)       |\
;;;894                           (((Timing->WriteRecoveryTime)-1) <<16)     |\
;;;895                           (((Timing->RCDDelay)-1) << 24));   
;;;896    
;;;897        Device->SDTR[FMC_SDRAM_BANK1] = tmpr1;
000076  6083              STR      r3,[r0,#8]
000078  f0074470          AND      r4,r7,#0xf0000000     ;887
00007c  4322              ORRS     r2,r2,r4              ;891
;;;898        Device->SDTR[FMC_SDRAM_BANK2] = tmpr2;
00007e  60c2              STR      r2,[r0,#0xc]
                  |L20.128|
;;;899      }
;;;900      
;;;901      return HAL_OK;
000080  2000              MOVS     r0,#0
;;;902    }
000082  e8bd83f0          POP      {r4-r9,pc}
;;;903    
                          ENDP

000086  0000              DCW      0x0000
                  |L20.136|
                          DCD      0xff0f0fff

                          AREA ||i.FMC_SDRAM_WriteProtection_Disable||, CODE, READONLY, ALIGN=1

                  FMC_SDRAM_WriteProtection_Disable PROC
;;;966      */
;;;967    HAL_StatusTypeDef FMC_SDRAM_WriteProtection_Disable(FMC_SDRAM_TypeDef *Device, uint32_t Bank)
000000  f8502021          LDR      r2,[r0,r1,LSL #2]
;;;968    {
;;;969      /* Check the parameters */
;;;970      assert_param(IS_FMC_SDRAM_DEVICE(Device));
;;;971      assert_param(IS_FMC_SDRAM_BANK(Bank));
;;;972      
;;;973      /* Disable write protection */
;;;974      Device->SDCR[Bank] &= ~FMC_SDRAM_WRITE_PROTECTION_ENABLE;
000004  f4227200          BIC      r2,r2,#0x200
000008  f8402021          STR      r2,[r0,r1,LSL #2]
;;;975      
;;;976      return HAL_OK;
00000c  2000              MOVS     r0,#0
;;;977    }
00000e  4770              BX       lr
;;;978      
                          ENDP


                          AREA ||i.FMC_SDRAM_WriteProtection_Enable||, CODE, READONLY, ALIGN=1

                  FMC_SDRAM_WriteProtection_Enable PROC
;;;949      */
;;;950    HAL_StatusTypeDef FMC_SDRAM_WriteProtection_Enable(FMC_SDRAM_TypeDef *Device, uint32_t Bank)
000000  f8502021          LDR      r2,[r0,r1,LSL #2]
;;;951    { 
;;;952      /* Check the parameters */
;;;953      assert_param(IS_FMC_SDRAM_DEVICE(Device));
;;;954      assert_param(IS_FMC_SDRAM_BANK(Bank));
;;;955      
;;;956      /* Enable write protection */
;;;957      Device->SDCR[Bank] |= FMC_SDRAM_WRITE_PROTECTION_ENABLE;
000004  f4427200          ORR      r2,r2,#0x200
000008  f8402021          STR      r2,[r0,r1,LSL #2]
;;;958      
;;;959      return HAL_OK;  
00000c  2000              MOVS     r0,#0
;;;960    }
00000e  4770              BX       lr
;;;961    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F7_V1.11.0\\Drivers\\STM32F7xx_HAL_Driver\\Src\\stm32f7xx_ll_fmc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f7xx_ll_fmc_c_65a710dd____REV16|
#line 468 "D:\\Program_Files_x86\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.3.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___18_stm32f7xx_ll_fmc_c_65a710dd____REV16| PROC
#line 469

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f7xx_ll_fmc_c_65a710dd____REVSH|
#line 483
|__asm___18_stm32f7xx_ll_fmc_c_65a710dd____REVSH| PROC
#line 484

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f7xx_ll_fmc_c_65a710dd____RRX|
#line 670
|__asm___18_stm32f7xx_ll_fmc_c_65a710dd____RRX| PROC
#line 671

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
