; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\rmp_kernel.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\rmp_kernel.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Core -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Inc -I.\Source -I.\Drivers -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6-ALIENTEK\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\rmp_kernel.crf ..\..\MProkaron\Kernel\rmp_kernel.c]
                          THUMB

                          AREA ||i.RMP_CRC16||, CODE, READONLY, ALIGN=2

                  RMP_CRC16 PROC
;;;280    #ifdef __RMP_U16_T__
;;;281    rmp_ptr_t RMP_CRC16(const rmp_u8_t* Data, rmp_ptr_t Length)
000000  b5f0              PUSH     {r4-r7,lr}
;;;282    {
000002  b0c1              SUB      sp,sp,#0x104
000004  460c              MOV      r4,r1
;;;283        rmp_ptr_t Data_Cnt;
;;;284        rmp_u8_t Index;
;;;285        rmp_u8_t Temp_High;
;;;286        rmp_u8_t Temp_Low;
;;;287        
;;;288        /* CRC16 constants with X^16+X^15+X^2+1 */
;;;289        static const rmp_u8_t CRC16_High[256]=
;;;290        {
;;;291            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;292            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;293            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;294            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;295            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;296            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;297            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;298            0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;299            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;300            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;301            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;302            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;303            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;304            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;305            0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;306            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;307            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;308            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;309            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;310            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;311            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;312            0x00, 0xC1, 0x81, 0x40
;;;313        };
;;;314    
;;;315        const rmp_u8_t CRC16_Low[256]=
000006  490c              LDR      r1,|L1.56|
000008  f44f7280          MOV      r2,#0x100
00000c  4605              MOV      r5,r0                 ;282
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       __aeabi_memcpy4
;;;316        {
;;;317            0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7,
;;;318            0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E,
;;;319            0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9,
;;;320            0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC,
;;;321            0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
;;;322            0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32,
;;;323            0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D,
;;;324            0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38,
;;;325            0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF,
;;;326            0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
;;;327            0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1,
;;;328            0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4,
;;;329            0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB,
;;;330            0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA,
;;;331            0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
;;;332            0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0,
;;;333            0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97,
;;;334            0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E,
;;;335            0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89,
;;;336            0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
;;;337            0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83,
;;;338            0x41, 0x81, 0x80, 0x40
;;;339        };
;;;340    
;;;341        Temp_High=0xFF;
000014  20ff              MOVS     r0,#0xff
;;;342        Temp_Low=0xFF;
;;;343        for(Data_Cnt=0;Data_Cnt<Length;Data_Cnt++)
;;;344        {
;;;345            Index=Temp_Low^Data[Data_Cnt];
;;;346            Temp_Low=(rmp_u8_t)(Temp_High^CRC16_High[Index]);
000016  4f09              LDR      r7,|L1.60|
000018  2200              MOVS     r2,#0                 ;343
00001a  4603              MOV      r3,r0                 ;342
00001c  466e              MOV      r6,sp                 ;315
00001e  e005              B        |L1.44|
                  |L1.32|
000020  5ca9              LDRB     r1,[r5,r2]            ;345
000022  4059              EORS     r1,r1,r3              ;345
000024  5c7b              LDRB     r3,[r7,r1]
000026  4043              EORS     r3,r3,r0
;;;347            Temp_High=CRC16_Low[Index];
000028  5c70              LDRB     r0,[r6,r1]
00002a  1c52              ADDS     r2,r2,#1
                  |L1.44|
00002c  42a2              CMP      r2,r4                 ;343
00002e  d3f7              BCC      |L1.32|
;;;348        }
;;;349    
;;;350        return (rmp_u16_t)(((rmp_u16_t)Temp_High)<<8|Temp_Low);
;;;351    }
000030  b041              ADD      sp,sp,#0x104
000032  ea432000          ORR      r0,r3,r0,LSL #8       ;350
000036  bdf0              POP      {r4-r7,pc}
;;;352    #endif
                          ENDP

                  |L1.56|
                          DCD      ||.constdata||+0x4e0
                  |L1.60|
                          DCD      ||.constdata||+0x100

                          AREA ||i.RMP_Checkbox||, CODE, READONLY, ALIGN=1

                  RMP_Checkbox PROC
;;;3440   ******************************************************************************/
;;;3441   void RMP_Checkbox(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_ptr_t Status)    
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;3442   {   
;;;3443       /* Clear the area */
;;;3444       RMP_Rectangle(Coord_X,Coord_Y,Length,Length,RMP_CTL_WHITE,RMP_CTL_WHITE);
000004  f64f78ff          MOV      r8,#0xffff
000008  469b              MOV      r11,r3                ;3442
00000a  4606              MOV      r6,r0                 ;3442
00000c  4692              MOV      r10,r2                ;3442
00000e  460d              MOV      r5,r1                 ;3442
000010  4613              MOV      r3,r2
000012  f8cd8000          STR      r8,[sp,#0]
000016  f8cd8004          STR      r8,[sp,#4]
00001a  f7fffffe          BL       RMP_Rectangle
;;;3445                                                                        
;;;3446       /* Draw checkbox outline */
;;;3447       RMP_Line(Coord_X,Coord_Y,Coord_X+Length-1,Coord_Y,RMP_CTL_DARK);                 
00001e  eb06040a          ADD      r4,r6,r10
000022  462b              MOV      r3,r5
000024  1e62              SUBS     r2,r4,#1
000026  f64739ef          MOV      r9,#0x7bef
00002a  4619              MOV      r1,r3
00002c  4630              MOV      r0,r6
00002e  f8cd9000          STR      r9,[sp,#0]
000032  f7fffffe          BL       RMP_Line
;;;3448       RMP_Line(Coord_X+Length-1,Coord_Y,Coord_X+Length-1,Coord_Y+Length-1,RMP_CTL_WHITE);
000036  1e62              SUBS     r2,r4,#1
000038  4629              MOV      r1,r5
00003a  eb05070a          ADD      r7,r5,r10
00003e  4610              MOV      r0,r2
000040  1e7b              SUBS     r3,r7,#1
000042  f8cd8000          STR      r8,[sp,#0]
000046  f7fffffe          BL       RMP_Line
;;;3449       RMP_Line(Coord_X+Length-1,Coord_Y+Length-1,Coord_X,Coord_Y+Length-1,RMP_CTL_WHITE);
00004a  1e7b              SUBS     r3,r7,#1
00004c  4632              MOV      r2,r6
00004e  1e79              SUBS     r1,r7,#1
000050  f8cd8000          STR      r8,[sp,#0]
000054  1e60              SUBS     r0,r4,#1
000056  f7fffffe          BL       RMP_Line
;;;3450       RMP_Line(Coord_X,Coord_Y+Length-1,Coord_X,Coord_Y,RMP_CTL_DARK);
00005a  4632              MOV      r2,r6
00005c  462b              MOV      r3,r5
00005e  1e79              SUBS     r1,r7,#1
000060  4610              MOV      r0,r2
000062  f8cd9000          STR      r9,[sp,#0]
000066  f7fffffe          BL       RMP_Line
;;;3451   
;;;3452       RMP_Line(Coord_X+1,Coord_Y+1,Coord_X+Length-2,Coord_Y+1,RMP_CTL_BLACK);
00006a  1ea2              SUBS     r2,r4,#2
00006c  f04f0800          MOV      r8,#0
000070  1c6b              ADDS     r3,r5,#1
000072  f8cd8000          STR      r8,[sp,#0]
000076  1c69              ADDS     r1,r5,#1
000078  1c70              ADDS     r0,r6,#1
00007a  f7fffffe          BL       RMP_Line
;;;3453       RMP_Line(Coord_X+Length-2,Coord_Y+1,Coord_X+Length-2,Coord_Y+Length-2,RMP_CTL_DARK);
00007e  1ea2              SUBS     r2,r4,#2
000080  f8cd9000          STR      r9,[sp,#0]
000084  1ebb              SUBS     r3,r7,#2
000086  4610              MOV      r0,r2
000088  1c69              ADDS     r1,r5,#1
00008a  f7fffffe          BL       RMP_Line
;;;3454       RMP_Line(Coord_X+Length-2,Coord_Y+Length-2,Coord_X,Coord_Y+Length-2,RMP_CTL_DARK);
00008e  1ea0              SUBS     r0,r4,#2
000090  4632              MOV      r2,r6
000092  1ebb              SUBS     r3,r7,#2
000094  f8cd9000          STR      r9,[sp,#0]
000098  1eb9              SUBS     r1,r7,#2
00009a  f7fffffe          BL       RMP_Line
;;;3455       RMP_Line(Coord_X+1,Coord_Y+Length-2,Coord_X+1,Coord_Y+1,RMP_CTL_BLACK);
00009e  1eb9              SUBS     r1,r7,#2
0000a0  f8cd8000          STR      r8,[sp,#0]
0000a4  1c6b              ADDS     r3,r5,#1
0000a6  1c72              ADDS     r2,r6,#1
0000a8  1c70              ADDS     r0,r6,#1
0000aa  f7fffffe          BL       RMP_Line
;;;3456       
;;;3457       if(Status!=0)
0000ae  f1bb0f00          CMP      r11,#0
0000b2  d007              BEQ      |L2.196|
;;;3458           RMP_Checkbox_Set(Coord_X, Coord_Y, Length);
0000b4  b002              ADD      sp,sp,#8
0000b6  4652              MOV      r2,r10
0000b8  4629              MOV      r1,r5
0000ba  4630              MOV      r0,r6
0000bc  e8bd5ff0          POP      {r4-r12,lr}
0000c0  f7ffbffe          B.W      RMP_Checkbox_Set
                  |L2.196|
;;;3459   }
0000c4  e8bd9ffc          POP      {r2-r12,pc}
;;;3460   /* End Function:RMP_Checkbox *************************************************/
                          ENDP


                          AREA ||i.RMP_Checkbox_Clr||, CODE, READONLY, ALIGN=2

                  RMP_Checkbox_Clr PROC
;;;3413   ******************************************************************************/
;;;3414   void RMP_Checkbox_Clr(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;3415   {
000004  4615              MOV      r5,r2
000006  460e              MOV      r6,r1
;;;3416       rmp_cnt_t Count;
;;;3417       
;;;3418       /* Erase the tick inside */
;;;3419       for(Count=0;Count<=2*Length/13;Count++)
000008  2400              MOVS     r4,#0
00000a  4681              MOV      r9,r0                 ;3415
;;;3420       {
;;;3421           RMP_Line(Coord_X+4*Length/13+Count,Coord_Y+6*Length/13+Count,
00000c  eb020145          ADD      r1,r2,r5,LSL #1
000010  0097              LSLS     r7,r2,#2
000012  0050              LSLS     r0,r2,#1              ;3419
000014  9001              STR      r0,[sp,#4]            ;3415
000016  ea4f0a41          LSL      r10,r1,#1
00001a  ea4f0bc2          LSL      r11,r2,#3
00001e  e016              B        |L3.78|
                  |L3.32|
000020  fb9bf3f0          SDIV     r3,r11,r0
000024  fb9af1f0          SDIV     r1,r10,r0
000028  fb97f2f0          SDIV     r2,r7,r0
00002c  fb97f0f0          SDIV     r0,r7,r0
000030  f64f7cff          MOV      r12,#0xffff
000034  f8cdc000          STR      r12,[sp,#0]
000038  4433              ADD      r3,r3,r6
00003a  4431              ADD      r1,r1,r6
00003c  444a              ADD      r2,r2,r9
00003e  4448              ADD      r0,r0,r9
000040  4423              ADD      r3,r3,r4
000042  4422              ADD      r2,r2,r4
000044  4421              ADD      r1,r1,r4
000046  4420              ADD      r0,r0,r4
000048  f7fffffe          BL       RMP_Line
00004c  1c64              ADDS     r4,r4,#1
                  |L3.78|
00004e  9901              LDR      r1,[sp,#4]            ;3419
000050  200d              MOVS     r0,#0xd               ;3419
000052  fb91f1f0          SDIV     r1,r1,r0              ;3419
000056  42a1              CMP      r1,r4                 ;3419
000058  dae2              BGE      |L3.32|
;;;3422                    Coord_X+4*Length/13+Count,Coord_Y+8*Length/13+Count,RMP_CTL_WHITE);
;;;3423       }
;;;3424       for(Count=0;Count<=4*Length/13;Count++)
00005a  2400              MOVS     r4,#0
00005c  e01a              B        |L3.148|
;;;3425       {
;;;3426           RMP_Line(Coord_X+6*Length/13+Count,Coord_Y+8*Length/13-Count,
00005e  bf00              NOP      
                  |L3.96|
000060  eb050185          ADD      r1,r5,r5,LSL #2
000064  f64f7cff          MOV      r12,#0xffff
000068  fb9af2f0          SDIV     r2,r10,r0
00006c  0049              LSLS     r1,r1,#1
00006e  f8cdc000          STR      r12,[sp,#0]
000072  fb91f3f0          SDIV     r3,r1,r0
000076  fb9bf1f0          SDIV     r1,r11,r0
00007a  fb9af0f0          SDIV     r0,r10,r0
00007e  444a              ADD      r2,r2,r9
000080  4422              ADD      r2,r2,r4
000082  4433              ADD      r3,r3,r6
000084  4431              ADD      r1,r1,r6
000086  4448              ADD      r0,r0,r9
000088  1b1b              SUBS     r3,r3,r4
00008a  1b09              SUBS     r1,r1,r4
00008c  4420              ADD      r0,r0,r4
00008e  f7fffffe          BL       RMP_Line
000092  1c64              ADDS     r4,r4,#1
                  |L3.148|
000094  200d              MOVS     r0,#0xd               ;3424
000096  fb97f1f0          SDIV     r1,r7,r0              ;3424
00009a  42a1              CMP      r1,r4                 ;3424
00009c  dae0              BGE      |L3.96|
;;;3427                    Coord_X+6*Length/13+Count,Coord_Y+10*Length/13-Count,RMP_CTL_WHITE);
;;;3428       }
;;;3429   }
00009e  e8bd9ffc          POP      {r2-r12,pc}
;;;3430   /* End Function:RMP_Checkbox_Clr *********************************************/
                          ENDP


                          AREA ||i.RMP_Checkbox_Set||, CODE, READONLY, ALIGN=2

                  RMP_Checkbox_Set PROC
;;;3387   ******************************************************************************/
;;;3388   void RMP_Checkbox_Set(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;3389   {
000004  4615              MOV      r5,r2
000006  460e              MOV      r6,r1
;;;3390       rmp_cnt_t Count;
;;;3391       
;;;3392       /* Draw a tick inside */
;;;3393       for(Count=0;Count<=2*Length/13;Count++)
000008  2400              MOVS     r4,#0
00000a  4681              MOV      r9,r0                 ;3389
;;;3394       {
;;;3395           RMP_Line(Coord_X+4*Length/13+Count,Coord_Y+6*Length/13+Count,
00000c  eb020145          ADD      r1,r2,r5,LSL #1
000010  0097              LSLS     r7,r2,#2
000012  0050              LSLS     r0,r2,#1              ;3393
000014  9001              STR      r0,[sp,#4]            ;3389
000016  ea4f0a41          LSL      r10,r1,#1
00001a  ea4f0bc2          LSL      r11,r2,#3
00001e  e016              B        |L4.78|
                  |L4.32|
000020  fb9bf3f0          SDIV     r3,r11,r0
000024  fb9af1f0          SDIV     r1,r10,r0
000028  fb97f2f0          SDIV     r2,r7,r0
00002c  fb97f0f0          SDIV     r0,r7,r0
000030  f04f0c00          MOV      r12,#0
000034  f8cdc000          STR      r12,[sp,#0]
000038  4433              ADD      r3,r3,r6
00003a  4431              ADD      r1,r1,r6
00003c  444a              ADD      r2,r2,r9
00003e  4448              ADD      r0,r0,r9
000040  4423              ADD      r3,r3,r4
000042  4422              ADD      r2,r2,r4
000044  4421              ADD      r1,r1,r4
000046  4420              ADD      r0,r0,r4
000048  f7fffffe          BL       RMP_Line
00004c  1c64              ADDS     r4,r4,#1
                  |L4.78|
00004e  9901              LDR      r1,[sp,#4]            ;3393
000050  200d              MOVS     r0,#0xd               ;3393
000052  fb91f1f0          SDIV     r1,r1,r0              ;3393
000056  42a1              CMP      r1,r4                 ;3393
000058  dae2              BGE      |L4.32|
;;;3396                    Coord_X+4*Length/13+Count,Coord_Y+8*Length/13+Count,RMP_CTL_BLACK);
;;;3397       }
;;;3398       for(Count=0;Count<=4*Length/13;Count++)
00005a  2400              MOVS     r4,#0
00005c  e01a              B        |L4.148|
;;;3399       {
;;;3400           RMP_Line(Coord_X+6*Length/13+Count,Coord_Y+8*Length/13-Count,
00005e  bf00              NOP      
                  |L4.96|
000060  eb050185          ADD      r1,r5,r5,LSL #2
000064  f04f0c00          MOV      r12,#0
000068  fb9af2f0          SDIV     r2,r10,r0
00006c  0049              LSLS     r1,r1,#1
00006e  f8cdc000          STR      r12,[sp,#0]
000072  fb91f3f0          SDIV     r3,r1,r0
000076  fb9bf1f0          SDIV     r1,r11,r0
00007a  fb9af0f0          SDIV     r0,r10,r0
00007e  444a              ADD      r2,r2,r9
000080  4422              ADD      r2,r2,r4
000082  4433              ADD      r3,r3,r6
000084  4431              ADD      r1,r1,r6
000086  4448              ADD      r0,r0,r9
000088  1b1b              SUBS     r3,r3,r4
00008a  1b09              SUBS     r1,r1,r4
00008c  4420              ADD      r0,r0,r4
00008e  f7fffffe          BL       RMP_Line
000092  1c64              ADDS     r4,r4,#1
                  |L4.148|
000094  200d              MOVS     r0,#0xd               ;3398
000096  fb97f1f0          SDIV     r1,r7,r0              ;3398
00009a  42a1              CMP      r1,r4                 ;3398
00009c  dae0              BGE      |L4.96|
;;;3401                    Coord_X+6*Length/13+Count,Coord_Y+10*Length/13-Count,RMP_CTL_BLACK);
;;;3402       }
;;;3403   }
00009e  e8bd9ffc          POP      {r2-r12,pc}
;;;3404   /* End Function:RMP_Checkbox_Set *********************************************/
                          ENDP


                          AREA ||i.RMP_Circle||, CODE, READONLY, ALIGN=1

                  RMP_Circle PROC
;;;2898   ******************************************************************************/
;;;2899   void RMP_Circle(rmp_cnt_t Center_X, rmp_cnt_t Center_Y, rmp_cnt_t Radius, rmp_ptr_t Border, rmp_ptr_t Fill)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;2900   {
000004  b085              SUB      sp,sp,#0x14
000006  460e              MOV      r6,r1
;;;2901       rmp_cnt_t Cur_X;
;;;2902       rmp_cnt_t Cur_Y;
;;;2903       rmp_cnt_t Fill_Y;
;;;2904       rmp_cnt_t Error;  
;;;2905       rmp_cnt_t Quick;
;;;2906   
;;;2907       Cur_X=0;
;;;2908       Cur_Y=Radius;
;;;2909       Error=3-(Radius<<1);
000008  2103              MOVS     r1,#3
00000a  4607              MOV      r7,r0                 ;2900
00000c  eba10a42          SUB      r10,r1,r2,LSL #1
000010  f04f0400          MOV      r4,#0                 ;2907
;;;2910   
;;;2911       if(Fill!=RMP_TRANS)
000014  9812              LDR      r0,[sp,#0x48]
000016  4615              MOV      r5,r2                 ;2908
000018  2801              CMP      r0,#1
00001a  d07d              BEQ      |L5.280|
;;;2912       {  
;;;2913           /* When we are filling the circle, we can try not to fill the areas that have been filled
;;;2914            * using the rectangle fill method to increase fill speed.
;;;2915            * Square 2 is 1.414. Here we let the condition to be 1.5. */
;;;2916           Quick=(Radius<<1)/3;
00001c  006a              LSLS     r2,r5,#1
;;;2917           /* First, fill the square hole using the fast direct-fill method */
;;;2918           RMP_Rectangle(Center_X-Quick,Center_Y-Quick, (Quick<<1)+1,(Quick<<1)+1, Fill, Fill);  
00001e  9812              LDR      r0,[sp,#0x48]
000020  fb92f9f1          SDIV     r9,r2,r1              ;2916
000024  2301              MOVS     r3,#1
000026  9000              STR      r0,[sp,#0]
000028  9001              STR      r0,[sp,#4]
00002a  eba60109          SUB      r1,r6,r9
00002e  eb030249          ADD      r2,r3,r9,LSL #1
000032  eba70009          SUB      r0,r7,r9
000036  4613              MOV      r3,r2
000038  f7fffffe          BL       RMP_Rectangle
;;;2919   
;;;2920           while(Cur_X<=Cur_Y) 
00003c  e0bd              B        |L5.442|
                  |L5.62|
;;;2921           {  
;;;2922               if(Cur_X<Quick)
00003e  454c              CMP      r4,r9
000040  da3c              BGE      |L5.188|
;;;2923               {
;;;2924                   for(Fill_Y=Cur_X;Fill_Y<=Cur_Y;Fill_Y++)  
000042  46a0              MOV      r8,r4
000044  e037              B        |L5.182|
                  |L5.70|
;;;2925                   {
;;;2926                       if(Fill_Y<Quick)
000046  45c8              CMP      r8,r9
000048  db33              BLT      |L5.178|
;;;2927                           continue;
;;;2928                       
;;;2929                       RMP_POINT(Center_X+Cur_X,Center_Y+Fill_Y,Fill);  
00004a  eb060108          ADD      r1,r6,r8
00004e  9a12              LDR      r2,[sp,#0x48]
000050  1938              ADDS     r0,r7,r4
000052  468b              MOV      r11,r1
000054  9001              STR      r0,[sp,#4]
000056  f7fffffe          BL       RMP_Point
;;;2930                       RMP_POINT(Center_X-Cur_X,Center_Y+Fill_Y,Fill);  
00005a  9a12              LDR      r2,[sp,#0x48]
00005c  1b38              SUBS     r0,r7,r4
00005e  4659              MOV      r1,r11                ;2929
000060  9000              STR      r0,[sp,#0]
000062  f7fffffe          BL       RMP_Point
;;;2931                       RMP_POINT(Center_X+Cur_X,Center_Y-Fill_Y,Fill); 
000066  eba60108          SUB      r1,r6,r8
00006a  9a12              LDR      r2,[sp,#0x48]
00006c  9801              LDR      r0,[sp,#4]
00006e  468b              MOV      r11,r1
000070  f7fffffe          BL       RMP_Point
;;;2932                       RMP_POINT(Center_X-Cur_X,Center_Y-Fill_Y,Fill);  
000074  9a12              LDR      r2,[sp,#0x48]
000076  4659              MOV      r1,r11                ;2931
000078  9800              LDR      r0,[sp,#0]
00007a  f7fffffe          BL       RMP_Point
;;;2933                       RMP_POINT(Center_X+Fill_Y,Center_Y+Cur_X,Fill); 
00007e  1931              ADDS     r1,r6,r4
000080  9a12              LDR      r2,[sp,#0x48]
000082  eb070008          ADD      r0,r7,r8
000086  468b              MOV      r11,r1
000088  9001              STR      r0,[sp,#4]
00008a  f7fffffe          BL       RMP_Point
;;;2934                       RMP_POINT(Center_X-Fill_Y,Center_Y+Cur_X,Fill);  
00008e  9a12              LDR      r2,[sp,#0x48]
000090  eba70008          SUB      r0,r7,r8
000094  4659              MOV      r1,r11                ;2933
000096  9000              STR      r0,[sp,#0]
000098  f7fffffe          BL       RMP_Point
;;;2935                       RMP_POINT(Center_X+Fill_Y,Center_Y-Cur_X,Fill);  
00009c  1b31              SUBS     r1,r6,r4
00009e  9a12              LDR      r2,[sp,#0x48]
0000a0  9801              LDR      r0,[sp,#4]
0000a2  468b              MOV      r11,r1
0000a4  f7fffffe          BL       RMP_Point
;;;2936                       RMP_POINT(Center_X-Fill_Y,Center_Y-Cur_X,Fill);
0000a8  9a12              LDR      r2,[sp,#0x48]
0000aa  4659              MOV      r1,r11                ;2935
0000ac  9800              LDR      r0,[sp,#0]
0000ae  f7fffffe          BL       RMP_Point
                  |L5.178|
0000b2  f1080801          ADD      r8,r8,#1              ;2924
                  |L5.182|
0000b6  45a8              CMP      r8,r5                 ;2924
0000b8  ddc5              BLE      |L5.70|
0000ba  e03f              B        |L5.316|
                  |L5.188|
0000bc  1b30              SUBS     r0,r6,r4              ;2935
0000be  9001              STR      r0,[sp,#4]            ;2933
0000c0  1930              ADDS     r0,r6,r4              ;2933
0000c2  9004              STR      r0,[sp,#0x10]         ;2930
0000c4  1b38              SUBS     r0,r7,r4              ;2930
;;;2937                   }
;;;2938               }
;;;2939               /* Here the "Cur_X" is already out of range. We do not check the conditions anymore */
;;;2940               else
;;;2941               {
;;;2942                   for(Fill_Y=Cur_X;Fill_Y<=Cur_Y;Fill_Y++)  
0000c6  46a0              MOV      r8,r4
0000c8  eb070b04          ADD      r11,r7,r4             ;2929
0000cc  9000              STR      r0,[sp,#0]
0000ce  e033              B        |L5.312|
                  |L5.208|
;;;2943                   {                   
;;;2944                       RMP_POINT(Center_X+Cur_X,Center_Y+Fill_Y,Fill);  
0000d0  9a12              LDR      r2,[sp,#0x48]
0000d2  eb060108          ADD      r1,r6,r8
0000d6  4658              MOV      r0,r11                ;2942
0000d8  9102              STR      r1,[sp,#8]
0000da  f7fffffe          BL       RMP_Point
;;;2945                       RMP_POINT(Center_X-Cur_X,Center_Y+Fill_Y,Fill);  
0000de  9a12              LDR      r2,[sp,#0x48]
0000e0  9902              LDR      r1,[sp,#8]
0000e2  9800              LDR      r0,[sp,#0]
0000e4  f7fffffe          BL       RMP_Point
;;;2946                       RMP_POINT(Center_X+Cur_X,Center_Y-Fill_Y,Fill); 
0000e8  9a12              LDR      r2,[sp,#0x48]
0000ea  eba60108          SUB      r1,r6,r8
0000ee  4658              MOV      r0,r11                ;2945
0000f0  9102              STR      r1,[sp,#8]
0000f2  f7fffffe          BL       RMP_Point
;;;2947                       RMP_POINT(Center_X-Cur_X,Center_Y-Fill_Y,Fill);  
0000f6  9a12              LDR      r2,[sp,#0x48]
0000f8  9902              LDR      r1,[sp,#8]
0000fa  9800              LDR      r0,[sp,#0]
0000fc  f7fffffe          BL       RMP_Point
;;;2948                       RMP_POINT(Center_X+Fill_Y,Center_Y+Cur_X,Fill); 
000100  eb070008          ADD      r0,r7,r8
000104  9003              STR      r0,[sp,#0xc]
000106  9904              LDR      r1,[sp,#0x10]
000108  9a12              LDR      r2,[sp,#0x48]
00010a  f7fffffe          BL       RMP_Point
;;;2949                       RMP_POINT(Center_X-Fill_Y,Center_Y+Cur_X,Fill);  
00010e  9904              LDR      r1,[sp,#0x10]
000110  eba70008          SUB      r0,r7,r8
000114  9002              STR      r0,[sp,#8]
000116  e000              B        |L5.282|
                  |L5.280|
000118  e092              B        |L5.576|
                  |L5.282|
00011a  9a12              LDR      r2,[sp,#0x48]
00011c  f7fffffe          BL       RMP_Point
;;;2950                       RMP_POINT(Center_X+Fill_Y,Center_Y-Cur_X,Fill);  
000120  9a12              LDR      r2,[sp,#0x48]
000122  9901              LDR      r1,[sp,#4]
000124  9803              LDR      r0,[sp,#0xc]
000126  f7fffffe          BL       RMP_Point
;;;2951                       RMP_POINT(Center_X-Fill_Y,Center_Y-Cur_X,Fill);
00012a  9a12              LDR      r2,[sp,#0x48]
00012c  e9dd1001          LDRD     r1,r0,[sp,#4]
000130  f7fffffe          BL       RMP_Point
000134  f1080801          ADD      r8,r8,#1              ;2942
                  |L5.312|
000138  45a8              CMP      r8,r5                 ;2942
00013a  ddc9              BLE      |L5.208|
                  |L5.316|
;;;2952                   }
;;;2953               }
;;;2954               RMP_POINT(Center_X+Cur_X,Center_Y+Cur_Y,Border);  
00013c  1971              ADDS     r1,r6,r5
00013e  9a08              LDR      r2,[sp,#0x20]
000140  1938              ADDS     r0,r7,r4
000142  4688              MOV      r8,r1
000144  9000              STR      r0,[sp,#0]
000146  f7fffffe          BL       RMP_Point
;;;2955               RMP_POINT(Center_X-Cur_X,Center_Y+Cur_Y,Border);  
00014a  1b38              SUBS     r0,r7,r4
00014c  9a08              LDR      r2,[sp,#0x20]
00014e  4641              MOV      r1,r8                 ;2954
000150  4683              MOV      r11,r0
000152  f7fffffe          BL       RMP_Point
;;;2956               RMP_POINT(Center_X+Cur_X,Center_Y-Cur_Y,Border); 
000156  1b71              SUBS     r1,r6,r5
000158  9a08              LDR      r2,[sp,#0x20]
00015a  9800              LDR      r0,[sp,#0]
00015c  4688              MOV      r8,r1
00015e  f7fffffe          BL       RMP_Point
;;;2957               RMP_POINT(Center_X-Cur_X,Center_Y-Cur_Y,Border);  
000162  9a08              LDR      r2,[sp,#0x20]
000164  4641              MOV      r1,r8                 ;2956
000166  4658              MOV      r0,r11                ;2956
000168  f7fffffe          BL       RMP_Point
;;;2958               RMP_POINT(Center_X+Cur_Y,Center_Y+Cur_X,Border); 
00016c  1931              ADDS     r1,r6,r4
00016e  9a08              LDR      r2,[sp,#0x20]
000170  1978              ADDS     r0,r7,r5
000172  4688              MOV      r8,r1
000174  4683              MOV      r11,r0
000176  f7fffffe          BL       RMP_Point
;;;2959               RMP_POINT(Center_X-Cur_Y,Center_Y+Cur_X,Border);  
00017a  9a08              LDR      r2,[sp,#0x20]
00017c  1b78              SUBS     r0,r7,r5
00017e  4641              MOV      r1,r8                 ;2958
000180  9000              STR      r0,[sp,#0]
000182  f7fffffe          BL       RMP_Point
;;;2960               RMP_POINT(Center_X+Cur_Y,Center_Y-Cur_X,Border);  
000186  1b31              SUBS     r1,r6,r4
000188  9a08              LDR      r2,[sp,#0x20]
00018a  4658              MOV      r0,r11                ;2959
00018c  4688              MOV      r8,r1
00018e  f7fffffe          BL       RMP_Point
;;;2961               RMP_POINT(Center_X-Cur_Y,Center_Y-Cur_X,Border);
000192  9a08              LDR      r2,[sp,#0x20]
000194  4641              MOV      r1,r8                 ;2960
000196  9800              LDR      r0,[sp,#0]
000198  f7fffffe          BL       RMP_Point
;;;2962   
;;;2963               if(Error<0) 
00019c  f1ba0f00          CMP      r10,#0
0001a0  da04              BGE      |L5.428|
;;;2964                   Error=Error+(Cur_X<<2)+6;
0001a2  eb0a0084          ADD      r0,r10,r4,LSL #2
0001a6  f1000a06          ADD      r10,r0,#6
0001aa  e005              B        |L5.440|
                  |L5.428|
;;;2965               else 
;;;2966               {  
;;;2967                   Error=Error+((Cur_X-Cur_Y)<<2)+10;  
0001ac  1b61              SUBS     r1,r4,r5
0001ae  1e6d              SUBS     r5,r5,#1
0001b0  eb0a0081          ADD      r0,r10,r1,LSL #2
0001b4  f1000a0a          ADD      r10,r0,#0xa
                  |L5.440|
0001b8  1c64              ADDS     r4,r4,#1
                  |L5.442|
0001ba  42ac              CMP      r4,r5                 ;2920
0001bc  f77faf3f          BLE      |L5.62|
                  |L5.448|
;;;2968                   Cur_Y--;  
;;;2969               }  
;;;2970               Cur_X++;  
;;;2971           }
;;;2972       }
;;;2973       else 
;;;2974       {  
;;;2975           /* Border only */ 
;;;2976           while(Cur_X<=Cur_Y) 
;;;2977           {
;;;2978               RMP_POINT(Center_X+Cur_X,Center_Y+Cur_Y,Border);  
;;;2979               RMP_POINT(Center_X-Cur_X,Center_Y+Cur_Y,Border);  
;;;2980               RMP_POINT(Center_X+Cur_X,Center_Y-Cur_Y,Border); 
;;;2981               RMP_POINT(Center_X-Cur_X,Center_Y-Cur_Y,Border);  
;;;2982               RMP_POINT(Center_X+Cur_Y,Center_Y+Cur_X,Border); 
;;;2983               RMP_POINT(Center_X-Cur_Y,Center_Y+Cur_X,Border);  
;;;2984               RMP_POINT(Center_X+Cur_Y,Center_Y-Cur_X,Border);  
;;;2985               RMP_POINT(Center_X-Cur_Y,Center_Y-Cur_X,Border);
;;;2986   
;;;2987               if(Error<0)
;;;2988                   Error=Error+(Cur_X<<2)+6;
;;;2989               else 
;;;2990               {
;;;2991                   Error=Error+((Cur_X-Cur_Y)<<2);
;;;2992                   Cur_Y--;
;;;2993               }
;;;2994               Cur_X++;  
;;;2995           }  
;;;2996       }
;;;2997   }
0001c0  b009              ADD      sp,sp,#0x24
0001c2  e8bd8ff0          POP      {r4-r11,pc}
                  |L5.454|
0001c6  1971              ADDS     r1,r6,r5              ;2978
0001c8  9a08              LDR      r2,[sp,#0x20]         ;2978
0001ca  1938              ADDS     r0,r7,r4              ;2978
0001cc  4688              MOV      r8,r1                 ;2978
0001ce  4683              MOV      r11,r0                ;2978
0001d0  f7fffffe          BL       RMP_Point
0001d4  1b38              SUBS     r0,r7,r4              ;2979
0001d6  9a08              LDR      r2,[sp,#0x20]         ;2979
0001d8  4641              MOV      r1,r8                 ;2978
0001da  4681              MOV      r9,r0                 ;2979
0001dc  f7fffffe          BL       RMP_Point
0001e0  1b71              SUBS     r1,r6,r5              ;2980
0001e2  9a08              LDR      r2,[sp,#0x20]         ;2980
0001e4  4658              MOV      r0,r11                ;2979
0001e6  4688              MOV      r8,r1                 ;2980
0001e8  f7fffffe          BL       RMP_Point
0001ec  9a08              LDR      r2,[sp,#0x20]         ;2981
0001ee  4641              MOV      r1,r8                 ;2980
0001f0  4648              MOV      r0,r9                 ;2980
0001f2  f7fffffe          BL       RMP_Point
0001f6  1931              ADDS     r1,r6,r4              ;2982
0001f8  9a08              LDR      r2,[sp,#0x20]         ;2982
0001fa  1978              ADDS     r0,r7,r5              ;2982
0001fc  4688              MOV      r8,r1                 ;2982
0001fe  4683              MOV      r11,r0                ;2982
000200  f7fffffe          BL       RMP_Point
000204  1b78              SUBS     r0,r7,r5              ;2983
000206  9a08              LDR      r2,[sp,#0x20]         ;2983
000208  4641              MOV      r1,r8                 ;2982
00020a  4681              MOV      r9,r0                 ;2983
00020c  f7fffffe          BL       RMP_Point
000210  1b31              SUBS     r1,r6,r4              ;2984
000212  9a08              LDR      r2,[sp,#0x20]         ;2984
000214  4658              MOV      r0,r11                ;2983
000216  4688              MOV      r8,r1                 ;2984
000218  f7fffffe          BL       RMP_Point
00021c  9a08              LDR      r2,[sp,#0x20]         ;2985
00021e  4641              MOV      r1,r8                 ;2984
000220  4648              MOV      r0,r9                 ;2984
000222  f7fffffe          BL       RMP_Point
000226  f1ba0f00          CMP      r10,#0                ;2987
00022a  da04              BGE      |L5.566|
00022c  eb0a0084          ADD      r0,r10,r4,LSL #2      ;2988
000230  f1000a06          ADD      r10,r0,#6             ;2988
000234  e003              B        |L5.574|
                  |L5.566|
000236  1b61              SUBS     r1,r4,r5              ;2991
000238  1e6d              SUBS     r5,r5,#1              ;2991
00023a  eb0a0a81          ADD      r10,r10,r1,LSL #2     ;2991
                  |L5.574|
00023e  1c64              ADDS     r4,r4,#1              ;2991
                  |L5.576|
000240  42ac              CMP      r4,r5                 ;2976
000242  ddc0              BLE      |L5.454|
000244  e7bc              B        |L5.448|
;;;2998   /* End Function:RMP_Circle ***************************************************/
                          ENDP


                          AREA ||i.RMP_Clear||, CODE, READONLY, ALIGN=1

                  RMP_Clear PROC
;;;67     ******************************************************************************/
;;;68     void RMP_Clear(volatile void* Addr, rmp_ptr_t Size)
000000  2300              MOVS     r3,#0
;;;69     {
;;;70         rmp_u8_t* Ptr;
;;;71         rmp_cnt_t Count;
;;;72        
;;;73         Ptr=(rmp_u8_t*)Addr;
;;;74         for(Count=0;Count<(rmp_cnt_t)Size;Count++)
000002  461a              MOV      r2,r3
000004  e001              B        |L6.10|
                  |L6.6|
;;;75             Ptr[Count]=0;
000006  5483              STRB     r3,[r0,r2]
000008  1c52              ADDS     r2,r2,#1
                  |L6.10|
00000a  428a              CMP      r2,r1                 ;74
00000c  dbfb              BLT      |L6.6|
;;;76     }
00000e  4770              BX       lr
;;;77     /* End Function:RMP_Clear ****************************************************/
                          ENDP


                          AREA ||i.RMP_Cmdbtn||, CODE, READONLY, ALIGN=1

                  RMP_Cmdbtn PROC
;;;3519   ******************************************************************************/
;;;3520   void RMP_Cmdbtn(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width, rmp_ptr_t Status)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;3521   {
000004  4680              MOV      r8,r0
;;;3522       RMP_Rectangle(Coord_X,Coord_Y,Length,Width,RMP_CTL_GREY,RMP_CTL_GREY);
000006  f64b50d7          MOV      r0,#0xbdd7
00000a  461d              MOV      r5,r3                 ;3521
00000c  4616              MOV      r6,r2                 ;3521
00000e  9c08              LDR      r4,[sp,#0x20]
000010  460f              MOV      r7,r1                 ;3521
000012  9000              STR      r0,[sp,#0]
000014  9001              STR      r0,[sp,#4]
000016  4640              MOV      r0,r8
000018  f7fffffe          BL       RMP_Rectangle
;;;3523   
;;;3524       if(Status!=0)
;;;3525           RMP_Cmdbtn_Down(Coord_X, Coord_Y, Length, Width);
;;;3526       else
;;;3527           RMP_Cmdbtn_Up(Coord_X, Coord_Y, Length, Width);
00001c  462b              MOV      r3,r5
00001e  4632              MOV      r2,r6
000020  4639              MOV      r1,r7
000022  4640              MOV      r0,r8
000024  b124              CBZ      r4,|L7.48|
000026  b002              ADD      sp,sp,#8              ;3525
000028  e8bd41f0          POP      {r4-r8,lr}            ;3525
00002c  f7ffbffe          B.W      RMP_Cmdbtn_Down
                  |L7.48|
000030  b002              ADD      sp,sp,#8
000032  e8bd41f0          POP      {r4-r8,lr}
000036  f7ffbffe          B.W      RMP_Cmdbtn_Up
;;;3528   }
;;;3529   /* End Function:RMP_Cmdbtn ***************************************************/
                          ENDP


                          AREA ||i.RMP_Cmdbtn_Down||, CODE, READONLY, ALIGN=1

                  RMP_Cmdbtn_Down PROC
;;;3470   ******************************************************************************/
;;;3471   void RMP_Cmdbtn_Down(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;3472   {
;;;3473       RMP_Line(Coord_X,Coord_Y,Coord_X+Length-1,Coord_Y,RMP_CTL_BLACK);
000004  1884              ADDS     r4,r0,r2
000006  461f              MOV      r7,r3                 ;3472
000008  1e62              SUBS     r2,r4,#1
00000a  460d              MOV      r5,r1                 ;3472
00000c  4606              MOV      r6,r0                 ;3472
00000e  f04f0900          MOV      r9,#0
000012  460b              MOV      r3,r1
000014  f8cd9000          STR      r9,[sp,#0]
000018  f7fffffe          BL       RMP_Line
;;;3474       RMP_Line(Coord_X+Length-1,Coord_Y,Coord_X+Length-1,Coord_Y+Width-1,RMP_CTL_WHITE);
00001c  1e62              SUBS     r2,r4,#1
00001e  f64f78ff          MOV      r8,#0xffff
000022  442f              ADD      r7,r7,r5
000024  4610              MOV      r0,r2
000026  1e7b              SUBS     r3,r7,#1
000028  4629              MOV      r1,r5
00002a  f8cd8000          STR      r8,[sp,#0]
00002e  f7fffffe          BL       RMP_Line
;;;3475       RMP_Line(Coord_X+Length-1,Coord_Y+Width-1,Coord_X,Coord_Y+Width-1,RMP_CTL_WHITE);
000032  1e7b              SUBS     r3,r7,#1
000034  4632              MOV      r2,r6
000036  1e79              SUBS     r1,r7,#1
000038  f8cd8000          STR      r8,[sp,#0]
00003c  1e60              SUBS     r0,r4,#1
00003e  f7fffffe          BL       RMP_Line
;;;3476       RMP_Line(Coord_X,Coord_Y+Width-1,Coord_X,Coord_Y,RMP_CTL_BLACK);
000042  4632              MOV      r2,r6
000044  462b              MOV      r3,r5
000046  1e79              SUBS     r1,r7,#1
000048  4610              MOV      r0,r2
00004a  f8cd9000          STR      r9,[sp,#0]
00004e  f7fffffe          BL       RMP_Line
;;;3477       /* Clear the old shadow */
;;;3478       RMP_Line(Coord_X+Length-2,Coord_Y+Width-2,Coord_X+1,Coord_Y+Width-2,RMP_CTL_GREY);    
000052  1ebb              SUBS     r3,r7,#2
000054  f64b58d7          MOV      r8,#0xbdd7
000058  1eb9              SUBS     r1,r7,#2
00005a  f8cd8000          STR      r8,[sp,#0]
00005e  1ea0              SUBS     r0,r4,#2
000060  1c72              ADDS     r2,r6,#1
000062  f7fffffe          BL       RMP_Line
;;;3479       RMP_Line(Coord_X+Length-2,Coord_Y+1,Coord_X+Length-2,Coord_Y+Width-2,RMP_CTL_GREY);    
000066  1ea2              SUBS     r2,r4,#2
000068  f8cd8000          STR      r8,[sp,#0]
00006c  1ebb              SUBS     r3,r7,#2
00006e  4610              MOV      r0,r2
000070  1c69              ADDS     r1,r5,#1
000072  f7fffffe          BL       RMP_Line
;;;3480       /* The shadow */                            
;;;3481       RMP_Line(Coord_X+1,Coord_Y+Width-2,Coord_X+1,Coord_Y+1,RMP_CTL_DARK);    
000076  1eb9              SUBS     r1,r7,#2
000078  f64738ef          MOV      r8,#0x7bef
00007c  1c6b              ADDS     r3,r5,#1
00007e  f8cd8000          STR      r8,[sp,#0]
000082  1c72              ADDS     r2,r6,#1
000084  1c70              ADDS     r0,r6,#1
000086  f7fffffe          BL       RMP_Line
;;;3482       RMP_Line(Coord_X+1,Coord_Y+1,Coord_X+Length-2,Coord_Y+1,RMP_CTL_DARK);    
00008a  1ea2              SUBS     r2,r4,#2
00008c  f8cd8000          STR      r8,[sp,#0]
000090  1c6b              ADDS     r3,r5,#1
000092  1c69              ADDS     r1,r5,#1
000094  1c70              ADDS     r0,r6,#1
000096  f7fffffe          BL       RMP_Line
;;;3483   }
00009a  e8bd83f8          POP      {r3-r9,pc}
;;;3484   /* End Function:RMP_Cmdbtn_Down **********************************************/
                          ENDP


                          AREA ||i.RMP_Cmdbtn_Up||, CODE, READONLY, ALIGN=1

                  RMP_Cmdbtn_Up PROC
;;;3494   ******************************************************************************/
;;;3495   void RMP_Cmdbtn_Up(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;3496   {
;;;3497       RMP_Line(Coord_X,Coord_Y,Coord_X+Length-1,Coord_Y,RMP_CTL_WHITE);
000004  1885              ADDS     r5,r0,r2
000006  461c              MOV      r4,r3                 ;3496
000008  1e6a              SUBS     r2,r5,#1
00000a  460e              MOV      r6,r1                 ;3496
00000c  4607              MOV      r7,r0                 ;3496
00000e  f64f79ff          MOV      r9,#0xffff
000012  460b              MOV      r3,r1
000014  f8cd9000          STR      r9,[sp,#0]
000018  f7fffffe          BL       RMP_Line
;;;3498       RMP_Line(Coord_X+Length-1,Coord_Y,Coord_X+Length-1,Coord_Y+Width-1,RMP_CTL_BLACK);
00001c  1e6a              SUBS     r2,r5,#1
00001e  f04f0800          MOV      r8,#0
000022  4434              ADD      r4,r4,r6
000024  4610              MOV      r0,r2
000026  1e63              SUBS     r3,r4,#1
000028  4631              MOV      r1,r6
00002a  f8cd8000          STR      r8,[sp,#0]
00002e  f7fffffe          BL       RMP_Line
;;;3499       RMP_Line(Coord_X+Length-1,Coord_Y+Width-1,Coord_X,Coord_Y+Width-1,RMP_CTL_BLACK);
000032  1e63              SUBS     r3,r4,#1
000034  463a              MOV      r2,r7
000036  1e68              SUBS     r0,r5,#1
000038  4619              MOV      r1,r3
00003a  f8cd8000          STR      r8,[sp,#0]
00003e  f7fffffe          BL       RMP_Line
;;;3500       RMP_Line(Coord_X,Coord_Y+Width-1,Coord_X,Coord_Y,RMP_CTL_WHITE);
000042  463a              MOV      r2,r7
000044  4633              MOV      r3,r6
000046  1e61              SUBS     r1,r4,#1
000048  4610              MOV      r0,r2
00004a  f8cd9000          STR      r9,[sp,#0]
00004e  f7fffffe          BL       RMP_Line
;;;3501       /* Clear the old shadow */
;;;3502       RMP_Line(Coord_X+1,Coord_Y+Width-2,Coord_X+1,Coord_Y+1,RMP_CTL_GREY);    
000052  1ea1              SUBS     r1,r4,#2
000054  f64b58d7          MOV      r8,#0xbdd7
000058  1c73              ADDS     r3,r6,#1
00005a  f8cd8000          STR      r8,[sp,#0]
00005e  1c7a              ADDS     r2,r7,#1
000060  1c78              ADDS     r0,r7,#1
000062  f7fffffe          BL       RMP_Line
;;;3503       RMP_Line(Coord_X+1,Coord_Y+1,Coord_X+Length-2,Coord_Y+1,RMP_CTL_GREY);    
000066  1eaa              SUBS     r2,r5,#2
000068  f8cd8000          STR      r8,[sp,#0]
00006c  1c73              ADDS     r3,r6,#1
00006e  1c71              ADDS     r1,r6,#1
000070  1c78              ADDS     r0,r7,#1
000072  f7fffffe          BL       RMP_Line
;;;3504       /* The shadow */
;;;3505       RMP_Line(Coord_X+Length-2,Coord_Y+Width-2,Coord_X+1,Coord_Y+Width-2,RMP_CTL_DARK);    
000076  1ea3              SUBS     r3,r4,#2
000078  f64738ef          MOV      r8,#0x7bef
00007c  1ea8              SUBS     r0,r5,#2
00007e  4619              MOV      r1,r3
000080  1c7a              ADDS     r2,r7,#1
000082  f8cd8000          STR      r8,[sp,#0]
000086  f7fffffe          BL       RMP_Line
;;;3506       RMP_Line(Coord_X+Length-2,Coord_Y+1,Coord_X+Length-2,Coord_Y+Width-2,RMP_CTL_DARK);    
00008a  1eaa              SUBS     r2,r5,#2
00008c  f8cd8000          STR      r8,[sp,#0]
000090  1ea3              SUBS     r3,r4,#2
000092  4610              MOV      r0,r2
000094  1c71              ADDS     r1,r6,#1
000096  f7fffffe          BL       RMP_Line
;;;3507   }
00009a  e8bd83f8          POP      {r3-r9,pc}
;;;3508   /* End Function:RMP_Cmdbtn_Up ************************************************/
                          ENDP


                          AREA ||i.RMP_Cursor||, CODE, READONLY, ALIGN=2

                  RMP_Cursor PROC
;;;3210   #ifdef RMP_CTL_BLACK
;;;3211   void RMP_Cursor(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_ptr_t Style)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;3212   {
;;;3213       rmp_cnt_t Count;
;;;3214       rmp_cnt_t Size_B;
;;;3215       rmp_cnt_t Size_W;
;;;3216       const rmp_u8_t* Black;
;;;3217       const rmp_u8_t* White;
;;;3218   
;;;3219       /* Normal Mouse - all matrix encoded in (Y,X) */
;;;3220       static const rmp_u8_t Arrow_B[]=
;;;3221       {
;;;3222           0x00,0x10,0x11,0x20,0x22,0x30,0x33,0x40,0x44,0x50,0x55,0x60,0x66,0x70,0x77,0x80,
;;;3223           0x88,0x90,0x95,0x96,0x97,0x98,0x99,0xA0,0xA2,0xA3,0xA5,0xB0,0xB1,0xB3,0xB6,0xC0,
;;;3224           0xC1,0xC4,0xC6,0xD0,0xD4,0xD7,0xE5,0xE7,0xF5,0xF6
;;;3225       };
;;;3226       static const rmp_u8_t Arrow_W[]=
;;;3227       {
;;;3228           0x21,0x31,0x32,0x41,0x42,0x43,0x51,0x52,0x53,0x54,0x61,0x62,0x63,0x64,0x65,0x71,
;;;3229           0x72,0x73,0x74,0x75,0x76,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x91,0x92,0x93,0x94,
;;;3230           0xA1,0xA4,0xB4,0xB5,0xC5,0xD5,0xD6,0xE6
;;;3231       };
;;;3232       /* Busy mark - no white part */
;;;3233       static const rmp_u8_t Busy_B[]=
;;;3234       {
;;;3235           0x0A,0x0B,0x0C,0x0D,0x0E,0x1A,0x1B,0x1D,0x1E,0x2A,0x2C,0x2E,0x3B,0x3D,0x4C,0x5B,
;;;3236           0x5D,0x6A,0x6E,0x7A,0x7C,0x7E,0x8A,0x8B,0x8C,0x8D,0x8E
;;;3237       };
;;;3238       static const rmp_u8_t Busy_W[]=
;;;3239       {
;;;3240           0x1C,0x2B,0x2D,0x3C,0x5C,0x6B,0x6C,0x6D,0x7B,0x7D
;;;3241       };
;;;3242       /* Question mark - no white part */
;;;3243       static const rmp_u8_t Question[]=
;;;3244       {
;;;3245           0x0B,0x0C,0x0D,0x1A,0x1B,0x1C,0x1D,0x1E,0x29,0x2A,0x2B,0x2D,0x2E,0x2F,0x39,0x3A,
;;;3246           0x3E,0x3F,0x4A,0x4D,0x4E,0x4F,0x5C,0x5D,0x5E,0x6C,0x6D,0x8D,0x8E,0x9D,0x9E
;;;3247       };
;;;3248       /* Hand-shaped cursor */
;;;3249       static const rmp_u8_t Hand_B[]=
;;;3250       {
;;;3251           0x05,0x06,0x14,0x17,0x24,0x27,0x34,0x37,0x39,0x44,0x47,0x48,0x4A,0x4C,0x51,0x52,
;;;3252           0x54,0x57,0x5A,0x5B,0x5D,0x5E,0x60,0x63,0x64,0x67,0x6A,0x6D,0x6F,0x70,0x74,0x77,
;;;3253           0x7A,0x7D,0x7F,0x80,0x8F,0x90,0x9F,0xA0,0xAF,0xB0,0xBF,0xC1,0xCE,0xD1,0xD2,0xD3,
;;;3254           0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xE1,0xEE,0xF2,0xF3,0xF4,
;;;3255           0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD
;;;3256       };
;;;3257       static const rmp_u8_t Hand_W[]=
;;;3258       {
;;;3259           0x15,0x16,0x25,0x26,0x35,0x36,0x45,0x46,0x49,0x55,0x56,0x58,0x59,0x5C,0x61,0x62,
;;;3260           0x65,0x66,0x68,0x69,0x6B,0x6C,0x6E,0x71,0x72,0x73,0x75,0x76,0x78,0x79,0x7B,0x7C,
;;;3261           0x7E,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x91,
;;;3262           0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0xA1,0xA2,0xA3,
;;;3263           0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xB1,0xB2,0xB3,0xB4,0xB5,
;;;3264           0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,
;;;3265           0xC9,0xCA,0xCB,0xCC,0xCD,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,
;;;3266           0xED
;;;3267       };
;;;3268       /* The cursor for text editing - no white part */
;;;3269       static const rmp_u8_t Text[]=
;;;3270       {
;;;3271           0x00,0x01,0x02,0x04,0x05,0x06,0x13,0x23,0x33,0x43,0x53,0x63,0x73,0x83,0x93,0xA3,
;;;3272           0xB3,0xC3,0xD3,0xE3,0xF0,0xF1,0xF2,0xF4,0xF5,0xF6
;;;3273       };
;;;3274       /* The stop cursor */
;;;3275       static const rmp_u8_t Stop_B[]=
;;;3276       {
;;;3277           0x05,0x06,0x07,0x08,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x22,0x23,0x24,0x29,
;;;3278           0x2A,0x2B,0x31,0x32,0x33,0x34,0x3A,0x3B,0x3C,0x41,0x42,0x43,0x44,0x45,0x4B,0x4C,
;;;3279           0x50,0x51,0x54,0x55,0x56,0x5C,0x5D,0x60,0x61,0x65,0x66,0x67,0x6C,0x6D,0x70,0x71,
;;;3280           0x76,0x77,0x78,0x7C,0x7D,0x80,0x81,0x87,0x88,0x89,0x8C,0x8D,0x91,0x92,0x98,0x99,
;;;3281           0x9A,0x9B,0x9C,0xA1,0xA2,0xA3,0xA9,0xAA,0xAB,0xAC,0xB2,0xB3,0xB4,0xB9,0xBA,0xBB,
;;;3282           0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xD5,0xD6,0xD7,0xD8
;;;3283       };
;;;3284       static const rmp_u8_t Stop_W[]=
;;;3285       {
;;;3286           0x25,0x26,0x27,0x28,0x35,0x36,0x37,0x38,0x39,0x46,0x47,0x48,0x49,0x4A,0x52,0x53,
;;;3287           0x57,0x58,0x59,0x5A,0x5B,0x62,0x63,0x64,0x68,0x69,0x6A,0x6B,0x72,0x73,0x74,0x75,
;;;3288           0x79,0x7A,0x7B,0x82,0x83,0x84,0x85,0x86,0x8A,0x8B,0x93,0x94,0x95,0x96,0x97,0xA4,
;;;3289           0xA5,0xA6,0xA7,0xA8,0xB5,0xB6,0xB7,0xB8
;;;3290       };
;;;3291          /* Cross arrow - no white part  */
;;;3292       static const rmp_u8_t Adj_ALL[]=
;;;3293       {
;;;3294           0x07,0x16,0x17,0x18,0x25,0x26,0x27,0x28,0x29,0x37,0x47,0x52,0x57,0x5C,0x61,0x62,
;;;3295           0x67,0x6C,0x6D,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7A,0x7B,0x7C,
;;;3296           0x7D,0x7E,0x81,0x82,0x87,0x8C,0x8D,0x92,0x97,0x9C,0xA7,0xB7,0xC5,0xC6,0xC7,0xC8,
;;;3297           0xC9,0xD6,0xD7,0xD8,0xE7
;;;3298       };    
;;;3299       /* Left to right arrow - no white part */
;;;3300       static const rmp_u8_t Adj_LR[]=
;;;3301       {
;;;3302           0x52,0x5D,0x61,0x62,0x6D,0x6E,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,
;;;3303           0x7A,0x7B,0x7C,0x7D,0x7E,0x7F,0x81,0x82,0x8D,0x8E,0x92,0x9D
;;;3304       };
;;;3305       /* Up to down arrow - no white part */
;;;3306       static const rmp_u8_t Adj_UD[]=
;;;3307       {
;;;3308           0x07,0x16,0x17,0x18,0x25,0x26,0x27,0x28,0x29,0x37,0x47,0x57,0x67,0x77,0x87,0x97,
;;;3309           0xA7,0xB7,0xC7,0xD5,0xD6,0xD7,0xD8,0xD9,0xE6,0xE7,0xE8,0xF7
;;;3310   
;;;3311       };
;;;3312       /* Bottom-right to top-left arrow - no white part */
;;;3313       static const rmp_u8_t Adj_BRUL[]=
;;;3314       {
;;;3315           0x00,0x01,0x02,0x03,0x04,0x10,0x11,0x12,0x13,0x20,0x21,0x22,0x30,0x31,0x33,0x40,
;;;3316           0x44,0x55,0x66,0x77,0x88,0x99,0xAA,0xBB,0xBF,0xCC,0xCE,0xCF,0xDD,0xDE,0xDF,0xEC,
;;;3317           0xED,0xEE,0xEF,0xFB,0xFC,0xFD,0xFE,0xFF
;;;3318       };
;;;3319       /* Bottom-left to top-right arrow - no white part */
;;;3320       static const rmp_u8_t Adj_BLUR[]=
;;;3321       {
;;;3322           0x0B,0x0C,0x0D,0x0E,0x0F,0x1C,0x1D,0x1E,0x1F,0x2D,0x2E,0x2F,0x3C,0x3E,0x3F,0x4B,
;;;3323           0x4F,0x5A,0x69,0x78,0x87,0x96,0xA5,0xB0,0xB4,0xC0,0xC1,0xC3,0xD0,0xD1,0xD2,0xE0,
;;;3324           0xE1,0xE2,0xE3,0xF0,0xF1,0xF2,0xF3,0xF4
;;;3325       };
;;;3326       /* The crosshair cursor - no white part */
;;;3327       static const rmp_u8_t Cross[]=
;;;3328       {
;;;3329           0x07,0x17,0x27,0x37,0x46,0x47,0x48,0x55,0x57,0x59,0x64,0x6A,0x70,0x71,0x72,0x73,
;;;3330           0x74,0x75,0x77,0x79,0x7A,0x7B,0x7C,0x7D,0x7E,0x84,0x8A,0x95,0x97,0x99,0xA6,0xA7,
;;;3331           0xA8,0xB7,0xC7,0xD7,0xE7
;;;3332       };
;;;3333       
;;;3334       /* Draw them */
;;;3335       switch(Style)
000004  2a0c              CMP      r2,#0xc
000006  4615              MOV      r5,r2                 ;3212
000008  4689              MOV      r9,r1                 ;3212
00000a  4682              MOV      r10,r0                ;3212
;;;3336       {
;;;3337           case RMP_CUR_NORM:{Size_B=sizeof(Arrow_B);Size_W=sizeof(Arrow_W);Black=Arrow_B;White=Arrow_W;break;}
;;;3338           case RMP_CUR_BUSY:case RMP_CUR_QUESTION:
;;;3339           {
;;;3340               for(Count=0;Count<sizeof(Arrow_B);Count++)                                                              
;;;3341                   RMP_POINT(Coord_X+(Arrow_B[Count]&0x0F),Coord_Y+(Arrow_B[Count]>>4),RMP_CTL_BLACK);
;;;3342               for(Count=0;Count<sizeof(Arrow_W);Count++)                                                              
;;;3343                   RMP_POINT(Coord_X+(Arrow_W[Count]&0x0F),Coord_Y+(Arrow_W[Count]>>4),RMP_CTL_WHITE);
00000c  f64f7bff          MOV      r11,#0xffff
000010  d27b              BCS      |L10.266|
000012  e8dff002          TBB      [pc,r2]               ;3335
000016  060d              DCB      0x06,0x0d
000018  0d3c4448          DCB      0x0d,0x3c,0x44,0x48
00001c  5055585d          DCB      0x50,0x55,0x58,0x5d
000020  5f64              DCB      0x5f,0x64
000022  4c42              LDR      r4,|L10.300|
000024  262a              MOVS     r6,#0x2a              ;3337
000026  2528              MOVS     r5,#0x28              ;3337
;;;3344               
;;;3345               if(Style==RMP_CUR_BUSY)
;;;3346               {
;;;3347                   Size_B=sizeof(Busy_B);
;;;3348                   Size_W=sizeof(Busy_W);
;;;3349                   Black=Busy_B;
;;;3350                   White=Busy_W;
;;;3351               }
;;;3352               else
;;;3353               {
;;;3354                   Size_B=sizeof(Question);
;;;3355                   Size_W=0;
;;;3356                   Black=Question;
;;;3357                   White=0;
;;;3358               }
;;;3359               break;
;;;3360           }       
;;;3361           case RMP_CUR_HAND:{Size_B=sizeof(Hand_B);Size_W=sizeof(Hand_W);Black=Hand_B;White=Hand_W;break;}
;;;3362           case RMP_CUR_TEXT:{Size_B=sizeof(Text);Size_W=0;Black=Text;White=0;break;}
;;;3363           case RMP_CUR_STOP:{Size_B=sizeof(Stop_B);Size_W=sizeof(Stop_W);Black=Stop_B;White=Stop_W;break;}
;;;3364           case RMP_CUR_MOVE:{Size_B=sizeof(Adj_ALL);Size_W=0;Black=Adj_ALL;White=0;break;}
;;;3365           case RMP_CUR_LR:{Size_B=sizeof(Adj_LR);Size_W=0;Black=Adj_LR;White=0;break;}
;;;3366           case RMP_CUR_UD:{Size_B=sizeof(Adj_UD);Size_W=0;Black=Adj_UD;White=0;break;}
;;;3367           case RMP_CUR_ULBR:{Size_B=sizeof(Adj_BRUL);Size_W=0;Black=Adj_BRUL;White=0;break;}
;;;3368           case RMP_CUR_URBL:{Size_B=sizeof(Adj_BLUR);Size_W=0;Black=Adj_BLUR;White=0;break;}
;;;3369           case RMP_CUR_CROSS:{Size_B=sizeof(Cross);Size_W=0;Black=Cross;White=0;break;}
;;;3370           default:return;
;;;3371       }
;;;3372       
;;;3373       for(Count=0;Count<Size_B;Count++)                                                              
000028  2700              MOVS     r7,#0
00002a  f104082a          ADD      r8,r4,#0x2a           ;3337
00002e  e05c              B        |L10.234|
000030  4e3e              LDR      r6,|L10.300|
000032  2400              MOVS     r4,#0                 ;3340
                  |L10.52|
000034  5d30              LDRB     r0,[r6,r4]            ;3341
000036  f000020f          AND      r2,r0,#0xf            ;3341
00003a  eb091110          ADD      r1,r9,r0,LSR #4       ;3341
00003e  eb02000a          ADD      r0,r2,r10             ;3341
000042  2200              MOVS     r2,#0                 ;3341
000044  f7fffffe          BL       RMP_Point
000048  1c64              ADDS     r4,r4,#1              ;3341
00004a  2c2a              CMP      r4,#0x2a              ;3340
00004c  d3f2              BCC      |L10.52|
00004e  4e37              LDR      r6,|L10.300|
000050  2400              MOVS     r4,#0                 ;3342
000052  465f              MOV      r7,r11                ;3343
000054  362a              ADDS     r6,r6,#0x2a           ;3337
                  |L10.86|
000056  5d30              LDRB     r0,[r6,r4]            ;3343
000058  f000020f          AND      r2,r0,#0xf            ;3343
00005c  eb091110          ADD      r1,r9,r0,LSR #4       ;3343
000060  eb02000a          ADD      r0,r2,r10             ;3343
000064  463a              MOV      r2,r7                 ;3343
000066  f7fffffe          BL       RMP_Point
00006a  1c64              ADDS     r4,r4,#1              ;3343
00006c  2c28              CMP      r4,#0x28              ;3342
00006e  d3f2              BCC      |L10.86|
000070  2d01              CMP      r5,#1                 ;3345
000072  d004              BEQ      |L10.126|
000074  4c2d              LDR      r4,|L10.300|
000076  2700              MOVS     r7,#0
000078  3477              ADDS     r4,r4,#0x77           ;3356
00007a  261f              MOVS     r6,#0x1f              ;3354
00007c  e033              B        |L10.230|
                  |L10.126|
00007e  4c2b              LDR      r4,|L10.300|
000080  2700              MOVS     r7,#0
000082  261b              MOVS     r6,#0x1b              ;3347
000084  3452              ADDS     r4,r4,#0x52           ;3349
000086  250a              MOVS     r5,#0xa               ;3348
000088  f104081b          ADD      r8,r4,#0x1b           ;3350
00008c  e02d              B        |L10.234|
00008e  4c27              LDR      r4,|L10.300|
000090  2700              MOVS     r7,#0
000092  2649              MOVS     r6,#0x49              ;3361
000094  3496              ADDS     r4,r4,#0x96           ;3361
000096  2571              MOVS     r5,#0x71              ;3361
000098  f1040849          ADD      r8,r4,#0x49           ;3361
00009c  e025              B        |L10.234|
00009e  2700              MOVS     r7,#0
0000a0  4c23              LDR      r4,|L10.304|
0000a2  261a              MOVS     r6,#0x1a              ;3362
0000a4  e01f              B        |L10.230|
0000a6  4c22              LDR      r4,|L10.304|
0000a8  2700              MOVS     r7,#0
0000aa  265c              MOVS     r6,#0x5c              ;3363
0000ac  341a              ADDS     r4,r4,#0x1a           ;3363
0000ae  2538              MOVS     r5,#0x38              ;3363
0000b0  f104085c          ADD      r8,r4,#0x5c           ;3363
0000b4  e019              B        |L10.234|
0000b6  4c1e              LDR      r4,|L10.304|
0000b8  2700              MOVS     r7,#0
0000ba  34ae              ADDS     r4,r4,#0xae           ;3364
0000bc  2635              MOVS     r6,#0x35              ;3364
0000be  e012              B        |L10.230|
0000c0  4c1b              LDR      r4,|L10.304|
0000c2  34e3              ADDS     r4,r4,#0xe3           ;3365
0000c4  e001              B        |L10.202|
0000c6  4c1a              LDR      r4,|L10.304|
0000c8  34ff              ADDS     r4,r4,#0xff           ;3366
                  |L10.202|
0000ca  2700              MOVS     r7,#0
0000cc  261c              MOVS     r6,#0x1c              ;3365
0000ce  e00a              B        |L10.230|
0000d0  4c18              LDR      r4,|L10.308|
0000d2  e001              B        |L10.216|
0000d4  4c17              LDR      r4,|L10.308|
0000d6  3428              ADDS     r4,r4,#0x28           ;3368
                  |L10.216|
0000d8  2700              MOVS     r7,#0
0000da  2628              MOVS     r6,#0x28              ;3367
0000dc  e003              B        |L10.230|
0000de  4c15              LDR      r4,|L10.308|
0000e0  2700              MOVS     r7,#0
0000e2  3450              ADDS     r4,r4,#0x50           ;3369
0000e4  2625              MOVS     r6,#0x25              ;3369
                  |L10.230|
0000e6  2500              MOVS     r5,#0                 ;3369
0000e8  46a8              MOV      r8,r5                 ;3369
                  |L10.234|
;;;3374           RMP_POINT(Coord_X+(Black[Count]&0x0F),Coord_Y+(Black[Count]>>4),RMP_CTL_BLACK);
0000ea  5de0              LDRB     r0,[r4,r7]
0000ec  f000020f          AND      r2,r0,#0xf
0000f0  eb091110          ADD      r1,r9,r0,LSR #4
0000f4  eb02000a          ADD      r0,r2,r10
0000f8  2200              MOVS     r2,#0
0000fa  f7fffffe          BL       RMP_Point
0000fe  1c7f              ADDS     r7,r7,#1
000100  42b7              CMP      r7,r6                 ;3373
000102  dbf2              BLT      |L10.234|
;;;3375       for(Count=0;Count<Size_W;Count++)                                                              
000104  2400              MOVS     r4,#0
000106  465e              MOV      r6,r11                ;3343
000108  e00c              B        |L10.292|
                  |L10.266|
00010a  e00d              B        |L10.296|
                  |L10.268|
;;;3376           RMP_POINT(Coord_X+(White[Count]&0x0F),Coord_Y+(White[Count]>>4),RMP_CTL_WHITE);
00010c  f8180004          LDRB     r0,[r8,r4]
000110  f000020f          AND      r2,r0,#0xf
000114  eb091110          ADD      r1,r9,r0,LSR #4
000118  eb02000a          ADD      r0,r2,r10
00011c  4632              MOV      r2,r6
00011e  f7fffffe          BL       RMP_Point
000122  1c64              ADDS     r4,r4,#1
                  |L10.292|
000124  42ac              CMP      r4,r5                 ;3375
000126  dbf1              BLT      |L10.268|
                  |L10.296|
;;;3377   }
000128  e8bd9ff0          POP      {r4-r12,pc}
;;;3378   /* End Function: RMP_Cursor **************************************************/
                          ENDP

                  |L10.300|
                          DCD      ||.constdata||+0x200
                  |L10.304|
                          DCD      ||.constdata||+0x350
                  |L10.308|
                          DCD      ||.constdata||+0x46b

                          AREA ||i.RMP_Dot_Line||, CODE, READONLY, ALIGN=1

                  RMP_Dot_Line PROC
;;;2736   ******************************************************************************/
;;;2737   void RMP_Dot_Line(rmp_cnt_t Start_X, rmp_cnt_t Start_Y, rmp_cnt_t End_X,rmp_cnt_t End_Y, rmp_ptr_t Dot, rmp_ptr_t Space)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;2738   {
;;;2739       rmp_cnt_t Trav_X;
;;;2740       rmp_cnt_t Trav_Y;
;;;2741       rmp_cnt_t Dir_X;
;;;2742       rmp_cnt_t Dir_Y;
;;;2743       rmp_cnt_t Error;
;;;2744       rmp_cnt_t Cur_X;
;;;2745       rmp_cnt_t Cur_Y;
;;;2746   
;;;2747       Error=0;
;;;2748       /* Get their absolute value, and then draw the line */
;;;2749       Trav_X=(Start_X>End_X)?(Start_X-End_X):(End_X-Start_X);
000004  4290              CMP      r0,r2
000006  f04f0400          MOV      r4,#0                 ;2747
00000a  eba20700          SUB      r7,r2,r0
00000e  dd01              BLE      |L11.20|
000010  1a86              SUBS     r6,r0,r2
000012  e000              B        |L11.22|
                  |L11.20|
000014  463e              MOV      r6,r7
                  |L11.22|
;;;2750       Trav_Y=(Start_Y>End_Y)?(Start_Y-End_Y):(End_Y-Start_Y);
000016  4299              CMP      r1,r3
000018  eba30c01          SUB      r12,r3,r1
00001c  dd01              BLE      |L11.34|
00001e  1acd              SUBS     r5,r1,r3
000020  e000              B        |L11.36|
                  |L11.34|
000022  4665              MOV      r5,r12
                  |L11.36|
;;;2751   
;;;2752       /* Decide the increment direction */
;;;2753       if(End_X-Start_X>0)
000024  2f00              CMP      r7,#0
;;;2754           Dir_X=1;
;;;2755       else
;;;2756           Dir_X=-1;
000026  f04f37ff          MOV      r7,#0xffffffff
00002a  dd02              BLE      |L11.50|
00002c  f04f0901          MOV      r9,#1                 ;2754
000030  e000              B        |L11.52|
                  |L11.50|
000032  46b9              MOV      r9,r7
                  |L11.52|
;;;2757   
;;;2758       if(End_Y-Start_Y>0)
000034  f1bc0f00          CMP      r12,#0
000038  dd00              BLE      |L11.60|
;;;2759           Dir_Y=1;
00003a  2701              MOVS     r7,#1
                  |L11.60|
;;;2760       else
;;;2761           Dir_Y=-1;
;;;2762   
;;;2763       if(Trav_X>Trav_Y)
00003c  42ae              CMP      r6,r5
00003e  46b8              MOV      r8,r7                 ;2761
000040  dd1b              BLE      |L11.122|
;;;2764       {
;;;2765           Cur_Y=Start_Y;
;;;2766           for(Cur_X=Start_X;Cur_X!=End_X+Dir_X;Cur_X+=Dir_X)
000042  eb020a09          ADD      r10,r2,r9
000046  468b              MOV      r11,r1                ;2765
000048  4607              MOV      r7,r0
00004a  e012              B        |L11.114|
                  |L11.76|
;;;2767           {
;;;2768               /* Draw the dot and the white space alternatively */
;;;2769               if((Cur_X&0x01)!=0)
00004c  07f8              LSLS     r0,r7,#31
00004e  d001              BEQ      |L11.84|
;;;2770                   RMP_POINT(Cur_X,Cur_Y,Dot);
000050  9a0a              LDR      r2,[sp,#0x28]
000052  e003              B        |L11.92|
                  |L11.84|
;;;2771               else
;;;2772               {
;;;2773                   if(Space!=RMP_TRANS)
000054  980b              LDR      r0,[sp,#0x2c]
000056  2801              CMP      r0,#1
000058  d004              BEQ      |L11.100|
;;;2774                       RMP_POINT(Cur_X,Cur_Y,Space);
00005a  4602              MOV      r2,r0
                  |L11.92|
00005c  4659              MOV      r1,r11
00005e  4638              MOV      r0,r7
000060  f7fffffe          BL       RMP_Point
                  |L11.100|
;;;2775               }
;;;2776               Error+=Trav_Y;
000064  442c              ADD      r4,r4,r5
;;;2777               if((Error<<1)>=Trav_X)
000066  ebb60f44          CMP      r6,r4,LSL #1
00006a  dc01              BGT      |L11.112|
;;;2778               {
;;;2779                   Cur_Y+=Dir_Y;
;;;2780                   Error-=Trav_X;
00006c  1ba4              SUBS     r4,r4,r6
00006e  44c3              ADD      r11,r11,r8            ;2779
                  |L11.112|
000070  444f              ADD      r7,r7,r9              ;2766
                  |L11.114|
000072  45ba              CMP      r10,r7                ;2766
000074  d1ea              BNE      |L11.76|
                  |L11.118|
;;;2781               }
;;;2782           }
;;;2783       }
;;;2784       else
;;;2785       {
;;;2786           Cur_X=Start_X;
;;;2787           for(Cur_Y=Start_Y;Cur_Y!=End_Y+Dir_Y;Cur_Y+=Dir_Y)
;;;2788           {
;;;2789               /* Draw the dot and the white space alternatively */
;;;2790               if((Cur_Y&0x01)!=0)
;;;2791                   RMP_POINT(Cur_X,Cur_Y,Dot);
;;;2792               else
;;;2793               {
;;;2794                   if(Space!=RMP_TRANS)
;;;2795                       RMP_POINT(Cur_X,Cur_Y,Space);
;;;2796               }
;;;2797   
;;;2798               Error+=Trav_X;
;;;2799               if((Error<<1)>=Trav_Y)
;;;2800               {
;;;2801                   Cur_X+=Dir_X;
;;;2802                   Error-=Trav_Y;
;;;2803               }
;;;2804           }
;;;2805       }
;;;2806   }
000076  e8bd9ff0          POP      {r4-r12,pc}
                  |L11.122|
00007a  eb030a08          ADD      r10,r3,r8             ;2787
00007e  4683              MOV      r11,r0                ;2786
000080  460f              MOV      r7,r1                 ;2787
000082  e012              B        |L11.170|
                  |L11.132|
000084  07f8              LSLS     r0,r7,#31             ;2790
000086  d001              BEQ      |L11.140|
000088  9a0a              LDR      r2,[sp,#0x28]         ;2791
00008a  e003              B        |L11.148|
                  |L11.140|
00008c  980b              LDR      r0,[sp,#0x2c]         ;2794
00008e  2801              CMP      r0,#1                 ;2794
000090  d004              BEQ      |L11.156|
000092  4602              MOV      r2,r0                 ;2795
                  |L11.148|
000094  4639              MOV      r1,r7                 ;2795
000096  4658              MOV      r0,r11                ;2795
000098  f7fffffe          BL       RMP_Point
                  |L11.156|
00009c  4434              ADD      r4,r4,r6              ;2798
00009e  ebb50f44          CMP      r5,r4,LSL #1          ;2799
0000a2  dc01              BGT      |L11.168|
0000a4  1b64              SUBS     r4,r4,r5              ;2802
0000a6  44cb              ADD      r11,r11,r9            ;2801
                  |L11.168|
0000a8  4447              ADD      r7,r7,r8              ;2787
                  |L11.170|
0000aa  45ba              CMP      r10,r7                ;2787
0000ac  d1ea              BNE      |L11.132|
0000ae  e7e2              B        |L11.118|
;;;2807   /* End Function:RMP_Dot_Line *************************************************/
                          ENDP


                          AREA ||i.RMP_Free||, CODE, READONLY, ALIGN=1

                  RMP_Free PROC
;;;2518   ******************************************************************************/
;;;2519   void RMP_Free(volatile void* Pool, void* Mem_Ptr)
000000  b570              PUSH     {r4-r6,lr}
;;;2520   {
000002  0005              MOVS     r5,r0
000004  d039              BEQ      |L12.122|
;;;2521       volatile struct RMP_Mem* Mem; 
;;;2522       volatile struct RMP_Mem_Head* Mem_Head;
;;;2523       volatile struct RMP_Mem_Head* Left_Head;
;;;2524       volatile struct RMP_Mem_Head* Right_Head;
;;;2525       rmp_cnt_t Merge_Left;
;;;2526   
;;;2527       /* Check if pointer is null */
;;;2528       if((Pool==0)||(Mem_Ptr==0))
000006  2900              CMP      r1,#0
000008  d037              BEQ      |L12.122|
;;;2529       {
;;;2530           RMP_COVERAGE_MARKER();
;;;2531           return;
;;;2532       }
;;;2533       else
;;;2534           RMP_COVERAGE_MARKER();
;;;2535       
;;;2536       /* See if the address is within the allocatable address range. If not, abort directly. */
;;;2537       Mem=(volatile struct RMP_Mem*)Pool;
;;;2538       if((((rmp_ptr_t)Mem_Ptr)<=((rmp_ptr_t)Mem))||(((rmp_ptr_t)Mem_Ptr)>=(((rmp_ptr_t)Mem)+Mem->Size)))
00000a  42a9              CMP      r1,r5
00000c  d935              BLS      |L12.122|
00000e  6882              LDR      r2,[r0,#8]
000010  1950              ADDS     r0,r2,r5
000012  4288              CMP      r0,r1
000014  d931              BLS      |L12.122|
;;;2539       {
;;;2540           RMP_COVERAGE_MARKER();
;;;2541           return;
;;;2542       }
;;;2543       else
;;;2544           RMP_COVERAGE_MARKER();
;;;2545   
;;;2546       Mem_Head=(struct RMP_Mem_Head*)(((rmp_ptr_t)Mem_Ptr)-sizeof(struct RMP_Mem_Head));
000016  f1a10410          SUB      r4,r1,#0x10
;;;2547       /* See if the block can really be freed */
;;;2548       if(Mem_Head->State==RMP_MEM_FREE)
00001a  68a0              LDR      r0,[r4,#8]
00001c  2800              CMP      r0,#0
00001e  d02c              BEQ      |L12.122|
;;;2549       {
;;;2550           RMP_COVERAGE_MARKER();
;;;2551           return;
;;;2552       }
;;;2553       else
;;;2554           RMP_COVERAGE_MARKER();
;;;2555   
;;;2556       /* Mark it as free */
;;;2557       Mem_Head->State=RMP_MEM_FREE;
000020  2000              MOVS     r0,#0
000022  60a0              STR      r0,[r4,#8]
;;;2558       
;;;2559       /* Now check if we can merge it with the higher blocks */
;;;2560       Right_Head=(struct RMP_Mem_Head*)(((rmp_ptr_t)(Mem_Head->Tail))+sizeof(struct RMP_Mem_Tail));
000024  68e6              LDR      r6,[r4,#0xc]
;;;2561       if(((rmp_ptr_t)Right_Head)!=(((rmp_ptr_t)Mem)+Mem->Size))
000026  68a9              LDR      r1,[r5,#8]
000028  1d36              ADDS     r6,r6,#4
00002a  1948              ADDS     r0,r1,r5
00002c  42b0              CMP      r0,r6
00002e  d00b              BEQ      |L12.72|
;;;2562       {
;;;2563           RMP_COVERAGE_MARKER();
;;;2564           /* If this one is unoccupied */
;;;2565           if((Right_Head->State)==RMP_MEM_FREE)
000030  68b0              LDR      r0,[r6,#8]
000032  b948              CBNZ     r0,|L12.72|
;;;2566           {
;;;2567               RMP_COVERAGE_MARKER();
;;;2568               /* Delete, merge */
;;;2569               _RMP_Mem_Del(Pool,Right_Head);
000034  4631              MOV      r1,r6
000036  4628              MOV      r0,r5
000038  f7fffffe          BL       _RMP_Mem_Del
;;;2570               _RMP_Mem_Block(Mem_Head,
00003c  68f0              LDR      r0,[r6,#0xc]
00003e  1b01              SUBS     r1,r0,r4
000040  4620              MOV      r0,r4
000042  1d09              ADDS     r1,r1,#4
000044  f7fffffe          BL       _RMP_Mem_Block
                  |L12.72|
;;;2571                              ((rmp_ptr_t)(Right_Head->Tail))+sizeof(struct RMP_Mem_Tail)-(rmp_ptr_t)Mem_Head);
;;;2572           }
;;;2573           else
;;;2574               RMP_COVERAGE_MARKER();
;;;2575       }
;;;2576       else
;;;2577           RMP_COVERAGE_MARKER();
;;;2578   
;;;2579       /* Now check if we can merge it with the lower blocks */
;;;2580       Merge_Left=0;
;;;2581       if((rmp_ptr_t)Mem_Head!=Mem->Start)
000048  6868              LDR      r0,[r5,#4]
00004a  42a0              CMP      r0,r4
00004c  d003              BEQ      |L12.86|
;;;2582       {
;;;2583           RMP_COVERAGE_MARKER();
;;;2584           Left_Head=((struct RMP_Mem_Tail*)(((rmp_ptr_t)Mem_Head)-sizeof(struct RMP_Mem_Tail)))->Head;
00004e  f8546c04          LDR      r6,[r4,#-4]
;;;2585   
;;;2586           /* If this one is unoccupied */
;;;2587           if(Left_Head->State==RMP_MEM_FREE)
000052  68b0              LDR      r0,[r6,#8]
000054  b128              CBZ      r0,|L12.98|
                  |L12.86|
;;;2588           {
;;;2589               RMP_COVERAGE_MARKER();
;;;2590               /* Delete, merge */
;;;2591               _RMP_Mem_Del(Pool, Left_Head);
;;;2592               _RMP_Mem_Block(Left_Head,
;;;2593                              (rmp_ptr_t)((rmp_ptr_t)(Mem_Head->Tail)+sizeof(struct RMP_Mem_Tail)-(rmp_ptr_t)Left_Head));
;;;2594   
;;;2595               /* We have completed the merge here and the original block has destroyed.
;;;2596                * Thus there's no need to insert it into the list again */
;;;2597               Merge_Left=1;
;;;2598           }
;;;2599           else
;;;2600               RMP_COVERAGE_MARKER();
;;;2601       }
;;;2602       else
;;;2603           RMP_COVERAGE_MARKER();
;;;2604   
;;;2605       /* If we did not merge it with the left-side blocks, insert the original pointer's block 
;;;2606        * into the TLSF table(Merging with the right-side one won't disturb this) */
;;;2607       if(Merge_Left==0)
;;;2608       {
;;;2609           RMP_COVERAGE_MARKER();
;;;2610           _RMP_Mem_Ins(Pool, Mem_Head);
000056  4621              MOV      r1,r4
                  |L12.88|
000058  4628              MOV      r0,r5
00005a  e8bd4070          POP      {r4-r6,lr}
00005e  f7ffbffe          B.W      _RMP_Mem_Ins
                  |L12.98|
000062  4631              MOV      r1,r6                 ;2591
000064  4628              MOV      r0,r5                 ;2591
000066  f7fffffe          BL       _RMP_Mem_Del
00006a  68e0              LDR      r0,[r4,#0xc]          ;2592
00006c  1b81              SUBS     r1,r0,r6              ;2592
00006e  4630              MOV      r0,r6                 ;2592
000070  1d09              ADDS     r1,r1,#4              ;2592
000072  f7fffffe          BL       _RMP_Mem_Block
;;;2611       }
;;;2612       else
;;;2613       {
;;;2614           RMP_COVERAGE_MARKER();
;;;2615           _RMP_Mem_Ins(Pool, Left_Head);
000076  4631              MOV      r1,r6
000078  e7ee              B        |L12.88|
                  |L12.122|
;;;2616       }
;;;2617   }
00007a  bd70              POP      {r4-r6,pc}
;;;2618   /* End Function:RMP_Free *****************************************************/
                          ENDP


                          AREA ||i.RMP_Init||, CODE, READONLY, ALIGN=1

                  RMP_Init PROC
;;;1971   ******************************************************************************/
;;;1972   void RMP_Init(void)
000000  f7fffffe          BL       RMP_Lock_Sched
;;;1973   {
;;;1974       RMP_Lock_Sched();
;;;1975       
;;;1976       /* Platform will use this hook to do something */
;;;1977       _RMP_Plat_Hook();
000004  f7fffffe          BL       _RMP_Plat_Hook
;;;1978       /* Start the second thread here */
;;;1979       RMP_Init_Hook();
000008  f7fffffe          BL       RMP_Init_Hook
;;;1980       
;;;1981       RMP_Unlock_Sched();
00000c  f7fffffe          BL       RMP_Unlock_Sched
                  |L13.16|
;;;1982       
;;;1983       while(1)
;;;1984           RMP_Init_Idle();
000010  f7fffffe          BL       RMP_Init_Idle
000014  e7fc              B        |L13.16|
;;;1985   }
;;;1986   /* End Function:RMP_Init *****************************************************/
                          ENDP


                          AREA ||i.RMP_LSB_Get||, CODE, READONLY, ALIGN=1

                  RMP_LSB_Get PROC
;;;2119   ******************************************************************************/
;;;2120   rmp_ptr_t RMP_LSB_Get(rmp_ptr_t Val)
000000  b510              PUSH     {r4,lr}
;;;2121   {
;;;2122       return RMP_WORD_SIZE-1-RMP_MSB_Get(RMP_RBIT_Get(Val));
000002  f7fffffe          BL       RMP_RBIT_Get
000006  f7fffffe          BL       RMP_MSB_Get
00000a  f1c0001f          RSB      r0,r0,#0x1f
;;;2123   }
00000e  bd10              POP      {r4,pc}
;;;2124   /* End Function:RMP_LSB_Get **************************************************/
                          ENDP


                          AREA ||i.RMP_Line||, CODE, READONLY, ALIGN=1

                  RMP_Line PROC
;;;2630   #ifdef RMP_POINT
;;;2631   void RMP_Line(rmp_cnt_t Start_X, rmp_cnt_t Start_Y, rmp_cnt_t End_X, rmp_cnt_t End_Y, rmp_ptr_t Color)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;2632   {
;;;2633       rmp_cnt_t Trav_X;
;;;2634       rmp_cnt_t Trav_Y;
;;;2635       rmp_cnt_t Dir_X;
;;;2636       rmp_cnt_t Dir_Y;
;;;2637       rmp_cnt_t Error;
;;;2638       rmp_cnt_t Cur_X;
;;;2639       rmp_cnt_t Cur_Y;
;;;2640       
;;;2641       /* See if this line is horizontal or vertical. If so we speed it up */
;;;2642       if(Start_X==End_X)
000004  4290              CMP      r0,r2
000006  460c              MOV      r4,r1                 ;2632
000008  4605              MOV      r5,r0                 ;2632
00000a  d110              BNE      |L15.46|
;;;2643       {
;;;2644           /* Vertical */
;;;2645           if(Start_Y>End_Y)
00000c  429c              CMP      r4,r3
00000e  dd01              BLE      |L15.20|
;;;2646           {
;;;2647               Dir_Y=End_Y;
000010  461e              MOV      r6,r3
;;;2648               Trav_Y=Start_Y;
000012  e008              B        |L15.38|
                  |L15.20|
;;;2649           }
;;;2650           else
;;;2651           {
;;;2652               Dir_Y=Start_Y;
000014  460e              MOV      r6,r1
;;;2653               Trav_Y=End_Y;
000016  461c              MOV      r4,r3
000018  e005              B        |L15.38|
                  |L15.26|
;;;2654           }
;;;2655           
;;;2656           for(Cur_Y=Dir_Y;Cur_Y<=Trav_Y;Cur_Y++)
;;;2657               RMP_POINT(Start_X,Cur_Y,Color);
00001a  9a0a              LDR      r2,[sp,#0x28]
00001c  4631              MOV      r1,r6
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       RMP_Point
000024  1c76              ADDS     r6,r6,#1
                  |L15.38|
000026  42a6              CMP      r6,r4                 ;2656
000028  ddf7              BLE      |L15.26|
                  |L15.42|
;;;2658           return;
;;;2659       }
;;;2660       else if(Start_Y==End_Y)
;;;2661       {
;;;2662           /* Horizontal */
;;;2663           if(Start_X>End_X)
;;;2664           {
;;;2665               Dir_X=End_X;
;;;2666               Trav_X=Start_X;
;;;2667           }
;;;2668           else
;;;2669           {
;;;2670               Dir_X=Start_X;
;;;2671               Trav_X=End_X;
;;;2672           }
;;;2673           
;;;2674           for(Cur_X=Dir_X;Cur_X<=Trav_X;Cur_X++)
;;;2675               RMP_POINT(Cur_X,Start_Y,Color);
;;;2676           return;
;;;2677       }
;;;2678   
;;;2679       Error=0;
;;;2680       /* Get their absolute value, and then draw the line */
;;;2681       Trav_X=(Start_X>End_X)?(Start_X-End_X):(End_X-Start_X);
;;;2682       Trav_Y=(Start_Y>End_Y)?(Start_Y-End_Y):(End_Y-Start_Y);
;;;2683   
;;;2684       /* Decide the increment direction */
;;;2685       if(End_X-Start_X>0)
;;;2686           Dir_X=1;
;;;2687       else
;;;2688           Dir_X=-1;
;;;2689   
;;;2690       if(End_Y-Start_Y>0)
;;;2691           Dir_Y=1;
;;;2692       else
;;;2693           Dir_Y=-1;
;;;2694   
;;;2695       if(Trav_X>Trav_Y)
;;;2696       {
;;;2697           Cur_Y=Start_Y;
;;;2698           for(Cur_X=Start_X;Cur_X!=End_X+Dir_X;Cur_X+=Dir_X)
;;;2699           {
;;;2700               RMP_POINT(Cur_X,Cur_Y,Color);
;;;2701               Error+=Trav_Y;
;;;2702               if((Error<<1)>=Trav_X)
;;;2703               {
;;;2704                   Cur_Y+=Dir_Y;
;;;2705                   Error-=Trav_X;
;;;2706               }
;;;2707           }
;;;2708       }
;;;2709       else
;;;2710       {
;;;2711           Cur_X=Start_X;
;;;2712           for(Cur_Y=Start_Y;Cur_Y!=End_Y+Dir_Y;Cur_Y+=Dir_Y)
;;;2713           {
;;;2714               RMP_POINT(Cur_X,Cur_Y,Color);
;;;2715               Error+=Trav_X;
;;;2716               if((Error<<1)>=Trav_Y)
;;;2717               {
;;;2718                   Cur_X+=Dir_X;
;;;2719                   Error-=Trav_Y;
;;;2720               }
;;;2721           }
;;;2722       }
;;;2723   }
00002a  e8bd9ff0          POP      {r4-r12,pc}
                  |L15.46|
00002e  429c              CMP      r4,r3                 ;2660
000030  d10f              BNE      |L15.82|
000032  4295              CMP      r5,r2                 ;2663
000034  dd01              BLE      |L15.58|
000036  4616              MOV      r6,r2                 ;2665
000038  e008              B        |L15.76|
                  |L15.58|
00003a  4606              MOV      r6,r0                 ;2670
00003c  4615              MOV      r5,r2                 ;2671
00003e  e005              B        |L15.76|
                  |L15.64|
000040  9a0a              LDR      r2,[sp,#0x28]         ;2675
000042  4621              MOV      r1,r4                 ;2675
000044  4630              MOV      r0,r6                 ;2675
000046  f7fffffe          BL       RMP_Point
00004a  1c76              ADDS     r6,r6,#1              ;2675
                  |L15.76|
00004c  42ae              CMP      r6,r5                 ;2674
00004e  ddf7              BLE      |L15.64|
000050  e7eb              B        |L15.42|
                  |L15.82|
000052  2600              MOVS     r6,#0                 ;2679
000054  1b51              SUBS     r1,r2,r5              ;2681
000056  4295              CMP      r5,r2                 ;2681
000058  dd01              BLE      |L15.94|
00005a  1aa8              SUBS     r0,r5,r2              ;2681
00005c  e000              B        |L15.96|
                  |L15.94|
00005e  4608              MOV      r0,r1                 ;2681
                  |L15.96|
000060  4680              MOV      r8,r0                 ;2681
000062  1b18              SUBS     r0,r3,r4              ;2682
000064  429c              CMP      r4,r3                 ;2682
000066  dd01              BLE      |L15.108|
000068  1ae7              SUBS     r7,r4,r3              ;2682
00006a  e000              B        |L15.110|
                  |L15.108|
00006c  4607              MOV      r7,r0                 ;2682
                  |L15.110|
00006e  2900              CMP      r1,#0                 ;2685
000070  f04f31ff          MOV      r1,#0xffffffff        ;2688
000074  dd02              BLE      |L15.124|
000076  f04f0a01          MOV      r10,#1                ;2686
00007a  e000              B        |L15.126|
                  |L15.124|
00007c  468a              MOV      r10,r1                ;2688
                  |L15.126|
00007e  2800              CMP      r0,#0                 ;2690
000080  dd02              BLE      |L15.136|
000082  f04f0901          MOV      r9,#1                 ;2691
000086  e000              B        |L15.138|
                  |L15.136|
000088  4689              MOV      r9,r1                 ;2693
                  |L15.138|
00008a  45b8              CMP      r8,r7                 ;2695
00008c  dd12              BLE      |L15.180|
00008e  eb020b0a          ADD      r11,r2,r10            ;2698
000092  e00c              B        |L15.174|
                  |L15.148|
000094  9a0a              LDR      r2,[sp,#0x28]         ;2700
000096  4621              MOV      r1,r4                 ;2700
000098  4628              MOV      r0,r5                 ;2700
00009a  f7fffffe          BL       RMP_Point
00009e  443e              ADD      r6,r6,r7              ;2701
0000a0  ebb80f46          CMP      r8,r6,LSL #1          ;2702
0000a4  dc02              BGT      |L15.172|
0000a6  444c              ADD      r4,r4,r9              ;2704
0000a8  eba60608          SUB      r6,r6,r8              ;2705
                  |L15.172|
0000ac  4455              ADD      r5,r5,r10             ;2698
                  |L15.174|
0000ae  45ab              CMP      r11,r5                ;2698
0000b0  d1f0              BNE      |L15.148|
0000b2  e7ba              B        |L15.42|
                  |L15.180|
0000b4  eb030b09          ADD      r11,r3,r9             ;2712
0000b8  e00b              B        |L15.210|
                  |L15.186|
0000ba  9a0a              LDR      r2,[sp,#0x28]         ;2714
0000bc  4621              MOV      r1,r4                 ;2714
0000be  4628              MOV      r0,r5                 ;2714
0000c0  f7fffffe          BL       RMP_Point
0000c4  4446              ADD      r6,r6,r8              ;2715
0000c6  ebb70f46          CMP      r7,r6,LSL #1          ;2716
0000ca  dc01              BGT      |L15.208|
0000cc  1bf6              SUBS     r6,r6,r7              ;2719
0000ce  4455              ADD      r5,r5,r10             ;2718
                  |L15.208|
0000d0  444c              ADD      r4,r4,r9              ;2712
                  |L15.210|
0000d2  45a3              CMP      r11,r4                ;2712
0000d4  d1f1              BNE      |L15.186|
0000d6  e7a8              B        |L15.42|
;;;2724   /* End Function:RMP_Line *****************************************************/
                          ENDP


                          AREA ||i.RMP_Lineedit||, CODE, READONLY, ALIGN=1

                  RMP_Lineedit PROC
;;;3557   ******************************************************************************/
;;;3558   void RMP_Lineedit(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;3559   {
;;;3560       RMP_Rectangle(Coord_X,Coord_Y,Length,Width,RMP_CTL_WHITE,RMP_CTL_WHITE);
000004  f64f78ff          MOV      r8,#0xffff
000008  4606              MOV      r6,r0                 ;3559
00000a  469a              MOV      r10,r3                ;3559
00000c  4614              MOV      r4,r2                 ;3559
00000e  460d              MOV      r5,r1                 ;3559
000010  f8cd8000          STR      r8,[sp,#0]
000014  f8cd8004          STR      r8,[sp,#4]
000018  f7fffffe          BL       RMP_Rectangle
;;;3561       
;;;3562       /* Now draw the border */
;;;3563       RMP_Line(Coord_X,Coord_Y,Coord_X+Length-1,Coord_Y,RMP_CTL_DARK);
00001c  1937              ADDS     r7,r6,r4
00001e  462b              MOV      r3,r5
000020  1e7a              SUBS     r2,r7,#1
000022  f64739ef          MOV      r9,#0x7bef
000026  4619              MOV      r1,r3
000028  4630              MOV      r0,r6
00002a  f8cd9000          STR      r9,[sp,#0]
00002e  f7fffffe          BL       RMP_Line
;;;3564       RMP_Line(Coord_X+Length-1,Coord_Y,Coord_X+Length-1,Coord_Y+Width-1,RMP_CTL_WHITE);
000032  eb05040a          ADD      r4,r5,r10
000036  4629              MOV      r1,r5
000038  1e7a              SUBS     r2,r7,#1
00003a  f8cd8000          STR      r8,[sp,#0]
00003e  1e78              SUBS     r0,r7,#1
000040  1e63              SUBS     r3,r4,#1
000042  f7fffffe          BL       RMP_Line
;;;3565       RMP_Line(Coord_X+Length-1,Coord_Y+Width-1,Coord_X,Coord_Y+Width-1,RMP_CTL_WHITE);
000046  1e63              SUBS     r3,r4,#1
000048  4632              MOV      r2,r6
00004a  1e78              SUBS     r0,r7,#1
00004c  4619              MOV      r1,r3
00004e  f8cd8000          STR      r8,[sp,#0]
000052  f7fffffe          BL       RMP_Line
;;;3566       RMP_Line(Coord_X,Coord_Y+Width-1,Coord_X,Coord_Y,RMP_CTL_DARK);
000056  4632              MOV      r2,r6
000058  462b              MOV      r3,r5
00005a  1e61              SUBS     r1,r4,#1
00005c  4610              MOV      r0,r2
00005e  f8cd9000          STR      r9,[sp,#0]
000062  f7fffffe          BL       RMP_Line
;;;3567       /* The shadow */
;;;3568       RMP_Line(Coord_X+1,Coord_Y+Width-2,Coord_X+1,Coord_Y+1,RMP_CTL_BLACK);    
000066  1ea1              SUBS     r1,r4,#2
000068  f04f0800          MOV      r8,#0
00006c  1c6b              ADDS     r3,r5,#1
00006e  f8cd8000          STR      r8,[sp,#0]
000072  1c72              ADDS     r2,r6,#1
000074  1c70              ADDS     r0,r6,#1
000076  f7fffffe          BL       RMP_Line
;;;3569       RMP_Line(Coord_X+1,Coord_Y+1,Coord_X+Length-2,Coord_Y+1,RMP_CTL_BLACK);
00007a  1eba              SUBS     r2,r7,#2
00007c  f8cd8000          STR      r8,[sp,#0]
000080  1c6b              ADDS     r3,r5,#1
000082  1c69              ADDS     r1,r5,#1
000084  1c70              ADDS     r0,r6,#1
000086  f7fffffe          BL       RMP_Line
;;;3570   }
00008a  e8bd87fc          POP      {r2-r10,pc}
;;;3571   /* End Function:RMP_Lineedit *************************************************/
                          ENDP


                          AREA ||i.RMP_Lineedit_Clr||, CODE, READONLY, ALIGN=1

                  RMP_Lineedit_Clr PROC
;;;3541   ******************************************************************************/
;;;3542   void RMP_Lineedit_Clr(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length,
000000  b51c              PUSH     {r2-r4,lr}
;;;3543                         rmp_cnt_t Width, rmp_cnt_t Clr_X, rmp_cnt_t Clr_Len)
;;;3544   {
;;;3545       RMP_Rectangle(Clr_X,Coord_Y+1,Clr_Len,Width-2,RMP_CTL_WHITE,RMP_CTL_WHITE);
000002  f64f74ff          MOV      r4,#0xffff
000006  1c49              ADDS     r1,r1,#1
000008  e9dd0204          LDRD     r0,r2,[sp,#0x10]      ;3544
00000c  1e9b              SUBS     r3,r3,#2
00000e  9400              STR      r4,[sp,#0]
000010  9401              STR      r4,[sp,#4]
000012  f7fffffe          BL       RMP_Rectangle
;;;3546   }
000016  bd1c              POP      {r2-r4,pc}
;;;3547   /* End Function:RMP_Lineedit_Clr *********************************************/
                          ENDP


                          AREA ||i.RMP_List_Crt||, CODE, READONLY, ALIGN=1

                  RMP_List_Crt PROC
;;;231    ******************************************************************************/
;;;232    void RMP_List_Crt(volatile struct RMP_List* Head)
000000  6000              STR      r0,[r0,#0]
;;;233    {
;;;234        Head->Prev=(struct RMP_List*)Head;
;;;235        Head->Next=(struct RMP_List*)Head;
000002  6040              STR      r0,[r0,#4]
;;;236    }
000004  4770              BX       lr
;;;237    /* End Function:RMP_List_Crt *************************************************/
                          ENDP


                          AREA ||i.RMP_List_Del||, CODE, READONLY, ALIGN=1

                  RMP_List_Del PROC
;;;245    ******************************************************************************/
;;;246    void RMP_List_Del(volatile struct RMP_List* Prev,volatile struct RMP_List* Next)
000000  6008              STR      r0,[r1,#0]
;;;247    {
;;;248        Next->Prev=(struct RMP_List*)Prev;
;;;249        Prev->Next=(struct RMP_List*)Next;
000002  6041              STR      r1,[r0,#4]
;;;250    }
000004  4770              BX       lr
;;;251    /* End Function:RMP_List_Del *************************************************/
                          ENDP


                          AREA ||i.RMP_List_Ins||, CODE, READONLY, ALIGN=1

                  RMP_List_Ins PROC
;;;260    ******************************************************************************/
;;;261    void RMP_List_Ins(volatile struct RMP_List* New,
000000  6010              STR      r0,[r2,#0]
;;;262                      volatile struct RMP_List* Prev,
;;;263                      volatile struct RMP_List* Next)
;;;264    {
;;;265        Next->Prev=(struct RMP_List*)New;
;;;266        New->Next=(struct RMP_List*)Next;
000002  6042              STR      r2,[r0,#4]
;;;267        New->Prev=(struct RMP_List*)Prev;
000004  6001              STR      r1,[r0,#0]
;;;268        Prev->Next=(struct RMP_List*)New;
000006  6048              STR      r0,[r1,#4]
;;;269    }
000008  4770              BX       lr
;;;270    /* End Function:RMP_List_Ins *************************************************/
                          ENDP


                          AREA ||i.RMP_Load_Ctx||, CODE, READONLY, ALIGN=1

                  RMP_Load_Ctx PROC
;;;1956   #if(RMP_USE_HOOKS==RMP_FALSE)
;;;1957   void RMP_Load_Ctx(void)
000000  4770              BX       lr
;;;1958   {
;;;1959       return;
;;;1960   }
;;;1961   #endif
                          ENDP


                          AREA ||i.RMP_Lock_Sched||, CODE, READONLY, ALIGN=2

                  RMP_Lock_Sched PROC
;;;361    ******************************************************************************/
;;;362    void RMP_Lock_Sched(void)
000000  20ff              MOVS     r0,#0xff
;;;363    {
000002  b510              PUSH     {r4,lr}
;;;364        RMP_MASK_INT();
000004  f7fffffe          BL       RMP_Mask_Int
;;;365        RMP_Sched_Locked=1;
000008  4803              LDR      r0,|L22.24|
00000a  2101              MOVS     r1,#1
00000c  6081              STR      r1,[r0,#8]  ; RMP_Sched_Locked
;;;366        RMP_Sched_Lock_Cnt++;
00000e  6841              LDR      r1,[r0,#4]  ; RMP_Sched_Lock_Cnt
000010  1c49              ADDS     r1,r1,#1
000012  6041              STR      r1,[r0,#4]  ; RMP_Sched_Lock_Cnt
;;;367    }
000014  bd10              POP      {r4,pc}
;;;368    /* End Function:RMP_Lock_Sched ***********************************************/
                          ENDP

000016  0000              DCW      0x0000
                  |L22.24|
                          DCD      ||.data||

                          AREA ||i.RMP_Malloc||, CODE, READONLY, ALIGN=1

                  RMP_Malloc PROC
;;;2445   ******************************************************************************/
;;;2446   void* RMP_Malloc(volatile void* Pool, rmp_ptr_t Size)                                                       
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;2447   {    
000004  0006              MOVS     r6,r0
000006  d00c              BEQ      |L23.34|
;;;2448       rmp_cnt_t FLI_Level;
;;;2449       rmp_cnt_t SLI_Level;
;;;2450       volatile struct RMP_Mem* Mem;
;;;2451       rmp_ptr_t Old_Size;
;;;2452       volatile struct RMP_Mem_Head* Mem_Head;
;;;2453       rmp_ptr_t Rounded_Size;
;;;2454       volatile struct RMP_Mem_Head* New_Mem;
;;;2455       rmp_ptr_t New_Size;
;;;2456       
;;;2457       if((Pool==0)||(Size==0))
000008  b159              CBZ      r1,|L23.34|
00000a  1dc9              ADDS     r1,r1,#7
;;;2458       {
;;;2459           RMP_COVERAGE_MARKER();
;;;2460           return (void*)(0);
;;;2461       }
;;;2462       else
;;;2463           RMP_COVERAGE_MARKER();
;;;2464       
;;;2465       /* Round up the size:a multiple of 8 and bigger than 64B */
;;;2466       Rounded_Size=RMP_ROUND_UP(Size,3);
00000c  f0210407          BIC      r4,r1,#7
;;;2467       /* See if it is smaller than the smallest block */
;;;2468       Rounded_Size=(Rounded_Size>64)?Rounded_Size:64;
000010  2c40              CMP      r4,#0x40
000012  d800              BHI      |L23.22|
000014  2440              MOVS     r4,#0x40
                  |L23.22|
;;;2469   
;;;2470       /* See if such block exists, if not, abort */
;;;2471       if(_RMP_Mem_Search(Pool,Rounded_Size,&FLI_Level,&SLI_Level)!=0)
000016  466a              MOV      r2,sp
000018  ab01              ADD      r3,sp,#4
00001a  4621              MOV      r1,r4
00001c  f7fffffe          BL       _RMP_Mem_Search
000020  b110              CBZ      r0,|L23.40|
                  |L23.34|
;;;2472       {
;;;2473           RMP_COVERAGE_MARKER();
;;;2474           return (void*)(0);
000022  2000              MOVS     r0,#0
                  |L23.36|
;;;2475       }
;;;2476       else
;;;2477           RMP_COVERAGE_MARKER();
;;;2478       
;;;2479       Mem=(volatile struct RMP_Mem*)Pool;
;;;2480       
;;;2481       /* There is such block. Get it and delete it from the TLSF list. */
;;;2482       Mem_Head=(struct RMP_Mem_Head*)(Mem->Table[RMP_MEM_POS(FLI_Level,SLI_Level)].Next);
;;;2483       _RMP_Mem_Del(Pool, Mem_Head);
;;;2484   
;;;2485       /* Allocate and calculate if the space left could be big enough to be a new 
;;;2486        * block. If so, we will put the block back into the TLSF table */
;;;2487       New_Size=((rmp_ptr_t)(Mem_Head->Tail))-((rmp_ptr_t)Mem_Head)-sizeof(struct RMP_Mem_Head)-Rounded_Size;
;;;2488       if(New_Size>=(sizeof(struct RMP_Mem_Head)+64+sizeof(struct RMP_Mem_Tail)))
;;;2489       {
;;;2490           RMP_COVERAGE_MARKER();
;;;2491           Old_Size=sizeof(struct RMP_Mem_Head)+Rounded_Size+sizeof(struct RMP_Mem_Tail);
;;;2492           New_Mem=(volatile struct RMP_Mem_Head*)(((rmp_ptr_t)Mem_Head)+Old_Size);
;;;2493   
;;;2494           _RMP_Mem_Block(Mem_Head, Old_Size);
;;;2495           _RMP_Mem_Block(New_Mem, New_Size);
;;;2496   
;;;2497           /* Put the extra block back */
;;;2498           _RMP_Mem_Ins(Pool, New_Mem);
;;;2499       }
;;;2500       else
;;;2501           RMP_COVERAGE_MARKER();
;;;2502   
;;;2503       /* Mark the block as in use */
;;;2504       Mem_Head->State=RMP_MEM_USED;
;;;2505   
;;;2506       /* Finally, return the start address */
;;;2507       return (void*)(((rmp_ptr_t)Mem_Head)+sizeof(struct RMP_Mem_Head));
;;;2508   }
000024  e8bd81fc          POP      {r2-r8,pc}
                  |L23.40|
000028  68f0              LDR      r0,[r6,#0xc]          ;2482
00002a  e9dd2100          LDRD     r2,r1,[sp,#0]         ;2482
00002e  eb0101c2          ADD      r1,r1,r2,LSL #3       ;2482
000032  2204              MOVS     r2,#4                 ;2482
000034  eb0201c1          ADD      r1,r2,r1,LSL #3       ;2482
000038  5845              LDR      r5,[r0,r1]            ;2482
00003a  4630              MOV      r0,r6                 ;2483
00003c  4629              MOV      r1,r5                 ;2483
00003e  f7fffffe          BL       _RMP_Mem_Del
000042  68e8              LDR      r0,[r5,#0xc]          ;2487
000044  1b40              SUBS     r0,r0,r5              ;2487
000046  1b07              SUBS     r7,r0,r4              ;2487
000048  3f10              SUBS     r7,r7,#0x10           ;2487
00004a  2f54              CMP      r7,#0x54              ;2488
00004c  d30d              BCC      |L23.106|
00004e  f1040114          ADD      r1,r4,#0x14           ;2491
000052  4628              MOV      r0,r5                 ;2494
000054  186c              ADDS     r4,r5,r1              ;2492
000056  f7fffffe          BL       _RMP_Mem_Block
00005a  4639              MOV      r1,r7                 ;2495
00005c  4620              MOV      r0,r4                 ;2495
00005e  f7fffffe          BL       _RMP_Mem_Block
000062  4621              MOV      r1,r4                 ;2498
000064  4630              MOV      r0,r6                 ;2498
000066  f7fffffe          BL       _RMP_Mem_Ins
                  |L23.106|
00006a  2001              MOVS     r0,#1                 ;2504
00006c  60a8              STR      r0,[r5,#8]            ;2504
00006e  f1050010          ADD      r0,r5,#0x10           ;2507
000072  e7d7              B        |L23.36|
;;;2509   /* End Function:RMP_Malloc ***************************************************/
                          ENDP


                          AREA ||i.RMP_Matrix||, CODE, READONLY, ALIGN=2

                  RMP_Matrix PROC
;;;3010   ******************************************************************************/
;;;3011   void RMP_Matrix(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, const rmp_u8_t* Matrix,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;3012                   rmp_cnt_t Bit_Order, rmp_cnt_t Length, rmp_cnt_t Width, rmp_ptr_t Color)
;;;3013   {
000004  ea5f0902          MOVS     r9,r2
000008  4682              MOV      r10,r0
00000a  e9dd020a          LDRD     r0,r2,[sp,#0x28]
00000e  d029              BEQ      |L24.100|
;;;3014       rmp_cnt_t Len_Cnt;
;;;3015       rmp_cnt_t Wid_Cnt;
;;;3016       rmp_cnt_t Mat_Pos;
;;;3017       
;;;3018       if((Matrix==0)||((Length&0x07)!=0)||(Length==0)||(Width==0))
000010  0744              LSLS     r4,r0,#29
000012  d127              BNE      |L24.100|
000014  2800              CMP      r0,#0
000016  d025              BEQ      |L24.100|
000018  2a00              CMP      r2,#0
00001a  d023              BEQ      |L24.100|
;;;3019           return;
;;;3020       
;;;3021       Mat_Pos=0;
;;;3022       /* Natural order */
;;;3023       if(Bit_Order==RMP_MAT_BIG)
;;;3024       {
;;;3025           for(Wid_Cnt=Coord_Y;Wid_Cnt<Width+Coord_Y;Wid_Cnt++)
00001c  1857              ADDS     r7,r2,r1
00001e  f04f0b01          MOV      r11,#1                ;3013
000022  2b01              CMP      r3,#1                 ;3023
;;;3026           {
;;;3027               for(Len_Cnt=Coord_X;Len_Cnt<Length+Coord_X;Len_Cnt++)
;;;3028               {
;;;3029                   if(RMP_MAT_BPOS(Matrix,Mat_Pos)!=0)
;;;3030                       RMP_Point(Len_Cnt,Wid_Cnt,Color);
;;;3031                   Mat_Pos++;
;;;3032               }
;;;3033           }
;;;3034       }
;;;3035       /* Small order */
;;;3036       else
;;;3037       {
;;;3038           for(Wid_Cnt=Coord_Y;Wid_Cnt<Width+Coord_Y;Wid_Cnt++)
000024  4688              MOV      r8,r1
000026  eb00060a          ADD      r6,r0,r10             ;3027
00002a  d019              BEQ      |L24.96|
00002c  e032              B        |L24.148|
                  |L24.46|
00002e  4655              MOV      r5,r10                ;3027
000030  e012              B        |L24.88|
000032  bf00              NOP                            ;3029
                  |L24.52|
000034  eb0901e4          ADD      r1,r9,r4,ASR #3       ;3029
000038  f0040207          AND      r2,r4,#7              ;3029
00003c  f1c20207          RSB      r2,r2,#7              ;3029
000040  7809              LDRB     r1,[r1,#0]            ;3029
000042  fa0bf002          LSL      r0,r11,r2             ;3029
000046  4201              TST      r1,r0                 ;3029
000048  d004              BEQ      |L24.84|
00004a  9a0c              LDR      r2,[sp,#0x30]         ;3030
00004c  4641              MOV      r1,r8                 ;3030
00004e  4628              MOV      r0,r5                 ;3030
000050  f7fffffe          BL       RMP_Point
                  |L24.84|
000054  1c64              ADDS     r4,r4,#1              ;3030
000056  1c6d              ADDS     r5,r5,#1              ;3030
                  |L24.88|
000058  42ae              CMP      r6,r5                 ;3027
00005a  dceb              BGT      |L24.52|
00005c  f1080801          ADD      r8,r8,#1              ;3025
                  |L24.96|
000060  4547              CMP      r7,r8                 ;3025
000062  dce4              BGT      |L24.46|
                  |L24.100|
;;;3039           {
;;;3040               for(Len_Cnt=Coord_X;Len_Cnt<Length+Coord_X;Len_Cnt++)
;;;3041               {
;;;3042                   if(RMP_MAT_SPOS(Matrix,Mat_Pos)!=0)
;;;3043                       RMP_Point(Len_Cnt,Wid_Cnt,Color);
;;;3044                   Mat_Pos++;
;;;3045               }
;;;3046           }
;;;3047       }
;;;3048   }
000064  e8bd9ff0          POP      {r4-r12,pc}
                  |L24.104|
000068  4655              MOV      r5,r10                ;3040
00006a  e00f              B        |L24.140|
                  |L24.108|
00006c  eb0900e4          ADD      r0,r9,r4,ASR #3       ;3042
000070  f0040207          AND      r2,r4,#7              ;3042
000074  7801              LDRB     r1,[r0,#0]            ;3042
000076  fa0bf002          LSL      r0,r11,r2             ;3042
00007a  4201              TST      r1,r0                 ;3042
00007c  d004              BEQ      |L24.136|
00007e  9a0c              LDR      r2,[sp,#0x30]         ;3043
000080  4641              MOV      r1,r8                 ;3043
000082  4628              MOV      r0,r5                 ;3043
000084  f7fffffe          BL       RMP_Point
                  |L24.136|
000088  1c64              ADDS     r4,r4,#1              ;3043
00008a  1c6d              ADDS     r5,r5,#1              ;3043
                  |L24.140|
00008c  42ae              CMP      r6,r5                 ;3040
00008e  dced              BGT      |L24.108|
000090  f1080801          ADD      r8,r8,#1              ;3038
                  |L24.148|
000094  4547              CMP      r7,r8                 ;3038
000096  dce7              BGT      |L24.104|
000098  e7e4              B        |L24.100|
;;;3049   /* End Function:RMP_Matrix ***************************************************/
                          ENDP


                          AREA ||i.RMP_Matrix_AA||, CODE, READONLY, ALIGN=2

                  RMP_Matrix_AA PROC
;;;3068   #ifdef RMP_COLOR_75P
;;;3069   void RMP_Matrix_AA(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, const rmp_u8_t* Matrix,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;3070                      rmp_cnt_t Bit_Order, rmp_cnt_t Length, rmp_cnt_t Width, rmp_ptr_t Color, rmp_ptr_t Back)
;;;3071   {
000004  b085              SUB      sp,sp,#0x14
000006  4682              MOV      r10,r0
000008  ea5f0802          MOVS     r8,r2
00000c  468b              MOV      r11,r1
00000e  e9dd520e          LDRD     r5,r2,[sp,#0x38]
000012  9811              LDR      r0,[sp,#0x44]
000014  d07e              BEQ      |L25.276|
;;;3072       rmp_cnt_t Len_Cnt;
;;;3073       rmp_cnt_t Wid_Cnt;
;;;3074       rmp_cnt_t Mat_Pos;
;;;3075       rmp_cnt_t Anti_Alias;
;;;3076       rmp_ptr_t Color_25;
;;;3077       rmp_ptr_t Color_50;
;;;3078       rmp_ptr_t Color_75;
;;;3079       rmp_ptr_t Total;
;;;3080       
;;;3081       if((Matrix==0)||((Length&0x07)!=0)||(Length==0)||(Width==0))
000016  0769              LSLS     r1,r5,#29
000018  d17c              BNE      |L25.276|
00001a  2d00              CMP      r5,#0
00001c  d07a              BEQ      |L25.276|
00001e  2a00              CMP      r2,#0
000020  d078              BEQ      |L25.276|
;;;3082           return;
;;;3083       
;;;3084       Mat_Pos=0;
;;;3085       Total=Length*Width;
;;;3086       Color_25=RMP_COLOR_25P(Color,Back);
;;;3087       Color_50=RMP_COLOR_50P(Color,Back);
000022  9910              LDR      r1,[sp,#0x40]
;;;3088       Color_75=RMP_COLOR_75P(Color,Back);
;;;3089       
;;;3090       /* Natural order */
;;;3091       if(Bit_Order==RMP_MAT_BIG)
;;;3092       {
;;;3093           for(Wid_Cnt=Coord_Y;Wid_Cnt<Width+Coord_Y;Wid_Cnt++)
000024  eb02090b          ADD      r9,r2,r11
000028  436a              MULS     r2,r5,r2              ;3085
00002a  0acc              LSRS     r4,r1,#11             ;3087
00002c  9200              STR      r2,[sp,#0]            ;3091
00002e  0ac6              LSRS     r6,r0,#11             ;3086
000030  9a10              LDR      r2,[sp,#0x40]         ;3086
000032  2b01              CMP      r3,#1                 ;3091
000034  9b10              LDR      r3,[sp,#0x40]         ;3086
000036  eb060646          ADD      r6,r6,r6,LSL #1       ;3086
00003a  f3c01145          UBFX     r1,r0,#5,#6           ;3086
00003e  eb0623d3          ADD      r3,r6,r3,LSR #11      ;3086
000042  eb010641          ADD      r6,r1,r1,LSL #1       ;3086
000046  f3c21245          UBFX     r2,r2,#5,#6           ;3086
00004a  4416              ADD      r6,r6,r2              ;3086
00004c  ea4f0393          LSR      r3,r3,#2              ;3086
000050  ea4f0696          LSR      r6,r6,#2              ;3086
000054  ea4f23c3          LSL      r3,r3,#11             ;3086
000058  ea431346          ORR      r3,r3,r6,LSL #5       ;3086
00005c  eb040744          ADD      r7,r4,r4,LSL #1       ;3088
000060  eb0426d0          ADD      r6,r4,r0,LSR #11      ;3087
000064  eb0727d0          ADD      r7,r7,r0,LSR #11      ;3088
000068  eb020442          ADD      r4,r2,r2,LSL #1       ;3088
00006c  ea4f0c56          LSR      r12,r6,#1             ;3087
000070  440a              ADD      r2,r2,r1              ;3087
000072  ea4f0697          LSR      r6,r7,#2              ;3088
000076  440c              ADD      r4,r4,r1              ;3088
000078  9910              LDR      r1,[sp,#0x40]         ;3086
00007a  ea4f27cc          LSL      r7,r12,#11            ;3087
00007e  ea4f0252          LSR      r2,r2,#1              ;3087
000082  f001011f          AND      r1,r1,#0x1f           ;3086
000086  f000001f          AND      r0,r0,#0x1f           ;3086
00008a  ea471242          ORR      r2,r7,r2,LSL #5       ;3087
00008e  eb000740          ADD      r7,r0,r0,LSL #1       ;3086
000092  440f              ADD      r7,r7,r1              ;3086
000094  ea4f0c94          LSR      r12,r4,#2             ;3088
000098  eb010441          ADD      r4,r1,r1,LSL #1       ;3088
00009c  4401              ADD      r1,r1,r0              ;3087
00009e  ea4f26c6          LSL      r6,r6,#11             ;3088
0000a2  ea430397          ORR      r3,r3,r7,LSR #2       ;3086
0000a6  9304              STR      r3,[sp,#0x10]         ;3088
0000a8  4404              ADD      r4,r4,r0              ;3088
0000aa  ea46134c          ORR      r3,r6,r12,LSL #5      ;3088
0000ae  ea420151          ORR      r1,r2,r1,LSR #1       ;3087
0000b2  9103              STR      r1,[sp,#0xc]          ;3088
0000b4  ea430194          ORR      r1,r3,r4,LSR #2       ;3088
0000b8  f04f0400          MOV      r4,#0                 ;3084
;;;3094           {
;;;3095               for(Len_Cnt=Coord_X;Len_Cnt<Length+Coord_X;Len_Cnt++)
;;;3096               {
;;;3097                   if(RMP_MAT_BPOS(Matrix,Mat_Pos)!=0)
;;;3098                       RMP_Point(Len_Cnt,Wid_Cnt,Color);
;;;3099                   else
;;;3100                   {
;;;3101                       /* Anti-aliasing */
;;;3102                       Anti_Alias=0;
;;;3103                       
;;;3104                       if(Mat_Pos-1>=0)
;;;3105                       {
;;;3106                           if((Len_Cnt!=Coord_X)&&(RMP_MAT_BPOS(Matrix,Mat_Pos-1)!=0))
;;;3107                               Anti_Alias++;
;;;3108                           if((Mat_Pos-Length>=0)&&(RMP_MAT_BPOS(Matrix,Mat_Pos-Length)!=0))
;;;3109                               Anti_Alias++;
;;;3110                       }
;;;3111                       
;;;3112                       if(Mat_Pos+1<Total)
;;;3113                       {
;;;3114                           if((Len_Cnt!=Coord_X+Length-1)&&(RMP_MAT_BPOS(Matrix,Mat_Pos+1)!=0))
0000bc  eb0a0005          ADD      r0,r10,r5
0000c0  f1a00001          SUB      r0,r0,#1              ;3084
0000c4  e9cd0101          STRD     r0,r1,[sp,#4]         ;3084
0000c8  eb05070a          ADD      r7,r5,r10             ;3095
0000cc  d06c              BEQ      |L25.424|
0000ce  e0d1              B        |L25.628|
                  |L25.208|
0000d0  4656              MOV      r6,r10                ;3095
0000d2  e065              B        |L25.416|
                  |L25.212|
0000d4  eb0800e4          ADD      r0,r8,r4,ASR #3       ;3097
0000d8  f04f0c01          MOV      r12,#1                ;3097
0000dc  f0040207          AND      r2,r4,#7              ;3097
0000e0  f1c20207          RSB      r2,r2,#7              ;3097
0000e4  7801              LDRB     r1,[r0,#0]            ;3097
0000e6  fa0cf002          LSL      r0,r12,r2             ;3097
0000ea  4201              TST      r1,r0                 ;3097
0000ec  d001              BEQ      |L25.242|
0000ee  9a10              LDR      r2,[sp,#0x40]         ;3098
0000f0  e050              B        |L25.404|
                  |L25.242|
0000f2  2000              MOVS     r0,#0                 ;3102
0000f4  2c01              CMP      r4,#1                 ;3104
0000f6  d41e              BMI      |L25.310|
0000f8  4556              CMP      r6,r10                ;3106
0000fa  d00e              BEQ      |L25.282|
0000fc  1e61              SUBS     r1,r4,#1              ;3106
0000fe  f0010307          AND      r3,r1,#7              ;3106
000102  eb0802e1          ADD      r2,r8,r1,ASR #3       ;3106
000106  f1c30307          RSB      r3,r3,#7              ;3106
00010a  7812              LDRB     r2,[r2,#0]            ;3106
00010c  fa0cf103          LSL      r1,r12,r3             ;3106
000110  420a              TST      r2,r1                 ;3106
000112  e000              B        |L25.278|
                  |L25.276|
000114  e04a              B        |L25.428|
                  |L25.278|
000116  d000              BEQ      |L25.282|
000118  2001              MOVS     r0,#1                 ;3107
                  |L25.282|
00011a  1b61              SUBS     r1,r4,r5              ;3108
00011c  d40b              BMI      |L25.310|
00011e  eb0802e1          ADD      r2,r8,r1,ASR #3       ;3108
000122  f0010307          AND      r3,r1,#7              ;3108
000126  f1c30307          RSB      r3,r3,#7              ;3108
00012a  7812              LDRB     r2,[r2,#0]            ;3108
00012c  fa0cf103          LSL      r1,r12,r3             ;3108
000130  420a              TST      r2,r1                 ;3108
000132  d000              BEQ      |L25.310|
000134  1c40              ADDS     r0,r0,#1              ;3108
                  |L25.310|
000136  9a00              LDR      r2,[sp,#0]            ;3112
000138  1c61              ADDS     r1,r4,#1              ;3112
00013a  4291              CMP      r1,r2                 ;3112
00013c  d21e              BCS      |L25.380|
00013e  9a01              LDR      r2,[sp,#4]
000140  42b2              CMP      r2,r6
000142  d00b              BEQ      |L25.348|
000144  eb0802e1          ADD      r2,r8,r1,ASR #3
000148  f0010307          AND      r3,r1,#7
00014c  f1c30307          RSB      r3,r3,#7
000150  7812              LDRB     r2,[r2,#0]
000152  fa0cf103          LSL      r1,r12,r3
000156  420a              TST      r2,r1
000158  d000              BEQ      |L25.348|
00015a  1c40              ADDS     r0,r0,#1
                  |L25.348|
;;;3115                               Anti_Alias++;
;;;3116                           if((Mat_Pos+Length<Total)&&(RMP_MAT_BPOS(Matrix,Mat_Pos+Length)!=0))
00015c  9a00              LDR      r2,[sp,#0]
00015e  1961              ADDS     r1,r4,r5
000160  4291              CMP      r1,r2
000162  d20b              BCS      |L25.380|
000164  eb0802e1          ADD      r2,r8,r1,ASR #3
000168  f0010307          AND      r3,r1,#7
00016c  f1c30307          RSB      r3,r3,#7
000170  7812              LDRB     r2,[r2,#0]
000172  fa0cf103          LSL      r1,r12,r3
000176  420a              TST      r2,r1
000178  d000              BEQ      |L25.380|
00017a  1c40              ADDS     r0,r0,#1
                  |L25.380|
;;;3117                               Anti_Alias++;
;;;3118                       }
;;;3119                       
;;;3120                       switch(Anti_Alias)
00017c  2801              CMP      r0,#1
00017e  d004              BEQ      |L25.394|
000180  2802              CMP      r0,#2
000182  d004              BEQ      |L25.398|
000184  2803              CMP      r0,#3
000186  d109              BNE      |L25.412|
000188  e003              B        |L25.402|
                  |L25.394|
;;;3121                       {
;;;3122                           case 1:RMP_Point(Len_Cnt,Wid_Cnt,Color_25);break;
00018a  9a04              LDR      r2,[sp,#0x10]
00018c  e002              B        |L25.404|
                  |L25.398|
;;;3123                           case 2:RMP_Point(Len_Cnt,Wid_Cnt,Color_50);break;
00018e  9a03              LDR      r2,[sp,#0xc]
000190  e000              B        |L25.404|
                  |L25.402|
;;;3124                           case 3:RMP_Point(Len_Cnt,Wid_Cnt,Color_75);break;
000192  9a02              LDR      r2,[sp,#8]
                  |L25.404|
000194  4659              MOV      r1,r11
000196  4630              MOV      r0,r6
000198  f7fffffe          BL       RMP_Point
                  |L25.412|
00019c  1c64              ADDS     r4,r4,#1
00019e  1c76              ADDS     r6,r6,#1
                  |L25.416|
0001a0  42b7              CMP      r7,r6                 ;3095
0001a2  dc97              BGT      |L25.212|
0001a4  f10b0b01          ADD      r11,r11,#1            ;3093
                  |L25.424|
0001a8  45d9              CMP      r9,r11                ;3093
0001aa  dc91              BGT      |L25.208|
                  |L25.428|
;;;3125                           default:break;
;;;3126                       }
;;;3127                   }
;;;3128                   
;;;3129                   Mat_Pos++;
;;;3130               }
;;;3131           }
;;;3132       }
;;;3133       /* Small order */
;;;3134       else
;;;3135       {
;;;3136           for(Wid_Cnt=Coord_Y;Wid_Cnt<Width+Coord_Y;Wid_Cnt++)
;;;3137           {
;;;3138               for(Len_Cnt=Coord_X;Len_Cnt<Length+Coord_X;Len_Cnt++)
;;;3139               {
;;;3140                   if(RMP_MAT_SPOS(Matrix,Mat_Pos)!=0)
;;;3141                       RMP_Point(Len_Cnt,Wid_Cnt,Color);
;;;3142                   else
;;;3143                   {
;;;3144                       /* Anti-aliasing */
;;;3145                       Anti_Alias=0;
;;;3146                       
;;;3147                       if(Mat_Pos-1>=0)
;;;3148                       {
;;;3149                           if((Len_Cnt!=Coord_X)&&(RMP_MAT_SPOS(Matrix,Mat_Pos-1)!=0))
;;;3150                               Anti_Alias++;
;;;3151                           if((Mat_Pos-Length>=0)&&(RMP_MAT_SPOS(Matrix,Mat_Pos-Length)!=0))
;;;3152                               Anti_Alias++;
;;;3153                       }
;;;3154                       
;;;3155                       if(Mat_Pos+1<Total)
;;;3156                       {
;;;3157                           if((Len_Cnt!=Coord_X+Length-1)&&(RMP_MAT_SPOS(Matrix,Mat_Pos+1)!=0))
;;;3158                               Anti_Alias++;
;;;3159                           if((Mat_Pos+Length<Total)&&(RMP_MAT_SPOS(Matrix,Mat_Pos+Length)!=0))
;;;3160                               Anti_Alias++;
;;;3161                       }
;;;3162                       
;;;3163                       switch(Anti_Alias)
;;;3164                       {
;;;3165                           case 1:RMP_Point(Len_Cnt,Wid_Cnt,Color_25);break;
;;;3166                           case 2:RMP_Point(Len_Cnt,Wid_Cnt,Color_50);break;
;;;3167                           case 3:RMP_Point(Len_Cnt,Wid_Cnt,Color_75);break;
;;;3168                           default:break;
;;;3169                       }
;;;3170                   }
;;;3171                   
;;;3172                   Mat_Pos++;
;;;3173               }
;;;3174           }
;;;3175       }
;;;3176   }
0001ac  b005              ADD      sp,sp,#0x14
0001ae  e8bd8ff0          POP      {r4-r11,pc}
                  |L25.434|
0001b2  4656              MOV      r6,r10                ;3138
0001b4  e05a              B        |L25.620|
0001b6  bf00              NOP                            ;3140
                  |L25.440|
0001b8  eb0800e4          ADD      r0,r8,r4,ASR #3       ;3140
0001bc  f04f0e01          MOV      lr,#1                 ;3140
0001c0  f0040207          AND      r2,r4,#7              ;3140
0001c4  7801              LDRB     r1,[r0,#0]            ;3140
0001c6  fa0ef002          LSL      r0,lr,r2              ;3140
0001ca  4201              TST      r1,r0                 ;3140
0001cc  d001              BEQ      |L25.466|
0001ce  9a10              LDR      r2,[sp,#0x40]         ;3141
0001d0  e046              B        |L25.608|
                  |L25.466|
0001d2  2000              MOVS     r0,#0                 ;3145
0001d4  2c01              CMP      r4,#1                 ;3147
0001d6  d418              BMI      |L25.522|
0001d8  4556              CMP      r6,r10                ;3149
0001da  d00a              BEQ      |L25.498|
0001dc  1e61              SUBS     r1,r4,#1              ;3149
0001de  f0010c07          AND      r12,r1,#7             ;3149
0001e2  eb0803e1          ADD      r3,r8,r1,ASR #3       ;3149
0001e6  fa0ef20c          LSL      r2,lr,r12             ;3149
0001ea  7819              LDRB     r1,[r3,#0]            ;3149
0001ec  4211              TST      r1,r2                 ;3149
0001ee  d000              BEQ      |L25.498|
0001f0  2001              MOVS     r0,#1                 ;3150
                  |L25.498|
0001f2  1b61              SUBS     r1,r4,r5              ;3151
0001f4  d409              BMI      |L25.522|
0001f6  eb0802e1          ADD      r2,r8,r1,ASR #3       ;3151
0001fa  f0010307          AND      r3,r1,#7              ;3151
0001fe  7812              LDRB     r2,[r2,#0]            ;3151
000200  fa0ef103          LSL      r1,lr,r3              ;3151
000204  420a              TST      r2,r1                 ;3151
000206  d000              BEQ      |L25.522|
000208  1c40              ADDS     r0,r0,#1              ;3151
                  |L25.522|
00020a  9a00              LDR      r2,[sp,#0]            ;3155
00020c  1c61              ADDS     r1,r4,#1              ;3155
00020e  4291              CMP      r1,r2                 ;3155
000210  d21a              BCS      |L25.584|
000212  9a01              LDR      r2,[sp,#4]            ;3157
000214  42b2              CMP      r2,r6                 ;3157
000216  d009              BEQ      |L25.556|
000218  eb0802e1          ADD      r2,r8,r1,ASR #3       ;3157
00021c  f0010307          AND      r3,r1,#7              ;3157
000220  7812              LDRB     r2,[r2,#0]            ;3157
000222  fa0ef103          LSL      r1,lr,r3              ;3157
000226  420a              TST      r2,r1                 ;3157
000228  d000              BEQ      |L25.556|
00022a  1c40              ADDS     r0,r0,#1              ;3157
                  |L25.556|
00022c  9a00              LDR      r2,[sp,#0]            ;3159
00022e  1961              ADDS     r1,r4,r5              ;3159
000230  4291              CMP      r1,r2                 ;3159
000232  d209              BCS      |L25.584|
000234  eb0802e1          ADD      r2,r8,r1,ASR #3       ;3159
000238  f0010307          AND      r3,r1,#7              ;3159
00023c  7812              LDRB     r2,[r2,#0]            ;3159
00023e  fa0ef103          LSL      r1,lr,r3              ;3159
000242  420a              TST      r2,r1                 ;3159
000244  d000              BEQ      |L25.584|
000246  1c40              ADDS     r0,r0,#1              ;3159
                  |L25.584|
000248  2801              CMP      r0,#1                 ;3163
00024a  d004              BEQ      |L25.598|
00024c  2802              CMP      r0,#2                 ;3163
00024e  d004              BEQ      |L25.602|
000250  2803              CMP      r0,#3                 ;3163
000252  d109              BNE      |L25.616|
000254  e003              B        |L25.606|
                  |L25.598|
000256  9a04              LDR      r2,[sp,#0x10]         ;3165
000258  e002              B        |L25.608|
                  |L25.602|
00025a  9a03              LDR      r2,[sp,#0xc]          ;3166
00025c  e000              B        |L25.608|
                  |L25.606|
00025e  9a02              LDR      r2,[sp,#8]            ;3167
                  |L25.608|
000260  4659              MOV      r1,r11                ;3167
000262  4630              MOV      r0,r6                 ;3167
000264  f7fffffe          BL       RMP_Point
                  |L25.616|
000268  1c64              ADDS     r4,r4,#1              ;3167
00026a  1c76              ADDS     r6,r6,#1              ;3167
                  |L25.620|
00026c  42b7              CMP      r7,r6                 ;3138
00026e  dca3              BGT      |L25.440|
000270  f10b0b01          ADD      r11,r11,#1            ;3136
                  |L25.628|
000274  45d9              CMP      r9,r11                ;3136
000276  dc9c              BGT      |L25.434|
000278  e798              B        |L25.428|
;;;3177   #endif
                          ENDP


                          AREA ||i.RMP_Mem_Init||, CODE, READONLY, ALIGN=1

                  RMP_Mem_Init PROC
;;;2161   ******************************************************************************/
;;;2162   rmp_ret_t RMP_Mem_Init(volatile void* Pool, rmp_ptr_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;2163   {
000002  0004              MOVS     r4,r0
000004  460d              MOV      r5,r1
;;;2164       rmp_cnt_t FLI_Cnt;
;;;2165       rmp_ptr_t Offset;
;;;2166       rmp_ptr_t Bitmap_Size;
;;;2167       volatile struct RMP_Mem* Mem;
;;;2168       
;;;2169       /* See if the memory pool is large enough to enable dynamic allocation - at
;;;2170        * least 1024 machine words or pool initialization will be refused */
;;;2171       if((Pool==0)||(Size<(1024*sizeof(rmp_ptr_t))))
;;;2172       {
;;;2173           RMP_COVERAGE_MARKER();
;;;2174           return RMP_ERR_MEM;
000006  f06f0006          MVN      r0,#6
00000a  d06a              BEQ      |L26.226|
00000c  f5b55f80          CMP      r5,#0x1000            ;2171
000010  d367              BCC      |L26.226|
;;;2175       }
;;;2176       else
;;;2177           RMP_COVERAGE_MARKER();
;;;2178       
;;;2179       /* See if the address and size is word-aligned */
;;;2180       if(((((rmp_ptr_t)Pool)&RMP_ALIGN_MASK)!=0)||((Size&RMP_ALIGN_MASK)!=0))
000012  ea440105          ORR      r1,r4,r5
000016  0789              LSLS     r1,r1,#30
000018  d163              BNE      |L26.226|
;;;2181       {
;;;2182           RMP_COVERAGE_MARKER();
;;;2183           return RMP_ERR_MEM;
;;;2184       }
;;;2185       else
;;;2186           RMP_COVERAGE_MARKER();
;;;2187   
;;;2188       Mem=(volatile struct RMP_Mem*)Pool;
;;;2189       Mem->Size=Size;
00001a  60a5              STR      r5,[r4,#8]
00001c  f1a50014          SUB      r0,r5,#0x14
;;;2190       /* Calculate the FLI value needed for this - we always align to 64 byte */
;;;2191       Mem->FLI_Num=RMP_MSB_Get(Size-sizeof(struct RMP_Mem))-6+1;
000020  f7fffffe          BL       RMP_MSB_Get
;;;2192       
;;;2193       /* Decide the location of the bitmap */
;;;2194       Offset=sizeof(struct RMP_Mem);
000024  2214              MOVS     r2,#0x14
000026  1f40              SUBS     r0,r0,#5
000028  6020              STR      r0,[r4,#0]            ;2191
;;;2195       Bitmap_Size=RMP_ROUND_UP(Mem->FLI_Num,RMP_ALIGN_ORDER);
00002a  6821              LDR      r1,[r4,#0]
;;;2196       /* Initialize the bitmap */
;;;2197       for(FLI_Cnt=0;FLI_Cnt<(rmp_cnt_t)(Bitmap_Size>>RMP_ALIGN_ORDER);FLI_Cnt++)
00002c  2000              MOVS     r0,#0
00002e  4603              MOV      r3,r0
000030  1cc9              ADDS     r1,r1,#3
000032  f0210103          BIC      r1,r1,#3              ;2195
000036  e003              B        |L26.64|
                  |L26.56|
;;;2198           Mem->Bitmap[FLI_Cnt]=0;
000038  eb040680          ADD      r6,r4,r0,LSL #2
00003c  6133              STR      r3,[r6,#0x10]
00003e  1c40              ADDS     r0,r0,#1
                  |L26.64|
000040  ebb00f91          CMP      r0,r1,LSR #2          ;2197
000044  dbf8              BLT      |L26.56|
;;;2199       
;;;2200       /* Decide the location of the allocation table - "-sizeof(rmp_ptr_t)" is
;;;2201        * because we defined the length=1 in our struct already */
;;;2202       Offset+=Bitmap_Size-sizeof(rmp_ptr_t);
000046  440a              ADD      r2,r2,r1
;;;2203       Mem->Table=(struct RMP_List*)(((rmp_ptr_t)Mem)+Offset);
;;;2204       /* Initialize the allocation table */
;;;2205       for(FLI_Cnt=0;FLI_Cnt<(rmp_cnt_t)(Mem->FLI_Num);FLI_Cnt++)
000048  2000              MOVS     r0,#0
00004a  1f12              SUBS     r2,r2,#4
00004c  18a3              ADDS     r3,r4,r2              ;2203
00004e  60e3              STR      r3,[r4,#0xc]          ;2203
000050  e036              B        |L26.192|
                  |L26.82|
;;;2206       {
;;;2207           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,0)]));
000052  68e1              LDR      r1,[r4,#0xc]
000054  eb011180          ADD      r1,r1,r0,LSL #6
000058  6009              STR      r1,[r1,#0]
00005a  6049              STR      r1,[r1,#4]
;;;2208           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,1)]));
00005c  2308              MOVS     r3,#8
00005e  68e1              LDR      r1,[r4,#0xc]
000060  eb031380          ADD      r3,r3,r0,LSL #6
000064  4419              ADD      r1,r1,r3
000066  6009              STR      r1,[r1,#0]
000068  6049              STR      r1,[r1,#4]
;;;2209           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,2)]));
00006a  68e1              LDR      r1,[r4,#0xc]
00006c  2310              MOVS     r3,#0x10
00006e  eb031380          ADD      r3,r3,r0,LSL #6
000072  4419              ADD      r1,r1,r3
000074  6009              STR      r1,[r1,#0]
000076  6049              STR      r1,[r1,#4]
;;;2210           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,3)]));
000078  68e1              LDR      r1,[r4,#0xc]
00007a  2318              MOVS     r3,#0x18
00007c  eb031380          ADD      r3,r3,r0,LSL #6
000080  4419              ADD      r1,r1,r3
000082  6009              STR      r1,[r1,#0]
000084  6049              STR      r1,[r1,#4]
;;;2211           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,4)]));
000086  68e1              LDR      r1,[r4,#0xc]
000088  2320              MOVS     r3,#0x20
00008a  eb031380          ADD      r3,r3,r0,LSL #6
00008e  4419              ADD      r1,r1,r3
000090  6009              STR      r1,[r1,#0]
000092  6049              STR      r1,[r1,#4]
;;;2212           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,5)]));
000094  68e1              LDR      r1,[r4,#0xc]
000096  2328              MOVS     r3,#0x28
000098  eb031380          ADD      r3,r3,r0,LSL #6
00009c  4419              ADD      r1,r1,r3
00009e  6009              STR      r1,[r1,#0]
0000a0  6049              STR      r1,[r1,#4]
;;;2213           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,6)]));
0000a2  68e1              LDR      r1,[r4,#0xc]
0000a4  2330              MOVS     r3,#0x30
0000a6  eb031380          ADD      r3,r3,r0,LSL #6
0000aa  4419              ADD      r1,r1,r3
0000ac  6009              STR      r1,[r1,#0]
0000ae  6049              STR      r1,[r1,#4]
;;;2214           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,7)]));
0000b0  68e1              LDR      r1,[r4,#0xc]
0000b2  2338              MOVS     r3,#0x38
0000b4  eb031380          ADD      r3,r3,r0,LSL #6
0000b8  4419              ADD      r1,r1,r3
0000ba  6009              STR      r1,[r1,#0]
0000bc  6049              STR      r1,[r1,#4]
0000be  1c40              ADDS     r0,r0,#1
                  |L26.192|
0000c0  6821              LDR      r1,[r4,#0]            ;2205
0000c2  4281              CMP      r1,r0                 ;2205
0000c4  dcc5              BGT      |L26.82|
;;;2215       }
;;;2216       
;;;2217       /* Calculate the offset of the actual allocatable memory - each FLI have
;;;2218        * 8 SLIs, and each SLI has a corresponding table header */
;;;2219       Offset+=sizeof(struct RMP_List)*8*Mem->FLI_Num;
0000c6  6820              LDR      r0,[r4,#0]
0000c8  eb021080          ADD      r0,r2,r0,LSL #6
;;;2220       Mem->Start=((rmp_ptr_t)Mem)+Offset;
0000cc  1822              ADDS     r2,r4,r0
0000ce  6062              STR      r2,[r4,#4]
;;;2221       
;;;2222       /* Initialize the first big block */
;;;2223       _RMP_Mem_Block((struct RMP_Mem_Head*)(Mem->Start),Size-Offset);
0000d0  1a29              SUBS     r1,r5,r0
0000d2  6860              LDR      r0,[r4,#4]
0000d4  f7fffffe          BL       _RMP_Mem_Block
;;;2224       /* Insert the memory into the corresponding level */
;;;2225       _RMP_Mem_Ins(Pool,(struct RMP_Mem_Head*)(Mem->Start));
0000d8  6861              LDR      r1,[r4,#4]
0000da  4620              MOV      r0,r4
0000dc  f7fffffe          BL       _RMP_Mem_Ins
;;;2226       
;;;2227       return 0;
0000e0  2000              MOVS     r0,#0
                  |L26.226|
;;;2228   }
0000e2  bd70              POP      {r4-r6,pc}
;;;2229   /* End Function:RMP_Mem_Init *************************************************/
                          ENDP


                          AREA ||i.RMP_Print_Int||, CODE, READONLY, ALIGN=2

                  RMP_Print_Int PROC
;;;85     ******************************************************************************/
;;;86     rmp_cnt_t RMP_Print_Int(rmp_cnt_t Int)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;87     {
;;;88         rmp_ptr_t Iter;
;;;89         rmp_cnt_t Count;
;;;90         rmp_cnt_t Num;
;;;91         rmp_ptr_t Div;
;;;92         
;;;93         /* how many digits are there? */
;;;94         if(Int==0)
000004  2800              CMP      r0,#0
;;;95         {
;;;96             RMP_Putchar('0');
;;;97             return 1;
;;;98         }
;;;99         else if(Int<0)
;;;100        {
;;;101            /* How many digits are there? */
;;;102            Count=0;
;;;103            Div=1;
;;;104            Iter=(rmp_ptr_t)(-Int);
;;;105            while(Iter!=0)
;;;106            {
;;;107                Iter/=10;
000006  f04f010a          MOV      r1,#0xa
00000a  d008              BEQ      |L27.30|
00000c  da2e              BGE      |L27.108|
00000e  f1c00000          RSB      r0,r0,#0              ;104
000012  f04f0500          MOV      r5,#0                 ;102
000016  4606              MOV      r6,r0                 ;104
000018  f04f0201          MOV      r2,#1                 ;103
00001c  e00c              B        |L27.56|
                  |L27.30|
00001e  f04f0030          MOV      r0,#0x30              ;96
000022  f7fffffe          BL       RMP_Putchar
000026  2001              MOVS     r0,#1                 ;97
                  |L27.40|
;;;108                Count++;
;;;109                Div*=10;
;;;110            }
;;;111            Div/=10;
;;;112            
;;;113            RMP_Putchar('-');
;;;114            Iter=-Int;
;;;115            Num=Count+1;
;;;116            
;;;117            while(Count>0)
;;;118            {
;;;119                Count--;
;;;120                RMP_Putchar(Iter/Div+'0');
;;;121                Iter=Iter%Div;
;;;122                Div/=10;
;;;123            }
;;;124        }
;;;125        else
;;;126        {
;;;127            /* How many digits are there? */
;;;128            Count=0;
;;;129            Div=1;
;;;130            Iter=Int;
;;;131            while(Iter!=0)
;;;132            {
;;;133                Iter/=10;
;;;134                Count++;
;;;135                Div*=10;
;;;136            }
;;;137            Div/=10;
;;;138            
;;;139            Iter=Int;
;;;140            Num=Count;
;;;141            
;;;142            while(Count>0)
;;;143            {
;;;144                Count--;
;;;145                RMP_Putchar(Iter/Div+'0');
;;;146                Iter=Iter%Div;
;;;147                Div/=10;
;;;148            }
;;;149        }
;;;150        
;;;151        return Num;
;;;152    }
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L27.44|
00002c  fbb0f0f1          UDIV     r0,r0,r1              ;107
000030  eb020282          ADD      r2,r2,r2,LSL #2       ;109
000034  0052              LSLS     r2,r2,#1              ;109
000036  1c6d              ADDS     r5,r5,#1              ;109
                  |L27.56|
000038  2800              CMP      r0,#0                 ;105
00003a  d1f7              BNE      |L27.44|
00003c  4688              MOV      r8,r1                 ;111
00003e  fbb2f4f8          UDIV     r4,r2,r8              ;111
000042  202d              MOVS     r0,#0x2d              ;113
000044  f7fffffe          BL       RMP_Putchar
000048  1c6f              ADDS     r7,r5,#1              ;115
00004a  e00c              B        |L27.102|
                  |L27.76|
00004c  fbb6f0f4          UDIV     r0,r6,r4              ;120
000050  1e6d              SUBS     r5,r5,#1              ;120
000052  3030              ADDS     r0,r0,#0x30           ;120
000054  b240              SXTB     r0,r0                 ;120
000056  f7fffffe          BL       RMP_Putchar
00005a  fbb6f1f4          UDIV     r1,r6,r4              ;121
00005e  fb046611          MLS      r6,r4,r1,r6           ;121
000062  fbb4f4f8          UDIV     r4,r4,r8              ;122
                  |L27.102|
000066  2d00              CMP      r5,#0                 ;117
000068  dcf0              BGT      |L27.76|
00006a  e020              B        |L27.174|
                  |L27.108|
00006c  2400              MOVS     r4,#0                 ;128
00006e  ea4f0200          MOV.W    r2,r0                 ;130
000072  2301              MOVS     r3,#1                 ;129
                  |L27.116|
000074  fbb2f2f1          UDIV     r2,r2,r1              ;133
000078  eb030383          ADD      r3,r3,r3,LSL #2       ;135
00007c  1c64              ADDS     r4,r4,#1              ;135
00007e  005b              LSLS     r3,r3,#1              ;135
000080  2a00              CMP      r2,#0                 ;135
000082  d1f7              BNE      |L27.116|
000084  4688              MOV      r8,r1                 ;107
000086  4605              MOV      r5,r0                 ;139
000088  fbb3f6f8          UDIV     r6,r3,r8              ;137
00008c  4627              MOV      r7,r4                 ;140
00008e  e00c              B        |L27.170|
                  |L27.144|
000090  fbb5f0f6          UDIV     r0,r5,r6              ;145
000094  1e64              SUBS     r4,r4,#1              ;145
000096  3030              ADDS     r0,r0,#0x30           ;145
000098  b240              SXTB     r0,r0                 ;145
00009a  f7fffffe          BL       RMP_Putchar
00009e  fbb5f1f6          UDIV     r1,r5,r6              ;146
0000a2  fb065511          MLS      r5,r6,r1,r5           ;146
0000a6  fbb6f6f8          UDIV     r6,r6,r8              ;147
                  |L27.170|
0000aa  2c00              CMP      r4,#0                 ;142
0000ac  dcf0              BGT      |L27.144|
                  |L27.174|
0000ae  4638              MOV      r0,r7                 ;151
0000b0  e7ba              B        |L27.40|
;;;153    /* End Function:RMP_Print_Int ************************************************/
                          ENDP


                          AREA ||i.RMP_Print_String||, CODE, READONLY, ALIGN=1

                  RMP_Print_String PROC
;;;208    ******************************************************************************/
;;;209    rmp_cnt_t RMP_Print_String(rmp_s8_t* String)
000000  b570              PUSH     {r4-r6,lr}
;;;210    {
;;;211        rmp_cnt_t Count;
;;;212        
;;;213        Count=0;
000002  2400              MOVS     r4,#0
000004  4605              MOV      r5,r0                 ;210
                  |L28.6|
;;;214        while(Count<RMP_KERNEL_DEBUG_MAX_STR)
;;;215        {
;;;216            if(String[Count]=='\0')
000006  5728              LDRSB    r0,[r5,r4]
000008  b120              CBZ      r0,|L28.20|
00000a  1c64              ADDS     r4,r4,#1
;;;217                break;
;;;218            
;;;219            RMP_Putchar(String[Count++]);
00000c  f7fffffe          BL       RMP_Putchar
000010  2cff              CMP      r4,#0xff              ;214
000012  dbf8              BLT      |L28.6|
                  |L28.20|
;;;220        }
;;;221        
;;;222        return Count;
000014  4620              MOV      r0,r4
;;;223    }
000016  bd70              POP      {r4-r6,pc}
;;;224    /* End Function:RMP_Print_String *********************************************/
                          ENDP


                          AREA ||i.RMP_Print_Uint||, CODE, READONLY, ALIGN=1

                  RMP_Print_Uint PROC
;;;161    ******************************************************************************/
;;;162    rmp_cnt_t RMP_Print_Uint(rmp_ptr_t Uint)
000000  b570              PUSH     {r4-r6,lr}
;;;163    {
000002  0004              MOVS     r4,r0
000004  d001              BEQ      |L29.10|
;;;164        rmp_ptr_t Iter;
;;;165        rmp_cnt_t Count;
;;;166        rmp_cnt_t Num;
;;;167        
;;;168        /* how many digits are there? */
;;;169        if(Uint==0)
;;;170        {
;;;171            RMP_Putchar('0');
;;;172            return 1;
;;;173        }
;;;174        else
;;;175        {
;;;176            /* Filter out all the zeroes */
;;;177            Count=0;
000006  2100              MOVS     r1,#0
;;;178            Iter=Uint;
;;;179            while((Iter>>((sizeof(rmp_ptr_t)*8)-4))==0)
000008  e006              B        |L29.24|
                  |L29.10|
00000a  2030              MOVS     r0,#0x30              ;171
00000c  f7fffffe          BL       RMP_Putchar
000010  2001              MOVS     r0,#1                 ;172
;;;180            {
;;;181                Iter<<=4;
;;;182                Count++;
;;;183            }
;;;184            /* Count is the number of pts to print */
;;;185            Count=sizeof(rmp_ptr_t)*2-Count;
;;;186            Num=Count;
;;;187            while(Count>0)
;;;188            {
;;;189                Count--;
;;;190                Iter=(Uint>>(Count*4))&0x0F;
;;;191                if(Iter<10)
;;;192                    RMP_Putchar('0'+Iter);
;;;193                else
;;;194                    RMP_Putchar('A'+Iter-10);
;;;195            }
;;;196        }
;;;197        
;;;198        return Num;
;;;199    }
000012  bd70              POP      {r4-r6,pc}
                  |L29.20|
000014  0100              LSLS     r0,r0,#4              ;181
000016  1c49              ADDS     r1,r1,#1              ;181
                  |L29.24|
000018  0f02              LSRS     r2,r0,#28             ;179
00001a  d0fb              BEQ      |L29.20|
00001c  f1c10508          RSB      r5,r1,#8              ;185
000020  462e              MOV      r6,r5                 ;186
000022  e00e              B        |L29.66|
                  |L29.36|
000024  4628              MOV      r0,r5                 ;189
000026  1e6d              SUBS     r5,r5,#1              ;189
000028  0081              LSLS     r1,r0,#2              ;189
00002a  1f09              SUBS     r1,r1,#4              ;189
00002c  fa24f001          LSR      r0,r4,r1              ;190
000030  f000000f          AND      r0,r0,#0xf            ;190
000034  280a              CMP      r0,#0xa               ;191
000036  d201              BCS      |L29.60|
000038  3030              ADDS     r0,r0,#0x30           ;191
00003a  e000              B        |L29.62|
                  |L29.60|
00003c  3037              ADDS     r0,r0,#0x37           ;192
                  |L29.62|
00003e  f7fffffe          BL       RMP_Putchar
                  |L29.66|
000042  2d00              CMP      r5,#0                 ;187
000044  dcee              BGT      |L29.36|
000046  4630              MOV      r0,r6                 ;198
000048  bd70              POP      {r4-r6,pc}
;;;200    /* End Function:RMP_Print_Uint ***********************************************/
                          ENDP


                          AREA ||i.RMP_Progbar||, CODE, READONLY, ALIGN=1

                  RMP_Progbar PROC
;;;3864   ******************************************************************************/
;;;3865   void RMP_Progbar(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width,
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;3866                    rmp_cnt_t Style, rmp_cnt_t Prog, rmp_ptr_t Fore, rmp_ptr_t Back)
;;;3867   {
000004  ad0a              ADD      r5,sp,#0x28
000006  461f              MOV      r7,r3
000008  4614              MOV      r4,r2
00000a  4688              MOV      r8,r1
00000c  4606              MOV      r6,r0
00000e  e895000f          LDM      r5,{r0-r3}
000012  e88d000f          STM      sp,{r0-r3}
;;;3868       /* Draw the progress bar according to the style of the progress bar */
;;;3869       RMP_Progbar_Prog(Coord_X,Coord_Y,Length,Width,Style,Prog,Fore,Back);
000016  463b              MOV      r3,r7
000018  4622              MOV      r2,r4
00001a  4641              MOV      r1,r8
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       RMP_Progbar_Prog
;;;3870       /* Now draw the border */
;;;3871       RMP_Line(Coord_X,Coord_Y,Coord_X+Length-1,Coord_Y,RMP_CTL_BLACK);
000022  4434              ADD      r4,r4,r6
000024  4643              MOV      r3,r8
000026  2500              MOVS     r5,#0
000028  4619              MOV      r1,r3
00002a  1e62              SUBS     r2,r4,#1
00002c  4630              MOV      r0,r6
00002e  9500              STR      r5,[sp,#0]
000030  f7fffffe          BL       RMP_Line
;;;3872       RMP_Line(Coord_X+Length-1,Coord_Y,Coord_X+Length-1,Coord_Y+Width-1,RMP_CTL_BLACK);
000034  1e62              SUBS     r2,r4,#1
000036  4641              MOV      r1,r8
000038  4447              ADD      r7,r7,r8
00003a  4610              MOV      r0,r2
00003c  1e7b              SUBS     r3,r7,#1
00003e  9500              STR      r5,[sp,#0]
000040  f7fffffe          BL       RMP_Line
;;;3873       RMP_Line(Coord_X+Length-1,Coord_Y+Width-1,Coord_X,Coord_Y+Width-1,RMP_CTL_BLACK);
000044  1e60              SUBS     r0,r4,#1
000046  4632              MOV      r2,r6
000048  1e7b              SUBS     r3,r7,#1
00004a  9500              STR      r5,[sp,#0]
00004c  1e79              SUBS     r1,r7,#1
00004e  f7fffffe          BL       RMP_Line
;;;3874       RMP_Line(Coord_X,Coord_Y+Width-1,Coord_X,Coord_Y,RMP_CTL_BLACK);
000052  4632              MOV      r2,r6
000054  4643              MOV      r3,r8
000056  1e79              SUBS     r1,r7,#1
000058  4610              MOV      r0,r2
00005a  9500              STR      r5,[sp,#0]
00005c  f7fffffe          BL       RMP_Line
;;;3875   }
000060  e8bd81ff          POP      {r0-r8,pc}
;;;3876   #endif
                          ENDP


                          AREA ||i.RMP_Progbar_Prog||, CODE, READONLY, ALIGN=1

                  RMP_Progbar_Prog PROC
;;;3802   ******************************************************************************/
;;;3803   void RMP_Progbar_Prog(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width,
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;3804                         rmp_cnt_t Style, rmp_cnt_t Prog, rmp_ptr_t Fore, rmp_ptr_t Back)
;;;3805   {
000004  4682              MOV      r10,r0
000006  4616              MOV      r6,r2
000008  461d              MOV      r5,r3
00000a  4689              MOV      r9,r1
00000c  e9dd400b          LDRD     r4,r0,[sp,#0x2c]
;;;3806       /* The critical value for drawing the bar */
;;;3807       rmp_ptr_t Pivot;
;;;3808       
;;;3809       switch(Style)
000010  f8ddc028          LDR      r12,[sp,#0x28]
;;;3810       {
;;;3811           case RMP_PBAR_L2R:
;;;3812           {
;;;3813               Pivot=Length*Prog/100;
000014  f04f0264          MOV      r2,#0x64
000018  9f0d              LDR      r7,[sp,#0x34]         ;3809
00001a  fb06f304          MUL      r3,r6,r4
00001e  f1bc0f00          CMP      r12,#0                ;3809
000022  d021              BEQ      |L31.104|
;;;3814               if(Prog!=0)
;;;3815                   RMP_Rectangle(Coord_X,Coord_Y,Pivot,Width,Fore,Fore);
;;;3816               if(Prog!=100)
;;;3817                   RMP_Rectangle(Coord_X+Pivot,Coord_Y,Length-Pivot,Width,Back,Back);
;;;3818               break;
;;;3819           }
;;;3820           case RMP_PBAR_D2U:
;;;3821           {
;;;3822               Pivot=Width*Prog/100;
000024  fb05f104          MUL      r1,r5,r4
000028  f1bc0f01          CMP      r12,#1                ;3809
00002c  d036              BEQ      |L31.156|
00002e  f1bc0f02          CMP      r12,#2                ;3809
000032  d049              BEQ      |L31.200|
000034  f1bc0f03          CMP      r12,#3                ;3809
000038  d12e              BNE      |L31.152|
;;;3823               if(Prog!=0)
;;;3824                   RMP_Rectangle(Coord_X,Coord_Y+Width-Pivot,Length,Pivot,Fore,Fore);
;;;3825               if(Prog!=100)
;;;3826                   RMP_Rectangle(Coord_X,Coord_Y,Length,Width-Pivot,Back,Back);
;;;3827               break;
;;;3828           }
;;;3829           case RMP_PBAR_R2L:
;;;3830           {
;;;3831               Pivot=Length*Prog/100;
;;;3832               if(Prog!=0)
;;;3833                   RMP_Rectangle(Coord_X+Length-Pivot,Coord_Y,Pivot,Width,Fore,Fore);
;;;3834               if(Prog!=100)
;;;3835                   RMP_Rectangle(Coord_X,Coord_Y,Length-Pivot,Width,Back,Back);
;;;3836               break;
;;;3837           }
;;;3838           case RMP_PBAR_U2D:
;;;3839           {
;;;3840               Pivot=Width*Prog/100;
00003a  fb91f1f2          SDIV     r1,r1,r2
00003e  4688              MOV      r8,r1
;;;3841               if(Prog!=0)
000040  b14c              CBZ      r4,|L31.86|
;;;3842                   RMP_Rectangle(Coord_X,Coord_Y,Length,Pivot,Fore,Fore);
000042  460b              MOV      r3,r1
000044  4632              MOV      r2,r6
000046  4649              MOV      r1,r9
000048  9000              STR      r0,[sp,#0]
00004a  9001              STR      r0,[sp,#4]
00004c  4650              MOV      r0,r10
00004e  f7fffffe          BL       RMP_Rectangle
;;;3843               if(Prog!=100)
000052  2c64              CMP      r4,#0x64
000054  d020              BEQ      |L31.152|
                  |L31.86|
;;;3844                   RMP_Rectangle(Coord_X,Coord_Y+Pivot,Length,Width-Pivot,Back,Back);
000056  eba50308          SUB      r3,r5,r8
00005a  4632              MOV      r2,r6
00005c  eb090108          ADD      r1,r9,r8
000060  9700              STR      r7,[sp,#0]
000062  9701              STR      r7,[sp,#4]
                  |L31.100|
000064  4650              MOV      r0,r10
000066  e015              B        |L31.148|
                  |L31.104|
000068  fb93f1f2          SDIV     r1,r3,r2              ;3813
00006c  4688              MOV      r8,r1                 ;3813
00006e  b14c              CBZ      r4,|L31.132|
000070  462b              MOV      r3,r5                 ;3815
000072  460a              MOV      r2,r1                 ;3815
000074  4649              MOV      r1,r9                 ;3815
000076  9000              STR      r0,[sp,#0]            ;3815
000078  9001              STR      r0,[sp,#4]            ;3815
00007a  4650              MOV      r0,r10                ;3815
00007c  f7fffffe          BL       RMP_Rectangle
000080  2c64              CMP      r4,#0x64              ;3816
000082  d009              BEQ      |L31.152|
                  |L31.132|
000084  eba60208          SUB      r2,r6,r8              ;3817
000088  462b              MOV      r3,r5                 ;3817
00008a  eb0a0008          ADD      r0,r10,r8             ;3817
00008e  4649              MOV      r1,r9                 ;3817
000090  9700              STR      r7,[sp,#0]            ;3817
000092  9701              STR      r7,[sp,#4]            ;3817
                  |L31.148|
000094  f7fffffe          BL       RMP_Rectangle
                  |L31.152|
;;;3845               break;
;;;3846           }
;;;3847           default: break;
;;;3848       }
;;;3849   }
000098  e8bd87fc          POP      {r2-r10,pc}
                  |L31.156|
00009c  fb91f8f2          SDIV     r8,r1,r2              ;3822
0000a0  b164              CBZ      r4,|L31.188|
0000a2  eb090105          ADD      r1,r9,r5              ;3824
0000a6  4643              MOV      r3,r8                 ;3824
0000a8  eba10108          SUB      r1,r1,r8              ;3824
0000ac  4632              MOV      r2,r6                 ;3824
0000ae  9000              STR      r0,[sp,#0]            ;3824
0000b0  9001              STR      r0,[sp,#4]            ;3824
0000b2  4650              MOV      r0,r10                ;3824
0000b4  f7fffffe          BL       RMP_Rectangle
0000b8  2c64              CMP      r4,#0x64              ;3825
0000ba  d0ed              BEQ      |L31.152|
                  |L31.188|
0000bc  eba50308          SUB      r3,r5,r8              ;3826
0000c0  4632              MOV      r2,r6                 ;3826
0000c2  9700              STR      r7,[sp,#0]            ;3826
0000c4  9701              STR      r7,[sp,#4]            ;3826
0000c6  e014              B        |L31.242|
                  |L31.200|
0000c8  fb93f8f2          SDIV     r8,r3,r2              ;3831
0000cc  b164              CBZ      r4,|L31.232|
0000ce  eb0a0106          ADD      r1,r10,r6             ;3833
0000d2  9000              STR      r0,[sp,#0]            ;3833
0000d4  9001              STR      r0,[sp,#4]            ;3833
0000d6  eba10008          SUB      r0,r1,r8              ;3833
0000da  462b              MOV      r3,r5                 ;3833
0000dc  4642              MOV      r2,r8                 ;3833
0000de  4649              MOV      r1,r9                 ;3833
0000e0  f7fffffe          BL       RMP_Rectangle
0000e4  2c64              CMP      r4,#0x64              ;3834
0000e6  d0d7              BEQ      |L31.152|
                  |L31.232|
0000e8  eba60208          SUB      r2,r6,r8              ;3835
0000ec  462b              MOV      r3,r5                 ;3835
0000ee  9700              STR      r7,[sp,#0]            ;3835
0000f0  9701              STR      r7,[sp,#4]            ;3835
                  |L31.242|
0000f2  4649              MOV      r1,r9                 ;3826
0000f4  e7b6              B        |L31.100|
;;;3850   /* End Function:RMP_Progbar_Prog *********************************************/
                          ENDP


                          AREA ||i.RMP_Progbar_Set||, CODE, READONLY, ALIGN=2

                  RMP_Progbar_Set PROC
;;;3723   ******************************************************************************/
;;;3724   void RMP_Progbar_Set(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width,
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;3725                        rmp_cnt_t Style, rmp_cnt_t Old_Prog, rmp_cnt_t New_Prog, rmp_ptr_t Fore, rmp_ptr_t Back)
;;;3726   {
000004  e9dd8b0d          LDRD     r8,r11,[sp,#0x34]
000008  e9dd650f          LDRD     r6,r5,[sp,#0x3c]
;;;3727       /* The critical values for drawing the bar */
;;;3728       rmp_ptr_t Old_Pivot;
;;;3729       rmp_ptr_t New_Pivot;
;;;3730       
;;;3731       /* If things does not change, return to save time */
;;;3732       if(Old_Prog==New_Prog)
00000c  f8ddc030          LDR      r12,[sp,#0x30]
000010  45d8              CMP      r8,r11
000012  d037              BEQ      |L32.132|
;;;3733           return;
;;;3734       
;;;3735       switch(Style)
;;;3736       {
;;;3737           case RMP_PBAR_L2R:
;;;3738           {
;;;3739               Old_Pivot=(Length-2)*Old_Prog/100;
000014  1e94              SUBS     r4,r2,#2
000016  f04f0e64          MOV      lr,#0x64
00001a  f1bc0f00          CMP      r12,#0                ;3735
00001e  fb04fa08          MUL      r10,r4,r8
;;;3740               New_Pivot=(Length-2)*New_Prog/100;
000022  fb04f70b          MUL      r7,r4,r11
000026  d019              BEQ      |L32.92|
;;;3741               /* Progress decreased */
;;;3742               if(Old_Pivot>New_Pivot)
;;;3743                   RMP_Rectangle(Coord_X+1+New_Pivot,Coord_Y+1,Old_Pivot-New_Pivot,Width-2,Back,Back);
000028  1e9c              SUBS     r4,r3,#2
00002a  9400              STR      r4,[sp,#0]            ;3735
00002c  f1bc0f01          CMP      r12,#1                ;3735
;;;3744               /* Progress increased */
;;;3745               else
;;;3746                   RMP_Rectangle(Coord_X+1+Old_Pivot,Coord_Y+1,New_Pivot-Old_Pivot,Width-2,Fore,Fore);
;;;3747               break;
;;;3748           }
;;;3749           case RMP_PBAR_D2U:
;;;3750           {
;;;3751               Old_Pivot=(Width-2)*Old_Prog/100;
000030  fb04f908          MUL      r9,r4,r8
;;;3752               New_Pivot=(Width-2)*New_Prog/100;
000034  fb04f40b          MUL      r4,r4,r11
000038  d026              BEQ      |L32.136|
00003a  f1bc0f02          CMP      r12,#2                ;3735
00003e  d036              BEQ      |L32.174|
000040  f1bc0f03          CMP      r12,#3                ;3735
000044  d11e              BNE      |L32.132|
;;;3753               /* Progress decreased */
;;;3754               if(Old_Pivot>New_Pivot)
;;;3755                   RMP_Rectangle(Coord_X+1,Coord_Y-1+Width-Old_Pivot,Length-2,Old_Pivot-New_Pivot,Back,Back);
;;;3756               /* Progress increased */
;;;3757               else
;;;3758                   RMP_Rectangle(Coord_X+1,Coord_Y-1+Width-New_Pivot,Length-2,New_Pivot-Old_Pivot,Fore,Fore);
;;;3759               break;
;;;3760           }
;;;3761           case RMP_PBAR_R2L:
;;;3762           {
;;;3763               Old_Pivot=(Length-2)*Old_Prog/100;
;;;3764               New_Pivot=(Length-2)*New_Prog/100;
;;;3765               /* Progress decreased */
;;;3766               if(Old_Pivot>New_Pivot)
;;;3767                   RMP_Rectangle(Coord_X-1+Length-Old_Pivot,Coord_Y+1,Old_Pivot-New_Pivot,Width-2,Back,Back);
;;;3768               /* Progress increased */
;;;3769               else
;;;3770                   RMP_Rectangle(Coord_X-1+Length-New_Pivot,Coord_Y+1,New_Pivot-Old_Pivot,Width-2,Fore,Fore);
;;;3771               break;
;;;3772           }
;;;3773           case RMP_PBAR_U2D:
;;;3774           {
;;;3775               Old_Pivot=(Width-2)*Old_Prog/100;
000046  fb99f3fe          SDIV     r3,r9,lr
;;;3776               New_Pivot=(Width-2)*New_Prog/100;
00004a  fb94f4fe          SDIV     r4,r4,lr
;;;3777               /* Progress decreased */
;;;3778               if(Old_Pivot>New_Pivot)
00004e  42a3              CMP      r3,r4
000050  d941              BLS      |L32.214|
;;;3779                   RMP_Rectangle(Coord_X+1,Coord_Y+1+New_Pivot,Length-2,Old_Pivot-New_Pivot,Back,Back);
000052  1b1b              SUBS     r3,r3,r4
000054  9500              STR      r5,[sp,#0]
000056  4421              ADD      r1,r1,r4
000058  9501              STR      r5,[sp,#4]
00005a  e040              B        |L32.222|
                  |L32.92|
00005c  fb9af2fe          SDIV     r2,r10,lr             ;3739
000060  fb97f4fe          SDIV     r4,r7,lr              ;3740
000064  42a2              CMP      r2,r4                 ;3742
000066  d904              BLS      |L32.114|
000068  1b12              SUBS     r2,r2,r4              ;3743
00006a  9500              STR      r5,[sp,#0]            ;3743
00006c  4420              ADD      r0,r0,r4              ;3743
00006e  9501              STR      r5,[sp,#4]            ;3743
000070  e003              B        |L32.122|
                  |L32.114|
000072  4410              ADD      r0,r0,r2              ;3746
000074  9600              STR      r6,[sp,#0]            ;3746
000076  1aa2              SUBS     r2,r4,r2              ;3746
000078  9601              STR      r6,[sp,#4]            ;3746
                  |L32.122|
00007a  1c40              ADDS     r0,r0,#1              ;3746
00007c  e028              B        |L32.208|
00007e  bf00              NOP                            ;3746
                  |L32.128|
000080  f7fffffe          BL       RMP_Rectangle
                  |L32.132|
;;;3780               /* Progress increased */
;;;3781               else
;;;3782                   RMP_Rectangle(Coord_X+1,Coord_Y+1+Old_Pivot,Length-2,New_Pivot-Old_Pivot,Fore,Fore);
;;;3783               break;
;;;3784           }
;;;3785           default: break;
;;;3786       }
;;;3787   }
000084  e8bd9ffc          POP      {r2-r12,pc}
                  |L32.136|
000088  4419              ADD      r1,r1,r3              ;3755
00008a  fb99f3fe          SDIV     r3,r9,lr              ;3751
00008e  fb94f4fe          SDIV     r4,r4,lr              ;3752
000092  42a3              CMP      r3,r4                 ;3754
000094  d904              BLS      |L32.160|
000096  1ac9              SUBS     r1,r1,r3              ;3755
000098  9500              STR      r5,[sp,#0]            ;3755
00009a  1b1b              SUBS     r3,r3,r4              ;3755
00009c  9501              STR      r5,[sp,#4]            ;3755
00009e  e003              B        |L32.168|
                  |L32.160|
0000a0  1b09              SUBS     r1,r1,r4              ;3758
0000a2  9600              STR      r6,[sp,#0]            ;3758
0000a4  1ae3              SUBS     r3,r4,r3              ;3758
0000a6  9601              STR      r6,[sp,#4]            ;3758
                  |L32.168|
0000a8  1c40              ADDS     r0,r0,#1              ;3758
0000aa  1e49              SUBS     r1,r1,#1              ;3758
0000ac  e019              B        |L32.226|
                  |L32.174|
0000ae  4410              ADD      r0,r0,r2              ;3767
0000b0  fb9af2fe          SDIV     r2,r10,lr             ;3763
0000b4  fb97f4fe          SDIV     r4,r7,lr              ;3764
0000b8  42a2              CMP      r2,r4                 ;3766
0000ba  d904              BLS      |L32.198|
0000bc  1a80              SUBS     r0,r0,r2              ;3767
0000be  9500              STR      r5,[sp,#0]            ;3767
0000c0  1b12              SUBS     r2,r2,r4              ;3767
0000c2  9501              STR      r5,[sp,#4]            ;3767
0000c4  e003              B        |L32.206|
                  |L32.198|
0000c6  1b00              SUBS     r0,r0,r4              ;3770
0000c8  9600              STR      r6,[sp,#0]            ;3770
0000ca  1aa2              SUBS     r2,r4,r2              ;3770
0000cc  9601              STR      r6,[sp,#4]            ;3770
                  |L32.206|
0000ce  1e40              SUBS     r0,r0,#1              ;3770
                  |L32.208|
0000d0  1c49              ADDS     r1,r1,#1              ;3770
0000d2  1e9b              SUBS     r3,r3,#2              ;3770
0000d4  e7d4              B        |L32.128|
                  |L32.214|
0000d6  4419              ADD      r1,r1,r3              ;3782
0000d8  9600              STR      r6,[sp,#0]            ;3782
0000da  1ae3              SUBS     r3,r4,r3              ;3782
0000dc  9601              STR      r6,[sp,#4]            ;3782
                  |L32.222|
0000de  1c40              ADDS     r0,r0,#1              ;3782
0000e0  1c49              ADDS     r1,r1,#1              ;3782
                  |L32.226|
0000e2  1e92              SUBS     r2,r2,#2              ;3782
0000e4  e7cc              B        |L32.128|
;;;3788   /* End Function:RMP_Progbar_Set **********************************************/
                          ENDP


                          AREA ||i.RMP_RBIT_Get||, CODE, READONLY, ALIGN=2

                  RMP_RBIT_Get PROC
;;;2078   
;;;2079   rmp_ptr_t RMP_RBIT_Get(rmp_ptr_t Val)
000000  4a0a              LDR      r2,|L33.44|
;;;2080   {
000002  0e03              LSRS     r3,r0,#24
000004  b570              PUSH     {r4-r6,lr}
;;;2081       rmp_ptr_t Ret;
;;;2082       rmp_ptr_t Src;
;;;2083       rmp_u8_t* To;
;;;2084       rmp_u8_t* From;
;;;2085       
;;;2086       Src=Val;
;;;2087       To=(rmp_u8_t*)(&Ret);
;;;2088       From=(rmp_u8_t*)(&Src);
;;;2089       
;;;2090   #if(RMP_WORD_ORDER==4)
;;;2091       To[0]=RMP_RBIT_Table[From[1]];
;;;2092       To[1]=RMP_RBIT_Table[From[0]];
;;;2093   #elif(RMP_WORD_ORDER==5)
;;;2094       To[0]=RMP_RBIT_Table[From[3]];
000006  f3c04407          UBFX     r4,r0,#16,#8
00000a  f3c02507          UBFX     r5,r0,#8,#8
00000e  b2c6              UXTB     r6,r0
000010  5cd0              LDRB     r0,[r2,r3]
;;;2095       To[1]=RMP_RBIT_Table[From[2]];
000012  5d14              LDRB     r4,[r2,r4]
;;;2096       To[2]=RMP_RBIT_Table[From[1]];
000014  5d53              LDRB     r3,[r2,r5]
;;;2097       To[3]=RMP_RBIT_Table[From[0]];
000016  f3600107          BFI      r1,r0,#0,#8
00001a  5d92              LDRB     r2,[r2,r6]
00001c  4608              MOV      r0,r1
00001e  f364200f          BFI      r0,r4,#8,#8
000022  f3634017          BFI      r0,r3,#16,#8
000026  f362601f          BFI      r0,r2,#24,#8
;;;2098   #else
;;;2099       To[0]=RMP_RBIT_Table[From[7]];
;;;2100       To[1]=RMP_RBIT_Table[From[6]];
;;;2101       To[2]=RMP_RBIT_Table[From[5]];
;;;2102       To[3]=RMP_RBIT_Table[From[4]];
;;;2103       To[4]=RMP_RBIT_Table[From[3]];
;;;2104       To[5]=RMP_RBIT_Table[From[2]];
;;;2105       To[6]=RMP_RBIT_Table[From[1]];
;;;2106       To[7]=RMP_RBIT_Table[From[0]];
;;;2107   #endif
;;;2108   
;;;2109       return Ret;
;;;2110   }
00002a  bd70              POP      {r4-r6,pc}
;;;2111   /* End Function:RMP_RBIT_Get *************************************************/
                          ENDP

                  |L33.44|
                          DCD      ||.constdata||

                          AREA ||i.RMP_Radiobtn||, CODE, READONLY, ALIGN=1

                  RMP_Radiobtn PROC
;;;3695   ******************************************************************************/
;;;3696   void RMP_Radiobtn(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_ptr_t Status)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;3697   {   
000004  4607              MOV      r7,r0
;;;3698       /* Fill the area with rect */
;;;3699       RMP_Rectangle(Coord_X,Coord_Y,Length,Length,RMP_CTL_GREY,RMP_CTL_GREY);
000006  f64b50d7          MOV      r0,#0xbdd7
00000a  461c              MOV      r4,r3                 ;3697
00000c  4615              MOV      r5,r2                 ;3697
00000e  460e              MOV      r6,r1                 ;3697
000010  4613              MOV      r3,r2
000012  9000              STR      r0,[sp,#0]
000014  9001              STR      r0,[sp,#4]
000016  4638              MOV      r0,r7
000018  f7fffffe          BL       RMP_Rectangle
;;;3700       
;;;3701       /* Draw the circle first */
;;;3702       RMP_Radiobtn_Circle(Coord_X,Coord_Y,Length);
00001c  462a              MOV      r2,r5
00001e  4631              MOV      r1,r6
000020  4638              MOV      r0,r7
000022  f7fffffe          BL       RMP_Radiobtn_Circle
;;;3703       
;;;3704       /* See if the radio button is selected */
;;;3705       if(Status==RMP_RBTN_SEL)
000026  2c01              CMP      r4,#1
000028  d107              BNE      |L34.58|
;;;3706           RMP_Radiobtn_Set(Coord_X, Coord_Y, Length);
00002a  b002              ADD      sp,sp,#8
00002c  462a              MOV      r2,r5
00002e  4631              MOV      r1,r6
000030  4638              MOV      r0,r7
000032  e8bd41f0          POP      {r4-r8,lr}
000036  f7ffbffe          B.W      RMP_Radiobtn_Set
                  |L34.58|
;;;3707   }
00003a  e8bd81fc          POP      {r2-r8,pc}
;;;3708   /* End Function:RMP_Radiobtn *************************************************/
                          ENDP


                          AREA ||i.RMP_Radiobtn_Circle||, CODE, READONLY, ALIGN=1

                  RMP_Radiobtn_Circle PROC
;;;3580   ******************************************************************************/
;;;3581   void RMP_Radiobtn_Circle(rmp_cnt_t Coord_X,rmp_cnt_t Coord_Y,rmp_cnt_t Length)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;3582   {   
;;;3583       rmp_cnt_t Radius;
;;;3584       rmp_cnt_t Center_X;
;;;3585       rmp_cnt_t Center_Y;
;;;3586       rmp_cnt_t Cur_X;
;;;3587       rmp_cnt_t Cur_Y;
;;;3588       rmp_cnt_t Error;
;;;3589       
;;;3590       /* The radius is the length/2 */
;;;3591       Radius=Length>>1;
000004  ea4f0862          ASR      r8,r2,#1
;;;3592       Center_X=Coord_X+Radius;
;;;3593       Center_Y=Coord_Y+Radius;
;;;3594       
;;;3595       /* Now we begin to draw the inner halfcircle */
;;;3596       Cur_X=0;
;;;3597       Cur_Y=Radius-1;
;;;3598       Error=3-((Radius-1)<<1);  
000008  2305              MOVS     r3,#5
00000a  2500              MOVS     r5,#0                 ;3596
00000c  eb000708          ADD      r7,r0,r8              ;3592
000010  eb010608          ADD      r6,r1,r8              ;3593
000014  eba30948          SUB      r9,r3,r8,LSL #1
000018  f1a80401          SUB      r4,r8,#1              ;3597
00001c  e044              B        |L35.168|
                  |L35.30|
;;;3599       
;;;3600       while(Cur_X<=Cur_Y) 
;;;3601       {  
;;;3602           /* This is the upper-left part */
;;;3603           RMP_POINT(Center_X+Cur_X,Center_Y-Cur_Y,RMP_CTL_DDARK);
00001e  1b31              SUBS     r1,r6,r4
000020  f646324d          MOV      r2,#0x6b4d
000024  1978              ADDS     r0,r7,r5
000026  468b              MOV      r11,r1
000028  4682              MOV      r10,r0
00002a  f7fffffe          BL       RMP_Point
;;;3604           RMP_POINT(Center_X-Cur_X,Center_Y-Cur_Y,RMP_CTL_DDARK);
00002e  1b78              SUBS     r0,r7,r5
000030  4659              MOV      r1,r11                ;3603
000032  4683              MOV      r11,r0
000034  f646324d          MOV      r2,#0x6b4d
000038  f7fffffe          BL       RMP_Point
;;;3605           RMP_POINT(Center_X-Cur_Y,Center_Y-Cur_X,RMP_CTL_DDARK);
00003c  1b71              SUBS     r1,r6,r5
00003e  f646324d          MOV      r2,#0x6b4d
000042  1b38              SUBS     r0,r7,r4
000044  9102              STR      r1,[sp,#8]
000046  9000              STR      r0,[sp,#0]
000048  f7fffffe          BL       RMP_Point
;;;3606           RMP_POINT(Center_X-Cur_Y,Center_Y+Cur_X,RMP_CTL_DDARK);
00004c  9800              LDR      r0,[sp,#0]
00004e  1971              ADDS     r1,r6,r5
000050  f646324d          MOV      r2,#0x6b4d
000054  9101              STR      r1,[sp,#4]
000056  f7fffffe          BL       RMP_Point
;;;3607           
;;;3608           /* This is the lower-right part */
;;;3609           RMP_POINT(Center_X+Cur_X,Center_Y+Cur_Y,RMP_CTL_LGREY);
00005a  1931              ADDS     r1,r6,r4
00005c  4650              MOV      r0,r10
00005e  f24e721c          MOV      r2,#0xe71c
000062  9100              STR      r1,[sp,#0]
000064  f7fffffe          BL       RMP_Point
;;;3610           RMP_POINT(Center_X-Cur_X,Center_Y+Cur_Y,RMP_CTL_LGREY);  
000068  9900              LDR      r1,[sp,#0]
00006a  4658              MOV      r0,r11                ;3609
00006c  f24e721c          MOV      r2,#0xe71c
000070  f7fffffe          BL       RMP_Point
;;;3611           RMP_POINT(Center_X+Cur_Y,Center_Y+Cur_X,RMP_CTL_LGREY); 
000074  1938              ADDS     r0,r7,r4
000076  9901              LDR      r1,[sp,#4]
000078  4682              MOV      r10,r0
00007a  f24e721c          MOV      r2,#0xe71c
00007e  f7fffffe          BL       RMP_Point
;;;3612           RMP_POINT(Center_X+Cur_Y,Center_Y-Cur_X,RMP_CTL_LGREY);  
000082  9902              LDR      r1,[sp,#8]
000084  4650              MOV      r0,r10                ;3611
000086  f24e721c          MOV      r2,#0xe71c
00008a  f7fffffe          BL       RMP_Point
;;;3613           
;;;3614           if(Error<0) 
00008e  f1b90f00          CMP      r9,#0
000092  da04              BGE      |L35.158|
;;;3615           {
;;;3616               Error=Error+(Cur_X<<2)+6;
000094  eb090085          ADD      r0,r9,r5,LSL #2
000098  f1000906          ADD      r9,r0,#6
00009c  e003              B        |L35.166|
                  |L35.158|
;;;3617           }
;;;3618           else 
;;;3619           {
;;;3620               Error=Error+((Cur_X-Cur_Y)<<2);
00009e  1b29              SUBS     r1,r5,r4
0000a0  1e64              SUBS     r4,r4,#1
0000a2  eb090981          ADD      r9,r9,r1,LSL #2
                  |L35.166|
0000a6  1c6d              ADDS     r5,r5,#1
                  |L35.168|
0000a8  42a5              CMP      r5,r4                 ;3600
0000aa  ddb8              BLE      |L35.30|
;;;3621               Cur_Y--;
;;;3622           }
;;;3623           Cur_X++;
;;;3624       } 
;;;3625       
;;;3626       /* Now we begin to draw the outer halfcircle */
;;;3627       Cur_X=0;
;;;3628       Cur_Y=Radius;
;;;3629       Error=3-(Radius<<1);  
0000ac  2103              MOVS     r1,#3
0000ae  4645              MOV      r5,r8                 ;3628
0000b0  2400              MOVS     r4,#0                 ;3627
0000b2  eba10948          SUB      r9,r1,r8,LSL #1
;;;3630       
;;;3631       while(Cur_X<=Cur_Y) 
0000b6  e044              B        |L35.322|
                  |L35.184|
;;;3632       {  
;;;3633           /* This is the upper-left part */
;;;3634           RMP_POINT(Center_X+Cur_X,Center_Y-Cur_Y,RMP_CTL_DGREY);
0000b8  1b71              SUBS     r1,r6,r5
0000ba  f24a5214          MOV      r2,#0xa514
0000be  1938              ADDS     r0,r7,r4
0000c0  4688              MOV      r8,r1
0000c2  4682              MOV      r10,r0
0000c4  f7fffffe          BL       RMP_Point
;;;3635           RMP_POINT(Center_X-Cur_X,Center_Y-Cur_Y,RMP_CTL_DGREY);
0000c8  1b38              SUBS     r0,r7,r4
0000ca  4641              MOV      r1,r8                 ;3634
0000cc  f24a5214          MOV      r2,#0xa514
0000d0  9001              STR      r0,[sp,#4]
0000d2  f7fffffe          BL       RMP_Point
;;;3636           RMP_POINT(Center_X-Cur_Y,Center_Y-Cur_X,RMP_CTL_DGREY);
0000d6  1b78              SUBS     r0,r7,r5
0000d8  f24a5214          MOV      r2,#0xa514
0000dc  1b31              SUBS     r1,r6,r4
0000de  4680              MOV      r8,r0
0000e0  9100              STR      r1,[sp,#0]
0000e2  f7fffffe          BL       RMP_Point
;;;3637           RMP_POINT(Center_X-Cur_Y,Center_Y+Cur_X,RMP_CTL_DGREY);
0000e6  1931              ADDS     r1,r6,r4
0000e8  4640              MOV      r0,r8                 ;3636
0000ea  468b              MOV      r11,r1
0000ec  f24a5214          MOV      r2,#0xa514
0000f0  f7fffffe          BL       RMP_Point
;;;3638           
;;;3639           /* This is the lower-right part */
;;;3640           RMP_POINT(Center_X+Cur_X,Center_Y+Cur_Y,RMP_CTL_WHITE);
0000f4  1971              ADDS     r1,r6,r5
0000f6  4650              MOV      r0,r10
0000f8  4688              MOV      r8,r1
0000fa  f64f72ff          MOV      r2,#0xffff
0000fe  f7fffffe          BL       RMP_Point
;;;3641           RMP_POINT(Center_X-Cur_X,Center_Y+Cur_Y,RMP_CTL_WHITE);  
000102  9801              LDR      r0,[sp,#4]
000104  4641              MOV      r1,r8                 ;3640
000106  f64f72ff          MOV      r2,#0xffff
00010a  f7fffffe          BL       RMP_Point
;;;3642           RMP_POINT(Center_X+Cur_Y,Center_Y+Cur_X,RMP_CTL_WHITE); 
00010e  1978              ADDS     r0,r7,r5
000110  4659              MOV      r1,r11                ;3641
000112  4680              MOV      r8,r0
000114  f64f72ff          MOV      r2,#0xffff
000118  f7fffffe          BL       RMP_Point
;;;3643           RMP_POINT(Center_X+Cur_Y,Center_Y-Cur_X,RMP_CTL_WHITE);  
00011c  9900              LDR      r1,[sp,#0]
00011e  4640              MOV      r0,r8                 ;3642
000120  f64f72ff          MOV      r2,#0xffff
000124  f7fffffe          BL       RMP_Point
;;;3644           
;;;3645           if(Error<0) 
000128  f1b90f00          CMP      r9,#0
00012c  da04              BGE      |L35.312|
;;;3646           {  
;;;3647               Error=Error+(Cur_X<<2)+6;  
00012e  eb090084          ADD      r0,r9,r4,LSL #2
000132  f1000906          ADD      r9,r0,#6
000136  e003              B        |L35.320|
                  |L35.312|
;;;3648           } 
;;;3649           else 
;;;3650           {  
;;;3651               Error=Error+((Cur_X-Cur_Y)<<2);  
000138  1b61              SUBS     r1,r4,r5
00013a  1e6d              SUBS     r5,r5,#1
00013c  eb090981          ADD      r9,r9,r1,LSL #2
                  |L35.320|
000140  1c64              ADDS     r4,r4,#1
                  |L35.322|
000142  42ac              CMP      r4,r5                 ;3631
000144  ddb8              BLE      |L35.184|
;;;3652               Cur_Y--;  
;;;3653           }  
;;;3654           Cur_X++;  
;;;3655       } 
;;;3656   }
000146  e8bd8ffe          POP      {r1-r11,pc}
;;;3657   /* End Function:RMP_Radiobtn_Circle ******************************************/
                          ENDP


                          AREA ||i.RMP_Radiobtn_Clr||, CODE, READONLY, ALIGN=1

                  RMP_Radiobtn_Clr PROC
;;;3680   ******************************************************************************/
;;;3681   void RMP_Radiobtn_Clr(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length)
000000  b538              PUSH     {r3-r5,lr}
;;;3682   {
;;;3683       RMP_Circle(Coord_X+Length/2,Coord_Y+Length/2,Length/6,RMP_CTL_GREY,RMP_CTL_GREY);
000002  2506              MOVS     r5,#6
000004  4614              MOV      r4,r2
000006  fb92f2f5          SDIV     r2,r2,r5
00000a  eb0474d4          ADD      r4,r4,r4,LSR #31
00000e  f64b53d7          MOV      r3,#0xbdd7
000012  9300              STR      r3,[sp,#0]
000014  eb010164          ADD      r1,r1,r4,ASR #1
000018  eb000064          ADD      r0,r0,r4,ASR #1
00001c  f7fffffe          BL       RMP_Circle
;;;3684   }
000020  bd38              POP      {r3-r5,pc}
;;;3685   /* End Function:RMP_Radiobtn_Clr *********************************************/
                          ENDP


                          AREA ||i.RMP_Radiobtn_Set||, CODE, READONLY, ALIGN=1

                  RMP_Radiobtn_Set PROC
;;;3666   ******************************************************************************/
;;;3667   void RMP_Radiobtn_Set(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length)
000000  b538              PUSH     {r3-r5,lr}
;;;3668   {
;;;3669       RMP_Circle(Coord_X+Length/2,Coord_Y+Length/2,Length/6,RMP_CTL_BLACK,RMP_CTL_BLACK);
000002  2506              MOVS     r5,#6
000004  4613              MOV      r3,r2
000006  fb92f2f5          SDIV     r2,r2,r5
00000a  eb0373d3          ADD      r3,r3,r3,LSR #31
00000e  2400              MOVS     r4,#0
000010  9400              STR      r4,[sp,#0]
000012  eb010163          ADD      r1,r1,r3,ASR #1
000016  eb000063          ADD      r0,r0,r3,ASR #1
00001a  4623              MOV      r3,r4
00001c  f7fffffe          BL       RMP_Circle
;;;3670   }
000020  bd38              POP      {r3-r5,pc}
;;;3671   /* End Function:RMP_Radiobtn_Set *********************************************/
                          ENDP


                          AREA ||i.RMP_Rectangle||, CODE, READONLY, ALIGN=1

                  RMP_Rectangle PROC
;;;2822   ******************************************************************************/
;;;2823   void RMP_Rectangle(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y, rmp_cnt_t Length, rmp_cnt_t Width, rmp_ptr_t Border, rmp_ptr_t Fill)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;2824   {
;;;2825       rmp_cnt_t Line_Cnt;
;;;2826       
;;;2827       if(Fill!=RMP_TRANS)
;;;2828       {
;;;2829           for(Line_Cnt=0;Line_Cnt<Width;Line_Cnt++)
;;;2830               RMP_Line(Coord_X,Coord_Y+Line_Cnt,Coord_X+Length-1,Coord_Y+Line_Cnt,Fill);
000004  eb000402          ADD      r4,r0,r2
000008  461f              MOV      r7,r3                 ;2824
00000a  4688              MOV      r8,r1                 ;2824
00000c  4682              MOV      r10,r0                ;2824
00000e  e9dd690a          LDRD     r6,r9,[sp,#0x28]      ;2824
000012  f1b90f01          CMP      r9,#1                 ;2827
000016  d00d              BEQ      |L38.52|
000018  2500              MOVS     r5,#0                 ;2829
00001a  e009              B        |L38.48|
                  |L38.28|
00001c  eb080305          ADD      r3,r8,r5
000020  4650              MOV      r0,r10
000022  1e62              SUBS     r2,r4,#1
000024  4619              MOV      r1,r3
000026  f8cd9000          STR      r9,[sp,#0]
00002a  f7fffffe          BL       RMP_Line
00002e  1c6d              ADDS     r5,r5,#1
                  |L38.48|
000030  42bd              CMP      r5,r7                 ;2829
000032  dbf3              BLT      |L38.28|
                  |L38.52|
;;;2831       }
;;;2832   
;;;2833       if(Border!=RMP_TRANS)
000034  2e01              CMP      r6,#1
000036  d01d              BEQ      |L38.116|
;;;2834       {
;;;2835           RMP_Line(Coord_X,Coord_Y,Coord_X+Length-1,Coord_Y,Border);
000038  4643              MOV      r3,r8
00003a  4650              MOV      r0,r10
00003c  1e62              SUBS     r2,r4,#1
00003e  4619              MOV      r1,r3
000040  9600              STR      r6,[sp,#0]
000042  f7fffffe          BL       RMP_Line
;;;2836           RMP_Line(Coord_X+Length-1,Coord_Y,Coord_X+Length-1,Coord_Y+Width-1,Border);
000046  eb080507          ADD      r5,r8,r7
00004a  4641              MOV      r1,r8
00004c  1e62              SUBS     r2,r4,#1
00004e  9600              STR      r6,[sp,#0]
000050  1e6b              SUBS     r3,r5,#1
000052  1e60              SUBS     r0,r4,#1
000054  f7fffffe          BL       RMP_Line
;;;2837           RMP_Line(Coord_X+Length-1,Coord_Y+Width-1,Coord_X,Coord_Y+Width-1,Border);
000058  1e60              SUBS     r0,r4,#1
00005a  4652              MOV      r2,r10
00005c  1e6b              SUBS     r3,r5,#1
00005e  9600              STR      r6,[sp,#0]
000060  1e69              SUBS     r1,r5,#1
000062  f7fffffe          BL       RMP_Line
;;;2838           RMP_Line(Coord_X,Coord_Y+Width-1,Coord_X,Coord_Y,Border);
000066  4652              MOV      r2,r10
000068  4643              MOV      r3,r8
00006a  1e69              SUBS     r1,r5,#1
00006c  4610              MOV      r0,r2
00006e  9600              STR      r6,[sp,#0]
000070  f7fffffe          BL       RMP_Line
                  |L38.116|
;;;2839       }
;;;2840   }
000074  e8bd8ff8          POP      {r3-r11,pc}
;;;2841   /* End Function:RMP_Rectangle ************************************************/
                          ENDP


                          AREA ||i.RMP_Round_Rect||, CODE, READONLY, ALIGN=1

                  RMP_Round_Rect PROC
;;;2853   ******************************************************************************/
;;;2854   void RMP_Round_Rect(rmp_cnt_t Coord_X, rmp_cnt_t Coord_Y,
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;2855                       rmp_cnt_t Length, rmp_cnt_t Width, rmp_cnt_t Round, rmp_ptr_t Color)
;;;2856   {
000004  4688              MOV      r8,r1
000006  4681              MOV      r9,r0
;;;2857       rmp_cnt_t Cir_X_0;
;;;2858       rmp_cnt_t Cir_X_1;
;;;2859       rmp_cnt_t Cir_Y_0;
;;;2860       rmp_cnt_t Cir_Y_1;
;;;2861       
;;;2862       Cir_X_0=Coord_X+Round+1;
;;;2863       Cir_X_1=Coord_X+Length-Round-1;
000008  1881              ADDS     r1,r0,r2
00000a  e9dd540e          LDRD     r5,r4,[sp,#0x38]      ;2856
;;;2864       Cir_Y_0=Coord_Y+Round+1;
;;;2865       Cir_Y_1=Coord_Y+Width-Round-1;
00000e  eb080703          ADD      r7,r8,r3
000012  1b4e              SUBS     r6,r1,r5              ;2863
;;;2866       
;;;2867       /* Draw the innermost one rectangle */
;;;2868       RMP_Rectangle(Coord_X+Round+1,Coord_Y+Round+1,Length-Round-Round-2,Width-Round-Round-2,Color,Color);
000014  9400              STR      r4,[sp,#0]
000016  4428              ADD      r0,r0,r5              ;2862
000018  9401              STR      r4,[sp,#4]
00001a  1c41              ADDS     r1,r0,#1              ;2862
00001c  9102              STR      r1,[sp,#8]            ;2865
00001e  1b79              SUBS     r1,r7,r5              ;2865
000020  f1a10b01          SUB      r11,r1,#1             ;2865
000024  f1a60a01          SUB      r10,r6,#1             ;2865
000028  eb080105          ADD      r1,r8,r5              ;2864
00002c  1c4e              ADDS     r6,r1,#1              ;2864
00002e  9603              STR      r6,[sp,#0xc]
000030  1b5b              SUBS     r3,r3,r5
000032  1b52              SUBS     r2,r2,r5
000034  1b5e              SUBS     r6,r3,r5
000036  1b57              SUBS     r7,r2,r5
000038  1eb3              SUBS     r3,r6,#2
00003a  1eba              SUBS     r2,r7,#2
00003c  1c40              ADDS     r0,r0,#1
00003e  1c49              ADDS     r1,r1,#1
000040  f7fffffe          BL       RMP_Rectangle
;;;2869   
;;;2870       /* Draw 4 small side rectangles */
;;;2871       RMP_Rectangle(Coord_X,Cir_Y_0,Round+1,Width-Round-Round-2,Color,Color);
000044  9903              LDR      r1,[sp,#0xc]
000046  1eb3              SUBS     r3,r6,#2
000048  1c6a              ADDS     r2,r5,#1
00004a  4648              MOV      r0,r9
00004c  9400              STR      r4,[sp,#0]
00004e  9401              STR      r4,[sp,#4]
000050  f7fffffe          BL       RMP_Rectangle
;;;2872       RMP_Rectangle(Cir_X_1,Cir_Y_0,Round+1,Width-Round-Round-2,Color,Color);
000054  9903              LDR      r1,[sp,#0xc]
000056  1eb3              SUBS     r3,r6,#2
000058  1c6a              ADDS     r2,r5,#1
00005a  4650              MOV      r0,r10
00005c  9400              STR      r4,[sp,#0]
00005e  9401              STR      r4,[sp,#4]
000060  f7fffffe          BL       RMP_Rectangle
;;;2873       RMP_Rectangle(Cir_X_0,Cir_Y_1,Length-Round-Round-2,Round+1,Color,Color);
000064  9802              LDR      r0,[sp,#8]
000066  1eba              SUBS     r2,r7,#2
000068  1c6b              ADDS     r3,r5,#1
00006a  4659              MOV      r1,r11
00006c  9400              STR      r4,[sp,#0]
00006e  9401              STR      r4,[sp,#4]
000070  f7fffffe          BL       RMP_Rectangle
;;;2874       RMP_Rectangle(Cir_X_0,Coord_Y,Length-Round-Round-2,Round+1,Color,Color);
000074  9802              LDR      r0,[sp,#8]
000076  1eba              SUBS     r2,r7,#2
000078  1c6b              ADDS     r3,r5,#1
00007a  4641              MOV      r1,r8
00007c  9400              STR      r4,[sp,#0]
00007e  9401              STR      r4,[sp,#4]
000080  f7fffffe          BL       RMP_Rectangle
;;;2875       
;;;2876       /* Draw 4 circles */
;;;2877       RMP_Circle(Cir_X_0,Cir_Y_0,Round,Color,Color);
000084  e9dd0102          LDRD     r0,r1,[sp,#8]
000088  4623              MOV      r3,r4
00008a  462a              MOV      r2,r5
00008c  9400              STR      r4,[sp,#0]
00008e  f7fffffe          BL       RMP_Circle
;;;2878       RMP_Circle(Cir_X_1,Cir_Y_0,Round,Color,Color);
000092  9903              LDR      r1,[sp,#0xc]
000094  4623              MOV      r3,r4
000096  462a              MOV      r2,r5
000098  4650              MOV      r0,r10
00009a  9400              STR      r4,[sp,#0]
00009c  f7fffffe          BL       RMP_Circle
;;;2879       RMP_Circle(Cir_X_0,Cir_Y_1,Round,Color,Color);
0000a0  9802              LDR      r0,[sp,#8]
0000a2  4623              MOV      r3,r4
0000a4  462a              MOV      r2,r5
0000a6  4659              MOV      r1,r11
0000a8  9400              STR      r4,[sp,#0]
0000aa  f7fffffe          BL       RMP_Circle
;;;2880       RMP_Circle(Cir_X_1,Cir_Y_1,Round,Color,Color);
0000ae  4623              MOV      r3,r4
0000b0  462a              MOV      r2,r5
0000b2  4659              MOV      r1,r11
0000b4  4650              MOV      r0,r10
0000b6  9400              STR      r4,[sp,#0]
0000b8  f7fffffe          BL       RMP_Circle
;;;2881   }
0000bc  e8bd9fff          POP      {r0-r12,pc}
;;;2882   /* End Function:RMP_Round_Rect ***********************************************/
                          ENDP


                          AREA ||i.RMP_Save_Ctx||, CODE, READONLY, ALIGN=1

                  RMP_Save_Ctx PROC
;;;1942   #if(RMP_USE_HOOKS==RMP_FALSE)
;;;1943   void RMP_Save_Ctx(void)
000000  4770              BX       lr
;;;1944   {
;;;1945       return;
;;;1946   }
;;;1947   #endif
                          ENDP


                          AREA ||i.RMP_Sem_Abort||, CODE, READONLY, ALIGN=1

                  RMP_Sem_Abort PROC
;;;1737   ******************************************************************************/
;;;1738   rmp_ret_t RMP_Sem_Abort(volatile struct RMP_Thd* Thread)
000000  b570              PUSH     {r4-r6,lr}
;;;1739   {
000002  0004              MOVS     r4,r0
;;;1740       /* Check if this thread structure could possibly be in use */
;;;1741       if(Thread==0)
;;;1742       {
;;;1743           RMP_COVERAGE_MARKER();
;;;1744           return RMP_ERR_THD;
000004  f04f35ff          MOV      r5,#0xffffffff
000008  d011              BEQ      |L41.46|
;;;1745       }
;;;1746       else
;;;1747           RMP_COVERAGE_MARKER();
;;;1748   
;;;1749       RMP_Lock_Sched();
00000a  f7fffffe          BL       RMP_Lock_Sched
;;;1750       
;;;1751       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
00000e  69a0              LDR      r0,[r4,#0x18]
000010  f0100fff          TST      r0,#0xff
000014  d00d              BEQ      |L41.50|
;;;1752       {
;;;1753           RMP_COVERAGE_MARKER();
;;;1754           RMP_Unlock_Sched();
;;;1755           return RMP_ERR_THD;
;;;1756       }
;;;1757       else
;;;1758           RMP_COVERAGE_MARKER();
;;;1759       
;;;1760       /* Is it waiting on a semaphore? If no, we abort and return an error code */
;;;1761       if((RMP_THD_STATE(Thread->State)!=RMP_THD_SEMBLK)&&
000016  69a0              LDR      r0,[r4,#0x18]
000018  b2c0              UXTB     r0,r0
00001a  2807              CMP      r0,#7
00001c  d00c              BEQ      |L41.56|
;;;1762          (RMP_THD_STATE(Thread->State)!=RMP_THD_SEMDLY))
00001e  69a0              LDR      r0,[r4,#0x18]
000020  b2c0              UXTB     r0,r0
000022  2808              CMP      r0,#8
000024  d008              BEQ      |L41.56|
;;;1763       {
;;;1764           RMP_COVERAGE_MARKER();
;;;1765           RMP_Unlock_Sched();
000026  f7fffffe          BL       RMP_Unlock_Sched
;;;1766           return RMP_ERR_STATE;
00002a  00a8              LSLS     r0,r5,#2
;;;1767       }
;;;1768       else
;;;1769           RMP_COVERAGE_MARKER();
;;;1770   
;;;1771       /* Waiting for a semaphore. We abort it and return */
;;;1772       RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1773       if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1774       {
;;;1775           RMP_COVERAGE_MARKER();
;;;1776           RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1777       }
;;;1778       else
;;;1779           RMP_COVERAGE_MARKER();
;;;1780       
;;;1781       RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1782       /* Set to running if not suspended */
;;;1783       _RMP_Set_Rdy(Thread);
;;;1784       
;;;1785       Thread->Retval=RMP_ERR_OPER;
;;;1786       RMP_Unlock_Sched();
;;;1787       return 0;
;;;1788   }
00002c  bd70              POP      {r4-r6,pc}
                  |L41.46|
00002e  4628              MOV      r0,r5                 ;1744
000030  bd70              POP      {r4-r6,pc}
                  |L41.50|
000032  f7fffffe          BL       RMP_Unlock_Sched
000036  e7fa              B        |L41.46|
                  |L41.56|
000038  6820              LDR      r0,[r4,#0]            ;1772
00003a  6861              LDR      r1,[r4,#4]            ;1772
00003c  6008              STR      r0,[r1,#0]            ;1772
00003e  6041              STR      r1,[r0,#4]            ;1772
000040  69a0              LDR      r0,[r4,#0x18]         ;1773
000042  b2c0              UXTB     r0,r0                 ;1773
000044  2808              CMP      r0,#8                 ;1773
000046  d103              BNE      |L41.80|
000048  68a1              LDR      r1,[r4,#8]            ;1776
00004a  68e0              LDR      r0,[r4,#0xc]          ;1776
00004c  6001              STR      r1,[r0,#0]            ;1776
00004e  6048              STR      r0,[r1,#4]            ;1776
                  |L41.80|
000050  69a0              LDR      r0,[r4,#0x18]         ;1781
000052  f02000ff          BIC      r0,r0,#0xff           ;1781
000056  1c40              ADDS     r0,r0,#1              ;1781
000058  61a0              STR      r0,[r4,#0x18]         ;1781
00005a  4620              MOV      r0,r4                 ;1783
00005c  f7fffffe          BL       _RMP_Set_Rdy
000060  f06f0004          MVN      r0,#4                 ;1785
000064  63a0              STR      r0,[r4,#0x38]         ;1785
000066  f7fffffe          BL       RMP_Unlock_Sched
00006a  2000              MOVS     r0,#0                 ;1787
00006c  bd70              POP      {r4-r6,pc}
;;;1789   /* End Function:RMP_Sem_Abort ************************************************/
                          ENDP


                          AREA ||i.RMP_Sem_Crt||, CODE, READONLY, ALIGN=1

                  RMP_Sem_Crt PROC
;;;1556   ******************************************************************************/
;;;1557   rmp_ret_t RMP_Sem_Crt(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Number)
000000  b570              PUSH     {r4-r6,lr}
;;;1558   {
000002  0004              MOVS     r4,r0
000004  460d              MOV      r5,r1
;;;1559       /* Check if this semaphore structure could possibly be in use */
;;;1560       if(Semaphore==0)
;;;1561       {
;;;1562           RMP_COVERAGE_MARKER();
;;;1563           return RMP_ERR_SEM;
000006  f06f0605          MVN      r6,#5
00000a  d005              BEQ      |L42.24|
;;;1564       }
;;;1565       else
;;;1566           RMP_COVERAGE_MARKER();
;;;1567       
;;;1568       RMP_Lock_Sched();
00000c  f7fffffe          BL       RMP_Lock_Sched
;;;1569       
;;;1570       if(Semaphore->State!=RMP_SEM_FREE)
000010  68a0              LDR      r0,[r4,#8]
000012  b118              CBZ      r0,|L42.28|
;;;1571       {
;;;1572           RMP_COVERAGE_MARKER();
;;;1573           RMP_Unlock_Sched();
000014  f7fffffe          BL       RMP_Unlock_Sched
                  |L42.24|
000018  4630              MOV      r0,r6                 ;1563
;;;1574           return RMP_ERR_SEM;
;;;1575       }
;;;1576       else
;;;1577           RMP_COVERAGE_MARKER();
;;;1578       
;;;1579       /* Is the number too great to initialize? */
;;;1580       if(Number>=RMP_SEM_MAX_NUM)
;;;1581       {
;;;1582           RMP_COVERAGE_MARKER();
;;;1583           RMP_Unlock_Sched();
;;;1584           return RMP_ERR_OPER;
;;;1585       }
;;;1586       else
;;;1587           RMP_COVERAGE_MARKER();
;;;1588   
;;;1589       /* Initialize contents */
;;;1590       Semaphore->Cur_Num=Number;
;;;1591       Semaphore->State=RMP_SEM_USED;
;;;1592       RMP_List_Crt(&(Semaphore->Wait_List));
;;;1593       
;;;1594       RMP_Unlock_Sched();
;;;1595       
;;;1596       return 0;
;;;1597   }
00001a  bd70              POP      {r4-r6,pc}
                  |L42.28|
00001c  f5b57f7a          CMP      r5,#0x3e8             ;1580
000020  d304              BCC      |L42.44|
000022  f7fffffe          BL       RMP_Unlock_Sched
000026  f06f0004          MVN      r0,#4                 ;1584
00002a  bd70              POP      {r4-r6,pc}
                  |L42.44|
00002c  2001              MOVS     r0,#1                 ;1591
00002e  60e5              STR      r5,[r4,#0xc]          ;1590
000030  60a0              STR      r0,[r4,#8]            ;1591
000032  6024              STR      r4,[r4,#0]            ;1591
000034  6064              STR      r4,[r4,#4]            ;1591
000036  f7fffffe          BL       RMP_Unlock_Sched
00003a  2000              MOVS     r0,#0                 ;1596
00003c  bd70              POP      {r4-r6,pc}
;;;1598   /* End Function:RMP_Sem_Crt **************************************************/
                          ENDP


                          AREA ||i.RMP_Sem_Del||, CODE, READONLY, ALIGN=1

                  RMP_Sem_Del PROC
;;;1605   ******************************************************************************/
;;;1606   rmp_ret_t RMP_Sem_Del(volatile struct RMP_Sem* Semaphore)
000000  b570              PUSH     {r4-r6,lr}
;;;1607   {
000002  0005              MOVS     r5,r0
;;;1608       struct RMP_Thd* Thread;
;;;1609       
;;;1610       /* Check if this semaphore structure could possibly be in use */
;;;1611       if(Semaphore==0)
;;;1612       {
;;;1613           RMP_COVERAGE_MARKER();
;;;1614           return RMP_ERR_SEM;
000004  f06f0405          MVN      r4,#5
000008  d006              BEQ      |L43.24|
;;;1615       }
;;;1616       else
;;;1617           RMP_COVERAGE_MARKER();
;;;1618       
;;;1619       RMP_Lock_Sched();
00000a  f7fffffe          BL       RMP_Lock_Sched
;;;1620       
;;;1621       if(Semaphore->State!=RMP_SEM_USED)
00000e  68a8              LDR      r0,[r5,#8]
000010  2801              CMP      r0,#1
000012  d019              BEQ      |L43.72|
;;;1622       {
;;;1623           RMP_COVERAGE_MARKER();
;;;1624           RMP_Unlock_Sched();
000014  f7fffffe          BL       RMP_Unlock_Sched
                  |L43.24|
000018  4620              MOV      r0,r4                 ;1614
;;;1625           return RMP_ERR_SEM;
;;;1626       }
;;;1627       else
;;;1628           RMP_COVERAGE_MARKER();
;;;1629   
;;;1630       /* Get rid of all guys waiting on it */
;;;1631       while(&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)
;;;1632       {
;;;1633           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
;;;1634           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1635           
;;;1636           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1637           {
;;;1638               RMP_COVERAGE_MARKER();
;;;1639               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1640           }
;;;1641           else
;;;1642               RMP_COVERAGE_MARKER();
;;;1643   
;;;1644           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1645           /* Set to running if not suspended */
;;;1646           _RMP_Set_Rdy(Thread);
;;;1647           Thread->Retval=RMP_ERR_OPER;
;;;1648       }
;;;1649       Semaphore->State=RMP_SEM_FREE;
;;;1650       
;;;1651       RMP_Unlock_Sched();
;;;1652   
;;;1653       return 0;
;;;1654   }
00001a  bd70              POP      {r4-r6,pc}
                  |L43.28|
00001c  686c              LDR      r4,[r5,#4]            ;1633
00001e  e9d40100          LDRD     r0,r1,[r4,#0]         ;1633
000022  6008              STR      r0,[r1,#0]            ;1633
000024  6041              STR      r1,[r0,#4]            ;1633
000026  7e20              LDRB     r0,[r4,#0x18]         ;1636
000028  2808              CMP      r0,#8                 ;1636
00002a  d103              BNE      |L43.52|
00002c  e9d40102          LDRD     r0,r1,[r4,#8]         ;1636
000030  6008              STR      r0,[r1,#0]            ;1636
000032  6041              STR      r1,[r0,#4]            ;1636
                  |L43.52|
000034  69a0              LDR      r0,[r4,#0x18]         ;1644
000036  f02000ff          BIC      r0,r0,#0xff           ;1644
00003a  1c40              ADDS     r0,r0,#1              ;1644
00003c  61a0              STR      r0,[r4,#0x18]         ;1646
00003e  4620              MOV      r0,r4                 ;1646
000040  f7fffffe          BL       _RMP_Set_Rdy
000044  63a6              STR      r6,[r4,#0x38]         ;1647
000046  e001              B        |L43.76|
                  |L43.72|
000048  f06f0604          MVN      r6,#4                 ;1647
                  |L43.76|
00004c  6868              LDR      r0,[r5,#4]            ;1631
00004e  42a8              CMP      r0,r5                 ;1631
000050  d1e4              BNE      |L43.28|
000052  2000              MOVS     r0,#0                 ;1649
000054  60a8              STR      r0,[r5,#8]            ;1649
000056  f7fffffe          BL       RMP_Unlock_Sched
00005a  2000              MOVS     r0,#0                 ;1653
00005c  bd70              POP      {r4-r6,pc}
;;;1655   /* End Function:RMP_Sem_Del **************************************************/
                          ENDP


                          AREA ||i.RMP_Sem_Pend||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Pend PROC
;;;1663   ******************************************************************************/
;;;1664   rmp_ret_t RMP_Sem_Pend(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Slices)
000000  b570              PUSH     {r4-r6,lr}
;;;1665   {
000002  0005              MOVS     r5,r0
000004  460e              MOV      r6,r1
;;;1666       /* Check if this semaphore structure could possibly be in use */
;;;1667       if(Semaphore==0)
;;;1668       {
;;;1669           RMP_COVERAGE_MARKER();
;;;1670           return RMP_ERR_SEM;
000006  f06f0405          MVN      r4,#5
00000a  d006              BEQ      |L44.26|
;;;1671       }
;;;1672       else
;;;1673           RMP_COVERAGE_MARKER();
;;;1674       
;;;1675       RMP_Lock_Sched();
00000c  f7fffffe          BL       RMP_Lock_Sched
;;;1676       
;;;1677       if(Semaphore->State!=RMP_SEM_USED)
000010  68a8              LDR      r0,[r5,#8]
000012  2801              CMP      r0,#1
000014  d003              BEQ      |L44.30|
;;;1678       {
;;;1679           RMP_COVERAGE_MARKER();
;;;1680           RMP_Unlock_Sched();
000016  f7fffffe          BL       RMP_Unlock_Sched
                  |L44.26|
00001a  4620              MOV      r0,r4                 ;1670
;;;1681           return RMP_ERR_SEM;
;;;1682       }
;;;1683       else
;;;1684           RMP_COVERAGE_MARKER();
;;;1685       
;;;1686       /* Check if we can get one immediately */
;;;1687       if(Semaphore->Cur_Num!=0)
;;;1688       {
;;;1689           RMP_COVERAGE_MARKER();
;;;1690           Semaphore->Cur_Num--;
;;;1691           RMP_Unlock_Sched();
;;;1692           return Semaphore->Cur_Num;
;;;1693       }
;;;1694       else
;;;1695       {
;;;1696           RMP_COVERAGE_MARKER();
;;;1697           /* Cannot get one, we need to block */
;;;1698           if(Slices==0)
;;;1699           {
;;;1700               RMP_COVERAGE_MARKER();
;;;1701               RMP_Unlock_Sched();
;;;1702               return RMP_ERR_OPER;
;;;1703           }
;;;1704           else
;;;1705               RMP_COVERAGE_MARKER();
;;;1706   
;;;1707           /* We must be running - place into waitlist now */
;;;1708           _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1709           RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),Semaphore->Wait_List.Prev,&(Semaphore->Wait_List));
;;;1710           
;;;1711           if(Slices<RMP_MAX_SLICES)
;;;1712           {
;;;1713               RMP_COVERAGE_MARKER();
;;;1714               _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1715               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SEMDLY);
;;;1716           }
;;;1717           else
;;;1718           {
;;;1719               RMP_COVERAGE_MARKER();
;;;1720               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SEMBLK);
;;;1721           }
;;;1722           
;;;1723           RMP_Cur_Thd->Retval=0;
;;;1724       }
;;;1725       
;;;1726       RMP_Unlock_Sched();
;;;1727   
;;;1728       return RMP_Cur_Thd->Retval;
;;;1729   }
00001c  bd70              POP      {r4-r6,pc}
                  |L44.30|
00001e  68e8              LDR      r0,[r5,#0xc]          ;1687
000020  b130              CBZ      r0,|L44.48|
000022  68e8              LDR      r0,[r5,#0xc]          ;1690
000024  1e40              SUBS     r0,r0,#1              ;1690
000026  60e8              STR      r0,[r5,#0xc]          ;1690
000028  f7fffffe          BL       RMP_Unlock_Sched
00002c  68e8              LDR      r0,[r5,#0xc]          ;1692
00002e  bd70              POP      {r4-r6,pc}
                  |L44.48|
000030  b1be              CBZ      r6,|L44.98|
000032  4c16              LDR      r4,|L44.140|
000034  69a0              LDR      r0,[r4,#0x18]         ;1708  ; RMP_Cur_Thd
000036  f7fffffe          BL       _RMP_Clr_Rdy
00003a  6829              LDR      r1,[r5,#0]            ;1709
00003c  462a              MOV      r2,r5                 ;1709
00003e  69a0              LDR      r0,[r4,#0x18]         ;1709  ; RMP_Cur_Thd
000040  f7fffffe          BL       RMP_List_Ins
000044  4812              LDR      r0,|L44.144|
000046  4286              CMP      r6,r0                 ;1711
000048  d210              BCS      |L44.108|
00004a  69a0              LDR      r0,[r4,#0x18]         ;1714  ; RMP_Cur_Thd
00004c  4631              MOV      r1,r6                 ;1714
00004e  f7fffffe          BL       _RMP_Dly_Ins
000052  69a0              LDR      r0,[r4,#0x18]         ;1715  ; RMP_Cur_Thd
000054  69a1              LDR      r1,[r4,#0x18]         ;1715  ; RMP_Cur_Thd
000056  6980              LDR      r0,[r0,#0x18]         ;1715
000058  f02000ff          BIC      r0,r0,#0xff           ;1715
00005c  f0400008          ORR      r0,r0,#8              ;1715
000060  e00a              B        |L44.120|
                  |L44.98|
000062  f7fffffe          BL       RMP_Unlock_Sched
000066  f06f0004          MVN      r0,#4                 ;1702
00006a  bd70              POP      {r4-r6,pc}
                  |L44.108|
00006c  69a0              LDR      r0,[r4,#0x18]         ;1720  ; RMP_Cur_Thd
00006e  69a1              LDR      r1,[r4,#0x18]         ;1720  ; RMP_Cur_Thd
000070  6980              LDR      r0,[r0,#0x18]         ;1720
000072  f02000ff          BIC      r0,r0,#0xff           ;1720
000076  1dc0              ADDS     r0,r0,#7              ;1720
                  |L44.120|
000078  6188              STR      r0,[r1,#0x18]         ;1723
00007a  69a1              LDR      r1,[r4,#0x18]         ;1723  ; RMP_Cur_Thd
00007c  2000              MOVS     r0,#0                 ;1723
00007e  6388              STR      r0,[r1,#0x38]         ;1726
000080  f7fffffe          BL       RMP_Unlock_Sched
000084  69a0              LDR      r0,[r4,#0x18]         ;1728  ; RMP_Cur_Thd
000086  6b80              LDR      r0,[r0,#0x38]         ;1728
000088  bd70              POP      {r4-r6,pc}
;;;1730   /* End Function:RMP_Sem_Pend *************************************************/
                          ENDP

00008a  0000              DCW      0x0000
                  |L44.140|
                          DCD      ||.data||
                  |L44.144|
                          DCD      0x000186a0

                          AREA ||i.RMP_Sem_Post||, CODE, READONLY, ALIGN=1

                  RMP_Sem_Post PROC
;;;1797   ******************************************************************************/
;;;1798   rmp_ret_t RMP_Sem_Post(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Number)
000000  b570              PUSH     {r4-r6,lr}
;;;1799   {
000002  0004              MOVS     r4,r0
000004  460d              MOV      r5,r1
;;;1800       struct RMP_Thd* Thread;
;;;1801       
;;;1802       /* Check if this semaphore structure could possibly be in use */
;;;1803       if((Semaphore==0)||(Number==0))
;;;1804       {
;;;1805           RMP_COVERAGE_MARKER();
;;;1806           return RMP_ERR_SEM;
000006  f06f0605          MVN      r6,#5
00000a  d007              BEQ      |L45.28|
00000c  b135              CBZ      r5,|L45.28|
;;;1807       }
;;;1808       else
;;;1809           RMP_COVERAGE_MARKER();
;;;1810       
;;;1811       RMP_Lock_Sched();
00000e  f7fffffe          BL       RMP_Lock_Sched
;;;1812       
;;;1813       if(Semaphore->State!=RMP_SEM_USED)
000012  68a0              LDR      r0,[r4,#8]
000014  2801              CMP      r0,#1
000016  d003              BEQ      |L45.32|
;;;1814       {
;;;1815           RMP_COVERAGE_MARKER();
;;;1816           RMP_Unlock_Sched();
000018  f7fffffe          BL       RMP_Unlock_Sched
                  |L45.28|
00001c  4630              MOV      r0,r6                 ;1806
;;;1817           return RMP_ERR_SEM;
;;;1818       }
;;;1819       else
;;;1820           RMP_COVERAGE_MARKER();
;;;1821       
;;;1822       /* Would the maximum value be exceeded if this is posted? */
;;;1823       if((Semaphore->Cur_Num+Number)>=RMP_SEM_MAX_NUM)
;;;1824       {
;;;1825           RMP_COVERAGE_MARKER();
;;;1826           RMP_Unlock_Sched();
;;;1827           return RMP_ERR_OPER;
;;;1828       }
;;;1829       else
;;;1830           RMP_COVERAGE_MARKER();
;;;1831       
;;;1832       Semaphore->Cur_Num+=Number;
;;;1833       /* Is there any thread waiting on it? If there are, clean them up*/
;;;1834       while((&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)&&(Semaphore->Cur_Num!=0))
;;;1835       {
;;;1836           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
;;;1837           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1838           
;;;1839           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1840           {
;;;1841               RMP_COVERAGE_MARKER();
;;;1842               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1843           }
;;;1844           else
;;;1845               RMP_COVERAGE_MARKER();
;;;1846           
;;;1847           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1848           /* Set to running if not suspended */
;;;1849           _RMP_Set_Rdy(Thread);
;;;1850   
;;;1851           /* Finally, return success */
;;;1852           Thread->Retval=0;
;;;1853           Semaphore->Cur_Num--;
;;;1854       }
;;;1855   
;;;1856       RMP_Unlock_Sched();
;;;1857       return 0;
;;;1858   }
00001e  bd70              POP      {r4-r6,pc}
                  |L45.32|
000020  68e0              LDR      r0,[r4,#0xc]          ;1823
000022  4428              ADD      r0,r0,r5              ;1823
000024  f5b07f7a          CMP      r0,#0x3e8             ;1823
000028  d304              BCC      |L45.52|
00002a  f7fffffe          BL       RMP_Unlock_Sched
00002e  f06f0004          MVN      r0,#4                 ;1827
000032  bd70              POP      {r4-r6,pc}
                  |L45.52|
000034  68e0              LDR      r0,[r4,#0xc]          ;1832
000036  4428              ADD      r0,r0,r5              ;1832
000038  e017              B        |L45.106|
                  |L45.58|
00003a  6865              LDR      r5,[r4,#4]            ;1836
00003c  e9d50100          LDRD     r0,r1,[r5,#0]         ;1836
000040  6008              STR      r0,[r1,#0]            ;1836
000042  6041              STR      r1,[r0,#4]            ;1836
000044  7e28              LDRB     r0,[r5,#0x18]         ;1839
000046  2808              CMP      r0,#8                 ;1839
000048  d103              BNE      |L45.82|
00004a  e9d50102          LDRD     r0,r1,[r5,#8]         ;1839
00004e  6008              STR      r0,[r1,#0]            ;1839
000050  6041              STR      r1,[r0,#4]            ;1839
                  |L45.82|
000052  69a8              LDR      r0,[r5,#0x18]         ;1847
000054  f02000ff          BIC      r0,r0,#0xff           ;1847
000058  1c40              ADDS     r0,r0,#1              ;1847
00005a  61a8              STR      r0,[r5,#0x18]         ;1849
00005c  4628              MOV      r0,r5                 ;1849
00005e  f7fffffe          BL       _RMP_Set_Rdy
000062  2000              MOVS     r0,#0                 ;1852
000064  63a8              STR      r0,[r5,#0x38]         ;1853
000066  68e0              LDR      r0,[r4,#0xc]          ;1853
000068  1e40              SUBS     r0,r0,#1              ;1853
                  |L45.106|
00006a  60e0              STR      r0,[r4,#0xc]          ;1832
00006c  6860              LDR      r0,[r4,#4]            ;1834
00006e  42a0              CMP      r0,r4                 ;1834
000070  d002              BEQ      |L45.120|
000072  68e0              LDR      r0,[r4,#0xc]          ;1834
000074  2800              CMP      r0,#0                 ;1834
000076  d1e0              BNE      |L45.58|
                  |L45.120|
000078  f7fffffe          BL       RMP_Unlock_Sched
00007c  2000              MOVS     r0,#0                 ;1857
00007e  bd70              POP      {r4-r6,pc}
;;;1859   /* End Function:RMP_Sem_Post *************************************************/
                          ENDP


                          AREA ||i.RMP_Sem_Post_ISR||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Post_ISR PROC
;;;1869   ******************************************************************************/
;;;1870   rmp_ret_t RMP_Sem_Post_ISR(volatile struct RMP_Sem* Semaphore, rmp_ptr_t Number)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1871   {
000004  0004              MOVS     r4,r0
;;;1872       struct RMP_Thd* Thread;
;;;1873       /* Check if this semaphore structure could possibly be in use */
;;;1874       if((Semaphore==0)||(Number==0))
;;;1875       {
;;;1876           RMP_COVERAGE_MARKER();
;;;1877           return RMP_ERR_SEM;
000006  f06f0005          MVN      r0,#5
00000a  d00a              BEQ      |L46.34|
00000c  2900              CMP      r1,#0                 ;1874
00000e  d008              BEQ      |L46.34|
;;;1878       }
;;;1879       else
;;;1880           RMP_COVERAGE_MARKER();
;;;1881       
;;;1882       if(Semaphore->State!=RMP_SEM_USED)
000010  68a2              LDR      r2,[r4,#8]
000012  2a01              CMP      r2,#1
000014  d105              BNE      |L46.34|
;;;1883       {
;;;1884           RMP_COVERAGE_MARKER();
;;;1885           return RMP_ERR_SEM;
;;;1886       }
;;;1887       else
;;;1888           RMP_COVERAGE_MARKER();
;;;1889   
;;;1890       /* Would the maximum value be exceeded if this is posted? */
;;;1891       if((Semaphore->Cur_Num+Number)>=RMP_SEM_MAX_NUM)
000016  68e0              LDR      r0,[r4,#0xc]
000018  4408              ADD      r0,r0,r1
00001a  f5b07f7a          CMP      r0,#0x3e8
00001e  d302              BCC      |L46.38|
;;;1892       {
;;;1893           RMP_COVERAGE_MARKER();
;;;1894           return RMP_ERR_OPER;
000020  1f90              SUBS     r0,r2,#6
                  |L46.34|
;;;1895       }
;;;1896       else
;;;1897           RMP_COVERAGE_MARKER();
;;;1898       
;;;1899       Semaphore->Cur_Num+=Number;
;;;1900       /* Is there any thread waiting on it? If there are, clean them up*/
;;;1901       while((&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)&&(Semaphore->Cur_Num!=0))
;;;1902       {
;;;1903           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
;;;1904           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1905           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1906           {
;;;1907               RMP_COVERAGE_MARKER();
;;;1908               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1909           }
;;;1910           else
;;;1911               RMP_COVERAGE_MARKER();
;;;1912           
;;;1913           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1914           /* Set to running if not suspended */
;;;1915           _RMP_Set_Rdy(Thread);
;;;1916           
;;;1917           /* If schedule pending, trigger it now because we are in ISR */
;;;1918           if(RMP_Sched_Pend!=0)
;;;1919           {
;;;1920               RMP_COVERAGE_MARKER();
;;;1921               RMP_Sched_Pend=0;
;;;1922               _RMP_Yield();   
;;;1923           }
;;;1924           else
;;;1925               RMP_COVERAGE_MARKER();
;;;1926   
;;;1927           /* Finally, return success */
;;;1928           Thread->Retval=0;
;;;1929           Semaphore->Cur_Num--;
;;;1930       }
;;;1931   
;;;1932       return 0;
;;;1933   }
000022  e8bd81f0          POP      {r4-r8,pc}
                  |L46.38|
000026  68e0              LDR      r0,[r4,#0xc]          ;1899
000028  2700              MOVS     r7,#0                 ;1918
00002a  4e14              LDR      r6,|L46.124|
00002c  4408              ADD      r0,r0,r1              ;1899
00002e  e01b              B        |L46.104|
                  |L46.48|
000030  6865              LDR      r5,[r4,#4]            ;1903
000032  e9d50100          LDRD     r0,r1,[r5,#0]         ;1903
000036  6008              STR      r0,[r1,#0]            ;1903
000038  6041              STR      r1,[r0,#4]            ;1903
00003a  7e28              LDRB     r0,[r5,#0x18]         ;1905
00003c  2808              CMP      r0,#8                 ;1905
00003e  d103              BNE      |L46.72|
000040  e9d50102          LDRD     r0,r1,[r5,#8]         ;1905
000044  6008              STR      r0,[r1,#0]            ;1905
000046  6041              STR      r1,[r0,#4]            ;1905
                  |L46.72|
000048  69a8              LDR      r0,[r5,#0x18]         ;1913
00004a  f02000ff          BIC      r0,r0,#0xff           ;1913
00004e  1c40              ADDS     r0,r0,#1              ;1913
000050  61a8              STR      r0,[r5,#0x18]         ;1915
000052  4628              MOV      r0,r5                 ;1915
000054  f7fffffe          BL       _RMP_Set_Rdy
000058  68f0              LDR      r0,[r6,#0xc]          ;1918  ; RMP_Sched_Pend
00005a  b110              CBZ      r0,|L46.98|
00005c  60f7              STR      r7,[r6,#0xc]          ;1921  ; RMP_Sched_Pend
00005e  f7fffffe          BL       _RMP_Yield
                  |L46.98|
000062  63af              STR      r7,[r5,#0x38]         ;1929
000064  68e0              LDR      r0,[r4,#0xc]          ;1929
000066  1e40              SUBS     r0,r0,#1              ;1929
                  |L46.104|
000068  60e0              STR      r0,[r4,#0xc]          ;1899
00006a  6860              LDR      r0,[r4,#4]            ;1901
00006c  42a0              CMP      r0,r4                 ;1901
00006e  d002              BEQ      |L46.118|
000070  68e0              LDR      r0,[r4,#0xc]          ;1901
000072  2800              CMP      r0,#0                 ;1901
000074  d1dc              BNE      |L46.48|
                  |L46.118|
000076  2000              MOVS     r0,#0                 ;1932
000078  e7d3              B        |L46.34|
;;;1934   /* End Function:RMP_Sem_Post_ISR *********************************************/
                          ENDP

00007a  0000              DCW      0x0000
                  |L46.124|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Cancel||, CODE, READONLY, ALIGN=1

                  RMP_Thd_Cancel PROC
;;;1514   ******************************************************************************/
;;;1515   rmp_ret_t RMP_Thd_Cancel(volatile struct RMP_Thd* Thread)
000000  b510              PUSH     {r4,lr}
;;;1516   {
000002  0004              MOVS     r4,r0
000004  d00a              BEQ      |L47.28|
;;;1517       /* Check if this thread structure could possibly be in use */
;;;1518       if(Thread==0)
;;;1519       {
;;;1520           RMP_COVERAGE_MARKER();
;;;1521           return RMP_ERR_THD;
;;;1522       }
;;;1523       else
;;;1524           RMP_COVERAGE_MARKER();
;;;1525       
;;;1526       RMP_Lock_Sched();
000006  f7fffffe          BL       RMP_Lock_Sched
;;;1527       
;;;1528       /* Is it delayed? */
;;;1529       if(RMP_THD_STATE(Thread->State)!=RMP_THD_DELAYED)
00000a  69a0              LDR      r0,[r4,#0x18]
00000c  b2c0              UXTB     r0,r0
00000e  2806              CMP      r0,#6
000010  d007              BEQ      |L47.34|
;;;1530       {
;;;1531           RMP_COVERAGE_MARKER();
;;;1532           RMP_Unlock_Sched();
000012  f7fffffe          BL       RMP_Unlock_Sched
;;;1533           return RMP_ERR_STATE;
000016  f06f0003          MVN      r0,#3
;;;1534       }
;;;1535       else
;;;1536           RMP_COVERAGE_MARKER();
;;;1537   
;;;1538       /* Delete it from the delay list */
;;;1539       RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1540       RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1541       /* Set to running if not suspended */
;;;1542       _RMP_Set_Rdy(Thread);
;;;1543       
;;;1544       Thread->Retval=RMP_ERR_OPER;
;;;1545       RMP_Unlock_Sched();
;;;1546       return 0;
;;;1547   }
00001a  bd10              POP      {r4,pc}
                  |L47.28|
00001c  f04f30ff          MOV      r0,#0xffffffff        ;1521
000020  bd10              POP      {r4,pc}
                  |L47.34|
000022  68a0              LDR      r0,[r4,#8]            ;1539
000024  68e1              LDR      r1,[r4,#0xc]          ;1539
000026  6008              STR      r0,[r1,#0]            ;1539
000028  6041              STR      r1,[r0,#4]            ;1539
00002a  69a0              LDR      r0,[r4,#0x18]         ;1540
00002c  f02000ff          BIC      r0,r0,#0xff           ;1540
000030  1c40              ADDS     r0,r0,#1              ;1540
000032  61a0              STR      r0,[r4,#0x18]         ;1540
000034  4620              MOV      r0,r4                 ;1542
000036  f7fffffe          BL       _RMP_Set_Rdy
00003a  f06f0004          MVN      r0,#4                 ;1544
00003e  63a0              STR      r0,[r4,#0x38]         ;1544
000040  f7fffffe          BL       RMP_Unlock_Sched
000044  2000              MOVS     r0,#0                 ;1546
000046  bd10              POP      {r4,pc}
;;;1548   /* End Function:RMP_Thd_Cancel ***********************************************/
                          ENDP


                          AREA ||i.RMP_Thd_Crt||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Crt PROC
;;;766    ******************************************************************************/
;;;767    rmp_ret_t RMP_Thd_Crt(volatile struct RMP_Thd* Thread, void* Entry, void* Stack, void* Arg, rmp_ptr_t Prio, rmp_ptr_t Slices)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;768    {
000004  4699              MOV      r9,r3
000006  4690              MOV      r8,r2
000008  468a              MOV      r10,r1
00000a  4604              MOV      r4,r0
00000c  e9dd6508          LDRD     r6,r5,[sp,#0x20]
;;;769        /* Check if the priority and timeslice range is correct */
;;;770        if(Prio>=RMP_MAX_PREEMPT_PRIO)
000010  2e20              CMP      r6,#0x20
000012  d303              BCC      |L48.28|
;;;771        {
;;;772            RMP_COVERAGE_MARKER();
;;;773            return RMP_ERR_PRIO;
000014  f06f0001          MVN      r0,#1
                  |L48.24|
;;;774        }
;;;775        else
;;;776            RMP_COVERAGE_MARKER();
;;;777        
;;;778        if((Slices==0)||(Slices>=RMP_MAX_SLICES))
;;;779        {
;;;780            RMP_COVERAGE_MARKER();
;;;781            return RMP_ERR_SLICE;
;;;782        }
;;;783        else
;;;784            RMP_COVERAGE_MARKER();
;;;785        
;;;786        /* Check if this thread structure could possibly be in use */
;;;787        if(Thread==0)
;;;788        {
;;;789            RMP_COVERAGE_MARKER();
;;;790            return RMP_ERR_THD;
;;;791        }
;;;792        else
;;;793            RMP_COVERAGE_MARKER();
;;;794        
;;;795        RMP_Lock_Sched();
;;;796        
;;;797        if(RMP_THD_STATE(Thread->State)!=RMP_THD_FREE)
;;;798        {
;;;799            RMP_COVERAGE_MARKER();
;;;800            RMP_Unlock_Sched();
;;;801            return RMP_ERR_THD;
;;;802        }
;;;803        else
;;;804            RMP_COVERAGE_MARKER();
;;;805        
;;;806        /* Create the thread and insert it into the list */
;;;807        Thread->Prio=Prio;
;;;808        Thread->Slices=Slices;
;;;809        Thread->Slices_Left=Slices;
;;;810        Thread->Stack=(rmp_ptr_t)Stack;
;;;811        
;;;812        /* Initialize its stack and sending list */
;;;813        _RMP_Stack_Init((rmp_ptr_t)Entry, (rmp_ptr_t)Stack, (rmp_ptr_t)Arg);
;;;814        RMP_List_Crt(&(Thread->Snd_List));
;;;815        
;;;816        /* Notify the scheduler that we have created something new, also check locks */
;;;817        Thread->State=RMP_THD_RUNNING;
;;;818        _RMP_Set_Rdy(Thread);
;;;819        
;;;820        RMP_Unlock_Sched();
;;;821    
;;;822        return 0;
;;;823    }
000018  e8bd87f0          POP      {r4-r10,pc}
                  |L48.28|
00001c  b115              CBZ      r5,|L48.36|
00001e  4815              LDR      r0,|L48.116|
000020  4285              CMP      r5,r0                 ;778
000022  d302              BCC      |L48.42|
                  |L48.36|
000024  f06f0002          MVN      r0,#2                 ;781
000028  e7f6              B        |L48.24|
                  |L48.42|
00002a  f04f37ff          MOV      r7,#0xffffffff        ;790
00002e  b13c              CBZ      r4,|L48.64|
000030  f7fffffe          BL       RMP_Lock_Sched
000034  69a0              LDR      r0,[r4,#0x18]         ;797
000036  f0100fff          TST      r0,#0xff              ;797
00003a  d003              BEQ      |L48.68|
00003c  f7fffffe          BL       RMP_Unlock_Sched
                  |L48.64|
000040  4638              MOV      r0,r7                 ;790
000042  e7e9              B        |L48.24|
                  |L48.68|
000044  6266              STR      r6,[r4,#0x24]         ;807
000046  61e5              STR      r5,[r4,#0x1c]         ;808
000048  6225              STR      r5,[r4,#0x20]         ;809
00004a  f8c48034          STR      r8,[r4,#0x34]         ;810
00004e  464a              MOV      r2,r9                 ;813
000050  4641              MOV      r1,r8                 ;813
000052  4650              MOV      r0,r10                ;813
000054  f7fffffe          BL       _RMP_Stack_Init
000058  f1040010          ADD      r0,r4,#0x10           ;814
00005c  6120              STR      r0,[r4,#0x10]         ;814
00005e  6160              STR      r0,[r4,#0x14]         ;814
000060  2001              MOVS     r0,#1                 ;817
000062  61a0              STR      r0,[r4,#0x18]         ;817
000064  4620              MOV      r0,r4                 ;818
000066  f7fffffe          BL       _RMP_Set_Rdy
00006a  f7fffffe          BL       RMP_Unlock_Sched
00006e  2000              MOVS     r0,#0                 ;822
000070  e7d2              B        |L48.24|
;;;824    /* End Function:RMP_Thd_Crt **************************************************/
                          ENDP

000072  0000              DCW      0x0000
                  |L48.116|
                          DCD      0x000186a0

                          AREA ||i.RMP_Thd_Del||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Del PROC
;;;831    ******************************************************************************/
;;;832    rmp_ret_t RMP_Thd_Del(volatile struct RMP_Thd* Thread)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;833    {
000004  0004              MOVS     r4,r0
;;;834        struct RMP_Thd* Release;
;;;835        
;;;836        /* Check if this thread structure could possibly be in use */
;;;837        if(Thread==0)
;;;838        {
;;;839            RMP_COVERAGE_MARKER();
;;;840            return RMP_ERR_THD;
000006  f04f35ff          MOV      r5,#0xffffffff
00000a  d014              BEQ      |L49.54|
;;;841        }
;;;842        else
;;;843            RMP_COVERAGE_MARKER();
;;;844        
;;;845        RMP_Lock_Sched();
00000c  f7fffffe          BL       RMP_Lock_Sched
;;;846        
;;;847        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
000010  69a0              LDR      r0,[r4,#0x18]
;;;848        {
;;;849            RMP_COVERAGE_MARKER();
;;;850            RMP_Unlock_Sched();
;;;851            return RMP_ERR_THD;
;;;852        }
;;;853        else
;;;854            RMP_COVERAGE_MARKER();
;;;855        
;;;856        /* See if anyone waiting to send to this thread. If there is, release all these threads */
;;;857        while(&(Thread->Snd_List)!=Thread->Snd_List.Next)
;;;858        {
;;;859            Release=(struct RMP_Thd*)(Thread->Snd_List.Next);
;;;860            RMP_List_Del(Release->Run_Head.Prev,Release->Run_Head.Next);
;;;861            if(RMP_THD_STATE(Release->State)==RMP_THD_SNDDLY)
;;;862            {
;;;863                RMP_COVERAGE_MARKER();
;;;864                RMP_List_Del(Release->Dly_Head.Prev,Release->Dly_Head.Next);
;;;865            }
;;;866            else
;;;867                RMP_COVERAGE_MARKER();
;;;868            
;;;869            RMP_THD_STATE_SET(Release->State,RMP_THD_RUNNING);
;;;870            /* Set ready if not suspended */
;;;871            _RMP_Set_Rdy(Release);
;;;872            Release->Retval=RMP_ERR_OPER;
000012  1f2f              SUBS     r7,r5,#4
000014  f0100fff          TST      r0,#0xff              ;847
000018  d010              BEQ      |L49.60|
00001a  f1040610          ADD      r6,r4,#0x10           ;857
                  |L49.30|
00001e  6960              LDR      r0,[r4,#0x14]         ;857
000020  42b0              CMP      r0,r6                 ;857
000022  d01c              BEQ      |L49.94|
000024  6965              LDR      r5,[r4,#0x14]         ;859
000026  e9d50100          LDRD     r0,r1,[r5,#0]         ;859
00002a  6008              STR      r0,[r1,#0]            ;859
00002c  6041              STR      r1,[r0,#4]            ;859
00002e  7e28              LDRB     r0,[r5,#0x18]         ;861
000030  2803              CMP      r0,#3                 ;861
000032  d006              BEQ      |L49.66|
000034  e009              B        |L49.74|
                  |L49.54|
000036  4628              MOV      r0,r5                 ;840
                  |L49.56|
;;;873        }
;;;874        
;;;875        /* See what is its state */
;;;876        switch(RMP_THD_STATE(Thread->State))
;;;877        {
;;;878            case RMP_THD_RUNNING:
;;;879            {
;;;880                RMP_COVERAGE_MARKER();
;;;881                /* Clear ready if not suspended */
;;;882                _RMP_Clr_Rdy(Thread);
;;;883                break;
;;;884            }
;;;885            
;;;886            /* Do nothing if it is blocked on receive */
;;;887            case RMP_THD_RCVBLK:
;;;888            {
;;;889                RMP_COVERAGE_MARKER();
;;;890                break;
;;;891            }
;;;892            
;;;893            case RMP_THD_SNDBLK:RMP_COVERAGE_MARKER();
;;;894            case RMP_THD_SEMBLK:
;;;895            {
;;;896                RMP_COVERAGE_MARKER();
;;;897                RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;898                break;
;;;899            }
;;;900            
;;;901            case RMP_THD_SNDDLY:RMP_COVERAGE_MARKER();
;;;902            case RMP_THD_SEMDLY:
;;;903            {
;;;904                RMP_COVERAGE_MARKER();
;;;905                RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;906                /* Fall-through case */
;;;907            }
;;;908            case RMP_THD_RCVDLY:RMP_COVERAGE_MARKER();
;;;909            case RMP_THD_DELAYED:
;;;910            {
;;;911                RMP_COVERAGE_MARKER();
;;;912                RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;913                break;
;;;914            }
;;;915            /* Should not get here */
;;;916            default:while(1);
;;;917        }
;;;918        /* Set return value to failure anyway */
;;;919        Thread->Retval=RMP_ERR_OPER;
;;;920        Thread->State=RMP_THD_FREE;
;;;921        /* If we are deleting ourself, pend a yield */
;;;922        if(Thread==RMP_Cur_Thd)
;;;923        {
;;;924            RMP_COVERAGE_MARKER();
;;;925            RMP_Sched_Pend=1;
;;;926        }
;;;927        else
;;;928            RMP_COVERAGE_MARKER();
;;;929        
;;;930        RMP_Unlock_Sched();
;;;931        
;;;932        /* If we are deleting ourself, just stop the execution here */
;;;933        if(Thread==RMP_Cur_Thd)
;;;934            while(1);
;;;935        else
;;;936            RMP_COVERAGE_MARKER();
;;;937    
;;;938        return 0;
;;;939    }
000038  e8bd81f0          POP      {r4-r8,pc}
                  |L49.60|
00003c  f7fffffe          BL       RMP_Unlock_Sched
000040  e7f9              B        |L49.54|
                  |L49.66|
000042  e9d50102          LDRD     r0,r1,[r5,#8]         ;851
000046  6008              STR      r0,[r1,#0]            ;851
000048  6041              STR      r1,[r0,#4]            ;851
                  |L49.74|
00004a  69a8              LDR      r0,[r5,#0x18]         ;869
00004c  f02000ff          BIC      r0,r0,#0xff           ;869
000050  1c40              ADDS     r0,r0,#1              ;869
000052  61a8              STR      r0,[r5,#0x18]         ;871
000054  4628              MOV      r0,r5                 ;871
000056  f7fffffe          BL       _RMP_Set_Rdy
00005a  63af              STR      r7,[r5,#0x38]         ;872
00005c  e7df              B        |L49.30|
                  |L49.94|
00005e  69a0              LDR      r0,[r4,#0x18]         ;876
000060  b2c0              UXTB     r0,r0                 ;876
000062  2809              CMP      r0,#9                 ;876
000064  d224              BCS      |L49.176|
000066  e8dff000          TBB      [pc,r0]               ;876
00006a  2305              DCB      0x23,0x05
00006c  090c1410          DCB      0x09,0x0c,0x14,0x10
000070  10090c00          DCB      0x10,0x09,0x0c,0x00
000074  4620              MOV      r0,r4                 ;882
000076  f7fffffe          BL       _RMP_Clr_Rdy
00007a  e00a              B        |L49.146|
00007c  6820              LDR      r0,[r4,#0]            ;897
00007e  6861              LDR      r1,[r4,#4]            ;897
000080  e005              B        |L49.142|
000082  6821              LDR      r1,[r4,#0]            ;905
000084  6860              LDR      r0,[r4,#4]            ;905
000086  6001              STR      r1,[r0,#0]            ;905
000088  6048              STR      r0,[r1,#4]            ;905
00008a  68a0              LDR      r0,[r4,#8]            ;912
00008c  68e1              LDR      r1,[r4,#0xc]          ;912
                  |L49.142|
00008e  6008              STR      r0,[r1,#0]            ;912
000090  6041              STR      r1,[r0,#4]            ;912
                  |L49.146|
000092  2000              MOVS     r0,#0                 ;920
000094  63a7              STR      r7,[r4,#0x38]         ;919
000096  4d08              LDR      r5,|L49.184|
000098  61a0              STR      r0,[r4,#0x18]         ;920
00009a  69a8              LDR      r0,[r5,#0x18]         ;922  ; RMP_Cur_Thd
00009c  4284              CMP      r4,r0                 ;922
00009e  d101              BNE      |L49.164|
0000a0  2001              MOVS     r0,#1                 ;925
0000a2  60e8              STR      r0,[r5,#0xc]          ;925  ; RMP_Sched_Pend
                  |L49.164|
0000a4  f7fffffe          BL       RMP_Unlock_Sched
0000a8  69a8              LDR      r0,[r5,#0x18]         ;933  ; RMP_Cur_Thd
0000aa  4284              CMP      r4,r0                 ;933
0000ac  d101              BNE      |L49.178|
                  |L49.174|
0000ae  e7fe              B        |L49.174|
                  |L49.176|
0000b0  e7fe              B        |L49.176|
                  |L49.178|
0000b2  2000              MOVS     r0,#0                 ;938
0000b4  e7c0              B        |L49.56|
;;;940    /* End Function:RMP_Thd_Del **************************************************/
                          ENDP

0000b6  0000              DCW      0x0000
                  |L49.184|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Delay||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Delay PROC
;;;1484   ******************************************************************************/
;;;1485   rmp_ret_t RMP_Thd_Delay(rmp_ptr_t Slices)
000000  b570              PUSH     {r4-r6,lr}
;;;1486   {
000002  0005              MOVS     r5,r0
000004  d002              BEQ      |L50.12|
;;;1487       if((Slices==0)||(Slices>=RMP_MAX_SLICES))
000006  480f              LDR      r0,|L50.68|
000008  4285              CMP      r5,r0
00000a  d302              BCC      |L50.18|
                  |L50.12|
;;;1488       {
;;;1489           RMP_COVERAGE_MARKER();
;;;1490           return RMP_ERR_SLICE;
00000c  f06f0002          MVN      r0,#2
;;;1491       }
;;;1492       else
;;;1493           RMP_COVERAGE_MARKER();
;;;1494       
;;;1495       RMP_Lock_Sched();
;;;1496   
;;;1497       /* We must be running and not suspended so we will be out of running queue */
;;;1498       _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1499       RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_DELAYED);
;;;1500       _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1501   
;;;1502       RMP_Cur_Thd->Retval=0;
;;;1503       RMP_Unlock_Sched();
;;;1504       /* Need to return if successful or not */
;;;1505       return RMP_Cur_Thd->Retval;
;;;1506   }
000010  bd70              POP      {r4-r6,pc}
                  |L50.18|
000012  f7fffffe          BL       RMP_Lock_Sched
000016  4c0c              LDR      r4,|L50.72|
000018  69a0              LDR      r0,[r4,#0x18]         ;1498  ; RMP_Cur_Thd
00001a  f7fffffe          BL       _RMP_Clr_Rdy
00001e  69a0              LDR      r0,[r4,#0x18]         ;1499  ; RMP_Cur_Thd
000020  69a1              LDR      r1,[r4,#0x18]         ;1499  ; RMP_Cur_Thd
000022  6980              LDR      r0,[r0,#0x18]         ;1499
000024  f02000ff          BIC      r0,r0,#0xff           ;1499
000028  1d80              ADDS     r0,r0,#6              ;1499
00002a  6188              STR      r0,[r1,#0x18]         ;1500
00002c  69a0              LDR      r0,[r4,#0x18]         ;1500  ; RMP_Cur_Thd
00002e  4629              MOV      r1,r5                 ;1500
000030  f7fffffe          BL       _RMP_Dly_Ins
000034  69a1              LDR      r1,[r4,#0x18]         ;1502  ; RMP_Cur_Thd
000036  2000              MOVS     r0,#0                 ;1502
000038  6388              STR      r0,[r1,#0x38]         ;1503
00003a  f7fffffe          BL       RMP_Unlock_Sched
00003e  69a0              LDR      r0,[r4,#0x18]         ;1505  ; RMP_Cur_Thd
000040  6b80              LDR      r0,[r0,#0x38]         ;1505
000042  bd70              POP      {r4-r6,pc}
;;;1507   /* End Function:RMP_Thd_Delay ************************************************/
                          ENDP

                  |L50.68|
                          DCD      0x000186a0
                  |L50.72|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Rcv||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Rcv PROC
;;;1367   ******************************************************************************/
;;;1368   rmp_ret_t RMP_Thd_Rcv(rmp_ptr_t* Data, rmp_ptr_t Slices)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1369   {
000004  0006              MOVS     r6,r0
000006  460f              MOV      r7,r1
;;;1370       struct RMP_Thd* Sender;
;;;1371       
;;;1372       if(Data==0)
;;;1373       {
;;;1374           RMP_COVERAGE_MARKER();
;;;1375           return RMP_ERR_OPER;
000008  f06f0804          MVN      r8,#4
00000c  d015              BEQ      |L51.58|
;;;1376       }
;;;1377       else
;;;1378           RMP_COVERAGE_MARKER();
;;;1379       
;;;1380       RMP_Lock_Sched();
00000e  f7fffffe          BL       RMP_Lock_Sched
;;;1381       
;;;1382       /* Is there any other guy waiting on us? If there is, unblock it and set it running */
;;;1383       Sender=0;
;;;1384       if(&(RMP_Cur_Thd->Snd_List)!=RMP_Cur_Thd->Snd_List.Next)
000012  4d35              LDR      r5,|L51.232|
000014  2400              MOVS     r4,#0                 ;1383
000016  69a9              LDR      r1,[r5,#0x18]  ; RMP_Cur_Thd
000018  69a8              LDR      r0,[r5,#0x18]  ; RMP_Cur_Thd
00001a  3010              ADDS     r0,r0,#0x10
00001c  6949              LDR      r1,[r1,#0x14]
00001e  4281              CMP      r1,r0
000020  d01a              BEQ      |L51.88|
;;;1385       {
;;;1386           RMP_COVERAGE_MARKER();
;;;1387           /* Read the data */
;;;1388           Sender=(struct RMP_Thd*)(RMP_Cur_Thd->Snd_List.Next);
000022  69a8              LDR      r0,[r5,#0x18]  ; RMP_Cur_Thd
000024  6944              LDR      r4,[r0,#0x14]
000026  e9d40100          LDRD     r0,r1,[r4,#0]
00002a  6008              STR      r0,[r1,#0]
00002c  6041              STR      r1,[r0,#4]
;;;1389           RMP_List_Del(Sender->Run_Head.Prev,Sender->Run_Head.Next);
;;;1390           *Data=Sender->Data;
00002e  6b20              LDR      r0,[r4,#0x30]
;;;1391           /* Now we unblock it - what state is it in? */
;;;1392           if((RMP_THD_STATE(Sender->State)==RMP_THD_SNDDLY))
000030  6030              STR      r0,[r6,#0]
000032  7e20              LDRB     r0,[r4,#0x18]
000034  2803              CMP      r0,#3
000036  d003              BEQ      |L51.64|
000038  e006              B        |L51.72|
                  |L51.58|
00003a  4640              MOV      r0,r8                 ;1375
                  |L51.60|
;;;1393           {
;;;1394               RMP_COVERAGE_MARKER();
;;;1395               RMP_List_Del(Sender->Dly_Head.Prev,Sender->Dly_Head.Next);
;;;1396           }
;;;1397           else
;;;1398               RMP_COVERAGE_MARKER();
;;;1399           
;;;1400           RMP_THD_STATE_SET(Sender->State,RMP_THD_RUNNING);
;;;1401           /* Set to running if not suspended */
;;;1402           _RMP_Set_Rdy(Sender);
;;;1403       }
;;;1404   
;;;1405       /* Check if there is a value in our mailbox. If yes, we return with that value */
;;;1406       if((RMP_Cur_Thd->State&RMP_THD_MBOXFUL)!=0)
;;;1407       {
;;;1408           RMP_COVERAGE_MARKER();
;;;1409           /* Get the value from mailbox */
;;;1410           *Data=RMP_Cur_Thd->Mailbox;
;;;1411           /* See if we unblocked a sender. If yes, we place the new value into 
;;;1412            * our mailbox and it is still full */
;;;1413           if(Sender!=0)
;;;1414               RMP_Cur_Thd->Mailbox=Sender->Data;
;;;1415           else
;;;1416               RMP_Cur_Thd->State&=~RMP_THD_MBOXFUL;
;;;1417           
;;;1418           RMP_Unlock_Sched();
;;;1419           return 0;
;;;1420       }
;;;1421       else
;;;1422       {
;;;1423           RMP_COVERAGE_MARKER();
;;;1424           
;;;1425           /* Box empty. Do we have somebody waiting? */
;;;1426           if(Sender!=0)
;;;1427           {
;;;1428               RMP_COVERAGE_MARKER();
;;;1429               RMP_Cur_Thd->Mailbox=Sender->Data;
;;;1430               RMP_Unlock_Sched();
;;;1431               return 0;
;;;1432           }
;;;1433           /* No sender waiting on us and box empty, we need to block */
;;;1434           else
;;;1435           {
;;;1436               RMP_COVERAGE_MARKER();
;;;1437               
;;;1438               if(Slices==0)
;;;1439               {
;;;1440                   RMP_COVERAGE_MARKER();
;;;1441                   RMP_Unlock_Sched();
;;;1442                   return RMP_ERR_OPER;
;;;1443               }
;;;1444               else
;;;1445                   RMP_COVERAGE_MARKER();
;;;1446   
;;;1447               /* We must be running and not suspended so we will surely be deleted from queue */
;;;1448               _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1449   
;;;1450               if(Slices<RMP_MAX_SLICES)
;;;1451               {
;;;1452                   RMP_COVERAGE_MARKER();
;;;1453                   _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1454                   RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_RCVDLY);
;;;1455               }
;;;1456               else
;;;1457               {
;;;1458                   RMP_COVERAGE_MARKER();
;;;1459                   RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_RCVBLK);
;;;1460               }
;;;1461               RMP_Unlock_Sched();
;;;1462               
;;;1463               /* Dummy read - to separate the lock & unlock. If the compiler optimizes these two
;;;1464                * functions(inline them) on some architectures sometimes we never block. */
;;;1465               *Data=RMP_Cur_Thd->Mailbox;
;;;1466               
;;;1467               /* We've been unblocked. There must be something in our mbox, or we should have failed */
;;;1468               RMP_Lock_Sched();
;;;1469               *Data=RMP_Cur_Thd->Mailbox;
;;;1470               RMP_Cur_Thd->State&=~RMP_THD_MBOXFUL;
;;;1471           }
;;;1472       }
;;;1473       
;;;1474       RMP_Unlock_Sched();
;;;1475       return RMP_Cur_Thd->Retval;
;;;1476   }
00003c  e8bd81f0          POP      {r4-r8,pc}
                  |L51.64|
000040  e9d40102          LDRD     r0,r1,[r4,#8]
000044  6008              STR      r0,[r1,#0]
000046  6041              STR      r1,[r0,#4]
                  |L51.72|
000048  69a0              LDR      r0,[r4,#0x18]         ;1400
00004a  f02000ff          BIC      r0,r0,#0xff           ;1400
00004e  1c40              ADDS     r0,r0,#1              ;1400
000050  61a0              STR      r0,[r4,#0x18]         ;1402
000052  4620              MOV      r0,r4                 ;1402
000054  f7fffffe          BL       _RMP_Set_Rdy
                  |L51.88|
000058  69a8              LDR      r0,[r5,#0x18]         ;1406  ; RMP_Cur_Thd
00005a  8b00              LDRH     r0,[r0,#0x18]         ;1406
00005c  0580              LSLS     r0,r0,#22             ;1406
00005e  d50d              BPL      |L51.124|
000060  69a8              LDR      r0,[r5,#0x18]         ;1410  ; RMP_Cur_Thd
000062  6ac0              LDR      r0,[r0,#0x2c]         ;1410
000064  6030              STR      r0,[r6,#0]            ;1413
000066  b954              CBNZ     r4,|L51.126|
000068  69a8              LDR      r0,[r5,#0x18]         ;1416  ; RMP_Cur_Thd
00006a  6981              LDR      r1,[r0,#0x18]         ;1416
00006c  f4217100          BIC      r1,r1,#0x200          ;1416
000070  f8c01018          STR.W    r1,[r0,#0x18]         ;1416
                  |L51.116|
000074  f7fffffe          BL       RMP_Unlock_Sched
000078  2000              MOVS     r0,#0                 ;1419
00007a  e7df              B        |L51.60|
                  |L51.124|
00007c  b11c              CBZ      r4,|L51.134|
                  |L51.126|
00007e  69a8              LDR      r0,[r5,#0x18]         ;1429  ; RMP_Cur_Thd
000080  6b21              LDR      r1,[r4,#0x30]         ;1429
000082  62c1              STR      r1,[r0,#0x2c]         ;1431
000084  e7f6              B        |L51.116|
                  |L51.134|
000086  b187              CBZ      r7,|L51.170|
000088  69a8              LDR      r0,[r5,#0x18]         ;1448  ; RMP_Cur_Thd
00008a  f7fffffe          BL       _RMP_Clr_Rdy
00008e  4817              LDR      r0,|L51.236|
000090  4287              CMP      r7,r0                 ;1450
000092  d20d              BCS      |L51.176|
000094  69a8              LDR      r0,[r5,#0x18]         ;1453  ; RMP_Cur_Thd
000096  4639              MOV      r1,r7                 ;1453
000098  f7fffffe          BL       _RMP_Dly_Ins
00009c  69a8              LDR      r0,[r5,#0x18]         ;1454  ; RMP_Cur_Thd
00009e  69a9              LDR      r1,[r5,#0x18]         ;1454  ; RMP_Cur_Thd
0000a0  6980              LDR      r0,[r0,#0x18]         ;1454
0000a2  f02000ff          BIC      r0,r0,#0xff           ;1454
0000a6  1d40              ADDS     r0,r0,#5              ;1454
0000a8  e008              B        |L51.188|
                  |L51.170|
0000aa  f7fffffe          BL       RMP_Unlock_Sched
0000ae  e7c4              B        |L51.58|
                  |L51.176|
0000b0  69a8              LDR      r0,[r5,#0x18]         ;1459  ; RMP_Cur_Thd
0000b2  69a9              LDR      r1,[r5,#0x18]         ;1459  ; RMP_Cur_Thd
0000b4  6980              LDR      r0,[r0,#0x18]         ;1459
0000b6  f02000ff          BIC      r0,r0,#0xff           ;1459
0000ba  1d00              ADDS     r0,r0,#4              ;1459
                  |L51.188|
0000bc  6188              STR      r0,[r1,#0x18]         ;1461
0000be  f7fffffe          BL       RMP_Unlock_Sched
0000c2  69a8              LDR      r0,[r5,#0x18]         ;1465  ; RMP_Cur_Thd
0000c4  6ac0              LDR      r0,[r0,#0x2c]         ;1465
0000c6  6030              STR      r0,[r6,#0]            ;1468
0000c8  f7fffffe          BL       RMP_Lock_Sched
0000cc  69a8              LDR      r0,[r5,#0x18]         ;1469  ; RMP_Cur_Thd
0000ce  6ac0              LDR      r0,[r0,#0x2c]         ;1469
0000d0  6030              STR      r0,[r6,#0]            ;1470
0000d2  69a8              LDR      r0,[r5,#0x18]         ;1470  ; RMP_Cur_Thd
0000d4  6981              LDR      r1,[r0,#0x18]         ;1470
0000d6  f4217100          BIC      r1,r1,#0x200          ;1470
0000da  6181              STR      r1,[r0,#0x18]         ;1474
0000dc  f7fffffe          BL       RMP_Unlock_Sched
0000e0  69a8              LDR      r0,[r5,#0x18]         ;1475  ; RMP_Cur_Thd
0000e2  6b80              LDR      r0,[r0,#0x38]         ;1475
0000e4  e7aa              B        |L51.60|
;;;1477   /* End Function:RMP_Thd_Rcv **************************************************/
                          ENDP

0000e6  0000              DCW      0x0000
                  |L51.232|
                          DCD      ||.data||
                  |L51.236|
                          DCD      0x000186a0

                          AREA ||i.RMP_Thd_Resume||, CODE, READONLY, ALIGN=1

                  RMP_Thd_Resume PROC
;;;1111   ******************************************************************************/
;;;1112   rmp_ret_t RMP_Thd_Resume(volatile struct RMP_Thd* Thread)
000000  b570              PUSH     {r4-r6,lr}
;;;1113   {
000002  0004              MOVS     r4,r0
;;;1114       rmp_ret_t Retval;
;;;1115       
;;;1116       /* Check if this thread structure could possibly be in use */
;;;1117       if(Thread==0)
;;;1118       {
;;;1119           RMP_COVERAGE_MARKER();
;;;1120           return RMP_ERR_THD;
000004  f04f35ff          MOV      r5,#0xffffffff
000008  d011              BEQ      |L52.46|
;;;1121       }
;;;1122       else
;;;1123           RMP_COVERAGE_MARKER();
;;;1124   
;;;1125       RMP_Lock_Sched();
00000a  f7fffffe          BL       RMP_Lock_Sched
;;;1126       
;;;1127       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
00000e  69a0              LDR      r0,[r4,#0x18]
000010  f0100fff          TST      r0,#0xff
000014  d00d              BEQ      |L52.50|
;;;1128       {
;;;1129           RMP_COVERAGE_MARKER();
;;;1130           RMP_Unlock_Sched();
;;;1131           return RMP_ERR_THD;
;;;1132       }
;;;1133       else
;;;1134           RMP_COVERAGE_MARKER();
;;;1135       
;;;1136       /* Check if the thread is suspended, if not, then throw an error */
;;;1137       if((Thread->State&RMP_THD_SUSPENDED)!=0)
000016  69a0              LDR      r0,[r4,#0x18]
000018  05c0              LSLS     r0,r0,#23
00001a  d512              BPL      |L52.66|
;;;1138       {
;;;1139           RMP_COVERAGE_MARKER();
;;;1140           
;;;1141           /* Suspended */
;;;1142           Thread->State&=~RMP_THD_SUSPENDED;
00001c  69a0              LDR      r0,[r4,#0x18]
00001e  f4207080          BIC      r0,r0,#0x100
000022  61a0              STR      r0,[r4,#0x18]
;;;1143           /* Only when it is running will we put it back. It can't be suspended here, 
;;;1144            * so the set ready operation will surely put it back */
;;;1145           if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
000024  69a0              LDR      r0,[r4,#0x18]
000026  b2c0              UXTB     r0,r0
000028  2801              CMP      r0,#1
00002a  d005              BEQ      |L52.56|
00002c  e007              B        |L52.62|
                  |L52.46|
00002e  4628              MOV      r0,r5                 ;1120
;;;1146           {
;;;1147               RMP_COVERAGE_MARKER();
;;;1148               _RMP_Set_Rdy(Thread);
;;;1149           }
;;;1150           else
;;;1151               RMP_COVERAGE_MARKER();
;;;1152           
;;;1153           Retval=0;
;;;1154       }
;;;1155       else
;;;1156       {
;;;1157           RMP_COVERAGE_MARKER();
;;;1158           Retval=RMP_ERR_STATE;
;;;1159       }
;;;1160       
;;;1161       RMP_Unlock_Sched();
;;;1162   
;;;1163       return Retval;
;;;1164   }
000030  bd70              POP      {r4-r6,pc}
                  |L52.50|
000032  f7fffffe          BL       RMP_Unlock_Sched
000036  e7fa              B        |L52.46|
                  |L52.56|
000038  4620              MOV      r0,r4                 ;1148
00003a  f7fffffe          BL       _RMP_Set_Rdy
                  |L52.62|
00003e  2400              MOVS     r4,#0                 ;1153
000040  e001              B        |L52.70|
                  |L52.66|
000042  f06f0403          MVN      r4,#3                 ;1158
                  |L52.70|
000046  f7fffffe          BL       RMP_Unlock_Sched
00004a  4620              MOV      r0,r4                 ;1163
00004c  bd70              POP      {r4-r6,pc}
;;;1165   /* End Function:RMP_Thd_Resume ***********************************************/
                          ENDP


                          AREA ||i.RMP_Thd_Set||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Set PROC
;;;951    ******************************************************************************/
;;;952    rmp_ret_t RMP_Thd_Set(volatile struct RMP_Thd* Thread, rmp_ptr_t Prio, rmp_ptr_t Slices)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;953    {
000004  0015              MOVS     r5,r2
000006  460e              MOV      r6,r1
000008  4604              MOV      r4,r0
00000a  d018              BEQ      |L53.62|
;;;954        /* Check if the priority and timeslice range is correct */
;;;955        if(Slices==0)
;;;956        {
;;;957            RMP_COVERAGE_MARKER();
;;;958            return RMP_ERR_SLICE;
;;;959        }
;;;960        else
;;;961            RMP_COVERAGE_MARKER();
;;;962        
;;;963        /* Check if this thread structure could possibly be in use */
;;;964        if(Thread==0)
;;;965        {
;;;966            RMP_COVERAGE_MARKER();
;;;967            return RMP_ERR_THD;
00000c  f04f37ff          MOV      r7,#0xffffffff
000010  b1c4              CBZ      r4,|L53.68|
;;;968        }
;;;969        else
;;;970            RMP_COVERAGE_MARKER();
;;;971        
;;;972        RMP_Lock_Sched();
000012  f7fffffe          BL       RMP_Lock_Sched
;;;973        
;;;974        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
000016  69a0              LDR      r0,[r4,#0x18]
000018  f0100fff          TST      r0,#0xff
00001c  d014              BEQ      |L53.72|
;;;975        {
;;;976            RMP_COVERAGE_MARKER();
;;;977            RMP_Unlock_Sched();
;;;978            return RMP_ERR_THD;
;;;979        }
;;;980        else
;;;981            RMP_COVERAGE_MARKER();
;;;982        
;;;983        /* See if the thread is in running state */
;;;984        if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
00001e  69a0              LDR      r0,[r4,#0x18]
;;;985        {
;;;986            RMP_COVERAGE_MARKER();
;;;987            
;;;988            /* See if we are gonna change one of it or both */
;;;989            if(Prio<RMP_MAX_PREEMPT_PRIO)
;;;990            {
;;;991                RMP_COVERAGE_MARKER();
;;;992                if(Thread->Prio!=Prio)
;;;993                {
;;;994                    RMP_COVERAGE_MARKER();
;;;995                    /* It doesn't matter whether this is suspended or not. 
;;;996                     * If suspended, the operations will not be conducted. */
;;;997                    _RMP_Clr_Rdy(Thread);
;;;998                    Thread->Prio=Prio;
;;;999                    _RMP_Set_Rdy(Thread);
;;;1000               }
;;;1001               else
;;;1002                   RMP_COVERAGE_MARKER();
;;;1003           }
;;;1004           else
;;;1005               RMP_COVERAGE_MARKER();
;;;1006           
;;;1007           if(Slices<RMP_MAX_SLICES)
000020  4f11              LDR      r7,|L53.104|
000022  b2c0              UXTB     r0,r0                 ;984
000024  2801              CMP      r0,#1                 ;984
000026  d012              BEQ      |L53.78|
;;;1008           {
;;;1009               RMP_COVERAGE_MARKER();
;;;1010               Thread->Slices=Slices;
;;;1011           }
;;;1012           else
;;;1013               RMP_COVERAGE_MARKER();
;;;1014       }
;;;1015       else
;;;1016       {
;;;1017           RMP_COVERAGE_MARKER();
;;;1018           
;;;1019           if(Prio<RMP_MAX_PREEMPT_PRIO)
000028  2e20              CMP      r6,#0x20
00002a  d200              BCS      |L53.46|
;;;1020           {
;;;1021               RMP_COVERAGE_MARKER();
;;;1022               Thread->Prio=Prio;
00002c  6266              STR      r6,[r4,#0x24]
                  |L53.46|
;;;1023           }
;;;1024           else
;;;1025               RMP_COVERAGE_MARKER();
;;;1026           
;;;1027           if(Slices<RMP_MAX_SLICES)
00002e  42bd              CMP      r5,r7
000030  d200              BCS      |L53.52|
;;;1028           {
;;;1029               RMP_COVERAGE_MARKER();
;;;1030               Thread->Slices=Slices;
000032  61e5              STR      r5,[r4,#0x1c]
                  |L53.52|
;;;1031           }
;;;1032           else
;;;1033               RMP_COVERAGE_MARKER();
;;;1034       }
;;;1035       
;;;1036       RMP_Unlock_Sched();
000034  f7fffffe          BL       RMP_Unlock_Sched
;;;1037       return 0;
000038  2000              MOVS     r0,#0
                  |L53.58|
;;;1038   }
00003a  e8bd81f0          POP      {r4-r8,pc}
                  |L53.62|
00003e  f06f0002          MVN      r0,#2                 ;958
000042  e7fa              B        |L53.58|
                  |L53.68|
000044  4638              MOV      r0,r7                 ;967
000046  e7f8              B        |L53.58|
                  |L53.72|
000048  f7fffffe          BL       RMP_Unlock_Sched
00004c  e7fa              B        |L53.68|
                  |L53.78|
00004e  2e20              CMP      r6,#0x20              ;989
000050  d2ed              BCS      |L53.46|
000052  6a60              LDR      r0,[r4,#0x24]         ;992
000054  42b0              CMP      r0,r6                 ;992
000056  d0ea              BEQ      |L53.46|
000058  4620              MOV      r0,r4                 ;997
00005a  f7fffffe          BL       _RMP_Clr_Rdy
00005e  6266              STR      r6,[r4,#0x24]         ;998
000060  4620              MOV      r0,r4                 ;999
000062  f7fffffe          BL       _RMP_Set_Rdy
000066  e7e2              B        |L53.46|
;;;1039   /* End Function:RMP_Thd_Set **************************************************/
                          ENDP

                  |L53.104|
                          DCD      0x000186a0

                          AREA ||i.RMP_Thd_Snd||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Snd PROC
;;;1175   ******************************************************************************/
;;;1176   rmp_ret_t RMP_Thd_Snd(volatile struct RMP_Thd* Thread, rmp_ptr_t Data, rmp_ptr_t Slices)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1177   {
000004  0004              MOVS     r4,r0
000006  4616              MOV      r6,r2
000008  460f              MOV      r7,r1
;;;1178       /* Check if this thread structure could possibly be in use */
;;;1179       if(Thread==0)
;;;1180       {
;;;1181           RMP_COVERAGE_MARKER();
;;;1182           return RMP_ERR_THD;
00000a  f04f35ff          MOV      r5,#0xffffffff
00000e  d029              BEQ      |L54.100|
;;;1183       }
;;;1184       else
;;;1185           RMP_COVERAGE_MARKER();
;;;1186       
;;;1187       RMP_Lock_Sched();
000010  f7fffffe          BL       RMP_Lock_Sched
;;;1188       
;;;1189       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
000014  69a0              LDR      r0,[r4,#0x18]
000016  f0100fff          TST      r0,#0xff
00001a  d026              BEQ      |L54.106|
;;;1190       {
;;;1191           RMP_COVERAGE_MARKER();
;;;1192           RMP_Unlock_Sched();
;;;1193           return RMP_ERR_THD;
;;;1194       }
;;;1195       else
;;;1196           RMP_COVERAGE_MARKER();
;;;1197       
;;;1198       /* Are we sending to ourself? This is not allowed */
;;;1199       if(RMP_Cur_Thd==Thread)
00001c  4d2c              LDR      r5,|L54.208|
;;;1200       {
;;;1201           RMP_COVERAGE_MARKER();
;;;1202           RMP_Unlock_Sched();
;;;1203           return RMP_ERR_OPER;
00001e  f06f0804          MVN      r8,#4
000022  69a8              LDR      r0,[r5,#0x18]         ;1199  ; RMP_Cur_Thd
000024  42a0              CMP      r0,r4                 ;1199
000026  d023              BEQ      |L54.112|
;;;1204       }
;;;1205       else
;;;1206           RMP_COVERAGE_MARKER();
;;;1207       
;;;1208       RMP_Cur_Thd->Retval=0;
000028  69a9              LDR      r1,[r5,#0x18]  ; RMP_Cur_Thd
00002a  2000              MOVS     r0,#0
;;;1209   
;;;1210       /* See if there is already a value in the mailbox, if yes, we block */
;;;1211       if((Thread->State&RMP_THD_MBOXFUL)!=0)
00002c  6388              STR      r0,[r1,#0x38]
00002e  69a0              LDR      r0,[r4,#0x18]
000030  0580              LSLS     r0,r0,#22
000032  d52b              BPL      |L54.140|
;;;1212       {
;;;1213           RMP_COVERAGE_MARKER();
;;;1214           
;;;1215           /* Mailbox full, we block, and put ourself into the queue */
;;;1216           if(Slices==0)
000034  b1e6              CBZ      r6,|L54.112|
;;;1217           {
;;;1218               RMP_COVERAGE_MARKER();
;;;1219               RMP_Unlock_Sched();
;;;1220               return RMP_ERR_OPER;
;;;1221           }
;;;1222           else
;;;1223               RMP_COVERAGE_MARKER();
;;;1224   
;;;1225           /* We must be running */
;;;1226           _RMP_Clr_Rdy(RMP_Cur_Thd);
000036  69a8              LDR      r0,[r5,#0x18]  ; RMP_Cur_Thd
000038  f7fffffe          BL       _RMP_Clr_Rdy
;;;1227           RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),Thread->Snd_List.Prev,&(Thread->Snd_List));
00003c  6921              LDR      r1,[r4,#0x10]
00003e  f1040210          ADD      r2,r4,#0x10
000042  69a8              LDR      r0,[r5,#0x18]  ; RMP_Cur_Thd
000044  f7fffffe          BL       RMP_List_Ins
;;;1228   
;;;1229           if(Slices<RMP_MAX_SLICES)
000048  4822              LDR      r0,|L54.212|
00004a  4286              CMP      r6,r0
00004c  d214              BCS      |L54.120|
;;;1230           {
;;;1231               RMP_COVERAGE_MARKER();
;;;1232               _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
00004e  69a8              LDR      r0,[r5,#0x18]  ; RMP_Cur_Thd
000050  4631              MOV      r1,r6
000052  f7fffffe          BL       _RMP_Dly_Ins
;;;1233               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SNDDLY);
000056  69a8              LDR      r0,[r5,#0x18]  ; RMP_Cur_Thd
000058  69a9              LDR      r1,[r5,#0x18]  ; RMP_Cur_Thd
00005a  6980              LDR      r0,[r0,#0x18]
00005c  f02000ff          BIC      r0,r0,#0xff
000060  1cc0              ADDS     r0,r0,#3
000062  e00f              B        |L54.132|
                  |L54.100|
000064  4628              MOV      r0,r5                 ;1182
                  |L54.102|
;;;1234           }
;;;1235           else
;;;1236           {
;;;1237               RMP_COVERAGE_MARKER();
;;;1238               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SNDBLK);
;;;1239           }
;;;1240   
;;;1241           RMP_Cur_Thd->Data=Data;
;;;1242       }
;;;1243       else
;;;1244       {
;;;1245           RMP_COVERAGE_MARKER();
;;;1246           
;;;1247           /* Mailbox not full. We need to check if the receiver is waiting for us */
;;;1248           if((RMP_THD_STATE(Thread->State)==RMP_THD_RCVBLK)||
;;;1249              (RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY))
;;;1250           {
;;;1251               RMP_COVERAGE_MARKER();
;;;1252               
;;;1253               /* The receiver is blocked, wake it up and return the value */
;;;1254               if(RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY)
;;;1255               {
;;;1256                   RMP_COVERAGE_MARKER();
;;;1257                   RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1258               }
;;;1259               else
;;;1260                   RMP_COVERAGE_MARKER();
;;;1261               
;;;1262               RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1263               /* Set to running if not suspended */
;;;1264               _RMP_Set_Rdy(Thread);
;;;1265           }
;;;1266           else
;;;1267               RMP_COVERAGE_MARKER();
;;;1268           
;;;1269           /* Set the mailbox */
;;;1270           Thread->Mailbox=Data;
;;;1271           Thread->State|=RMP_THD_MBOXFUL;
;;;1272       }
;;;1273       
;;;1274       RMP_Unlock_Sched();
;;;1275   
;;;1276       return RMP_Cur_Thd->Retval;
;;;1277   }
000066  e8bd81f0          POP      {r4-r8,pc}
                  |L54.106|
00006a  f7fffffe          BL       RMP_Unlock_Sched
00006e  e7f9              B        |L54.100|
                  |L54.112|
000070  f7fffffe          BL       RMP_Unlock_Sched
000074  4640              MOV      r0,r8                 ;1220
000076  e7f6              B        |L54.102|
                  |L54.120|
000078  69a8              LDR      r0,[r5,#0x18]         ;1238  ; RMP_Cur_Thd
00007a  69a9              LDR      r1,[r5,#0x18]         ;1238  ; RMP_Cur_Thd
00007c  6980              LDR      r0,[r0,#0x18]         ;1238
00007e  f02000ff          BIC      r0,r0,#0xff           ;1238
000082  1c80              ADDS     r0,r0,#2              ;1238
                  |L54.132|
000084  6188              STR      r0,[r1,#0x18]         ;1241
000086  69a8              LDR      r0,[r5,#0x18]         ;1241  ; RMP_Cur_Thd
000088  6307              STR      r7,[r0,#0x30]         ;1241
00008a  e01c              B        |L54.198|
                  |L54.140|
00008c  69a0              LDR      r0,[r4,#0x18]         ;1248
00008e  b2c0              UXTB     r0,r0                 ;1248
000090  2804              CMP      r0,#4                 ;1248
000092  d003              BEQ      |L54.156|
000094  69a0              LDR      r0,[r4,#0x18]         ;1249
000096  b2c0              UXTB     r0,r0                 ;1249
000098  2805              CMP      r0,#5                 ;1249
00009a  d10f              BNE      |L54.188|
                  |L54.156|
00009c  69a0              LDR      r0,[r4,#0x18]         ;1254
00009e  b2c0              UXTB     r0,r0                 ;1254
0000a0  2805              CMP      r0,#5                 ;1254
0000a2  d103              BNE      |L54.172|
0000a4  68a0              LDR      r0,[r4,#8]            ;1257
0000a6  68e1              LDR      r1,[r4,#0xc]          ;1257
0000a8  6008              STR      r0,[r1,#0]            ;1257
0000aa  6041              STR      r1,[r0,#4]            ;1257
                  |L54.172|
0000ac  69a0              LDR      r0,[r4,#0x18]         ;1262
0000ae  f02000ff          BIC      r0,r0,#0xff           ;1262
0000b2  1c40              ADDS     r0,r0,#1              ;1262
0000b4  61a0              STR      r0,[r4,#0x18]         ;1262
0000b6  4620              MOV      r0,r4                 ;1264
0000b8  f7fffffe          BL       _RMP_Set_Rdy
                  |L54.188|
0000bc  62e7              STR      r7,[r4,#0x2c]         ;1270
0000be  69a0              LDR      r0,[r4,#0x18]         ;1271
0000c0  f4407000          ORR      r0,r0,#0x200          ;1271
0000c4  61a0              STR      r0,[r4,#0x18]         ;1271
                  |L54.198|
0000c6  f7fffffe          BL       RMP_Unlock_Sched
0000ca  69a8              LDR      r0,[r5,#0x18]         ;1276  ; RMP_Cur_Thd
0000cc  6b80              LDR      r0,[r0,#0x38]         ;1276
0000ce  e7ca              B        |L54.102|
;;;1278   /* End Function:RMP_Thd_Snd **************************************************/
                          ENDP

                  |L54.208|
                          DCD      ||.data||
                  |L54.212|
                          DCD      0x000186a0

                          AREA ||i.RMP_Thd_Snd_ISR||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Snd_ISR PROC
;;;1290   ******************************************************************************/
;;;1291   rmp_ret_t RMP_Thd_Snd_ISR(volatile struct RMP_Thd* Thread, rmp_ptr_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;1292   {
000002  0004              MOVS     r4,r0
000004  460d              MOV      r5,r1
;;;1293       /* Check if this thread structure could possibly be in use */
;;;1294       if(Thread==0)
;;;1295       {
;;;1296           RMP_COVERAGE_MARKER();
;;;1297           return RMP_ERR_THD;
000006  f04f30ff          MOV      r0,#0xffffffff
00000a  d008              BEQ      |L55.30|
;;;1298       }
;;;1299       else
;;;1300           RMP_COVERAGE_MARKER();
;;;1301       
;;;1302       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
00000c  69a1              LDR      r1,[r4,#0x18]
00000e  f0110fff          TST      r1,#0xff
000012  d004              BEQ      |L55.30|
;;;1303       {
;;;1304           RMP_COVERAGE_MARKER();
;;;1305           return RMP_ERR_THD;
;;;1306       }
;;;1307       else
;;;1308           RMP_COVERAGE_MARKER();
;;;1309   
;;;1310       /* See if there is already a value in the mailbox, if yes, we abort */
;;;1311       if((Thread->State&RMP_THD_MBOXFUL)!=0)
000014  69a0              LDR      r0,[r4,#0x18]
000016  0580              LSLS     r0,r0,#22
000018  d502              BPL      |L55.32|
;;;1312       {
;;;1313           RMP_COVERAGE_MARKER();
;;;1314           return RMP_ERR_OPER;
00001a  f06f0004          MVN      r0,#4
                  |L55.30|
;;;1315       }
;;;1316       else
;;;1317       {
;;;1318           RMP_COVERAGE_MARKER();
;;;1319           
;;;1320           /* Mailbox not full. We need to check if the receiver is waiting for us */
;;;1321           if((RMP_THD_STATE(Thread->State)==RMP_THD_RCVBLK)||
;;;1322              (RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY))
;;;1323           {
;;;1324               RMP_COVERAGE_MARKER();
;;;1325   
;;;1326               /* The receiver is blocked, wake it up and return the value */
;;;1327               if(RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY)
;;;1328               {
;;;1329                   RMP_COVERAGE_MARKER();
;;;1330                   RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1331               }
;;;1332               else
;;;1333                   RMP_COVERAGE_MARKER();
;;;1334               
;;;1335               RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1336   
;;;1337               /* Set to running if not suspended */
;;;1338               _RMP_Set_Rdy(Thread);
;;;1339   
;;;1340               /* If schedule pending, trigger it now because we are in ISR */
;;;1341               if(RMP_Sched_Pend!=0)
;;;1342               {
;;;1343                   RMP_COVERAGE_MARKER();
;;;1344                   RMP_Sched_Pend=0;
;;;1345                   _RMP_Yield();
;;;1346               }
;;;1347               else
;;;1348                   RMP_COVERAGE_MARKER();
;;;1349           }
;;;1350           else
;;;1351               RMP_COVERAGE_MARKER();
;;;1352           
;;;1353           /* Set the mailbox */
;;;1354           Thread->Mailbox=Data;
;;;1355           Thread->State|=RMP_THD_MBOXFUL;
;;;1356       }
;;;1357   
;;;1358       return 0;
;;;1359   }
00001e  bd70              POP      {r4-r6,pc}
                  |L55.32|
000020  69a0              LDR      r0,[r4,#0x18]         ;1321
000022  b2c0              UXTB     r0,r0                 ;1321
000024  2804              CMP      r0,#4                 ;1321
000026  d003              BEQ      |L55.48|
000028  69a0              LDR      r0,[r4,#0x18]         ;1322
00002a  b2c0              UXTB     r0,r0                 ;1322
00002c  2805              CMP      r0,#5                 ;1322
00002e  d116              BNE      |L55.94|
                  |L55.48|
000030  69a0              LDR      r0,[r4,#0x18]         ;1327
000032  b2c0              UXTB     r0,r0                 ;1327
000034  2805              CMP      r0,#5                 ;1327
000036  d103              BNE      |L55.64|
000038  68a2              LDR      r2,[r4,#8]            ;1330
00003a  68e0              LDR      r0,[r4,#0xc]          ;1330
00003c  6002              STR      r2,[r0,#0]            ;1330
00003e  6050              STR      r0,[r2,#4]            ;1330
                  |L55.64|
000040  69a0              LDR      r0,[r4,#0x18]         ;1335
000042  f02000ff          BIC      r0,r0,#0xff           ;1335
000046  1c40              ADDS     r0,r0,#1              ;1335
000048  61a0              STR      r0,[r4,#0x18]         ;1335
00004a  4620              MOV      r0,r4                 ;1338
00004c  f7fffffe          BL       _RMP_Set_Rdy
000050  4806              LDR      r0,|L55.108|
000052  68c1              LDR      r1,[r0,#0xc]          ;1341  ; RMP_Sched_Pend
000054  b119              CBZ      r1,|L55.94|
000056  2100              MOVS     r1,#0                 ;1344
000058  60c1              STR      r1,[r0,#0xc]          ;1344  ; RMP_Sched_Pend
00005a  f7fffffe          BL       _RMP_Yield
                  |L55.94|
00005e  62e5              STR      r5,[r4,#0x2c]         ;1354
000060  69a0              LDR      r0,[r4,#0x18]         ;1355
000062  f4407000          ORR      r0,r0,#0x200          ;1355
000066  61a0              STR      r0,[r4,#0x18]         ;1355
000068  2000              MOVS     r0,#0                 ;1358
00006a  bd70              POP      {r4-r6,pc}
;;;1360   /* End Function:RMP_Thd_Snd_ISR **********************************************/
                          ENDP

                  |L55.108|
                          DCD      ||.data||

                          AREA ||i.RMP_Thd_Suspend||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Suspend PROC
;;;1046   ******************************************************************************/
;;;1047   rmp_ret_t RMP_Thd_Suspend(volatile struct RMP_Thd* Thread)
000000  b570              PUSH     {r4-r6,lr}
;;;1048   {
000002  0004              MOVS     r4,r0
;;;1049       /* Check if this thread structure could possibly be in use */
;;;1050       if(Thread==0)
;;;1051       {
;;;1052           RMP_COVERAGE_MARKER();
;;;1053           return RMP_ERR_THD;
000004  f04f35ff          MOV      r5,#0xffffffff
000008  d00c              BEQ      |L56.36|
;;;1054       }
;;;1055       else
;;;1056           RMP_COVERAGE_MARKER();
;;;1057       
;;;1058       RMP_Lock_Sched();
00000a  f7fffffe          BL       RMP_Lock_Sched
;;;1059       
;;;1060       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
00000e  69a0              LDR      r0,[r4,#0x18]
000010  f0100fff          TST      r0,#0xff
000014  d008              BEQ      |L56.40|
;;;1061       {
;;;1062           RMP_COVERAGE_MARKER();
;;;1063           RMP_Unlock_Sched();
;;;1064           return RMP_ERR_THD;
;;;1065       }
;;;1066       else
;;;1067           RMP_COVERAGE_MARKER();
;;;1068       
;;;1069       /* Suspend it */
;;;1070       if((Thread->State&RMP_THD_SUSPENDED)!=0)
000016  69a0              LDR      r0,[r4,#0x18]
000018  05c0              LSLS     r0,r0,#23
00001a  d508              BPL      |L56.46|
;;;1071       {
;;;1072           RMP_COVERAGE_MARKER();
;;;1073           RMP_Unlock_Sched();
00001c  f7fffffe          BL       RMP_Unlock_Sched
;;;1074           return RMP_ERR_STATE;
000020  00a8              LSLS     r0,r5,#2
;;;1075       }
;;;1076       else
;;;1077           RMP_COVERAGE_MARKER();
;;;1078       
;;;1079       /* Only when it is running do we clear this. If we are clearing this, it is not
;;;1080        * suspended, so trhe running queue removal is guaranteed to succceed */
;;;1081       if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
;;;1082       {
;;;1083           RMP_COVERAGE_MARKER();
;;;1084           _RMP_Clr_Rdy(Thread);
;;;1085       }
;;;1086       else
;;;1087           RMP_COVERAGE_MARKER();
;;;1088       
;;;1089       /* Mark this as suspended */
;;;1090       Thread->State|=RMP_THD_SUSPENDED;
;;;1091       
;;;1092       /* If we are suspending ourself, pend a yield */
;;;1093       if(Thread==RMP_Cur_Thd)
;;;1094       {
;;;1095           RMP_COVERAGE_MARKER();
;;;1096           RMP_Sched_Pend=1;
;;;1097       }
;;;1098       else
;;;1099           RMP_COVERAGE_MARKER();
;;;1100       
;;;1101       RMP_Unlock_Sched();
;;;1102       return 0;
;;;1103   }
000022  bd70              POP      {r4-r6,pc}
                  |L56.36|
000024  4628              MOV      r0,r5                 ;1053
000026  bd70              POP      {r4-r6,pc}
                  |L56.40|
000028  f7fffffe          BL       RMP_Unlock_Sched
00002c  e7fa              B        |L56.36|
                  |L56.46|
00002e  69a0              LDR      r0,[r4,#0x18]         ;1081
000030  b2c0              UXTB     r0,r0                 ;1081
000032  2801              CMP      r0,#1                 ;1081
000034  d102              BNE      |L56.60|
000036  4620              MOV      r0,r4                 ;1084
000038  f7fffffe          BL       _RMP_Clr_Rdy
                  |L56.60|
00003c  69a1              LDR      r1,[r4,#0x18]         ;1090
00003e  4806              LDR      r0,|L56.88|
000040  f4417180          ORR      r1,r1,#0x100          ;1090
000044  61a1              STR      r1,[r4,#0x18]         ;1090
000046  6981              LDR      r1,[r0,#0x18]         ;1093  ; RMP_Cur_Thd
000048  428c              CMP      r4,r1                 ;1093
00004a  d101              BNE      |L56.80|
00004c  2101              MOVS     r1,#1                 ;1096
00004e  60c1              STR      r1,[r0,#0xc]          ;1096  ; RMP_Sched_Pend
                  |L56.80|
000050  f7fffffe          BL       RMP_Unlock_Sched
000054  2000              MOVS     r0,#0                 ;1102
000056  bd70              POP      {r4-r6,pc}
;;;1104   /* End Function:RMP_Thd_Suspend **********************************************/
                          ENDP

                  |L56.88|
                          DCD      ||.data||

                          AREA ||i.RMP_Unlock_Sched||, CODE, READONLY, ALIGN=2

                  RMP_Unlock_Sched PROC
;;;375    ******************************************************************************/
;;;376    void RMP_Unlock_Sched(void)
000000  490c              LDR      r1,|L57.52|
;;;377    {
000002  b510              PUSH     {r4,lr}
;;;378        if(RMP_Sched_Lock_Cnt==1)
000004  6848              LDR      r0,[r1,#4]  ; RMP_Sched_Lock_Cnt
000006  2801              CMP      r0,#1
000008  d006              BEQ      |L57.24|
;;;379        {
;;;380            RMP_COVERAGE_MARKER();
;;;381            /* Clear the count before enabling */
;;;382            RMP_Sched_Lock_Cnt=0;
;;;383            RMP_Sched_Locked=0;
;;;384            /* Now see if the scheduler scheduling action is pended in the lock-unlock 
;;;385             * period. If yes, perform a schedule now */
;;;386            if(RMP_Sched_Pend!=0)
;;;387            {
;;;388                RMP_COVERAGE_MARKER();
;;;389                /* Reset the count and trigger the context switch */
;;;390                RMP_Sched_Pend=0;
;;;391                _RMP_Yield();
;;;392            }
;;;393            else
;;;394                RMP_COVERAGE_MARKER();
;;;395            
;;;396            RMP_UNMASK_INT();
;;;397        }
;;;398        else if(RMP_Sched_Lock_Cnt>1)
00000a  6848              LDR      r0,[r1,#4]  ; RMP_Sched_Lock_Cnt
00000c  2801              CMP      r0,#1
00000e  d910              BLS      |L57.50|
;;;399        {
;;;400            RMP_COVERAGE_MARKER();
;;;401            RMP_Sched_Lock_Cnt--;
000010  6848              LDR      r0,[r1,#4]  ; RMP_Sched_Lock_Cnt
000012  1e40              SUBS     r0,r0,#1
000014  6048              STR      r0,[r1,#4]  ; RMP_Sched_Lock_Cnt
;;;402        }
;;;403        /* Trying to unlock a scheduler that is not locked - should never happen */
;;;404        else
;;;405            while(1);
;;;406    }
000016  bd10              POP      {r4,pc}
                  |L57.24|
000018  2000              MOVS     r0,#0                 ;382
00001a  6048              STR      r0,[r1,#4]            ;382  ; RMP_Sched_Lock_Cnt
00001c  6088              STR      r0,[r1,#8]            ;383  ; RMP_Sched_Locked
00001e  68ca              LDR      r2,[r1,#0xc]          ;386  ; RMP_Sched_Pend
000020  b112              CBZ      r2,|L57.40|
000022  60c8              STR      r0,[r1,#0xc]          ;390  ; RMP_Sched_Pend
000024  f7fffffe          BL       _RMP_Yield
                  |L57.40|
000028  e8bd4010          POP      {r4,lr}               ;396
00002c  2000              MOVS     r0,#0                 ;396
00002e  f7ffbffe          B.W      RMP_Mask_Int
                  |L57.50|
000032  e7fe              B        |L57.50|
;;;407    /* End Function:RMP_Unlock_Sched *********************************************/
                          ENDP

                  |L57.52|
                          DCD      ||.data||

                          AREA ||i.RMP_Yield||, CODE, READONLY, ALIGN=2

                  RMP_Yield PROC
;;;414    ******************************************************************************/
;;;415    void RMP_Yield(void)
000000  4803              LDR      r0,|L58.16|
;;;416    {
;;;417        if(RMP_Sched_Locked==0)
000002  6881              LDR      r1,[r0,#8]  ; RMP_Sched_Locked
000004  b111              CBZ      r1,|L58.12|
;;;418        {
;;;419            RMP_COVERAGE_MARKER();
;;;420            /* Now see if the scheduler scheduling action is pended in the lock-unlock 
;;;421             * period. If yes, perform a schedule now */
;;;422            _RMP_Yield();
;;;423        }
;;;424        else
;;;425        {
;;;426            RMP_COVERAGE_MARKER();
;;;427            RMP_Sched_Pend=1;
000006  2101              MOVS     r1,#1
000008  60c1              STR      r1,[r0,#0xc]  ; RMP_Sched_Pend
;;;428        }
;;;429    }
00000a  4770              BX       lr
                  |L58.12|
00000c  f7ffbffe          B.W      _RMP_Yield
;;;430    /* End Function:RMP_Yield ****************************************************/
                          ENDP

                  |L58.16|
                          DCD      ||.data||

                          AREA ||i._RMP_Clr_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Clr_Rdy PROC
;;;686    ******************************************************************************/
;;;687    void _RMP_Clr_Rdy(volatile struct RMP_Thd* Thread)
000000  b510              PUSH     {r4,lr}
;;;688    {
;;;689        /* Is it suspended? If yes, no need to delete again */
;;;690        if((Thread->State&RMP_THD_SUSPENDED)==0)
000002  6981              LDR      r1,[r0,#0x18]
000004  05c9              LSLS     r1,r1,#23
000006  d41a              BMI      |L59.62|
;;;691        {
;;;692            RMP_COVERAGE_MARKER();
;;;693            /* See if it is the last thread on the priority level */
;;;694            if(Thread->Run_Head.Prev==Thread->Run_Head.Next)
000008  6801              LDR      r1,[r0,#0]
00000a  6842              LDR      r2,[r0,#4]
;;;695            {
;;;696                RMP_COVERAGE_MARKER();
;;;697                RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]&=~(((rmp_ptr_t)1)<<(Thread->Prio&RMP_WORD_MASK));
00000c  2301              MOVS     r3,#1
00000e  4291              CMP      r1,r2                 ;694
000010  d10c              BNE      |L59.44|
000012  6a41              LDR      r1,[r0,#0x24]
000014  4a0a              LDR      r2,|L59.64|
000016  0949              LSRS     r1,r1,#5
000018  eb020181          ADD      r1,r2,r1,LSL #2
00001c  680a              LDR      r2,[r1,#0]
00001e  6a44              LDR      r4,[r0,#0x24]
000020  f004041f          AND      r4,r4,#0x1f
000024  fa03f404          LSL      r4,r3,r4
000028  43a2              BICS     r2,r2,r4
00002a  600a              STR      r2,[r1,#0]
                  |L59.44|
;;;698            }
;;;699            else
;;;700                RMP_COVERAGE_MARKER();
;;;701            
;;;702            /* Delete this from the corresponding runqueue */
;;;703            RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
00002c  6801              LDR      r1,[r0,#0]
00002e  6842              LDR      r2,[r0,#4]
000030  6011              STR      r1,[r2,#0]
000032  604a              STR      r2,[r1,#4]
;;;704            
;;;705            /* If it is the current thread, request a context switch */
;;;706            if(Thread==RMP_Cur_Thd)
000034  4902              LDR      r1,|L59.64|
000036  698a              LDR      r2,[r1,#0x18]  ; RMP_Cur_Thd
000038  4290              CMP      r0,r2
00003a  d100              BNE      |L59.62|
;;;707            {
;;;708                RMP_COVERAGE_MARKER();
;;;709                RMP_Sched_Pend=1;
00003c  60cb              STR      r3,[r1,#0xc]  ; RMP_Sched_Pend
                  |L59.62|
;;;710            }
;;;711            else
;;;712                RMP_COVERAGE_MARKER();
;;;713        }
;;;714        else
;;;715            RMP_COVERAGE_MARKER();
;;;716    }
00003e  bd10              POP      {r4,pc}
;;;717    /* End Function:_RMP_Clr_Rdy *************************************************/
                          ENDP

                  |L59.64|
                          DCD      ||.data||

                          AREA ||i._RMP_Dly_Ins||, CODE, READONLY, ALIGN=2

                  _RMP_Dly_Ins PROC
;;;726    ******************************************************************************/
;;;727    void _RMP_Dly_Ins(volatile struct RMP_Thd* Thread, rmp_ptr_t Slices)
000000  b470              PUSH     {r4-r6}
;;;728    {
;;;729        struct RMP_List* Trav_Ptr;
;;;730        struct RMP_Thd* Trav_Thd;
;;;731        
;;;732        /* Find a place to insert this timer */
;;;733        Trav_Ptr=(struct RMP_List*)RMP_Delay.Next;
000002  4c0a              LDR      r4,|L60.44|
;;;734        while(Trav_Ptr!=&(RMP_Delay))
;;;735        {
;;;736            Trav_Thd=RMP_DLY2THD(Trav_Ptr);
;;;737            if((Trav_Thd->Timeout-RMP_Tick)>Slices)
000004  f1a40520          SUB      r5,r4,#0x20
000008  6862              LDR      r2,[r4,#4]            ;733  ; RMP_Delay
00000a  e005              B        |L60.24|
                  |L60.12|
00000c  696e              LDR      r6,[r5,#0x14]  ; RMP_Tick
00000e  6a13              LDR      r3,[r2,#0x20]
000010  1b9b              SUBS     r3,r3,r6
000012  428b              CMP      r3,r1
000014  d802              BHI      |L60.28|
;;;738            {
;;;739                RMP_COVERAGE_MARKER();
;;;740                break;
;;;741            }
;;;742            else
;;;743                RMP_COVERAGE_MARKER();
;;;744            
;;;745            Trav_Ptr=(struct RMP_List*)(Trav_Ptr->Next);
000016  6852              LDR      r2,[r2,#4]
                  |L60.24|
000018  42a2              CMP      r2,r4                 ;734
00001a  d1f7              BNE      |L60.12|
                  |L60.28|
;;;746        }
;;;747    
;;;748        /* Insert this into the list */
;;;749        Thread->Timeout=RMP_Tick+Slices;
00001c  696b              LDR      r3,[r5,#0x14]  ; RMP_Tick
00001e  4419              ADD      r1,r1,r3
000020  6281              STR      r1,[r0,#0x28]
;;;750        RMP_List_Ins(&Thread->Dly_Head,Trav_Ptr->Prev,Trav_Ptr);
000022  6811              LDR      r1,[r2,#0]
000024  3008              ADDS     r0,r0,#8
000026  bc70              POP      {r4-r6}
000028  f7ffbffe          B.W      RMP_List_Ins
;;;751    }
;;;752    /* End Function:_RMP_Dly_Ins *************************************************/
                          ENDP

                  |L60.44|
                          DCD      ||.data||+0x20

                          AREA ||i._RMP_Get_High_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Get_High_Rdy PROC
;;;494    ******************************************************************************/
;;;495    void _RMP_Get_High_Rdy(void)
000000  b510              PUSH     {r4,lr}
;;;496    {
;;;497        rmp_cnt_t Count;
;;;498        
;;;499        /* Write the SP value to thread structure */
;;;500        RMP_Cur_Thd->Stack=RMP_Cur_SP;
000002  4c17              LDR      r4,|L61.96|
;;;501        
;;;502        /* No need to detect scheduler locks - if this interrupt can be entered, the scheduler is not locked */
;;;503        RMP_Sched_Pend=0;
000004  2100              MOVS     r1,#0
000006  69e2              LDR      r2,[r4,#0x1c]         ;500  ; RMP_Cur_SP
000008  69a3              LDR      r3,[r4,#0x18]         ;500  ; RMP_Cur_Thd
;;;504        /* See which one is ready, and pick it */
;;;505        for(Count=RMP_BITMAP_SIZE-1;Count>=0;Count--)
;;;506        {
;;;507            if(RMP_Bitmap[Count]==0)
00000a  4620              MOV      r0,r4
00000c  635a              STR      r2,[r3,#0x34]         ;503
00000e  60e1              STR      r1,[r4,#0xc]          ;503  ; RMP_Sched_Pend
000010  6801              LDR      r1,[r0,#0]
000012  b301              CBZ      r1,|L61.86|
;;;508            {
;;;509                RMP_COVERAGE_MARKER();
;;;510                continue;
;;;511            }
;;;512            else
;;;513                RMP_COVERAGE_MARKER();
;;;514            
;;;515            Count=RMP_MSB_Get(RMP_Bitmap[Count])+(Count<<RMP_WORD_ORDER);
000014  6800              LDR      r0,[r0,#0]
000016  f7fffffe          BL       RMP_MSB_Get
;;;516            
;;;517            /* See if the current thread and the next thread are the same. If yes, place the current at the end of the queue */
;;;518            if(RMP_Cur_Thd==(struct RMP_Thd*)(RMP_Run[Count].Next))
00001a  4a12              LDR      r2,|L61.100|
00001c  eb0203c0          ADD      r3,r2,r0,LSL #3
000020  6858              LDR      r0,[r3,#4]
000022  69a1              LDR      r1,[r4,#0x18]  ; RMP_Cur_Thd
000024  4288              CMP      r0,r1
000026  d110              BNE      |L61.74|
;;;519            {
;;;520                RMP_COVERAGE_MARKER();
;;;521                RMP_List_Del(RMP_Cur_Thd->Run_Head.Prev, RMP_Cur_Thd->Run_Head.Next);
000028  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
00002a  69a1              LDR      r1,[r4,#0x18]  ; RMP_Cur_Thd
00002c  6800              LDR      r0,[r0,#0]
00002e  6849              LDR      r1,[r1,#4]
000030  6008              STR      r0,[r1,#0]
000032  6041              STR      r1,[r0,#4]
;;;522                RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),
000034  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
000036  69a1              LDR      r1,[r4,#0x18]  ; RMP_Cur_Thd
000038  6a40              LDR      r0,[r0,#0x24]
00003a  6a49              LDR      r1,[r1,#0x24]
00003c  f8521031          LDR      r1,[r2,r1,LSL #3]
000040  eb0202c0          ADD      r2,r2,r0,LSL #3
000044  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
000046  f7fffffe          BL       RMP_List_Ins
                  |L61.74|
;;;523                             RMP_Run[RMP_Cur_Thd->Prio].Prev,
;;;524                             &(RMP_Run[RMP_Cur_Thd->Prio]));
;;;525            }
;;;526            else
;;;527                RMP_COVERAGE_MARKER();
;;;528            
;;;529            /* Replenish timeslices */
;;;530            RMP_Cur_Thd->Slices_Left=RMP_Cur_Thd->Slices;
00004a  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
00004c  69a1              LDR      r1,[r4,#0x18]  ; RMP_Cur_Thd
00004e  69c0              LDR      r0,[r0,#0x1c]
;;;531            RMP_Cur_Thd=(struct RMP_Thd*)(RMP_Run[Count].Next);
000050  6208              STR      r0,[r1,#0x20]
000052  6858              LDR      r0,[r3,#4]
000054  61a0              STR      r0,[r4,#0x18]  ; RMP_Cur_Thd
                  |L61.86|
;;;532            break;
;;;533        }
;;;534        
;;;535        /* Load the SP value from thread structure */
;;;536        RMP_Cur_SP=RMP_Cur_Thd->Stack;
000056  69a0              LDR      r0,[r4,#0x18]  ; RMP_Cur_Thd
000058  6b40              LDR      r0,[r0,#0x34]
00005a  61e0              STR      r0,[r4,#0x1c]  ; RMP_Cur_SP
;;;537        
;;;538    #if(RMP_USE_HOOKS==RMP_TRUE)
;;;539        RMP_Sched_Hook();
;;;540    #endif
;;;541    }
00005c  bd10              POP      {r4,pc}
;;;542    /* End Function:_RMP_Get_High_Rdy ********************************************/
                          ENDP

00005e  0000              DCW      0x0000
                  |L61.96|
                          DCD      ||.data||
                  |L61.100|
                          DCD      ||.bss||

                          AREA ||i._RMP_Get_Near_Ticks||, CODE, READONLY, ALIGN=2

                  _RMP_Get_Near_Ticks PROC
;;;612    ******************************************************************************/
;;;613    rmp_ptr_t _RMP_Get_Near_Ticks(void)
000000  4908              LDR      r1,|L62.36|
;;;614    {
;;;615        rmp_ptr_t Value;
;;;616        struct RMP_Thd* Thread;
;;;617        
;;;618        /* What is the current thread's timeout value? */
;;;619        Value=RMP_Cur_Thd->Slices_Left;
000002  f1a10220          SUB      r2,r1,#0x20
000006  6990              LDR      r0,[r2,#0x18]  ; RMP_Cur_Thd
;;;620        
;;;621        /* What is the nearest timer timeout value? */
;;;622        if((&RMP_Delay)!=RMP_Delay.Next)
000008  684b              LDR      r3,[r1,#4]  ; RMP_Delay
00000a  428b              CMP      r3,r1
00000c  6a00              LDR      r0,[r0,#0x20]         ;619
00000e  d007              BEQ      |L62.32|
;;;623        {
;;;624            RMP_COVERAGE_MARKER();
;;;625            Thread=RMP_DLY2THD(RMP_Delay.Next);
000010  6849              LDR      r1,[r1,#4]  ; RMP_Delay
;;;626            /* See if it is nearer - don't worry about the situation that the timer
;;;627             * have overflown, because if that is to happen, it would have been 
;;;628             * already processed by the timeout processing routine just before. */
;;;629            if((Thread->Timeout-RMP_Tick)<Value)
000012  6953              LDR      r3,[r2,#0x14]  ; RMP_Tick
000014  6a09              LDR      r1,[r1,#0x20]
000016  1acb              SUBS     r3,r1,r3
000018  4283              CMP      r3,r0
00001a  d201              BCS      |L62.32|
;;;630            {
;;;631                RMP_COVERAGE_MARKER();
;;;632                Value=Thread->Timeout-RMP_Tick;
00001c  6950              LDR      r0,[r2,#0x14]  ; RMP_Tick
00001e  1a08              SUBS     r0,r1,r0
                  |L62.32|
;;;633            }
;;;634            else
;;;635                RMP_COVERAGE_MARKER();
;;;636        }
;;;637        else
;;;638            RMP_COVERAGE_MARKER();
;;;639        
;;;640        return Value;
;;;641    }
000020  4770              BX       lr
;;;642    /* End Function:_RMP_Get_Near_Ticks ******************************************/
                          ENDP

000022  0000              DCW      0x0000
                  |L62.36|
                          DCD      ||.data||+0x20

                          AREA ||i._RMP_Mem_Block||, CODE, READONLY, ALIGN=1

                  _RMP_Mem_Block PROC
;;;2239   ******************************************************************************/
;;;2240   void _RMP_Mem_Block(volatile struct RMP_Mem_Head* Addr, rmp_ptr_t Size)
000000  2200              MOVS     r2,#0
;;;2241   {
;;;2242       volatile struct RMP_Mem_Head* Mem_Head;
;;;2243       
;;;2244       /* Get the big memory block's size and position */
;;;2245       Mem_Head=(struct RMP_Mem_Head*)Addr;
;;;2246       
;;;2247       /* Initialize the big memory block */
;;;2248       Mem_Head->State=RMP_MEM_FREE;
000002  6082              STR      r2,[r0,#8]
;;;2249       Mem_Head->Tail=(struct RMP_Mem_Tail*)(((rmp_ptr_t)Mem_Head)+Size-sizeof(struct RMP_Mem_Tail));
000004  4401              ADD      r1,r1,r0
000006  1f09              SUBS     r1,r1,#4              ;2248
000008  60c1              STR      r1,[r0,#0xc]
;;;2250       Mem_Head->Tail->Head=Mem_Head;
00000a  68c1              LDR      r1,[r0,#0xc]
00000c  6008              STR      r0,[r1,#0]
;;;2251   }
00000e  4770              BX       lr
;;;2252   /* End Function:_RMP_Mem_Block ***********************************************/
                          ENDP


                          AREA ||i._RMP_Mem_Del||, CODE, READONLY, ALIGN=1

                  _RMP_Mem_Del PROC
;;;2306   ******************************************************************************/
;;;2307   void _RMP_Mem_Del(volatile void* Pool, volatile struct RMP_Mem_Head* Mem_Head)
000000  b570              PUSH     {r4-r6,lr}
;;;2308   {
000002  4605              MOV      r5,r0
;;;2309       rmp_ptr_t FLI_Level;
;;;2310       rmp_ptr_t SLI_Level;
;;;2311       rmp_ptr_t Level;
;;;2312       rmp_ptr_t Size;
;;;2313       volatile struct RMP_Mem* Mem;
;;;2314       volatile struct RMP_List* Slot;    
;;;2315       
;;;2316       /* Get the memory pool and block size */
;;;2317       Mem=(volatile struct RMP_Mem*)Pool;
;;;2318       Size=(rmp_ptr_t)(Mem_Head->Tail)-((rmp_ptr_t)Mem_Head)-sizeof(struct RMP_Mem_Head);
000004  68c8              LDR      r0,[r1,#0xc]
000006  460c              MOV      r4,r1                 ;2308
000008  1b06              SUBS     r6,r0,r4
00000a  3e10              SUBS     r6,r6,#0x10
;;;2319       
;;;2320       /* Guarantee the Mem_Size is bigger than 64 or a failure will surely occur here */
;;;2321       FLI_Level=RMP_MSB_Get(Size)-6;
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       RMP_MSB_Get
;;;2322       /* Decide the SLI level directly from the FLI level */
;;;2323       SLI_Level=(Size>>(FLI_Level+3))&0x07;
000012  1ec1              SUBS     r1,r0,#3
;;;2324       /* Calculate the bit position */
;;;2325       Level=RMP_MEM_POS(FLI_Level,SLI_Level);
;;;2326       /* Get the slot */
;;;2327       Slot=&(Mem->Table[Level]);
000014  68ea              LDR      r2,[r5,#0xc]
000016  40ce              LSRS     r6,r6,r1              ;2323
000018  1f80              SUBS     r0,r0,#6              ;2323
00001a  f0060107          AND      r1,r6,#7              ;2323
00001e  eb0100c0          ADD      r0,r1,r0,LSL #3       ;2325
;;;2328   
;;;2329       /* Delete the node now */
;;;2330       RMP_List_Del(Mem_Head->Head.Prev,Mem_Head->Head.Next);
000022  6821              LDR      r1,[r4,#0]
000024  eb0202c0          ADD      r2,r2,r0,LSL #3       ;2327
000028  6863              LDR      r3,[r4,#4]
00002a  6019              STR      r1,[r3,#0]
00002c  604b              STR      r3,[r1,#4]
;;;2331   
;;;2332       /* See if there are any blocks in the level, equal means no. So
;;;2333        * what we deleted is the last blockm need to clear the flag */
;;;2334       if(Slot==Slot->Next)
00002e  6851              LDR      r1,[r2,#4]
000030  4291              CMP      r1,r2
000032  d109              BNE      |L64.72|
;;;2335       {
;;;2336           RMP_COVERAGE_MARKER();
;;;2337           /* Clear the corresponding bit in the TLSF bitmap */
;;;2338           Mem->Bitmap[Level>>RMP_WORD_ORDER]&=~RMP_POW2(Level&RMP_WORD_MASK);
000034  0941              LSRS     r1,r0,#5
000036  f000031f          AND      r3,r0,#0x1f
00003a  eb050081          ADD      r0,r5,r1,LSL #2
00003e  2101              MOVS     r1,#1
000040  6902              LDR      r2,[r0,#0x10]
000042  4099              LSLS     r1,r1,r3
000044  438a              BICS     r2,r2,r1
000046  6102              STR      r2,[r0,#0x10]
                  |L64.72|
;;;2339       }
;;;2340       else
;;;2341           RMP_COVERAGE_MARKER();
;;;2342   }
000048  bd70              POP      {r4-r6,pc}
;;;2343   /* End Function:_RMP_Mem_Del *************************************************/
                          ENDP


                          AREA ||i._RMP_Mem_Ins||, CODE, READONLY, ALIGN=1

                  _RMP_Mem_Ins PROC
;;;2261   ******************************************************************************/
;;;2262   void _RMP_Mem_Ins(volatile void* Pool, volatile struct RMP_Mem_Head* Mem_Head)
000000  b570              PUSH     {r4-r6,lr}
;;;2263   {
000002  4604              MOV      r4,r0
;;;2264       rmp_ptr_t FLI_Level;
;;;2265       rmp_ptr_t SLI_Level;
;;;2266       rmp_ptr_t Level;
;;;2267       rmp_ptr_t Size;
;;;2268       volatile struct RMP_Mem* Mem;
;;;2269       volatile struct RMP_List* Slot;
;;;2270       
;;;2271       /* Get the memory pool and block size */
;;;2272       Mem=(volatile struct RMP_Mem*)Pool;
;;;2273       Size=(rmp_ptr_t)(Mem_Head->Tail)-((rmp_ptr_t)Mem_Head)-sizeof(struct RMP_Mem_Head);
000004  68c8              LDR      r0,[r1,#0xc]
000006  460e              MOV      r6,r1                 ;2263
000008  1b85              SUBS     r5,r0,r6
00000a  3d10              SUBS     r5,r5,#0x10
;;;2274   
;;;2275       /* Guarantee the Mem_Size is bigger than 64 or a failure will surely occur here */
;;;2276       FLI_Level=RMP_MSB_Get(Size)-6;
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       RMP_MSB_Get
;;;2277       /* Decide the SLI level directly from the FLI level */
;;;2278       SLI_Level=(Size>>(FLI_Level+3))&0x07;
;;;2279       /* Calculate the bit position */
;;;2280       Level=RMP_MEM_POS(FLI_Level,SLI_Level);
;;;2281       /* Get the slot */
;;;2282       Slot=&(Mem->Table[Level]);
000012  68e2              LDR      r2,[r4,#0xc]
000014  1ec1              SUBS     r1,r0,#3              ;2278
000016  40cd              LSRS     r5,r5,r1              ;2278
000018  1f80              SUBS     r0,r0,#6              ;2278
00001a  f0050107          AND      r1,r5,#7              ;2278
00001e  eb0100c0          ADD      r0,r1,r0,LSL #3       ;2280
000022  eb0201c0          ADD      r1,r2,r0,LSL #3
;;;2283   
;;;2284       /* See if there are any blocks in the level, equal means no. So what we inserted is the first block */
;;;2285       if(Slot==Slot->Next)
000026  684a              LDR      r2,[r1,#4]
000028  428a              CMP      r2,r1
00002a  d109              BNE      |L65.64|
;;;2286       {
;;;2287           RMP_COVERAGE_MARKER();
;;;2288           /* Set the corresponding bit in the TLSF bitmap */
;;;2289           Mem->Bitmap[Level>>RMP_WORD_ORDER]|=RMP_POW2(Level&RMP_WORD_MASK);
00002c  0942              LSRS     r2,r0,#5
00002e  f000051f          AND      r5,r0,#0x1f
000032  eb040082          ADD      r0,r4,r2,LSL #2
000036  2201              MOVS     r2,#1
000038  6903              LDR      r3,[r0,#0x10]
00003a  40aa              LSLS     r2,r2,r5
00003c  4313              ORRS     r3,r3,r2
00003e  6103              STR      r3,[r0,#0x10]
                  |L65.64|
;;;2290       }
;;;2291       else
;;;2292           RMP_COVERAGE_MARKER();
;;;2293   
;;;2294       /* Insert the node now */
;;;2295       RMP_List_Ins(&(Mem_Head->Head), Slot, Slot->Next);
000040  684a              LDR      r2,[r1,#4]
000042  4630              MOV      r0,r6
000044  e8bd4070          POP      {r4-r6,lr}
000048  f7ffbffe          B.W      RMP_List_Ins
;;;2296   }
;;;2297   /* End Function:_RMP_Mem_Ins *************************************************/
                          ENDP


                          AREA ||i._RMP_Mem_Search||, CODE, READONLY, ALIGN=1

                  _RMP_Mem_Search PROC
;;;2353   ******************************************************************************/
;;;2354   rmp_ret_t _RMP_Mem_Search(volatile void* Pool, rmp_ptr_t Size, rmp_cnt_t* FLI_Level, rmp_cnt_t* SLI_Level)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;2355   {
000004  461e              MOV      r6,r3
000006  4617              MOV      r7,r2
000008  4604              MOV      r4,r0
00000a  460d              MOV      r5,r1
;;;2356       rmp_ptr_t FLI_Level_Temp;
;;;2357       rmp_ptr_t SLI_Level_Temp;
;;;2358       rmp_cnt_t Level;
;;;2359       rmp_cnt_t Word;
;;;2360       rmp_cnt_t Limit;
;;;2361       rmp_ptr_t LSB;
;;;2362       volatile struct RMP_Mem* Mem;
;;;2363   
;;;2364       /* Make sure that it is bigger than 64. 64=2^6 */
;;;2365       FLI_Level_Temp=RMP_MSB_Get(Size)-6;
00000c  4608              MOV      r0,r1
00000e  f7fffffe          BL       RMP_MSB_Get
;;;2366       
;;;2367       /* Decide the SLI level directly from the FLI level. We plus the number by one here
;;;2368        * so that we can avoid the list search. However, when the allocated memory is just
;;;2369        * one of the levels, then we don't need to jump to the next level and can fit directly */
;;;2370       SLI_Level_Temp=(Size>>(FLI_Level_Temp+3))&0x07;
000012  1ec2              SUBS     r2,r0,#3
000014  fa25f102          LSR      r1,r5,r2
000018  f0010107          AND      r1,r1,#7
;;;2371       if(Size!=(RMP_POW2(FLI_Level_Temp+3)*(SLI_Level_Temp+8)))
00001c  f1010308          ADD      r3,r1,#8
000020  4093              LSLS     r3,r3,r2
000022  1f80              SUBS     r0,r0,#6
000024  42ab              CMP      r3,r5
000026  d004              BEQ      |L66.50|
000028  1c49              ADDS     r1,r1,#1
;;;2372       {
;;;2373           RMP_COVERAGE_MARKER();
;;;2374           SLI_Level_Temp++;
;;;2375           
;;;2376           /* If the SLI level is the largest of the SLI level, then jump to the next FLI level */
;;;2377           if(SLI_Level_Temp==8)
00002a  2908              CMP      r1,#8
00002c  d101              BNE      |L66.50|
;;;2378           {
;;;2379               RMP_COVERAGE_MARKER();
;;;2380               FLI_Level_Temp+=1;
;;;2381               SLI_Level_Temp=0;
00002e  2100              MOVS     r1,#0
000030  1c40              ADDS     r0,r0,#1
                  |L66.50|
;;;2382           }
;;;2383           else
;;;2384               RMP_COVERAGE_MARKER();
;;;2385       }
;;;2386       else
;;;2387           RMP_COVERAGE_MARKER();
;;;2388       
;;;2389       /* Check if the FLI level is over the boundary */
;;;2390       Mem=(volatile struct RMP_Mem*)Pool;
;;;2391       if(FLI_Level_Temp>=Mem->FLI_Num)
000032  6822              LDR      r2,[r4,#0]
;;;2392       {
;;;2393           RMP_COVERAGE_MARKER();
;;;2394           return -1;
000034  f04f39ff          MOV      r9,#0xffffffff
000038  4282              CMP      r2,r0                 ;2391
00003a  d933              BLS      |L66.164|
;;;2395       }
;;;2396       else
;;;2397           RMP_COVERAGE_MARKER();
;;;2398       
;;;2399       /* Try to find one position on this processor word level */
;;;2400       Level=RMP_MEM_POS(FLI_Level_Temp,SLI_Level_Temp);
00003c  eb0105c0          ADD      r5,r1,r0,LSL #3
;;;2401       LSB=RMP_LSB_Get(Mem->Bitmap[Level>>RMP_WORD_ORDER]>>(Level&RMP_WORD_MASK));
000040  f005081f          AND      r8,r5,#0x1f
000044  1168              ASRS     r0,r5,#5
000046  eb040080          ADD      r0,r4,r0,LSL #2
00004a  6900              LDR      r0,[r0,#0x10]
00004c  fa20f008          LSR      r0,r0,r8
000050  f7fffffe          BL       RMP_LSB_Get
;;;2402       /* If there's at least one block that matches the query, return the level */
;;;2403       if(LSB<RMP_WORD_SIZE)
000054  2820              CMP      r0,#0x20
000056  d208              BCS      |L66.106|
;;;2404       {
;;;2405           RMP_COVERAGE_MARKER();
;;;2406           Level=(Level&(~RMP_WORD_MASK))+LSB+(Level&RMP_WORD_MASK);
000058  f025011f          BIC      r1,r5,#0x1f
00005c  4401              ADD      r1,r1,r0
00005e  eb010008          ADD      r0,r1,r8
;;;2407           *FLI_Level=Level>>3;
000062  10c1              ASRS     r1,r0,#3
;;;2408           *SLI_Level=Level&0x07;
000064  f0000007          AND      r0,r0,#7
;;;2409           return 0;
000068  e014              B        |L66.148|
                  |L66.106|
;;;2410       }
;;;2411       /* No one exactly fits */
;;;2412       else
;;;2413       {
;;;2414           RMP_COVERAGE_MARKER();
;;;2415           Limit=RMP_ROUND_UP(Mem->FLI_Num,RMP_ALIGN_ORDER)>>RMP_ALIGN_ORDER;
00006a  6820              LDR      r0,[r4,#0]
;;;2416           /* From the next word, query one by one */
;;;2417           for(Word=(Level>>RMP_WORD_ORDER)+1;Word<Limit;Word++)
00006c  2101              MOVS     r1,#1
00006e  eb011565          ADD      r5,r1,r5,ASR #5
000072  1cc0              ADDS     r0,r0,#3
000074  0880              LSRS     r0,r0,#2              ;2415
000076  e013              B        |L66.160|
                  |L66.120|
;;;2418           {
;;;2419               /* If the level has blocks of one FLI level */
;;;2420               if(Mem->Bitmap[Word]!=0)
000078  eb040185          ADD      r1,r4,r5,LSL #2
00007c  6909              LDR      r1,[r1,#0x10]
00007e  b171              CBZ      r1,|L66.158|
;;;2421               {
;;;2422                   RMP_COVERAGE_MARKER();
;;;2423                   /* Find the actual level */ 
;;;2424                   LSB=RMP_LSB_Get(Mem->Bitmap[Word]);
000080  eb040085          ADD      r0,r4,r5,LSL #2
000084  6900              LDR      r0,[r0,#0x10]
000086  f7fffffe          BL       RMP_LSB_Get
;;;2425                   *FLI_Level=((Word<<RMP_WORD_ORDER)+LSB)>>3;
00008a  eb001145          ADD      r1,r0,r5,LSL #5
;;;2426                   *SLI_Level=LSB&0x07;
00008e  f0000007          AND      r0,r0,#7
000092  08c9              LSRS     r1,r1,#3              ;2425
                  |L66.148|
000094  6039              STR      r1,[r7,#0]
;;;2427                   return 0;
000096  6030              STR      r0,[r6,#0]
000098  2000              MOVS     r0,#0
                  |L66.154|
;;;2428               }
;;;2429               else
;;;2430                   RMP_COVERAGE_MARKER();
;;;2431           }
;;;2432       }
;;;2433   
;;;2434       /* Search failed */
;;;2435       return -1;
;;;2436   }
00009a  e8bd87f0          POP      {r4-r10,pc}
                  |L66.158|
00009e  1c6d              ADDS     r5,r5,#1
                  |L66.160|
0000a0  4285              CMP      r5,r0                 ;2417
0000a2  dbe9              BLT      |L66.120|
                  |L66.164|
0000a4  4648              MOV      r0,r9                 ;2435
0000a6  e7f8              B        |L66.154|
;;;2437   /* End Function:_RMP_Mem_Search **********************************************/
                          ENDP


                          AREA ||i._RMP_Set_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Set_Rdy PROC
;;;653    ******************************************************************************/
;;;654    void _RMP_Set_Rdy(volatile struct RMP_Thd* Thread)
000000  b510              PUSH     {r4,lr}
;;;655    {        
000002  4603              MOV      r3,r0
;;;656        /* Is it suspended? If yes, we can't directly set it running */
;;;657        if((Thread->State&RMP_THD_SUSPENDED)==0)
000004  6980              LDR      r0,[r0,#0x18]
000006  05c0              LSLS     r0,r0,#23
000008  d41e              BMI      |L67.72|
;;;658        {
;;;659            RMP_COVERAGE_MARKER();
;;;660            /* Insert this into the corresponding runqueue */
;;;661            RMP_List_Ins(&(Thread->Run_Head),RMP_Run[Thread->Prio].Prev,&(RMP_Run[Thread->Prio]));
00000a  6a5a              LDR      r2,[r3,#0x24]
00000c  6a59              LDR      r1,[r3,#0x24]
00000e  480f              LDR      r0,|L67.76|
000010  f8501031          LDR      r1,[r0,r1,LSL #3]
000014  eb0002c2          ADD      r2,r0,r2,LSL #3
000018  4618              MOV      r0,r3
00001a  f7fffffe          BL       RMP_List_Ins
;;;662            /* Set this runlevel as active */
;;;663            RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]|=((rmp_ptr_t)1)<<(Thread->Prio&RMP_WORD_MASK);
00001e  6a58              LDR      r0,[r3,#0x24]
000020  2101              MOVS     r1,#1
000022  4a0b              LDR      r2,|L67.80|
000024  0940              LSRS     r0,r0,#5
000026  eb020080          ADD      r0,r2,r0,LSL #2
00002a  6802              LDR      r2,[r0,#0]
00002c  6a5c              LDR      r4,[r3,#0x24]
00002e  f004041f          AND      r4,r4,#0x1f
000032  fa01f404          LSL      r4,r1,r4
000036  4322              ORRS     r2,r2,r4
000038  6002              STR      r2,[r0,#0]
;;;664            
;;;665            /* Compare this with the current one to see if we need a context switch */
;;;666            if(Thread->Prio>RMP_Cur_Thd->Prio)
00003a  4805              LDR      r0,|L67.80|
00003c  6a5a              LDR      r2,[r3,#0x24]
00003e  6983              LDR      r3,[r0,#0x18]  ; RMP_Cur_Thd
000040  6a5b              LDR      r3,[r3,#0x24]
000042  429a              CMP      r2,r3
000044  d900              BLS      |L67.72|
;;;667            {
;;;668                RMP_COVERAGE_MARKER();
;;;669                RMP_Sched_Pend=1;
000046  60c1              STR      r1,[r0,#0xc]  ; RMP_Sched_Pend
                  |L67.72|
;;;670            }
;;;671            else
;;;672                RMP_COVERAGE_MARKER();
;;;673        }
;;;674        else
;;;675            RMP_COVERAGE_MARKER();
;;;676    }
000048  bd10              POP      {r4,pc}
;;;677    /* End Function:_RMP_Set_Rdy *************************************************/
                          ENDP

00004a  0000              DCW      0x0000
                  |L67.76|
                          DCD      ||.bss||
                  |L67.80|
                          DCD      ||.data||

                          AREA ||i._RMP_Tick_Handler||, CODE, READONLY, ALIGN=2

                  _RMP_Tick_Handler PROC
;;;549    ******************************************************************************/
;;;550    void _RMP_Tick_Handler(rmp_ptr_t Ticks)
000000  b510              PUSH     {r4,lr}
;;;551    {
;;;552        struct RMP_Thd* Thread;
;;;553        /* Increase the timestamp as always */
;;;554        RMP_Tick+=Ticks;
000002  4c13              LDR      r4,|L68.80|
000004  6961              LDR      r1,[r4,#0x14]  ; RMP_Tick
000006  4401              ADD      r1,r1,r0
000008  6161              STR      r1,[r4,#0x14]  ; RMP_Tick
;;;555        
;;;556        /* See if the current thread expired. If yes, trigger a scheduler event */
;;;557        if(Ticks>RMP_Cur_Thd->Slices_Left)
00000a  69a1              LDR      r1,[r4,#0x18]  ; RMP_Cur_Thd
00000c  6a09              LDR      r1,[r1,#0x20]
00000e  4281              CMP      r1,r0
000010  d202              BCS      |L68.24|
;;;558        {
;;;559            RMP_COVERAGE_MARKER();
;;;560            RMP_Sched_Pend=1;
000012  2001              MOVS     r0,#1
000014  60e0              STR      r0,[r4,#0xc]  ; RMP_Sched_Pend
000016  e003              B        |L68.32|
                  |L68.24|
;;;561        }
;;;562        else
;;;563        {
;;;564            RMP_COVERAGE_MARKER();
;;;565            RMP_Cur_Thd->Slices_Left-=Ticks;
000018  69a1              LDR      r1,[r4,#0x18]  ; RMP_Cur_Thd
00001a  6a0a              LDR      r2,[r1,#0x20]
00001c  1a10              SUBS     r0,r2,r0
00001e  6208              STR      r0,[r1,#0x20]
                  |L68.32|
;;;566        }
;;;567        
;;;568        /* Check if there are any timer events */
;;;569        if((&RMP_Delay)!=RMP_Delay.Next)
000020  480b              LDR      r0,|L68.80|
000022  3020              ADDS     r0,r0,#0x20
000024  6841              LDR      r1,[r0,#4]  ; RMP_Delay
000026  4281              CMP      r1,r0
000028  d008              BEQ      |L68.60|
;;;570        {
;;;571            RMP_COVERAGE_MARKER();
;;;572            Thread=RMP_DLY2THD(RMP_Delay.Next);
00002a  6840              LDR      r0,[r0,#4]  ; RMP_Delay
;;;573            /* If the value is less than this, then it means that the time have
;;;574             * already passed and we have to process this */
;;;575            if((RMP_Tick-Thread->Timeout)<=(RMP_ALLBITS>>1))
00002c  6961              LDR      r1,[r4,#0x14]  ; RMP_Tick
00002e  6a00              LDR      r0,[r0,#0x20]
000030  1a08              SUBS     r0,r1,r0
000032  f1b04f00          CMP      r0,#0x80000000
000036  d201              BCS      |L68.60|
;;;576            {
;;;577                RMP_COVERAGE_MARKER();
;;;578                /* No need to care about scheduler locks if this interrupt can be entered
;;;579                 * - we have disabled timer and scheduler interrupts in scheduler lock */
;;;580                _RMP_Timer_Proc();
000038  f7fffffe          BL       _RMP_Timer_Proc
                  |L68.60|
;;;581            }
;;;582            else
;;;583                RMP_COVERAGE_MARKER();
;;;584        }
;;;585        else
;;;586            RMP_COVERAGE_MARKER();
;;;587        
;;;588        if(RMP_Sched_Pend!=0)
00003c  68e0              LDR      r0,[r4,#0xc]  ; RMP_Sched_Pend
00003e  2800              CMP      r0,#0
000040  d005              BEQ      |L68.78|
;;;589        {
;;;590            RMP_COVERAGE_MARKER();
;;;591            RMP_Sched_Pend=0;
000042  2000              MOVS     r0,#0
000044  60e0              STR      r0,[r4,#0xc]  ; RMP_Sched_Pend
;;;592            _RMP_Yield();
000046  e8bd4010          POP      {r4,lr}
00004a  f7ffbffe          B.W      _RMP_Yield
                  |L68.78|
;;;593        }
;;;594        else
;;;595            RMP_COVERAGE_MARKER();
;;;596        
;;;597    #if(RMP_USE_HOOKS==RMP_TRUE)
;;;598        RMP_Tick_Hook(Ticks);
;;;599    #endif
;;;600    }
00004e  bd10              POP      {r4,pc}
;;;601    /* End Function:_RMP_Tick_Handler ********************************************/
                          ENDP

                  |L68.80|
                          DCD      ||.data||

                          AREA ||i._RMP_Timer_Proc||, CODE, READONLY, ALIGN=2

                  _RMP_Timer_Proc PROC
;;;437    ******************************************************************************/
;;;438    void _RMP_Timer_Proc(void)
000000  b570              PUSH     {r4-r6,lr}
;;;439    {
;;;440        struct RMP_Thd* Thread;
;;;441        
;;;442        /* Process the timer events, if there are any of them */
;;;443        while((&RMP_Delay)!=RMP_Delay.Next)
;;;444        {
;;;445            Thread=RMP_DLY2THD(RMP_Delay.Next);
000002  4c16              LDR      r4,|L69.92|
;;;446            /* If the value is more than this, then it means that the time have
;;;447             * already passed and we have to process this */
;;;448            if((RMP_Tick-Thread->Timeout)>(RMP_ALLBITS>>1))
;;;449            {
;;;450                RMP_COVERAGE_MARKER();
;;;451                break;
;;;452            }
;;;453            else
;;;454                RMP_COVERAGE_MARKER();
;;;455            
;;;456            /* This thread should be processed */
;;;457            RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;458            switch(RMP_THD_STATE(Thread->State))
;;;459            {
;;;460                case RMP_THD_SNDDLY:RMP_COVERAGE_MARKER();
;;;461                case RMP_THD_SEMDLY:
;;;462                {
;;;463                    RMP_COVERAGE_MARKER();
;;;464                    RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;465                    Thread->Retval=RMP_ERR_OPER;
000004  f06f0504          MVN      r5,#4
000008  e023              B        |L69.82|
                  |L69.10|
00000a  6860              LDR      r0,[r4,#4]            ;445  ; RMP_Delay
00000c  4913              LDR      r1,|L69.92|
00000e  3920              SUBS     r1,r1,#0x20           ;448
000010  6949              LDR      r1,[r1,#0x14]         ;448  ; RMP_Tick
000012  6a02              LDR      r2,[r0,#0x20]         ;448
000014  3808              SUBS     r0,r0,#8              ;448
000016  1a89              SUBS     r1,r1,r2              ;448
000018  f1b14f00          CMP      r1,#0x80000000        ;448
00001c  d21c              BCS      |L69.88|
00001e  e9d01202          LDRD     r1,r2,[r0,#8]         ;448
000022  6011              STR      r1,[r2,#0]            ;448
000024  604a              STR      r2,[r1,#4]            ;448
000026  7e01              LDRB     r1,[r0,#0x18]         ;458
000028  2903              CMP      r1,#3                 ;458
00002a  d006              BEQ      |L69.58|
00002c  2905              CMP      r1,#5                 ;458
00002e  d008              BEQ      |L69.66|
000030  2906              CMP      r1,#6                 ;458
000032  d007              BEQ      |L69.68|
000034  2908              CMP      r1,#8                 ;458
000036  d000              BEQ      |L69.58|
                  |L69.56|
;;;466                    break;
;;;467                }
;;;468                
;;;469                case RMP_THD_RCVDLY:
;;;470                {
;;;471                    RMP_COVERAGE_MARKER();
;;;472                    Thread->Retval=RMP_ERR_OPER;
;;;473                    break;
;;;474                }
;;;475                
;;;476                case RMP_THD_DELAYED:RMP_COVERAGE_MARKER();break;
;;;477                /* Should not get here */
;;;478                default:while(1);
000038  e7fe              B        |L69.56|
                  |L69.58|
00003a  e9d01200          LDRD     r1,r2,[r0,#0]
00003e  6011              STR      r1,[r2,#0]
000040  604a              STR      r2,[r1,#4]
                  |L69.66|
000042  6385              STR      r5,[r0,#0x38]         ;472
                  |L69.68|
;;;479            }
;;;480    
;;;481            RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
000044  6981              LDR      r1,[r0,#0x18]
000046  f02101ff          BIC      r1,r1,#0xff
00004a  1c49              ADDS     r1,r1,#1
;;;482            /* Set to ready if not suspended */
;;;483            _RMP_Set_Rdy(Thread);
00004c  6181              STR      r1,[r0,#0x18]
00004e  f7fffffe          BL       _RMP_Set_Rdy
                  |L69.82|
000052  6860              LDR      r0,[r4,#4]            ;443  ; RMP_Delay
000054  42a0              CMP      r0,r4                 ;443
000056  d1d8              BNE      |L69.10|
                  |L69.88|
;;;484        }
;;;485    }
000058  bd70              POP      {r4-r6,pc}
;;;486    /* Begin Function:_RMP_Timer_Proc ********************************************/
                          ENDP

00005a  0000              DCW      0x0000
                  |L69.92|
                          DCD      ||.data||+0x20

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;1994   ******************************************************************************/
;;;1995   int main(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1996   {
;;;1997       rmp_ptr_t Count;
;;;1998       
;;;1999   #ifdef RMP_COVERAGE
;;;2000       /* Initialize coverage markers if coverage enabled */
;;;2001       for(Count=0;Count<RMP_COVERAGE_LINES;Count++)
;;;2002           RMP_Coverage[Count]=0;
;;;2003   #endif
;;;2004       
;;;2005       /* Initialize the kernel data structures first */
;;;2006       _RMP_Low_Level_Init();
000004  f7fffffe          BL       _RMP_Low_Level_Init
;;;2007       
;;;2008   #if(RMP_USE_HOOKS==RMP_TRUE)
;;;2009       RMP_Start_Hook();
;;;2010   #endif
;;;2011       
;;;2012       RMP_Tick=0;
000008  4c1d              LDR      r4,|L70.128|
00000a  2500              MOVS     r5,#0
00000c  6165              STR      r5,[r4,#0x14]  ; RMP_Tick
;;;2013       /* Now initialize the kernel data structures */
;;;2014       RMP_Sched_Lock_Cnt=0;
00000e  6065              STR      r5,[r4,#4]  ; RMP_Sched_Lock_Cnt
;;;2015       RMP_Sched_Locked=0;
000010  60a5              STR      r5,[r4,#8]  ; RMP_Sched_Locked
;;;2016       RMP_Sched_Pend=0;
000012  60e5              STR      r5,[r4,#0xc]  ; RMP_Sched_Pend
;;;2017       RMP_Timer_Pend=0;
000014  6125              STR      r5,[r4,#0x10]  ; RMP_Timer_Pend
;;;2018       
;;;2019       /* Linked lists */
;;;2020       RMP_List_Crt(&RMP_Delay);
000016  f1040020          ADD      r0,r4,#0x20
00001a  6000              STR      r0,[r0,#0]
00001c  6040              STR      r0,[r0,#4]
;;;2021       for(Count=0;Count<RMP_MAX_PREEMPT_PRIO;Count++)
00001e  ea4f0105          MOV.W    r1,r5
;;;2022           RMP_List_Crt(&RMP_Run[Count]);
000022  4f18              LDR      r7,|L70.132|
                  |L70.36|
000024  eb0700c1          ADD      r0,r7,r1,LSL #3
000028  6000              STR      r0,[r0,#0]
00002a  6040              STR      r0,[r0,#4]
00002c  1c49              ADDS     r1,r1,#1
00002e  2920              CMP      r1,#0x20              ;2021
000030  d3f8              BCC      |L70.36|
;;;2023       for(Count=0;Count<RMP_BITMAP_SIZE;Count++)
;;;2024           RMP_Bitmap[Count]=0;
000032  4e13              LDR      r6,|L70.128|
000034  6035              STR      r5,[r6,#0]
;;;2025           
;;;2026       /* Now boot into the first thread */
;;;2027       RMP_Clear(&RMP_Init_Thd,sizeof(struct RMP_Thd));
000036  213c              MOVS     r1,#0x3c
000038  4813              LDR      r0,|L70.136|
00003a  f7fffffe          BL       RMP_Clear
;;;2028       RMP_Init_Thd.Prio=0;
00003e  4b12              LDR      r3,|L70.136|
;;;2029       RMP_Init_Thd.Slices=10;
000040  200a              MOVS     r0,#0xa
;;;2030       RMP_Init_Thd.Slices_Left=10;
;;;2031       RMP_Init_Thd.State=RMP_THD_RUNNING;
000042  2201              MOVS     r2,#1
;;;2032       RMP_Init_Thd.Stack=RMP_INIT_STACK;
000044  f1a30144          SUB      r1,r3,#0x44
000048  625d              STR      r5,[r3,#0x24]         ;2028  ; RMP_Init_Thd
00004a  61d8              STR      r0,[r3,#0x1c]         ;2029  ; RMP_Init_Thd
00004c  6218              STR      r0,[r3,#0x20]         ;2030  ; RMP_Init_Thd
00004e  619a              STR      r2,[r3,#0x18]         ;2031  ; RMP_Init_Thd
000050  6359              STR      r1,[r3,#0x34]  ; RMP_Init_Thd
;;;2033       
;;;2034       /* Initialize sending list */
;;;2035       RMP_List_Crt(&(RMP_Init_Thd.Snd_List));
000052  f1010054          ADD      r0,r1,#0x54
000056  6000              STR      r0,[r0,#0]
000058  6040              STR      r0,[r0,#4]
;;;2036       
;;;2037       /* Insert this into the corresponding runqueue */
;;;2038       RMP_List_Ins(&(RMP_Init_Thd.Run_Head),RMP_Run[0].Prev,&(RMP_Run[0]));
00005a  6839              LDR      r1,[r7,#0]  ; RMP_Run
00005c  3810              SUBS     r0,r0,#0x10
00005e  4a09              LDR      r2,|L70.132|
000060  f7fffffe          BL       RMP_List_Ins
;;;2039       /* Set this runlevel as active - in fact it is always active */
;;;2040       RMP_Bitmap[0]|=1;
000064  6830              LDR      r0,[r6,#0]  ; RMP_Bitmap
000066  f0400001          ORR      r0,r0,#1
00006a  6030              STR      r0,[r6,#0]  ; RMP_Bitmap
;;;2041       
;;;2042       /* Set current thread and stack */
;;;2043       RMP_Cur_Thd=(struct RMP_Thd*)(&RMP_Init_Thd);
00006c  61a3              STR      r3,[r4,#0x18]  ; RMP_Cur_Thd
;;;2044       RMP_Cur_SP=RMP_Init_Thd.Stack;
00006e  6b58              LDR      r0,[r3,#0x34]  ; RMP_Init_Thd
000070  61e0              STR      r0,[r4,#0x1c]  ; RMP_Cur_SP
;;;2045       
;;;2046       /* Now jump to the user function and will never return. Initialization of stack is not needed */
;;;2047       _RMP_Start((rmp_ptr_t)RMP_Init, (rmp_ptr_t)RMP_Init_Thd.Stack);
000072  6b59              LDR      r1,[r3,#0x34]  ; RMP_Init_Thd
000074  4805              LDR      r0,|L70.140|
000076  f7fffffe          BL       _RMP_Start
;;;2048       
;;;2049       return 0;
00007a  2000              MOVS     r0,#0
;;;2050   }
00007c  e8bd81f0          POP      {r4-r8,pc}
;;;2051   /* End Function:main *********************************************************/
                          ENDP

                  |L70.128|
                          DCD      ||.data||
                  |L70.132|
                          DCD      ||.bss||
                  |L70.136|
                          DCD      ||.bss||+0x200
                  |L70.140|
                          DCD      RMP_Init

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  RMP_Run
                          %        256
                  RMP_Init_Stack
                          %        256
                  RMP_Init_Thd
                          %        60

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  RMP_RBIT_Table
000000  008040c0          DCB      0x00,0x80,0x40,0xc0
000004  20a060e0          DCB      0x20,0xa0,0x60,0xe0
000008  109050d0          DCB      0x10,0x90,0x50,0xd0
00000c  30b070f0          DCB      0x30,0xb0,0x70,0xf0
000010  088848c8          DCB      0x08,0x88,0x48,0xc8
000014  28a868e8          DCB      0x28,0xa8,0x68,0xe8
000018  189858d8          DCB      0x18,0x98,0x58,0xd8
00001c  38b878f8          DCB      0x38,0xb8,0x78,0xf8
000020  048444c4          DCB      0x04,0x84,0x44,0xc4
000024  24a464e4          DCB      0x24,0xa4,0x64,0xe4
000028  149454d4          DCB      0x14,0x94,0x54,0xd4
00002c  34b474f4          DCB      0x34,0xb4,0x74,0xf4
000030  0c8c4ccc          DCB      0x0c,0x8c,0x4c,0xcc
000034  2cac6cec          DCB      0x2c,0xac,0x6c,0xec
000038  1c9c5cdc          DCB      0x1c,0x9c,0x5c,0xdc
00003c  3cbc7cfc          DCB      0x3c,0xbc,0x7c,0xfc
000040  028242c2          DCB      0x02,0x82,0x42,0xc2
000044  22a262e2          DCB      0x22,0xa2,0x62,0xe2
000048  129252d2          DCB      0x12,0x92,0x52,0xd2
00004c  32b272f2          DCB      0x32,0xb2,0x72,0xf2
000050  0a8a4aca          DCB      0x0a,0x8a,0x4a,0xca
000054  2aaa6aea          DCB      0x2a,0xaa,0x6a,0xea
000058  1a9a5ada          DCB      0x1a,0x9a,0x5a,0xda
00005c  3aba7afa          DCB      0x3a,0xba,0x7a,0xfa
000060  068646c6          DCB      0x06,0x86,0x46,0xc6
000064  26a666e6          DCB      0x26,0xa6,0x66,0xe6
000068  169656d6          DCB      0x16,0x96,0x56,0xd6
00006c  36b676f6          DCB      0x36,0xb6,0x76,0xf6
000070  0e8e4ece          DCB      0x0e,0x8e,0x4e,0xce
000074  2eae6eee          DCB      0x2e,0xae,0x6e,0xee
000078  1e9e5ede          DCB      0x1e,0x9e,0x5e,0xde
00007c  3ebe7efe          DCB      0x3e,0xbe,0x7e,0xfe
000080  018141c1          DCB      0x01,0x81,0x41,0xc1
000084  21a161e1          DCB      0x21,0xa1,0x61,0xe1
000088  119151d1          DCB      0x11,0x91,0x51,0xd1
00008c  31b171f1          DCB      0x31,0xb1,0x71,0xf1
000090  098949c9          DCB      0x09,0x89,0x49,0xc9
000094  29a969e9          DCB      0x29,0xa9,0x69,0xe9
000098  199959d9          DCB      0x19,0x99,0x59,0xd9
00009c  39b979f9          DCB      0x39,0xb9,0x79,0xf9
0000a0  058545c5          DCB      0x05,0x85,0x45,0xc5
0000a4  25a565e5          DCB      0x25,0xa5,0x65,0xe5
0000a8  159555d5          DCB      0x15,0x95,0x55,0xd5
0000ac  35b575f5          DCB      0x35,0xb5,0x75,0xf5
0000b0  0d8d4dcd          DCB      0x0d,0x8d,0x4d,0xcd
0000b4  2dad6ded          DCB      0x2d,0xad,0x6d,0xed
0000b8  1d9d5ddd          DCB      0x1d,0x9d,0x5d,0xdd
0000bc  3dbd7dfd          DCB      0x3d,0xbd,0x7d,0xfd
0000c0  038343c3          DCB      0x03,0x83,0x43,0xc3
0000c4  23a363e3          DCB      0x23,0xa3,0x63,0xe3
0000c8  139353d3          DCB      0x13,0x93,0x53,0xd3
0000cc  33b373f3          DCB      0x33,0xb3,0x73,0xf3
0000d0  0b8b4bcb          DCB      0x0b,0x8b,0x4b,0xcb
0000d4  2bab6beb          DCB      0x2b,0xab,0x6b,0xeb
0000d8  1b9b5bdb          DCB      0x1b,0x9b,0x5b,0xdb
0000dc  3bbb7bfb          DCB      0x3b,0xbb,0x7b,0xfb
0000e0  078747c7          DCB      0x07,0x87,0x47,0xc7
0000e4  27a767e7          DCB      0x27,0xa7,0x67,0xe7
0000e8  179757d7          DCB      0x17,0x97,0x57,0xd7
0000ec  37b777f7          DCB      0x37,0xb7,0x77,0xf7
0000f0  0f8f4fcf          DCB      0x0f,0x8f,0x4f,0xcf
0000f4  2faf6fef          DCB      0x2f,0xaf,0x6f,0xef
0000f8  1f9f5fdf          DCB      0x1f,0x9f,0x5f,0xdf
0000fc  3fbf7fff          DCB      0x3f,0xbf,0x7f,0xff
                  CRC16_High
000100  00c18140          DCB      0x00,0xc1,0x81,0x40
000104  01c08041          DCB      0x01,0xc0,0x80,0x41
000108  01c08041          DCB      0x01,0xc0,0x80,0x41
00010c  00c18140          DCB      0x00,0xc1,0x81,0x40
000110  01c08041          DCB      0x01,0xc0,0x80,0x41
000114  00c18140          DCB      0x00,0xc1,0x81,0x40
000118  00c18140          DCB      0x00,0xc1,0x81,0x40
00011c  01c08041          DCB      0x01,0xc0,0x80,0x41
000120  01c08041          DCB      0x01,0xc0,0x80,0x41
000124  00c18140          DCB      0x00,0xc1,0x81,0x40
000128  00c18140          DCB      0x00,0xc1,0x81,0x40
00012c  01c08041          DCB      0x01,0xc0,0x80,0x41
000130  00c18140          DCB      0x00,0xc1,0x81,0x40
000134  01c08041          DCB      0x01,0xc0,0x80,0x41
000138  01c08041          DCB      0x01,0xc0,0x80,0x41
00013c  00c18140          DCB      0x00,0xc1,0x81,0x40
000140  01c08041          DCB      0x01,0xc0,0x80,0x41
000144  00c18140          DCB      0x00,0xc1,0x81,0x40
000148  00c18140          DCB      0x00,0xc1,0x81,0x40
00014c  01c08041          DCB      0x01,0xc0,0x80,0x41
000150  00c18140          DCB      0x00,0xc1,0x81,0x40
000154  01c08041          DCB      0x01,0xc0,0x80,0x41
000158  01c08041          DCB      0x01,0xc0,0x80,0x41
00015c  00c18140          DCB      0x00,0xc1,0x81,0x40
000160  00c18140          DCB      0x00,0xc1,0x81,0x40
000164  01c08041          DCB      0x01,0xc0,0x80,0x41
000168  01c08041          DCB      0x01,0xc0,0x80,0x41
00016c  00c18140          DCB      0x00,0xc1,0x81,0x40
000170  01c08041          DCB      0x01,0xc0,0x80,0x41
000174  00c18140          DCB      0x00,0xc1,0x81,0x40
000178  00c18140          DCB      0x00,0xc1,0x81,0x40
00017c  01c08041          DCB      0x01,0xc0,0x80,0x41
000180  01c08041          DCB      0x01,0xc0,0x80,0x41
000184  00c18140          DCB      0x00,0xc1,0x81,0x40
000188  00c18140          DCB      0x00,0xc1,0x81,0x40
00018c  01c08041          DCB      0x01,0xc0,0x80,0x41
000190  00c18140          DCB      0x00,0xc1,0x81,0x40
000194  01c08041          DCB      0x01,0xc0,0x80,0x41
000198  01c08041          DCB      0x01,0xc0,0x80,0x41
00019c  00c18140          DCB      0x00,0xc1,0x81,0x40
0001a0  00c18140          DCB      0x00,0xc1,0x81,0x40
0001a4  01c08041          DCB      0x01,0xc0,0x80,0x41
0001a8  01c08041          DCB      0x01,0xc0,0x80,0x41
0001ac  00c18140          DCB      0x00,0xc1,0x81,0x40
0001b0  01c08041          DCB      0x01,0xc0,0x80,0x41
0001b4  00c18140          DCB      0x00,0xc1,0x81,0x40
0001b8  00c18140          DCB      0x00,0xc1,0x81,0x40
0001bc  01c08041          DCB      0x01,0xc0,0x80,0x41
0001c0  00c18140          DCB      0x00,0xc1,0x81,0x40
0001c4  01c08041          DCB      0x01,0xc0,0x80,0x41
0001c8  01c08041          DCB      0x01,0xc0,0x80,0x41
0001cc  00c18140          DCB      0x00,0xc1,0x81,0x40
0001d0  01c08041          DCB      0x01,0xc0,0x80,0x41
0001d4  00c18140          DCB      0x00,0xc1,0x81,0x40
0001d8  00c18140          DCB      0x00,0xc1,0x81,0x40
0001dc  01c08041          DCB      0x01,0xc0,0x80,0x41
0001e0  01c08041          DCB      0x01,0xc0,0x80,0x41
0001e4  00c18140          DCB      0x00,0xc1,0x81,0x40
0001e8  00c18140          DCB      0x00,0xc1,0x81,0x40
0001ec  01c08041          DCB      0x01,0xc0,0x80,0x41
0001f0  00c18140          DCB      0x00,0xc1,0x81,0x40
0001f4  01c08041          DCB      0x01,0xc0,0x80,0x41
0001f8  01c08041          DCB      0x01,0xc0,0x80,0x41
0001fc  00c18140          DCB      0x00,0xc1,0x81,0x40
                  Arrow_B
000200  00101120          DCB      0x00,0x10,0x11,0x20
000204  22303340          DCB      0x22,0x30,0x33,0x40
000208  44505560          DCB      0x44,0x50,0x55,0x60
00020c  66707780          DCB      0x66,0x70,0x77,0x80
000210  88909596          DCB      0x88,0x90,0x95,0x96
000214  979899a0          DCB      0x97,0x98,0x99,0xa0
000218  a2a3a5b0          DCB      0xa2,0xa3,0xa5,0xb0
00021c  b1b3b6c0          DCB      0xb1,0xb3,0xb6,0xc0
000220  c1c4c6d0          DCB      0xc1,0xc4,0xc6,0xd0
000224  d4d7e5e7          DCB      0xd4,0xd7,0xe5,0xe7
000228  f5f6              DCB      0xf5,0xf6
                  Arrow_W
00022a  2131              DCB      0x21,0x31
00022c  32414243          DCB      0x32,0x41,0x42,0x43
000230  51525354          DCB      0x51,0x52,0x53,0x54
000234  61626364          DCB      0x61,0x62,0x63,0x64
000238  65717273          DCB      0x65,0x71,0x72,0x73
00023c  74757681          DCB      0x74,0x75,0x76,0x81
000240  82838485          DCB      0x82,0x83,0x84,0x85
000244  86879192          DCB      0x86,0x87,0x91,0x92
000248  9394a1a4          DCB      0x93,0x94,0xa1,0xa4
00024c  b4b5c5d5          DCB      0xb4,0xb5,0xc5,0xd5
000250  d6e6              DCB      0xd6,0xe6
                  Busy_B
000252  0a0b              DCB      0x0a,0x0b
000254  0c0d0e1a          DCB      0x0c,0x0d,0x0e,0x1a
000258  1b1d1e2a          DCB      0x1b,0x1d,0x1e,0x2a
00025c  2c2e3b3d          DCB      0x2c,0x2e,0x3b,0x3d
000260  4c5b5d6a          DCB      0x4c,0x5b,0x5d,0x6a
000264  6e7a7c7e          DCB      0x6e,0x7a,0x7c,0x7e
000268  8a8b8c8d          DCB      0x8a,0x8b,0x8c,0x8d
00026c  8e                DCB      0x8e
                  Busy_W
00026d  1c2b2d            DCB      0x1c,0x2b,0x2d
000270  3c5c6b6c          DCB      0x3c,0x5c,0x6b,0x6c
000274  6d7b7d            DCB      0x6d,0x7b,0x7d
                  Question
000277  0b                DCB      0x0b
000278  0c0d1a1b          DCB      0x0c,0x0d,0x1a,0x1b
00027c  1c1d1e29          DCB      0x1c,0x1d,0x1e,0x29
000280  2a2b2d2e          DCB      0x2a,0x2b,0x2d,0x2e
000284  2f393a3e          DCB      0x2f,0x39,0x3a,0x3e
000288  3f4a4d4e          DCB      0x3f,0x4a,0x4d,0x4e
00028c  4f5c5d5e          DCB      0x4f,0x5c,0x5d,0x5e
000290  6c6d8d8e          DCB      0x6c,0x6d,0x8d,0x8e
000294  9d9e              DCB      0x9d,0x9e
                  Hand_B
000296  0506              DCB      0x05,0x06
000298  14172427          DCB      0x14,0x17,0x24,0x27
00029c  34373944          DCB      0x34,0x37,0x39,0x44
0002a0  47484a4c          DCB      0x47,0x48,0x4a,0x4c
0002a4  51525457          DCB      0x51,0x52,0x54,0x57
0002a8  5a5b5d5e          DCB      0x5a,0x5b,0x5d,0x5e
0002ac  60636467          DCB      0x60,0x63,0x64,0x67
0002b0  6a6d6f70          DCB      0x6a,0x6d,0x6f,0x70
0002b4  74777a7d          DCB      0x74,0x77,0x7a,0x7d
0002b8  7f808f90          DCB      0x7f,0x80,0x8f,0x90
0002bc  9fa0afb0          DCB      0x9f,0xa0,0xaf,0xb0
0002c0  bfc1ced1          DCB      0xbf,0xc1,0xce,0xd1
0002c4  d2d3d4d5          DCB      0xd2,0xd3,0xd4,0xd5
0002c8  d6d7d8d9          DCB      0xd6,0xd7,0xd8,0xd9
0002cc  dadbdcdd          DCB      0xda,0xdb,0xdc,0xdd
0002d0  dee1eef2          DCB      0xde,0xe1,0xee,0xf2
0002d4  f3f4f5f6          DCB      0xf3,0xf4,0xf5,0xf6
0002d8  f7f8f9fa          DCB      0xf7,0xf8,0xf9,0xfa
0002dc  fbfcfd            DCB      0xfb,0xfc,0xfd
                  Hand_W
0002df  15                DCB      0x15
0002e0  16252635          DCB      0x16,0x25,0x26,0x35
0002e4  36454649          DCB      0x36,0x45,0x46,0x49
0002e8  55565859          DCB      0x55,0x56,0x58,0x59
0002ec  5c616265          DCB      0x5c,0x61,0x62,0x65
0002f0  6668696b          DCB      0x66,0x68,0x69,0x6b
0002f4  6c6e7172          DCB      0x6c,0x6e,0x71,0x72
0002f8  73757678          DCB      0x73,0x75,0x76,0x78
0002fc  797b7c7e          DCB      0x79,0x7b,0x7c,0x7e
000300  81828384          DCB      0x81,0x82,0x83,0x84
000304  85868788          DCB      0x85,0x86,0x87,0x88
000308  898a8b8c          DCB      0x89,0x8a,0x8b,0x8c
00030c  8d8e9192          DCB      0x8d,0x8e,0x91,0x92
000310  93949596          DCB      0x93,0x94,0x95,0x96
000314  9798999a          DCB      0x97,0x98,0x99,0x9a
000318  9b9c9d9e          DCB      0x9b,0x9c,0x9d,0x9e
00031c  a1a2a3a4          DCB      0xa1,0xa2,0xa3,0xa4
000320  a5a6a7a8          DCB      0xa5,0xa6,0xa7,0xa8
000324  a9aaabac          DCB      0xa9,0xaa,0xab,0xac
000328  adaeb1b2          DCB      0xad,0xae,0xb1,0xb2
00032c  b3b4b5b6          DCB      0xb3,0xb4,0xb5,0xb6
000330  b7b8b9ba          DCB      0xb7,0xb8,0xb9,0xba
000334  bbbcbdbe          DCB      0xbb,0xbc,0xbd,0xbe
000338  c2c3c4c5          DCB      0xc2,0xc3,0xc4,0xc5
00033c  c6c7c8c9          DCB      0xc6,0xc7,0xc8,0xc9
000340  cacbcccd          DCB      0xca,0xcb,0xcc,0xcd
000344  e2e3e4e5          DCB      0xe2,0xe3,0xe4,0xe5
000348  e6e7e8e9          DCB      0xe6,0xe7,0xe8,0xe9
00034c  eaebeced          DCB      0xea,0xeb,0xec,0xed
                  Text
000350  00010204          DCB      0x00,0x01,0x02,0x04
000354  05061323          DCB      0x05,0x06,0x13,0x23
000358  33435363          DCB      0x33,0x43,0x53,0x63
00035c  738393a3          DCB      0x73,0x83,0x93,0xa3
000360  b3c3d3e3          DCB      0xb3,0xc3,0xd3,0xe3
000364  f0f1f2f4          DCB      0xf0,0xf1,0xf2,0xf4
000368  f5f6              DCB      0xf5,0xf6
                  Stop_B
00036a  0506              DCB      0x05,0x06
00036c  07081314          DCB      0x07,0x08,0x13,0x14
000370  15161718          DCB      0x15,0x16,0x17,0x18
000374  191a2223          DCB      0x19,0x1a,0x22,0x23
000378  24292a2b          DCB      0x24,0x29,0x2a,0x2b
00037c  31323334          DCB      0x31,0x32,0x33,0x34
000380  3a3b3c41          DCB      0x3a,0x3b,0x3c,0x41
000384  42434445          DCB      0x42,0x43,0x44,0x45
000388  4b4c5051          DCB      0x4b,0x4c,0x50,0x51
00038c  5455565c          DCB      0x54,0x55,0x56,0x5c
000390  5d606165          DCB      0x5d,0x60,0x61,0x65
000394  66676c6d          DCB      0x66,0x67,0x6c,0x6d
000398  70717677          DCB      0x70,0x71,0x76,0x77
00039c  787c7d80          DCB      0x78,0x7c,0x7d,0x80
0003a0  81878889          DCB      0x81,0x87,0x88,0x89
0003a4  8c8d9192          DCB      0x8c,0x8d,0x91,0x92
0003a8  98999a9b          DCB      0x98,0x99,0x9a,0x9b
0003ac  9ca1a2a3          DCB      0x9c,0xa1,0xa2,0xa3
0003b0  a9aaabac          DCB      0xa9,0xaa,0xab,0xac
0003b4  b2b3b4b9          DCB      0xb2,0xb3,0xb4,0xb9
0003b8  babbc3c4          DCB      0xba,0xbb,0xc3,0xc4
0003bc  c5c6c7c8          DCB      0xc5,0xc6,0xc7,0xc8
0003c0  c9cad5d6          DCB      0xc9,0xca,0xd5,0xd6
0003c4  d7d8              DCB      0xd7,0xd8
                  Stop_W
0003c6  2526              DCB      0x25,0x26
0003c8  27283536          DCB      0x27,0x28,0x35,0x36
0003cc  37383946          DCB      0x37,0x38,0x39,0x46
0003d0  4748494a          DCB      0x47,0x48,0x49,0x4a
0003d4  52535758          DCB      0x52,0x53,0x57,0x58
0003d8  595a5b62          DCB      0x59,0x5a,0x5b,0x62
0003dc  63646869          DCB      0x63,0x64,0x68,0x69
0003e0  6a6b7273          DCB      0x6a,0x6b,0x72,0x73
0003e4  7475797a          DCB      0x74,0x75,0x79,0x7a
0003e8  7b828384          DCB      0x7b,0x82,0x83,0x84
0003ec  85868a8b          DCB      0x85,0x86,0x8a,0x8b
0003f0  93949596          DCB      0x93,0x94,0x95,0x96
0003f4  97a4a5a6          DCB      0x97,0xa4,0xa5,0xa6
0003f8  a7a8b5b6          DCB      0xa7,0xa8,0xb5,0xb6
0003fc  b7b8              DCB      0xb7,0xb8
                  Adj_ALL
0003fe  0716              DCB      0x07,0x16
000400  17182526          DCB      0x17,0x18,0x25,0x26
000404  27282937          DCB      0x27,0x28,0x29,0x37
000408  4752575c          DCB      0x47,0x52,0x57,0x5c
00040c  6162676c          DCB      0x61,0x62,0x67,0x6c
000410  6d707172          DCB      0x6d,0x70,0x71,0x72
000414  73747576          DCB      0x73,0x74,0x75,0x76
000418  7778797a          DCB      0x77,0x78,0x79,0x7a
00041c  7b7c7d7e          DCB      0x7b,0x7c,0x7d,0x7e
000420  8182878c          DCB      0x81,0x82,0x87,0x8c
000424  8d92979c          DCB      0x8d,0x92,0x97,0x9c
000428  a7b7c5c6          DCB      0xa7,0xb7,0xc5,0xc6
00042c  c7c8c9d6          DCB      0xc7,0xc8,0xc9,0xd6
000430  d7d8e7            DCB      0xd7,0xd8,0xe7
                  Adj_LR
000433  52                DCB      0x52
000434  5d61626d          DCB      0x5d,0x61,0x62,0x6d
000438  6e707172          DCB      0x6e,0x70,0x71,0x72
00043c  73747576          DCB      0x73,0x74,0x75,0x76
000440  7778797a          DCB      0x77,0x78,0x79,0x7a
000444  7b7c7d7e          DCB      0x7b,0x7c,0x7d,0x7e
000448  7f81828d          DCB      0x7f,0x81,0x82,0x8d
00044c  8e929d            DCB      0x8e,0x92,0x9d
                  Adj_UD
00044f  07                DCB      0x07
000450  16171825          DCB      0x16,0x17,0x18,0x25
000454  26272829          DCB      0x26,0x27,0x28,0x29
000458  37475767          DCB      0x37,0x47,0x57,0x67
00045c  778797a7          DCB      0x77,0x87,0x97,0xa7
000460  b7c7d5d6          DCB      0xb7,0xc7,0xd5,0xd6
000464  d7d8d9e6          DCB      0xd7,0xd8,0xd9,0xe6
000468  e7e8f7            DCB      0xe7,0xe8,0xf7
                  Adj_BRUL
00046b  00                DCB      0x00
00046c  01020304          DCB      0x01,0x02,0x03,0x04
000470  10111213          DCB      0x10,0x11,0x12,0x13
000474  20212230          DCB      0x20,0x21,0x22,0x30
000478  31334044          DCB      0x31,0x33,0x40,0x44
00047c  55667788          DCB      0x55,0x66,0x77,0x88
000480  99aabbbf          DCB      0x99,0xaa,0xbb,0xbf
000484  cccecfdd          DCB      0xcc,0xce,0xcf,0xdd
000488  dedfeced          DCB      0xde,0xdf,0xec,0xed
00048c  eeeffbfc          DCB      0xee,0xef,0xfb,0xfc
000490  fdfeff            DCB      0xfd,0xfe,0xff
                  Adj_BLUR
000493  0b                DCB      0x0b
000494  0c0d0e0f          DCB      0x0c,0x0d,0x0e,0x0f
000498  1c1d1e1f          DCB      0x1c,0x1d,0x1e,0x1f
00049c  2d2e2f3c          DCB      0x2d,0x2e,0x2f,0x3c
0004a0  3e3f4b4f          DCB      0x3e,0x3f,0x4b,0x4f
0004a4  5a697887          DCB      0x5a,0x69,0x78,0x87
0004a8  96a5b0b4          DCB      0x96,0xa5,0xb0,0xb4
0004ac  c0c1c3d0          DCB      0xc0,0xc1,0xc3,0xd0
0004b0  d1d2e0e1          DCB      0xd1,0xd2,0xe0,0xe1
0004b4  e2e3f0f1          DCB      0xe2,0xe3,0xf0,0xf1
0004b8  f2f3f4            DCB      0xf2,0xf3,0xf4
                  Cross
0004bb  07                DCB      0x07
0004bc  17273746          DCB      0x17,0x27,0x37,0x46
0004c0  47485557          DCB      0x47,0x48,0x55,0x57
0004c4  59646a70          DCB      0x59,0x64,0x6a,0x70
0004c8  71727374          DCB      0x71,0x72,0x73,0x74
0004cc  7577797a          DCB      0x75,0x77,0x79,0x7a
0004d0  7b7c7d7e          DCB      0x7b,0x7c,0x7d,0x7e
0004d4  848a9597          DCB      0x84,0x8a,0x95,0x97
0004d8  99a6a7a8          DCB      0x99,0xa6,0xa7,0xa8
0004dc  b7c7d7e7          DCB      0xb7,0xc7,0xd7,0xe7
0004e0  00c0c101          DCB      0x00,0xc0,0xc1,0x01
0004e4  c30302c2          DCB      0xc3,0x03,0x02,0xc2
0004e8  c60607c7          DCB      0xc6,0x06,0x07,0xc7
0004ec  05c5c404          DCB      0x05,0xc5,0xc4,0x04
0004f0  cc0c0dcd          DCB      0xcc,0x0c,0x0d,0xcd
0004f4  0fcfce0e          DCB      0x0f,0xcf,0xce,0x0e
0004f8  0acacb0b          DCB      0x0a,0xca,0xcb,0x0b
0004fc  c90908c8          DCB      0xc9,0x09,0x08,0xc8
000500  d81819d9          DCB      0xd8,0x18,0x19,0xd9
000504  1bdbda1a          DCB      0x1b,0xdb,0xda,0x1a
000508  1ededf1f          DCB      0x1e,0xde,0xdf,0x1f
00050c  dd1d1cdc          DCB      0xdd,0x1d,0x1c,0xdc
000510  14d4d515          DCB      0x14,0xd4,0xd5,0x15
000514  d71716d6          DCB      0xd7,0x17,0x16,0xd6
000518  d21213d3          DCB      0xd2,0x12,0x13,0xd3
00051c  11d1d010          DCB      0x11,0xd1,0xd0,0x10
000520  f03031f1          DCB      0xf0,0x30,0x31,0xf1
000524  33f3f232          DCB      0x33,0xf3,0xf2,0x32
000528  36f6f737          DCB      0x36,0xf6,0xf7,0x37
00052c  f53534f4          DCB      0xf5,0x35,0x34,0xf4
000530  3cfcfd3d          DCB      0x3c,0xfc,0xfd,0x3d
000534  ff3f3efe          DCB      0xff,0x3f,0x3e,0xfe
000538  fa3a3bfb          DCB      0xfa,0x3a,0x3b,0xfb
00053c  39f9f838          DCB      0x39,0xf9,0xf8,0x38
000540  28e8e929          DCB      0x28,0xe8,0xe9,0x29
000544  eb2b2aea          DCB      0xeb,0x2b,0x2a,0xea
000548  ee2e2fef          DCB      0xee,0x2e,0x2f,0xef
00054c  2dedec2c          DCB      0x2d,0xed,0xec,0x2c
000550  e42425e5          DCB      0xe4,0x24,0x25,0xe5
000554  27e7e626          DCB      0x27,0xe7,0xe6,0x26
000558  22e2e323          DCB      0x22,0xe2,0xe3,0x23
00055c  e12120e0          DCB      0xe1,0x21,0x20,0xe0
000560  a06061a1          DCB      0xa0,0x60,0x61,0xa1
000564  63a3a262          DCB      0x63,0xa3,0xa2,0x62
000568  66a6a767          DCB      0x66,0xa6,0xa7,0x67
00056c  a56564a4          DCB      0xa5,0x65,0x64,0xa4
000570  6cacad6d          DCB      0x6c,0xac,0xad,0x6d
000574  af6f6eae          DCB      0xaf,0x6f,0x6e,0xae
000578  aa6a6bab          DCB      0xaa,0x6a,0x6b,0xab
00057c  69a9a868          DCB      0x69,0xa9,0xa8,0x68
000580  78b8b979          DCB      0x78,0xb8,0xb9,0x79
000584  bb7b7aba          DCB      0xbb,0x7b,0x7a,0xba
000588  be7e7fbf          DCB      0xbe,0x7e,0x7f,0xbf
00058c  7dbdbc7c          DCB      0x7d,0xbd,0xbc,0x7c
000590  b47475b5          DCB      0xb4,0x74,0x75,0xb5
000594  77b7b676          DCB      0x77,0xb7,0xb6,0x76
000598  72b2b373          DCB      0x72,0xb2,0xb3,0x73
00059c  b17170b0          DCB      0xb1,0x71,0x70,0xb0
0005a0  50909151          DCB      0x50,0x90,0x91,0x51
0005a4  93535292          DCB      0x93,0x53,0x52,0x92
0005a8  96565797          DCB      0x96,0x56,0x57,0x97
0005ac  55959454          DCB      0x55,0x95,0x94,0x54
0005b0  9c5c5d9d          DCB      0x9c,0x5c,0x5d,0x9d
0005b4  5f9f9e5e          DCB      0x5f,0x9f,0x9e,0x5e
0005b8  5a9a9b5b          DCB      0x5a,0x9a,0x9b,0x5b
0005bc  99595898          DCB      0x99,0x59,0x58,0x98
0005c0  88484989          DCB      0x88,0x48,0x49,0x89
0005c4  4b8b8a4a          DCB      0x4b,0x8b,0x8a,0x4a
0005c8  4e8e8f4f          DCB      0x4e,0x8e,0x8f,0x4f
0005cc  8d4d4c8c          DCB      0x8d,0x4d,0x4c,0x8c
0005d0  44848545          DCB      0x44,0x84,0x85,0x45
0005d4  87474686          DCB      0x87,0x47,0x46,0x86
0005d8  82424383          DCB      0x82,0x42,0x43,0x83
0005dc  41818040          DCB      0x41,0x81,0x80,0x40

                          AREA ||.data||, DATA, ALIGN=2

                  RMP_Bitmap
                          DCD      0x00000000
                  RMP_Sched_Lock_Cnt
                          DCD      0x00000000
                  RMP_Sched_Locked
                          DCD      0x00000000
                  RMP_Sched_Pend
                          DCD      0x00000000
                  RMP_Timer_Pend
                          DCD      0x00000000
                  RMP_Tick
                          DCD      0x00000000
                  RMP_Cur_Thd
                          DCD      0x00000000
                  RMP_Cur_SP
                          DCD      0x00000000
                  RMP_Delay
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\..\\MProkaron\\Kernel\\rmp_kernel.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_rmp_kernel_c_346ad0e8____REV16|
#line 468 "D:\\Program_Files_x86\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.3.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___12_rmp_kernel_c_346ad0e8____REV16| PROC
#line 469

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_rmp_kernel_c_346ad0e8____REVSH|
#line 483
|__asm___12_rmp_kernel_c_346ad0e8____REVSH| PROC
#line 484

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___12_rmp_kernel_c_346ad0e8____RRX|
#line 670
|__asm___12_rmp_kernel_c_346ad0e8____RRX| PROC
#line 671

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
