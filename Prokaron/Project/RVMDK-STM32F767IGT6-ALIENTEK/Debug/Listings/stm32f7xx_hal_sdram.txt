; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f7xx_hal_sdram.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f7xx_hal_sdram.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Core -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Inc -I.\Source -I.\Drivers -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6-ALIENTEK\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f7xx_hal_sdram.crf ..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_sdram.c]
                          THUMB

                          AREA ||i.HAL_SDRAM_DMA_XferCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_DMA_XferCpltCallback PROC
;;;262      */
;;;263    __weak void HAL_SDRAM_DMA_XferCpltCallback(DMA_HandleTypeDef *hdma)
000000  4770              BX       lr
;;;264    {
;;;265      /* Prevent unused argument(s) compilation warning */
;;;266      UNUSED(hdma);
;;;267     
;;;268      /* NOTE: This function Should not be modified, when the callback is needed,
;;;269                the HAL_SDRAM_DMA_XferCpltCallback could be implemented in the user file
;;;270       */ 
;;;271    }
;;;272    
                          ENDP


                          AREA ||i.HAL_SDRAM_DMA_XferErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_DMA_XferErrorCallback PROC
;;;277      */
;;;278    __weak void HAL_SDRAM_DMA_XferErrorCallback(DMA_HandleTypeDef *hdma)
000000  4770              BX       lr
;;;279    {
;;;280      /* Prevent unused argument(s) compilation warning */
;;;281      UNUSED(hdma);
;;;282     
;;;283      /* NOTE: This function Should not be modified, when the callback is needed,
;;;284                the HAL_SDRAM_DMA_XferErrorCallback could be implemented in the user file
;;;285       */ 
;;;286    }
;;;287    
                          ENDP


                          AREA ||i.HAL_SDRAM_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_DeInit PROC
;;;172      */
;;;173    HAL_StatusTypeDef HAL_SDRAM_DeInit(SDRAM_HandleTypeDef *hsdram)
000000  b510              PUSH     {r4,lr}
;;;174    {
000002  4604              MOV      r4,r0
;;;175      /* Initialize the low level hardware (MSP) */
;;;176      HAL_SDRAM_MspDeInit(hsdram);
000004  f7fffffe          BL       HAL_SDRAM_MspDeInit
000008  e9d40100          LDRD     r0,r1,[r4,#0]
;;;177    
;;;178      /* Configure the SDRAM registers with their reset values */
;;;179      FMC_SDRAM_DeInit(hsdram->Instance, hsdram->Init.SDBank);
00000c  f7fffffe          BL       FMC_SDRAM_DeInit
;;;180    
;;;181      /* Reset the SDRAM controller state */
;;;182      hsdram->State = HAL_SDRAM_STATE_RESET;
000010  2000              MOVS     r0,#0
000012  62e0              STR      r0,[r4,#0x2c]
;;;183    
;;;184      /* Release Lock */
;;;185      __HAL_UNLOCK(hsdram);
000014  6320              STR      r0,[r4,#0x30]
;;;186    
;;;187      return HAL_OK;
;;;188    }
000016  bd10              POP      {r4,pc}
;;;189    
                          ENDP


                          AREA ||i.HAL_SDRAM_GetModeStatus||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_GetModeStatus PROC
;;;804      */
;;;805    uint32_t HAL_SDRAM_GetModeStatus(SDRAM_HandleTypeDef *hsdram)
000000  e9d00100          LDRD     r0,r1,[r0,#0]
;;;806    {
;;;807      /* Return the SDRAM memory current mode */
;;;808      return(FMC_SDRAM_GetModeStatus(hsdram->Instance, hsdram->Init.SDBank));
000004  f7ffbffe          B.W      FMC_SDRAM_GetModeStatus
;;;809    }
;;;810    
                          ENDP


                          AREA ||i.HAL_SDRAM_GetState||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_GetState PROC
;;;835      */
;;;836    HAL_SDRAM_StateTypeDef HAL_SDRAM_GetState(SDRAM_HandleTypeDef *hsdram)
000000  6ac0              LDR      r0,[r0,#0x2c]
;;;837    {
;;;838      return hsdram->State;
;;;839    }
000002  4770              BX       lr
;;;840    
                          ENDP


                          AREA ||i.HAL_SDRAM_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_IRQHandler PROC
;;;227    */
;;;228    void HAL_SDRAM_IRQHandler(SDRAM_HandleTypeDef *hsdram)
000000  b510              PUSH     {r4,lr}
;;;229    {
000002  4604              MOV      r4,r0
;;;230      /* Check SDRAM interrupt Rising edge flag */
;;;231      if(__FMC_SDRAM_GET_FLAG(hsdram->Instance, FMC_SDRAM_FLAG_REFRESH_IT))
000004  6800              LDR      r0,[r0,#0]
000006  6980              LDR      r0,[r0,#0x18]
000008  07c0              LSLS     r0,r0,#31
00000a  d007              BEQ      |L6.28|
;;;232      {
;;;233        /* SDRAM refresh error interrupt callback */
;;;234        HAL_SDRAM_RefreshErrorCallback(hsdram);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       HAL_SDRAM_RefreshErrorCallback
;;;235        
;;;236        /* Clear SDRAM refresh error interrupt pending bit */
;;;237        __FMC_SDRAM_CLEAR_FLAG(hsdram->Instance, FMC_SDRAM_FLAG_REFRESH_ERROR);
000012  6820              LDR      r0,[r4,#0]
000014  6941              LDR      r1,[r0,#0x14]
000016  f0410101          ORR      r1,r1,#1
00001a  6141              STR      r1,[r0,#0x14]
                  |L6.28|
;;;238      }
;;;239    }
00001c  bd10              POP      {r4,pc}
;;;240    
                          ENDP


                          AREA ||i.HAL_SDRAM_Init||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_Init PROC
;;;135      */
;;;136    HAL_StatusTypeDef HAL_SDRAM_Init(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_TimingTypeDef *Timing)
000000  b570              PUSH     {r4-r6,lr}
;;;137    {   
000002  0004              MOVS     r4,r0
000004  460d              MOV      r5,r1
000006  d002              BEQ      |L7.14|
;;;138      /* Check the SDRAM handle parameter */
;;;139      if(hsdram == NULL)
;;;140      {
;;;141        return HAL_ERROR;
;;;142      }
;;;143      
;;;144      if(hsdram->State == HAL_SDRAM_STATE_RESET)
000008  6ae0              LDR      r0,[r4,#0x2c]
00000a  b110              CBZ      r0,|L7.18|
00000c  e006              B        |L7.28|
                  |L7.14|
00000e  2001              MOVS     r0,#1                 ;141
;;;145      {  
;;;146        /* Allocate lock resource and initialize it */
;;;147        hsdram->Lock = HAL_UNLOCKED;
;;;148        /* Initialize the low level hardware (MSP) */
;;;149        HAL_SDRAM_MspInit(hsdram);
;;;150      }
;;;151      
;;;152      /* Initialize the SDRAM controller state */
;;;153      hsdram->State = HAL_SDRAM_STATE_BUSY;
;;;154      
;;;155      /* Initialize SDRAM control Interface */
;;;156      FMC_SDRAM_Init(hsdram->Instance, &(hsdram->Init));
;;;157      
;;;158      /* Initialize SDRAM timing Interface */
;;;159      FMC_SDRAM_Timing_Init(hsdram->Instance, Timing, hsdram->Init.SDBank); 
;;;160      
;;;161      /* Update the SDRAM controller state */
;;;162      hsdram->State = HAL_SDRAM_STATE_READY;
;;;163      
;;;164      return HAL_OK;
;;;165    }
000010  bd70              POP      {r4-r6,pc}
                  |L7.18|
000012  2000              MOVS     r0,#0                 ;147
000014  6320              STR      r0,[r4,#0x30]         ;149
000016  4620              MOV      r0,r4                 ;149
000018  f7fffffe          BL       HAL_SDRAM_MspInit
                  |L7.28|
00001c  2002              MOVS     r0,#2                 ;153
00001e  62e0              STR      r0,[r4,#0x2c]         ;153
000020  6820              LDR      r0,[r4,#0]            ;156
000022  1d21              ADDS     r1,r4,#4              ;156
000024  f7fffffe          BL       FMC_SDRAM_Init
000028  e9d40200          LDRD     r0,r2,[r4,#0]         ;159
00002c  4629              MOV      r1,r5                 ;159
00002e  f7fffffe          BL       FMC_SDRAM_Timing_Init
000032  2001              MOVS     r0,#1                 ;162
000034  62e0              STR      r0,[r4,#0x2c]         ;162
000036  2000              MOVS     r0,#0                 ;164
000038  bd70              POP      {r4-r6,pc}
;;;166    
                          ENDP


                          AREA ||i.HAL_SDRAM_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_MspDeInit PROC
;;;211      */
;;;212    __weak void HAL_SDRAM_MspDeInit(SDRAM_HandleTypeDef *hsdram)
000000  4770              BX       lr
;;;213    {
;;;214      /* Prevent unused argument(s) compilation warning */
;;;215      UNUSED(hsdram);
;;;216     
;;;217      /* NOTE: This function Should not be modified, when the callback is needed,
;;;218                the HAL_SDRAM_MspDeInit could be implemented in the user file
;;;219       */ 
;;;220    }
;;;221    
                          ENDP


                          AREA ||i.HAL_SDRAM_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_MspInit PROC
;;;195      */
;;;196    __weak void HAL_SDRAM_MspInit(SDRAM_HandleTypeDef *hsdram)
000000  4770              BX       lr
;;;197    {
;;;198      /* Prevent unused argument(s) compilation warning */
;;;199      UNUSED(hsdram);
;;;200     
;;;201      /* NOTE: This function Should not be modified, when the callback is needed,
;;;202                the HAL_SDRAM_MspInit could be implemented in the user file
;;;203       */ 
;;;204    }
;;;205    
                          ENDP


                          AREA ||i.HAL_SDRAM_ProgramRefreshRate||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_ProgramRefreshRate PROC
;;;751      */
;;;752    HAL_StatusTypeDef HAL_SDRAM_ProgramRefreshRate(SDRAM_HandleTypeDef *hsdram, uint32_t RefreshRate)
000000  b510              PUSH     {r4,lr}
;;;753    {
000002  4604              MOV      r4,r0
;;;754      /* Check the SDRAM controller state */
;;;755      if(hsdram->State == HAL_SDRAM_STATE_BUSY)
000004  6ac0              LDR      r0,[r0,#0x2c]
000006  2802              CMP      r0,#2
000008  d007              BEQ      |L10.26|
;;;756      {
;;;757        return HAL_BUSY;
;;;758      } 
;;;759      
;;;760      /* Update the SDRAM state */
;;;761      hsdram->State = HAL_SDRAM_STATE_BUSY;
00000a  2002              MOVS     r0,#2
00000c  62e0              STR      r0,[r4,#0x2c]
;;;762      
;;;763      /* Program the refresh rate */
;;;764      FMC_SDRAM_ProgramRefreshRate(hsdram->Instance ,RefreshRate);
00000e  6820              LDR      r0,[r4,#0]
000010  f7fffffe          BL       FMC_SDRAM_ProgramRefreshRate
;;;765      
;;;766      /* Update the SDRAM state */
;;;767      hsdram->State = HAL_SDRAM_STATE_READY;
000014  2001              MOVS     r0,#1
000016  62e0              STR      r0,[r4,#0x2c]
;;;768      
;;;769      return HAL_OK;   
000018  2000              MOVS     r0,#0
                  |L10.26|
;;;770    }
00001a  bd10              POP      {r4,pc}
;;;771    
                          ENDP


                          AREA ||i.HAL_SDRAM_Read_16b||, CODE, READONLY, ALIGN=2

                  HAL_SDRAM_Read_16b PROC
;;;399      */
;;;400    HAL_StatusTypeDef HAL_SDRAM_Read_16b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint16_t *pDstBuffer, uint32_t BufferSize)
000000  b530              PUSH     {r4,r5,lr}
;;;401    {
;;;402      __IO uint16_t *pSdramAddress = (uint16_t *)pAddress;
;;;403      
;;;404      /* Process Locked */
;;;405      __HAL_LOCK(hsdram);
000002  6b04              LDR      r4,[r0,#0x30]
000004  2c01              CMP      r4,#1
000006  d013              BEQ      |L11.48|
;;;406      
;;;407      /* Check the SDRAM controller state */
;;;408      if(hsdram->State == HAL_SDRAM_STATE_BUSY)
000008  6ac5              LDR      r5,[r0,#0x2c]
00000a  2401              MOVS     r4,#1                 ;405
00000c  6304              STR      r4,[r0,#0x30]
00000e  2d02              CMP      r5,#2
000010  d00e              BEQ      |L11.48|
;;;409      {
;;;410        return HAL_BUSY;
;;;411      }
;;;412      else if(hsdram->State == HAL_SDRAM_STATE_PRECHARGED)
000012  6ac4              LDR      r4,[r0,#0x2c]
000014  2c05              CMP      r4,#5
000016  d00d              BEQ      |L11.52|
;;;413      {
;;;414        return  HAL_ERROR; 
;;;415      }  
;;;416      
;;;417      /* Read data from source */
;;;418      for(; BufferSize != 0; BufferSize--)
000018  b133              CBZ      r3,|L11.40|
;;;419      {
;;;420        *pDstBuffer = *(__IO uint16_t *)pSdramAddress;  
00001a  bf00              NOP      
                  |L11.28|
00001c  f8314b02          LDRH     r4,[r1],#2
000020  1e5b              SUBS     r3,r3,#1
000022  f8224b02          STRH     r4,[r2],#2
000026  d1f9              BNE      |L11.28|
                  |L11.40|
;;;421        pDstBuffer++;
;;;422        pSdramAddress++;               
;;;423      }
;;;424      
;;;425      /* Process Unlocked */
;;;426      __HAL_UNLOCK(hsdram);       
000028  2100              MOVS     r1,#0
;;;427      
;;;428      return HAL_OK; 
00002a  6301              STR      r1,[r0,#0x30]
00002c  4608              MOV      r0,r1
;;;429    }
00002e  bd30              POP      {r4,r5,pc}
                  |L11.48|
000030  2002              MOVS     r0,#2                 ;410
000032  bd30              POP      {r4,r5,pc}
                  |L11.52|
000034  2001              MOVS     r0,#1                 ;414
000036  bd30              POP      {r4,r5,pc}
;;;430    
                          ENDP


                          AREA ||i.HAL_SDRAM_Read_32b||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_Read_32b PROC
;;;482      */
;;;483    HAL_StatusTypeDef HAL_SDRAM_Read_32b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint32_t *pDstBuffer, uint32_t BufferSize)
000000  b530              PUSH     {r4,r5,lr}
;;;484    {
;;;485      __IO uint32_t *pSdramAddress = (uint32_t *)pAddress;
;;;486      
;;;487      /* Process Locked */
;;;488      __HAL_LOCK(hsdram);
000002  6b04              LDR      r4,[r0,#0x30]
000004  2c01              CMP      r4,#1
000006  d010              BEQ      |L12.42|
;;;489      
;;;490      /* Check the SDRAM controller state */
;;;491      if(hsdram->State == HAL_SDRAM_STATE_BUSY)
000008  6ac5              LDR      r5,[r0,#0x2c]
00000a  2401              MOVS     r4,#1                 ;488
00000c  6304              STR      r4,[r0,#0x30]
00000e  2d02              CMP      r5,#2
000010  d00b              BEQ      |L12.42|
;;;492      {
;;;493        return HAL_BUSY;
;;;494      }
;;;495      else if(hsdram->State == HAL_SDRAM_STATE_PRECHARGED)
000012  6ac4              LDR      r4,[r0,#0x2c]
000014  2c05              CMP      r4,#5
000016  d00a              BEQ      |L12.46|
;;;496      {
;;;497        return  HAL_ERROR; 
;;;498      }  
;;;499      
;;;500      /* Read data from source */
;;;501      for(; BufferSize != 0; BufferSize--)
000018  b11b              CBZ      r3,|L12.34|
                  |L12.26|
;;;502      {
;;;503        *pDstBuffer = *(__IO uint32_t *)pSdramAddress;  
00001a  c910              LDM      r1!,{r4}
00001c  1e5b              SUBS     r3,r3,#1
00001e  c210              STM      r2!,{r4}
000020  d1fb              BNE      |L12.26|
                  |L12.34|
;;;504        pDstBuffer++;
;;;505        pSdramAddress++;               
;;;506      }
;;;507      
;;;508      /* Process Unlocked */
;;;509      __HAL_UNLOCK(hsdram);       
000022  2100              MOVS     r1,#0
;;;510      
;;;511      return HAL_OK; 
000024  6301              STR      r1,[r0,#0x30]
000026  4608              MOV      r0,r1
;;;512    }
000028  bd30              POP      {r4,r5,pc}
                  |L12.42|
00002a  2002              MOVS     r0,#2                 ;493
00002c  bd30              POP      {r4,r5,pc}
                  |L12.46|
00002e  2001              MOVS     r0,#1                 ;497
000030  bd30              POP      {r4,r5,pc}
;;;513    
                          ENDP


                          AREA ||i.HAL_SDRAM_Read_8b||, CODE, READONLY, ALIGN=2

                  HAL_SDRAM_Read_8b PROC
;;;314      */
;;;315    HAL_StatusTypeDef HAL_SDRAM_Read_8b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint8_t *pDstBuffer, uint32_t BufferSize)
000000  b530              PUSH     {r4,r5,lr}
;;;316    {
;;;317      __IO uint8_t *pSdramAddress = (uint8_t *)pAddress;
;;;318      
;;;319      /* Process Locked */
;;;320      __HAL_LOCK(hsdram);
000002  6b04              LDR      r4,[r0,#0x30]
000004  2c01              CMP      r4,#1
000006  d013              BEQ      |L13.48|
;;;321      
;;;322      /* Check the SDRAM controller state */
;;;323      if(hsdram->State == HAL_SDRAM_STATE_BUSY)
000008  6ac5              LDR      r5,[r0,#0x2c]
00000a  2401              MOVS     r4,#1                 ;320
00000c  6304              STR      r4,[r0,#0x30]
00000e  2d02              CMP      r5,#2
000010  d00e              BEQ      |L13.48|
;;;324      {
;;;325        return HAL_BUSY;
;;;326      }
;;;327      else if(hsdram->State == HAL_SDRAM_STATE_PRECHARGED)
000012  6ac4              LDR      r4,[r0,#0x2c]
000014  2c05              CMP      r4,#5
000016  d00d              BEQ      |L13.52|
;;;328      {
;;;329        return  HAL_ERROR; 
;;;330      }  
;;;331      
;;;332      /* Read data from source */
;;;333      for(; BufferSize != 0; BufferSize--)
000018  b133              CBZ      r3,|L13.40|
;;;334      {
;;;335        *pDstBuffer = *(__IO uint8_t *)pSdramAddress;  
00001a  bf00              NOP      
                  |L13.28|
00001c  f8114b01          LDRB     r4,[r1],#1
000020  1e5b              SUBS     r3,r3,#1
000022  f8024b01          STRB     r4,[r2],#1
000026  d1f9              BNE      |L13.28|
                  |L13.40|
;;;336        pDstBuffer++;
;;;337        pSdramAddress++;
;;;338      }
;;;339      
;;;340      /* Process Unlocked */
;;;341      __HAL_UNLOCK(hsdram);
000028  2100              MOVS     r1,#0
;;;342      
;;;343      return HAL_OK; 
00002a  6301              STR      r1,[r0,#0x30]
00002c  4608              MOV      r0,r1
;;;344    }
00002e  bd30              POP      {r4,r5,pc}
                  |L13.48|
000030  2002              MOVS     r0,#2                 ;325
000032  bd30              POP      {r4,r5,pc}
                  |L13.52|
000034  2001              MOVS     r0,#1                 ;329
000036  bd30              POP      {r4,r5,pc}
;;;345    
                          ENDP


                          AREA ||i.HAL_SDRAM_Read_DMA||, CODE, READONLY, ALIGN=2

                  HAL_SDRAM_Read_DMA PROC
;;;565      */
;;;566    HAL_StatusTypeDef HAL_SDRAM_Read_DMA(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint32_t *pDstBuffer, uint32_t BufferSize)
000000  b570              PUSH     {r4-r6,lr}
;;;567    {
000002  4604              MOV      r4,r0
;;;568      uint32_t tmp = 0;
;;;569        
;;;570      /* Process Locked */
;;;571      __HAL_LOCK(hsdram);
000004  6b00              LDR      r0,[r0,#0x30]
000006  2801              CMP      r0,#1
000008  d012              BEQ      |L14.48|
;;;572      
;;;573      /* Check the SDRAM controller state */  
;;;574      tmp = hsdram->State;
00000a  6ae0              LDR      r0,[r4,#0x2c]
00000c  2501              MOVS     r5,#1                 ;571
;;;575      
;;;576      if(tmp == HAL_SDRAM_STATE_BUSY)
00000e  6325              STR      r5,[r4,#0x30]
000010  2802              CMP      r0,#2
000012  d00c              BEQ      |L14.46|
;;;577      {
;;;578        return HAL_BUSY;
;;;579      }
;;;580      else if(tmp == HAL_SDRAM_STATE_PRECHARGED)
000014  2805              CMP      r0,#5
000016  d00d              BEQ      |L14.52|
;;;581      {
;;;582        return  HAL_ERROR; 
;;;583      }  
;;;584      
;;;585      /* Configure DMA user callbacks */
;;;586      hsdram->hdma->XferCpltCallback  = HAL_SDRAM_DMA_XferCpltCallback;
000018  6b65              LDR      r5,[r4,#0x34]
00001a  4807              LDR      r0,|L14.56|
;;;587      hsdram->hdma->XferErrorCallback = HAL_SDRAM_DMA_XferErrorCallback;
00001c  6428              STR      r0,[r5,#0x40]
00001e  6b65              LDR      r5,[r4,#0x34]
000020  4806              LDR      r0,|L14.60|
;;;588      
;;;589      /* Enable the DMA Stream */
;;;590      HAL_DMA_Start_IT(hsdram->hdma, (uint32_t)pAddress, (uint32_t)pDstBuffer, (uint32_t)BufferSize);
000022  6528              STR      r0,[r5,#0x50]
000024  6b60              LDR      r0,[r4,#0x34]
000026  f7fffffe          BL       HAL_DMA_Start_IT
;;;591      
;;;592      /* Process Unlocked */
;;;593      __HAL_UNLOCK(hsdram);  
00002a  2000              MOVS     r0,#0
;;;594      
;;;595      return HAL_OK; 
00002c  6320              STR      r0,[r4,#0x30]
                  |L14.46|
;;;596    }
00002e  bd70              POP      {r4-r6,pc}
                  |L14.48|
000030  2002              MOVS     r0,#2                 ;571
000032  bd70              POP      {r4-r6,pc}
                  |L14.52|
000034  2001              MOVS     r0,#1                 ;582
000036  bd70              POP      {r4-r6,pc}
;;;597    
                          ENDP

                  |L14.56|
                          DCD      HAL_SDRAM_DMA_XferCpltCallback
                  |L14.60|
                          DCD      HAL_SDRAM_DMA_XferErrorCallback

                          AREA ||i.HAL_SDRAM_RefreshErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_RefreshErrorCallback PROC
;;;246      */
;;;247    __weak void HAL_SDRAM_RefreshErrorCallback(SDRAM_HandleTypeDef *hsdram)
000000  4770              BX       lr
;;;248    {
;;;249      /* Prevent unused argument(s) compilation warning */
;;;250      UNUSED(hsdram);
;;;251     
;;;252      /* NOTE: This function Should not be modified, when the callback is needed,
;;;253                the HAL_SDRAM_RefreshErrorCallback could be implemented in the user file
;;;254       */ 
;;;255    }
;;;256    
                          ENDP


                          AREA ||i.HAL_SDRAM_SendCommand||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_SendCommand PROC
;;;717      */  
;;;718    HAL_StatusTypeDef HAL_SDRAM_SendCommand(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
000000  b570              PUSH     {r4-r6,lr}
;;;719    {
000002  4604              MOV      r4,r0
;;;720      /* Check the SDRAM controller state */
;;;721      if(hsdram->State == HAL_SDRAM_STATE_BUSY)
000004  6ac0              LDR      r0,[r0,#0x2c]
000006  460d              MOV      r5,r1                 ;719
000008  2802              CMP      r0,#2
00000a  d00a              BEQ      |L16.34|
;;;722      {
;;;723        return HAL_BUSY;
;;;724      }
;;;725      
;;;726      /* Update the SDRAM state */
;;;727      hsdram->State = HAL_SDRAM_STATE_BUSY;
00000c  2002              MOVS     r0,#2
00000e  62e0              STR      r0,[r4,#0x2c]
;;;728      
;;;729      /* Send SDRAM command */
;;;730      FMC_SDRAM_SendCommand(hsdram->Instance, Command, Timeout);
000010  6820              LDR      r0,[r4,#0]
000012  f7fffffe          BL       FMC_SDRAM_SendCommand
;;;731      
;;;732      /* Update the SDRAM controller state state */
;;;733      if(Command->CommandMode == FMC_SDRAM_CMD_PALL)
000016  6828              LDR      r0,[r5,#0]
000018  2802              CMP      r0,#2
00001a  d003              BEQ      |L16.36|
;;;734      {
;;;735        hsdram->State = HAL_SDRAM_STATE_PRECHARGED;
;;;736      }
;;;737      else
;;;738      {
;;;739        hsdram->State = HAL_SDRAM_STATE_READY;
00001c  2001              MOVS     r0,#1
                  |L16.30|
00001e  62e0              STR      r0,[r4,#0x2c]
;;;740      }
;;;741      
;;;742      return HAL_OK;  
000020  2000              MOVS     r0,#0
                  |L16.34|
;;;743    }
000022  bd70              POP      {r4-r6,pc}
                  |L16.36|
000024  2005              MOVS     r0,#5                 ;735
000026  e7fa              B        |L16.30|
;;;744    
                          ENDP


                          AREA ||i.HAL_SDRAM_SetAutoRefreshNumber||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_SetAutoRefreshNumber PROC
;;;778      */
;;;779    HAL_StatusTypeDef HAL_SDRAM_SetAutoRefreshNumber(SDRAM_HandleTypeDef *hsdram, uint32_t AutoRefreshNumber)
000000  b510              PUSH     {r4,lr}
;;;780    {
000002  4604              MOV      r4,r0
;;;781      /* Check the SDRAM controller state */
;;;782      if(hsdram->State == HAL_SDRAM_STATE_BUSY)
000004  6ac0              LDR      r0,[r0,#0x2c]
000006  2802              CMP      r0,#2
000008  d007              BEQ      |L17.26|
;;;783      {
;;;784        return HAL_BUSY;
;;;785      } 
;;;786      
;;;787      /* Update the SDRAM state */
;;;788      hsdram->State = HAL_SDRAM_STATE_BUSY;
00000a  2002              MOVS     r0,#2
00000c  62e0              STR      r0,[r4,#0x2c]
;;;789      
;;;790      /* Set the Auto-Refresh number */
;;;791      FMC_SDRAM_SetAutoRefreshNumber(hsdram->Instance ,AutoRefreshNumber);
00000e  6820              LDR      r0,[r4,#0]
000010  f7fffffe          BL       FMC_SDRAM_SetAutoRefreshNumber
;;;792      
;;;793      /* Update the SDRAM state */
;;;794      hsdram->State = HAL_SDRAM_STATE_READY;
000014  2001              MOVS     r0,#1
000016  62e0              STR      r0,[r4,#0x2c]
;;;795      
;;;796      return HAL_OK;
000018  2000              MOVS     r0,#0
                  |L17.26|
;;;797    }
00001a  bd10              POP      {r4,pc}
;;;798    
                          ENDP


                          AREA ||i.HAL_SDRAM_WriteProtection_Disable||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_WriteProtection_Disable PROC
;;;689      */
;;;690    HAL_StatusTypeDef HAL_SDRAM_WriteProtection_Disable(SDRAM_HandleTypeDef *hsdram)
000000  b510              PUSH     {r4,lr}
;;;691    {
000002  4604              MOV      r4,r0
;;;692      /* Check the SDRAM controller state */
;;;693      if(hsdram->State == HAL_SDRAM_STATE_BUSY)
000004  6ac0              LDR      r0,[r0,#0x2c]
000006  2802              CMP      r0,#2
000008  d008              BEQ      |L18.28|
;;;694      {
;;;695        return HAL_BUSY;
;;;696      }
;;;697      
;;;698      /* Update the SDRAM state */
;;;699      hsdram->State = HAL_SDRAM_STATE_BUSY;
00000a  2002              MOVS     r0,#2
00000c  62e0              STR      r0,[r4,#0x2c]
00000e  e9d40100          LDRD     r0,r1,[r4,#0]
;;;700      
;;;701      /* Disable write protection */
;;;702      FMC_SDRAM_WriteProtection_Disable(hsdram->Instance, hsdram->Init.SDBank);
000012  f7fffffe          BL       FMC_SDRAM_WriteProtection_Disable
;;;703      
;;;704      /* Update the SDRAM state */
;;;705      hsdram->State = HAL_SDRAM_STATE_READY;
000016  2001              MOVS     r0,#1
000018  62e0              STR      r0,[r4,#0x2c]
;;;706      
;;;707      return HAL_OK;
00001a  2000              MOVS     r0,#0
                  |L18.28|
;;;708    }
00001c  bd10              POP      {r4,pc}
;;;709    
                          ENDP


                          AREA ||i.HAL_SDRAM_WriteProtection_Enable||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_WriteProtection_Enable PROC
;;;663      */
;;;664    HAL_StatusTypeDef HAL_SDRAM_WriteProtection_Enable(SDRAM_HandleTypeDef *hsdram)
000000  b510              PUSH     {r4,lr}
;;;665    { 
000002  4604              MOV      r4,r0
;;;666      /* Check the SDRAM controller state */ 
;;;667      if(hsdram->State == HAL_SDRAM_STATE_BUSY)
000004  6ac0              LDR      r0,[r0,#0x2c]
000006  2802              CMP      r0,#2
000008  d008              BEQ      |L19.28|
;;;668      {
;;;669        return HAL_BUSY;
;;;670      }
;;;671      
;;;672      /* Update the SDRAM state */
;;;673      hsdram->State = HAL_SDRAM_STATE_BUSY;
00000a  2002              MOVS     r0,#2
00000c  62e0              STR      r0,[r4,#0x2c]
00000e  e9d40100          LDRD     r0,r1,[r4,#0]
;;;674      
;;;675      /* Enable write protection */
;;;676      FMC_SDRAM_WriteProtection_Enable(hsdram->Instance, hsdram->Init.SDBank);
000012  f7fffffe          BL       FMC_SDRAM_WriteProtection_Enable
;;;677      
;;;678      /* Update the SDRAM state */
;;;679      hsdram->State = HAL_SDRAM_STATE_WRITE_PROTECTED;
000016  2004              MOVS     r0,#4
000018  62e0              STR      r0,[r4,#0x2c]
;;;680      
;;;681      return HAL_OK;  
00001a  2000              MOVS     r0,#0
                  |L19.28|
;;;682    }
00001c  bd10              POP      {r4,pc}
;;;683    
                          ENDP


                          AREA ||i.HAL_SDRAM_Write_16b||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_Write_16b PROC
;;;439      */
;;;440    HAL_StatusTypeDef HAL_SDRAM_Write_16b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint16_t *pSrcBuffer, uint32_t BufferSize)
000000  b530              PUSH     {r4,r5,lr}
;;;441    {
;;;442      __IO uint16_t *pSdramAddress = (uint16_t *)pAddress;
;;;443      uint32_t tmp = 0;
;;;444      
;;;445      /* Process Locked */
;;;446      __HAL_LOCK(hsdram);
000002  6b04              LDR      r4,[r0,#0x30]
000004  2c01              CMP      r4,#1
000006  d013              BEQ      |L20.48|
;;;447      
;;;448      /* Check the SDRAM controller state */
;;;449      tmp = hsdram->State;
000008  6ac4              LDR      r4,[r0,#0x2c]
00000a  2501              MOVS     r5,#1                 ;446
;;;450      
;;;451      if(tmp == HAL_SDRAM_STATE_BUSY)
00000c  6305              STR      r5,[r0,#0x30]
00000e  2c02              CMP      r4,#2
000010  d00e              BEQ      |L20.48|
;;;452      {
;;;453        return HAL_BUSY;
;;;454      }
;;;455      else if((tmp == HAL_SDRAM_STATE_PRECHARGED) || (tmp == HAL_SDRAM_STATE_WRITE_PROTECTED))
000012  2c05              CMP      r4,#5
000014  d00e              BEQ      |L20.52|
000016  2c04              CMP      r4,#4
000018  d00c              BEQ      |L20.52|
;;;456      {
;;;457        return  HAL_ERROR; 
;;;458      }
;;;459      
;;;460      /* Write data to memory */
;;;461      for(; BufferSize != 0; BufferSize--)
00001a  b12b              CBZ      r3,|L20.40|
                  |L20.28|
;;;462      {
;;;463        *(__IO uint16_t *)pSdramAddress = *pSrcBuffer;
00001c  f8324b02          LDRH     r4,[r2],#2
000020  1e5b              SUBS     r3,r3,#1
000022  f8214b02          STRH     r4,[r1],#2
000026  d1f9              BNE      |L20.28|
                  |L20.40|
;;;464        pSrcBuffer++;
;;;465        pSdramAddress++;            
;;;466      }
;;;467      
;;;468      /* Process Unlocked */
;;;469      __HAL_UNLOCK(hsdram);    
000028  2100              MOVS     r1,#0
;;;470      
;;;471      return HAL_OK;   
00002a  6301              STR      r1,[r0,#0x30]
00002c  4608              MOV      r0,r1
;;;472    }
00002e  bd30              POP      {r4,r5,pc}
                  |L20.48|
000030  2002              MOVS     r0,#2                 ;453
000032  bd30              POP      {r4,r5,pc}
                  |L20.52|
000034  2001              MOVS     r0,#1                 ;457
000036  bd30              POP      {r4,r5,pc}
;;;473    
                          ENDP


                          AREA ||i.HAL_SDRAM_Write_32b||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_Write_32b PROC
;;;522      */
;;;523    HAL_StatusTypeDef HAL_SDRAM_Write_32b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint32_t *pSrcBuffer, uint32_t BufferSize)
000000  b530              PUSH     {r4,r5,lr}
;;;524    {
;;;525      __IO uint32_t *pSdramAddress = (uint32_t *)pAddress;
;;;526      uint32_t tmp = 0;
;;;527      
;;;528      /* Process Locked */
;;;529      __HAL_LOCK(hsdram);
000002  6b04              LDR      r4,[r0,#0x30]
000004  2c01              CMP      r4,#1
000006  d011              BEQ      |L21.44|
;;;530      
;;;531      /* Check the SDRAM controller state */
;;;532      tmp = hsdram->State;
000008  6ac4              LDR      r4,[r0,#0x2c]
00000a  2501              MOVS     r5,#1                 ;529
;;;533      
;;;534      if(tmp == HAL_SDRAM_STATE_BUSY)
00000c  6305              STR      r5,[r0,#0x30]
00000e  2c02              CMP      r4,#2
000010  d00c              BEQ      |L21.44|
;;;535      {
;;;536        return HAL_BUSY;
;;;537      }
;;;538      else if((tmp == HAL_SDRAM_STATE_PRECHARGED) || (tmp == HAL_SDRAM_STATE_WRITE_PROTECTED))
000012  2c05              CMP      r4,#5
000014  d00c              BEQ      |L21.48|
000016  2c04              CMP      r4,#4
000018  d00a              BEQ      |L21.48|
;;;539      {
;;;540        return  HAL_ERROR; 
;;;541      }
;;;542      
;;;543      /* Write data to memory */
;;;544      for(; BufferSize != 0; BufferSize--)
00001a  b11b              CBZ      r3,|L21.36|
                  |L21.28|
;;;545      {
;;;546        *(__IO uint32_t *)pSdramAddress = *pSrcBuffer;
00001c  ca10              LDM      r2!,{r4}
00001e  1e5b              SUBS     r3,r3,#1
000020  c110              STM      r1!,{r4}
000022  d1fb              BNE      |L21.28|
                  |L21.36|
;;;547        pSrcBuffer++;
;;;548        pSdramAddress++;          
;;;549      }
;;;550      
;;;551      /* Process Unlocked */
;;;552      __HAL_UNLOCK(hsdram);    
000024  2100              MOVS     r1,#0
;;;553      
;;;554      return HAL_OK;  
000026  6301              STR      r1,[r0,#0x30]
000028  4608              MOV      r0,r1
;;;555    }
00002a  bd30              POP      {r4,r5,pc}
                  |L21.44|
00002c  2002              MOVS     r0,#2                 ;536
00002e  bd30              POP      {r4,r5,pc}
                  |L21.48|
000030  2001              MOVS     r0,#1                 ;540
000032  bd30              POP      {r4,r5,pc}
;;;556    
                          ENDP


                          AREA ||i.HAL_SDRAM_Write_8b||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_Write_8b PROC
;;;355      */
;;;356    HAL_StatusTypeDef HAL_SDRAM_Write_8b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint8_t *pSrcBuffer, uint32_t BufferSize)
000000  b530              PUSH     {r4,r5,lr}
;;;357    {
;;;358      __IO uint8_t *pSdramAddress = (uint8_t *)pAddress;
;;;359      uint32_t tmp = 0;
;;;360      
;;;361      /* Process Locked */
;;;362      __HAL_LOCK(hsdram);
000002  6b04              LDR      r4,[r0,#0x30]
000004  2c01              CMP      r4,#1
000006  d013              BEQ      |L22.48|
;;;363      
;;;364      /* Check the SDRAM controller state */
;;;365      tmp = hsdram->State;
000008  6ac4              LDR      r4,[r0,#0x2c]
00000a  2501              MOVS     r5,#1                 ;362
;;;366      
;;;367      if(tmp == HAL_SDRAM_STATE_BUSY)
00000c  6305              STR      r5,[r0,#0x30]
00000e  2c02              CMP      r4,#2
000010  d00e              BEQ      |L22.48|
;;;368      {
;;;369        return HAL_BUSY;
;;;370      }
;;;371      else if((tmp == HAL_SDRAM_STATE_PRECHARGED) || (tmp == HAL_SDRAM_STATE_WRITE_PROTECTED))
000012  2c05              CMP      r4,#5
000014  d00e              BEQ      |L22.52|
000016  2c04              CMP      r4,#4
000018  d00c              BEQ      |L22.52|
;;;372      {
;;;373        return  HAL_ERROR; 
;;;374      }
;;;375      
;;;376      /* Write data to memory */
;;;377      for(; BufferSize != 0; BufferSize--)
00001a  b12b              CBZ      r3,|L22.40|
                  |L22.28|
;;;378      {
;;;379        *(__IO uint8_t *)pSdramAddress = *pSrcBuffer;
00001c  f8124b01          LDRB     r4,[r2],#1
000020  1e5b              SUBS     r3,r3,#1
000022  f8014b01          STRB     r4,[r1],#1
000026  d1f9              BNE      |L22.28|
                  |L22.40|
;;;380        pSrcBuffer++;
;;;381        pSdramAddress++;
;;;382      }
;;;383      
;;;384      /* Process Unlocked */
;;;385      __HAL_UNLOCK(hsdram);    
000028  2100              MOVS     r1,#0
;;;386      
;;;387      return HAL_OK;   
00002a  6301              STR      r1,[r0,#0x30]
00002c  4608              MOV      r0,r1
;;;388    }
00002e  bd30              POP      {r4,r5,pc}
                  |L22.48|
000030  2002              MOVS     r0,#2                 ;369
000032  bd30              POP      {r4,r5,pc}
                  |L22.52|
000034  2001              MOVS     r0,#1                 ;373
000036  bd30              POP      {r4,r5,pc}
;;;389    
                          ENDP


                          AREA ||i.HAL_SDRAM_Write_DMA||, CODE, READONLY, ALIGN=2

                  HAL_SDRAM_Write_DMA PROC
;;;606      */
;;;607    HAL_StatusTypeDef HAL_SDRAM_Write_DMA(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint32_t *pSrcBuffer, uint32_t BufferSize)
000000  b570              PUSH     {r4-r6,lr}
;;;608    {
000002  4604              MOV      r4,r0
;;;609      uint32_t tmp = 0;
;;;610      
;;;611      /* Process Locked */
;;;612      __HAL_LOCK(hsdram);
000004  6b00              LDR      r0,[r0,#0x30]
000006  4615              MOV      r5,r2                 ;608
000008  2801              CMP      r0,#1
00000a  d016              BEQ      |L23.58|
;;;613      
;;;614      /* Check the SDRAM controller state */  
;;;615      tmp = hsdram->State;
00000c  6ae0              LDR      r0,[r4,#0x2c]
00000e  2201              MOVS     r2,#1                 ;612
;;;616      
;;;617      if(tmp == HAL_SDRAM_STATE_BUSY)
000010  6322              STR      r2,[r4,#0x30]
000012  2802              CMP      r0,#2
000014  d010              BEQ      |L23.56|
;;;618      {
;;;619        return HAL_BUSY;
;;;620      }
;;;621      else if((tmp == HAL_SDRAM_STATE_PRECHARGED) || (tmp == HAL_SDRAM_STATE_WRITE_PROTECTED))
000016  2805              CMP      r0,#5
000018  d011              BEQ      |L23.62|
00001a  2804              CMP      r0,#4
00001c  d00f              BEQ      |L23.62|
;;;622      {
;;;623        return  HAL_ERROR; 
;;;624      }  
;;;625      
;;;626      /* Configure DMA user callbacks */
;;;627      hsdram->hdma->XferCpltCallback  = HAL_SDRAM_DMA_XferCpltCallback;
00001e  6b62              LDR      r2,[r4,#0x34]
000020  4808              LDR      r0,|L23.68|
;;;628      hsdram->hdma->XferErrorCallback = HAL_SDRAM_DMA_XferErrorCallback;
000022  6410              STR      r0,[r2,#0x40]
000024  6b62              LDR      r2,[r4,#0x34]
000026  4808              LDR      r0,|L23.72|
;;;629      
;;;630      /* Enable the DMA Stream */
;;;631      HAL_DMA_Start_IT(hsdram->hdma, (uint32_t)pSrcBuffer, (uint32_t)pAddress, (uint32_t)BufferSize);
000028  6510              STR      r0,[r2,#0x50]
00002a  460a              MOV      r2,r1
00002c  6b60              LDR      r0,[r4,#0x34]
00002e  4629              MOV      r1,r5
000030  f7fffffe          BL       HAL_DMA_Start_IT
;;;632      
;;;633      /* Process Unlocked */
;;;634      __HAL_UNLOCK(hsdram);
000034  2000              MOVS     r0,#0
;;;635      
;;;636      return HAL_OK;
000036  6320              STR      r0,[r4,#0x30]
                  |L23.56|
;;;637    }
000038  bd70              POP      {r4-r6,pc}
                  |L23.58|
00003a  2002              MOVS     r0,#2                 ;612
00003c  bd70              POP      {r4-r6,pc}
                  |L23.62|
00003e  2001              MOVS     r0,#1                 ;623
000040  bd70              POP      {r4-r6,pc}
;;;638    
                          ENDP

000042  0000              DCW      0x0000
                  |L23.68|
                          DCD      HAL_SDRAM_DMA_XferCpltCallback
                  |L23.72|
                          DCD      HAL_SDRAM_DMA_XferErrorCallback

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F7_V1.11.0\\Drivers\\STM32F7xx_HAL_Driver\\Src\\stm32f7xx_hal_sdram.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32f7xx_hal_sdram_c_77ca3b75____REV16|
#line 468 "D:\\Program_Files_x86\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.3.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___21_stm32f7xx_hal_sdram_c_77ca3b75____REV16| PROC
#line 469

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32f7xx_hal_sdram_c_77ca3b75____REVSH|
#line 483
|__asm___21_stm32f7xx_hal_sdram_c_77ca3b75____REVSH| PROC
#line 484

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32f7xx_hal_sdram_c_77ca3b75____RRX|
#line 670
|__asm___21_stm32f7xx_hal_sdram_c_77ca3b75____RRX| PROC
#line 671

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
