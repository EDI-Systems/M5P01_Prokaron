; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f7xx_hal_ltdc.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f7xx_hal_ltdc.d --cpu=Cortex-M7.fp.dp --apcs=interwork -O3 --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Core -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Inc -I.\Source -I.\Drivers -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6-ALIENTEK\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f7xx_hal_ltdc.crf ..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_ltdc.c]
                          THUMB

                          AREA ||i.HAL_LTDC_ConfigCLUT||, CODE, READONLY, ALIGN=2

                  HAL_LTDC_ConfigCLUT PROC
;;;592      */
;;;593    HAL_StatusTypeDef HAL_LTDC_ConfigCLUT(LTDC_HandleTypeDef *hltdc, uint32_t *pCLUT, uint32_t CLUTSize, uint32_t LayerIdx)
000000  b5f0              PUSH     {r4-r7,lr}
;;;594    {
;;;595      uint32_t tmp = 0;
;;;596      uint32_t counter = 0;
;;;597      uint32_t pcounter = 0;
;;;598    
;;;599      /* Process locked */
;;;600      __HAL_LOCK(hltdc);
000002  f8d040a0          LDR      r4,[r0,#0xa0]
000006  2500              MOVS     r5,#0                 ;596
000008  2c01              CMP      r4,#1
00000a  d006              BEQ      |L1.26|
00000c  2601              MOVS     r6,#1
;;;601    
;;;602      /* Change LTDC peripheral state */
;;;603      hltdc->State = HAL_LTDC_STATE_BUSY;  
00000e  2402              MOVS     r4,#2
000010  f8c040a4          STR      r4,[r0,#0xa4]
000014  f8c060a0          STR      r6,[r0,#0xa0]         ;600
000018  e01f              B        |L1.90|
                  |L1.26|
00001a  2002              MOVS     r0,#2                 ;600
;;;604    
;;;605      /* Check the parameters */
;;;606      assert_param(IS_LTDC_LAYER(LayerIdx)); 
;;;607    
;;;608      for(counter = 0; (counter < CLUTSize); counter++)
;;;609      {
;;;610        if(hltdc->LayerCfg[LayerIdx].PixelFormat == LTDC_PIXEL_FORMAT_AL44)
;;;611        {
;;;612          tmp  = (((counter + 16*counter) << 24) | ((uint32_t)(*pCLUT) & 0xFF) | ((uint32_t)(*pCLUT) & 0xFF00) | ((uint32_t)(*pCLUT) & 0xFF0000));
;;;613        }
;;;614        else
;;;615        { 
;;;616          tmp  = ((counter << 24) | ((uint32_t)(*pCLUT) & 0xFF) | ((uint32_t)(*pCLUT) & 0xFF00) | ((uint32_t)(*pCLUT) & 0xFF0000));
;;;617        }
;;;618        pcounter = (uint32_t)pCLUT + sizeof(*pCLUT);
;;;619        pCLUT = (uint32_t *)pcounter;
;;;620    
;;;621        /* Specifies the C-LUT address and RGB value */
;;;622        LTDC_LAYER(hltdc, LayerIdx)->CLUTWR  = tmp;
;;;623      }
;;;624      
;;;625      /* Change the LTDC state*/
;;;626      hltdc->State = HAL_LTDC_STATE_READY; 
;;;627    
;;;628      /* Process unlocked */
;;;629      __HAL_UNLOCK(hltdc);  
;;;630    
;;;631      return HAL_OK;
;;;632    }
00001c  bdf0              POP      {r4-r7,pc}
00001e  bf00              NOP                            ;610
                  |L1.32|
000020  eb030483          ADD      r4,r3,r3,LSL #2       ;610
000024  eb0404c3          ADD      r4,r4,r3,LSL #3       ;610
000028  eb000484          ADD      r4,r0,r4,LSL #2       ;610
00002c  6ca4              LDR      r4,[r4,#0x48]         ;610
00002e  2c06              CMP      r4,#6                 ;610
000030  d01c              BEQ      |L1.108|
000032  680f              LDR      r7,[r1,#0]            ;616
000034  b2fc              UXTB     r4,r7                 ;616
000036  f4074c7f          AND      r12,r7,#0xff00        ;616
00003a  ea446405          ORR      r4,r4,r5,LSL #24      ;616
00003e  f407077f          AND      r7,r7,#0xff0000       ;616
000042  ea44040c          ORR      r4,r4,r12             ;616
000046  433c              ORRS     r4,r4,r7              ;616
                  |L1.72|
000048  6807              LDR      r7,[r0,#0]            ;622
00004a  f04f0cc4          MOV      r12,#0xc4             ;622
00004e  eb0c1cc3          ADD      r12,r12,r3,LSL #7     ;622
000052  f847400c          STR      r4,[r7,r12]           ;622
000056  1d09              ADDS     r1,r1,#4              ;622
000058  1c6d              ADDS     r5,r5,#1              ;622
                  |L1.90|
00005a  4295              CMP      r5,r2                 ;608
00005c  d3e0              BCC      |L1.32|
00005e  2100              MOVS     r1,#0                 ;629
000060  f8c060a4          STR      r6,[r0,#0xa4]         ;626
000064  f8c010a0          STR      r1,[r0,#0xa0]         ;631
000068  4608              MOV      r0,r1                 ;631
00006a  bdf0              POP      {r4-r7,pc}
                  |L1.108|
00006c  f8d1c000          LDR      r12,[r1,#0]           ;612
000070  eb051e05          ADD      lr,r5,r5,LSL #4       ;612
000074  f00c04ff          AND      r4,r12,#0xff          ;612
000078  f40c477f          AND      r7,r12,#0xff00        ;612
00007c  ea44640e          ORR      r4,r4,lr,LSL #24      ;612
000080  433c              ORRS     r4,r4,r7              ;612
000082  f40c0c7f          AND      r12,r12,#0xff0000     ;612
000086  ea44040c          ORR      r4,r4,r12             ;612
00008a  e7dd              B        |L1.72|
;;;633    
                          ENDP


                          AREA ||i.HAL_LTDC_ConfigColorKeying||, CODE, READONLY, ALIGN=1

                  HAL_LTDC_ConfigColorKeying PROC
;;;554      */
;;;555    HAL_StatusTypeDef HAL_LTDC_ConfigColorKeying(LTDC_HandleTypeDef *hltdc, uint32_t RGBValue, uint32_t LayerIdx)
000000  b530              PUSH     {r4,r5,lr}
;;;556    {
;;;557      /* Process locked */
;;;558      __HAL_LOCK(hltdc);
000002  f8d030a0          LDR      r3,[r0,#0xa0]
000006  2b01              CMP      r3,#1
000008  d016              BEQ      |L2.56|
;;;559    
;;;560      /* Change LTDC peripheral state */
;;;561      hltdc->State = HAL_LTDC_STATE_BUSY;
00000a  2502              MOVS     r5,#2
00000c  2301              MOVS     r3,#1                 ;558
;;;562    
;;;563      /* Check the parameters */
;;;564      assert_param(IS_LTDC_LAYER(LayerIdx));
;;;565    
;;;566      /* Configures the default color values */
;;;567      LTDC_LAYER(hltdc, LayerIdx)->CKCR &=  ~(LTDC_LxCKCR_CKBLUE | LTDC_LxCKCR_CKGREEN | LTDC_LxCKCR_CKRED);
00000e  2490              MOVS     r4,#0x90
000010  e9c03528          STRD     r3,r5,[r0,#0xa0]      ;561
000014  eb0412c2          ADD      r2,r4,r2,LSL #7
000018  6804              LDR      r4,[r0,#0]
00001a  58a5              LDR      r5,[r4,r2]
00001c  f005457f          AND      r5,r5,#0xff000000
000020  50a5              STR      r5,[r4,r2]
;;;568      LTDC_LAYER(hltdc, LayerIdx)->CKCR  = RGBValue;
000022  6804              LDR      r4,[r0,#0]
000024  50a1              STR      r1,[r4,r2]
;;;569    
;;;570      /* Sets the Reload type */
;;;571      hltdc->Instance->SRCR = LTDC_SRCR_IMR;
000026  6802              LDR      r2,[r0,#0]
;;;572    
;;;573      /* Change the LTDC state*/
;;;574      hltdc->State = HAL_LTDC_STATE_READY;
;;;575    
;;;576      /* Process unlocked */
;;;577      __HAL_UNLOCK(hltdc);
000028  2100              MOVS     r1,#0
00002a  6253              STR      r3,[r2,#0x24]         ;571
00002c  f8c030a4          STR      r3,[r0,#0xa4]         ;574
;;;578    
;;;579      return HAL_OK;
000030  f8c010a0          STR      r1,[r0,#0xa0]
000034  4608              MOV      r0,r1
;;;580    }
000036  bd30              POP      {r4,r5,pc}
                  |L2.56|
000038  2002              MOVS     r0,#2                 ;558
00003a  bd30              POP      {r4,r5,pc}
;;;581    
                          ENDP


                          AREA ||i.HAL_LTDC_ConfigColorKeying_NoReload||, CODE, READONLY, ALIGN=1

                  HAL_LTDC_ConfigColorKeying_NoReload PROC
;;;1603     */
;;;1604   HAL_StatusTypeDef HAL_LTDC_ConfigColorKeying_NoReload(LTDC_HandleTypeDef *hltdc, uint32_t RGBValue, uint32_t LayerIdx)
000000  b570              PUSH     {r4-r6,lr}
;;;1605   {
;;;1606     /* Process locked */
;;;1607     __HAL_LOCK(hltdc);
000002  f8d030a0          LDR      r3,[r0,#0xa0]
000006  2b01              CMP      r3,#1
000008  d014              BEQ      |L3.52|
00000a  2401              MOVS     r4,#1
00000c  6803              LDR      r3,[r0,#0]
;;;1608   
;;;1609     /* Change LTDC peripheral state */
;;;1610     hltdc->State = HAL_LTDC_STATE_BUSY;
;;;1611   
;;;1612     /* Check the parameters */
;;;1613     assert_param(IS_LTDC_LAYER(LayerIdx));
;;;1614   
;;;1615     /* Configures the default color values */
;;;1616     LTDC_LAYER(hltdc, LayerIdx)->CKCR &=  ~(LTDC_LxCKCR_CKBLUE | LTDC_LxCKCR_CKGREEN | LTDC_LxCKCR_CKRED);
00000e  2690              MOVS     r6,#0x90
000010  2502              MOVS     r5,#2                 ;1610
000012  eb0612c2          ADD      r2,r6,r2,LSL #7
000016  e9c04528          STRD     r4,r5,[r0,#0xa0]      ;1610
00001a  589e              LDR      r6,[r3,r2]
;;;1617     LTDC_LAYER(hltdc, LayerIdx)->CKCR  = RGBValue;
;;;1618   
;;;1619     /* Do not Sets the Reload  */
;;;1620   
;;;1621     /* Change the LTDC state*/
;;;1622     hltdc->State = HAL_LTDC_STATE_READY;
;;;1623   
;;;1624     /* Process unlocked */
;;;1625     __HAL_UNLOCK(hltdc);
00001c  2500              MOVS     r5,#0
00001e  f006467f          AND      r6,r6,#0xff000000     ;1616
000022  509e              STR      r6,[r3,r2]            ;1616
000024  6803              LDR      r3,[r0,#0]            ;1617
000026  5099              STR      r1,[r3,r2]            ;1617
000028  f8c040a4          STR      r4,[r0,#0xa4]         ;1622
;;;1626   
;;;1627     return HAL_OK;
00002c  f8c050a0          STR      r5,[r0,#0xa0]
000030  4628              MOV      r0,r5
;;;1628   }
000032  bd70              POP      {r4-r6,pc}
                  |L3.52|
000034  2002              MOVS     r0,#2                 ;1607
000036  bd70              POP      {r4-r6,pc}
;;;1629   
                          ENDP


                          AREA ||i.HAL_LTDC_ConfigLayer||, CODE, READONLY, ALIGN=1

                  HAL_LTDC_ConfigLayer PROC
;;;505      */
;;;506    HAL_StatusTypeDef HAL_LTDC_ConfigLayer(LTDC_HandleTypeDef *hltdc, LTDC_LayerCfgTypeDef *pLayerCfg, uint32_t LayerIdx)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;507    {   
000004  4604              MOV      r4,r0
;;;508      /* Process locked */
;;;509      __HAL_LOCK(hltdc);
000006  f8d000a0          LDR      r0,[r0,#0xa0]
00000a  4616              MOV      r6,r2                 ;507
00000c  460f              MOV      r7,r1                 ;507
00000e  2801              CMP      r0,#1
000010  d01b              BEQ      |L4.74|
000012  2501              MOVS     r5,#1
;;;510      
;;;511      /* Change LTDC peripheral state */
;;;512      hltdc->State = HAL_LTDC_STATE_BUSY;
000014  2002              MOVS     r0,#2
000016  e9c45028          STRD     r5,r0,[r4,#0xa0]
;;;513    
;;;514      /* Check the parameters */
;;;515      assert_param(IS_LTDC_LAYER(LayerIdx));
;;;516      assert_param(IS_LTDC_PIXEL_FORMAT(pLayerCfg->PixelFormat));
;;;517      assert_param(IS_LTDC_BLENDING_FACTOR1(pLayerCfg->BlendingFactor1));
;;;518      assert_param(IS_LTDC_BLENDING_FACTOR2(pLayerCfg->BlendingFactor2));
;;;519      assert_param(IS_LTDC_HCONFIGST(pLayerCfg->WindowX0));
;;;520      assert_param(IS_LTDC_HCONFIGSP(pLayerCfg->WindowX1));
;;;521      assert_param(IS_LTDC_VCONFIGST(pLayerCfg->WindowY0));
;;;522      assert_param(IS_LTDC_VCONFIGSP(pLayerCfg->WindowY1));
;;;523      assert_param(IS_LTDC_ALPHA(pLayerCfg->Alpha0));
;;;524      assert_param(IS_LTDC_CFBLL(pLayerCfg->ImageWidth));
;;;525      assert_param(IS_LTDC_CFBLNBR(pLayerCfg->ImageHeight));
;;;526    
;;;527      /* Copy new layer configuration into handle structure */
;;;528      hltdc->LayerCfg[LayerIdx] = *pLayerCfg;  
00001a  eb060086          ADD      r0,r6,r6,LSL #2
00001e  eb0000c6          ADD      r0,r0,r6,LSL #3
000022  2234              MOVS     r2,#0x34
000024  eb040080          ADD      r0,r4,r0,LSL #2
000028  3038              ADDS     r0,r0,#0x38
00002a  f7fffffe          BL       __aeabi_memcpy4
;;;529    
;;;530      /* Configure the LTDC Layer */  
;;;531      LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);
00002e  4632              MOV      r2,r6
000030  4639              MOV      r1,r7
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       LTDC_SetConfig
;;;532    
;;;533      /* Sets the Reload type */
;;;534      hltdc->Instance->SRCR = LTDC_SRCR_IMR;
000038  6821              LDR      r1,[r4,#0]
;;;535    
;;;536      /* Initialize the LTDC state*/
;;;537      hltdc->State  = HAL_LTDC_STATE_READY;
;;;538    
;;;539      /* Process unlocked */
;;;540      __HAL_UNLOCK(hltdc);
00003a  2000              MOVS     r0,#0
00003c  624d              STR      r5,[r1,#0x24]         ;534
00003e  f8c450a4          STR      r5,[r4,#0xa4]         ;537
000042  f8c400a0          STR      r0,[r4,#0xa0]         ;509
                  |L4.70|
;;;541    
;;;542      return HAL_OK;
;;;543    }
000046  e8bd81f0          POP      {r4-r8,pc}
                  |L4.74|
00004a  2002              MOVS     r0,#2                 ;509
00004c  e7fb              B        |L4.70|
;;;544    
                          ENDP


                          AREA ||i.HAL_LTDC_ConfigLayer_NoReload||, CODE, READONLY, ALIGN=1

                  HAL_LTDC_ConfigLayer_NoReload PROC
;;;1232     */
;;;1233   HAL_StatusTypeDef HAL_LTDC_ConfigLayer_NoReload(LTDC_HandleTypeDef *hltdc, LTDC_LayerCfgTypeDef *pLayerCfg, uint32_t LayerIdx)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1234   {   
000004  4604              MOV      r4,r0
;;;1235     /* Process locked */
;;;1236     __HAL_LOCK(hltdc);
000006  f8d000a0          LDR      r0,[r0,#0xa0]
00000a  4615              MOV      r5,r2                 ;1234
00000c  460f              MOV      r7,r1                 ;1234
00000e  2801              CMP      r0,#1
000010  d01b              BEQ      |L5.74|
000012  2601              MOVS     r6,#1
;;;1237     
;;;1238     /* Change LTDC peripheral state */
;;;1239     hltdc->State = HAL_LTDC_STATE_BUSY;
000014  2002              MOVS     r0,#2
000016  f8c400a4          STR      r0,[r4,#0xa4]
;;;1240   
;;;1241     /* Check the parameters */
;;;1242     assert_param(IS_LTDC_LAYER(LayerIdx));
;;;1243     assert_param(IS_LTDC_PIXEL_FORMAT(pLayerCfg->PixelFormat));
;;;1244     assert_param(IS_LTDC_BLENDING_FACTOR1(pLayerCfg->BlendingFactor1));
;;;1245     assert_param(IS_LTDC_BLENDING_FACTOR2(pLayerCfg->BlendingFactor2));
;;;1246     assert_param(IS_LTDC_HCONFIGST(pLayerCfg->WindowX0));
;;;1247     assert_param(IS_LTDC_HCONFIGSP(pLayerCfg->WindowX1));
;;;1248     assert_param(IS_LTDC_VCONFIGST(pLayerCfg->WindowY0));
;;;1249     assert_param(IS_LTDC_VCONFIGSP(pLayerCfg->WindowY1));
;;;1250     assert_param(IS_LTDC_ALPHA(pLayerCfg->Alpha0));
;;;1251     assert_param(IS_LTDC_CFBLL(pLayerCfg->ImageWidth));
;;;1252     assert_param(IS_LTDC_CFBLNBR(pLayerCfg->ImageHeight));
;;;1253   
;;;1254     /* Copy new layer configuration into handle structure */
;;;1255     hltdc->LayerCfg[LayerIdx] = *pLayerCfg;  
00001a  eb050085          ADD      r0,r5,r5,LSL #2
00001e  f8c460a0          STR      r6,[r4,#0xa0]
000022  eb0000c5          ADD      r0,r0,r5,LSL #3
000026  2234              MOVS     r2,#0x34
000028  eb040080          ADD      r0,r4,r0,LSL #2
00002c  3038              ADDS     r0,r0,#0x38
00002e  f7fffffe          BL       __aeabi_memcpy4
;;;1256   
;;;1257     /* Configure the LTDC Layer */  
;;;1258     LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);
000032  462a              MOV      r2,r5
000034  4639              MOV      r1,r7
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       LTDC_SetConfig
;;;1259   
;;;1260     /* Do not Sets the Reload  */
;;;1261   
;;;1262     /* Initialize the LTDC state*/
;;;1263     hltdc->State  = HAL_LTDC_STATE_READY;
;;;1264   
;;;1265     /* Process unlocked */
;;;1266     __HAL_UNLOCK(hltdc);
00003c  2000              MOVS     r0,#0
00003e  f8c460a4          STR      r6,[r4,#0xa4]         ;1263
000042  f8c400a0          STR      r0,[r4,#0xa0]         ;1236
                  |L5.70|
;;;1267   
;;;1268     return HAL_OK;
;;;1269   }
000046  e8bd81f0          POP      {r4-r8,pc}
                  |L5.74|
00004a  2002              MOVS     r0,#2                 ;1236
00004c  e7fb              B        |L5.70|
;;;1270   
                          ENDP


                          AREA ||i.HAL_LTDC_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_LTDC_DeInit PROC
;;;251    
;;;252    HAL_StatusTypeDef HAL_LTDC_DeInit(LTDC_HandleTypeDef *hltdc)
000000  b510              PUSH     {r4,lr}
;;;253    {
000002  4604              MOV      r4,r0
;;;254      /* DeInit the low level hardware */
;;;255      HAL_LTDC_MspDeInit(hltdc); 
000004  f7fffffe          BL       HAL_LTDC_MspDeInit
;;;256    
;;;257      /* Initialize the error code */
;;;258      hltdc->ErrorCode = HAL_LTDC_ERROR_NONE;
000008  2000              MOVS     r0,#0
00000a  f8c400a8          STR      r0,[r4,#0xa8]
;;;259    
;;;260      /* Initialize the LTDC state*/
;;;261      hltdc->State = HAL_LTDC_STATE_RESET;
00000e  f8c400a4          STR      r0,[r4,#0xa4]
;;;262    
;;;263      /* Release Lock */
;;;264      __HAL_UNLOCK(hltdc);
000012  f8c400a0          STR      r0,[r4,#0xa0]
;;;265    
;;;266      return HAL_OK;
;;;267    }
000016  bd10              POP      {r4,pc}
;;;268    
                          ENDP


                          AREA ||i.HAL_LTDC_DisableCLUT||, CODE, READONLY, ALIGN=1

                  HAL_LTDC_DisableCLUT PROC
;;;748      */
;;;749    HAL_StatusTypeDef HAL_LTDC_DisableCLUT(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx)
000000  b510              PUSH     {r4,lr}
;;;750    {
;;;751     
;;;752      /* Process locked */
;;;753      __HAL_LOCK(hltdc);
000002  f8d020a0          LDR      r2,[r0,#0xa0]
000006  2a01              CMP      r2,#1
000008  d014              BEQ      |L7.52|
;;;754    
;;;755      /* Change LTDC peripheral state */
;;;756      hltdc->State = HAL_LTDC_STATE_BUSY;
00000a  2402              MOVS     r4,#2
00000c  2201              MOVS     r2,#1                 ;753
;;;757    
;;;758      /* Check the parameters */
;;;759      assert_param(IS_LTDC_LAYER(LayerIdx));
;;;760    
;;;761      /* Disable LTDC color lookup table by setting CLUTEN bit */
;;;762      LTDC_LAYER(hltdc, LayerIdx)->CR &= ~(uint32_t)LTDC_LxCR_CLUTEN;
00000e  2384              MOVS     r3,#0x84
000010  e9c02428          STRD     r2,r4,[r0,#0xa0]      ;756
000014  eb0313c1          ADD      r3,r3,r1,LSL #7
000018  f8501ba0          LDR      r1,[r0],#0xa0
00001c  58cc              LDR      r4,[r1,r3]
00001e  f0240410          BIC      r4,r4,#0x10
000022  50cc              STR      r4,[r1,r3]
;;;763    
;;;764      /* Sets the Reload type */
;;;765      hltdc->Instance->SRCR = LTDC_SRCR_IMR;
000024  f8503ca0          LDR      r3,[r0,#-0xa0]
;;;766    
;;;767      /* Change the LTDC state*/
;;;768      hltdc->State = HAL_LTDC_STATE_READY; 
;;;769    
;;;770      /* Process unlocked */
;;;771      __HAL_UNLOCK(hltdc);
000028  2100              MOVS     r1,#0
00002a  625a              STR      r2,[r3,#0x24]         ;765
00002c  6042              STR      r2,[r0,#4]            ;768
;;;772    
;;;773      return HAL_OK;
00002e  6001              STR      r1,[r0,#0]
000030  4608              MOV      r0,r1
;;;774    }
000032  bd10              POP      {r4,pc}
                  |L7.52|
000034  2002              MOVS     r0,#2                 ;753
000036  bd10              POP      {r4,pc}
;;;775    
                          ENDP


                          AREA ||i.HAL_LTDC_DisableCLUT_NoReload||, CODE, READONLY, ALIGN=1

                  HAL_LTDC_DisableCLUT_NoReload PROC
;;;1745     */
;;;1746   HAL_StatusTypeDef HAL_LTDC_DisableCLUT_NoReload(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx)
000000  b530              PUSH     {r4,r5,lr}
;;;1747   {
;;;1748    
;;;1749     /* Process locked */
;;;1750     __HAL_LOCK(hltdc);
000002  f8d020a0          LDR      r2,[r0,#0xa0]
000006  2a01              CMP      r2,#1
000008  d012              BEQ      |L8.48|
00000a  2301              MOVS     r3,#1
00000c  6802              LDR      r2,[r0,#0]
;;;1751   
;;;1752     /* Change LTDC peripheral state */
;;;1753     hltdc->State = HAL_LTDC_STATE_BUSY;
;;;1754   
;;;1755     /* Check the parameters */
;;;1756     assert_param(IS_LTDC_LAYER(LayerIdx));
;;;1757   
;;;1758     /* Disable LTDC color lookup table by setting CLUTEN bit */
;;;1759     LTDC_LAYER(hltdc, LayerIdx)->CR &= ~(uint32_t)LTDC_LxCR_CLUTEN;
00000e  2484              MOVS     r4,#0x84
000010  2502              MOVS     r5,#2                 ;1753
000012  eb0411c1          ADD      r1,r4,r1,LSL #7
000016  e9c03528          STRD     r3,r5,[r0,#0xa0]      ;1753
00001a  5855              LDR      r5,[r2,r1]
;;;1760   
;;;1761     /* Do not Sets the Reload  */
;;;1762   
;;;1763     /* Change the LTDC state*/
;;;1764     hltdc->State = HAL_LTDC_STATE_READY; 
;;;1765   
;;;1766     /* Process unlocked */
;;;1767     __HAL_UNLOCK(hltdc);
00001c  2400              MOVS     r4,#0
00001e  f0250510          BIC      r5,r5,#0x10           ;1759
000022  5055              STR      r5,[r2,r1]            ;1759
000024  f8c030a4          STR      r3,[r0,#0xa4]         ;1764
;;;1768   
;;;1769     return HAL_OK;
000028  f8c040a0          STR      r4,[r0,#0xa0]
00002c  4620              MOV      r0,r4
;;;1770   }
00002e  bd30              POP      {r4,r5,pc}
                  |L8.48|
000030  2002              MOVS     r0,#2                 ;1750
000032  bd30              POP      {r4,r5,pc}
;;;1771   
                          ENDP


                          AREA ||i.HAL_LTDC_DisableColorKeying||, CODE, READONLY, ALIGN=1

                  HAL_LTDC_DisableColorKeying PROC
;;;677      */
;;;678    HAL_StatusTypeDef HAL_LTDC_DisableColorKeying(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx)
000000  b510              PUSH     {r4,lr}
;;;679    {
;;;680      /* Process locked */
;;;681      __HAL_LOCK(hltdc);
000002  f8d020a0          LDR      r2,[r0,#0xa0]
000006  2a01              CMP      r2,#1
000008  d014              BEQ      |L9.52|
;;;682    
;;;683      /* Change LTDC peripheral state */
;;;684      hltdc->State = HAL_LTDC_STATE_BUSY;
00000a  2402              MOVS     r4,#2
00000c  2201              MOVS     r2,#1                 ;681
;;;685    
;;;686      /* Check the parameters */
;;;687      assert_param(IS_LTDC_LAYER(LayerIdx));
;;;688    
;;;689      /* Disable LTDC color keying by setting COLKEN bit */
;;;690      LTDC_LAYER(hltdc, LayerIdx)->CR &= ~(uint32_t)LTDC_LxCR_COLKEN;
00000e  2384              MOVS     r3,#0x84
000010  e9c02428          STRD     r2,r4,[r0,#0xa0]      ;684
000014  eb0313c1          ADD      r3,r3,r1,LSL #7
000018  f8501ba0          LDR      r1,[r0],#0xa0
00001c  58cc              LDR      r4,[r1,r3]
00001e  f0240402          BIC      r4,r4,#2
000022  50cc              STR      r4,[r1,r3]
;;;691    
;;;692      /* Sets the Reload type */
;;;693      hltdc->Instance->SRCR = LTDC_SRCR_IMR;
000024  f8503ca0          LDR      r3,[r0,#-0xa0]
;;;694    
;;;695      /* Change the LTDC state*/
;;;696      hltdc->State = HAL_LTDC_STATE_READY; 
;;;697    
;;;698      /* Process unlocked */
;;;699      __HAL_UNLOCK(hltdc);
000028  2100              MOVS     r1,#0
00002a  625a              STR      r2,[r3,#0x24]         ;693
00002c  6042              STR      r2,[r0,#4]            ;696
;;;700    
;;;701      return HAL_OK;
00002e  6001              STR      r1,[r0,#0]
000030  4608              MOV      r0,r1
;;;702    }
000032  bd10              POP      {r4,pc}
                  |L9.52|
000034  2002              MOVS     r0,#2                 ;681
000036  bd10              POP      {r4,pc}
;;;703    
                          ENDP


                          AREA ||i.HAL_LTDC_DisableColorKeying_NoReload||, CODE, READONLY, ALIGN=1

                  HAL_LTDC_DisableColorKeying_NoReload PROC
;;;1674     */
;;;1675   HAL_StatusTypeDef HAL_LTDC_DisableColorKeying_NoReload(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx)
000000  b530              PUSH     {r4,r5,lr}
;;;1676   {
;;;1677     /* Process locked */
;;;1678     __HAL_LOCK(hltdc);
000002  f8d020a0          LDR      r2,[r0,#0xa0]
000006  2a01              CMP      r2,#1
000008  d012              BEQ      |L10.48|
00000a  2301              MOVS     r3,#1
00000c  6802              LDR      r2,[r0,#0]
;;;1679   
;;;1680     /* Change LTDC peripheral state */
;;;1681     hltdc->State = HAL_LTDC_STATE_BUSY;
;;;1682   
;;;1683     /* Check the parameters */
;;;1684     assert_param(IS_LTDC_LAYER(LayerIdx));
;;;1685   
;;;1686     /* Disable LTDC color keying by setting COLKEN bit */
;;;1687     LTDC_LAYER(hltdc, LayerIdx)->CR &= ~(uint32_t)LTDC_LxCR_COLKEN;
00000e  2484              MOVS     r4,#0x84
000010  2502              MOVS     r5,#2                 ;1681
000012  eb0411c1          ADD      r1,r4,r1,LSL #7
000016  e9c03528          STRD     r3,r5,[r0,#0xa0]      ;1681
00001a  5855              LDR      r5,[r2,r1]
;;;1688   
;;;1689     /* Do not Sets the Reload  */
;;;1690   
;;;1691     /* Change the LTDC state*/
;;;1692     hltdc->State = HAL_LTDC_STATE_READY; 
;;;1693   
;;;1694     /* Process unlocked */
;;;1695     __HAL_UNLOCK(hltdc);
00001c  2400              MOVS     r4,#0
00001e  f0250502          BIC      r5,r5,#2              ;1687
000022  5055              STR      r5,[r2,r1]            ;1687
000024  f8c030a4          STR      r3,[r0,#0xa4]         ;1692
;;;1696   
;;;1697     return HAL_OK;
000028  f8c040a0          STR      r4,[r0,#0xa0]
00002c  4620              MOV      r0,r4
;;;1698   }
00002e  bd30              POP      {r4,r5,pc}
                  |L10.48|
000030  2002              MOVS     r0,#2                 ;1678
000032  bd30              POP      {r4,r5,pc}
;;;1699   
                          ENDP


                          AREA ||i.HAL_LTDC_DisableDither||, CODE, READONLY, ALIGN=2

                  HAL_LTDC_DisableDither PROC
;;;809    
;;;810    HAL_StatusTypeDef HAL_LTDC_DisableDither(LTDC_HandleTypeDef *hltdc)
000000  b510              PUSH     {r4,lr}
;;;811    {
;;;812      /* Process locked */
;;;813      __HAL_LOCK(hltdc);
000002  f8d010a0          LDR      r1,[r0,#0xa0]
000006  2901              CMP      r1,#1
000008  d00f              BEQ      |L11.42|
00000a  2201              MOVS     r2,#1
;;;814    
;;;815      /* Change LTDC peripheral state */
;;;816      hltdc->State = HAL_LTDC_STATE_BUSY;
;;;817    
;;;818      /* Disable Dither by setting DTEN bit */
;;;819      LTDC->GCR &= ~(uint32_t)LTDC_GCR_DEN;
00000c  4908              LDR      r1,|L11.48|
00000e  2302              MOVS     r3,#2                 ;816
000010  e9c02328          STRD     r2,r3,[r0,#0xa0]      ;816
000014  680b              LDR      r3,[r1,#0]
000016  f4233480          BIC      r4,r3,#0x10000
00001a  600c              STR      r4,[r1,#0]
;;;820    
;;;821      /* Change the LTDC state*/
;;;822      hltdc->State = HAL_LTDC_STATE_READY;
;;;823    
;;;824      /* Process unlocked */
;;;825      __HAL_UNLOCK(hltdc);
00001c  2300              MOVS     r3,#0
00001e  f8c020a4          STR      r2,[r0,#0xa4]         ;822
;;;826    
;;;827      return HAL_OK;
000022  f8c030a0          STR      r3,[r0,#0xa0]
000026  4618              MOV      r0,r3
;;;828    }
000028  bd10              POP      {r4,pc}
                  |L11.42|
00002a  2002              MOVS     r0,#2                 ;813
00002c  bd10              POP      {r4,pc}
;;;829    
                          ENDP

00002e  0000              DCW      0x0000
                  |L11.48|
                          DCD      0x40016818

                          AREA ||i.HAL_LTDC_EnableCLUT||, CODE, READONLY, ALIGN=1

                  HAL_LTDC_EnableCLUT PROC
;;;712      */
;;;713    HAL_StatusTypeDef HAL_LTDC_EnableCLUT(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx)
000000  b510              PUSH     {r4,lr}
;;;714    {
;;;715    
;;;716      /* Process locked */
;;;717      __HAL_LOCK(hltdc);
000002  f8d020a0          LDR      r2,[r0,#0xa0]
000006  2a01              CMP      r2,#1
000008  d014              BEQ      |L12.52|
;;;718    
;;;719      /* Change LTDC peripheral state */
;;;720      hltdc->State = HAL_LTDC_STATE_BUSY;
00000a  2402              MOVS     r4,#2
00000c  2201              MOVS     r2,#1                 ;717
;;;721    
;;;722      /* Check the parameters */
;;;723      assert_param(IS_LTDC_LAYER(LayerIdx));
;;;724    
;;;725      /* Disable LTDC color lookup table by setting CLUTEN bit */
;;;726      LTDC_LAYER(hltdc, LayerIdx)->CR |= (uint32_t)LTDC_LxCR_CLUTEN;
00000e  2384              MOVS     r3,#0x84
000010  e9c02428          STRD     r2,r4,[r0,#0xa0]      ;720
000014  eb0313c1          ADD      r3,r3,r1,LSL #7
000018  f8501ba0          LDR      r1,[r0],#0xa0
00001c  58cc              LDR      r4,[r1,r3]
00001e  f0440410          ORR      r4,r4,#0x10
000022  50cc              STR      r4,[r1,r3]
;;;727    
;;;728      /* Sets the Reload type */
;;;729      hltdc->Instance->SRCR = LTDC_SRCR_IMR;
000024  f8503ca0          LDR      r3,[r0,#-0xa0]
;;;730    
;;;731      /* Change the LTDC state*/
;;;732      hltdc->State = HAL_LTDC_STATE_READY; 
;;;733    
;;;734      /* Process unlocked */
;;;735      __HAL_UNLOCK(hltdc);
000028  2100              MOVS     r1,#0
00002a  625a              STR      r2,[r3,#0x24]         ;729
00002c  6042              STR      r2,[r0,#4]            ;732
;;;736    
;;;737      return HAL_OK;
00002e  6001              STR      r1,[r0,#0]
000030  4608              MOV      r0,r1
;;;738    }
000032  bd10              POP      {r4,pc}
                  |L12.52|
000034  2002              MOVS     r0,#2                 ;717
000036  bd10              POP      {r4,pc}
;;;739    
                          ENDP


                          AREA ||i.HAL_LTDC_EnableCLUT_NoReload||, CODE, READONLY, ALIGN=1

                  HAL_LTDC_EnableCLUT_NoReload PROC
;;;1709     */
;;;1710   HAL_StatusTypeDef HAL_LTDC_EnableCLUT_NoReload(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx)
000000  b530              PUSH     {r4,r5,lr}
;;;1711   {
;;;1712   
;;;1713     /* Process locked */
;;;1714     __HAL_LOCK(hltdc);
000002  f8d020a0          LDR      r2,[r0,#0xa0]
000006  2a01              CMP      r2,#1
000008  d012              BEQ      |L13.48|
00000a  2301              MOVS     r3,#1
00000c  6802              LDR      r2,[r0,#0]
;;;1715   
;;;1716     /* Change LTDC peripheral state */
;;;1717     hltdc->State = HAL_LTDC_STATE_BUSY;
;;;1718   
;;;1719     /* Check the parameters */
;;;1720     assert_param(IS_LTDC_LAYER(LayerIdx));
;;;1721   
;;;1722     /* Disable LTDC color lookup table by setting CLUTEN bit */
;;;1723     LTDC_LAYER(hltdc, LayerIdx)->CR |= (uint32_t)LTDC_LxCR_CLUTEN;
00000e  2484              MOVS     r4,#0x84
000010  2502              MOVS     r5,#2                 ;1717
000012  eb0411c1          ADD      r1,r4,r1,LSL #7
000016  e9c03528          STRD     r3,r5,[r0,#0xa0]      ;1717
00001a  5855              LDR      r5,[r2,r1]
;;;1724   
;;;1725     /* Do not Sets the Reload  */
;;;1726   
;;;1727     /* Change the LTDC state*/
;;;1728     hltdc->State = HAL_LTDC_STATE_READY; 
;;;1729   
;;;1730     /* Process unlocked */
;;;1731     __HAL_UNLOCK(hltdc);
00001c  2400              MOVS     r4,#0
00001e  f0450510          ORR      r5,r5,#0x10           ;1723
000022  5055              STR      r5,[r2,r1]            ;1723
000024  f8c030a4          STR      r3,[r0,#0xa4]         ;1728
;;;1732   
;;;1733     return HAL_OK;
000028  f8c040a0          STR      r4,[r0,#0xa0]
00002c  4620              MOV      r0,r4
;;;1734   }
00002e  bd30              POP      {r4,r5,pc}
                  |L13.48|
000030  2002              MOVS     r0,#2                 ;1714
000032  bd30              POP      {r4,r5,pc}
;;;1735   
                          ENDP


                          AREA ||i.HAL_LTDC_EnableColorKeying||, CODE, READONLY, ALIGN=1

                  HAL_LTDC_EnableColorKeying PROC
;;;642      */
;;;643    HAL_StatusTypeDef HAL_LTDC_EnableColorKeying(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx)
000000  b510              PUSH     {r4,lr}
;;;644    {  
;;;645      /* Process locked */
;;;646      __HAL_LOCK(hltdc);
000002  f8d020a0          LDR      r2,[r0,#0xa0]
000006  2a01              CMP      r2,#1
000008  d014              BEQ      |L14.52|
;;;647    
;;;648      /* Change LTDC peripheral state */
;;;649      hltdc->State = HAL_LTDC_STATE_BUSY;
00000a  2402              MOVS     r4,#2
00000c  2201              MOVS     r2,#1                 ;646
;;;650    
;;;651      /* Check the parameters */
;;;652      assert_param(IS_LTDC_LAYER(LayerIdx));
;;;653    
;;;654      /* Enable LTDC color keying by setting COLKEN bit */
;;;655      LTDC_LAYER(hltdc, LayerIdx)->CR |= (uint32_t)LTDC_LxCR_COLKEN;
00000e  2384              MOVS     r3,#0x84
000010  e9c02428          STRD     r2,r4,[r0,#0xa0]      ;649
000014  eb0313c1          ADD      r3,r3,r1,LSL #7
000018  f8501ba0          LDR      r1,[r0],#0xa0
00001c  58cc              LDR      r4,[r1,r3]
00001e  f0440402          ORR      r4,r4,#2
000022  50cc              STR      r4,[r1,r3]
;;;656    
;;;657      /* Sets the Reload type */
;;;658      hltdc->Instance->SRCR = LTDC_SRCR_IMR;
000024  f8503ca0          LDR      r3,[r0,#-0xa0]
;;;659    
;;;660      /* Change the LTDC state*/
;;;661      hltdc->State = HAL_LTDC_STATE_READY; 
;;;662    
;;;663      /* Process unlocked */
;;;664      __HAL_UNLOCK(hltdc);
000028  2100              MOVS     r1,#0
00002a  625a              STR      r2,[r3,#0x24]         ;658
00002c  6042              STR      r2,[r0,#4]            ;661
;;;665    
;;;666      return HAL_OK;  
00002e  6001              STR      r1,[r0,#0]
000030  4608              MOV      r0,r1
;;;667    }
000032  bd10              POP      {r4,pc}
                  |L14.52|
000034  2002              MOVS     r0,#2                 ;646
000036  bd10              POP      {r4,pc}
;;;668      
                          ENDP


                          AREA ||i.HAL_LTDC_EnableColorKeying_NoReload||, CODE, READONLY, ALIGN=1

                  HAL_LTDC_EnableColorKeying_NoReload PROC
;;;1639     */
;;;1640   HAL_StatusTypeDef HAL_LTDC_EnableColorKeying_NoReload(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx)
000000  b530              PUSH     {r4,r5,lr}
;;;1641   {  
;;;1642     /* Process locked */
;;;1643     __HAL_LOCK(hltdc);
000002  f8d020a0          LDR      r2,[r0,#0xa0]
000006  2a01              CMP      r2,#1
000008  d012              BEQ      |L15.48|
00000a  2301              MOVS     r3,#1
00000c  6802              LDR      r2,[r0,#0]
;;;1644   
;;;1645     /* Change LTDC peripheral state */
;;;1646     hltdc->State = HAL_LTDC_STATE_BUSY;
;;;1647   
;;;1648     /* Check the parameters */
;;;1649     assert_param(IS_LTDC_LAYER(LayerIdx));
;;;1650   
;;;1651     /* Enable LTDC color keying by setting COLKEN bit */
;;;1652     LTDC_LAYER(hltdc, LayerIdx)->CR |= (uint32_t)LTDC_LxCR_COLKEN;
00000e  2484              MOVS     r4,#0x84
000010  2502              MOVS     r5,#2                 ;1646
000012  eb0411c1          ADD      r1,r4,r1,LSL #7
000016  e9c03528          STRD     r3,r5,[r0,#0xa0]      ;1646
00001a  5855              LDR      r5,[r2,r1]
;;;1653   
;;;1654     /* Do not Sets the Reload  */
;;;1655   
;;;1656     /* Change the LTDC state*/
;;;1657     hltdc->State = HAL_LTDC_STATE_READY; 
;;;1658   
;;;1659     /* Process unlocked */
;;;1660     __HAL_UNLOCK(hltdc);
00001c  2400              MOVS     r4,#0
00001e  f0450502          ORR      r5,r5,#2              ;1652
000022  5055              STR      r5,[r2,r1]            ;1652
000024  f8c030a4          STR      r3,[r0,#0xa4]         ;1657
;;;1661   
;;;1662     return HAL_OK;  
000028  f8c040a0          STR      r4,[r0,#0xa0]
00002c  4620              MOV      r0,r4
;;;1663   }
00002e  bd30              POP      {r4,r5,pc}
                  |L15.48|
000030  2002              MOVS     r0,#2                 ;1643
000032  bd30              POP      {r4,r5,pc}
;;;1664   
                          ENDP


                          AREA ||i.HAL_LTDC_EnableDither||, CODE, READONLY, ALIGN=2

                  HAL_LTDC_EnableDither PROC
;;;782    
;;;783    HAL_StatusTypeDef HAL_LTDC_EnableDither(LTDC_HandleTypeDef *hltdc)
000000  b510              PUSH     {r4,lr}
;;;784    {
;;;785      /* Process locked */
;;;786      __HAL_LOCK(hltdc);
000002  f8d010a0          LDR      r1,[r0,#0xa0]
000006  2901              CMP      r1,#1
000008  d00f              BEQ      |L16.42|
00000a  2201              MOVS     r2,#1
;;;787    
;;;788      /* Change LTDC peripheral state */
;;;789      hltdc->State = HAL_LTDC_STATE_BUSY;
;;;790    
;;;791      /* Enable Dither by setting DTEN bit */
;;;792      LTDC->GCR |= (uint32_t)LTDC_GCR_DEN;
00000c  4908              LDR      r1,|L16.48|
00000e  2302              MOVS     r3,#2                 ;789
000010  e9c02328          STRD     r2,r3,[r0,#0xa0]      ;789
000014  680b              LDR      r3,[r1,#0]
000016  f4433480          ORR      r4,r3,#0x10000
00001a  600c              STR      r4,[r1,#0]
;;;793    
;;;794      /* Change the LTDC state*/
;;;795      hltdc->State = HAL_LTDC_STATE_READY; 
;;;796    
;;;797      /* Process unlocked */
;;;798      __HAL_UNLOCK(hltdc);
00001c  2300              MOVS     r3,#0
00001e  f8c020a4          STR      r2,[r0,#0xa4]         ;795
;;;799    
;;;800      return HAL_OK;
000022  f8c030a0          STR      r3,[r0,#0xa0]
000026  4618              MOV      r0,r3
;;;801    }
000028  bd10              POP      {r4,pc}
                  |L16.42|
00002a  2002              MOVS     r0,#2                 ;786
00002c  bd10              POP      {r4,pc}
;;;802    
                          ENDP

00002e  0000              DCW      0x0000
                  |L16.48|
                          DCD      0x40016818

                          AREA ||i.HAL_LTDC_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_LTDC_ErrorCallback PROC
;;;423      */
;;;424    __weak void HAL_LTDC_ErrorCallback(LTDC_HandleTypeDef *hltdc)
000000  4770              BX       lr
;;;425    {
;;;426      /* Prevent unused argument(s) compilation warning */
;;;427      UNUSED(hltdc);
;;;428      
;;;429      /* NOTE : This function Should not be modified, when the callback is needed,
;;;430                the HAL_LTDC_ErrorCallback could be implemented in the user file
;;;431       */
;;;432    }
;;;433    
                          ENDP


                          AREA ||i.HAL_LTDC_GetError||, CODE, READONLY, ALIGN=1

                  HAL_LTDC_GetError PROC
;;;1808   */
;;;1809   uint32_t HAL_LTDC_GetError(LTDC_HandleTypeDef *hltdc)
000000  f8d000a8          LDR      r0,[r0,#0xa8]
;;;1810   {
;;;1811     return hltdc->ErrorCode;
;;;1812   }
000004  4770              BX       lr
;;;1813   
                          ENDP


                          AREA ||i.HAL_LTDC_GetState||, CODE, READONLY, ALIGN=1

                  HAL_LTDC_GetState PROC
;;;1797     */
;;;1798   HAL_LTDC_StateTypeDef HAL_LTDC_GetState(LTDC_HandleTypeDef *hltdc)
000000  f8d000a4          LDR      r0,[r0,#0xa4]
;;;1799   {
;;;1800     return hltdc->State;
;;;1801   }
000004  4770              BX       lr
;;;1802   
                          ENDP


                          AREA ||i.HAL_LTDC_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_LTDC_IRQHandler PROC
;;;323      */
;;;324    void HAL_LTDC_IRQHandler(LTDC_HandleTypeDef *hltdc)
000000  b570              PUSH     {r4-r6,lr}
;;;325    {
000002  4604              MOV      r4,r0
;;;326      /* Transfer Error Interrupt management ***************************************/
;;;327      if(__HAL_LTDC_GET_FLAG(hltdc, LTDC_FLAG_TE) != RESET)
000004  6800              LDR      r0,[r0,#0]
;;;328      {
;;;329        if(__HAL_LTDC_GET_IT_SOURCE(hltdc, LTDC_IT_TE) != RESET)
;;;330        {
;;;331          /* Disable the transfer Error interrupt */
;;;332          __HAL_LTDC_DISABLE_IT(hltdc, LTDC_IT_TE);
;;;333    
;;;334          /* Clear the transfer error flag */
;;;335          __HAL_LTDC_CLEAR_FLAG(hltdc, LTDC_FLAG_TE);
000006  2604              MOVS     r6,#4
000008  2500              MOVS     r5,#0
00000a  6b81              LDR      r1,[r0,#0x38]         ;327
00000c  0749              LSLS     r1,r1,#29             ;327
00000e  d515              BPL      |L20.60|
000010  6b81              LDR      r1,[r0,#0x38]         ;329
000012  0749              LSLS     r1,r1,#29             ;329
000014  d512              BPL      |L20.60|
000016  6b41              LDR      r1,[r0,#0x34]         ;332
000018  f0210104          BIC      r1,r1,#4              ;332
00001c  6341              STR      r1,[r0,#0x34]         ;332
00001e  6820              LDR      r0,[r4,#0]
000020  63c6              STR      r6,[r0,#0x3c]
;;;336    
;;;337          /* Update error code */
;;;338          hltdc->ErrorCode |= HAL_LTDC_ERROR_TE;
000022  f8d400a8          LDR      r0,[r4,#0xa8]
000026  f0400001          ORR      r0,r0,#1
00002a  f8c400a8          STR      r0,[r4,#0xa8]
;;;339    
;;;340          /* Change LTDC state */
;;;341          hltdc->State = HAL_LTDC_STATE_ERROR;
00002e  f8c460a4          STR      r6,[r4,#0xa4]
;;;342    
;;;343          /* Process unlocked */
;;;344          __HAL_UNLOCK(hltdc);
;;;345    
;;;346          /* Transfer error Callback */
;;;347          HAL_LTDC_ErrorCallback(hltdc);
000032  4620              MOV      r0,r4
000034  f8c450a0          STR      r5,[r4,#0xa0]
000038  f7fffffe          BL       HAL_LTDC_ErrorCallback
                  |L20.60|
;;;348        }
;;;349      }
;;;350      /* FIFO underrun Interrupt management ***************************************/
;;;351      if(__HAL_LTDC_GET_FLAG(hltdc, LTDC_FLAG_FU) != RESET)
00003c  6820              LDR      r0,[r4,#0]
00003e  6b81              LDR      r1,[r0,#0x38]
000040  0789              LSLS     r1,r1,#30
000042  d516              BPL      |L20.114|
;;;352      {
;;;353        if(__HAL_LTDC_GET_IT_SOURCE(hltdc, LTDC_IT_FU) != RESET)
000044  6b81              LDR      r1,[r0,#0x38]
000046  0789              LSLS     r1,r1,#30
000048  d513              BPL      |L20.114|
;;;354        {
;;;355          /* Disable the FIFO underrun interrupt */
;;;356          __HAL_LTDC_DISABLE_IT(hltdc, LTDC_IT_FU);
00004a  6b42              LDR      r2,[r0,#0x34]
;;;357    
;;;358          /* Clear the FIFO underrun flag */
;;;359          __HAL_LTDC_CLEAR_FLAG(hltdc, LTDC_FLAG_FU);
00004c  2102              MOVS     r1,#2
00004e  f0220202          BIC      r2,r2,#2              ;356
000052  6342              STR      r2,[r0,#0x34]         ;356
000054  6820              LDR      r0,[r4,#0]
000056  63c1              STR      r1,[r0,#0x3c]
;;;360    
;;;361          /* Update error code */
;;;362          hltdc->ErrorCode |= HAL_LTDC_ERROR_FU;
000058  f8d400a8          LDR      r0,[r4,#0xa8]
00005c  f0400002          ORR      r0,r0,#2
000060  f8c400a8          STR      r0,[r4,#0xa8]
;;;363    
;;;364          /* Change LTDC state */
;;;365          hltdc->State = HAL_LTDC_STATE_ERROR;
000064  f8c460a4          STR      r6,[r4,#0xa4]
;;;366    
;;;367          /* Process unlocked */
;;;368          __HAL_UNLOCK(hltdc);
;;;369          
;;;370          /* Transfer error Callback */
;;;371          HAL_LTDC_ErrorCallback(hltdc);
000068  4620              MOV      r0,r4
00006a  f8c450a0          STR      r5,[r4,#0xa0]
00006e  f7fffffe          BL       HAL_LTDC_ErrorCallback
                  |L20.114|
;;;372        }
;;;373      }
;;;374      /* Line Interrupt management ************************************************/
;;;375      if(__HAL_LTDC_GET_FLAG(hltdc, LTDC_FLAG_LI) != RESET)
000072  6820              LDR      r0,[r4,#0]
;;;376      {
;;;377        if(__HAL_LTDC_GET_IT_SOURCE(hltdc, LTDC_IT_LI) != RESET)
;;;378        {
;;;379          /* Disable the Line interrupt */
;;;380          __HAL_LTDC_DISABLE_IT(hltdc, LTDC_IT_LI);
;;;381    
;;;382          /* Clear the Line interrupt flag */  
;;;383          __HAL_LTDC_CLEAR_FLAG(hltdc, LTDC_FLAG_LI);
000074  2601              MOVS     r6,#1
000076  6b81              LDR      r1,[r0,#0x38]         ;375
000078  07c9              LSLS     r1,r1,#31             ;375
00007a  d00f              BEQ      |L20.156|
00007c  6b81              LDR      r1,[r0,#0x38]         ;377
00007e  07c9              LSLS     r1,r1,#31             ;377
000080  d00c              BEQ      |L20.156|
000082  6b41              LDR      r1,[r0,#0x34]         ;380
000084  f0210101          BIC      r1,r1,#1              ;380
000088  6341              STR      r1,[r0,#0x34]         ;380
00008a  6820              LDR      r0,[r4,#0]
00008c  63c6              STR      r6,[r0,#0x3c]
;;;384    
;;;385          /* Change LTDC state */
;;;386          hltdc->State = HAL_LTDC_STATE_READY;
00008e  f8c460a4          STR      r6,[r4,#0xa4]
;;;387    
;;;388          /* Process unlocked */
;;;389          __HAL_UNLOCK(hltdc);
;;;390    
;;;391          /* Line interrupt Callback */
;;;392          HAL_LTDC_LineEventCallback(hltdc);
000092  4620              MOV      r0,r4
000094  f8c450a0          STR      r5,[r4,#0xa0]
000098  f7fffffe          BL       HAL_LTDC_LineEventCallback
                  |L20.156|
;;;393        }
;;;394      }
;;;395      /* Register reload Interrupt management ***************************************/
;;;396      if(__HAL_LTDC_GET_FLAG(hltdc, LTDC_FLAG_RR) != RESET)
00009c  6820              LDR      r0,[r4,#0]
00009e  6b81              LDR      r1,[r0,#0x38]
0000a0  0709              LSLS     r1,r1,#28
0000a2  d510              BPL      |L20.198|
;;;397      {
;;;398        if(__HAL_LTDC_GET_IT_SOURCE(hltdc, LTDC_IT_RR) != RESET)
0000a4  6b81              LDR      r1,[r0,#0x38]
0000a6  0709              LSLS     r1,r1,#28
0000a8  d50d              BPL      |L20.198|
;;;399        {
;;;400          /* Disable the register reload interrupt */
;;;401          __HAL_LTDC_DISABLE_IT(hltdc, LTDC_IT_RR);
0000aa  6b42              LDR      r2,[r0,#0x34]
;;;402          
;;;403          /* Clear the register reload flag */
;;;404          __HAL_LTDC_CLEAR_FLAG(hltdc, LTDC_FLAG_RR);
0000ac  2108              MOVS     r1,#8
0000ae  f0220208          BIC      r2,r2,#8              ;401
0000b2  6342              STR      r2,[r0,#0x34]         ;401
0000b4  6820              LDR      r0,[r4,#0]
0000b6  63c1              STR      r1,[r0,#0x3c]
;;;405          
;;;406          /* Change LTDC state */
;;;407          hltdc->State = HAL_LTDC_STATE_READY;
0000b8  f8c460a4          STR      r6,[r4,#0xa4]
;;;408          
;;;409          /* Process unlocked */
;;;410          __HAL_UNLOCK(hltdc);
;;;411          
;;;412          /* Register reload interrupt Callback */
;;;413          HAL_LTDC_ReloadEventCallback(hltdc);
0000bc  4620              MOV      r0,r4
0000be  f8c450a0          STR      r5,[r4,#0xa0]
0000c2  f7fffffe          BL       HAL_LTDC_ReloadEventCallback
                  |L20.198|
;;;414        }
;;;415      }  
;;;416    }
0000c6  bd70              POP      {r4-r6,pc}
;;;417    
                          ENDP


                          AREA ||i.HAL_LTDC_Init||, CODE, READONLY, ALIGN=2

                  HAL_LTDC_Init PROC
;;;158      */
;;;159    HAL_StatusTypeDef HAL_LTDC_Init(LTDC_HandleTypeDef *hltdc)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;160    {
000004  0004              MOVS     r4,r0
000006  d004              BEQ      |L21.18|
;;;161      uint32_t tmp = 0, tmp1 = 0;
;;;162    
;;;163      /* Check the LTDC peripheral state */
;;;164      if(hltdc == NULL)
;;;165      {
;;;166        return HAL_ERROR;
;;;167      }
;;;168    
;;;169      /* Check function parameters */
;;;170      assert_param(IS_LTDC_ALL_INSTANCE(hltdc->Instance));
;;;171      assert_param(IS_LTDC_HSYNC(hltdc->Init.HorizontalSync));
;;;172      assert_param(IS_LTDC_VSYNC(hltdc->Init.VerticalSync));
;;;173      assert_param(IS_LTDC_AHBP(hltdc->Init.AccumulatedHBP));
;;;174      assert_param(IS_LTDC_AVBP(hltdc->Init.AccumulatedVBP));
;;;175      assert_param(IS_LTDC_AAH(hltdc->Init.AccumulatedActiveH));
;;;176      assert_param(IS_LTDC_AAW(hltdc->Init.AccumulatedActiveW));
;;;177      assert_param(IS_LTDC_TOTALH(hltdc->Init.TotalHeigh));
;;;178      assert_param(IS_LTDC_TOTALW(hltdc->Init.TotalWidth));
;;;179      assert_param(IS_LTDC_HSPOL(hltdc->Init.HSPolarity));
;;;180      assert_param(IS_LTDC_VSPOL(hltdc->Init.VSPolarity));
;;;181      assert_param(IS_LTDC_DEPOL(hltdc->Init.DEPolarity));
;;;182      assert_param(IS_LTDC_PCPOL(hltdc->Init.PCPolarity));
;;;183    
;;;184      if(hltdc->State == HAL_LTDC_STATE_RESET)
000008  f8d400a4          LDR      r0,[r4,#0xa4]
00000c  2500              MOVS     r5,#0
00000e  b118              CBZ      r0,|L21.24|
000010  e007              B        |L21.34|
                  |L21.18|
000012  2001              MOVS     r0,#1                 ;166
                  |L21.20|
;;;185      {
;;;186        /* Allocate lock resource and initialize it */
;;;187        hltdc->Lock = HAL_UNLOCKED;
;;;188        /* Init the low level hardware */
;;;189        HAL_LTDC_MspInit(hltdc);
;;;190      }
;;;191      
;;;192      /* Change LTDC peripheral state */
;;;193      hltdc->State = HAL_LTDC_STATE_BUSY;
;;;194    
;;;195      /* Configures the HS, VS, DE and PC polarity */
;;;196      hltdc->Instance->GCR &= ~(LTDC_GCR_HSPOL | LTDC_GCR_VSPOL | LTDC_GCR_DEPOL | LTDC_GCR_PCPOL);
;;;197      hltdc->Instance->GCR |=  (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
;;;198      hltdc->Init.DEPolarity | hltdc->Init.PCPolarity);
;;;199    
;;;200      /* Sets Synchronization size */
;;;201      hltdc->Instance->SSCR &= ~(LTDC_SSCR_VSH | LTDC_SSCR_HSW);
;;;202      tmp = (hltdc->Init.HorizontalSync << 16);
;;;203      hltdc->Instance->SSCR |= (tmp | hltdc->Init.VerticalSync);
;;;204    
;;;205      /* Sets Accumulated Back porch */
;;;206      hltdc->Instance->BPCR &= ~(LTDC_BPCR_AVBP | LTDC_BPCR_AHBP);
;;;207      tmp = (hltdc->Init.AccumulatedHBP << 16);
;;;208      hltdc->Instance->BPCR |= (tmp | hltdc->Init.AccumulatedVBP);
;;;209    
;;;210      /* Sets Accumulated Active Width */
;;;211      hltdc->Instance->AWCR &= ~(LTDC_AWCR_AAH | LTDC_AWCR_AAW);
;;;212      tmp = (hltdc->Init.AccumulatedActiveW << 16);
;;;213      hltdc->Instance->AWCR |= (tmp | hltdc->Init.AccumulatedActiveH);
;;;214    
;;;215      /* Sets Total Width */
;;;216      hltdc->Instance->TWCR &= ~(LTDC_TWCR_TOTALH | LTDC_TWCR_TOTALW);
;;;217      tmp = (hltdc->Init.TotalWidth << 16);
;;;218      hltdc->Instance->TWCR |= (tmp | hltdc->Init.TotalHeigh);
;;;219    
;;;220      /* Sets the background color value */
;;;221      tmp = ((uint32_t)(hltdc->Init.Backcolor.Green) << 8);
;;;222      tmp1 = ((uint32_t)(hltdc->Init.Backcolor.Red) << 16);
;;;223      hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
;;;224      hltdc->Instance->BCCR |= (tmp1 | tmp | hltdc->Init.Backcolor.Blue);
;;;225    
;;;226      /* Enable the transfer Error interrupt */
;;;227      __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_TE);
;;;228    
;;;229      /* Enable the FIFO underrun interrupt */
;;;230      __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_FU);
;;;231    
;;;232      /* Enable LTDC by setting LTDCEN bit */
;;;233      __HAL_LTDC_ENABLE(hltdc);
;;;234    
;;;235      /* Initialize the error code */
;;;236      hltdc->ErrorCode = HAL_LTDC_ERROR_NONE;  
;;;237    
;;;238      /* Initialize the LTDC state*/
;;;239      hltdc->State = HAL_LTDC_STATE_READY;
;;;240    
;;;241      return HAL_OK;
;;;242    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L21.24|
000018  4620              MOV      r0,r4                 ;189
00001a  f8c450a0          STR      r5,[r4,#0xa0]         ;189
00001e  f7fffffe          BL       HAL_LTDC_MspInit
                  |L21.34|
000022  4836              LDR      r0,|L21.252|
000024  2102              MOVS     r1,#2                 ;193
000026  f8c410a4          STR      r1,[r4,#0xa4]         ;193
00002a  2201              MOVS     r2,#1                 ;239
00002c  cc02              LDM      r4!,{r1}              ;196
00002e  698b              LDR      r3,[r1,#0x18]         ;196
000030  f0234370          BIC      r3,r3,#0xf0000000     ;196
000034  618b              STR      r3,[r1,#0x18]         ;196
000036  e894004a          LDM      r4,{r1,r3,r6}         ;196
00003a  4319              ORRS     r1,r1,r3              ;197
00003c  68e3              LDR      r3,[r4,#0xc]          ;197
00003e  431e              ORRS     r6,r6,r3              ;197
000040  f8543d04          LDR      r3,[r4,#-4]!          ;197
000044  4331              ORRS     r1,r1,r6              ;197
000046  699e              LDR      r6,[r3,#0x18]         ;197
000048  4331              ORRS     r1,r1,r6              ;197
00004a  6199              STR      r1,[r3,#0x18]         ;197
00004c  6821              LDR      r1,[r4,#0]            ;201
00004e  688b              LDR      r3,[r1,#8]            ;201
000050  4003              ANDS     r3,r3,r0              ;201
000052  608b              STR      r3,[r1,#8]            ;201
000054  6821              LDR      r1,[r4,#0]            ;203
000056  8aa6              LDRH     r6,[r4,#0x14]         ;202
000058  69a7              LDR      r7,[r4,#0x18]         ;203
00005a  688b              LDR      r3,[r1,#8]            ;203
00005c  433b              ORRS     r3,r3,r7              ;203
00005e  ea434306          ORR      r3,r3,r6,LSL #16      ;203
000062  608b              STR      r3,[r1,#8]            ;203
000064  6821              LDR      r1,[r4,#0]            ;206
000066  68cb              LDR      r3,[r1,#0xc]          ;206
000068  4003              ANDS     r3,r3,r0              ;206
00006a  60cb              STR      r3,[r1,#0xc]          ;206
00006c  6821              LDR      r1,[r4,#0]            ;208
00006e  8ba3              LDRH     r3,[r4,#0x1c]         ;207
000070  6a27              LDR      r7,[r4,#0x20]         ;208
000072  68ce              LDR      r6,[r1,#0xc]          ;208
000074  433e              ORRS     r6,r6,r7              ;208
000076  ea464603          ORR      r6,r6,r3,LSL #16      ;208
00007a  60ce              STR      r6,[r1,#0xc]          ;208
00007c  6821              LDR      r1,[r4,#0]            ;211
00007e  690b              LDR      r3,[r1,#0x10]         ;211
000080  4003              ANDS     r3,r3,r0              ;211
000082  610b              STR      r3,[r1,#0x10]         ;211
000084  6821              LDR      r1,[r4,#0]            ;213
000086  8ca6              LDRH     r6,[r4,#0x24]         ;212
000088  6aa7              LDR      r7,[r4,#0x28]         ;213
00008a  690b              LDR      r3,[r1,#0x10]         ;213
00008c  433b              ORRS     r3,r3,r7              ;213
00008e  ea434306          ORR      r3,r3,r6,LSL #16      ;213
000092  610b              STR      r3,[r1,#0x10]         ;213
000094  6821              LDR      r1,[r4,#0]            ;216
000096  694b              LDR      r3,[r1,#0x14]         ;216
000098  4003              ANDS     r3,r3,r0              ;216
00009a  614b              STR      r3,[r1,#0x14]         ;216
00009c  6821              LDR      r1,[r4,#0]            ;218
00009e  8da3              LDRH     r3,[r4,#0x2c]         ;217
0000a0  6b26              LDR      r6,[r4,#0x30]         ;218
0000a2  6948              LDR      r0,[r1,#0x14]         ;218
0000a4  4330              ORRS     r0,r0,r6              ;218
0000a6  ea404003          ORR      r0,r0,r3,LSL #16      ;218
0000aa  6148              STR      r0,[r1,#0x14]         ;218
0000ac  6823              LDR      r3,[r4,#0]            ;223
0000ae  f8941035          LDRB     r1,[r4,#0x35]         ;221
0000b2  f8940036          LDRB     r0,[r4,#0x36]         ;222
0000b6  6ade              LDR      r6,[r3,#0x2c]         ;223
0000b8  0400              LSLS     r0,r0,#16             ;222
0000ba  f006467f          AND      r6,r6,#0xff000000     ;223
0000be  62de              STR      r6,[r3,#0x2c]         ;223
0000c0  6823              LDR      r3,[r4,#0]            ;224
0000c2  ea402001          ORR      r0,r0,r1,LSL #8       ;224
0000c6  f8946034          LDRB     r6,[r4,#0x34]         ;224
0000ca  6ad9              LDR      r1,[r3,#0x2c]         ;224
0000cc  4331              ORRS     r1,r1,r6              ;224
0000ce  4301              ORRS     r1,r1,r0              ;224
0000d0  62d9              STR      r1,[r3,#0x2c]         ;224
0000d2  6820              LDR      r0,[r4,#0]            ;227
0000d4  6b41              LDR      r1,[r0,#0x34]         ;227
0000d6  f0410104          ORR      r1,r1,#4              ;227
0000da  6341              STR      r1,[r0,#0x34]         ;227
0000dc  6820              LDR      r0,[r4,#0]            ;230
0000de  6b41              LDR      r1,[r0,#0x34]         ;230
0000e0  f0410102          ORR      r1,r1,#2              ;230
0000e4  6341              STR      r1,[r0,#0x34]         ;230
0000e6  6820              LDR      r0,[r4,#0]            ;233
0000e8  6981              LDR      r1,[r0,#0x18]         ;233
0000ea  f0410101          ORR      r1,r1,#1              ;233
0000ee  6181              STR      r1,[r0,#0x18]         ;233
0000f0  f8c450a8          STR      r5,[r4,#0xa8]         ;236
0000f4  f8c420a4          STR      r2,[r4,#0xa4]         ;239
0000f8  2000              MOVS     r0,#0                 ;241
0000fa  e78b              B        |L21.20|
;;;243    
                          ENDP

                  |L21.252|
                          DCD      0xf000f800

                          AREA ||i.HAL_LTDC_LineEventCallback||, CODE, READONLY, ALIGN=1

                  HAL_LTDC_LineEventCallback PROC
;;;439      */
;;;440    __weak void HAL_LTDC_LineEventCallback(LTDC_HandleTypeDef *hltdc)
000000  4770              BX       lr
;;;441    {
;;;442      /* Prevent unused argument(s) compilation warning */
;;;443      UNUSED(hltdc);
;;;444      
;;;445      /* NOTE : This function Should not be modified, when the callback is needed,
;;;446                the HAL_LTDC_LineEventCallback could be implemented in the user file
;;;447       */
;;;448    }
;;;449    
                          ENDP


                          AREA ||i.HAL_LTDC_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_LTDC_MspDeInit PROC
;;;290      */
;;;291    __weak void HAL_LTDC_MspDeInit(LTDC_HandleTypeDef* hltdc)
000000  4770              BX       lr
;;;292    {
;;;293      /* Prevent unused argument(s) compilation warning */
;;;294      UNUSED(hltdc);
;;;295      
;;;296      /* NOTE : This function Should not be modified, when the callback is needed,
;;;297                the HAL_LTDC_MspDeInit could be implemented in the user file
;;;298       */
;;;299    }
;;;300    
                          ENDP


                          AREA ||i.HAL_LTDC_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_LTDC_MspInit PROC
;;;274      */
;;;275    __weak void HAL_LTDC_MspInit(LTDC_HandleTypeDef* hltdc)
000000  4770              BX       lr
;;;276    {
;;;277      /* Prevent unused argument(s) compilation warning */
;;;278      UNUSED(hltdc);
;;;279      
;;;280      /* NOTE : This function Should not be modified, when the callback is needed,
;;;281                the HAL_LTDC_MspInit could be implemented in the user file
;;;282       */ 
;;;283    }
;;;284    
                          ENDP


                          AREA ||i.HAL_LTDC_ProgramLineEvent||, CODE, READONLY, ALIGN=2

                  HAL_LTDC_ProgramLineEvent PROC
;;;1159     */
;;;1160   HAL_StatusTypeDef HAL_LTDC_ProgramLineEvent(LTDC_HandleTypeDef *hltdc, uint32_t Line)
000000  b570              PUSH     {r4-r6,lr}
;;;1161   {
;;;1162     /* Process locked */
;;;1163     __HAL_LOCK(hltdc);
000002  f8d020a0          LDR      r2,[r0,#0xa0]
000006  2a01              CMP      r2,#1
000008  d010              BEQ      |L25.44|
00000a  2201              MOVS     r2,#1
;;;1164   
;;;1165     /* Change LTDC peripheral state */
;;;1166     hltdc->State = HAL_LTDC_STATE_BUSY;
00000c  2302              MOVS     r3,#2
00000e  e9c02328          STRD     r2,r3,[r0,#0xa0]
;;;1167   
;;;1168     /* Check the parameters */
;;;1169     assert_param(IS_LTDC_LIPOS(Line));
;;;1170   
;;;1171     /* Enable the Line interrupt */
;;;1172     __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_LI);
000012  f8503ba0          LDR      r3,[r0],#0xa0
;;;1173   
;;;1174     /* Sets the Line Interrupt position */
;;;1175     LTDC->LIPCR = (uint32_t)Line;
000016  4d06              LDR      r5,|L25.48|
;;;1176   
;;;1177     /* Change the LTDC state*/
;;;1178     hltdc->State = HAL_LTDC_STATE_READY;
;;;1179   
;;;1180     /* Process unlocked */
;;;1181     __HAL_UNLOCK(hltdc);
000018  2400              MOVS     r4,#0
00001a  6b5e              LDR      r6,[r3,#0x34]         ;1172
00001c  f0460601          ORR      r6,r6,#1              ;1172
000020  635e              STR      r6,[r3,#0x34]         ;1172
000022  6029              STR      r1,[r5,#0]            ;1175
000024  6042              STR      r2,[r0,#4]            ;1178
;;;1182   
;;;1183     return HAL_OK;
000026  6004              STR      r4,[r0,#0]
000028  4620              MOV      r0,r4
;;;1184   }
00002a  bd70              POP      {r4-r6,pc}
                  |L25.44|
00002c  2002              MOVS     r0,#2                 ;1163
00002e  bd70              POP      {r4-r6,pc}
;;;1185   
                          ENDP

                  |L25.48|
                          DCD      0x40016840

                          AREA ||i.HAL_LTDC_Reload||, CODE, READONLY, ALIGN=1

                  HAL_LTDC_Reload PROC
;;;1194     */
;;;1195   HAL_StatusTypeDef  HAL_LTDC_Reload(LTDC_HandleTypeDef *hltdc, uint32_t ReloadType)
000000  b530              PUSH     {r4,r5,lr}
;;;1196   {
;;;1197     assert_param(IS_LTDC_RELAOD(ReloadType));
;;;1198   
;;;1199     /* Process locked */
;;;1200     __HAL_LOCK(hltdc);
000002  f8d020a0          LDR      r2,[r0,#0xa0]
000006  2a01              CMP      r2,#1
000008  d011              BEQ      |L26.46|
00000a  2201              MOVS     r2,#1
;;;1201   
;;;1202     /* Change LTDC peripheral state */
;;;1203     hltdc->State = HAL_LTDC_STATE_BUSY;  
00000c  2302              MOVS     r3,#2
00000e  e9c02328          STRD     r2,r3,[r0,#0xa0]
;;;1204     
;;;1205     /* Enable the Reload interrupt */  
;;;1206     __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_RR);
000012  f8503ba0          LDR      r3,[r0],#0xa0
;;;1207          
;;;1208     /* Apply Reload type */
;;;1209     hltdc->Instance->SRCR = ReloadType;        
;;;1210   
;;;1211     /* Change the LTDC state*/
;;;1212     hltdc->State = HAL_LTDC_STATE_READY;
;;;1213     
;;;1214     /* Process unlocked */
;;;1215     __HAL_UNLOCK(hltdc);
000016  2400              MOVS     r4,#0
000018  6b5d              LDR      r5,[r3,#0x34]         ;1206
00001a  f0450508          ORR      r5,r5,#8              ;1206
00001e  635d              STR      r5,[r3,#0x34]         ;1206
000020  f8503ca0          LDR      r3,[r0,#-0xa0]        ;1209
000024  6259              STR      r1,[r3,#0x24]         ;1209
000026  6042              STR      r2,[r0,#4]            ;1212
;;;1216     
;;;1217     return HAL_OK;
000028  6004              STR      r4,[r0,#0]
00002a  4620              MOV      r0,r4
;;;1218   }
00002c  bd30              POP      {r4,r5,pc}
                  |L26.46|
00002e  2002              MOVS     r0,#2                 ;1200
000030  bd30              POP      {r4,r5,pc}
;;;1219   
                          ENDP


                          AREA ||i.HAL_LTDC_ReloadEventCallback||, CODE, READONLY, ALIGN=1

                  HAL_LTDC_ReloadEventCallback PROC
;;;455      */
;;;456    __weak void HAL_LTDC_ReloadEventCallback(LTDC_HandleTypeDef *hltdc)
000000  4770              BX       lr
;;;457    {
;;;458      /* Prevent unused argument(s) compilation warning */
;;;459      UNUSED(hltdc);
;;;460      
;;;461      /* NOTE : This function Should not be modified, when the callback is needed,
;;;462                the HAL_LTDC_ReloadEvenCallback could be implemented in the user file
;;;463       */
;;;464    }
;;;465    
                          ENDP


                          AREA ||i.HAL_LTDC_SetAddress||, CODE, READONLY, ALIGN=1

                  HAL_LTDC_SetAddress PROC
;;;1044     */
;;;1045   HAL_StatusTypeDef HAL_LTDC_SetAddress(LTDC_HandleTypeDef *hltdc, uint32_t Address, uint32_t LayerIdx)
000000  b570              PUSH     {r4-r6,lr}
;;;1046   {
000002  4604              MOV      r4,r0
;;;1047     LTDC_LayerCfgTypeDef *pLayerCfg;
;;;1048   
;;;1049     /* Process locked */
;;;1050     __HAL_LOCK(hltdc);
000004  f8d000a0          LDR      r0,[r0,#0xa0]
000008  460b              MOV      r3,r1                 ;1046
00000a  2801              CMP      r0,#1
00000c  d016              BEQ      |L28.60|
;;;1051   
;;;1052     /* Change LTDC peripheral state */
;;;1053     hltdc->State = HAL_LTDC_STATE_BUSY;
;;;1054   
;;;1055     /* Check the parameters */
;;;1056     assert_param(IS_LTDC_LAYER(LayerIdx));
;;;1057   
;;;1058     /* Get layer configuration from handle structure */
;;;1059     pLayerCfg = &hltdc->LayerCfg[LayerIdx];
00000e  eb020082          ADD      r0,r2,r2,LSL #2
000012  2501              MOVS     r5,#1                 ;1050
000014  eb0001c2          ADD      r1,r0,r2,LSL #3
000018  2002              MOVS     r0,#2                 ;1053
00001a  eb040181          ADD      r1,r4,r1,LSL #2
00001e  e9c45028          STRD     r5,r0,[r4,#0xa0]      ;1053
;;;1060   
;;;1061     /* Reconfigure the Address */
;;;1062     pLayerCfg->FBStartAdress = Address;
;;;1063   
;;;1064     /* Set LTDC parameters */
;;;1065     LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);
000022  4620              MOV      r0,r4
000024  65cb              STR      r3,[r1,#0x5c]
000026  3138              ADDS     r1,r1,#0x38
000028  f7fffffe          BL       LTDC_SetConfig
;;;1066   
;;;1067     /* Sets the Reload type */
;;;1068     hltdc->Instance->SRCR = LTDC_SRCR_IMR;
00002c  6821              LDR      r1,[r4,#0]
;;;1069   
;;;1070     /* Change the LTDC state*/
;;;1071     hltdc->State = HAL_LTDC_STATE_READY;
;;;1072   
;;;1073     /* Process unlocked */
;;;1074     __HAL_UNLOCK(hltdc);
00002e  2000              MOVS     r0,#0
000030  624d              STR      r5,[r1,#0x24]         ;1068
000032  f8c450a4          STR      r5,[r4,#0xa4]         ;1071
000036  f8c400a0          STR      r0,[r4,#0xa0]         ;1050
;;;1075   
;;;1076     return HAL_OK;
;;;1077   }
00003a  bd70              POP      {r4-r6,pc}
                  |L28.60|
00003c  2002              MOVS     r0,#2                 ;1050
00003e  bd70              POP      {r4-r6,pc}
;;;1078   
                          ENDP


                          AREA ||i.HAL_LTDC_SetAddress_NoReload||, CODE, READONLY, ALIGN=1

                  HAL_LTDC_SetAddress_NoReload PROC
;;;1487     */
;;;1488   HAL_StatusTypeDef HAL_LTDC_SetAddress_NoReload(LTDC_HandleTypeDef *hltdc, uint32_t Address, uint32_t LayerIdx)
000000  b570              PUSH     {r4-r6,lr}
;;;1489   {
000002  4604              MOV      r4,r0
;;;1490     LTDC_LayerCfgTypeDef *pLayerCfg;
;;;1491   
;;;1492     /* Process locked */
;;;1493     __HAL_LOCK(hltdc);
000004  f8d000a0          LDR      r0,[r0,#0xa0]
000008  460b              MOV      r3,r1                 ;1489
00000a  2801              CMP      r0,#1
00000c  d014              BEQ      |L29.56|
;;;1494   
;;;1495     /* Change LTDC peripheral state */
;;;1496     hltdc->State = HAL_LTDC_STATE_BUSY;
;;;1497   
;;;1498     /* Check the parameters */
;;;1499     assert_param(IS_LTDC_LAYER(LayerIdx));
;;;1500   
;;;1501     /* Get layer configuration from handle structure */
;;;1502     pLayerCfg = &hltdc->LayerCfg[LayerIdx];
00000e  eb020082          ADD      r0,r2,r2,LSL #2
000012  2501              MOVS     r5,#1                 ;1493
000014  eb0001c2          ADD      r1,r0,r2,LSL #3
000018  2002              MOVS     r0,#2                 ;1496
00001a  eb040181          ADD      r1,r4,r1,LSL #2
00001e  e9c45028          STRD     r5,r0,[r4,#0xa0]      ;1496
;;;1503   
;;;1504     /* Reconfigure the Address */
;;;1505     pLayerCfg->FBStartAdress = Address;
;;;1506   
;;;1507     /* Set LTDC parameters */
;;;1508     LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);
000022  4620              MOV      r0,r4
000024  65cb              STR      r3,[r1,#0x5c]
000026  3138              ADDS     r1,r1,#0x38
000028  f7fffffe          BL       LTDC_SetConfig
;;;1509   
;;;1510     /* Do not Sets the Reload  */
;;;1511   
;;;1512     /* Change the LTDC state*/
;;;1513     hltdc->State = HAL_LTDC_STATE_READY;
;;;1514   
;;;1515     /* Process unlocked */
;;;1516     __HAL_UNLOCK(hltdc);
00002c  2000              MOVS     r0,#0
00002e  f8c450a4          STR      r5,[r4,#0xa4]         ;1513
000032  f8c400a0          STR      r0,[r4,#0xa0]         ;1493
;;;1517   
;;;1518     return HAL_OK;
;;;1519   }
000036  bd70              POP      {r4-r6,pc}
                  |L29.56|
000038  2002              MOVS     r0,#2                 ;1493
00003a  bd70              POP      {r4-r6,pc}
;;;1520   
                          ENDP


                          AREA ||i.HAL_LTDC_SetAlpha||, CODE, READONLY, ALIGN=1

                  HAL_LTDC_SetAlpha PROC
;;;1000     */
;;;1001   HAL_StatusTypeDef HAL_LTDC_SetAlpha(LTDC_HandleTypeDef *hltdc, uint32_t Alpha, uint32_t LayerIdx)
000000  b570              PUSH     {r4-r6,lr}
;;;1002   {
000002  4604              MOV      r4,r0
;;;1003     LTDC_LayerCfgTypeDef *pLayerCfg;
;;;1004   
;;;1005     /* Process locked */
;;;1006     __HAL_LOCK(hltdc);
000004  f8d000a0          LDR      r0,[r0,#0xa0]
000008  460b              MOV      r3,r1                 ;1002
00000a  2801              CMP      r0,#1
00000c  d016              BEQ      |L30.60|
;;;1007   
;;;1008     /* Change LTDC peripheral state */
;;;1009     hltdc->State = HAL_LTDC_STATE_BUSY;
;;;1010   
;;;1011     /* Check the parameters */
;;;1012     assert_param(IS_LTDC_ALPHA(Alpha));
;;;1013     assert_param(IS_LTDC_LAYER(LayerIdx));
;;;1014   
;;;1015     /* Get layer configuration from handle structure */
;;;1016     pLayerCfg = &hltdc->LayerCfg[LayerIdx];
00000e  eb020082          ADD      r0,r2,r2,LSL #2
000012  2501              MOVS     r5,#1                 ;1006
000014  eb0001c2          ADD      r1,r0,r2,LSL #3
000018  2002              MOVS     r0,#2                 ;1009
00001a  eb040181          ADD      r1,r4,r1,LSL #2
00001e  e9c45028          STRD     r5,r0,[r4,#0xa0]      ;1009
;;;1017   
;;;1018     /* Reconfigure the Alpha value */
;;;1019     pLayerCfg->Alpha = Alpha;
;;;1020   
;;;1021     /* Set LTDC parameters */
;;;1022     LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);
000022  4620              MOV      r0,r4
000024  64cb              STR      r3,[r1,#0x4c]
000026  3138              ADDS     r1,r1,#0x38
000028  f7fffffe          BL       LTDC_SetConfig
;;;1023   
;;;1024     /* Sets the Reload type */
;;;1025     hltdc->Instance->SRCR = LTDC_SRCR_IMR;
00002c  6821              LDR      r1,[r4,#0]
;;;1026   
;;;1027     /* Change the LTDC state*/
;;;1028     hltdc->State = HAL_LTDC_STATE_READY;
;;;1029   
;;;1030     /* Process unlocked */
;;;1031     __HAL_UNLOCK(hltdc);
00002e  2000              MOVS     r0,#0
000030  624d              STR      r5,[r1,#0x24]         ;1025
000032  f8c450a4          STR      r5,[r4,#0xa4]         ;1028
000036  f8c400a0          STR      r0,[r4,#0xa0]         ;1006
;;;1032   
;;;1033     return HAL_OK;
;;;1034   }
00003a  bd70              POP      {r4-r6,pc}
                  |L30.60|
00003c  2002              MOVS     r0,#2                 ;1006
00003e  bd70              POP      {r4-r6,pc}
;;;1035   /**
                          ENDP


                          AREA ||i.HAL_LTDC_SetAlpha_NoReload||, CODE, READONLY, ALIGN=1

                  HAL_LTDC_SetAlpha_NoReload PROC
;;;1442     */
;;;1443   HAL_StatusTypeDef HAL_LTDC_SetAlpha_NoReload(LTDC_HandleTypeDef *hltdc, uint32_t Alpha, uint32_t LayerIdx)
000000  b570              PUSH     {r4-r6,lr}
;;;1444   {
000002  4604              MOV      r4,r0
;;;1445     LTDC_LayerCfgTypeDef *pLayerCfg;
;;;1446   
;;;1447     /* Process locked */
;;;1448     __HAL_LOCK(hltdc);
000004  f8d000a0          LDR      r0,[r0,#0xa0]
000008  460b              MOV      r3,r1                 ;1444
00000a  2801              CMP      r0,#1
00000c  d014              BEQ      |L31.56|
;;;1449   
;;;1450     /* Change LTDC peripheral state */
;;;1451     hltdc->State = HAL_LTDC_STATE_BUSY;
;;;1452   
;;;1453     /* Check the parameters */
;;;1454     assert_param(IS_LTDC_ALPHA(Alpha));
;;;1455     assert_param(IS_LTDC_LAYER(LayerIdx));
;;;1456   
;;;1457     /* Get layer configuration from handle structure */
;;;1458     pLayerCfg = &hltdc->LayerCfg[LayerIdx];
00000e  eb020082          ADD      r0,r2,r2,LSL #2
000012  2501              MOVS     r5,#1                 ;1448
000014  eb0001c2          ADD      r1,r0,r2,LSL #3
000018  2002              MOVS     r0,#2                 ;1451
00001a  eb040181          ADD      r1,r4,r1,LSL #2
00001e  e9c45028          STRD     r5,r0,[r4,#0xa0]      ;1451
;;;1459   
;;;1460     /* Reconfigure the Alpha value */
;;;1461     pLayerCfg->Alpha = Alpha;
;;;1462   
;;;1463     /* Set LTDC parameters */
;;;1464     LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);
000022  4620              MOV      r0,r4
000024  64cb              STR      r3,[r1,#0x4c]
000026  3138              ADDS     r1,r1,#0x38
000028  f7fffffe          BL       LTDC_SetConfig
;;;1465   
;;;1466     /* Do not Sets the Reload  */
;;;1467   
;;;1468     /* Change the LTDC state*/
;;;1469     hltdc->State = HAL_LTDC_STATE_READY;
;;;1470   
;;;1471     /* Process unlocked */
;;;1472     __HAL_UNLOCK(hltdc);
00002c  2000              MOVS     r0,#0
00002e  f8c450a4          STR      r5,[r4,#0xa4]         ;1469
000032  f8c400a0          STR      r0,[r4,#0xa0]         ;1448
;;;1473   
;;;1474     return HAL_OK;
;;;1475   }
000036  bd70              POP      {r4-r6,pc}
                  |L31.56|
000038  2002              MOVS     r0,#2                 ;1448
00003a  bd70              POP      {r4-r6,pc}
;;;1476   
                          ENDP


                          AREA ||i.HAL_LTDC_SetPitch||, CODE, READONLY, ALIGN=2

                  HAL_LTDC_SetPitch PROC
;;;1091     */
;;;1092   HAL_StatusTypeDef HAL_LTDC_SetPitch(LTDC_HandleTypeDef *hltdc, uint32_t LinePitchInPixels, uint32_t LayerIdx)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1093   {
;;;1094     uint32_t tmp = 0;
;;;1095     uint32_t pitchUpdate = 0;
;;;1096     uint32_t pixelFormat = 0;
;;;1097     
;;;1098     /* Process locked */
;;;1099     __HAL_LOCK(hltdc);
000002  f8d030a0          LDR      r3,[r0,#0xa0]
000006  2b01              CMP      r3,#1
000008  d035              BEQ      |L32.118|
00000a  2601              MOVS     r6,#1
;;;1100     
;;;1101     /* Change LTDC peripheral state */
;;;1102     hltdc->State = HAL_LTDC_STATE_BUSY;
00000c  2302              MOVS     r3,#2
;;;1103     
;;;1104     /* Check the parameters */
;;;1105     assert_param(IS_LTDC_LAYER(LayerIdx));
;;;1106     
;;;1107     /* get LayerIdx used pixel format */
;;;1108     pixelFormat = hltdc->LayerCfg[LayerIdx].PixelFormat;
00000e  eb020482          ADD      r4,r2,r2,LSL #2
000012  eb0404c2          ADD      r4,r4,r2,LSL #3
000016  e9c06328          STRD     r6,r3,[r0,#0xa0]      ;1102
00001a  eb000384          ADD      r3,r0,r4,LSL #2
00001e  6c9b              LDR      r3,[r3,#0x48]
000020  b35b              CBZ      r3,|L32.122|
;;;1109     
;;;1110     if(pixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
;;;1111     {
;;;1112       tmp = 4;
;;;1113     }
;;;1114     else if (pixelFormat == LTDC_PIXEL_FORMAT_RGB888)
000022  2b01              CMP      r3,#1
000024  d02b              BEQ      |L32.126|
;;;1115     {
;;;1116       tmp = 3;
;;;1117     }
;;;1118     else if((pixelFormat == LTDC_PIXEL_FORMAT_ARGB4444) || \
000026  2b04              CMP      r3,#4
000028  d02b              BEQ      |L32.130|
;;;1119             (pixelFormat == LTDC_PIXEL_FORMAT_RGB565)   || \
00002a  2b02              CMP      r3,#2
00002c  d029              BEQ      |L32.130|
;;;1120             (pixelFormat == LTDC_PIXEL_FORMAT_ARGB1555) || \
00002e  2b03              CMP      r3,#3
000030  d027              BEQ      |L32.130|
;;;1121            (pixelFormat == LTDC_PIXEL_FORMAT_AL88))
000032  2b07              CMP      r3,#7
000034  d025              BEQ      |L32.130|
;;;1122     {
;;;1123       tmp = 2;
;;;1124     }
;;;1125     else
;;;1126     {
;;;1127       tmp = 1;
000036  2301              MOVS     r3,#1
                  |L32.56|
;;;1128     }
;;;1129     
;;;1130     pitchUpdate = ((LinePitchInPixels * tmp) << 16);
;;;1131     
;;;1132     /* Clear previously set standard pitch */
;;;1133     LTDC_LAYER(hltdc, LayerIdx)->CFBLR &= ~LTDC_LxCFBLR_CFBP;
000038  6805              LDR      r5,[r0,#0]
00003a  f04f0cb0          MOV      r12,#0xb0
00003e  4f12              LDR      r7,|L32.136|
000040  eb0c12c2          ADD      r2,r12,r2,LSL #7
;;;1134     
;;;1135     /* Sets the Reload type as immediate update of LTDC pitch configured above */
;;;1136     LTDC->SRCR |= LTDC_SRCR_IMR;
000044  4c11              LDR      r4,|L32.140|
000046  4359              MULS     r1,r3,r1              ;1130
000048  58ab              LDR      r3,[r5,r2]            ;1133
00004a  403b              ANDS     r3,r3,r7              ;1133
00004c  50ab              STR      r3,[r5,r2]            ;1133
00004e  6823              LDR      r3,[r4,#0]
;;;1137     
;;;1138     /* Set new line pitch value */
;;;1139     LTDC_LAYER(hltdc, LayerIdx)->CFBLR |= pitchUpdate;
;;;1140     
;;;1141     /* Sets the Reload type as immediate update of LTDC pitch configured above */
;;;1142     LTDC->SRCR |= LTDC_SRCR_IMR;
;;;1143     
;;;1144     /* Change the LTDC state*/
;;;1145     hltdc->State = HAL_LTDC_STATE_READY;
;;;1146     
;;;1147     /* Process unlocked */
;;;1148     __HAL_UNLOCK(hltdc);
000050  2700              MOVS     r7,#0
000052  f0430301          ORR      r3,r3,#1              ;1136
000056  6023              STR      r3,[r4,#0]            ;1136
000058  6803              LDR      r3,[r0,#0]            ;1139
00005a  589d              LDR      r5,[r3,r2]            ;1139
00005c  ea454501          ORR      r5,r5,r1,LSL #16      ;1139
000060  509d              STR      r5,[r3,r2]            ;1139
000062  6821              LDR      r1,[r4,#0]            ;1142
000064  f0410101          ORR      r1,r1,#1              ;1142
000068  6021              STR      r1,[r4,#0]            ;1142
00006a  f8c060a4          STR      r6,[r0,#0xa4]         ;1145
;;;1149     
;;;1150     return HAL_OK;  
00006e  f8c070a0          STR      r7,[r0,#0xa0]
000072  4638              MOV      r0,r7
;;;1151   }
000074  bdf0              POP      {r4-r7,pc}
                  |L32.118|
000076  2002              MOVS     r0,#2                 ;1099
000078  bdf0              POP      {r4-r7,pc}
                  |L32.122|
00007a  2304              MOVS     r3,#4                 ;1112
00007c  e7dc              B        |L32.56|
                  |L32.126|
00007e  2303              MOVS     r3,#3                 ;1116
000080  e7da              B        |L32.56|
                  |L32.130|
000082  2302              MOVS     r3,#2                 ;1123
000084  e7d8              B        |L32.56|
;;;1152   
                          ENDP

000086  0000              DCW      0x0000
                  |L32.136|
                          DCD      0xe000ffff
                  |L32.140|
                          DCD      0x40016824

                          AREA ||i.HAL_LTDC_SetPitch_NoReload||, CODE, READONLY, ALIGN=2

                  HAL_LTDC_SetPitch_NoReload PROC
;;;1534     */
;;;1535   HAL_StatusTypeDef HAL_LTDC_SetPitch_NoReload(LTDC_HandleTypeDef *hltdc, uint32_t LinePitchInPixels, uint32_t LayerIdx)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1536   {
;;;1537     uint32_t tmp = 0;
;;;1538     uint32_t pitchUpdate = 0;
;;;1539     uint32_t pixelFormat = 0;
;;;1540     
;;;1541     /* Process locked */
;;;1542     __HAL_LOCK(hltdc);
000002  f8d030a0          LDR      r3,[r0,#0xa0]
000006  2b01              CMP      r3,#1
000008  d02b              BEQ      |L33.98|
00000a  2401              MOVS     r4,#1
;;;1543     
;;;1544     /* Change LTDC peripheral state */
;;;1545     hltdc->State = HAL_LTDC_STATE_BUSY;
00000c  2302              MOVS     r3,#2
;;;1546     
;;;1547     /* Check the parameters */
;;;1548     assert_param(IS_LTDC_LAYER(LayerIdx));
;;;1549     
;;;1550     /* get LayerIdx used pixel format */
;;;1551     pixelFormat = hltdc->LayerCfg[LayerIdx].PixelFormat;
00000e  eb020582          ADD      r5,r2,r2,LSL #2
000012  eb0505c2          ADD      r5,r5,r2,LSL #3
000016  e9c04328          STRD     r4,r3,[r0,#0xa0]      ;1545
00001a  eb000385          ADD      r3,r0,r5,LSL #2
00001e  6c9b              LDR      r3,[r3,#0x48]
000020  b30b              CBZ      r3,|L33.102|
;;;1552     
;;;1553     if(pixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
;;;1554     {
;;;1555       tmp = 4;
;;;1556     }
;;;1557     else if (pixelFormat == LTDC_PIXEL_FORMAT_RGB888)
000022  2b01              CMP      r3,#1
000024  d021              BEQ      |L33.106|
;;;1558     {
;;;1559       tmp = 3;
;;;1560     }
;;;1561     else if((pixelFormat == LTDC_PIXEL_FORMAT_ARGB4444) || \
000026  2b04              CMP      r3,#4
000028  d021              BEQ      |L33.110|
;;;1562             (pixelFormat == LTDC_PIXEL_FORMAT_RGB565)   || \
00002a  2b02              CMP      r3,#2
00002c  d01f              BEQ      |L33.110|
;;;1563             (pixelFormat == LTDC_PIXEL_FORMAT_ARGB1555) || \
00002e  2b03              CMP      r3,#3
000030  d01d              BEQ      |L33.110|
;;;1564            (pixelFormat == LTDC_PIXEL_FORMAT_AL88))
000032  2b07              CMP      r3,#7
000034  d01b              BEQ      |L33.110|
;;;1565     {
;;;1566       tmp = 2;
;;;1567     }
;;;1568     else
;;;1569     {
;;;1570       tmp = 1;
000036  2301              MOVS     r3,#1
                  |L33.56|
;;;1571     }
;;;1572     
;;;1573     pitchUpdate = ((LinePitchInPixels * tmp) << 16);
;;;1574     
;;;1575     /* Clear previously set standard pitch */
;;;1576     LTDC_LAYER(hltdc, LayerIdx)->CFBLR &= ~LTDC_LxCFBLR_CFBP;
000038  6805              LDR      r5,[r0,#0]
00003a  27b0              MOVS     r7,#0xb0
00003c  4e0d              LDR      r6,|L33.116|
00003e  eb0712c2          ADD      r2,r7,r2,LSL #7
000042  4359              MULS     r1,r3,r1              ;1573
000044  58ab              LDR      r3,[r5,r2]
;;;1577     
;;;1578     /* Set new line pitch value */
;;;1579     LTDC_LAYER(hltdc, LayerIdx)->CFBLR |= pitchUpdate;
;;;1580     
;;;1581     /* Do not Sets the Reload  */
;;;1582     
;;;1583     /* Change the LTDC state*/
;;;1584     hltdc->State = HAL_LTDC_STATE_READY;
;;;1585     
;;;1586     /* Process unlocked */
;;;1587     __HAL_UNLOCK(hltdc);
000046  2700              MOVS     r7,#0
000048  4033              ANDS     r3,r3,r6              ;1576
00004a  50ab              STR      r3,[r5,r2]            ;1576
00004c  6803              LDR      r3,[r0,#0]            ;1579
00004e  589d              LDR      r5,[r3,r2]            ;1579
000050  ea454501          ORR      r5,r5,r1,LSL #16      ;1579
000054  509d              STR      r5,[r3,r2]            ;1579
000056  f8c040a4          STR      r4,[r0,#0xa4]         ;1584
;;;1588     
;;;1589     return HAL_OK;  
00005a  f8c070a0          STR      r7,[r0,#0xa0]
00005e  4638              MOV      r0,r7
;;;1590   }
000060  bdf0              POP      {r4-r7,pc}
                  |L33.98|
000062  2002              MOVS     r0,#2                 ;1542
000064  bdf0              POP      {r4-r7,pc}
                  |L33.102|
000066  2304              MOVS     r3,#4                 ;1555
000068  e7e6              B        |L33.56|
                  |L33.106|
00006a  2303              MOVS     r3,#3                 ;1559
00006c  e7e4              B        |L33.56|
                  |L33.110|
00006e  2302              MOVS     r3,#2                 ;1566
000070  e7e2              B        |L33.56|
;;;1591   
                          ENDP

000072  0000              DCW      0x0000
                  |L33.116|
                          DCD      0xe000ffff

                          AREA ||i.HAL_LTDC_SetPixelFormat||, CODE, READONLY, ALIGN=1

                  HAL_LTDC_SetPixelFormat PROC
;;;955      */
;;;956    HAL_StatusTypeDef HAL_LTDC_SetPixelFormat(LTDC_HandleTypeDef *hltdc, uint32_t Pixelformat, uint32_t LayerIdx)
000000  b570              PUSH     {r4-r6,lr}
;;;957    {
000002  4604              MOV      r4,r0
;;;958      LTDC_LayerCfgTypeDef *pLayerCfg;
;;;959    
;;;960      /* Process locked */
;;;961      __HAL_LOCK(hltdc);
000004  f8d000a0          LDR      r0,[r0,#0xa0]
000008  460b              MOV      r3,r1                 ;957
00000a  2801              CMP      r0,#1
00000c  d016              BEQ      |L34.60|
;;;962    
;;;963      /* Change LTDC peripheral state */
;;;964      hltdc->State = HAL_LTDC_STATE_BUSY;
;;;965    
;;;966      /* Check the parameters */
;;;967      assert_param(IS_LTDC_LAYER(LayerIdx));
;;;968      assert_param(IS_LTDC_PIXEL_FORMAT(Pixelformat));
;;;969    
;;;970      /* Get layer configuration from handle structure */
;;;971      pLayerCfg = &hltdc->LayerCfg[LayerIdx];  
00000e  eb020082          ADD      r0,r2,r2,LSL #2
000012  2501              MOVS     r5,#1                 ;961
000014  eb0001c2          ADD      r1,r0,r2,LSL #3
000018  2002              MOVS     r0,#2                 ;964
00001a  eb040181          ADD      r1,r4,r1,LSL #2
00001e  e9c45028          STRD     r5,r0,[r4,#0xa0]      ;964
;;;972    
;;;973      /* Reconfigure the pixel format */
;;;974      pLayerCfg->PixelFormat = Pixelformat;
;;;975    
;;;976      /* Set LTDC parameters */
;;;977      LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);   
000022  4620              MOV      r0,r4
000024  648b              STR      r3,[r1,#0x48]
000026  3138              ADDS     r1,r1,#0x38
000028  f7fffffe          BL       LTDC_SetConfig
;;;978    
;;;979      /* Sets the Reload type */
;;;980      hltdc->Instance->SRCR = LTDC_SRCR_IMR;
00002c  6821              LDR      r1,[r4,#0]
;;;981    
;;;982      /* Change the LTDC state*/
;;;983      hltdc->State = HAL_LTDC_STATE_READY;
;;;984    
;;;985      /* Process unlocked */
;;;986      __HAL_UNLOCK(hltdc);
00002e  2000              MOVS     r0,#0
000030  624d              STR      r5,[r1,#0x24]         ;980
000032  f8c450a4          STR      r5,[r4,#0xa4]         ;983
000036  f8c400a0          STR      r0,[r4,#0xa0]         ;961
;;;987    
;;;988      return HAL_OK;
;;;989    }
00003a  bd70              POP      {r4-r6,pc}
                  |L34.60|
00003c  2002              MOVS     r0,#2                 ;961
00003e  bd70              POP      {r4-r6,pc}
;;;990    
                          ENDP


                          AREA ||i.HAL_LTDC_SetPixelFormat_NoReload||, CODE, READONLY, ALIGN=1

                  HAL_LTDC_SetPixelFormat_NoReload PROC
;;;1397     */
;;;1398   HAL_StatusTypeDef HAL_LTDC_SetPixelFormat_NoReload(LTDC_HandleTypeDef *hltdc, uint32_t Pixelformat, uint32_t LayerIdx)
000000  b570              PUSH     {r4-r6,lr}
;;;1399   {
000002  4604              MOV      r4,r0
;;;1400     LTDC_LayerCfgTypeDef *pLayerCfg;
;;;1401   
;;;1402     /* Process locked */
;;;1403     __HAL_LOCK(hltdc);
000004  f8d000a0          LDR      r0,[r0,#0xa0]
000008  460b              MOV      r3,r1                 ;1399
00000a  2801              CMP      r0,#1
00000c  d014              BEQ      |L35.56|
;;;1404   
;;;1405     /* Change LTDC peripheral state */
;;;1406     hltdc->State = HAL_LTDC_STATE_BUSY;
;;;1407   
;;;1408     /* Check the parameters */
;;;1409     assert_param(IS_LTDC_LAYER(LayerIdx));
;;;1410     assert_param(IS_LTDC_PIXEL_FORMAT(Pixelformat));
;;;1411   
;;;1412     /* Get layer configuration from handle structure */
;;;1413     pLayerCfg = &hltdc->LayerCfg[LayerIdx];  
00000e  eb020082          ADD      r0,r2,r2,LSL #2
000012  2501              MOVS     r5,#1                 ;1403
000014  eb0001c2          ADD      r1,r0,r2,LSL #3
000018  2002              MOVS     r0,#2                 ;1406
00001a  eb040181          ADD      r1,r4,r1,LSL #2
00001e  e9c45028          STRD     r5,r0,[r4,#0xa0]      ;1406
;;;1414   
;;;1415     /* Reconfigure the pixel format */
;;;1416     pLayerCfg->PixelFormat = Pixelformat;
;;;1417   
;;;1418     /* Set LTDC parameters */
;;;1419     LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);   
000022  4620              MOV      r0,r4
000024  648b              STR      r3,[r1,#0x48]
000026  3138              ADDS     r1,r1,#0x38
000028  f7fffffe          BL       LTDC_SetConfig
;;;1420   
;;;1421     /* Do not Sets the Reload  */
;;;1422   
;;;1423     /* Change the LTDC state*/
;;;1424     hltdc->State = HAL_LTDC_STATE_READY;
;;;1425   
;;;1426     /* Process unlocked */
;;;1427     __HAL_UNLOCK(hltdc);
00002c  2000              MOVS     r0,#0
00002e  f8c450a4          STR      r5,[r4,#0xa4]         ;1424
000032  f8c400a0          STR      r0,[r4,#0xa0]         ;1403
;;;1428   
;;;1429     return HAL_OK;
;;;1430   }
000036  bd70              POP      {r4-r6,pc}
                  |L35.56|
000038  2002              MOVS     r0,#2                 ;1403
00003a  bd70              POP      {r4-r6,pc}
;;;1431   
                          ENDP


                          AREA ||i.HAL_LTDC_SetWindowPosition||, CODE, READONLY, ALIGN=1

                  HAL_LTDC_SetWindowPosition PROC
;;;902      */
;;;903    HAL_StatusTypeDef HAL_LTDC_SetWindowPosition(LTDC_HandleTypeDef *hltdc, uint32_t X0, uint32_t Y0, uint32_t LayerIdx)
000000  b570              PUSH     {r4-r6,lr}
;;;904    {
000002  4604              MOV      r4,r0
;;;905      LTDC_LayerCfgTypeDef *pLayerCfg;
;;;906      
;;;907      /* Process locked */
;;;908      __HAL_LOCK(hltdc);
000004  f8d000a0          LDR      r0,[r0,#0xa0]
000008  460e              MOV      r6,r1                 ;904
00000a  2801              CMP      r0,#1
00000c  d01e              BEQ      |L36.76|
;;;909    
;;;910      /* Change LTDC peripheral state */
;;;911      hltdc->State = HAL_LTDC_STATE_BUSY;
;;;912    
;;;913      /* Get layer configuration from handle structure */
;;;914      pLayerCfg = &hltdc->LayerCfg[LayerIdx];
00000e  eb030083          ADD      r0,r3,r3,LSL #2
000012  2501              MOVS     r5,#1                 ;908
000014  eb0001c3          ADD      r1,r0,r3,LSL #3
000018  2002              MOVS     r0,#2                 ;911
00001a  eb040181          ADD      r1,r4,r1,LSL #2
00001e  e9c45028          STRD     r5,r0,[r4,#0xa0]      ;911
;;;915    
;;;916      /* Check the parameters */
;;;917      assert_param(IS_LTDC_LAYER(LayerIdx));
;;;918      assert_param(IS_LTDC_HCONFIGST(pLayerCfg->WindowX0));
;;;919      assert_param(IS_LTDC_HCONFIGSP(pLayerCfg->WindowX1));
;;;920      assert_param(IS_LTDC_VCONFIGST(pLayerCfg->WindowY0));
;;;921      assert_param(IS_LTDC_VCONFIGSP(pLayerCfg->WindowY1));
;;;922    
;;;923      /* update horizontal start/stop */
;;;924      pLayerCfg->WindowX0 = X0;
;;;925      pLayerCfg->WindowX1 = X0 + pLayerCfg->ImageWidth;
000022  638e              STR      r6,[r1,#0x38]
000024  6e08              LDR      r0,[r1,#0x60]
000026  4430              ADD      r0,r0,r6
000028  e9c1020f          STRD     r0,r2,[r1,#0x3c]
;;;926    
;;;927      /* update vertical start/stop */
;;;928      pLayerCfg->WindowY0 = Y0;
;;;929      pLayerCfg->WindowY1 = Y0 + pLayerCfg->ImageHeight;
00002c  6e48              LDR      r0,[r1,#0x64]
00002e  4410              ADD      r0,r0,r2
;;;930    
;;;931      /* Set LTDC parameters */
;;;932      LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);
000030  6448              STR      r0,[r1,#0x44]
000032  3138              ADDS     r1,r1,#0x38
000034  461a              MOV      r2,r3
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       LTDC_SetConfig
;;;933    
;;;934      /* Sets the Reload type */
;;;935      hltdc->Instance->SRCR = LTDC_SRCR_IMR;
00003c  6821              LDR      r1,[r4,#0]
;;;936    
;;;937      /* Change the LTDC state*/
;;;938      hltdc->State = HAL_LTDC_STATE_READY;
;;;939    
;;;940      /* Process unlocked */
;;;941      __HAL_UNLOCK(hltdc);
00003e  2000              MOVS     r0,#0
000040  624d              STR      r5,[r1,#0x24]         ;935
000042  f8c450a4          STR      r5,[r4,#0xa4]         ;938
000046  f8c400a0          STR      r0,[r4,#0xa0]         ;908
;;;942    
;;;943      return HAL_OK;
;;;944    }
00004a  bd70              POP      {r4-r6,pc}
                  |L36.76|
00004c  2002              MOVS     r0,#2                 ;908
00004e  bd70              POP      {r4-r6,pc}
;;;945    
                          ENDP


                          AREA ||i.HAL_LTDC_SetWindowPosition_NoReload||, CODE, READONLY, ALIGN=1

                  HAL_LTDC_SetWindowPosition_NoReload PROC
;;;1344     */
;;;1345   HAL_StatusTypeDef HAL_LTDC_SetWindowPosition_NoReload(LTDC_HandleTypeDef *hltdc, uint32_t X0, uint32_t Y0, uint32_t LayerIdx)
000000  b570              PUSH     {r4-r6,lr}
;;;1346   {
000002  4604              MOV      r4,r0
;;;1347     LTDC_LayerCfgTypeDef *pLayerCfg;
;;;1348     
;;;1349     /* Process locked */
;;;1350     __HAL_LOCK(hltdc);
000004  f8d000a0          LDR      r0,[r0,#0xa0]
000008  460e              MOV      r6,r1                 ;1346
00000a  2801              CMP      r0,#1
00000c  d01c              BEQ      |L37.72|
;;;1351   
;;;1352     /* Change LTDC peripheral state */
;;;1353     hltdc->State = HAL_LTDC_STATE_BUSY;
;;;1354   
;;;1355     /* Get layer configuration from handle structure */
;;;1356     pLayerCfg = &hltdc->LayerCfg[LayerIdx];
00000e  eb030083          ADD      r0,r3,r3,LSL #2
000012  eb0000c3          ADD      r0,r0,r3,LSL #3
000016  2501              MOVS     r5,#1                 ;1350
000018  eb040180          ADD      r1,r4,r0,LSL #2
00001c  2002              MOVS     r0,#2                 ;1353
00001e  e9c45028          STRD     r5,r0,[r4,#0xa0]      ;1353
;;;1357   
;;;1358     /* Check the parameters */
;;;1359     assert_param(IS_LTDC_LAYER(LayerIdx));
;;;1360     assert_param(IS_LTDC_HCONFIGST(pLayerCfg->WindowX0));
;;;1361     assert_param(IS_LTDC_HCONFIGSP(pLayerCfg->WindowX1));
;;;1362     assert_param(IS_LTDC_VCONFIGST(pLayerCfg->WindowY0));
;;;1363     assert_param(IS_LTDC_VCONFIGSP(pLayerCfg->WindowY1));
;;;1364   
;;;1365     /* update horizontal start/stop */
;;;1366     pLayerCfg->WindowX0 = X0;
;;;1367     pLayerCfg->WindowX1 = X0 + pLayerCfg->ImageWidth;
000022  638e              STR      r6,[r1,#0x38]
000024  6e08              LDR      r0,[r1,#0x60]
000026  4430              ADD      r0,r0,r6
000028  e9c1020f          STRD     r0,r2,[r1,#0x3c]
;;;1368   
;;;1369     /* update vertical start/stop */
;;;1370     pLayerCfg->WindowY0 = Y0;
;;;1371     pLayerCfg->WindowY1 = Y0 + pLayerCfg->ImageHeight;
00002c  6e48              LDR      r0,[r1,#0x64]
00002e  4410              ADD      r0,r0,r2
;;;1372   
;;;1373     /* Set LTDC parameters */
;;;1374     LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);
000030  6448              STR      r0,[r1,#0x44]
000032  3138              ADDS     r1,r1,#0x38
000034  461a              MOV      r2,r3
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       LTDC_SetConfig
;;;1375   
;;;1376     /* Do not Sets the Reload  */
;;;1377   
;;;1378     /* Change the LTDC state*/
;;;1379     hltdc->State = HAL_LTDC_STATE_READY;
;;;1380   
;;;1381     /* Process unlocked */
;;;1382     __HAL_UNLOCK(hltdc);
00003c  2000              MOVS     r0,#0
00003e  f8c450a4          STR      r5,[r4,#0xa4]         ;1379
000042  f8c400a0          STR      r0,[r4,#0xa0]         ;1350
;;;1383   
;;;1384     return HAL_OK;
;;;1385   }
000046  bd70              POP      {r4-r6,pc}
                  |L37.72|
000048  2002              MOVS     r0,#2                 ;1350
00004a  bd70              POP      {r4-r6,pc}
;;;1386   
                          ENDP


                          AREA ||i.HAL_LTDC_SetWindowSize||, CODE, READONLY, ALIGN=1

                  HAL_LTDC_SetWindowSize PROC
;;;840      */
;;;841    HAL_StatusTypeDef HAL_LTDC_SetWindowSize(LTDC_HandleTypeDef *hltdc, uint32_t XSize, uint32_t YSize, uint32_t LayerIdx) 
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;842    {
000004  4604              MOV      r4,r0
;;;843      LTDC_LayerCfgTypeDef *pLayerCfg;
;;;844    
;;;845      /* Process locked */
;;;846      __HAL_LOCK(hltdc);
000006  f8d000a0          LDR      r0,[r0,#0xa0]
00000a  460f              MOV      r7,r1                 ;842
00000c  2801              CMP      r0,#1
00000e  d01e              BEQ      |L38.78|
;;;847    
;;;848      /* Change LTDC peripheral state */
;;;849      hltdc->State = HAL_LTDC_STATE_BUSY; 
;;;850    
;;;851      /* Get layer configuration from handle structure */
;;;852      pLayerCfg = &hltdc->LayerCfg[LayerIdx];
000010  eb030083          ADD      r0,r3,r3,LSL #2
000014  eb0000c3          ADD      r0,r0,r3,LSL #3
000018  2501              MOVS     r5,#1                 ;846
;;;853    
;;;854      /* Check the parameters (Layers parameters)*/
;;;855      assert_param(IS_LTDC_LAYER(LayerIdx));
;;;856      assert_param(IS_LTDC_HCONFIGST(pLayerCfg->WindowX0));
;;;857      assert_param(IS_LTDC_HCONFIGSP(pLayerCfg->WindowX1));
;;;858      assert_param(IS_LTDC_VCONFIGST(pLayerCfg->WindowY0));
;;;859      assert_param(IS_LTDC_VCONFIGSP(pLayerCfg->WindowY1));
;;;860      assert_param(IS_LTDC_CFBLL(XSize));
;;;861      assert_param(IS_LTDC_CFBLNBR(YSize));
;;;862    
;;;863      /* update horizontal start/stop */
;;;864      pLayerCfg->WindowX0 = 0;
00001a  2600              MOVS     r6,#0
00001c  eb040180          ADD      r1,r4,r0,LSL #2       ;852
000020  2002              MOVS     r0,#2                 ;849
000022  e9c45028          STRD     r5,r0,[r4,#0xa0]      ;849
000026  e9c1670e          STRD     r6,r7,[r1,#0x38]      ;849
00002a  e9c16210          STRD     r6,r2,[r1,#0x40]      ;849
00002e  e9c17218          STRD     r7,r2,[r1,#0x60]      ;849
;;;865      pLayerCfg->WindowX1 = XSize + pLayerCfg->WindowX0;
;;;866    
;;;867      /* update vertical start/stop */  
;;;868      pLayerCfg->WindowY0 = 0;
;;;869      pLayerCfg->WindowY1 = YSize + pLayerCfg->WindowY0;
;;;870    
;;;871      /* Reconfigures the color frame buffer pitch in byte */
;;;872      pLayerCfg->ImageWidth = XSize;
;;;873    
;;;874      /* Reconfigures the frame buffer line number */
;;;875      pLayerCfg->ImageHeight = YSize;
;;;876    
;;;877      /* Set LTDC parameters */
;;;878      LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);
000032  3138              ADDS     r1,r1,#0x38
000034  461a              MOV      r2,r3
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       LTDC_SetConfig
;;;879    
;;;880      /* Sets the Reload type */
;;;881      hltdc->Instance->SRCR = LTDC_SRCR_IMR;
00003c  6820              LDR      r0,[r4,#0]
00003e  6245              STR      r5,[r0,#0x24]
;;;882    
;;;883      /* Change the LTDC state*/
;;;884      hltdc->State = HAL_LTDC_STATE_READY;
000040  f8c450a4          STR      r5,[r4,#0xa4]
;;;885    
;;;886      /* Process unlocked */
;;;887      __HAL_UNLOCK(hltdc);
;;;888    
;;;889      return HAL_OK;
000044  2000              MOVS     r0,#0
000046  f8c460a0          STR      r6,[r4,#0xa0]         ;846
                  |L38.74|
;;;890    }
00004a  e8bd81f0          POP      {r4-r8,pc}
                  |L38.78|
00004e  2002              MOVS     r0,#2                 ;846
000050  e7fb              B        |L38.74|
;;;891    
                          ENDP


                          AREA ||i.HAL_LTDC_SetWindowSize_NoReload||, CODE, READONLY, ALIGN=1

                  HAL_LTDC_SetWindowSize_NoReload PROC
;;;1282     */
;;;1283   HAL_StatusTypeDef HAL_LTDC_SetWindowSize_NoReload(LTDC_HandleTypeDef *hltdc, uint32_t XSize, uint32_t YSize, uint32_t LayerIdx) 
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1284   {
000004  4604              MOV      r4,r0
;;;1285     LTDC_LayerCfgTypeDef *pLayerCfg;
;;;1286   
;;;1287     /* Process locked */
;;;1288     __HAL_LOCK(hltdc);
000006  f8d000a0          LDR      r0,[r0,#0xa0]
00000a  460f              MOV      r7,r1                 ;1284
00000c  2801              CMP      r0,#1
00000e  d01c              BEQ      |L39.74|
;;;1289   
;;;1290     /* Change LTDC peripheral state */
;;;1291     hltdc->State = HAL_LTDC_STATE_BUSY; 
;;;1292   
;;;1293     /* Get layer configuration from handle structure */
;;;1294     pLayerCfg = &hltdc->LayerCfg[LayerIdx];
000010  eb030083          ADD      r0,r3,r3,LSL #2
000014  eb0000c3          ADD      r0,r0,r3,LSL #3
000018  2601              MOVS     r6,#1                 ;1288
;;;1295   
;;;1296     /* Check the parameters (Layers parameters)*/
;;;1297     assert_param(IS_LTDC_LAYER(LayerIdx));
;;;1298     assert_param(IS_LTDC_HCONFIGST(pLayerCfg->WindowX0));
;;;1299     assert_param(IS_LTDC_HCONFIGSP(pLayerCfg->WindowX1));
;;;1300     assert_param(IS_LTDC_VCONFIGST(pLayerCfg->WindowY0));
;;;1301     assert_param(IS_LTDC_VCONFIGSP(pLayerCfg->WindowY1));
;;;1302     assert_param(IS_LTDC_CFBLL(XSize));
;;;1303     assert_param(IS_LTDC_CFBLNBR(YSize));
;;;1304   
;;;1305     /* update horizontal start/stop */
;;;1306     pLayerCfg->WindowX0 = 0;
00001a  2500              MOVS     r5,#0
00001c  eb040180          ADD      r1,r4,r0,LSL #2       ;1294
000020  2002              MOVS     r0,#2                 ;1291
000022  e9c46028          STRD     r6,r0,[r4,#0xa0]      ;1291
000026  e9c1570e          STRD     r5,r7,[r1,#0x38]      ;1291
00002a  e9c15210          STRD     r5,r2,[r1,#0x40]      ;1291
00002e  e9c17218          STRD     r7,r2,[r1,#0x60]      ;1291
;;;1307     pLayerCfg->WindowX1 = XSize + pLayerCfg->WindowX0;
;;;1308   
;;;1309     /* update vertical start/stop */  
;;;1310     pLayerCfg->WindowY0 = 0;
;;;1311     pLayerCfg->WindowY1 = YSize + pLayerCfg->WindowY0;
;;;1312   
;;;1313     /* Reconfigures the color frame buffer pitch in byte */
;;;1314     pLayerCfg->ImageWidth = XSize;
;;;1315   
;;;1316     /* Reconfigures the frame buffer line number */
;;;1317     pLayerCfg->ImageHeight = YSize;
;;;1318   
;;;1319     /* Set LTDC parameters */
;;;1320     LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);
000032  3138              ADDS     r1,r1,#0x38
000034  461a              MOV      r2,r3
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       LTDC_SetConfig
;;;1321   
;;;1322     /* Do not Sets the Reload  */
;;;1323   
;;;1324     /* Change the LTDC state*/
;;;1325     hltdc->State = HAL_LTDC_STATE_READY;
00003c  f8c460a4          STR      r6,[r4,#0xa4]
;;;1326   
;;;1327     /* Process unlocked */
;;;1328     __HAL_UNLOCK(hltdc);
;;;1329   
;;;1330     return HAL_OK;
000040  2000              MOVS     r0,#0
000042  f8c450a0          STR      r5,[r4,#0xa0]         ;1288
                  |L39.70|
;;;1331   }
000046  e8bd81f0          POP      {r4-r8,pc}
                  |L39.74|
00004a  2002              MOVS     r0,#2                 ;1288
00004c  e7fb              B        |L39.70|
;;;1332   
                          ENDP


                          AREA ||i.LTDC_SetConfig||, CODE, READONLY, ALIGN=1

                  LTDC_SetConfig PROC
;;;1826     */
;;;1827   static void LTDC_SetConfig(LTDC_HandleTypeDef *hltdc, LTDC_LayerCfgTypeDef *pLayerCfg, uint32_t LayerIdx)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;1828   {
000004  4681              MOV      r9,r0
;;;1829     uint32_t tmp = 0;
;;;1830     uint32_t tmp1 = 0;
;;;1831     uint32_t tmp2 = 0;
;;;1832   
;;;1833     /* Configures the horizontal start and stop position */
;;;1834     tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16)) << 16);
000006  6800              LDR      r0,[r0,#0]
;;;1835     LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
000008  2488              MOVS     r4,#0x88
00000a  4693              MOV      r11,r2                ;1828
00000c  888d              LDRH     r5,[r1,#4]            ;1834
;;;1836     LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16) + 1) | tmp);
;;;1837   
;;;1838     /* Configures the vertical start and stop position */
;;;1839     tmp = ((pLayerCfg->WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16);
;;;1840     LTDC_LAYER(hltdc, LayerIdx)->WVPCR &= ~(LTDC_LxWVPCR_WVSTPOS | LTDC_LxWVPCR_WVSPPOS);
00000e  228c              MOVS     r2,#0x8c
000010  eb0417cb          ADD      r7,r4,r11,LSL #7      ;1835
000014  468a              MOV      r10,r1                ;1828
000016  68c3              LDR      r3,[r0,#0xc]          ;1834
;;;1841     LTDC_LAYER(hltdc, LayerIdx)->WVPCR  = ((pLayerCfg->WindowY0 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1) | tmp);  
;;;1842   
;;;1843     /* Specifies the pixel format */
;;;1844     LTDC_LAYER(hltdc, LayerIdx)->PFCR &= ~(LTDC_LxPFCR_PF);
000018  2194              MOVS     r1,#0x94
00001a  46be              MOV      lr,r7                 ;1835
00001c  59c4              LDR      r4,[r0,r7]            ;1835
00001e  f3c3430b          UBFX     r3,r3,#16,#12         ;1834
000022  442b              ADD      r3,r3,r5              ;1834
000024  f4044470          AND      r4,r4,#0xf000         ;1835
000028  041f              LSLS     r7,r3,#16             ;1834
00002a  9701              STR      r7,[sp,#4]            ;1835
00002c  eb0212cb          ADD      r2,r2,r11,LSL #7      ;1840
000030  f840400e          STR      r4,[r0,lr]            ;1835
000034  eb0113cb          ADD      r3,r1,r11,LSL #7
;;;1845     LTDC_LAYER(hltdc, LayerIdx)->PFCR = (pLayerCfg->PixelFormat);
;;;1846   
;;;1847     /* Configures the default color values */
;;;1848     tmp = ((uint32_t)(pLayerCfg->Backcolor.Green) << 8);
;;;1849     tmp1 = ((uint32_t)(pLayerCfg->Backcolor.Red) << 16);
;;;1850     tmp2 = (pLayerCfg->Alpha0 << 24);  
;;;1851     LTDC_LAYER(hltdc, LayerIdx)->DCCR &= ~(LTDC_LxDCCR_DCBLUE | LTDC_LxDCCR_DCGREEN | LTDC_LxDCCR_DCRED | LTDC_LxDCCR_DCALPHA);
;;;1852     LTDC_LAYER(hltdc, LayerIdx)->DCCR = (pLayerCfg->Backcolor.Blue | tmp | tmp1 | tmp2); 
;;;1853   
;;;1854     /* Specifies the constant alpha value */
;;;1855     LTDC_LAYER(hltdc, LayerIdx)->CACR &= ~(LTDC_LxCACR_CONSTA);
;;;1856     LTDC_LAYER(hltdc, LayerIdx)->CACR = (pLayerCfg->Alpha);
;;;1857   
;;;1858     /* Specifies the blending factors */
;;;1859     LTDC_LAYER(hltdc, LayerIdx)->BFCR &= ~(LTDC_LxBFCR_BF2 | LTDC_LxBFCR_BF1);
000038  f8da7000          LDR      r7,[r10,#0]
00003c  219c              MOVS     r1,#0x9c              ;1851
;;;1860     LTDC_LAYER(hltdc, LayerIdx)->BFCR = (pLayerCfg->BlendingFactor1 | pLayerCfg->BlendingFactor2);
;;;1861   
;;;1862     /* Configures the color frame buffer start address */
;;;1863     LTDC_LAYER(hltdc, LayerIdx)->CFBAR &= ~(LTDC_LxCFBAR_CFBADD);
00003e  f04f0cac          MOV      r12,#0xac
000042  eb0114cb          ADD      r4,r1,r11,LSL #7      ;1851
000046  f2407107          MOV      r1,#0x707             ;1859
00004a  9102              STR      r1,[sp,#8]
00004c  eb0c11cb          ADD      r1,r12,r11,LSL #7
000050  f8d9c000          LDR      r12,[r9,#0]           ;1836
000054  2598              MOVS     r5,#0x98              ;1855
000056  2000              MOVS     r0,#0                 ;1851
000058  f8cdc000          STR      r12,[sp,#0]           ;1836
00005c  26a0              MOVS     r6,#0xa0              ;1859
00005e  eb0515cb          ADD      r5,r5,r11,LSL #7      ;1855
000062  f8dcc00c          LDR      r12,[r12,#0xc]        ;1836
000066  eb0616cb          ADD      r6,r6,r11,LSL #7      ;1859
00006a  f3cc4c0b          UBFX     r12,r12,#16,#12       ;1836
00006e  f10c0c01          ADD      r12,r12,#1            ;1836
000072  eb07080c          ADD      r8,r7,r12             ;1836
000076  f8ddc000          LDR      r12,[sp,#0]           ;1836
00007a  9f01              LDR      r7,[sp,#4]            ;1836
00007c  ea480807          ORR      r8,r8,r7              ;1836
000080  f84c800e          STR      r8,[r12,lr]           ;1836
000084  f8d97000          LDR      r7,[r9,#0]            ;1839
000088  f8bac00c          LDRH     r12,[r10,#0xc]        ;1839
00008c  46b8              MOV      r8,r7                 ;1839
00008e  68ff              LDR      r7,[r7,#0xc]          ;1839
000090  f3c7070a          UBFX     r7,r7,#0,#11          ;1839
000094  4467              ADD      r7,r7,r12             ;1839
000096  ea4f4e07          LSL      lr,r7,#16             ;1839
00009a  f8587002          LDR      r7,[r8,r2]            ;1840
00009e  f4074c70          AND      r12,r7,#0xf000        ;1840
0000a2  f848c002          STR      r12,[r8,r2]           ;1840
0000a6  f8d9c000          LDR      r12,[r9,#0]           ;1841
0000aa  f8da7008          LDR      r7,[r10,#8]           ;1841
0000ae  f8dc800c          LDR      r8,[r12,#0xc]         ;1841
0000b2  f3c8080a          UBFX     r8,r8,#0,#11          ;1841
0000b6  f1080801          ADD      r8,r8,#1              ;1841
0000ba  44b8              ADD      r8,r8,r7              ;1841
0000bc  ea48080e          ORR      r8,r8,lr              ;1841
0000c0  f84c8002          STR      r8,[r12,r2]           ;1841
0000c4  f8d92000          LDR      r2,[r9,#0]            ;1844
0000c8  58d7              LDR      r7,[r2,r3]            ;1844
0000ca  f0270707          BIC      r7,r7,#7              ;1844
0000ce  50d7              STR      r7,[r2,r3]            ;1844
0000d0  f8d97000          LDR      r7,[r9,#0]            ;1845
0000d4  f8da2010          LDR      r2,[r10,#0x10]        ;1845
0000d8  50fa              STR      r2,[r7,r3]            ;1845
0000da  f89a2031          LDRB     r2,[r10,#0x31]        ;1848
0000de  f89a3018          LDRB     r3,[r10,#0x18]        ;1850
0000e2  ea4f2c02          LSL      r12,r2,#8             ;1848
0000e6  f89a2032          LDRB     r2,[r10,#0x32]        ;1849
0000ea  0412              LSLS     r2,r2,#16             ;1849
0000ec  ea426203          ORR      r2,r2,r3,LSL #24      ;1852
0000f0  f8d93000          LDR      r3,[r9,#0]            ;1851
0000f4  591f              LDR      r7,[r3,r4]            ;1851
0000f6  5118              STR      r0,[r3,r4]            ;1851
0000f8  f89a3030          LDRB     r3,[r10,#0x30]        ;1852
0000fc  ea43030c          ORR      r3,r3,r12             ;1852
000100  4313              ORRS     r3,r3,r2              ;1852
000102  f8d92000          LDR      r2,[r9,#0]            ;1852
000106  5113              STR      r3,[r2,r4]            ;1852
000108  f8d92000          LDR      r2,[r9,#0]            ;1855
00010c  5953              LDR      r3,[r2,r5]            ;1855
00010e  f02303ff          BIC      r3,r3,#0xff           ;1855
000112  5153              STR      r3,[r2,r5]            ;1855
000114  f8d92000          LDR      r2,[r9,#0]            ;1856
000118  f8da3014          LDR      r3,[r10,#0x14]        ;1856
00011c  5153              STR      r3,[r2,r5]            ;1856
00011e  f8d92000          LDR      r2,[r9,#0]            ;1859
000122  5993              LDR      r3,[r2,r6]            ;1859
000124  9c02              LDR      r4,[sp,#8]            ;1859
000126  43a3              BICS     r3,r3,r4              ;1859
000128  5193              STR      r3,[r2,r6]            ;1859
00012a  f8d93000          LDR      r3,[r9,#0]            ;1860
00012e  e9da2407          LDRD     r2,r4,[r10,#0x1c]     ;1859
000132  4322              ORRS     r2,r2,r4              ;1860
000134  519a              STR      r2,[r3,r6]            ;1860
000136  f8d92000          LDR      r2,[r9,#0]
00013a  5853              LDR      r3,[r2,r1]
00013c  5050              STR      r0,[r2,r1]
;;;1864     LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (pLayerCfg->FBStartAdress);
00013e  f8d92000          LDR      r2,[r9,#0]
000142  f8da0024          LDR      r0,[r10,#0x24]
000146  5050              STR      r0,[r2,r1]
000148  f8da0010          LDR      r0,[r10,#0x10]        ;1828
00014c  b3c8              CBZ      r0,|L40.450|
;;;1865   
;;;1866     if(pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
;;;1867     {
;;;1868       tmp = 4;
;;;1869     }
;;;1870     else if (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_RGB888)
00014e  2801              CMP      r0,#1
000150  d03a              BEQ      |L40.456|
;;;1871     {
;;;1872       tmp = 3;
;;;1873     }
;;;1874     else if((pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB4444) || \
000152  2804              CMP      r0,#4
000154  d03a              BEQ      |L40.460|
;;;1875       (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_RGB565)   || \
000156  2802              CMP      r0,#2
000158  d038              BEQ      |L40.460|
;;;1876         (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB1555) || \
00015a  2803              CMP      r0,#3
00015c  d036              BEQ      |L40.460|
;;;1877           (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_AL88))
00015e  2807              CMP      r0,#7
000160  d034              BEQ      |L40.460|
;;;1878     {
;;;1879       tmp = 2;
;;;1880     }
;;;1881     else
;;;1882     {
;;;1883       tmp = 1;
000162  2001              MOVS     r0,#1
                  |L40.356|
;;;1884     }
;;;1885   
;;;1886     /* Configures the color frame buffer pitch in byte */
;;;1887     LTDC_LAYER(hltdc, LayerIdx)->CFBLR  &= ~(LTDC_LxCFBLR_CFBLL | LTDC_LxCFBLR_CFBP);
000164  f8d93000          LDR      r3,[r9,#0]
000168  25b0              MOVS     r5,#0xb0
00016a  eb0511cb          ADD      r1,r5,r11,LSL #7
;;;1888     LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16) | (((pLayerCfg->WindowX1 - pLayerCfg->WindowX0) * tmp)  + 3));
;;;1889   
;;;1890     /* Configures the frame buffer line number */
;;;1891     LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  &= ~(LTDC_LxCFBLNR_CFBLNBR);
00016e  22b4              MOVS     r2,#0xb4
;;;1892     LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (pLayerCfg->ImageHeight);
;;;1893   
;;;1894     /* Enable LTDC_Layer by setting LEN bit */  
;;;1895     LTDC_LAYER(hltdc, LayerIdx)->CR |= (uint32_t)LTDC_LxCR_LEN;
000170  2484              MOVS     r4,#0x84
000172  585d              LDR      r5,[r3,r1]            ;1887
000174  eb0212cb          ADD      r2,r2,r11,LSL #7      ;1891
000178  f00525e0          AND      r5,r5,#0xe000e000     ;1887
00017c  505d              STR      r5,[r3,r1]            ;1887
00017e  e9da3500          LDRD     r3,r5,[r10,#0]
000182  eb0414cb          ADD      r4,r4,r11,LSL #7
000186  1aeb              SUBS     r3,r5,r3              ;1888
000188  f8ba5028          LDRH     r5,[r10,#0x28]        ;1888
00018c  4343              MULS     r3,r0,r3              ;1888
00018e  4345              MULS     r5,r0,r5              ;1888
000190  f8d90000          LDR      r0,[r9,#0]            ;1888
000194  1cdb              ADDS     r3,r3,#3              ;1888
000196  ea434305          ORR      r3,r3,r5,LSL #16      ;1888
00019a  5043              STR      r3,[r0,r1]            ;1888
00019c  f8d90000          LDR      r0,[r9,#0]            ;1891
0001a0  5881              LDR      r1,[r0,r2]            ;1891
0001a2  f36f010a          BFC      r1,#0,#11             ;1891
0001a6  5081              STR      r1,[r0,r2]            ;1891
0001a8  f8d90000          LDR      r0,[r9,#0]            ;1892
0001ac  f8da102c          LDR      r1,[r10,#0x2c]        ;1892
0001b0  5081              STR      r1,[r0,r2]            ;1892
0001b2  f8d90000          LDR      r0,[r9,#0]
0001b6  5901              LDR      r1,[r0,r4]
0001b8  f0410101          ORR      r1,r1,#1
0001bc  5101              STR      r1,[r0,r4]
;;;1896   }
0001be  e8bd8ffe          POP      {r1-r11,pc}
                  |L40.450|
0001c2  e7ff              B        |L40.452|
                  |L40.452|
0001c4  2004              MOVS     r0,#4                 ;1868
0001c6  e7cd              B        |L40.356|
                  |L40.456|
0001c8  2003              MOVS     r0,#3                 ;1872
0001ca  e7cb              B        |L40.356|
                  |L40.460|
0001cc  2002              MOVS     r0,#2                 ;1879
0001ce  e7c9              B        |L40.356|
;;;1897   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F7_V1.11.0\\Drivers\\STM32F7xx_HAL_Driver\\Src\\stm32f7xx_hal_ltdc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f7xx_hal_ltdc_c_fa7241fd____REV16|
#line 468 "D:\\Program_Files_x86\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.3.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___20_stm32f7xx_hal_ltdc_c_fa7241fd____REV16| PROC
#line 469

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f7xx_hal_ltdc_c_fa7241fd____REVSH|
#line 483
|__asm___20_stm32f7xx_hal_ltdc_c_fa7241fd____REVSH| PROC
#line 484

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f7xx_hal_ltdc_c_fa7241fd____RRX|
#line 670
|__asm___20_stm32f7xx_hal_ltdc_c_fa7241fd____RRX| PROC
#line 671

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
