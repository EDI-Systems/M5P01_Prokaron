; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f7xx_hal_sdram.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f7xx_hal_sdram.d --cpu=Cortex-M7 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Inc -I.\Source -I.\Drivers -I..\..\..\M6P1(L)_Lua\lua -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6-ALIENTEK-LUA\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER -Dlua_writestring=RMP_lua_writestring -Dlua_writeline=RMP_lua_writeline --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f7xx_hal_sdram.crf ..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_sdram.c]
                          THUMB

                          AREA ||i.HAL_SDRAM_DMA_XferCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_DMA_XferCpltCallback PROC
;;;262      */
;;;263    __weak void HAL_SDRAM_DMA_XferCpltCallback(DMA_HandleTypeDef *hdma)
000000  4770              BX       lr
;;;264    {
;;;265      /* Prevent unused argument(s) compilation warning */
;;;266      UNUSED(hdma);
;;;267     
;;;268      /* NOTE: This function Should not be modified, when the callback is needed,
;;;269                the HAL_SDRAM_DMA_XferCpltCallback could be implemented in the user file
;;;270       */ 
;;;271    }
;;;272    
                          ENDP


                          AREA ||i.HAL_SDRAM_DMA_XferErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_DMA_XferErrorCallback PROC
;;;277      */
;;;278    __weak void HAL_SDRAM_DMA_XferErrorCallback(DMA_HandleTypeDef *hdma)
000000  4770              BX       lr
;;;279    {
;;;280      /* Prevent unused argument(s) compilation warning */
;;;281      UNUSED(hdma);
;;;282     
;;;283      /* NOTE: This function Should not be modified, when the callback is needed,
;;;284                the HAL_SDRAM_DMA_XferErrorCallback could be implemented in the user file
;;;285       */ 
;;;286    }
;;;287    
                          ENDP


                          AREA ||i.HAL_SDRAM_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_DeInit PROC
;;;172      */
;;;173    HAL_StatusTypeDef HAL_SDRAM_DeInit(SDRAM_HandleTypeDef *hsdram)
000000  b510              PUSH     {r4,lr}
;;;174    {
000002  4604              MOV      r4,r0
;;;175      /* Initialize the low level hardware (MSP) */
;;;176      HAL_SDRAM_MspDeInit(hsdram);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       HAL_SDRAM_MspDeInit
;;;177    
;;;178      /* Configure the SDRAM registers with their reset values */
;;;179      FMC_SDRAM_DeInit(hsdram->Instance, hsdram->Init.SDBank);
00000a  e9d40100          LDRD     r0,r1,[r4,#0]
00000e  f7fffffe          BL       FMC_SDRAM_DeInit
;;;180    
;;;181      /* Reset the SDRAM controller state */
;;;182      hsdram->State = HAL_SDRAM_STATE_RESET;
000012  2000              MOVS     r0,#0
000014  62e0              STR      r0,[r4,#0x2c]
;;;183    
;;;184      /* Release Lock */
;;;185      __HAL_UNLOCK(hsdram);
000016  bf00              NOP      
000018  6320              STR      r0,[r4,#0x30]
00001a  bf00              NOP      
;;;186    
;;;187      return HAL_OK;
;;;188    }
00001c  bd10              POP      {r4,pc}
;;;189    
                          ENDP


                          AREA ||i.HAL_SDRAM_GetModeStatus||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_GetModeStatus PROC
;;;804      */
;;;805    uint32_t HAL_SDRAM_GetModeStatus(SDRAM_HandleTypeDef *hsdram)
000000  b510              PUSH     {r4,lr}
;;;806    {
000002  4604              MOV      r4,r0
;;;807      /* Return the SDRAM memory current mode */
;;;808      return(FMC_SDRAM_GetModeStatus(hsdram->Instance, hsdram->Init.SDBank));
000004  e9d40100          LDRD     r0,r1,[r4,#0]
000008  f7fffffe          BL       FMC_SDRAM_GetModeStatus
;;;809    }
00000c  bd10              POP      {r4,pc}
;;;810    
                          ENDP


                          AREA ||i.HAL_SDRAM_GetState||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_GetState PROC
;;;835      */
;;;836    HAL_SDRAM_StateTypeDef HAL_SDRAM_GetState(SDRAM_HandleTypeDef *hsdram)
000000  4601              MOV      r1,r0
;;;837    {
;;;838      return hsdram->State;
000002  6ac8              LDR      r0,[r1,#0x2c]
;;;839    }
000004  4770              BX       lr
;;;840    
                          ENDP


                          AREA ||i.HAL_SDRAM_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_IRQHandler PROC
;;;227    */
;;;228    void HAL_SDRAM_IRQHandler(SDRAM_HandleTypeDef *hsdram)
000000  b510              PUSH     {r4,lr}
;;;229    {
000002  4604              MOV      r4,r0
;;;230      /* Check SDRAM interrupt Rising edge flag */
;;;231      if(__FMC_SDRAM_GET_FLAG(hsdram->Instance, FMC_SDRAM_FLAG_REFRESH_IT))
000004  6820              LDR      r0,[r4,#0]
000006  6980              LDR      r0,[r0,#0x18]
000008  f0000001          AND      r0,r0,#1
00000c  b140              CBZ      r0,|L6.32|
;;;232      {
;;;233        /* SDRAM refresh error interrupt callback */
;;;234        HAL_SDRAM_RefreshErrorCallback(hsdram);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       HAL_SDRAM_RefreshErrorCallback
;;;235        
;;;236        /* Clear SDRAM refresh error interrupt pending bit */
;;;237        __FMC_SDRAM_CLEAR_FLAG(hsdram->Instance, FMC_SDRAM_FLAG_REFRESH_ERROR);
000014  6820              LDR      r0,[r4,#0]
000016  6940              LDR      r0,[r0,#0x14]
000018  f0400001          ORR      r0,r0,#1
00001c  6821              LDR      r1,[r4,#0]
00001e  6148              STR      r0,[r1,#0x14]
                  |L6.32|
;;;238      }
;;;239    }
000020  bd10              POP      {r4,pc}
;;;240    
                          ENDP


                          AREA ||i.HAL_SDRAM_Init||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_Init PROC
;;;135      */
;;;136    HAL_StatusTypeDef HAL_SDRAM_Init(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_TimingTypeDef *Timing)
000000  b570              PUSH     {r4-r6,lr}
;;;137    {   
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;138      /* Check the SDRAM handle parameter */
;;;139      if(hsdram == NULL)
000006  b90c              CBNZ     r4,|L7.12|
;;;140      {
;;;141        return HAL_ERROR;
000008  2001              MOVS     r0,#1
                  |L7.10|
;;;142      }
;;;143      
;;;144      if(hsdram->State == HAL_SDRAM_STATE_RESET)
;;;145      {  
;;;146        /* Allocate lock resource and initialize it */
;;;147        hsdram->Lock = HAL_UNLOCKED;
;;;148        /* Initialize the low level hardware (MSP) */
;;;149        HAL_SDRAM_MspInit(hsdram);
;;;150      }
;;;151      
;;;152      /* Initialize the SDRAM controller state */
;;;153      hsdram->State = HAL_SDRAM_STATE_BUSY;
;;;154      
;;;155      /* Initialize SDRAM control Interface */
;;;156      FMC_SDRAM_Init(hsdram->Instance, &(hsdram->Init));
;;;157      
;;;158      /* Initialize SDRAM timing Interface */
;;;159      FMC_SDRAM_Timing_Init(hsdram->Instance, Timing, hsdram->Init.SDBank); 
;;;160      
;;;161      /* Update the SDRAM controller state */
;;;162      hsdram->State = HAL_SDRAM_STATE_READY;
;;;163      
;;;164      return HAL_OK;
;;;165    }
00000a  bd70              POP      {r4-r6,pc}
                  |L7.12|
00000c  6ae0              LDR      r0,[r4,#0x2c]         ;144
00000e  b920              CBNZ     r0,|L7.26|
000010  2000              MOVS     r0,#0                 ;147
000012  6320              STR      r0,[r4,#0x30]         ;147
000014  4620              MOV      r0,r4                 ;149
000016  f7fffffe          BL       HAL_SDRAM_MspInit
                  |L7.26|
00001a  2002              MOVS     r0,#2                 ;153
00001c  62e0              STR      r0,[r4,#0x2c]         ;153
00001e  1d21              ADDS     r1,r4,#4              ;156
000020  6820              LDR      r0,[r4,#0]            ;156
000022  f7fffffe          BL       FMC_SDRAM_Init
000026  4629              MOV      r1,r5                 ;159
000028  e9d40200          LDRD     r0,r2,[r4,#0]         ;159
00002c  f7fffffe          BL       FMC_SDRAM_Timing_Init
000030  2001              MOVS     r0,#1                 ;162
000032  62e0              STR      r0,[r4,#0x2c]         ;162
000034  2000              MOVS     r0,#0                 ;164
000036  e7e8              B        |L7.10|
;;;166    
                          ENDP


                          AREA ||i.HAL_SDRAM_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_MspDeInit PROC
;;;211      */
;;;212    __weak void HAL_SDRAM_MspDeInit(SDRAM_HandleTypeDef *hsdram)
000000  4770              BX       lr
;;;213    {
;;;214      /* Prevent unused argument(s) compilation warning */
;;;215      UNUSED(hsdram);
;;;216     
;;;217      /* NOTE: This function Should not be modified, when the callback is needed,
;;;218                the HAL_SDRAM_MspDeInit could be implemented in the user file
;;;219       */ 
;;;220    }
;;;221    
                          ENDP


                          AREA ||i.HAL_SDRAM_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_MspInit PROC
;;;195      */
;;;196    __weak void HAL_SDRAM_MspInit(SDRAM_HandleTypeDef *hsdram)
000000  4770              BX       lr
;;;197    {
;;;198      /* Prevent unused argument(s) compilation warning */
;;;199      UNUSED(hsdram);
;;;200     
;;;201      /* NOTE: This function Should not be modified, when the callback is needed,
;;;202                the HAL_SDRAM_MspInit could be implemented in the user file
;;;203       */ 
;;;204    }
;;;205    
                          ENDP


                          AREA ||i.HAL_SDRAM_ProgramRefreshRate||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_ProgramRefreshRate PROC
;;;751      */
;;;752    HAL_StatusTypeDef HAL_SDRAM_ProgramRefreshRate(SDRAM_HandleTypeDef *hsdram, uint32_t RefreshRate)
000000  b570              PUSH     {r4-r6,lr}
;;;753    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;754      /* Check the SDRAM controller state */
;;;755      if(hsdram->State == HAL_SDRAM_STATE_BUSY)
000006  6ae0              LDR      r0,[r4,#0x2c]
000008  2802              CMP      r0,#2
00000a  d100              BNE      |L10.14|
                  |L10.12|
;;;756      {
;;;757        return HAL_BUSY;
;;;758      } 
;;;759      
;;;760      /* Update the SDRAM state */
;;;761      hsdram->State = HAL_SDRAM_STATE_BUSY;
;;;762      
;;;763      /* Program the refresh rate */
;;;764      FMC_SDRAM_ProgramRefreshRate(hsdram->Instance ,RefreshRate);
;;;765      
;;;766      /* Update the SDRAM state */
;;;767      hsdram->State = HAL_SDRAM_STATE_READY;
;;;768      
;;;769      return HAL_OK;   
;;;770    }
00000c  bd70              POP      {r4-r6,pc}
                  |L10.14|
00000e  2002              MOVS     r0,#2                 ;761
000010  62e0              STR      r0,[r4,#0x2c]         ;761
000012  4629              MOV      r1,r5                 ;764
000014  6820              LDR      r0,[r4,#0]            ;764
000016  f7fffffe          BL       FMC_SDRAM_ProgramRefreshRate
00001a  2001              MOVS     r0,#1                 ;767
00001c  62e0              STR      r0,[r4,#0x2c]         ;767
00001e  2000              MOVS     r0,#0                 ;769
000020  e7f4              B        |L10.12|
;;;771    
                          ENDP


                          AREA ||i.HAL_SDRAM_Read_16b||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_Read_16b PROC
;;;399      */
;;;400    HAL_StatusTypeDef HAL_SDRAM_Read_16b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint16_t *pDstBuffer, uint32_t BufferSize)
000000  b530              PUSH     {r4,r5,lr}
;;;401    {
000002  4604              MOV      r4,r0
;;;402      __IO uint16_t *pSdramAddress = (uint16_t *)pAddress;
000004  460d              MOV      r5,r1
;;;403      
;;;404      /* Process Locked */
;;;405      __HAL_LOCK(hsdram);
000006  bf00              NOP      
000008  6b20              LDR      r0,[r4,#0x30]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L11.18|
00000e  2002              MOVS     r0,#2
                  |L11.16|
;;;406      
;;;407      /* Check the SDRAM controller state */
;;;408      if(hsdram->State == HAL_SDRAM_STATE_BUSY)
;;;409      {
;;;410        return HAL_BUSY;
;;;411      }
;;;412      else if(hsdram->State == HAL_SDRAM_STATE_PRECHARGED)
;;;413      {
;;;414        return  HAL_ERROR; 
;;;415      }  
;;;416      
;;;417      /* Read data from source */
;;;418      for(; BufferSize != 0; BufferSize--)
;;;419      {
;;;420        *pDstBuffer = *(__IO uint16_t *)pSdramAddress;  
;;;421        pDstBuffer++;
;;;422        pSdramAddress++;               
;;;423      }
;;;424      
;;;425      /* Process Unlocked */
;;;426      __HAL_UNLOCK(hsdram);       
;;;427      
;;;428      return HAL_OK; 
;;;429    }
000010  bd30              POP      {r4,r5,pc}
                  |L11.18|
000012  2001              MOVS     r0,#1                 ;405
000014  6320              STR      r0,[r4,#0x30]         ;405
000016  bf00              NOP                            ;405
000018  6ae0              LDR      r0,[r4,#0x2c]         ;408
00001a  2802              CMP      r0,#2                 ;408
00001c  d100              BNE      |L11.32|
00001e  e7f7              B        |L11.16|
                  |L11.32|
000020  6ae0              LDR      r0,[r4,#0x2c]         ;412
000022  2805              CMP      r0,#5                 ;412
000024  d101              BNE      |L11.42|
000026  2001              MOVS     r0,#1                 ;414
000028  e7f2              B        |L11.16|
                  |L11.42|
00002a  e004              B        |L11.54|
                  |L11.44|
00002c  8828              LDRH     r0,[r5,#0]            ;420
00002e  8010              STRH     r0,[r2,#0]            ;420
000030  1c92              ADDS     r2,r2,#2              ;421
000032  1cad              ADDS     r5,r5,#2              ;422
000034  1e5b              SUBS     r3,r3,#1              ;418
                  |L11.54|
000036  2b00              CMP      r3,#0                 ;418
000038  d1f8              BNE      |L11.44|
00003a  bf00              NOP                            ;426
00003c  2000              MOVS     r0,#0                 ;426
00003e  6320              STR      r0,[r4,#0x30]         ;426
000040  bf00              NOP                            ;426
000042  bf00              NOP                            ;428
000044  e7e4              B        |L11.16|
;;;430    
                          ENDP


                          AREA ||i.HAL_SDRAM_Read_32b||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_Read_32b PROC
;;;482      */
;;;483    HAL_StatusTypeDef HAL_SDRAM_Read_32b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint32_t *pDstBuffer, uint32_t BufferSize)
000000  b530              PUSH     {r4,r5,lr}
;;;484    {
000002  4604              MOV      r4,r0
;;;485      __IO uint32_t *pSdramAddress = (uint32_t *)pAddress;
000004  460d              MOV      r5,r1
;;;486      
;;;487      /* Process Locked */
;;;488      __HAL_LOCK(hsdram);
000006  bf00              NOP      
000008  6b20              LDR      r0,[r4,#0x30]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L12.18|
00000e  2002              MOVS     r0,#2
                  |L12.16|
;;;489      
;;;490      /* Check the SDRAM controller state */
;;;491      if(hsdram->State == HAL_SDRAM_STATE_BUSY)
;;;492      {
;;;493        return HAL_BUSY;
;;;494      }
;;;495      else if(hsdram->State == HAL_SDRAM_STATE_PRECHARGED)
;;;496      {
;;;497        return  HAL_ERROR; 
;;;498      }  
;;;499      
;;;500      /* Read data from source */
;;;501      for(; BufferSize != 0; BufferSize--)
;;;502      {
;;;503        *pDstBuffer = *(__IO uint32_t *)pSdramAddress;  
;;;504        pDstBuffer++;
;;;505        pSdramAddress++;               
;;;506      }
;;;507      
;;;508      /* Process Unlocked */
;;;509      __HAL_UNLOCK(hsdram);       
;;;510      
;;;511      return HAL_OK; 
;;;512    }
000010  bd30              POP      {r4,r5,pc}
                  |L12.18|
000012  2001              MOVS     r0,#1                 ;488
000014  6320              STR      r0,[r4,#0x30]         ;488
000016  bf00              NOP                            ;488
000018  6ae0              LDR      r0,[r4,#0x2c]         ;491
00001a  2802              CMP      r0,#2                 ;491
00001c  d100              BNE      |L12.32|
00001e  e7f7              B        |L12.16|
                  |L12.32|
000020  6ae0              LDR      r0,[r4,#0x2c]         ;495
000022  2805              CMP      r0,#5                 ;495
000024  d101              BNE      |L12.42|
000026  2001              MOVS     r0,#1                 ;497
000028  e7f2              B        |L12.16|
                  |L12.42|
00002a  e004              B        |L12.54|
                  |L12.44|
00002c  6828              LDR      r0,[r5,#0]            ;503
00002e  6010              STR      r0,[r2,#0]            ;503
000030  1d12              ADDS     r2,r2,#4              ;504
000032  1d2d              ADDS     r5,r5,#4              ;505
000034  1e5b              SUBS     r3,r3,#1              ;501
                  |L12.54|
000036  2b00              CMP      r3,#0                 ;501
000038  d1f8              BNE      |L12.44|
00003a  bf00              NOP                            ;509
00003c  2000              MOVS     r0,#0                 ;509
00003e  6320              STR      r0,[r4,#0x30]         ;509
000040  bf00              NOP                            ;509
000042  bf00              NOP                            ;511
000044  e7e4              B        |L12.16|
;;;513    
                          ENDP


                          AREA ||i.HAL_SDRAM_Read_8b||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_Read_8b PROC
;;;314      */
;;;315    HAL_StatusTypeDef HAL_SDRAM_Read_8b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint8_t *pDstBuffer, uint32_t BufferSize)
000000  b530              PUSH     {r4,r5,lr}
;;;316    {
000002  4604              MOV      r4,r0
;;;317      __IO uint8_t *pSdramAddress = (uint8_t *)pAddress;
000004  460d              MOV      r5,r1
;;;318      
;;;319      /* Process Locked */
;;;320      __HAL_LOCK(hsdram);
000006  bf00              NOP      
000008  6b20              LDR      r0,[r4,#0x30]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L13.18|
00000e  2002              MOVS     r0,#2
                  |L13.16|
;;;321      
;;;322      /* Check the SDRAM controller state */
;;;323      if(hsdram->State == HAL_SDRAM_STATE_BUSY)
;;;324      {
;;;325        return HAL_BUSY;
;;;326      }
;;;327      else if(hsdram->State == HAL_SDRAM_STATE_PRECHARGED)
;;;328      {
;;;329        return  HAL_ERROR; 
;;;330      }  
;;;331      
;;;332      /* Read data from source */
;;;333      for(; BufferSize != 0; BufferSize--)
;;;334      {
;;;335        *pDstBuffer = *(__IO uint8_t *)pSdramAddress;  
;;;336        pDstBuffer++;
;;;337        pSdramAddress++;
;;;338      }
;;;339      
;;;340      /* Process Unlocked */
;;;341      __HAL_UNLOCK(hsdram);
;;;342      
;;;343      return HAL_OK; 
;;;344    }
000010  bd30              POP      {r4,r5,pc}
                  |L13.18|
000012  2001              MOVS     r0,#1                 ;320
000014  6320              STR      r0,[r4,#0x30]         ;320
000016  bf00              NOP                            ;320
000018  6ae0              LDR      r0,[r4,#0x2c]         ;323
00001a  2802              CMP      r0,#2                 ;323
00001c  d100              BNE      |L13.32|
00001e  e7f7              B        |L13.16|
                  |L13.32|
000020  6ae0              LDR      r0,[r4,#0x2c]         ;327
000022  2805              CMP      r0,#5                 ;327
000024  d101              BNE      |L13.42|
000026  2001              MOVS     r0,#1                 ;329
000028  e7f2              B        |L13.16|
                  |L13.42|
00002a  e004              B        |L13.54|
                  |L13.44|
00002c  7828              LDRB     r0,[r5,#0]            ;335
00002e  7010              STRB     r0,[r2,#0]            ;335
000030  1c52              ADDS     r2,r2,#1              ;336
000032  1c6d              ADDS     r5,r5,#1              ;337
000034  1e5b              SUBS     r3,r3,#1              ;333
                  |L13.54|
000036  2b00              CMP      r3,#0                 ;333
000038  d1f8              BNE      |L13.44|
00003a  bf00              NOP                            ;341
00003c  2000              MOVS     r0,#0                 ;341
00003e  6320              STR      r0,[r4,#0x30]         ;341
000040  bf00              NOP                            ;341
000042  bf00              NOP                            ;343
000044  e7e4              B        |L13.16|
;;;345    
                          ENDP


                          AREA ||i.HAL_SDRAM_Read_DMA||, CODE, READONLY, ALIGN=2

                  HAL_SDRAM_Read_DMA PROC
;;;565      */
;;;566    HAL_StatusTypeDef HAL_SDRAM_Read_DMA(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint32_t *pDstBuffer, uint32_t BufferSize)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;567    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;568      uint32_t tmp = 0;
00000c  2500              MOVS     r5,#0
;;;569        
;;;570      /* Process Locked */
;;;571      __HAL_LOCK(hsdram);
00000e  bf00              NOP      
000010  6b20              LDR      r0,[r4,#0x30]
000012  2801              CMP      r0,#1
000014  d102              BNE      |L14.28|
000016  2002              MOVS     r0,#2
                  |L14.24|
;;;572      
;;;573      /* Check the SDRAM controller state */  
;;;574      tmp = hsdram->State;
;;;575      
;;;576      if(tmp == HAL_SDRAM_STATE_BUSY)
;;;577      {
;;;578        return HAL_BUSY;
;;;579      }
;;;580      else if(tmp == HAL_SDRAM_STATE_PRECHARGED)
;;;581      {
;;;582        return  HAL_ERROR; 
;;;583      }  
;;;584      
;;;585      /* Configure DMA user callbacks */
;;;586      hsdram->hdma->XferCpltCallback  = HAL_SDRAM_DMA_XferCpltCallback;
;;;587      hsdram->hdma->XferErrorCallback = HAL_SDRAM_DMA_XferErrorCallback;
;;;588      
;;;589      /* Enable the DMA Stream */
;;;590      HAL_DMA_Start_IT(hsdram->hdma, (uint32_t)pAddress, (uint32_t)pDstBuffer, (uint32_t)BufferSize);
;;;591      
;;;592      /* Process Unlocked */
;;;593      __HAL_UNLOCK(hsdram);  
;;;594      
;;;595      return HAL_OK; 
;;;596    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L14.28|
00001c  2001              MOVS     r0,#1                 ;571
00001e  6320              STR      r0,[r4,#0x30]         ;571
000020  bf00              NOP                            ;571
000022  6ae5              LDR      r5,[r4,#0x2c]         ;574
000024  2d02              CMP      r5,#2                 ;576
000026  d101              BNE      |L14.44|
000028  2002              MOVS     r0,#2                 ;578
00002a  e7f5              B        |L14.24|
                  |L14.44|
00002c  2d05              CMP      r5,#5                 ;580
00002e  d101              BNE      |L14.52|
000030  2001              MOVS     r0,#1                 ;582
000032  e7f1              B        |L14.24|
                  |L14.52|
000034  4808              LDR      r0,|L14.88|
000036  6b61              LDR      r1,[r4,#0x34]         ;586
000038  6408              STR      r0,[r1,#0x40]         ;586
00003a  4808              LDR      r0,|L14.92|
00003c  6b61              LDR      r1,[r4,#0x34]         ;587
00003e  6508              STR      r0,[r1,#0x50]         ;587
000040  4643              MOV      r3,r8                 ;590
000042  463a              MOV      r2,r7                 ;590
000044  4631              MOV      r1,r6                 ;590
000046  6b60              LDR      r0,[r4,#0x34]         ;590
000048  f7fffffe          BL       HAL_DMA_Start_IT
00004c  bf00              NOP                            ;593
00004e  2000              MOVS     r0,#0                 ;593
000050  6320              STR      r0,[r4,#0x30]         ;593
000052  bf00              NOP                            ;593
000054  bf00              NOP                            ;595
000056  e7df              B        |L14.24|
;;;597    
                          ENDP

                  |L14.88|
                          DCD      HAL_SDRAM_DMA_XferCpltCallback
                  |L14.92|
                          DCD      HAL_SDRAM_DMA_XferErrorCallback

                          AREA ||i.HAL_SDRAM_RefreshErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_RefreshErrorCallback PROC
;;;246      */
;;;247    __weak void HAL_SDRAM_RefreshErrorCallback(SDRAM_HandleTypeDef *hsdram)
000000  4770              BX       lr
;;;248    {
;;;249      /* Prevent unused argument(s) compilation warning */
;;;250      UNUSED(hsdram);
;;;251     
;;;252      /* NOTE: This function Should not be modified, when the callback is needed,
;;;253                the HAL_SDRAM_RefreshErrorCallback could be implemented in the user file
;;;254       */ 
;;;255    }
;;;256    
                          ENDP


                          AREA ||i.HAL_SDRAM_SendCommand||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_SendCommand PROC
;;;717      */  
;;;718    HAL_StatusTypeDef HAL_SDRAM_SendCommand(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
000000  b570              PUSH     {r4-r6,lr}
;;;719    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;720      /* Check the SDRAM controller state */
;;;721      if(hsdram->State == HAL_SDRAM_STATE_BUSY)
000008  6ae0              LDR      r0,[r4,#0x2c]
00000a  2802              CMP      r0,#2
00000c  d100              BNE      |L16.16|
                  |L16.14|
;;;722      {
;;;723        return HAL_BUSY;
;;;724      }
;;;725      
;;;726      /* Update the SDRAM state */
;;;727      hsdram->State = HAL_SDRAM_STATE_BUSY;
;;;728      
;;;729      /* Send SDRAM command */
;;;730      FMC_SDRAM_SendCommand(hsdram->Instance, Command, Timeout);
;;;731      
;;;732      /* Update the SDRAM controller state state */
;;;733      if(Command->CommandMode == FMC_SDRAM_CMD_PALL)
;;;734      {
;;;735        hsdram->State = HAL_SDRAM_STATE_PRECHARGED;
;;;736      }
;;;737      else
;;;738      {
;;;739        hsdram->State = HAL_SDRAM_STATE_READY;
;;;740      }
;;;741      
;;;742      return HAL_OK;  
;;;743    }
00000e  bd70              POP      {r4-r6,pc}
                  |L16.16|
000010  2002              MOVS     r0,#2                 ;727
000012  62e0              STR      r0,[r4,#0x2c]         ;727
000014  4632              MOV      r2,r6                 ;730
000016  4629              MOV      r1,r5                 ;730
000018  6820              LDR      r0,[r4,#0]            ;730
00001a  f7fffffe          BL       FMC_SDRAM_SendCommand
00001e  6828              LDR      r0,[r5,#0]            ;733
000020  2802              CMP      r0,#2                 ;733
000022  d102              BNE      |L16.42|
000024  2005              MOVS     r0,#5                 ;735
000026  62e0              STR      r0,[r4,#0x2c]         ;735
000028  e001              B        |L16.46|
                  |L16.42|
00002a  2001              MOVS     r0,#1                 ;739
00002c  62e0              STR      r0,[r4,#0x2c]         ;739
                  |L16.46|
00002e  2000              MOVS     r0,#0                 ;742
000030  e7ed              B        |L16.14|
;;;744    
                          ENDP


                          AREA ||i.HAL_SDRAM_SetAutoRefreshNumber||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_SetAutoRefreshNumber PROC
;;;778      */
;;;779    HAL_StatusTypeDef HAL_SDRAM_SetAutoRefreshNumber(SDRAM_HandleTypeDef *hsdram, uint32_t AutoRefreshNumber)
000000  b570              PUSH     {r4-r6,lr}
;;;780    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;781      /* Check the SDRAM controller state */
;;;782      if(hsdram->State == HAL_SDRAM_STATE_BUSY)
000006  6ae0              LDR      r0,[r4,#0x2c]
000008  2802              CMP      r0,#2
00000a  d100              BNE      |L17.14|
                  |L17.12|
;;;783      {
;;;784        return HAL_BUSY;
;;;785      } 
;;;786      
;;;787      /* Update the SDRAM state */
;;;788      hsdram->State = HAL_SDRAM_STATE_BUSY;
;;;789      
;;;790      /* Set the Auto-Refresh number */
;;;791      FMC_SDRAM_SetAutoRefreshNumber(hsdram->Instance ,AutoRefreshNumber);
;;;792      
;;;793      /* Update the SDRAM state */
;;;794      hsdram->State = HAL_SDRAM_STATE_READY;
;;;795      
;;;796      return HAL_OK;
;;;797    }
00000c  bd70              POP      {r4-r6,pc}
                  |L17.14|
00000e  2002              MOVS     r0,#2                 ;788
000010  62e0              STR      r0,[r4,#0x2c]         ;788
000012  4629              MOV      r1,r5                 ;791
000014  6820              LDR      r0,[r4,#0]            ;791
000016  f7fffffe          BL       FMC_SDRAM_SetAutoRefreshNumber
00001a  2001              MOVS     r0,#1                 ;794
00001c  62e0              STR      r0,[r4,#0x2c]         ;794
00001e  2000              MOVS     r0,#0                 ;796
000020  e7f4              B        |L17.12|
;;;798    
                          ENDP


                          AREA ||i.HAL_SDRAM_WriteProtection_Disable||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_WriteProtection_Disable PROC
;;;689      */
;;;690    HAL_StatusTypeDef HAL_SDRAM_WriteProtection_Disable(SDRAM_HandleTypeDef *hsdram)
000000  b510              PUSH     {r4,lr}
;;;691    {
000002  4604              MOV      r4,r0
;;;692      /* Check the SDRAM controller state */
;;;693      if(hsdram->State == HAL_SDRAM_STATE_BUSY)
000004  6ae0              LDR      r0,[r4,#0x2c]
000006  2802              CMP      r0,#2
000008  d100              BNE      |L18.12|
                  |L18.10|
;;;694      {
;;;695        return HAL_BUSY;
;;;696      }
;;;697      
;;;698      /* Update the SDRAM state */
;;;699      hsdram->State = HAL_SDRAM_STATE_BUSY;
;;;700      
;;;701      /* Disable write protection */
;;;702      FMC_SDRAM_WriteProtection_Disable(hsdram->Instance, hsdram->Init.SDBank);
;;;703      
;;;704      /* Update the SDRAM state */
;;;705      hsdram->State = HAL_SDRAM_STATE_READY;
;;;706      
;;;707      return HAL_OK;
;;;708    }
00000a  bd10              POP      {r4,pc}
                  |L18.12|
00000c  2002              MOVS     r0,#2                 ;699
00000e  62e0              STR      r0,[r4,#0x2c]         ;699
000010  e9d40100          LDRD     r0,r1,[r4,#0]         ;702
000014  f7fffffe          BL       FMC_SDRAM_WriteProtection_Disable
000018  2001              MOVS     r0,#1                 ;705
00001a  62e0              STR      r0,[r4,#0x2c]         ;705
00001c  2000              MOVS     r0,#0                 ;707
00001e  e7f4              B        |L18.10|
;;;709    
                          ENDP


                          AREA ||i.HAL_SDRAM_WriteProtection_Enable||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_WriteProtection_Enable PROC
;;;663      */
;;;664    HAL_StatusTypeDef HAL_SDRAM_WriteProtection_Enable(SDRAM_HandleTypeDef *hsdram)
000000  b510              PUSH     {r4,lr}
;;;665    { 
000002  4604              MOV      r4,r0
;;;666      /* Check the SDRAM controller state */ 
;;;667      if(hsdram->State == HAL_SDRAM_STATE_BUSY)
000004  6ae0              LDR      r0,[r4,#0x2c]
000006  2802              CMP      r0,#2
000008  d100              BNE      |L19.12|
                  |L19.10|
;;;668      {
;;;669        return HAL_BUSY;
;;;670      }
;;;671      
;;;672      /* Update the SDRAM state */
;;;673      hsdram->State = HAL_SDRAM_STATE_BUSY;
;;;674      
;;;675      /* Enable write protection */
;;;676      FMC_SDRAM_WriteProtection_Enable(hsdram->Instance, hsdram->Init.SDBank);
;;;677      
;;;678      /* Update the SDRAM state */
;;;679      hsdram->State = HAL_SDRAM_STATE_WRITE_PROTECTED;
;;;680      
;;;681      return HAL_OK;  
;;;682    }
00000a  bd10              POP      {r4,pc}
                  |L19.12|
00000c  2002              MOVS     r0,#2                 ;673
00000e  62e0              STR      r0,[r4,#0x2c]         ;673
000010  e9d40100          LDRD     r0,r1,[r4,#0]         ;676
000014  f7fffffe          BL       FMC_SDRAM_WriteProtection_Enable
000018  2004              MOVS     r0,#4                 ;679
00001a  62e0              STR      r0,[r4,#0x2c]         ;679
00001c  2000              MOVS     r0,#0                 ;681
00001e  e7f4              B        |L19.10|
;;;683    
                          ENDP


                          AREA ||i.HAL_SDRAM_Write_16b||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_Write_16b PROC
;;;439      */
;;;440    HAL_StatusTypeDef HAL_SDRAM_Write_16b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint16_t *pSrcBuffer, uint32_t BufferSize)
000000  b570              PUSH     {r4-r6,lr}
;;;441    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;442      __IO uint16_t *pSdramAddress = (uint16_t *)pAddress;
000006  462e              MOV      r6,r5
;;;443      uint32_t tmp = 0;
000008  2100              MOVS     r1,#0
;;;444      
;;;445      /* Process Locked */
;;;446      __HAL_LOCK(hsdram);
00000a  bf00              NOP      
00000c  6b20              LDR      r0,[r4,#0x30]
00000e  2801              CMP      r0,#1
000010  d101              BNE      |L20.22|
000012  2002              MOVS     r0,#2
                  |L20.20|
;;;447      
;;;448      /* Check the SDRAM controller state */
;;;449      tmp = hsdram->State;
;;;450      
;;;451      if(tmp == HAL_SDRAM_STATE_BUSY)
;;;452      {
;;;453        return HAL_BUSY;
;;;454      }
;;;455      else if((tmp == HAL_SDRAM_STATE_PRECHARGED) || (tmp == HAL_SDRAM_STATE_WRITE_PROTECTED))
;;;456      {
;;;457        return  HAL_ERROR; 
;;;458      }
;;;459      
;;;460      /* Write data to memory */
;;;461      for(; BufferSize != 0; BufferSize--)
;;;462      {
;;;463        *(__IO uint16_t *)pSdramAddress = *pSrcBuffer;
;;;464        pSrcBuffer++;
;;;465        pSdramAddress++;            
;;;466      }
;;;467      
;;;468      /* Process Unlocked */
;;;469      __HAL_UNLOCK(hsdram);    
;;;470      
;;;471      return HAL_OK;   
;;;472    }
000014  bd70              POP      {r4-r6,pc}
                  |L20.22|
000016  2001              MOVS     r0,#1                 ;446
000018  6320              STR      r0,[r4,#0x30]         ;446
00001a  bf00              NOP                            ;446
00001c  6ae1              LDR      r1,[r4,#0x2c]         ;449
00001e  2902              CMP      r1,#2                 ;451
000020  d101              BNE      |L20.38|
000022  2002              MOVS     r0,#2                 ;453
000024  e7f6              B        |L20.20|
                  |L20.38|
000026  2905              CMP      r1,#5                 ;455
000028  d001              BEQ      |L20.46|
00002a  2904              CMP      r1,#4                 ;455
00002c  d101              BNE      |L20.50|
                  |L20.46|
00002e  2001              MOVS     r0,#1                 ;457
000030  e7f0              B        |L20.20|
                  |L20.50|
000032  e004              B        |L20.62|
                  |L20.52|
000034  8810              LDRH     r0,[r2,#0]            ;463
000036  8030              STRH     r0,[r6,#0]            ;463
000038  1c92              ADDS     r2,r2,#2              ;464
00003a  1cb6              ADDS     r6,r6,#2              ;465
00003c  1e5b              SUBS     r3,r3,#1              ;461
                  |L20.62|
00003e  2b00              CMP      r3,#0                 ;461
000040  d1f8              BNE      |L20.52|
000042  bf00              NOP                            ;469
000044  2000              MOVS     r0,#0                 ;469
000046  6320              STR      r0,[r4,#0x30]         ;469
000048  bf00              NOP                            ;469
00004a  bf00              NOP                            ;471
00004c  e7e2              B        |L20.20|
;;;473    
                          ENDP


                          AREA ||i.HAL_SDRAM_Write_32b||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_Write_32b PROC
;;;522      */
;;;523    HAL_StatusTypeDef HAL_SDRAM_Write_32b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint32_t *pSrcBuffer, uint32_t BufferSize)
000000  b570              PUSH     {r4-r6,lr}
;;;524    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;525      __IO uint32_t *pSdramAddress = (uint32_t *)pAddress;
000006  462e              MOV      r6,r5
;;;526      uint32_t tmp = 0;
000008  2100              MOVS     r1,#0
;;;527      
;;;528      /* Process Locked */
;;;529      __HAL_LOCK(hsdram);
00000a  bf00              NOP      
00000c  6b20              LDR      r0,[r4,#0x30]
00000e  2801              CMP      r0,#1
000010  d101              BNE      |L21.22|
000012  2002              MOVS     r0,#2
                  |L21.20|
;;;530      
;;;531      /* Check the SDRAM controller state */
;;;532      tmp = hsdram->State;
;;;533      
;;;534      if(tmp == HAL_SDRAM_STATE_BUSY)
;;;535      {
;;;536        return HAL_BUSY;
;;;537      }
;;;538      else if((tmp == HAL_SDRAM_STATE_PRECHARGED) || (tmp == HAL_SDRAM_STATE_WRITE_PROTECTED))
;;;539      {
;;;540        return  HAL_ERROR; 
;;;541      }
;;;542      
;;;543      /* Write data to memory */
;;;544      for(; BufferSize != 0; BufferSize--)
;;;545      {
;;;546        *(__IO uint32_t *)pSdramAddress = *pSrcBuffer;
;;;547        pSrcBuffer++;
;;;548        pSdramAddress++;          
;;;549      }
;;;550      
;;;551      /* Process Unlocked */
;;;552      __HAL_UNLOCK(hsdram);    
;;;553      
;;;554      return HAL_OK;  
;;;555    }
000014  bd70              POP      {r4-r6,pc}
                  |L21.22|
000016  2001              MOVS     r0,#1                 ;529
000018  6320              STR      r0,[r4,#0x30]         ;529
00001a  bf00              NOP                            ;529
00001c  6ae1              LDR      r1,[r4,#0x2c]         ;532
00001e  2902              CMP      r1,#2                 ;534
000020  d101              BNE      |L21.38|
000022  2002              MOVS     r0,#2                 ;536
000024  e7f6              B        |L21.20|
                  |L21.38|
000026  2905              CMP      r1,#5                 ;538
000028  d001              BEQ      |L21.46|
00002a  2904              CMP      r1,#4                 ;538
00002c  d101              BNE      |L21.50|
                  |L21.46|
00002e  2001              MOVS     r0,#1                 ;540
000030  e7f0              B        |L21.20|
                  |L21.50|
000032  e004              B        |L21.62|
                  |L21.52|
000034  6810              LDR      r0,[r2,#0]            ;546
000036  6030              STR      r0,[r6,#0]            ;546
000038  1d12              ADDS     r2,r2,#4              ;547
00003a  1d36              ADDS     r6,r6,#4              ;548
00003c  1e5b              SUBS     r3,r3,#1              ;544
                  |L21.62|
00003e  2b00              CMP      r3,#0                 ;544
000040  d1f8              BNE      |L21.52|
000042  bf00              NOP                            ;552
000044  2000              MOVS     r0,#0                 ;552
000046  6320              STR      r0,[r4,#0x30]         ;552
000048  bf00              NOP                            ;552
00004a  bf00              NOP                            ;554
00004c  e7e2              B        |L21.20|
;;;556    
                          ENDP


                          AREA ||i.HAL_SDRAM_Write_8b||, CODE, READONLY, ALIGN=1

                  HAL_SDRAM_Write_8b PROC
;;;355      */
;;;356    HAL_StatusTypeDef HAL_SDRAM_Write_8b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint8_t *pSrcBuffer, uint32_t BufferSize)
000000  b570              PUSH     {r4-r6,lr}
;;;357    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;358      __IO uint8_t *pSdramAddress = (uint8_t *)pAddress;
000006  462e              MOV      r6,r5
;;;359      uint32_t tmp = 0;
000008  2100              MOVS     r1,#0
;;;360      
;;;361      /* Process Locked */
;;;362      __HAL_LOCK(hsdram);
00000a  bf00              NOP      
00000c  6b20              LDR      r0,[r4,#0x30]
00000e  2801              CMP      r0,#1
000010  d101              BNE      |L22.22|
000012  2002              MOVS     r0,#2
                  |L22.20|
;;;363      
;;;364      /* Check the SDRAM controller state */
;;;365      tmp = hsdram->State;
;;;366      
;;;367      if(tmp == HAL_SDRAM_STATE_BUSY)
;;;368      {
;;;369        return HAL_BUSY;
;;;370      }
;;;371      else if((tmp == HAL_SDRAM_STATE_PRECHARGED) || (tmp == HAL_SDRAM_STATE_WRITE_PROTECTED))
;;;372      {
;;;373        return  HAL_ERROR; 
;;;374      }
;;;375      
;;;376      /* Write data to memory */
;;;377      for(; BufferSize != 0; BufferSize--)
;;;378      {
;;;379        *(__IO uint8_t *)pSdramAddress = *pSrcBuffer;
;;;380        pSrcBuffer++;
;;;381        pSdramAddress++;
;;;382      }
;;;383      
;;;384      /* Process Unlocked */
;;;385      __HAL_UNLOCK(hsdram);    
;;;386      
;;;387      return HAL_OK;   
;;;388    }
000014  bd70              POP      {r4-r6,pc}
                  |L22.22|
000016  2001              MOVS     r0,#1                 ;362
000018  6320              STR      r0,[r4,#0x30]         ;362
00001a  bf00              NOP                            ;362
00001c  6ae1              LDR      r1,[r4,#0x2c]         ;365
00001e  2902              CMP      r1,#2                 ;367
000020  d101              BNE      |L22.38|
000022  2002              MOVS     r0,#2                 ;369
000024  e7f6              B        |L22.20|
                  |L22.38|
000026  2905              CMP      r1,#5                 ;371
000028  d001              BEQ      |L22.46|
00002a  2904              CMP      r1,#4                 ;371
00002c  d101              BNE      |L22.50|
                  |L22.46|
00002e  2001              MOVS     r0,#1                 ;373
000030  e7f0              B        |L22.20|
                  |L22.50|
000032  e004              B        |L22.62|
                  |L22.52|
000034  7810              LDRB     r0,[r2,#0]            ;379
000036  7030              STRB     r0,[r6,#0]            ;379
000038  1c52              ADDS     r2,r2,#1              ;380
00003a  1c76              ADDS     r6,r6,#1              ;381
00003c  1e5b              SUBS     r3,r3,#1              ;377
                  |L22.62|
00003e  2b00              CMP      r3,#0                 ;377
000040  d1f8              BNE      |L22.52|
000042  bf00              NOP                            ;385
000044  2000              MOVS     r0,#0                 ;385
000046  6320              STR      r0,[r4,#0x30]         ;385
000048  bf00              NOP                            ;385
00004a  bf00              NOP                            ;387
00004c  e7e2              B        |L22.20|
;;;389    
                          ENDP


                          AREA ||i.HAL_SDRAM_Write_DMA||, CODE, READONLY, ALIGN=2

                  HAL_SDRAM_Write_DMA PROC
;;;606      */
;;;607    HAL_StatusTypeDef HAL_SDRAM_Write_DMA(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint32_t *pSrcBuffer, uint32_t BufferSize)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;608    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;609      uint32_t tmp = 0;
00000c  2500              MOVS     r5,#0
;;;610      
;;;611      /* Process Locked */
;;;612      __HAL_LOCK(hsdram);
00000e  bf00              NOP      
000010  6b20              LDR      r0,[r4,#0x30]
000012  2801              CMP      r0,#1
000014  d102              BNE      |L23.28|
000016  2002              MOVS     r0,#2
                  |L23.24|
;;;613      
;;;614      /* Check the SDRAM controller state */  
;;;615      tmp = hsdram->State;
;;;616      
;;;617      if(tmp == HAL_SDRAM_STATE_BUSY)
;;;618      {
;;;619        return HAL_BUSY;
;;;620      }
;;;621      else if((tmp == HAL_SDRAM_STATE_PRECHARGED) || (tmp == HAL_SDRAM_STATE_WRITE_PROTECTED))
;;;622      {
;;;623        return  HAL_ERROR; 
;;;624      }  
;;;625      
;;;626      /* Configure DMA user callbacks */
;;;627      hsdram->hdma->XferCpltCallback  = HAL_SDRAM_DMA_XferCpltCallback;
;;;628      hsdram->hdma->XferErrorCallback = HAL_SDRAM_DMA_XferErrorCallback;
;;;629      
;;;630      /* Enable the DMA Stream */
;;;631      HAL_DMA_Start_IT(hsdram->hdma, (uint32_t)pSrcBuffer, (uint32_t)pAddress, (uint32_t)BufferSize);
;;;632      
;;;633      /* Process Unlocked */
;;;634      __HAL_UNLOCK(hsdram);
;;;635      
;;;636      return HAL_OK;
;;;637    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L23.28|
00001c  2001              MOVS     r0,#1                 ;612
00001e  6320              STR      r0,[r4,#0x30]         ;612
000020  bf00              NOP                            ;612
000022  6ae5              LDR      r5,[r4,#0x2c]         ;615
000024  2d02              CMP      r5,#2                 ;617
000026  d101              BNE      |L23.44|
000028  2002              MOVS     r0,#2                 ;619
00002a  e7f5              B        |L23.24|
                  |L23.44|
00002c  2d05              CMP      r5,#5                 ;621
00002e  d001              BEQ      |L23.52|
000030  2d04              CMP      r5,#4                 ;621
000032  d101              BNE      |L23.56|
                  |L23.52|
000034  2001              MOVS     r0,#1                 ;623
000036  e7ef              B        |L23.24|
                  |L23.56|
000038  4808              LDR      r0,|L23.92|
00003a  6b61              LDR      r1,[r4,#0x34]         ;627
00003c  6408              STR      r0,[r1,#0x40]         ;627
00003e  4808              LDR      r0,|L23.96|
000040  6b61              LDR      r1,[r4,#0x34]         ;628
000042  6508              STR      r0,[r1,#0x50]         ;628
000044  4643              MOV      r3,r8                 ;631
000046  4632              MOV      r2,r6                 ;631
000048  4639              MOV      r1,r7                 ;631
00004a  6b60              LDR      r0,[r4,#0x34]         ;631
00004c  f7fffffe          BL       HAL_DMA_Start_IT
000050  bf00              NOP                            ;634
000052  2000              MOVS     r0,#0                 ;634
000054  6320              STR      r0,[r4,#0x30]         ;634
000056  bf00              NOP                            ;634
000058  bf00              NOP                            ;636
00005a  e7dd              B        |L23.24|
;;;638    
                          ENDP

                  |L23.92|
                          DCD      HAL_SDRAM_DMA_XferCpltCallback
                  |L23.96|
                          DCD      HAL_SDRAM_DMA_XferErrorCallback

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F7_V1.11.0\\Drivers\\STM32F7xx_HAL_Driver\\Src\\stm32f7xx_hal_sdram.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32f7xx_hal_sdram_c_77ca3b75____REV16|
#line 464 "D:\\Program_Files_x86\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.1.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___21_stm32f7xx_hal_sdram_c_77ca3b75____REV16| PROC
#line 465

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32f7xx_hal_sdram_c_77ca3b75____REVSH|
#line 479
|__asm___21_stm32f7xx_hal_sdram_c_77ca3b75____REVSH| PROC
#line 480

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32f7xx_hal_sdram_c_77ca3b75____RRX|
#line 666
|__asm___21_stm32f7xx_hal_sdram_c_77ca3b75____RRX| PROC
#line 667

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
