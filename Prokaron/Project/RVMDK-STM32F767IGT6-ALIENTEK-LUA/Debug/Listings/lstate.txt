; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\lstate.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\lstate.d --cpu=Cortex-M7 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Inc -I.\Source -I.\Drivers -I..\..\..\M6P1(L)_Lua\lua -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6-ALIENTEK-LUA\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER -Dlua_writestring=RMP_lua_writestring -Dlua_writeline=RMP_lua_writeline --enum_is_int --signed_chars --omf_browse=.\debug\output\lstate.crf ..\..\..\M6P1(L)_Lua\lua\lstate.c]
                          THUMB

                          AREA ||i.close_state||, CODE, READONLY, ALIGN=1

                  close_state PROC
;;;259    
;;;260    static void close_state (lua_State *L) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;261      global_State *g = G(L);
000004  6925              LDR      r5,[r4,#0x10]
;;;262      luaF_close(L, L->stack);  /* close all upvalues for this thread */
000006  4620              MOV      r0,r4
000008  6a21              LDR      r1,[r4,#0x20]
00000a  f7fffffe          BL       luaF_close
;;;263      luaC_freeallobjects(L);  /* collect all objects */
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       luaC_freeallobjects
;;;264      if (g->version)  /* closing a fully built state? */
000014  f8d50090          LDR      r0,[r5,#0x90]
000018  b100              CBZ      r0,|L1.28|
;;;265        luai_userstateclose(L);
00001a  bf00              NOP      
                  |L1.28|
;;;266      luaM_freearray(L, G(L)->strt.hash, G(L)->strt.size);
00001c  6920              LDR      r0,[r4,#0x10]
00001e  69c0              LDR      r0,[r0,#0x1c]
000020  0082              LSLS     r2,r0,#2
000022  6920              LDR      r0,[r4,#0x10]
000024  6941              LDR      r1,[r0,#0x14]
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       luaM_free_
;;;267      freestack(L);
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       freestack
;;;268      lua_assert(gettotalbytes(g) == sizeof(LG));
;;;269      (*g->frealloc)(g->ud, fromstate(L), sizeof(LG), 0);  /* free main block */
000032  1f21              SUBS     r1,r4,#4
000034  2300              MOVS     r3,#0
000036  f44f7254          MOV      r2,#0x350
00003a  e9d56000          LDRD     r6,r0,[r5,#0]
00003e  47b0              BLX      r6
;;;270    }
000040  bd70              POP      {r4-r6,pc}
;;;271    
                          ENDP


                          AREA ||i.f_luaopen||, CODE, READONLY, ALIGN=1

                  f_luaopen PROC
;;;220    */
;;;221    static void f_luaopen (lua_State *L, void *ud) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;222      global_State *g = G(L);
000006  6925              LDR      r5,[r4,#0x10]
;;;223      UNUSED(ud);
;;;224      stack_init(L, L);  /* init stack */
000008  4621              MOV      r1,r4
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       stack_init
;;;225      init_registry(L, g);
000010  4629              MOV      r1,r5
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       init_registry
;;;226      luaS_init(L);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       luaS_init
;;;227      luaT_init(L);
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       luaT_init
;;;228      luaX_init(L);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       luaX_init
;;;229      g->gcrunning = 1;  /* allow gc */
00002a  2001              MOVS     r0,#1
00002c  f8850039          STRB     r0,[r5,#0x39]
;;;230      g->version = lua_version(NULL);
000030  2000              MOVS     r0,#0
000032  f7fffffe          BL       lua_version
000036  f8c50090          STR      r0,[r5,#0x90]
;;;231      luai_userstateopen(L);
;;;232    }
00003a  bd70              POP      {r4-r6,pc}
;;;233    
                          ENDP


                          AREA ||i.freestack||, CODE, READONLY, ALIGN=1

                  freestack PROC
;;;188    
;;;189    static void freestack (lua_State *L) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;190      if (L->stack == NULL)
000004  6a20              LDR      r0,[r4,#0x20]
000006  b900              CBNZ     r0,|L3.10|
                  |L3.8|
;;;191        return;  /* stack not completely built yet */
;;;192      L->ci = &L->base_ci;  /* free the entire 'ci' list */
;;;193      luaE_freeCI(L);
;;;194      lua_assert(L->nci == 0);
;;;195      luaM_freearray(L, L->stack, L->stacksize);  /* free stack array */
;;;196    }
000008  bd10              POP      {r4,pc}
                  |L3.10|
00000a  f1040034          ADD      r0,r4,#0x34           ;192
00000e  6160              STR      r0,[r4,#0x14]         ;192
000010  4620              MOV      r0,r4                 ;193
000012  f7fffffe          BL       luaE_freeCI
000016  6e20              LDR      r0,[r4,#0x60]         ;195
000018  0102              LSLS     r2,r0,#4              ;195
00001a  4620              MOV      r0,r4                 ;195
00001c  6a21              LDR      r1,[r4,#0x20]         ;195
00001e  f7fffffe          BL       luaM_free_
000022  bf00              NOP      
000024  e7f0              B        |L3.8|
;;;197    
                          ENDP


                          AREA ||i.init_registry||, CODE, READONLY, ALIGN=1

                  init_registry PROC
;;;201    */
;;;202    static void init_registry (lua_State *L, global_State *g) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  b086              SUB      sp,sp,#0x18
000006  4604              MOV      r4,r0
000008  460e              MOV      r6,r1
;;;203      TValue temp;
;;;204      /* create registry */
;;;205      Table *registry = luaH_new(L);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       luaH_new
000010  4605              MOV      r5,r0
;;;206      sethvalue(L, &g->l_registry, registry);
000012  f1060020          ADD      r0,r6,#0x20
000016  4629              MOV      r1,r5
000018  6001              STR      r1,[r0,#0]
00001a  2245              MOVS     r2,#0x45
00001c  7202              STRB     r2,[r0,#8]
;;;207      luaH_resize(L, registry, LUA_RIDX_LAST, 0);
00001e  2300              MOVS     r3,#0
000020  2202              MOVS     r2,#2
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       luaH_resize
;;;208      /* registry[LUA_RIDX_MAINTHREAD] = L */
;;;209      setthvalue(L, &temp, L);  /* temp = L */
000028  a802              ADD      r0,sp,#8
00002a  4621              MOV      r1,r4
00002c  6001              STR      r1,[r0,#0]
00002e  2248              MOVS     r2,#0x48
000030  7202              STRB     r2,[r0,#8]
;;;210      luaH_setint(L, registry, LUA_RIDX_MAINTHREAD, &temp);
000032  2201              MOVS     r2,#1
000034  2300              MOVS     r3,#0
000036  4629              MOV      r1,r5
000038  9000              STR      r0,[sp,#0]
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       luaH_setint
;;;211      /* registry[LUA_RIDX_GLOBALS] = table of globals */
;;;212      sethvalue(L, &temp, luaH_new(L));  /* temp = new table (global table) */
000040  af02              ADD      r7,sp,#8
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       luaH_new
000048  4680              MOV      r8,r0
00004a  f8c78000          STR      r8,[r7,#0]
00004e  2045              MOVS     r0,#0x45
000050  7238              STRB     r0,[r7,#8]
;;;213      luaH_setint(L, registry, LUA_RIDX_GLOBALS, &temp);
000052  a802              ADD      r0,sp,#8
000054  2202              MOVS     r2,#2
000056  2300              MOVS     r3,#0
000058  4629              MOV      r1,r5
00005a  9000              STR      r0,[sp,#0]
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       luaH_setint
;;;214    }
000062  b006              ADD      sp,sp,#0x18
000064  e8bd81f0          POP      {r4-r8,pc}
;;;215    
                          ENDP


                          AREA ||i.luaE_extendCI||, CODE, READONLY, ALIGN=1

                  luaE_extendCI PROC
;;;117    
;;;118    CallInfo *luaE_extendCI (lua_State *L) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;119      CallInfo *ci;
;;;120      luaE_incCcalls(L);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       luaE_incCcalls
;;;121      ci = luaM_new(L, CallInfo);
00000a  2200              MOVS     r2,#0
00000c  2124              MOVS     r1,#0x24
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       luaM_malloc_
000014  4605              MOV      r5,r0
;;;122      lua_assert(L->ci->next == NULL);
;;;123      L->ci->next = ci;
000016  6960              LDR      r0,[r4,#0x14]
000018  60c5              STR      r5,[r0,#0xc]
;;;124      ci->previous = L->ci;
00001a  6960              LDR      r0,[r4,#0x14]
00001c  60a8              STR      r0,[r5,#8]
;;;125      ci->next = NULL;
00001e  2000              MOVS     r0,#0
000020  60e8              STR      r0,[r5,#0xc]
;;;126      ci->u.l.trap = 0;
000022  2100              MOVS     r1,#0
000024  6169              STR      r1,[r5,#0x14]
;;;127      L->nci++;
000026  88e0              LDRH     r0,[r4,#6]
000028  1c40              ADDS     r0,r0,#1
00002a  80e0              STRH     r0,[r4,#6]
;;;128      return ci;
00002c  4628              MOV      r0,r5
;;;129    }
00002e  bd70              POP      {r4-r6,pc}
;;;130    
                          ENDP


                          AREA ||i.luaE_freeCI||, CODE, READONLY, ALIGN=1

                  luaE_freeCI PROC
;;;134    */
;;;135    void luaE_freeCI (lua_State *L) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;136      CallInfo *ci = L->ci;
000004  6965              LDR      r5,[r4,#0x14]
;;;137      CallInfo *next = ci->next;
000006  68ee              LDR      r6,[r5,#0xc]
;;;138      ci->next = NULL;
000008  2000              MOVS     r0,#0
00000a  60e8              STR      r0,[r5,#0xc]
;;;139      L->nCcalls -= L->nci;  /* to subtract removed elements from 'nCcalls' */
00000c  f8b4006e          LDRH     r0,[r4,#0x6e]
000010  88e1              LDRH     r1,[r4,#6]
000012  1a40              SUBS     r0,r0,r1
000014  f8a4006e          STRH     r0,[r4,#0x6e]
;;;140      while ((ci = next) != NULL) {
000018  e008              B        |L6.44|
                  |L6.26|
;;;141        next = ci->next;
00001a  68ee              LDR      r6,[r5,#0xc]
;;;142        luaM_free(L, ci);
00001c  2224              MOVS     r2,#0x24
00001e  4629              MOV      r1,r5
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       luaM_free_
;;;143        L->nci--;
000026  88e0              LDRH     r0,[r4,#6]
000028  1e40              SUBS     r0,r0,#1
00002a  80e0              STRH     r0,[r4,#6]
                  |L6.44|
00002c  1e35              SUBS     r5,r6,#0              ;140
00002e  d1f4              BNE      |L6.26|
;;;144      }
;;;145      L->nCcalls += L->nci;  /* to subtract removed elements from 'nCcalls' */
000030  f8b4006e          LDRH     r0,[r4,#0x6e]
000034  88e1              LDRH     r1,[r4,#6]
000036  4408              ADD      r0,r0,r1
000038  f8a4006e          STRH     r0,[r4,#0x6e]
;;;146    }
00003c  bd70              POP      {r4-r6,pc}
;;;147    
                          ENDP


                          AREA ||i.luaE_freethread||, CODE, READONLY, ALIGN=1

                  luaE_freethread PROC
;;;302    
;;;303    void luaE_freethread (lua_State *L, lua_State *L1) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;304      LX *l = fromstate(L1);
000006  1f26              SUBS     r6,r4,#4
;;;305      luaF_close(L1, L1->stack);  /* close all upvalues for this thread */
000008  4620              MOV      r0,r4
00000a  6a21              LDR      r1,[r4,#0x20]
00000c  f7fffffe          BL       luaF_close
;;;306      lua_assert(L1->openupval == NULL);
;;;307      luai_userstatefree(L, L1);
;;;308      freestack(L1);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       freestack
;;;309      luaM_free(L, l);
000016  227c              MOVS     r2,#0x7c
000018  4631              MOV      r1,r6
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       luaM_free_
;;;310    }
000020  bd70              POP      {r4-r6,pc}
;;;311    
                          ENDP


                          AREA ||i.luaE_incCcalls||, CODE, READONLY, ALIGN=2

                  luaE_incCcalls PROC
;;;107    */
;;;108    void luaE_incCcalls (lua_State *L) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;109      if (++L->nCcalls >= LUAI_MAXCCALLS) {
000004  f8b4006e          LDRH     r0,[r4,#0x6e]
000008  1c40              ADDS     r0,r0,#1
00000a  b280              UXTH     r0,r0
00000c  f8a4006e          STRH     r0,[r4,#0x6e]
000010  f6400198          MOV      r1,#0x898
000014  4288              CMP      r0,r1
000016  db12              BLT      |L8.62|
;;;110        if (L->nCcalls == LUAI_MAXCCALLS)
000018  f8b4006e          LDRH     r0,[r4,#0x6e]
00001c  4288              CMP      r0,r1
00001e  d104              BNE      |L8.42|
;;;111          luaG_runerror(L, "C stack overflow");
000020  a107              ADR      r1,|L8.64|
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       luaG_runerror
000028  e009              B        |L8.62|
                  |L8.42|
;;;112        else if (L->nCcalls >= (LUAI_MAXCCALLS + (LUAI_MAXCCALLS>>3)))
00002a  f8b4006e          LDRH     r0,[r4,#0x6e]
00002e  f64011ab          MOV      r1,#0x9ab
000032  4288              CMP      r0,r1
000034  db03              BLT      |L8.62|
;;;113          luaD_throw(L, LUA_ERRERR);  /* error while handing stack error */
000036  2106              MOVS     r1,#6
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       luaD_throw
                  |L8.62|
;;;114      }
;;;115    }
00003e  bd10              POP      {r4,pc}
;;;116    
                          ENDP

                  |L8.64|
000040  43207374          DCB      "C stack overflow",0
000044  61636b20
000048  6f766572
00004c  666c6f77
000050  00      
000051  00                DCB      0
000052  00                DCB      0
000053  00                DCB      0

                          AREA ||i.luaE_setdebt||, CODE, READONLY, ALIGN=1

                  luaE_setdebt PROC
;;;89     */
;;;90     void luaE_setdebt (global_State *g, l_mem debt) {
000000  b510              PUSH     {r4,lr}
;;;91       l_mem tb = gettotalbytes(g);
000002  e9d03402          LDRD     r3,r4,[r0,#8]
000006  191a              ADDS     r2,r3,r4
;;;92       lua_assert(tb > 0);
;;;93       if (debt < tb - MAX_LMEM)
000008  f06f4300          MVN      r3,#0x80000000
00000c  1ad3              SUBS     r3,r2,r3
00000e  428b              CMP      r3,r1
000010  dd02              BLE      |L9.24|
;;;94         debt = tb - MAX_LMEM;  /* will make 'totalbytes == MAX_LMEM' */
000012  f06f4300          MVN      r3,#0x80000000
000016  1ad1              SUBS     r1,r2,r3
                  |L9.24|
;;;95       g->totalbytes = tb - debt;
000018  1a53              SUBS     r3,r2,r1
00001a  6083              STR      r3,[r0,#8]
;;;96       g->GCdebt = debt;
00001c  60c1              STR      r1,[r0,#0xc]
;;;97     }
00001e  bd10              POP      {r4,pc}
;;;98     
                          ENDP


                          AREA ||i.luaE_shrinkCI||, CODE, READONLY, ALIGN=1

                  luaE_shrinkCI PROC
;;;151    */
;;;152    void luaE_shrinkCI (lua_State *L) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;153      CallInfo *ci = L->ci;
000004  6965              LDR      r5,[r4,#0x14]
;;;154      CallInfo *next2;  /* next's next */
;;;155      L->nCcalls -= L->nci;  /* to subtract removed elements from 'nCcalls' */
000006  f8b4006e          LDRH     r0,[r4,#0x6e]
00000a  88e1              LDRH     r1,[r4,#6]
00000c  1a40              SUBS     r0,r0,r1
00000e  f8a4006e          STRH     r0,[r4,#0x6e]
;;;156      /* while there are two nexts */
;;;157      while (ci->next != NULL && (next2 = ci->next->next) != NULL) {
000012  e00a              B        |L10.42|
                  |L10.20|
;;;158        luaM_free(L, ci->next);  /* free next */
000014  2224              MOVS     r2,#0x24
000016  4620              MOV      r0,r4
000018  68e9              LDR      r1,[r5,#0xc]
00001a  f7fffffe          BL       luaM_free_
;;;159        L->nci--;
00001e  88e0              LDRH     r0,[r4,#6]
000020  1e40              SUBS     r0,r0,#1
000022  80e0              STRH     r0,[r4,#6]
;;;160        ci->next = next2;  /* remove 'next' from the list */
000024  60ee              STR      r6,[r5,#0xc]
;;;161        next2->previous = ci;
000026  60b5              STR      r5,[r6,#8]
;;;162        ci = next2;  /* keep next's next */
000028  4635              MOV      r5,r6
                  |L10.42|
00002a  68e8              LDR      r0,[r5,#0xc]          ;157
00002c  b118              CBZ      r0,|L10.54|
00002e  68e8              LDR      r0,[r5,#0xc]          ;157
000030  68c6              LDR      r6,[r0,#0xc]          ;157
000032  2e00              CMP      r6,#0                 ;157
000034  d1ee              BNE      |L10.20|
                  |L10.54|
;;;163      }
;;;164      L->nCcalls += L->nci;  /* to subtract removed elements from 'nCcalls' */
000036  f8b4006e          LDRH     r0,[r4,#0x6e]
00003a  88e1              LDRH     r1,[r4,#6]
00003c  4408              ADD      r0,r0,r1
00003e  f8a4006e          STRH     r0,[r4,#0x6e]
;;;165    }
000042  bd70              POP      {r4-r6,pc}
;;;166    
                          ENDP


                          AREA ||i.lua_close||, CODE, READONLY, ALIGN=1

                  lua_close PROC
;;;363    
;;;364    LUA_API void lua_close (lua_State *L) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;365      L = G(L)->mainthread;  /* only the main thread can be closed */
000004  6920              LDR      r0,[r4,#0x10]
000006  f8d0408c          LDR      r4,[r0,#0x8c]
;;;366      lua_lock(L);
;;;367      close_state(L);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       close_state
;;;368    }
000010  bd10              POP      {r4,pc}
;;;369    
                          ENDP


                          AREA ||i.lua_newstate||, CODE, READONLY, ALIGN=2

                  lua_newstate PROC
;;;312    
;;;313    LUA_API lua_State *lua_newstate (lua_Alloc f, void *ud) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
;;;314      int i;
;;;315      lua_State *L;
;;;316      global_State *g;
;;;317      LG *l = cast(LG *, (*f)(ud, NULL, LUA_TTHREAD, sizeof(LG)));
000008  f44f7354          MOV      r3,#0x350
00000c  2208              MOVS     r2,#8
00000e  2100              MOVS     r1,#0
000010  4640              MOV      r0,r8
000012  47b8              BLX      r7
000014  4681              MOV      r9,r0
;;;318      if (l == NULL) return NULL;
000016  f1b90f00          CMP      r9,#0
00001a  d102              BNE      |L12.34|
00001c  2000              MOVS     r0,#0
                  |L12.30|
;;;319      L = &l->l.l;
;;;320      g = &l->g;
;;;321      L->tt = LUA_TTHREAD;
;;;322      g->currentwhite = bitmask(WHITE0BIT);
;;;323      L->marked = luaC_white(g);
;;;324      preinit_thread(L, g);
;;;325      g->allgc = obj2gco(L);  /* by now, only object is the main thread */
;;;326      L->next = NULL;
;;;327      g->frealloc = f;
;;;328      g->ud = ud;
;;;329      g->mainthread = L;
;;;330      g->seed = makeseed(L);
;;;331      g->gcrunning = 0;  /* no GC while building state */
;;;332      g->strt.size = g->strt.nuse = 0;
;;;333      g->strt.hash = NULL;
;;;334      setnilvalue(&g->l_registry);
;;;335      g->panic = NULL;
;;;336      g->version = NULL;
;;;337      g->gcstate = GCSpause;
;;;338      g->gckind = KGC_INC;
;;;339      g->gcemergency = 0;
;;;340      g->finobj = g->tobefnz = g->fixedgc = NULL;
;;;341      g->survival = g->old = g->reallyold = NULL;
;;;342      g->finobjsur = g->finobjold = g->finobjrold = NULL;
;;;343      g->sweepgc = NULL;
;;;344      g->gray = g->grayagain = NULL;
;;;345      g->weak = g->ephemeron = g->allweak = g->protogray = NULL;
;;;346      g->twups = NULL;
;;;347      g->totalbytes = sizeof(LG);
;;;348      g->GCdebt = 0;
;;;349      setgcparam(g->gcpause, LUAI_GCPAUSE);
;;;350      setgcparam(g->gcstepmul, LUAI_GCMUL);
;;;351      g->gcstepsize = LUAI_GCSTEPSIZE;
;;;352      setgcparam(g->genmajormul, LUAI_GENMAJORMUL);
;;;353      g->genminormul = LUAI_GENMINORMUL;
;;;354      for (i=0; i < LUA_NUMTAGS; i++) g->mt[i] = NULL;
;;;355      if (luaD_rawrunprotected(L, f_luaopen, NULL) != LUA_OK) {
;;;356        /* memory allocation error: free partial state */
;;;357        close_state(L);
;;;358        L = NULL;
;;;359      }
;;;360      return L;
;;;361    }
00001e  e8bd87f0          POP      {r4-r10,pc}
                  |L12.34|
000022  f1090504          ADD      r5,r9,#4              ;319
000026  f1090480          ADD      r4,r9,#0x80           ;320
00002a  2008              MOVS     r0,#8                 ;321
00002c  7128              STRB     r0,[r5,#4]            ;321
00002e  f8840034          STRB     r0,[r4,#0x34]         ;322
000032  f8940034          LDRB     r0,[r4,#0x34]         ;323
000036  f0000018          AND      r0,r0,#0x18           ;323
00003a  7168              STRB     r0,[r5,#5]            ;323
00003c  4621              MOV      r1,r4                 ;324
00003e  4628              MOV      r0,r5                 ;324
000040  f7fffffe          BL       preinit_thread
000044  6425              STR      r5,[r4,#0x40]         ;325
000046  2000              MOVS     r0,#0                 ;326
000048  6028              STR      r0,[r5,#0]            ;326
00004a  6027              STR      r7,[r4,#0]            ;327
00004c  f8c48004          STR      r8,[r4,#4]            ;328
000050  f8c4508c          STR      r5,[r4,#0x8c]         ;329
000054  4628              MOV      r0,r5                 ;330
000056  f7fffffe          BL       makeseed
00005a  6320              STR      r0,[r4,#0x30]         ;330
00005c  2000              MOVS     r0,#0                 ;331
00005e  f8840039          STRB     r0,[r4,#0x39]         ;331
000062  2100              MOVS     r1,#0                 ;332
000064  61a1              STR      r1,[r4,#0x18]         ;332
000066  61e1              STR      r1,[r4,#0x1c]         ;332
000068  6160              STR      r0,[r4,#0x14]         ;333
00006a  2028              MOVS     r0,#0x28              ;334
00006c  5501              STRB     r1,[r0,r4]            ;334
00006e  2000              MOVS     r0,#0                 ;335
000070  3420              ADDS     r4,r4,#0x20           ;335
000072  66a0              STR      r0,[r4,#0x68]         ;335
000074  6720              STR      r0,[r4,#0x70]         ;336
000076  2008              MOVS     r0,#8                 ;337
000078  7560              STRB     r0,[r4,#0x15]         ;337
00007a  2000              MOVS     r0,#0                 ;338
00007c  75a0              STRB     r0,[r4,#0x16]         ;338
00007e  76a0              STRB     r0,[r4,#0x1a]         ;339
000080  64a0              STR      r0,[r4,#0x48]         ;340
000082  6460              STR      r0,[r4,#0x44]         ;340
000084  62a0              STR      r0,[r4,#0x28]         ;340
000086  6560              STR      r0,[r4,#0x54]         ;341
000088  6520              STR      r0,[r4,#0x50]         ;341
00008a  64e0              STR      r0,[r4,#0x4c]         ;341
00008c  6620              STR      r0,[r4,#0x60]         ;342
00008e  65e0              STR      r0,[r4,#0x5c]         ;342
000090  65a0              STR      r0,[r4,#0x58]         ;342
000092  6260              STR      r0,[r4,#0x24]         ;343
000094  6320              STR      r0,[r4,#0x30]         ;344
000096  62e0              STR      r0,[r4,#0x2c]         ;344
000098  6420              STR      r0,[r4,#0x40]         ;345
00009a  63e0              STR      r0,[r4,#0x3c]         ;345
00009c  63a0              STR      r0,[r4,#0x38]         ;345
00009e  6360              STR      r0,[r4,#0x34]         ;345
0000a0  6660              STR      r0,[r4,#0x64]         ;346
0000a2  f44f7054          MOV      r0,#0x350             ;347
0000a6  f8440c18          STR      r0,[r4,#-0x18]        ;347
0000aa  2000              MOVS     r0,#0                 ;348
0000ac  f8440c14          STR      r0,[r4,#-0x14]        ;348
0000b0  2032              MOVS     r0,#0x32              ;349
0000b2  76e0              STRB     r0,[r4,#0x1b]         ;349
0000b4  2019              MOVS     r0,#0x19              ;350
0000b6  7720              STRB     r0,[r4,#0x1c]         ;350
0000b8  200d              MOVS     r0,#0xd               ;351
0000ba  7760              STRB     r0,[r4,#0x1d]         ;351
0000bc  2019              MOVS     r0,#0x19              ;352
0000be  7620              STRB     r0,[r4,#0x18]         ;352
0000c0  2014              MOVS     r0,#0x14              ;353
0000c2  75e0              STRB     r0,[r4,#0x17]         ;353
0000c4  3c20              SUBS     r4,r4,#0x20           ;353
0000c6  2600              MOVS     r6,#0                 ;354
0000c8  e005              B        |L12.214|
                  |L12.202|
0000ca  2100              MOVS     r1,#0                 ;354
0000cc  f5047080          ADD      r0,r4,#0x100          ;354
0000d0  f8401026          STR      r1,[r0,r6,LSL #2]     ;354
0000d4  1c76              ADDS     r6,r6,#1              ;354
                  |L12.214|
0000d6  2e09              CMP      r6,#9                 ;354
0000d8  dbf7              BLT      |L12.202|
0000da  2200              MOVS     r2,#0                 ;355
0000dc  4905              LDR      r1,|L12.244|
0000de  4628              MOV      r0,r5                 ;355
0000e0  f7fffffe          BL       luaD_rawrunprotected
0000e4  b118              CBZ      r0,|L12.238|
0000e6  4628              MOV      r0,r5                 ;357
0000e8  f7fffffe          BL       close_state
0000ec  2500              MOVS     r5,#0                 ;358
                  |L12.238|
0000ee  4628              MOV      r0,r5                 ;360
0000f0  e795              B        |L12.30|
;;;362    
                          ENDP

0000f2  0000              DCW      0x0000
                  |L12.244|
                          DCD      f_luaopen

                          AREA ||i.lua_newthread||, CODE, READONLY, ALIGN=1

                  lua_newthread PROC
;;;272    
;;;273    LUA_API lua_State *lua_newthread (lua_State *L) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;274      global_State *g = G(L);
000004  692e              LDR      r6,[r5,#0x10]
;;;275      lua_State *L1;
;;;276      lua_lock(L);
;;;277      luaC_checkGC(L);
000006  6928              LDR      r0,[r5,#0x10]
000008  68c0              LDR      r0,[r0,#0xc]
00000a  2800              CMP      r0,#0
00000c  dd03              BLE      |L13.22|
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       luaC_step
000014  bf00              NOP      
                  |L13.22|
;;;278      /* create new thread */
;;;279      L1 = &cast(LX *, luaM_newobject(L, LUA_TTHREAD, sizeof(LX)))->l;
000016  2208              MOVS     r2,#8
000018  217c              MOVS     r1,#0x7c
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       luaM_malloc_
000020  1d04              ADDS     r4,r0,#4
;;;280      L1->marked = luaC_white(g);
000022  f8960034          LDRB     r0,[r6,#0x34]
000026  f0000018          AND      r0,r0,#0x18
00002a  7160              STRB     r0,[r4,#5]
;;;281      L1->tt = LUA_TTHREAD;
00002c  2008              MOVS     r0,#8
00002e  7120              STRB     r0,[r4,#4]
;;;282      /* link it on list 'allgc' */
;;;283      L1->next = g->allgc;
000030  6c30              LDR      r0,[r6,#0x40]
000032  6020              STR      r0,[r4,#0]
;;;284      g->allgc = obj2gco(L1);
000034  6434              STR      r4,[r6,#0x40]
;;;285      /* anchor it on L stack */
;;;286      setthvalue2s(L, L->top, L1);
000036  68e8              LDR      r0,[r5,#0xc]
000038  4621              MOV      r1,r4
00003a  6001              STR      r1,[r0,#0]
00003c  2248              MOVS     r2,#0x48
00003e  7202              STRB     r2,[r0,#8]
;;;287      api_incr_top(L);
000040  68e8              LDR      r0,[r5,#0xc]
000042  3010              ADDS     r0,r0,#0x10
000044  60e8              STR      r0,[r5,#0xc]
;;;288      preinit_thread(L1, g);
000046  4631              MOV      r1,r6
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       preinit_thread
;;;289      L1->hookmask = L->hookmask;
00004e  6f28              LDR      r0,[r5,#0x70]
000050  6720              STR      r0,[r4,#0x70]
;;;290      L1->basehookcount = L->basehookcount;
000052  6e68              LDR      r0,[r5,#0x64]
000054  6660              STR      r0,[r4,#0x64]
;;;291      L1->hook = L->hook;
000056  6da8              LDR      r0,[r5,#0x58]
000058  65a0              STR      r0,[r4,#0x58]
;;;292      resethookcount(L1);
00005a  6e60              LDR      r0,[r4,#0x64]
00005c  66a0              STR      r0,[r4,#0x68]
;;;293      /* initialize L1 extra space */
;;;294      memcpy(lua_getextraspace(L1), lua_getextraspace(g->mainthread),
00005e  1f20              SUBS     r0,r4,#4
000060  f8d6108c          LDR      r1,[r6,#0x8c]
000064  f8511c04          LDR      r1,[r1,#-4]
000068  6001              STR      r1,[r0,#0]
;;;295             LUA_EXTRASPACE);
;;;296      luai_userstatethread(L, L1);
;;;297      stack_init(L1, L);  /* init stack */
00006a  4629              MOV      r1,r5
00006c  4620              MOV      r0,r4
00006e  f7fffffe          BL       stack_init
;;;298      lua_unlock(L);
;;;299      return L1;
000072  4620              MOV      r0,r4
;;;300    }
000074  bd70              POP      {r4-r6,pc}
;;;301    
                          ENDP


                          AREA ||i.makeseed||, CODE, READONLY, ALIGN=2

                  makeseed PROC
;;;72     
;;;73     static unsigned int makeseed (lua_State *L) {
000000  b530              PUSH     {r4,r5,lr}
000002  b085              SUB      sp,sp,#0x14
000004  4605              MOV      r5,r0
;;;74       char buff[4 * sizeof(size_t)];
;;;75       unsigned int h = luai_makeseed();
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       time
00000c  9000              STR      r0,[sp,#0]
;;;76       int p = 0;
00000e  2400              MOVS     r4,#0
;;;77       addbuff(buff, p, L);  /* heap variable */
000010  4628              MOV      r0,r5
000012  a901              ADD      r1,sp,#4
000014  4421              ADD      r1,r1,r4
000016  6008              STR      r0,[r1,#0]
000018  1d24              ADDS     r4,r4,#4
;;;78       addbuff(buff, p, &h);  /* local variable */
00001a  4668              MOV      r0,sp
00001c  a901              ADD      r1,sp,#4
00001e  4421              ADD      r1,r1,r4
000020  6008              STR      r0,[r1,#0]
000022  1d24              ADDS     r4,r4,#4
;;;79       addbuff(buff, p, luaO_nilobject);  /* global variable */
000024  4808              LDR      r0,|L14.72|
000026  a901              ADD      r1,sp,#4
000028  4421              ADD      r1,r1,r4
00002a  6008              STR      r0,[r1,#0]
00002c  1d24              ADDS     r4,r4,#4
;;;80       addbuff(buff, p, &lua_newstate);  /* public function */
00002e  4807              LDR      r0,|L14.76|
000030  a901              ADD      r1,sp,#4
000032  4421              ADD      r1,r1,r4
000034  6008              STR      r0,[r1,#0]
000036  1d24              ADDS     r4,r4,#4
;;;81       lua_assert(p == sizeof(buff));
;;;82       return luaS_hash(buff, p, h);
000038  4621              MOV      r1,r4
00003a  a801              ADD      r0,sp,#4
00003c  9a00              LDR      r2,[sp,#0]
00003e  f7fffffe          BL       luaS_hash
;;;83     }
000042  b005              ADD      sp,sp,#0x14
000044  bd30              POP      {r4,r5,pc}
;;;84     
                          ENDP

000046  0000              DCW      0x0000
                  |L14.72|
                          DCD      luaO_nilobject_
                  |L14.76|
                          DCD      lua_newstate

                          AREA ||i.preinit_thread||, CODE, READONLY, ALIGN=1

                  preinit_thread PROC
;;;238    */
;;;239    static void preinit_thread (lua_State *L, global_State *g) {
000000  6101              STR      r1,[r0,#0x10]
;;;240      G(L) = g;
;;;241      L->stack = NULL;
000002  2200              MOVS     r2,#0
000004  6202              STR      r2,[r0,#0x20]
;;;242      L->ci = NULL;
000006  6142              STR      r2,[r0,#0x14]
;;;243      L->nci = 0;
000008  80c2              STRH     r2,[r0,#6]
;;;244      L->stacksize = 0;
00000a  6602              STR      r2,[r0,#0x60]
;;;245      L->twups = L;  /* thread has no upvalues */
00000c  62c0              STR      r0,[r0,#0x2c]
;;;246      L->errorJmp = NULL;
00000e  6302              STR      r2,[r0,#0x30]
;;;247      L->nCcalls = 0;
000010  f8a0206e          STRH     r2,[r0,#0x6e]
;;;248      L->hook = NULL;
000014  6582              STR      r2,[r0,#0x58]
;;;249      L->hookmask = 0;
000016  6702              STR      r2,[r0,#0x70]
;;;250      L->basehookcount = 0;
000018  6642              STR      r2,[r0,#0x64]
;;;251      L->allowhook = 1;
00001a  2201              MOVS     r2,#1
00001c  f8802074          STRB     r2,[r0,#0x74]
;;;252      resethookcount(L);
000020  6e42              LDR      r2,[r0,#0x64]
000022  6682              STR      r2,[r0,#0x68]
;;;253      L->openupval = NULL;
000024  2200              MOVS     r2,#0
000026  6242              STR      r2,[r0,#0x24]
;;;254      L->nny = 1;
000028  2201              MOVS     r2,#1
00002a  f8a0206c          STRH     r2,[r0,#0x6c]
;;;255      L->status = LUA_OK;
00002e  2200              MOVS     r2,#0
000030  7202              STRB     r2,[r0,#8]
;;;256      L->errfunc = 0;
000032  65c2              STR      r2,[r0,#0x5c]
;;;257    }
000034  4770              BX       lr
;;;258    
                          ENDP


                          AREA ||i.stack_init||, CODE, READONLY, ALIGN=1

                  stack_init PROC
;;;167    
;;;168    static void stack_init (lua_State *L1, lua_State *L) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;169      int i; CallInfo *ci;
;;;170      /* initialize stack array */
;;;171      L1->stack = luaM_newvector(L, BASIC_STACK_SIZE, StackValue);
000008  2200              MOVS     r2,#0
00000a  f44f7120          MOV      r1,#0x280
00000e  4638              MOV      r0,r7
000010  f7fffffe          BL       luaM_malloc_
000014  6220              STR      r0,[r4,#0x20]
;;;172      L1->stacksize = BASIC_STACK_SIZE;
000016  2028              MOVS     r0,#0x28
000018  6620              STR      r0,[r4,#0x60]
;;;173      for (i = 0; i < BASIC_STACK_SIZE; i++)
00001a  2600              MOVS     r6,#0
00001c  e005              B        |L16.42|
                  |L16.30|
;;;174        setnilvalue(s2v(L1->stack + i));  /* erase new stack */
00001e  2000              MOVS     r0,#0
000020  6a21              LDR      r1,[r4,#0x20]
000022  eb011106          ADD      r1,r1,r6,LSL #4
000026  7208              STRB     r0,[r1,#8]
000028  1c76              ADDS     r6,r6,#1              ;173
                  |L16.42|
00002a  2e28              CMP      r6,#0x28              ;173
00002c  dbf7              BLT      |L16.30|
;;;175      L1->top = L1->stack;
00002e  6a20              LDR      r0,[r4,#0x20]
000030  60e0              STR      r0,[r4,#0xc]
;;;176      L1->stack_last = L1->stack + L1->stacksize - EXTRA_STACK;
000032  6e21              LDR      r1,[r4,#0x60]
000034  6a20              LDR      r0,[r4,#0x20]
000036  eb001001          ADD      r0,r0,r1,LSL #4
00003a  3850              SUBS     r0,r0,#0x50
00003c  61e0              STR      r0,[r4,#0x1c]
;;;177      /* initialize first ci */
;;;178      ci = &L1->base_ci;
00003e  f1040534          ADD      r5,r4,#0x34
;;;179      ci->next = ci->previous = NULL;
000042  2000              MOVS     r0,#0
000044  60a8              STR      r0,[r5,#8]
000046  60e8              STR      r0,[r5,#0xc]
;;;180      ci->callstatus = CIST_C;
000048  2002              MOVS     r0,#2
00004a  8468              STRH     r0,[r5,#0x22]
;;;181      ci->func = L1->top;
00004c  68e0              LDR      r0,[r4,#0xc]
00004e  6028              STR      r0,[r5,#0]
;;;182      setnilvalue(s2v(L1->top));  /* 'function' entry for this 'ci' */
000050  2000              MOVS     r0,#0
000052  68e1              LDR      r1,[r4,#0xc]
000054  7208              STRB     r0,[r1,#8]
;;;183      L1->top++;
000056  68e0              LDR      r0,[r4,#0xc]
000058  3010              ADDS     r0,r0,#0x10
00005a  60e0              STR      r0,[r4,#0xc]
;;;184      ci->top = L1->top + LUA_MINSTACK;
00005c  68e0              LDR      r0,[r4,#0xc]
00005e  f50070a0          ADD      r0,r0,#0x140
000062  6068              STR      r0,[r5,#4]
;;;185      L1->ci = ci;
000064  6165              STR      r5,[r4,#0x14]
;;;186    }
000066  e8bd81f0          POP      {r4-r8,pc}
;;;187    
                          ENDP

