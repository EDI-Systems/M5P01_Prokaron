; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\lmem.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\lmem.d --cpu=Cortex-M7 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Inc -I.\Source -I.\Drivers -I..\..\..\M6P1(L)_Lua\lua -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6-ALIENTEK-LUA\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER -Dlua_writestring=RMP_lua_writestring -Dlua_writeline=RMP_lua_writeline --enum_is_int --signed_chars --omf_browse=.\debug\output\lmem.crf ..\..\..\M6P1(L)_Lua\lua\lmem.c]
                          THUMB

                          AREA ||i.luaM_free_||, CODE, READONLY, ALIGN=1

                  luaM_free_ PROC
;;;108    */
;;;109    void luaM_free_ (lua_State *L, void *block, size_t osize) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
;;;110      global_State *g = G(L);
00000a  692c              LDR      r4,[r5,#0x10]
;;;111      lua_assert((block == 0) == (block == NULL));
;;;112      (*g->frealloc)(g->ud, block, osize, 0);
00000c  2300              MOVS     r3,#0
00000e  4632              MOV      r2,r6
000010  4639              MOV      r1,r7
000012  e9d4c000          LDRD     r12,r0,[r4,#0]
000016  47e0              BLX      r12
;;;113      g->GCdebt -= osize;
000018  68e0              LDR      r0,[r4,#0xc]
00001a  1b80              SUBS     r0,r0,r6
00001c  60e0              STR      r0,[r4,#0xc]
;;;114    }
00001e  e8bd81f0          POP      {r4-r8,pc}
;;;115    
                          ENDP


                          AREA ||i.luaM_growaux_||, CODE, READONLY, ALIGN=2

                  luaM_growaux_ PROC
;;;55     
;;;56     void *luaM_growaux_ (lua_State *L, void *block, int nelems, int *psize,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;57                          int size_elems, int limit, const char *what) {
000004  4683              MOV      r11,r0
000006  4688              MOV      r8,r1
000008  4691              MOV      r9,r2
00000a  461e              MOV      r6,r3
00000c  e9dda50a          LDRD     r10,r5,[sp,#0x28]
;;;58       void *newblock;
;;;59       int size = *psize;
000010  6834              LDR      r4,[r6,#0]
;;;60       if (nelems + 1 <= size)  /* does one extra element still fit? */
000012  f1090001          ADD      r0,r9,#1
000016  42a0              CMP      r0,r4
000018  dc02              BGT      |L2.32|
;;;61         return block;  /* nothing to be done */
00001a  4640              MOV      r0,r8
                  |L2.28|
;;;62       if (size >= limit / 2) {  /* cannot double it? */
;;;63         if (size >= limit)  /* cannot grow even a little? */
;;;64           luaG_runerror(L, "too many %s (limit is %d)", what, limit);
;;;65         size = limit;  /* still have at least one free place */
;;;66       }
;;;67       else {
;;;68         size *= 2;
;;;69         if (size < MINSIZEARRAY)
;;;70           size = MINSIZEARRAY;  /* minimum size */
;;;71       }
;;;72       lua_assert(nelems + 1 <= size && size <= limit);
;;;73       /* 'limit' ensures that multiplication will not overflow */
;;;74       newblock = luaM_realloc_(L, block, cast_sizet(*psize) * size_elems,
;;;75                                          cast_sizet(size) * size_elems);
;;;76       if (newblock == NULL)
;;;77         luaM_error(L);
;;;78       *psize = size;  /* update only when everything else is OK */
;;;79       return newblock;
;;;80     }
00001c  e8bd9ff0          POP      {r4-r12,pc}
                  |L2.32|
000020  eb0571d5          ADD      r1,r5,r5,LSR #31      ;62
000024  ebb40f61          CMP      r4,r1,ASR #1          ;62
000028  db09              BLT      |L2.62|
00002a  42ac              CMP      r4,r5                 ;63
00002c  db05              BLT      |L2.58|
00002e  462b              MOV      r3,r5                 ;64
000030  a10e              ADR      r1,|L2.108|
000032  4658              MOV      r0,r11                ;64
000034  9a0c              LDR      r2,[sp,#0x30]         ;64
000036  f7fffffe          BL       luaG_runerror
                  |L2.58|
00003a  462c              MOV      r4,r5                 ;65
00003c  e003              B        |L2.70|
                  |L2.62|
00003e  0064              LSLS     r4,r4,#1              ;68
000040  2c04              CMP      r4,#4                 ;69
000042  da00              BGE      |L2.70|
000044  2404              MOVS     r4,#4                 ;70
                  |L2.70|
000046  fb04f30a          MUL      r3,r4,r10             ;74
00004a  6830              LDR      r0,[r6,#0]            ;74
00004c  fb00f20a          MUL      r2,r0,r10             ;74
000050  4641              MOV      r1,r8                 ;74
000052  4658              MOV      r0,r11                ;74
000054  f7fffffe          BL       luaM_realloc_
000058  4607              MOV      r7,r0                 ;74
00005a  b91f              CBNZ     r7,|L2.100|
00005c  2104              MOVS     r1,#4                 ;77
00005e  4658              MOV      r0,r11                ;77
000060  f7fffffe          BL       luaD_throw
                  |L2.100|
000064  6034              STR      r4,[r6,#0]            ;78
000066  4638              MOV      r0,r7                 ;79
000068  e7d8              B        |L2.28|
;;;81     
                          ENDP

00006a  0000              DCW      0x0000
                  |L2.108|
00006c  746f6f20          DCB      "too many %s (limit is %d)",0
000070  6d616e79
000074  20257320
000078  286c696d
00007c  69742069
000080  73202564
000084  2900    
000086  00                DCB      0
000087  00                DCB      0

                          AREA ||i.luaM_malloc_||, CODE, READONLY, ALIGN=1

                  luaM_malloc_ PROC
;;;150    
;;;151    void *luaM_malloc_ (lua_State *L, size_t size, int tag) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4690              MOV      r8,r2
;;;152      hardtest(L, 0, size);
;;;153      if (size == 0)
00000a  b915              CBNZ     r5,|L3.18|
;;;154        return NULL;  /* that's all */
00000c  2000              MOVS     r0,#0
                  |L3.14|
;;;155      else {
;;;156        global_State *g = G(L);
;;;157        void *newblock = (*g->frealloc)(g->ud, NULL, tag, size);
;;;158        if (newblock == NULL) {
;;;159          if (g->version) {  /* is state fully built? */
;;;160            luaC_fullgc(L, 1);  /* try to free some memory... */
;;;161            newblock = (*g->frealloc)(g->ud, NULL, tag, size);  /* try again */
;;;162          }
;;;163          if (newblock == NULL)
;;;164            luaM_error(L);
;;;165        }
;;;166        g->GCdebt += size;
;;;167        return newblock;
;;;168      }
;;;169    }
00000e  e8bd81f0          POP      {r4-r8,pc}
                  |L3.18|
000012  693c              LDR      r4,[r7,#0x10]         ;156
000014  462b              MOV      r3,r5                 ;157
000016  4642              MOV      r2,r8                 ;157
000018  2100              MOVS     r1,#0                 ;157
00001a  e9d4c000          LDRD     r12,r0,[r4,#0]        ;157
00001e  47e0              BLX      r12                   ;157
000020  4606              MOV      r6,r0                 ;157
000022  b996              CBNZ     r6,|L3.74|
000024  f8d40090          LDR      r0,[r4,#0x90]         ;159
000028  b150              CBZ      r0,|L3.64|
00002a  2101              MOVS     r1,#1                 ;160
00002c  4638              MOV      r0,r7                 ;160
00002e  f7fffffe          BL       luaC_fullgc
000032  462b              MOV      r3,r5                 ;161
000034  4642              MOV      r2,r8                 ;161
000036  2100              MOVS     r1,#0                 ;161
000038  e9d4c000          LDRD     r12,r0,[r4,#0]        ;161
00003c  47e0              BLX      r12                   ;161
00003e  4606              MOV      r6,r0                 ;161
                  |L3.64|
000040  b91e              CBNZ     r6,|L3.74|
000042  2104              MOVS     r1,#4                 ;164
000044  4638              MOV      r0,r7                 ;164
000046  f7fffffe          BL       luaD_throw
                  |L3.74|
00004a  68e0              LDR      r0,[r4,#0xc]          ;166
00004c  4428              ADD      r0,r0,r5              ;166
00004e  60e0              STR      r0,[r4,#0xc]          ;166
000050  4630              MOV      r0,r6                 ;167
000052  e7dc              B        |L3.14|
                          ENDP


                          AREA ||i.luaM_realloc_||, CODE, READONLY, ALIGN=1

                  luaM_realloc_ PROC
;;;120    */
;;;121    void *luaM_realloc_ (lua_State *L, void *block, size_t osize, size_t nsize) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4680              MOV      r8,r0
000006  4689              MOV      r9,r1
000008  4616              MOV      r6,r2
00000a  461d              MOV      r5,r3
;;;122      void *newblock;
;;;123      global_State *g = G(L);
00000c  f8d84010          LDR      r4,[r8,#0x10]
;;;124      lua_assert((osize == 0) == (block == NULL));
;;;125      hardtest(L, osize, nsize);
;;;126      newblock = (*g->frealloc)(g->ud, block, osize, nsize);
000010  462b              MOV      r3,r5
000012  4632              MOV      r2,r6
000014  4649              MOV      r1,r9
000016  e9d4c000          LDRD     r12,r0,[r4,#0]
00001a  47e0              BLX      r12
00001c  4607              MOV      r7,r0
;;;127      if (newblock == NULL && nsize > 0) {
00001e  b9a7              CBNZ     r7,|L4.74|
000020  b19d              CBZ      r5,|L4.74|
;;;128        /* Is state fully built? Not shrinking a block? */
;;;129        if (g->version && nsize > osize) {
000022  f8d40090          LDR      r0,[r4,#0x90]
000026  b160              CBZ      r0,|L4.66|
000028  42b5              CMP      r5,r6
00002a  d90a              BLS      |L4.66|
;;;130          luaC_fullgc(L, 1);  /* try to free some memory... */
00002c  2101              MOVS     r1,#1
00002e  4640              MOV      r0,r8
000030  f7fffffe          BL       luaC_fullgc
;;;131          newblock = (*g->frealloc)(g->ud, block, osize, nsize);  /* try again */
000034  462b              MOV      r3,r5
000036  4632              MOV      r2,r6
000038  4649              MOV      r1,r9
00003a  e9d4c000          LDRD     r12,r0,[r4,#0]
00003e  47e0              BLX      r12
000040  4607              MOV      r7,r0
                  |L4.66|
;;;132        }
;;;133        if (newblock == NULL)
000042  b917              CBNZ     r7,|L4.74|
;;;134          return NULL;
000044  2000              MOVS     r0,#0
                  |L4.70|
;;;135      }
;;;136      lua_assert((nsize == 0) == (newblock == NULL));
;;;137      g->GCdebt = (g->GCdebt + nsize) - osize;
;;;138      return newblock;
;;;139    }
000046  e8bd87f0          POP      {r4-r10,pc}
                  |L4.74|
00004a  68e0              LDR      r0,[r4,#0xc]          ;137
00004c  4428              ADD      r0,r0,r5              ;137
00004e  1b80              SUBS     r0,r0,r6              ;137
000050  60e0              STR      r0,[r4,#0xc]          ;137
000052  4638              MOV      r0,r7                 ;138
000054  e7f7              B        |L4.70|
;;;140    
                          ENDP


                          AREA ||i.luaM_saferealloc_||, CODE, READONLY, ALIGN=1

                  luaM_saferealloc_ PROC
;;;141    
;;;142    void *luaM_saferealloc_ (lua_State *L, void *block, size_t osize,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;143                                                        size_t nsize) {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  461c              MOV      r4,r3
;;;144      void *newblock = luaM_realloc_(L, block, osize, nsize);
00000c  4623              MOV      r3,r4
00000e  4642              MOV      r2,r8
000010  4639              MOV      r1,r7
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       luaM_realloc_
000018  4605              MOV      r5,r0
;;;145      if (newblock == NULL && nsize > 0)  /* allocation failed? */
00001a  b925              CBNZ     r5,|L5.38|
00001c  b11c              CBZ      r4,|L5.38|
;;;146        luaM_error(L);
00001e  2104              MOVS     r1,#4
000020  4630              MOV      r0,r6
000022  f7fffffe          BL       luaD_throw
                  |L5.38|
;;;147      return newblock;
000026  4628              MOV      r0,r5
;;;148    }
000028  e8bd81f0          POP      {r4-r8,pc}
;;;149    
                          ENDP


                          AREA ||i.luaM_shrinkvector_||, CODE, READONLY, ALIGN=1

                  luaM_shrinkvector_ PROC
;;;82     
;;;83     void *luaM_shrinkvector_ (lua_State *L, void *block, int *size,
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;84                               int final_n, int size_elem) {
000004  4607              MOV      r7,r0
000006  4616              MOV      r6,r2
000008  461c              MOV      r4,r3
00000a  f8dd8038          LDR      r8,[sp,#0x38]
;;;85       global_State *g = G(L);
00000e  693d              LDR      r5,[r7,#0x10]
;;;86       void *newblock;
;;;87       size_t oldsize = cast_sizet((*size) * size_elem);
000010  6830              LDR      r0,[r6,#0]
000012  fb00fa08          MUL      r10,r0,r8
;;;88       size_t newsize = cast_sizet(final_n * size_elem);
000016  fb04fb08          MUL      r11,r4,r8
;;;89       lua_assert(newsize <= oldsize);
;;;90       newblock = (*g->frealloc)(g->ud, block, oldsize, newsize);
00001a  465b              MOV      r3,r11
00001c  4652              MOV      r2,r10
00001e  e9d5c000          LDRD     r12,r0,[r5,#0]
000022  9901              LDR      r1,[sp,#4]
000024  47e0              BLX      r12
000026  4681              MOV      r9,r0
;;;91       if (newblock == NULL && final_n > 0)  /* allocation failed? */
000028  f1b90f00          CMP      r9,#0
00002c  d106              BNE      |L6.60|
00002e  2c00              CMP      r4,#0
000030  dd04              BLE      |L6.60|
;;;92         luaM_error(L);
000032  2104              MOVS     r1,#4
000034  4638              MOV      r0,r7
000036  f7fffffe          BL       luaD_throw
00003a  e009              B        |L6.80|
                  |L6.60|
;;;93       else {
;;;94         g->GCdebt += newsize - oldsize;
00003c  ebab010a          SUB      r1,r11,r10
000040  68e8              LDR      r0,[r5,#0xc]
000042  4408              ADD      r0,r0,r1
000044  60e8              STR      r0,[r5,#0xc]
;;;95         *size = final_n;
000046  6034              STR      r4,[r6,#0]
;;;96         return newblock;
000048  4648              MOV      r0,r9
                  |L6.74|
;;;97       }
;;;98     }
00004a  b004              ADD      sp,sp,#0x10
00004c  e8bd9ff0          POP      {r4-r12,pc}
                  |L6.80|
000050  bf00              NOP      
000052  e7fa              B        |L6.74|
;;;99     
                          ENDP


                          AREA ||i.luaM_toobig||, CODE, READONLY, ALIGN=2

                  luaM_toobig PROC
;;;100    
;;;101    l_noret luaM_toobig (lua_State *L) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;102      luaG_runerror(L, "memory allocation error: block too big");
000004  a102              ADR      r1,|L7.16|
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       luaG_runerror
;;;103    }
00000c  bd10              POP      {r4,pc}
;;;104    
                          ENDP

00000e  0000              DCW      0x0000
                  |L7.16|
000010  6d656d6f          DCB      "memory allocation error: block too big",0
000014  72792061
000018  6c6c6f63
00001c  6174696f
000020  6e206572
000024  726f723a
000028  20626c6f
00002c  636b2074
000030  6f6f2062
000034  696700  
000037  00                DCB      0
