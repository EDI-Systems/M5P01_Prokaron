; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\lstrlib.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\lstrlib.d --cpu=Cortex-M7 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Inc -I.\Source -I.\Drivers -I..\..\..\M6P1(L)_Lua\lua -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6-ALIENTEK-LUA\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER -Dlua_writestring=RMP_lua_writestring -Dlua_writeline=RMP_lua_writeline --enum_is_int --signed_chars --omf_browse=.\debug\output\lstrlib.crf ..\..\..\M6P1(L)_Lua\lua\lstrlib.c]
                          THUMB

                          AREA ||i.add_s||, CODE, READONLY, ALIGN=2

                  add_s PROC
;;;789    
;;;790    static void add_s (MatchState *ms, luaL_Buffer *b, const char *s,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;791                                                       const char *e) {
000004  4680              MOV      r8,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
00000a  4699              MOV      r9,r3
;;;792      size_t l, i;
;;;793      lua_State *L = ms->L;
00000c  f8d8a00c          LDR      r10,[r8,#0xc]
;;;794      const char *news = lua_tolstring(L, 3, &l);
000010  466a              MOV      r2,sp
000012  2103              MOVS     r1,#3
000014  4650              MOV      r0,r10
000016  f7fffffe          BL       lua_tolstring
00001a  4606              MOV      r6,r0
;;;795      for (i = 0; i < l; i++) {
00001c  2500              MOVS     r5,#0
00001e  e056              B        |L1.206|
                  |L1.32|
;;;796        if (news[i] != L_ESC)
000020  5d70              LDRB     r0,[r6,r5]
000022  2825              CMP      r0,#0x25
000024  d00e              BEQ      |L1.68|
;;;797          luaL_addchar(b, news[i]);
000026  e9d41001          LDRD     r1,r0,[r4,#4]
00002a  4288              CMP      r0,r1
00002c  d303              BCC      |L1.54|
00002e  2101              MOVS     r1,#1
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       luaL_prepbuffsize
                  |L1.54|
000036  5d71              LDRB     r1,[r6,r5]
000038  68a2              LDR      r2,[r4,#8]
00003a  1c50              ADDS     r0,r2,#1
00003c  60a0              STR      r0,[r4,#8]
00003e  6820              LDR      r0,[r4,#0]
000040  5481              STRB     r1,[r0,r2]
000042  e043              B        |L1.204|
                  |L1.68|
;;;798        else {
;;;799          i++;  /* skip ESC */
000044  1c6d              ADDS     r5,r5,#1
;;;800          if (!isdigit(uchar(news[i]))) {
000046  f7fffffe          BL       __rt_ctype_table
00004a  6800              LDR      r0,[r0,#0]
00004c  5d71              LDRB     r1,[r6,r5]
00004e  5c40              LDRB     r0,[r0,r1]
000050  2820              CMP      r0,#0x20
000052  d016              BEQ      |L1.130|
;;;801            if (news[i] != L_ESC)
000054  5d70              LDRB     r0,[r6,r5]
000056  2825              CMP      r0,#0x25
000058  d004              BEQ      |L1.100|
;;;802              luaL_error(L, "invalid use of '%c' in replacement string", L_ESC);
00005a  2225              MOVS     r2,#0x25
00005c  a11e              ADR      r1,|L1.216|
00005e  4650              MOV      r0,r10
000060  f7fffffe          BL       luaL_error
                  |L1.100|
;;;803            luaL_addchar(b, news[i]);
000064  e9d41001          LDRD     r1,r0,[r4,#4]
000068  4288              CMP      r0,r1
00006a  d303              BCC      |L1.116|
00006c  2101              MOVS     r1,#1
00006e  4620              MOV      r0,r4
000070  f7fffffe          BL       luaL_prepbuffsize
                  |L1.116|
000074  5d71              LDRB     r1,[r6,r5]
000076  68a2              LDR      r2,[r4,#8]
000078  1c50              ADDS     r0,r2,#1
00007a  60a0              STR      r0,[r4,#8]
00007c  6820              LDR      r0,[r4,#0]
00007e  5481              STRB     r1,[r0,r2]
000080  e024              B        |L1.204|
                  |L1.130|
;;;804          }
;;;805          else if (news[i] == '0')
000082  5d70              LDRB     r0,[r6,r5]
000084  2830              CMP      r0,#0x30
000086  d106              BNE      |L1.150|
;;;806              luaL_addlstring(b, s, e - s);
000088  eba90207          SUB      r2,r9,r7
00008c  4639              MOV      r1,r7
00008e  4620              MOV      r0,r4
000090  f7fffffe          BL       luaL_addlstring
000094  e01a              B        |L1.204|
                  |L1.150|
;;;807          else {
;;;808            push_onecapture(ms, news[i] - '1', s, e);
000096  5770              LDRSB    r0,[r6,r5]
000098  f1a00131          SUB      r1,r0,#0x31
00009c  464b              MOV      r3,r9
00009e  463a              MOV      r2,r7
0000a0  4640              MOV      r0,r8
0000a2  f7fffffe          BL       push_onecapture
;;;809            luaL_tolstring(L, -1, NULL);  /* if number, convert it to string */
0000a6  2200              MOVS     r2,#0
0000a8  1e51              SUBS     r1,r2,#1
0000aa  4650              MOV      r0,r10
0000ac  f7fffffe          BL       luaL_tolstring
;;;810            lua_remove(L, -2);  /* remove original value */
0000b0  f04f32ff          MOV      r2,#0xffffffff
0000b4  0051              LSLS     r1,r2,#1
0000b6  4650              MOV      r0,r10
0000b8  f7fffffe          BL       lua_rotate
0000bc  f06f0101          MVN      r1,#1
0000c0  4650              MOV      r0,r10
0000c2  f7fffffe          BL       lua_settop
;;;811            luaL_addvalue(b);  /* add capture to accumulated result */
0000c6  4620              MOV      r0,r4
0000c8  f7fffffe          BL       luaL_addvalue
                  |L1.204|
0000cc  1c6d              ADDS     r5,r5,#1              ;795
                  |L1.206|
0000ce  9800              LDR      r0,[sp,#0]            ;795
0000d0  4285              CMP      r5,r0                 ;795
0000d2  d3a5              BCC      |L1.32|
;;;812          }
;;;813        }
;;;814      }
;;;815    }
0000d4  e8bd8ff8          POP      {r3-r11,pc}
;;;816    
                          ENDP

                  |L1.216|
0000d8  696e7661          DCB      "invalid use of '%c' in replacement string",0
0000dc  6c696420
0000e0  75736520
0000e4  6f662027
0000e8  25632720
0000ec  696e2072
0000f0  65706c61
0000f4  63656d65
0000f8  6e742073
0000fc  7472696e
000100  6700    
000102  00                DCB      0
000103  00                DCB      0

                          AREA ||i.add_value||, CODE, READONLY, ALIGN=2

                  add_value PROC
;;;817    
;;;818    static void add_value (MatchState *ms, luaL_Buffer *b, const char *s,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;819                                           const char *e, int tr) {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
00000c  f8dd8028          LDR      r8,[sp,#0x28]
;;;820      lua_State *L = ms->L;
000010  f8d6900c          LDR      r9,[r6,#0xc]
;;;821      switch (tr) {
000014  f1b80f05          CMP      r8,#5
000018  d015              BEQ      |L2.70|
00001a  f1b80f06          CMP      r8,#6
00001e  d11d              BNE      |L2.92|
;;;822        case LUA_TFUNCTION: {
;;;823          int n;
;;;824          lua_pushvalue(L, 3);
000020  2103              MOVS     r1,#3
000022  4648              MOV      r0,r9
000024  f7fffffe          BL       lua_pushvalue
;;;825          n = push_captures(ms, s, e);
000028  462a              MOV      r2,r5
00002a  4621              MOV      r1,r4
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       push_captures
000032  4682              MOV      r10,r0
;;;826          lua_call(L, n, 1);
000034  2000              MOVS     r0,#0
000036  4603              MOV      r3,r0
000038  2201              MOVS     r2,#1
00003a  4651              MOV      r1,r10
00003c  9000              STR      r0,[sp,#0]
00003e  4648              MOV      r0,r9
000040  f7fffffe          BL       lua_callk
;;;827          break;
000044  e012              B        |L2.108|
                  |L2.70|
;;;828        }
;;;829        case LUA_TTABLE: {
;;;830          push_onecapture(ms, 0, s, e);
000046  462b              MOV      r3,r5
000048  4622              MOV      r2,r4
00004a  2100              MOVS     r1,#0
00004c  4630              MOV      r0,r6
00004e  f7fffffe          BL       push_onecapture
;;;831          lua_gettable(L, 3);
000052  2103              MOVS     r1,#3
000054  4648              MOV      r0,r9
000056  f7fffffe          BL       lua_gettable
;;;832          break;
00005a  e007              B        |L2.108|
                  |L2.92|
;;;833        }
;;;834        default: {  /* LUA_TNUMBER or LUA_TSTRING */
;;;835          add_s(ms, b, s, e);
00005c  462b              MOV      r3,r5
00005e  4622              MOV      r2,r4
000060  4639              MOV      r1,r7
000062  4630              MOV      r0,r6
000064  f7fffffe          BL       add_s
                  |L2.104|
;;;836          return;
;;;837        }
;;;838      }
;;;839      if (!lua_toboolean(L, -1)) {  /* nil or false? */
;;;840        lua_pop(L, 1);
;;;841        lua_pushlstring(L, s, e - s);  /* keep original text */
;;;842      }
;;;843      else if (!lua_isstring(L, -1))
;;;844        luaL_error(L, "invalid replacement value (a %s)", luaL_typename(L, -1));
;;;845      luaL_addvalue(b);  /* add result to accumulator */
;;;846    }
000068  e8bd8ff8          POP      {r3-r11,pc}
                  |L2.108|
00006c  bf00              NOP                            ;827
00006e  f04f31ff          MOV      r1,#0xffffffff        ;839
000072  4648              MOV      r0,r9                 ;839
000074  f7fffffe          BL       lua_toboolean
000078  b950              CBNZ     r0,|L2.144|
00007a  f06f0101          MVN      r1,#1                 ;840
00007e  4648              MOV      r0,r9                 ;840
000080  f7fffffe          BL       lua_settop
000084  1b2a              SUBS     r2,r5,r4              ;841
000086  4621              MOV      r1,r4                 ;841
000088  4648              MOV      r0,r9                 ;841
00008a  f7fffffe          BL       lua_pushlstring
00008e  e015              B        |L2.188|
                  |L2.144|
000090  f04f31ff          MOV      r1,#0xffffffff        ;843
000094  4648              MOV      r0,r9                 ;843
000096  f7fffffe          BL       lua_isstring
00009a  b978              CBNZ     r0,|L2.188|
00009c  f04f31ff          MOV      r1,#0xffffffff        ;844
0000a0  4648              MOV      r0,r9                 ;844
0000a2  f7fffffe          BL       lua_type
0000a6  4683              MOV      r11,r0                ;844
0000a8  4659              MOV      r1,r11                ;844
0000aa  4648              MOV      r0,r9                 ;844
0000ac  f7fffffe          BL       lua_typename
0000b0  4682              MOV      r10,r0                ;844
0000b2  4652              MOV      r2,r10                ;844
0000b4  a104              ADR      r1,|L2.200|
0000b6  4648              MOV      r0,r9                 ;844
0000b8  f7fffffe          BL       luaL_error
                  |L2.188|
0000bc  4638              MOV      r0,r7                 ;845
0000be  f7fffffe          BL       luaL_addvalue
0000c2  bf00              NOP      
0000c4  e7d0              B        |L2.104|
;;;847    
                          ENDP

0000c6  0000              DCW      0x0000
                  |L2.200|
0000c8  696e7661          DCB      "invalid replacement value (a %s)",0
0000cc  6c696420
0000d0  7265706c
0000d4  6163656d
0000d8  656e7420
0000dc  76616c75
0000e0  65202861
0000e4  20257329
0000e8  00      
0000e9  00                DCB      0
0000ea  00                DCB      0
0000eb  00                DCB      0

                          AREA ||i.addlenmod||, CODE, READONLY, ALIGN=1

                  addlenmod PROC
;;;1105   */
;;;1106   static void addlenmod (char *form, const char *lenmod) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;1107     size_t l = strlen(form);
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       strlen
00000e  4605              MOV      r5,r0
;;;1108     size_t lm = strlen(lenmod);
000010  4630              MOV      r0,r6
000012  f7fffffe          BL       strlen
000016  4607              MOV      r7,r0
;;;1109     char spec = form[l - 1];
000018  1e68              SUBS     r0,r5,#1
00001a  f9148000          LDRSB    r8,[r4,r0]
;;;1110     strcpy(form + l - 1, lenmod);
00001e  1961              ADDS     r1,r4,r5
000020  1e48              SUBS     r0,r1,#1
000022  4631              MOV      r1,r6
000024  f7fffffe          BL       strcpy
;;;1111     form[l + lm - 1] = spec;
000028  19e8              ADDS     r0,r5,r7
00002a  1e40              SUBS     r0,r0,#1
00002c  f8048000          STRB     r8,[r4,r0]
;;;1112     form[l + lm] = '\0';
000030  2000              MOVS     r0,#0
000032  19e9              ADDS     r1,r5,r7
000034  5460              STRB     r0,[r4,r1]
;;;1113   }
000036  e8bd81f0          POP      {r4-r8,pc}
;;;1114   
                          ENDP


                          AREA ||i.addliteral||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_sizespec
                          REQUIRE _printf_percent
                          REQUIRE _printf_return_value
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_lld
                          REQUIRE _printf_lli
                          REQUIRE _printf_llu
                          REQUIRE _printf_llo
                          REQUIRE _printf_llx
                          REQUIRE _printf_longlong_dec
                          REQUIRE _printf_longlong_oct
                          REQUIRE _printf_longlong_hex
                  addliteral PROC
;;;1045   
;;;1046   static void addliteral (lua_State *L, luaL_Buffer *b, int arg) {
000000  e92d5ffc          PUSH     {r2-r12,lr}
000004  4681              MOV      r9,r0
000006  460c              MOV      r4,r1
000008  4690              MOV      r8,r2
;;;1047     switch (lua_type(L, arg)) {
00000a  4641              MOV      r1,r8
00000c  4648              MOV      r0,r9
00000e  f7fffffe          BL       lua_type
000012  2800              CMP      r0,#0
000014  d04a              BEQ      |L4.172|
000016  2801              CMP      r0,#1
000018  d049              BEQ      |L4.174|
00001a  2803              CMP      r0,#3
00001c  d00d              BEQ      |L4.58|
00001e  2804              CMP      r0,#4
000020  d14e              BNE      |L4.192|
;;;1048       case LUA_TSTRING: {
;;;1049         size_t len;
;;;1050         const char *s = lua_tolstring(L, arg, &len);
000022  aa01              ADD      r2,sp,#4
000024  4641              MOV      r1,r8
000026  4648              MOV      r0,r9
000028  f7fffffe          BL       lua_tolstring
00002c  4605              MOV      r5,r0
;;;1051         addquoted(b, s, len);
00002e  4629              MOV      r1,r5
000030  4620              MOV      r0,r4
000032  9a01              LDR      r2,[sp,#4]
000034  f7fffffe          BL       addquoted
;;;1052         break;
000038  e048              B        |L4.204|
                  |L4.58|
;;;1053       }
;;;1054       case LUA_TNUMBER: {
;;;1055         char *buff = luaL_prepbuffsize(b, MAX_ITEM);
00003a  f44f71d6          MOV      r1,#0x1ac
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       luaL_prepbuffsize
000044  4682              MOV      r10,r0
;;;1056         int nb;
;;;1057         if (!lua_isinteger(L, arg))  /* float? */
000046  4641              MOV      r1,r8
000048  4648              MOV      r0,r9
00004a  f7fffffe          BL       lua_isinteger
00004e  b968              CBNZ     r0,|L4.108|
;;;1058           nb = quotefloat(L, buff, lua_tonumber(L, arg));
000050  2200              MOVS     r2,#0
000052  4641              MOV      r1,r8
000054  4648              MOV      r0,r9
000056  f7fffffe          BL       lua_tonumberx
00005a  4606              MOV      r6,r0
00005c  4632              MOV      r2,r6
00005e  460b              MOV      r3,r1
000060  4651              MOV      r1,r10
000062  4648              MOV      r0,r9
000064  f7fffffe          BL       quotefloat
000068  4605              MOV      r5,r0
00006a  e01b              B        |L4.164|
                  |L4.108|
;;;1059         else {  /* integers */
;;;1060           lua_Integer n = lua_tointeger(L, arg);
00006c  2200              MOVS     r2,#0
00006e  4641              MOV      r1,r8
000070  4648              MOV      r0,r9
000072  f7fffffe          BL       lua_tointegerx
000076  4606              MOV      r6,r0
000078  460f              MOV      r7,r1
;;;1061           const char *format = (n == LUA_MININTEGER)  /* corner case? */
00007a  f04f4200          MOV      r2,#0x80000000
00007e  ea870102          EOR      r1,r7,r2
000082  ea560001          ORRS     r0,r6,r1
000086  d101              BNE      |L4.140|
;;;1062                              ? "0x%" LUA_INTEGER_FRMLEN "x"  /* use hex */
000088  a012              ADR      r0,|L4.212|
00008a  e000              B        |L4.142|
                  |L4.140|
;;;1063                              : LUA_INTEGER_FMT;  /* else use default format */
00008c  a013              ADR      r0,|L4.220|
                  |L4.142|
00008e  4683              MOV      r11,r0
;;;1064           nb = l_sprintf(buff, MAX_ITEM, format, (LUAI_UACINT)n);
000090  465a              MOV      r2,r11
000092  f44f71d6          MOV      r1,#0x1ac
000096  4650              MOV      r0,r10
000098  e9cd6700          STRD     r6,r7,[sp,#0]
00009c  f7fffffe          BL       __2snprintf
0000a0  4605              MOV      r5,r0
;;;1065         }
0000a2  bf00              NOP      
                  |L4.164|
;;;1066         luaL_addsize(b, nb);
0000a4  68a0              LDR      r0,[r4,#8]
0000a6  4428              ADD      r0,r0,r5
0000a8  60a0              STR      r0,[r4,#8]
;;;1067         break;
0000aa  e00f              B        |L4.204|
                  |L4.172|
;;;1068       }
;;;1069       case LUA_TNIL: case LUA_TBOOLEAN: {
0000ac  bf00              NOP      
                  |L4.174|
;;;1070         luaL_tolstring(L, arg, NULL);
0000ae  2200              MOVS     r2,#0
0000b0  4641              MOV      r1,r8
0000b2  4648              MOV      r0,r9
0000b4  f7fffffe          BL       luaL_tolstring
;;;1071         luaL_addvalue(b);
0000b8  4620              MOV      r0,r4
0000ba  f7fffffe          BL       luaL_addvalue
;;;1072         break;
0000be  e005              B        |L4.204|
                  |L4.192|
;;;1073       }
;;;1074       default: {
;;;1075         luaL_argerror(L, arg, "value has no literal form");
0000c0  a208              ADR      r2,|L4.228|
0000c2  4641              MOV      r1,r8
0000c4  4648              MOV      r0,r9
0000c6  f7fffffe          BL       luaL_argerror
0000ca  bf00              NOP                            ;1047
                  |L4.204|
0000cc  bf00              NOP                            ;1052
;;;1076       }
;;;1077     }
;;;1078   }
0000ce  e8bd9ffc          POP      {r2-r12,pc}
;;;1079   
                          ENDP

0000d2  0000              DCW      0x0000
                  |L4.212|
0000d4  3078256c          DCB      "0x%llx",0
0000d8  6c7800  
0000db  00                DCB      0
                  |L4.220|
0000dc  256c6c64          DCB      "%lld",0
0000e0  00      
0000e1  00                DCB      0
0000e2  00                DCB      0
0000e3  00                DCB      0
                  |L4.228|
0000e4  76616c75          DCB      "value has no literal form",0
0000e8  65206861
0000ec  73206e6f
0000f0  206c6974
0000f4  6572616c
0000f8  20666f72
0000fc  6d00    
0000fe  00                DCB      0
0000ff  00                DCB      0

                          AREA ||i.addquoted||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                  addquoted PROC
;;;992    
;;;993    static void addquoted (luaL_Buffer *b, const char *s, size_t len) {
000000  b5fe              PUSH     {r1-r7,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;994      luaL_addchar(b, '"');
000008  e9d41001          LDRD     r1,r0,[r4,#4]
00000c  4288              CMP      r0,r1
00000e  d303              BCC      |L5.24|
000010  2101              MOVS     r1,#1
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       luaL_prepbuffsize
                  |L5.24|
000018  2122              MOVS     r1,#0x22
00001a  68a2              LDR      r2,[r4,#8]
00001c  1c50              ADDS     r0,r2,#1
00001e  60a0              STR      r0,[r4,#8]
000020  6820              LDR      r0,[r4,#0]
000022  5481              STRB     r1,[r0,r2]
;;;995      while (len--) {
000024  e055              B        |L5.210|
                  |L5.38|
;;;996        if (*s == '"' || *s == '\\' || *s == '\n') {
000026  7828              LDRB     r0,[r5,#0]
000028  2822              CMP      r0,#0x22
00002a  d005              BEQ      |L5.56|
00002c  7828              LDRB     r0,[r5,#0]
00002e  285c              CMP      r0,#0x5c
000030  d002              BEQ      |L5.56|
000032  7828              LDRB     r0,[r5,#0]
000034  280a              CMP      r0,#0xa
000036  d11c              BNE      |L5.114|
                  |L5.56|
;;;997          luaL_addchar(b, '\\');
000038  e9d41001          LDRD     r1,r0,[r4,#4]
00003c  4288              CMP      r0,r1
00003e  d303              BCC      |L5.72|
000040  2101              MOVS     r1,#1
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       luaL_prepbuffsize
                  |L5.72|
000048  215c              MOVS     r1,#0x5c
00004a  68a2              LDR      r2,[r4,#8]
00004c  1c50              ADDS     r0,r2,#1
00004e  60a0              STR      r0,[r4,#8]
000050  6820              LDR      r0,[r4,#0]
000052  5481              STRB     r1,[r0,r2]
;;;998          luaL_addchar(b, *s);
000054  e9d41001          LDRD     r1,r0,[r4,#4]
000058  4288              CMP      r0,r1
00005a  d303              BCC      |L5.100|
00005c  2101              MOVS     r1,#1
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       luaL_prepbuffsize
                  |L5.100|
000064  7829              LDRB     r1,[r5,#0]
000066  68a2              LDR      r2,[r4,#8]
000068  1c50              ADDS     r0,r2,#1
00006a  60a0              STR      r0,[r4,#8]
00006c  6820              LDR      r0,[r4,#0]
00006e  5481              STRB     r1,[r0,r2]
000070  e02e              B        |L5.208|
                  |L5.114|
;;;999        }
;;;1000       else if (iscntrl(uchar(*s))) {
000072  f7fffffe          BL       __rt_ctype_table
000076  6800              LDR      r0,[r0,#0]
000078  7829              LDRB     r1,[r5,#0]
00007a  5c40              LDRB     r0,[r0,r1]
00007c  f0000040          AND      r0,r0,#0x40
000080  b1c0              CBZ      r0,|L5.180|
;;;1001         char buff[10];
;;;1002         if (!isdigit(uchar(*(s+1))))
000082  f7fffffe          BL       __rt_ctype_table
000086  6800              LDR      r0,[r0,#0]
000088  7869              LDRB     r1,[r5,#1]
00008a  5c40              LDRB     r0,[r0,r1]
00008c  2820              CMP      r0,#0x20
00008e  d006              BEQ      |L5.158|
;;;1003           l_sprintf(buff, sizeof(buff), "\\%d", (int)uchar(*s));
000090  782b              LDRB     r3,[r5,#0]
000092  a219              ADR      r2,|L5.248|
000094  210a              MOVS     r1,#0xa
000096  4668              MOV      r0,sp
000098  f7fffffe          BL       __2snprintf
00009c  e005              B        |L5.170|
                  |L5.158|
;;;1004         else
;;;1005           l_sprintf(buff, sizeof(buff), "\\%03d", (int)uchar(*s));
00009e  782b              LDRB     r3,[r5,#0]
0000a0  a216              ADR      r2,|L5.252|
0000a2  210a              MOVS     r1,#0xa
0000a4  4668              MOV      r0,sp
0000a6  f7fffffe          BL       __2snprintf
                  |L5.170|
;;;1006         luaL_addstring(b, buff);
0000aa  4669              MOV      r1,sp
0000ac  4620              MOV      r0,r4
0000ae  f7fffffe          BL       luaL_addstring
;;;1007       }
0000b2  e00d              B        |L5.208|
                  |L5.180|
;;;1008       else
;;;1009         luaL_addchar(b, *s);
0000b4  e9d41001          LDRD     r1,r0,[r4,#4]
0000b8  4288              CMP      r0,r1
0000ba  d303              BCC      |L5.196|
0000bc  2101              MOVS     r1,#1
0000be  4620              MOV      r0,r4
0000c0  f7fffffe          BL       luaL_prepbuffsize
                  |L5.196|
0000c4  7829              LDRB     r1,[r5,#0]
0000c6  68a2              LDR      r2,[r4,#8]
0000c8  1c50              ADDS     r0,r2,#1
0000ca  60a0              STR      r0,[r4,#8]
0000cc  6820              LDR      r0,[r4,#0]
0000ce  5481              STRB     r1,[r0,r2]
                  |L5.208|
;;;1010       s++;
0000d0  1c6d              ADDS     r5,r5,#1
                  |L5.210|
0000d2  1e30              SUBS     r0,r6,#0              ;995
0000d4  f1a60601          SUB      r6,r6,#1              ;995
0000d8  d1a5              BNE      |L5.38|
;;;1011     }
;;;1012     luaL_addchar(b, '"');
0000da  e9d41001          LDRD     r1,r0,[r4,#4]
0000de  4288              CMP      r0,r1
0000e0  d303              BCC      |L5.234|
0000e2  2101              MOVS     r1,#1
0000e4  4620              MOV      r0,r4
0000e6  f7fffffe          BL       luaL_prepbuffsize
                  |L5.234|
0000ea  2122              MOVS     r1,#0x22
0000ec  68a2              LDR      r2,[r4,#8]
0000ee  1c50              ADDS     r0,r2,#1
0000f0  60a0              STR      r0,[r4,#8]
0000f2  6820              LDR      r0,[r4,#0]
0000f4  5481              STRB     r1,[r0,r2]
;;;1013   }
0000f6  bdfe              POP      {r1-r7,pc}
;;;1014   
                          ENDP

                  |L5.248|
0000f8  5c256400          DCB      "\\%d",0
                  |L5.252|
0000fc  5c253033          DCB      "\\%03d",0
000100  6400    
000102  00                DCB      0
000103  00                DCB      0

                          AREA ||i.arith||, CODE, READONLY, ALIGN=1

                  arith PROC
;;;232    
;;;233    static int arith (lua_State *L, int op, const char *mtname) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;234      if (tonum(L, 1) && tonum(L, 2))
000008  2101              MOVS     r1,#1
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       tonum
000010  b148              CBZ      r0,|L6.38|
000012  2102              MOVS     r1,#2
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       tonum
00001a  b120              CBZ      r0,|L6.38|
;;;235        lua_arith(L, op);  /* result will be on the top */
00001c  4631              MOV      r1,r6
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       lua_arith
000024  e003              B        |L6.46|
                  |L6.38|
;;;236      else
;;;237        trymt(L, mtname);
000026  4621              MOV      r1,r4
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       trymt
                  |L6.46|
;;;238      return 1;
00002e  2001              MOVS     r0,#1
;;;239    }
000030  bd70              POP      {r4-r6,pc}
;;;240    
                          ENDP


                          AREA ||i.arith_add||, CODE, READONLY, ALIGN=2

                  arith_add PROC
;;;241    
;;;242    static int arith_add (lua_State *L) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;243      return arith(L, LUA_OPADD, "__add");
000004  a202              ADR      r2,|L7.16|
000006  2100              MOVS     r1,#0
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       arith
;;;244    }
00000e  bd10              POP      {r4,pc}
;;;245    
                          ENDP

                  |L7.16|
000010  5f5f6164          DCB      "__add",0
000014  6400    
000016  00                DCB      0
000017  00                DCB      0

                          AREA ||i.arith_div||, CODE, READONLY, ALIGN=2

                  arith_div PROC
;;;261    
;;;262    static int arith_div (lua_State *L) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;263      return arith(L, LUA_OPDIV, "__div");
000004  a202              ADR      r2,|L8.16|
000006  2105              MOVS     r1,#5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       arith
;;;264    }
00000e  bd10              POP      {r4,pc}
;;;265    
                          ENDP

                  |L8.16|
000010  5f5f6469          DCB      "__div",0
000014  7600    
000016  00                DCB      0
000017  00                DCB      0

                          AREA ||i.arith_idiv||, CODE, READONLY, ALIGN=2

                  arith_idiv PROC
;;;265    
;;;266    static int arith_idiv (lua_State *L) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;267      return arith(L, LUA_OPIDIV, "__idiv");
000004  a202              ADR      r2,|L9.16|
000006  2106              MOVS     r1,#6
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       arith
;;;268    }
00000e  bd10              POP      {r4,pc}
;;;269    
                          ENDP

                  |L9.16|
000010  5f5f6964          DCB      "__idiv",0
000014  697600  
000017  00                DCB      0

                          AREA ||i.arith_mod||, CODE, READONLY, ALIGN=2

                  arith_mod PROC
;;;253    
;;;254    static int arith_mod (lua_State *L) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;255      return arith(L, LUA_OPMOD, "__mod");
000004  a202              ADR      r2,|L10.16|
000006  2103              MOVS     r1,#3
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       arith
;;;256    }
00000e  bd10              POP      {r4,pc}
;;;257    
                          ENDP

                  |L10.16|
000010  5f5f6d6f          DCB      "__mod",0
000014  6400    
000016  00                DCB      0
000017  00                DCB      0

                          AREA ||i.arith_mul||, CODE, READONLY, ALIGN=2

                  arith_mul PROC
;;;249    
;;;250    static int arith_mul (lua_State *L) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;251      return arith(L, LUA_OPMUL, "__mul");
000004  a202              ADR      r2,|L11.16|
000006  2102              MOVS     r1,#2
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       arith
;;;252    }
00000e  bd10              POP      {r4,pc}
;;;253    
                          ENDP

                  |L11.16|
000010  5f5f6d75          DCB      "__mul",0
000014  6c00    
000016  00                DCB      0
000017  00                DCB      0

                          AREA ||i.arith_pow||, CODE, READONLY, ALIGN=2

                  arith_pow PROC
;;;257    
;;;258    static int arith_pow (lua_State *L) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;259      return arith(L, LUA_OPPOW, "__pow");
000004  a202              ADR      r2,|L12.16|
000006  2104              MOVS     r1,#4
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       arith
;;;260    }
00000e  bd10              POP      {r4,pc}
;;;261    
                          ENDP

                  |L12.16|
000010  5f5f706f          DCB      "__pow",0
000014  7700    
000016  00                DCB      0
000017  00                DCB      0

                          AREA ||i.arith_sub||, CODE, READONLY, ALIGN=2

                  arith_sub PROC
;;;245    
;;;246    static int arith_sub (lua_State *L) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;247      return arith(L, LUA_OPSUB, "__sub");
000004  a202              ADR      r2,|L13.16|
000006  2101              MOVS     r1,#1
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       arith
;;;248    }
00000e  bd10              POP      {r4,pc}
;;;249    
                          ENDP

                  |L13.16|
000010  5f5f7375          DCB      "__sub",0
000014  6200    
000016  00                DCB      0
000017  00                DCB      0

                          AREA ||i.arith_unm||, CODE, READONLY, ALIGN=2

                  arith_unm PROC
;;;269    
;;;270    static int arith_unm (lua_State *L) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;271      return arith(L, LUA_OPUNM, "__unm");
000004  a202              ADR      r2,|L14.16|
000006  210c              MOVS     r1,#0xc
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       arith
;;;272    }
00000e  bd10              POP      {r4,pc}
;;;273    
                          ENDP

                  |L14.16|
000010  5f5f756e          DCB      "__unm",0
000014  6d00    
000016  00                DCB      0
000017  00                DCB      0

                          AREA ||i.capture_to_close||, CODE, READONLY, ALIGN=2

                  capture_to_close PROC
;;;336    
;;;337    static int capture_to_close (MatchState *ms) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;338      int level = ms->level;
000004  7d2c              LDRB     r4,[r5,#0x14]
;;;339      for (level--; level>=0; level--)
000006  1e64              SUBS     r4,r4,#1
000008  e009              B        |L15.30|
                  |L15.10|
;;;340        if (ms->capture[level].len == CAP_UNFINISHED) return level;
00000a  f1050018          ADD      r0,r5,#0x18
00000e  eb0000c4          ADD      r0,r0,r4,LSL #3
000012  6840              LDR      r0,[r0,#4]
000014  1c40              ADDS     r0,r0,#1
000016  b908              CBNZ     r0,|L15.28|
000018  4620              MOV      r0,r4
                  |L15.26|
;;;341      return luaL_error(ms->L, "invalid pattern capture");
;;;342    }
00001a  bd70              POP      {r4-r6,pc}
                  |L15.28|
00001c  1e64              SUBS     r4,r4,#1              ;339
                  |L15.30|
00001e  2c00              CMP      r4,#0                 ;339
000020  daf3              BGE      |L15.10|
000022  a102              ADR      r1,|L15.44|
000024  68e8              LDR      r0,[r5,#0xc]          ;341
000026  f7fffffe          BL       luaL_error
00002a  e7f6              B        |L15.26|
;;;343    
                          ENDP

                  |L15.44|
00002c  696e7661          DCB      "invalid pattern capture",0
000030  6c696420
000034  70617474
000038  65726e20
00003c  63617074
000040  75726500

                          AREA ||i.check_capture||, CODE, READONLY, ALIGN=2

                  check_capture PROC
;;;328    
;;;329    static int check_capture (MatchState *ms, int l) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;330      l -= '1';
000006  3c31              SUBS     r4,r4,#0x31
;;;331      if (l < 0 || l >= ms->level || ms->capture[l].len == CAP_UNFINISHED)
000008  2c00              CMP      r4,#0
00000a  db09              BLT      |L16.32|
00000c  7d28              LDRB     r0,[r5,#0x14]
00000e  42a0              CMP      r0,r4
000010  dd06              BLE      |L16.32|
000012  f1050018          ADD      r0,r5,#0x18
000016  eb0000c4          ADD      r0,r0,r4,LSL #3
00001a  6840              LDR      r0,[r0,#4]
00001c  1c40              ADDS     r0,r0,#1
00001e  b928              CBNZ     r0,|L16.44|
                  |L16.32|
;;;332        return luaL_error(ms->L, "invalid capture index %%%d", l + 1);
000020  1c62              ADDS     r2,r4,#1
000022  a103              ADR      r1,|L16.48|
000024  68e8              LDR      r0,[r5,#0xc]
000026  f7fffffe          BL       luaL_error
                  |L16.42|
;;;333      return l;
;;;334    }
00002a  bd70              POP      {r4-r6,pc}
                  |L16.44|
00002c  4620              MOV      r0,r4                 ;333
00002e  e7fc              B        |L16.42|
;;;335    
                          ENDP

                  |L16.48|
000030  696e7661          DCB      "invalid capture index %%%d",0
000034  6c696420
000038  63617074
00003c  75726520
000040  696e6465
000044  78202525
000048  256400  
00004b  00                DCB      0

                          AREA ||i.classend||, CODE, READONLY, ALIGN=2

                  classend PROC
;;;344    
;;;345    static const char *classend (MatchState *ms, const char *p) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;346      switch (*p++) {
000006  f9141b01          LDRSB    r1,[r4],#1
00000a  2925              CMP      r1,#0x25
00000c  d002              BEQ      |L17.20|
00000e  295b              CMP      r1,#0x5b
000010  d122              BNE      |L17.88|
000012  e008              B        |L17.38|
                  |L17.20|
;;;347        case L_ESC: {
;;;348          if (p == ms->p_end)
000014  68a8              LDR      r0,[r5,#8]
000016  42a0              CMP      r0,r4
000018  d103              BNE      |L17.34|
;;;349            luaL_error(ms->L, "malformed pattern (ends with '%%')");
00001a  a110              ADR      r1,|L17.92|
00001c  68e8              LDR      r0,[r5,#0xc]
00001e  f7fffffe          BL       luaL_error
                  |L17.34|
;;;350          return p+1;
000022  1c60              ADDS     r0,r4,#1
                  |L17.36|
;;;351        }
;;;352        case '[': {
;;;353          if (*p == '^') p++;
;;;354          do {  /* look for a ']' */
;;;355            if (p == ms->p_end)
;;;356              luaL_error(ms->L, "malformed pattern (missing ']')");
;;;357            if (*(p++) == L_ESC && p < ms->p_end)
;;;358              p++;  /* skip escapes (e.g. '%]') */
;;;359          } while (*p != ']');
;;;360          return p+1;
;;;361        }
;;;362        default: {
;;;363          return p;
;;;364        }
;;;365      }
;;;366    }
000024  bd70              POP      {r4-r6,pc}
                  |L17.38|
000026  7820              LDRB     r0,[r4,#0]            ;353
000028  285e              CMP      r0,#0x5e              ;353
00002a  d100              BNE      |L17.46|
00002c  1c64              ADDS     r4,r4,#1              ;353
                  |L17.46|
00002e  bf00              NOP                            ;354
                  |L17.48|
000030  68a8              LDR      r0,[r5,#8]            ;355
000032  42a0              CMP      r0,r4                 ;355
000034  d103              BNE      |L17.62|
000036  a112              ADR      r1,|L17.128|
000038  68e8              LDR      r0,[r5,#0xc]          ;356
00003a  f7fffffe          BL       luaL_error
                  |L17.62|
00003e  f8141b01          LDRB     r1,[r4],#1            ;357
000042  2925              CMP      r1,#0x25              ;357
000044  d103              BNE      |L17.78|
000046  68a8              LDR      r0,[r5,#8]            ;357
000048  42a0              CMP      r0,r4                 ;357
00004a  d900              BLS      |L17.78|
00004c  1c64              ADDS     r4,r4,#1              ;358
                  |L17.78|
00004e  7820              LDRB     r0,[r4,#0]            ;359
000050  285d              CMP      r0,#0x5d              ;359
000052  d1ed              BNE      |L17.48|
000054  1c60              ADDS     r0,r4,#1              ;360
000056  e7e5              B        |L17.36|
                  |L17.88|
000058  4620              MOV      r0,r4                 ;363
00005a  e7e3              B        |L17.36|
;;;367    
                          ENDP

                  |L17.92|
00005c  6d616c66          DCB      "malformed pattern (ends with '%%')",0
000060  6f726d65
000064  64207061
000068  74746572
00006c  6e202865
000070  6e647320
000074  77697468
000078  20272525
00007c  272900  
00007f  00                DCB      0
                  |L17.128|
000080  6d616c66          DCB      "malformed pattern (missing ']')",0
000084  6f726d65
000088  64207061
00008c  74746572
000090  6e20286d
000094  69737369
000098  6e672027
00009c  5d272900

                          AREA ||i.copywithendian||, CODE, READONLY, ALIGN=2

                  copywithendian PROC
;;;1415   */
;;;1416   static void copywithendian (volatile char *dest, volatile const char *src,
000000  b530              PUSH     {r4,r5,lr}
;;;1417                               int size, int islittle) {
;;;1418     if (islittle == nativeendian.little) {
000002  4c0d              LDR      r4,|L18.56|
000004  f9944000          LDRSB    r4,[r4,#0]  ; nativeendian
000008  429c              CMP      r4,r3
00000a  d109              BNE      |L18.32|
;;;1419       while (size-- != 0)
00000c  e003              B        |L18.22|
                  |L18.14|
;;;1420         *(dest++) = *(src++);
00000e  f8114b01          LDRB     r4,[r1],#1
000012  f8004b01          STRB     r4,[r0],#1
                  |L18.22|
000016  1e14              SUBS     r4,r2,#0              ;1419
000018  f1a20201          SUB      r2,r2,#1              ;1419
00001c  d1f7              BNE      |L18.14|
00001e  e00a              B        |L18.54|
                  |L18.32|
;;;1421     }
;;;1422     else {
;;;1423       dest += size - 1;
000020  1e54              SUBS     r4,r2,#1
000022  4420              ADD      r0,r0,r4
;;;1424       while (size-- != 0)
000024  e003              B        |L18.46|
                  |L18.38|
;;;1425         *(dest--) = *(src++);
000026  f8114b01          LDRB     r4,[r1],#1
00002a  f8004901          STRB     r4,[r0],#-1
                  |L18.46|
00002e  1e14              SUBS     r4,r2,#0              ;1424
000030  f1a20201          SUB      r2,r2,#1              ;1424
000034  d1f7              BNE      |L18.38|
                  |L18.54|
;;;1426     }
;;;1427   }
000036  bd30              POP      {r4,r5,pc}
;;;1428   
                          ENDP

                  |L18.56|
                          DCD      nativeendian

                          AREA ||i.createmetatable||, CODE, READONLY, ALIGN=2

                  createmetatable PROC
;;;1663   
;;;1664   static void createmetatable (lua_State *L) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;1665     /* table to be metatable for strings */
;;;1666     luaL_newlibtable(L, stringmetamethods);
000004  2209              MOVS     r2,#9
000006  2100              MOVS     r1,#0
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       lua_createtable
;;;1667     luaL_setfuncs(L, stringmetamethods, 0);
00000e  2200              MOVS     r2,#0
000010  4913              LDR      r1,|L19.96|
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       luaL_setfuncs
;;;1668     lua_pushliteral(L, "");  /* dummy string */
000018  a112              ADR      r1,|L19.100|
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       lua_pushstring
;;;1669     lua_pushvalue(L, -2);  /* copy table */
000020  f06f0101          MVN      r1,#1
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       lua_pushvalue
;;;1670     lua_setmetatable(L, -2);  /* set table as metatable for strings */
00002a  f06f0101          MVN      r1,#1
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       lua_setmetatable
;;;1671     lua_pop(L, 1);  /* pop dummy string */
000034  f06f0101          MVN      r1,#1
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       lua_settop
;;;1672     lua_pushvalue(L, -2);  /* get string library */
00003e  f06f0101          MVN      r1,#1
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       lua_pushvalue
;;;1673     lua_setfield(L, -2, "__index");  /* metatable.__index = string */
000048  a207              ADR      r2,|L19.104|
00004a  f06f0101          MVN      r1,#1
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       lua_setfield
;;;1674     lua_pop(L, 1);  /* pop metatable */
000054  f06f0101          MVN      r1,#1
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       lua_settop
;;;1675   }
00005e  bd10              POP      {r4,pc}
;;;1676   
                          ENDP

                  |L19.96|
                          DCD      stringmetamethods
                  |L19.100|
000064  00                DCB      0
000065  00                DCB      0
000066  00                DCB      0
000067  00                DCB      0
                  |L19.104|
000068  5f5f696e          DCB      "__index",0
00006c  64657800

                          AREA ||i.digit||, CODE, READONLY, ALIGN=1

                  digit PROC
;;;1279   */
;;;1280   static int digit (int c) { return '0' <= c && c <= '9'; }
000000  4601              MOV      r1,r0
000002  2930              CMP      r1,#0x30
000004  db03              BLT      |L20.14|
000006  2939              CMP      r1,#0x39
000008  dc01              BGT      |L20.14|
00000a  2001              MOVS     r0,#1
                  |L20.12|
00000c  4770              BX       lr
                  |L20.14|
00000e  2000              MOVS     r0,#0
000010  e7fc              B        |L20.12|
;;;1281   
                          ENDP


                          AREA ||i.end_capture||, CODE, READONLY, ALIGN=1

                  end_capture PROC
;;;489    
;;;490    static const char *end_capture (MatchState *ms, const char *s,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;491                                      const char *p) {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;492      int l = capture_to_close(ms);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       capture_to_close
000010  4605              MOV      r5,r0
;;;493      const char *res;
;;;494      ms->capture[l].len = s - ms->capture[l].init;  /* close capture */
000012  f1040018          ADD      r0,r4,#0x18
000016  f8500035          LDR      r0,[r0,r5,LSL #3]
00001a  1a31              SUBS     r1,r6,r0
00001c  f1040018          ADD      r0,r4,#0x18
000020  eb0000c5          ADD      r0,r0,r5,LSL #3
000024  6041              STR      r1,[r0,#4]
;;;495      if ((res = match(ms, s, p)) == NULL)  /* match failed? */
000026  463a              MOV      r2,r7
000028  4631              MOV      r1,r6
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       match
000030  f1b00800          SUBS     r8,r0,#0
000034  d105              BNE      |L21.66|
;;;496        ms->capture[l].len = CAP_UNFINISHED;  /* undo capture */
000036  1e41              SUBS     r1,r0,#1
000038  f1040018          ADD      r0,r4,#0x18
00003c  eb0000c5          ADD      r0,r0,r5,LSL #3
000040  6041              STR      r1,[r0,#4]
                  |L21.66|
;;;497      return res;
000042  4640              MOV      r0,r8
;;;498    }
000044  e8bd81f0          POP      {r4-r8,pc}
;;;499    
                          ENDP


                          AREA ||i.getdetails||, CODE, READONLY, ALIGN=2

                  getdetails PROC
;;;1367   */
;;;1368   static KOption getdetails (Header *h, size_t totalsize,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1369                              const char **fmt, int *psize, int *ntoalign) {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
00000c  f8dd9020          LDR      r9,[sp,#0x20]
;;;1370     KOption opt = getoption(h, fmt, psize);
000010  4632              MOV      r2,r6
000012  4629              MOV      r1,r5
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       getoption
00001a  4607              MOV      r7,r0
;;;1371     int align = *psize;  /* usually, alignment follows size */
00001c  6830              LDR      r0,[r6,#0]
00001e  9000              STR      r0,[sp,#0]
;;;1372     if (opt == Kpaddalign) {  /* 'X' gets alignment from following option */
000020  2f07              CMP      r7,#7
000022  d110              BNE      |L22.70|
;;;1373       if (**fmt == '\0' || getoption(h, fmt, &align) == Kchar || align == 0)
000024  6828              LDR      r0,[r5,#0]
000026  7800              LDRB     r0,[r0,#0]
000028  b140              CBZ      r0,|L22.60|
00002a  466a              MOV      r2,sp
00002c  4629              MOV      r1,r5
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       getoption
000034  2803              CMP      r0,#3
000036  d001              BEQ      |L22.60|
000038  9800              LDR      r0,[sp,#0]
00003a  b920              CBNZ     r0,|L22.70|
                  |L22.60|
;;;1374         luaL_argerror(h->L, 1, "invalid next option for option 'X'");
00003c  a215              ADR      r2,|L22.148|
00003e  2101              MOVS     r1,#1
000040  6820              LDR      r0,[r4,#0]
000042  f7fffffe          BL       luaL_argerror
                  |L22.70|
;;;1375     }
;;;1376     if (align <= 1 || opt == Kchar)  /* need no alignment? */
000046  9800              LDR      r0,[sp,#0]
000048  2801              CMP      r0,#1
00004a  dd01              BLE      |L22.80|
00004c  2f03              CMP      r7,#3
00004e  d103              BNE      |L22.88|
                  |L22.80|
;;;1377       *ntoalign = 0;
000050  2000              MOVS     r0,#0
000052  f8c90000          STR      r0,[r9,#0]
000056  e019              B        |L22.140|
                  |L22.88|
;;;1378     else {
;;;1379       if (align > h->maxalign)  /* enforce maximum alignment */
000058  68a0              LDR      r0,[r4,#8]
00005a  9900              LDR      r1,[sp,#0]
00005c  4288              CMP      r0,r1
00005e  da01              BGE      |L22.100|
;;;1380         align = h->maxalign;
000060  68a0              LDR      r0,[r4,#8]
000062  9000              STR      r0,[sp,#0]
                  |L22.100|
;;;1381       if ((align & (align - 1)) != 0)  /* is 'align' not a power of 2? */
000064  9800              LDR      r0,[sp,#0]
000066  1e40              SUBS     r0,r0,#1
000068  9900              LDR      r1,[sp,#0]
00006a  4008              ANDS     r0,r0,r1
00006c  b120              CBZ      r0,|L22.120|
;;;1382         luaL_argerror(h->L, 1, "format asks for alignment not power of 2");
00006e  a212              ADR      r2,|L22.184|
000070  2101              MOVS     r1,#1
000072  6820              LDR      r0,[r4,#0]
000074  f7fffffe          BL       luaL_argerror
                  |L22.120|
;;;1383       *ntoalign = (align - (int)(totalsize & (align - 1))) & (align - 1);
000078  9800              LDR      r0,[sp,#0]
00007a  1e40              SUBS     r0,r0,#1
00007c  ea000008          AND      r0,r0,r8
000080  9900              LDR      r1,[sp,#0]
000082  1a08              SUBS     r0,r1,r0
000084  1e49              SUBS     r1,r1,#1
000086  4008              ANDS     r0,r0,r1
000088  f8c90000          STR      r0,[r9,#0]
                  |L22.140|
;;;1384     }
;;;1385     return opt;
00008c  4638              MOV      r0,r7
;;;1386   }
00008e  e8bd83f8          POP      {r3-r9,pc}
;;;1387   
                          ENDP

000092  0000              DCW      0x0000
                  |L22.148|
000094  696e7661          DCB      "invalid next option for option 'X'",0
000098  6c696420
00009c  6e657874
0000a0  206f7074
0000a4  696f6e20
0000a8  666f7220
0000ac  6f707469
0000b0  6f6e2027
0000b4  582700  
0000b7  00                DCB      0
                  |L22.184|
0000b8  666f726d          DCB      "format asks for alignment not power of 2",0
0000bc  61742061
0000c0  736b7320
0000c4  666f7220
0000c8  616c6967
0000cc  6e6d656e
0000d0  74206e6f
0000d4  7420706f
0000d8  77657220
0000dc  6f662032
0000e0  00      
0000e1  00                DCB      0
0000e2  00                DCB      0
0000e3  00                DCB      0

                          AREA ||i.getnum||, CODE, READONLY, ALIGN=2

                  getnum PROC
;;;1281   
;;;1282   static int getnum (const char **fmt, int df) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;1283     if (!digit(**fmt))  /* no number? */
000006  6821              LDR      r1,[r4,#0]
000008  f9910000          LDRSB    r0,[r1,#0]
00000c  f7fffffe          BL       digit
000010  b908              CBNZ     r0,|L23.22|
;;;1284       return df;  /* return default value */
000012  4630              MOV      r0,r6
                  |L23.20|
;;;1285     else {
;;;1286       int a = 0;
;;;1287       do {
;;;1288         a = a*10 + (*((*fmt)++) - '0');
;;;1289       } while (digit(**fmt) && a <= ((int)MAXSIZE - 9)/10);
;;;1290       return a;
;;;1291     }
;;;1292   }
000014  bd70              POP      {r4-r6,pc}
                  |L23.22|
000016  2500              MOVS     r5,#0                 ;1286
000018  bf00              NOP                            ;1287
                  |L23.26|
00001a  6821              LDR      r1,[r4,#0]            ;1288
00001c  1c48              ADDS     r0,r1,#1              ;1288
00001e  6020              STR      r0,[r4,#0]            ;1288
000020  f9910000          LDRSB    r0,[r1,#0]            ;1288
000024  3830              SUBS     r0,r0,#0x30           ;1288
000026  eb050185          ADD      r1,r5,r5,LSL #2       ;1288
00002a  eb000541          ADD      r5,r0,r1,LSL #1       ;1288
00002e  6821              LDR      r1,[r4,#0]            ;1289
000030  f9910000          LDRSB    r0,[r1,#0]            ;1289
000034  f7fffffe          BL       digit
000038  b110              CBZ      r0,|L23.64|
00003a  4802              LDR      r0,|L23.68|
00003c  4285              CMP      r5,r0                 ;1289
00003e  ddec              BLE      |L23.26|
                  |L23.64|
000040  4628              MOV      r0,r5                 ;1290
000042  e7e7              B        |L23.20|
;;;1293   
                          ENDP

                  |L23.68|
                          DCD      0x0ccccccb

                          AREA ||i.getnumlimit||, CODE, READONLY, ALIGN=2

                  getnumlimit PROC
;;;1298   */
;;;1299   static int getnumlimit (Header *h, const char **fmt, int df) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;1300     int sz = getnum(fmt, df);
00000a  4639              MOV      r1,r7
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       getnum
000012  4604              MOV      r4,r0
;;;1301     if (sz > MAXINTSIZE || sz <= 0)
000014  2c10              CMP      r4,#0x10
000016  dc01              BGT      |L24.28|
000018  2c00              CMP      r4,#0
00001a  dc07              BGT      |L24.44|
                  |L24.28|
;;;1302       return luaL_error(h->L, "integral size (%d) out of limits [1,%d]",
00001c  2310              MOVS     r3,#0x10
00001e  4622              MOV      r2,r4
000020  a103              ADR      r1,|L24.48|
000022  6828              LDR      r0,[r5,#0]
000024  f7fffffe          BL       luaL_error
                  |L24.40|
;;;1303                               sz, MAXINTSIZE);
;;;1304     return sz;
;;;1305   }
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L24.44|
00002c  4620              MOV      r0,r4                 ;1304
00002e  e7fb              B        |L24.40|
;;;1306   
                          ENDP

                  |L24.48|
000030  696e7465          DCB      "integral size (%d) out of limits [1,%d]",0
000034  6772616c
000038  2073697a
00003c  65202825
000040  6429206f
000044  7574206f
000048  66206c69
00004c  6d697473
000050  205b312c
000054  25645d00

                          AREA ||i.getoption||, CODE, READONLY, ALIGN=2

                  getoption PROC
;;;1320   */
;;;1321   static KOption getoption (Header *h, const char **fmt, int *size) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;1322     int opt = *((*fmt)++);
00000a  6831              LDR      r1,[r6,#0]
00000c  1c48              ADDS     r0,r1,#1
00000e  6030              STR      r0,[r6,#0]
000010  f9917000          LDRSB    r7,[r1,#0]
;;;1323     *size = 0;  /* default */
000014  2000              MOVS     r0,#0
000016  6020              STR      r0,[r4,#0]
;;;1324     switch (opt) {
000018  4638              MOV      r0,r7
00001a  2f62              CMP      r7,#0x62
00001c  d039              BEQ      |L25.146|
00001e  dc1e              BGT      |L25.94|
000020  2848              CMP      r0,#0x48
000022  d042              BEQ      |L25.170|
000024  dc0e              BGT      |L25.68|
000026  283d              CMP      r0,#0x3d
000028  d073              BEQ      |L25.274|
00002a  dc06              BGT      |L25.58|
00002c  2820              CMP      r0,#0x20
00002e  d071              BEQ      |L25.276|
000030  2821              CMP      r0,#0x21
000032  d070              BEQ      |L25.278|
000034  283c              CMP      r0,#0x3c
                  |L25.54|
000036  d16f              BNE      |L25.280|
000038  e090              B        |L25.348|
                  |L25.58|
00003a  283e              CMP      r0,#0x3e
00003c  d06d              BEQ      |L25.282|
00003e  2842              CMP      r0,#0x42
000040  d1f9              BNE      |L25.54|
000042  e02b              B        |L25.156|
                  |L25.68|
000044  284c              CMP      r0,#0x4c
000046  d038              BEQ      |L25.186|
000048  dc04              BGT      |L25.84|
00004a  2849              CMP      r0,#0x49
00004c  d059              BEQ      |L25.258|
00004e  284a              CMP      r0,#0x4a
000050  d1f1              BNE      |L25.54|
000052  e03a              B        |L25.202|
                  |L25.84|
000054  2854              CMP      r0,#0x54
000056  d03c              BEQ      |L25.210|
000058  2858              CMP      r0,#0x58
00005a  d1ec              BNE      |L25.54|
00005c  e07b              B        |L25.342|
                  |L25.94|
00005e  286a              CMP      r0,#0x6a
000060  d02f              BEQ      |L25.194|
000062  dc09              BGT      |L25.120|
000064  f1a00063          SUB      r0,r0,#0x63
000068  2807              CMP      r0,#7
00006a  d255              BCS      |L25.280|
00006c  e8dff000          TBB      [pc,r0]
000070  5e398835          DCB      0x5e,0x39,0x88,0x35
000074  88194100          DCB      0x88,0x19,0x41,0x00
                  |L25.120|
000078  2873              CMP      r0,#0x73
00007a  d04f              BEQ      |L25.284|
00007c  dc04              BGT      |L25.136|
00007e  286c              CMP      r0,#0x6c
000080  d017              BEQ      |L25.178|
000082  286e              CMP      r0,#0x6e
000084  d17c              BNE      |L25.384|
000086  e030              B        |L25.234|
                  |L25.136|
000088  2878              CMP      r0,#0x78
00008a  d060              BEQ      |L25.334|
00008c  287a              CMP      r0,#0x7a
00008e  d177              BNE      |L25.384|
000090  e05b              B        |L25.330|
                  |L25.146|
;;;1325       case 'b': *size = sizeof(char); return Kint;
000092  2001              MOVS     r0,#1
000094  6020              STR      r0,[r4,#0]
000096  2000              MOVS     r0,#0
                  |L25.152|
;;;1326       case 'B': *size = sizeof(char); return Kuint;
;;;1327       case 'h': *size = sizeof(short); return Kint;
;;;1328       case 'H': *size = sizeof(short); return Kuint;
;;;1329       case 'l': *size = sizeof(long); return Kint;
;;;1330       case 'L': *size = sizeof(long); return Kuint;
;;;1331       case 'j': *size = sizeof(lua_Integer); return Kint;
;;;1332       case 'J': *size = sizeof(lua_Integer); return Kuint;
;;;1333       case 'T': *size = sizeof(size_t); return Kuint;
;;;1334       case 'f': *size = sizeof(float); return Kfloat;
;;;1335       case 'd': *size = sizeof(double); return Kfloat;
;;;1336       case 'n': *size = sizeof(lua_Number); return Kfloat;
;;;1337       case 'i': *size = getnumlimit(h, fmt, sizeof(int)); return Kint;
;;;1338       case 'I': *size = getnumlimit(h, fmt, sizeof(int)); return Kuint;
;;;1339       case 's': *size = getnumlimit(h, fmt, sizeof(size_t)); return Kstring;
;;;1340       case 'c':
;;;1341         *size = getnum(fmt, -1);
;;;1342         if (*size == -1)
;;;1343           luaL_error(h->L, "missing size for format option 'c'");
;;;1344         return Kchar;
;;;1345       case 'z': return Kzstr;
;;;1346       case 'x': *size = 1; return Kpadding;
;;;1347       case 'X': return Kpaddalign;
;;;1348       case ' ': break;
;;;1349       case '<': h->islittle = 1; break;
;;;1350       case '>': h->islittle = 0; break;
;;;1351       case '=': h->islittle = nativeendian.little; break;
;;;1352       case '!': h->maxalign = getnumlimit(h, fmt, MAXALIGN); break;
;;;1353       default: luaL_error(h->L, "invalid format option '%c'", opt);
;;;1354     }
;;;1355     return Knop;
;;;1356   }
000098  e8bd81f0          POP      {r4-r8,pc}
                  |L25.156|
00009c  2001              MOVS     r0,#1                 ;1326
00009e  6020              STR      r0,[r4,#0]            ;1326
0000a0  e7fa              B        |L25.152|
0000a2  2002              MOVS     r0,#2                 ;1327
0000a4  6020              STR      r0,[r4,#0]            ;1327
0000a6  2000              MOVS     r0,#0                 ;1327
0000a8  e7f6              B        |L25.152|
                  |L25.170|
0000aa  2002              MOVS     r0,#2                 ;1328
0000ac  6020              STR      r0,[r4,#0]            ;1328
0000ae  2001              MOVS     r0,#1                 ;1328
0000b0  e7f2              B        |L25.152|
                  |L25.178|
0000b2  2004              MOVS     r0,#4                 ;1329
0000b4  6020              STR      r0,[r4,#0]            ;1329
0000b6  2000              MOVS     r0,#0                 ;1329
0000b8  e7ee              B        |L25.152|
                  |L25.186|
0000ba  2004              MOVS     r0,#4                 ;1330
0000bc  6020              STR      r0,[r4,#0]            ;1330
0000be  2001              MOVS     r0,#1                 ;1330
0000c0  e7ea              B        |L25.152|
                  |L25.194|
0000c2  2008              MOVS     r0,#8                 ;1331
0000c4  6020              STR      r0,[r4,#0]            ;1331
0000c6  2000              MOVS     r0,#0                 ;1331
0000c8  e7e6              B        |L25.152|
                  |L25.202|
0000ca  2008              MOVS     r0,#8                 ;1332
0000cc  6020              STR      r0,[r4,#0]            ;1332
0000ce  2001              MOVS     r0,#1                 ;1332
0000d0  e7e2              B        |L25.152|
                  |L25.210|
0000d2  2004              MOVS     r0,#4                 ;1333
0000d4  6020              STR      r0,[r4,#0]            ;1333
0000d6  2001              MOVS     r0,#1                 ;1333
0000d8  e7de              B        |L25.152|
0000da  2004              MOVS     r0,#4                 ;1334
0000dc  6020              STR      r0,[r4,#0]            ;1334
0000de  2002              MOVS     r0,#2                 ;1334
0000e0  e7da              B        |L25.152|
0000e2  2008              MOVS     r0,#8                 ;1335
0000e4  6020              STR      r0,[r4,#0]            ;1335
0000e6  2002              MOVS     r0,#2                 ;1335
0000e8  e7d6              B        |L25.152|
                  |L25.234|
0000ea  2008              MOVS     r0,#8                 ;1336
0000ec  6020              STR      r0,[r4,#0]            ;1336
0000ee  2002              MOVS     r0,#2                 ;1336
0000f0  e7d2              B        |L25.152|
0000f2  2204              MOVS     r2,#4                 ;1337
0000f4  4631              MOV      r1,r6                 ;1337
0000f6  4628              MOV      r0,r5                 ;1337
0000f8  f7fffffe          BL       getnumlimit
0000fc  6020              STR      r0,[r4,#0]            ;1337
0000fe  2000              MOVS     r0,#0                 ;1337
000100  e7ca              B        |L25.152|
                  |L25.258|
000102  2204              MOVS     r2,#4                 ;1338
000104  4631              MOV      r1,r6                 ;1338
000106  4628              MOV      r0,r5                 ;1338
000108  f7fffffe          BL       getnumlimit
00010c  6020              STR      r0,[r4,#0]            ;1338
00010e  2001              MOVS     r0,#1                 ;1338
000110  e7c2              B        |L25.152|
                  |L25.274|
000112  e029              B        |L25.360|
                  |L25.276|
000114  e021              B        |L25.346|
                  |L25.278|
000116  e02c              B        |L25.370|
                  |L25.280|
000118  e032              B        |L25.384|
                  |L25.282|
00011a  e022              B        |L25.354|
                  |L25.284|
00011c  2204              MOVS     r2,#4                 ;1339
00011e  4631              MOV      r1,r6                 ;1339
000120  4628              MOV      r0,r5                 ;1339
000122  f7fffffe          BL       getnumlimit
000126  6020              STR      r0,[r4,#0]            ;1339
000128  2004              MOVS     r0,#4                 ;1339
00012a  e7b5              B        |L25.152|
00012c  f04f31ff          MOV      r1,#0xffffffff        ;1341
000130  4630              MOV      r0,r6                 ;1341
000132  f7fffffe          BL       getnum
000136  6020              STR      r0,[r4,#0]            ;1341
000138  6820              LDR      r0,[r4,#0]            ;1342
00013a  1c40              ADDS     r0,r0,#1              ;1342
00013c  b918              CBNZ     r0,|L25.326|
00013e  a115              ADR      r1,|L25.404|
000140  6828              LDR      r0,[r5,#0]            ;1343
000142  f7fffffe          BL       luaL_error
                  |L25.326|
000146  2003              MOVS     r0,#3                 ;1344
000148  e7a6              B        |L25.152|
                  |L25.330|
00014a  2005              MOVS     r0,#5                 ;1345
00014c  e7a4              B        |L25.152|
                  |L25.334|
00014e  2001              MOVS     r0,#1                 ;1346
000150  6020              STR      r0,[r4,#0]            ;1346
000152  2006              MOVS     r0,#6                 ;1346
000154  e7a0              B        |L25.152|
                  |L25.342|
000156  2007              MOVS     r0,#7                 ;1347
000158  e79e              B        |L25.152|
                  |L25.346|
00015a  e017              B        |L25.396|
                  |L25.348|
00015c  2001              MOVS     r0,#1                 ;1349
00015e  6068              STR      r0,[r5,#4]            ;1349
000160  e014              B        |L25.396|
                  |L25.354|
000162  2000              MOVS     r0,#0                 ;1350
000164  6068              STR      r0,[r5,#4]            ;1350
000166  e011              B        |L25.396|
                  |L25.360|
000168  4813              LDR      r0,|L25.440|
00016a  f9900000          LDRSB    r0,[r0,#0]            ;1351  ; nativeendian
00016e  6068              STR      r0,[r5,#4]            ;1351
000170  e00c              B        |L25.396|
                  |L25.370|
000172  2208              MOVS     r2,#8                 ;1352
000174  4631              MOV      r1,r6                 ;1352
000176  4628              MOV      r0,r5                 ;1352
000178  f7fffffe          BL       getnumlimit
00017c  60a8              STR      r0,[r5,#8]            ;1352
00017e  e005              B        |L25.396|
                  |L25.384|
000180  463a              MOV      r2,r7                 ;1353
000182  a10e              ADR      r1,|L25.444|
000184  6828              LDR      r0,[r5,#0]            ;1353
000186  f7fffffe          BL       luaL_error
00018a  bf00              NOP                            ;1324
                  |L25.396|
00018c  bf00              NOP                            ;1348
00018e  2008              MOVS     r0,#8                 ;1355
000190  e782              B        |L25.152|
;;;1357   
                          ENDP

000192  0000              DCW      0x0000
                  |L25.404|
000194  6d697373          DCB      "missing size for format option 'c'",0
000198  696e6720
00019c  73697a65
0001a0  20666f72
0001a4  20666f72
0001a8  6d617420
0001ac  6f707469
0001b0  6f6e2027
0001b4  632700  
0001b7  00                DCB      0
                  |L25.440|
                          DCD      nativeendian
                  |L25.444|
0001bc  696e7661          DCB      "invalid format option '%c'",0
0001c0  6c696420
0001c4  666f726d
0001c8  6174206f
0001cc  7074696f
0001d0  6e202725
0001d4  632700  
0001d7  00                DCB      0

                          AREA ||i.gmatch||, CODE, READONLY, ALIGN=2

                  gmatch PROC
;;;775    
;;;776    static int gmatch (lua_State *L) {
000000  e92d41ff          PUSH     {r0-r8,lr}
000004  4605              MOV      r5,r0
;;;777      size_t ls, lp;
;;;778      const char *s = luaL_checklstring(L, 1, &ls);
000006  aa03              ADD      r2,sp,#0xc
000008  2101              MOVS     r1,#1
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       luaL_checklstring
000010  4606              MOV      r6,r0
;;;779      const char *p = luaL_checklstring(L, 2, &lp);
000012  aa02              ADD      r2,sp,#8
000014  2102              MOVS     r1,#2
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       luaL_checklstring
00001c  4607              MOV      r7,r0
;;;780      GMatchState *gm;
;;;781      lua_settop(L, 2);  /* keep them on closure to avoid being collected */
00001e  2102              MOVS     r1,#2
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       lua_settop
;;;782      gm = (GMatchState *)lua_newuserdatauv(L, sizeof(GMatchState), 0);
000026  2200              MOVS     r2,#0
000028  f44f7192          MOV      r1,#0x124
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       lua_newuserdatauv
000032  4604              MOV      r4,r0
;;;783      prepstate(&gm->ms, L, s, ls, p, lp);
000034  9802              LDR      r0,[sp,#8]
000036  e9cd7000          STRD     r7,r0,[sp,#0]
00003a  4632              MOV      r2,r6
00003c  4629              MOV      r1,r5
00003e  f104000c          ADD      r0,r4,#0xc
000042  9b03              LDR      r3,[sp,#0xc]
000044  f7fffffe          BL       prepstate
;;;784      gm->src = s; gm->p = p; gm->lastmatch = NULL;
000048  6026              STR      r6,[r4,#0]
00004a  6067              STR      r7,[r4,#4]
00004c  2000              MOVS     r0,#0
00004e  60a0              STR      r0,[r4,#8]
;;;785      lua_pushcclosure(L, gmatch_aux, 3);
000050  2203              MOVS     r2,#3
000052  4904              LDR      r1,|L26.100|
000054  4628              MOV      r0,r5
000056  f7fffffe          BL       lua_pushcclosure
;;;786      return 1;
00005a  2001              MOVS     r0,#1
;;;787    }
00005c  b004              ADD      sp,sp,#0x10
00005e  e8bd81f0          POP      {r4-r8,pc}
;;;788    
                          ENDP

000062  0000              DCW      0x0000
                  |L26.100|
                          DCD      gmatch_aux

                          AREA ||i.gmatch_aux||, CODE, READONLY, ALIGN=2

                  gmatch_aux PROC
;;;759    
;;;760    static int gmatch_aux (lua_State *L) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4607              MOV      r7,r0
;;;761      GMatchState *gm = (GMatchState *)lua_touserdata(L, lua_upvalueindex(3));
000006  4913              LDR      r1,|L27.84|
000008  4638              MOV      r0,r7
00000a  f7fffffe          BL       lua_touserdata
00000e  4604              MOV      r4,r0
;;;762      const char *src;
;;;763      gm->ms.L = L;
000010  61a7              STR      r7,[r4,#0x18]
;;;764      for (src = gm->src; src <= gm->ms.src_end; src++) {
000012  6825              LDR      r5,[r4,#0]
000014  e019              B        |L27.74|
                  |L27.22|
;;;765        const char *e;
;;;766        reprepstate(&gm->ms);
000016  f104000c          ADD      r0,r4,#0xc
00001a  f7fffffe          BL       reprepstate
;;;767        if ((e = match(&gm->ms, src, gm->p)) != NULL && e != gm->lastmatch) {
00001e  4629              MOV      r1,r5
000020  f104000c          ADD      r0,r4,#0xc
000024  6862              LDR      r2,[r4,#4]
000026  f7fffffe          BL       match
00002a  1e06              SUBS     r6,r0,#0
00002c  d00c              BEQ      |L27.72|
00002e  68a0              LDR      r0,[r4,#8]
000030  42b0              CMP      r0,r6
000032  d009              BEQ      |L27.72|
;;;768          gm->src = gm->lastmatch = e;
000034  60a6              STR      r6,[r4,#8]
000036  6026              STR      r6,[r4,#0]
;;;769          return push_captures(&gm->ms, src, e);
000038  4632              MOV      r2,r6
00003a  4629              MOV      r1,r5
00003c  f104000c          ADD      r0,r4,#0xc
000040  f7fffffe          BL       push_captures
                  |L27.68|
;;;770        }
;;;771      }
;;;772      return 0;  /* not found */
;;;773    }
000044  e8bd81f0          POP      {r4-r8,pc}
                  |L27.72|
000048  1c6d              ADDS     r5,r5,#1              ;764
                  |L27.74|
00004a  6920              LDR      r0,[r4,#0x10]         ;764
00004c  42a8              CMP      r0,r5                 ;764
00004e  d2e2              BCS      |L27.22|
000050  2000              MOVS     r0,#0                 ;772
000052  e7f7              B        |L27.68|
;;;774    
                          ENDP

                  |L27.84|
                          DCD      0xfff0b9d5

                          AREA ||i.initheader||, CODE, READONLY, ALIGN=2

                  initheader PROC
;;;1310   */
;;;1311   static void initheader (lua_State *L, Header *h) {
000000  6008              STR      r0,[r1,#0]
;;;1312     h->L = L;
;;;1313     h->islittle = nativeendian.little;
000002  4a03              LDR      r2,|L28.16|
000004  f9922000          LDRSB    r2,[r2,#0]  ; nativeendian
000008  604a              STR      r2,[r1,#4]
;;;1314     h->maxalign = 1;
00000a  2201              MOVS     r2,#1
00000c  608a              STR      r2,[r1,#8]
;;;1315   }
00000e  4770              BX       lr
;;;1316   
                          ENDP

                  |L28.16|
                          DCD      nativeendian

                          AREA ||i.lmemfind||, CODE, READONLY, ALIGN=1

                  lmemfind PROC
;;;614    
;;;615    static const char *lmemfind (const char *s1, size_t l1,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;616                                   const char *s2, size_t l2) {
000004  4680              MOV      r8,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
;;;617      if (l2 == 0) return s1;  /* empty strings are everywhere */
00000c  b915              CBNZ     r5,|L29.20|
00000e  4640              MOV      r0,r8
                  |L29.16|
;;;618      else if (l2 > l1) return NULL;  /* avoids a negative 'l1' */
;;;619      else {
;;;620        const char *init;  /* to search for a '*s2' inside 's1' */
;;;621        l2--;  /* 1st char will be checked by 'memchr' */
;;;622        l1 = l1-l2;  /* 's2' cannot be found after that */
;;;623        while (l1 > 0 && (init = (const char *)memchr(s1, *s2, l1)) != NULL) {
;;;624          init++;   /* 1st char is already checked */
;;;625          if (memcmp(init, s2+1, l2) == 0)
;;;626            return init-1;
;;;627          else {  /* correct 'l1' and 's1' to try again */
;;;628            l1 -= init-s1;
;;;629            s1 = init;
;;;630          }
;;;631        }
;;;632        return NULL;  /* not found */
;;;633      }
;;;634    }
000010  e8bd81f0          POP      {r4-r8,pc}
                  |L29.20|
000014  42a5              CMP      r5,r4                 ;618
000016  d901              BLS      |L29.28|
000018  2000              MOVS     r0,#0                 ;618
00001a  e7f9              B        |L29.16|
                  |L29.28|
00001c  1e6d              SUBS     r5,r5,#1              ;621
00001e  1b64              SUBS     r4,r4,r5              ;622
000020  e00c              B        |L29.60|
                  |L29.34|
000022  1c76              ADDS     r6,r6,#1              ;624
000024  462a              MOV      r2,r5                 ;625
000026  1c79              ADDS     r1,r7,#1              ;625
000028  4630              MOV      r0,r6                 ;625
00002a  f7fffffe          BL       memcmp
00002e  b908              CBNZ     r0,|L29.52|
000030  1e70              SUBS     r0,r6,#1              ;626
000032  e7ed              B        |L29.16|
                  |L29.52|
000034  eba60008          SUB      r0,r6,r8              ;628
000038  1a24              SUBS     r4,r4,r0              ;628
00003a  46b0              MOV      r8,r6                 ;629
                  |L29.60|
00003c  b13c              CBZ      r4,|L29.78|
00003e  f9971000          LDRSB    r1,[r7,#0]            ;623
000042  4622              MOV      r2,r4                 ;623
000044  4640              MOV      r0,r8                 ;623
000046  f7fffffe          BL       memchr
00004a  1e06              SUBS     r6,r0,#0              ;623
00004c  d1e9              BNE      |L29.34|
                  |L29.78|
00004e  2000              MOVS     r0,#0                 ;632
000050  e7de              B        |L29.16|
;;;635    
                          ENDP


                          AREA ||i.luaopen_string||, CODE, READONLY, ALIGN=2

                  luaopen_string PROC
;;;1680   */
;;;1681   LUAMOD_API int luaopen_string (lua_State *L) {
000000  b538              PUSH     {r3-r5,lr}
000002  4604              MOV      r4,r0
;;;1682     luaL_newlib(L, strlib);
000004  2088              MOVS     r0,#0x88
000006  2200              MOVS     r2,#0
000008  4b09              LDR      r3,|L30.48|
00000a  9000              STR      r0,[sp,#0]
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       luaL_checkversion_
000012  2211              MOVS     r2,#0x11
000014  2100              MOVS     r1,#0
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       lua_createtable
00001c  2200              MOVS     r2,#0
00001e  4905              LDR      r1,|L30.52|
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       luaL_setfuncs
;;;1683     createmetatable(L);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       createmetatable
;;;1684     return 1;
00002c  2001              MOVS     r0,#1
;;;1685   }
00002e  bd38              POP      {r3-r5,pc}
;;;1686   
                          ENDP

                  |L30.48|
                          DCD      0x407f8000
                  |L30.52|
                          DCD      strlib

                          AREA ||i.match||, CODE, READONLY, ALIGN=2

                  match PROC
;;;511    
;;;512    static const char *match (MatchState *ms, const char *s, const char *p) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;513      if (ms->matchdepth-- == 0)
00000a  6929              LDR      r1,[r5,#0x10]
00000c  1e48              SUBS     r0,r1,#1
00000e  6128              STR      r0,[r5,#0x10]
000010  b919              CBNZ     r1,|L31.26|
;;;514        luaL_error(ms->L, "pattern too complex");
000012  a177              ADR      r1,|L31.496|
000014  68e8              LDR      r0,[r5,#0xc]
000016  f7fffffe          BL       luaL_error
                  |L31.26|
;;;515      init: /* using goto's to optimize tail recursion */
00001a  bf00              NOP      
                  |L31.28|
;;;516      if (p != ms->p_end) {  /* end of pattern? */
00001c  68a8              LDR      r0,[r5,#8]
00001e  42a0              CMP      r0,r4
000020  d07c              BEQ      |L31.284|
;;;517        switch (*p) {
000022  f9940000          LDRSB    r0,[r4,#0]
000026  2824              CMP      r0,#0x24
000028  d022              BEQ      |L31.112|
00002a  2825              CMP      r0,#0x25
00002c  d02d              BEQ      |L31.138|
00002e  2828              CMP      r0,#0x28
000030  d002              BEQ      |L31.56|
000032  2829              CMP      r0,#0x29
000034  d173              BNE      |L31.286|
000036  e014              B        |L31.98|
                  |L31.56|
;;;518          case '(': {  /* start capture */
;;;519            if (*(p + 1) == ')')  /* position capture? */
000038  7860              LDRB     r0,[r4,#1]
00003a  2829              CMP      r0,#0x29
00003c  d108              BNE      |L31.80|
;;;520              s = start_capture(ms, s, p + 2, CAP_POSITION);
00003e  f06f0301          MVN      r3,#1
000042  1ca2              ADDS     r2,r4,#2
000044  4631              MOV      r1,r6
000046  4628              MOV      r0,r5
000048  f7fffffe          BL       start_capture
00004c  4606              MOV      r6,r0
00004e  e007              B        |L31.96|
                  |L31.80|
;;;521            else
;;;522              s = start_capture(ms, s, p + 1, CAP_UNFINISHED);
000050  f04f33ff          MOV      r3,#0xffffffff
000054  1c62              ADDS     r2,r4,#1
000056  4631              MOV      r1,r6
000058  4628              MOV      r0,r5
00005a  f7fffffe          BL       start_capture
00005e  4606              MOV      r6,r0
                  |L31.96|
;;;523            break;
000060  e0be              B        |L31.480|
                  |L31.98|
;;;524          }
;;;525          case ')': {  /* end capture */
;;;526            s = end_capture(ms, s, p + 1);
000062  1c62              ADDS     r2,r4,#1
000064  4631              MOV      r1,r6
000066  4628              MOV      r0,r5
000068  f7fffffe          BL       end_capture
00006c  4606              MOV      r6,r0
;;;527            break;
00006e  e0b7              B        |L31.480|
                  |L31.112|
;;;528          }
;;;529          case '$': {
;;;530            if ((p + 1) != ms->p_end)  /* is the '$' the last char in pattern? */
000070  1c60              ADDS     r0,r4,#1
000072  68a9              LDR      r1,[r5,#8]
000074  4281              CMP      r1,r0
000076  d000              BEQ      |L31.122|
;;;531              goto dflt;  /* no; go to default */
000078  e06b              B        |L31.338|
                  |L31.122|
;;;532            s = (s == ms->src_end) ? s : NULL;  /* check end of string */
00007a  6868              LDR      r0,[r5,#4]
00007c  42b0              CMP      r0,r6
00007e  d101              BNE      |L31.132|
000080  4630              MOV      r0,r6
000082  e000              B        |L31.134|
                  |L31.132|
000084  2000              MOVS     r0,#0
                  |L31.134|
000086  4606              MOV      r6,r0
;;;533            break;
000088  e0aa              B        |L31.480|
                  |L31.138|
;;;534          }
;;;535          case L_ESC: {  /* escaped sequences not in the format class[*+?-]? */
;;;536            switch (*(p + 1)) {
00008a  f9940001          LDRSB    r0,[r4,#1]
00008e  2836              CMP      r0,#0x36
000090  d04e              BEQ      |L31.304|
000092  dc08              BGT      |L31.166|
000094  f1a00030          SUB      r0,r0,#0x30
000098  2806              CMP      r0,#6
00009a  d256              BCS      |L31.330|
00009c  e8dff000          TBB      [pc,r0]
0000a0  42434445          DCB      0x42,0x43,0x44,0x45
0000a4  4647              DCB      0x46,0x47
                  |L31.166|
0000a6  2839              CMP      r0,#0x39
0000a8  d045              BEQ      |L31.310|
0000aa  dc04              BGT      |L31.182|
0000ac  2837              CMP      r0,#0x37
0000ae  d040              BEQ      |L31.306|
0000b0  2838              CMP      r0,#0x38
0000b2  d14a              BNE      |L31.330|
0000b4  e03e              B        |L31.308|
                  |L31.182|
0000b6  2862              CMP      r0,#0x62
0000b8  d002              BEQ      |L31.192|
0000ba  2866              CMP      r0,#0x66
0000bc  d145              BNE      |L31.330|
0000be  e009              B        |L31.212|
                  |L31.192|
;;;537              case 'b': {  /* balanced string? */
;;;538                s = matchbalance(ms, s, p + 2);
0000c0  1ca2              ADDS     r2,r4,#2
0000c2  4631              MOV      r1,r6
0000c4  4628              MOV      r0,r5
0000c6  f7fffffe          BL       matchbalance
0000ca  4606              MOV      r6,r0
;;;539                if (s != NULL) {
0000cc  b10e              CBZ      r6,|L31.210|
;;;540                  p += 4; goto init;  /* return match(ms, s, p + 4); */
0000ce  1d24              ADDS     r4,r4,#4
0000d0  e7a4              B        |L31.28|
                  |L31.210|
;;;541                }  /* else fail (s == NULL) */
;;;542                break;
0000d2  e03b              B        |L31.332|
                  |L31.212|
;;;543              }
;;;544              case 'f': {  /* frontier? */
;;;545                const char *ep; char previous;
;;;546                p += 2;
0000d4  1ca4              ADDS     r4,r4,#2
;;;547                if (*p != '[')
0000d6  7820              LDRB     r0,[r4,#0]
0000d8  285b              CMP      r0,#0x5b
0000da  d003              BEQ      |L31.228|
;;;548                  luaL_error(ms->L, "missing '[' after '%%f' in pattern");
0000dc  a149              ADR      r1,|L31.516|
0000de  68e8              LDR      r0,[r5,#0xc]
0000e0  f7fffffe          BL       luaL_error
                  |L31.228|
;;;549                ep = classend(ms, p);  /* points to what is next */
0000e4  4621              MOV      r1,r4
0000e6  4628              MOV      r0,r5
0000e8  f7fffffe          BL       classend
0000ec  4607              MOV      r7,r0
;;;550                previous = (s == ms->src_init) ? '\0' : *(s - 1);
0000ee  6828              LDR      r0,[r5,#0]
0000f0  42b0              CMP      r0,r6
0000f2  d101              BNE      |L31.248|
0000f4  2000              MOVS     r0,#0
0000f6  e001              B        |L31.252|
                  |L31.248|
0000f8  f9160c01          LDRSB    r0,[r6,#-1]
                  |L31.252|
0000fc  4680              MOV      r8,r0
;;;551                if (!matchbracketclass(uchar(previous), p, ep - 1) &&
0000fe  1e7a              SUBS     r2,r7,#1
000100  f00800ff          AND      r0,r8,#0xff
000104  4621              MOV      r1,r4
000106  f7fffffe          BL       matchbracketclass
00010a  b948              CBNZ     r0,|L31.288|
;;;552                   matchbracketclass(uchar(*s), p, ep - 1)) {
00010c  1e7a              SUBS     r2,r7,#1
00010e  7830              LDRB     r0,[r6,#0]
000110  4621              MOV      r1,r4
000112  f7fffffe          BL       matchbracketclass
000116  b118              CBZ      r0,|L31.288|
;;;553                  p = ep; goto init;  /* return match(ms, s, ep); */
000118  463c              MOV      r4,r7
00011a  e77f              B        |L31.28|
                  |L31.284|
00011c  e061              B        |L31.482|
                  |L31.286|
00011e  e017              B        |L31.336|
                  |L31.288|
;;;554                }
;;;555                s = NULL;  /* match failed */
000120  2600              MOVS     r6,#0
;;;556                break;
000122  e013              B        |L31.332|
;;;557              }
;;;558              case '0': case '1': case '2': case '3':
000124  bf00              NOP      
000126  bf00              NOP      
000128  bf00              NOP      
;;;559              case '4': case '5': case '6': case '7':
00012a  bf00              NOP      
00012c  bf00              NOP      
00012e  bf00              NOP      
                  |L31.304|
000130  bf00              NOP      
                  |L31.306|
;;;560              case '8': case '9': {  /* capture results (%0-%9)? */
000132  bf00              NOP      
                  |L31.308|
000134  bf00              NOP      
                  |L31.310|
;;;561                s = match_capture(ms, s, uchar(*(p + 1)));
000136  7862              LDRB     r2,[r4,#1]
000138  4631              MOV      r1,r6
00013a  4628              MOV      r0,r5
00013c  f7fffffe          BL       match_capture
000140  4606              MOV      r6,r0
;;;562                if (s != NULL) {
000142  b10e              CBZ      r6,|L31.328|
;;;563                  p += 2; goto init;  /* return match(ms, s, p + 2) */
000144  1ca4              ADDS     r4,r4,#2
000146  e769              B        |L31.28|
                  |L31.328|
;;;564                }
;;;565                break;
000148  e000              B        |L31.332|
                  |L31.330|
;;;566              }
;;;567              default: goto dflt;
00014a  e002              B        |L31.338|
                  |L31.332|
00014c  bf00              NOP                            ;542
;;;568            }
;;;569            break;
00014e  e047              B        |L31.480|
                  |L31.336|
;;;570          }
;;;571          default: dflt: {  /* pattern class plus optional suffix */
000150  bf00              NOP      
                  |L31.338|
;;;572            const char *ep = classend(ms, p);  /* points to optional suffix */
000152  4621              MOV      r1,r4
000154  4628              MOV      r0,r5
000156  f7fffffe          BL       classend
00015a  4607              MOV      r7,r0
;;;573            /* does not match at least once? */
;;;574            if (!singlematch(ms, s, p, ep)) {
00015c  463b              MOV      r3,r7
00015e  4622              MOV      r2,r4
000160  4631              MOV      r1,r6
000162  4628              MOV      r0,r5
000164  f7fffffe          BL       singlematch
000168  b960              CBNZ     r0,|L31.388|
;;;575              if (*ep == '*' || *ep == '?' || *ep == '-') {  /* accept empty? */
00016a  7838              LDRB     r0,[r7,#0]
00016c  282a              CMP      r0,#0x2a
00016e  d005              BEQ      |L31.380|
000170  7838              LDRB     r0,[r7,#0]
000172  283f              CMP      r0,#0x3f
000174  d002              BEQ      |L31.380|
000176  7838              LDRB     r0,[r7,#0]
000178  282d              CMP      r0,#0x2d
00017a  d101              BNE      |L31.384|
                  |L31.380|
;;;576                p = ep + 1; goto init;  /* return match(ms, s, ep + 1); */
00017c  1c7c              ADDS     r4,r7,#1
00017e  e74d              B        |L31.28|
                  |L31.384|
;;;577              }
;;;578              else  /* '+' or no suffix */
;;;579                s = NULL;  /* fail */
000180  2600              MOVS     r6,#0
000182  e02c              B        |L31.478|
                  |L31.388|
;;;580            }
;;;581            else {  /* matched once */
;;;582              switch (*ep) {  /* handle optional suffix */
000184  f9970000          LDRSB    r0,[r7,#0]
000188  282a              CMP      r0,#0x2a
00018a  d014              BEQ      |L31.438|
00018c  282b              CMP      r0,#0x2b
00018e  d010              BEQ      |L31.434|
000190  282d              CMP      r0,#0x2d
000192  d018              BEQ      |L31.454|
000194  283f              CMP      r0,#0x3f
000196  d11e              BNE      |L31.470|
;;;583                case '?': {  /* optional */
;;;584                  const char *res;
;;;585                  if ((res = match(ms, s + 1, ep + 1)) != NULL)
000198  1c7a              ADDS     r2,r7,#1
00019a  1c71              ADDS     r1,r6,#1
00019c  4628              MOV      r0,r5
00019e  f7fffffe          BL       match
0001a2  f1b00800          SUBS     r8,r0,#0
0001a6  d001              BEQ      |L31.428|
;;;586                    s = res;
0001a8  4646              MOV      r6,r8
0001aa  e001              B        |L31.432|
                  |L31.428|
;;;587                  else {
;;;588                    p = ep + 1; goto init;  /* else return match(ms, s, ep + 1); */
0001ac  1c7c              ADDS     r4,r7,#1
0001ae  e735              B        |L31.28|
                  |L31.432|
;;;589                  }
;;;590                  break;
0001b0  e014              B        |L31.476|
                  |L31.434|
;;;591                }
;;;592                case '+':  /* 1 or more repetitions */
;;;593                  s++;  /* 1 match already done */
0001b2  1c76              ADDS     r6,r6,#1
;;;594                  /* FALLTHROUGH */
;;;595                case '*':  /* 0 or more repetitions */
0001b4  bf00              NOP      
                  |L31.438|
;;;596                  s = max_expand(ms, s, p, ep);
0001b6  463b              MOV      r3,r7
0001b8  4622              MOV      r2,r4
0001ba  4631              MOV      r1,r6
0001bc  4628              MOV      r0,r5
0001be  f7fffffe          BL       max_expand
0001c2  4606              MOV      r6,r0
;;;597                  break;
0001c4  e00a              B        |L31.476|
                  |L31.454|
;;;598                case '-':  /* 0 or more repetitions (minimum) */
;;;599                  s = min_expand(ms, s, p, ep);
0001c6  463b              MOV      r3,r7
0001c8  4622              MOV      r2,r4
0001ca  4631              MOV      r1,r6
0001cc  4628              MOV      r0,r5
0001ce  f7fffffe          BL       min_expand
0001d2  4606              MOV      r6,r0
;;;600                  break;
0001d4  e002              B        |L31.476|
                  |L31.470|
;;;601                default:  /* no suffix */
;;;602                  s++; p = ep; goto init;  /* return match(ms, s + 1, ep); */
0001d6  1c76              ADDS     r6,r6,#1
0001d8  463c              MOV      r4,r7
0001da  e71f              B        |L31.28|
                  |L31.476|
0001dc  bf00              NOP                            ;590
                  |L31.478|
;;;603              }
;;;604            }
;;;605            break;
0001de  bf00              NOP      
                  |L31.480|
0001e0  bf00              NOP                            ;523
                  |L31.482|
;;;606          }
;;;607        }
;;;608      }
;;;609      ms->matchdepth++;
0001e2  6928              LDR      r0,[r5,#0x10]
0001e4  1c40              ADDS     r0,r0,#1
0001e6  6128              STR      r0,[r5,#0x10]
;;;610      return s;
0001e8  4630              MOV      r0,r6
;;;611    }
0001ea  e8bd81f0          POP      {r4-r8,pc}
;;;612    
                          ENDP

0001ee  0000              DCW      0x0000
                  |L31.496|
0001f0  70617474          DCB      "pattern too complex",0
0001f4  65726e20
0001f8  746f6f20
0001fc  636f6d70
000200  6c657800
                  |L31.516|
000204  6d697373          DCB      "missing '[' after '%%f' in pattern",0
000208  696e6720
00020c  275b2720
000210  61667465
000214  72202725
000218  25662720
00021c  696e2070
000220  61747465
000224  726e00  
000227  00                DCB      0

                          AREA ||i.match_capture||, CODE, READONLY, ALIGN=1

                  match_capture PROC
;;;500    
;;;501    static const char *match_capture (MatchState *ms, const char *s, int l) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;502      size_t len;
;;;503      l = check_capture(ms, l);
00000a  4629              MOV      r1,r5
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       check_capture
000012  4605              MOV      r5,r0
;;;504      len = ms->capture[l].len;
000014  f1040018          ADD      r0,r4,#0x18
000018  eb0000c5          ADD      r0,r0,r5,LSL #3
00001c  6847              LDR      r7,[r0,#4]
;;;505      if ((size_t)(ms->src_end-s) >= len &&
00001e  6860              LDR      r0,[r4,#4]
000020  1b80              SUBS     r0,r0,r6
000022  42b8              CMP      r0,r7
000024  d30b              BCC      |L32.62|
;;;506          memcmp(ms->capture[l].init, s, len) == 0)
000026  f1040118          ADD      r1,r4,#0x18
00002a  f8510035          LDR      r0,[r1,r5,LSL #3]
00002e  463a              MOV      r2,r7
000030  4631              MOV      r1,r6
000032  f7fffffe          BL       memcmp
000036  b910              CBNZ     r0,|L32.62|
;;;507        return s+len;
000038  19f0              ADDS     r0,r6,r7
                  |L32.58|
;;;508      else return NULL;
;;;509    }
00003a  e8bd81f0          POP      {r4-r8,pc}
                  |L32.62|
00003e  2000              MOVS     r0,#0                 ;508
000040  e7fb              B        |L32.58|
;;;510    
                          ENDP


                          AREA ||i.match_class||, CODE, READONLY, ALIGN=1

                  match_class PROC
;;;368    
;;;369    static int match_class (int c, int cl) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;370      int res;
;;;371      switch (tolower(cl)) {
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       tolower
00000e  2870              CMP      r0,#0x70
000010  d03d              BEQ      |L33.142|
000012  dc0c              BGT      |L33.46|
000014  2864              CMP      r0,#0x64
000016  d021              BEQ      |L33.92|
000018  dc04              BGT      |L33.36|
00001a  2861              CMP      r0,#0x61
00001c  d010              BEQ      |L33.64|
00001e  2863              CMP      r0,#0x63
000020  d160              BNE      |L33.228|
000022  e014              B        |L33.78|
                  |L33.36|
000024  2867              CMP      r0,#0x67
000026  d024              BEQ      |L33.114|
000028  286c              CMP      r0,#0x6c
00002a  d15b              BNE      |L33.228|
00002c  e028              B        |L33.128|
                  |L33.46|
00002e  3873              SUBS     r0,r0,#0x73
000030  2808              CMP      r0,#8
000032  d257              BCS      |L33.228|
000034  e8dff000          TBB      [pc,r0]
000038  32563956          DCB      0x32,0x56,0x39,0x56
00003c  40475650          DCB      0x40,0x47,0x56,0x50
                  |L33.64|
;;;372        case 'a' : res = isalpha(c); break;
000040  f7fffffe          BL       __rt_ctype_table
000044  6800              LDR      r0,[r0,#0]
000046  5d00              LDRB     r0,[r0,r4]
000048  f0000598          AND      r5,r0,#0x98
00004c  e051              B        |L33.242|
                  |L33.78|
;;;373        case 'c' : res = iscntrl(c); break;
00004e  f7fffffe          BL       __rt_ctype_table
000052  6800              LDR      r0,[r0,#0]
000054  5d00              LDRB     r0,[r0,r4]
000056  f0000540          AND      r5,r0,#0x40
00005a  e04a              B        |L33.242|
                  |L33.92|
;;;374        case 'd' : res = isdigit(c); break;
00005c  f7fffffe          BL       __rt_ctype_table
000060  6800              LDR      r0,[r0,#0]
000062  5d00              LDRB     r0,[r0,r4]
000064  2820              CMP      r0,#0x20
000066  d101              BNE      |L33.108|
000068  2001              MOVS     r0,#1
00006a  e000              B        |L33.110|
                  |L33.108|
00006c  2000              MOVS     r0,#0
                  |L33.110|
00006e  4605              MOV      r5,r0
000070  e03f              B        |L33.242|
                  |L33.114|
;;;375        case 'g' : res = isgraph(c); break;
000072  f7fffffe          BL       __rt_ctype_table
000076  6800              LDR      r0,[r0,#0]
000078  5d00              LDRB     r0,[r0,r4]
00007a  f00005ba          AND      r5,r0,#0xba
00007e  e038              B        |L33.242|
                  |L33.128|
;;;376        case 'l' : res = islower(c); break;
000080  f7fffffe          BL       __rt_ctype_table
000084  6800              LDR      r0,[r0,#0]
000086  5d00              LDRB     r0,[r0,r4]
000088  f0000508          AND      r5,r0,#8
00008c  e031              B        |L33.242|
                  |L33.142|
;;;377        case 'p' : res = ispunct(c); break;
00008e  f7fffffe          BL       __rt_ctype_table
000092  6800              LDR      r0,[r0,#0]
000094  5d00              LDRB     r0,[r0,r4]
000096  f0000502          AND      r5,r0,#2
00009a  e02a              B        |L33.242|
;;;378        case 's' : res = isspace(c); break;
00009c  f7fffffe          BL       __rt_ctype_table
0000a0  6800              LDR      r0,[r0,#0]
0000a2  5d00              LDRB     r0,[r0,r4]
0000a4  f0000501          AND      r5,r0,#1
0000a8  e023              B        |L33.242|
;;;379        case 'u' : res = isupper(c); break;
0000aa  f7fffffe          BL       __rt_ctype_table
0000ae  6800              LDR      r0,[r0,#0]
0000b0  5d00              LDRB     r0,[r0,r4]
0000b2  f0000510          AND      r5,r0,#0x10
0000b6  e01c              B        |L33.242|
;;;380        case 'w' : res = isalnum(c); break;
0000b8  f7fffffe          BL       __rt_ctype_table
0000bc  6800              LDR      r0,[r0,#0]
0000be  5d00              LDRB     r0,[r0,r4]
0000c0  f0000538          AND      r5,r0,#0x38
0000c4  e015              B        |L33.242|
;;;381        case 'x' : res = isxdigit(c); break;
0000c6  f7fffffe          BL       __rt_ctype_table
0000ca  6800              LDR      r0,[r0,#0]
0000cc  5d07              LDRB     r7,[r0,r4]
0000ce  ea870087          EOR      r0,r7,r7,LSL #2
0000d2  f0000580          AND      r5,r0,#0x80
0000d6  e00c              B        |L33.242|
;;;382        case 'z' : res = (c == 0); break;  /* deprecated option */
0000d8  b90c              CBNZ     r4,|L33.222|
0000da  2001              MOVS     r0,#1
0000dc  e000              B        |L33.224|
                  |L33.222|
0000de  2000              MOVS     r0,#0
                  |L33.224|
0000e0  4605              MOV      r5,r0
0000e2  e006              B        |L33.242|
                  |L33.228|
;;;383        default: return (cl == c);
0000e4  42a6              CMP      r6,r4
0000e6  d102              BNE      |L33.238|
0000e8  2001              MOVS     r0,#1
                  |L33.234|
;;;384      }
;;;385      return (islower(cl) ? res : !res);
;;;386    }
0000ea  e8bd81f0          POP      {r4-r8,pc}
                  |L33.238|
0000ee  2000              MOVS     r0,#0                 ;383
0000f0  e7fb              B        |L33.234|
                  |L33.242|
0000f2  bf00              NOP                            ;372
0000f4  f7fffffe          BL       __rt_ctype_table
0000f8  6800              LDR      r0,[r0,#0]            ;385
0000fa  5d80              LDRB     r0,[r0,r6]            ;385
0000fc  f0000008          AND      r0,r0,#8              ;385
000100  b108              CBZ      r0,|L33.262|
000102  4628              MOV      r0,r5                 ;385
000104  e7f1              B        |L33.234|
                  |L33.262|
000106  b90d              CBNZ     r5,|L33.268|
000108  2001              MOVS     r0,#1                 ;385
00010a  e7ee              B        |L33.234|
                  |L33.268|
00010c  2000              MOVS     r0,#0                 ;385
00010e  e7ec              B        |L33.234|
;;;387    
                          ENDP


                          AREA ||i.matchbalance||, CODE, READONLY, ALIGN=2

                  matchbalance PROC
;;;427    
;;;428    static const char *matchbalance (MatchState *ms, const char *s,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;429                                       const char *p) {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;430      if (p >= ms->p_end - 1)
00000a  68b0              LDR      r0,[r6,#8]
00000c  1e40              SUBS     r0,r0,#1
00000e  42a8              CMP      r0,r5
000010  d803              BHI      |L34.26|
;;;431        luaL_error(ms->L, "malformed pattern (missing arguments to '%%b')");
000012  a114              ADR      r1,|L34.100|
000014  68f0              LDR      r0,[r6,#0xc]
000016  f7fffffe          BL       luaL_error
                  |L34.26|
;;;432      if (*s != *p) return NULL;
00001a  f9940000          LDRSB    r0,[r4,#0]
00001e  f9951000          LDRSB    r1,[r5,#0]
000022  4288              CMP      r0,r1
000024  d002              BEQ      |L34.44|
000026  2000              MOVS     r0,#0
                  |L34.40|
;;;433      else {
;;;434        int b = *p;
;;;435        int e = *(p+1);
;;;436        int cont = 1;
;;;437        while (++s < ms->src_end) {
;;;438          if (*s == e) {
;;;439            if (--cont == 0) return s+1;
;;;440          }
;;;441          else if (*s == b) cont++;
;;;442        }
;;;443      }
;;;444      return NULL;  /* string ends out of balance */
;;;445    }
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L34.44|
00002c  f9952000          LDRSB    r2,[r5,#0]            ;434
000030  f9953001          LDRSB    r3,[r5,#1]            ;435
000034  2101              MOVS     r1,#1                 ;436
000036  e00d              B        |L34.84|
                  |L34.56|
000038  f9940000          LDRSB    r0,[r4,#0]            ;438
00003c  4298              CMP      r0,r3                 ;438
00003e  d104              BNE      |L34.74|
000040  1e48              SUBS     r0,r1,#1              ;439
000042  1e01              SUBS     r1,r0,#0              ;439
000044  d106              BNE      |L34.84|
000046  1c60              ADDS     r0,r4,#1              ;439
000048  e7ee              B        |L34.40|
                  |L34.74|
00004a  f9940000          LDRSB    r0,[r4,#0]            ;441
00004e  4290              CMP      r0,r2                 ;441
000050  d100              BNE      |L34.84|
000052  1c49              ADDS     r1,r1,#1              ;441
                  |L34.84|
000054  1c60              ADDS     r0,r4,#1              ;437
000056  4604              MOV      r4,r0                 ;437
000058  6877              LDR      r7,[r6,#4]            ;437
00005a  42b8              CMP      r0,r7                 ;437
00005c  d3ec              BCC      |L34.56|
00005e  bf00              NOP                            ;443
000060  2000              MOVS     r0,#0                 ;444
000062  e7e1              B        |L34.40|
;;;446    
                          ENDP

                  |L34.100|
000064  6d616c66          DCB      "malformed pattern (missing arguments to '%%b')",0
000068  6f726d65
00006c  64207061
000070  74746572
000074  6e20286d
000078  69737369
00007c  6e672061
000080  7267756d
000084  656e7473
000088  20746f20
00008c  27252562
000090  272900  
000093  00                DCB      0

                          AREA ||i.matchbracketclass||, CODE, READONLY, ALIGN=1

                  matchbracketclass PROC
;;;388    
;;;389    static int matchbracketclass (int c, const char *p, const char *ec) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
;;;390      int sig = 1;
00000a  2701              MOVS     r7,#1
;;;391      if (*(p+1) == '^') {
00000c  7860              LDRB     r0,[r4,#1]
00000e  285e              CMP      r0,#0x5e
000010  d101              BNE      |L35.22|
;;;392        sig = 0;
000012  2700              MOVS     r7,#0
;;;393        p++;  /* skip the '^' */
000014  1c64              ADDS     r4,r4,#1
                  |L35.22|
;;;394      }
;;;395      while (++p < ec) {
000016  e020              B        |L35.90|
                  |L35.24|
;;;396        if (*p == L_ESC) {
000018  7820              LDRB     r0,[r4,#0]
00001a  2825              CMP      r0,#0x25
00001c  d108              BNE      |L35.48|
;;;397          p++;
00001e  1c64              ADDS     r4,r4,#1
;;;398          if (match_class(c, uchar(*p)))
000020  7821              LDRB     r1,[r4,#0]
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       match_class
000028  b1b8              CBZ      r0,|L35.90|
;;;399            return sig;
00002a  4638              MOV      r0,r7
                  |L35.44|
;;;400        }
;;;401        else if ((*(p+1) == '-') && (p+2 < ec)) {
;;;402          p+=2;
;;;403          if (uchar(*(p-2)) <= c && c <= uchar(*p))
;;;404            return sig;
;;;405        }
;;;406        else if (uchar(*p) == c) return sig;
;;;407      }
;;;408      return !sig;
;;;409    }
00002c  e8bd81f0          POP      {r4-r8,pc}
                  |L35.48|
000030  7860              LDRB     r0,[r4,#1]            ;401
000032  282d              CMP      r0,#0x2d              ;401
000034  d10c              BNE      |L35.80|
000036  1ca0              ADDS     r0,r4,#2              ;401
000038  42b0              CMP      r0,r6                 ;401
00003a  d209              BCS      |L35.80|
00003c  1ca4              ADDS     r4,r4,#2              ;402
00003e  f8140c02          LDRB     r0,[r4,#-2]           ;403
000042  42a8              CMP      r0,r5                 ;403
000044  dc09              BGT      |L35.90|
000046  7820              LDRB     r0,[r4,#0]            ;403
000048  42a8              CMP      r0,r5                 ;403
00004a  db06              BLT      |L35.90|
00004c  4638              MOV      r0,r7                 ;404
00004e  e7ed              B        |L35.44|
                  |L35.80|
000050  7820              LDRB     r0,[r4,#0]            ;406
000052  42a8              CMP      r0,r5                 ;406
000054  d101              BNE      |L35.90|
000056  4638              MOV      r0,r7                 ;406
000058  e7e8              B        |L35.44|
                  |L35.90|
00005a  1c60              ADDS     r0,r4,#1              ;395
00005c  4604              MOV      r4,r0                 ;395
00005e  42b0              CMP      r0,r6                 ;395
000060  d3da              BCC      |L35.24|
000062  b90f              CBNZ     r7,|L35.104|
000064  2001              MOVS     r0,#1                 ;408
000066  e7e1              B        |L35.44|
                  |L35.104|
000068  2000              MOVS     r0,#0                 ;408
00006a  e7df              B        |L35.44|
;;;410    
                          ENDP


                          AREA ||i.max_expand||, CODE, READONLY, ALIGN=1

                  max_expand PROC
;;;447    
;;;448    static const char *max_expand (MatchState *ms, const char *s,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;449                                     const char *p, const char *ep) {
000004  4680              MOV      r8,r0
000006  460d              MOV      r5,r1
000008  4691              MOV      r9,r2
00000a  461e              MOV      r6,r3
;;;450      ptrdiff_t i = 0;  /* counts maximum expand for item */
00000c  2400              MOVS     r4,#0
;;;451      while (singlematch(ms, s + i, p, ep))
00000e  e000              B        |L36.18|
                  |L36.16|
;;;452        i++;
000010  1c64              ADDS     r4,r4,#1
                  |L36.18|
000012  1929              ADDS     r1,r5,r4              ;451
000014  4633              MOV      r3,r6                 ;451
000016  464a              MOV      r2,r9                 ;451
000018  4640              MOV      r0,r8                 ;451
00001a  f7fffffe          BL       singlematch
00001e  2800              CMP      r0,#0                 ;451
000020  d1f6              BNE      |L36.16|
;;;453      /* keeps trying to match with the maximum repetitions */
;;;454      while (i>=0) {
000022  e00b              B        |L36.60|
                  |L36.36|
;;;455        const char *res = match(ms, (s+i), ep+1);
000024  1929              ADDS     r1,r5,r4
000026  1c72              ADDS     r2,r6,#1
000028  4640              MOV      r0,r8
00002a  f7fffffe          BL       match
00002e  4607              MOV      r7,r0
;;;456        if (res) return res;
000030  b117              CBZ      r7,|L36.56|
000032  4638              MOV      r0,r7
                  |L36.52|
;;;457        i--;  /* else didn't match; reduce 1 repetition to try again */
;;;458      }
;;;459      return NULL;
;;;460    }
000034  e8bd87f0          POP      {r4-r10,pc}
                  |L36.56|
000038  1e64              SUBS     r4,r4,#1              ;457
00003a  bf00              NOP                            ;458
                  |L36.60|
00003c  2c00              CMP      r4,#0                 ;454
00003e  daf1              BGE      |L36.36|
000040  2000              MOVS     r0,#0                 ;459
000042  e7f7              B        |L36.52|
;;;461    
                          ENDP


                          AREA ||i.min_expand||, CODE, READONLY, ALIGN=1

                  min_expand PROC
;;;462    
;;;463    static const char *min_expand (MatchState *ms, const char *s,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;464                                     const char *p, const char *ep) {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4690              MOV      r8,r2
00000a  461d              MOV      r5,r3
;;;465      for (;;) {
00000c  bf00              NOP      
                  |L37.14|
;;;466        const char *res = match(ms, s, ep+1);
00000e  1c6a              ADDS     r2,r5,#1
000010  4621              MOV      r1,r4
000012  4638              MOV      r0,r7
000014  f7fffffe          BL       match
000018  4606              MOV      r6,r0
;;;467        if (res != NULL)
00001a  b116              CBZ      r6,|L37.34|
;;;468          return res;
00001c  4630              MOV      r0,r6
                  |L37.30|
;;;469        else if (singlematch(ms, s, p, ep))
;;;470          s++;  /* try with one more repetition */
;;;471        else return NULL;
;;;472      }
;;;473    }
00001e  e8bd81f0          POP      {r4-r8,pc}
                  |L37.34|
000022  462b              MOV      r3,r5                 ;469
000024  4642              MOV      r2,r8                 ;469
000026  4621              MOV      r1,r4                 ;469
000028  4638              MOV      r0,r7                 ;469
00002a  f7fffffe          BL       singlematch
00002e  b108              CBZ      r0,|L37.52|
000030  1c64              ADDS     r4,r4,#1              ;470
000032  e001              B        |L37.56|
                  |L37.52|
000034  2000              MOVS     r0,#0                 ;471
000036  e7f2              B        |L37.30|
                  |L37.56|
000038  e7e9              B        |L37.14|
;;;474    
                          ENDP


                          AREA ||i.nospecials||, CODE, READONLY, ALIGN=2

                  nospecials PROC
;;;666    /* check whether pattern has no special characters */
;;;667    static int nospecials (const char *p, size_t l) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;668      size_t upto = 0;
000006  2400              MOVS     r4,#0
;;;669      do {
000008  bf00              NOP      
                  |L38.10|
;;;670        if (strpbrk(p + upto, SPECIALS))
00000a  1928              ADDS     r0,r5,r4
00000c  a107              ADR      r1,|L38.44|
00000e  f7fffffe          BL       strpbrk
000012  b108              CBZ      r0,|L38.24|
;;;671          return 0;  /* pattern has a special character */
000014  2000              MOVS     r0,#0
                  |L38.22|
;;;672        upto += strlen(p + upto) + 1;  /* may have more after \0 */
;;;673      } while (upto <= l);
;;;674      return 1;  /* no special chars found */
;;;675    }
000016  bd70              POP      {r4-r6,pc}
                  |L38.24|
000018  1928              ADDS     r0,r5,r4              ;672
00001a  f7fffffe          BL       strlen
00001e  1c40              ADDS     r0,r0,#1              ;672
000020  4404              ADD      r4,r4,r0              ;672
000022  42b4              CMP      r4,r6                 ;673
000024  d9f1              BLS      |L38.10|
000026  2001              MOVS     r0,#1                 ;674
000028  e7f5              B        |L38.22|
;;;676    
                          ENDP

00002a  0000              DCW      0x0000
                  |L38.44|
00002c  5e242a2b          DCB      "^$$*+?.([%-",0
000030  3f2e285b
000034  252d00  
000037  00                DCB      0

                          AREA ||i.packint||, CODE, READONLY, ALIGN=1

                  packint PROC
;;;1394   */
;;;1395   static void packint (luaL_Buffer *b, lua_Unsigned n,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1396                        int islittle, int size, int neg) {
000004  4680              MOV      r8,r0
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
00000a  e9dd4b0b          LDRD     r4,r11,[sp,#0x2c]
00000e  f8dd9028          LDR      r9,[sp,#0x28]
;;;1397     char *buff = luaL_prepbuffsize(b, size);
000012  4621              MOV      r1,r4
000014  4640              MOV      r0,r8
000016  f7fffffe          BL       luaL_prepbuffsize
00001a  4682              MOV      r10,r0
;;;1398     int i;
;;;1399     buff[islittle ? 0 : size - 1] = (char)(n & MC);  /* first byte */
00001c  b2f0              UXTB     r0,r6
00001e  b241              SXTB     r1,r0
000020  f1b90f00          CMP      r9,#0
000024  d001              BEQ      |L39.42|
000026  2000              MOVS     r0,#0
000028  e000              B        |L39.44|
                  |L39.42|
00002a  1e60              SUBS     r0,r4,#1
                  |L39.44|
00002c  f80a1000          STRB     r1,[r10,r0]
;;;1400     for (i = 1; i < size; i++) {
000030  2501              MOVS     r5,#1
000032  e00f              B        |L39.84|
                  |L39.52|
;;;1401       n >>= NB;
000034  0a30              LSRS     r0,r6,#8
000036  ea406607          ORR      r6,r0,r7,LSL #24
00003a  0a3f              LSRS     r7,r7,#8
;;;1402       buff[islittle ? i : size - 1 - i] = (char)(n & MC);
00003c  b2f0              UXTB     r0,r6
00003e  b241              SXTB     r1,r0
000040  f1b90f00          CMP      r9,#0
000044  d001              BEQ      |L39.74|
000046  4628              MOV      r0,r5
000048  e001              B        |L39.78|
                  |L39.74|
00004a  1e60              SUBS     r0,r4,#1
00004c  1b40              SUBS     r0,r0,r5
                  |L39.78|
00004e  f80a1000          STRB     r1,[r10,r0]
000052  1c6d              ADDS     r5,r5,#1              ;1400
                  |L39.84|
000054  42a5              CMP      r5,r4                 ;1400
000056  dbed              BLT      |L39.52|
;;;1403     }
;;;1404     if (neg && size > SZINT) {  /* negative number need sign extension? */
000058  f1bb0f00          CMP      r11,#0
00005c  d011              BEQ      |L39.130|
00005e  2c08              CMP      r4,#8
000060  dd0f              BLE      |L39.130|
;;;1405       for (i = SZINT; i < size; i++)  /* correct extra bytes */
000062  2508              MOVS     r5,#8
000064  e00b              B        |L39.126|
                  |L39.102|
;;;1406         buff[islittle ? i : size - 1 - i] = (char)MC;
000066  f04f31ff          MOV      r1,#0xffffffff
00006a  f1b90f00          CMP      r9,#0
00006e  d001              BEQ      |L39.116|
000070  4628              MOV      r0,r5
000072  e001              B        |L39.120|
                  |L39.116|
000074  1e60              SUBS     r0,r4,#1
000076  1b40              SUBS     r0,r0,r5
                  |L39.120|
000078  f80a1000          STRB     r1,[r10,r0]
00007c  1c6d              ADDS     r5,r5,#1              ;1405
                  |L39.126|
00007e  42a5              CMP      r5,r4                 ;1405
000080  dbf1              BLT      |L39.102|
                  |L39.130|
;;;1407     }
;;;1408     luaL_addsize(b, size);  /* add result to buffer */
000082  f8d80008          LDR      r0,[r8,#8]
000086  4420              ADD      r0,r0,r4
000088  f8c80008          STR      r0,[r8,#8]
;;;1409   }
00008c  e8bd9ff0          POP      {r4-r12,pc}
;;;1410   
                          ENDP


                          AREA ||i.posrelat||, CODE, READONLY, ALIGN=1

                  posrelat PROC
;;;63     /* translate a relative string position: negative means back from end */
;;;64     static lua_Integer posrelat (lua_Integer pos, size_t len) {
000000  b570              PUSH     {r4-r6,lr}
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;65       if (pos >= 0) return pos;
000006  2100              MOVS     r1,#0
000008  4608              MOV      r0,r1
00000a  1a59              SUBS     r1,r3,r1
00000c  eb740000          SBCS     r0,r4,r0
000010  db02              BLT      |L40.24|
000012  4618              MOV      r0,r3
000014  4621              MOV      r1,r4
                  |L40.22|
;;;66       else if (0u - (size_t)pos > len) return 0;
;;;67       else return (lua_Integer)len + pos + 1;
;;;68     }
000016  bd70              POP      {r4-r6,pc}
                  |L40.24|
000018  4258              RSBS     r0,r3,#0              ;66
00001a  4290              CMP      r0,r2                 ;66
00001c  d902              BLS      |L40.36|
00001e  2000              MOVS     r0,#0                 ;66
000020  4601              MOV      r1,r0                 ;66
000022  e7f8              B        |L40.22|
                  |L40.36|
000024  18d5              ADDS     r5,r2,r3              ;67
000026  f1440000          ADC      r0,r4,#0              ;67
00002a  1c6d              ADDS     r5,r5,#1              ;67
00002c  f1400100          ADC      r1,r0,#0              ;67
000030  4628              MOV      r0,r5                 ;67
000032  e7f0              B        |L40.22|
;;;69     
                          ENDP


                          AREA ||i.prepstate||, CODE, READONLY, ALIGN=1

                  prepstate PROC
;;;677    
;;;678    static void prepstate (MatchState *ms, lua_State *L,
000000  b570              PUSH     {r4-r6,lr}
;;;679                           const char *s, size_t ls, const char *p, size_t lp) {
000002  e9dd4504          LDRD     r4,r5,[sp,#0x10]
;;;680      ms->L = L;
000006  60c1              STR      r1,[r0,#0xc]
;;;681      ms->matchdepth = MAXCCALLS;
000008  26c8              MOVS     r6,#0xc8
00000a  6106              STR      r6,[r0,#0x10]
;;;682      ms->src_init = s;
00000c  6002              STR      r2,[r0,#0]
;;;683      ms->src_end = s + ls;
00000e  18d6              ADDS     r6,r2,r3
000010  6046              STR      r6,[r0,#4]
;;;684      ms->p_end = p + lp;
000012  1966              ADDS     r6,r4,r5
000014  6086              STR      r6,[r0,#8]
;;;685    }
000016  bd70              POP      {r4-r6,pc}
;;;686    
                          ENDP


                          AREA ||i.push_captures||, CODE, READONLY, ALIGN=2

                  push_captures PROC
;;;655    
;;;656    static int push_captures (MatchState *ms, const char *s, const char *e) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4690              MOV      r8,r2
;;;657      int i;
;;;658      int nlevels = (ms->level == 0 && s) ? 1 : ms->level;
00000a  7d20              LDRB     r0,[r4,#0x14]
00000c  b910              CBNZ     r0,|L42.20|
00000e  b10e              CBZ      r6,|L42.20|
000010  2001              MOVS     r0,#1
000012  e000              B        |L42.22|
                  |L42.20|
000014  7d20              LDRB     r0,[r4,#0x14]
                  |L42.22|
000016  4607              MOV      r7,r0
;;;659      luaL_checkstack(ms->L, nlevels, "too many captures");
000018  a209              ADR      r2,|L42.64|
00001a  4639              MOV      r1,r7
00001c  68e0              LDR      r0,[r4,#0xc]
00001e  f7fffffe          BL       luaL_checkstack
;;;660      for (i = 0; i < nlevels; i++)
000022  2500              MOVS     r5,#0
000024  e006              B        |L42.52|
                  |L42.38|
;;;661        push_onecapture(ms, i, s, e);
000026  4643              MOV      r3,r8
000028  4632              MOV      r2,r6
00002a  4629              MOV      r1,r5
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       push_onecapture
000032  1c6d              ADDS     r5,r5,#1              ;660
                  |L42.52|
000034  42bd              CMP      r5,r7                 ;660
000036  dbf6              BLT      |L42.38|
;;;662      return nlevels;  /* number of strings pushed */
000038  4638              MOV      r0,r7
;;;663    }
00003a  e8bd81f0          POP      {r4-r8,pc}
;;;664    
                          ENDP

00003e  0000              DCW      0x0000
                  |L42.64|
000040  746f6f20          DCB      "too many captures",0
000044  6d616e79
000048  20636170
00004c  74757265
000050  7300    
000052  00                DCB      0
000053  00                DCB      0

                          AREA ||i.push_onecapture||, CODE, READONLY, ALIGN=2

                  push_onecapture PROC
;;;636    
;;;637    static void push_onecapture (MatchState *ms, int i, const char *s,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;638                                                        const char *e) {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  469a              MOV      r10,r3
;;;639      if (i >= ms->level) {
00000c  7d20              LDRB     r0,[r4,#0x14]
00000e  42a8              CMP      r0,r5
000010  dc0d              BGT      |L43.46|
;;;640        if (i == 0)  /* ms->level == 0, too */
000012  b935              CBNZ     r5,|L43.34|
;;;641          lua_pushlstring(ms->L, s, e - s);  /* add whole match */
000014  ebaa0206          SUB      r2,r10,r6
000018  4631              MOV      r1,r6
00001a  68e0              LDR      r0,[r4,#0xc]
00001c  f7fffffe          BL       lua_pushlstring
000020  e02c              B        |L43.124|
                  |L43.34|
;;;642        else
;;;643          luaL_error(ms->L, "invalid capture index %%%d", i + 1);
000022  1c6a              ADDS     r2,r5,#1
000024  a116              ADR      r1,|L43.128|
000026  68e0              LDR      r0,[r4,#0xc]
000028  f7fffffe          BL       luaL_error
00002c  e026              B        |L43.124|
                  |L43.46|
;;;644      }
;;;645      else {
;;;646        ptrdiff_t l = ms->capture[i].len;
00002e  f1040018          ADD      r0,r4,#0x18
000032  eb0000c5          ADD      r0,r0,r5,LSL #3
000036  f8d09004          LDR      r9,[r0,#4]
;;;647        if (l == CAP_UNFINISHED) luaL_error(ms->L, "unfinished capture");
00003a  f1090001          ADD      r0,r9,#1
00003e  b918              CBNZ     r0,|L43.72|
000040  a116              ADR      r1,|L43.156|
000042  68e0              LDR      r0,[r4,#0xc]
000044  f7fffffe          BL       luaL_error
                  |L43.72|
;;;648        if (l == CAP_POSITION)
000048  f1090002          ADD      r0,r9,#2
00004c  b968              CBNZ     r0,|L43.106|
;;;649          lua_pushinteger(ms->L, (ms->capture[i].init - ms->src_init) + 1);
00004e  f1040118          ADD      r1,r4,#0x18
000052  f8511035          LDR      r1,[r1,r5,LSL #3]
000056  6822              LDR      r2,[r4,#0]
000058  1a89              SUBS     r1,r1,r2
00005a  1c49              ADDS     r1,r1,#1
00005c  17cb              ASRS     r3,r1,#31
00005e  460f              MOV      r7,r1
000060  463a              MOV      r2,r7
000062  68e0              LDR      r0,[r4,#0xc]
000064  f7fffffe          BL       lua_pushinteger
000068  e007              B        |L43.122|
                  |L43.106|
;;;650        else
;;;651          lua_pushlstring(ms->L, ms->capture[i].init, l);
00006a  f1040218          ADD      r2,r4,#0x18
00006e  f8521035          LDR      r1,[r2,r5,LSL #3]
000072  464a              MOV      r2,r9
000074  68e0              LDR      r0,[r4,#0xc]
000076  f7fffffe          BL       lua_pushlstring
                  |L43.122|
;;;652      }
00007a  bf00              NOP      
                  |L43.124|
;;;653    }
00007c  e8bd87f0          POP      {r4-r10,pc}
;;;654    
                          ENDP

                  |L43.128|
000080  696e7661          DCB      "invalid capture index %%%d",0
000084  6c696420
000088  63617074
00008c  75726520
000090  696e6465
000094  78202525
000098  256400  
00009b  00                DCB      0
                  |L43.156|
00009c  756e6669          DCB      "unfinished capture",0
0000a0  6e697368
0000a4  65642063
0000a8  61707475
0000ac  726500  
0000af  00                DCB      0

                          AREA ||i.quotefloat||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_return_value
                          REQUIRE _printf_a
                          REQUIRE _printf_fp_hex
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  quotefloat PROC
;;;1021   */
;;;1022   static int quotefloat (lua_State *L, char *buff, lua_Number n) {
000000  e92d5ffc          PUSH     {r2-r12,lr}
000004  4683              MOV      r11,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
;;;1023     const char *s;  /* for the fixed representations */
;;;1024     if (n == (lua_Number)HUGE_VAL)  /* inf? */
00000c  2200              MOVS     r2,#0
00000e  4b23              LDR      r3,|L44.156|
000010  4620              MOV      r0,r4
000012  4629              MOV      r1,r5
000014  f7fffffe          BL       __aeabi_cdcmpeq
000018  d101              BNE      |L44.30|
;;;1025       s = "1e9999";
00001a  a621              ADR      r6,|L44.160|
00001c  e036              B        |L44.140|
                  |L44.30|
;;;1026     else if (n == -(lua_Number)HUGE_VAL)  /* -inf? */
00001e  2200              MOVS     r2,#0
000020  4b21              LDR      r3,|L44.168|
000022  4620              MOV      r0,r4
000024  4629              MOV      r1,r5
000026  f7fffffe          BL       __aeabi_cdcmpeq
00002a  d101              BNE      |L44.48|
;;;1027       s = "-1e9999";
00002c  a61f              ADR      r6,|L44.172|
00002e  e02d              B        |L44.140|
                  |L44.48|
;;;1028     else if (n != n)  /* NaN? */
000030  4622              MOV      r2,r4
000032  462b              MOV      r3,r5
000034  4620              MOV      r0,r4
000036  4629              MOV      r1,r5
000038  f7fffffe          BL       __aeabi_cdcmpeq
00003c  d001              BEQ      |L44.66|
;;;1029       s = "(0/0)";
00003e  a61d              ADR      r6,|L44.180|
000040  e023              B        |L44.138|
                  |L44.66|
;;;1030     else {  /* format number as hexadecimal */
;;;1031       int  nb = lua_number2strx(L, buff, MAX_ITEM,
000042  a21e              ADR      r2,|L44.188|
000044  f44f71d6          MOV      r1,#0x1ac
000048  4638              MOV      r0,r7
00004a  e9cd4500          STRD     r4,r5,[sp,#0]
00004e  f7fffffe          BL       __2snprintf
000052  4680              MOV      r8,r0
;;;1032                                    "%" LUA_NUMBER_FRMLEN "a", n);
;;;1033       /* ensures that 'buff' string uses a dot as the radix character */
;;;1034       if (memchr(buff, '.', nb) == NULL) {  /* no dot? */
000054  4642              MOV      r2,r8
000056  212e              MOVS     r1,#0x2e
000058  4638              MOV      r0,r7
00005a  f7fffffe          BL       memchr
00005e  b988              CBNZ     r0,|L44.132|
;;;1035         char point = lua_getlocaledecpoint();  /* try locale point */
000060  f7fffffe          BL       localeconv
000064  6800              LDR      r0,[r0,#0]
000066  f990a000          LDRSB    r10,[r0,#0]
;;;1036         char *ppoint = (char *)memchr(buff, point, nb);
00006a  4642              MOV      r2,r8
00006c  4651              MOV      r1,r10
00006e  4638              MOV      r0,r7
000070  f7fffffe          BL       memchr
000074  4681              MOV      r9,r0
;;;1037         if (ppoint) *ppoint = '.';  /* change it to a dot */
000076  f1b90f00          CMP      r9,#0
00007a  d002              BEQ      |L44.130|
00007c  202e              MOVS     r0,#0x2e
00007e  f8890000          STRB     r0,[r9,#0]
                  |L44.130|
;;;1038       }
000082  bf00              NOP      
                  |L44.132|
;;;1039       return nb;
000084  4640              MOV      r0,r8
                  |L44.134|
;;;1040     }
;;;1041     /* for the fixed representations */
;;;1042     return l_sprintf(buff, MAX_ITEM, "%s", s);
;;;1043   }
000086  e8bd9ffc          POP      {r2-r12,pc}
                  |L44.138|
00008a  bf00              NOP                            ;1040
                  |L44.140|
00008c  4633              MOV      r3,r6                 ;1042
00008e  a20c              ADR      r2,|L44.192|
000090  f44f71d6          MOV      r1,#0x1ac             ;1042
000094  4638              MOV      r0,r7                 ;1042
000096  f7fffffe          BL       __2snprintf
00009a  e7f4              B        |L44.134|
;;;1044   
                          ENDP

                  |L44.156|
                          DCD      0x7ff00000
                  |L44.160|
0000a0  31653939          DCB      "1e9999",0
0000a4  393900  
0000a7  00                DCB      0
                  |L44.168|
                          DCD      0xfff00000
                  |L44.172|
0000ac  2d316539          DCB      "-1e9999",0
0000b0  39393900
                  |L44.180|
0000b4  28302f30          DCB      "(0/0)",0
0000b8  2900    
0000ba  00                DCB      0
0000bb  00                DCB      0
                  |L44.188|
0000bc  256100            DCB      "%a",0
0000bf  00                DCB      0
                  |L44.192|
0000c0  257300            DCB      "%s",0
0000c3  00                DCB      0

                          AREA ||i.reprepstate||, CODE, READONLY, ALIGN=1

                  reprepstate PROC
;;;687    
;;;688    static void reprepstate (MatchState *ms) {
000000  2100              MOVS     r1,#0
;;;689      ms->level = 0;
000002  7501              STRB     r1,[r0,#0x14]
;;;690      lua_assert(ms->matchdepth == MAXCCALLS);
;;;691    }
000004  4770              BX       lr
;;;692    
                          ENDP


                          AREA ||i.scanformat||, CODE, READONLY, ALIGN=2

                  scanformat PROC
;;;1080   
;;;1081   static const char *scanformat (lua_State *L, const char *strfrmt, char *form) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;1082     const char *p = strfrmt;
00000a  4634              MOV      r4,r6
;;;1083     while (*p != '\0' && strchr(FLAGS, *p) != NULL) p++;  /* skip flags */
00000c  e000              B        |L46.16|
                  |L46.14|
00000e  1c64              ADDS     r4,r4,#1
                  |L46.16|
000010  7820              LDRB     r0,[r4,#0]
000012  b130              CBZ      r0,|L46.34|
000014  f9941000          LDRSB    r1,[r4,#0]
000018  a025              ADR      r0,|L46.176|
00001a  f7fffffe          BL       strchr
00001e  2800              CMP      r0,#0
000020  d1f5              BNE      |L46.14|
                  |L46.34|
;;;1084     if ((size_t)(p - strfrmt) >= sizeof(FLAGS)/sizeof(char))
000022  1ba0              SUBS     r0,r4,r6
000024  2806              CMP      r0,#6
000026  d303              BCC      |L46.48|
;;;1085       luaL_error(L, "invalid format (repeated flags)");
000028  a123              ADR      r1,|L46.184|
00002a  4638              MOV      r0,r7
00002c  f7fffffe          BL       luaL_error
                  |L46.48|
;;;1086     if (isdigit(uchar(*p))) p++;  /* skip width */
000030  f7fffffe          BL       __rt_ctype_table
000034  6800              LDR      r0,[r0,#0]
000036  7821              LDRB     r1,[r4,#0]
000038  5c40              LDRB     r0,[r0,r1]
00003a  2820              CMP      r0,#0x20
00003c  d100              BNE      |L46.64|
00003e  1c64              ADDS     r4,r4,#1
                  |L46.64|
;;;1087     if (isdigit(uchar(*p))) p++;  /* (2 digits at most) */
000040  f7fffffe          BL       __rt_ctype_table
000044  6800              LDR      r0,[r0,#0]
000046  7821              LDRB     r1,[r4,#0]
000048  5c40              LDRB     r0,[r0,r1]
00004a  2820              CMP      r0,#0x20
00004c  d100              BNE      |L46.80|
00004e  1c64              ADDS     r4,r4,#1
                  |L46.80|
;;;1088     if (*p == '.') {
000050  7820              LDRB     r0,[r4,#0]
000052  282e              CMP      r0,#0x2e
000054  d110              BNE      |L46.120|
;;;1089       p++;
000056  1c64              ADDS     r4,r4,#1
;;;1090       if (isdigit(uchar(*p))) p++;  /* skip precision */
000058  f7fffffe          BL       __rt_ctype_table
00005c  6800              LDR      r0,[r0,#0]
00005e  7821              LDRB     r1,[r4,#0]
000060  5c40              LDRB     r0,[r0,r1]
000062  2820              CMP      r0,#0x20
000064  d100              BNE      |L46.104|
000066  1c64              ADDS     r4,r4,#1
                  |L46.104|
;;;1091       if (isdigit(uchar(*p))) p++;  /* (2 digits at most) */
000068  f7fffffe          BL       __rt_ctype_table
00006c  6800              LDR      r0,[r0,#0]
00006e  7821              LDRB     r1,[r4,#0]
000070  5c40              LDRB     r0,[r0,r1]
000072  2820              CMP      r0,#0x20
000074  d100              BNE      |L46.120|
000076  1c64              ADDS     r4,r4,#1
                  |L46.120|
;;;1092     }
;;;1093     if (isdigit(uchar(*p)))
000078  f7fffffe          BL       __rt_ctype_table
00007c  6800              LDR      r0,[r0,#0]
00007e  7821              LDRB     r1,[r4,#0]
000080  5c40              LDRB     r0,[r0,r1]
000082  2820              CMP      r0,#0x20
000084  d103              BNE      |L46.142|
;;;1094       luaL_error(L, "invalid format (width or precision too long)");
000086  a114              ADR      r1,|L46.216|
000088  4638              MOV      r0,r7
00008a  f7fffffe          BL       luaL_error
                  |L46.142|
;;;1095     *(form++) = '%';
00008e  2025              MOVS     r0,#0x25
000090  f8050b01          STRB     r0,[r5],#1
;;;1096     memcpy(form, strfrmt, ((p - strfrmt) + 1) * sizeof(char));
000094  1ba0              SUBS     r0,r4,r6
000096  1c42              ADDS     r2,r0,#1
000098  4631              MOV      r1,r6
00009a  4628              MOV      r0,r5
00009c  f7fffffe          BL       __aeabi_memcpy
;;;1097     form += (p - strfrmt) + 1;
0000a0  1ba0              SUBS     r0,r4,r6
0000a2  1c40              ADDS     r0,r0,#1
0000a4  4405              ADD      r5,r5,r0
;;;1098     *form = '\0';
0000a6  2000              MOVS     r0,#0
0000a8  7028              STRB     r0,[r5,#0]
;;;1099     return p;
0000aa  4620              MOV      r0,r4
;;;1100   }
0000ac  e8bd81f0          POP      {r4-r8,pc}
;;;1101   
                          ENDP

                  |L46.176|
0000b0  2d2b2023          DCB      "-+ #0",0
0000b4  3000    
0000b6  00                DCB      0
0000b7  00                DCB      0
                  |L46.184|
0000b8  696e7661          DCB      "invalid format (repeated flags)",0
0000bc  6c696420
0000c0  666f726d
0000c4  61742028
0000c8  72657065
0000cc  61746564
0000d0  20666c61
0000d4  67732900
                  |L46.216|
0000d8  696e7661          DCB      "invalid format (width or precision too long)",0
0000dc  6c696420
0000e0  666f726d
0000e4  61742028
0000e8  77696474
0000ec  68206f72
0000f0  20707265
0000f4  63697369
0000f8  6f6e2074
0000fc  6f6f206c
000100  6f6e6729
000104  00      
000105  00                DCB      0
000106  00                DCB      0
000107  00                DCB      0

                          AREA ||i.singlematch||, CODE, READONLY, ALIGN=1

                  singlematch PROC
;;;411    
;;;412    static int singlematch (MatchState *ms, const char *s, const char *p,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;413                            const char *ep) {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4614              MOV      r4,r2
00000a  461f              MOV      r7,r3
;;;414      if (s >= ms->src_end)
00000c  6870              LDR      r0,[r6,#4]
00000e  42a8              CMP      r0,r5
000010  d802              BHI      |L47.24|
;;;415        return 0;
000012  2000              MOVS     r0,#0
                  |L47.20|
;;;416      else {
;;;417        int c = uchar(*s);
;;;418        switch (*p) {
;;;419          case '.': return 1;  /* matches any char */
;;;420          case L_ESC: return match_class(c, uchar(*(p+1)));
;;;421          case '[': return matchbracketclass(c, p, ep-1);
;;;422          default:  return (uchar(*p) == c);
;;;423        }
;;;424      }
;;;425    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L47.24|
000018  f8958000          LDRB     r8,[r5,#0]            ;417
00001c  f9940000          LDRSB    r0,[r4,#0]            ;418
000020  2825              CMP      r0,#0x25              ;418
000022  d006              BEQ      |L47.50|
000024  282e              CMP      r0,#0x2e              ;418
000026  d002              BEQ      |L47.46|
000028  285b              CMP      r0,#0x5b              ;418
00002a  d10d              BNE      |L47.72|
00002c  e006              B        |L47.60|
                  |L47.46|
00002e  2001              MOVS     r0,#1                 ;419
000030  e7f0              B        |L47.20|
                  |L47.50|
000032  7861              LDRB     r1,[r4,#1]            ;420
000034  4640              MOV      r0,r8                 ;420
000036  f7fffffe          BL       match_class
00003a  e7eb              B        |L47.20|
                  |L47.60|
00003c  1e7a              SUBS     r2,r7,#1              ;421
00003e  4621              MOV      r1,r4                 ;421
000040  4640              MOV      r0,r8                 ;421
000042  f7fffffe          BL       matchbracketclass
000046  e7e5              B        |L47.20|
                  |L47.72|
000048  7820              LDRB     r0,[r4,#0]            ;422
00004a  4540              CMP      r0,r8                 ;422
00004c  d101              BNE      |L47.82|
00004e  2001              MOVS     r0,#1                 ;422
000050  e7e0              B        |L47.20|
                  |L47.82|
000052  2000              MOVS     r0,#0                 ;422
000054  e7de              B        |L47.20|
;;;426    
                          ENDP


                          AREA ||i.start_capture||, CODE, READONLY, ALIGN=2

                  start_capture PROC
;;;475    
;;;476    static const char *start_capture (MatchState *ms, const char *s,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;477                                        const char *p, int what) {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4690              MOV      r8,r2
00000a  461f              MOV      r7,r3
;;;478      const char *res;
;;;479      int level = ms->level;
00000c  7d25              LDRB     r5,[r4,#0x14]
;;;480      if (level >= LUA_MAXCAPTURES) luaL_error(ms->L, "too many captures");
00000e  2d20              CMP      r5,#0x20
000010  db03              BLT      |L48.26|
000012  a10d              ADR      r1,|L48.72|
000014  68e0              LDR      r0,[r4,#0xc]
000016  f7fffffe          BL       luaL_error
                  |L48.26|
;;;481      ms->capture[level].init = s;
00001a  f1040018          ADD      r0,r4,#0x18
00001e  f8406035          STR      r6,[r0,r5,LSL #3]
;;;482      ms->capture[level].len = what;
000022  eb0000c5          ADD      r0,r0,r5,LSL #3
000026  6047              STR      r7,[r0,#4]
;;;483      ms->level = level+1;
000028  1c68              ADDS     r0,r5,#1
00002a  7520              STRB     r0,[r4,#0x14]
;;;484      if ((res=match(ms, s, p)) == NULL)  /* match failed? */
00002c  4642              MOV      r2,r8
00002e  4631              MOV      r1,r6
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       match
000036  f1b00900          SUBS     r9,r0,#0
00003a  d102              BNE      |L48.66|
;;;485        ms->level--;  /* undo capture */
00003c  7d20              LDRB     r0,[r4,#0x14]
00003e  1e40              SUBS     r0,r0,#1
000040  7520              STRB     r0,[r4,#0x14]
                  |L48.66|
;;;486      return res;
000042  4648              MOV      r0,r9
;;;487    }
000044  e8bd87f0          POP      {r4-r10,pc}
;;;488    
                          ENDP

                  |L48.72|
000048  746f6f20          DCB      "too many captures",0
00004c  6d616e79
000050  20636170
000054  74757265
000058  7300    
00005a  00                DCB      0
00005b  00                DCB      0

                          AREA ||i.str_byte||, CODE, READONLY, ALIGN=2

                  str_byte PROC
;;;148    
;;;149    static int str_byte (lua_State *L) {
000000  e92d4ff1          PUSH     {r0,r4-r11,lr}
000004  b082              SUB      sp,sp,#8
;;;150      size_t l;
;;;151      const char *s = luaL_checklstring(L, 1, &l);
000006  aa01              ADD      r2,sp,#4
000008  2101              MOVS     r1,#1
00000a  9802              LDR      r0,[sp,#8]
00000c  f7fffffe          BL       luaL_checklstring
000010  9000              STR      r0,[sp,#0]
;;;152      lua_Integer posi = posrelat(luaL_optinteger(L, 2, 1), l);
000012  2201              MOVS     r2,#1
000014  2300              MOVS     r3,#0
000016  2102              MOVS     r1,#2
000018  9802              LDR      r0,[sp,#8]
00001a  f7fffffe          BL       luaL_optinteger
00001e  4680              MOV      r8,r0
000020  9a01              LDR      r2,[sp,#4]
000022  f7fffffe          BL       posrelat
000026  4604              MOV      r4,r0
000028  460d              MOV      r5,r1
;;;153      lua_Integer pose = posrelat(luaL_optinteger(L, 3, posi), l);
00002a  4622              MOV      r2,r4
00002c  462b              MOV      r3,r5
00002e  2103              MOVS     r1,#3
000030  9802              LDR      r0,[sp,#8]
000032  f7fffffe          BL       luaL_optinteger
000036  4680              MOV      r8,r0
000038  9a01              LDR      r2,[sp,#4]
00003a  f7fffffe          BL       posrelat
00003e  4606              MOV      r6,r0
000040  460f              MOV      r7,r1
;;;154      int n, i;
;;;155      if (posi < 1) posi = 1;
000042  1e61              SUBS     r1,r4,#1
000044  f1750000          SBCS     r0,r5,#0
000048  da01              BGE      |L49.78|
00004a  2401              MOVS     r4,#1
00004c  2500              MOVS     r5,#0
                  |L49.78|
;;;156      if (pose > (lua_Integer)l) pose = l;
00004e  2100              MOVS     r1,#0
000050  9801              LDR      r0,[sp,#4]
000052  1b80              SUBS     r0,r0,r6
000054  41b9              SBCS     r1,r1,r7
000056  da01              BGE      |L49.92|
000058  2700              MOVS     r7,#0
00005a  9e01              LDR      r6,[sp,#4]
                  |L49.92|
;;;157      if (posi > pose) return 0;  /* empty interval; return no values */
00005c  1b30              SUBS     r0,r6,r4
00005e  eb770005          SBCS     r0,r7,r5
000062  da02              BGE      |L49.106|
000064  2000              MOVS     r0,#0
                  |L49.102|
;;;158      if (pose - posi >= INT_MAX)  /* arithmetic overflow? */
;;;159        return luaL_error(L, "string slice too long");
;;;160      n = (int)(pose -  posi) + 1;
;;;161      luaL_checkstack(L, n, "string slice too long");
;;;162      for (i=0; i<n; i++)
;;;163        lua_pushinteger(L, uchar(s[posi+i-1]));
;;;164      return n;
;;;165    }
000066  e8bd8ffe          POP      {r1-r11,pc}
                  |L49.106|
00006a  1b31              SUBS     r1,r6,r4              ;158
00006c  eb670005          SBC      r0,r7,r5              ;158
000070  f06f4300          MVN      r3,#0x80000000        ;158
000074  1ac9              SUBS     r1,r1,r3              ;158
000076  f1700000          SBCS     r0,r0,#0              ;158
00007a  db04              BLT      |L49.134|
00007c  a110              ADR      r1,|L49.192|
00007e  9802              LDR      r0,[sp,#8]            ;159
000080  f7fffffe          BL       luaL_error
000084  e7ef              B        |L49.102|
                  |L49.134|
000086  1b30              SUBS     r0,r6,r4              ;160
000088  f1000b01          ADD      r11,r0,#1             ;160
00008c  a20c              ADR      r2,|L49.192|
00008e  4659              MOV      r1,r11                ;161
000090  9802              LDR      r0,[sp,#8]            ;161
000092  f7fffffe          BL       luaL_checkstack
000096  f04f0a00          MOV      r10,#0                ;162
00009a  e00c              B        |L49.182|
                  |L49.156|
00009c  eb14020a          ADDS     r2,r4,r10             ;163
0000a0  1e50              SUBS     r0,r2,#1              ;163
0000a2  9a00              LDR      r2,[sp,#0]            ;163
0000a4  5c11              LDRB     r1,[r2,r0]            ;163
0000a6  460a              MOV      r2,r1                 ;163
0000a8  f04f0300          MOV      r3,#0                 ;163
0000ac  9802              LDR      r0,[sp,#8]            ;163
0000ae  f7fffffe          BL       lua_pushinteger
0000b2  f10a0a01          ADD      r10,r10,#1            ;162
                  |L49.182|
0000b6  45da              CMP      r10,r11               ;162
0000b8  dbf0              BLT      |L49.156|
0000ba  4658              MOV      r0,r11                ;164
0000bc  e7d3              B        |L49.102|
;;;166    
                          ENDP

0000be  0000              DCW      0x0000
                  |L49.192|
0000c0  73747269          DCB      "string slice too long",0
0000c4  6e672073
0000c8  6c696365
0000cc  20746f6f
0000d0  206c6f6e
0000d4  6700    
0000d6  00                DCB      0
0000d7  00                DCB      0

                          AREA ||i.str_char||, CODE, READONLY, ALIGN=2

                  str_char PROC
;;;167    
;;;168    static int str_char (lua_State *L) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  f5ad5d82          SUB      sp,sp,#0x1040
000008  4680              MOV      r8,r0
;;;169      int n = lua_gettop(L);  /* number of arguments */
00000a  4640              MOV      r0,r8
00000c  f7fffffe          BL       lua_gettop
000010  4607              MOV      r7,r0
;;;170      int i;
;;;171      luaL_Buffer b;
;;;172      char *p = luaL_buffinitsize(L, &b, n);
000012  463a              MOV      r2,r7
000014  a90c              ADD      r1,sp,#0x30
000016  4640              MOV      r0,r8
000018  f7fffffe          BL       luaL_buffinitsize
00001c  4681              MOV      r9,r0
;;;173      for (i=1; i<=n; i++) {
00001e  2601              MOVS     r6,#1
000020  e013              B        |L50.74|
                  |L50.34|
;;;174        lua_Integer c = luaL_checkinteger(L, i);
000022  4631              MOV      r1,r6
000024  4640              MOV      r0,r8
000026  f7fffffe          BL       luaL_checkinteger
00002a  4604              MOV      r4,r0
00002c  460d              MOV      r5,r1
;;;175        luaL_argcheck(L, uchar(c) == c, i, "value out of range");
00002e  b2e0              UXTB     r0,r4
000030  4060              EORS     r0,r0,r4
000032  4328              ORRS     r0,r0,r5
000034  d004              BEQ      |L50.64|
000036  a20a              ADR      r2,|L50.96|
000038  4631              MOV      r1,r6
00003a  4640              MOV      r0,r8
00003c  f7fffffe          BL       luaL_argerror
                  |L50.64|
;;;176        p[i - 1] = uchar(c);
000040  b261              SXTB     r1,r4
000042  1e70              SUBS     r0,r6,#1
000044  f8091000          STRB     r1,[r9,r0]
000048  1c76              ADDS     r6,r6,#1              ;173
                  |L50.74|
00004a  42be              CMP      r6,r7                 ;173
00004c  dde9              BLE      |L50.34|
;;;177      }
;;;178      luaL_pushresultsize(&b, n);
00004e  4639              MOV      r1,r7
000050  a80c              ADD      r0,sp,#0x30
000052  f7fffffe          BL       luaL_pushresultsize
;;;179      return 1;
000056  2001              MOVS     r0,#1
;;;180    }
000058  f50d5d82          ADD      sp,sp,#0x1040
00005c  e8bd87f0          POP      {r4-r10,pc}
;;;181    
                          ENDP

                  |L50.96|
000060  76616c75          DCB      "value out of range",0
000064  65206f75
000068  74206f66
00006c  2072616e
000070  676500  
000073  00                DCB      0

                          AREA ||i.str_dump||, CODE, READONLY, ALIGN=2

                  str_dump PROC
;;;189    
;;;190    static int str_dump (lua_State *L) {
000000  b570              PUSH     {r4-r6,lr}
000002  f5ad5d82          SUB      sp,sp,#0x1040
000006  4604              MOV      r4,r0
;;;191      luaL_Buffer b;
;;;192      int strip = lua_toboolean(L, 2);
000008  2102              MOVS     r1,#2
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       lua_toboolean
000010  4605              MOV      r5,r0
;;;193      luaL_checktype(L, 1, LUA_TFUNCTION);
000012  2206              MOVS     r2,#6
000014  2101              MOVS     r1,#1
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       luaL_checktype
;;;194      lua_settop(L, 1);
00001c  2101              MOVS     r1,#1
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       lua_settop
;;;195      luaL_buffinit(L,&b);
000024  a90c              ADD      r1,sp,#0x30
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       luaL_buffinit
;;;196      if (lua_dump(L, writer, &b, strip) != 0)
00002c  462b              MOV      r3,r5
00002e  aa0c              ADD      r2,sp,#0x30
000030  4908              LDR      r1,|L51.84|
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       lua_dump
000038  b130              CBZ      r0,|L51.72|
;;;197        return luaL_error(L, "unable to dump given function");
00003a  a107              ADR      r1,|L51.88|
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       luaL_error
                  |L51.66|
;;;198      luaL_pushresult(&b);
;;;199      return 1;
;;;200    }
000042  f50d5d82          ADD      sp,sp,#0x1040
000046  bd70              POP      {r4-r6,pc}
                  |L51.72|
000048  a80c              ADD      r0,sp,#0x30           ;198
00004a  f7fffffe          BL       luaL_pushresult
00004e  2001              MOVS     r0,#1                 ;199
000050  e7f7              B        |L51.66|
;;;201    
                          ENDP

000052  0000              DCW      0x0000
                  |L51.84|
                          DCD      writer
                  |L51.88|
000058  756e6162          DCB      "unable to dump given function",0
00005c  6c652074
000060  6f206475
000064  6d702067
000068  6976656e
00006c  2066756e
000070  6374696f
000074  6e00    
000076  00                DCB      0
000077  00                DCB      0

                          AREA ||i.str_find||, CODE, READONLY, ALIGN=1

                  str_find PROC
;;;740    
;;;741    static int str_find (lua_State *L) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;742      return str_find_aux(L, 1);
000004  2101              MOVS     r1,#1
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       str_find_aux
;;;743    }
00000c  bd10              POP      {r4,pc}
;;;744    
                          ENDP


                          AREA ||i.str_find_aux||, CODE, READONLY, ALIGN=1

                  str_find_aux PROC
;;;693    
;;;694    static int str_find_aux (lua_State *L, int find) {
000000  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
000004  b0cb              SUB      sp,sp,#0x12c
000006  468a              MOV      r10,r1
;;;695      size_t ls, lp;
;;;696      const char *s = luaL_checklstring(L, 1, &ls);
000008  aa49              ADD      r2,sp,#0x124
00000a  2101              MOVS     r1,#1
00000c  984b              LDR      r0,[sp,#0x12c]
00000e  f7fffffe          BL       luaL_checklstring
000012  4606              MOV      r6,r0
;;;697      const char *p = luaL_checklstring(L, 2, &lp);
000014  aa48              ADD      r2,sp,#0x120
000016  2102              MOVS     r1,#2
000018  984b              LDR      r0,[sp,#0x12c]
00001a  f7fffffe          BL       luaL_checklstring
00001e  4681              MOV      r9,r0
;;;698      lua_Integer init = posrelat(luaL_optinteger(L, 3, 1), ls);
000020  2201              MOVS     r2,#1
000022  2300              MOVS     r3,#0
000024  2103              MOVS     r1,#3
000026  984b              LDR      r0,[sp,#0x12c]
000028  f7fffffe          BL       luaL_optinteger
00002c  4607              MOV      r7,r0
00002e  9a49              LDR      r2,[sp,#0x124]
000030  f7fffffe          BL       posrelat
000034  4604              MOV      r4,r0
000036  460d              MOV      r5,r1
;;;699      if (init < 1) init = 1;
000038  1e61              SUBS     r1,r4,#1
00003a  f1750000          SBCS     r0,r5,#0
00003e  da01              BGE      |L53.68|
000040  2401              MOVS     r4,#1
000042  e00e              B        |L53.98|
                  |L53.68|
;;;700      else if (init > (lua_Integer)ls + 1) {  /* start after string's end? */
000044  2100              MOVS     r1,#0
000046  9849              LDR      r0,[sp,#0x124]
000048  1c42              ADDS     r2,r0,#1
00004a  eb410001          ADC      r0,r1,r1
00004e  1b11              SUBS     r1,r2,r4
000050  41a8              SBCS     r0,r0,r5
000052  da06              BGE      |L53.98|
;;;701        lua_pushnil(L);  /* cannot find anything */
000054  984b              LDR      r0,[sp,#0x12c]
000056  f7fffffe          BL       lua_pushnil
;;;702        return 1;
00005a  2001              MOVS     r0,#1
                  |L53.92|
;;;703      }
;;;704      /* explicit request or no special characters? */
;;;705      if (find && (lua_toboolean(L, 4) || nospecials(p, lp))) {
;;;706        /* do a plain search */
;;;707        const char *s2 = lmemfind(s + init - 1, ls - (size_t)init + 1, p, lp);
;;;708        if (s2) {
;;;709          lua_pushinteger(L, (s2 - s) + 1);
;;;710          lua_pushinteger(L, (s2 - s) + lp);
;;;711          return 2;
;;;712        }
;;;713      }
;;;714      else {
;;;715        MatchState ms;
;;;716        const char *s1 = s + init - 1;
;;;717        int anchor = (*p == '^');
;;;718        if (anchor) {
;;;719          p++; lp--;  /* skip anchor character */
;;;720        }
;;;721        prepstate(&ms, L, s, ls, p, lp);
;;;722        do {
;;;723          const char *res;
;;;724          reprepstate(&ms);
;;;725          if ((res=match(&ms, s1, p)) != NULL) {
;;;726            if (find) {
;;;727              lua_pushinteger(L, (s1 - s) + 1);  /* start */
;;;728              lua_pushinteger(L, res - s);   /* end */
;;;729              return push_captures(&ms, NULL, 0) + 2;
;;;730            }
;;;731            else
;;;732              return push_captures(&ms, s1, res);
;;;733          }
;;;734        } while (s1++ < ms.src_end && !anchor);
;;;735      }
;;;736      lua_pushnil(L);  /* not found */
;;;737      return 1;
;;;738    }
00005c  b04d              ADD      sp,sp,#0x134
00005e  e8bd8ff0          POP      {r4-r11,pc}
                  |L53.98|
000062  f1ba0f00          CMP      r10,#0                ;705
000066  d02b              BEQ      |L53.192|
000068  2104              MOVS     r1,#4                 ;705
00006a  984b              LDR      r0,[sp,#0x12c]        ;705
00006c  f7fffffe          BL       lua_toboolean
000070  b920              CBNZ     r0,|L53.124|
000072  4648              MOV      r0,r9                 ;705
000074  9948              LDR      r1,[sp,#0x120]        ;705
000076  f7fffffe          BL       nospecials
00007a  b308              CBZ      r0,|L53.192|
                  |L53.124|
00007c  9a49              LDR      r2,[sp,#0x124]        ;707
00007e  1b12              SUBS     r2,r2,r4              ;707
000080  1c51              ADDS     r1,r2,#1              ;707
000082  1932              ADDS     r2,r6,r4              ;707
000084  1e50              SUBS     r0,r2,#1              ;707
000086  464a              MOV      r2,r9                 ;707
000088  9b48              LDR      r3,[sp,#0x120]        ;707
00008a  f7fffffe          BL       lmemfind
00008e  4683              MOV      r11,r0                ;707
000090  f1bb0f00          CMP      r11,#0                ;708
000094  d013              BEQ      |L53.190|
000096  ebab0006          SUB      r0,r11,r6             ;709
00009a  1c40              ADDS     r0,r0,#1              ;709
00009c  17c3              ASRS     r3,r0,#31             ;709
00009e  4607              MOV      r7,r0                 ;709
0000a0  463a              MOV      r2,r7                 ;709
0000a2  984b              LDR      r0,[sp,#0x12c]        ;709
0000a4  f7fffffe          BL       lua_pushinteger
0000a8  ebab0006          SUB      r0,r11,r6             ;710
0000ac  9a48              LDR      r2,[sp,#0x120]        ;710
0000ae  1881              ADDS     r1,r0,r2              ;710
0000b0  460a              MOV      r2,r1                 ;710
0000b2  2300              MOVS     r3,#0                 ;710
0000b4  984b              LDR      r0,[sp,#0x12c]        ;710
0000b6  f7fffffe          BL       lua_pushinteger
0000ba  2002              MOVS     r0,#2                 ;711
0000bc  e7ce              B        |L53.92|
                  |L53.190|
0000be  e053              B        |L53.360|
                  |L53.192|
0000c0  1930              ADDS     r0,r6,r4              ;716
0000c2  1e47              SUBS     r7,r0,#1              ;716
0000c4  f8990000          LDRB     r0,[r9,#0]            ;717
0000c8  285e              CMP      r0,#0x5e              ;717
0000ca  d101              BNE      |L53.208|
0000cc  2001              MOVS     r0,#1                 ;717
0000ce  e000              B        |L53.210|
                  |L53.208|
0000d0  2000              MOVS     r0,#0                 ;717
                  |L53.210|
0000d2  4680              MOV      r8,r0                 ;717
0000d4  f1b80f00          CMP      r8,#0                 ;718
0000d8  d004              BEQ      |L53.228|
0000da  f1090901          ADD      r9,r9,#1              ;719
0000de  9848              LDR      r0,[sp,#0x120]        ;719
0000e0  1e40              SUBS     r0,r0,#1              ;719
0000e2  9048              STR      r0,[sp,#0x120]        ;719
                  |L53.228|
0000e4  9848              LDR      r0,[sp,#0x120]        ;721
0000e6  e9cd9000          STRD     r9,r0,[sp,#0]         ;721
0000ea  4632              MOV      r2,r6                 ;721
0000ec  a802              ADD      r0,sp,#8              ;721
0000ee  9b49              LDR      r3,[sp,#0x124]        ;721
0000f0  994b              LDR      r1,[sp,#0x12c]        ;721
0000f2  f7fffffe          BL       prepstate
0000f6  bf00              NOP                            ;722
                  |L53.248|
0000f8  a802              ADD      r0,sp,#8              ;724
0000fa  f7fffffe          BL       reprepstate
0000fe  464a              MOV      r2,r9                 ;725
000100  4639              MOV      r1,r7                 ;725
000102  a802              ADD      r0,sp,#8              ;725
000104  f7fffffe          BL       match
000108  f1b00b00          SUBS     r11,r0,#0             ;725
00010c  d023              BEQ      |L53.342|
00010e  f1ba0f00          CMP      r10,#0                ;726
000112  d01a              BEQ      |L53.330|
000114  1bb8              SUBS     r0,r7,r6              ;727
000116  1c40              ADDS     r0,r0,#1              ;727
000118  17c1              ASRS     r1,r0,#31             ;727
00011a  4602              MOV      r2,r0                 ;727
00011c  460b              MOV      r3,r1                 ;727
00011e  e9cd0100          STRD     r0,r1,[sp,#0]         ;727
000122  984b              LDR      r0,[sp,#0x12c]        ;727
000124  f7fffffe          BL       lua_pushinteger
000128  ebab0006          SUB      r0,r11,r6             ;728
00012c  17c1              ASRS     r1,r0,#31             ;728
00012e  4602              MOV      r2,r0                 ;728
000130  460b              MOV      r3,r1                 ;728
000132  e9cd0100          STRD     r0,r1,[sp,#0]         ;728
000136  984b              LDR      r0,[sp,#0x12c]        ;728
000138  f7fffffe          BL       lua_pushinteger
00013c  2200              MOVS     r2,#0                 ;729
00013e  4611              MOV      r1,r2                 ;729
000140  a802              ADD      r0,sp,#8              ;729
000142  f7fffffe          BL       push_captures
000146  1c80              ADDS     r0,r0,#2              ;729
000148  e788              B        |L53.92|
                  |L53.330|
00014a  465a              MOV      r2,r11                ;732
00014c  4639              MOV      r1,r7                 ;732
00014e  a802              ADD      r0,sp,#8              ;732
000150  f7fffffe          BL       push_captures
000154  e782              B        |L53.92|
                  |L53.342|
000156  4638              MOV      r0,r7                 ;734
000158  1c7f              ADDS     r7,r7,#1              ;734
00015a  9903              LDR      r1,[sp,#0xc]          ;734
00015c  4288              CMP      r0,r1                 ;734
00015e  d202              BCS      |L53.358|
000160  f1b80f00          CMP      r8,#0                 ;734
000164  d0c8              BEQ      |L53.248|
                  |L53.358|
000166  bf00              NOP                            ;735
                  |L53.360|
000168  984b              LDR      r0,[sp,#0x12c]        ;736
00016a  f7fffffe          BL       lua_pushnil
00016e  2001              MOVS     r0,#1                 ;737
000170  e774              B        |L53.92|
;;;739    
                          ENDP


                          AREA ||i.str_format||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_truncate_unsigned
                          REQUIRE _printf_truncate_signed
                          REQUIRE _printf_sizespec
                          REQUIRE _printf_percent
                          REQUIRE _printf_return_value
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_i
                          REQUIRE _printf_u
                          REQUIRE _printf_o
                          REQUIRE _printf_x
                          REQUIRE _printf_c
                          REQUIRE _printf_lc
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_longlong_oct
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_str
                          REQUIRE _printf_wctomb
                          REQUIRE _printf_lld
                          REQUIRE _printf_lli
                          REQUIRE _printf_llu
                          REQUIRE _printf_llo
                          REQUIRE _printf_llx
                          REQUIRE _printf_longlong_dec
                          REQUIRE _printf_f
                          REQUIRE _printf_e
                          REQUIRE _printf_g
                          REQUIRE _printf_a
                          REQUIRE _printf_fp_hex
                          REQUIRE _printf_fp_dec
                          REQUIRE _printf_p
                          REQUIRE _printf_s
                          REQUIRE _printf_n
                          REQUIRE _printf_charcount
                          REQUIRE _printf_str
                  str_format PROC
;;;1115   
;;;1116   static int str_format (lua_State *L) {
000000  e92d4ff1          PUSH     {r0,r4-r11,lr}
000004  b092              SUB      sp,sp,#0x48
000006  f5ad5d80          SUB      sp,sp,#0x1000
;;;1117     int top = lua_gettop(L);
00000a  f50d5080          ADD      r0,sp,#0x1000
00000e  6c80              LDR      r0,[r0,#0x48]
000010  f7fffffe          BL       lua_gettop
000014  4606              MOV      r6,r0
;;;1118     int arg = 1;
000016  2501              MOVS     r5,#1
;;;1119     size_t sfl;
;;;1120     const char *strfrmt = luaL_checklstring(L, arg, &sfl);
000018  f50d5282          ADD      r2,sp,#0x1040
00001c  4629              MOV      r1,r5
00001e  f50d5080          ADD      r0,sp,#0x1000
000022  6c80              LDR      r0,[r0,#0x48]
000024  f7fffffe          BL       luaL_checklstring
000028  4604              MOV      r4,r0
;;;1121     const char *strfrmt_end = strfrmt+sfl;
00002a  f50d5080          ADD      r0,sp,#0x1000
00002e  6c00              LDR      r0,[r0,#0x40]
000030  eb040b00          ADD      r11,r4,r0
;;;1122     luaL_Buffer b;
;;;1123     luaL_buffinit(L, &b);
000034  a90c              ADD      r1,sp,#0x30
000036  f50d5080          ADD      r0,sp,#0x1000
00003a  6c80              LDR      r0,[r0,#0x48]
00003c  f7fffffe          BL       luaL_buffinit
;;;1124     while (strfrmt < strfrmt_end) {
000040  e11a              B        |L54.632|
                  |L54.66|
;;;1125       if (*strfrmt != L_ESC)
000042  7820              LDRB     r0,[r4,#0]
000044  2825              CMP      r0,#0x25
000046  d00f              BEQ      |L54.104|
;;;1126         luaL_addchar(&b, *strfrmt++);
000048  e9dd010d          LDRD     r0,r1,[sp,#0x34]
00004c  4281              CMP      r1,r0
00004e  d303              BCC      |L54.88|
000050  2101              MOVS     r1,#1
000052  a80c              ADD      r0,sp,#0x30
000054  f7fffffe          BL       luaL_prepbuffsize
                  |L54.88|
000058  f8142b01          LDRB     r2,[r4],#1
00005c  9b0e              LDR      r3,[sp,#0x38]
00005e  1c59              ADDS     r1,r3,#1
000060  910e              STR      r1,[sp,#0x38]
000062  980c              LDR      r0,[sp,#0x30]
000064  54c2              STRB     r2,[r0,r3]
000066  e107              B        |L54.632|
                  |L54.104|
;;;1127       else if (*++strfrmt == L_ESC)
000068  1c60              ADDS     r0,r4,#1
00006a  4604              MOV      r4,r0
00006c  7800              LDRB     r0,[r0,#0]
00006e  2825              CMP      r0,#0x25
000070  d10f              BNE      |L54.146|
;;;1128         luaL_addchar(&b, *strfrmt++);  /* %% */
000072  e9dd010d          LDRD     r0,r1,[sp,#0x34]
000076  4281              CMP      r1,r0
000078  d303              BCC      |L54.130|
00007a  2101              MOVS     r1,#1
00007c  a80c              ADD      r0,sp,#0x30
00007e  f7fffffe          BL       luaL_prepbuffsize
                  |L54.130|
000082  f8142b01          LDRB     r2,[r4],#1
000086  9b0e              LDR      r3,[sp,#0x38]
000088  1c59              ADDS     r1,r3,#1
00008a  910e              STR      r1,[sp,#0x38]
00008c  980c              LDR      r0,[sp,#0x30]
00008e  54c2              STRB     r2,[r0,r3]
000090  e0f2              B        |L54.632|
                  |L54.146|
;;;1129       else { /* format item */
;;;1130         char form[MAX_FORMAT];  /* to store the format ('%...') */
;;;1131         char *buff = luaL_prepbuffsize(&b, MAX_ITEM);  /* to put formatted item */
000092  f44f71d6          MOV      r1,#0x1ac
000096  a80c              ADD      r0,sp,#0x30
000098  f7fffffe          BL       luaL_prepbuffsize
00009c  4682              MOV      r10,r0
;;;1132         int nb = 0;  /* number of bytes in added item */
00009e  f04f0900          MOV      r9,#0
;;;1133         if (++arg > top)
0000a2  1c68              ADDS     r0,r5,#1
0000a4  4605              MOV      r5,r0
0000a6  42b0              CMP      r0,r6
0000a8  dd06              BLE      |L54.184|
;;;1134           luaL_argerror(L, arg, "no value");
0000aa  a277              ADR      r2,|L54.648|
0000ac  4629              MOV      r1,r5
0000ae  f50d5080          ADD      r0,sp,#0x1000
0000b2  6c80              LDR      r0,[r0,#0x48]
0000b4  f7fffffe          BL       luaL_argerror
                  |L54.184|
;;;1135         strfrmt = scanformat(L, strfrmt, form);
0000b8  aa04              ADD      r2,sp,#0x10
0000ba  4621              MOV      r1,r4
0000bc  f50d5080          ADD      r0,sp,#0x1000
0000c0  6c80              LDR      r0,[r0,#0x48]
0000c2  f7fffffe          BL       scanformat
0000c6  4604              MOV      r4,r0
;;;1136         switch (*strfrmt++) {
0000c8  f9141b01          LDRSB    r1,[r4],#1
0000cc  2966              CMP      r1,#0x66
0000ce  d066              BEQ      |L54.414|
0000d0  dc12              BGT      |L54.248|
0000d2  2961              CMP      r1,#0x61
0000d4  d04c              BEQ      |L54.368|
0000d6  dc08              BGT      |L54.234|
0000d8  2941              CMP      r1,#0x41
0000da  d04a              BEQ      |L54.370|
0000dc  2945              CMP      r1,#0x45
0000de  d05d              BEQ      |L54.412|
0000e0  2947              CMP      r1,#0x47
0000e2  d05e              BEQ      |L54.418|
0000e4  2958              CMP      r1,#0x58
                  |L54.230|
0000e6  d172              BNE      |L54.462|
0000e8  e02c              B        |L54.324|
                  |L54.234|
0000ea  2963              CMP      r1,#0x63
0000ec  d015              BEQ      |L54.282|
0000ee  2964              CMP      r1,#0x64
0000f0  d023              BEQ      |L54.314|
0000f2  2965              CMP      r1,#0x65
0000f4  d1f7              BNE      |L54.230|
0000f6  e050              B        |L54.410|
                  |L54.248|
0000f8  2971              CMP      r1,#0x71
0000fa  d06a              BEQ      |L54.466|
0000fc  dc06              BGT      |L54.268|
0000fe  2967              CMP      r1,#0x67
000100  d04e              BEQ      |L54.416|
000102  2969              CMP      r1,#0x69
000104  d01a              BEQ      |L54.316|
000106  296f              CMP      r1,#0x6f
000108  d1ed              BNE      |L54.230|
00010a  e018              B        |L54.318|
                  |L54.268|
00010c  2973              CMP      r1,#0x73
00010e  d068              BEQ      |L54.482|
000110  2975              CMP      r1,#0x75
000112  d015              BEQ      |L54.320|
000114  2978              CMP      r1,#0x78
000116  d1e6              BNE      |L54.230|
000118  e013              B        |L54.322|
                  |L54.282|
;;;1137           case 'c': {
;;;1138             nb = l_sprintf(buff, MAX_ITEM, form, (int)luaL_checkinteger(L, arg));
00011a  4629              MOV      r1,r5
00011c  f50d5080          ADD      r0,sp,#0x1000
000120  6c80              LDR      r0,[r0,#0x48]
000122  f7fffffe          BL       luaL_checkinteger
000126  4607              MOV      r7,r0
000128  463b              MOV      r3,r7
00012a  aa04              ADD      r2,sp,#0x10
00012c  f44f71d6          MOV      r1,#0x1ac
000130  4650              MOV      r0,r10
000132  f7fffffe          BL       __2snprintf
000136  4681              MOV      r9,r0
;;;1139             break;
000138  e098              B        |L54.620|
                  |L54.314|
;;;1140           }
;;;1141           case 'd': case 'i':
00013a  bf00              NOP      
                  |L54.316|
;;;1142           case 'o': case 'u': case 'x': case 'X': {
00013c  bf00              NOP      
                  |L54.318|
00013e  bf00              NOP      
                  |L54.320|
000140  bf00              NOP      
                  |L54.322|
000142  bf00              NOP      
                  |L54.324|
;;;1143             lua_Integer n = luaL_checkinteger(L, arg);
000144  4629              MOV      r1,r5
000146  f50d5080          ADD      r0,sp,#0x1000
00014a  6c80              LDR      r0,[r0,#0x48]
00014c  f7fffffe          BL       luaL_checkinteger
000150  4607              MOV      r7,r0
000152  4688              MOV      r8,r1
;;;1144             addlenmod(form, LUA_INTEGER_FRMLEN);
000154  a14f              ADR      r1,|L54.660|
000156  a804              ADD      r0,sp,#0x10
000158  f7fffffe          BL       addlenmod
;;;1145             nb = l_sprintf(buff, MAX_ITEM, form, (LUAI_UACINT)n);
00015c  aa04              ADD      r2,sp,#0x10
00015e  f44f71d6          MOV      r1,#0x1ac
000162  4650              MOV      r0,r10
000164  e9cd7800          STRD     r7,r8,[sp,#0]
000168  f7fffffe          BL       __2snprintf
00016c  4681              MOV      r9,r0
;;;1146             break;
00016e  e07d              B        |L54.620|
                  |L54.368|
;;;1147           }
;;;1148           case 'a': case 'A':
000170  bf00              NOP      
                  |L54.370|
;;;1149             addlenmod(form, LUA_NUMBER_FRMLEN);
000172  a147              ADR      r1,|L54.656|
000174  a804              ADD      r0,sp,#0x10
000176  f7fffffe          BL       addlenmod
;;;1150             nb = lua_number2strx(L, buff, MAX_ITEM, form,
00017a  4629              MOV      r1,r5
00017c  f50d5080          ADD      r0,sp,#0x1000
000180  6c80              LDR      r0,[r0,#0x48]
000182  f7fffffe          BL       luaL_checknumber
000186  aa04              ADD      r2,sp,#0x10
000188  e9cd0100          STRD     r0,r1,[sp,#0]
00018c  f44f71d6          MOV      r1,#0x1ac
000190  4650              MOV      r0,r10
000192  f7fffffe          BL       __2snprintf
000196  4681              MOV      r9,r0
;;;1151                                     luaL_checknumber(L, arg));
;;;1152             break;
000198  e068              B        |L54.620|
                  |L54.410|
;;;1153           case 'e': case 'E': case 'f':
00019a  bf00              NOP      
                  |L54.412|
00019c  bf00              NOP      
                  |L54.414|
;;;1154           case 'g': case 'G': {
00019e  bf00              NOP      
                  |L54.416|
0001a0  bf00              NOP      
                  |L54.418|
;;;1155             lua_Number n = luaL_checknumber(L, arg);
0001a2  4629              MOV      r1,r5
0001a4  f50d5080          ADD      r0,sp,#0x1000
0001a8  6c80              LDR      r0,[r0,#0x48]
0001aa  f7fffffe          BL       luaL_checknumber
0001ae  4607              MOV      r7,r0
0001b0  4688              MOV      r8,r1
;;;1156             addlenmod(form, LUA_NUMBER_FRMLEN);
0001b2  a137              ADR      r1,|L54.656|
0001b4  a804              ADD      r0,sp,#0x10
0001b6  f7fffffe          BL       addlenmod
;;;1157             nb = l_sprintf(buff, MAX_ITEM, form, (LUAI_UACNUMBER)n);
0001ba  aa04              ADD      r2,sp,#0x10
0001bc  f44f71d6          MOV      r1,#0x1ac
0001c0  4650              MOV      r0,r10
0001c2  e9cd7800          STRD     r7,r8,[sp,#0]
0001c6  f7fffffe          BL       __2snprintf
0001ca  4681              MOV      r9,r0
;;;1158             break;
0001cc  e04e              B        |L54.620|
                  |L54.462|
0001ce  e040              B        |L54.594|
0001d0  e7ff              B        |L54.466|
                  |L54.466|
;;;1159           }
;;;1160           case 'q': {
;;;1161             addliteral(L, &b, arg);
0001d2  462a              MOV      r2,r5
0001d4  a90c              ADD      r1,sp,#0x30
0001d6  f50d5080          ADD      r0,sp,#0x1000
0001da  6c80              LDR      r0,[r0,#0x48]
0001dc  f7fffffe          BL       addliteral
;;;1162             break;
0001e0  e044              B        |L54.620|
                  |L54.482|
;;;1163           }
;;;1164           case 's': {
;;;1165             size_t l;
;;;1166             const char *s = luaL_tolstring(L, arg, &l);
0001e2  aa03              ADD      r2,sp,#0xc
0001e4  4629              MOV      r1,r5
0001e6  f50d5080          ADD      r0,sp,#0x1000
0001ea  6c80              LDR      r0,[r0,#0x48]
0001ec  f7fffffe          BL       luaL_tolstring
0001f0  4607              MOV      r7,r0
;;;1167             if (form[2] == '\0')  /* no modifiers? */
0001f2  f89d0012          LDRB     r0,[sp,#0x12]
0001f6  b918              CBNZ     r0,|L54.512|
;;;1168               luaL_addvalue(&b);  /* keep entire string */
0001f8  a80c              ADD      r0,sp,#0x30
0001fa  f7fffffe          BL       luaL_addvalue
0001fe  e027              B        |L54.592|
                  |L54.512|
;;;1169             else {
;;;1170               luaL_argcheck(L, l == strlen(s), arg, "string contains zeros");
000200  4638              MOV      r0,r7
000202  f7fffffe          BL       strlen
000206  9903              LDR      r1,[sp,#0xc]
000208  4288              CMP      r0,r1
00020a  d006              BEQ      |L54.538|
00020c  a222              ADR      r2,|L54.664|
00020e  4629              MOV      r1,r5
000210  f50d5080          ADD      r0,sp,#0x1000
000214  6c80              LDR      r0,[r0,#0x48]
000216  f7fffffe          BL       luaL_argerror
                  |L54.538|
;;;1171               if (!strchr(form, '.') && l >= 100) {
00021a  212e              MOVS     r1,#0x2e
00021c  a804              ADD      r0,sp,#0x10
00021e  f7fffffe          BL       strchr
000222  b930              CBNZ     r0,|L54.562|
000224  9803              LDR      r0,[sp,#0xc]
000226  2864              CMP      r0,#0x64
000228  d303              BCC      |L54.562|
;;;1172                 /* no precision and string is too long to be formatted */
;;;1173                 luaL_addvalue(&b);  /* keep entire string */
00022a  a80c              ADD      r0,sp,#0x30
00022c  f7fffffe          BL       luaL_addvalue
000230  e00e              B        |L54.592|
                  |L54.562|
;;;1174               }
;;;1175               else {  /* format the string into 'buff' */
;;;1176                 nb = l_sprintf(buff, MAX_ITEM, form, s);
000232  463b              MOV      r3,r7
000234  aa04              ADD      r2,sp,#0x10
000236  f44f71d6          MOV      r1,#0x1ac
00023a  4650              MOV      r0,r10
00023c  f7fffffe          BL       __2snprintf
000240  4681              MOV      r9,r0
;;;1177                 lua_pop(L, 1);  /* remove result from 'luaL_tolstring' */
000242  f06f0101          MVN      r1,#1
000246  f50d5080          ADD      r0,sp,#0x1000
00024a  6c80              LDR      r0,[r0,#0x48]
00024c  f7fffffe          BL       lua_settop
                  |L54.592|
;;;1178               }
;;;1179             }
;;;1180             break;
000250  e00c              B        |L54.620|
                  |L54.594|
;;;1181           }
;;;1182           default: {  /* also treat cases 'pnLlh' */
;;;1183             return luaL_error(L, "invalid option '%%%c' to 'format'",
000252  f9142c01          LDRSB    r2,[r4,#-1]
000256  a116              ADR      r1,|L54.688|
000258  f50d5080          ADD      r0,sp,#0x1000
00025c  6c80              LDR      r0,[r0,#0x48]
00025e  f7fffffe          BL       luaL_error
                  |L54.610|
;;;1184                                  *(strfrmt - 1));
;;;1185           }
;;;1186         }
;;;1187         lua_assert(nb < MAX_ITEM);
;;;1188         luaL_addsize(&b, nb);
;;;1189       }
;;;1190     }
;;;1191     luaL_pushresult(&b);
;;;1192     return 1;
;;;1193   }
000262  b013              ADD      sp,sp,#0x4c
000264  f50d5d80          ADD      sp,sp,#0x1000
000268  e8bd8ff0          POP      {r4-r11,pc}
                  |L54.620|
00026c  bf00              NOP                            ;1139
00026e  980e              LDR      r0,[sp,#0x38]         ;1188
000270  eb000109          ADD      r1,r0,r9              ;1188
000274  910e              STR      r1,[sp,#0x38]         ;1188
000276  bf00              NOP                            ;1189
                  |L54.632|
000278  455c              CMP      r4,r11                ;1124
00027a  f4ffaee2          BCC      |L54.66|
00027e  a80c              ADD      r0,sp,#0x30           ;1191
000280  f7fffffe          BL       luaL_pushresult
000284  2001              MOVS     r0,#1                 ;1192
000286  e7ec              B        |L54.610|
;;;1194   
                          ENDP

                  |L54.648|
000288  6e6f2076          DCB      "no value"
00028c  616c7565
                  |L54.656|
000290  00                DCB      0
000291  00                DCB      0
000292  00                DCB      0
000293  00                DCB      0
                  |L54.660|
000294  6c6c00            DCB      "ll",0
000297  00                DCB      0
                  |L54.664|
000298  73747269          DCB      "string contains zeros",0
00029c  6e672063
0002a0  6f6e7461
0002a4  696e7320
0002a8  7a65726f
0002ac  7300    
0002ae  00                DCB      0
0002af  00                DCB      0
                  |L54.688|
0002b0  696e7661          DCB      "invalid option '%%%c' to 'format'",0
0002b4  6c696420
0002b8  6f707469
0002bc  6f6e2027
0002c0  25252563
0002c4  2720746f
0002c8  2027666f
0002cc  726d6174
0002d0  2700    
0002d2  00                DCB      0
0002d3  00                DCB      0

                          AREA ||i.str_gsub||, CODE, READONLY, ALIGN=2

                  str_gsub PROC
;;;848    
;;;849    static int str_gsub (lua_State *L) {
000000  e92d4ff1          PUSH     {r0,r4-r11,lr}
000004  f5ad5d8a          SUB      sp,sp,#0x1140
;;;850      size_t srcl, lp;
;;;851      const char *src = luaL_checklstring(L, 1, &srcl);  /* subject */
000008  f241123c          MOV      r2,#0x113c
00000c  446a              ADD      r2,r2,sp
00000e  2101              MOVS     r1,#1
000010  f50d5080          ADD      r0,sp,#0x1000
000014  f8d00140          LDR      r0,[r0,#0x140]
000018  f7fffffe          BL       luaL_checklstring
00001c  4604              MOV      r4,r0
;;;852      const char *p = luaL_checklstring(L, 2, &lp);  /* pattern */
00001e  f2411238          MOV      r2,#0x1138
000022  446a              ADD      r2,r2,sp
000024  2102              MOVS     r1,#2
000026  f50d5080          ADD      r0,sp,#0x1000
00002a  f8d00140          LDR      r0,[r0,#0x140]
00002e  f7fffffe          BL       luaL_checklstring
000032  4682              MOV      r10,r0
;;;853      const char *lastmatch = NULL;  /* end of last match */
000034  2100              MOVS     r1,#0
000036  f50d5080          ADD      r0,sp,#0x1000
00003a  f8c01134          STR      r1,[r0,#0x134]
;;;854      int tr = lua_type(L, 3);  /* replacement type */
00003e  2103              MOVS     r1,#3
000040  f8d00140          LDR      r0,[r0,#0x140]
000044  f7fffffe          BL       lua_type
000048  4681              MOV      r9,r0
;;;855      lua_Integer max_s = luaL_optinteger(L, 4, srcl + 1);  /* max replacements */
00004a  f50d5080          ADD      r0,sp,#0x1000
00004e  f8d0013c          LDR      r0,[r0,#0x13c]
000052  1c42              ADDS     r2,r0,#1
000054  2300              MOVS     r3,#0
000056  2104              MOVS     r1,#4
000058  f50d5080          ADD      r0,sp,#0x1000
00005c  f8d00140          LDR      r0,[r0,#0x140]
000060  f7fffffe          BL       luaL_optinteger
000064  4607              MOV      r7,r0
000066  4688              MOV      r8,r1
;;;856      int anchor = (*p == '^');
000068  f89a0000          LDRB     r0,[r10,#0]
00006c  285e              CMP      r0,#0x5e
00006e  d101              BNE      |L55.116|
000070  2101              MOVS     r1,#1
000072  e000              B        |L55.118|
                  |L55.116|
000074  2100              MOVS     r1,#0
                  |L55.118|
000076  f50d5080          ADD      r0,sp,#0x1000
00007a  f8c01130          STR      r1,[r0,#0x130]
;;;857      lua_Integer n = 0;  /* replacement count */
00007e  2500              MOVS     r5,#0
000080  462e              MOV      r6,r5
;;;858      MatchState ms;
;;;859      luaL_Buffer b;
;;;860      luaL_argcheck(L, tr == LUA_TNUMBER || tr == LUA_TSTRING ||
000082  f1b90f03          CMP      r9,#3
000086  d00e              BEQ      |L55.166|
000088  f1b90f04          CMP      r9,#4
00008c  d00b              BEQ      |L55.166|
00008e  f1b90f06          CMP      r9,#6
000092  d008              BEQ      |L55.166|
000094  f1b90f05          CMP      r9,#5
000098  d005              BEQ      |L55.166|
00009a  a248              ADR      r2,|L55.444|
00009c  2103              MOVS     r1,#3
00009e  f8d00140          LDR      r0,[r0,#0x140]
0000a2  f7fffffe          BL       luaL_argerror
                  |L55.166|
;;;861                       tr == LUA_TFUNCTION || tr == LUA_TTABLE, 3,
;;;862                          "string/function/table expected");
;;;863      luaL_buffinit(L, &b);
0000a6  a902              ADD      r1,sp,#8
0000a8  f50d5080          ADD      r0,sp,#0x1000
0000ac  f8d00140          LDR      r0,[r0,#0x140]
0000b0  f7fffffe          BL       luaL_buffinit
;;;864      if (anchor) {
0000b4  f50d5080          ADD      r0,sp,#0x1000
0000b8  f8d00130          LDR      r0,[r0,#0x130]
0000bc  b150              CBZ      r0,|L55.212|
;;;865        p++; lp--;  /* skip anchor character */
0000be  f10a0a01          ADD      r10,r10,#1
0000c2  f50d5080          ADD      r0,sp,#0x1000
0000c6  f8d00138          LDR      r0,[r0,#0x138]
0000ca  1e40              SUBS     r0,r0,#1
0000cc  f50d5180          ADD      r1,sp,#0x1000
0000d0  f8c10138          STR      r0,[r1,#0x138]
                  |L55.212|
;;;866      }
;;;867      prepstate(&ms, L, src, srcl, p, lp);
0000d4  f50d5080          ADD      r0,sp,#0x1000
0000d8  f8d00138          LDR      r0,[r0,#0x138]
0000dc  e9cda000          STRD     r10,r0,[sp,#0]
0000e0  f50d5080          ADD      r0,sp,#0x1000
0000e4  4622              MOV      r2,r4
0000e6  f8d0313c          LDR      r3,[r0,#0x13c]
0000ea  f8d01140          LDR      r1,[r0,#0x140]
0000ee  3018              ADDS     r0,r0,#0x18
0000f0  f7fffffe          BL       prepstate
;;;868      while (n < max_s) {
0000f4  e044              B        |L55.384|
                  |L55.246|
;;;869        const char *e;
;;;870        reprepstate(&ms);  /* (re)prepare state for new match */
0000f6  f2410018          MOV      r0,#0x1018
0000fa  4468              ADD      r0,r0,sp
0000fc  f7fffffe          BL       reprepstate
;;;871        if ((e = match(&ms, src, p)) != NULL && e != lastmatch) {  /* match? */
000100  4652              MOV      r2,r10
000102  4621              MOV      r1,r4
000104  f2410018          MOV      r0,#0x1018
000108  4468              ADD      r0,r0,sp
00010a  f7fffffe          BL       match
00010e  f1b00b00          SUBS     r11,r0,#0
000112  d018              BEQ      |L55.326|
000114  f50d5080          ADD      r0,sp,#0x1000
000118  f8d00134          LDR      r0,[r0,#0x134]
00011c  4583              CMP      r11,r0
00011e  d012              BEQ      |L55.326|
;;;872          n++;
000120  1c6d              ADDS     r5,r5,#1
000122  f1460600          ADC      r6,r6,#0
;;;873          add_value(&ms, &b, src, e, tr);  /* add replacement to buffer */
000126  465b              MOV      r3,r11
000128  4622              MOV      r2,r4
00012a  a902              ADD      r1,sp,#8
00012c  f2410018          MOV      r0,#0x1018
000130  4468              ADD      r0,r0,sp
000132  f8cd9000          STR      r9,[sp,#0]
000136  f7fffffe          BL       add_value
;;;874          src = lastmatch = e;
00013a  f50d5080          ADD      r0,sp,#0x1000
00013e  465c              MOV      r4,r11
000140  f8c0b134          STR      r11,[r0,#0x134]
000144  e015              B        |L55.370|
                  |L55.326|
;;;875        }
;;;876        else if (src < ms.src_end)  /* otherwise, skip one character */
000146  f50d5080          ADD      r0,sp,#0x1000
00014a  69c1              LDR      r1,[r0,#0x1c]
00014c  42a1              CMP      r1,r4
00014e  d90f              BLS      |L55.368|
;;;877          luaL_addchar(&b, *src++);
000150  e9dd0103          LDRD     r0,r1,[sp,#0xc]
000154  4281              CMP      r1,r0
000156  d303              BCC      |L55.352|
000158  2101              MOVS     r1,#1
00015a  a802              ADD      r0,sp,#8
00015c  f7fffffe          BL       luaL_prepbuffsize
                  |L55.352|
000160  f8142b01          LDRB     r2,[r4],#1
000164  9b04              LDR      r3,[sp,#0x10]
000166  1c59              ADDS     r1,r3,#1
000168  9104              STR      r1,[sp,#0x10]
00016a  9802              LDR      r0,[sp,#8]
00016c  54c2              STRB     r2,[r0,r3]
00016e  e000              B        |L55.370|
                  |L55.368|
;;;878        else break;  /* end of subject */
000170  e00a              B        |L55.392|
                  |L55.370|
;;;879        if (anchor) break;
000172  f50d5080          ADD      r0,sp,#0x1000
000176  f8d00130          LDR      r0,[r0,#0x130]
00017a  b100              CBZ      r0,|L55.382|
00017c  e004              B        |L55.392|
                  |L55.382|
;;;880      }
00017e  bf00              NOP      
                  |L55.384|
000180  1be8              SUBS     r0,r5,r7              ;868
000182  eb760008          SBCS     r0,r6,r8              ;868
000186  dbb6              BLT      |L55.246|
                  |L55.392|
000188  bf00              NOP                            ;878
;;;881      luaL_addlstring(&b, src, ms.src_end-src);
00018a  f50d5080          ADD      r0,sp,#0x1000
00018e  69c0              LDR      r0,[r0,#0x1c]
000190  1b02              SUBS     r2,r0,r4
000192  4621              MOV      r1,r4
000194  a802              ADD      r0,sp,#8
000196  f7fffffe          BL       luaL_addlstring
;;;882      luaL_pushresult(&b);
00019a  a802              ADD      r0,sp,#8
00019c  f7fffffe          BL       luaL_pushresult
;;;883      lua_pushinteger(L, n);  /* number of substitutions */
0001a0  462a              MOV      r2,r5
0001a2  4633              MOV      r3,r6
0001a4  f50d5080          ADD      r0,sp,#0x1000
0001a8  f8d00140          LDR      r0,[r0,#0x140]
0001ac  f7fffffe          BL       lua_pushinteger
;;;884      return 2;
0001b0  2002              MOVS     r0,#2
;;;885    }
0001b2  b051              ADD      sp,sp,#0x144
0001b4  f50d5d80          ADD      sp,sp,#0x1000
0001b8  e8bd8ff0          POP      {r4-r11,pc}
;;;886    
                          ENDP

                  |L55.444|
0001bc  73747269          DCB      "string/function/table expected",0
0001c0  6e672f66
0001c4  756e6374
0001c8  696f6e2f
0001cc  7461626c
0001d0  65206578
0001d4  70656374
0001d8  656400  
0001db  00                DCB      0

                          AREA ||i.str_len||, CODE, READONLY, ALIGN=1

                  str_len PROC
;;;54     
;;;55     static int str_len (lua_State *L) {
000000  b538              PUSH     {r3-r5,lr}
000002  4604              MOV      r4,r0
;;;56       size_t l;
;;;57       luaL_checklstring(L, 1, &l);
000004  466a              MOV      r2,sp
000006  2101              MOVS     r1,#1
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       luaL_checklstring
;;;58       lua_pushinteger(L, (lua_Integer)l);
00000e  2300              MOVS     r3,#0
000010  4620              MOV      r0,r4
000012  9a00              LDR      r2,[sp,#0]
000014  f7fffffe          BL       lua_pushinteger
;;;59       return 1;
000018  2001              MOVS     r0,#1
;;;60     }
00001a  bd38              POP      {r3-r5,pc}
;;;61     
                          ENDP


                          AREA ||i.str_lower||, CODE, READONLY, ALIGN=1

                  str_lower PROC
;;;96     
;;;97     static int str_lower (lua_State *L) {
000000  b5f0              PUSH     {r4-r7,lr}
000002  b091              SUB      sp,sp,#0x44
000004  f5ad5d80          SUB      sp,sp,#0x1000
000008  4605              MOV      r5,r0
;;;98       size_t l;
;;;99       size_t i;
;;;100      luaL_Buffer b;
;;;101      const char *s = luaL_checklstring(L, 1, &l);
00000a  f50d5282          ADD      r2,sp,#0x1040
00000e  2101              MOVS     r1,#1
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       luaL_checklstring
000016  4606              MOV      r6,r0
;;;102      char *p = luaL_buffinitsize(L, &b, l);
000018  f50d5080          ADD      r0,sp,#0x1000
00001c  a90c              ADD      r1,sp,#0x30
00001e  6c02              LDR      r2,[r0,#0x40]
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       luaL_buffinitsize
000026  4607              MOV      r7,r0
;;;103      for (i=0; i<l; i++)
000028  2400              MOVS     r4,#0
00002a  e005              B        |L57.56|
                  |L57.44|
;;;104        p[i] = tolower(uchar(s[i]));
00002c  5d30              LDRB     r0,[r6,r4]
00002e  f7fffffe          BL       tolower
000032  b240              SXTB     r0,r0
000034  5538              STRB     r0,[r7,r4]
000036  1c64              ADDS     r4,r4,#1              ;103
                  |L57.56|
000038  f50d5080          ADD      r0,sp,#0x1000         ;103
00003c  6c00              LDR      r0,[r0,#0x40]         ;103
00003e  4284              CMP      r4,r0                 ;103
000040  d3f4              BCC      |L57.44|
;;;105      luaL_pushresultsize(&b, l);
000042  f50d5080          ADD      r0,sp,#0x1000
000046  6c01              LDR      r1,[r0,#0x40]
000048  a80c              ADD      r0,sp,#0x30
00004a  f7fffffe          BL       luaL_pushresultsize
;;;106      return 1;
00004e  2001              MOVS     r0,#1
;;;107    }
000050  b011              ADD      sp,sp,#0x44
000052  f50d5d80          ADD      sp,sp,#0x1000
000056  bdf0              POP      {r4-r7,pc}
;;;108    
                          ENDP


                          AREA ||i.str_match||, CODE, READONLY, ALIGN=1

                  str_match PROC
;;;745    
;;;746    static int str_match (lua_State *L) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;747      return str_find_aux(L, 0);
000004  2100              MOVS     r1,#0
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       str_find_aux
;;;748    }
00000c  bd10              POP      {r4,pc}
;;;749    
                          ENDP


                          AREA ||i.str_pack||, CODE, READONLY, ALIGN=2

                  str_pack PROC
;;;1429   
;;;1430   static int str_pack (lua_State *L) {
000000  e92d4ff1          PUSH     {r0,r4-r11,lr}
000004  f5ad5d84          SUB      sp,sp,#0x1080
;;;1431     luaL_Buffer b;
;;;1432     Header h;
;;;1433     const char *fmt = luaL_checkstring(L, 1);  /* format string */
000008  2200              MOVS     r2,#0
00000a  2101              MOVS     r1,#1
00000c  f50d5080          ADD      r0,sp,#0x1000
000010  f8d00080          LDR      r0,[r0,#0x80]
000014  f7fffffe          BL       luaL_checklstring
000018  9016              STR      r0,[sp,#0x58]
;;;1434     int arg = 1;  /* current argument to pack */
00001a  f04f0901          MOV      r9,#1
;;;1435     size_t totalsize = 0;  /* accumulate total size of result */
00001e  2600              MOVS     r6,#0
;;;1436     initheader(L, &h);
000020  a917              ADD      r1,sp,#0x5c
000022  f50d5080          ADD      r0,sp,#0x1000
000026  f8d00080          LDR      r0,[r0,#0x80]
00002a  f7fffffe          BL       initheader
;;;1437     lua_pushnil(L);  /* mark to separate arguments from string buffer */
00002e  f50d5080          ADD      r0,sp,#0x1000
000032  f8d00080          LDR      r0,[r0,#0x80]
000036  f7fffffe          BL       lua_pushnil
;;;1438     luaL_buffinit(L, &b);
00003a  a91a              ADD      r1,sp,#0x68
00003c  f50d5080          ADD      r0,sp,#0x1000
000040  f8d00080          LDR      r0,[r0,#0x80]
000044  f7fffffe          BL       luaL_buffinit
;;;1439     while (*fmt != '\0') {
000048  e171              B        |L59.814|
                  |L59.74|
;;;1440       int size, ntoalign;
;;;1441       KOption opt = getdetails(&h, totalsize, &fmt, &size, &ntoalign);
00004a  a814              ADD      r0,sp,#0x50
00004c  ab15              ADD      r3,sp,#0x54
00004e  aa16              ADD      r2,sp,#0x58
000050  4631              MOV      r1,r6
000052  9000              STR      r0,[sp,#0]
000054  a817              ADD      r0,sp,#0x5c
000056  f7fffffe          BL       getdetails
00005a  9013              STR      r0,[sp,#0x4c]
;;;1442       totalsize += ntoalign + size;
00005c  e9dd1014          LDRD     r1,r0,[sp,#0x50]
000060  4401              ADD      r1,r1,r0
000062  440e              ADD      r6,r6,r1
;;;1443       while (ntoalign-- > 0)
000064  e00d              B        |L59.130|
                  |L59.102|
;;;1444        luaL_addchar(&b, LUAL_PACKPADBYTE);  /* fill alignment */
000066  e9dd011b          LDRD     r0,r1,[sp,#0x6c]
00006a  4281              CMP      r1,r0
00006c  d303              BCC      |L59.118|
00006e  2101              MOVS     r1,#1
000070  a81a              ADD      r0,sp,#0x68
000072  f7fffffe          BL       luaL_prepbuffsize
                  |L59.118|
000076  2200              MOVS     r2,#0
000078  9b1c              LDR      r3,[sp,#0x70]
00007a  1c59              ADDS     r1,r3,#1
00007c  911c              STR      r1,[sp,#0x70]
00007e  981a              LDR      r0,[sp,#0x68]
000080  54c2              STRB     r2,[r0,r3]
                  |L59.130|
000082  9a14              LDR      r2,[sp,#0x50]         ;1443
000084  1e50              SUBS     r0,r2,#1              ;1443
000086  9014              STR      r0,[sp,#0x50]         ;1443
000088  2a00              CMP      r2,#0                 ;1443
00008a  dcec              BGT      |L59.102|
;;;1445       arg++;
00008c  f1090901          ADD      r9,r9,#1
;;;1446       switch (opt) {
000090  9813              LDR      r0,[sp,#0x4c]
000092  2809              CMP      r0,#9
000094  d247              BCS      |L59.294|
000096  e8dff000          TBB      [pc,r0]
00009a  0547              DCB      0x05,0x47
00009c  7aa4d4eb          DCB      0x7a,0xa4,0xd4,0xeb
0000a0  eae9e800          DCB      0xea,0xe9,0xe8,0x00
;;;1447         case Kint: {  /* signed integers */
;;;1448           lua_Integer n = luaL_checkinteger(L, arg);
0000a4  4649              MOV      r1,r9
0000a6  f50d5080          ADD      r0,sp,#0x1000
0000aa  f8d00080          LDR      r0,[r0,#0x80]
0000ae  f7fffffe          BL       luaL_checkinteger
0000b2  4604              MOV      r4,r0
0000b4  460d              MOV      r5,r1
;;;1449           if (size < SZINT) {  /* need overflow check? */
0000b6  9815              LDR      r0,[sp,#0x54]
0000b8  2808              CMP      r0,#8
0000ba  da21              BGE      |L59.256|
;;;1450             lua_Integer lim = (lua_Integer)1 << ((size * NB) - 1);
0000bc  2101              MOVS     r1,#1
0000be  9815              LDR      r0,[sp,#0x54]
0000c0  ebc102c0          RSB      r2,r1,r0,LSL #3
0000c4  468b              MOV      r11,r1
0000c6  f04f0a00          MOV      r10,#0
0000ca  4658              MOV      r0,r11
0000cc  4651              MOV      r1,r10
0000ce  f7fffffe          BL       __aeabi_llsl
0000d2  4607              MOV      r7,r0
0000d4  4688              MOV      r8,r1
;;;1451             luaL_argcheck(L, -lim <= n && n < lim, arg, "integer overflow");
0000d6  2000              MOVS     r0,#0
0000d8  4279              RSBS     r1,r7,#0
0000da  eb600008          SBC      r0,r0,r8
0000de  1a61              SUBS     r1,r4,r1
0000e0  eb750000          SBCS     r0,r5,r0
0000e4  db03              BLT      |L59.238|
0000e6  1be0              SUBS     r0,r4,r7
0000e8  eb750008          SBCS     r0,r5,r8
0000ec  db07              BLT      |L59.254|
                  |L59.238|
0000ee  a297              ADR      r2,|L59.844|
0000f0  4649              MOV      r1,r9
0000f2  f50d5080          ADD      r0,sp,#0x1000
0000f6  f8d00080          LDR      r0,[r0,#0x80]
0000fa  f7fffffe          BL       luaL_argerror
                  |L59.254|
;;;1452           }
0000fe  bf00              NOP      
                  |L59.256|
;;;1453           packint(&b, (lua_Unsigned)n, h.islittle, size, (n < 0));
000100  2100              MOVS     r1,#0
000102  4608              MOV      r0,r1
000104  1a61              SUBS     r1,r4,r1
000106  eb750000          SBCS     r0,r5,r0
00010a  da01              BGE      |L59.272|
00010c  2101              MOVS     r1,#1
00010e  e000              B        |L59.274|
                  |L59.272|
000110  2100              MOVS     r1,#0
                  |L59.274|
000112  9a15              LDR      r2,[sp,#0x54]
000114  9818              LDR      r0,[sp,#0x60]
000116  e9cd2101          STRD     r2,r1,[sp,#4]
00011a  9000              STR      r0,[sp,#0]
00011c  4622              MOV      r2,r4
00011e  462b              MOV      r3,r5
000120  a81a              ADD      r0,sp,#0x68
000122  f7fffffe          BL       packint
                  |L59.294|
;;;1454           break;
000126  e100              B        |L59.810|
;;;1455         }
;;;1456         case Kuint: {  /* unsigned integers */
;;;1457           lua_Integer n = luaL_checkinteger(L, arg);
000128  4649              MOV      r1,r9
00012a  f50d5080          ADD      r0,sp,#0x1000
00012e  f8d00080          LDR      r0,[r0,#0x80]
000132  f7fffffe          BL       luaL_checkinteger
000136  4604              MOV      r4,r0
000138  460d              MOV      r5,r1
;;;1458           if (size < SZINT)  /* need overflow check? */
00013a  9815              LDR      r0,[sp,#0x54]
00013c  2808              CMP      r0,#8
00013e  da1a              BGE      |L59.374|
;;;1459             luaL_argcheck(L, (lua_Unsigned)n < ((lua_Unsigned)1 << (size * NB)),
000140  9815              LDR      r0,[sp,#0x54]
000142  00c3              LSLS     r3,r0,#3
000144  2001              MOVS     r0,#1
000146  2100              MOVS     r1,#0
000148  f50d5280          ADD      r2,sp,#0x1000
00014c  e9c2101e          STRD     r1,r0,[r2,#0x78]
000150  461a              MOV      r2,r3
000152  f50d5180          ADD      r1,sp,#0x1000
000156  e9d1101e          LDRD     r1,r0,[r1,#0x78]
00015a  f7fffffe          BL       __aeabi_llsl
00015e  1a20              SUBS     r0,r4,r0
000160  eb750001          SBCS     r0,r5,r1
000164  d307              BCC      |L59.374|
000166  a27e              ADR      r2,|L59.864|
000168  4649              MOV      r1,r9
00016a  f50d5080          ADD      r0,sp,#0x1000
00016e  f8d00080          LDR      r0,[r0,#0x80]
000172  f7fffffe          BL       luaL_argerror
                  |L59.374|
;;;1460                              arg, "unsigned overflow");
;;;1461           packint(&b, (lua_Unsigned)n, h.islittle, size, 0);
000176  2100              MOVS     r1,#0
000178  9a15              LDR      r2,[sp,#0x54]
00017a  9818              LDR      r0,[sp,#0x60]
00017c  e9cd2101          STRD     r2,r1,[sp,#4]
000180  9000              STR      r0,[sp,#0]
000182  4622              MOV      r2,r4
000184  462b              MOV      r3,r5
000186  a81a              ADD      r0,sp,#0x68
000188  f7fffffe          BL       packint
;;;1462           break;
00018c  e0cd              B        |L59.810|
;;;1463         }
;;;1464         case Kfloat: {  /* floating-point options */
;;;1465           volatile Ftypes u;
;;;1466           char *buff = luaL_prepbuffsize(&b, size);
00018e  a81a              ADD      r0,sp,#0x68
000190  9915              LDR      r1,[sp,#0x54]
000192  f7fffffe          BL       luaL_prepbuffsize
000196  4607              MOV      r7,r0
;;;1467           lua_Number n = luaL_checknumber(L, arg);  /* get argument */
000198  4649              MOV      r1,r9
00019a  f50d5080          ADD      r0,sp,#0x1000
00019e  f8d00080          LDR      r0,[r0,#0x80]
0001a2  f7fffffe          BL       luaL_checknumber
0001a6  4604              MOV      r4,r0
0001a8  460d              MOV      r5,r1
;;;1468           if (size == sizeof(u.f)) u.f = (float)n;  /* copy it into 'u' */
0001aa  9815              LDR      r0,[sp,#0x54]
0001ac  2804              CMP      r0,#4
0001ae  d105              BNE      |L59.444|
0001b0  4620              MOV      r0,r4
0001b2  4629              MOV      r1,r5
0001b4  f7fffffe          BL       __aeabi_d2f
0001b8  9008              STR      r0,[sp,#0x20]
0001ba  e007              B        |L59.460|
                  |L59.444|
;;;1469           else if (size == sizeof(u.d)) u.d = (double)n;
0001bc  9815              LDR      r0,[sp,#0x54]
0001be  2808              CMP      r0,#8
0001c0  d102              BNE      |L59.456|
0001c2  9408              STR      r4,[sp,#0x20]
0001c4  9509              STR      r5,[sp,#0x24]
0001c6  e001              B        |L59.460|
                  |L59.456|
;;;1470           else u.n = n;
0001c8  9408              STR      r4,[sp,#0x20]
0001ca  9509              STR      r5,[sp,#0x24]
                  |L59.460|
;;;1471           /* move 'u' to final result, correcting endianness if needed */
;;;1472           copywithendian(buff, u.buff, size, h.islittle);
0001cc  a908              ADD      r1,sp,#0x20
0001ce  4638              MOV      r0,r7
0001d0  9b18              LDR      r3,[sp,#0x60]
0001d2  9a15              LDR      r2,[sp,#0x54]
0001d4  f7fffffe          BL       copywithendian
;;;1473           luaL_addsize(&b, size);
0001d8  991c              LDR      r1,[sp,#0x70]
0001da  9815              LDR      r0,[sp,#0x54]
0001dc  4401              ADD      r1,r1,r0
0001de  911c              STR      r1,[sp,#0x70]
;;;1474           break;
0001e0  e0a3              B        |L59.810|
;;;1475         }
;;;1476         case Kchar: {  /* fixed-size string */
;;;1477           size_t len;
;;;1478           const char *s = luaL_checklstring(L, arg, &len);
0001e2  aa12              ADD      r2,sp,#0x48
0001e4  4649              MOV      r1,r9
0001e6  f50d5080          ADD      r0,sp,#0x1000
0001ea  f8d00080          LDR      r0,[r0,#0x80]
0001ee  f7fffffe          BL       luaL_checklstring
0001f2  4604              MOV      r4,r0
;;;1479           luaL_argcheck(L, len <= (size_t)size, arg,
0001f4  9912              LDR      r1,[sp,#0x48]
0001f6  9815              LDR      r0,[sp,#0x54]
0001f8  4281              CMP      r1,r0
0001fa  d907              BLS      |L59.524|
0001fc  a25d              ADR      r2,|L59.884|
0001fe  4649              MOV      r1,r9
000200  f50d5080          ADD      r0,sp,#0x1000
000204  f8d00080          LDR      r0,[r0,#0x80]
000208  f7fffffe          BL       luaL_argerror
                  |L59.524|
;;;1480                            "string longer than given size");
;;;1481           luaL_addlstring(&b, s, len);  /* add string */
00020c  4621              MOV      r1,r4
00020e  a81a              ADD      r0,sp,#0x68
000210  9a12              LDR      r2,[sp,#0x48]
000212  f7fffffe          BL       luaL_addlstring
;;;1482           while (len++ < (size_t)size)  /* pad extra space */
000216  e00d              B        |L59.564|
                  |L59.536|
;;;1483             luaL_addchar(&b, LUAL_PACKPADBYTE);
000218  e9dd011b          LDRD     r0,r1,[sp,#0x6c]
00021c  4281              CMP      r1,r0
00021e  d303              BCC      |L59.552|
000220  2101              MOVS     r1,#1
000222  a81a              ADD      r0,sp,#0x68
000224  f7fffffe          BL       luaL_prepbuffsize
                  |L59.552|
000228  2200              MOVS     r2,#0
00022a  9b1c              LDR      r3,[sp,#0x70]
00022c  1c59              ADDS     r1,r3,#1
00022e  911c              STR      r1,[sp,#0x70]
000230  981a              LDR      r0,[sp,#0x68]
000232  54c2              STRB     r2,[r0,r3]
                  |L59.564|
000234  9a12              LDR      r2,[sp,#0x48]         ;1482
000236  1c51              ADDS     r1,r2,#1              ;1482
000238  9112              STR      r1,[sp,#0x48]         ;1482
00023a  9815              LDR      r0,[sp,#0x54]         ;1482
00023c  4282              CMP      r2,r0                 ;1482
00023e  d3eb              BCC      |L59.536|
;;;1484           break;
000240  e073              B        |L59.810|
;;;1485         }
;;;1486         case Kstring: {  /* strings with length count */
;;;1487           size_t len;
;;;1488           const char *s = luaL_checklstring(L, arg, &len);
000242  aa12              ADD      r2,sp,#0x48
000244  4649              MOV      r1,r9
000246  f50d5080          ADD      r0,sp,#0x1000
00024a  f8d00080          LDR      r0,[r0,#0x80]
00024e  f7fffffe          BL       luaL_checklstring
000252  4604              MOV      r4,r0
;;;1489           luaL_argcheck(L, size >= (int)sizeof(size_t) ||
000254  9815              LDR      r0,[sp,#0x54]
000256  2804              CMP      r0,#4
000258  da13              BGE      |L59.642|
00025a  9815              LDR      r0,[sp,#0x54]
00025c  00c1              LSLS     r1,r0,#3
00025e  2001              MOVS     r0,#1
000260  4088              LSLS     r0,r0,r1
000262  9912              LDR      r1,[sp,#0x48]
000264  4288              CMP      r0,r1
000266  d80c              BHI      |L59.642|
000268  e003              B        |L59.626|
00026a  e05b              B        |L59.804|
00026c  e059              B        |L59.802|
00026e  e049              B        |L59.772|
000270  e01a              B        |L59.680|
                  |L59.626|
000272  a248              ADR      r2,|L59.916|
000274  4649              MOV      r1,r9
000276  f50d5080          ADD      r0,sp,#0x1000
00027a  f8d00080          LDR      r0,[r0,#0x80]
00027e  f7fffffe          BL       luaL_argerror
                  |L59.642|
;;;1490                            len < ((size_t)1 << (size * NB)),
;;;1491                            arg, "string length does not fit in given size");
;;;1492           packint(&b, (lua_Unsigned)len, h.islittle, size, 0);  /* pack length */
000282  2100              MOVS     r1,#0
000284  9a15              LDR      r2,[sp,#0x54]
000286  9818              LDR      r0,[sp,#0x60]
000288  e9cd2101          STRD     r2,r1,[sp,#4]
00028c  9000              STR      r0,[sp,#0]
00028e  460b              MOV      r3,r1
000290  a81a              ADD      r0,sp,#0x68
000292  9a12              LDR      r2,[sp,#0x48]
000294  f7fffffe          BL       packint
;;;1493           luaL_addlstring(&b, s, len);
000298  4621              MOV      r1,r4
00029a  a81a              ADD      r0,sp,#0x68
00029c  9a12              LDR      r2,[sp,#0x48]
00029e  f7fffffe          BL       luaL_addlstring
;;;1494           totalsize += len;
0002a2  9812              LDR      r0,[sp,#0x48]
0002a4  4406              ADD      r6,r6,r0
;;;1495           break;
0002a6  e040              B        |L59.810|
                  |L59.680|
;;;1496         }
;;;1497         case Kzstr: {  /* zero-terminated string */
;;;1498           size_t len;
;;;1499           const char *s = luaL_checklstring(L, arg, &len);
0002a8  aa12              ADD      r2,sp,#0x48
0002aa  4649              MOV      r1,r9
0002ac  f50d5080          ADD      r0,sp,#0x1000
0002b0  f8d00080          LDR      r0,[r0,#0x80]
0002b4  f7fffffe          BL       luaL_checklstring
0002b8  4604              MOV      r4,r0
;;;1500           luaL_argcheck(L, strlen(s) == len, arg, "string contains zeros");
0002ba  4620              MOV      r0,r4
0002bc  f7fffffe          BL       strlen
0002c0  9912              LDR      r1,[sp,#0x48]
0002c2  4288              CMP      r0,r1
0002c4  d007              BEQ      |L59.726|
0002c6  a23e              ADR      r2,|L59.960|
0002c8  4649              MOV      r1,r9
0002ca  f50d5080          ADD      r0,sp,#0x1000
0002ce  f8d00080          LDR      r0,[r0,#0x80]
0002d2  f7fffffe          BL       luaL_argerror
                  |L59.726|
;;;1501           luaL_addlstring(&b, s, len);
0002d6  4621              MOV      r1,r4
0002d8  a81a              ADD      r0,sp,#0x68
0002da  9a12              LDR      r2,[sp,#0x48]
0002dc  f7fffffe          BL       luaL_addlstring
;;;1502           luaL_addchar(&b, '\0');  /* add zero at the end */
0002e0  e9dd011b          LDRD     r0,r1,[sp,#0x6c]
0002e4  4281              CMP      r1,r0
0002e6  d303              BCC      |L59.752|
0002e8  2101              MOVS     r1,#1
0002ea  a81a              ADD      r0,sp,#0x68
0002ec  f7fffffe          BL       luaL_prepbuffsize
                  |L59.752|
0002f0  2200              MOVS     r2,#0
0002f2  9b1c              LDR      r3,[sp,#0x70]
0002f4  1c59              ADDS     r1,r3,#1
0002f6  911c              STR      r1,[sp,#0x70]
0002f8  981a              LDR      r0,[sp,#0x68]
0002fa  54c2              STRB     r2,[r0,r3]
;;;1503           totalsize += len + 1;
0002fc  9812              LDR      r0,[sp,#0x48]
0002fe  1c40              ADDS     r0,r0,#1
000300  4406              ADD      r6,r6,r0
;;;1504           break;
000302  e012              B        |L59.810|
                  |L59.772|
;;;1505         }
;;;1506         case Kpadding: luaL_addchar(&b, LUAL_PACKPADBYTE);  /* FALLTHROUGH */
000304  e9dd011b          LDRD     r0,r1,[sp,#0x6c]
000308  4281              CMP      r1,r0
00030a  d303              BCC      |L59.788|
00030c  2101              MOVS     r1,#1
00030e  a81a              ADD      r0,sp,#0x68
000310  f7fffffe          BL       luaL_prepbuffsize
                  |L59.788|
000314  2200              MOVS     r2,#0
000316  9b1c              LDR      r3,[sp,#0x70]
000318  1c59              ADDS     r1,r3,#1
00031a  911c              STR      r1,[sp,#0x70]
00031c  981a              LDR      r0,[sp,#0x68]
00031e  54c2              STRB     r2,[r0,r3]
;;;1507         case Kpaddalign: case Knop:
000320  bf00              NOP      
                  |L59.802|
000322  bf00              NOP      
                  |L59.804|
;;;1508           arg--;  /* undo increment */
000324  f1a90901          SUB      r9,r9,#1
;;;1509           break;
000328  bf00              NOP      
                  |L59.810|
00032a  bf00              NOP                            ;1454
;;;1510       }
;;;1511     }
00032c  bf00              NOP      
                  |L59.814|
00032e  9816              LDR      r0,[sp,#0x58]         ;1439
000330  7800              LDRB     r0,[r0,#0]            ;1439
000332  2800              CMP      r0,#0                 ;1439
000334  f47fae89          BNE      |L59.74|
;;;1512     luaL_pushresult(&b);
000338  a81a              ADD      r0,sp,#0x68
00033a  f7fffffe          BL       luaL_pushresult
;;;1513     return 1;
00033e  2001              MOVS     r0,#1
;;;1514   }
000340  b021              ADD      sp,sp,#0x84
000342  f50d5d80          ADD      sp,sp,#0x1000
000346  e8bd8ff0          POP      {r4-r11,pc}
;;;1515   
                          ENDP

00034a  0000              DCW      0x0000
                  |L59.844|
00034c  696e7465          DCB      "integer overflow",0
000350  67657220
000354  6f766572
000358  666c6f77
00035c  00      
00035d  00                DCB      0
00035e  00                DCB      0
00035f  00                DCB      0
                  |L59.864|
000360  756e7369          DCB      "unsigned overflow",0
000364  676e6564
000368  206f7665
00036c  72666c6f
000370  7700    
000372  00                DCB      0
000373  00                DCB      0
                  |L59.884|
000374  73747269          DCB      "string longer than given size",0
000378  6e67206c
00037c  6f6e6765
000380  72207468
000384  616e2067
000388  6976656e
00038c  2073697a
000390  6500    
000392  00                DCB      0
000393  00                DCB      0
                  |L59.916|
000394  73747269          DCB      "string length does not fit in given size",0
000398  6e67206c
00039c  656e6774
0003a0  6820646f
0003a4  6573206e
0003a8  6f742066
0003ac  69742069
0003b0  6e206769
0003b4  76656e20
0003b8  73697a65
0003bc  00      
0003bd  00                DCB      0
0003be  00                DCB      0
0003bf  00                DCB      0
                  |L59.960|
0003c0  73747269          DCB      "string contains zeros",0
0003c4  6e672063
0003c8  6f6e7461
0003cc  696e7320
0003d0  7a65726f
0003d4  7300    
0003d6  00                DCB      0
0003d7  00                DCB      0

                          AREA ||i.str_packsize||, CODE, READONLY, ALIGN=2

                  str_packsize PROC
;;;1516   
;;;1517   static int str_packsize (lua_State *L) {
000000  b570              PUSH     {r4-r6,lr}
000002  b088              SUB      sp,sp,#0x20
000004  4605              MOV      r5,r0
;;;1518     Header h;
;;;1519     const char *fmt = luaL_checkstring(L, 1);  /* format string */
000006  2200              MOVS     r2,#0
000008  2101              MOVS     r1,#1
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       luaL_checklstring
000010  9004              STR      r0,[sp,#0x10]
;;;1520     size_t totalsize = 0;  /* accumulate total size of result */
000012  2400              MOVS     r4,#0
;;;1521     initheader(L, &h);
000014  a905              ADD      r1,sp,#0x14
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       initheader
;;;1522     while (*fmt != '\0') {
00001c  e028              B        |L60.112|
                  |L60.30|
;;;1523       int size, ntoalign;
;;;1524       KOption opt = getdetails(&h, totalsize, &fmt, &size, &ntoalign);
00001e  a802              ADD      r0,sp,#8
000020  ab03              ADD      r3,sp,#0xc
000022  aa04              ADD      r2,sp,#0x10
000024  4621              MOV      r1,r4
000026  9000              STR      r0,[sp,#0]
000028  a805              ADD      r0,sp,#0x14
00002a  f7fffffe          BL       getdetails
00002e  4606              MOV      r6,r0
;;;1525       size += ntoalign;  /* total space used by option */
000030  e9dd1002          LDRD     r1,r0,[sp,#8]
000034  4408              ADD      r0,r0,r1
000036  9003              STR      r0,[sp,#0xc]
;;;1526       luaL_argcheck(L, totalsize <= MAXSIZE - size, 1,
000038  f06f4100          MVN      r1,#0x80000000
00003c  9803              LDR      r0,[sp,#0xc]
00003e  1a08              SUBS     r0,r1,r0
000040  42a0              CMP      r0,r4
000042  d204              BCS      |L60.78|
000044  a210              ADR      r2,|L60.136|
000046  2101              MOVS     r1,#1
000048  4628              MOV      r0,r5
00004a  f7fffffe          BL       luaL_argerror
                  |L60.78|
;;;1527                        "format result too large");
;;;1528       totalsize += size;
00004e  9803              LDR      r0,[sp,#0xc]
000050  4404              ADD      r4,r4,r0
;;;1529       switch (opt) {
000052  2e04              CMP      r6,#4
000054  d002              BEQ      |L60.92|
000056  2e05              CMP      r6,#5
000058  d107              BNE      |L60.106|
00005a  e000              B        |L60.94|
                  |L60.92|
;;;1530         case Kstring:  /* strings with length count */
;;;1531         case Kzstr:    /* zero-terminated string */
00005c  bf00              NOP      
                  |L60.94|
;;;1532           luaL_argerror(L, 1, "variable-length format");
00005e  a210              ADR      r2,|L60.160|
000060  2101              MOVS     r1,#1
000062  4628              MOV      r0,r5
000064  f7fffffe          BL       luaL_argerror
;;;1533           /* call never return, but to avoid warnings: *//* FALLTHROUGH */
;;;1534         default:  break;
000068  bf00              NOP      
                  |L60.106|
00006a  bf00              NOP      
00006c  bf00              NOP      
;;;1535       }
;;;1536     }
00006e  bf00              NOP      
                  |L60.112|
000070  9804              LDR      r0,[sp,#0x10]         ;1522
000072  7800              LDRB     r0,[r0,#0]            ;1522
000074  2800              CMP      r0,#0                 ;1522
000076  d1d2              BNE      |L60.30|
;;;1537     lua_pushinteger(L, (lua_Integer)totalsize);
000078  4622              MOV      r2,r4
00007a  2300              MOVS     r3,#0
00007c  4628              MOV      r0,r5
00007e  f7fffffe          BL       lua_pushinteger
;;;1538     return 1;
000082  2001              MOVS     r0,#1
;;;1539   }
000084  b008              ADD      sp,sp,#0x20
000086  bd70              POP      {r4-r6,pc}
;;;1540   
                          ENDP

                  |L60.136|
000088  666f726d          DCB      "format result too large",0
00008c  61742072
000090  6573756c
000094  7420746f
000098  6f206c61
00009c  72676500
                  |L60.160|
0000a0  76617269          DCB      "variable-length format",0
0000a4  61626c65
0000a8  2d6c656e
0000ac  67746820
0000b0  666f726d
0000b4  617400  
0000b7  00                DCB      0

                          AREA ||i.str_rep||, CODE, READONLY, ALIGN=2

                  str_rep PROC
;;;122    
;;;123    static int str_rep (lua_State *L) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  f5ad5d82          SUB      sp,sp,#0x1040
000008  4680              MOV      r8,r0
;;;124      size_t l, lsep;
;;;125      const char *s = luaL_checklstring(L, 1, &l);
00000a  f241023c          MOV      r2,#0x103c
00000e  446a              ADD      r2,r2,sp
000010  2101              MOVS     r1,#1
000012  4640              MOV      r0,r8
000014  f7fffffe          BL       luaL_checklstring
000018  4682              MOV      r10,r0
;;;126      lua_Integer n = luaL_checkinteger(L, 2);
00001a  2102              MOVS     r1,#2
00001c  4640              MOV      r0,r8
00001e  f7fffffe          BL       luaL_checkinteger
000022  4604              MOV      r4,r0
000024  460d              MOV      r5,r1
;;;127      const char *sep = luaL_optlstring(L, 3, "", &lsep);
000026  f2410338          MOV      r3,#0x1038
00002a  446b              ADD      r3,r3,sp
00002c  a23a              ADR      r2,|L61.280|
00002e  2103              MOVS     r1,#3
000030  4640              MOV      r0,r8
000032  f7fffffe          BL       luaL_optlstring
000036  4681              MOV      r9,r0
;;;128      if (n <= 0) lua_pushliteral(L, "");
000038  2100              MOVS     r1,#0
00003a  4608              MOV      r0,r1
00003c  1b09              SUBS     r1,r1,r4
00003e  41a8              SBCS     r0,r0,r5
000040  db04              BLT      |L61.76|
000042  a135              ADR      r1,|L61.280|
000044  4640              MOV      r0,r8
000046  f7fffffe          BL       lua_pushstring
00004a  e063              B        |L61.276|
                  |L61.76|
;;;129      else if (l + lsep < l || l + lsep > MAXSIZE / n)  /* may overflow? */
00004c  f50d5080          ADD      r0,sp,#0x1000
000050  e9d0010e          LDRD     r0,r1,[r0,#0x38]
000054  4401              ADD      r1,r1,r0
000056  f50d5080          ADD      r0,sp,#0x1000
00005a  6bc0              LDR      r0,[r0,#0x3c]
00005c  4281              CMP      r1,r0
00005e  d30f              BCC      |L61.128|
000060  4622              MOV      r2,r4
000062  462b              MOV      r3,r5
000064  f06f4000          MVN      r0,#0x80000000
000068  2100              MOVS     r1,#0
00006a  f7fffffe          BL       __aeabi_ldivmod
00006e  f50d5280          ADD      r2,sp,#0x1000
000072  e9d2230e          LDRD     r2,r3,[r2,#0x38]
000076  441a              ADD      r2,r2,r3
000078  1a80              SUBS     r0,r0,r2
00007a  f1710100          SBCS     r1,r1,#0
00007e  da07              BGE      |L61.144|
                  |L61.128|
;;;130        return luaL_error(L, "resulting string too large");
000080  a126              ADR      r1,|L61.284|
000082  4640              MOV      r0,r8
000084  f7fffffe          BL       luaL_error
                  |L61.136|
;;;131      else {
;;;132        size_t totallen = (size_t)n * l + (size_t)(n - 1) * lsep;
;;;133        luaL_Buffer b;
;;;134        char *p = luaL_buffinitsize(L, &b, totallen);
;;;135        while (n-- > 1) {  /* first n-1 copies (followed by separator) */
;;;136          memcpy(p, s, l * sizeof(char)); p += l;
;;;137          if (lsep > 0) {  /* empty 'memcpy' is not that cheap */
;;;138            memcpy(p, sep, lsep * sizeof(char));
;;;139            p += lsep;
;;;140          }
;;;141        }
;;;142        memcpy(p, s, l * sizeof(char));  /* last copy (not followed by separator) */
;;;143        luaL_pushresultsize(&b, totallen);
;;;144      }
;;;145      return 1;
;;;146    }
000088  f50d5d82          ADD      sp,sp,#0x1040
00008c  e8bd87f0          POP      {r4-r10,pc}
                  |L61.144|
000090  f50d5080          ADD      r0,sp,#0x1000         ;132
000094  6bc0              LDR      r0,[r0,#0x3c]         ;132
000096  fb04f100          MUL      r1,r4,r0              ;132
00009a  1e62              SUBS     r2,r4,#1              ;132
00009c  f50d5080          ADD      r0,sp,#0x1000         ;132
0000a0  6b80              LDR      r0,[r0,#0x38]         ;132
0000a2  fb021700          MLA      r7,r2,r0,r1           ;132
0000a6  463a              MOV      r2,r7                 ;134
0000a8  a90a              ADD      r1,sp,#0x28           ;134
0000aa  4640              MOV      r0,r8                 ;134
0000ac  f7fffffe          BL       luaL_buffinitsize
0000b0  4606              MOV      r6,r0                 ;134
0000b2  e019              B        |L61.232|
                  |L61.180|
0000b4  f50d5080          ADD      r0,sp,#0x1000         ;136
0000b8  4651              MOV      r1,r10                ;136
0000ba  6bc2              LDR      r2,[r0,#0x3c]         ;136
0000bc  4630              MOV      r0,r6                 ;136
0000be  f7fffffe          BL       __aeabi_memcpy
0000c2  f50d5080          ADD      r0,sp,#0x1000         ;136
0000c6  6bc0              LDR      r0,[r0,#0x3c]         ;136
0000c8  4406              ADD      r6,r6,r0              ;136
0000ca  f50d5080          ADD      r0,sp,#0x1000         ;137
0000ce  6b80              LDR      r0,[r0,#0x38]         ;137
0000d0  b150              CBZ      r0,|L61.232|
0000d2  f50d5080          ADD      r0,sp,#0x1000         ;138
0000d6  4649              MOV      r1,r9                 ;138
0000d8  6b82              LDR      r2,[r0,#0x38]         ;138
0000da  4630              MOV      r0,r6                 ;138
0000dc  f7fffffe          BL       __aeabi_memcpy
0000e0  f50d5080          ADD      r0,sp,#0x1000         ;139
0000e4  6b80              LDR      r0,[r0,#0x38]         ;139
0000e6  4406              ADD      r6,r6,r0              ;139
                  |L61.232|
0000e8  4628              MOV      r0,r5                 ;135
0000ea  4621              MOV      r1,r4                 ;135
0000ec  1e64              SUBS     r4,r4,#1              ;135
0000ee  f1650500          SBC      r5,r5,#0              ;135
0000f2  2200              MOVS     r2,#0                 ;135
0000f4  f1d10101          RSBS     r1,r1,#1              ;135
0000f8  4182              SBCS     r2,r2,r0              ;135
0000fa  dbdb              BLT      |L61.180|
0000fc  f50d5080          ADD      r0,sp,#0x1000         ;142
000100  4651              MOV      r1,r10                ;142
000102  6bc2              LDR      r2,[r0,#0x3c]         ;142
000104  4630              MOV      r0,r6                 ;142
000106  f7fffffe          BL       __aeabi_memcpy
00010a  4639              MOV      r1,r7                 ;143
00010c  a80a              ADD      r0,sp,#0x28           ;143
00010e  f7fffffe          BL       luaL_pushresultsize
000112  bf00              NOP                            ;144
                  |L61.276|
000114  2001              MOVS     r0,#1                 ;145
000116  e7b7              B        |L61.136|
;;;147    
                          ENDP

                  |L61.280|
000118  00                DCB      0
000119  00                DCB      0
00011a  00                DCB      0
00011b  00                DCB      0
                  |L61.284|
00011c  72657375          DCB      "resulting string too large",0
000120  6c74696e
000124  67207374
000128  72696e67
00012c  20746f6f
000130  206c6172
000134  676500  
000137  00                DCB      0

                          AREA ||i.str_reverse||, CODE, READONLY, ALIGN=1

                  str_reverse PROC
;;;84     
;;;85     static int str_reverse (lua_State *L) {
000000  b5f0              PUSH     {r4-r7,lr}
000002  b091              SUB      sp,sp,#0x44
000004  f5ad5d80          SUB      sp,sp,#0x1000
000008  4605              MOV      r5,r0
;;;86       size_t l, i;
;;;87       luaL_Buffer b;
;;;88       const char *s = luaL_checklstring(L, 1, &l);
00000a  f50d5282          ADD      r2,sp,#0x1040
00000e  2101              MOVS     r1,#1
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       luaL_checklstring
000016  4606              MOV      r6,r0
;;;89       char *p = luaL_buffinitsize(L, &b, l);
000018  f50d5080          ADD      r0,sp,#0x1000
00001c  a90c              ADD      r1,sp,#0x30
00001e  6c02              LDR      r2,[r0,#0x40]
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       luaL_buffinitsize
000026  4607              MOV      r7,r0
;;;90       for (i = 0; i < l; i++)
000028  2400              MOVS     r4,#0
00002a  e007              B        |L62.60|
                  |L62.44|
;;;91         p[i] = s[l - i - 1];
00002c  f50d5080          ADD      r0,sp,#0x1000
000030  6c00              LDR      r0,[r0,#0x40]
000032  1b00              SUBS     r0,r0,r4
000034  1e40              SUBS     r0,r0,#1
000036  5c30              LDRB     r0,[r6,r0]
000038  5538              STRB     r0,[r7,r4]
00003a  1c64              ADDS     r4,r4,#1              ;90
                  |L62.60|
00003c  f50d5080          ADD      r0,sp,#0x1000         ;90
000040  6c00              LDR      r0,[r0,#0x40]         ;90
000042  4284              CMP      r4,r0                 ;90
000044  d3f2              BCC      |L62.44|
;;;92       luaL_pushresultsize(&b, l);
000046  f50d5080          ADD      r0,sp,#0x1000
00004a  6c01              LDR      r1,[r0,#0x40]
00004c  a80c              ADD      r0,sp,#0x30
00004e  f7fffffe          BL       luaL_pushresultsize
;;;93       return 1;
000052  2001              MOVS     r0,#1
;;;94     }
000054  b011              ADD      sp,sp,#0x44
000056  f50d5d80          ADD      sp,sp,#0x1000
00005a  bdf0              POP      {r4-r7,pc}
;;;95     
                          ENDP


                          AREA ||i.str_sub||, CODE, READONLY, ALIGN=2

                  str_sub PROC
;;;70     
;;;71     static int str_sub (lua_State *L) {
000000  e92d4ff8          PUSH     {r3-r11,lr}
000004  4683              MOV      r11,r0
;;;72       size_t l;
;;;73       const char *s = luaL_checklstring(L, 1, &l);
000006  466a              MOV      r2,sp
000008  2101              MOVS     r1,#1
00000a  4658              MOV      r0,r11
00000c  f7fffffe          BL       luaL_checklstring
000010  4682              MOV      r10,r0
;;;74       lua_Integer start = posrelat(luaL_checkinteger(L, 2), l);
000012  2102              MOVS     r1,#2
000014  4658              MOV      r0,r11
000016  f7fffffe          BL       luaL_checkinteger
00001a  4680              MOV      r8,r0
00001c  9a00              LDR      r2,[sp,#0]
00001e  f7fffffe          BL       posrelat
000022  4604              MOV      r4,r0
000024  460d              MOV      r5,r1
;;;75       lua_Integer end = posrelat(luaL_optinteger(L, 3, -1), l);
000026  f04f32ff          MOV      r2,#0xffffffff
00002a  4613              MOV      r3,r2
00002c  2103              MOVS     r1,#3
00002e  4658              MOV      r0,r11
000030  f7fffffe          BL       luaL_optinteger
000034  4680              MOV      r8,r0
000036  9a00              LDR      r2,[sp,#0]
000038  f7fffffe          BL       posrelat
00003c  4606              MOV      r6,r0
00003e  460f              MOV      r7,r1
;;;76       if (start < 1) start = 1;
000040  1e61              SUBS     r1,r4,#1
000042  f1750000          SBCS     r0,r5,#0
000046  da01              BGE      |L63.76|
000048  2401              MOVS     r4,#1
00004a  2500              MOVS     r5,#0
                  |L63.76|
;;;77       if (end > (lua_Integer)l) end = l;
00004c  2100              MOVS     r1,#0
00004e  9800              LDR      r0,[sp,#0]
000050  1b80              SUBS     r0,r0,r6
000052  41b9              SBCS     r1,r1,r7
000054  da01              BGE      |L63.90|
000056  2700              MOVS     r7,#0
000058  9e00              LDR      r6,[sp,#0]
                  |L63.90|
;;;78       if (start <= end)
00005a  1b30              SUBS     r0,r6,r4
00005c  eb770005          SBCS     r0,r7,r5
000060  db0a              BLT      |L63.120|
;;;79         lua_pushlstring(L, s + start - 1, (size_t)(end - start) + 1);
000062  1b30              SUBS     r0,r6,r4
000064  f1000201          ADD      r2,r0,#1
000068  eb0a0004          ADD      r0,r10,r4
00006c  f1a00101          SUB      r1,r0,#1
000070  4658              MOV      r0,r11
000072  f7fffffe          BL       lua_pushlstring
000076  e003              B        |L63.128|
                  |L63.120|
;;;80       else lua_pushliteral(L, "");
000078  a103              ADR      r1,|L63.136|
00007a  4658              MOV      r0,r11
00007c  f7fffffe          BL       lua_pushstring
                  |L63.128|
;;;81       return 1;
000080  2001              MOVS     r0,#1
;;;82     }
000082  e8bd8ff8          POP      {r3-r11,pc}
;;;83     
                          ENDP

000086  0000              DCW      0x0000
                  |L63.136|
000088  00                DCB      0
000089  00                DCB      0
00008a  00                DCB      0
00008b  00                DCB      0

                          AREA ||i.str_unpack||, CODE, READONLY, ALIGN=2

                  str_unpack PROC
;;;1575   
;;;1576   static int str_unpack (lua_State *L) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  b092              SUB      sp,sp,#0x48
000006  4682              MOV      r10,r0
;;;1577     Header h;
;;;1578     const char *fmt = luaL_checkstring(L, 1);
000008  2200              MOVS     r2,#0
00000a  2101              MOVS     r1,#1
00000c  4650              MOV      r0,r10
00000e  f7fffffe          BL       luaL_checklstring
000012  900d              STR      r0,[sp,#0x34]
;;;1579     size_t ld;
;;;1580     const char *data = luaL_checklstring(L, 2, &ld);
000014  aa0c              ADD      r2,sp,#0x30
000016  2102              MOVS     r1,#2
000018  4650              MOV      r0,r10
00001a  f7fffffe          BL       luaL_checklstring
00001e  4605              MOV      r5,r0
;;;1581     size_t pos = (size_t)posrelat(luaL_optinteger(L, 3, 1), ld) - 1;
000020  2201              MOVS     r2,#1
000022  2300              MOVS     r3,#0
000024  2103              MOVS     r1,#3
000026  4650              MOV      r0,r10
000028  f7fffffe          BL       luaL_optinteger
00002c  4606              MOV      r6,r0
00002e  9a0c              LDR      r2,[sp,#0x30]
000030  f7fffffe          BL       posrelat
000034  1e44              SUBS     r4,r0,#1
;;;1582     int n = 0;  /* number of results */
000036  f04f0800          MOV      r8,#0
;;;1583     luaL_argcheck(L, pos <= ld, 3, "initial position out of string");
00003a  980c              LDR      r0,[sp,#0x30]
00003c  4284              CMP      r4,r0
00003e  d904              BLS      |L64.74|
000040  a258              ADR      r2,|L64.420|
000042  2103              MOVS     r1,#3
000044  4650              MOV      r0,r10
000046  f7fffffe          BL       luaL_argerror
                  |L64.74|
;;;1584     initheader(L, &h);
00004a  a90e              ADD      r1,sp,#0x38
00004c  4650              MOV      r0,r10
00004e  f7fffffe          BL       initheader
;;;1585     while (*fmt != '\0') {
000052  e098              B        |L64.390|
                  |L64.84|
;;;1586       int size, ntoalign;
;;;1587       KOption opt = getdetails(&h, pos, &fmt, &size, &ntoalign);
000054  a80a              ADD      r0,sp,#0x28
000056  ab0b              ADD      r3,sp,#0x2c
000058  aa0d              ADD      r2,sp,#0x34
00005a  4621              MOV      r1,r4
00005c  9000              STR      r0,[sp,#0]
00005e  a80e              ADD      r0,sp,#0x38
000060  f7fffffe          BL       getdetails
000064  4681              MOV      r9,r0
;;;1588       if ((size_t)ntoalign + size > ~pos || pos + ntoalign + size > ld)
000066  e9dd010a          LDRD     r0,r1,[sp,#0x28]
00006a  4408              ADD      r0,r0,r1
00006c  43e1              MVNS     r1,r4
00006e  4288              CMP      r0,r1
000070  d806              BHI      |L64.128|
000072  980a              LDR      r0,[sp,#0x28]
000074  4420              ADD      r0,r0,r4
000076  990b              LDR      r1,[sp,#0x2c]
000078  4408              ADD      r0,r0,r1
00007a  990c              LDR      r1,[sp,#0x30]
00007c  4288              CMP      r0,r1
00007e  d904              BLS      |L64.138|
                  |L64.128|
;;;1589         luaL_argerror(L, 2, "data string too short");
000080  a250              ADR      r2,|L64.452|
000082  2102              MOVS     r1,#2
000084  4650              MOV      r0,r10
000086  f7fffffe          BL       luaL_argerror
                  |L64.138|
;;;1590       pos += ntoalign;  /* skip alignment */
00008a  980a              LDR      r0,[sp,#0x28]
00008c  4404              ADD      r4,r4,r0
;;;1591       /* stack space for item + next position */
;;;1592       luaL_checkstack(L, 2, "too many results");
00008e  a253              ADR      r2,|L64.476|
000090  2102              MOVS     r1,#2
000092  4650              MOV      r0,r10
000094  f7fffffe          BL       luaL_checkstack
;;;1593       n++;
000098  f1080801          ADD      r8,r8,#1
;;;1594       switch (opt) {
00009c  f1b90f09          CMP      r9,#9
0000a0  d26d              BCS      |L64.382|
0000a2  e8dff009          TBB      [pc,r9]
0000a6  0506              DCB      0x05,0x06
0000a8  1b383e5b          DCB      0x1b,0x38,0x3e,0x5b
0000ac  68676900          DCB      0x68,0x67,0x69,0x00
;;;1595         case Kint:
;;;1596         case Kuint: {
0000b0  bf00              NOP      
;;;1597           lua_Integer res = unpackint(L, data + pos, h.islittle, size,
0000b2  f1b90f00          CMP      r9,#0
0000b6  d101              BNE      |L64.188|
0000b8  2001              MOVS     r0,#1
0000ba  e000              B        |L64.190|
                  |L64.188|
0000bc  2000              MOVS     r0,#0
                  |L64.190|
0000be  9000              STR      r0,[sp,#0]
0000c0  1929              ADDS     r1,r5,r4
0000c2  4650              MOV      r0,r10
0000c4  9b0b              LDR      r3,[sp,#0x2c]
0000c6  9a0f              LDR      r2,[sp,#0x3c]
0000c8  f7fffffe          BL       unpackint
0000cc  4606              MOV      r6,r0
0000ce  460f              MOV      r7,r1
;;;1598                                          (opt == Kint));
;;;1599           lua_pushinteger(L, res);
0000d0  4632              MOV      r2,r6
0000d2  463b              MOV      r3,r7
0000d4  4650              MOV      r0,r10
0000d6  f7fffffe          BL       lua_pushinteger
;;;1600           break;
0000da  e050              B        |L64.382|
;;;1601         }
;;;1602         case Kfloat: {
;;;1603           volatile Ftypes u;
;;;1604           lua_Number num;
;;;1605           copywithendian(u.buff, data + pos, size, h.islittle);
0000dc  1929              ADDS     r1,r5,r4
0000de  4668              MOV      r0,sp
0000e0  9b0f              LDR      r3,[sp,#0x3c]
0000e2  9a0b              LDR      r2,[sp,#0x2c]
0000e4  f7fffffe          BL       copywithendian
;;;1606           if (size == sizeof(u.f)) num = (lua_Number)u.f;
0000e8  980b              LDR      r0,[sp,#0x2c]
0000ea  2804              CMP      r0,#4
0000ec  d105              BNE      |L64.250|
0000ee  9800              LDR      r0,[sp,#0]
0000f0  f7fffffe          BL       __aeabi_f2d
0000f4  4606              MOV      r6,r0
0000f6  460f              MOV      r7,r1
0000f8  e007              B        |L64.266|
                  |L64.250|
;;;1607           else if (size == sizeof(u.d)) num = (lua_Number)u.d;
0000fa  980b              LDR      r0,[sp,#0x2c]
0000fc  2808              CMP      r0,#8
0000fe  d102              BNE      |L64.262|
000100  9e00              LDR      r6,[sp,#0]
000102  9f01              LDR      r7,[sp,#4]
000104  e001              B        |L64.266|
                  |L64.262|
;;;1608           else num = u.n;
000106  9e00              LDR      r6,[sp,#0]
000108  9f01              LDR      r7,[sp,#4]
                  |L64.266|
;;;1609           lua_pushnumber(L, num);
00010a  4632              MOV      r2,r6
00010c  463b              MOV      r3,r7
00010e  4650              MOV      r0,r10
000110  f7fffffe          BL       lua_pushnumber
;;;1610           break;
000114  e033              B        |L64.382|
;;;1611         }
;;;1612         case Kchar: {
;;;1613           lua_pushlstring(L, data + pos, size);
000116  1929              ADDS     r1,r5,r4
000118  4650              MOV      r0,r10
00011a  9a0b              LDR      r2,[sp,#0x2c]
00011c  f7fffffe          BL       lua_pushlstring
;;;1614           break;
000120  e02d              B        |L64.382|
;;;1615         }
;;;1616         case Kstring: {
;;;1617           size_t len = (size_t)unpackint(L, data + pos, h.islittle, size, 0);
000122  2000              MOVS     r0,#0
000124  9000              STR      r0,[sp,#0]
000126  1929              ADDS     r1,r5,r4
000128  4650              MOV      r0,r10
00012a  9b0b              LDR      r3,[sp,#0x2c]
00012c  9a0f              LDR      r2,[sp,#0x3c]
00012e  f7fffffe          BL       unpackint
000132  4606              MOV      r6,r0
;;;1618           luaL_argcheck(L, pos + len + size <= ld, 2, "data string too short");
000134  19a0              ADDS     r0,r4,r6
000136  990b              LDR      r1,[sp,#0x2c]
000138  4408              ADD      r0,r0,r1
00013a  990c              LDR      r1,[sp,#0x30]
00013c  4288              CMP      r0,r1
00013e  d904              BLS      |L64.330|
000140  a220              ADR      r2,|L64.452|
000142  2102              MOVS     r1,#2
000144  4650              MOV      r0,r10
000146  f7fffffe          BL       luaL_argerror
                  |L64.330|
;;;1619           lua_pushlstring(L, data + pos + size, len);
00014a  1928              ADDS     r0,r5,r4
00014c  9a0b              LDR      r2,[sp,#0x2c]
00014e  1881              ADDS     r1,r0,r2
000150  4632              MOV      r2,r6
000152  4650              MOV      r0,r10
000154  f7fffffe          BL       lua_pushlstring
;;;1620           pos += len;  /* skip string */
000158  4434              ADD      r4,r4,r6
;;;1621           break;
00015a  e010              B        |L64.382|
;;;1622         }
;;;1623         case Kzstr: {
;;;1624           size_t len = (int)strlen(data + pos);
00015c  1928              ADDS     r0,r5,r4
00015e  f7fffffe          BL       strlen
000162  4606              MOV      r6,r0
;;;1625           lua_pushlstring(L, data + pos, len);
000164  1929              ADDS     r1,r5,r4
000166  4632              MOV      r2,r6
000168  4650              MOV      r0,r10
00016a  f7fffffe          BL       lua_pushlstring
;;;1626           pos += len + 1;  /* skip string plus final '\0' */
00016e  1c70              ADDS     r0,r6,#1
000170  4404              ADD      r4,r4,r0
;;;1627           break;
000172  e004              B        |L64.382|
;;;1628         }
;;;1629         case Kpaddalign: case Kpadding: case Knop:
000174  bf00              NOP      
000176  bf00              NOP      
;;;1630           n--;  /* undo increment */
000178  f1a80801          SUB      r8,r8,#1
;;;1631           break;
00017c  bf00              NOP      
                  |L64.382|
00017e  bf00              NOP                            ;1600
;;;1632       }
;;;1633       pos += size;
000180  980b              LDR      r0,[sp,#0x2c]
000182  4404              ADD      r4,r4,r0
;;;1634     }
000184  bf00              NOP      
                  |L64.390|
000186  980d              LDR      r0,[sp,#0x34]         ;1585
000188  7800              LDRB     r0,[r0,#0]            ;1585
00018a  2800              CMP      r0,#0                 ;1585
00018c  f47faf62          BNE      |L64.84|
;;;1635     lua_pushinteger(L, pos + 1);  /* next position */
000190  1c62              ADDS     r2,r4,#1
000192  2300              MOVS     r3,#0
000194  4650              MOV      r0,r10
000196  f7fffffe          BL       lua_pushinteger
;;;1636     return n + 1;
00019a  f1080001          ADD      r0,r8,#1
;;;1637   }
00019e  b012              ADD      sp,sp,#0x48
0001a0  e8bd87f0          POP      {r4-r10,pc}
;;;1638   
                          ENDP

                  |L64.420|
0001a4  696e6974          DCB      "initial position out of string",0
0001a8  69616c20
0001ac  706f7369
0001b0  74696f6e
0001b4  206f7574
0001b8  206f6620
0001bc  73747269
0001c0  6e6700  
0001c3  00                DCB      0
                  |L64.452|
0001c4  64617461          DCB      "data string too short",0
0001c8  20737472
0001cc  696e6720
0001d0  746f6f20
0001d4  73686f72
0001d8  7400    
0001da  00                DCB      0
0001db  00                DCB      0
                  |L64.476|
0001dc  746f6f20          DCB      "too many results",0
0001e0  6d616e79
0001e4  20726573
0001e8  756c7473
0001ec  00      
0001ed  00                DCB      0
0001ee  00                DCB      0
0001ef  00                DCB      0

                          AREA ||i.str_upper||, CODE, READONLY, ALIGN=1

                  str_upper PROC
;;;109    
;;;110    static int str_upper (lua_State *L) {
000000  b5f0              PUSH     {r4-r7,lr}
000002  b091              SUB      sp,sp,#0x44
000004  f5ad5d80          SUB      sp,sp,#0x1000
000008  4605              MOV      r5,r0
;;;111      size_t l;
;;;112      size_t i;
;;;113      luaL_Buffer b;
;;;114      const char *s = luaL_checklstring(L, 1, &l);
00000a  f50d5282          ADD      r2,sp,#0x1040
00000e  2101              MOVS     r1,#1
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       luaL_checklstring
000016  4606              MOV      r6,r0
;;;115      char *p = luaL_buffinitsize(L, &b, l);
000018  f50d5080          ADD      r0,sp,#0x1000
00001c  a90c              ADD      r1,sp,#0x30
00001e  6c02              LDR      r2,[r0,#0x40]
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       luaL_buffinitsize
000026  4607              MOV      r7,r0
;;;116      for (i=0; i<l; i++)
000028  2400              MOVS     r4,#0
00002a  e005              B        |L65.56|
                  |L65.44|
;;;117        p[i] = toupper(uchar(s[i]));
00002c  5d30              LDRB     r0,[r6,r4]
00002e  f7fffffe          BL       toupper
000032  b240              SXTB     r0,r0
000034  5538              STRB     r0,[r7,r4]
000036  1c64              ADDS     r4,r4,#1              ;116
                  |L65.56|
000038  f50d5080          ADD      r0,sp,#0x1000         ;116
00003c  6c00              LDR      r0,[r0,#0x40]         ;116
00003e  4284              CMP      r4,r0                 ;116
000040  d3f4              BCC      |L65.44|
;;;118      luaL_pushresultsize(&b, l);
000042  f50d5080          ADD      r0,sp,#0x1000
000046  6c01              LDR      r1,[r0,#0x40]
000048  a80c              ADD      r0,sp,#0x30
00004a  f7fffffe          BL       luaL_pushresultsize
;;;119      return 1;
00004e  2001              MOVS     r0,#1
;;;120    }
000050  b011              ADD      sp,sp,#0x44
000052  f50d5d80          ADD      sp,sp,#0x1000
000056  bdf0              POP      {r4-r7,pc}
;;;121    
                          ENDP


                          AREA ||i.tonum||, CODE, READONLY, ALIGN=1

                  tonum PROC
;;;209    
;;;210    static int tonum (lua_State *L, int arg) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;211      if (lua_type(L, arg) == LUA_TNUMBER) {  /* already a number? */
000006  4631              MOV      r1,r6
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       lua_type
00000e  2803              CMP      r0,#3
000010  d105              BNE      |L66.30|
;;;212        lua_pushvalue(L, arg);
000012  4631              MOV      r1,r6
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       lua_pushvalue
;;;213        return 1;
00001a  2001              MOVS     r0,#1
                  |L66.28|
;;;214      }
;;;215      else {  /* check whether it is a numerical string */
;;;216        size_t len;
;;;217        const char *s = lua_tolstring(L, arg, &len);
;;;218        return (s != NULL && lua_stringtonumber(L, s) == len + 1);
;;;219      }
;;;220    }
00001c  bdf8              POP      {r3-r7,pc}
                  |L66.30|
00001e  466a              MOV      r2,sp                 ;217
000020  4631              MOV      r1,r6                 ;217
000022  4628              MOV      r0,r5                 ;217
000024  f7fffffe          BL       lua_tolstring
000028  4604              MOV      r4,r0                 ;217
00002a  b14c              CBZ      r4,|L66.64|
00002c  4621              MOV      r1,r4                 ;218
00002e  4628              MOV      r0,r5                 ;218
000030  f7fffffe          BL       lua_stringtonumber
000034  9900              LDR      r1,[sp,#0]            ;218
000036  1c49              ADDS     r1,r1,#1              ;218
000038  4288              CMP      r0,r1                 ;218
00003a  d101              BNE      |L66.64|
00003c  2001              MOVS     r0,#1                 ;218
00003e  e7ed              B        |L66.28|
                  |L66.64|
000040  2000              MOVS     r0,#0                 ;218
000042  e7eb              B        |L66.28|
;;;221    
                          ENDP


                          AREA ||i.trymt||, CODE, READONLY, ALIGN=2

                  trymt PROC
;;;222    
;;;223    static void trymt (lua_State *L, const char *mtname) {
000000  e92d43f8          PUSH     {r3-r9,lr}
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;224      lua_settop(L, 2);  /* back to the original arguments */
000008  2102              MOVS     r1,#2
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       lua_settop
;;;225      if (lua_type(L, 2) == LUA_TSTRING || !luaL_getmetafield(L, 2, mtname))
000010  2102              MOVS     r1,#2
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       lua_type
000018  2804              CMP      r0,#4
00001a  d005              BEQ      |L67.40|
00001c  4622              MOV      r2,r4
00001e  2102              MOVS     r1,#2
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       luaL_getmetafield
000026  b9e0              CBNZ     r0,|L67.98|
                  |L67.40|
;;;226        luaL_error(L, "attempt to %s a '%s' with a '%s'", mtname + 2,
000028  f04f31ff          MOV      r1,#0xffffffff
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       lua_type
000032  4680              MOV      r8,r0
000034  4641              MOV      r1,r8
000036  4628              MOV      r0,r5
000038  f7fffffe          BL       lua_typename
00003c  4606              MOV      r6,r0
00003e  f06f0101          MVN      r1,#1
000042  4628              MOV      r0,r5
000044  f7fffffe          BL       lua_type
000048  4680              MOV      r8,r0
00004a  4641              MOV      r1,r8
00004c  4628              MOV      r0,r5
00004e  f7fffffe          BL       lua_typename
000052  4607              MOV      r7,r0
000054  463b              MOV      r3,r7
000056  1ca2              ADDS     r2,r4,#2
000058  a109              ADR      r1,|L67.128|
00005a  4628              MOV      r0,r5
00005c  9600              STR      r6,[sp,#0]
00005e  f7fffffe          BL       luaL_error
                  |L67.98|
;;;227                      luaL_typename(L, -2), luaL_typename(L, -1));
;;;228      lua_insert(L, -3);  /* put metamethod before arguments */
000062  2201              MOVS     r2,#1
000064  1f11              SUBS     r1,r2,#4
000066  4628              MOV      r0,r5
000068  f7fffffe          BL       lua_rotate
;;;229      lua_call(L, 2, 1);  /* call metamethod */
00006c  2000              MOVS     r0,#0
00006e  4603              MOV      r3,r0
000070  2201              MOVS     r2,#1
000072  2102              MOVS     r1,#2
000074  9000              STR      r0,[sp,#0]
000076  4628              MOV      r0,r5
000078  f7fffffe          BL       lua_callk
;;;230    }
00007c  e8bd83f8          POP      {r3-r9,pc}
;;;231    
                          ENDP

                  |L67.128|
000080  61747465          DCB      "attempt to %s a '%s' with a '%s'",0
000084  6d707420
000088  746f2025
00008c  73206120
000090  27257327
000094  20776974
000098  68206120
00009c  27257327
0000a0  00      
0000a1  00                DCB      0
0000a2  00                DCB      0
0000a3  00                DCB      0

                          AREA ||i.unpackint||, CODE, READONLY, ALIGN=2

                  unpackint PROC
;;;1549   */
;;;1550   static lua_Integer unpackint (lua_State *L, const char *str,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1551                                 int islittle, int size, int issigned) {
000004  b083              SUB      sp,sp,#0xc
000006  468a              MOV      r10,r1
000008  4693              MOV      r11,r2
00000a  461c              MOV      r4,r3
;;;1552     lua_Unsigned res = 0;
00000c  2000              MOVS     r0,#0
00000e  4605              MOV      r5,r0
000010  4606              MOV      r6,r0
;;;1553     int i;
;;;1554     int limit = (size  <= SZINT) ? size : SZINT;
000012  2c08              CMP      r4,#8
000014  dc01              BGT      |L68.26|
000016  4620              MOV      r0,r4
000018  e000              B        |L68.28|
                  |L68.26|
00001a  2008              MOVS     r0,#8
                  |L68.28|
00001c  9000              STR      r0,[sp,#0]
;;;1555     for (i = limit - 1; i >= 0; i--) {
00001e  9800              LDR      r0,[sp,#0]
000020  f1a00901          SUB      r9,r0,#1
000024  e010              B        |L68.72|
                  |L68.38|
;;;1556       res <<= NB;
000026  0230              LSLS     r0,r6,#8
000028  ea406615          ORR      r6,r0,r5,LSR #24
00002c  022d              LSLS     r5,r5,#8
;;;1557       res |= (lua_Unsigned)(unsigned char)str[islittle ? i : size - 1 - i];
00002e  f1bb0f00          CMP      r11,#0
000032  d001              BEQ      |L68.56|
000034  4648              MOV      r0,r9
000036  e002              B        |L68.62|
                  |L68.56|
000038  1e60              SUBS     r0,r4,#1
00003a  eba00009          SUB      r0,r0,r9
                  |L68.62|
00003e  f81a0000          LDRB     r0,[r10,r0]
000042  4305              ORRS     r5,r5,r0
000044  f1a90901          SUB      r9,r9,#1              ;1555
                  |L68.72|
000048  f1b90f00          CMP      r9,#0                 ;1555
00004c  daeb              BGE      |L68.38|
;;;1558     }
;;;1559     if (size < SZINT) {  /* real size smaller than lua_Integer? */
00004e  2c08              CMP      r4,#8
000050  da17              BGE      |L68.130|
;;;1560       if (issigned) {  /* needs sign extension? */
000052  9810              LDR      r0,[sp,#0x40]
000054  2800              CMP      r0,#0
000056  d03b              BEQ      |L68.208|
;;;1561         lua_Unsigned mask = (lua_Unsigned)1 << (size*NB - 1);
000058  2001              MOVS     r0,#1
00005a  ebc002c4          RSB      r2,r0,r4,LSL #3
00005e  4601              MOV      r1,r0
000060  2000              MOVS     r0,#0
000062  e9cd0101          STRD     r0,r1,[sp,#4]
000066  4608              MOV      r0,r1
000068  9901              LDR      r1,[sp,#4]
00006a  f7fffffe          BL       __aeabi_llsl
00006e  4607              MOV      r7,r0
000070  4688              MOV      r8,r1
;;;1562         res = ((res ^ mask) - mask);  /* do sign extension */
000072  ea850007          EOR      r0,r5,r7
000076  ea860108          EOR      r1,r6,r8
00007a  1bc5              SUBS     r5,r0,r7
00007c  eb610608          SBC      r6,r1,r8
;;;1563       }
000080  e026              B        |L68.208|
                  |L68.130|
;;;1564     }
;;;1565     else if (size > SZINT) {  /* must check unread bytes */
000082  2c08              CMP      r4,#8
000084  dd24              BLE      |L68.208|
;;;1566       int mask = (!issigned || (lua_Integer)res >= 0) ? 0 : MC;
000086  9810              LDR      r0,[sp,#0x40]
000088  b128              CBZ      r0,|L68.150|
00008a  2100              MOVS     r1,#0
00008c  4608              MOV      r0,r1
00008e  1a69              SUBS     r1,r5,r1
000090  eb760000          SBCS     r0,r6,r0
000094  db01              BLT      |L68.154|
                  |L68.150|
000096  2000              MOVS     r0,#0
000098  e000              B        |L68.156|
                  |L68.154|
00009a  20ff              MOVS     r0,#0xff
                  |L68.156|
00009c  4607              MOV      r7,r0
;;;1567       for (i = limit; i < size; i++) {
00009e  f8dd9000          LDR      r9,[sp,#0]
0000a2  e012              B        |L68.202|
                  |L68.164|
;;;1568         if ((unsigned char)str[islittle ? i : size - 1 - i] != mask)
0000a4  f1bb0f00          CMP      r11,#0
0000a8  d001              BEQ      |L68.174|
0000aa  4648              MOV      r0,r9
0000ac  e002              B        |L68.180|
                  |L68.174|
0000ae  1e60              SUBS     r0,r4,#1
0000b0  eba00009          SUB      r0,r0,r9
                  |L68.180|
0000b4  f81a0000          LDRB     r0,[r10,r0]
0000b8  42b8              CMP      r0,r7
0000ba  d004              BEQ      |L68.198|
;;;1569           luaL_error(L, "%d-byte integer does not fit into Lua Integer", size);
0000bc  4622              MOV      r2,r4
0000be  a107              ADR      r1,|L68.220|
0000c0  9803              LDR      r0,[sp,#0xc]
0000c2  f7fffffe          BL       luaL_error
                  |L68.198|
0000c6  f1090901          ADD      r9,r9,#1              ;1567
                  |L68.202|
0000ca  45a1              CMP      r9,r4                 ;1567
0000cc  dbea              BLT      |L68.164|
;;;1570       }
;;;1571     }
0000ce  bf00              NOP      
                  |L68.208|
;;;1572     return (lua_Integer)res;
0000d0  4628              MOV      r0,r5
0000d2  4631              MOV      r1,r6
;;;1573   }
0000d4  b007              ADD      sp,sp,#0x1c
0000d6  e8bd8ff0          POP      {r4-r11,pc}
;;;1574   
                          ENDP

0000da  0000              DCW      0x0000
                  |L68.220|
0000dc  25642d62          DCB      "%d-byte integer does not fit into Lua Integer",0
0000e0  79746520
0000e4  696e7465
0000e8  67657220
0000ec  646f6573
0000f0  206e6f74
0000f4  20666974
0000f8  20696e74
0000fc  6f204c75
000100  6120496e
000104  74656765
000108  7200    
00010a  00                DCB      0
00010b  00                DCB      0

                          AREA ||i.writer||, CODE, READONLY, ALIGN=1

                  writer PROC
;;;182    
;;;183    static int writer (lua_State *L, const void *b, size_t size, void *B) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461c              MOV      r4,r3
;;;184      (void)L;
;;;185      luaL_addlstring((luaL_Buffer *) B, (const char *)b, size);
00000c  4632              MOV      r2,r6
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       luaL_addlstring
;;;186      return 0;
000016  2000              MOVS     r0,#0
;;;187    }
000018  e8bd81f0          POP      {r4-r8,pc}
;;;188    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  stringmetamethods
                          DCD      ||.conststring||
                          DCD      arith_add
                          DCD      ||.conststring||+0x8
                          DCD      arith_sub
                          DCD      ||.conststring||+0x10
                          DCD      arith_mul
                          DCD      ||.conststring||+0x18
                          DCD      arith_mod
                          DCD      ||.conststring||+0x20
                          DCD      arith_pow
                          DCD      ||.conststring||+0x28
                          DCD      arith_div
                          DCD      ||.conststring||+0x30
                          DCD      arith_idiv
                          DCD      ||.conststring||+0x38
                          DCD      arith_unm
                          DCD      ||.conststring||+0x40
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                  nativeendian
                          DCD      0x00000001
                  strlib
                          DCD      ||.conststring||+0x48
                          DCD      str_byte
                          DCD      ||.conststring||+0x50
                          DCD      str_char
                          DCD      ||.conststring||+0x58
                          DCD      str_dump
                          DCD      ||.conststring||+0x60
                          DCD      str_find
                          DCD      ||.conststring||+0x68
                          DCD      str_format
                          DCD      ||.conststring||+0x70
                          DCD      gmatch
                          DCD      ||.conststring||+0x78
                          DCD      str_gsub
                          DCD      ||.conststring||+0x80
                          DCD      str_len
                          DCD      ||.conststring||+0x84
                          DCD      str_lower
                          DCD      ||.conststring||+0x8c
                          DCD      str_match
                          DCD      ||.conststring||+0x94
                          DCD      str_rep
                          DCD      ||.conststring||+0x98
                          DCD      str_reverse
                          DCD      ||.conststring||+0xa0
                          DCD      str_sub
                          DCD      ||.conststring||+0xa4
                          DCD      str_upper
                          DCD      ||.conststring||+0xac
                          DCD      str_pack
                          DCD      ||.conststring||+0xb4
                          DCD      str_packsize
                          DCD      ||.conststring||+0xc0
                          DCD      str_unpack
                          DCD      0x00000000
                          DCD      0x00000000

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  5f5f6164          DCB      "__add",0
000004  6400    
000006  00                DCB      0
000007  00                DCB      0
000008  5f5f7375          DCB      "__sub",0
00000c  6200    
00000e  00                DCB      0
00000f  00                DCB      0
000010  5f5f6d75          DCB      "__mul",0
000014  6c00    
000016  00                DCB      0
000017  00                DCB      0
000018  5f5f6d6f          DCB      "__mod",0
00001c  6400    
00001e  00                DCB      0
00001f  00                DCB      0
000020  5f5f706f          DCB      "__pow",0
000024  7700    
000026  00                DCB      0
000027  00                DCB      0
000028  5f5f6469          DCB      "__div",0
00002c  7600    
00002e  00                DCB      0
00002f  00                DCB      0
000030  5f5f6964          DCB      "__idiv",0
000034  697600  
000037  00                DCB      0
000038  5f5f756e          DCB      "__unm",0
00003c  6d00    
00003e  00                DCB      0
00003f  00                DCB      0
000040  5f5f696e          DCB      "__index",0
000044  64657800
000048  62797465          DCB      "byte",0
00004c  00      
00004d  00                DCB      0
00004e  00                DCB      0
00004f  00                DCB      0
000050  63686172          DCB      "char",0
000054  00      
000055  00                DCB      0
000056  00                DCB      0
000057  00                DCB      0
000058  64756d70          DCB      "dump",0
00005c  00      
00005d  00                DCB      0
00005e  00                DCB      0
00005f  00                DCB      0
000060  66696e64          DCB      "find",0
000064  00      
000065  00                DCB      0
000066  00                DCB      0
000067  00                DCB      0
000068  666f726d          DCB      "format",0
00006c  617400  
00006f  00                DCB      0
000070  676d6174          DCB      "gmatch",0
000074  636800  
000077  00                DCB      0
000078  67737562          DCB      "gsub",0
00007c  00      
00007d  00                DCB      0
00007e  00                DCB      0
00007f  00                DCB      0
000080  6c656e00          DCB      "len",0
000084  6c6f7765          DCB      "lower",0
000088  7200    
00008a  00                DCB      0
00008b  00                DCB      0
00008c  6d617463          DCB      "match",0
000090  6800    
000092  00                DCB      0
000093  00                DCB      0
000094  72657000          DCB      "rep",0
000098  72657665          DCB      "reverse",0
00009c  72736500
0000a0  73756200          DCB      "sub",0
0000a4  75707065          DCB      "upper",0
0000a8  7200    
0000aa  00                DCB      0
0000ab  00                DCB      0
0000ac  7061636b          DCB      "pack",0
0000b0  00      
0000b1  00                DCB      0
0000b2  00                DCB      0
0000b3  00                DCB      0
0000b4  7061636b          DCB      "packsize",0
0000b8  73697a65
0000bc  00      
0000bd  00                DCB      0
0000be  00                DCB      0
0000bf  00                DCB      0
0000c0  756e7061          DCB      "unpack",0
0000c4  636b00  
