; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\lcode.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\lcode.d --cpu=Cortex-M7 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Inc -I.\Source -I.\Drivers -I..\..\..\M6P1(L)_Lua\lua -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6-ALIENTEK-LUA\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER -Dlua_writestring=RMP_lua_writestring -Dlua_writeline=RMP_lua_writeline --enum_is_int --signed_chars --omf_browse=.\debug\output\lcode.crf ..\..\..\M6P1(L)_Lua\lua\lcode.c]
                          THUMB

                          AREA ||i.addk||, CODE, READONLY, ALIGN=2

                  addk PROC
;;;506    */
;;;507    static int addk (FuncState *fs, TValue *key, TValue *v) {
000000  e92d4ffe          PUSH     {r1-r11,lr}
000004  4606              MOV      r6,r0
000006  468a              MOV      r10,r1
000008  4617              MOV      r7,r2
;;;508      lua_State *L = fs->ls->L;
00000a  68b0              LDR      r0,[r6,#8]
00000c  f8d0b034          LDR      r11,[r0,#0x34]
;;;509      Proto *f = fs->f;
000010  6834              LDR      r4,[r6,#0]
;;;510      TValue *idx = luaH_set(L, fs->ls->h, key);  /* index scanner table */
000012  68b0              LDR      r0,[r6,#8]
000014  4652              MOV      r2,r10
000016  6c01              LDR      r1,[r0,#0x40]
000018  4658              MOV      r0,r11
00001a  f7fffffe          BL       luaH_set
00001e  4680              MOV      r8,r0
;;;511      int k, oldsize;
;;;512      if (ttisinteger(idx)) {  /* is there an index there? */
000020  f8980008          LDRB     r0,[r8,#8]
000024  2823              CMP      r0,#0x23
000026  d11a              BNE      |L1.94|
;;;513        k = cast_int(ivalue(idx));
000028  f8d85000          LDR      r5,[r8,#0]
;;;514        /* correct value? (warning: must distinguish floats from integers!) */
;;;515        if (k < fs->nk && ttypetag(&f->k[k]) == ttypetag(v) &&
00002c  69f0              LDR      r0,[r6,#0x1c]
00002e  42a8              CMP      r0,r5
000030  dd15              BLE      |L1.94|
000032  6b20              LDR      r0,[r4,#0x30]
000034  eb001005          ADD      r0,r0,r5,LSL #4
000038  7a00              LDRB     r0,[r0,#8]
00003a  f000003f          AND      r0,r0,#0x3f
00003e  7a39              LDRB     r1,[r7,#8]
000040  f001013f          AND      r1,r1,#0x3f
000044  4288              CMP      r0,r1
000046  d10a              BNE      |L1.94|
;;;516                          luaV_rawequalobj(&f->k[k], v))
000048  6b20              LDR      r0,[r4,#0x30]
00004a  eb001105          ADD      r1,r0,r5,LSL #4
00004e  463a              MOV      r2,r7
000050  2000              MOVS     r0,#0
000052  f7fffffe          BL       luaV_equalobj
000056  b110              CBZ      r0,|L1.94|
;;;517          return k;  /* reuse index */
000058  4628              MOV      r0,r5
                  |L1.90|
;;;518      }
;;;519      /* constant not found; create a new entry */
;;;520      oldsize = f->sizek;
;;;521      k = fs->nk;
;;;522      /* numerical value does not need GC barrier;
;;;523         table has no metatable, so it does not need to invalidate cache */
;;;524      setivalue(idx, k);
;;;525      luaM_growvector(L, f->k, k, f->sizek, TValue, MAXARG_Ax, "constants");
;;;526      while (oldsize < f->sizek) setnilvalue(&f->k[oldsize++]);
;;;527      setobj(L, &f->k[k], v);
;;;528      fs->nk++;
;;;529      luaC_barrier(L, f, v);
;;;530      return k;
;;;531    }
00005a  e8bd8ffe          POP      {r1-r11,pc}
                  |L1.94|
00005e  f8d49010          LDR      r9,[r4,#0x10]         ;520
000062  69f5              LDR      r5,[r6,#0x1c]         ;521
000064  4640              MOV      r0,r8                 ;524
000066  17e9              ASRS     r1,r5,#31             ;524
000068  e9c05100          STRD     r5,r1,[r0,#0]         ;524
00006c  2123              MOVS     r1,#0x23              ;524
00006e  7201              STRB     r1,[r0,#8]            ;524
000070  a01e              ADR      r0,|L1.236|
000072  f06f417e          MVN      r1,#0xfe000000        ;525
000076  2210              MOVS     r2,#0x10              ;525
000078  e9cd2100          STRD     r2,r1,[sp,#0]         ;525
00007c  9002              STR      r0,[sp,#8]            ;525
00007e  f1040310          ADD      r3,r4,#0x10           ;525
000082  462a              MOV      r2,r5                 ;525
000084  4658              MOV      r0,r11                ;525
000086  6b21              LDR      r1,[r4,#0x30]         ;525
000088  f7fffffe          BL       luaM_growaux_
00008c  6320              STR      r0,[r4,#0x30]         ;525
00008e  e007              B        |L1.160|
                  |L1.144|
000090  2200              MOVS     r2,#0                 ;526
000092  4648              MOV      r0,r9                 ;526
000094  f1090901          ADD      r9,r9,#1              ;526
000098  6b23              LDR      r3,[r4,#0x30]         ;526
00009a  eb031000          ADD      r0,r3,r0,LSL #4       ;526
00009e  7202              STRB     r2,[r0,#8]            ;526
                  |L1.160|
0000a0  6920              LDR      r0,[r4,#0x10]         ;526
0000a2  4548              CMP      r0,r9                 ;526
0000a4  dcf4              BGT      |L1.144|
0000a6  6b22              LDR      r2,[r4,#0x30]         ;527
0000a8  eb021005          ADD      r0,r2,r5,LSL #4       ;527
0000ac  4639              MOV      r1,r7                 ;527
0000ae  e9d12300          LDRD     r2,r3,[r1,#0]         ;527
0000b2  e9c02300          STRD     r2,r3,[r0,#0]         ;527
0000b6  7a0a              LDRB     r2,[r1,#8]            ;527
0000b8  7202              STRB     r2,[r0,#8]            ;527
0000ba  69f0              LDR      r0,[r6,#0x1c]         ;528
0000bc  1c40              ADDS     r0,r0,#1              ;528
0000be  61f0              STR      r0,[r6,#0x1c]         ;528
0000c0  7a38              LDRB     r0,[r7,#8]            ;529
0000c2  f0000040          AND      r0,r0,#0x40           ;529
0000c6  b170              CBZ      r0,|L1.230|
0000c8  7960              LDRB     r0,[r4,#5]            ;529
0000ca  f0000020          AND      r0,r0,#0x20           ;529
0000ce  b150              CBZ      r0,|L1.230|
0000d0  6838              LDR      r0,[r7,#0]            ;529
0000d2  7940              LDRB     r0,[r0,#5]            ;529
0000d4  f0000018          AND      r0,r0,#0x18           ;529
0000d8  b128              CBZ      r0,|L1.230|
0000da  4621              MOV      r1,r4                 ;529
0000dc  4658              MOV      r0,r11                ;529
0000de  683a              LDR      r2,[r7,#0]            ;529
0000e0  f7fffffe          BL       luaC_barrier_
0000e4  e000              B        |L1.232|
                  |L1.230|
0000e6  bf00              NOP                            ;529
                  |L1.232|
0000e8  4628              MOV      r0,r5                 ;530
0000ea  e7b6              B        |L1.90|
;;;532    
                          ENDP

                  |L1.236|
0000ec  636f6e73          DCB      "constants",0
0000f0  74616e74
0000f4  7300    
0000f6  00                DCB      0
0000f7  00                DCB      0

                          AREA ||i.boolK||, CODE, READONLY, ALIGN=1

                  boolK PROC
;;;569    */
;;;570    static int boolK (FuncState *fs, int b) {
000000  b57f              PUSH     {r0-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;571      TValue o;
;;;572      setbvalue(&o, b);
000006  4668              MOV      r0,sp
000008  6004              STR      r4,[r0,#0]
00000a  2101              MOVS     r1,#1
00000c  7201              STRB     r1,[r0,#8]
;;;573      return addk(fs, &o, &o);  /* use boolean itself as key */
00000e  466a              MOV      r2,sp
000010  4669              MOV      r1,sp
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       addk
;;;574    }
000018  b004              ADD      sp,sp,#0x10
00001a  bd70              POP      {r4-r6,pc}
;;;575    
                          ENDP


                          AREA ||i.codeABRK||, CODE, READONLY, ALIGN=1

                  codeABRK PROC
;;;911    
;;;912    static void codeABRK (FuncState *fs, OpCode o, int a, int b,
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;913                          expdesc *ec) {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  9c0a              LDR      r4,[sp,#0x28]
;;;914      int k = luaK_exp2RK(fs, ec);
00000e  4621              MOV      r1,r4
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       luaK_exp2RK
000016  4681              MOV      r9,r0
;;;915      luaK_codeABCk(fs, o, a, b, ec->u.info, k);
000018  68a0              LDR      r0,[r4,#8]
00001a  4643              MOV      r3,r8
00001c  463a              MOV      r2,r7
00001e  4631              MOV      r1,r6
000020  e9cd0900          STRD     r0,r9,[sp,#0]
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       luaK_codeABCk
;;;916    }
00002a  e8bd87fc          POP      {r2-r10,pc}
;;;917    
                          ENDP


                          AREA ||i.code_loadbool||, CODE, READONLY, ALIGN=1

                  code_loadbool PROC
;;;781    
;;;782    static int code_loadbool (FuncState *fs, int A, int b, int jump) {
000000  e92d41fc          PUSH     {r2-r8,lr}
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
;;;783      luaK_getlabel(fs);  /* those instructions may be jump targets */
00000c  4638              MOV      r0,r7
00000e  f7fffffe          BL       luaK_getlabel
;;;784      return luaK_codeABC(fs, OP_LOADBOOL, A, b, jump);
000012  2000              MOVS     r0,#0
000014  462b              MOV      r3,r5
000016  4622              MOV      r2,r4
000018  2105              MOVS     r1,#5
00001a  e9cd6000          STRD     r6,r0,[sp,#0]
00001e  4638              MOV      r0,r7
000020  f7fffffe          BL       luaK_codeABCk
;;;785    }
000024  e8bd81fc          POP      {r2-r8,pc}
;;;786    
                          ENDP


                          AREA ||i.codearith||, CODE, READONLY, ALIGN=1

                  codearith PROC
;;;1275   */
;;;1276   static void codearith (FuncState *fs, OpCode op,
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;1277                          expdesc *e1, expdesc *e2, int flip, int line) {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4690              MOV      r8,r2
00000a  461d              MOV      r5,r3
00000c  e9dd960a          LDRD     r9,r6,[sp,#0x28]
;;;1278     if (!isSCint(e2))
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       isSCint
000016  b938              CBNZ     r0,|L5.40|
;;;1279       codebinexpval(fs, op, e1, e2, line);  /* use standard operators */
000018  462b              MOV      r3,r5
00001a  4642              MOV      r2,r8
00001c  4621              MOV      r1,r4
00001e  4638              MOV      r0,r7
000020  9600              STR      r6,[sp,#0]
000022  f7fffffe          BL       codebinexpval
000026  e008              B        |L5.58|
                  |L5.40|
;;;1280     else  /* use immediate operators */
;;;1281       codebini(fs, cast(OpCode, op - OP_ADD + OP_ADDI), e1, e2, flip, line);
000028  f1a4010c          SUB      r1,r4,#0xc
00002c  462b              MOV      r3,r5
00002e  4642              MOV      r2,r8
000030  4638              MOV      r0,r7
000032  e9cd9600          STRD     r9,r6,[sp,#0]
000036  f7fffffe          BL       codebini
                  |L5.58|
;;;1282   }
00003a  e8bd87fc          POP      {r2-r10,pc}
;;;1283   
                          ENDP


                          AREA ||i.codebinexpval||, CODE, READONLY, ALIGN=1

                  codebinexpval PROC
;;;1249   */
;;;1250   static void codebinexpval (FuncState *fs, OpCode op,
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;1251                              expdesc *e1, expdesc *e2, int line) {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
00000a  461c              MOV      r4,r3
00000c  f8dd8030          LDR      r8,[sp,#0x30]
;;;1252     int v2 = luaK_exp2anyreg(fs, e2);  /* both operands are in registers */
000010  4621              MOV      r1,r4
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       luaK_exp2anyreg
000018  4681              MOV      r9,r0
;;;1253     int v1 = luaK_exp2anyreg(fs, e1);
00001a  4629              MOV      r1,r5
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       luaK_exp2anyreg
000022  4683              MOV      r11,r0
;;;1254     int pc = luaK_codeABC(fs, op, 0, v1, v2);  /* generate opcode */
000024  2000              MOVS     r0,#0
000026  465b              MOV      r3,r11
000028  4602              MOV      r2,r0
00002a  4639              MOV      r1,r7
00002c  e9cd9000          STRD     r9,r0,[sp,#0]
000030  4630              MOV      r0,r6
000032  f7fffffe          BL       luaK_codeABCk
000036  4682              MOV      r10,r0
;;;1255     finishbinexpval(fs, e1, e2, pc, line);
000038  4653              MOV      r3,r10
00003a  4622              MOV      r2,r4
00003c  4629              MOV      r1,r5
00003e  4630              MOV      r0,r6
000040  f8cd8000          STR      r8,[sp,#0]
000044  f7fffffe          BL       finishbinexpval
;;;1256   }
000048  e8bd9ffc          POP      {r2-r12,pc}
;;;1257   
                          ENDP


                          AREA ||i.codebini||, CODE, READONLY, ALIGN=1

                  codebini PROC
;;;1261   */
;;;1262   static void codebini (FuncState *fs, OpCode op,
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;1263                          expdesc *e1, expdesc *e2, int k, int line) {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
00000a  461c              MOV      r4,r3
00000c  e9dd890c          LDRD     r8,r9,[sp,#0x30]
;;;1264     int v2 = cast_int(e2->u.ival);  /* immediate operand */
000010  f8d4a008          LDR      r10,[r4,#8]
;;;1265     int v1 = luaK_exp2anyreg(fs, e1);
000014  4629              MOV      r1,r5
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       luaK_exp2anyreg
00001c  9002              STR      r0,[sp,#8]
;;;1266     int pc = codeABsC(fs, op, 0, v1, v2, k);  /* generate opcode */
00001e  f10a007f          ADD      r0,r10,#0x7f
000022  e9cd0800          STRD     r0,r8,[sp,#0]
000026  2200              MOVS     r2,#0
000028  4639              MOV      r1,r7
00002a  4630              MOV      r0,r6
00002c  9b02              LDR      r3,[sp,#8]
00002e  f7fffffe          BL       luaK_codeABCk
000032  4683              MOV      r11,r0
;;;1267     finishbinexpval(fs, e1, e2, pc, line);
000034  465b              MOV      r3,r11
000036  4622              MOV      r2,r4
000038  4629              MOV      r1,r5
00003a  4630              MOV      r0,r6
00003c  f8cd9000          STR      r9,[sp,#0]
000040  f7fffffe          BL       finishbinexpval
;;;1268   }
000044  e8bd8ffe          POP      {r1-r11,pc}
;;;1269   
                          ENDP


                          AREA ||i.codebitwise||, CODE, READONLY, ALIGN=1

                  codebitwise PROC
;;;1308   */
;;;1309   static void codebitwise (FuncState *fs, BinOpr opr,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1310                            expdesc *e1, expdesc *e2, int line) {
000004  b083              SUB      sp,sp,#0xc
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
00000a  461c              MOV      r4,r3
00000c  f8dd8040          LDR      r8,[sp,#0x40]
;;;1311     int inv = 0;
000010  f04f0b00          MOV      r11,#0
;;;1312     int v1, v2, pc;
;;;1313     OpCode op;
;;;1314     if (e1->k == VKINT && luaK_exp2RK(fs, e1)) {
000014  6828              LDR      r0,[r5,#0]
000016  2806              CMP      r0,#6
000018  d10b              BNE      |L8.50|
00001a  4629              MOV      r1,r5
00001c  9803              LDR      r0,[sp,#0xc]
00001e  f7fffffe          BL       luaK_exp2RK
000022  b130              CBZ      r0,|L8.50|
;;;1315       swapexps(e1, e2);  /* 'e2' will be the constant operand */
000024  4621              MOV      r1,r4
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       swapexps
;;;1316       inv = 1;
00002c  f04f0b01          MOV      r11,#1
000030  e014              B        |L8.92|
                  |L8.50|
;;;1317     }
;;;1318     else if (!(e2->k == VKINT && luaK_exp2RK(fs, e2))) {  /* no constants? */
000032  6820              LDR      r0,[r4,#0]
000034  2806              CMP      r0,#6
000036  d104              BNE      |L8.66|
000038  4621              MOV      r1,r4
00003a  9803              LDR      r0,[sp,#0xc]
00003c  f7fffffe          BL       luaK_exp2RK
000040  b960              CBNZ     r0,|L8.92|
                  |L8.66|
;;;1319       op = cast(OpCode, opr - OPR_BAND + OP_BAND);
000042  f106071f          ADD      r7,r6,#0x1f
;;;1320       codebinexpval(fs, op, e1, e2, line);  /* all-register opcodes */
000046  4623              MOV      r3,r4
000048  462a              MOV      r2,r5
00004a  4639              MOV      r1,r7
00004c  f8cd8000          STR      r8,[sp,#0]
000050  9803              LDR      r0,[sp,#0xc]
000052  f7fffffe          BL       codebinexpval
                  |L8.86|
;;;1321       return;
;;;1322     }
;;;1323     v1 = luaK_exp2anyreg(fs, e1);
;;;1324     v2 = e2->u.info;  /* index in K array */
;;;1325     op = cast(OpCode, opr - OPR_BAND + OP_BANDK);
;;;1326     lua_assert(ttisinteger(&fs->f->k[v2]));
;;;1327     pc = luaK_codeABCk(fs, op, 0, v1, v2, inv);
;;;1328     finishbinexpval(fs, e1, e2, pc, line);
;;;1329   }
000056  b007              ADD      sp,sp,#0x1c
000058  e8bd8ff0          POP      {r4-r11,pc}
                  |L8.92|
00005c  4629              MOV      r1,r5                 ;1323
00005e  9803              LDR      r0,[sp,#0xc]          ;1323
000060  f7fffffe          BL       luaK_exp2anyreg
000064  9002              STR      r0,[sp,#8]            ;1323
000066  f8d49008          LDR      r9,[r4,#8]            ;1324
00006a  f1060713          ADD      r7,r6,#0x13           ;1325
00006e  e9cd9b00          STRD     r9,r11,[sp,#0]        ;1327
000072  2200              MOVS     r2,#0                 ;1327
000074  4639              MOV      r1,r7                 ;1327
000076  e9dd3002          LDRD     r3,r0,[sp,#8]         ;1327
00007a  f7fffffe          BL       luaK_codeABCk
00007e  4682              MOV      r10,r0                ;1327
000080  4653              MOV      r3,r10                ;1328
000082  4622              MOV      r2,r4                 ;1328
000084  4629              MOV      r1,r5                 ;1328
000086  f8cd8000          STR      r8,[sp,#0]            ;1328
00008a  9803              LDR      r0,[sp,#0xc]          ;1328
00008c  f7fffffe          BL       finishbinexpval
000090  bf00              NOP      
000092  e7e0              B        |L8.86|
;;;1330   
                          ENDP


                          AREA ||i.codecommutative||, CODE, READONLY, ALIGN=1

                  codecommutative PROC
;;;1293   */
;;;1294   static void codecommutative (FuncState *fs, OpCode op,
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;1295                                expdesc *e1, expdesc *e2, int line) {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
00000c  f8dd8028          LDR      r8,[sp,#0x28]
;;;1296     int flip = 0;
000010  f04f0900          MOV      r9,#0
;;;1297     if (isSCint(e1)) {
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       isSCint
00001a  b128              CBZ      r0,|L9.40|
;;;1298       swapexps(e1, e2);
00001c  4629              MOV      r1,r5
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       swapexps
;;;1299       flip = 1;
000024  f04f0901          MOV      r9,#1
                  |L9.40|
;;;1300     }
;;;1301     codearith(fs, op, e1, e2, flip, line);
000028  462b              MOV      r3,r5
00002a  4622              MOV      r2,r4
00002c  4639              MOV      r1,r7
00002e  4630              MOV      r0,r6
000030  e9cd9800          STRD     r9,r8,[sp,#0]
000034  f7fffffe          BL       codearith
;;;1302   }
000038  e8bd87fc          POP      {r2-r10,pc}
;;;1303   
                          ENDP


                          AREA ||i.codeconcat||, CODE, READONLY, ALIGN=1

                  codeconcat PROC
;;;1524   */
;;;1525   static void codeconcat (FuncState *fs, expdesc *e1, expdesc *e2, int line) {
000000  e92d47fc          PUSH     {r2-r10,lr}
000004  4680              MOV      r8,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1526     Instruction *ie2 = previousinstruction(fs);
00000c  4640              MOV      r0,r8
00000e  f7fffffe          BL       previousinstruction
000012  4604              MOV      r4,r0
;;;1527     if (GET_OPCODE(*ie2) == OP_CONCAT) {  /* is 'e2' a concatenation? */
000014  7820              LDRB     r0,[r4,#0]
000016  f000007f          AND      r0,r0,#0x7f
00001a  282f              CMP      r0,#0x2f
00001c  d112              BNE      |L10.68|
;;;1528       int n = GETARG_B(*ie2);  /* # of elements concatenated in 'e2' */
00001e  6820              LDR      r0,[r4,#0]
000020  f3c04907          UBFX     r9,r0,#16,#8
;;;1529       lua_assert(e1->u.info + 1 == GETARG_A(*ie2));
;;;1530       freeexp(fs, e2);
000024  4631              MOV      r1,r6
000026  4640              MOV      r0,r8
000028  f7fffffe          BL       freeexp
;;;1531       SETARG_A(*ie2, e1->u.info);  /* correct first element ('e1') */
00002c  7a29              LDRB     r1,[r5,#8]
00002e  6820              LDR      r0,[r4,#0]
000030  f36110ce          BFI      r0,r1,#7,#8
000034  6020              STR      r0,[r4,#0]
;;;1532       SETARG_B(*ie2, n + 1);  /* will concatenate one more element */
000036  f1090001          ADD      r0,r9,#1
00003a  6821              LDR      r1,[r4,#0]
00003c  f3604117          BFI      r1,r0,#16,#8
000040  6021              STR      r1,[r4,#0]
;;;1533     }
000042  e010              B        |L10.102|
                  |L10.68|
;;;1534     else {  /* 'e2' is not a concatenation */
;;;1535       luaK_codeABC(fs, OP_CONCAT, e1->u.info, 2, 0);  /* new concat opcode */
000044  2000              MOVS     r0,#0
000046  9000              STR      r0,[sp,#0]
000048  9001              STR      r0,[sp,#4]
00004a  2302              MOVS     r3,#2
00004c  212f              MOVS     r1,#0x2f
00004e  4640              MOV      r0,r8
000050  68aa              LDR      r2,[r5,#8]
000052  f7fffffe          BL       luaK_codeABCk
;;;1536       freeexp(fs, e2);
000056  4631              MOV      r1,r6
000058  4640              MOV      r0,r8
00005a  f7fffffe          BL       freeexp
;;;1537       luaK_fixline(fs, line);
00005e  4639              MOV      r1,r7
000060  4640              MOV      r0,r8
000062  f7fffffe          BL       luaK_fixline
                  |L10.102|
;;;1538     }
;;;1539   }
000066  e8bd87fc          POP      {r2-r10,pc}
;;;1540   
                          ENDP


                          AREA ||i.codeeq||, CODE, READONLY, ALIGN=1

                  codeeq PROC
;;;1385   */
;;;1386   static void codeeq (FuncState *fs, BinOpr opr, expdesc *e1, expdesc *e2) {
000000  e92d47ff          PUSH     {r0-r10,lr}
000004  4681              MOV      r9,r0
000006  4688              MOV      r8,r1
000008  4614              MOV      r4,r2
00000a  461e              MOV      r6,r3
;;;1387     int r1, r2;
;;;1388     lua_Integer im;
;;;1389     OpCode op;
;;;1390     if (e1->k != VNONRELOC) {
00000c  6820              LDR      r0,[r4,#0]
00000e  2807              CMP      r0,#7
000010  d003              BEQ      |L11.26|
;;;1391       lua_assert(e1->k == VK || e1->k == VKINT || e1->k == VKFLT);
;;;1392       swapexps(e1, e2);
000012  4631              MOV      r1,r6
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       swapexps
                  |L11.26|
;;;1393     }
;;;1394     r1 = luaK_exp2anyreg(fs, e1);  /* 1nd expression must be in register */
00001a  4621              MOV      r1,r4
00001c  4648              MOV      r0,r9
00001e  f7fffffe          BL       luaK_exp2anyreg
000022  4682              MOV      r10,r0
;;;1395     if (isSCnumber(e2, &im)) {
000024  a902              ADD      r1,sp,#8
000026  4630              MOV      r0,r6
000028  f7fffffe          BL       isSCnumber
00002c  b110              CBZ      r0,|L11.52|
;;;1396       op = OP_EQI;
00002e  2736              MOVS     r7,#0x36
;;;1397       r2 = cast_int(im);  /* immediate operand */
000030  9d02              LDR      r5,[sp,#8]
000032  e00d              B        |L11.80|
                  |L11.52|
;;;1398     }
;;;1399     else if (luaK_exp2RK(fs, e2)) {  /* 1st expression is constant? */
000034  4631              MOV      r1,r6
000036  4648              MOV      r0,r9
000038  f7fffffe          BL       luaK_exp2RK
00003c  b110              CBZ      r0,|L11.68|
;;;1400       op = OP_EQK;
00003e  2735              MOVS     r7,#0x35
;;;1401       r2 = e2->u.info;  /* constant index */
000040  68b5              LDR      r5,[r6,#8]
000042  e005              B        |L11.80|
                  |L11.68|
;;;1402     }
;;;1403     else {
;;;1404       op = OP_EQ;  /* will compare two registers */
000044  2732              MOVS     r7,#0x32
;;;1405       r2 = luaK_exp2anyreg(fs, e2);
000046  4631              MOV      r1,r6
000048  4648              MOV      r0,r9
00004a  f7fffffe          BL       luaK_exp2anyreg
00004e  4605              MOV      r5,r0
                  |L11.80|
;;;1406     }
;;;1407     freeexps(fs, e1, e2);
000050  4632              MOV      r2,r6
000052  4621              MOV      r1,r4
000054  4648              MOV      r0,r9
000056  f7fffffe          BL       freeexps
;;;1408     e1->u.info = condjump(fs, op, r1, r2, (opr == OPR_EQ));
00005a  f1b80f0d          CMP      r8,#0xd
00005e  d101              BNE      |L11.100|
000060  2001              MOVS     r0,#1
000062  e000              B        |L11.102|
                  |L11.100|
000064  2000              MOVS     r0,#0
                  |L11.102|
000066  462b              MOV      r3,r5
000068  4652              MOV      r2,r10
00006a  4639              MOV      r1,r7
00006c  9000              STR      r0,[sp,#0]
00006e  4648              MOV      r0,r9
000070  f7fffffe          BL       condjump
000074  60a0              STR      r0,[r4,#8]
;;;1409     e1->k = VJMP;
000076  200e              MOVS     r0,#0xe
000078  6020              STR      r0,[r4,#0]
;;;1410   }
00007a  e8bd87ff          POP      {r0-r10,pc}
;;;1411   
                          ENDP


                          AREA ||i.codeextraarg||, CODE, READONLY, ALIGN=1

                  codeextraarg PROC
;;;405    */
;;;406    static int codeextraarg (FuncState *fs, int a) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;407      lua_assert(a <= MAXARG_Ax);
;;;408      return luaK_code(fs, CREATE_Ax(OP_EXTRAARG, a));
000006  204e              MOVS     r0,#0x4e
000008  ea4011c4          ORR      r1,r0,r4,LSL #7
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       luaK_code
;;;409    }
000012  bd70              POP      {r4-r6,pc}
;;;410    
                          ENDP


                          AREA ||i.codeisdef||, CODE, READONLY, ALIGN=1

                  codeisdef PROC
;;;1440   
;;;1441   static void codeisdef (FuncState *fs, int eq, expdesc *v) {
000000  b57c              PUSH     {r2-r6,lr}
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
000006  4614              MOV      r4,r2
;;;1442     normalizeindexed(fs, v);
000008  4621              MOV      r1,r4
00000a  4630              MOV      r0,r6
00000c  f7fffffe          BL       normalizeindexed
;;;1443     v->u.info = luaK_codeABCk(fs, OP_ISDEF, 0, v->u.ind.t, v->u.ind.idx, eq);
000010  f9b40008          LDRSH    r0,[r4,#8]
000014  e9cd0500          STRD     r0,r5,[sp,#0]
000018  7aa3              LDRB     r3,[r4,#0xa]
00001a  2200              MOVS     r2,#0
00001c  213e              MOVS     r1,#0x3e
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       luaK_codeABCk
000024  60a0              STR      r0,[r4,#8]
;;;1444     v->k = VRELOC;
000026  200f              MOVS     r0,#0xf
000028  6020              STR      r0,[r4,#0]
;;;1445   }
00002a  bd7c              POP      {r2-r6,pc}
;;;1446   
                          ENDP


                          AREA ||i.codenot||, CODE, READONLY, ALIGN=1

                  codenot PROC
;;;1059   */
;;;1060   static void codenot (FuncState *fs, expdesc *e) {
000000  b57c              PUSH     {r2-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1061     luaK_dischargevars(fs, e);
000006  4621              MOV      r1,r4
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       luaK_dischargevars
;;;1062     switch (e->k) {
00000e  6820              LDR      r0,[r4,#0]
000010  2810              CMP      r0,#0x10
000012  d22e              BCS      |L14.114|
000014  e8dff000          TBB      [pc,r0]
000018  2d080f09          DCB      0x2d,0x08,0x0f,0x09
00001c  0c0d0e18          DCB      0x0c,0x0d,0x0e,0x18
000020  2d2d2d2d          DCB      0x2d,0x2d,0x2d,0x2d
000024  2d2d1217          DCB      0x2d,0x2d,0x12,0x17
;;;1063       case VNIL: case VFALSE: {
000028  bf00              NOP      
;;;1064         e->k = VTRUE;  /* true == not nil == not false */
00002a  2002              MOVS     r0,#2
00002c  6020              STR      r0,[r4,#0]
;;;1065         break;
00002e  e021              B        |L14.116|
;;;1066       }
;;;1067       case VK: case VKFLT: case VKINT: case VTRUE: {
000030  bf00              NOP      
000032  bf00              NOP      
000034  bf00              NOP      
;;;1068         e->k = VFALSE;  /* false == not "x" == not 0.5 == not 1 == not true */
000036  2003              MOVS     r0,#3
000038  6020              STR      r0,[r4,#0]
;;;1069         break;
00003a  e01b              B        |L14.116|
;;;1070       }
;;;1071       case VJMP: {
;;;1072         negatecondition(fs, e);
00003c  4621              MOV      r1,r4
00003e  4628              MOV      r0,r5
000040  f7fffffe          BL       negatecondition
;;;1073         break;
000044  e016              B        |L14.116|
;;;1074       }
;;;1075       case VRELOC:
;;;1076       case VNONRELOC: {
000046  bf00              NOP      
;;;1077         discharge2anyreg(fs, e);
000048  4621              MOV      r1,r4
00004a  4628              MOV      r0,r5
00004c  f7fffffe          BL       discharge2anyreg
;;;1078         freeexp(fs, e);
000050  4621              MOV      r1,r4
000052  4628              MOV      r0,r5
000054  f7fffffe          BL       freeexp
;;;1079         e->u.info = luaK_codeABC(fs, OP_NOT, 0, e->u.info, 0);
000058  2000              MOVS     r0,#0
00005a  9000              STR      r0,[sp,#0]
00005c  9001              STR      r0,[sp,#4]
00005e  4602              MOV      r2,r0
000060  212d              MOVS     r1,#0x2d
000062  4628              MOV      r0,r5
000064  68a3              LDR      r3,[r4,#8]
000066  f7fffffe          BL       luaK_codeABCk
00006a  60a0              STR      r0,[r4,#8]
;;;1080         e->k = VRELOC;
00006c  200f              MOVS     r0,#0xf
00006e  6020              STR      r0,[r4,#0]
;;;1081         break;
000070  e000              B        |L14.116|
                  |L14.114|
000072  bf00              NOP                            ;1062
                  |L14.116|
000074  bf00              NOP                            ;1065
;;;1082       }
;;;1083       default: lua_assert(0);  /* cannot happen */
;;;1084     }
;;;1085     /* interchange true and false lists */
;;;1086     { int temp = e->f; e->f = e->t; e->t = temp; }
000076  6960              LDR      r0,[r4,#0x14]
000078  6921              LDR      r1,[r4,#0x10]
00007a  6161              STR      r1,[r4,#0x14]
00007c  6120              STR      r0,[r4,#0x10]
;;;1087     removevalues(fs, e->f);  /* values are useless when negated */
00007e  4628              MOV      r0,r5
000080  6961              LDR      r1,[r4,#0x14]
000082  f7fffffe          BL       removevalues
;;;1088     removevalues(fs, e->t);
000086  4628              MOV      r0,r5
000088  6921              LDR      r1,[r4,#0x10]
00008a  f7fffffe          BL       removevalues
;;;1089   }
00008e  bd7c              POP      {r2-r6,pc}
;;;1090   
                          ENDP


                          AREA ||i.codeorder||, CODE, READONLY, ALIGN=1

                  codeorder PROC
;;;1356   */
;;;1357   static void codeorder (FuncState *fs, OpCode op, expdesc *e1, expdesc *e2) {
000000  e92d47ff          PUSH     {r0-r10,lr}
000004  4680              MOV      r8,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
;;;1358     int r1, r2;
;;;1359     lua_Integer im;
;;;1360     if (isSCnumber(e2, &im)) {
00000c  a902              ADD      r1,sp,#8
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       isSCnumber
000014  b138              CBZ      r0,|L15.38|
;;;1361       /* use immediate operand */
;;;1362       r1 = luaK_exp2anyreg(fs, e1);
000016  4629              MOV      r1,r5
000018  4640              MOV      r0,r8
00001a  f7fffffe          BL       luaK_exp2anyreg
00001e  4681              MOV      r9,r0
;;;1363       r2 = cast_int(im);
000020  9c02              LDR      r4,[sp,#8]
;;;1364       op = cast(OpCode, (op - OP_LT) + OP_LTI);
000022  1d3f              ADDS     r7,r7,#4
000024  e01b              B        |L15.94|
                  |L15.38|
;;;1365     }
;;;1366     else if (isSCnumber(e1, &im)) {
000026  a902              ADD      r1,sp,#8
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       isSCnumber
00002e  b160              CBZ      r0,|L15.74|
;;;1367       /* transform (A < B) to (B > A) and (A <= B) to (B >= A) */
;;;1368       r1 = luaK_exp2anyreg(fs, e2);
000030  4631              MOV      r1,r6
000032  4640              MOV      r0,r8
000034  f7fffffe          BL       luaK_exp2anyreg
000038  4681              MOV      r9,r0
;;;1369       r2 = cast_int(im);
00003a  9c02              LDR      r4,[sp,#8]
;;;1370       op = (op == OP_LT) ? OP_GTI : OP_GEI;
00003c  2f33              CMP      r7,#0x33
00003e  d101              BNE      |L15.68|
000040  2039              MOVS     r0,#0x39
000042  e000              B        |L15.70|
                  |L15.68|
000044  203a              MOVS     r0,#0x3a
                  |L15.70|
000046  4607              MOV      r7,r0
000048  e009              B        |L15.94|
                  |L15.74|
;;;1371     }
;;;1372     else {  /* regular case, compare two registers */
;;;1373       r1 = luaK_exp2anyreg(fs, e1);
00004a  4629              MOV      r1,r5
00004c  4640              MOV      r0,r8
00004e  f7fffffe          BL       luaK_exp2anyreg
000052  4681              MOV      r9,r0
;;;1374       r2 = luaK_exp2anyreg(fs, e2);
000054  4631              MOV      r1,r6
000056  4640              MOV      r0,r8
000058  f7fffffe          BL       luaK_exp2anyreg
00005c  4604              MOV      r4,r0
                  |L15.94|
;;;1375     }
;;;1376     freeexps(fs, e1, e2);
00005e  4632              MOV      r2,r6
000060  4629              MOV      r1,r5
000062  4640              MOV      r0,r8
000064  f7fffffe          BL       freeexps
;;;1377     e1->u.info = condjump(fs, op, r1, r2, 1);
000068  2001              MOVS     r0,#1
00006a  4623              MOV      r3,r4
00006c  464a              MOV      r2,r9
00006e  4639              MOV      r1,r7
000070  9000              STR      r0,[sp,#0]
000072  4640              MOV      r0,r8
000074  f7fffffe          BL       condjump
000078  60a8              STR      r0,[r5,#8]
;;;1378     e1->k = VJMP;
00007a  200e              MOVS     r0,#0xe
00007c  6028              STR      r0,[r5,#0]
;;;1379   }
00007e  e8bd87ff          POP      {r0-r10,pc}
;;;1380   
                          ENDP


                          AREA ||i.codesJ||, CODE, READONLY, ALIGN=2

                  codesJ PROC
;;;394    */
;;;395    static int codesJ (FuncState *fs, OpCode o, int sj, int k) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
;;;396      unsigned int j = sj + OFFSET_sJ;
00000c  4805              LDR      r0,|L16.36|
00000e  eb050800          ADD      r8,r5,r0
;;;397      lua_assert(getOpMode(o) == isJ);
;;;398      lua_assert(j <= MAXARG_sJ && (k & ~1) == 0);
;;;399      return luaK_code(fs, CREATE_sJ(o, j, k));
000012  ea442008          ORR      r0,r4,r8,LSL #8
000016  ea4031c6          ORR      r1,r0,r6,LSL #15
00001a  4638              MOV      r0,r7
00001c  f7fffffe          BL       luaK_code
;;;400    }
000020  e8bd81f0          POP      {r4-r8,pc}
;;;401    
                          ENDP

                  |L16.36|
                          DCD      0x007fffff

                          AREA ||i.codeshift||, CODE, READONLY, ALIGN=1

                  codeshift PROC
;;;1335   */
;;;1336   static void codeshift (FuncState *fs, OpCode op,
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;1337                          expdesc *e1, expdesc *e2, int line) {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4690              MOV      r8,r2
00000a  461c              MOV      r4,r3
00000c  9e0a              LDR      r6,[sp,#0x28]
;;;1338     if (isSCint(e2)) {
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       isSCint
000014  b1b0              CBZ      r0,|L17.68|
;;;1339       int changedir = 0;
000016  f04f0900          MOV      r9,#0
;;;1340       if (op == OP_SHL) {
00001a  2d29              CMP      r5,#0x29
00001c  d109              BNE      |L17.50|
;;;1341         changedir = 1;
00001e  f04f0901          MOV      r9,#1
;;;1342         e2->u.ival = -(e2->u.ival);
000022  2200              MOVS     r2,#0
000024  e9d41002          LDRD     r1,r0,[r4,#8]
000028  4249              RSBS     r1,r1,#0
00002a  eb620000          SBC      r0,r2,r0
00002e  e9c41002          STRD     r1,r0,[r4,#8]
                  |L17.50|
;;;1343       }
;;;1344       codebini(fs, OP_SHRI, e1, e2, changedir, line);
000032  4623              MOV      r3,r4
000034  4642              MOV      r2,r8
000036  211d              MOVS     r1,#0x1d
000038  4638              MOV      r0,r7
00003a  e9cd9600          STRD     r9,r6,[sp,#0]
00003e  f7fffffe          BL       codebini
;;;1345     }
000042  e006              B        |L17.82|
                  |L17.68|
;;;1346     else
;;;1347       codebinexpval(fs, op, e1, e2, line);
000044  4623              MOV      r3,r4
000046  4642              MOV      r2,r8
000048  4629              MOV      r1,r5
00004a  4638              MOV      r0,r7
00004c  9600              STR      r6,[sp,#0]
00004e  f7fffffe          BL       codebinexpval
                  |L17.82|
;;;1348   }
000052  e8bd87fc          POP      {r2-r10,pc}
;;;1349   
                          ENDP


                          AREA ||i.codeunexpval||, CODE, READONLY, ALIGN=1

                  codeunexpval PROC
;;;1222   */
;;;1223   static void codeunexpval (FuncState *fs, OpCode op, expdesc *e, int line) {
000000  e92d41fc          PUSH     {r2-r8,lr}
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
;;;1224     int r = luaK_exp2anyreg(fs, e);  /* opcodes operate only on registers */
00000c  4621              MOV      r1,r4
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       luaK_exp2anyreg
000014  4680              MOV      r8,r0
;;;1225     freeexp(fs, e);
000016  4621              MOV      r1,r4
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       freeexp
;;;1226     e->u.info = luaK_codeABC(fs, op, 0, r, 0);  /* generate opcode */
00001e  2000              MOVS     r0,#0
000020  9000              STR      r0,[sp,#0]
000022  4643              MOV      r3,r8
000024  4602              MOV      r2,r0
000026  4639              MOV      r1,r7
000028  9001              STR      r0,[sp,#4]
00002a  4630              MOV      r0,r6
00002c  f7fffffe          BL       luaK_codeABCk
000030  60a0              STR      r0,[r4,#8]
;;;1227     e->k = VRELOC;  /* all those operations are relocatable */
000032  200f              MOVS     r0,#0xf
000034  6020              STR      r0,[r4,#0]
;;;1228     luaK_fixline(fs, line);
000036  4629              MOV      r1,r5
000038  4630              MOV      r0,r6
00003a  f7fffffe          BL       luaK_fixline
;;;1229   }
00003e  e8bd81fc          POP      {r2-r8,pc}
;;;1230   
                          ENDP


                          AREA ||i.condjump||, CODE, READONLY, ALIGN=1

                  condjump PROC
;;;181    */
;;;182    static int condjump (FuncState *fs, OpCode op, int A, int B, int k) {
000000  e92d41fc          PUSH     {r2-r8,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8020          LDR      r8,[sp,#0x20]
;;;183      luaK_codeABCk(fs, op, A, B, 0, k);
000010  2000              MOVS     r0,#0
000012  463b              MOV      r3,r7
000014  4632              MOV      r2,r6
000016  4629              MOV      r1,r5
000018  e9cd0800          STRD     r0,r8,[sp,#0]
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       luaK_codeABCk
;;;184      return luaK_jump(fs);
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       luaK_jump
;;;185    }
000028  e8bd81fc          POP      {r2-r8,pc}
;;;186    
                          ENDP


                          AREA ||i.constfolding||, CODE, READONLY, ALIGN=1

                  constfolding PROC
;;;1196   */
;;;1197   static int constfolding (FuncState *fs, int op, expdesc *e1,
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;1198                                                   const expdesc *e2) {
000004  b08f              SUB      sp,sp,#0x3c
000006  4607              MOV      r7,r0
000008  4688              MOV      r8,r1
00000a  4614              MOV      r4,r2
00000c  4699              MOV      r9,r3
;;;1199     TValue v1, v2, res;
;;;1200     if (!tonumeral(e1, &v1) || !tonumeral(e2, &v2) || !validop(op, &v1, &v2))
00000e  a90a              ADD      r1,sp,#0x28
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       tonumeral
000016  b150              CBZ      r0,|L20.46|
000018  a906              ADD      r1,sp,#0x18
00001a  4648              MOV      r0,r9
00001c  f7fffffe          BL       tonumeral
000020  b128              CBZ      r0,|L20.46|
000022  aa06              ADD      r2,sp,#0x18
000024  a90a              ADD      r1,sp,#0x28
000026  4640              MOV      r0,r8
000028  f7fffffe          BL       validop
00002c  b918              CBNZ     r0,|L20.54|
                  |L20.46|
;;;1201       return 0;  /* non-numeric operands or not safe to fold */
00002e  2000              MOVS     r0,#0
                  |L20.48|
;;;1202     luaO_rawarith(fs->ls->L, op, &v1, &v2, &res);  /* does operation */
;;;1203     if (ttisinteger(&res)) {
;;;1204       e1->k = VKINT;
;;;1205       e1->u.ival = ivalue(&res);
;;;1206     }
;;;1207     else {  /* folds neither NaN nor 0.0 (to avoid problems with -0.0) */
;;;1208       lua_Number n = fltvalue(&res);
;;;1209       if (luai_numisnan(n) || n == 0)
;;;1210         return 0;
;;;1211       e1->k = VKFLT;
;;;1212       e1->u.nval = n;
;;;1213     }
;;;1214     return 1;
;;;1215   }
000030  b00f              ADD      sp,sp,#0x3c
000032  e8bd83f0          POP      {r4-r9,pc}
                  |L20.54|
000036  a802              ADD      r0,sp,#8              ;1202
000038  9000              STR      r0,[sp,#0]            ;1202
00003a  68b9              LDR      r1,[r7,#8]            ;1202
00003c  ab06              ADD      r3,sp,#0x18           ;1202
00003e  aa0a              ADD      r2,sp,#0x28           ;1202
000040  6b48              LDR      r0,[r1,#0x34]         ;1202
000042  4641              MOV      r1,r8                 ;1202
000044  f7fffffe          BL       luaO_rawarith
000048  f89d0010          LDRB     r0,[sp,#0x10]         ;1203
00004c  2823              CMP      r0,#0x23              ;1203
00004e  d106              BNE      |L20.94|
000050  2006              MOVS     r0,#6                 ;1204
000052  6020              STR      r0,[r4,#0]            ;1204
000054  e9dd0102          LDRD     r0,r1,[sp,#8]         ;1205
000058  e9c40102          STRD     r0,r1,[r4,#8]         ;1205
00005c  e016              B        |L20.140|
                  |L20.94|
00005e  e9dd5602          LDRD     r5,r6,[sp,#8]         ;1208
000062  462a              MOV      r2,r5                 ;1209
000064  4633              MOV      r3,r6                 ;1209
000066  4628              MOV      r0,r5                 ;1209
000068  4631              MOV      r1,r6                 ;1209
00006a  f7fffffe          BL       __aeabi_cdcmpeq
00006e  d106              BNE      |L20.126|
000070  2200              MOVS     r2,#0                 ;1209
000072  4613              MOV      r3,r2                 ;1209
000074  4628              MOV      r0,r5                 ;1209
000076  4631              MOV      r1,r6                 ;1209
000078  f7fffffe          BL       __aeabi_cdcmpeq
00007c  d101              BNE      |L20.130|
                  |L20.126|
00007e  2000              MOVS     r0,#0                 ;1210
000080  e7d6              B        |L20.48|
                  |L20.130|
000082  2005              MOVS     r0,#5                 ;1211
000084  6020              STR      r0,[r4,#0]            ;1211
000086  e9c45602          STRD     r5,r6,[r4,#8]         ;1212
00008a  bf00              NOP                            ;1213
                  |L20.140|
00008c  2001              MOVS     r0,#1                 ;1214
00008e  e7cf              B        |L20.48|
;;;1216   
                          ENDP


                          AREA ||i.discharge2anyreg||, CODE, READONLY, ALIGN=1

                  discharge2anyreg PROC
;;;773    */
;;;774    static void discharge2anyreg (FuncState *fs, expdesc *e) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;775      if (e->k != VNONRELOC) {  /* no fixed register yet? */
000006  6828              LDR      r0,[r5,#0]
000008  2807              CMP      r0,#7
00000a  d00a              BEQ      |L21.34|
;;;776        luaK_reserveregs(fs, 1);  /* get a register */
00000c  2101              MOVS     r1,#1
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       luaK_reserveregs
;;;777        discharge2reg(fs, e, fs->freereg-1);  /* put value there */
000014  f8940030          LDRB     r0,[r4,#0x30]
000018  1e42              SUBS     r2,r0,#1
00001a  4629              MOV      r1,r5
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       discharge2reg
                  |L21.34|
;;;778      }
;;;779    }
000022  bd70              POP      {r4-r6,pc}
;;;780    
                          ENDP


                          AREA ||i.discharge2reg||, CODE, READONLY, ALIGN=1

                  discharge2reg PROC
;;;726    */
;;;727    static void discharge2reg (FuncState *fs, expdesc *e, int reg) {
000000  e92d41fc          PUSH     {r2-r8,lr}
000004  4680              MOV      r8,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;728      luaK_dischargevars(fs, e);
00000a  4621              MOV      r1,r4
00000c  4640              MOV      r0,r8
00000e  f7fffffe          BL       luaK_dischargevars
;;;729      switch (e->k) {
000012  6820              LDR      r0,[r4,#0]
000014  2810              CMP      r0,#0x10
000016  d24e              BCS      |L22.182|
000018  e8dff000          TBB      [pc,r0]
00001c  4d080f0e          DCB      0x4d,0x08,0x0f,0x0e
000020  1f252d40          DCB      0x1f,0x25,0x2d,0x40
000024  4d4d4d4d          DCB      0x4d,0x4d,0x4d,0x4d
000028  4d4d4d35          DCB      0x4d,0x4d,0x4d,0x35
;;;730        case VNIL: {
;;;731          luaK_nil(fs, reg, 1);
00002c  2201              MOVS     r2,#1
00002e  4629              MOV      r1,r5
000030  4640              MOV      r0,r8
000032  f7fffffe          BL       luaK_nil
;;;732          break;
000036  e040              B        |L22.186|
;;;733        }
;;;734        case VFALSE: case VTRUE: {
000038  bf00              NOP      
;;;735          luaK_codeABC(fs, OP_LOADBOOL, reg, e->k == VTRUE, 0);
00003a  2000              MOVS     r0,#0
00003c  9000              STR      r0,[sp,#0]
00003e  9001              STR      r0,[sp,#4]
000040  6820              LDR      r0,[r4,#0]
000042  2802              CMP      r0,#2
000044  d101              BNE      |L22.74|
000046  2001              MOVS     r0,#1
000048  e000              B        |L22.76|
                  |L22.74|
00004a  2000              MOVS     r0,#0
                  |L22.76|
00004c  4603              MOV      r3,r0
00004e  462a              MOV      r2,r5
000050  2105              MOVS     r1,#5
000052  4640              MOV      r0,r8
000054  f7fffffe          BL       luaK_codeABCk
;;;736          break;
000058  e02f              B        |L22.186|
;;;737        }
;;;738        case VK: {
;;;739          luaK_codek(fs, reg, e->u.info);
00005a  4629              MOV      r1,r5
00005c  4640              MOV      r0,r8
00005e  68a2              LDR      r2,[r4,#8]
000060  f7fffffe          BL       luaK_codek
;;;740          break;
000064  e029              B        |L22.186|
;;;741        }
;;;742        case VKFLT: {
;;;743          luaK_float(fs, reg, e->u.nval);
000066  e9d46302          LDRD     r6,r3,[r4,#8]
00006a  4632              MOV      r2,r6
00006c  4629              MOV      r1,r5
00006e  4640              MOV      r0,r8
000070  f7fffffe          BL       luaK_float
;;;744          break;
000074  e021              B        |L22.186|
;;;745        }
;;;746        case VKINT: {
;;;747          luaK_int(fs, reg, e->u.ival);
000076  e9d46302          LDRD     r6,r3,[r4,#8]
00007a  4632              MOV      r2,r6
00007c  4629              MOV      r1,r5
00007e  4640              MOV      r0,r8
000080  f7fffffe          BL       luaK_int
;;;748          break;
000084  e019              B        |L22.186|
;;;749        }
;;;750        case VRELOC: {
;;;751          Instruction *pc = &getinstruction(fs, e);
000086  f8d81000          LDR      r1,[r8,#0]
00008a  6b89              LDR      r1,[r1,#0x38]
00008c  68a2              LDR      r2,[r4,#8]
00008e  eb010082          ADD      r0,r1,r2,LSL #2
;;;752          SETARG_A(*pc, reg);  /* instruction will put result in 'reg' */
000092  6801              LDR      r1,[r0,#0]
000094  f36511ce          BFI      r1,r5,#7,#8
000098  6001              STR      r1,[r0,#0]
;;;753          break;
00009a  e00e              B        |L22.186|
;;;754        }
;;;755        case VNONRELOC: {
;;;756          if (reg != e->u.info)
00009c  68a0              LDR      r0,[r4,#8]
00009e  42a8              CMP      r0,r5
0000a0  d008              BEQ      |L22.180|
;;;757            luaK_codeABC(fs, OP_MOVE, reg, e->u.info, 0);
0000a2  2000              MOVS     r0,#0
0000a4  9000              STR      r0,[sp,#0]
0000a6  9001              STR      r0,[sp,#4]
0000a8  462a              MOV      r2,r5
0000aa  4601              MOV      r1,r0
0000ac  4640              MOV      r0,r8
0000ae  68a3              LDR      r3,[r4,#8]
0000b0  f7fffffe          BL       luaK_codeABCk
                  |L22.180|
;;;758          break;
0000b4  e001              B        |L22.186|
                  |L22.182|
;;;759        }
;;;760        default: {
;;;761          lua_assert(e->k == VJMP);
;;;762          return;  /* nothing to do... */
;;;763        }
;;;764      }
;;;765      e->u.info = reg;
;;;766      e->k = VNONRELOC;
;;;767    }
0000b6  e8bd81fc          POP      {r2-r8,pc}
                  |L22.186|
0000ba  bf00              NOP                            ;732
0000bc  60a5              STR      r5,[r4,#8]            ;765
0000be  2007              MOVS     r0,#7                 ;766
0000c0  6020              STR      r0,[r4,#0]            ;766
0000c2  bf00              NOP      
0000c4  e7f7              B        |L22.182|
;;;768    
                          ENDP


                          AREA ||i.exp2reg||, CODE, READONLY, ALIGN=1

                  exp2reg PROC
;;;807    */
;;;808    static void exp2reg (FuncState *fs, expdesc *e, int reg) {
000000  e92d4ff8          PUSH     {r3-r11,lr}
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;809      discharge2reg(fs, e, reg);
00000a  462a              MOV      r2,r5
00000c  4621              MOV      r1,r4
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       discharge2reg
;;;810      if (e->k == VJMP)  /* expression itself is a test? */
000014  6820              LDR      r0,[r4,#0]
000016  280e              CMP      r0,#0xe
000018  d105              BNE      |L23.38|
;;;811        luaK_concat(fs, &e->t, e->u.info);  /* put this jump in 't' list */
00001a  f1040110          ADD      r1,r4,#0x10
00001e  4630              MOV      r0,r6
000020  68a2              LDR      r2,[r4,#8]
000022  f7fffffe          BL       luaK_concat
                  |L23.38|
;;;812      if (hasjumps(e)) {
000026  e9d40104          LDRD     r0,r1,[r4,#0x10]
00002a  4288              CMP      r0,r1
00002c  d03d              BEQ      |L23.170|
;;;813        int final;  /* position after whole expression */
;;;814        int p_f = NO_JUMP;  /* position of an eventual LOAD false */
00002e  f04f37ff          MOV      r7,#0xffffffff
;;;815        int p_t = NO_JUMP;  /* position of an eventual LOAD true */
000032  46b8              MOV      r8,r7
;;;816        if (need_value(fs, e->t) || need_value(fs, e->f)) {
000034  4630              MOV      r0,r6
000036  6921              LDR      r1,[r4,#0x10]
000038  f7fffffe          BL       need_value
00003c  b920              CBNZ     r0,|L23.72|
00003e  4630              MOV      r0,r6
000040  6961              LDR      r1,[r4,#0x14]
000042  f7fffffe          BL       need_value
000046  b1e0              CBZ      r0,|L23.130|
                  |L23.72|
;;;817          int fj = (e->k == VJMP) ? NO_JUMP : luaK_jump(fs);
000048  6820              LDR      r0,[r4,#0]
00004a  280e              CMP      r0,#0xe
00004c  d102              BNE      |L23.84|
00004e  f04f30ff          MOV      r0,#0xffffffff
000052  e002              B        |L23.90|
                  |L23.84|
000054  4630              MOV      r0,r6
000056  f7fffffe          BL       luaK_jump
                  |L23.90|
00005a  4681              MOV      r9,r0
;;;818          p_f = code_loadbool(fs, reg, 0, 1);
00005c  2301              MOVS     r3,#1
00005e  2200              MOVS     r2,#0
000060  4629              MOV      r1,r5
000062  4630              MOV      r0,r6
000064  f7fffffe          BL       code_loadbool
000068  4607              MOV      r7,r0
;;;819          p_t = code_loadbool(fs, reg, 1, 0);
00006a  2300              MOVS     r3,#0
00006c  2201              MOVS     r2,#1
00006e  4629              MOV      r1,r5
000070  4630              MOV      r0,r6
000072  f7fffffe          BL       code_loadbool
000076  4680              MOV      r8,r0
;;;820          luaK_patchtohere(fs, fj);
000078  4649              MOV      r1,r9
00007a  4630              MOV      r0,r6
00007c  f7fffffe          BL       luaK_patchtohere
;;;821        }
000080  bf00              NOP      
                  |L23.130|
;;;822        final = luaK_getlabel(fs);
000082  4630              MOV      r0,r6
000084  f7fffffe          BL       luaK_getlabel
000088  4682              MOV      r10,r0
;;;823        patchlistaux(fs, e->f, final, reg, p_f);
00008a  9700              STR      r7,[sp,#0]
00008c  462b              MOV      r3,r5
00008e  4652              MOV      r2,r10
000090  4630              MOV      r0,r6
000092  6961              LDR      r1,[r4,#0x14]
000094  f7fffffe          BL       patchlistaux
;;;824        patchlistaux(fs, e->t, final, reg, p_t);
000098  f8cd8000          STR      r8,[sp,#0]
00009c  462b              MOV      r3,r5
00009e  4652              MOV      r2,r10
0000a0  4630              MOV      r0,r6
0000a2  6921              LDR      r1,[r4,#0x10]
0000a4  f7fffffe          BL       patchlistaux
;;;825      }
0000a8  bf00              NOP      
                  |L23.170|
;;;826      e->f = e->t = NO_JUMP;
0000aa  f04f30ff          MOV      r0,#0xffffffff
0000ae  6120              STR      r0,[r4,#0x10]
0000b0  6160              STR      r0,[r4,#0x14]
;;;827      e->u.info = reg;
0000b2  60a5              STR      r5,[r4,#8]
;;;828      e->k = VNONRELOC;
0000b4  2007              MOVS     r0,#7
0000b6  6020              STR      r0,[r4,#0]
;;;829    }
0000b8  e8bd8ff8          POP      {r3-r11,pc}
;;;830    
                          ENDP


                          AREA ||i.finaltarget||, CODE, READONLY, ALIGN=2

                  finaltarget PROC
;;;1669   */
;;;1670   static int finaltarget (Instruction *code, int i) {
000000  b530              PUSH     {r4,r5,lr}
000002  4602              MOV      r2,r0
;;;1671     int count;
;;;1672     for (count = 0; count < 100; count++) {  /* avoid infinite loops */
000004  2300              MOVS     r3,#0
000006  e00f              B        |L24.40|
                  |L24.8|
;;;1673       Instruction pc = code[i];
000008  f8520021          LDR      r0,[r2,r1,LSL #2]
;;;1674       if (GET_OPCODE(pc) != OP_JMP)
00000c  f000047f          AND      r4,r0,#0x7f
000010  2c31              CMP      r4,#0x31
000012  d000              BEQ      |L24.22|
;;;1675         break;
000014  e00a              B        |L24.44|
                  |L24.22|
;;;1676        else
;;;1677          i += GETARG_sJ(pc) + 1;
000016  f06f447f          MVN      r4,#0xff000000
00001a  ea042410          AND      r4,r4,r0,LSR #8
00001e  4d05              LDR      r5,|L24.52|
000020  1b64              SUBS     r4,r4,r5
000022  1c64              ADDS     r4,r4,#1
000024  4421              ADD      r1,r1,r4
000026  1c5b              ADDS     r3,r3,#1              ;1672
                  |L24.40|
000028  2b64              CMP      r3,#0x64              ;1672
00002a  dbed              BLT      |L24.8|
                  |L24.44|
00002c  bf00              NOP                            ;1675
;;;1678     }
;;;1679     return i;
00002e  4608              MOV      r0,r1
;;;1680   }
000030  bd30              POP      {r4,r5,pc}
;;;1681   
                          ENDP

000032  0000              DCW      0x0000
                  |L24.52|
                          DCD      0x007fffff

                          AREA ||i.finishbinexpval||, CODE, READONLY, ALIGN=1

                  finishbinexpval PROC
;;;1231   
;;;1232   static void finishbinexpval (FuncState *fs, expdesc *e1, expdesc *e2,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1233                                int pc, int line) {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
00000c  f8dd8018          LDR      r8,[sp,#0x18]
;;;1234     freeexps(fs, e1, e2);
000010  463a              MOV      r2,r7
000012  4621              MOV      r1,r4
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       freeexps
;;;1235     e1->u.info = pc;
00001a  60a5              STR      r5,[r4,#8]
;;;1236     e1->k = VRELOC;  /* all those operations are relocatable */
00001c  200f              MOVS     r0,#0xf
00001e  6020              STR      r0,[r4,#0]
;;;1237     luaK_fixline(fs, line);
000020  4641              MOV      r1,r8
000022  4630              MOV      r0,r6
000024  f7fffffe          BL       luaK_fixline
;;;1238   }
000028  e8bd81f0          POP      {r4-r8,pc}
;;;1239   
                          ENDP


                          AREA ||i.fitsBx||, CODE, READONLY, ALIGN=2

                  fitsBx PROC
;;;601    */
;;;602    static int fitsBx (lua_Integer i) {
000000  4602              MOV      r2,r0
000002  460b              MOV      r3,r1
;;;603      return (-OFFSET_sBx <= i && i <= MAXARG_Bx - OFFSET_sBx);
000004  4907              LDR      r1,|L26.36|
000006  1a51              SUBS     r1,r2,r1
000008  f17330ff          SBCS     r0,r3,#0xffffffff
00000c  db07              BLT      |L26.30|
00000e  f44f3180          MOV      r1,#0x10000
000012  2000              MOVS     r0,#0
000014  1a89              SUBS     r1,r1,r2
000016  4198              SBCS     r0,r0,r3
000018  db01              BLT      |L26.30|
00001a  2001              MOVS     r0,#1
                  |L26.28|
;;;604    }
00001c  4770              BX       lr
                  |L26.30|
00001e  2000              MOVS     r0,#0                 ;603
000020  e7fc              B        |L26.28|
;;;605    
                          ENDP

000022  0000              DCW      0x0000
                  |L26.36|
                          DCD      0xffff0001

                          AREA ||i.fitsC||, CODE, READONLY, ALIGN=1

                  fitsC PROC
;;;593    */
;;;594    static int fitsC (lua_Integer i) {
000000  4602              MOV      r2,r0
000002  460b              MOV      r3,r1
;;;595      return (-OFFSET_sC <= i && i <= MAXARG_C - OFFSET_sC);
000004  f06f017e          MVN      r1,#0x7e
000008  1a51              SUBS     r1,r2,r1
00000a  f17330ff          SBCS     r0,r3,#0xffffffff
00000e  db06              BLT      |L27.30|
000010  2000              MOVS     r0,#0
000012  f1d20180          RSBS     r1,r2,#0x80
000016  4198              SBCS     r0,r0,r3
000018  db01              BLT      |L27.30|
00001a  2001              MOVS     r0,#1
                  |L27.28|
;;;596    }
00001c  4770              BX       lr
                  |L27.30|
00001e  2000              MOVS     r0,#0                 ;595
000020  e7fc              B        |L27.28|
;;;597    
                          ENDP


                          AREA ||i.fixjump||, CODE, READONLY, ALIGN=2

                  fixjump PROC
;;;126    */
;;;127    static void fixjump (FuncState *fs, int pc, int dest) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
;;;128      Instruction *jmp = &fs->f->code[pc];
00000a  6820              LDR      r0,[r4,#0]
00000c  6b80              LDR      r0,[r0,#0x38]
00000e  eb000885          ADD      r8,r0,r5,LSL #2
;;;129      int offset = dest - (pc + 1);
000012  1c68              ADDS     r0,r5,#1
000014  1a3e              SUBS     r6,r7,r0
;;;130      lua_assert(dest != NO_JUMP);
;;;131      if (!(-OFFSET_sJ <= offset && offset <= MAXARG_sJ - OFFSET_sJ))
000016  480a              LDR      r0,|L28.64|
000018  4286              CMP      r6,r0
00001a  db02              BLT      |L28.34|
00001c  f5b60f00          CMP      r6,#0x800000
000020  dd03              BLE      |L28.42|
                  |L28.34|
;;;132        luaX_syntaxerror(fs->ls, "control structure too long");
000022  a108              ADR      r1,|L28.68|
000024  68a0              LDR      r0,[r4,#8]
000026  f7fffffe          BL       luaX_syntaxerror
                  |L28.42|
;;;133      lua_assert(GET_OPCODE(*jmp) == OP_JMP);
;;;134      SETARG_sJ(*jmp, offset);
00002a  f46f0000          MVN      r0,#0x800000
00002e  1831              ADDS     r1,r6,r0
000030  f8d80000          LDR      r0,[r8,#0]
000034  f361201f          BFI      r0,r1,#8,#24
000038  f8c80000          STR      r0,[r8,#0]
;;;135    }
00003c  e8bd81f0          POP      {r4-r8,pc}
;;;136    
                          ENDP

                  |L28.64|
                          DCD      0xff800001
                  |L28.68|
000044  636f6e74          DCB      "control structure too long",0
000048  726f6c20
00004c  73747275
000050  63747572
000054  6520746f
000058  6f206c6f
00005c  6e6700  
00005f  00                DCB      0

                          AREA ||i.floatI||, CODE, READONLY, ALIGN=1

                  floatI PROC
;;;614    
;;;615    static int floatI (lua_Number f, lua_Integer *fi) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;616      return (luaV_flttointeger(f, fi, 0) && fitsBx(*fi));
000008  2300              MOVS     r3,#0
00000a  4622              MOV      r2,r4
00000c  4628              MOV      r0,r5
00000e  4631              MOV      r1,r6
000010  f7fffffe          BL       luaV_flttointeger
000014  b138              CBZ      r0,|L29.38|
000016  e9d42100          LDRD     r2,r1,[r4,#0]
00001a  4610              MOV      r0,r2
00001c  f7fffffe          BL       fitsBx
000020  b108              CBZ      r0,|L29.38|
000022  2001              MOVS     r0,#1
                  |L29.36|
;;;617    }
000024  bd70              POP      {r4-r6,pc}
                  |L29.38|
000026  2000              MOVS     r0,#0                 ;616
000028  e7fc              B        |L29.36|
;;;618    
                          ENDP


                          AREA ||i.freeexp||, CODE, READONLY, ALIGN=1

                  freeexp PROC
;;;482    */
;;;483    static void freeexp (FuncState *fs, expdesc *e) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;484      if (e->k == VNONRELOC)
000006  6820              LDR      r0,[r4,#0]
000008  2807              CMP      r0,#7
00000a  d103              BNE      |L30.20|
;;;485        freereg(fs, e->u.info);
00000c  4628              MOV      r0,r5
00000e  68a1              LDR      r1,[r4,#8]
000010  f7fffffe          BL       freereg
                  |L30.20|
;;;486    }
000014  bd70              POP      {r4-r6,pc}
;;;487    
                          ENDP


                          AREA ||i.freeexps||, CODE, READONLY, ALIGN=1

                  freeexps PROC
;;;492    */
;;;493    static void freeexps (FuncState *fs, expdesc *e1, expdesc *e2) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;494      int r1 = (e1->k == VNONRELOC) ? e1->u.info : -1;
00000a  6820              LDR      r0,[r4,#0]
00000c  2807              CMP      r0,#7
00000e  d101              BNE      |L31.20|
000010  68a0              LDR      r0,[r4,#8]
000012  e001              B        |L31.24|
                  |L31.20|
000014  f04f30ff          MOV      r0,#0xffffffff
                  |L31.24|
000018  4607              MOV      r7,r0
;;;495      int r2 = (e2->k == VNONRELOC) ? e2->u.info : -1;
00001a  6828              LDR      r0,[r5,#0]
00001c  2807              CMP      r0,#7
00001e  d101              BNE      |L31.36|
000020  68a8              LDR      r0,[r5,#8]
000022  e001              B        |L31.40|
                  |L31.36|
000024  f04f30ff          MOV      r0,#0xffffffff
                  |L31.40|
000028  4680              MOV      r8,r0
;;;496      freeregs(fs, r1, r2);
00002a  4642              MOV      r2,r8
00002c  4639              MOV      r1,r7
00002e  4630              MOV      r0,r6
000030  f7fffffe          BL       freeregs
;;;497    }
000034  e8bd81f0          POP      {r4-r8,pc}
;;;498    
                          ENDP


                          AREA ||i.freereg||, CODE, READONLY, ALIGN=1

                  freereg PROC
;;;456    */
;;;457    static void freereg (FuncState *fs, int reg) {
000000  f890202e          LDRB     r2,[r0,#0x2e]
;;;458      if (reg >= fs->nactvar) {
000004  428a              CMP      r2,r1
000006  dc05              BGT      |L32.20|
;;;459        fs->freereg--;
000008  f8902030          LDRB     r2,[r0,#0x30]
00000c  1e52              SUBS     r2,r2,#1
00000e  f8802030          STRB     r2,[r0,#0x30]
;;;460        lua_assert(reg == fs->freereg);
000012  bf00              NOP      
                  |L32.20|
;;;461      }
;;;462    }
000014  4770              BX       lr
;;;463    
                          ENDP


                          AREA ||i.freeregs||, CODE, READONLY, ALIGN=1

                  freeregs PROC
;;;467    */
;;;468    static void freeregs (FuncState *fs, int r1, int r2) {
000000  b570              PUSH     {r4-r6,lr}
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
000006  4614              MOV      r4,r2
;;;469      if (r1 > r2) {
000008  42a5              CMP      r5,r4
00000a  dd08              BLE      |L33.30|
;;;470        freereg(fs, r1);
00000c  4629              MOV      r1,r5
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       freereg
;;;471        freereg(fs, r2);
000014  4621              MOV      r1,r4
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       freereg
00001c  e007              B        |L33.46|
                  |L33.30|
;;;472      }
;;;473      else {
;;;474        freereg(fs, r2);
00001e  4621              MOV      r1,r4
000020  4630              MOV      r0,r6
000022  f7fffffe          BL       freereg
;;;475        freereg(fs, r1);
000026  4629              MOV      r1,r5
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       freereg
                  |L33.46|
;;;476      }
;;;477    }
00002e  bd70              POP      {r4-r6,pc}
;;;478    
                          ENDP


                          AREA ||i.getjump||, CODE, READONLY, ALIGN=1

                  getjump PROC
;;;113    */
;;;114    static int getjump (FuncState *fs, int pc) {
000000  b510              PUSH     {r4,lr}
000002  4602              MOV      r2,r0
;;;115      int offset = GETARG_sJ(fs->f->code[pc]);
000004  6810              LDR      r0,[r2,#0]
000006  6b80              LDR      r0,[r0,#0x38]
000008  f8500021          LDR      r0,[r0,r1,LSL #2]
00000c  f06f447f          MVN      r4,#0xff000000
000010  ea042010          AND      r0,r4,r0,LSR #8
000014  1064              ASRS     r4,r4,#1
000016  1b03              SUBS     r3,r0,r4
;;;116      if (offset == NO_JUMP)  /* point to itself represents end of list */
000018  1c58              ADDS     r0,r3,#1
00001a  b910              CBNZ     r0,|L34.34|
;;;117        return NO_JUMP;  /* end of list */
00001c  f04f30ff          MOV      r0,#0xffffffff
                  |L34.32|
;;;118      else
;;;119        return (pc+1)+offset;  /* turn offset into absolute position */
;;;120    }
000020  bd10              POP      {r4,pc}
                  |L34.34|
000022  1c48              ADDS     r0,r1,#1              ;119
000024  4418              ADD      r0,r0,r3              ;119
000026  e7fb              B        |L34.32|
;;;121    
                          ENDP


                          AREA ||i.getjumpcontrol||, CODE, READONLY, ALIGN=2

                  getjumpcontrol PROC
;;;202    */
;;;203    static Instruction *getjumpcontrol (FuncState *fs, int pc) {
000000  b510              PUSH     {r4,lr}
000002  4603              MOV      r3,r0
;;;204      Instruction *pi = &fs->f->code[pc];
000004  6818              LDR      r0,[r3,#0]
000006  6b80              LDR      r0,[r0,#0x38]
000008  eb000281          ADD      r2,r0,r1,LSL #2
;;;205      if (pc >= 1 && testTMode(GET_OPCODE(*(pi-1))))
00000c  2901              CMP      r1,#1
00000e  db0a              BLT      |L35.38|
000010  f8120c04          LDRB     r0,[r2,#-4]
000014  f000007f          AND      r0,r0,#0x7f
000018  4c04              LDR      r4,|L35.44|
00001a  5c20              LDRB     r0,[r4,r0]
00001c  f0000010          AND      r0,r0,#0x10
000020  b108              CBZ      r0,|L35.38|
;;;206        return pi-1;
000022  1f10              SUBS     r0,r2,#4
                  |L35.36|
;;;207      else
;;;208        return pi;
;;;209    }
000024  bd10              POP      {r4,pc}
                  |L35.38|
000026  4610              MOV      r0,r2                 ;208
000028  e7fc              B        |L35.36|
;;;210    
                          ENDP

00002a  0000              DCW      0x0000
                  |L35.44|
                          DCD      luaP_opmodes

                          AREA ||i.isCint||, CODE, READONLY, ALIGN=1

                  isCint PROC
;;;1111   */
;;;1112   static int isCint (expdesc *e) {
000000  b510              PUSH     {r4,lr}
000002  4603              MOV      r3,r0
;;;1113     return luaK_isKint(e) && (l_castS2U(e->u.ival) <= l_castS2U(MAXARG_C));
000004  4618              MOV      r0,r3
000006  f7fffffe          BL       luaK_isKint
00000a  b140              CBZ      r0,|L36.30|
00000c  24ff              MOVS     r4,#0xff
00000e  2000              MOVS     r0,#0
000010  e9d31202          LDRD     r1,r2,[r3,#8]
000014  1a61              SUBS     r1,r4,r1
000016  4190              SBCS     r0,r0,r2
000018  d301              BCC      |L36.30|
00001a  2001              MOVS     r0,#1
                  |L36.28|
;;;1114   }
00001c  bd10              POP      {r4,pc}
                  |L36.30|
00001e  2000              MOVS     r0,#0                 ;1113
000020  e7fc              B        |L36.28|
;;;1115   
                          ENDP


                          AREA ||i.isKstr||, CODE, READONLY, ALIGN=1

                  isKstr PROC
;;;1094   */
;;;1095   static int isKstr (FuncState *fs, expdesc *e) {
000000  4602              MOV      r2,r0
;;;1096     return (e->k == VK && !hasjumps(e) && e->u.info <= MAXARG_B &&
000002  6808              LDR      r0,[r1,#0]
000004  2804              CMP      r0,#4
000006  d110              BNE      |L37.42|
000008  e9d10304          LDRD     r0,r3,[r1,#0x10]
00000c  4298              CMP      r0,r3
00000e  d10c              BNE      |L37.42|
000010  6888              LDR      r0,[r1,#8]
000012  28ff              CMP      r0,#0xff
000014  dc09              BGT      |L37.42|
;;;1097             ttisshrstring(&fs->f->k[e->u.info]));
000016  6810              LDR      r0,[r2,#0]
000018  6b00              LDR      r0,[r0,#0x30]
00001a  688b              LDR      r3,[r1,#8]
00001c  eb001003          ADD      r0,r0,r3,LSL #4
000020  7a00              LDRB     r0,[r0,#8]
000022  2854              CMP      r0,#0x54
000024  d101              BNE      |L37.42|
000026  2001              MOVS     r0,#1                 ;1096
                  |L37.40|
;;;1098   }
000028  4770              BX       lr
                  |L37.42|
00002a  2000              MOVS     r0,#0                 ;1096
00002c  e7fc              B        |L37.40|
;;;1099   
                          ENDP


                          AREA ||i.isSCint||, CODE, READONLY, ALIGN=1

                  isSCint PROC
;;;1120   */
;;;1121   static int isSCint (expdesc *e) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;1122     return luaK_isKint(e) && fitsC(e->u.ival);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       luaK_isKint
00000a  b138              CBZ      r0,|L38.28|
00000c  e9d42102          LDRD     r2,r1,[r4,#8]
000010  4610              MOV      r0,r2
000012  f7fffffe          BL       fitsC
000016  b108              CBZ      r0,|L38.28|
000018  2001              MOVS     r0,#1
                  |L38.26|
;;;1123   }
00001a  bd10              POP      {r4,pc}
                  |L38.28|
00001c  2000              MOVS     r0,#0                 ;1122
00001e  e7fc              B        |L38.26|
;;;1124   
                          ENDP


                          AREA ||i.isSCnumber||, CODE, READONLY, ALIGN=1

                  isSCnumber PROC
;;;1129   */
;;;1130   static int isSCnumber (expdesc *e, lua_Integer *i) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;1131     if (e->k == VKINT)
000008  6820              LDR      r0,[r4,#0]
00000a  2806              CMP      r0,#6
00000c  d104              BNE      |L39.24|
;;;1132       *i = e->u.ival;
00000e  e9d40102          LDRD     r0,r1,[r4,#8]
000012  e9c50100          STRD     r0,r1,[r5,#0]
000016  e00c              B        |L39.50|
                  |L39.24|
;;;1133     else if (!(e->k == VKFLT && floatI(e->u.nval, i)))
000018  6820              LDR      r0,[r4,#0]
00001a  2805              CMP      r0,#5
00001c  d106              BNE      |L39.44|
00001e  462a              MOV      r2,r5
000020  e9d46102          LDRD     r6,r1,[r4,#8]
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       floatI
00002a  b910              CBNZ     r0,|L39.50|
                  |L39.44|
;;;1134       return 0;  /* not a number */
00002c  2000              MOVS     r0,#0
                  |L39.46|
;;;1135     if (!hasjumps(e) && fitsC(*i)) {
;;;1136       *i += OFFSET_sC;
;;;1137       return 1;
;;;1138     }
;;;1139     else
;;;1140       return 0;
;;;1141   }
00002e  e8bd81f0          POP      {r4-r8,pc}
                  |L39.50|
000032  e9d40104          LDRD     r0,r1,[r4,#0x10]      ;1135
000036  4288              CMP      r0,r1                 ;1135
000038  d10f              BNE      |L39.90|
00003a  e9d52100          LDRD     r2,r1,[r5,#0]         ;1135
00003e  4610              MOV      r0,r2                 ;1135
000040  f7fffffe          BL       fitsC
000044  b148              CBZ      r0,|L39.90|
000046  227f              MOVS     r2,#0x7f              ;1136
000048  e9d53000          LDRD     r3,r0,[r5,#0]         ;1136
00004c  189a              ADDS     r2,r3,r2              ;1136
00004e  f1400000          ADC      r0,r0,#0              ;1136
000052  e9c52000          STRD     r2,r0,[r5,#0]         ;1136
000056  2001              MOVS     r0,#1                 ;1137
000058  e7e9              B        |L39.46|
                  |L39.90|
00005a  2000              MOVS     r0,#0                 ;1140
00005c  e7e7              B        |L39.46|
;;;1142   
                          ENDP


                          AREA ||i.jumponcond||, CODE, READONLY, ALIGN=1

                  jumponcond PROC
;;;988    */
;;;989    static int jumponcond (FuncState *fs, expdesc *e, int cond) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;990      if (e->k == VRELOC) {
000008  6828              LDR      r0,[r5,#0]
00000a  280f              CMP      r0,#0xf
00000c  d119              BNE      |L40.66|
;;;991        Instruction ie = getinstruction(fs, e);
00000e  6820              LDR      r0,[r4,#0]
000010  6b80              LDR      r0,[r0,#0x38]
000012  68a9              LDR      r1,[r5,#8]
000014  f8507021          LDR      r7,[r0,r1,LSL #2]
;;;992        if (GET_OPCODE(ie) == OP_NOT) {
000018  f007007f          AND      r0,r7,#0x7f
00001c  282d              CMP      r0,#0x2d
00001e  d10f              BNE      |L40.64|
;;;993          fs->pc--;  /* remove previous OP_NOT */
000020  6920              LDR      r0,[r4,#0x10]
000022  1e40              SUBS     r0,r0,#1
000024  6120              STR      r0,[r4,#0x10]
;;;994          return condjump(fs, OP_TEST, GETARG_B(ie), 0, !cond);
000026  b90e              CBNZ     r6,|L40.44|
000028  2001              MOVS     r0,#1
00002a  e000              B        |L40.46|
                  |L40.44|
00002c  2000              MOVS     r0,#0
                  |L40.46|
00002e  2300              MOVS     r3,#0
000030  f3c74207          UBFX     r2,r7,#16,#8
000034  213b              MOVS     r1,#0x3b
000036  9000              STR      r0,[sp,#0]
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       condjump
                  |L40.62|
;;;995        }
;;;996        /* else go through */
;;;997      }
;;;998      discharge2anyreg(fs, e);
;;;999      freeexp(fs, e);
;;;1000     return condjump(fs, OP_TESTSET, NO_REG, e->u.info, cond);
;;;1001   }
00003e  bdf8              POP      {r3-r7,pc}
                  |L40.64|
000040  bf00              NOP                            ;997
                  |L40.66|
000042  4629              MOV      r1,r5                 ;998
000044  4620              MOV      r0,r4                 ;998
000046  f7fffffe          BL       discharge2anyreg
00004a  4629              MOV      r1,r5                 ;999
00004c  4620              MOV      r0,r4                 ;999
00004e  f7fffffe          BL       freeexp
000052  9600              STR      r6,[sp,#0]            ;1000
000054  22ff              MOVS     r2,#0xff              ;1000
000056  213c              MOVS     r1,#0x3c              ;1000
000058  4620              MOV      r0,r4                 ;1000
00005a  68ab              LDR      r3,[r5,#8]            ;1000
00005c  f7fffffe          BL       condjump
000060  e7ed              B        |L40.62|
;;;1002   
                          ENDP


                          AREA ||i.luaK_checkstack||, CODE, READONLY, ALIGN=2

                  luaK_checkstack PROC
;;;431    */
;;;432    void luaK_checkstack (FuncState *fs, int n) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;433      int newstack = fs->freereg + n;
000006  f8940030          LDRB     r0,[r4,#0x30]
00000a  1985              ADDS     r5,r0,r6
;;;434      if (newstack > fs->f->maxstacksize) {
00000c  6820              LDR      r0,[r4,#0]
00000e  7a00              LDRB     r0,[r0,#8]
000010  42a8              CMP      r0,r5
000012  da07              BGE      |L41.36|
;;;435        if (newstack >= MAXREGS)
000014  2dff              CMP      r5,#0xff
000016  db03              BLT      |L41.32|
;;;436          luaX_syntaxerror(fs->ls,
000018  a103              ADR      r1,|L41.40|
00001a  68a0              LDR      r0,[r4,#8]
00001c  f7fffffe          BL       luaX_syntaxerror
                  |L41.32|
;;;437            "function or expression needs too many registers");
;;;438        fs->f->maxstacksize = cast_byte(newstack);
000020  6821              LDR      r1,[r4,#0]
000022  720d              STRB     r5,[r1,#8]
                  |L41.36|
;;;439      }
;;;440    }
000024  bd70              POP      {r4-r6,pc}
;;;441    
                          ENDP

000026  0000              DCW      0x0000
                  |L41.40|
000028  66756e63          DCB      "function or expression needs too many registers",0
00002c  74696f6e
000030  206f7220
000034  65787072
000038  65737369
00003c  6f6e206e
000040  65656473
000044  20746f6f
000048  206d616e
00004c  79207265
000050  67697374
000054  65727300

                          AREA ||i.luaK_code||, CODE, READONLY, ALIGN=2

                  luaK_code PROC
;;;343    */
;;;344    static int luaK_code (FuncState *fs, Instruction i) {
000000  b5fe              PUSH     {r1-r7,lr}
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;345      Proto *f = fs->f;
000006  6825              LDR      r5,[r4,#0]
;;;346      /* put new instruction in code array */
;;;347      luaM_growvector(fs->ls->L, f->code, fs->pc, f->sizecode, Instruction,
000008  a00f              ADR      r0,|L42.72|
00000a  f06f4140          MVN      r1,#0xc0000000
00000e  2204              MOVS     r2,#4
000010  e9cd2100          STRD     r2,r1,[sp,#0]
000014  9002              STR      r0,[sp,#8]
000016  6922              LDR      r2,[r4,#0x10]
000018  6ba9              LDR      r1,[r5,#0x38]
00001a  68a3              LDR      r3,[r4,#8]
00001c  6b58              LDR      r0,[r3,#0x34]
00001e  f1050314          ADD      r3,r5,#0x14
000022  f7fffffe          BL       luaM_growaux_
000026  63a8              STR      r0,[r5,#0x38]
;;;348                      MAX_INT, "opcodes");
;;;349      f->code[fs->pc] = i;
000028  6ba8              LDR      r0,[r5,#0x38]
00002a  6921              LDR      r1,[r4,#0x10]
00002c  f8406021          STR      r6,[r0,r1,LSL #2]
;;;350      savelineinfo(fs, f, fs->pc, fs->ls->lastline);
000030  68a0              LDR      r0,[r4,#8]
000032  6883              LDR      r3,[r0,#8]
000034  4629              MOV      r1,r5
000036  4620              MOV      r0,r4
000038  6922              LDR      r2,[r4,#0x10]
00003a  f7fffffe          BL       savelineinfo
;;;351      return fs->pc++;
00003e  6920              LDR      r0,[r4,#0x10]
000040  1c41              ADDS     r1,r0,#1
000042  6121              STR      r1,[r4,#0x10]
;;;352    }
000044  bdfe              POP      {r1-r7,pc}
;;;353    
                          ENDP

000046  0000              DCW      0x0000
                  |L42.72|
000048  6f70636f          DCB      "opcodes",0
00004c  64657300

                          AREA ||i.luaK_codeABCk||, CODE, READONLY, ALIGN=1

                  luaK_codeABCk PROC
;;;358    */
;;;359    int luaK_codeABCk (FuncState *fs, OpCode o, int a, int b, int c, int k) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
00000c  e9dd8908          LDRD     r8,r9,[sp,#0x20]
;;;360      lua_assert(getOpMode(o) == iABC);
;;;361      lua_assert(a <= MAXARG_A && b <= MAXARG_B &&
;;;362                 c <= MAXARG_C && (k & ~1) == 0);
;;;363      return luaK_code(fs, CREATE_ABCk(o, a, b, c, k));
000010  ea4410c5          ORR      r0,r4,r5,LSL #7
000014  ea404006          ORR      r0,r0,r6,LSL #16
000018  ea406008          ORR      r0,r0,r8,LSL #24
00001c  ea4031c9          ORR      r1,r0,r9,LSL #15
000020  4638              MOV      r0,r7
000022  f7fffffe          BL       luaK_code
;;;364    }
000026  e8bd87f0          POP      {r4-r10,pc}
;;;365    
                          ENDP


                          AREA ||i.luaK_codeABx||, CODE, READONLY, ALIGN=1

                  luaK_codeABx PROC
;;;373    */
;;;374    int luaK_codeABx (FuncState *fs, OpCode o, int a, unsigned int bc) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
;;;375      lua_assert(getOpMode(o) == iABx);
;;;376      lua_assert(a <= MAXARG_A && bc <= MAXARG_Bx);
;;;377      return luaK_code(fs, CREATE_ABx(o, a, bc));
00000c  ea4410c5          ORR      r0,r4,r5,LSL #7
000010  ea4031c6          ORR      r1,r0,r6,LSL #15
000014  4638              MOV      r0,r7
000016  f7fffffe          BL       luaK_code
;;;378    }
00001a  e8bd81f0          POP      {r4-r8,pc}
;;;379    
                          ENDP


                          AREA ||i.luaK_codeAsBx||, CODE, READONLY, ALIGN=1

                  luaK_codeAsBx PROC
;;;383    */
;;;384    int luaK_codeAsBx (FuncState *fs, OpCode o, int a, int bc) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
;;;385      unsigned int b = bc + OFFSET_sBx;
00000c  f64f70ff          MOV      r0,#0xffff
000010  eb060800          ADD      r8,r6,r0
;;;386      lua_assert(getOpMode(o) == iAsBx);
;;;387      lua_assert(a <= MAXARG_A && b <= MAXARG_Bx);
;;;388      return luaK_code(fs, CREATE_ABx(o, a, b));
000014  ea4410c5          ORR      r0,r4,r5,LSL #7
000018  ea4031c8          ORR      r1,r0,r8,LSL #15
00001c  4638              MOV      r0,r7
00001e  f7fffffe          BL       luaK_code
;;;389    }
000022  e8bd81f0          POP      {r4-r8,pc}
;;;390    
                          ENDP


                          AREA ||i.luaK_codek||, CODE, READONLY, ALIGN=1

                  luaK_codek PROC
;;;416    */
;;;417    static int luaK_codek (FuncState *fs, int reg, int k) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4614              MOV      r4,r2
;;;418      if (k <= MAXARG_Bx)
00000a  f5b43f00          CMP      r4,#0x20000
00000e  da07              BGE      |L46.32|
;;;419        return luaK_codeABx(fs, OP_LOADK, reg, k);
000010  4623              MOV      r3,r4
000012  462a              MOV      r2,r5
000014  2103              MOVS     r1,#3
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       luaK_codeABx
                  |L46.28|
;;;420      else {
;;;421        int p = luaK_codeABx(fs, OP_LOADKX, reg, 0);
;;;422        codeextraarg(fs, k);
;;;423        return p;
;;;424      }
;;;425    }
00001c  e8bd81f0          POP      {r4-r8,pc}
                  |L46.32|
000020  2300              MOVS     r3,#0                 ;421
000022  462a              MOV      r2,r5                 ;421
000024  2104              MOVS     r1,#4                 ;421
000026  4630              MOV      r0,r6                 ;421
000028  f7fffffe          BL       luaK_codeABx
00002c  4607              MOV      r7,r0                 ;421
00002e  4621              MOV      r1,r4                 ;422
000030  4630              MOV      r0,r6                 ;422
000032  f7fffffe          BL       codeextraarg
000036  4638              MOV      r0,r7                 ;423
000038  e7f0              B        |L46.28|
;;;426    
                          ENDP


                          AREA ||i.luaK_codeundef||, CODE, READONLY, ALIGN=1

                  luaK_codeundef PROC
;;;1447   
;;;1448   void luaK_codeundef (FuncState *fs, expdesc *v) {
000000  b57c              PUSH     {r2-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1449     normalizeindexed(fs, v);
000006  4621              MOV      r1,r4
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       normalizeindexed
;;;1450     v->u.info = luaK_codeABC(fs, OP_UNDEF, v->u.ind.t, v->u.ind.idx, 0);
00000e  2000              MOVS     r0,#0
000010  9000              STR      r0,[sp,#0]
000012  9001              STR      r0,[sp,#4]
000014  f9b43008          LDRSH    r3,[r4,#8]
000018  7aa2              LDRB     r2,[r4,#0xa]
00001a  213d              MOVS     r1,#0x3d
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       luaK_codeABCk
000022  60a0              STR      r0,[r4,#8]
;;;1451     v->k = VRELOC;
000024  200f              MOVS     r0,#0xf
000026  6020              STR      r0,[r4,#0]
;;;1452   }
000028  bd7c              POP      {r2-r6,pc}
;;;1453   
                          ENDP


                          AREA ||i.luaK_concat||, CODE, READONLY, ALIGN=1

                  luaK_concat PROC
;;;140    */
;;;141    void luaK_concat (FuncState *fs, int *l1, int l2) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;142      if (l2 == NO_JUMP) return;  /* nothing to concatenate? */
00000a  1c68              ADDS     r0,r5,#1
00000c  b908              CBNZ     r0,|L48.18|
                  |L48.14|
;;;143      else if (*l1 == NO_JUMP)  /* no original list? */
;;;144        *l1 = l2;  /* 'l1' points to 'l2' */
;;;145      else {
;;;146        int list = *l1;
;;;147        int next;
;;;148        while ((next = getjump(fs, list)) != NO_JUMP)  /* find last element */
;;;149          list = next;
;;;150        fixjump(fs, list, l2);  /* last element links to 'l2' */
;;;151      }
;;;152    }
00000e  e8bd81f0          POP      {r4-r8,pc}
                  |L48.18|
000012  6820              LDR      r0,[r4,#0]            ;143
000014  1c40              ADDS     r0,r0,#1              ;143
000016  b908              CBNZ     r0,|L48.28|
000018  6025              STR      r5,[r4,#0]            ;144
00001a  e011              B        |L48.64|
                  |L48.28|
00001c  f8d48000          LDR      r8,[r4,#0]            ;146
000020  e000              B        |L48.36|
                  |L48.34|
000022  46b0              MOV      r8,r6                 ;149
                  |L48.36|
000024  4641              MOV      r1,r8                 ;148
000026  4638              MOV      r0,r7                 ;148
000028  f7fffffe          BL       getjump
00002c  4606              MOV      r6,r0                 ;148
00002e  1c40              ADDS     r0,r0,#1              ;148
000030  2800              CMP      r0,#0                 ;148
000032  d1f6              BNE      |L48.34|
000034  462a              MOV      r2,r5                 ;150
000036  4641              MOV      r1,r8                 ;150
000038  4638              MOV      r0,r7                 ;150
00003a  f7fffffe          BL       fixjump
00003e  bf00              NOP                            ;151
                  |L48.64|
000040  bf00              NOP      
000042  e7e4              B        |L48.14|
;;;153    
                          ENDP


                          AREA ||i.luaK_dischargevars||, CODE, READONLY, ALIGN=2

                  luaK_dischargevars PROC
;;;674    */
;;;675    void luaK_dischargevars (FuncState *fs, expdesc *e) {
000000  b57c              PUSH     {r2-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;676      switch (e->k) {
000006  6820              LDR      r0,[r4,#0]
000008  3808              SUBS     r0,r0,#8
00000a  280b              CMP      r0,#0xb
00000c  d26c              BCS      |L49.232|
00000e  e8dff000          TBB      [pc,r0]
000012  060e              DCB      0x06,0x0e
000014  501b2a3d          DCB      0x50,0x1b,0x2a,0x3d
000018  6b6b6665          DCB      0x6b,0x6b,0x66,0x65
00001c  0900              DCB      0x09,0x00
;;;677        case VLOCAL: {  /* already in a register */
;;;678          e->k = VNONRELOC;  /* becomes a non-relocatable value */
00001e  2007              MOVS     r0,#7
000020  6020              STR      r0,[r4,#0]
;;;679          break;
000022  e062              B        |L49.234|
;;;680        }
;;;681        case VUNDEF: {  /* not a real expression */
;;;682          luaK_semerror(fs->ls, "'undef' is not a value!!");
000024  a132              ADR      r1,|L49.240|
000026  68a8              LDR      r0,[r5,#8]
000028  f7fffffe          BL       luaK_semerror
;;;683          break;
00002c  e05d              B        |L49.234|
;;;684        }
;;;685        case VUPVAL: {  /* move value to some (pending) register */
;;;686          e->u.info = luaK_codeABC(fs, OP_GETUPVAL, 0, e->u.info, 0);
00002e  2000              MOVS     r0,#0
000030  9000              STR      r0,[sp,#0]
000032  9001              STR      r0,[sp,#4]
000034  4602              MOV      r2,r0
000036  2107              MOVS     r1,#7
000038  4628              MOV      r0,r5
00003a  68a3              LDR      r3,[r4,#8]
00003c  f7fffffe          BL       luaK_codeABCk
000040  60a0              STR      r0,[r4,#8]
;;;687          e->k = VRELOC;
000042  200f              MOVS     r0,#0xf
000044  6020              STR      r0,[r4,#0]
;;;688          break;
000046  e050              B        |L49.234|
;;;689        }
;;;690        case VINDEXUP: {
;;;691          e->u.info = luaK_codeABC(fs, OP_GETTABUP, 0, e->u.ind.t, e->u.ind.idx);
000048  2100              MOVS     r1,#0
00004a  f9b40008          LDRSH    r0,[r4,#8]
00004e  e9cd0100          STRD     r0,r1,[sp,#0]
000052  7aa3              LDRB     r3,[r4,#0xa]
000054  460a              MOV      r2,r1
000056  2109              MOVS     r1,#9
000058  4628              MOV      r0,r5
00005a  f7fffffe          BL       luaK_codeABCk
00005e  60a0              STR      r0,[r4,#8]
;;;692          e->k = VRELOC;
000060  200f              MOVS     r0,#0xf
000062  6020              STR      r0,[r4,#0]
;;;693          break;
000064  e041              B        |L49.234|
;;;694        }
;;;695        case VINDEXI: {
;;;696          freereg(fs, e->u.ind.t);
000066  7aa1              LDRB     r1,[r4,#0xa]
000068  4628              MOV      r0,r5
00006a  f7fffffe          BL       freereg
;;;697          e->u.info = luaK_codeABC(fs, OP_GETI, 0, e->u.ind.t, e->u.ind.idx);
00006e  2100              MOVS     r1,#0
000070  f9b40008          LDRSH    r0,[r4,#8]
000074  e9cd0100          STRD     r0,r1,[sp,#0]
000078  7aa3              LDRB     r3,[r4,#0xa]
00007a  460a              MOV      r2,r1
00007c  210b              MOVS     r1,#0xb
00007e  4628              MOV      r0,r5
000080  f7fffffe          BL       luaK_codeABCk
000084  60a0              STR      r0,[r4,#8]
;;;698          e->k = VRELOC;
000086  200f              MOVS     r0,#0xf
000088  6020              STR      r0,[r4,#0]
;;;699          break;
00008a  e02e              B        |L49.234|
;;;700        }
;;;701        case VINDEXSTR: {
;;;702          freereg(fs, e->u.ind.t);
00008c  7aa1              LDRB     r1,[r4,#0xa]
00008e  4628              MOV      r0,r5
000090  f7fffffe          BL       freereg
;;;703          e->u.info = luaK_codeABC(fs, OP_GETFIELD, 0, e->u.ind.t, e->u.ind.idx);
000094  2100              MOVS     r1,#0
000096  f9b40008          LDRSH    r0,[r4,#8]
00009a  e9cd0100          STRD     r0,r1,[sp,#0]
00009e  7aa3              LDRB     r3,[r4,#0xa]
0000a0  460a              MOV      r2,r1
0000a2  210c              MOVS     r1,#0xc
0000a4  4628              MOV      r0,r5
0000a6  f7fffffe          BL       luaK_codeABCk
0000aa  60a0              STR      r0,[r4,#8]
;;;704          e->k = VRELOC;
0000ac  200f              MOVS     r0,#0xf
0000ae  6020              STR      r0,[r4,#0]
;;;705          break;
0000b0  e01b              B        |L49.234|
;;;706        }
;;;707        case VINDEXED: {
;;;708          freeregs(fs, e->u.ind.t, e->u.ind.idx);
0000b2  f9b42008          LDRSH    r2,[r4,#8]
0000b6  7aa1              LDRB     r1,[r4,#0xa]
0000b8  4628              MOV      r0,r5
0000ba  f7fffffe          BL       freeregs
;;;709          e->u.info = luaK_codeABC(fs, OP_GETTABLE, 0, e->u.ind.t, e->u.ind.idx);
0000be  2100              MOVS     r1,#0
0000c0  f9b40008          LDRSH    r0,[r4,#8]
0000c4  e9cd0100          STRD     r0,r1,[sp,#0]
0000c8  7aa3              LDRB     r3,[r4,#0xa]
0000ca  460a              MOV      r2,r1
0000cc  210a              MOVS     r1,#0xa
0000ce  4628              MOV      r0,r5
0000d0  f7fffffe          BL       luaK_codeABCk
0000d4  60a0              STR      r0,[r4,#8]
;;;710          e->k = VRELOC;
0000d6  200f              MOVS     r0,#0xf
0000d8  6020              STR      r0,[r4,#0]
;;;711          break;
0000da  e006              B        |L49.234|
;;;712        }
;;;713        case VVARARG: case VCALL: {
0000dc  bf00              NOP      
;;;714          luaK_setoneret(fs, e);
0000de  4621              MOV      r1,r4
0000e0  4628              MOV      r0,r5
0000e2  f7fffffe          BL       luaK_setoneret
;;;715          break;
0000e6  e000              B        |L49.234|
                  |L49.232|
;;;716        }
;;;717        default: break;  /* there is one value available (somewhere) */
0000e8  bf00              NOP      
                  |L49.234|
0000ea  bf00              NOP                            ;679
;;;718      }
;;;719    }
0000ec  bd7c              POP      {r2-r6,pc}
;;;720    
                          ENDP

0000ee  0000              DCW      0x0000
                  |L49.240|
0000f0  27756e64          DCB      "'undef' is not a value!!",0
0000f4  65662720
0000f8  6973206e
0000fc  6f742061
000100  2076616c
000104  75652121
000108  00      
000109  00                DCB      0
00010a  00                DCB      0
00010b  00                DCB      0

                          AREA ||i.luaK_exp2RK||, CODE, READONLY, ALIGN=1

                  luaK_exp2RK PROC
;;;889    */
;;;890    int luaK_exp2RK (FuncState *fs, expdesc *e) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;891      luaK_exp2val(fs, e);
000008  4621              MOV      r1,r4
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       luaK_exp2val
;;;892      switch (e->k) {  /* move constants to 'k' */
000010  6820              LDR      r0,[r4,#0]
000012  2807              CMP      r0,#7
000014  d230              BCS      |L50.120|
000016  e8dff000          TBB      [pc,r0]
00001a  2f10              DCB      0x2f,0x10
00001c  040a251d          DCB      0x04,0x0a,0x25,0x1d
000020  1500              DCB      0x15,0x00
;;;893        case VTRUE: e->u.info = boolK(fs, 1); goto vk;
000022  2101              MOVS     r1,#1
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       boolK
00002a  60a0              STR      r0,[r4,#8]
00002c  e01b              B        |L50.102|
;;;894        case VFALSE: e->u.info = boolK(fs, 0); goto vk;
00002e  2100              MOVS     r1,#0
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       boolK
000036  60a0              STR      r0,[r4,#8]
000038  e015              B        |L50.102|
;;;895        case VNIL: e->u.info = nilK(fs); goto vk;
00003a  4628              MOV      r0,r5
00003c  f7fffffe          BL       nilK
000040  60a0              STR      r0,[r4,#8]
000042  e010              B        |L50.102|
;;;896        case VKINT: e->u.info = luaK_intK(fs, e->u.ival); goto vk;
000044  e9d46302          LDRD     r6,r3,[r4,#8]
000048  4632              MOV      r2,r6
00004a  4628              MOV      r0,r5
00004c  f7fffffe          BL       luaK_intK
000050  60a0              STR      r0,[r4,#8]
000052  e008              B        |L50.102|
;;;897        case VKFLT: e->u.info = luaK_numberK(fs, e->u.nval); goto vk;
000054  e9d46302          LDRD     r6,r3,[r4,#8]
000058  4632              MOV      r2,r6
00005a  4628              MOV      r0,r5
00005c  f7fffffe          BL       luaK_numberK
000060  60a0              STR      r0,[r4,#8]
000062  e000              B        |L50.102|
;;;898        case VK:
;;;899         vk:
000064  bf00              NOP      
                  |L50.102|
;;;900          e->k = VK;
000066  2004              MOVS     r0,#4
000068  6020              STR      r0,[r4,#0]
;;;901          if (e->u.info <= MAXINDEXRK)  /* constant fits in 'argC'? */
00006a  68a0              LDR      r0,[r4,#8]
00006c  28ff              CMP      r0,#0xff
00006e  dc02              BGT      |L50.118|
;;;902            return 1;
000070  2001              MOVS     r0,#1
                  |L50.114|
;;;903          else break;
;;;904        default: break;
;;;905      }
;;;906      /* not a constant in the right range: put it in a register */
;;;907      luaK_exp2anyreg(fs, e);
;;;908      return 0;
;;;909    }
000072  e8bd81f0          POP      {r4-r8,pc}
                  |L50.118|
000076  e000              B        |L50.122|
                  |L50.120|
000078  bf00              NOP                            ;904
                  |L50.122|
00007a  bf00              NOP                            ;903
00007c  4621              MOV      r1,r4                 ;907
00007e  4628              MOV      r0,r5                 ;907
000080  f7fffffe          BL       luaK_exp2anyreg
000084  2000              MOVS     r0,#0                 ;908
000086  e7f4              B        |L50.114|
;;;910    
                          ENDP


                          AREA ||i.luaK_exp2anyreg||, CODE, READONLY, ALIGN=1

                  luaK_exp2anyreg PROC
;;;846    */
;;;847    int luaK_exp2anyreg (FuncState *fs, expdesc *e) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;848      luaK_dischargevars(fs, e);
000006  4621              MOV      r1,r4
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       luaK_dischargevars
;;;849      if (e->k == VNONRELOC) {  /* expression already has a register? */
00000e  6820              LDR      r0,[r4,#0]
000010  2807              CMP      r0,#7
000012  d111              BNE      |L51.56|
;;;850        if (!hasjumps(e))  /* no jumps? */
000014  e9d40104          LDRD     r0,r1,[r4,#0x10]
000018  4288              CMP      r0,r1
00001a  d101              BNE      |L51.32|
;;;851          return e->u.info;  /* result is already in a register */
00001c  68a0              LDR      r0,[r4,#8]
                  |L51.30|
;;;852        if (e->u.info >= fs->nactvar) {  /* reg. is not a local? */
;;;853          exp2reg(fs, e, e->u.info);  /* put final result in it */
;;;854          return e->u.info;
;;;855        }
;;;856      }
;;;857      luaK_exp2nextreg(fs, e);  /* otherwise, use next available register */
;;;858      return e->u.info;
;;;859    }
00001e  bd70              POP      {r4-r6,pc}
                  |L51.32|
000020  f895102e          LDRB     r1,[r5,#0x2e]         ;852
000024  68a0              LDR      r0,[r4,#8]            ;852
000026  4288              CMP      r0,r1                 ;852
000028  db06              BLT      |L51.56|
00002a  4621              MOV      r1,r4                 ;853
00002c  4628              MOV      r0,r5                 ;853
00002e  68a2              LDR      r2,[r4,#8]            ;853
000030  f7fffffe          BL       exp2reg
000034  68a0              LDR      r0,[r4,#8]            ;854
000036  e7f2              B        |L51.30|
                  |L51.56|
000038  4621              MOV      r1,r4                 ;857
00003a  4628              MOV      r0,r5                 ;857
00003c  f7fffffe          BL       luaK_exp2nextreg
000040  68a0              LDR      r0,[r4,#8]            ;858
000042  e7ec              B        |L51.30|
;;;860    
                          ENDP


                          AREA ||i.luaK_exp2anyregup||, CODE, READONLY, ALIGN=1

                  luaK_exp2anyregup PROC
;;;865    */
;;;866    void luaK_exp2anyregup (FuncState *fs, expdesc *e) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;867      if (e->k != VUPVAL || hasjumps(e))
000006  6820              LDR      r0,[r4,#0]
000008  2809              CMP      r0,#9
00000a  d103              BNE      |L52.20|
00000c  e9d40104          LDRD     r0,r1,[r4,#0x10]
000010  4288              CMP      r0,r1
000012  d003              BEQ      |L52.28|
                  |L52.20|
;;;868        luaK_exp2anyreg(fs, e);
000014  4621              MOV      r1,r4
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       luaK_exp2anyreg
                  |L52.28|
;;;869    }
00001c  bd70              POP      {r4-r6,pc}
;;;870    
                          ENDP


                          AREA ||i.luaK_exp2nextreg||, CODE, READONLY, ALIGN=1

                  luaK_exp2nextreg PROC
;;;834    */
;;;835    void luaK_exp2nextreg (FuncState *fs, expdesc *e) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;836      luaK_dischargevars(fs, e);
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       luaK_dischargevars
;;;837      freeexp(fs, e);
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       freeexp
;;;838      luaK_reserveregs(fs, 1);
000016  2101              MOVS     r1,#1
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       luaK_reserveregs
;;;839      exp2reg(fs, e, fs->freereg - 1);
00001e  f8940030          LDRB     r0,[r4,#0x30]
000022  1e42              SUBS     r2,r0,#1
000024  4629              MOV      r1,r5
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       exp2reg
;;;840    }
00002c  bd70              POP      {r4-r6,pc}
;;;841    
                          ENDP


                          AREA ||i.luaK_exp2val||, CODE, READONLY, ALIGN=1

                  luaK_exp2val PROC
;;;875    */
;;;876    void luaK_exp2val (FuncState *fs, expdesc *e) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;877      if (hasjumps(e))
000006  e9d40104          LDRD     r0,r1,[r4,#0x10]
00000a  4288              CMP      r0,r1
00000c  d004              BEQ      |L54.24|
;;;878        luaK_exp2anyreg(fs, e);
00000e  4621              MOV      r1,r4
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       luaK_exp2anyreg
000016  e003              B        |L54.32|
                  |L54.24|
;;;879      else
;;;880        luaK_dischargevars(fs, e);
000018  4621              MOV      r1,r4
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       luaK_dischargevars
                  |L54.32|
;;;881    }
000020  bd70              POP      {r4-r6,pc}
;;;882    
                          ENDP


                          AREA ||i.luaK_finish||, CODE, READONLY, ALIGN=1

                  luaK_finish PROC
;;;1686   */
;;;1687   void luaK_finish (FuncState *fs) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4607              MOV      r7,r0
;;;1688     int i;
;;;1689     Proto *p = fs->f;
000006  683c              LDR      r4,[r7,#0]
;;;1690     for (i = 0; i < fs->pc; i++) {
000008  2600              MOVS     r6,#0
00000a  e042              B        |L55.146|
                  |L55.12|
;;;1691       Instruction *pc = &p->code[i];
00000c  6ba0              LDR      r0,[r4,#0x38]
00000e  eb000586          ADD      r5,r0,r6,LSL #2
;;;1692       lua_assert(i == 0 || isOT(*(pc - 1)) == isIT(*pc));
;;;1693       switch (GET_OPCODE(*pc)) {
000012  7828              LDRB     r0,[r5,#0]
000014  f000007f          AND      r0,r0,#0x7f
000018  2841              CMP      r0,#0x41
00001a  d017              BEQ      |L55.76|
00001c  dc04              BGT      |L55.40|
00001e  2831              CMP      r0,#0x31
000020  d029              BEQ      |L55.118|
000022  2840              CMP      r0,#0x40
000024  d132              BNE      |L55.140|
000026  e012              B        |L55.78|
                  |L55.40|
000028  2842              CMP      r0,#0x42
00002a  d002              BEQ      |L55.50|
00002c  2843              CMP      r0,#0x43
00002e  d12d              BNE      |L55.140|
000030  e000              B        |L55.52|
                  |L55.50|
;;;1694         case OP_RETURN0: case OP_RETURN1: {
000032  bf00              NOP      
                  |L55.52|
;;;1695           if (p->sizep == 0 && !p->is_vararg)
000034  69e0              LDR      r0,[r4,#0x1c]
000036  b910              CBNZ     r0,|L55.62|
000038  79e0              LDRB     r0,[r4,#7]
00003a  b900              CBNZ     r0,|L55.62|
;;;1696             break;  /* no extra work */
00003c  e027              B        |L55.142|
                  |L55.62|
;;;1697           /* else use OP_RETURN to do the extra work */
;;;1698           SET_OPCODE(*pc, OP_RETURN);
00003e  6828              LDR      r0,[r5,#0]
000040  f020007f          BIC      r0,r0,#0x7f
000044  f0400041          ORR      r0,r0,#0x41
000048  6028              STR      r0,[r5,#0]
;;;1699           /* FALLTHROUGH */
;;;1700         }
;;;1701         case OP_RETURN: case OP_TAILCALL: {
00004a  bf00              NOP      
                  |L55.76|
00004c  bf00              NOP      
                  |L55.78|
;;;1702           if (p->sizep > 0 || p->is_vararg) {
00004e  69e0              LDR      r0,[r4,#0x1c]
000050  2800              CMP      r0,#0
000052  dc01              BGT      |L55.88|
000054  79e0              LDRB     r0,[r4,#7]
000056  b168              CBZ      r0,|L55.116|
                  |L55.88|
;;;1703             SETARG_C(*pc, p->is_vararg ? p->numparams + 1 : 0);
000058  79e0              LDRB     r0,[r4,#7]
00005a  b110              CBZ      r0,|L55.98|
00005c  79a0              LDRB     r0,[r4,#6]
00005e  1c40              ADDS     r0,r0,#1
000060  e000              B        |L55.100|
                  |L55.98|
000062  2000              MOVS     r0,#0
                  |L55.100|
000064  6829              LDR      r1,[r5,#0]
000066  f360611f          BFI      r1,r0,#24,#8
00006a  6029              STR      r1,[r5,#0]
;;;1704             SETARG_k(*pc, 1);  /* signal that there is extra work */
00006c  6828              LDR      r0,[r5,#0]
00006e  f4404000          ORR      r0,r0,#0x8000
000072  6028              STR      r0,[r5,#0]
                  |L55.116|
;;;1705           }
;;;1706           break;
000074  e00b              B        |L55.142|
                  |L55.118|
;;;1707         }
;;;1708         case OP_JMP: {
;;;1709           int target = finaltarget(p->code, i);
000076  4631              MOV      r1,r6
000078  6ba0              LDR      r0,[r4,#0x38]
00007a  f7fffffe          BL       finaltarget
00007e  4680              MOV      r8,r0
;;;1710           fixjump(fs, i, target);
000080  4642              MOV      r2,r8
000082  4631              MOV      r1,r6
000084  4638              MOV      r0,r7
000086  f7fffffe          BL       fixjump
;;;1711           break;
00008a  e000              B        |L55.142|
                  |L55.140|
;;;1712         }
;;;1713         default: break;
00008c  bf00              NOP      
                  |L55.142|
00008e  bf00              NOP                            ;1696
000090  1c76              ADDS     r6,r6,#1              ;1690
                  |L55.146|
000092  6938              LDR      r0,[r7,#0x10]         ;1690
000094  42b0              CMP      r0,r6                 ;1690
000096  dcb9              BGT      |L55.12|
;;;1714       }
;;;1715     }
;;;1716   }
000098  e8bd81f0          POP      {r4-r8,pc}
                          ENDP


                          AREA ||i.luaK_fixline||, CODE, READONLY, ALIGN=1

                  luaK_fixline PROC
;;;1629   */
;;;1630   void luaK_fixline (FuncState *fs, int line) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1631     Proto *f = fs->f;
000006  6826              LDR      r6,[r4,#0]
;;;1632     if (f->lineinfo[fs->pc - 1] == ABSLINEINFO) {
000008  6c71              LDR      r1,[r6,#0x44]
00000a  6920              LDR      r0,[r4,#0x10]
00000c  1e40              SUBS     r0,r0,#1
00000e  5608              LDRSB    r0,[r1,r0]
000010  3080              ADDS     r0,r0,#0x80
000012  b938              CBNZ     r0,|L56.36|
;;;1633       lua_assert(f->abslineinfo[fs->nabslineinfo - 1].pc == fs->pc - 1);
;;;1634       f->abslineinfo[fs->nabslineinfo - 1].line = line;
000014  6cb1              LDR      r1,[r6,#0x48]
000016  6a60              LDR      r0,[r4,#0x24]
000018  1e40              SUBS     r0,r0,#1
00001a  eb0100c0          ADD      r0,r1,r0,LSL #3
00001e  6045              STR      r5,[r0,#4]
;;;1635       fs->previousline = line;
000020  61a5              STR      r5,[r4,#0x18]
000022  e00d              B        |L56.64|
                  |L56.36|
;;;1636     }
;;;1637     else {
;;;1638       fs->previousline -= f->lineinfo[fs->pc - 1];  /* undo previous info. */
000024  6c71              LDR      r1,[r6,#0x44]
000026  6920              LDR      r0,[r4,#0x10]
000028  1e40              SUBS     r0,r0,#1
00002a  5608              LDRSB    r0,[r1,r0]
00002c  69a1              LDR      r1,[r4,#0x18]
00002e  1a08              SUBS     r0,r1,r0
000030  61a0              STR      r0,[r4,#0x18]
;;;1639       savelineinfo(fs, f, fs->pc - 1, line);  /* redo it */
000032  6920              LDR      r0,[r4,#0x10]
000034  1e42              SUBS     r2,r0,#1
000036  462b              MOV      r3,r5
000038  4631              MOV      r1,r6
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       savelineinfo
                  |L56.64|
;;;1640     }
;;;1641   }
000040  bd70              POP      {r4-r6,pc}
;;;1642   
                          ENDP


                          AREA ||i.luaK_float||, CODE, READONLY, ALIGN=1

                  luaK_float PROC
;;;619    
;;;620    static void luaK_float (FuncState *fs, int reg, lua_Number f) {
000000  e92d41fc          PUSH     {r2-r8,lr}
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
;;;621      lua_Integer fi;
;;;622      if (floatI(f, &fi))
00000c  466a              MOV      r2,sp
00000e  4620              MOV      r0,r4
000010  4629              MOV      r1,r5
000012  f7fffffe          BL       floatI
000016  b130              CBZ      r0,|L57.38|
;;;623        luaK_codeAsBx(fs, OP_LOADF, reg, cast_int(fi));
000018  4632              MOV      r2,r6
00001a  2102              MOVS     r1,#2
00001c  4638              MOV      r0,r7
00001e  9b00              LDR      r3,[sp,#0]
000020  f7fffffe          BL       luaK_codeAsBx
000024  e00a              B        |L57.60|
                  |L57.38|
;;;624      else
;;;625        luaK_codek(fs, reg, luaK_numberK(fs, f));
000026  4622              MOV      r2,r4
000028  462b              MOV      r3,r5
00002a  4638              MOV      r0,r7
00002c  f7fffffe          BL       luaK_numberK
000030  4680              MOV      r8,r0
000032  4642              MOV      r2,r8
000034  4631              MOV      r1,r6
000036  4638              MOV      r0,r7
000038  f7fffffe          BL       luaK_codek
                  |L57.60|
;;;626    }
00003c  e8bd81fc          POP      {r2-r8,pc}
;;;627    
                          ENDP


                          AREA ||i.luaK_getlabel||, CODE, READONLY, ALIGN=1

                  luaK_getlabel PROC
;;;191    */
;;;192    int luaK_getlabel (FuncState *fs) {
000000  4601              MOV      r1,r0
;;;193      fs->lasttarget = fs->pc;
000002  6908              LDR      r0,[r1,#0x10]
000004  6148              STR      r0,[r1,#0x14]
;;;194      return fs->pc;
000006  6908              LDR      r0,[r1,#0x10]
;;;195    }
000008  4770              BX       lr
;;;196    
                          ENDP


                          AREA ||i.luaK_goiffalse||, CODE, READONLY, ALIGN=1

                  luaK_goiffalse PROC
;;;1033   */
;;;1034   void luaK_goiffalse (FuncState *fs, expdesc *e) {
000000  b570              PUSH     {r4-r6,lr}
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;1035     int pc;  /* pc of new jump */
;;;1036     luaK_dischargevars(fs, e);
000006  4621              MOV      r1,r4
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       luaK_dischargevars
;;;1037     switch (e->k) {
00000e  6820              LDR      r0,[r4,#0]
000010  2801              CMP      r0,#1
000012  d005              BEQ      |L59.32|
000014  2803              CMP      r0,#3
000016  d004              BEQ      |L59.34|
000018  280e              CMP      r0,#0xe
00001a  d105              BNE      |L59.40|
;;;1038       case VJMP: {
;;;1039         pc = e->u.info;  /* already jump if true */
00001c  68a5              LDR      r5,[r4,#8]
;;;1040         break;
00001e  e00a              B        |L59.54|
                  |L59.32|
;;;1041       }
;;;1042       case VNIL: case VFALSE: {
000020  bf00              NOP      
                  |L59.34|
;;;1043         pc = NO_JUMP;  /* always false; do nothing */
000022  f04f35ff          MOV      r5,#0xffffffff
;;;1044         break;
000026  e006              B        |L59.54|
                  |L59.40|
;;;1045       }
;;;1046       default: {
;;;1047         pc = jumponcond(fs, e, 1);  /* jump if true */
000028  2201              MOVS     r2,#1
00002a  4621              MOV      r1,r4
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       jumponcond
000032  4605              MOV      r5,r0
;;;1048         break;
000034  bf00              NOP      
                  |L59.54|
000036  bf00              NOP                            ;1040
;;;1049       }
;;;1050     }
;;;1051     luaK_concat(fs, &e->t, pc);  /* insert new jump in 't' list */
000038  462a              MOV      r2,r5
00003a  f1040110          ADD      r1,r4,#0x10
00003e  4630              MOV      r0,r6
000040  f7fffffe          BL       luaK_concat
;;;1052     luaK_patchtohere(fs, e->f);  /* false list jumps to here (to go through) */
000044  4630              MOV      r0,r6
000046  6961              LDR      r1,[r4,#0x14]
000048  f7fffffe          BL       luaK_patchtohere
;;;1053     e->f = NO_JUMP;
00004c  f04f30ff          MOV      r0,#0xffffffff
000050  6160              STR      r0,[r4,#0x14]
;;;1054   }
000052  bd70              POP      {r4-r6,pc}
;;;1055   
                          ENDP


                          AREA ||i.luaK_goiftrue||, CODE, READONLY, ALIGN=1

                  luaK_goiftrue PROC
;;;1006   */
;;;1007   void luaK_goiftrue (FuncState *fs, expdesc *e) {
000000  b570              PUSH     {r4-r6,lr}
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;1008     int pc;  /* pc of new jump */
;;;1009     luaK_dischargevars(fs, e);
000006  4621              MOV      r1,r4
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       luaK_dischargevars
;;;1010     switch (e->k) {
00000e  6820              LDR      r0,[r4,#0]
000010  2805              CMP      r0,#5
000012  d010              BEQ      |L60.54|
000014  dc04              BGT      |L60.32|
000016  2802              CMP      r0,#2
000018  d00f              BEQ      |L60.58|
00001a  2804              CMP      r0,#4
00001c  d110              BNE      |L60.64|
00001e  e009              B        |L60.52|
                  |L60.32|
000020  2806              CMP      r0,#6
000022  d009              BEQ      |L60.56|
000024  280e              CMP      r0,#0xe
000026  d10b              BNE      |L60.64|
;;;1011       case VJMP: {  /* condition? */
;;;1012         negatecondition(fs, e);  /* jump when it is false */
000028  4621              MOV      r1,r4
00002a  4630              MOV      r0,r6
00002c  f7fffffe          BL       negatecondition
;;;1013         pc = e->u.info;  /* save jump position */
000030  68a5              LDR      r5,[r4,#8]
;;;1014         break;
000032  e00c              B        |L60.78|
                  |L60.52|
;;;1015       }
;;;1016       case VK: case VKFLT: case VKINT: case VTRUE: {
000034  bf00              NOP      
                  |L60.54|
000036  bf00              NOP      
                  |L60.56|
000038  bf00              NOP      
                  |L60.58|
;;;1017         pc = NO_JUMP;  /* always true; do nothing */
00003a  f04f35ff          MOV      r5,#0xffffffff
;;;1018         break;
00003e  e006              B        |L60.78|
                  |L60.64|
;;;1019       }
;;;1020       default: {
;;;1021         pc = jumponcond(fs, e, 0);  /* jump when false */
000040  2200              MOVS     r2,#0
000042  4621              MOV      r1,r4
000044  4630              MOV      r0,r6
000046  f7fffffe          BL       jumponcond
00004a  4605              MOV      r5,r0
;;;1022         break;
00004c  bf00              NOP      
                  |L60.78|
00004e  bf00              NOP                            ;1014
;;;1023       }
;;;1024     }
;;;1025     luaK_concat(fs, &e->f, pc);  /* insert new jump in false list */
000050  462a              MOV      r2,r5
000052  f1040114          ADD      r1,r4,#0x14
000056  4630              MOV      r0,r6
000058  f7fffffe          BL       luaK_concat
;;;1026     luaK_patchtohere(fs, e->t);  /* true list jumps to here (to go through) */
00005c  4630              MOV      r0,r6
00005e  6921              LDR      r1,[r4,#0x10]
000060  f7fffffe          BL       luaK_patchtohere
;;;1027     e->t = NO_JUMP;
000064  f04f30ff          MOV      r0,#0xffffffff
000068  6120              STR      r0,[r4,#0x10]
;;;1028   }
00006a  bd70              POP      {r4-r6,pc}
;;;1029   
                          ENDP


                          AREA ||i.luaK_indexed||, CODE, READONLY, ALIGN=1

                  luaK_indexed PROC
;;;1149   */
;;;1150   void luaK_indexed (FuncState *fs, expdesc *t, expdesc *k) {
000000  b570              PUSH     {r4-r6,lr}
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;1151     lua_assert(!hasjumps(t) && (vkisinreg(t->k) || t->k == VUPVAL));
;;;1152     if (t->k == VUPVAL && !isKstr(fs, k))  /* upvalue indexed by non string? */
000008  6820              LDR      r0,[r4,#0]
00000a  2809              CMP      r0,#9
00000c  d108              BNE      |L61.32|
00000e  4629              MOV      r1,r5
000010  4630              MOV      r0,r6
000012  f7fffffe          BL       isKstr
000016  b918              CBNZ     r0,|L61.32|
;;;1153       luaK_exp2anyreg(fs, t);  /* put it in a register */
000018  4621              MOV      r1,r4
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       luaK_exp2anyreg
                  |L61.32|
;;;1154     t->u.ind.t = t->u.info;  /* register or upvalue index */
000020  7a21              LDRB     r1,[r4,#8]
000022  72a1              STRB     r1,[r4,#0xa]
;;;1155     if (t->k == VUPVAL) {
000024  6820              LDR      r0,[r4,#0]
000026  2809              CMP      r0,#9
000028  d105              BNE      |L61.54|
;;;1156       t->u.ind.idx = k->u.info;  /* literal string */
00002a  8928              LDRH     r0,[r5,#8]
00002c  b200              SXTH     r0,r0
00002e  8120              STRH     r0,[r4,#8]
;;;1157       t->k = VINDEXUP;
000030  200b              MOVS     r0,#0xb
000032  6020              STR      r0,[r4,#0]
000034  e01c              B        |L61.112|
                  |L61.54|
;;;1158     }
;;;1159     else if (isKstr(fs, k)) {
000036  4629              MOV      r1,r5
000038  4630              MOV      r0,r6
00003a  f7fffffe          BL       isKstr
00003e  b128              CBZ      r0,|L61.76|
;;;1160       t->u.ind.idx = k->u.info;  /* literal string */
000040  8928              LDRH     r0,[r5,#8]
000042  b200              SXTH     r0,r0
000044  8120              STRH     r0,[r4,#8]
;;;1161       t->k = VINDEXSTR;
000046  200d              MOVS     r0,#0xd
000048  6020              STR      r0,[r4,#0]
00004a  e011              B        |L61.112|
                  |L61.76|
;;;1162     }
;;;1163     else if (isCint(k)) {
00004c  4628              MOV      r0,r5
00004e  f7fffffe          BL       isCint
000052  b128              CBZ      r0,|L61.96|
;;;1164       t->u.ind.idx = cast_int(k->u.ival);  /* integer constant in proper range */
000054  8928              LDRH     r0,[r5,#8]
000056  b200              SXTH     r0,r0
000058  8120              STRH     r0,[r4,#8]
;;;1165       t->k = VINDEXI;
00005a  200c              MOVS     r0,#0xc
00005c  6020              STR      r0,[r4,#0]
00005e  e007              B        |L61.112|
                  |L61.96|
;;;1166     }
;;;1167     else {
;;;1168       t->u.ind.idx = luaK_exp2anyreg(fs, k);  /* register */
000060  4629              MOV      r1,r5
000062  4630              MOV      r0,r6
000064  f7fffffe          BL       luaK_exp2anyreg
000068  b200              SXTH     r0,r0
00006a  8120              STRH     r0,[r4,#8]
;;;1169       t->k = VINDEXED;
00006c  200a              MOVS     r0,#0xa
00006e  6020              STR      r0,[r4,#0]
                  |L61.112|
;;;1170     }
;;;1171   }
000070  bd70              POP      {r4-r6,pc}
;;;1172   
                          ENDP


                          AREA ||i.luaK_infix||, CODE, READONLY, ALIGN=1

                  luaK_infix PROC
;;;1477   */
;;;1478   void luaK_infix (FuncState *fs, BinOpr op, expdesc *v) {
000000  b57c              PUSH     {r2-r6,lr}
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;1479     switch (op) {
000008  2c15              CMP      r4,#0x15
00000a  d24e              BCS      |L62.170|
00000c  e8dff004          TBB      [pc,r4]
000010  1a1b1c1f          DCB      0x1a,0x1b,0x1c,0x1f
000014  201d1e21          DCB      0x20,0x1d,0x1e,0x21
000018  22232425          DCB      0x22,0x23,0x24,0x25
00001c  152f4041          DCB      0x15,0x2f,0x40,0x41
000020  3042430b          DCB      0x30,0x42,0x43,0x0b
000024  1000              DCB      0x10,0x00
;;;1480       case OPR_AND: {
;;;1481         luaK_goiftrue(fs, v);  /* go ahead only if 'v' is true */
000026  4629              MOV      r1,r5
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       luaK_goiftrue
;;;1482         break;
00002e  e03d              B        |L62.172|
;;;1483       }
;;;1484       case OPR_OR: {
;;;1485         luaK_goiffalse(fs, v);  /* go ahead only if 'v' is false */
000030  4629              MOV      r1,r5
000032  4630              MOV      r0,r6
000034  f7fffffe          BL       luaK_goiffalse
;;;1486         break;
000038  e038              B        |L62.172|
;;;1487       }
;;;1488       case OPR_CONCAT: {
;;;1489         luaK_exp2nextreg(fs, v);  /* operand must be on the stack */
00003a  4629              MOV      r1,r5
00003c  4630              MOV      r0,r6
00003e  f7fffffe          BL       luaK_exp2nextreg
;;;1490         break;
000042  e033              B        |L62.172|
;;;1491       }
;;;1492       case OPR_ADD: case OPR_SUB:
000044  bf00              NOP      
;;;1493       case OPR_MUL: case OPR_DIV: case OPR_IDIV:
000046  bf00              NOP      
000048  bf00              NOP      
00004a  bf00              NOP      
;;;1494       case OPR_MOD: case OPR_POW:
00004c  bf00              NOP      
00004e  bf00              NOP      
;;;1495       case OPR_BAND: case OPR_BOR: case OPR_BXOR:
000050  bf00              NOP      
000052  bf00              NOP      
000054  bf00              NOP      
;;;1496       case OPR_SHL: case OPR_SHR: {
000056  bf00              NOP      
000058  bf00              NOP      
;;;1497         if (!tonumeral(v, NULL))
00005a  2100              MOVS     r1,#0
00005c  4628              MOV      r0,r5
00005e  f7fffffe          BL       tonumeral
000062  b918              CBNZ     r0,|L62.108|
;;;1498           luaK_exp2anyreg(fs, v);
000064  4629              MOV      r1,r5
000066  4630              MOV      r0,r6
000068  f7fffffe          BL       luaK_exp2anyreg
                  |L62.108|
;;;1499         /* else keep numeral, which may be folded with 2nd operand */
;;;1500         break;
00006c  e01e              B        |L62.172|
;;;1501       }
;;;1502       case OPR_EQ: case OPR_NE: {
00006e  bf00              NOP      
;;;1503         if (!tonumeral(v, NULL) && fs->ls->t.token != TK_UNDEF)
000070  2100              MOVS     r1,#0
000072  4628              MOV      r0,r5
000074  f7fffffe          BL       tonumeral
000078  b948              CBNZ     r0,|L62.142|
00007a  68b0              LDR      r0,[r6,#8]
00007c  6900              LDR      r0,[r0,#0x10]
00007e  f2401115          MOV      r1,#0x115
000082  4288              CMP      r0,r1
000084  d003              BEQ      |L62.142|
;;;1504           luaK_exp2RK(fs, v);
000086  4629              MOV      r1,r5
000088  4630              MOV      r0,r6
00008a  f7fffffe          BL       luaK_exp2RK
                  |L62.142|
;;;1505         /* else keep numeral, which may be an immediate operand */
;;;1506         break;
00008e  e00d              B        |L62.172|
;;;1507       }
;;;1508       case OPR_LT: case OPR_LE:
000090  bf00              NOP      
;;;1509       case OPR_GT: case OPR_GE: {
000092  bf00              NOP      
000094  bf00              NOP      
;;;1510         lua_Integer dummy;
;;;1511         if (!isSCnumber(v, &dummy))
000096  4669              MOV      r1,sp
000098  4628              MOV      r0,r5
00009a  f7fffffe          BL       isSCnumber
00009e  b918              CBNZ     r0,|L62.168|
;;;1512           luaK_exp2anyreg(fs, v);
0000a0  4629              MOV      r1,r5
0000a2  4630              MOV      r0,r6
0000a4  f7fffffe          BL       luaK_exp2anyreg
                  |L62.168|
;;;1513         /* else keep numeral, which may be an immediate operand */
;;;1514         break;
0000a8  e000              B        |L62.172|
                  |L62.170|
0000aa  bf00              NOP                            ;1479
                  |L62.172|
0000ac  bf00              NOP                            ;1482
;;;1515       }
;;;1516       default: lua_assert(0);
;;;1517     }
;;;1518   }
0000ae  bd7c              POP      {r2-r6,pc}
;;;1519   
                          ENDP


                          AREA ||i.luaK_int||, CODE, READONLY, ALIGN=1

                  luaK_int PROC
;;;606    
;;;607    void luaK_int (FuncState *fs, int reg, lua_Integer i) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
;;;608      if (fitsBx(i))
00000c  4620              MOV      r0,r4
00000e  4629              MOV      r1,r5
000010  f7fffffe          BL       fitsBx
000014  b130              CBZ      r0,|L63.36|
;;;609        luaK_codeAsBx(fs, OP_LOADI, reg, cast_int(i));
000016  4623              MOV      r3,r4
000018  4632              MOV      r2,r6
00001a  2101              MOVS     r1,#1
00001c  4638              MOV      r0,r7
00001e  f7fffffe          BL       luaK_codeAsBx
000022  e00a              B        |L63.58|
                  |L63.36|
;;;610      else
;;;611        luaK_codek(fs, reg, luaK_intK(fs, i));
000024  4622              MOV      r2,r4
000026  462b              MOV      r3,r5
000028  4638              MOV      r0,r7
00002a  f7fffffe          BL       luaK_intK
00002e  4680              MOV      r8,r0
000030  4642              MOV      r2,r8
000032  4631              MOV      r1,r6
000034  4638              MOV      r0,r7
000036  f7fffffe          BL       luaK_codek
                  |L63.58|
;;;612    }
00003a  e8bd81f0          POP      {r4-r8,pc}
;;;613    
                          ENDP


                          AREA ||i.luaK_intK||, CODE, READONLY, ALIGN=1

                  luaK_intK PROC
;;;549    */
;;;550    static int luaK_intK (FuncState *fs, lua_Integer n) {
000000  b570              PUSH     {r4-r6,lr}
000002  b088              SUB      sp,sp,#0x20
000004  4606              MOV      r6,r0
000006  4614              MOV      r4,r2
000008  461d              MOV      r5,r3
;;;551      TValue k, o;
;;;552      setpvalue(&k, cast_voidp(cast_sizet(n)));
00000a  a804              ADD      r0,sp,#0x10
00000c  6004              STR      r4,[r0,#0]
00000e  2102              MOVS     r1,#2
000010  7201              STRB     r1,[r0,#8]
;;;553      setivalue(&o, n);
000012  4668              MOV      r0,sp
000014  e9c04500          STRD     r4,r5,[r0,#0]
000018  2123              MOVS     r1,#0x23
00001a  7201              STRB     r1,[r0,#8]
;;;554      return addk(fs, &k, &o);
00001c  466a              MOV      r2,sp
00001e  a904              ADD      r1,sp,#0x10
000020  4630              MOV      r0,r6
000022  f7fffffe          BL       addk
;;;555    }
000026  b008              ADD      sp,sp,#0x20
000028  bd70              POP      {r4-r6,pc}
;;;556    
                          ENDP


                          AREA ||i.luaK_isKint||, CODE, READONLY, ALIGN=1

                  luaK_isKint PROC
;;;1102   */
;;;1103   int luaK_isKint (expdesc *e) {
000000  4601              MOV      r1,r0
;;;1104     return (e->k == VKINT && !hasjumps(e));
000002  6808              LDR      r0,[r1,#0]
000004  2806              CMP      r0,#6
000006  d105              BNE      |L65.20|
000008  e9d10204          LDRD     r0,r2,[r1,#0x10]
00000c  4290              CMP      r0,r2
00000e  d101              BNE      |L65.20|
000010  2001              MOVS     r0,#1
                  |L65.18|
;;;1105   }
000012  4770              BX       lr
                  |L65.20|
000014  2000              MOVS     r0,#0                 ;1104
000016  e7fc              B        |L65.18|
;;;1106   
                          ENDP


                          AREA ||i.luaK_jump||, CODE, READONLY, ALIGN=1

                  luaK_jump PROC
;;;158    */
;;;159    int luaK_jump (FuncState *fs) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;160      return codesJ(fs, OP_JMP, NO_JUMP, 0);
000004  2300              MOVS     r3,#0
000006  1e5a              SUBS     r2,r3,#1
000008  2131              MOVS     r1,#0x31
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       codesJ
;;;161    }
000010  bd10              POP      {r4,pc}
;;;162    
                          ENDP


                          AREA ||i.luaK_nil||, CODE, READONLY, ALIGN=1

                  luaK_nil PROC
;;;90     */
;;;91     void luaK_nil (FuncState *fs, int from, int n) {
000000  e92d41fc          PUSH     {r2-r8,lr}
000004  4680              MOV      r8,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
;;;92       int l = from + n - 1;  /* last register to set nil */
00000a  19a0              ADDS     r0,r4,r6
00000c  1e47              SUBS     r7,r0,#1
;;;93       Instruction *previous = previousinstruction(fs);
00000e  4640              MOV      r0,r8
000010  f7fffffe          BL       previousinstruction
000014  4605              MOV      r5,r0
;;;94       if (GET_OPCODE(*previous) == OP_LOADNIL) {  /* previous is LOADNIL? */
000016  7828              LDRB     r0,[r5,#0]
000018  f000007f          AND      r0,r0,#0x7f
00001c  2806              CMP      r0,#6
00001e  d122              BNE      |L67.102|
;;;95         int pfrom = GETARG_A(*previous);  /* get previous range */
000020  882a              LDRH     r2,[r5,#0]
000022  f3c210c7          UBFX     r0,r2,#7,#8
;;;96         int pl = pfrom + GETARG_B(*previous);
000026  682a              LDR      r2,[r5,#0]
000028  f3c24207          UBFX     r2,r2,#16,#8
00002c  1811              ADDS     r1,r2,r0
;;;97         if ((pfrom <= from && from <= pl + 1) ||
00002e  42a0              CMP      r0,r4
000030  dc02              BGT      |L67.56|
000032  1c4a              ADDS     r2,r1,#1
000034  4294              CMP      r4,r2
000036  dd04              BLE      |L67.66|
                  |L67.56|
;;;98             (from <= pfrom && pfrom <= l + 1)) {  /* can connect both? */
000038  4284              CMP      r4,r0
00003a  dc13              BGT      |L67.100|
00003c  1c7a              ADDS     r2,r7,#1
00003e  4290              CMP      r0,r2
000040  dc10              BGT      |L67.100|
                  |L67.66|
;;;99           if (pfrom < from) from = pfrom;  /* from = min(from, pfrom) */
000042  42a0              CMP      r0,r4
000044  da00              BGE      |L67.72|
000046  4604              MOV      r4,r0
                  |L67.72|
;;;100          if (pl > l) l = pl;  /* l = max(l, pl) */
000048  42b9              CMP      r1,r7
00004a  dd00              BLE      |L67.78|
00004c  460f              MOV      r7,r1
                  |L67.78|
;;;101          SETARG_A(*previous, from);
00004e  682a              LDR      r2,[r5,#0]
000050  f36412ce          BFI      r2,r4,#7,#8
000054  602a              STR      r2,[r5,#0]
;;;102          SETARG_B(*previous, l - from);
000056  1b3b              SUBS     r3,r7,r4
000058  682a              LDR      r2,[r5,#0]
00005a  f3634217          BFI      r2,r3,#16,#8
00005e  602a              STR      r2,[r5,#0]
                  |L67.96|
;;;103          return;
;;;104        }  /* else go through */
;;;105      }
;;;106      luaK_codeABC(fs, OP_LOADNIL, from, n - 1, 0);  /* else no optimization */
;;;107    }
000060  e8bd81fc          POP      {r2-r8,pc}
                  |L67.100|
000064  bf00              NOP                            ;105
                  |L67.102|
000066  2000              MOVS     r0,#0                 ;106
000068  9000              STR      r0,[sp,#0]            ;106
00006a  1e73              SUBS     r3,r6,#1              ;106
00006c  4622              MOV      r2,r4                 ;106
00006e  2106              MOVS     r1,#6                 ;106
000070  9001              STR      r0,[sp,#4]            ;106
000072  4640              MOV      r0,r8                 ;106
000074  f7fffffe          BL       luaK_codeABCk
000078  bf00              NOP      
00007a  e7f1              B        |L67.96|
;;;108    
                          ENDP


                          AREA ||i.luaK_numberK||, CODE, READONLY, ALIGN=1

                  luaK_numberK PROC
;;;559    */
;;;560    static int luaK_numberK (FuncState *fs, lua_Number r) {
000000  b57f              PUSH     {r0-r6,lr}
000002  4606              MOV      r6,r0
000004  4614              MOV      r4,r2
000006  461d              MOV      r5,r3
;;;561      TValue o;
;;;562      setfltvalue(&o, r);
000008  4668              MOV      r0,sp
00000a  e9c04500          STRD     r4,r5,[r0,#0]
00000e  2113              MOVS     r1,#0x13
000010  7201              STRB     r1,[r0,#8]
;;;563      return addk(fs, &o, &o);  /* use number itself as key */
000012  466a              MOV      r2,sp
000014  4669              MOV      r1,sp
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       addk
;;;564    }
00001c  b004              ADD      sp,sp,#0x10
00001e  bd70              POP      {r4-r6,pc}
;;;565    
                          ENDP


                          AREA ||i.luaK_patchclose||, CODE, READONLY, ALIGN=1

                  luaK_patchclose PROC
;;;303    */
;;;304    void luaK_patchclose (FuncState *fs, int list) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;305      for (; list != NO_JUMP; list = getjump(fs, list)) {
000006  e00e              B        |L69.38|
                  |L69.8|
;;;306        lua_assert(GET_OPCODE(fs->f->code[list]) == OP_JMP);
;;;307        SETARG_m(fs->f->code[list], 1);
000008  6828              LDR      r0,[r5,#0]
00000a  6b80              LDR      r0,[r0,#0x38]
00000c  f8500024          LDR      r0,[r0,r4,LSL #2]
000010  f0400080          ORR      r0,r0,#0x80
000014  6829              LDR      r1,[r5,#0]
000016  6b89              LDR      r1,[r1,#0x38]
000018  f8410024          STR      r0,[r1,r4,LSL #2]
00001c  4621              MOV      r1,r4                 ;305
00001e  4628              MOV      r0,r5                 ;305
000020  f7fffffe          BL       getjump
000024  4604              MOV      r4,r0                 ;305
                  |L69.38|
000026  1c60              ADDS     r0,r4,#1              ;305
000028  2800              CMP      r0,#0                 ;305
00002a  d1ed              BNE      |L69.8|
;;;308      }
;;;309    }
00002c  bd70              POP      {r4-r6,pc}
;;;310    
                          ENDP


                          AREA ||i.luaK_patchgoto||, CODE, READONLY, ALIGN=1

                  luaK_patchgoto PROC
;;;283    */
;;;284    void luaK_patchgoto (FuncState *fs, int list, int target, int hasclose) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;285      lua_assert(!hasclose || GET_OPCODE(fs->f->code[target]) == OP_CLOSE);
;;;286      while (list != NO_JUMP) {
00000c  e01e              B        |L70.76|
                  |L70.14|
;;;287        int next = getjump(fs, list);
00000e  4621              MOV      r1,r4
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       getjump
000016  4680              MOV      r8,r0
;;;288        lua_assert(!GETARG_m(fs->f->code[list]) || hasclose);
;;;289        patchtestreg(fs, list, NO_REG);  /* do not generate values */
000018  22ff              MOVS     r2,#0xff
00001a  4621              MOV      r1,r4
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       patchtestreg
;;;290        if (!hasclose || GETARG_m(fs->f->code[list]))
000022  b137              CBZ      r7,|L70.50|
000024  6828              LDR      r0,[r5,#0]
000026  6b80              LDR      r0,[r0,#0x38]
000028  f8100024          LDRB     r0,[r0,r4,LSL #2]
00002c  f3c010c0          UBFX     r0,r0,#7,#1
000030  b128              CBZ      r0,|L70.62|
                  |L70.50|
;;;291          fixjump(fs, list, target);
000032  4632              MOV      r2,r6
000034  4621              MOV      r1,r4
000036  4628              MOV      r0,r5
000038  f7fffffe          BL       fixjump
00003c  e004              B        |L70.72|
                  |L70.62|
;;;292        else  /* there is a CLOSE instruction but jump does not need it */
;;;293          fixjump(fs, list, target + 1);  /* avoid CLOSE instruction */
00003e  1c72              ADDS     r2,r6,#1
000040  4621              MOV      r1,r4
000042  4628              MOV      r0,r5
000044  f7fffffe          BL       fixjump
                  |L70.72|
;;;294        list = next;
000048  4644              MOV      r4,r8
;;;295      }
00004a  bf00              NOP      
                  |L70.76|
00004c  1c60              ADDS     r0,r4,#1              ;286
00004e  2800              CMP      r0,#0                 ;286
000050  d1dd              BNE      |L70.14|
;;;296    }
000052  e8bd81f0          POP      {r4-r8,pc}
;;;297    
                          ENDP


                          AREA ||i.luaK_patchlist||, CODE, READONLY, ALIGN=1

                  luaK_patchlist PROC
;;;265    */
;;;266    void luaK_patchlist (FuncState *fs, int list, int target) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;267      lua_assert(target <= fs->pc);
;;;268      patchlistaux(fs, list, target, NO_REG, target);
000008  23ff              MOVS     r3,#0xff
00000a  4622              MOV      r2,r4
00000c  4631              MOV      r1,r6
00000e  4628              MOV      r0,r5
000010  9400              STR      r4,[sp,#0]
000012  f7fffffe          BL       patchlistaux
;;;269    }
000016  bdf8              POP      {r3-r7,pc}
;;;270    
                          ENDP


                          AREA ||i.luaK_patchtohere||, CODE, READONLY, ALIGN=1

                  luaK_patchtohere PROC
;;;271    
;;;272    void luaK_patchtohere (FuncState *fs, int list) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;273      int hr = luaK_getlabel(fs);  /* mark "here" as a jump target */
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       luaK_getlabel
00000c  4606              MOV      r6,r0
;;;274      luaK_patchlist(fs, list, hr);
00000e  4632              MOV      r2,r6
000010  4629              MOV      r1,r5
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       luaK_patchlist
;;;275    }
000018  bd70              POP      {r4-r6,pc}
;;;276    
                          ENDP


                          AREA ||i.luaK_posfix||, CODE, READONLY, ALIGN=1

                  luaK_posfix PROC
;;;1544   */
;;;1545   void luaK_posfix (FuncState *fs, BinOpr opr,
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;1546                     expdesc *e1, expdesc *e2, int line) {
000004  4680              MOV      r8,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
00000a  461e              MOV      r6,r3
00000c  9d0a              LDR      r5,[sp,#0x28]
;;;1547     switch (opr) {
00000e  2c15              CMP      r4,#0x15
000010  d26f              BCS      |L73.242|
000012  e8dff004          TBB      [pc,r4]
000016  3647              DCB      0x36,0x47
000018  374a4b48          DCB      0x37,0x4a,0x4b,0x48
00001c  495d5e5f          DCB      0x49,0x5d,0x5e,0x5f
000020  6f902b9f          DCB      0x6f,0x90,0x2b,0x9f
000024  b5b6a0bf          DCB      0xb5,0xb6,0xa0,0xbf
000028  c00b1b00          DCB      0xc0,0x0b,0x1b,0x00
;;;1548       case OPR_AND: {
;;;1549         lua_assert(e1->t == NO_JUMP);  /* list closed by 'luK_infix' */
;;;1550         luaK_dischargevars(fs, e2);
00002c  4631              MOV      r1,r6
00002e  4640              MOV      r0,r8
000030  f7fffffe          BL       luaK_dischargevars
;;;1551         luaK_concat(fs, &e2->f, e1->f);
000034  f1060114          ADD      r1,r6,#0x14
000038  4640              MOV      r0,r8
00003a  697a              LDR      r2,[r7,#0x14]
00003c  f7fffffe          BL       luaK_concat
;;;1552         *e1 = *e2;
000040  2218              MOVS     r2,#0x18
000042  4631              MOV      r1,r6
000044  4638              MOV      r0,r7
000046  f7fffffe          BL       __aeabi_memcpy4
;;;1553         break;
00004a  e0b2              B        |L73.434|
;;;1554       }
;;;1555       case OPR_OR: {
;;;1556         lua_assert(e1->f == NO_JUMP);  /* list closed by 'luK_infix' */
;;;1557         luaK_dischargevars(fs, e2);
00004c  4631              MOV      r1,r6
00004e  4640              MOV      r0,r8
000050  f7fffffe          BL       luaK_dischargevars
;;;1558         luaK_concat(fs, &e2->t, e1->t);
000054  f1060110          ADD      r1,r6,#0x10
000058  4640              MOV      r0,r8
00005a  693a              LDR      r2,[r7,#0x10]
00005c  f7fffffe          BL       luaK_concat
;;;1559         *e1 = *e2;
000060  2218              MOVS     r2,#0x18
000062  4631              MOV      r1,r6
000064  4638              MOV      r0,r7
000066  f7fffffe          BL       __aeabi_memcpy4
;;;1560         break;
00006a  e0a2              B        |L73.434|
;;;1561       }
;;;1562       case OPR_CONCAT: {  /* e1 .. e2 */
;;;1563         luaK_exp2nextreg(fs, e2);
00006c  4631              MOV      r1,r6
00006e  4640              MOV      r0,r8
000070  f7fffffe          BL       luaK_exp2nextreg
;;;1564         codeconcat(fs, e1, e2, line);
000074  462b              MOV      r3,r5
000076  4632              MOV      r2,r6
000078  4639              MOV      r1,r7
00007a  4640              MOV      r0,r8
00007c  f7fffffe          BL       codeconcat
;;;1565         break;
000080  e097              B        |L73.434|
;;;1566       }
;;;1567       case OPR_ADD: case OPR_MUL: {
000082  bf00              NOP      
;;;1568         if (!constfolding(fs, opr + LUA_OPADD, e1, e2))
000084  4633              MOV      r3,r6
000086  463a              MOV      r2,r7
000088  4621              MOV      r1,r4
00008a  4640              MOV      r0,r8
00008c  f7fffffe          BL       constfolding
000090  b938              CBNZ     r0,|L73.162|
;;;1569           codecommutative(fs, cast(OpCode, opr + OP_ADD), e1, e2, line);
000092  4633              MOV      r3,r6
000094  463a              MOV      r2,r7
000096  f104011f          ADD      r1,r4,#0x1f
00009a  4640              MOV      r0,r8
00009c  9500              STR      r5,[sp,#0]
00009e  f7fffffe          BL       codecommutative
                  |L73.162|
;;;1570         break;
0000a2  e086              B        |L73.434|
;;;1571       }
;;;1572       case OPR_SUB: case OPR_DIV:
0000a4  bf00              NOP      
;;;1573       case OPR_IDIV: case OPR_MOD: case OPR_POW: {
0000a6  bf00              NOP      
0000a8  bf00              NOP      
0000aa  bf00              NOP      
;;;1574         if (!constfolding(fs, opr + LUA_OPADD, e1, e2))
0000ac  4633              MOV      r3,r6
0000ae  463a              MOV      r2,r7
0000b0  4621              MOV      r1,r4
0000b2  4640              MOV      r0,r8
0000b4  f7fffffe          BL       constfolding
0000b8  b948              CBNZ     r0,|L73.206|
;;;1575           codearith(fs, cast(OpCode, opr + OP_ADD), e1, e2, 0, line);
0000ba  2000              MOVS     r0,#0
0000bc  4633              MOV      r3,r6
0000be  463a              MOV      r2,r7
0000c0  f104011f          ADD      r1,r4,#0x1f
0000c4  e9cd0500          STRD     r0,r5,[sp,#0]
0000c8  4640              MOV      r0,r8
0000ca  f7fffffe          BL       codearith
                  |L73.206|
;;;1576         break;
0000ce  e070              B        |L73.434|
;;;1577       }
;;;1578       case OPR_BAND: case OPR_BOR: case OPR_BXOR: {
0000d0  bf00              NOP      
0000d2  bf00              NOP      
;;;1579         if (!constfolding(fs, opr + LUA_OPADD, e1, e2))
0000d4  4633              MOV      r3,r6
0000d6  463a              MOV      r2,r7
0000d8  4621              MOV      r1,r4
0000da  4640              MOV      r0,r8
0000dc  f7fffffe          BL       constfolding
0000e0  b930              CBNZ     r0,|L73.240|
;;;1580           codebitwise(fs, opr, e1, e2, line);
0000e2  4633              MOV      r3,r6
0000e4  463a              MOV      r2,r7
0000e6  4621              MOV      r1,r4
0000e8  4640              MOV      r0,r8
0000ea  9500              STR      r5,[sp,#0]
0000ec  f7fffffe          BL       codebitwise
                  |L73.240|
;;;1581         break;
0000f0  e05f              B        |L73.434|
                  |L73.242|
0000f2  e05d              B        |L73.432|
;;;1582       }
;;;1583       case OPR_SHL: {
;;;1584         if (!constfolding(fs, LUA_OPSHL, e1, e2)) {
0000f4  4633              MOV      r3,r6
0000f6  463a              MOV      r2,r7
0000f8  210a              MOVS     r1,#0xa
0000fa  4640              MOV      r0,r8
0000fc  f7fffffe          BL       constfolding
000100  b9c0              CBNZ     r0,|L73.308|
;;;1585           if (isSCint(e1)) {
000102  4638              MOV      r0,r7
000104  f7fffffe          BL       isSCint
000108  b168              CBZ      r0,|L73.294|
;;;1586             swapexps(e1, e2);
00010a  4631              MOV      r1,r6
00010c  4638              MOV      r0,r7
00010e  f7fffffe          BL       swapexps
;;;1587             codebini(fs, OP_SHLI, e1, e2, 1, line);
000112  2001              MOVS     r0,#1
000114  4633              MOV      r3,r6
000116  463a              MOV      r2,r7
000118  211e              MOVS     r1,#0x1e
00011a  e9cd0500          STRD     r0,r5,[sp,#0]
00011e  4640              MOV      r0,r8
000120  f7fffffe          BL       codebini
000124  e006              B        |L73.308|
                  |L73.294|
;;;1588           }
;;;1589           else
;;;1590             codeshift(fs, OP_SHL, e1, e2, line);
000126  4633              MOV      r3,r6
000128  463a              MOV      r2,r7
00012a  2129              MOVS     r1,#0x29
00012c  4640              MOV      r0,r8
00012e  9500              STR      r5,[sp,#0]
000130  f7fffffe          BL       codeshift
                  |L73.308|
;;;1591         }
;;;1592         break;
000134  e03d              B        |L73.434|
;;;1593       }
;;;1594       case OPR_SHR: {
;;;1595         if (!constfolding(fs, LUA_OPSHR, e1, e2))
000136  4633              MOV      r3,r6
000138  463a              MOV      r2,r7
00013a  210b              MOVS     r1,#0xb
00013c  4640              MOV      r0,r8
00013e  f7fffffe          BL       constfolding
000142  b930              CBNZ     r0,|L73.338|
;;;1596           codeshift(fs, OP_SHR, e1, e2, line);
000144  4633              MOV      r3,r6
000146  463a              MOV      r2,r7
000148  212a              MOVS     r1,#0x2a
00014a  4640              MOV      r0,r8
00014c  9500              STR      r5,[sp,#0]
00014e  f7fffffe          BL       codeshift
                  |L73.338|
;;;1597         break;
000152  e02e              B        |L73.434|
;;;1598       }
;;;1599       case OPR_EQ: case OPR_NE: {
000154  bf00              NOP      
;;;1600         if (e2->k == VUNDEF)
000156  6830              LDR      r0,[r6,#0]
000158  2812              CMP      r0,#0x12
00015a  d10a              BNE      |L73.370|
;;;1601           codeisdef(fs, opr == OPR_NE, e1);
00015c  2c10              CMP      r4,#0x10
00015e  d101              BNE      |L73.356|
000160  2001              MOVS     r0,#1
000162  e000              B        |L73.358|
                  |L73.356|
000164  2000              MOVS     r0,#0
                  |L73.358|
000166  4601              MOV      r1,r0
000168  463a              MOV      r2,r7
00016a  4640              MOV      r0,r8
00016c  f7fffffe          BL       codeisdef
000170  e005              B        |L73.382|
                  |L73.370|
;;;1602         else
;;;1603           codeeq(fs, opr, e1, e2);
000172  4633              MOV      r3,r6
000174  463a              MOV      r2,r7
000176  4621              MOV      r1,r4
000178  4640              MOV      r0,r8
00017a  f7fffffe          BL       codeeq
                  |L73.382|
;;;1604         break;
00017e  e018              B        |L73.434|
;;;1605       }
;;;1606       case OPR_LT: case OPR_LE: {
000180  bf00              NOP      
;;;1607         OpCode op = cast(OpCode, (opr - OPR_EQ) + OP_EQ);
000182  f1040925          ADD      r9,r4,#0x25
;;;1608         codeorder(fs, op, e1, e2);
000186  4633              MOV      r3,r6
000188  463a              MOV      r2,r7
00018a  4649              MOV      r1,r9
00018c  4640              MOV      r0,r8
00018e  f7fffffe          BL       codeorder
;;;1609         break;
000192  e00e              B        |L73.434|
;;;1610       }
;;;1611       case OPR_GT: case OPR_GE: {
000194  bf00              NOP      
;;;1612         /* '(a > b)' <=> '(b < a)';  '(a >= b)' <=> '(b <= a)' */
;;;1613         OpCode op = cast(OpCode, (opr - OPR_NE) + OP_EQ);
000196  f1040922          ADD      r9,r4,#0x22
;;;1614         swapexps(e1, e2);
00019a  4631              MOV      r1,r6
00019c  4638              MOV      r0,r7
00019e  f7fffffe          BL       swapexps
;;;1615         codeorder(fs, op, e1, e2);
0001a2  4633              MOV      r3,r6
0001a4  463a              MOV      r2,r7
0001a6  4649              MOV      r1,r9
0001a8  4640              MOV      r0,r8
0001aa  f7fffffe          BL       codeorder
;;;1616         break;
0001ae  e000              B        |L73.434|
                  |L73.432|
0001b0  bf00              NOP                            ;1547
                  |L73.434|
0001b2  bf00              NOP                            ;1553
;;;1617       }
;;;1618       default: lua_assert(0);
;;;1619     }
;;;1620   }
0001b4  e8bd87fc          POP      {r2-r10,pc}
;;;1621   
                          ENDP


                          AREA ||i.luaK_prefix||, CODE, READONLY, ALIGN=2

                  luaK_prefix PROC
;;;1457   */
;;;1458   void luaK_prefix (FuncState *fs, UnOpr op, expdesc *e, int line) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  461f              MOV      r7,r3
;;;1459     static const expdesc ef = {VKINT, {0}, NO_JUMP, NO_JUMP};
;;;1460     switch (op) {
00000c  b134              CBZ      r4,|L74.28|
00000e  2c01              CMP      r4,#1
000010  d005              BEQ      |L74.30|
000012  2c02              CMP      r4,#2
000014  d015              BEQ      |L74.66|
000016  2c03              CMP      r4,#3
000018  d118              BNE      |L74.76|
00001a  e00a              B        |L74.50|
                  |L74.28|
;;;1461       case OPR_MINUS: case OPR_BNOT:  /* use 'ef' as fake 2nd operand */
00001c  bf00              NOP      
                  |L74.30|
;;;1462         if (constfolding(fs, op + LUA_OPUNM, e, &ef))
00001e  4b0d              LDR      r3,|L74.84|
000020  462a              MOV      r2,r5
000022  f104010c          ADD      r1,r4,#0xc
000026  4630              MOV      r0,r6
000028  f7fffffe          BL       constfolding
00002c  b100              CBZ      r0,|L74.48|
;;;1463           break;
00002e  e00e              B        |L74.78|
                  |L74.48|
;;;1464         /* FALLTHROUGH */
;;;1465       case OPR_LEN:
000030  bf00              NOP      
                  |L74.50|
;;;1466         codeunexpval(fs, cast(OpCode, op + OP_UNM), e, line);
000032  463b              MOV      r3,r7
000034  462a              MOV      r2,r5
000036  f104012b          ADD      r1,r4,#0x2b
00003a  4630              MOV      r0,r6
00003c  f7fffffe          BL       codeunexpval
;;;1467         break;
000040  e005              B        |L74.78|
                  |L74.66|
;;;1468       case OPR_NOT: codenot(fs, e); break;
000042  4629              MOV      r1,r5
000044  4630              MOV      r0,r6
000046  f7fffffe          BL       codenot
00004a  e000              B        |L74.78|
                  |L74.76|
00004c  bf00              NOP                            ;1460
                  |L74.78|
00004e  bf00              NOP                            ;1463
;;;1469       default: lua_assert(0);
;;;1470     }
;;;1471   }
000050  e8bd81f0          POP      {r4-r8,pc}
;;;1472   
                          ENDP

                  |L74.84|
                          DCD      ||ef||

                          AREA ||i.luaK_reserveregs||, CODE, READONLY, ALIGN=1

                  luaK_reserveregs PROC
;;;445    */
;;;446    void luaK_reserveregs (FuncState *fs, int n) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;447      luaK_checkstack(fs, n);
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       luaK_checkstack
;;;448      fs->freereg += n;
00000e  f8940030          LDRB     r0,[r4,#0x30]
000012  4428              ADD      r0,r0,r5
000014  f8840030          STRB     r0,[r4,#0x30]
;;;449    }
000018  bd70              POP      {r4-r6,pc}
;;;450    
                          ENDP


                          AREA ||i.luaK_ret||, CODE, READONLY, ALIGN=1

                  luaK_ret PROC
;;;166    */
;;;167    void luaK_ret (FuncState *fs, int first, int nret) {
000000  e92d41fc          PUSH     {r2-r8,lr}
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;168      OpCode op;
;;;169      switch (nret) {
00000a  b115              CBZ      r5,|L76.18|
00000c  2d01              CMP      r5,#1
00000e  d104              BNE      |L76.26|
000010  e001              B        |L76.22|
                  |L76.18|
;;;170        case 0: op = OP_RETURN0; break;
000012  2442              MOVS     r4,#0x42
000014  e003              B        |L76.30|
                  |L76.22|
;;;171        case 1: op = OP_RETURN1; break;
000016  2443              MOVS     r4,#0x43
000018  e001              B        |L76.30|
                  |L76.26|
;;;172        default: op = OP_RETURN; break;
00001a  2441              MOVS     r4,#0x41
00001c  bf00              NOP      
                  |L76.30|
00001e  bf00              NOP                            ;170
;;;173      }
;;;174      luaK_codeABC(fs, op, first, nret + 1, 0);
000020  2000              MOVS     r0,#0
000022  9000              STR      r0,[sp,#0]
000024  1c6b              ADDS     r3,r5,#1
000026  4632              MOV      r2,r6
000028  4621              MOV      r1,r4
00002a  9001              STR      r0,[sp,#4]
00002c  4638              MOV      r0,r7
00002e  f7fffffe          BL       luaK_codeABCk
;;;175    }
000032  e8bd81fc          POP      {r2-r8,pc}
;;;176    
                          ENDP


                          AREA ||i.luaK_self||, CODE, READONLY, ALIGN=1

                  luaK_self PROC
;;;958    */
;;;959    void luaK_self (FuncState *fs, expdesc *e, expdesc *key) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;960      int ereg;
;;;961      luaK_exp2anyreg(fs, e);
000008  4621              MOV      r1,r4
00000a  4630              MOV      r0,r6
00000c  f7fffffe          BL       luaK_exp2anyreg
;;;962      ereg = e->u.info;  /* register where 'e' was placed */
000010  68a7              LDR      r7,[r4,#8]
;;;963      freeexp(fs, e);
000012  4621              MOV      r1,r4
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       freeexp
;;;964      e->u.info = fs->freereg;  /* base register for op_self */
00001a  f8960030          LDRB     r0,[r6,#0x30]
00001e  60a0              STR      r0,[r4,#8]
;;;965      e->k = VNONRELOC;  /* self expression has a fixed register */
000020  2007              MOVS     r0,#7
000022  6020              STR      r0,[r4,#0]
;;;966      luaK_reserveregs(fs, 2);  /* function and 'self' produced by op_self */
000024  2102              MOVS     r1,#2
000026  4630              MOV      r0,r6
000028  f7fffffe          BL       luaK_reserveregs
;;;967      codeABRK(fs, OP_SELF, e->u.info, ereg, key);
00002c  9500              STR      r5,[sp,#0]
00002e  463b              MOV      r3,r7
000030  2112              MOVS     r1,#0x12
000032  4630              MOV      r0,r6
000034  68a2              LDR      r2,[r4,#8]
000036  f7fffffe          BL       codeABRK
;;;968      freeexp(fs, key);
00003a  4629              MOV      r1,r5
00003c  4630              MOV      r0,r6
00003e  f7fffffe          BL       freeexp
;;;969    }
000042  bdf8              POP      {r3-r7,pc}
;;;970    
                          ENDP


                          AREA ||i.luaK_semerror||, CODE, READONLY, ALIGN=1

                  luaK_semerror PROC
;;;44     /* semantic error */
;;;45     l_noret luaK_semerror (LexState *ls, const char *msg) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;46       ls->t.token = 0;  /* remove "near <token>" from final message */
000006  2000              MOVS     r0,#0
000008  6120              STR      r0,[r4,#0x10]
;;;47       luaX_syntaxerror(ls, msg);
00000a  4629              MOV      r1,r5
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       luaX_syntaxerror
;;;48     }
000012  bd70              POP      {r4-r6,pc}
;;;49     
                          ENDP


                          AREA ||i.luaK_setlist||, CODE, READONLY, ALIGN=2

                  luaK_setlist PROC
;;;1650   */
;;;1651   void luaK_setlist (FuncState *fs, int base, int nelems, int tostore) {
000000  e92d47fc          PUSH     {r2-r10,lr}
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;1652     int c =  (nelems - 1)/LFIELDS_PER_FLUSH + 1;
00000c  1e78              SUBS     r0,r7,#1
00000e  2132              MOVS     r1,#0x32
000010  fb90f0f1          SDIV     r0,r0,r1
000014  1c44              ADDS     r4,r0,#1
;;;1653     int b = (tostore == LUA_MULTRET) ? 0 : tostore;
000016  f1080001          ADD      r0,r8,#1
00001a  b908              CBNZ     r0,|L79.32|
00001c  2000              MOVS     r0,#0
00001e  e000              B        |L79.34|
                  |L79.32|
000020  4640              MOV      r0,r8
                  |L79.34|
000022  4681              MOV      r9,r0
;;;1654     lua_assert(tostore != 0 && tostore <= LFIELDS_PER_FLUSH);
;;;1655     if (c <= MAXARG_C)
000024  2cff              CMP      r4,#0xff
000026  dc09              BGT      |L79.60|
;;;1656       luaK_codeABC(fs, OP_SETLIST, base, b, c);
000028  2000              MOVS     r0,#0
00002a  464b              MOV      r3,r9
00002c  4632              MOV      r2,r6
00002e  214a              MOVS     r1,#0x4a
000030  e9cd4000          STRD     r4,r0,[sp,#0]
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       luaK_codeABCk
00003a  e014              B        |L79.102|
                  |L79.60|
;;;1657     else if (c <= MAXARG_Ax) {
00003c  f1b47f00          CMP      r4,#0x2000000
000040  da0d              BGE      |L79.94|
;;;1658       luaK_codeABC(fs, OP_SETLIST, base, b, 0);
000042  2000              MOVS     r0,#0
000044  9000              STR      r0,[sp,#0]
000046  464b              MOV      r3,r9
000048  4632              MOV      r2,r6
00004a  214a              MOVS     r1,#0x4a
00004c  9001              STR      r0,[sp,#4]
00004e  4628              MOV      r0,r5
000050  f7fffffe          BL       luaK_codeABCk
;;;1659       codeextraarg(fs, c);
000054  4621              MOV      r1,r4
000056  4628              MOV      r0,r5
000058  f7fffffe          BL       codeextraarg
00005c  e003              B        |L79.102|
                  |L79.94|
;;;1660     }
;;;1661     else
;;;1662       luaX_syntaxerror(fs->ls, "constructor too long");
00005e  a104              ADR      r1,|L79.112|
000060  68a8              LDR      r0,[r5,#8]
000062  f7fffffe          BL       luaX_syntaxerror
                  |L79.102|
;;;1663     fs->freereg = base + 1;  /* free registers with list values */
000066  1c70              ADDS     r0,r6,#1
000068  f8850030          STRB     r0,[r5,#0x30]
;;;1664   }
00006c  e8bd87fc          POP      {r2-r10,pc}
;;;1665   
                          ENDP

                  |L79.112|
000070  636f6e73          DCB      "constructor too long",0
000074  74727563
000078  746f7220
00007c  746f6f20
000080  6c6f6e67
000084  00      
000085  00                DCB      0
000086  00                DCB      0
000087  00                DCB      0

                          AREA ||i.luaK_setoneret||, CODE, READONLY, ALIGN=1

                  luaK_setoneret PROC
;;;656    */
;;;657    void luaK_setoneret (FuncState *fs, expdesc *e) {
000000  b510              PUSH     {r4,lr}
;;;658      if (e->k == VCALL) {  /* expression is an open function call? */
000002  680a              LDR      r2,[r1,#0]
000004  2a10              CMP      r2,#0x10
000006  d10a              BNE      |L80.30|
;;;659        /* already returns 1 value */
;;;660        lua_assert(GETARG_C(getinstruction(fs, e)) == 2);
;;;661        e->k = VNONRELOC;  /* result has fixed position */
000008  2207              MOVS     r2,#7
00000a  600a              STR      r2,[r1,#0]
;;;662        e->u.info = GETARG_A(getinstruction(fs, e));
00000c  6802              LDR      r2,[r0,#0]
00000e  6b92              LDR      r2,[r2,#0x38]
000010  688b              LDR      r3,[r1,#8]
000012  f8322023          LDRH     r2,[r2,r3,LSL #2]
000016  f3c212c7          UBFX     r2,r2,#7,#8
00001a  608a              STR      r2,[r1,#8]
00001c  e012              B        |L80.68|
                  |L80.30|
;;;663      }
;;;664      else if (e->k == VVARARG) {
00001e  680a              LDR      r2,[r1,#0]
000020  2a11              CMP      r2,#0x11
000022  d10f              BNE      |L80.68|
;;;665        SETARG_C(getinstruction(fs, e), 2);
000024  6802              LDR      r2,[r0,#0]
000026  6b92              LDR      r2,[r2,#0x38]
000028  688b              LDR      r3,[r1,#8]
00002a  f8522023          LDR      r2,[r2,r3,LSL #2]
00002e  f022427f          BIC      r2,r2,#0xff000000
000032  f0427200          ORR      r2,r2,#0x2000000
000036  6803              LDR      r3,[r0,#0]
000038  6b9b              LDR      r3,[r3,#0x38]
00003a  688c              LDR      r4,[r1,#8]
00003c  f8432024          STR      r2,[r3,r4,LSL #2]
;;;666        e->k = VRELOC;  /* can relocate its simple result */
000040  220f              MOVS     r2,#0xf
000042  600a              STR      r2,[r1,#0]
                  |L80.68|
;;;667      }
;;;668    }
000044  bd10              POP      {r4,pc}
;;;669    
                          ENDP


                          AREA ||i.luaK_setreturns||, CODE, READONLY, ALIGN=1

                  luaK_setreturns PROC
;;;633    */
;;;634    void luaK_setreturns (FuncState *fs, expdesc *e, int nresults) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
;;;635      Instruction *pc = &getinstruction(fs, e);
00000a  6830              LDR      r0,[r6,#0]
00000c  6b80              LDR      r0,[r0,#0x38]
00000e  68a9              LDR      r1,[r5,#8]
000010  eb000481          ADD      r4,r0,r1,LSL #2
;;;636      if (e->k == VCALL)  /* expression is an open function call? */
000014  6828              LDR      r0,[r5,#0]
000016  2810              CMP      r0,#0x10
000018  d105              BNE      |L81.38|
;;;637        SETARG_C(*pc, nresults + 1);
00001a  1c78              ADDS     r0,r7,#1
00001c  6821              LDR      r1,[r4,#0]
00001e  f360611f          BFI      r1,r0,#24,#8
000022  6021              STR      r1,[r4,#0]
000024  e013              B        |L81.78|
                  |L81.38|
;;;638      else if (e->k == VVARARG) {
000026  6828              LDR      r0,[r5,#0]
000028  2811              CMP      r0,#0x11
00002a  d10f              BNE      |L81.76|
;;;639        SETARG_C(*pc, nresults + 1);
00002c  1c78              ADDS     r0,r7,#1
00002e  6821              LDR      r1,[r4,#0]
000030  f360611f          BFI      r1,r0,#24,#8
000034  6021              STR      r1,[r4,#0]
;;;640        SETARG_A(*pc, fs->freereg);
000036  f8961030          LDRB     r1,[r6,#0x30]
00003a  6820              LDR      r0,[r4,#0]
00003c  f36110ce          BFI      r0,r1,#7,#8
000040  6020              STR      r0,[r4,#0]
;;;641        luaK_reserveregs(fs, 1);
000042  2101              MOVS     r1,#1
000044  4630              MOV      r0,r6
000046  f7fffffe          BL       luaK_reserveregs
00004a  e000              B        |L81.78|
                  |L81.76|
;;;642      }
;;;643      else lua_assert(nresults == LUA_MULTRET);
00004c  bf00              NOP      
                  |L81.78|
;;;644    }
00004e  e8bd81f0          POP      {r4-r8,pc}
;;;645    
                          ENDP


                          AREA ||i.luaK_storevar||, CODE, READONLY, ALIGN=1

                  luaK_storevar PROC
;;;921    */
;;;922    void luaK_storevar (FuncState *fs, expdesc *var, expdesc *ex) {
000000  e92d41fc          PUSH     {r2-r8,lr}
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;923      switch (var->k) {
00000a  6820              LDR      r0,[r4,#0]
00000c  3808              SUBS     r0,r0,#8
00000e  2806              CMP      r0,#6
000010  d242              BCS      |L82.152|
000012  e8dff000          TBB      [pc,r0]
000016  030e              DCB      0x03,0x0e
000018  381d262f          DCB      0x38,0x1d,0x26,0x2f
;;;924        case VLOCAL: {
;;;925          freeexp(fs, ex);
00001c  4629              MOV      r1,r5
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       freeexp
;;;926          exp2reg(fs, ex, var->u.info);  /* compute 'ex' into proper place */
000024  4629              MOV      r1,r5
000026  4630              MOV      r0,r6
000028  68a2              LDR      r2,[r4,#8]
00002a  f7fffffe          BL       exp2reg
                  |L82.46|
;;;927          return;
;;;928        }
;;;929        case VUPVAL: {
;;;930          int e = luaK_exp2anyreg(fs, ex);
;;;931          luaK_codeABC(fs, OP_SETUPVAL, e, var->u.info, 0);
;;;932          break;
;;;933        }
;;;934        case VINDEXUP: {
;;;935          codeABRK(fs, OP_SETTABUP, var->u.ind.t, var->u.ind.idx, ex);
;;;936          break;
;;;937        }
;;;938        case VINDEXI: {
;;;939          codeABRK(fs, OP_SETI, var->u.ind.t, var->u.ind.idx, ex);
;;;940          break;
;;;941        }
;;;942        case VINDEXSTR: {
;;;943          codeABRK(fs, OP_SETFIELD, var->u.ind.t, var->u.ind.idx, ex);
;;;944          break;
;;;945        }
;;;946        case VINDEXED: {
;;;947          codeABRK(fs, OP_SETTABLE, var->u.ind.t, var->u.ind.idx, ex);
;;;948          break;
;;;949        }
;;;950        default: lua_assert(0);  /* invalid var kind to store */
;;;951      }
;;;952      freeexp(fs, ex);
;;;953    }
00002e  e8bd81fc          POP      {r2-r8,pc}
000032  4629              MOV      r1,r5                 ;930
000034  4630              MOV      r0,r6                 ;930
000036  f7fffffe          BL       luaK_exp2anyreg
00003a  4607              MOV      r7,r0                 ;930
00003c  2000              MOVS     r0,#0                 ;931
00003e  9000              STR      r0,[sp,#0]            ;931
000040  9001              STR      r0,[sp,#4]            ;931
000042  463a              MOV      r2,r7                 ;931
000044  2108              MOVS     r1,#8                 ;931
000046  4630              MOV      r0,r6                 ;931
000048  68a3              LDR      r3,[r4,#8]            ;931
00004a  f7fffffe          BL       luaK_codeABCk
00004e  e024              B        |L82.154|
000050  9500              STR      r5,[sp,#0]            ;935
000052  f9b43008          LDRSH    r3,[r4,#8]            ;935
000056  7aa2              LDRB     r2,[r4,#0xa]          ;935
000058  210d              MOVS     r1,#0xd               ;935
00005a  4630              MOV      r0,r6                 ;935
00005c  f7fffffe          BL       codeABRK
000060  e01b              B        |L82.154|
000062  9500              STR      r5,[sp,#0]            ;939
000064  f9b43008          LDRSH    r3,[r4,#8]            ;939
000068  7aa2              LDRB     r2,[r4,#0xa]          ;939
00006a  210f              MOVS     r1,#0xf               ;939
00006c  4630              MOV      r0,r6                 ;939
00006e  f7fffffe          BL       codeABRK
000072  e012              B        |L82.154|
000074  9500              STR      r5,[sp,#0]            ;943
000076  f9b43008          LDRSH    r3,[r4,#8]            ;943
00007a  7aa2              LDRB     r2,[r4,#0xa]          ;943
00007c  2110              MOVS     r1,#0x10              ;943
00007e  4630              MOV      r0,r6                 ;943
000080  f7fffffe          BL       codeABRK
000084  e009              B        |L82.154|
000086  9500              STR      r5,[sp,#0]            ;947
000088  f9b43008          LDRSH    r3,[r4,#8]            ;947
00008c  7aa2              LDRB     r2,[r4,#0xa]          ;947
00008e  210e              MOVS     r1,#0xe               ;947
000090  4630              MOV      r0,r6                 ;947
000092  f7fffffe          BL       codeABRK
000096  e000              B        |L82.154|
                  |L82.152|
000098  bf00              NOP                            ;923
                  |L82.154|
00009a  bf00              NOP                            ;932
00009c  4629              MOV      r1,r5                 ;952
00009e  4630              MOV      r0,r6                 ;952
0000a0  f7fffffe          BL       freeexp
0000a4  bf00              NOP      
0000a6  e7c2              B        |L82.46|
;;;954    
                          ENDP


                          AREA ||i.luaK_stringK||, CODE, READONLY, ALIGN=1

                  luaK_stringK PROC
;;;536    */
;;;537    int luaK_stringK (FuncState *fs, TString *s) {
000000  b57f              PUSH     {r0-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;538      TValue o;
;;;539      setsvalue(fs->ls->L, &o, s);
000006  4668              MOV      r0,sp
000008  4621              MOV      r1,r4
00000a  6001              STR      r1,[r0,#0]
00000c  790a              LDRB     r2,[r1,#4]
00000e  f0420240          ORR      r2,r2,#0x40
000012  7202              STRB     r2,[r0,#8]
;;;540      return addk(fs, &o, &o);  /* use string itself as key */
000014  466a              MOV      r2,sp
000016  4669              MOV      r1,sp
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       addk
;;;541    }
00001e  b004              ADD      sp,sp,#0x10
000020  bd70              POP      {r4-r6,pc}
;;;542    
                          ENDP


                          AREA ||i.need_value||, CODE, READONLY, ALIGN=1

                  need_value PROC
;;;791    */
;;;792    static int need_value (FuncState *fs, int list) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;793      for (; list != NO_JUMP; list = getjump(fs, list)) {
000006  e00f              B        |L84.40|
                  |L84.8|
;;;794        Instruction i = *getjumpcontrol(fs, list);
000008  4621              MOV      r1,r4
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       getjumpcontrol
000010  6806              LDR      r6,[r0,#0]
;;;795        if (GET_OPCODE(i) != OP_TESTSET) return 1;
000012  f006007f          AND      r0,r6,#0x7f
000016  283c              CMP      r0,#0x3c
000018  d001              BEQ      |L84.30|
00001a  2001              MOVS     r0,#1
                  |L84.28|
;;;796      }
;;;797      return 0;  /* not found */
;;;798    }
00001c  bd70              POP      {r4-r6,pc}
                  |L84.30|
00001e  4621              MOV      r1,r4                 ;793
000020  4628              MOV      r0,r5                 ;793
000022  f7fffffe          BL       getjump
000026  4604              MOV      r4,r0                 ;793
                  |L84.40|
000028  1c60              ADDS     r0,r4,#1              ;793
00002a  2800              CMP      r0,#0                 ;793
00002c  d1ec              BNE      |L84.8|
00002e  bf00              NOP                            ;797
000030  e7f4              B        |L84.28|
;;;799    
                          ENDP


                          AREA ||i.negatecondition||, CODE, READONLY, ALIGN=1

                  negatecondition PROC
;;;974    */
;;;975    static void negatecondition (FuncState *fs, expdesc *e) {
000000  b570              PUSH     {r4-r6,lr}
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;976      Instruction *pc = getjumpcontrol(fs, e->u.info);
000006  4630              MOV      r0,r6
000008  68a9              LDR      r1,[r5,#8]
00000a  f7fffffe          BL       getjumpcontrol
00000e  4604              MOV      r4,r0
;;;977      lua_assert(testTMode(GET_OPCODE(*pc)) && GET_OPCODE(*pc) != OP_TESTSET &&
;;;978                                               GET_OPCODE(*pc) != OP_TEST);
;;;979      SETARG_k(*pc, (GETARG_k(*pc) ^ 1));
000010  8820              LDRH     r0,[r4,#0]
000012  0bc0              LSRS     r0,r0,#15
000014  43c1              MVNS     r1,r0
000016  6820              LDR      r0,[r4,#0]
000018  f36130cf          BFI      r0,r1,#15,#1
00001c  6020              STR      r0,[r4,#0]
;;;980    }
00001e  bd70              POP      {r4-r6,pc}
;;;981    
                          ENDP


                          AREA ||i.nilK||, CODE, READONLY, ALIGN=1

                  nilK PROC
;;;579    */
;;;580    static int nilK (FuncState *fs) {
000000  b510              PUSH     {r4,lr}
000002  b088              SUB      sp,sp,#0x20
000004  4604              MOV      r4,r0
;;;581      TValue k, v;
;;;582      setnilvalue(&v);
000006  2000              MOVS     r0,#0
000008  f88d0008          STRB     r0,[sp,#8]
;;;583      /* cannot use nil as key; instead use table itself to represent nil */
;;;584      sethvalue(fs->ls->L, &k, fs->ls->h);
00000c  a804              ADD      r0,sp,#0x10
00000e  68a2              LDR      r2,[r4,#8]
000010  6c11              LDR      r1,[r2,#0x40]
000012  6001              STR      r1,[r0,#0]
000014  2245              MOVS     r2,#0x45
000016  7202              STRB     r2,[r0,#8]
;;;585      return addk(fs, &k, &v);
000018  466a              MOV      r2,sp
00001a  a904              ADD      r1,sp,#0x10
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       addk
;;;586    }
000022  b008              ADD      sp,sp,#0x20
000024  bd10              POP      {r4,pc}
;;;587    
                          ENDP


                          AREA ||i.normalizeindexed||, CODE, READONLY, ALIGN=2

                  normalizeindexed PROC
;;;1412   
;;;1413   static void normalizeindexed (FuncState *fs, expdesc *v) {
000000  e92d41fc          PUSH     {r2-r8,lr}
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;1414     if (v->k != VINDEXED) {  /* not in proper form? */
000008  6820              LDR      r0,[r4,#0]
00000a  280a              CMP      r0,#0xa
00000c  d041              BEQ      |L87.146|
;;;1415       int key = fs->freereg;  /* register with key value */
00000e  f8956030          LDRB     r6,[r5,#0x30]
;;;1416       luaK_reserveregs(fs, 1);
000012  2101              MOVS     r1,#1
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       luaK_reserveregs
;;;1417       switch (v->k) {
00001a  6820              LDR      r0,[r4,#0]
00001c  280b              CMP      r0,#0xb
00001e  d015              BEQ      |L87.76|
000020  280c              CMP      r0,#0xc
000022  d002              BEQ      |L87.42|
000024  280d              CMP      r0,#0xd
000026  d129              BNE      |L87.124|
000028  e009              B        |L87.62|
                  |L87.42|
;;;1418         case VINDEXI:
;;;1419           luaK_int(fs, key, v->u.ind.idx);
00002a  f9b40008          LDRSH    r0,[r4,#8]
00002e  17c3              ASRS     r3,r0,#31
000030  4607              MOV      r7,r0
000032  463a              MOV      r2,r7
000034  4631              MOV      r1,r6
000036  4628              MOV      r0,r5
000038  f7fffffe          BL       luaK_int
;;;1420           break;
00003c  e023              B        |L87.134|
                  |L87.62|
;;;1421         case VINDEXSTR:
;;;1422           luaK_codek(fs, key, v->u.ind.idx);
00003e  f9b42008          LDRSH    r2,[r4,#8]
000042  4631              MOV      r1,r6
000044  4628              MOV      r0,r5
000046  f7fffffe          BL       luaK_codek
;;;1423           break;
00004a  e01c              B        |L87.134|
                  |L87.76|
;;;1424         case VINDEXUP:
;;;1425           luaK_codek(fs, key, v->u.ind.idx);
00004c  f9b42008          LDRSH    r2,[r4,#8]
000050  4631              MOV      r1,r6
000052  4628              MOV      r0,r5
000054  f7fffffe          BL       luaK_codek
;;;1426           luaK_codeABC(fs, OP_GETUPVAL, fs->freereg, v->u.ind.t, 0);
000058  2000              MOVS     r0,#0
00005a  9000              STR      r0,[sp,#0]
00005c  9001              STR      r0,[sp,#4]
00005e  7aa3              LDRB     r3,[r4,#0xa]
000060  f8952030          LDRB     r2,[r5,#0x30]
000064  2107              MOVS     r1,#7
000066  4628              MOV      r0,r5
000068  f7fffffe          BL       luaK_codeABCk
;;;1427           v->u.ind.t = fs->freereg;
00006c  f8951030          LDRB     r1,[r5,#0x30]
000070  72a1              STRB     r1,[r4,#0xa]
;;;1428           luaK_reserveregs(fs, 1);  /* one more register for the upvalue */
000072  2101              MOVS     r1,#1
000074  4628              MOV      r0,r5
000076  f7fffffe          BL       luaK_reserveregs
;;;1429           break;
00007a  e004              B        |L87.134|
                  |L87.124|
;;;1430         default:
;;;1431           luaK_semerror(fs->ls, "'undef' is not a value!!");
00007c  a109              ADR      r1,|L87.164|
00007e  68a8              LDR      r0,[r5,#8]
000080  f7fffffe          BL       luaK_semerror
;;;1432           break;
000084  bf00              NOP      
                  |L87.134|
000086  bf00              NOP                            ;1420
;;;1433       }
;;;1434       v->u.ind.idx = key;
000088  b230              SXTH     r0,r6
00008a  8120              STRH     r0,[r4,#8]
;;;1435       v->k = VINDEXED;
00008c  200a              MOVS     r0,#0xa
00008e  6020              STR      r0,[r4,#0]
;;;1436     }
000090  bf00              NOP      
                  |L87.146|
;;;1437     freeregs(fs, v->u.ind.t, v->u.ind.idx);
000092  f9b42008          LDRSH    r2,[r4,#8]
000096  7aa1              LDRB     r1,[r4,#0xa]
000098  4628              MOV      r0,r5
00009a  f7fffffe          BL       freeregs
;;;1438   }
00009e  e8bd81fc          POP      {r2-r8,pc}
;;;1439   
                          ENDP

0000a2  0000              DCW      0x0000
                  |L87.164|
0000a4  27756e64          DCB      "'undef' is not a value!!",0
0000a8  65662720
0000ac  6973206e
0000b0  6f742061
0000b4  2076616c
0000b8  75652121
0000bc  00      
0000bd  00                DCB      0
0000be  00                DCB      0
0000bf  00                DCB      0

                          AREA ||i.patchlistaux||, CODE, READONLY, ALIGN=1

                  patchlistaux PROC
;;;247    */
;;;248    static void patchlistaux (FuncState *fs, int list, int vtarget, int reg,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;249                              int dtarget) {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
00000c  f8dd8020          LDR      r8,[sp,#0x20]
;;;250      while (list != NO_JUMP) {
000010  e017              B        |L88.66|
                  |L88.18|
;;;251        int next = getjump(fs, list);
000012  4621              MOV      r1,r4
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       getjump
00001a  4681              MOV      r9,r0
;;;252        if (patchtestreg(fs, list, reg))
00001c  462a              MOV      r2,r5
00001e  4621              MOV      r1,r4
000020  4630              MOV      r0,r6
000022  f7fffffe          BL       patchtestreg
000026  b128              CBZ      r0,|L88.52|
;;;253          fixjump(fs, list, vtarget);
000028  463a              MOV      r2,r7
00002a  4621              MOV      r1,r4
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       fixjump
000032  e004              B        |L88.62|
                  |L88.52|
;;;254        else
;;;255          fixjump(fs, list, dtarget);  /* jump to default target */
000034  4642              MOV      r2,r8
000036  4621              MOV      r1,r4
000038  4630              MOV      r0,r6
00003a  f7fffffe          BL       fixjump
                  |L88.62|
;;;256        list = next;
00003e  464c              MOV      r4,r9
;;;257      }
000040  bf00              NOP      
                  |L88.66|
000042  1c60              ADDS     r0,r4,#1              ;250
000044  2800              CMP      r0,#0                 ;250
000046  d1e4              BNE      |L88.18|
;;;258    }
000048  e8bd87f0          POP      {r4-r10,pc}
;;;259    
                          ENDP


                          AREA ||i.patchtestreg||, CODE, READONLY, ALIGN=1

                  patchtestreg PROC
;;;218    */
;;;219    static int patchtestreg (FuncState *fs, int node, int reg) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;220      Instruction *i = getjumpcontrol(fs, node);
00000a  4639              MOV      r1,r7
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       getjumpcontrol
000012  4604              MOV      r4,r0
;;;221      if (GET_OPCODE(*i) != OP_TESTSET)
000014  7820              LDRB     r0,[r4,#0]
000016  f000007f          AND      r0,r0,#0x7f
00001a  283c              CMP      r0,#0x3c
00001c  d002              BEQ      |L89.36|
;;;222        return 0;  /* cannot patch other instructions */
00001e  2000              MOVS     r0,#0
                  |L89.32|
;;;223      if (reg != NO_REG && reg != GETARG_B(*i))
;;;224        SETARG_A(*i, reg);
;;;225      else {
;;;226         /* no register to put value or register already has the value;
;;;227            change instruction to simple test */
;;;228        *i = CREATE_ABCk(OP_TEST, GETARG_B(*i), 0, 0, GETARG_k(*i));
;;;229      }
;;;230      return 1;
;;;231    }
000020  e8bd81f0          POP      {r4-r8,pc}
                  |L89.36|
000024  2dff              CMP      r5,#0xff              ;223
000026  d009              BEQ      |L89.60|
000028  6820              LDR      r0,[r4,#0]            ;223
00002a  f3c04007          UBFX     r0,r0,#16,#8          ;223
00002e  42a8              CMP      r0,r5                 ;223
000030  d004              BEQ      |L89.60|
000032  6820              LDR      r0,[r4,#0]            ;224
000034  f36510ce          BFI      r0,r5,#7,#8           ;224
000038  6020              STR      r0,[r4,#0]            ;224
00003a  e00b              B        |L89.84|
                  |L89.60|
00003c  6820              LDR      r0,[r4,#0]            ;228
00003e  f3c04007          UBFX     r0,r0,#16,#8          ;228
000042  213b              MOVS     r1,#0x3b              ;228
000044  ea4110c0          ORR      r0,r1,r0,LSL #7       ;228
000048  8821              LDRH     r1,[r4,#0]            ;228
00004a  f3c131c0          UBFX     r1,r1,#15,#1          ;228
00004e  ea4030c1          ORR      r0,r0,r1,LSL #15      ;228
000052  6020              STR      r0,[r4,#0]            ;228
                  |L89.84|
000054  2001              MOVS     r0,#1                 ;230
000056  e7e3              B        |L89.32|
;;;232    
                          ENDP


                          AREA ||i.previousinstruction||, CODE, READONLY, ALIGN=2

                  previousinstruction PROC
;;;75     */
;;;76     static Instruction *previousinstruction (FuncState *fs) {
000000  4601              MOV      r1,r0
;;;77       static const Instruction invalidinstruction = -1;
;;;78       if (fs->pc > fs->lasttarget)
000002  e9d10204          LDRD     r0,r2,[r1,#0x10]
000006  4290              CMP      r0,r2
000008  dd06              BLE      |L90.24|
;;;79         return &fs->f->code[fs->pc - 1];  /* previous instruction */
00000a  6808              LDR      r0,[r1,#0]
00000c  6b82              LDR      r2,[r0,#0x38]
00000e  6908              LDR      r0,[r1,#0x10]
000010  1e40              SUBS     r0,r0,#1
000012  eb020080          ADD      r0,r2,r0,LSL #2
                  |L90.22|
;;;80       else
;;;81         return cast(Instruction*, &invalidinstruction);
;;;82     }
000016  4770              BX       lr
                  |L90.24|
000018  4800              LDR      r0,|L90.28|
00001a  e7fc              B        |L90.22|
;;;83     
                          ENDP

                  |L90.28|
                          DCD      invalidinstruction

                          AREA ||i.removevalues||, CODE, READONLY, ALIGN=1

                  removevalues PROC
;;;236    */
;;;237    static void removevalues (FuncState *fs, int list) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;238      for (; list != NO_JUMP; list = getjump(fs, list))
000006  e009              B        |L91.28|
                  |L91.8|
;;;239          patchtestreg(fs, list, NO_REG);
000008  22ff              MOVS     r2,#0xff
00000a  4621              MOV      r1,r4
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       patchtestreg
000012  4621              MOV      r1,r4                 ;238
000014  4628              MOV      r0,r5                 ;238
000016  f7fffffe          BL       getjump
00001a  4604              MOV      r4,r0                 ;238
                  |L91.28|
00001c  1c60              ADDS     r0,r4,#1              ;238
00001e  2800              CMP      r0,#0                 ;238
000020  d1f2              BNE      |L91.8|
;;;240    }
000022  bd70              POP      {r4-r6,pc}
;;;241    
                          ENDP


                          AREA ||i.savelineinfo||, CODE, READONLY, ALIGN=2

                  savelineinfo PROC
;;;322    */
;;;323    static void savelineinfo (FuncState *fs, Proto *f, int pc, int line) {
000000  e92d43fe          PUSH     {r1-r9,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  461e              MOV      r6,r3
;;;324      int linedif = line - fs->previousline;
00000c  69a0              LDR      r0,[r4,#0x18]
00000e  eba60800          SUB      r8,r6,r0
;;;325      if (abs(linedif) >= 0x80 || fs->iwthabs++ > MAXIWTHABS) {
000012  f1b80000          SUBS     r0,r8,#0
000016  db01              BLT      |L92.28|
000018  4601              MOV      r1,r0
00001a  e000              B        |L92.30|
                  |L92.28|
00001c  4241              RSBS     r1,r0,#0
                  |L92.30|
00001e  2980              CMP      r1,#0x80
000020  da07              BGE      |L92.50|
000022  f8142f31          LDRB     r2,[r4,#0x31]!
000026  7821              LDRB     r1,[r4,#0]
000028  1c49              ADDS     r1,r1,#1
00002a  f8041931          STRB     r1,[r4],#-0x31
00002e  2a78              CMP      r2,#0x78
000030  dd1f              BLE      |L92.114|
                  |L92.50|
;;;326        luaM_growvector(fs->ls->L, f->abslineinfo, fs->nabslineinfo,
000032  a01b              ADR      r0,|L92.160|
000034  f06f4160          MVN      r1,#0xe0000000
000038  2208              MOVS     r2,#8
00003a  e9cd2100          STRD     r2,r1,[sp,#0]
00003e  9002              STR      r0,[sp,#8]
000040  6a62              LDR      r2,[r4,#0x24]
000042  6ca9              LDR      r1,[r5,#0x48]
000044  68a3              LDR      r3,[r4,#8]
000046  6b58              LDR      r0,[r3,#0x34]
000048  f1050324          ADD      r3,r5,#0x24
00004c  f7fffffe          BL       luaM_growaux_
000050  64a8              STR      r0,[r5,#0x48]
;;;327                        f->sizeabslineinfo, AbsLineInfo, MAX_INT, "lines");
;;;328        f->abslineinfo[fs->nabslineinfo].pc = pc;
000052  6ca8              LDR      r0,[r5,#0x48]
000054  6a61              LDR      r1,[r4,#0x24]
000056  f8407031          STR      r7,[r0,r1,LSL #3]
;;;329        f->abslineinfo[fs->nabslineinfo++].line = line;
00005a  6a61              LDR      r1,[r4,#0x24]
00005c  1c48              ADDS     r0,r1,#1
00005e  6260              STR      r0,[r4,#0x24]
000060  6ca8              LDR      r0,[r5,#0x48]
000062  eb0000c1          ADD      r0,r0,r1,LSL #3
000066  6046              STR      r6,[r0,#4]
;;;330        linedif = ABSLINEINFO;  /* signal there is absolute information */
000068  f06f087f          MVN      r8,#0x7f
;;;331        fs->iwthabs = 0;  /* restart counter */
00006c  2000              MOVS     r0,#0
00006e  f8840031          STRB     r0,[r4,#0x31]
                  |L92.114|
;;;332      }
;;;333      luaM_growvector(fs->ls->L, f->lineinfo, pc, f->sizelineinfo, ls_byte,
000072  a00d              ADR      r0,|L92.168|
000074  f06f4100          MVN      r1,#0x80000000
000078  2201              MOVS     r2,#1
00007a  e9cd2100          STRD     r2,r1,[sp,#0]
00007e  9002              STR      r0,[sp,#8]
000080  6c69              LDR      r1,[r5,#0x44]
000082  68a2              LDR      r2,[r4,#8]
000084  f1050318          ADD      r3,r5,#0x18
000088  6b50              LDR      r0,[r2,#0x34]
00008a  463a              MOV      r2,r7
00008c  f7fffffe          BL       luaM_growaux_
000090  6468              STR      r0,[r5,#0x44]
;;;334                      MAX_INT, "opcodes");
;;;335      f->lineinfo[pc] = linedif;
000092  fa4ff088          SXTB     r0,r8
000096  6c69              LDR      r1,[r5,#0x44]
000098  55c8              STRB     r0,[r1,r7]
;;;336      fs->previousline = line;  /* last line saved */
00009a  61a6              STR      r6,[r4,#0x18]
;;;337    }
00009c  e8bd83fe          POP      {r1-r9,pc}
;;;338    
                          ENDP

                  |L92.160|
0000a0  6c696e65          DCB      "lines",0
0000a4  7300    
0000a6  00                DCB      0
0000a7  00                DCB      0
                  |L92.168|
0000a8  6f70636f          DCB      "opcodes",0
0000ac  64657300

                          AREA ||i.swapexps||, CODE, READONLY, ALIGN=1

                  swapexps PROC
;;;1284   
;;;1285   static void swapexps (expdesc *e1, expdesc *e2) {
000000  b530              PUSH     {r4,r5,lr}
000002  b087              SUB      sp,sp,#0x1c
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;1286     expdesc temp = *e1; *e1 = *e2; *e2 = temp;  /* swap 'e1' and 'e2' */
000008  2218              MOVS     r2,#0x18
00000a  4621              MOV      r1,r4
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       __aeabi_memcpy4
000012  2218              MOVS     r2,#0x18
000014  4629              MOV      r1,r5
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       __aeabi_memcpy4
00001c  2218              MOVS     r2,#0x18
00001e  4669              MOV      r1,sp
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       __aeabi_memcpy4
;;;1287   }
000026  b007              ADD      sp,sp,#0x1c
000028  bd30              POP      {r4,r5,pc}
;;;1288   
                          ENDP


                          AREA ||i.tonumeral||, CODE, READONLY, ALIGN=1

                  tonumeral PROC
;;;54     */
;;;55     static int tonumeral(const expdesc *e, TValue *v) {
000000  b510              PUSH     {r4,lr}
000002  4602              MOV      r2,r0
;;;56       if (hasjumps(e))
000004  e9d20304          LDRD     r0,r3,[r2,#0x10]
000008  4298              CMP      r0,r3
00000a  d001              BEQ      |L94.16|
;;;57         return 0;  /* not a numeral */
00000c  2000              MOVS     r0,#0
                  |L94.14|
;;;58       switch (e->k) {
;;;59         case VKINT:
;;;60           if (v) setivalue(v, e->u.ival);
;;;61           return 1;
;;;62         case VKFLT:
;;;63           if (v) setfltvalue(v, e->u.nval);
;;;64           return 1;
;;;65         default: return 0;
;;;66       }
;;;67     }
00000e  bd10              POP      {r4,pc}
                  |L94.16|
000010  6810              LDR      r0,[r2,#0]            ;58
000012  2805              CMP      r0,#5                 ;58
000014  d00c              BEQ      |L94.48|
000016  2806              CMP      r0,#6                 ;58
000018  d115              BNE      |L94.70|
00001a  b139              CBZ      r1,|L94.44|
00001c  4608              MOV      r0,r1                 ;60
00001e  e9d23402          LDRD     r3,r4,[r2,#8]         ;60
000022  e9c03400          STRD     r3,r4,[r0,#0]         ;60
000026  2323              MOVS     r3,#0x23              ;60
000028  7203              STRB     r3,[r0,#8]            ;60
00002a  bf00              NOP                            ;60
                  |L94.44|
00002c  2001              MOVS     r0,#1                 ;61
00002e  e7ee              B        |L94.14|
                  |L94.48|
000030  b139              CBZ      r1,|L94.66|
000032  4608              MOV      r0,r1                 ;63
000034  e9d23402          LDRD     r3,r4,[r2,#8]         ;63
000038  e9c03400          STRD     r3,r4,[r0,#0]         ;63
00003c  2313              MOVS     r3,#0x13              ;63
00003e  7203              STRB     r3,[r0,#8]            ;63
000040  bf00              NOP                            ;63
                  |L94.66|
000042  2001              MOVS     r0,#1                 ;64
000044  e7e3              B        |L94.14|
                  |L94.70|
000046  2000              MOVS     r0,#0                 ;65
000048  e7e1              B        |L94.14|
;;;68     
                          ENDP


                          AREA ||i.validop||, CODE, READONLY, ALIGN=1

                  validop PROC
;;;1178   */
;;;1179   static int validop (int op, TValue *v1, TValue *v2) {
000000  e92d41fc          PUSH     {r2-r8,lr}
000004  4680              MOV      r8,r0
000006  460d              MOV      r5,r1
000008  4614              MOV      r4,r2
;;;1180     switch (op) {
00000a  f1a80003          SUB      r0,r8,#3
00000e  280b              CMP      r0,#0xb
000010  d246              BCS      |L95.160|
000012  e8dff000          TBB      [pc,r0]
000016  3045              DCB      0x30,0x45
000018  2e2f0607          DCB      0x2e,0x2f,0x06,0x07
00001c  08090a45          DCB      0x08,0x09,0x0a,0x45
000020  0b00              DCB      0x0b,0x00
;;;1181       case LUA_OPBAND: case LUA_OPBOR: case LUA_OPBXOR:
000022  bf00              NOP      
000024  bf00              NOP      
;;;1182       case LUA_OPSHL: case LUA_OPSHR: case LUA_OPBNOT: {  /* conversion errors */
000026  bf00              NOP      
000028  bf00              NOP      
00002a  bf00              NOP      
;;;1183         lua_Integer i;
;;;1184         return (tointegerns(v1, &i) && tointegerns(v2, &i));
00002c  7a28              LDRB     r0,[r5,#8]
00002e  2823              CMP      r0,#0x23
000030  d105              BNE      |L95.62|
000032  e9d50100          LDRD     r0,r1,[r5,#0]
000036  e9cd0100          STRD     r0,r1,[sp,#0]
00003a  2001              MOVS     r0,#1
00003c  e004              B        |L95.72|
                  |L95.62|
00003e  2200              MOVS     r2,#0
000040  4669              MOV      r1,sp
000042  4628              MOV      r0,r5
000044  f7fffffe          BL       luaV_tointegerns
                  |L95.72|
000048  b188              CBZ      r0,|L95.110|
00004a  7a20              LDRB     r0,[r4,#8]
00004c  2823              CMP      r0,#0x23
00004e  d105              BNE      |L95.92|
000050  e9d40100          LDRD     r0,r1,[r4,#0]
000054  e9cd0100          STRD     r0,r1,[sp,#0]
000058  2001              MOVS     r0,#1
00005a  e004              B        |L95.102|
                  |L95.92|
00005c  2200              MOVS     r2,#0
00005e  4669              MOV      r1,sp
000060  4620              MOV      r0,r4
000062  f7fffffe          BL       luaV_tointegerns
                  |L95.102|
000066  b110              CBZ      r0,|L95.110|
000068  2001              MOVS     r0,#1
                  |L95.106|
;;;1185       }
;;;1186       case LUA_OPDIV: case LUA_OPIDIV: case LUA_OPMOD:  /* division by 0 */
;;;1187         return (nvalue(v2) != 0);
;;;1188       default: return 1;  /* everything else is valid */
;;;1189     }
;;;1190   }
00006a  e8bd81fc          POP      {r2-r8,pc}
                  |L95.110|
00006e  2000              MOVS     r0,#0                 ;1184
000070  e7fb              B        |L95.106|
000072  bf00              NOP                            ;1186
000074  bf00              NOP                            ;1186
000076  7a20              LDRB     r0,[r4,#8]            ;1187
000078  2823              CMP      r0,#0x23              ;1187
00007a  d105              BNE      |L95.136|
00007c  e9d42100          LDRD     r2,r1,[r4,#0]         ;1187
000080  4610              MOV      r0,r2                 ;1187
000082  f7fffffe          BL       __aeabi_l2d
000086  e001              B        |L95.140|
                  |L95.136|
000088  e9d40100          LDRD     r0,r1,[r4,#0]         ;1187
                  |L95.140|
00008c  4606              MOV      r6,r0                 ;1187
00008e  2200              MOVS     r2,#0                 ;1187
000090  4613              MOV      r3,r2                 ;1187
000092  f7fffffe          BL       __aeabi_cdcmpeq
000096  d001              BEQ      |L95.156|
000098  2001              MOVS     r0,#1                 ;1187
00009a  e7e6              B        |L95.106|
                  |L95.156|
00009c  2000              MOVS     r0,#0                 ;1187
00009e  e7e4              B        |L95.106|
                  |L95.160|
0000a0  2001              MOVS     r0,#1                 ;1188
0000a2  e7e2              B        |L95.106|
;;;1191   
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=3

                  invalidinstruction
                          DCD      0xffffffff
                          DCD      0x00000000
                  ||ef||
                          DCD      0x00000006
                          DCD      0x00000000
000010  00000000          DCQ      0x0000000000000000
000014  00000000
                          DCD      0xffffffff
                          DCD      0xffffffff
