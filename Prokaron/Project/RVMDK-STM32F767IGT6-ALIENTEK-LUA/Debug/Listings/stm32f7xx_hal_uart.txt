; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f7xx_hal_uart.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f7xx_hal_uart.d --cpu=Cortex-M7 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Inc -I.\Source -I.\Drivers -I..\..\..\M6P1(L)_Lua\lua -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6-ALIENTEK-LUA\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER -Dlua_writestring=RMP_lua_writestring -Dlua_writeline=RMP_lua_writeline --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f7xx_hal_uart.crf ..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_uart.c]
                          THUMB

                          AREA ||i.HAL_HalfDuplex_EnableReceiver||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableReceiver PROC
;;;2070     */
;;;2071   HAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2072   {
;;;2073     /* Process Locked */
;;;2074     __HAL_LOCK(huart);
000002  bf00              NOP      
000004  6e88              LDR      r0,[r1,#0x68]
000006  2801              CMP      r0,#1
000008  d101              BNE      |L1.14|
00000a  2002              MOVS     r0,#2
                  |L1.12|
;;;2075     huart->gState = HAL_UART_STATE_BUSY;
;;;2076   
;;;2077     /* Clear TE and RE bits */
;;;2078     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TE | USART_CR1_RE));
;;;2079     /* Enable the USART's receive interface by setting the RE bit in the USART CR1 register */
;;;2080     SET_BIT(huart->Instance->CR1, USART_CR1_RE);
;;;2081   
;;;2082     huart->gState = HAL_UART_STATE_READY;
;;;2083     /* Process Unlocked */
;;;2084     __HAL_UNLOCK(huart);
;;;2085   
;;;2086     return HAL_OK;
;;;2087   }
00000c  4770              BX       lr
                  |L1.14|
00000e  2001              MOVS     r0,#1                 ;2074
000010  6688              STR      r0,[r1,#0x68]         ;2074
000012  bf00              NOP                            ;2074
000014  2024              MOVS     r0,#0x24              ;2075
000016  66c8              STR      r0,[r1,#0x6c]         ;2075
000018  6808              LDR      r0,[r1,#0]            ;2078
00001a  6800              LDR      r0,[r0,#0]            ;2078
00001c  f020000c          BIC      r0,r0,#0xc            ;2078
000020  680a              LDR      r2,[r1,#0]            ;2078
000022  6010              STR      r0,[r2,#0]            ;2078
000024  6808              LDR      r0,[r1,#0]            ;2080
000026  6800              LDR      r0,[r0,#0]            ;2080
000028  f0400004          ORR      r0,r0,#4              ;2080
00002c  680a              LDR      r2,[r1,#0]            ;2080
00002e  6010              STR      r0,[r2,#0]            ;2080
000030  2020              MOVS     r0,#0x20              ;2082
000032  66c8              STR      r0,[r1,#0x6c]         ;2082
000034  bf00              NOP                            ;2084
000036  2000              MOVS     r0,#0                 ;2084
000038  6688              STR      r0,[r1,#0x68]         ;2084
00003a  bf00              NOP                            ;2084
00003c  bf00              NOP                            ;2086
00003e  e7e5              B        |L1.12|
;;;2088   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_EnableTransmitter||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableTransmitter PROC
;;;2047     */
;;;2048   HAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2049   {
;;;2050     /* Process Locked */
;;;2051     __HAL_LOCK(huart);
000002  bf00              NOP      
000004  6e88              LDR      r0,[r1,#0x68]
000006  2801              CMP      r0,#1
000008  d101              BNE      |L2.14|
00000a  2002              MOVS     r0,#2
                  |L2.12|
;;;2052     huart->gState = HAL_UART_STATE_BUSY;
;;;2053   
;;;2054     /* Clear TE and RE bits */
;;;2055     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TE | USART_CR1_RE));
;;;2056     /* Enable the USART's transmit interface by setting the TE bit in the USART CR1 register */
;;;2057     SET_BIT(huart->Instance->CR1, USART_CR1_TE);
;;;2058   
;;;2059     huart->gState= HAL_UART_STATE_READY;
;;;2060     /* Process Unlocked */
;;;2061     __HAL_UNLOCK(huart);
;;;2062   
;;;2063     return HAL_OK;
;;;2064   }
00000c  4770              BX       lr
                  |L2.14|
00000e  2001              MOVS     r0,#1                 ;2051
000010  6688              STR      r0,[r1,#0x68]         ;2051
000012  bf00              NOP                            ;2051
000014  2024              MOVS     r0,#0x24              ;2052
000016  66c8              STR      r0,[r1,#0x6c]         ;2052
000018  6808              LDR      r0,[r1,#0]            ;2055
00001a  6800              LDR      r0,[r0,#0]            ;2055
00001c  f020000c          BIC      r0,r0,#0xc            ;2055
000020  680a              LDR      r2,[r1,#0]            ;2055
000022  6010              STR      r0,[r2,#0]            ;2055
000024  6808              LDR      r0,[r1,#0]            ;2057
000026  6800              LDR      r0,[r0,#0]            ;2057
000028  f0400008          ORR      r0,r0,#8              ;2057
00002c  680a              LDR      r2,[r1,#0]            ;2057
00002e  6010              STR      r0,[r2,#0]            ;2057
000030  2020              MOVS     r0,#0x20              ;2059
000032  66c8              STR      r0,[r1,#0x6c]         ;2059
000034  bf00              NOP                            ;2061
000036  2000              MOVS     r0,#0                 ;2061
000038  6688              STR      r0,[r1,#0x68]         ;2061
00003a  bf00              NOP                            ;2061
00003c  bf00              NOP                            ;2063
00003e  e7e5              B        |L2.12|
;;;2065   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_Init||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_Init PROC
;;;303      */
;;;304    HAL_StatusTypeDef HAL_HalfDuplex_Init(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;305    {
000002  4604              MOV      r4,r0
;;;306      /* Check the UART handle allocation */
;;;307      if(huart == NULL)
000004  b90c              CBNZ     r4,|L3.10|
;;;308      {
;;;309        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L3.8|
;;;310      }
;;;311    
;;;312      if(huart->gState == HAL_UART_STATE_RESET)
;;;313      {
;;;314        /* Allocate lock resource and initialize it */
;;;315        huart->Lock = HAL_UNLOCKED;
;;;316    
;;;317        /* Init the low level hardware : GPIO, CLOCK */
;;;318        HAL_UART_MspInit(huart);
;;;319      }
;;;320    
;;;321      huart->gState = HAL_UART_STATE_BUSY;
;;;322    
;;;323      /* Disable the Peripheral */
;;;324      __HAL_UART_DISABLE(huart);
;;;325    
;;;326      /* Set the UART Communication parameters */
;;;327      if (UART_SetConfig(huart) == HAL_ERROR)
;;;328      {
;;;329        return HAL_ERROR;
;;;330      }
;;;331    
;;;332      if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;333      {
;;;334        UART_AdvFeatureConfig(huart);
;;;335      }
;;;336    
;;;337      /* In half-duplex mode, the following bits must be kept cleared:
;;;338      - LINEN and CLKEN bits in the USART_CR2 register,
;;;339      - SCEN and IREN bits in the USART_CR3 register.*/
;;;340      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;341      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_IREN | USART_CR3_SCEN));
;;;342    
;;;343      /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;344      SET_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
;;;345    
;;;346      /* Enable the Peripheral */
;;;347      __HAL_UART_ENABLE(huart);
;;;348    
;;;349      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;350      return (UART_CheckIdleState(huart));
;;;351    }
000008  bd10              POP      {r4,pc}
                  |L3.10|
00000a  6ee0              LDR      r0,[r4,#0x6c]         ;312
00000c  b920              CBNZ     r0,|L3.24|
00000e  2000              MOVS     r0,#0                 ;315
000010  66a0              STR      r0,[r4,#0x68]         ;315
000012  4620              MOV      r0,r4                 ;318
000014  f7fffffe          BL       HAL_UART_MspInit
                  |L3.24|
000018  2024              MOVS     r0,#0x24              ;321
00001a  66e0              STR      r0,[r4,#0x6c]         ;321
00001c  6820              LDR      r0,[r4,#0]            ;324
00001e  6800              LDR      r0,[r0,#0]            ;324
000020  f0200001          BIC      r0,r0,#1              ;324
000024  6821              LDR      r1,[r4,#0]            ;324
000026  6008              STR      r0,[r1,#0]            ;324
000028  4620              MOV      r0,r4                 ;327
00002a  f7fffffe          BL       UART_SetConfig
00002e  2801              CMP      r0,#1                 ;327
000030  d100              BNE      |L3.52|
000032  e7e9              B        |L3.8|
                  |L3.52|
000034  6a60              LDR      r0,[r4,#0x24]         ;332
000036  b110              CBZ      r0,|L3.62|
000038  4620              MOV      r0,r4                 ;334
00003a  f7fffffe          BL       UART_AdvFeatureConfig
                  |L3.62|
00003e  6820              LDR      r0,[r4,#0]            ;340
000040  6840              LDR      r0,[r0,#4]            ;340
000042  f4204090          BIC      r0,r0,#0x4800         ;340
000046  6821              LDR      r1,[r4,#0]            ;340
000048  6048              STR      r0,[r1,#4]            ;340
00004a  6820              LDR      r0,[r4,#0]            ;341
00004c  6880              LDR      r0,[r0,#8]            ;341
00004e  f0200022          BIC      r0,r0,#0x22           ;341
000052  6821              LDR      r1,[r4,#0]            ;341
000054  6088              STR      r0,[r1,#8]            ;341
000056  6820              LDR      r0,[r4,#0]            ;344
000058  6880              LDR      r0,[r0,#8]            ;344
00005a  f0400008          ORR      r0,r0,#8              ;344
00005e  6821              LDR      r1,[r4,#0]            ;344
000060  6088              STR      r0,[r1,#8]            ;344
000062  6820              LDR      r0,[r4,#0]            ;347
000064  6800              LDR      r0,[r0,#0]            ;347
000066  f0400001          ORR      r0,r0,#1              ;347
00006a  6821              LDR      r1,[r4,#0]            ;347
00006c  6008              STR      r0,[r1,#0]            ;347
00006e  4620              MOV      r0,r4                 ;350
000070  f7fffffe          BL       UART_CheckIdleState
000074  e7c8              B        |L3.8|
;;;352    
                          ENDP


                          AREA ||i.HAL_LIN_Init||, CODE, READONLY, ALIGN=1

                  HAL_LIN_Init PROC
;;;363      */
;;;364    HAL_StatusTypeDef HAL_LIN_Init(UART_HandleTypeDef *huart, uint32_t BreakDetectLength)
000000  b570              PUSH     {r4-r6,lr}
;;;365    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;366      /* Check the UART handle allocation */
;;;367      if(huart == NULL)
000006  b90c              CBNZ     r4,|L4.12|
;;;368      {
;;;369        return HAL_ERROR;
000008  2001              MOVS     r0,#1
                  |L4.10|
;;;370      }
;;;371    
;;;372      /* Check the parameters */
;;;373      assert_param(IS_UART_INSTANCE(huart->Instance));
;;;374      assert_param(IS_UART_LIN_BREAK_DETECT_LENGTH(BreakDetectLength));
;;;375      assert_param(IS_LIN_WORD_LENGTH(huart->Init.WordLength));
;;;376    
;;;377      if(huart->gState == HAL_UART_STATE_RESET)
;;;378      {
;;;379        /* Allocate lock resource and initialize it */
;;;380        huart->Lock = HAL_UNLOCKED;
;;;381    
;;;382        /* Init the low level hardware : GPIO, CLOCK */
;;;383        HAL_UART_MspInit(huart);
;;;384      }
;;;385    
;;;386      huart->gState = HAL_UART_STATE_BUSY;
;;;387    
;;;388      /* Disable the Peripheral */
;;;389      __HAL_UART_DISABLE(huart);
;;;390    
;;;391      /* Set the UART Communication parameters */
;;;392      if (UART_SetConfig(huart) == HAL_ERROR)
;;;393      {
;;;394        return HAL_ERROR;
;;;395      }
;;;396    
;;;397      if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;398      {
;;;399        UART_AdvFeatureConfig(huart);
;;;400      }
;;;401    
;;;402      /* In LIN mode, the following bits must be kept cleared:
;;;403      - LINEN and CLKEN bits in the USART_CR2 register,
;;;404      - SCEN and IREN bits in the USART_CR3 register.*/
;;;405      CLEAR_BIT(huart->Instance->CR2, USART_CR2_CLKEN);
;;;406      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_HDSEL | USART_CR3_IREN | USART_CR3_SCEN));
;;;407    
;;;408      /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;409      SET_BIT(huart->Instance->CR2, USART_CR2_LINEN);
;;;410    
;;;411      /* Set the USART LIN Break detection length. */
;;;412      MODIFY_REG(huart->Instance->CR2, USART_CR2_LBDL, BreakDetectLength);
;;;413    
;;;414      /* Enable the Peripheral */
;;;415      __HAL_UART_ENABLE(huart);
;;;416    
;;;417      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;418      return (UART_CheckIdleState(huart));
;;;419    }
00000a  bd70              POP      {r4-r6,pc}
                  |L4.12|
00000c  6ee0              LDR      r0,[r4,#0x6c]         ;377
00000e  b920              CBNZ     r0,|L4.26|
000010  2000              MOVS     r0,#0                 ;380
000012  66a0              STR      r0,[r4,#0x68]         ;380
000014  4620              MOV      r0,r4                 ;383
000016  f7fffffe          BL       HAL_UART_MspInit
                  |L4.26|
00001a  2024              MOVS     r0,#0x24              ;386
00001c  66e0              STR      r0,[r4,#0x6c]         ;386
00001e  6820              LDR      r0,[r4,#0]            ;389
000020  6800              LDR      r0,[r0,#0]            ;389
000022  f0200001          BIC      r0,r0,#1              ;389
000026  6821              LDR      r1,[r4,#0]            ;389
000028  6008              STR      r0,[r1,#0]            ;389
00002a  4620              MOV      r0,r4                 ;392
00002c  f7fffffe          BL       UART_SetConfig
000030  2801              CMP      r0,#1                 ;392
000032  d100              BNE      |L4.54|
000034  e7e9              B        |L4.10|
                  |L4.54|
000036  6a60              LDR      r0,[r4,#0x24]         ;397
000038  b110              CBZ      r0,|L4.64|
00003a  4620              MOV      r0,r4                 ;399
00003c  f7fffffe          BL       UART_AdvFeatureConfig
                  |L4.64|
000040  6820              LDR      r0,[r4,#0]            ;405
000042  6840              LDR      r0,[r0,#4]            ;405
000044  f4206000          BIC      r0,r0,#0x800          ;405
000048  6821              LDR      r1,[r4,#0]            ;405
00004a  6048              STR      r0,[r1,#4]            ;405
00004c  6820              LDR      r0,[r4,#0]            ;406
00004e  6880              LDR      r0,[r0,#8]            ;406
000050  f020002a          BIC      r0,r0,#0x2a           ;406
000054  6821              LDR      r1,[r4,#0]            ;406
000056  6088              STR      r0,[r1,#8]            ;406
000058  6820              LDR      r0,[r4,#0]            ;409
00005a  6840              LDR      r0,[r0,#4]            ;409
00005c  f4404080          ORR      r0,r0,#0x4000         ;409
000060  6821              LDR      r1,[r4,#0]            ;409
000062  6048              STR      r0,[r1,#4]            ;409
000064  6820              LDR      r0,[r4,#0]            ;412
000066  6840              LDR      r0,[r0,#4]            ;412
000068  f0200020          BIC      r0,r0,#0x20           ;412
00006c  4328              ORRS     r0,r0,r5              ;412
00006e  6821              LDR      r1,[r4,#0]            ;412
000070  6048              STR      r0,[r1,#4]            ;412
000072  6820              LDR      r0,[r4,#0]            ;415
000074  6800              LDR      r0,[r0,#0]            ;415
000076  f0400001          ORR      r0,r0,#1              ;415
00007a  6821              LDR      r1,[r4,#0]            ;415
00007c  6008              STR      r0,[r1,#0]            ;415
00007e  4620              MOV      r0,r4                 ;418
000080  f7fffffe          BL       UART_CheckIdleState
000084  e7c1              B        |L4.10|
;;;420    
                          ENDP


                          AREA ||i.HAL_LIN_SendBreak||, CODE, READONLY, ALIGN=1

                  HAL_LIN_SendBreak PROC
;;;2094     */
;;;2095   HAL_StatusTypeDef HAL_LIN_SendBreak(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2096   {
;;;2097     /* Check the parameters */
;;;2098     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;2099   
;;;2100     /* Process Locked */
;;;2101     __HAL_LOCK(huart);
000002  bf00              NOP      
000004  6e88              LDR      r0,[r1,#0x68]
000006  2801              CMP      r0,#1
000008  d101              BNE      |L5.14|
00000a  2002              MOVS     r0,#2
                  |L5.12|
;;;2102   
;;;2103     huart->gState = HAL_UART_STATE_BUSY;
;;;2104   
;;;2105     /* Send break characters */
;;;2106     SET_BIT(huart->Instance->RQR, UART_SENDBREAK_REQUEST);
;;;2107   
;;;2108     huart->gState = HAL_UART_STATE_READY;
;;;2109   
;;;2110     /* Process Unlocked */
;;;2111     __HAL_UNLOCK(huart);
;;;2112   
;;;2113     return HAL_OK;
;;;2114   }
00000c  4770              BX       lr
                  |L5.14|
00000e  2001              MOVS     r0,#1                 ;2101
000010  6688              STR      r0,[r1,#0x68]         ;2101
000012  bf00              NOP                            ;2101
000014  2024              MOVS     r0,#0x24              ;2103
000016  66c8              STR      r0,[r1,#0x6c]         ;2103
000018  6808              LDR      r0,[r1,#0]            ;2106
00001a  6980              LDR      r0,[r0,#0x18]         ;2106
00001c  f0400002          ORR      r0,r0,#2              ;2106
000020  680a              LDR      r2,[r1,#0]            ;2106
000022  6190              STR      r0,[r2,#0x18]         ;2106
000024  2020              MOVS     r0,#0x20              ;2108
000026  66c8              STR      r0,[r1,#0x6c]         ;2108
000028  bf00              NOP                            ;2111
00002a  2000              MOVS     r0,#0                 ;2111
00002c  6688              STR      r0,[r1,#0x68]         ;2111
00002e  bf00              NOP                            ;2111
000030  bf00              NOP                            ;2113
000032  e7eb              B        |L5.12|
;;;2115   
                          ENDP


                          AREA ||i.HAL_MultiProcessorEx_AddressLength_Set||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessorEx_AddressLength_Set PROC
;;;2128     */
;;;2129   HAL_StatusTypeDef HAL_MultiProcessorEx_AddressLength_Set(UART_HandleTypeDef *huart, uint32_t AddressLength)
000000  b570              PUSH     {r4-r6,lr}
;;;2130   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2131     /* Check the UART handle allocation */
;;;2132     if(huart == NULL)
000006  b90c              CBNZ     r4,|L6.12|
;;;2133     {
;;;2134       return HAL_ERROR;
000008  2001              MOVS     r0,#1
                  |L6.10|
;;;2135     }
;;;2136   
;;;2137     /* Check the address length parameter */
;;;2138     assert_param(IS_UART_ADDRESSLENGTH_DETECT(AddressLength));
;;;2139   
;;;2140     huart->gState = HAL_UART_STATE_BUSY;
;;;2141   
;;;2142     /* Disable the Peripheral */
;;;2143     __HAL_UART_DISABLE(huart);
;;;2144   
;;;2145     /* Set the address length */
;;;2146     MODIFY_REG(huart->Instance->CR2, USART_CR2_ADDM7, AddressLength);
;;;2147   
;;;2148     /* Enable the Peripheral */
;;;2149     __HAL_UART_ENABLE(huart);
;;;2150   
;;;2151     /* TEACK and/or REACK to check before moving huart->gState to Ready */
;;;2152     return (UART_CheckIdleState(huart));
;;;2153   }
00000a  bd70              POP      {r4-r6,pc}
                  |L6.12|
00000c  2024              MOVS     r0,#0x24              ;2140
00000e  66e0              STR      r0,[r4,#0x6c]         ;2140
000010  6820              LDR      r0,[r4,#0]            ;2143
000012  6800              LDR      r0,[r0,#0]            ;2143
000014  f0200001          BIC      r0,r0,#1              ;2143
000018  6821              LDR      r1,[r4,#0]            ;2143
00001a  6008              STR      r0,[r1,#0]            ;2143
00001c  6820              LDR      r0,[r4,#0]            ;2146
00001e  6840              LDR      r0,[r0,#4]            ;2146
000020  f0200010          BIC      r0,r0,#0x10           ;2146
000024  4328              ORRS     r0,r0,r5              ;2146
000026  6821              LDR      r1,[r4,#0]            ;2146
000028  6048              STR      r0,[r1,#4]            ;2146
00002a  6820              LDR      r0,[r4,#0]            ;2149
00002c  6800              LDR      r0,[r0,#0]            ;2149
00002e  f0400001          ORR      r0,r0,#1              ;2149
000032  6821              LDR      r1,[r4,#0]            ;2149
000034  6008              STR      r0,[r1,#0]            ;2149
000036  4620              MOV      r0,r4                 ;2152
000038  f7fffffe          BL       UART_CheckIdleState
00003c  e7e5              B        |L6.10|
;;;2154   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_DisableMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_DisableMuteMode PROC
;;;1766     */
;;;1767   HAL_StatusTypeDef HAL_MultiProcessor_DisableMuteMode(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1768   {
000002  4604              MOV      r4,r0
;;;1769     /* Process Locked */
;;;1770     __HAL_LOCK(huart);
000004  bf00              NOP      
000006  6ea0              LDR      r0,[r4,#0x68]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L7.16|
00000c  2002              MOVS     r0,#2
                  |L7.14|
;;;1771   
;;;1772     huart->gState = HAL_UART_STATE_BUSY;
;;;1773   
;;;1774      /* Disable USART mute mode by clearing the MME bit in the CR1 register */
;;;1775     CLEAR_BIT(huart->Instance->CR1, USART_CR1_MME);
;;;1776   
;;;1777     huart->gState = HAL_UART_STATE_READY;
;;;1778   
;;;1779     return (UART_CheckIdleState(huart));
;;;1780   }
00000e  bd10              POP      {r4,pc}
                  |L7.16|
000010  2001              MOVS     r0,#1                 ;1770
000012  66a0              STR      r0,[r4,#0x68]         ;1770
000014  bf00              NOP                            ;1770
000016  2024              MOVS     r0,#0x24              ;1772
000018  66e0              STR      r0,[r4,#0x6c]         ;1772
00001a  6820              LDR      r0,[r4,#0]            ;1775
00001c  6800              LDR      r0,[r0,#0]            ;1775
00001e  f4205000          BIC      r0,r0,#0x2000         ;1775
000022  6821              LDR      r1,[r4,#0]            ;1775
000024  6008              STR      r0,[r1,#0]            ;1775
000026  2020              MOVS     r0,#0x20              ;1777
000028  66e0              STR      r0,[r4,#0x6c]         ;1777
00002a  4620              MOV      r0,r4                 ;1779
00002c  f7fffffe          BL       UART_CheckIdleState
000030  e7ed              B        |L7.14|
;;;1781   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_EnableMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_EnableMuteMode PROC
;;;1745     */
;;;1746   HAL_StatusTypeDef HAL_MultiProcessor_EnableMuteMode(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1747   {
000002  4604              MOV      r4,r0
;;;1748     /* Process Locked */
;;;1749     __HAL_LOCK(huart);
000004  bf00              NOP      
000006  6ea0              LDR      r0,[r4,#0x68]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L8.16|
00000c  2002              MOVS     r0,#2
                  |L8.14|
;;;1750   
;;;1751     huart->gState = HAL_UART_STATE_BUSY;
;;;1752   
;;;1753     /* Enable USART mute mode by setting the MME bit in the CR1 register */
;;;1754     SET_BIT(huart->Instance->CR1, USART_CR1_MME);
;;;1755   
;;;1756     huart->gState = HAL_UART_STATE_READY;
;;;1757   
;;;1758     return (UART_CheckIdleState(huart));
;;;1759   }
00000e  bd10              POP      {r4,pc}
                  |L8.16|
000010  2001              MOVS     r0,#1                 ;1749
000012  66a0              STR      r0,[r4,#0x68]         ;1749
000014  bf00              NOP                            ;1749
000016  2024              MOVS     r0,#0x24              ;1751
000018  66e0              STR      r0,[r4,#0x6c]         ;1751
00001a  6820              LDR      r0,[r4,#0]            ;1754
00001c  6800              LDR      r0,[r0,#0]            ;1754
00001e  f4405000          ORR      r0,r0,#0x2000         ;1754
000022  6821              LDR      r1,[r4,#0]            ;1754
000024  6008              STR      r0,[r1,#0]            ;1754
000026  2020              MOVS     r0,#0x20              ;1756
000028  66e0              STR      r0,[r4,#0x6c]         ;1756
00002a  4620              MOV      r0,r4                 ;1758
00002c  f7fffffe          BL       UART_CheckIdleState
000030  e7ed              B        |L8.14|
;;;1760   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_EnterMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_EnterMuteMode PROC
;;;1787     */
;;;1788   void HAL_MultiProcessor_EnterMuteMode(UART_HandleTypeDef *huart)
000000  6801              LDR      r1,[r0,#0]
;;;1789   {
;;;1790     __HAL_UART_SEND_REQ(huart, UART_MUTE_MODE_REQUEST);
000002  6989              LDR      r1,[r1,#0x18]
000004  f0410104          ORR      r1,r1,#4
000008  6802              LDR      r2,[r0,#0]
00000a  6191              STR      r1,[r2,#0x18]
;;;1791   }
00000c  4770              BX       lr
;;;1792   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_Init||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_Init PROC
;;;437      */
;;;438    HAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod)
000000  b570              PUSH     {r4-r6,lr}
;;;439    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;440      /* Check the UART handle allocation */
;;;441      if(huart == NULL)
000008  b90c              CBNZ     r4,|L10.14|
;;;442      {
;;;443        return HAL_ERROR;
00000a  2001              MOVS     r0,#1
                  |L10.12|
;;;444      }
;;;445    
;;;446      /* Check the wake up method parameter */
;;;447      assert_param(IS_UART_WAKEUPMETHOD(WakeUpMethod));
;;;448    
;;;449      if(huart->gState == HAL_UART_STATE_RESET)
;;;450      {
;;;451        /* Allocate lock resource and initialize it */
;;;452        huart->Lock = HAL_UNLOCKED;
;;;453    
;;;454        /* Init the low level hardware : GPIO, CLOCK */
;;;455        HAL_UART_MspInit(huart);
;;;456      }
;;;457    
;;;458      huart->gState = HAL_UART_STATE_BUSY;
;;;459    
;;;460      /* Disable the Peripheral */
;;;461      __HAL_UART_DISABLE(huart);
;;;462    
;;;463      /* Set the UART Communication parameters */
;;;464      if (UART_SetConfig(huart) == HAL_ERROR)
;;;465      {
;;;466        return HAL_ERROR;
;;;467      }
;;;468    
;;;469      if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;470      {
;;;471        UART_AdvFeatureConfig(huart);
;;;472      }
;;;473    
;;;474      /* In multiprocessor mode, the following bits must be kept cleared:
;;;475      - LINEN and CLKEN bits in the USART_CR2 register,
;;;476      - SCEN, HDSEL and IREN  bits in the USART_CR3 register. */
;;;477      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;478      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;479    
;;;480      if (WakeUpMethod == UART_WAKEUPMETHOD_ADDRESSMARK)
;;;481      {
;;;482        /* If address mark wake up method is chosen, set the USART address node */
;;;483        MODIFY_REG(huart->Instance->CR2, USART_CR2_ADD, ((uint32_t)Address << UART_CR2_ADDRESS_LSB_POS));
;;;484      }
;;;485    
;;;486      /* Set the wake up method by setting the WAKE bit in the CR1 register */
;;;487      MODIFY_REG(huart->Instance->CR1, USART_CR1_WAKE, WakeUpMethod);
;;;488    
;;;489      /* Enable the Peripheral */
;;;490      __HAL_UART_ENABLE(huart);
;;;491    
;;;492      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;493      return (UART_CheckIdleState(huart));
;;;494    }
00000c  bd70              POP      {r4-r6,pc}
                  |L10.14|
00000e  6ee0              LDR      r0,[r4,#0x6c]         ;449
000010  b920              CBNZ     r0,|L10.28|
000012  2000              MOVS     r0,#0                 ;452
000014  66a0              STR      r0,[r4,#0x68]         ;452
000016  4620              MOV      r0,r4                 ;455
000018  f7fffffe          BL       HAL_UART_MspInit
                  |L10.28|
00001c  2024              MOVS     r0,#0x24              ;458
00001e  66e0              STR      r0,[r4,#0x6c]         ;458
000020  6820              LDR      r0,[r4,#0]            ;461
000022  6800              LDR      r0,[r0,#0]            ;461
000024  f0200001          BIC      r0,r0,#1              ;461
000028  6821              LDR      r1,[r4,#0]            ;461
00002a  6008              STR      r0,[r1,#0]            ;461
00002c  4620              MOV      r0,r4                 ;464
00002e  f7fffffe          BL       UART_SetConfig
000032  2801              CMP      r0,#1                 ;464
000034  d100              BNE      |L10.56|
000036  e7e9              B        |L10.12|
                  |L10.56|
000038  6a60              LDR      r0,[r4,#0x24]         ;469
00003a  b110              CBZ      r0,|L10.66|
00003c  4620              MOV      r0,r4                 ;471
00003e  f7fffffe          BL       UART_AdvFeatureConfig
                  |L10.66|
000042  6820              LDR      r0,[r4,#0]            ;477
000044  6840              LDR      r0,[r0,#4]            ;477
000046  f4204090          BIC      r0,r0,#0x4800         ;477
00004a  6821              LDR      r1,[r4,#0]            ;477
00004c  6048              STR      r0,[r1,#4]            ;477
00004e  6820              LDR      r0,[r4,#0]            ;478
000050  6880              LDR      r0,[r0,#8]            ;478
000052  f020002a          BIC      r0,r0,#0x2a           ;478
000056  6821              LDR      r1,[r4,#0]            ;478
000058  6088              STR      r0,[r1,#8]            ;478
00005a  f5b56f00          CMP      r5,#0x800             ;480
00005e  d105              BNE      |L10.108|
000060  6820              LDR      r0,[r4,#0]            ;483
000062  6840              LDR      r0,[r0,#4]            ;483
000064  f366601f          BFI      r0,r6,#24,#8          ;483
000068  6821              LDR      r1,[r4,#0]            ;483
00006a  6048              STR      r0,[r1,#4]            ;483
                  |L10.108|
00006c  6820              LDR      r0,[r4,#0]            ;487
00006e  6800              LDR      r0,[r0,#0]            ;487
000070  f4206000          BIC      r0,r0,#0x800          ;487
000074  4328              ORRS     r0,r0,r5              ;487
000076  6821              LDR      r1,[r4,#0]            ;487
000078  6008              STR      r0,[r1,#0]            ;487
00007a  6820              LDR      r0,[r4,#0]            ;490
00007c  6800              LDR      r0,[r0,#0]            ;490
00007e  f0400001          ORR      r0,r0,#1              ;490
000082  6821              LDR      r1,[r4,#0]            ;490
000084  6008              STR      r0,[r1,#0]            ;490
000086  4620              MOV      r0,r4                 ;493
000088  f7fffffe          BL       UART_CheckIdleState
00008c  e7be              B        |L10.12|
;;;495    
                          ENDP


                          AREA ||i.HAL_RS485Ex_Init||, CODE, READONLY, ALIGN=2

                  HAL_RS485Ex_Init PROC
;;;515      */
;;;516    HAL_StatusTypeDef HAL_RS485Ex_Init(UART_HandleTypeDef *huart, uint32_t Polarity, uint32_t AssertionTime, uint32_t DeassertionTime)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;517    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;518      uint32_t temp = 0x0;
00000c  f04f0800          MOV      r8,#0
;;;519    
;;;520      /* Check the UART handle allocation */
;;;521      if(huart == NULL)
000010  b914              CBNZ     r4,|L11.24|
;;;522      {
;;;523        return HAL_ERROR;
000012  2001              MOVS     r0,#1
                  |L11.20|
;;;524      }
;;;525      /* Check the Driver Enable UART instance */
;;;526      assert_param(IS_UART_DRIVER_ENABLE_INSTANCE(huart->Instance));
;;;527    
;;;528      /* Check the Driver Enable polarity */
;;;529      assert_param(IS_UART_DE_POLARITY(Polarity));
;;;530    
;;;531      /* Check the Driver Enable assertion time */
;;;532      assert_param(IS_UART_ASSERTIONTIME(AssertionTime));
;;;533    
;;;534      /* Check the Driver Enable deassertion time */
;;;535      assert_param(IS_UART_DEASSERTIONTIME(DeassertionTime));
;;;536    
;;;537      if(huart->gState == HAL_UART_STATE_RESET)
;;;538      {
;;;539        /* Allocate lock resource and initialize it */
;;;540        huart->Lock = HAL_UNLOCKED;
;;;541    
;;;542        /* Init the low level hardware : GPIO, CLOCK, CORTEX */
;;;543        HAL_UART_MspInit(huart);
;;;544      }
;;;545    
;;;546      huart->gState = HAL_UART_STATE_BUSY;
;;;547    
;;;548      /* Disable the Peripheral */
;;;549      __HAL_UART_DISABLE(huart);
;;;550    
;;;551      /* Set the UART Communication parameters */
;;;552      if (UART_SetConfig(huart) == HAL_ERROR)
;;;553      {
;;;554        return HAL_ERROR;
;;;555      }
;;;556    
;;;557      if(huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;558      {
;;;559        UART_AdvFeatureConfig(huart);
;;;560      }
;;;561    
;;;562      /* Enable the Driver Enable mode by setting the DEM bit in the CR3 register */
;;;563      SET_BIT(huart->Instance->CR3, USART_CR3_DEM);
;;;564    
;;;565      /* Set the Driver Enable polarity */
;;;566      MODIFY_REG(huart->Instance->CR3, USART_CR3_DEP, Polarity);
;;;567    
;;;568      /* Set the Driver Enable assertion and deassertion times */
;;;569      temp = (AssertionTime << UART_CR1_DEAT_ADDRESS_LSB_POS);
;;;570      temp |= (DeassertionTime << UART_CR1_DEDT_ADDRESS_LSB_POS);
;;;571      MODIFY_REG(huart->Instance->CR1, (USART_CR1_DEDT|USART_CR1_DEAT), temp);
;;;572    
;;;573      /* Enable the Peripheral */
;;;574      __HAL_UART_ENABLE(huart);
;;;575    
;;;576      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;577      return (UART_CheckIdleState(huart));
;;;578    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L11.24|
000018  6ee0              LDR      r0,[r4,#0x6c]         ;537
00001a  b920              CBNZ     r0,|L11.38|
00001c  2000              MOVS     r0,#0                 ;540
00001e  66a0              STR      r0,[r4,#0x68]         ;540
000020  4620              MOV      r0,r4                 ;543
000022  f7fffffe          BL       HAL_UART_MspInit
                  |L11.38|
000026  2024              MOVS     r0,#0x24              ;546
000028  66e0              STR      r0,[r4,#0x6c]         ;546
00002a  6820              LDR      r0,[r4,#0]            ;549
00002c  6800              LDR      r0,[r0,#0]            ;549
00002e  f0200001          BIC      r0,r0,#1              ;549
000032  6821              LDR      r1,[r4,#0]            ;549
000034  6008              STR      r0,[r1,#0]            ;549
000036  4620              MOV      r0,r4                 ;552
000038  f7fffffe          BL       UART_SetConfig
00003c  2801              CMP      r0,#1                 ;552
00003e  d100              BNE      |L11.66|
000040  e7e8              B        |L11.20|
                  |L11.66|
000042  6a60              LDR      r0,[r4,#0x24]         ;557
000044  b110              CBZ      r0,|L11.76|
000046  4620              MOV      r0,r4                 ;559
000048  f7fffffe          BL       UART_AdvFeatureConfig
                  |L11.76|
00004c  6820              LDR      r0,[r4,#0]            ;563
00004e  6880              LDR      r0,[r0,#8]            ;563
000050  f4404080          ORR      r0,r0,#0x4000         ;563
000054  6821              LDR      r1,[r4,#0]            ;563
000056  6088              STR      r0,[r1,#8]            ;563
000058  6820              LDR      r0,[r4,#0]            ;566
00005a  6880              LDR      r0,[r0,#8]            ;566
00005c  f4204000          BIC      r0,r0,#0x8000         ;566
000060  4328              ORRS     r0,r0,r5              ;566
000062  6821              LDR      r1,[r4,#0]            ;566
000064  6088              STR      r0,[r1,#8]            ;566
000066  ea4f5846          LSL      r8,r6,#21             ;569
00006a  ea484807          ORR      r8,r8,r7,LSL #16      ;570
00006e  6820              LDR      r0,[r4,#0]            ;571
000070  6800              LDR      r0,[r0,#0]            ;571
000072  4908              LDR      r1,|L11.148|
000074  4008              ANDS     r0,r0,r1              ;571
000076  ea400008          ORR      r0,r0,r8              ;571
00007a  6821              LDR      r1,[r4,#0]            ;571
00007c  6008              STR      r0,[r1,#0]            ;571
00007e  6820              LDR      r0,[r4,#0]            ;574
000080  6800              LDR      r0,[r0,#0]            ;574
000082  f0400001          ORR      r0,r0,#1              ;574
000086  6821              LDR      r1,[r4,#0]            ;574
000088  6008              STR      r0,[r1,#0]            ;574
00008a  4620              MOV      r0,r4                 ;577
00008c  f7fffffe          BL       UART_CheckIdleState
000090  e7c0              B        |L11.20|
;;;579    
                          ENDP

000092  0000              DCW      0x0000
                  |L11.148|
                          DCD      0xfc00ffff

                          AREA ||i.HAL_UART_DMAPause||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAPause PROC
;;;1071     */
;;;1072   HAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;1073   {
;;;1074     /* Process Locked */
;;;1075     __HAL_LOCK(huart);
000002  bf00              NOP      
000004  6e88              LDR      r0,[r1,#0x68]
000006  2801              CMP      r0,#1
000008  d101              BNE      |L12.14|
00000a  2002              MOVS     r0,#2
                  |L12.12|
;;;1076   
;;;1077     if ((huart->gState == HAL_UART_STATE_BUSY_TX) &&
;;;1078         (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)))
;;;1079     {
;;;1080       /* Disable the UART DMA Tx request */
;;;1081       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1082     }
;;;1083     if ((huart->RxState == HAL_UART_STATE_BUSY_RX) &&
;;;1084         (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)))
;;;1085     {
;;;1086       /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1087       CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1088       CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1089   
;;;1090       /* Disable the UART DMA Rx request */
;;;1091       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1092     }
;;;1093   
;;;1094     /* Process Unlocked */
;;;1095     __HAL_UNLOCK(huart);
;;;1096   
;;;1097     return HAL_OK;
;;;1098   }
00000c  4770              BX       lr
                  |L12.14|
00000e  2001              MOVS     r0,#1                 ;1075
000010  6688              STR      r0,[r1,#0x68]         ;1075
000012  bf00              NOP                            ;1075
000014  6ec8              LDR      r0,[r1,#0x6c]         ;1077
000016  2821              CMP      r0,#0x21              ;1077
000018  d10a              BNE      |L12.48|
00001a  6808              LDR      r0,[r1,#0]            ;1078
00001c  6880              LDR      r0,[r0,#8]            ;1078
00001e  f0000080          AND      r0,r0,#0x80           ;1078
000022  b128              CBZ      r0,|L12.48|
000024  6808              LDR      r0,[r1,#0]            ;1081
000026  6880              LDR      r0,[r0,#8]            ;1081
000028  f0200080          BIC      r0,r0,#0x80           ;1081
00002c  680a              LDR      r2,[r1,#0]            ;1081
00002e  6090              STR      r0,[r2,#8]            ;1081
                  |L12.48|
000030  6f08              LDR      r0,[r1,#0x70]         ;1083
000032  2822              CMP      r0,#0x22              ;1083
000034  d116              BNE      |L12.100|
000036  6808              LDR      r0,[r1,#0]            ;1084
000038  6880              LDR      r0,[r0,#8]            ;1084
00003a  f0000040          AND      r0,r0,#0x40           ;1084
00003e  b188              CBZ      r0,|L12.100|
000040  6808              LDR      r0,[r1,#0]            ;1087
000042  6800              LDR      r0,[r0,#0]            ;1087
000044  f4207080          BIC      r0,r0,#0x100          ;1087
000048  680a              LDR      r2,[r1,#0]            ;1087
00004a  6010              STR      r0,[r2,#0]            ;1087
00004c  6808              LDR      r0,[r1,#0]            ;1088
00004e  6880              LDR      r0,[r0,#8]            ;1088
000050  f0200001          BIC      r0,r0,#1              ;1088
000054  680a              LDR      r2,[r1,#0]            ;1088
000056  6090              STR      r0,[r2,#8]            ;1088
000058  6808              LDR      r0,[r1,#0]            ;1091
00005a  6880              LDR      r0,[r0,#8]            ;1091
00005c  f0200040          BIC      r0,r0,#0x40           ;1091
000060  680a              LDR      r2,[r1,#0]            ;1091
000062  6090              STR      r0,[r2,#8]            ;1091
                  |L12.100|
000064  bf00              NOP                            ;1095
000066  2000              MOVS     r0,#0                 ;1095
000068  6688              STR      r0,[r1,#0x68]         ;1095
00006a  bf00              NOP                            ;1095
00006c  bf00              NOP                            ;1097
00006e  e7cd              B        |L12.12|
;;;1099   
                          ENDP


                          AREA ||i.HAL_UART_DMAResume||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAResume PROC
;;;1104     */
;;;1105   HAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;1106   {
;;;1107     /* Process Locked */
;;;1108     __HAL_LOCK(huart);
000002  bf00              NOP      
000004  6e88              LDR      r0,[r1,#0x68]
000006  2801              CMP      r0,#1
000008  d101              BNE      |L13.14|
00000a  2002              MOVS     r0,#2
                  |L13.12|
;;;1109   
;;;1110     if(huart->gState == HAL_UART_STATE_BUSY_TX)
;;;1111     {
;;;1112       /* Enable the UART DMA Tx request */
;;;1113       SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1114     }
;;;1115     if(huart->RxState == HAL_UART_STATE_BUSY_RX)
;;;1116     {
;;;1117       /* Clear the Overrun flag before resuming the Rx transfer*/
;;;1118       __HAL_UART_CLEAR_IT(huart, UART_CLEAR_OREF);
;;;1119   
;;;1120       /* Reenable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1121       SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1122       SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1123   
;;;1124       /* Enable the UART DMA Rx request */
;;;1125       SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1126     }
;;;1127   
;;;1128     /* If the UART peripheral is still not enabled, enable it */
;;;1129     if ((huart->Instance->CR1 & USART_CR1_UE) == 0U)
;;;1130     {
;;;1131       /* Enable UART peripheral */
;;;1132       __HAL_UART_ENABLE(huart);
;;;1133     }
;;;1134   
;;;1135     return HAL_OK;
;;;1136   }
00000c  4770              BX       lr
                  |L13.14|
00000e  2001              MOVS     r0,#1                 ;1108
000010  6688              STR      r0,[r1,#0x68]         ;1108
000012  bf00              NOP                            ;1108
000014  6ec8              LDR      r0,[r1,#0x6c]         ;1110
000016  2821              CMP      r0,#0x21              ;1110
000018  d105              BNE      |L13.38|
00001a  6808              LDR      r0,[r1,#0]            ;1113
00001c  6880              LDR      r0,[r0,#8]            ;1113
00001e  f0400080          ORR      r0,r0,#0x80           ;1113
000022  680a              LDR      r2,[r1,#0]            ;1113
000024  6090              STR      r0,[r2,#8]            ;1113
                  |L13.38|
000026  6f08              LDR      r0,[r1,#0x70]         ;1115
000028  2822              CMP      r0,#0x22              ;1115
00002a  d114              BNE      |L13.86|
00002c  2008              MOVS     r0,#8                 ;1118
00002e  680a              LDR      r2,[r1,#0]            ;1118
000030  6210              STR      r0,[r2,#0x20]         ;1118
000032  6808              LDR      r0,[r1,#0]            ;1121
000034  6800              LDR      r0,[r0,#0]            ;1121
000036  f4407080          ORR      r0,r0,#0x100          ;1121
00003a  680a              LDR      r2,[r1,#0]            ;1121
00003c  6010              STR      r0,[r2,#0]            ;1121
00003e  6808              LDR      r0,[r1,#0]            ;1122
000040  6880              LDR      r0,[r0,#8]            ;1122
000042  f0400001          ORR      r0,r0,#1              ;1122
000046  680a              LDR      r2,[r1,#0]            ;1122
000048  6090              STR      r0,[r2,#8]            ;1122
00004a  6808              LDR      r0,[r1,#0]            ;1125
00004c  6880              LDR      r0,[r0,#8]            ;1125
00004e  f0400040          ORR      r0,r0,#0x40           ;1125
000052  680a              LDR      r2,[r1,#0]            ;1125
000054  6090              STR      r0,[r2,#8]            ;1125
                  |L13.86|
000056  6808              LDR      r0,[r1,#0]            ;1129
000058  6800              LDR      r0,[r0,#0]            ;1129
00005a  f0000001          AND      r0,r0,#1              ;1129
00005e  b928              CBNZ     r0,|L13.108|
000060  6808              LDR      r0,[r1,#0]            ;1132
000062  6800              LDR      r0,[r0,#0]            ;1132
000064  f0400001          ORR      r0,r0,#1              ;1132
000068  680a              LDR      r2,[r1,#0]            ;1132
00006a  6010              STR      r0,[r2,#0]            ;1132
                  |L13.108|
00006c  2000              MOVS     r0,#0                 ;1135
00006e  e7cd              B        |L13.12|
;;;1137   
                          ENDP


                          AREA ||i.HAL_UART_DMAStop||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAStop PROC
;;;1142     */
;;;1143   HAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1144   {
000002  4604              MOV      r4,r0
;;;1145     /* The Lock is not implemented on this API to allow the user application
;;;1146        to call the HAL UART API under callbacks HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback() /
;;;1147        HAL_UART_TxHalfCpltCallback / HAL_UART_RxHalfCpltCallback:
;;;1148        indeed, when HAL_DMA_Abort() API is called, the DMA TX/RX Transfer or Half Transfer complete
;;;1149        interrupt is generated if the DMA transfer interruption occurs at the middle or at the end of
;;;1150        the stream and the corresponding call back is executed. */
;;;1151   
;;;1152     /* Stop UART DMA Tx request if ongoing */
;;;1153     if ((huart->gState == HAL_UART_STATE_BUSY_TX) &&
000004  6ee0              LDR      r0,[r4,#0x6c]
000006  2821              CMP      r0,#0x21
000008  d112              BNE      |L14.48|
;;;1154         (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)))
00000a  6820              LDR      r0,[r4,#0]
00000c  6880              LDR      r0,[r0,#8]
00000e  f0000080          AND      r0,r0,#0x80
000012  b168              CBZ      r0,|L14.48|
;;;1155     {
;;;1156       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000014  6820              LDR      r0,[r4,#0]
000016  6880              LDR      r0,[r0,#8]
000018  f0200080          BIC      r0,r0,#0x80
00001c  6821              LDR      r1,[r4,#0]
00001e  6088              STR      r0,[r1,#8]
;;;1157   
;;;1158       /* Abort the UART DMA Tx channel */
;;;1159       if(huart->hdmatx != NULL)
000020  6e20              LDR      r0,[r4,#0x60]
000022  b110              CBZ      r0,|L14.42|
;;;1160       {
;;;1161         HAL_DMA_Abort(huart->hdmatx);
000024  6e20              LDR      r0,[r4,#0x60]
000026  f7fffffe          BL       HAL_DMA_Abort
                  |L14.42|
;;;1162       }
;;;1163   
;;;1164       UART_EndTxTransfer(huart);
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       UART_EndTxTransfer
                  |L14.48|
;;;1165     }
;;;1166   
;;;1167     /* Stop UART DMA Rx request if ongoing */
;;;1168     if ((huart->RxState == HAL_UART_STATE_BUSY_RX) &&
000030  6f20              LDR      r0,[r4,#0x70]
000032  2822              CMP      r0,#0x22
000034  d112              BNE      |L14.92|
;;;1169         (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)))
000036  6820              LDR      r0,[r4,#0]
000038  6880              LDR      r0,[r0,#8]
00003a  f0000040          AND      r0,r0,#0x40
00003e  b168              CBZ      r0,|L14.92|
;;;1170     {
;;;1171       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000040  6820              LDR      r0,[r4,#0]
000042  6880              LDR      r0,[r0,#8]
000044  f0200040          BIC      r0,r0,#0x40
000048  6821              LDR      r1,[r4,#0]
00004a  6088              STR      r0,[r1,#8]
;;;1172   
;;;1173       /* Abort the UART DMA Rx channel */
;;;1174       if(huart->hdmarx != NULL)
00004c  6e60              LDR      r0,[r4,#0x64]
00004e  b110              CBZ      r0,|L14.86|
;;;1175       {
;;;1176         HAL_DMA_Abort(huart->hdmarx);
000050  6e60              LDR      r0,[r4,#0x64]
000052  f7fffffe          BL       HAL_DMA_Abort
                  |L14.86|
;;;1177       }
;;;1178   
;;;1179       UART_EndRxTransfer(huart);
000056  4620              MOV      r0,r4
000058  f7fffffe          BL       UART_EndRxTransfer
                  |L14.92|
;;;1180     }
;;;1181   
;;;1182     return HAL_OK;
00005c  2000              MOVS     r0,#0
;;;1183   }
00005e  bd10              POP      {r4,pc}
;;;1184   
                          ENDP


                          AREA ||i.HAL_UART_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_DeInit PROC
;;;584      */
;;;585    HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;586    {
000002  4604              MOV      r4,r0
;;;587      /* Check the UART handle allocation */
;;;588      if(huart == NULL)
000004  b90c              CBNZ     r4,|L15.10|
;;;589      {
;;;590        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L15.8|
;;;591      }
;;;592    
;;;593      /* Check the parameters */
;;;594      assert_param(IS_UART_INSTANCE(huart->Instance));
;;;595    
;;;596      huart->gState = HAL_UART_STATE_BUSY;
;;;597    
;;;598      /* Disable the Peripheral */
;;;599      __HAL_UART_DISABLE(huart);
;;;600    
;;;601      huart->Instance->CR1 = 0x0U;
;;;602      huart->Instance->CR2 = 0x0U;
;;;603      huart->Instance->CR3 = 0x0U;
;;;604    
;;;605      /* DeInit the low level hardware */
;;;606      HAL_UART_MspDeInit(huart);
;;;607    
;;;608      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;609      huart->gState    = HAL_UART_STATE_RESET;
;;;610      huart->RxState   = HAL_UART_STATE_RESET;
;;;611    
;;;612      /* Process Unlock */
;;;613      __HAL_UNLOCK(huart);
;;;614    
;;;615      return HAL_OK;
;;;616    }
000008  bd10              POP      {r4,pc}
                  |L15.10|
00000a  2024              MOVS     r0,#0x24              ;596
00000c  66e0              STR      r0,[r4,#0x6c]         ;596
00000e  6820              LDR      r0,[r4,#0]            ;599
000010  6800              LDR      r0,[r0,#0]            ;599
000012  f0200001          BIC      r0,r0,#1              ;599
000016  6821              LDR      r1,[r4,#0]            ;599
000018  6008              STR      r0,[r1,#0]            ;599
00001a  2000              MOVS     r0,#0                 ;601
00001c  6821              LDR      r1,[r4,#0]            ;601
00001e  6008              STR      r0,[r1,#0]            ;601
000020  6821              LDR      r1,[r4,#0]            ;602
000022  6048              STR      r0,[r1,#4]            ;602
000024  6821              LDR      r1,[r4,#0]            ;603
000026  6088              STR      r0,[r1,#8]            ;603
000028  4620              MOV      r0,r4                 ;606
00002a  f7fffffe          BL       HAL_UART_MspDeInit
00002e  2000              MOVS     r0,#0                 ;608
000030  6760              STR      r0,[r4,#0x74]         ;608
000032  66e0              STR      r0,[r4,#0x6c]         ;609
000034  6720              STR      r0,[r4,#0x70]         ;610
000036  bf00              NOP                            ;613
000038  66a0              STR      r0,[r4,#0x68]         ;613
00003a  bf00              NOP                            ;613
00003c  bf00              NOP                            ;615
00003e  e7e3              B        |L15.8|
;;;617    
                          ENDP


                          AREA ||i.HAL_UART_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_ErrorCallback PROC
;;;1547     */
;;;1548    __weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1549   {
;;;1550     /* Prevent unused argument(s) compilation warning */
;;;1551     UNUSED(huart);
;;;1552   
;;;1553     /* NOTE : This function should not be modified, when the callback is needed,
;;;1554               the HAL_UART_ErrorCallback can be implemented in the user file
;;;1555      */
;;;1556   }
;;;1557   
                          ENDP


                          AREA ||i.HAL_UART_GetError||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetError PROC
;;;1814   */
;;;1815   uint32_t HAL_UART_GetError(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;1816   {
;;;1817     return huart->ErrorCode;
000002  6f48              LDR      r0,[r1,#0x74]
;;;1818   }
000004  4770              BX       lr
;;;1819   
                          ENDP


                          AREA ||i.HAL_UART_GetState||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetState PROC
;;;1799     */
;;;1800   HAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;1801   {
;;;1802     uint32_t temp1= 0x00U, temp2 = 0x00U;
000002  2300              MOVS     r3,#0
000004  2200              MOVS     r2,#0
;;;1803     temp1 = huart->gState;
000006  6ecb              LDR      r3,[r1,#0x6c]
;;;1804     temp2 = huart->RxState;
000008  6f0a              LDR      r2,[r1,#0x70]
;;;1805   
;;;1806     return (HAL_UART_StateTypeDef)(temp1 | temp2);
00000a  ea430002          ORR      r0,r3,r2
;;;1807   }
00000e  4770              BX       lr
;;;1808   
                          ENDP


                          AREA ||i.HAL_UART_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_UART_IRQHandler PROC
;;;1189     */
;;;1190   void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1191   {
000004  4604              MOV      r4,r0
;;;1192     uint32_t isrflags   = READ_REG(huart->Instance->ISR);
000006  6820              LDR      r0,[r4,#0]
000008  69c5              LDR      r5,[r0,#0x1c]
;;;1193     uint32_t cr1its     = READ_REG(huart->Instance->CR1);
00000a  6820              LDR      r0,[r4,#0]
00000c  6806              LDR      r6,[r0,#0]
;;;1194     uint32_t cr3its     = READ_REG(huart->Instance->CR3);
00000e  6820              LDR      r0,[r4,#0]
000010  6887              LDR      r7,[r0,#8]
;;;1195     uint32_t errorflags;
;;;1196   
;;;1197     /* If no error occurs */
;;;1198     errorflags = (isrflags & (uint32_t)(USART_ISR_PE | USART_ISR_FE | USART_ISR_ORE | USART_ISR_NE));
000012  f005080f          AND      r8,r5,#0xf
;;;1199     if (errorflags == RESET)
000016  f1b80f00          CMP      r8,#0
00001a  d10a              BNE      |L19.50|
;;;1200     {
;;;1201       /* UART in mode Receiver ---------------------------------------------------*/
;;;1202       if(((isrflags & USART_ISR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
00001c  f0050020          AND      r0,r5,#0x20
000020  b138              CBZ      r0,|L19.50|
000022  f0060020          AND      r0,r6,#0x20
000026  b120              CBZ      r0,|L19.50|
;;;1203       {
;;;1204         UART_Receive_IT(huart);
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       UART_Receive_IT
                  |L19.46|
;;;1205         return;
;;;1206       }
;;;1207     }
;;;1208   
;;;1209     /* If some errors occur */
;;;1210     if(   (errorflags != RESET)
;;;1211        && (   ((cr3its & USART_CR3_EIE) != RESET)
;;;1212            || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)) )
;;;1213     {
;;;1214   
;;;1215       /* UART parity error interrupt occurred -------------------------------------*/
;;;1216       if(((isrflags & USART_ISR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
;;;1217       {
;;;1218         __HAL_UART_CLEAR_IT(huart, UART_CLEAR_PEF);
;;;1219   
;;;1220         huart->ErrorCode |= HAL_UART_ERROR_PE;
;;;1221       }
;;;1222   
;;;1223       /* UART frame error interrupt occurred --------------------------------------*/
;;;1224       if(((isrflags & USART_ISR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
;;;1225       {
;;;1226         __HAL_UART_CLEAR_IT(huart, UART_CLEAR_FEF);
;;;1227   
;;;1228         huart->ErrorCode |= HAL_UART_ERROR_FE;
;;;1229       }
;;;1230   
;;;1231       /* UART noise error interrupt occurred --------------------------------------*/
;;;1232       if(((isrflags & USART_ISR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
;;;1233       {
;;;1234         __HAL_UART_CLEAR_IT(huart, UART_CLEAR_NEF);
;;;1235   
;;;1236         huart->ErrorCode |= HAL_UART_ERROR_NE;
;;;1237       }
;;;1238       
;;;1239       /* UART Over-Run interrupt occurred -----------------------------------------*/
;;;1240       if(((isrflags & USART_ISR_ORE) != RESET) &&
;;;1241          (((cr1its & USART_CR1_RXNEIE) != RESET) || ((cr3its & USART_CR3_EIE) != RESET)))
;;;1242       {
;;;1243         __HAL_UART_CLEAR_IT(huart, UART_CLEAR_OREF);
;;;1244   
;;;1245         huart->ErrorCode |= HAL_UART_ERROR_ORE;
;;;1246       }
;;;1247   
;;;1248       /* Call UART Error Call back function if need be --------------------------*/
;;;1249       if(huart->ErrorCode != HAL_UART_ERROR_NONE)
;;;1250       {
;;;1251         /* UART in mode Receiver ---------------------------------------------------*/
;;;1252         if(((isrflags & USART_ISR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
;;;1253         {
;;;1254           UART_Receive_IT(huart);
;;;1255         }
;;;1256   
;;;1257         /* If Overrun error occurs, or if any error occurs in DMA mode reception,
;;;1258            consider error as blocking */
;;;1259         if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) ||
;;;1260             (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)))
;;;1261         {
;;;1262           /* Blocking error : transfer is aborted
;;;1263              Set the UART state ready to be able to start again the process,
;;;1264              Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
;;;1265           UART_EndRxTransfer(huart);
;;;1266   
;;;1267           /* Disable the UART DMA Rx request if enabled */
;;;1268           if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
;;;1269           {
;;;1270             CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1271   
;;;1272             /* Abort the UART DMA Rx channel */
;;;1273             if(huart->hdmarx != NULL)
;;;1274             {
;;;1275               /* Set the UART DMA Abort callback :
;;;1276               will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
;;;1277               huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
;;;1278   
;;;1279               /* Abort DMA RX */
;;;1280               if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
;;;1281               {
;;;1282                 /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */
;;;1283                 huart->hdmarx->XferAbortCallback(huart->hdmarx);
;;;1284               }
;;;1285             }
;;;1286             else
;;;1287             {
;;;1288               /* Call user error callback */
;;;1289               HAL_UART_ErrorCallback(huart);
;;;1290             }
;;;1291           }
;;;1292           else
;;;1293           {
;;;1294             /* Call user error callback */
;;;1295             HAL_UART_ErrorCallback(huart);
;;;1296           }
;;;1297         }
;;;1298         else
;;;1299         {
;;;1300           /* Non Blocking error : transfer could go on.
;;;1301              Error is notified to user through user error callback */
;;;1302           HAL_UART_ErrorCallback(huart);
;;;1303           huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1304         }
;;;1305       }
;;;1306       return;
;;;1307   
;;;1308     } /* End if some error occurs */
;;;1309   
;;;1310     /* UART in mode Transmitter ------------------------------------------------*/
;;;1311     if(((isrflags & USART_ISR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
;;;1312     {
;;;1313       UART_Transmit_IT(huart);
;;;1314       return;
;;;1315     }
;;;1316   
;;;1317     /* UART in mode Transmitter (transmission end) -----------------------------*/
;;;1318     if(((isrflags & USART_ISR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
;;;1319     {
;;;1320       UART_EndTransmit_IT(huart);
;;;1321       return;
;;;1322     }
;;;1323   
;;;1324   }
00002e  e8bd81f0          POP      {r4-r8,pc}
                  |L19.50|
000032  f1b80f00          CMP      r8,#0                 ;1210
000036  d07b              BEQ      |L19.304|
000038  f0070001          AND      r0,r7,#1              ;1211
00003c  b918              CBNZ     r0,|L19.70|
00003e  f4067090          AND      r0,r6,#0x120          ;1212
000042  2800              CMP      r0,#0                 ;1212
000044  d074              BEQ      |L19.304|
                  |L19.70|
000046  f0050001          AND      r0,r5,#1              ;1216
00004a  b148              CBZ      r0,|L19.96|
00004c  f4067080          AND      r0,r6,#0x100          ;1216
000050  b130              CBZ      r0,|L19.96|
000052  2001              MOVS     r0,#1                 ;1218
000054  6821              LDR      r1,[r4,#0]            ;1218
000056  6208              STR      r0,[r1,#0x20]         ;1218
000058  6f60              LDR      r0,[r4,#0x74]         ;1220
00005a  f0400001          ORR      r0,r0,#1              ;1220
00005e  6760              STR      r0,[r4,#0x74]         ;1220
                  |L19.96|
000060  f0050002          AND      r0,r5,#2              ;1224
000064  b148              CBZ      r0,|L19.122|
000066  f0070001          AND      r0,r7,#1              ;1224
00006a  b130              CBZ      r0,|L19.122|
00006c  2002              MOVS     r0,#2                 ;1226
00006e  6821              LDR      r1,[r4,#0]            ;1226
000070  6208              STR      r0,[r1,#0x20]         ;1226
000072  6f60              LDR      r0,[r4,#0x74]         ;1228
000074  f0400004          ORR      r0,r0,#4              ;1228
000078  6760              STR      r0,[r4,#0x74]         ;1228
                  |L19.122|
00007a  f0050004          AND      r0,r5,#4              ;1232
00007e  b148              CBZ      r0,|L19.148|
000080  f0070001          AND      r0,r7,#1              ;1232
000084  b130              CBZ      r0,|L19.148|
000086  2004              MOVS     r0,#4                 ;1234
000088  6821              LDR      r1,[r4,#0]            ;1234
00008a  6208              STR      r0,[r1,#0x20]         ;1234
00008c  6f60              LDR      r0,[r4,#0x74]         ;1236
00008e  f0400002          ORR      r0,r0,#2              ;1236
000092  6760              STR      r0,[r4,#0x74]         ;1236
                  |L19.148|
000094  f0050008          AND      r0,r5,#8              ;1240
000098  b160              CBZ      r0,|L19.180|
00009a  f0060020          AND      r0,r6,#0x20           ;1241
00009e  b910              CBNZ     r0,|L19.166|
0000a0  f0070001          AND      r0,r7,#1              ;1241
0000a4  b130              CBZ      r0,|L19.180|
                  |L19.166|
0000a6  2008              MOVS     r0,#8                 ;1243
0000a8  6821              LDR      r1,[r4,#0]            ;1243
0000aa  6208              STR      r0,[r1,#0x20]         ;1243
0000ac  6f60              LDR      r0,[r4,#0x74]         ;1245
0000ae  f0400008          ORR      r0,r0,#8              ;1245
0000b2  6760              STR      r0,[r4,#0x74]         ;1245
                  |L19.180|
0000b4  6f60              LDR      r0,[r4,#0x74]         ;1249
0000b6  b358              CBZ      r0,|L19.272|
0000b8  f0050020          AND      r0,r5,#0x20           ;1252
0000bc  b128              CBZ      r0,|L19.202|
0000be  f0060020          AND      r0,r6,#0x20           ;1252
0000c2  b110              CBZ      r0,|L19.202|
0000c4  4620              MOV      r0,r4                 ;1254
0000c6  f7fffffe          BL       UART_Receive_IT
                  |L19.202|
0000ca  6f60              LDR      r0,[r4,#0x74]         ;1259
0000cc  f0000008          AND      r0,r0,#8              ;1259
0000d0  b920              CBNZ     r0,|L19.220|
0000d2  6820              LDR      r0,[r4,#0]            ;1260
0000d4  6880              LDR      r0,[r0,#8]            ;1260
0000d6  f0000040          AND      r0,r0,#0x40           ;1260
0000da  b318              CBZ      r0,|L19.292|
                  |L19.220|
0000dc  4620              MOV      r0,r4                 ;1265
0000de  f7fffffe          BL       UART_EndRxTransfer
0000e2  6820              LDR      r0,[r4,#0]            ;1268
0000e4  6880              LDR      r0,[r0,#8]            ;1268
0000e6  f0000040          AND      r0,r0,#0x40           ;1268
0000ea  b1b8              CBZ      r0,|L19.284|
0000ec  6820              LDR      r0,[r4,#0]            ;1270
0000ee  6880              LDR      r0,[r0,#8]            ;1270
0000f0  f0200040          BIC      r0,r0,#0x40           ;1270
0000f4  6821              LDR      r1,[r4,#0]            ;1270
0000f6  6088              STR      r0,[r1,#8]            ;1270
0000f8  6e60              LDR      r0,[r4,#0x64]         ;1273
0000fa  b150              CBZ      r0,|L19.274|
0000fc  4817              LDR      r0,|L19.348|
0000fe  6e61              LDR      r1,[r4,#0x64]         ;1277
000100  6548              STR      r0,[r1,#0x54]         ;1277
000102  6e60              LDR      r0,[r4,#0x64]         ;1280
000104  f7fffffe          BL       HAL_DMA_Abort_IT
000108  b110              CBZ      r0,|L19.272|
00010a  6e60              LDR      r0,[r4,#0x64]         ;1283
00010c  6d41              LDR      r1,[r0,#0x54]         ;1283
00010e  4788              BLX      r1                    ;1283
                  |L19.272|
000110  e00d              B        |L19.302|
                  |L19.274|
000112  4620              MOV      r0,r4                 ;1289
000114  f7fffffe          BL       HAL_UART_ErrorCallback
000118  e009              B        |L19.302|
00011a  e009              B        |L19.304|
                  |L19.284|
00011c  4620              MOV      r0,r4                 ;1295
00011e  f7fffffe          BL       HAL_UART_ErrorCallback
000122  e004              B        |L19.302|
                  |L19.292|
000124  4620              MOV      r0,r4                 ;1302
000126  f7fffffe          BL       HAL_UART_ErrorCallback
00012a  2000              MOVS     r0,#0                 ;1303
00012c  6760              STR      r0,[r4,#0x74]         ;1303
                  |L19.302|
00012e  e77e              B        |L19.46|
                  |L19.304|
000130  f0050080          AND      r0,r5,#0x80           ;1311
000134  b130              CBZ      r0,|L19.324|
000136  f0060080          AND      r0,r6,#0x80           ;1311
00013a  b118              CBZ      r0,|L19.324|
00013c  4620              MOV      r0,r4                 ;1313
00013e  f7fffffe          BL       UART_Transmit_IT
000142  e774              B        |L19.46|
                  |L19.324|
000144  f0050040          AND      r0,r5,#0x40           ;1318
000148  b130              CBZ      r0,|L19.344|
00014a  f0060040          AND      r0,r6,#0x40           ;1318
00014e  b118              CBZ      r0,|L19.344|
000150  4620              MOV      r0,r4                 ;1320
000152  f7fffffe          BL       UART_EndTransmit_IT
000156  e76a              B        |L19.46|
                  |L19.344|
000158  bf00              NOP      
00015a  e768              B        |L19.46|
;;;1325   
                          ENDP

                  |L19.348|
                          DCD      UART_DMAAbortOnError

                          AREA ||i.HAL_UART_Init||, CODE, READONLY, ALIGN=1

                  HAL_UART_Init PROC
;;;240      */
;;;241    HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;242    {
000002  4604              MOV      r4,r0
;;;243      /* Check the UART handle allocation */
;;;244      if(huart == NULL)
000004  b90c              CBNZ     r4,|L20.10|
;;;245      {
;;;246        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L20.8|
;;;247      }
;;;248    
;;;249      if(huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
;;;250      {
;;;251        /* Check the parameters */
;;;252        assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
;;;253      }
;;;254      else
;;;255      {
;;;256        /* Check the parameters */
;;;257        assert_param(IS_UART_INSTANCE(huart->Instance));
;;;258      }
;;;259    
;;;260      if(huart->gState == HAL_UART_STATE_RESET)
;;;261      {
;;;262        /* Allocate lock resource and initialize it */
;;;263        huart->Lock = HAL_UNLOCKED;
;;;264    
;;;265        /* Init the low level hardware : GPIO, CLOCK */
;;;266        HAL_UART_MspInit(huart);
;;;267      }
;;;268    
;;;269      huart->gState = HAL_UART_STATE_BUSY;
;;;270    
;;;271      /* Disable the Peripheral */
;;;272      __HAL_UART_DISABLE(huart);
;;;273    
;;;274      /* Set the UART Communication parameters */
;;;275      if (UART_SetConfig(huart) == HAL_ERROR)
;;;276      {
;;;277        return HAL_ERROR;
;;;278      }
;;;279    
;;;280      if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
;;;281      {
;;;282        UART_AdvFeatureConfig(huart);
;;;283      }
;;;284    
;;;285      /* In asynchronous mode, the following bits must be kept cleared:
;;;286      - LINEN and CLKEN bits in the USART_CR2 register,
;;;287      - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
;;;288      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;289      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;290    
;;;291      /* Enable the Peripheral */
;;;292      __HAL_UART_ENABLE(huart);
;;;293    
;;;294      /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
;;;295      return (UART_CheckIdleState(huart));
;;;296    }
000008  bd10              POP      {r4,pc}
                  |L20.10|
00000a  69a0              LDR      r0,[r4,#0x18]         ;249
00000c  b100              CBZ      r0,|L20.16|
00000e  e000              B        |L20.18|
                  |L20.16|
000010  bf00              NOP                            ;257
                  |L20.18|
000012  6ee0              LDR      r0,[r4,#0x6c]         ;260
000014  b920              CBNZ     r0,|L20.32|
000016  2000              MOVS     r0,#0                 ;263
000018  66a0              STR      r0,[r4,#0x68]         ;263
00001a  4620              MOV      r0,r4                 ;266
00001c  f7fffffe          BL       HAL_UART_MspInit
                  |L20.32|
000020  2024              MOVS     r0,#0x24              ;269
000022  66e0              STR      r0,[r4,#0x6c]         ;269
000024  6820              LDR      r0,[r4,#0]            ;272
000026  6800              LDR      r0,[r0,#0]            ;272
000028  f0200001          BIC      r0,r0,#1              ;272
00002c  6821              LDR      r1,[r4,#0]            ;272
00002e  6008              STR      r0,[r1,#0]            ;272
000030  4620              MOV      r0,r4                 ;275
000032  f7fffffe          BL       UART_SetConfig
000036  2801              CMP      r0,#1                 ;275
000038  d100              BNE      |L20.60|
00003a  e7e5              B        |L20.8|
                  |L20.60|
00003c  6a60              LDR      r0,[r4,#0x24]         ;280
00003e  b110              CBZ      r0,|L20.70|
000040  4620              MOV      r0,r4                 ;282
000042  f7fffffe          BL       UART_AdvFeatureConfig
                  |L20.70|
000046  6820              LDR      r0,[r4,#0]            ;288
000048  6840              LDR      r0,[r0,#4]            ;288
00004a  f4204090          BIC      r0,r0,#0x4800         ;288
00004e  6821              LDR      r1,[r4,#0]            ;288
000050  6048              STR      r0,[r1,#4]            ;288
000052  6820              LDR      r0,[r4,#0]            ;289
000054  6880              LDR      r0,[r0,#8]            ;289
000056  f020002a          BIC      r0,r0,#0x2a           ;289
00005a  6821              LDR      r1,[r4,#0]            ;289
00005c  6088              STR      r0,[r1,#8]            ;289
00005e  6820              LDR      r0,[r4,#0]            ;292
000060  6800              LDR      r0,[r0,#0]            ;292
000062  f0400001          ORR      r0,r0,#1              ;292
000066  6821              LDR      r1,[r4,#0]            ;292
000068  6008              STR      r0,[r1,#0]            ;292
00006a  4620              MOV      r0,r4                 ;295
00006c  f7fffffe          BL       UART_CheckIdleState
000070  e7ca              B        |L20.8|
;;;297    
                          ENDP


                          AREA ||i.HAL_UART_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspDeInit PROC
;;;637      */
;;;638    __weak void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;639    {
;;;640      /* Prevent unused argument(s) compilation warning */
;;;641      UNUSED(huart);
;;;642    
;;;643      /* NOTE : This function should not be modified, when the callback is needed,
;;;644                the HAL_UART_MspDeInit can be implemented in the user file
;;;645       */
;;;646    }
;;;647    
                          ENDP


                          AREA ||i.HAL_UART_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspInit PROC
;;;622      */
;;;623    __weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;624    {
;;;625      /* Prevent unused argument(s) compilation warning */
;;;626      UNUSED(huart);
;;;627    
;;;628      /* NOTE : This function should not be modified, when the callback is needed,
;;;629                the HAL_UART_MspInit can be implemented in the user file
;;;630       */
;;;631    }
;;;632    
                          ENDP


                          AREA ||i.HAL_UART_Receive||, CODE, READONLY, ALIGN=1

                  HAL_UART_Receive PROC
;;;784      */
;;;785    HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;786    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  4699              MOV      r9,r3
;;;787      uint16_t* tmp;
;;;788      uint16_t uhMask;
;;;789      uint32_t tickstart = 0U;
00000c  f04f0a00          MOV      r10,#0
;;;790    
;;;791      /* Check that a Rx process is not already ongoing */
;;;792      if(huart->RxState == HAL_UART_STATE_READY)
000010  6f20              LDR      r0,[r4,#0x70]
000012  2820              CMP      r0,#0x20
000014  d176              BNE      |L23.260|
;;;793      {
;;;794        if((pData == NULL ) || (Size == 0U))
000016  b105              CBZ      r5,|L23.26|
000018  b916              CBNZ     r6,|L23.32|
                  |L23.26|
;;;795        {
;;;796          return  HAL_ERROR;
00001a  2001              MOVS     r0,#1
                  |L23.28|
;;;797        }
;;;798    
;;;799        /* Process Locked */
;;;800        __HAL_LOCK(huart);
;;;801    
;;;802        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;803        huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;804    
;;;805        /* Init tickstart for timeout managment*/
;;;806        tickstart = HAL_GetTick();
;;;807    
;;;808        huart->RxXferSize = Size;
;;;809        huart->RxXferCount = Size;
;;;810    
;;;811        /* Computation of UART mask to apply to RDR register */
;;;812        UART_MASK_COMPUTATION(huart);
;;;813        uhMask = huart->Mask;
;;;814    
;;;815        /* as long as data have to be received */
;;;816        while(huart->RxXferCount > 0U)
;;;817        {
;;;818          huart->RxXferCount--;
;;;819          if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;820          {
;;;821            return HAL_TIMEOUT;
;;;822          }
;;;823          if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;824          {
;;;825            tmp = (uint16_t*) pData ;
;;;826            *tmp = (uint16_t)(huart->Instance->RDR & uhMask);
;;;827            pData +=2U;
;;;828          }
;;;829          else
;;;830          {
;;;831            *pData++ = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask);
;;;832          }
;;;833        }
;;;834    
;;;835        /* At end of Rx process, restore huart->RxState to Ready */
;;;836        huart->RxState = HAL_UART_STATE_READY;
;;;837    
;;;838        /* Process Unlocked */
;;;839        __HAL_UNLOCK(huart);
;;;840    
;;;841        return HAL_OK;
;;;842      }
;;;843      else
;;;844      {
;;;845        return HAL_BUSY;
;;;846      }
;;;847    }
00001c  e8bd8ff8          POP      {r3-r11,pc}
                  |L23.32|
000020  bf00              NOP                            ;800
000022  6ea0              LDR      r0,[r4,#0x68]         ;800
000024  2801              CMP      r0,#1                 ;800
000026  d101              BNE      |L23.44|
000028  2002              MOVS     r0,#2                 ;800
00002a  e7f7              B        |L23.28|
                  |L23.44|
00002c  2001              MOVS     r0,#1                 ;800
00002e  66a0              STR      r0,[r4,#0x68]         ;800
000030  bf00              NOP                            ;800
000032  2000              MOVS     r0,#0                 ;802
000034  6760              STR      r0,[r4,#0x74]         ;802
000036  2022              MOVS     r0,#0x22              ;803
000038  6720              STR      r0,[r4,#0x70]         ;803
00003a  f7fffffe          BL       HAL_GetTick
00003e  4682              MOV      r10,r0                ;806
000040  f8a46058          STRH     r6,[r4,#0x58]         ;808
000044  f8a4605a          STRH     r6,[r4,#0x5a]         ;809
000048  bf00              NOP                            ;812
00004a  68a0              LDR      r0,[r4,#8]            ;812
00004c  f5b05f80          CMP      r0,#0x1000            ;812
000050  d10a              BNE      |L23.104|
000052  6920              LDR      r0,[r4,#0x10]         ;812
000054  b920              CBNZ     r0,|L23.96|
000056  f24010ff          MOV      r0,#0x1ff             ;812
00005a  f8a4005c          STRH     r0,[r4,#0x5c]         ;812
00005e  e01c              B        |L23.154|
                  |L23.96|
000060  20ff              MOVS     r0,#0xff              ;812
000062  f8a4005c          STRH     r0,[r4,#0x5c]         ;812
000066  e018              B        |L23.154|
                  |L23.104|
000068  68a0              LDR      r0,[r4,#8]            ;812
00006a  b948              CBNZ     r0,|L23.128|
00006c  6920              LDR      r0,[r4,#0x10]         ;812
00006e  b918              CBNZ     r0,|L23.120|
000070  20ff              MOVS     r0,#0xff              ;812
000072  f8a4005c          STRH     r0,[r4,#0x5c]         ;812
000076  e010              B        |L23.154|
                  |L23.120|
000078  207f              MOVS     r0,#0x7f              ;812
00007a  f8a4005c          STRH     r0,[r4,#0x5c]         ;812
00007e  e00c              B        |L23.154|
                  |L23.128|
000080  68a0              LDR      r0,[r4,#8]            ;812
000082  f1b05f80          CMP      r0,#0x10000000        ;812
000086  d108              BNE      |L23.154|
000088  6920              LDR      r0,[r4,#0x10]         ;812
00008a  b918              CBNZ     r0,|L23.148|
00008c  207f              MOVS     r0,#0x7f              ;812
00008e  f8a4005c          STRH     r0,[r4,#0x5c]         ;812
000092  e002              B        |L23.154|
                  |L23.148|
000094  203f              MOVS     r0,#0x3f              ;812
000096  f8a4005c          STRH     r0,[r4,#0x5c]         ;812
                  |L23.154|
00009a  bf00              NOP                            ;812
00009c  f8b4805c          LDRH     r8,[r4,#0x5c]         ;813
0000a0  e024              B        |L23.236|
                  |L23.162|
0000a2  f8b4005a          LDRH     r0,[r4,#0x5a]         ;818
0000a6  1e40              SUBS     r0,r0,#1              ;818
0000a8  f8a4005a          STRH     r0,[r4,#0x5a]         ;818
0000ac  4653              MOV      r3,r10                ;819
0000ae  2200              MOVS     r2,#0                 ;819
0000b0  2120              MOVS     r1,#0x20              ;819
0000b2  4620              MOV      r0,r4                 ;819
0000b4  f8cd9000          STR      r9,[sp,#0]            ;819
0000b8  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
0000bc  b108              CBZ      r0,|L23.194|
0000be  2003              MOVS     r0,#3                 ;821
0000c0  e7ac              B        |L23.28|
                  |L23.194|
0000c2  68a0              LDR      r0,[r4,#8]            ;823
0000c4  f5b05f80          CMP      r0,#0x1000            ;823
0000c8  d109              BNE      |L23.222|
0000ca  6920              LDR      r0,[r4,#0x10]         ;823
0000cc  b938              CBNZ     r0,|L23.222|
0000ce  462f              MOV      r7,r5                 ;825
0000d0  6820              LDR      r0,[r4,#0]            ;826
0000d2  6a40              LDR      r0,[r0,#0x24]         ;826
0000d4  ea000008          AND      r0,r0,r8              ;826
0000d8  8038              STRH     r0,[r7,#0]            ;826
0000da  1cad              ADDS     r5,r5,#2              ;827
0000dc  e006              B        |L23.236|
                  |L23.222|
0000de  6820              LDR      r0,[r4,#0]            ;831
0000e0  6a40              LDR      r0,[r0,#0x24]         ;831
0000e2  f00801ff          AND      r1,r8,#0xff           ;831
0000e6  4008              ANDS     r0,r0,r1              ;831
0000e8  f8050b01          STRB     r0,[r5],#1            ;831
                  |L23.236|
0000ec  f8b4005a          LDRH     r0,[r4,#0x5a]         ;816
0000f0  2800              CMP      r0,#0                 ;816
0000f2  d1d6              BNE      |L23.162|
0000f4  2020              MOVS     r0,#0x20              ;836
0000f6  6720              STR      r0,[r4,#0x70]         ;836
0000f8  bf00              NOP                            ;839
0000fa  2000              MOVS     r0,#0                 ;839
0000fc  66a0              STR      r0,[r4,#0x68]         ;839
0000fe  bf00              NOP                            ;839
000100  e78c              B        |L23.28|
000102  e7ff              B        |L23.260|
                  |L23.260|
000104  2002              MOVS     r0,#2                 ;845
000106  e789              B        |L23.28|
;;;848    
                          ENDP


                          AREA ||i.HAL_UART_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Receive_DMA PROC
;;;1008     */
;;;1009   HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;1010   {
000002  4604              MOV      r4,r0
000004  4615              MOV      r5,r2
;;;1011     uint32_t *tmp;
;;;1012   
;;;1013     /* Check that a Rx process is not already ongoing */
;;;1014     if(huart->RxState == HAL_UART_STATE_READY)
000006  6f20              LDR      r0,[r4,#0x70]
000008  2820              CMP      r0,#0x20
00000a  d142              BNE      |L24.146|
;;;1015     {
;;;1016       if((pData == NULL ) || (Size == 0U))
00000c  9801              LDR      r0,[sp,#4]
00000e  b100              CBZ      r0,|L24.18|
000010  b90d              CBNZ     r5,|L24.22|
                  |L24.18|
;;;1017       {
;;;1018         return HAL_ERROR;
000012  2001              MOVS     r0,#1
                  |L24.20|
;;;1019       }
;;;1020   
;;;1021       /* Process Locked */
;;;1022       __HAL_LOCK(huart);
;;;1023   
;;;1024       huart->pRxBuffPtr = pData;
;;;1025       huart->RxXferSize = Size;
;;;1026   
;;;1027       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1028       huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;1029   
;;;1030       /* Set the UART DMA transfer complete callback */
;;;1031       huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
;;;1032   
;;;1033       /* Set the UART DMA Half transfer complete callback */
;;;1034       huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
;;;1035   
;;;1036       /* Set the DMA error callback */
;;;1037       huart->hdmarx->XferErrorCallback = UART_DMAError;
;;;1038   
;;;1039       /* Set the DMA abort callback */
;;;1040       huart->hdmarx->XferAbortCallback = NULL;
;;;1041   
;;;1042       /* Enable the DMA channel */
;;;1043       tmp = (uint32_t*)&pData;
;;;1044       HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->RDR, *(uint32_t*)tmp, Size);
;;;1045   
;;;1046       /* Process Unlocked */
;;;1047       __HAL_UNLOCK(huart);
;;;1048   
;;;1049       /* Enable the UART Parity Error Interrupt */
;;;1050       SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1051   
;;;1052       /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1053       SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1054   
;;;1055       /* Enable the DMA transfer for the receiver request by setting the DMAR bit
;;;1056       in the UART CR3 register */
;;;1057       SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1058   
;;;1059       return HAL_OK;
;;;1060     }
;;;1061     else
;;;1062     {
;;;1063       return HAL_BUSY;
;;;1064     }
;;;1065   }
000014  bdfe              POP      {r1-r7,pc}
                  |L24.22|
000016  bf00              NOP                            ;1022
000018  6ea0              LDR      r0,[r4,#0x68]         ;1022
00001a  2801              CMP      r0,#1                 ;1022
00001c  d101              BNE      |L24.34|
00001e  2002              MOVS     r0,#2                 ;1022
000020  e7f8              B        |L24.20|
                  |L24.34|
000022  2001              MOVS     r0,#1                 ;1022
000024  66a0              STR      r0,[r4,#0x68]         ;1022
000026  bf00              NOP                            ;1022
000028  9801              LDR      r0,[sp,#4]            ;1024
00002a  6560              STR      r0,[r4,#0x54]         ;1024
00002c  f8a45058          STRH     r5,[r4,#0x58]         ;1025
000030  2000              MOVS     r0,#0                 ;1027
000032  6760              STR      r0,[r4,#0x74]         ;1027
000034  2022              MOVS     r0,#0x22              ;1028
000036  6720              STR      r0,[r4,#0x70]         ;1028
000038  4817              LDR      r0,|L24.152|
00003a  6e61              LDR      r1,[r4,#0x64]         ;1031
00003c  6408              STR      r0,[r1,#0x40]         ;1031
00003e  4817              LDR      r0,|L24.156|
000040  6e61              LDR      r1,[r4,#0x64]         ;1034
000042  6448              STR      r0,[r1,#0x44]         ;1034
000044  4816              LDR      r0,|L24.160|
000046  6e61              LDR      r1,[r4,#0x64]         ;1037
000048  6508              STR      r0,[r1,#0x50]         ;1037
00004a  2000              MOVS     r0,#0                 ;1040
00004c  6e61              LDR      r1,[r4,#0x64]         ;1040
00004e  6548              STR      r0,[r1,#0x54]         ;1040
000050  ae01              ADD      r6,sp,#4              ;1043
000052  6832              LDR      r2,[r6,#0]            ;1044
000054  6823              LDR      r3,[r4,#0]            ;1044
000056  f1030124          ADD      r1,r3,#0x24           ;1044
00005a  462b              MOV      r3,r5                 ;1044
00005c  6e60              LDR      r0,[r4,#0x64]         ;1044
00005e  f7fffffe          BL       HAL_DMA_Start_IT
000062  bf00              NOP                            ;1047
000064  2000              MOVS     r0,#0                 ;1047
000066  66a0              STR      r0,[r4,#0x68]         ;1047
000068  bf00              NOP                            ;1047
00006a  6820              LDR      r0,[r4,#0]            ;1050
00006c  6800              LDR      r0,[r0,#0]            ;1050
00006e  f4407080          ORR      r0,r0,#0x100          ;1050
000072  6821              LDR      r1,[r4,#0]            ;1050
000074  6008              STR      r0,[r1,#0]            ;1050
000076  6820              LDR      r0,[r4,#0]            ;1053
000078  6880              LDR      r0,[r0,#8]            ;1053
00007a  f0400001          ORR      r0,r0,#1              ;1053
00007e  6821              LDR      r1,[r4,#0]            ;1053
000080  6088              STR      r0,[r1,#8]            ;1053
000082  6820              LDR      r0,[r4,#0]            ;1057
000084  6880              LDR      r0,[r0,#8]            ;1057
000086  f0400040          ORR      r0,r0,#0x40           ;1057
00008a  6821              LDR      r1,[r4,#0]            ;1057
00008c  6088              STR      r0,[r1,#8]            ;1057
00008e  2000              MOVS     r0,#0                 ;1059
000090  e7c0              B        |L24.20|
                  |L24.146|
000092  2002              MOVS     r0,#2                 ;1063
000094  e7be              B        |L24.20|
;;;1066   
                          ENDP

000096  0000              DCW      0x0000
                  |L24.152|
                          DCD      UART_DMAReceiveCplt
                  |L24.156|
                          DCD      UART_DMARxHalfCplt
                  |L24.160|
                          DCD      UART_DMAError

                          AREA ||i.HAL_UART_Receive_IT||, CODE, READONLY, ALIGN=1

                  HAL_UART_Receive_IT PROC
;;;896      */
;;;897    HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b510              PUSH     {r4,lr}
;;;898    {
000002  4603              MOV      r3,r0
;;;899      /* Check that a Rx process is not already ongoing */
;;;900      if(huart->RxState == HAL_UART_STATE_READY)
000004  6f18              LDR      r0,[r3,#0x70]
000006  2820              CMP      r0,#0x20
000008  d151              BNE      |L25.174|
;;;901      {
;;;902        if((pData == NULL ) || (Size == 0U))
00000a  b101              CBZ      r1,|L25.14|
00000c  b90a              CBNZ     r2,|L25.18|
                  |L25.14|
;;;903        {
;;;904          return HAL_ERROR;
00000e  2001              MOVS     r0,#1
                  |L25.16|
;;;905        }
;;;906    
;;;907        /* Process Locked */
;;;908        __HAL_LOCK(huart);
;;;909    
;;;910        huart->pRxBuffPtr = pData;
;;;911        huart->RxXferSize = Size;
;;;912        huart->RxXferCount = Size;
;;;913    
;;;914        /* Computation of UART mask to apply to RDR register */
;;;915        UART_MASK_COMPUTATION(huart);
;;;916    
;;;917        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;918        huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;919    
;;;920        /* Process Unlocked */
;;;921        __HAL_UNLOCK(huart);
;;;922    
;;;923        /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;924        SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;925    
;;;926        /* Enable the UART Parity Error and Data Register not empty Interrupts */
;;;927        SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE);
;;;928    
;;;929        return HAL_OK;
;;;930      }
;;;931      else
;;;932      {
;;;933        return HAL_BUSY;
;;;934      }
;;;935    }
000010  bd10              POP      {r4,pc}
                  |L25.18|
000012  bf00              NOP                            ;908
000014  6e98              LDR      r0,[r3,#0x68]         ;908
000016  2801              CMP      r0,#1                 ;908
000018  d101              BNE      |L25.30|
00001a  2002              MOVS     r0,#2                 ;908
00001c  e7f8              B        |L25.16|
                  |L25.30|
00001e  2001              MOVS     r0,#1                 ;908
000020  6698              STR      r0,[r3,#0x68]         ;908
000022  bf00              NOP                            ;908
000024  6559              STR      r1,[r3,#0x54]         ;910
000026  f8a32058          STRH     r2,[r3,#0x58]         ;911
00002a  f8a3205a          STRH     r2,[r3,#0x5a]         ;912
00002e  bf00              NOP                            ;915
000030  6898              LDR      r0,[r3,#8]            ;915
000032  f5b05f80          CMP      r0,#0x1000            ;915
000036  d10a              BNE      |L25.78|
000038  6918              LDR      r0,[r3,#0x10]         ;915
00003a  b920              CBNZ     r0,|L25.70|
00003c  f24010ff          MOV      r0,#0x1ff             ;915
000040  f8a3005c          STRH     r0,[r3,#0x5c]         ;915
000044  e01c              B        |L25.128|
                  |L25.70|
000046  20ff              MOVS     r0,#0xff              ;915
000048  f8a3005c          STRH     r0,[r3,#0x5c]         ;915
00004c  e018              B        |L25.128|
                  |L25.78|
00004e  6898              LDR      r0,[r3,#8]            ;915
000050  b948              CBNZ     r0,|L25.102|
000052  6918              LDR      r0,[r3,#0x10]         ;915
000054  b918              CBNZ     r0,|L25.94|
000056  20ff              MOVS     r0,#0xff              ;915
000058  f8a3005c          STRH     r0,[r3,#0x5c]         ;915
00005c  e010              B        |L25.128|
                  |L25.94|
00005e  207f              MOVS     r0,#0x7f              ;915
000060  f8a3005c          STRH     r0,[r3,#0x5c]         ;915
000064  e00c              B        |L25.128|
                  |L25.102|
000066  6898              LDR      r0,[r3,#8]            ;915
000068  f1b05f80          CMP      r0,#0x10000000        ;915
00006c  d108              BNE      |L25.128|
00006e  6918              LDR      r0,[r3,#0x10]         ;915
000070  b918              CBNZ     r0,|L25.122|
000072  207f              MOVS     r0,#0x7f              ;915
000074  f8a3005c          STRH     r0,[r3,#0x5c]         ;915
000078  e002              B        |L25.128|
                  |L25.122|
00007a  203f              MOVS     r0,#0x3f              ;915
00007c  f8a3005c          STRH     r0,[r3,#0x5c]         ;915
                  |L25.128|
000080  bf00              NOP                            ;915
000082  2000              MOVS     r0,#0                 ;917
000084  6758              STR      r0,[r3,#0x74]         ;917
000086  2022              MOVS     r0,#0x22              ;918
000088  6718              STR      r0,[r3,#0x70]         ;918
00008a  bf00              NOP                            ;921
00008c  2000              MOVS     r0,#0                 ;921
00008e  6698              STR      r0,[r3,#0x68]         ;921
000090  bf00              NOP                            ;921
000092  6818              LDR      r0,[r3,#0]            ;924
000094  6880              LDR      r0,[r0,#8]            ;924
000096  f0400001          ORR      r0,r0,#1              ;924
00009a  681c              LDR      r4,[r3,#0]            ;924
00009c  60a0              STR      r0,[r4,#8]            ;924
00009e  6818              LDR      r0,[r3,#0]            ;927
0000a0  6800              LDR      r0,[r0,#0]            ;927
0000a2  f4407090          ORR      r0,r0,#0x120          ;927
0000a6  681c              LDR      r4,[r3,#0]            ;927
0000a8  6020              STR      r0,[r4,#0]            ;927
0000aa  2000              MOVS     r0,#0                 ;929
0000ac  e7b0              B        |L25.16|
                  |L25.174|
0000ae  2002              MOVS     r0,#2                 ;933
0000b0  e7ae              B        |L25.16|
;;;936    
                          ENDP


                          AREA ||i.HAL_UART_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxCpltCallback PROC
;;;1517     */
;;;1518   __weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1519   {
;;;1520     /* Prevent unused argument(s) compilation warning */
;;;1521     UNUSED(huart);
;;;1522   
;;;1523     /* NOTE : This function should not be modified, when the callback is needed,
;;;1524               the HAL_UART_RxCpltCallback can be implemented in the user file
;;;1525      */
;;;1526   }
;;;1527   
                          ENDP


                          AREA ||i.HAL_UART_RxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxHalfCpltCallback PROC
;;;1532     */
;;;1533   __weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1534   {
;;;1535     /* Prevent unused argument(s) compilation warning */
;;;1536     UNUSED(huart);
;;;1537   
;;;1538     /* NOTE: This function should not be modified, when the callback is needed,
;;;1539              the HAL_UART_RxHalfCpltCallback can be implemented in the user file
;;;1540      */
;;;1541   }
;;;1542   
                          ENDP


                          AREA ||i.HAL_UART_Transmit||, CODE, READONLY, ALIGN=1

                  HAL_UART_Transmit PROC
;;;715      */
;;;716    HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;717    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;718      uint16_t* tmp;
;;;719      uint32_t tickstart = 0U;
00000c  f04f0900          MOV      r9,#0
;;;720    
;;;721      /* Check that a Tx process is not already ongoing */
;;;722      if(huart->gState == HAL_UART_STATE_READY)
000010  6ee0              LDR      r0,[r4,#0x6c]
000012  2820              CMP      r0,#0x20
000014  d150              BNE      |L28.184|
;;;723      {
;;;724        if((pData == NULL ) || (Size == 0U))
000016  b105              CBZ      r5,|L28.26|
000018  b916              CBNZ     r6,|L28.32|
                  |L28.26|
;;;725        {
;;;726          return  HAL_ERROR;
00001a  2001              MOVS     r0,#1
                  |L28.28|
;;;727        }
;;;728    
;;;729        /* Process Locked */
;;;730        __HAL_LOCK(huart);
;;;731    
;;;732        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;733        huart->gState = HAL_UART_STATE_BUSY_TX;
;;;734    
;;;735        /* Init tickstart for timeout managment*/
;;;736        tickstart = HAL_GetTick();
;;;737    
;;;738        huart->TxXferSize = Size;
;;;739        huart->TxXferCount = Size;
;;;740        while(huart->TxXferCount > 0U)
;;;741        {
;;;742          huart->TxXferCount--;
;;;743          if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;744          {
;;;745            return HAL_TIMEOUT;
;;;746          }
;;;747          if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;748          {
;;;749            tmp = (uint16_t*) pData;
;;;750            huart->Instance->TDR = (*tmp & (uint16_t)0x01FFU);
;;;751            pData += 2;
;;;752          }
;;;753          else
;;;754          {
;;;755            huart->Instance->TDR = (*pData++ & (uint8_t)0xFFU);
;;;756          }
;;;757        }
;;;758        if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
;;;759        {
;;;760          return HAL_TIMEOUT;
;;;761        }
;;;762    
;;;763        /* At end of Tx process, restore huart->gState to Ready */
;;;764        huart->gState = HAL_UART_STATE_READY;
;;;765    
;;;766        /* Process Unlocked */
;;;767        __HAL_UNLOCK(huart);
;;;768    
;;;769        return HAL_OK;
;;;770      }
;;;771      else
;;;772      {
;;;773        return HAL_BUSY;
;;;774      }
;;;775    }
00001c  e8bd83f8          POP      {r3-r9,pc}
                  |L28.32|
000020  bf00              NOP                            ;730
000022  6ea0              LDR      r0,[r4,#0x68]         ;730
000024  2801              CMP      r0,#1                 ;730
000026  d101              BNE      |L28.44|
000028  2002              MOVS     r0,#2                 ;730
00002a  e7f7              B        |L28.28|
                  |L28.44|
00002c  2001              MOVS     r0,#1                 ;730
00002e  66a0              STR      r0,[r4,#0x68]         ;730
000030  bf00              NOP                            ;730
000032  2000              MOVS     r0,#0                 ;732
000034  6760              STR      r0,[r4,#0x74]         ;732
000036  2021              MOVS     r0,#0x21              ;733
000038  66e0              STR      r0,[r4,#0x6c]         ;733
00003a  f7fffffe          BL       HAL_GetTick
00003e  4681              MOV      r9,r0                 ;736
000040  f8a46050          STRH     r6,[r4,#0x50]         ;738
000044  f8a46052          STRH     r6,[r4,#0x52]         ;739
000048  e021              B        |L28.142|
                  |L28.74|
00004a  f8b40052          LDRH     r0,[r4,#0x52]         ;742
00004e  1e40              SUBS     r0,r0,#1              ;742
000050  f8a40052          STRH     r0,[r4,#0x52]         ;742
000054  464b              MOV      r3,r9                 ;743
000056  2200              MOVS     r2,#0                 ;743
000058  2180              MOVS     r1,#0x80              ;743
00005a  4620              MOV      r0,r4                 ;743
00005c  9700              STR      r7,[sp,#0]            ;743
00005e  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
000062  b108              CBZ      r0,|L28.104|
000064  2003              MOVS     r0,#3                 ;745
000066  e7d9              B        |L28.28|
                  |L28.104|
000068  68a0              LDR      r0,[r4,#8]            ;747
00006a  f5b05f80          CMP      r0,#0x1000            ;747
00006e  d10a              BNE      |L28.134|
000070  6920              LDR      r0,[r4,#0x10]         ;747
000072  b940              CBNZ     r0,|L28.134|
000074  46a8              MOV      r8,r5                 ;749
000076  f8b80000          LDRH     r0,[r8,#0]            ;750
00007a  f3c00008          UBFX     r0,r0,#0,#9           ;750
00007e  6821              LDR      r1,[r4,#0]            ;750
000080  6288              STR      r0,[r1,#0x28]         ;750
000082  1cad              ADDS     r5,r5,#2              ;751
000084  e003              B        |L28.142|
                  |L28.134|
000086  f8150b01          LDRB     r0,[r5],#1            ;755
00008a  6821              LDR      r1,[r4,#0]            ;755
00008c  6288              STR      r0,[r1,#0x28]         ;755
                  |L28.142|
00008e  f8b40052          LDRH     r0,[r4,#0x52]         ;740
000092  2800              CMP      r0,#0                 ;740
000094  d1d9              BNE      |L28.74|
000096  464b              MOV      r3,r9                 ;758
000098  2200              MOVS     r2,#0                 ;758
00009a  2140              MOVS     r1,#0x40              ;758
00009c  4620              MOV      r0,r4                 ;758
00009e  9700              STR      r7,[sp,#0]            ;758
0000a0  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
0000a4  b108              CBZ      r0,|L28.170|
0000a6  2003              MOVS     r0,#3                 ;760
0000a8  e7b8              B        |L28.28|
                  |L28.170|
0000aa  2020              MOVS     r0,#0x20              ;764
0000ac  66e0              STR      r0,[r4,#0x6c]         ;764
0000ae  bf00              NOP                            ;767
0000b0  2000              MOVS     r0,#0                 ;767
0000b2  66a0              STR      r0,[r4,#0x68]         ;767
0000b4  bf00              NOP                            ;767
0000b6  e7b1              B        |L28.28|
                  |L28.184|
0000b8  2002              MOVS     r0,#2                 ;773
0000ba  e7af              B        |L28.28|
;;;776    
                          ENDP


                          AREA ||i.HAL_UART_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Transmit_DMA PROC
;;;943      */
;;;944    HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;945    {
000002  4604              MOV      r4,r0
000004  4615              MOV      r5,r2
;;;946      uint32_t *tmp;
;;;947    
;;;948      /* Check that a Tx process is not already ongoing */
;;;949      if(huart->gState == HAL_UART_STATE_READY)
000006  6ee0              LDR      r0,[r4,#0x6c]
000008  2820              CMP      r0,#0x20
00000a  d13b              BNE      |L29.132|
;;;950      {
;;;951        if((pData == NULL ) || (Size == 0U))
00000c  9801              LDR      r0,[sp,#4]
00000e  b100              CBZ      r0,|L29.18|
000010  b90d              CBNZ     r5,|L29.22|
                  |L29.18|
;;;952        {
;;;953          return HAL_ERROR;
000012  2001              MOVS     r0,#1
                  |L29.20|
;;;954        }
;;;955    
;;;956        /* Process Locked */
;;;957        __HAL_LOCK(huart);
;;;958    
;;;959        huart->pTxBuffPtr = pData;
;;;960        huart->TxXferSize = Size;
;;;961        huart->TxXferCount = Size;
;;;962    
;;;963        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;964        huart->gState = HAL_UART_STATE_BUSY_TX;
;;;965    
;;;966        /* Set the UART DMA transfer complete callback */
;;;967        huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
;;;968    
;;;969        /* Set the UART DMA Half transfer complete callback */
;;;970        huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
;;;971    
;;;972        /* Set the DMA error callback */
;;;973        huart->hdmatx->XferErrorCallback = UART_DMAError;
;;;974    
;;;975        /* Set the DMA abort callback */
;;;976        huart->hdmatx->XferAbortCallback = NULL;
;;;977    
;;;978        /* Enable the UART transmit DMA channel */
;;;979        tmp = (uint32_t*)&pData;
;;;980        HAL_DMA_Start_IT(huart->hdmatx, *(uint32_t*)tmp, (uint32_t)&huart->Instance->TDR, Size);
;;;981    
;;;982        /* Clear the TC flag in the SR register by writing 0 to it */
;;;983        __HAL_UART_CLEAR_IT(huart, UART_FLAG_TC);
;;;984    
;;;985        /* Process Unlocked */
;;;986        __HAL_UNLOCK(huart);
;;;987    
;;;988        /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;989           in the UART CR3 register */
;;;990        SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;991    
;;;992        return HAL_OK;
;;;993      }
;;;994      else
;;;995      {
;;;996        return HAL_BUSY;
;;;997      }
;;;998    }
000014  bdfe              POP      {r1-r7,pc}
                  |L29.22|
000016  bf00              NOP                            ;957
000018  6ea0              LDR      r0,[r4,#0x68]         ;957
00001a  2801              CMP      r0,#1                 ;957
00001c  d101              BNE      |L29.34|
00001e  2002              MOVS     r0,#2                 ;957
000020  e7f8              B        |L29.20|
                  |L29.34|
000022  2001              MOVS     r0,#1                 ;957
000024  66a0              STR      r0,[r4,#0x68]         ;957
000026  bf00              NOP                            ;957
000028  9801              LDR      r0,[sp,#4]            ;959
00002a  64e0              STR      r0,[r4,#0x4c]         ;959
00002c  f8a45050          STRH     r5,[r4,#0x50]         ;960
000030  f8a45052          STRH     r5,[r4,#0x52]         ;961
000034  2000              MOVS     r0,#0                 ;963
000036  6760              STR      r0,[r4,#0x74]         ;963
000038  2021              MOVS     r0,#0x21              ;964
00003a  66e0              STR      r0,[r4,#0x6c]         ;964
00003c  4812              LDR      r0,|L29.136|
00003e  6e21              LDR      r1,[r4,#0x60]         ;967
000040  6408              STR      r0,[r1,#0x40]         ;967
000042  4812              LDR      r0,|L29.140|
000044  6e21              LDR      r1,[r4,#0x60]         ;970
000046  6448              STR      r0,[r1,#0x44]         ;970
000048  4811              LDR      r0,|L29.144|
00004a  6e21              LDR      r1,[r4,#0x60]         ;973
00004c  6508              STR      r0,[r1,#0x50]         ;973
00004e  2000              MOVS     r0,#0                 ;976
000050  6e21              LDR      r1,[r4,#0x60]         ;976
000052  6548              STR      r0,[r1,#0x54]         ;976
000054  ae01              ADD      r6,sp,#4              ;979
000056  6823              LDR      r3,[r4,#0]            ;980
000058  f1030228          ADD      r2,r3,#0x28           ;980
00005c  6831              LDR      r1,[r6,#0]            ;980
00005e  462b              MOV      r3,r5                 ;980
000060  6e20              LDR      r0,[r4,#0x60]         ;980
000062  f7fffffe          BL       HAL_DMA_Start_IT
000066  2040              MOVS     r0,#0x40              ;983
000068  6821              LDR      r1,[r4,#0]            ;983
00006a  6208              STR      r0,[r1,#0x20]         ;983
00006c  bf00              NOP                            ;986
00006e  2000              MOVS     r0,#0                 ;986
000070  66a0              STR      r0,[r4,#0x68]         ;986
000072  bf00              NOP                            ;986
000074  6820              LDR      r0,[r4,#0]            ;990
000076  6880              LDR      r0,[r0,#8]            ;990
000078  f0400080          ORR      r0,r0,#0x80           ;990
00007c  6821              LDR      r1,[r4,#0]            ;990
00007e  6088              STR      r0,[r1,#8]            ;990
000080  2000              MOVS     r0,#0                 ;992
000082  e7c7              B        |L29.20|
                  |L29.132|
000084  2002              MOVS     r0,#2                 ;996
000086  e7c5              B        |L29.20|
;;;999    
                          ENDP

                  |L29.136|
                          DCD      UART_DMATransmitCplt
                  |L29.140|
                          DCD      UART_DMATxHalfCplt
                  |L29.144|
                          DCD      UART_DMAError

                          AREA ||i.HAL_UART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  HAL_UART_Transmit_IT PROC
;;;855      */
;;;856    HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b510              PUSH     {r4,lr}
;;;857    {
000002  4603              MOV      r3,r0
;;;858      /* Check that a Tx process is not already ongoing */
;;;859      if(huart->gState == HAL_UART_STATE_READY)
000004  6ed8              LDR      r0,[r3,#0x6c]
000006  2820              CMP      r0,#0x20
000008  d121              BNE      |L30.78|
;;;860      {
;;;861        if((pData == NULL ) || (Size == 0U))
00000a  b101              CBZ      r1,|L30.14|
00000c  b90a              CBNZ     r2,|L30.18|
                  |L30.14|
;;;862        {
;;;863          return HAL_ERROR;
00000e  2001              MOVS     r0,#1
                  |L30.16|
;;;864        }
;;;865    
;;;866        /* Process Locked */
;;;867        __HAL_LOCK(huart);
;;;868    
;;;869        huart->pTxBuffPtr = pData;
;;;870        huart->TxXferSize = Size;
;;;871        huart->TxXferCount = Size;
;;;872    
;;;873        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;874        huart->gState = HAL_UART_STATE_BUSY_TX;
;;;875    
;;;876        /* Process Unlocked */
;;;877        __HAL_UNLOCK(huart);
;;;878    
;;;879        /* Enable the UART Transmit Data Register Empty Interrupt */
;;;880        SET_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
;;;881    
;;;882        return HAL_OK;
;;;883      }
;;;884      else
;;;885      {
;;;886        return HAL_BUSY;
;;;887      }
;;;888    }
000010  bd10              POP      {r4,pc}
                  |L30.18|
000012  bf00              NOP                            ;867
000014  6e98              LDR      r0,[r3,#0x68]         ;867
000016  2801              CMP      r0,#1                 ;867
000018  d101              BNE      |L30.30|
00001a  2002              MOVS     r0,#2                 ;867
00001c  e7f8              B        |L30.16|
                  |L30.30|
00001e  2001              MOVS     r0,#1                 ;867
000020  6698              STR      r0,[r3,#0x68]         ;867
000022  bf00              NOP                            ;867
000024  64d9              STR      r1,[r3,#0x4c]         ;869
000026  f8a32050          STRH     r2,[r3,#0x50]         ;870
00002a  f8a32052          STRH     r2,[r3,#0x52]         ;871
00002e  2000              MOVS     r0,#0                 ;873
000030  6758              STR      r0,[r3,#0x74]         ;873
000032  2021              MOVS     r0,#0x21              ;874
000034  66d8              STR      r0,[r3,#0x6c]         ;874
000036  bf00              NOP                            ;877
000038  2000              MOVS     r0,#0                 ;877
00003a  6698              STR      r0,[r3,#0x68]         ;877
00003c  bf00              NOP                            ;877
00003e  6818              LDR      r0,[r3,#0]            ;880
000040  6800              LDR      r0,[r0,#0]            ;880
000042  f0400080          ORR      r0,r0,#0x80           ;880
000046  681c              LDR      r4,[r3,#0]            ;880
000048  6020              STR      r0,[r4,#0]            ;880
00004a  2000              MOVS     r0,#0                 ;882
00004c  e7e0              B        |L30.16|
                  |L30.78|
00004e  2002              MOVS     r0,#2                 ;886
000050  e7de              B        |L30.16|
;;;889    
                          ENDP


                          AREA ||i.HAL_UART_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxCpltCallback PROC
;;;1487     */
;;;1488    __weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1489   {
;;;1490     /* Prevent unused argument(s) compilation warning */
;;;1491     UNUSED(huart);
;;;1492   
;;;1493     /* NOTE : This function should not be modified, when the callback is needed,
;;;1494               the HAL_UART_TxCpltCallback can be implemented in the user file
;;;1495      */
;;;1496   }
;;;1497   
                          ENDP


                          AREA ||i.HAL_UART_TxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxHalfCpltCallback PROC
;;;1502     */
;;;1503    __weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;1504   {
;;;1505     /* Prevent unused argument(s) compilation warning */
;;;1506     UNUSED(huart);
;;;1507   
;;;1508     /* NOTE: This function should not be modified, when the callback is needed,
;;;1509              the HAL_UART_TxHalfCpltCallback can be implemented in the user file
;;;1510      */
;;;1511   }
;;;1512   
                          ENDP


                          AREA ||i.UART_AdvFeatureConfig||, CODE, READONLY, ALIGN=1

                  UART_AdvFeatureConfig PROC
;;;1935     */
;;;1936   void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
000000  f8901024          LDRB     r1,[r0,#0x24]
;;;1937   {
;;;1938     /* Check whether the set of advanced features to configure is properly set */
;;;1939     assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));
;;;1940   
;;;1941     /* if required, configure TX pin active level inversion */
;;;1942     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
000004  f0010101          AND      r1,r1,#1
000008  b139              CBZ      r1,|L33.26|
;;;1943     {
;;;1944       assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
;;;1945       MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
00000a  6801              LDR      r1,[r0,#0]
00000c  6849              LDR      r1,[r1,#4]
00000e  f4213100          BIC      r1,r1,#0x20000
000012  6a82              LDR      r2,[r0,#0x28]
000014  4311              ORRS     r1,r1,r2
000016  6802              LDR      r2,[r0,#0]
000018  6051              STR      r1,[r2,#4]
                  |L33.26|
;;;1946     }
;;;1947   
;;;1948     /* if required, configure RX pin active level inversion */
;;;1949     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
00001a  f8901024          LDRB     r1,[r0,#0x24]
00001e  f0010102          AND      r1,r1,#2
000022  b139              CBZ      r1,|L33.52|
;;;1950     {
;;;1951       assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
;;;1952       MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
000024  6801              LDR      r1,[r0,#0]
000026  6849              LDR      r1,[r1,#4]
000028  f4213180          BIC      r1,r1,#0x10000
00002c  6ac2              LDR      r2,[r0,#0x2c]
00002e  4311              ORRS     r1,r1,r2
000030  6802              LDR      r2,[r0,#0]
000032  6051              STR      r1,[r2,#4]
                  |L33.52|
;;;1953     }
;;;1954   
;;;1955     /* if required, configure data inversion */
;;;1956     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
000034  f8901024          LDRB     r1,[r0,#0x24]
000038  f0010104          AND      r1,r1,#4
00003c  b139              CBZ      r1,|L33.78|
;;;1957     {
;;;1958       assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
;;;1959       MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
00003e  6801              LDR      r1,[r0,#0]
000040  6849              LDR      r1,[r1,#4]
000042  f4212180          BIC      r1,r1,#0x40000
000046  6b02              LDR      r2,[r0,#0x30]
000048  4311              ORRS     r1,r1,r2
00004a  6802              LDR      r2,[r0,#0]
00004c  6051              STR      r1,[r2,#4]
                  |L33.78|
;;;1960     }
;;;1961   
;;;1962     /* if required, configure RX/TX pins swap */
;;;1963     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
00004e  f8901024          LDRB     r1,[r0,#0x24]
000052  f0010108          AND      r1,r1,#8
000056  b139              CBZ      r1,|L33.104|
;;;1964     {
;;;1965       assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
;;;1966       MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
000058  6801              LDR      r1,[r0,#0]
00005a  6849              LDR      r1,[r1,#4]
00005c  f4214100          BIC      r1,r1,#0x8000
000060  6b42              LDR      r2,[r0,#0x34]
000062  4311              ORRS     r1,r1,r2
000064  6802              LDR      r2,[r0,#0]
000066  6051              STR      r1,[r2,#4]
                  |L33.104|
;;;1967     }
;;;1968   
;;;1969     /* if required, configure RX overrun detection disabling */
;;;1970     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
000068  f8901024          LDRB     r1,[r0,#0x24]
00006c  f0010110          AND      r1,r1,#0x10
000070  b139              CBZ      r1,|L33.130|
;;;1971     {
;;;1972       assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
;;;1973       MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
000072  6801              LDR      r1,[r0,#0]
000074  6889              LDR      r1,[r1,#8]
000076  f4215180          BIC      r1,r1,#0x1000
00007a  6b82              LDR      r2,[r0,#0x38]
00007c  4311              ORRS     r1,r1,r2
00007e  6802              LDR      r2,[r0,#0]
000080  6091              STR      r1,[r2,#8]
                  |L33.130|
;;;1974     }
;;;1975   
;;;1976     /* if required, configure DMA disabling on reception error */
;;;1977     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
000082  f8901024          LDRB     r1,[r0,#0x24]
000086  f0010120          AND      r1,r1,#0x20
00008a  b139              CBZ      r1,|L33.156|
;;;1978     {
;;;1979       assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
;;;1980       MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
00008c  6801              LDR      r1,[r0,#0]
00008e  6889              LDR      r1,[r1,#8]
000090  f4215100          BIC      r1,r1,#0x2000
000094  6bc2              LDR      r2,[r0,#0x3c]
000096  4311              ORRS     r1,r1,r2
000098  6802              LDR      r2,[r0,#0]
00009a  6091              STR      r1,[r2,#8]
                  |L33.156|
;;;1981     }
;;;1982   
;;;1983     /* if required, configure auto Baud rate detection scheme */
;;;1984     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
00009c  f8901024          LDRB     r1,[r0,#0x24]
0000a0  f0010140          AND      r1,r1,#0x40
0000a4  b199              CBZ      r1,|L33.206|
;;;1985     {
;;;1986       assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
;;;1987       MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
0000a6  6801              LDR      r1,[r0,#0]
0000a8  6849              LDR      r1,[r1,#4]
0000aa  f4211180          BIC      r1,r1,#0x100000
0000ae  6c02              LDR      r2,[r0,#0x40]
0000b0  4311              ORRS     r1,r1,r2
0000b2  6802              LDR      r2,[r0,#0]
0000b4  6051              STR      r1,[r2,#4]
;;;1988       /* set auto Baudrate detection parameters if detection is enabled */
;;;1989       if(huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
0000b6  6c01              LDR      r1,[r0,#0x40]
0000b8  f5b11f80          CMP      r1,#0x100000
0000bc  d107              BNE      |L33.206|
;;;1990       {
;;;1991         assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
;;;1992         MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
0000be  6801              LDR      r1,[r0,#0]
0000c0  6849              LDR      r1,[r1,#4]
0000c2  f42101c0          BIC      r1,r1,#0x600000
0000c6  6c42              LDR      r2,[r0,#0x44]
0000c8  4311              ORRS     r1,r1,r2
0000ca  6802              LDR      r2,[r0,#0]
0000cc  6051              STR      r1,[r2,#4]
                  |L33.206|
;;;1993       }
;;;1994     }
;;;1995   
;;;1996     /* if required, configure MSB first on communication line */
;;;1997     if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
0000ce  f8901024          LDRB     r1,[r0,#0x24]
0000d2  f0010180          AND      r1,r1,#0x80
0000d6  b139              CBZ      r1,|L33.232|
;;;1998     {
;;;1999       assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
;;;2000       MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
0000d8  6801              LDR      r1,[r0,#0]
0000da  6849              LDR      r1,[r1,#4]
0000dc  f4212100          BIC      r1,r1,#0x80000
0000e0  6c82              LDR      r2,[r0,#0x48]
0000e2  4311              ORRS     r1,r1,r2
0000e4  6802              LDR      r2,[r0,#0]
0000e6  6051              STR      r1,[r2,#4]
                  |L33.232|
;;;2001     }
;;;2002   }
0000e8  4770              BX       lr
;;;2003   
                          ENDP


                          AREA ||i.UART_CheckIdleState||, CODE, READONLY, ALIGN=1

                  UART_CheckIdleState PROC
;;;2010     */
;;;2011   HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
000000  b538              PUSH     {r3-r5,lr}
;;;2012   {
000002  4604              MOV      r4,r0
;;;2013     uint32_t tickstart = 0U;
000004  2500              MOVS     r5,#0
;;;2014   
;;;2015     /* Initialize the UART ErrorCode */
;;;2016     huart->ErrorCode = HAL_UART_ERROR_NONE;
000006  2000              MOVS     r0,#0
000008  6760              STR      r0,[r4,#0x74]
;;;2017   
;;;2018     /* Init tickstart for timeout managment*/
;;;2019     tickstart = HAL_GetTick();
00000a  f7fffffe          BL       HAL_GetTick
00000e  4605              MOV      r5,r0
;;;2020   
;;;2021     /* Check if the Transmitter is enabled */
;;;2022     if((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
000010  6820              LDR      r0,[r4,#0]
000012  6800              LDR      r0,[r0,#0]
000014  f0000008          AND      r0,r0,#8
000018  2808              CMP      r0,#8
00001a  d10c              BNE      |L34.54|
;;;2023     {
;;;2024       /* Wait until TEACK flag is set */
;;;2025       if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
00001c  f06f407e          MVN      r0,#0xfe000000
000020  462b              MOV      r3,r5
000022  2200              MOVS     r2,#0
000024  f44f1100          MOV      r1,#0x200000
000028  9000              STR      r0,[sp,#0]
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
000030  b108              CBZ      r0,|L34.54|
;;;2026       {
;;;2027         /* Timeout Occurred */
;;;2028         return HAL_TIMEOUT;
000032  2003              MOVS     r0,#3
                  |L34.52|
;;;2029       }
;;;2030     }
;;;2031   
;;;2032     /* Initialize the UART State */
;;;2033     huart->gState= HAL_UART_STATE_READY;
;;;2034     huart->RxState= HAL_UART_STATE_READY;
;;;2035   
;;;2036     /* Process Unlocked */
;;;2037     __HAL_UNLOCK(huart);
;;;2038   
;;;2039     return HAL_OK;
;;;2040   }
000034  bd38              POP      {r3-r5,pc}
                  |L34.54|
000036  2020              MOVS     r0,#0x20              ;2033
000038  66e0              STR      r0,[r4,#0x6c]         ;2033
00003a  6720              STR      r0,[r4,#0x70]         ;2034
00003c  bf00              NOP                            ;2037
00003e  2000              MOVS     r0,#0                 ;2037
000040  66a0              STR      r0,[r4,#0x68]         ;2037
000042  bf00              NOP                            ;2037
000044  bf00              NOP                            ;2039
000046  e7f5              B        |L34.52|
;;;2041   
                          ENDP


                          AREA ||i.UART_DMAAbortOnError||, CODE, READONLY, ALIGN=1

                  UART_DMAAbortOnError PROC
;;;1473     */
;;;1474   static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;1475   {
000002  4605              MOV      r5,r0
;;;1476     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)(hdma->Parent);
000004  6bec              LDR      r4,[r5,#0x3c]
;;;1477     huart->RxXferCount = 0U;
000006  2000              MOVS     r0,#0
000008  f8a4005a          STRH     r0,[r4,#0x5a]
;;;1478     huart->TxXferCount = 0U;
00000c  f8a40052          STRH     r0,[r4,#0x52]
;;;1479   
;;;1480     HAL_UART_ErrorCallback(huart);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       HAL_UART_ErrorCallback
;;;1481   }
000016  bd70              POP      {r4-r6,pc}
;;;1482   
                          ENDP


                          AREA ||i.UART_DMAError||, CODE, READONLY, ALIGN=1

                  UART_DMAError PROC
;;;1445     */
;;;1446   static void UART_DMAError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;1447   {
000002  4605              MOV      r5,r0
;;;1448     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6bec              LDR      r4,[r5,#0x3c]
;;;1449     huart->RxXferCount = 0U;
000006  2000              MOVS     r0,#0
000008  f8a4005a          STRH     r0,[r4,#0x5a]
;;;1450     huart->TxXferCount = 0U;
00000c  f8a40052          STRH     r0,[r4,#0x52]
;;;1451     /* Stop UART DMA Tx request if ongoing */
;;;1452     if (  (huart->gState == HAL_UART_STATE_BUSY_TX)
000010  6ee0              LDR      r0,[r4,#0x6c]
000012  2821              CMP      r0,#0x21
000014  d107              BNE      |L36.38|
;;;1453         &&(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) )
000016  6820              LDR      r0,[r4,#0]
000018  6880              LDR      r0,[r0,#8]
00001a  f0000080          AND      r0,r0,#0x80
00001e  b110              CBZ      r0,|L36.38|
;;;1454     {
;;;1455       UART_EndTxTransfer(huart);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       UART_EndTxTransfer
                  |L36.38|
;;;1456     }
;;;1457   
;;;1458     /* Stop UART DMA Rx request if ongoing */
;;;1459     if (  (huart->RxState == HAL_UART_STATE_BUSY_RX)
000026  6f20              LDR      r0,[r4,#0x70]
000028  2822              CMP      r0,#0x22
00002a  d107              BNE      |L36.60|
;;;1460         &&(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) )
00002c  6820              LDR      r0,[r4,#0]
00002e  6880              LDR      r0,[r0,#8]
000030  f0000040          AND      r0,r0,#0x40
000034  b110              CBZ      r0,|L36.60|
;;;1461     {
;;;1462       UART_EndRxTransfer(huart);
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       UART_EndRxTransfer
                  |L36.60|
;;;1463     }
;;;1464     SET_BIT(huart->ErrorCode, HAL_UART_ERROR_DMA);
00003c  6f60              LDR      r0,[r4,#0x74]
00003e  f0400010          ORR      r0,r0,#0x10
000042  6760              STR      r0,[r4,#0x74]
;;;1465     HAL_UART_ErrorCallback(huart);
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       HAL_UART_ErrorCallback
;;;1466   }
00004a  bd70              POP      {r4-r6,pc}
;;;1467   
                          ENDP


                          AREA ||i.UART_DMAReceiveCplt||, CODE, READONLY, ALIGN=1

                  UART_DMAReceiveCplt PROC
;;;1405     */
;;;1406   static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;1407   {
000002  4605              MOV      r5,r0
;;;1408     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6bec              LDR      r4,[r5,#0x3c]
;;;1409   
;;;1410     /* DMA Normal mode */
;;;1411     if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
000006  6828              LDR      r0,[r5,#0]
000008  6800              LDR      r0,[r0,#0]
00000a  f4007080          AND      r0,r0,#0x100
00000e  b9b0              CBNZ     r0,|L37.62|
;;;1412     {
;;;1413       huart->RxXferCount = 0U;
000010  2000              MOVS     r0,#0
000012  f8a4005a          STRH     r0,[r4,#0x5a]
;;;1414   
;;;1415       /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1416       CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
000016  6820              LDR      r0,[r4,#0]
000018  6800              LDR      r0,[r0,#0]
00001a  f4207080          BIC      r0,r0,#0x100
00001e  6821              LDR      r1,[r4,#0]
000020  6008              STR      r0,[r1,#0]
;;;1417       CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000022  6820              LDR      r0,[r4,#0]
000024  6880              LDR      r0,[r0,#8]
000026  f0200001          BIC      r0,r0,#1
00002a  6821              LDR      r1,[r4,#0]
00002c  6088              STR      r0,[r1,#8]
;;;1418   
;;;1419       /* Disable the DMA transfer for the receiver request by setting the DMAR bit
;;;1420       in the UART CR3 register */
;;;1421       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
00002e  6820              LDR      r0,[r4,#0]
000030  6880              LDR      r0,[r0,#8]
000032  f0200040          BIC      r0,r0,#0x40
000036  6821              LDR      r1,[r4,#0]
000038  6088              STR      r0,[r1,#8]
;;;1422   
;;;1423   	/* At end of Rx process, restore huart->RxState to Ready */
;;;1424       huart->RxState = HAL_UART_STATE_READY;
00003a  2020              MOVS     r0,#0x20
00003c  6720              STR      r0,[r4,#0x70]
                  |L37.62|
;;;1425     }
;;;1426     HAL_UART_RxCpltCallback(huart);
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       HAL_UART_RxCpltCallback
;;;1427   }
000044  bd70              POP      {r4-r6,pc}
;;;1428   
                          ENDP


                          AREA ||i.UART_DMARxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMARxHalfCplt PROC
;;;1433     */
;;;1434   static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;1435   {
000002  4604              MOV      r4,r0
;;;1436     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000004  6be5              LDR      r5,[r4,#0x3c]
;;;1437   
;;;1438     HAL_UART_RxHalfCpltCallback(huart);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       HAL_UART_RxHalfCpltCallback
;;;1439   }
00000c  bd70              POP      {r4-r6,pc}
;;;1440   
                          ENDP


                          AREA ||i.UART_DMATransmitCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATransmitCplt PROC
;;;1365     */
;;;1366   static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;1367   {
000002  4605              MOV      r5,r0
;;;1368     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000004  6bec              LDR      r4,[r5,#0x3c]
;;;1369   
;;;1370     /* DMA Normal mode*/
;;;1371     if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
000006  6828              LDR      r0,[r5,#0]
000008  6800              LDR      r0,[r0,#0]
00000a  f4007080          AND      r0,r0,#0x100
00000e  b978              CBNZ     r0,|L39.48|
;;;1372     {
;;;1373       huart->TxXferCount = 0U;
000010  2000              MOVS     r0,#0
000012  f8a40052          STRH     r0,[r4,#0x52]
;;;1374   
;;;1375       /* Disable the DMA transfer for transmit request by setting the DMAT bit
;;;1376          in the UART CR3 register */
;;;1377       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000016  6820              LDR      r0,[r4,#0]
000018  6880              LDR      r0,[r0,#8]
00001a  f0200080          BIC      r0,r0,#0x80
00001e  6821              LDR      r1,[r4,#0]
000020  6088              STR      r0,[r1,#8]
;;;1378   
;;;1379       /* Enable the UART Transmit Complete Interrupt */
;;;1380       SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
000022  6820              LDR      r0,[r4,#0]
000024  6800              LDR      r0,[r0,#0]
000026  f0400040          ORR      r0,r0,#0x40
00002a  6821              LDR      r1,[r4,#0]
00002c  6008              STR      r0,[r1,#0]
00002e  e002              B        |L39.54|
                  |L39.48|
;;;1381     }
;;;1382     /* DMA Circular mode */
;;;1383     else
;;;1384     {
;;;1385       HAL_UART_TxCpltCallback(huart);
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       HAL_UART_TxCpltCallback
                  |L39.54|
;;;1386     }
;;;1387   }
000036  bd70              POP      {r4-r6,pc}
;;;1388   
                          ENDP


                          AREA ||i.UART_DMATxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATxHalfCplt PROC
;;;1393     */
;;;1394   static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;1395   {
000002  4604              MOV      r4,r0
;;;1396     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000004  6be5              LDR      r5,[r4,#0x3c]
;;;1397   
;;;1398     HAL_UART_TxHalfCpltCallback(huart);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       HAL_UART_TxHalfCpltCallback
;;;1399   }
00000c  bd70              POP      {r4-r6,pc}
;;;1400   
                          ENDP


                          AREA ||i.UART_EndRxTransfer||, CODE, READONLY, ALIGN=1

                  UART_EndRxTransfer PROC
;;;1699     */
;;;1700   static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
000000  6801              LDR      r1,[r0,#0]
;;;1701   {
;;;1702     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1703     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000002  6809              LDR      r1,[r1,#0]
000004  f4217190          BIC      r1,r1,#0x120
000008  6802              LDR      r2,[r0,#0]
00000a  6011              STR      r1,[r2,#0]
;;;1704     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00000c  6801              LDR      r1,[r0,#0]
00000e  6889              LDR      r1,[r1,#8]
000010  f0210101          BIC      r1,r1,#1
000014  6802              LDR      r2,[r0,#0]
000016  6091              STR      r1,[r2,#8]
;;;1705   
;;;1706     /* At end of Rx process, restore huart->RxState to Ready */
;;;1707     huart->RxState = HAL_UART_STATE_READY;
000018  2120              MOVS     r1,#0x20
00001a  6701              STR      r1,[r0,#0x70]
;;;1708   }
00001c  4770              BX       lr
;;;1709   
                          ENDP


                          AREA ||i.UART_EndTransmit_IT||, CODE, READONLY, ALIGN=1

                  UART_EndTransmit_IT PROC
;;;1612     */
;;;1613   static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1614   {
000002  4604              MOV      r4,r0
;;;1615     /* Disable the UART Transmit Complete Interrupt */
;;;1616     CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
000004  6820              LDR      r0,[r4,#0]
000006  6800              LDR      r0,[r0,#0]
000008  f0200040          BIC      r0,r0,#0x40
00000c  6821              LDR      r1,[r4,#0]
00000e  6008              STR      r0,[r1,#0]
;;;1617   
;;;1618     /* Tx process is ended, restore huart->gState to Ready */
;;;1619     huart->gState = HAL_UART_STATE_READY;
000010  2020              MOVS     r0,#0x20
000012  66e0              STR      r0,[r4,#0x6c]
;;;1620   
;;;1621     HAL_UART_TxCpltCallback(huart);
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       HAL_UART_TxCpltCallback
;;;1622   
;;;1623     return HAL_OK;
00001a  2000              MOVS     r0,#0
;;;1624   }
00001c  bd10              POP      {r4,pc}
;;;1625   
                          ENDP


                          AREA ||i.UART_EndTxTransfer||, CODE, READONLY, ALIGN=1

                  UART_EndTxTransfer PROC
;;;1684     */
;;;1685   static void UART_EndTxTransfer(UART_HandleTypeDef *huart)
000000  6801              LDR      r1,[r0,#0]
;;;1686   {
;;;1687     /* Disable TXEIE and TCIE interrupts */
;;;1688     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000002  6809              LDR      r1,[r1,#0]
000004  f02101c0          BIC      r1,r1,#0xc0
000008  6802              LDR      r2,[r0,#0]
00000a  6011              STR      r1,[r2,#0]
;;;1689   
;;;1690     /* At end of Tx process, restore huart->gState to Ready */
;;;1691     huart->gState = HAL_UART_STATE_READY;
00000c  2120              MOVS     r1,#0x20
00000e  66c1              STR      r1,[r0,#0x6c]
;;;1692   }
000010  4770              BX       lr
;;;1693   
                          ENDP


                          AREA ||i.UART_Receive_IT||, CODE, READONLY, ALIGN=1

                  UART_Receive_IT PROC
;;;1632     */
;;;1633   static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1634   {
000002  4604              MOV      r4,r0
;;;1635     uint16_t* tmp;
;;;1636     uint16_t uhMask = huart->Mask;
000004  f8b4605c          LDRH     r6,[r4,#0x5c]
;;;1637   
;;;1638     /* Check that a Rx process is ongoing */
;;;1639     if(huart->RxState == HAL_UART_STATE_BUSY_RX)
000008  6f20              LDR      r0,[r4,#0x70]
00000a  2822              CMP      r0,#0x22
00000c  d132              BNE      |L44.116|
;;;1640     {
;;;1641   
;;;1642       if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
00000e  68a0              LDR      r0,[r4,#8]
000010  f5b05f80          CMP      r0,#0x1000
000014  d10a              BNE      |L44.44|
000016  6920              LDR      r0,[r4,#0x10]
000018  b940              CBNZ     r0,|L44.44|
;;;1643       {
;;;1644         tmp = (uint16_t*) huart->pRxBuffPtr ;
00001a  6d65              LDR      r5,[r4,#0x54]
;;;1645         *tmp = (uint16_t)(huart->Instance->RDR & uhMask);
00001c  6820              LDR      r0,[r4,#0]
00001e  6a40              LDR      r0,[r0,#0x24]
000020  4030              ANDS     r0,r0,r6
000022  8028              STRH     r0,[r5,#0]
;;;1646         huart->pRxBuffPtr +=2;
000024  6d60              LDR      r0,[r4,#0x54]
000026  1c80              ADDS     r0,r0,#2
000028  6560              STR      r0,[r4,#0x54]
00002a  e007              B        |L44.60|
                  |L44.44|
;;;1647       }
;;;1648       else
;;;1649       {
;;;1650         *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask);
00002c  6820              LDR      r0,[r4,#0]
00002e  6a40              LDR      r0,[r0,#0x24]
000030  b2f1              UXTB     r1,r6
000032  4008              ANDS     r0,r0,r1
000034  6d62              LDR      r2,[r4,#0x54]
000036  1c51              ADDS     r1,r2,#1
000038  6561              STR      r1,[r4,#0x54]
00003a  7010              STRB     r0,[r2,#0]
                  |L44.60|
;;;1651       }
;;;1652   
;;;1653       if(--huart->RxXferCount == 0)
00003c  f8b4005a          LDRH     r0,[r4,#0x5a]
000040  1e40              SUBS     r0,r0,#1
000042  b280              UXTH     r0,r0
000044  f8a4005a          STRH     r0,[r4,#0x5a]
000048  b990              CBNZ     r0,|L44.112|
;;;1654       {
;;;1655         /* Disable the UART Parity Error Interrupt and RXNE interrupt*/
;;;1656         CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
00004a  6820              LDR      r0,[r4,#0]
00004c  6800              LDR      r0,[r0,#0]
00004e  f4207090          BIC      r0,r0,#0x120
000052  6821              LDR      r1,[r4,#0]
000054  6008              STR      r0,[r1,#0]
;;;1657   
;;;1658         /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1659         CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000056  6820              LDR      r0,[r4,#0]
000058  6880              LDR      r0,[r0,#8]
00005a  f0200001          BIC      r0,r0,#1
00005e  6821              LDR      r1,[r4,#0]
000060  6088              STR      r0,[r1,#8]
;;;1660   
;;;1661         /* Rx process is completed, restore huart->RxState to Ready */
;;;1662         huart->RxState = HAL_UART_STATE_READY;
000062  2020              MOVS     r0,#0x20
000064  6720              STR      r0,[r4,#0x70]
;;;1663   
;;;1664         HAL_UART_RxCpltCallback(huart);
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       HAL_UART_RxCpltCallback
;;;1665   
;;;1666         return HAL_OK;
00006c  2000              MOVS     r0,#0
                  |L44.110|
;;;1667       }
;;;1668   
;;;1669       return HAL_OK;
;;;1670     }
;;;1671     else
;;;1672     {
;;;1673       /* Clear RXNE interrupt flag */
;;;1674       __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
;;;1675   
;;;1676       return HAL_BUSY;
;;;1677     }
;;;1678   }
00006e  bd70              POP      {r4-r6,pc}
                  |L44.112|
000070  2000              MOVS     r0,#0                 ;1669
000072  e7fc              B        |L44.110|
                  |L44.116|
000074  6820              LDR      r0,[r4,#0]            ;1674
000076  6980              LDR      r0,[r0,#0x18]         ;1674
000078  f0400008          ORR      r0,r0,#8              ;1674
00007c  6821              LDR      r1,[r4,#0]            ;1674
00007e  6188              STR      r0,[r1,#0x18]         ;1674
000080  2002              MOVS     r0,#2                 ;1676
000082  e7f4              B        |L44.110|
;;;1679   
                          ENDP


                          AREA ||i.UART_SetConfig||, CODE, READONLY, ALIGN=2

                  UART_SetConfig PROC
;;;1824     */
;;;1825   HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1826   {
000004  4604              MOV      r4,r0
;;;1827     uint32_t tmpreg                     = 0x00000000U;
000006  2500              MOVS     r5,#0
;;;1828     UART_ClockSourceTypeDef clocksource = UART_CLOCKSOURCE_UNDEFINED;
000008  2610              MOVS     r6,#0x10
;;;1829     uint16_t brrtemp                    = 0x0000U;
00000a  2700              MOVS     r7,#0
;;;1830     uint16_t usartdiv                   = 0x0000U;
00000c  46a8              MOV      r8,r5
;;;1831     HAL_StatusTypeDef ret               = HAL_OK;
00000e  46a9              MOV      r9,r5
;;;1832   
;;;1833     /* Check the parameters */
;;;1834     assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
;;;1835     assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;1836     assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
;;;1837     assert_param(IS_UART_PARITY(huart->Init.Parity));
;;;1838     assert_param(IS_UART_MODE(huart->Init.Mode));
;;;1839     assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
;;;1840     assert_param(IS_UART_ONE_BIT_SAMPLE(huart->Init.OneBitSampling));
;;;1841   
;;;1842   
;;;1843     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;1844     /* Clear M, PCE, PS, TE, RE and OVER8 bits and configure
;;;1845      *  the UART Word Length, Parity, Mode and oversampling:
;;;1846      *  set the M bits according to huart->Init.WordLength value
;;;1847      *  set PCE and PS bits according to huart->Init.Parity value
;;;1848      *  set TE and RE bits according to huart->Init.Mode value
;;;1849      *  set OVER8 bit according to huart->Init.OverSampling value */
;;;1850     tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
000010  6921              LDR      r1,[r4,#0x10]
000012  68a0              LDR      r0,[r4,#8]
000014  4308              ORRS     r0,r0,r1
000016  6961              LDR      r1,[r4,#0x14]
000018  4308              ORRS     r0,r0,r1
00001a  69e1              LDR      r1,[r4,#0x1c]
00001c  ea400501          ORR      r5,r0,r1
;;;1851     MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
000020  6820              LDR      r0,[r4,#0]
000022  6800              LDR      r0,[r0,#0]
000024  49cd              LDR      r1,|L45.860|
000026  4008              ANDS     r0,r0,r1
000028  4328              ORRS     r0,r0,r5
00002a  6821              LDR      r1,[r4,#0]
00002c  6008              STR      r0,[r1,#0]
;;;1852   
;;;1853     /*-------------------------- USART CR2 Configuration -----------------------*/
;;;1854     /* Configure the UART Stop Bits: Set STOP[13:12] bits according
;;;1855      * to huart->Init.StopBits value */
;;;1856     MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
00002e  6820              LDR      r0,[r4,#0]
000030  6840              LDR      r0,[r0,#4]
000032  f4205040          BIC      r0,r0,#0x3000
000036  68e1              LDR      r1,[r4,#0xc]
000038  4308              ORRS     r0,r0,r1
00003a  6821              LDR      r1,[r4,#0]
00003c  6048              STR      r0,[r1,#4]
;;;1857   
;;;1858     /*-------------------------- USART CR3 Configuration -----------------------*/
;;;1859     /* Configure
;;;1860      * - UART HardWare Flow Control: set CTSE and RTSE bits according
;;;1861      *   to huart->Init.HwFlowCtl value
;;;1862      * - one-bit sampling method versus three samples' majority rule according
;;;1863      *   to huart->Init.OneBitSampling */
;;;1864     tmpreg = (uint32_t)huart->Init.HwFlowCtl | huart->Init.OneBitSampling ;
00003e  6a21              LDR      r1,[r4,#0x20]
000040  69a0              LDR      r0,[r4,#0x18]
000042  ea400501          ORR      r5,r0,r1
;;;1865     MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);
000046  6820              LDR      r0,[r4,#0]
000048  6880              LDR      r0,[r0,#8]
00004a  f4206030          BIC      r0,r0,#0xb00
00004e  4328              ORRS     r0,r0,r5
000050  6821              LDR      r1,[r4,#0]
000052  6088              STR      r0,[r1,#8]
;;;1866   
;;;1867     /*-------------------------- USART BRR Configuration -----------------------*/
;;;1868     UART_GETCLOCKSOURCE(huart, clocksource);
000054  bf00              NOP      
000056  49c2              LDR      r1,|L45.864|
000058  6820              LDR      r0,[r4,#0]
00005a  4288              CMP      r0,r1
00005c  d115              BNE      |L45.138|
00005e  48c1              LDR      r0,|L45.868|
000060  6800              LDR      r0,[r0,#0]
000062  f0000003          AND      r0,r0,#3
000066  b130              CBZ      r0,|L45.118|
000068  2801              CMP      r0,#1
00006a  d008              BEQ      |L45.126|
00006c  2802              CMP      r0,#2
00006e  d004              BEQ      |L45.122|
000070  2803              CMP      r0,#3
000072  d108              BNE      |L45.134|
000074  e005              B        |L45.130|
                  |L45.118|
000076  2601              MOVS     r6,#1
000078  e006              B        |L45.136|
                  |L45.122|
00007a  2602              MOVS     r6,#2
00007c  e004              B        |L45.136|
                  |L45.126|
00007e  2604              MOVS     r6,#4
000080  e002              B        |L45.136|
                  |L45.130|
000082  2608              MOVS     r6,#8
000084  e000              B        |L45.136|
                  |L45.134|
000086  bf00              NOP      
                  |L45.136|
000088  e0c1              B        |L45.526|
                  |L45.138|
00008a  49b7              LDR      r1,|L45.872|
00008c  6820              LDR      r0,[r4,#0]
00008e  4288              CMP      r0,r1
000090  d115              BNE      |L45.190|
000092  48b4              LDR      r0,|L45.868|
000094  6800              LDR      r0,[r0,#0]
000096  f000000c          AND      r0,r0,#0xc
00009a  b130              CBZ      r0,|L45.170|
00009c  2804              CMP      r0,#4
00009e  d008              BEQ      |L45.178|
0000a0  2808              CMP      r0,#8
0000a2  d004              BEQ      |L45.174|
0000a4  280c              CMP      r0,#0xc
0000a6  d108              BNE      |L45.186|
0000a8  e005              B        |L45.182|
                  |L45.170|
0000aa  2600              MOVS     r6,#0
0000ac  e006              B        |L45.188|
                  |L45.174|
0000ae  2602              MOVS     r6,#2
0000b0  e004              B        |L45.188|
                  |L45.178|
0000b2  2604              MOVS     r6,#4
0000b4  e002              B        |L45.188|
                  |L45.182|
0000b6  2608              MOVS     r6,#8
0000b8  e000              B        |L45.188|
                  |L45.186|
0000ba  bf00              NOP      
                  |L45.188|
0000bc  e0a7              B        |L45.526|
                  |L45.190|
0000be  49ab              LDR      r1,|L45.876|
0000c0  6820              LDR      r0,[r4,#0]
0000c2  4288              CMP      r0,r1
0000c4  d115              BNE      |L45.242|
0000c6  48a7              LDR      r0,|L45.868|
0000c8  6800              LDR      r0,[r0,#0]
0000ca  f0000030          AND      r0,r0,#0x30
0000ce  b130              CBZ      r0,|L45.222|
0000d0  2810              CMP      r0,#0x10
0000d2  d008              BEQ      |L45.230|
0000d4  2820              CMP      r0,#0x20
0000d6  d004              BEQ      |L45.226|
0000d8  2830              CMP      r0,#0x30
0000da  d108              BNE      |L45.238|
0000dc  e005              B        |L45.234|
                  |L45.222|
0000de  2600              MOVS     r6,#0
0000e0  e006              B        |L45.240|
                  |L45.226|
0000e2  2602              MOVS     r6,#2
0000e4  e004              B        |L45.240|
                  |L45.230|
0000e6  2604              MOVS     r6,#4
0000e8  e002              B        |L45.240|
                  |L45.234|
0000ea  2608              MOVS     r6,#8
0000ec  e000              B        |L45.240|
                  |L45.238|
0000ee  bf00              NOP      
                  |L45.240|
0000f0  e08d              B        |L45.526|
                  |L45.242|
0000f2  499f              LDR      r1,|L45.880|
0000f4  6820              LDR      r0,[r4,#0]
0000f6  4288              CMP      r0,r1
0000f8  d115              BNE      |L45.294|
0000fa  489a              LDR      r0,|L45.868|
0000fc  6800              LDR      r0,[r0,#0]
0000fe  f00000c0          AND      r0,r0,#0xc0
000102  b130              CBZ      r0,|L45.274|
000104  2840              CMP      r0,#0x40
000106  d008              BEQ      |L45.282|
000108  2880              CMP      r0,#0x80
00010a  d004              BEQ      |L45.278|
00010c  28c0              CMP      r0,#0xc0
00010e  d108              BNE      |L45.290|
000110  e005              B        |L45.286|
                  |L45.274|
000112  2600              MOVS     r6,#0
000114  e006              B        |L45.292|
                  |L45.278|
000116  2602              MOVS     r6,#2
000118  e004              B        |L45.292|
                  |L45.282|
00011a  2604              MOVS     r6,#4
00011c  e002              B        |L45.292|
                  |L45.286|
00011e  2608              MOVS     r6,#8
000120  e000              B        |L45.292|
                  |L45.290|
000122  bf00              NOP      
                  |L45.292|
000124  e073              B        |L45.526|
                  |L45.294|
000126  4993              LDR      r1,|L45.884|
000128  6820              LDR      r0,[r4,#0]
00012a  4288              CMP      r0,r1
00012c  d118              BNE      |L45.352|
00012e  488d              LDR      r0,|L45.868|
000130  6800              LDR      r0,[r0,#0]
000132  f4007040          AND      r0,r0,#0x300
000136  b148              CBZ      r0,|L45.332|
000138  f5b07f80          CMP      r0,#0x100
00013c  d00a              BEQ      |L45.340|
00013e  f5b07f00          CMP      r0,#0x200
000142  d005              BEQ      |L45.336|
000144  f5b07f40          CMP      r0,#0x300
000148  d108              BNE      |L45.348|
00014a  e005              B        |L45.344|
                  |L45.332|
00014c  2600              MOVS     r6,#0
00014e  e006              B        |L45.350|
                  |L45.336|
000150  2602              MOVS     r6,#2
000152  e004              B        |L45.350|
                  |L45.340|
000154  2604              MOVS     r6,#4
000156  e002              B        |L45.350|
                  |L45.344|
000158  2608              MOVS     r6,#8
00015a  e000              B        |L45.350|
                  |L45.348|
00015c  bf00              NOP      
                  |L45.350|
00015e  e056              B        |L45.526|
                  |L45.352|
000160  4985              LDR      r1,|L45.888|
000162  6820              LDR      r0,[r4,#0]
000164  4288              CMP      r0,r1
000166  d118              BNE      |L45.410|
000168  487e              LDR      r0,|L45.868|
00016a  6800              LDR      r0,[r0,#0]
00016c  f4006040          AND      r0,r0,#0xc00
000170  b148              CBZ      r0,|L45.390|
000172  f5b06f80          CMP      r0,#0x400
000176  d00a              BEQ      |L45.398|
000178  f5b06f00          CMP      r0,#0x800
00017c  d005              BEQ      |L45.394|
00017e  f5b06f40          CMP      r0,#0xc00
000182  d108              BNE      |L45.406|
000184  e005              B        |L45.402|
                  |L45.390|
000186  2601              MOVS     r6,#1
000188  e006              B        |L45.408|
                  |L45.394|
00018a  2602              MOVS     r6,#2
00018c  e004              B        |L45.408|
                  |L45.398|
00018e  2604              MOVS     r6,#4
000190  e002              B        |L45.408|
                  |L45.402|
000192  2608              MOVS     r6,#8
000194  e000              B        |L45.408|
                  |L45.406|
000196  bf00              NOP      
                  |L45.408|
000198  e039              B        |L45.526|
                  |L45.410|
00019a  4978              LDR      r1,|L45.892|
00019c  6820              LDR      r0,[r4,#0]
00019e  4288              CMP      r0,r1
0001a0  d118              BNE      |L45.468|
0001a2  4870              LDR      r0,|L45.868|
0001a4  6800              LDR      r0,[r0,#0]
0001a6  f4005040          AND      r0,r0,#0x3000
0001aa  b148              CBZ      r0,|L45.448|
0001ac  f5b05f80          CMP      r0,#0x1000
0001b0  d00a              BEQ      |L45.456|
0001b2  f5b05f00          CMP      r0,#0x2000
0001b6  d005              BEQ      |L45.452|
0001b8  f5b05f40          CMP      r0,#0x3000
0001bc  d108              BNE      |L45.464|
0001be  e005              B        |L45.460|
                  |L45.448|
0001c0  2600              MOVS     r6,#0
0001c2  e006              B        |L45.466|
                  |L45.452|
0001c4  2602              MOVS     r6,#2
0001c6  e004              B        |L45.466|
                  |L45.456|
0001c8  2604              MOVS     r6,#4
0001ca  e002              B        |L45.466|
                  |L45.460|
0001cc  2608              MOVS     r6,#8
0001ce  e000              B        |L45.466|
                  |L45.464|
0001d0  bf00              NOP      
                  |L45.466|
0001d2  e01c              B        |L45.526|
                  |L45.468|
0001d4  496a              LDR      r1,|L45.896|
0001d6  6820              LDR      r0,[r4,#0]
0001d8  4288              CMP      r0,r1
0001da  d118              BNE      |L45.526|
0001dc  4861              LDR      r0,|L45.868|
0001de  6800              LDR      r0,[r0,#0]
0001e0  f4004040          AND      r0,r0,#0xc000
0001e4  b148              CBZ      r0,|L45.506|
0001e6  f5b04f80          CMP      r0,#0x4000
0001ea  d00a              BEQ      |L45.514|
0001ec  f5b04f00          CMP      r0,#0x8000
0001f0  d005              BEQ      |L45.510|
0001f2  f5b04f40          CMP      r0,#0xc000
0001f6  d108              BNE      |L45.522|
0001f8  e005              B        |L45.518|
                  |L45.506|
0001fa  2600              MOVS     r6,#0
0001fc  e006              B        |L45.524|
                  |L45.510|
0001fe  2602              MOVS     r6,#2
000200  e004              B        |L45.524|
                  |L45.514|
000202  2604              MOVS     r6,#4
000204  e002              B        |L45.524|
                  |L45.518|
000206  2608              MOVS     r6,#8
000208  e000              B        |L45.524|
                  |L45.522|
00020a  bf00              NOP      
                  |L45.524|
00020c  bf00              NOP      
                  |L45.526|
00020e  bf00              NOP      
;;;1869   
;;;1870     /* Check UART Over Sampling to set Baud Rate Register */
;;;1871     if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
000210  69e0              LDR      r0,[r4,#0x1c]
000212  f5b04f00          CMP      r0,#0x8000
000216  d152              BNE      |L45.702|
;;;1872     {
;;;1873       switch (clocksource)
000218  2e04              CMP      r6,#4
00021a  d02b              BEQ      |L45.628|
00021c  dc05              BGT      |L45.554|
00021e  b14e              CBZ      r6,|L45.564|
000220  2e01              CMP      r6,#1
000222  d012              BEQ      |L45.586|
000224  2e02              CMP      r6,#2
000226  d13b              BNE      |L45.672|
000228  e01a              B        |L45.608|
                  |L45.554|
00022a  2e08              CMP      r6,#8
00022c  d02d              BEQ      |L45.650|
00022e  2e10              CMP      r6,#0x10
000230  d136              BNE      |L45.672|
000232  e036              B        |L45.674|
                  |L45.564|
;;;1874       {
;;;1875       case UART_CLOCKSOURCE_PCLK1:
;;;1876           usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
000234  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
000238  0040              LSLS     r0,r0,#1
00023a  6861              LDR      r1,[r4,#4]
00023c  eb000051          ADD      r0,r0,r1,LSR #1
000240  fbb0f0f1          UDIV     r0,r0,r1
000244  fa1ff880          UXTH     r8,r0
;;;1877         break;
000248  e02e              B        |L45.680|
                  |L45.586|
;;;1878       case UART_CLOCKSOURCE_PCLK2:
;;;1879           usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
00024a  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
00024e  0040              LSLS     r0,r0,#1
000250  6861              LDR      r1,[r4,#4]
000252  eb000051          ADD      r0,r0,r1,LSR #1
000256  fbb0f0f1          UDIV     r0,r0,r1
00025a  fa1ff880          UXTH     r8,r0
;;;1880         break;
00025e  e023              B        |L45.680|
                  |L45.608|
;;;1881       case UART_CLOCKSOURCE_HSI:
;;;1882           usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate));
000260  4948              LDR      r1,|L45.900|
000262  6860              LDR      r0,[r4,#4]
000264  eb010050          ADD      r0,r1,r0,LSR #1
000268  6861              LDR      r1,[r4,#4]
00026a  fbb0f0f1          UDIV     r0,r0,r1
00026e  fa1ff880          UXTH     r8,r0
;;;1883         break;
000272  e019              B        |L45.680|
                  |L45.628|
;;;1884       case UART_CLOCKSOURCE_SYSCLK:
;;;1885           usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
000274  f7fffffe          BL       HAL_RCC_GetSysClockFreq
000278  0040              LSLS     r0,r0,#1
00027a  6861              LDR      r1,[r4,#4]
00027c  eb000051          ADD      r0,r0,r1,LSR #1
000280  fbb0f0f1          UDIV     r0,r0,r1
000284  fa1ff880          UXTH     r8,r0
;;;1886         break;
000288  e00e              B        |L45.680|
                  |L45.650|
;;;1887       case UART_CLOCKSOURCE_LSE:
;;;1888           usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
00028a  f44f3180          MOV      r1,#0x10000
00028e  6860              LDR      r0,[r4,#4]
000290  eb010050          ADD      r0,r1,r0,LSR #1
000294  6861              LDR      r1,[r4,#4]
000296  fbb0f0f1          UDIV     r0,r0,r1
00029a  fa1ff880          UXTH     r8,r0
;;;1889         break;
00029e  e003              B        |L45.680|
                  |L45.672|
;;;1890         case UART_CLOCKSOURCE_UNDEFINED:
0002a0  bf00              NOP      
                  |L45.674|
;;;1891       default:
;;;1892           ret = HAL_ERROR;
0002a2  f04f0901          MOV      r9,#1
;;;1893         break;
0002a6  bf00              NOP      
                  |L45.680|
0002a8  bf00              NOP                            ;1877
;;;1894       }
;;;1895   
;;;1896       brrtemp = usartdiv & 0xFFF0U;
0002aa  f64f70f0          MOV      r0,#0xfff0
0002ae  ea080700          AND      r7,r8,r0
;;;1897       brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
0002b2  f3c80042          UBFX     r0,r8,#1,#3
0002b6  4307              ORRS     r7,r7,r0
;;;1898       huart->Instance->BRR = brrtemp;
0002b8  6820              LDR      r0,[r4,#0]
0002ba  60c7              STR      r7,[r0,#0xc]
0002bc  e04a              B        |L45.852|
                  |L45.702|
;;;1899     }
;;;1900     else
;;;1901     {
;;;1902       switch (clocksource)
0002be  2e04              CMP      r6,#4
0002c0  d02c              BEQ      |L45.796|
0002c2  dc05              BGT      |L45.720|
0002c4  b14e              CBZ      r6,|L45.730|
0002c6  2e01              CMP      r6,#1
0002c8  d012              BEQ      |L45.752|
0002ca  2e02              CMP      r6,#2
0002cc  d13d              BNE      |L45.842|
0002ce  e01a              B        |L45.774|
                  |L45.720|
0002d0  2e08              CMP      r6,#8
0002d2  d02e              BEQ      |L45.818|
0002d4  2e10              CMP      r6,#0x10
0002d6  d138              BNE      |L45.842|
0002d8  e038              B        |L45.844|
                  |L45.730|
;;;1903       {
;;;1904       case UART_CLOCKSOURCE_PCLK1:
;;;1905           huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
0002da  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
0002de  6861              LDR      r1,[r4,#4]
0002e0  eb000051          ADD      r0,r0,r1,LSR #1
0002e4  fbb0f0f1          UDIV     r0,r0,r1
0002e8  b280              UXTH     r0,r0
0002ea  6821              LDR      r1,[r4,#0]
0002ec  60c8              STR      r0,[r1,#0xc]
;;;1906         break;
0002ee  e030              B        |L45.850|
                  |L45.752|
;;;1907       case UART_CLOCKSOURCE_PCLK2:
;;;1908           huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
0002f0  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
0002f4  6861              LDR      r1,[r4,#4]
0002f6  eb000051          ADD      r0,r0,r1,LSR #1
0002fa  fbb0f0f1          UDIV     r0,r0,r1
0002fe  b280              UXTH     r0,r0
000300  6821              LDR      r1,[r4,#0]
000302  60c8              STR      r0,[r1,#0xc]
;;;1909         break;
000304  e025              B        |L45.850|
                  |L45.774|
;;;1910       case UART_CLOCKSOURCE_HSI:
;;;1911           huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate));
000306  4920              LDR      r1,|L45.904|
000308  6860              LDR      r0,[r4,#4]
00030a  eb010050          ADD      r0,r1,r0,LSR #1
00030e  6861              LDR      r1,[r4,#4]
000310  fbb0f0f1          UDIV     r0,r0,r1
000314  b280              UXTH     r0,r0
000316  6821              LDR      r1,[r4,#0]
000318  60c8              STR      r0,[r1,#0xc]
;;;1912         break;
00031a  e01a              B        |L45.850|
                  |L45.796|
;;;1913       case UART_CLOCKSOURCE_SYSCLK:
;;;1914           huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
00031c  f7fffffe          BL       HAL_RCC_GetSysClockFreq
000320  6861              LDR      r1,[r4,#4]
000322  eb000051          ADD      r0,r0,r1,LSR #1
000326  fbb0f0f1          UDIV     r0,r0,r1
00032a  b280              UXTH     r0,r0
00032c  6821              LDR      r1,[r4,#0]
00032e  60c8              STR      r0,[r1,#0xc]
;;;1915         break;
000330  e00f              B        |L45.850|
                  |L45.818|
;;;1916       case UART_CLOCKSOURCE_LSE:
;;;1917           huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
000332  f44f4100          MOV      r1,#0x8000
000336  6860              LDR      r0,[r4,#4]
000338  eb010050          ADD      r0,r1,r0,LSR #1
00033c  6861              LDR      r1,[r4,#4]
00033e  fbb0f0f1          UDIV     r0,r0,r1
000342  b280              UXTH     r0,r0
000344  6821              LDR      r1,[r4,#0]
000346  60c8              STR      r0,[r1,#0xc]
;;;1918         break;
000348  e003              B        |L45.850|
                  |L45.842|
;;;1919         case UART_CLOCKSOURCE_UNDEFINED:
00034a  bf00              NOP      
                  |L45.844|
;;;1920       default:
;;;1921           ret = HAL_ERROR;
00034c  f04f0901          MOV      r9,#1
;;;1922         break;
000350  bf00              NOP      
                  |L45.850|
000352  bf00              NOP                            ;1906
                  |L45.852|
;;;1923       }
;;;1924     }
;;;1925   
;;;1926     return ret;
000354  4648              MOV      r0,r9
;;;1927   
;;;1928   }
000356  e8bd87f0          POP      {r4-r10,pc}
;;;1929   
                          ENDP

00035a  0000              DCW      0x0000
                  |L45.860|
                          DCD      0xefff69f3
                  |L45.864|
                          DCD      0x40011000
                  |L45.868|
                          DCD      0x40023890
                  |L45.872|
                          DCD      0x40004400
                  |L45.876|
                          DCD      0x40004800
                  |L45.880|
                          DCD      0x40004c00
                  |L45.884|
                          DCD      0x40005000
                  |L45.888|
                          DCD      0x40011400
                  |L45.892|
                          DCD      0x40007800
                  |L45.896|
                          DCD      0x40007c00
                  |L45.900|
                          DCD      0x01e84800
                  |L45.904|
                          DCD      0x00f42400

                          AREA ||i.UART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  UART_Transmit_IT PROC
;;;1564     */
;;;1565   static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;1566   {
;;;1567     uint16_t* tmp;
;;;1568   
;;;1569     /* Check that a Tx process is ongoing */
;;;1570     if (huart->gState == HAL_UART_STATE_BUSY_TX)
000002  6ec8              LDR      r0,[r1,#0x6c]
000004  2821              CMP      r0,#0x21
000006  d12d              BNE      |L46.100|
;;;1571     {
;;;1572   
;;;1573       if(huart->TxXferCount == 0U)
000008  f8b10052          LDRH     r0,[r1,#0x52]
00000c  b968              CBNZ     r0,|L46.42|
;;;1574       {
;;;1575         /* Disable the UART Transmit Data Register Empty Interrupt */
;;;1576         CLEAR_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
00000e  6808              LDR      r0,[r1,#0]
000010  6800              LDR      r0,[r0,#0]
000012  f0200080          BIC      r0,r0,#0x80
000016  680b              LDR      r3,[r1,#0]
000018  6018              STR      r0,[r3,#0]
;;;1577   
;;;1578         /* Enable the UART Transmit Complete Interrupt */
;;;1579         SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
00001a  6808              LDR      r0,[r1,#0]
00001c  6800              LDR      r0,[r0,#0]
00001e  f0400040          ORR      r0,r0,#0x40
000022  680b              LDR      r3,[r1,#0]
000024  6018              STR      r0,[r3,#0]
;;;1580   
;;;1581         return HAL_OK;
000026  2000              MOVS     r0,#0
                  |L46.40|
;;;1582       }
;;;1583       else
;;;1584       {
;;;1585         if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;1586         {
;;;1587           tmp = (uint16_t*) huart->pTxBuffPtr;
;;;1588           huart->Instance->TDR = (*tmp & (uint16_t)0x01FFU);
;;;1589           huart->pTxBuffPtr += 2U;
;;;1590         }
;;;1591         else
;;;1592         {
;;;1593           huart->Instance->TDR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0xFFU);
;;;1594         }
;;;1595   
;;;1596         huart->TxXferCount--;
;;;1597   
;;;1598         return HAL_OK;
;;;1599       }
;;;1600     }
;;;1601     else
;;;1602     {
;;;1603       return HAL_BUSY;
;;;1604     }
;;;1605   }
000028  4770              BX       lr
                  |L46.42|
00002a  6888              LDR      r0,[r1,#8]            ;1585
00002c  f5b05f80          CMP      r0,#0x1000            ;1585
000030  d10b              BNE      |L46.74|
000032  6908              LDR      r0,[r1,#0x10]         ;1585
000034  b948              CBNZ     r0,|L46.74|
000036  6cca              LDR      r2,[r1,#0x4c]         ;1587
000038  8810              LDRH     r0,[r2,#0]            ;1588
00003a  f3c00008          UBFX     r0,r0,#0,#9           ;1588
00003e  680b              LDR      r3,[r1,#0]            ;1588
000040  6298              STR      r0,[r3,#0x28]         ;1588
000042  6cc8              LDR      r0,[r1,#0x4c]         ;1589
000044  1c80              ADDS     r0,r0,#2              ;1589
000046  64c8              STR      r0,[r1,#0x4c]         ;1589
000048  e005              B        |L46.86|
                  |L46.74|
00004a  6ccb              LDR      r3,[r1,#0x4c]         ;1593
00004c  1c58              ADDS     r0,r3,#1              ;1593
00004e  64c8              STR      r0,[r1,#0x4c]         ;1593
000050  7818              LDRB     r0,[r3,#0]            ;1593
000052  680b              LDR      r3,[r1,#0]            ;1593
000054  6298              STR      r0,[r3,#0x28]         ;1593
                  |L46.86|
000056  f8b10052          LDRH     r0,[r1,#0x52]         ;1596
00005a  1e40              SUBS     r0,r0,#1              ;1596
00005c  f8a10052          STRH     r0,[r1,#0x52]         ;1596
000060  2000              MOVS     r0,#0                 ;1598
000062  e7e1              B        |L46.40|
                  |L46.100|
000064  2002              MOVS     r0,#2                 ;1603
000066  e7df              B        |L46.40|
;;;1606   
                          ENDP


                          AREA ||i.UART_WaitOnFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  UART_WaitOnFlagUntilTimeout PROC
;;;1334     */
;;;1335   HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1336   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  9e06              LDR      r6,[sp,#0x18]
;;;1337     /* Wait until flag is set */
;;;1338     while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
00000e  e01e              B        |L47.78|
                  |L47.16|
;;;1339     {
;;;1340       /* Check for the Timeout */
;;;1341       if(Timeout != HAL_MAX_DELAY)
000010  1c70              ADDS     r0,r6,#1
000012  b1e0              CBZ      r0,|L47.78|
;;;1342       {
;;;1343         if((Timeout == 0U)||((HAL_GetTick()-Tickstart) >=  Timeout))
000014  b12e              CBZ      r6,|L47.34|
000016  f7fffffe          BL       HAL_GetTick
00001a  eba00008          SUB      r0,r0,r8
00001e  42b0              CMP      r0,r6
000020  d315              BCC      |L47.78|
                  |L47.34|
;;;1344         {
;;;1345           /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
;;;1346           CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
000022  6820              LDR      r0,[r4,#0]
000024  6800              LDR      r0,[r0,#0]
000026  f42070d0          BIC      r0,r0,#0x1a0
00002a  6821              LDR      r1,[r4,#0]
00002c  6008              STR      r0,[r1,#0]
;;;1347           CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00002e  6820              LDR      r0,[r4,#0]
000030  6880              LDR      r0,[r0,#8]
000032  f0200001          BIC      r0,r0,#1
000036  6821              LDR      r1,[r4,#0]
000038  6088              STR      r0,[r1,#8]
;;;1348   
;;;1349           huart->gState = HAL_UART_STATE_READY;
00003a  2020              MOVS     r0,#0x20
00003c  66e0              STR      r0,[r4,#0x6c]
;;;1350           huart->RxState = HAL_UART_STATE_READY;
00003e  6720              STR      r0,[r4,#0x70]
;;;1351   
;;;1352           /* Process Unlocked */
;;;1353           __HAL_UNLOCK(huart);
000040  bf00              NOP      
000042  2000              MOVS     r0,#0
000044  66a0              STR      r0,[r4,#0x68]
000046  bf00              NOP      
;;;1354           return HAL_TIMEOUT;
000048  2003              MOVS     r0,#3
                  |L47.74|
;;;1355         }
;;;1356       }
;;;1357     }
;;;1358     return HAL_OK;
;;;1359   }
00004a  e8bd81f0          POP      {r4-r8,pc}
                  |L47.78|
00004e  6820              LDR      r0,[r4,#0]            ;1338
000050  69c0              LDR      r0,[r0,#0x1c]         ;1338
000052  4028              ANDS     r0,r0,r5              ;1338
000054  42a8              CMP      r0,r5                 ;1338
000056  d101              BNE      |L47.92|
000058  2001              MOVS     r0,#1                 ;1338
00005a  e000              B        |L47.94|
                  |L47.92|
00005c  2000              MOVS     r0,#0                 ;1338
                  |L47.94|
00005e  42b8              CMP      r0,r7                 ;1338
000060  d0d6              BEQ      |L47.16|
000062  2000              MOVS     r0,#0                 ;1358
000064  e7f1              B        |L47.74|
;;;1360   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F7_V1.11.0\\Drivers\\STM32F7xx_HAL_Driver\\Src\\stm32f7xx_hal_uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f7xx_hal_uart_c_d497114f____REV16|
#line 464 "D:\\Program_Files_x86\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.1.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___20_stm32f7xx_hal_uart_c_d497114f____REV16| PROC
#line 465

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f7xx_hal_uart_c_d497114f____REVSH|
#line 479
|__asm___20_stm32f7xx_hal_uart_c_d497114f____REVSH| PROC
#line 480

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f7xx_hal_uart_c_d497114f____RRX|
#line 666
|__asm___20_stm32f7xx_hal_uart_c_d497114f____RRX| PROC
#line 667

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
