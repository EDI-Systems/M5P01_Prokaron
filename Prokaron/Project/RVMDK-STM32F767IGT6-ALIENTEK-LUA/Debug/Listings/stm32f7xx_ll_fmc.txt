; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f7xx_ll_fmc.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f7xx_ll_fmc.d --cpu=Cortex-M7 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Inc -I.\Source -I.\Drivers -I..\..\..\M6P1(L)_Lua\lua -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6-ALIENTEK-LUA\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER -Dlua_writestring=RMP_lua_writestring -Dlua_writeline=RMP_lua_writeline --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f7xx_ll_fmc.crf ..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_ll_fmc.c]
                          THUMB

                          AREA ||i.FMC_NAND_AttributeSpace_Timing_Init||, CODE, READONLY, ALIGN=1

                  FMC_NAND_AttributeSpace_Timing_Init PROC
;;;554      */
;;;555    HAL_StatusTypeDef FMC_NAND_AttributeSpace_Timing_Init(FMC_NAND_TypeDef *Device, FMC_NAND_PCC_TimingTypeDef *Timing, uint32_t Bank)
000000  b530              PUSH     {r4,r5,lr}
;;;556    {
000002  4603              MOV      r3,r0
000004  4614              MOV      r4,r2
;;;557      uint32_t tmpr = 0;  
000006  2200              MOVS     r2,#0
;;;558      
;;;559      /* Check the parameters */ 
;;;560      assert_param(IS_FMC_NAND_DEVICE(Device)); 
;;;561      assert_param(IS_FMC_SETUP_TIME(Timing->SetupTime));
;;;562      assert_param(IS_FMC_WAIT_TIME(Timing->WaitSetupTime));
;;;563      assert_param(IS_FMC_HOLD_TIME(Timing->HoldSetupTime));
;;;564      assert_param(IS_FMC_HIZ_TIME(Timing->HiZSetupTime));
;;;565      assert_param(IS_FMC_NAND_BANK(Bank));
;;;566      
;;;567      /* Get the NAND bank 3 register value */
;;;568      tmpr = Device->PATT;
000008  68da              LDR      r2,[r3,#0xc]
;;;569    
;;;570      /* Clear ATTSETx, ATTWAITx, ATTHOLDx and ATTHIZx bits */
;;;571      tmpr &= ((uint32_t)~(FMC_PATT_ATTSET3  | FMC_PATT_ATTWAIT3 | FMC_PATT_ATTHOLD3 | \
00000a  2200              MOVS     r2,#0
;;;572                           FMC_PATT_ATTHIZ3));
;;;573      /* Set FMC_NAND device timing parameters */
;;;574      tmpr |= (uint32_t)(Timing->SetupTime                  |\
00000c  e9d10500          LDRD     r0,r5,[r1,#0]
000010  ea402005          ORR      r0,r0,r5,LSL #8
000014  890d              LDRH     r5,[r1,#8]
000016  ea404005          ORR      r0,r0,r5,LSL #16
00001a  7b0d              LDRB     r5,[r1,#0xc]
00001c  ea406005          ORR      r0,r0,r5,LSL #24
000020  4302              ORRS     r2,r2,r0
;;;575                       ((Timing->WaitSetupTime) << 8)     |\
;;;576                       ((Timing->HoldSetupTime) << 16)    |\
;;;577                       ((Timing->HiZSetupTime) << 24));
;;;578                           
;;;579        /* NAND bank 3 registers configuration */
;;;580        Device->PATT = tmpr;
000022  60da              STR      r2,[r3,#0xc]
;;;581      
;;;582      return HAL_OK;
000024  2000              MOVS     r0,#0
;;;583    }
000026  bd30              POP      {r4,r5,pc}
;;;584    
                          ENDP


                          AREA ||i.FMC_NAND_CommonSpace_Timing_Init||, CODE, READONLY, ALIGN=1

                  FMC_NAND_CommonSpace_Timing_Init PROC
;;;515      */
;;;516    HAL_StatusTypeDef FMC_NAND_CommonSpace_Timing_Init(FMC_NAND_TypeDef *Device, FMC_NAND_PCC_TimingTypeDef *Timing, uint32_t Bank)
000000  b530              PUSH     {r4,r5,lr}
;;;517    {
000002  4603              MOV      r3,r0
000004  4614              MOV      r4,r2
;;;518      uint32_t tmpr = 0;  
000006  2200              MOVS     r2,#0
;;;519      
;;;520      /* Check the parameters */
;;;521      assert_param(IS_FMC_NAND_DEVICE(Device));
;;;522      assert_param(IS_FMC_SETUP_TIME(Timing->SetupTime));
;;;523      assert_param(IS_FMC_WAIT_TIME(Timing->WaitSetupTime));
;;;524      assert_param(IS_FMC_HOLD_TIME(Timing->HoldSetupTime));
;;;525      assert_param(IS_FMC_HIZ_TIME(Timing->HiZSetupTime));
;;;526      assert_param(IS_FMC_NAND_BANK(Bank));
;;;527      
;;;528      /* Get the NAND bank 3 register value */
;;;529      tmpr = Device->PMEM;
000008  689a              LDR      r2,[r3,#8]
;;;530    
;;;531      /* Clear MEMSETx, MEMWAITx, MEMHOLDx and MEMHIZx bits */
;;;532      tmpr &= ((uint32_t)~(FMC_PMEM_MEMSET3  | FMC_PMEM_MEMWAIT3 | FMC_PMEM_MEMHOLD3 | \
00000a  2200              MOVS     r2,#0
;;;533                           FMC_PMEM_MEMHIZ3)); 
;;;534      /* Set FMC_NAND device timing parameters */
;;;535      tmpr |= (uint32_t)(Timing->SetupTime                  |\
00000c  e9d10500          LDRD     r0,r5,[r1,#0]
000010  ea402005          ORR      r0,r0,r5,LSL #8
000014  890d              LDRH     r5,[r1,#8]
000016  ea404005          ORR      r0,r0,r5,LSL #16
00001a  7b0d              LDRB     r5,[r1,#0xc]
00001c  ea406005          ORR      r0,r0,r5,LSL #24
000020  4302              ORRS     r2,r2,r0
;;;536                           ((Timing->WaitSetupTime) << 8)     |\
;;;537                           ((Timing->HoldSetupTime) << 16)    |\
;;;538                           ((Timing->HiZSetupTime) << 24)
;;;539                           );
;;;540                                
;;;541        /* NAND bank 3 registers configuration */
;;;542        Device->PMEM = tmpr;
000022  609a              STR      r2,[r3,#8]
;;;543      
;;;544      return HAL_OK;  
000024  2000              MOVS     r0,#0
;;;545    }
000026  bd30              POP      {r4,r5,pc}
;;;546    
                          ENDP


                          AREA ||i.FMC_NAND_DeInit||, CODE, READONLY, ALIGN=1

                  FMC_NAND_DeInit PROC
;;;590      */
;;;591    HAL_StatusTypeDef FMC_NAND_DeInit(FMC_NAND_TypeDef *Device, uint32_t Bank)
000000  4602              MOV      r2,r0
;;;592    {
;;;593      /* Check the parameters */ 
;;;594      assert_param(IS_FMC_NAND_DEVICE(Device)); 
;;;595      assert_param(IS_FMC_NAND_BANK(Bank));
;;;596          
;;;597      /* Disable the NAND Bank */
;;;598      __FMC_NAND_DISABLE(Device);
000002  6810              LDR      r0,[r2,#0]
000004  f0200004          BIC      r0,r0,#4
000008  6010              STR      r0,[r2,#0]
;;;599     
;;;600        /* Set the FMC_NAND_BANK3 registers to their reset values */
;;;601        Device->PCR  = 0x00000018U;
00000a  2018              MOVS     r0,#0x18
00000c  6010              STR      r0,[r2,#0]
;;;602        Device->SR   = 0x00000040U;
00000e  2040              MOVS     r0,#0x40
000010  6050              STR      r0,[r2,#4]
;;;603        Device->PMEM = 0xFCFCFCFCU;
000012  f04f30fc          MOV      r0,#0xfcfcfcfc
000016  6090              STR      r0,[r2,#8]
;;;604        Device->PATT = 0xFCFCFCFCU; 
000018  60d0              STR      r0,[r2,#0xc]
;;;605      
;;;606      return HAL_OK;
00001a  2000              MOVS     r0,#0
;;;607    }
00001c  4770              BX       lr
;;;608    
                          ENDP


                          AREA ||i.FMC_NAND_ECC_Disable||, CODE, READONLY, ALIGN=1

                  FMC_NAND_ECC_Disable PROC
;;;653      */  
;;;654    HAL_StatusTypeDef FMC_NAND_ECC_Disable(FMC_NAND_TypeDef *Device, uint32_t Bank)  
000000  4602              MOV      r2,r0
;;;655    {  
;;;656      /* Check the parameters */ 
;;;657      assert_param(IS_FMC_NAND_DEVICE(Device)); 
;;;658      assert_param(IS_FMC_NAND_BANK(Bank));
;;;659        
;;;660      /* Disable ECC feature */
;;;661        Device->PCR &= ~FMC_PCR_ECCEN;
000002  6810              LDR      r0,[r2,#0]
000004  f0200040          BIC      r0,r0,#0x40
000008  6010              STR      r0,[r2,#0]
;;;662    
;;;663      return HAL_OK;  
00000a  2000              MOVS     r0,#0
;;;664    }
00000c  4770              BX       lr
;;;665    
                          ENDP


                          AREA ||i.FMC_NAND_ECC_Enable||, CODE, READONLY, ALIGN=1

                  FMC_NAND_ECC_Enable PROC
;;;634      */    
;;;635    HAL_StatusTypeDef FMC_NAND_ECC_Enable(FMC_NAND_TypeDef *Device, uint32_t Bank)
000000  4602              MOV      r2,r0
;;;636    {
;;;637      /* Check the parameters */ 
;;;638      assert_param(IS_FMC_NAND_DEVICE(Device)); 
;;;639      assert_param(IS_FMC_NAND_BANK(Bank));
;;;640        
;;;641      /* Enable ECC feature */
;;;642        Device->PCR |= FMC_PCR_ECCEN;
000002  6810              LDR      r0,[r2,#0]
000004  f0400040          ORR      r0,r0,#0x40
000008  6010              STR      r0,[r2,#0]
;;;643      
;;;644      return HAL_OK;  
00000a  2000              MOVS     r0,#0
;;;645    }
00000c  4770              BX       lr
;;;646    
                          ENDP


                          AREA ||i.FMC_NAND_GetECC||, CODE, READONLY, ALIGN=1

                  FMC_NAND_GetECC PROC
;;;673      */
;;;674    HAL_StatusTypeDef FMC_NAND_GetECC(FMC_NAND_TypeDef *Device, uint32_t *ECCval, uint32_t Bank, uint32_t Timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;675    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4690              MOV      r8,r2
00000a  461c              MOV      r4,r3
;;;676      uint32_t tickstart = 0;
00000c  2700              MOVS     r7,#0
;;;677    
;;;678      /* Check the parameters */ 
;;;679      assert_param(IS_FMC_NAND_DEVICE(Device)); 
;;;680      assert_param(IS_FMC_NAND_BANK(Bank));
;;;681    
;;;682      /* Get tick */ 
;;;683      tickstart = HAL_GetTick();
00000e  f7fffffe          BL       HAL_GetTick
000012  4607              MOV      r7,r0
;;;684    
;;;685      /* Wait until FIFO is empty */
;;;686      while(__FMC_NAND_GET_FLAG(Device, Bank, FMC_FLAG_FEMPT) == RESET)
000014  e00a              B        |L6.44|
                  |L6.22|
;;;687      {
;;;688        /* Check for the Timeout */
;;;689        if(Timeout != HAL_MAX_DELAY)
000016  1c60              ADDS     r0,r4,#1
000018  b140              CBZ      r0,|L6.44|
;;;690        {
;;;691          if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
00001a  b124              CBZ      r4,|L6.38|
00001c  f7fffffe          BL       HAL_GetTick
000020  1bc0              SUBS     r0,r0,r7
000022  42a0              CMP      r0,r4
000024  d902              BLS      |L6.44|
                  |L6.38|
;;;692          {
;;;693            return HAL_TIMEOUT;
000026  2003              MOVS     r0,#3
                  |L6.40|
;;;694          }
;;;695        }  
;;;696      }
;;;697     
;;;698      /* Get the ECCR register value */
;;;699      *ECCval = (uint32_t)Device->ECCR;
;;;700    
;;;701      return HAL_OK;  
;;;702    }
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L6.44|
00002c  6868              LDR      r0,[r5,#4]            ;686
00002e  f3c01080          UBFX     r0,r0,#6,#1           ;686
000032  2800              CMP      r0,#0                 ;686
000034  d0ef              BEQ      |L6.22|
000036  6968              LDR      r0,[r5,#0x14]         ;699
000038  6030              STR      r0,[r6,#0]            ;699
00003a  2000              MOVS     r0,#0                 ;701
00003c  e7f4              B        |L6.40|
;;;703    
                          ENDP


                          AREA ||i.FMC_NAND_Init||, CODE, READONLY, ALIGN=2

                  FMC_NAND_Init PROC
;;;470      */
;;;471    HAL_StatusTypeDef FMC_NAND_Init(FMC_NAND_TypeDef *Device, FMC_NAND_InitTypeDef *Init)
000000  b510              PUSH     {r4,lr}
;;;472    {
000002  4602              MOV      r2,r0
;;;473      uint32_t tmpr  = 0; 
000004  2300              MOVS     r3,#0
;;;474        
;;;475      /* Check the parameters */
;;;476      assert_param(IS_FMC_NAND_DEVICE(Device));
;;;477      assert_param(IS_FMC_NAND_BANK(Init->NandBank));
;;;478      assert_param(IS_FMC_WAIT_FEATURE(Init->Waitfeature));
;;;479      assert_param(IS_FMC_NAND_MEMORY_WIDTH(Init->MemoryDataWidth));
;;;480      assert_param(IS_FMC_ECC_STATE(Init->EccComputation));
;;;481      assert_param(IS_FMC_ECCPAGE_SIZE(Init->ECCPageSize));
;;;482      assert_param(IS_FMC_TCLR_TIME(Init->TCLRSetupTime));
;;;483      assert_param(IS_FMC_TAR_TIME(Init->TARSetupTime));   
;;;484    
;;;485      /* Get the NAND bank 3 register value */
;;;486      tmpr = Device->PCR;
000006  6813              LDR      r3,[r2,#0]
;;;487    
;;;488      /* Clear PWAITEN, PBKEN, PTYP, PWID, ECCEN, TCLR, TAR and ECCPS bits */
;;;489      tmpr &= ((uint32_t)~(FMC_PCR_PWAITEN  | FMC_PCR_PBKEN | FMC_PCR_PTYP | \
000008  480a              LDR      r0,|L7.52|
00000a  4003              ANDS     r3,r3,r0
;;;490                           FMC_PCR_PWID | FMC_PCR_ECCEN | FMC_PCR_TCLR | \
;;;491                           FMC_PCR_TAR | FMC_PCR_ECCPS));  
;;;492      /* Set NAND device control parameters */
;;;493      tmpr |= (uint32_t)(Init->Waitfeature                |\
00000c  6848              LDR      r0,[r1,#4]
00000e  f0400008          ORR      r0,r0,#8
000012  688c              LDR      r4,[r1,#8]
000014  4320              ORRS     r0,r0,r4
000016  68cc              LDR      r4,[r1,#0xc]
000018  4320              ORRS     r0,r0,r4
00001a  690c              LDR      r4,[r1,#0x10]
00001c  4320              ORRS     r0,r0,r4
00001e  694c              LDR      r4,[r1,#0x14]
000020  ea402044          ORR      r0,r0,r4,LSL #9
000024  698c              LDR      r4,[r1,#0x18]
000026  ea403044          ORR      r0,r0,r4,LSL #13
00002a  4303              ORRS     r3,r3,r0
;;;494                          FMC_PCR_MEMORY_TYPE_NAND         |\
;;;495                          Init->MemoryDataWidth            |\
;;;496                          Init->EccComputation             |\
;;;497                          Init->ECCPageSize                |\
;;;498                          ((Init->TCLRSetupTime) << 9)     |\
;;;499                          ((Init->TARSetupTime) << 13));   
;;;500      
;;;501        /* NAND bank 3 registers configuration */
;;;502        Device->PCR  = tmpr;
00002c  6013              STR      r3,[r2,#0]
;;;503      
;;;504      return HAL_OK;
00002e  2000              MOVS     r0,#0
;;;505    
;;;506    }
000030  bd10              POP      {r4,pc}
;;;507    
                          ENDP

000032  0000              DCW      0x0000
                  |L7.52|
                          DCD      0xfff00181

                          AREA ||i.FMC_NORSRAM_DeInit||, CODE, READONLY, ALIGN=1

                  FMC_NORSRAM_DeInit PROC
;;;224      */
;;;225    HAL_StatusTypeDef FMC_NORSRAM_DeInit(FMC_NORSRAM_TypeDef *Device, FMC_NORSRAM_EXTENDED_TypeDef *ExDevice, uint32_t Bank)
000000  b510              PUSH     {r4,lr}
;;;226    {
000002  4603              MOV      r3,r0
;;;227      /* Check the parameters */
;;;228      assert_param(IS_FMC_NORSRAM_DEVICE(Device));
;;;229      assert_param(IS_FMC_NORSRAM_EXTENDED_DEVICE(ExDevice));
;;;230      assert_param(IS_FMC_NORSRAM_BANK(Bank));
;;;231      
;;;232      /* Disable the FMC_NORSRAM device */
;;;233      __FMC_NORSRAM_DISABLE(Device, Bank);
000004  f8530022          LDR      r0,[r3,r2,LSL #2]
000008  f0200001          BIC      r0,r0,#1
00000c  f8430022          STR      r0,[r3,r2,LSL #2]
;;;234      
;;;235      /* De-initialize the FMC_NORSRAM device */
;;;236      /* FMC_NORSRAM_BANK1 */
;;;237      if(Bank == FMC_NORSRAM_BANK1)
000010  b922              CBNZ     r2,|L8.28|
;;;238      {
;;;239        Device->BTCR[Bank] = 0x000030DB;    
000012  f24300db          MOV      r0,#0x30db
000016  f8430022          STR      r0,[r3,r2,LSL #2]
00001a  e003              B        |L8.36|
                  |L8.28|
;;;240      }
;;;241      /* FMC_NORSRAM_BANK2, FMC_NORSRAM_BANK3 or FMC_NORSRAM_BANK4 */
;;;242      else
;;;243      {   
;;;244        Device->BTCR[Bank] = 0x000030D2; 
00001c  f24300d2          MOV      r0,#0x30d2
000020  f8430022          STR      r0,[r3,r2,LSL #2]
                  |L8.36|
;;;245      }
;;;246      
;;;247      Device->BTCR[Bank + 1] = 0x0FFFFFFF;
000024  f06f4470          MVN      r4,#0xf0000000
000028  1c50              ADDS     r0,r2,#1
00002a  f8434020          STR      r4,[r3,r0,LSL #2]
;;;248      ExDevice->BWTR[Bank]   = 0x0FFFFFFF;
00002e  4620              MOV      r0,r4
000030  f8410022          STR      r0,[r1,r2,LSL #2]
;;;249       
;;;250      return HAL_OK;
000034  2000              MOVS     r0,#0
;;;251    }
000036  bd10              POP      {r4,pc}
;;;252    
                          ENDP


                          AREA ||i.FMC_NORSRAM_Extended_Timing_Init||, CODE, READONLY, ALIGN=2

                  FMC_NORSRAM_Extended_Timing_Init PROC
;;;315      */
;;;316    HAL_StatusTypeDef  FMC_NORSRAM_Extended_Timing_Init(FMC_NORSRAM_EXTENDED_TypeDef *Device, FMC_NORSRAM_TimingTypeDef *Timing, uint32_t Bank, uint32_t ExtendedMode)
000000  b570              PUSH     {r4-r6,lr}
;;;317    {  
000002  4604              MOV      r4,r0
000004  461d              MOV      r5,r3
;;;318      uint32_t tmpr = 0;
000006  2300              MOVS     r3,#0
;;;319     
;;;320      /* Check the parameters */
;;;321      assert_param(IS_FMC_EXTENDED_MODE(ExtendedMode));
;;;322      
;;;323      /* Set NORSRAM device timing register for write configuration, if extended mode is used */
;;;324      if(ExtendedMode == FMC_EXTENDED_MODE_ENABLE)
000008  f5b54f80          CMP      r5,#0x4000
00000c  d113              BNE      |L9.54|
;;;325      {
;;;326        /* Check the parameters */
;;;327        assert_param(IS_FMC_NORSRAM_EXTENDED_DEVICE(Device));  
;;;328        assert_param(IS_FMC_ADDRESS_SETUP_TIME(Timing->AddressSetupTime));
;;;329        assert_param(IS_FMC_ADDRESS_HOLD_TIME(Timing->AddressHoldTime));
;;;330        assert_param(IS_FMC_DATASETUP_TIME(Timing->DataSetupTime));
;;;331        assert_param(IS_FMC_TURNAROUND_TIME(Timing->BusTurnAroundDuration));
;;;332        assert_param(IS_FMC_CLK_DIV(Timing->CLKDivision));
;;;333        assert_param(IS_FMC_DATA_LATENCY(Timing->DataLatency));
;;;334        assert_param(IS_FMC_ACCESS_MODE(Timing->AccessMode));
;;;335        assert_param(IS_FMC_NORSRAM_BANK(Bank));  
;;;336        
;;;337        /* Get the BWTR register value */
;;;338        tmpr = Device->BWTR[Bank];
00000e  f8543022          LDR      r3,[r4,r2,LSL #2]
;;;339    
;;;340        /* Clear ADDSET, ADDHLD, DATAST, BUSTURN, CLKDIV, DATLAT and ACCMOD bits */
;;;341        tmpr &= ((uint32_t)~(FMC_BWTR1_ADDSET  | FMC_BWTR1_ADDHLD | FMC_BWTR1_DATAST | \
000012  480c              LDR      r0,|L9.68|
000014  4003              ANDS     r3,r3,r0
;;;342                             FMC_BWTR1_BUSTURN | FMC_BWTR1_ACCMOD));
;;;343        
;;;344        tmpr |= (uint32_t)(Timing->AddressSetupTime                 |\
000016  e9d10600          LDRD     r0,r6,[r1,#0]
00001a  ea401006          ORR      r0,r0,r6,LSL #4
00001e  688e              LDR      r6,[r1,#8]
000020  ea402006          ORR      r0,r0,r6,LSL #8
000024  898e              LDRH     r6,[r1,#0xc]
000026  ea404006          ORR      r0,r0,r6,LSL #16
00002a  698e              LDR      r6,[r1,#0x18]
00002c  4330              ORRS     r0,r0,r6
00002e  4303              ORRS     r3,r3,r0
;;;345                          ((Timing->AddressHoldTime) << 4)          |\
;;;346                          ((Timing->DataSetupTime) << 8)            |\
;;;347                          ((Timing->BusTurnAroundDuration) << 16)   |\
;;;348                          (Timing->AccessMode));
;;;349    
;;;350        Device->BWTR[Bank] = tmpr;
000030  f8443022          STR      r3,[r4,r2,LSL #2]
000034  e003              B        |L9.62|
                  |L9.54|
;;;351      }
;;;352      else
;;;353      {
;;;354        Device->BWTR[Bank] = 0x0FFFFFFF;
000036  f06f4070          MVN      r0,#0xf0000000
00003a  f8440022          STR      r0,[r4,r2,LSL #2]
                  |L9.62|
;;;355      }   
;;;356      
;;;357      return HAL_OK;  
00003e  2000              MOVS     r0,#0
;;;358    }
000040  bd70              POP      {r4-r6,pc}
;;;359    /**
                          ENDP

000042  0000              DCW      0x0000
                  |L9.68|
                          DCD      0xcff00000

                          AREA ||i.FMC_NORSRAM_Init||, CODE, READONLY, ALIGN=2

                  FMC_NORSRAM_Init PROC
;;;147      */
;;;148    HAL_StatusTypeDef  FMC_NORSRAM_Init(FMC_NORSRAM_TypeDef *Device, FMC_NORSRAM_InitTypeDef* Init)
000000  b510              PUSH     {r4,lr}
;;;149    { 
000002  4602              MOV      r2,r0
;;;150      uint32_t tmpr = 0;
000004  2300              MOVS     r3,#0
;;;151        
;;;152      /* Check the parameters */
;;;153      assert_param(IS_FMC_NORSRAM_DEVICE(Device));
;;;154      assert_param(IS_FMC_NORSRAM_BANK(Init->NSBank));
;;;155      assert_param(IS_FMC_MUX(Init->DataAddressMux));
;;;156      assert_param(IS_FMC_MEMORY(Init->MemoryType));
;;;157      assert_param(IS_FMC_NORSRAM_MEMORY_WIDTH(Init->MemoryDataWidth));
;;;158      assert_param(IS_FMC_BURSTMODE(Init->BurstAccessMode));
;;;159      assert_param(IS_FMC_WAIT_POLARITY(Init->WaitSignalPolarity));
;;;160      assert_param(IS_FMC_WAIT_SIGNAL_ACTIVE(Init->WaitSignalActive));
;;;161      assert_param(IS_FMC_WRITE_OPERATION(Init->WriteOperation));
;;;162      assert_param(IS_FMC_WAITE_SIGNAL(Init->WaitSignal));
;;;163      assert_param(IS_FMC_EXTENDED_MODE(Init->ExtendedMode));
;;;164      assert_param(IS_FMC_ASYNWAIT(Init->AsynchronousWait));
;;;165      assert_param(IS_FMC_WRITE_BURST(Init->WriteBurst));
;;;166      assert_param(IS_FMC_CONTINOUS_CLOCK(Init->ContinuousClock)); 
;;;167      assert_param(IS_FMC_WRITE_FIFO(Init->WriteFifo));
;;;168      assert_param(IS_FMC_PAGESIZE(Init->PageSize));
;;;169    
;;;170      /* Get the BTCR register value */
;;;171      tmpr = Device->BTCR[Init->NSBank];
000006  6808              LDR      r0,[r1,#0]
000008  f8523020          LDR      r3,[r2,r0,LSL #2]
;;;172      
;;;173      /* Clear MBKEN, MUXEN, MTYP, MWID, FACCEN, BURSTEN, WAITPOL, WAITCFG, WREN,
;;;174               WAITEN, EXTMOD, ASYNCWAIT, CBURSTRW and CCLKEN bits */
;;;175      tmpr &= ((uint32_t)~(FMC_BCR1_MBKEN     | FMC_BCR1_MUXEN    | FMC_BCR1_MTYP     | \
00000c  481b              LDR      r0,|L10.124|
00000e  4003              ANDS     r3,r3,r0
;;;176                           FMC_BCR1_MWID      | FMC_BCR1_FACCEN   | FMC_BCR1_BURSTEN  | \
;;;177                           FMC_BCR1_WAITPOL   | FMC_BCR1_CPSIZE    | FMC_BCR1_WAITCFG  | \
;;;178                           FMC_BCR1_WREN      | FMC_BCR1_WAITEN   | FMC_BCR1_EXTMOD   | \
;;;179                           FMC_BCR1_ASYNCWAIT | FMC_BCR1_CBURSTRW | FMC_BCR1_CCLKEN | FMC_BCR1_WFDIS));
;;;180      
;;;181      /* Set NORSRAM device control parameters */
;;;182      tmpr |= (uint32_t)(Init->DataAddressMux       |\
000010  e9d10401          LDRD     r0,r4,[r1,#4]
000014  4320              ORRS     r0,r0,r4
000016  68cc              LDR      r4,[r1,#0xc]
000018  4320              ORRS     r0,r0,r4
00001a  690c              LDR      r4,[r1,#0x10]
00001c  4320              ORRS     r0,r0,r4
00001e  694c              LDR      r4,[r1,#0x14]
000020  4320              ORRS     r0,r0,r4
000022  698c              LDR      r4,[r1,#0x18]
000024  4320              ORRS     r0,r0,r4
000026  69cc              LDR      r4,[r1,#0x1c]
000028  4320              ORRS     r0,r0,r4
00002a  6a0c              LDR      r4,[r1,#0x20]
00002c  4320              ORRS     r0,r0,r4
00002e  6a4c              LDR      r4,[r1,#0x24]
000030  4320              ORRS     r0,r0,r4
000032  6a8c              LDR      r4,[r1,#0x28]
000034  4320              ORRS     r0,r0,r4
000036  6acc              LDR      r4,[r1,#0x2c]
000038  4320              ORRS     r0,r0,r4
00003a  6b0c              LDR      r4,[r1,#0x30]
00003c  4320              ORRS     r0,r0,r4
00003e  6b8c              LDR      r4,[r1,#0x38]
000040  4320              ORRS     r0,r0,r4
000042  6b4c              LDR      r4,[r1,#0x34]
000044  4320              ORRS     r0,r0,r4
000046  4303              ORRS     r3,r3,r0
;;;183                        Init->MemoryType           |\
;;;184                        Init->MemoryDataWidth      |\
;;;185                        Init->BurstAccessMode      |\
;;;186                        Init->WaitSignalPolarity   |\
;;;187                        Init->WaitSignalActive     |\
;;;188                        Init->WriteOperation       |\
;;;189                        Init->WaitSignal           |\
;;;190                        Init->ExtendedMode         |\
;;;191                        Init->AsynchronousWait     |\
;;;192                        Init->WriteBurst           |\
;;;193                        Init->ContinuousClock      |\
;;;194                        Init->PageSize             |\
;;;195                        Init->WriteFifo);
;;;196                        
;;;197      if(Init->MemoryType == FMC_MEMORY_TYPE_NOR)
000048  6888              LDR      r0,[r1,#8]
00004a  2808              CMP      r0,#8
00004c  d101              BNE      |L10.82|
;;;198      {
;;;199        tmpr |= (uint32_t)FMC_NORSRAM_FLASH_ACCESS_ENABLE;
00004e  f0430340          ORR      r3,r3,#0x40
                  |L10.82|
;;;200      }
;;;201      
;;;202      Device->BTCR[Init->NSBank] = tmpr;
000052  6808              LDR      r0,[r1,#0]
000054  f8423020          STR      r3,[r2,r0,LSL #2]
;;;203    
;;;204      /* Configure synchronous mode when Continuous clock is enabled for bank2..4 */
;;;205      if((Init->ContinuousClock == FMC_CONTINUOUS_CLOCK_SYNC_ASYNC) && (Init->NSBank != FMC_NORSRAM_BANK1))
000058  6b08              LDR      r0,[r1,#0x30]
00005a  f5b01f80          CMP      r0,#0x100000
00005e  d105              BNE      |L10.108|
000060  6808              LDR      r0,[r1,#0]
000062  b118              CBZ      r0,|L10.108|
;;;206      { 
;;;207        Device->BTCR[FMC_NORSRAM_BANK1] |= (uint32_t)(Init->ContinuousClock);
000064  6810              LDR      r0,[r2,#0]
000066  6b0c              LDR      r4,[r1,#0x30]
000068  4320              ORRS     r0,r0,r4
00006a  6010              STR      r0,[r2,#0]
                  |L10.108|
;;;208      }
;;;209      if(Init->NSBank != FMC_NORSRAM_BANK1)
00006c  6808              LDR      r0,[r1,#0]
00006e  b118              CBZ      r0,|L10.120|
;;;210      {
;;;211        Device->BTCR[FMC_NORSRAM_BANK1] |= (uint32_t)(Init->WriteFifo);              
000070  6810              LDR      r0,[r2,#0]
000072  6b4c              LDR      r4,[r1,#0x34]
000074  4320              ORRS     r0,r0,r4
000076  6010              STR      r0,[r2,#0]
                  |L10.120|
;;;212      }
;;;213      
;;;214      return HAL_OK;
000078  2000              MOVS     r0,#0
;;;215    }
00007a  bd10              POP      {r4,pc}
;;;216    
                          ENDP

                  |L10.124|
                          DCD      0xffc00480

                          AREA ||i.FMC_NORSRAM_Timing_Init||, CODE, READONLY, ALIGN=1

                  FMC_NORSRAM_Timing_Init PROC
;;;261      */
;;;262    HAL_StatusTypeDef FMC_NORSRAM_Timing_Init(FMC_NORSRAM_TypeDef *Device, FMC_NORSRAM_TimingTypeDef *Timing, uint32_t Bank)
000000  b530              PUSH     {r4,r5,lr}
;;;263    {
000002  4603              MOV      r3,r0
000004  4614              MOV      r4,r2
;;;264      uint32_t tmpr = 0;
000006  2200              MOVS     r2,#0
;;;265      
;;;266      /* Check the parameters */
;;;267      assert_param(IS_FMC_NORSRAM_DEVICE(Device));
;;;268      assert_param(IS_FMC_ADDRESS_SETUP_TIME(Timing->AddressSetupTime));
;;;269      assert_param(IS_FMC_ADDRESS_HOLD_TIME(Timing->AddressHoldTime));
;;;270      assert_param(IS_FMC_DATASETUP_TIME(Timing->DataSetupTime));
;;;271      assert_param(IS_FMC_TURNAROUND_TIME(Timing->BusTurnAroundDuration));
;;;272      assert_param(IS_FMC_CLK_DIV(Timing->CLKDivision));
;;;273      assert_param(IS_FMC_DATA_LATENCY(Timing->DataLatency));
;;;274      assert_param(IS_FMC_ACCESS_MODE(Timing->AccessMode));
;;;275      assert_param(IS_FMC_NORSRAM_BANK(Bank));
;;;276      
;;;277      /* Get the BTCR register value */
;;;278      tmpr = Device->BTCR[Bank + 1];
000008  1c60              ADDS     r0,r4,#1
00000a  f8532020          LDR      r2,[r3,r0,LSL #2]
;;;279    
;;;280      /* Clear ADDSET, ADDHLD, DATAST, BUSTURN, CLKDIV, DATLAT and ACCMOD bits */
;;;281      tmpr &= ((uint32_t)~(FMC_BTR1_ADDSET  | FMC_BTR1_ADDHLD | FMC_BTR1_DATAST | \
00000e  f0024240          AND      r2,r2,#0xc0000000
;;;282                           FMC_BTR1_BUSTURN | FMC_BTR1_CLKDIV | FMC_BTR1_DATLAT | \
;;;283                           FMC_BTR1_ACCMOD));
;;;284      
;;;285      /* Set FMC_NORSRAM device timing parameters */  
;;;286      tmpr |= (uint32_t)(Timing->AddressSetupTime                  |\
000012  e9d10500          LDRD     r0,r5,[r1,#0]
000016  ea401005          ORR      r0,r0,r5,LSL #4
00001a  688d              LDR      r5,[r1,#8]
00001c  ea402005          ORR      r0,r0,r5,LSL #8
000020  898d              LDRH     r5,[r1,#0xc]
000022  ea404505          ORR      r5,r0,r5,LSL #16
000026  8a08              LDRH     r0,[r1,#0x10]
000028  1e40              SUBS     r0,r0,#1
00002a  ea455500          ORR      r5,r5,r0,LSL #20
00002e  7d08              LDRB     r0,[r1,#0x14]
000030  1e80              SUBS     r0,r0,#2
000032  ea456000          ORR      r0,r5,r0,LSL #24
000036  698d              LDR      r5,[r1,#0x18]
000038  4328              ORRS     r0,r0,r5
00003a  4302              ORRS     r2,r2,r0
;;;287                       ((Timing->AddressHoldTime) << 4)          |\
;;;288                       ((Timing->DataSetupTime) << 8)            |\
;;;289                       ((Timing->BusTurnAroundDuration) << 16)   |\
;;;290                       (((Timing->CLKDivision)-1) << 20)         |\
;;;291                       (((Timing->DataLatency)-2) << 24)         |\
;;;292                        (Timing->AccessMode)
;;;293                        );
;;;294      
;;;295      Device->BTCR[Bank + 1] = tmpr;
00003c  1c60              ADDS     r0,r4,#1
00003e  f8432020          STR      r2,[r3,r0,LSL #2]
;;;296      
;;;297      /* Configure Clock division value (in NORSRAM bank 1) when continuous clock is enabled */
;;;298      if(HAL_IS_BIT_SET(Device->BTCR[FMC_NORSRAM_BANK1], FMC_BCR1_CCLKEN))
000042  6818              LDR      r0,[r3,#0]
000044  f4001080          AND      r0,r0,#0x100000
000048  b138              CBZ      r0,|L11.90|
;;;299      {
;;;300        tmpr = (uint32_t)(Device->BTCR[FMC_NORSRAM_BANK1 + 1] & ~(((uint32_t)0x0F) << 20)); 
00004a  6858              LDR      r0,[r3,#4]
00004c  f4200270          BIC      r2,r0,#0xf00000
;;;301        tmpr |= (uint32_t)(((Timing->CLKDivision)-1) << 20);
000050  8a08              LDRH     r0,[r1,#0x10]
000052  1e40              SUBS     r0,r0,#1
000054  ea425200          ORR      r2,r2,r0,LSL #20
;;;302        Device->BTCR[FMC_NORSRAM_BANK1 + 1] = tmpr;
000058  605a              STR      r2,[r3,#4]
                  |L11.90|
;;;303      }  
;;;304      
;;;305      return HAL_OK;   
00005a  2000              MOVS     r0,#0
;;;306    }
00005c  bd30              POP      {r4,r5,pc}
;;;307    
                          ENDP


                          AREA ||i.FMC_NORSRAM_WriteOperation_Disable||, CODE, READONLY, ALIGN=1

                  FMC_NORSRAM_WriteOperation_Disable PROC
;;;401      */
;;;402    HAL_StatusTypeDef FMC_NORSRAM_WriteOperation_Disable(FMC_NORSRAM_TypeDef *Device, uint32_t Bank)
000000  4602              MOV      r2,r0
;;;403    { 
;;;404      /* Check the parameters */
;;;405      assert_param(IS_FMC_NORSRAM_DEVICE(Device));
;;;406      assert_param(IS_FMC_NORSRAM_BANK(Bank));
;;;407        
;;;408      /* Disable write operation */
;;;409      Device->BTCR[Bank] &= ~FMC_WRITE_OPERATION_ENABLE; 
000002  f8520021          LDR      r0,[r2,r1,LSL #2]
000006  f4205080          BIC      r0,r0,#0x1000
00000a  f8420021          STR      r0,[r2,r1,LSL #2]
;;;410    
;;;411      return HAL_OK;  
00000e  2000              MOVS     r0,#0
;;;412    }
000010  4770              BX       lr
;;;413    
                          ENDP


                          AREA ||i.FMC_NORSRAM_WriteOperation_Enable||, CODE, READONLY, ALIGN=1

                  FMC_NORSRAM_WriteOperation_Enable PROC
;;;383      */
;;;384    HAL_StatusTypeDef FMC_NORSRAM_WriteOperation_Enable(FMC_NORSRAM_TypeDef *Device, uint32_t Bank)
000000  4602              MOV      r2,r0
;;;385    {
;;;386      /* Check the parameters */
;;;387      assert_param(IS_FMC_NORSRAM_DEVICE(Device));
;;;388      assert_param(IS_FMC_NORSRAM_BANK(Bank));
;;;389      
;;;390      /* Enable write operation */
;;;391      Device->BTCR[Bank] |= FMC_WRITE_OPERATION_ENABLE; 
000002  f8520021          LDR      r0,[r2,r1,LSL #2]
000006  f4405080          ORR      r0,r0,#0x1000
00000a  f8420021          STR      r0,[r2,r1,LSL #2]
;;;392    
;;;393      return HAL_OK;  
00000e  2000              MOVS     r0,#0
;;;394    }
000010  4770              BX       lr
;;;395    
                          ENDP


                          AREA ||i.FMC_SDRAM_DeInit||, CODE, READONLY, ALIGN=1

                  FMC_SDRAM_DeInit PROC
;;;908      */
;;;909    HAL_StatusTypeDef FMC_SDRAM_DeInit(FMC_SDRAM_TypeDef *Device, uint32_t Bank)
000000  4602              MOV      r2,r0
;;;910    {
;;;911      /* Check the parameters */
;;;912      assert_param(IS_FMC_SDRAM_DEVICE(Device));
;;;913      assert_param(IS_FMC_SDRAM_BANK(Bank));
;;;914      
;;;915      /* De-initialize the SDRAM device */
;;;916      Device->SDCR[Bank] = 0x000002D0;
000002  f44f7034          MOV      r0,#0x2d0
000006  f8420021          STR      r0,[r2,r1,LSL #2]
;;;917      Device->SDTR[Bank] = 0x0FFFFFFF;    
00000a  f06f4370          MVN      r3,#0xf0000000
00000e  f1020008          ADD      r0,r2,#8
000012  f8403021          STR      r3,[r0,r1,LSL #2]
;;;918      Device->SDCMR      = 0x00000000;
000016  2000              MOVS     r0,#0
000018  6110              STR      r0,[r2,#0x10]
;;;919      Device->SDRTR      = 0x00000000;
00001a  6150              STR      r0,[r2,#0x14]
;;;920      Device->SDSR       = 0x00000000;
00001c  6190              STR      r0,[r2,#0x18]
;;;921    
;;;922      return HAL_OK;
;;;923    }
00001e  4770              BX       lr
;;;924    
                          ENDP


                          AREA ||i.FMC_SDRAM_GetModeStatus||, CODE, READONLY, ALIGN=1

                  FMC_SDRAM_GetModeStatus PROC
;;;1054     */
;;;1055   uint32_t FMC_SDRAM_GetModeStatus(FMC_SDRAM_TypeDef *Device, uint32_t Bank)
000000  4602              MOV      r2,r0
;;;1056   {
;;;1057     uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;1058     
;;;1059     /* Check the parameters */
;;;1060     assert_param(IS_FMC_SDRAM_DEVICE(Device));
;;;1061     assert_param(IS_FMC_SDRAM_BANK(Bank));
;;;1062   
;;;1063     /* Get the corresponding bank mode */
;;;1064     if(Bank == FMC_SDRAM_BANK1)
000004  b919              CBNZ     r1,|L15.14|
;;;1065     {
;;;1066       tmpreg = (uint32_t)(Device->SDSR & FMC_SDSR_MODES1); 
000006  6993              LDR      r3,[r2,#0x18]
000008  f0030006          AND      r0,r3,#6
00000c  e003              B        |L15.22|
                  |L15.14|
;;;1067     }
;;;1068     else
;;;1069     {
;;;1070       tmpreg = ((uint32_t)(Device->SDSR & FMC_SDSR_MODES2) >> 2);
00000e  6993              LDR      r3,[r2,#0x18]
000010  f0030318          AND      r3,r3,#0x18
000014  0898              LSRS     r0,r3,#2
                  |L15.22|
;;;1071     }
;;;1072     
;;;1073     /* Return the mode status */
;;;1074     return tmpreg;
;;;1075   }
000016  4770              BX       lr
;;;1076   
                          ENDP


                          AREA ||i.FMC_SDRAM_Init||, CODE, READONLY, ALIGN=1

                  FMC_SDRAM_Init PROC
;;;757      */
;;;758    HAL_StatusTypeDef FMC_SDRAM_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_InitTypeDef *Init)
000000  b530              PUSH     {r4,r5,lr}
;;;759    {
000002  4602              MOV      r2,r0
;;;760      uint32_t tmpr1 = 0;
000004  2300              MOVS     r3,#0
;;;761      uint32_t tmpr2 = 0;
000006  2400              MOVS     r4,#0
;;;762        
;;;763      /* Check the parameters */
;;;764      assert_param(IS_FMC_SDRAM_DEVICE(Device));
;;;765      assert_param(IS_FMC_SDRAM_BANK(Init->SDBank));
;;;766      assert_param(IS_FMC_COLUMNBITS_NUMBER(Init->ColumnBitsNumber));
;;;767      assert_param(IS_FMC_ROWBITS_NUMBER(Init->RowBitsNumber));
;;;768      assert_param(IS_FMC_SDMEMORY_WIDTH(Init->MemoryDataWidth));
;;;769      assert_param(IS_FMC_INTERNALBANK_NUMBER(Init->InternalBankNumber));
;;;770      assert_param(IS_FMC_CAS_LATENCY(Init->CASLatency));
;;;771      assert_param(IS_FMC_WRITE_PROTECTION(Init->WriteProtection));
;;;772      assert_param(IS_FMC_SDCLOCK_PERIOD(Init->SDClockPeriod));
;;;773      assert_param(IS_FMC_READ_BURST(Init->ReadBurst));
;;;774      assert_param(IS_FMC_READPIPE_DELAY(Init->ReadPipeDelay));   
;;;775    
;;;776      /* Set SDRAM bank configuration parameters */
;;;777      if (Init->SDBank != FMC_SDRAM_BANK2) 
000008  6808              LDR      r0,[r1,#0]
00000a  2801              CMP      r0,#1
00000c  d016              BEQ      |L16.60|
;;;778      {
;;;779        tmpr1 = Device->SDCR[FMC_SDRAM_BANK1];
00000e  6813              LDR      r3,[r2,#0]
;;;780        
;;;781        /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
;;;782        tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
000010  f36f030e          BFC      r3,#0,#15
;;;783                              FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP   | \
;;;784                              FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));
;;;785    
;;;786        tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
000014  e9d10501          LDRD     r0,r5,[r1,#4]
000018  4328              ORRS     r0,r0,r5
00001a  68cd              LDR      r5,[r1,#0xc]
00001c  4328              ORRS     r0,r0,r5
00001e  690d              LDR      r5,[r1,#0x10]
000020  4328              ORRS     r0,r0,r5
000022  694d              LDR      r5,[r1,#0x14]
000024  4328              ORRS     r0,r0,r5
000026  698d              LDR      r5,[r1,#0x18]
000028  4328              ORRS     r0,r0,r5
00002a  69cd              LDR      r5,[r1,#0x1c]
00002c  4328              ORRS     r0,r0,r5
00002e  6a0d              LDR      r5,[r1,#0x20]
000030  4328              ORRS     r0,r0,r5
000032  6a4d              LDR      r5,[r1,#0x24]
000034  4328              ORRS     r0,r0,r5
000036  4303              ORRS     r3,r3,r0
;;;787                            Init->RowBitsNumber      |\
;;;788                            Init->MemoryDataWidth    |\
;;;789                            Init->InternalBankNumber |\
;;;790                            Init->CASLatency         |\
;;;791                            Init->WriteProtection    |\
;;;792                            Init->SDClockPeriod      |\
;;;793                            Init->ReadBurst          |\
;;;794                            Init->ReadPipeDelay
;;;795                            );                                      
;;;796        Device->SDCR[FMC_SDRAM_BANK1] = tmpr1;
000038  6013              STR      r3,[r2,#0]
00003a  e019              B        |L16.112|
                  |L16.60|
;;;797      }
;;;798      else /* FMC_Bank2_SDRAM */                      
;;;799      {
;;;800        tmpr1 = Device->SDCR[FMC_SDRAM_BANK1];
00003c  6813              LDR      r3,[r2,#0]
;;;801        
;;;802        /* Clear SDCLK, RBURST, and RPIPE bits */
;;;803        tmpr1 &= ((uint32_t)~(FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));
00003e  f42343f8          BIC      r3,r3,#0x7c00
;;;804        
;;;805        tmpr1 |= (uint32_t)(Init->SDClockPeriod      |\
000042  e9d10507          LDRD     r0,r5,[r1,#0x1c]
000046  4328              ORRS     r0,r0,r5
000048  6a4d              LDR      r5,[r1,#0x24]
00004a  4328              ORRS     r0,r0,r5
00004c  4303              ORRS     r3,r3,r0
;;;806                            Init->ReadBurst          |\
;;;807                            Init->ReadPipeDelay);
;;;808        
;;;809        tmpr2 = Device->SDCR[FMC_SDRAM_BANK2];
00004e  6854              LDR      r4,[r2,#4]
;;;810        
;;;811        /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
;;;812        tmpr2 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
000050  f36f040e          BFC      r4,#0,#15
;;;813                              FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP   | \
;;;814                              FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));
;;;815    
;;;816        tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
000054  e9d10501          LDRD     r0,r5,[r1,#4]
000058  4328              ORRS     r0,r0,r5
00005a  68cd              LDR      r5,[r1,#0xc]
00005c  4328              ORRS     r0,r0,r5
00005e  690d              LDR      r5,[r1,#0x10]
000060  4328              ORRS     r0,r0,r5
000062  694d              LDR      r5,[r1,#0x14]
000064  4328              ORRS     r0,r0,r5
000066  698d              LDR      r5,[r1,#0x18]
000068  4328              ORRS     r0,r0,r5
00006a  4304              ORRS     r4,r4,r0
;;;817                           Init->RowBitsNumber       |\
;;;818                           Init->MemoryDataWidth     |\
;;;819                           Init->InternalBankNumber  |\
;;;820                           Init->CASLatency          |\
;;;821                           Init->WriteProtection);
;;;822    
;;;823        Device->SDCR[FMC_SDRAM_BANK1] = tmpr1;
00006c  6013              STR      r3,[r2,#0]
;;;824        Device->SDCR[FMC_SDRAM_BANK2] = tmpr2;
00006e  6054              STR      r4,[r2,#4]
                  |L16.112|
;;;825      }
;;;826      
;;;827      return HAL_OK;
000070  2000              MOVS     r0,#0
;;;828    }
000072  bd30              POP      {r4,r5,pc}
;;;829    
                          ENDP


                          AREA ||i.FMC_SDRAM_ProgramRefreshRate||, CODE, READONLY, ALIGN=1

                  FMC_SDRAM_ProgramRefreshRate PROC
;;;1015     */
;;;1016   HAL_StatusTypeDef FMC_SDRAM_ProgramRefreshRate(FMC_SDRAM_TypeDef *Device, uint32_t RefreshRate)
000000  4602              MOV      r2,r0
;;;1017   {
;;;1018     /* Check the parameters */
;;;1019     assert_param(IS_FMC_SDRAM_DEVICE(Device));
;;;1020     assert_param(IS_FMC_REFRESH_RATE(RefreshRate));
;;;1021     
;;;1022     /* Set the refresh rate in command register */
;;;1023     Device->SDRTR |= (RefreshRate<<1);
000002  6950              LDR      r0,[r2,#0x14]
000004  ea400041          ORR      r0,r0,r1,LSL #1
000008  6150              STR      r0,[r2,#0x14]
;;;1024     
;;;1025     return HAL_OK;   
00000a  2000              MOVS     r0,#0
;;;1026   }
00000c  4770              BX       lr
;;;1027   
                          ENDP


                          AREA ||i.FMC_SDRAM_SendCommand||, CODE, READONLY, ALIGN=1

                  FMC_SDRAM_SendCommand PROC
;;;986      */  
;;;987    HAL_StatusTypeDef FMC_SDRAM_SendCommand(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
000000  b518              PUSH     {r3,r4,lr}
;;;988    {
000002  4603              MOV      r3,r0
;;;989      __IO uint32_t tmpr = 0;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;990      
;;;991      /* Check the parameters */
;;;992      assert_param(IS_FMC_SDRAM_DEVICE(Device));
;;;993      assert_param(IS_FMC_COMMAND_MODE(Command->CommandMode));
;;;994      assert_param(IS_FMC_COMMAND_TARGET(Command->CommandTarget));
;;;995      assert_param(IS_FMC_AUTOREFRESH_NUMBER(Command->AutoRefreshNumber));
;;;996      assert_param(IS_FMC_MODE_REGISTER(Command->ModeRegisterDefinition));  
;;;997    
;;;998      /* Set command register */
;;;999      tmpr = (uint32_t)((Command->CommandMode)                  |\
000008  e9d10400          LDRD     r0,r4,[r1,#0]
00000c  4320              ORRS     r0,r0,r4
00000e  688c              LDR      r4,[r1,#8]
000010  1e64              SUBS     r4,r4,#1
000012  ea401044          ORR      r0,r0,r4,LSL #5
000016  68cc              LDR      r4,[r1,#0xc]
000018  ea402044          ORR      r0,r0,r4,LSL #9
00001c  9000              STR      r0,[sp,#0]
;;;1000                       (Command->CommandTarget)                |\
;;;1001                       (((Command->AutoRefreshNumber)-1) << 5) |\
;;;1002                       ((Command->ModeRegisterDefinition) << 9)
;;;1003                       );
;;;1004       
;;;1005     Device->SDCMR = tmpr;
00001e  9800              LDR      r0,[sp,#0]
000020  6118              STR      r0,[r3,#0x10]
;;;1006     
;;;1007     return HAL_OK;  
000022  2000              MOVS     r0,#0
;;;1008   }
000024  bd18              POP      {r3,r4,pc}
;;;1009   
                          ENDP


                          AREA ||i.FMC_SDRAM_SetAutoRefreshNumber||, CODE, READONLY, ALIGN=1

                  FMC_SDRAM_SetAutoRefreshNumber PROC
;;;1033     */
;;;1034   HAL_StatusTypeDef FMC_SDRAM_SetAutoRefreshNumber(FMC_SDRAM_TypeDef *Device, uint32_t AutoRefreshNumber)
000000  4602              MOV      r2,r0
;;;1035   {
;;;1036     /* Check the parameters */
;;;1037     assert_param(IS_FMC_SDRAM_DEVICE(Device));
;;;1038     assert_param(IS_FMC_AUTOREFRESH_NUMBER(AutoRefreshNumber));
;;;1039     
;;;1040     /* Set the Auto-refresh number in command register */
;;;1041     Device->SDCMR |= (AutoRefreshNumber << 5); 
000002  6910              LDR      r0,[r2,#0x10]
000004  ea401041          ORR      r0,r0,r1,LSL #5
000008  6110              STR      r0,[r2,#0x10]
;;;1042   
;;;1043     return HAL_OK;  
00000a  2000              MOVS     r0,#0
;;;1044   }
00000c  4770              BX       lr
;;;1045   
                          ENDP


                          AREA ||i.FMC_SDRAM_Timing_Init||, CODE, READONLY, ALIGN=2

                  FMC_SDRAM_Timing_Init PROC
;;;838      */
;;;839    HAL_StatusTypeDef FMC_SDRAM_Timing_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_TimingTypeDef *Timing, uint32_t Bank)
000000  b570              PUSH     {r4-r6,lr}
;;;840    {
000002  4603              MOV      r3,r0
000004  4615              MOV      r5,r2
;;;841      uint32_t tmpr1 = 0;
000006  2200              MOVS     r2,#0
;;;842      uint32_t tmpr2 = 0;
000008  2400              MOVS     r4,#0
;;;843        
;;;844      /* Check the parameters */
;;;845      assert_param(IS_FMC_SDRAM_DEVICE(Device));
;;;846      assert_param(IS_FMC_LOADTOACTIVE_DELAY(Timing->LoadToActiveDelay));
;;;847      assert_param(IS_FMC_EXITSELFREFRESH_DELAY(Timing->ExitSelfRefreshDelay));
;;;848      assert_param(IS_FMC_SELFREFRESH_TIME(Timing->SelfRefreshTime));
;;;849      assert_param(IS_FMC_ROWCYCLE_DELAY(Timing->RowCycleDelay));
;;;850      assert_param(IS_FMC_WRITE_RECOVERY_TIME(Timing->WriteRecoveryTime));
;;;851      assert_param(IS_FMC_RP_DELAY(Timing->RPDelay));
;;;852      assert_param(IS_FMC_RCD_DELAY(Timing->RCDDelay));
;;;853      assert_param(IS_FMC_SDRAM_BANK(Bank));
;;;854      
;;;855      /* Set SDRAM device timing parameters */ 
;;;856      if (Bank != FMC_SDRAM_BANK2) 
00000a  2d01              CMP      r5,#1
00000c  d01f              BEQ      |L20.78|
;;;857      {
;;;858        tmpr1 = Device->SDTR[FMC_SDRAM_BANK1];
00000e  689a              LDR      r2,[r3,#8]
;;;859        
;;;860        /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
;;;861        tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
000010  f0024270          AND      r2,r2,#0xf0000000
;;;862                              FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
;;;863                              FMC_SDTR1_TRCD));
;;;864        
;;;865        tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
000014  6808              LDR      r0,[r1,#0]
000016  1e40              SUBS     r0,r0,#1
000018  684e              LDR      r6,[r1,#4]
00001a  1e76              SUBS     r6,r6,#1
00001c  ea401606          ORR      r6,r0,r6,LSL #4
000020  6888              LDR      r0,[r1,#8]
000022  1e40              SUBS     r0,r0,#1
000024  ea462600          ORR      r6,r6,r0,LSL #8
000028  68c8              LDR      r0,[r1,#0xc]
00002a  1e40              SUBS     r0,r0,#1
00002c  ea463600          ORR      r6,r6,r0,LSL #12
000030  8a08              LDRH     r0,[r1,#0x10]
000032  1e40              SUBS     r0,r0,#1
000034  ea464600          ORR      r6,r6,r0,LSL #16
000038  8a88              LDRH     r0,[r1,#0x14]
00003a  1e40              SUBS     r0,r0,#1
00003c  ea465600          ORR      r6,r6,r0,LSL #20
000040  7e08              LDRB     r0,[r1,#0x18]
000042  1e40              SUBS     r0,r0,#1
000044  ea466000          ORR      r0,r6,r0,LSL #24
000048  4302              ORRS     r2,r2,r0
;;;866                           (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
;;;867                           (((Timing->SelfRefreshTime)-1) << 8)      |\
;;;868                           (((Timing->RowCycleDelay)-1) << 12)       |\
;;;869                           (((Timing->WriteRecoveryTime)-1) <<16)    |\
;;;870                           (((Timing->RPDelay)-1) << 20)             |\
;;;871                           (((Timing->RCDDelay)-1) << 24));
;;;872        Device->SDTR[FMC_SDRAM_BANK1] = tmpr1;
00004a  609a              STR      r2,[r3,#8]
00004c  e022              B        |L20.148|
                  |L20.78|
;;;873      }
;;;874      else /* FMC_Bank2_SDRAM */
;;;875      {
;;;876        tmpr1 = Device->SDTR[FMC_SDRAM_BANK1];
00004e  689a              LDR      r2,[r3,#8]
;;;877        
;;;878        /* Clear TRC and TRP bits */
;;;879        tmpr1 &= ((uint32_t)~(FMC_SDTR1_TRC | FMC_SDTR1_TRP));
000050  4811              LDR      r0,|L20.152|
000052  4002              ANDS     r2,r2,r0
;;;880        
;;;881        tmpr1 |= (uint32_t)((((Timing->RowCycleDelay)-1) << 12)       |\
000054  68c8              LDR      r0,[r1,#0xc]
000056  1e40              SUBS     r0,r0,#1
000058  0306              LSLS     r6,r0,#12
00005a  8a88              LDRH     r0,[r1,#0x14]
00005c  1e40              SUBS     r0,r0,#1
00005e  ea465000          ORR      r0,r6,r0,LSL #20
000062  4302              ORRS     r2,r2,r0
;;;882                            (((Timing->RPDelay)-1) << 20)); 
;;;883        
;;;884        tmpr2 = Device->SDTR[FMC_SDRAM_BANK2];
000064  68dc              LDR      r4,[r3,#0xc]
;;;885        
;;;886        /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
;;;887        tmpr2 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
000066  f0044470          AND      r4,r4,#0xf0000000
;;;888                              FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
;;;889                              FMC_SDTR1_TRCD));
;;;890        
;;;891        tmpr2 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
00006a  6808              LDR      r0,[r1,#0]
00006c  1e40              SUBS     r0,r0,#1
00006e  684e              LDR      r6,[r1,#4]
000070  1e76              SUBS     r6,r6,#1
000072  ea401606          ORR      r6,r0,r6,LSL #4
000076  6888              LDR      r0,[r1,#8]
000078  1e40              SUBS     r0,r0,#1
00007a  ea462600          ORR      r6,r6,r0,LSL #8
00007e  8a08              LDRH     r0,[r1,#0x10]
000080  1e40              SUBS     r0,r0,#1
000082  ea464600          ORR      r6,r6,r0,LSL #16
000086  7e08              LDRB     r0,[r1,#0x18]
000088  1e40              SUBS     r0,r0,#1
00008a  ea466000          ORR      r0,r6,r0,LSL #24
00008e  4304              ORRS     r4,r4,r0
;;;892                           (((Timing->ExitSelfRefreshDelay)-1) << 4)  |\
;;;893                           (((Timing->SelfRefreshTime)-1) << 8)       |\
;;;894                           (((Timing->WriteRecoveryTime)-1) <<16)     |\
;;;895                           (((Timing->RCDDelay)-1) << 24));   
;;;896    
;;;897        Device->SDTR[FMC_SDRAM_BANK1] = tmpr1;
000090  609a              STR      r2,[r3,#8]
;;;898        Device->SDTR[FMC_SDRAM_BANK2] = tmpr2;
000092  60dc              STR      r4,[r3,#0xc]
                  |L20.148|
;;;899      }
;;;900      
;;;901      return HAL_OK;
000094  2000              MOVS     r0,#0
;;;902    }
000096  bd70              POP      {r4-r6,pc}
;;;903    
                          ENDP

                  |L20.152|
                          DCD      0xff0f0fff

                          AREA ||i.FMC_SDRAM_WriteProtection_Disable||, CODE, READONLY, ALIGN=1

                  FMC_SDRAM_WriteProtection_Disable PROC
;;;966      */
;;;967    HAL_StatusTypeDef FMC_SDRAM_WriteProtection_Disable(FMC_SDRAM_TypeDef *Device, uint32_t Bank)
000000  4602              MOV      r2,r0
;;;968    {
;;;969      /* Check the parameters */
;;;970      assert_param(IS_FMC_SDRAM_DEVICE(Device));
;;;971      assert_param(IS_FMC_SDRAM_BANK(Bank));
;;;972      
;;;973      /* Disable write protection */
;;;974      Device->SDCR[Bank] &= ~FMC_SDRAM_WRITE_PROTECTION_ENABLE;
000002  f8520021          LDR      r0,[r2,r1,LSL #2]
000006  f4207000          BIC      r0,r0,#0x200
00000a  f8420021          STR      r0,[r2,r1,LSL #2]
;;;975      
;;;976      return HAL_OK;
00000e  2000              MOVS     r0,#0
;;;977    }
000010  4770              BX       lr
;;;978      
                          ENDP


                          AREA ||i.FMC_SDRAM_WriteProtection_Enable||, CODE, READONLY, ALIGN=1

                  FMC_SDRAM_WriteProtection_Enable PROC
;;;949      */
;;;950    HAL_StatusTypeDef FMC_SDRAM_WriteProtection_Enable(FMC_SDRAM_TypeDef *Device, uint32_t Bank)
000000  4602              MOV      r2,r0
;;;951    { 
;;;952      /* Check the parameters */
;;;953      assert_param(IS_FMC_SDRAM_DEVICE(Device));
;;;954      assert_param(IS_FMC_SDRAM_BANK(Bank));
;;;955      
;;;956      /* Enable write protection */
;;;957      Device->SDCR[Bank] |= FMC_SDRAM_WRITE_PROTECTION_ENABLE;
000002  f8520021          LDR      r0,[r2,r1,LSL #2]
000006  f4407000          ORR      r0,r0,#0x200
00000a  f8420021          STR      r0,[r2,r1,LSL #2]
;;;958      
;;;959      return HAL_OK;  
00000e  2000              MOVS     r0,#0
;;;960    }
000010  4770              BX       lr
;;;961    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F7_V1.11.0\\Drivers\\STM32F7xx_HAL_Driver\\Src\\stm32f7xx_ll_fmc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f7xx_ll_fmc_c_65a710dd____REV16|
#line 464 "D:\\Program_Files_x86\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.1.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___18_stm32f7xx_ll_fmc_c_65a710dd____REV16| PROC
#line 465

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f7xx_ll_fmc_c_65a710dd____REVSH|
#line 479
|__asm___18_stm32f7xx_ll_fmc_c_65a710dd____REVSH| PROC
#line 480

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f7xx_ll_fmc_c_65a710dd____RRX|
#line 666
|__asm___18_stm32f7xx_ll_fmc_c_65a710dd____RRX| PROC
#line 667

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
