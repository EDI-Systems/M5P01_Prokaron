; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\kernel.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\kernel.d --cpu=Cortex-M7 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Inc -I.\Source -I.\Drivers -I..\..\..\M6P1(L)_Lua\lua -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6-ALIENTEK-LUA\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER -Dlua_writestring=RMP_lua_writestring -Dlua_writeline=RMP_lua_writeline --enum_is_int --signed_chars --omf_browse=.\debug\output\kernel.crf ..\..\MProkaron\Kernel\kernel.c]
                          THUMB

                          AREA ||i.RMP_CRC16||, CODE, READONLY, ALIGN=2

                  RMP_CRC16 PROC
;;;264    #ifdef __U16__
;;;265    ptr_t RMP_CRC16(const u8* Data, ptr_t Length)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;266    {
000004  b0c1              SUB      sp,sp,#0x104
000006  4606              MOV      r6,r0
000008  460f              MOV      r7,r1
;;;267        ptr_t Data_Cnt;
;;;268        u8 Index;
;;;269        u8 Temp_High;
;;;270        u8 Temp_Low;
;;;271        
;;;272        /* CRC16 constants with X^16+X^15+X^2+1 */
;;;273        static const u8 CRC16_High[256]=
;;;274        {
;;;275            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;276            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;277            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;278            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;279            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;280            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;281            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;282            0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;283            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;284            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;285            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;286            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;287            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;288            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;289            0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;290            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;291            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;292            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
;;;293            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;294            0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
;;;295            0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
;;;296            0x00, 0xC1, 0x81, 0x40
;;;297        };
;;;298    
;;;299        const u8 CRC16_Low[256]=
00000a  f44f7280          MOV      r2,#0x100
00000e  490d              LDR      r1,|L1.68|
000010  a801              ADD      r0,sp,#4
000012  f7fffffe          BL       __aeabi_memcpy4
;;;300        {
;;;301            0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7,
;;;302            0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E,
;;;303            0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9,
;;;304            0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC,
;;;305            0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
;;;306            0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32,
;;;307            0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D,
;;;308            0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38,
;;;309            0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF,
;;;310            0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
;;;311            0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1,
;;;312            0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4,
;;;313            0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB,
;;;314            0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA,
;;;315            0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
;;;316            0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0,
;;;317            0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97,
;;;318            0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E,
;;;319            0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89,
;;;320            0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
;;;321            0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83,
;;;322            0x41, 0x81, 0x80, 0x40
;;;323        };
;;;324    
;;;325        Temp_High=0xFF;
000016  f04f08ff          MOV      r8,#0xff
;;;326        Temp_Low=0xFF;
00001a  46c1              MOV      r9,r8
;;;327        for(Data_Cnt=0;Data_Cnt<Length;Data_Cnt++)
00001c  2400              MOVS     r4,#0
00001e  e00a              B        |L1.54|
                  |L1.32|
;;;328        {
;;;329            Index=Temp_Low^Data[Data_Cnt];
000020  5d30              LDRB     r0,[r6,r4]
000022  ea800509          EOR      r5,r0,r9
;;;330            Temp_Low=(u8)(Temp_High^CRC16_High[Index]);
000026  4808              LDR      r0,|L1.72|
000028  5d40              LDRB     r0,[r0,r5]
00002a  ea800908          EOR      r9,r0,r8
;;;331            Temp_High=CRC16_Low[Index];
00002e  a801              ADD      r0,sp,#4
000030  f8108005          LDRB     r8,[r0,r5]
000034  1c64              ADDS     r4,r4,#1              ;327
                  |L1.54|
000036  42bc              CMP      r4,r7                 ;327
000038  d3f2              BCC      |L1.32|
;;;332        }
;;;333    
;;;334        return (u16)(((u16)Temp_High)<<8|Temp_Low);
00003a  ea492008          ORR      r0,r9,r8,LSL #8
;;;335    }
00003e  b041              ADD      sp,sp,#0x104
000040  e8bd83f0          POP      {r4-r9,pc}
;;;336    #endif
                          ENDP

                  |L1.68|
                          DCD      ||.constdata||+0x4e0
                  |L1.72|
                          DCD      CRC16_High

                          AREA ||i.RMP_Checkbox||, CODE, READONLY, ALIGN=1

                  RMP_Checkbox PROC
;;;2964   ******************************************************************************/
;;;2965   void RMP_Checkbox(cnt_t Coord_X, cnt_t Coord_Y, cnt_t Length, ptr_t Status)    
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;2966   {   
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4614              MOV      r4,r2
00000a  461f              MOV      r7,r3
;;;2967       /* Clear the area */
;;;2968       RMP_Rectangle(Coord_X,Coord_Y,Length,Length,RMP_CTL_WHITE,RMP_CTL_WHITE);
00000c  f64f70ff          MOV      r0,#0xffff
000010  9000              STR      r0,[sp,#0]
000012  4623              MOV      r3,r4
000014  4622              MOV      r2,r4
000016  4629              MOV      r1,r5
000018  9001              STR      r0,[sp,#4]
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       RMP_Rectangle
;;;2969                                                                        
;;;2970       /* Draw checkbox outline */
;;;2971       RMP_Line(Coord_X,Coord_Y,Coord_X+Length-1,Coord_Y,RMP_CTL_DARK);                 
000020  f64730ef          MOV      r0,#0x7bef
000024  9000              STR      r0,[sp,#0]
000026  1930              ADDS     r0,r6,r4
000028  1e42              SUBS     r2,r0,#1
00002a  462b              MOV      r3,r5
00002c  4629              MOV      r1,r5
00002e  4630              MOV      r0,r6
000030  f7fffffe          BL       RMP_Line
;;;2972       RMP_Line(Coord_X+Length-1,Coord_Y,Coord_X+Length-1,Coord_Y+Length-1,RMP_CTL_WHITE);
000034  f64f70ff          MOV      r0,#0xffff
000038  1929              ADDS     r1,r5,r4
00003a  1e4b              SUBS     r3,r1,#1
00003c  1931              ADDS     r1,r6,r4
00003e  1e4a              SUBS     r2,r1,#1
000040  1931              ADDS     r1,r6,r4
000042  9000              STR      r0,[sp,#0]
000044  1e48              SUBS     r0,r1,#1
000046  4629              MOV      r1,r5
000048  f7fffffe          BL       RMP_Line
;;;2973       RMP_Line(Coord_X+Length-1,Coord_Y+Length-1,Coord_X,Coord_Y+Length-1,RMP_CTL_WHITE);
00004c  f64f70ff          MOV      r0,#0xffff
000050  192a              ADDS     r2,r5,r4
000052  1e53              SUBS     r3,r2,#1
000054  192a              ADDS     r2,r5,r4
000056  1e51              SUBS     r1,r2,#1
000058  1932              ADDS     r2,r6,r4
00005a  9000              STR      r0,[sp,#0]
00005c  1e50              SUBS     r0,r2,#1
00005e  4632              MOV      r2,r6
000060  f7fffffe          BL       RMP_Line
;;;2974       RMP_Line(Coord_X,Coord_Y+Length-1,Coord_X,Coord_Y,RMP_CTL_DARK);
000064  f64730ef          MOV      r0,#0x7bef
000068  9000              STR      r0,[sp,#0]
00006a  1928              ADDS     r0,r5,r4
00006c  1e41              SUBS     r1,r0,#1
00006e  462b              MOV      r3,r5
000070  4632              MOV      r2,r6
000072  4630              MOV      r0,r6
000074  f7fffffe          BL       RMP_Line
;;;2975   
;;;2976       RMP_Line(Coord_X+1,Coord_Y+1,Coord_X+Length-2,Coord_Y+1,RMP_CTL_BLACK);
000078  2000              MOVS     r0,#0
00007a  9000              STR      r0,[sp,#0]
00007c  1930              ADDS     r0,r6,r4
00007e  1e82              SUBS     r2,r0,#2
000080  1c6b              ADDS     r3,r5,#1
000082  1c69              ADDS     r1,r5,#1
000084  1c70              ADDS     r0,r6,#1
000086  f7fffffe          BL       RMP_Line
;;;2977       RMP_Line(Coord_X+Length-2,Coord_Y+1,Coord_X+Length-2,Coord_Y+Length-2,RMP_CTL_DARK);
00008a  f64730ef          MOV      r0,#0x7bef
00008e  1929              ADDS     r1,r5,r4
000090  1e8b              SUBS     r3,r1,#2
000092  1931              ADDS     r1,r6,r4
000094  1e8a              SUBS     r2,r1,#2
000096  1931              ADDS     r1,r6,r4
000098  9000              STR      r0,[sp,#0]
00009a  1e88              SUBS     r0,r1,#2
00009c  1c69              ADDS     r1,r5,#1
00009e  f7fffffe          BL       RMP_Line
;;;2978       RMP_Line(Coord_X+Length-2,Coord_Y+Length-2,Coord_X,Coord_Y+Length-2,RMP_CTL_DARK);
0000a2  f64730ef          MOV      r0,#0x7bef
0000a6  192a              ADDS     r2,r5,r4
0000a8  1e93              SUBS     r3,r2,#2
0000aa  192a              ADDS     r2,r5,r4
0000ac  1e91              SUBS     r1,r2,#2
0000ae  1932              ADDS     r2,r6,r4
0000b0  9000              STR      r0,[sp,#0]
0000b2  1e90              SUBS     r0,r2,#2
0000b4  4632              MOV      r2,r6
0000b6  f7fffffe          BL       RMP_Line
;;;2979       RMP_Line(Coord_X+1,Coord_Y+Length-2,Coord_X+1,Coord_Y+1,RMP_CTL_BLACK);
0000ba  2000              MOVS     r0,#0
0000bc  9000              STR      r0,[sp,#0]
0000be  1928              ADDS     r0,r5,r4
0000c0  1e81              SUBS     r1,r0,#2
0000c2  1c6b              ADDS     r3,r5,#1
0000c4  1c72              ADDS     r2,r6,#1
0000c6  1c70              ADDS     r0,r6,#1
0000c8  f7fffffe          BL       RMP_Line
;;;2980       
;;;2981       if(Status!=0)
0000cc  b127              CBZ      r7,|L2.216|
;;;2982           RMP_Checkbox_Set(Coord_X, Coord_Y, Length);
0000ce  4622              MOV      r2,r4
0000d0  4629              MOV      r1,r5
0000d2  4630              MOV      r0,r6
0000d4  f7fffffe          BL       RMP_Checkbox_Set
                  |L2.216|
;;;2983   }
0000d8  e8bd81fc          POP      {r2-r8,pc}
;;;2984   /* End Function:RMP_Checkbox *************************************************/
                          ENDP


                          AREA ||i.RMP_Checkbox_Clr||, CODE, READONLY, ALIGN=1

                  RMP_Checkbox_Clr PROC
;;;2937   ******************************************************************************/
;;;2938   void RMP_Checkbox_Clr(cnt_t Coord_X, cnt_t Coord_Y, cnt_t Length)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;2939   {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;2940       cnt_t Count;
;;;2941       
;;;2942       /* Erase the tick inside */
;;;2943       for(Count=0;Count<=2*Length/13;Count++)
00000a  2400              MOVS     r4,#0
00000c  e024              B        |L3.88|
                  |L3.14|
;;;2944       {
;;;2945           RMP_Line(Coord_X+4*Length/13+Count,Coord_Y+6*Length/13+Count,
00000e  00e8              LSLS     r0,r5,#3
000010  210d              MOVS     r1,#0xd
000012  fb90f0f1          SDIV     r0,r0,r1
000016  4438              ADD      r0,r0,r7
000018  eb000804          ADD      r8,r0,r4
00001c  00a8              LSLS     r0,r5,#2
00001e  fb90f0f1          SDIV     r0,r0,r1
000022  4430              ADD      r0,r0,r6
000024  eb000904          ADD      r9,r0,r4
000028  eb050045          ADD      r0,r5,r5,LSL #1
00002c  0040              LSLS     r0,r0,#1
00002e  fb90f0f1          SDIV     r0,r0,r1
000032  4438              ADD      r0,r0,r7
000034  eb000a04          ADD      r10,r0,r4
000038  00a8              LSLS     r0,r5,#2
00003a  fb90f0f1          SDIV     r0,r0,r1
00003e  4430              ADD      r0,r0,r6
000040  eb000b04          ADD      r11,r0,r4
000044  f64f70ff          MOV      r0,#0xffff
000048  4643              MOV      r3,r8
00004a  464a              MOV      r2,r9
00004c  4651              MOV      r1,r10
00004e  9000              STR      r0,[sp,#0]
000050  4658              MOV      r0,r11
000052  f7fffffe          BL       RMP_Line
000056  1c64              ADDS     r4,r4,#1              ;2943
                  |L3.88|
000058  0068              LSLS     r0,r5,#1              ;2943
00005a  210d              MOVS     r1,#0xd               ;2943
00005c  fb90f0f1          SDIV     r0,r0,r1              ;2943
000060  42a0              CMP      r0,r4                 ;2943
000062  dad4              BGE      |L3.14|
;;;2946                    Coord_X+4*Length/13+Count,Coord_Y+8*Length/13+Count,RMP_CTL_WHITE);
;;;2947       }
;;;2948       for(Count=0;Count<=4*Length/13;Count++)
000064  2400              MOVS     r4,#0
000066  e028              B        |L3.186|
                  |L3.104|
;;;2949       {
;;;2950           RMP_Line(Coord_X+6*Length/13+Count,Coord_Y+8*Length/13-Count,
000068  eb050085          ADD      r0,r5,r5,LSL #2
00006c  0040              LSLS     r0,r0,#1
00006e  210d              MOVS     r1,#0xd
000070  fb90f0f1          SDIV     r0,r0,r1
000074  4438              ADD      r0,r0,r7
000076  eba00804          SUB      r8,r0,r4
00007a  eb050045          ADD      r0,r5,r5,LSL #1
00007e  0040              LSLS     r0,r0,#1
000080  fb90f0f1          SDIV     r0,r0,r1
000084  4430              ADD      r0,r0,r6
000086  eb000904          ADD      r9,r0,r4
00008a  00e8              LSLS     r0,r5,#3
00008c  fb90f0f1          SDIV     r0,r0,r1
000090  4438              ADD      r0,r0,r7
000092  eba00a04          SUB      r10,r0,r4
000096  eb050045          ADD      r0,r5,r5,LSL #1
00009a  0040              LSLS     r0,r0,#1
00009c  fb90f0f1          SDIV     r0,r0,r1
0000a0  4430              ADD      r0,r0,r6
0000a2  eb000b04          ADD      r11,r0,r4
0000a6  f64f70ff          MOV      r0,#0xffff
0000aa  4643              MOV      r3,r8
0000ac  464a              MOV      r2,r9
0000ae  4651              MOV      r1,r10
0000b0  9000              STR      r0,[sp,#0]
0000b2  4658              MOV      r0,r11
0000b4  f7fffffe          BL       RMP_Line
0000b8  1c64              ADDS     r4,r4,#1              ;2948
                  |L3.186|
0000ba  00a8              LSLS     r0,r5,#2              ;2948
0000bc  210d              MOVS     r1,#0xd               ;2948
0000be  fb90f0f1          SDIV     r0,r0,r1              ;2948
0000c2  42a0              CMP      r0,r4                 ;2948
0000c4  dad0              BGE      |L3.104|
;;;2951                    Coord_X+6*Length/13+Count,Coord_Y+10*Length/13-Count,RMP_CTL_WHITE);
;;;2952       }
;;;2953   }
0000c6  e8bd8ff8          POP      {r3-r11,pc}
;;;2954   /* End Function:RMP_Checkbox_Clr *********************************************/
                          ENDP


                          AREA ||i.RMP_Checkbox_Set||, CODE, READONLY, ALIGN=1

                  RMP_Checkbox_Set PROC
;;;2911   ******************************************************************************/
;;;2912   void RMP_Checkbox_Set(cnt_t Coord_X, cnt_t Coord_Y, cnt_t Length)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;2913   {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;2914       cnt_t Count;
;;;2915       
;;;2916       /* Draw a tick inside */
;;;2917       for(Count=0;Count<=2*Length/13;Count++)
00000a  2400              MOVS     r4,#0
00000c  e023              B        |L4.86|
                  |L4.14|
;;;2918       {
;;;2919           RMP_Line(Coord_X+4*Length/13+Count,Coord_Y+6*Length/13+Count,
00000e  00e8              LSLS     r0,r5,#3
000010  210d              MOVS     r1,#0xd
000012  fb90f0f1          SDIV     r0,r0,r1
000016  4438              ADD      r0,r0,r7
000018  eb000804          ADD      r8,r0,r4
00001c  00a8              LSLS     r0,r5,#2
00001e  fb90f0f1          SDIV     r0,r0,r1
000022  4430              ADD      r0,r0,r6
000024  eb000904          ADD      r9,r0,r4
000028  eb050045          ADD      r0,r5,r5,LSL #1
00002c  0040              LSLS     r0,r0,#1
00002e  fb90f0f1          SDIV     r0,r0,r1
000032  4438              ADD      r0,r0,r7
000034  eb000a04          ADD      r10,r0,r4
000038  00a8              LSLS     r0,r5,#2
00003a  fb90f0f1          SDIV     r0,r0,r1
00003e  4430              ADD      r0,r0,r6
000040  eb000b04          ADD      r11,r0,r4
000044  2000              MOVS     r0,#0
000046  4643              MOV      r3,r8
000048  464a              MOV      r2,r9
00004a  4651              MOV      r1,r10
00004c  9000              STR      r0,[sp,#0]
00004e  4658              MOV      r0,r11
000050  f7fffffe          BL       RMP_Line
000054  1c64              ADDS     r4,r4,#1              ;2917
                  |L4.86|
000056  0068              LSLS     r0,r5,#1              ;2917
000058  210d              MOVS     r1,#0xd               ;2917
00005a  fb90f0f1          SDIV     r0,r0,r1              ;2917
00005e  42a0              CMP      r0,r4                 ;2917
000060  dad5              BGE      |L4.14|
;;;2920                    Coord_X+4*Length/13+Count,Coord_Y+8*Length/13+Count,RMP_CTL_BLACK);
;;;2921       }
;;;2922       for(Count=0;Count<=4*Length/13;Count++)
000062  2400              MOVS     r4,#0
000064  e027              B        |L4.182|
                  |L4.102|
;;;2923       {
;;;2924           RMP_Line(Coord_X+6*Length/13+Count,Coord_Y+8*Length/13-Count,
000066  eb050085          ADD      r0,r5,r5,LSL #2
00006a  0040              LSLS     r0,r0,#1
00006c  210d              MOVS     r1,#0xd
00006e  fb90f0f1          SDIV     r0,r0,r1
000072  4438              ADD      r0,r0,r7
000074  eba00804          SUB      r8,r0,r4
000078  eb050045          ADD      r0,r5,r5,LSL #1
00007c  0040              LSLS     r0,r0,#1
00007e  fb90f0f1          SDIV     r0,r0,r1
000082  4430              ADD      r0,r0,r6
000084  eb000904          ADD      r9,r0,r4
000088  00e8              LSLS     r0,r5,#3
00008a  fb90f0f1          SDIV     r0,r0,r1
00008e  4438              ADD      r0,r0,r7
000090  eba00a04          SUB      r10,r0,r4
000094  eb050045          ADD      r0,r5,r5,LSL #1
000098  0040              LSLS     r0,r0,#1
00009a  fb90f0f1          SDIV     r0,r0,r1
00009e  4430              ADD      r0,r0,r6
0000a0  eb000b04          ADD      r11,r0,r4
0000a4  2000              MOVS     r0,#0
0000a6  4643              MOV      r3,r8
0000a8  464a              MOV      r2,r9
0000aa  4651              MOV      r1,r10
0000ac  9000              STR      r0,[sp,#0]
0000ae  4658              MOV      r0,r11
0000b0  f7fffffe          BL       RMP_Line
0000b4  1c64              ADDS     r4,r4,#1              ;2922
                  |L4.182|
0000b6  00a8              LSLS     r0,r5,#2              ;2922
0000b8  210d              MOVS     r1,#0xd               ;2922
0000ba  fb90f0f1          SDIV     r0,r0,r1              ;2922
0000be  42a0              CMP      r0,r4                 ;2922
0000c0  dad1              BGE      |L4.102|
;;;2925                    Coord_X+6*Length/13+Count,Coord_Y+10*Length/13-Count,RMP_CTL_BLACK);
;;;2926       }
;;;2927   }
0000c2  e8bd8ff8          POP      {r3-r11,pc}
;;;2928   /* End Function:RMP_Checkbox_Set *********************************************/
                          ENDP


                          AREA ||i.RMP_Circle||, CODE, READONLY, ALIGN=1

                  RMP_Circle PROC
;;;2422   ******************************************************************************/
;;;2423   void RMP_Circle(cnt_t Center_X, cnt_t Center_Y, cnt_t Radius, ptr_t Border, ptr_t Fill)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;2424   {
000004  b083              SUB      sp,sp,#0xc
000006  4605              MOV      r5,r0
000008  460e              MOV      r6,r1
00000a  4693              MOV      r11,r2
;;;2425       cnt_t Cur_X;
;;;2426       cnt_t Cur_Y;
;;;2427       cnt_t Fill_Y;
;;;2428       cnt_t Error;  
;;;2429       cnt_t Quick;
;;;2430   
;;;2431       Cur_X=0;
00000c  2400              MOVS     r4,#0
;;;2432       Cur_Y=Radius;
00000e  465f              MOV      r7,r11
;;;2433       Error=3-(Radius<<1);
000010  2003              MOVS     r0,#3
000012  eba00a4b          SUB      r10,r0,r11,LSL #1
;;;2434   
;;;2435       if(Fill!=RMP_TRANS)
000016  9810              LDR      r0,[sp,#0x40]
000018  2801              CMP      r0,#1
00001a  d07c              BEQ      |L5.278|
;;;2436       {  
;;;2437           /* When we are filling the circle, we can try not to fill the areas that have been filled
;;;2438            * using the rectangle fill method to increase fill speed.
;;;2439            * Square 2 is 1.414. Here we let the condition to be 1.5. */
;;;2440           Quick=(Radius<<1)/3;
00001c  ea4f004b          LSL      r0,r11,#1
000020  2103              MOVS     r1,#3
000022  fb90f9f1          SDIV     r9,r0,r1
;;;2441           /* First, fill the square hole using the fast direct-fill method */
;;;2442           RMP_Rectangle(Center_X-Quick,Center_Y-Quick, (Quick<<1)+1,(Quick<<1)+1, Fill, Fill);  
000026  9810              LDR      r0,[sp,#0x40]
000028  9000              STR      r0,[sp,#0]
00002a  f04f0c01          MOV      r12,#1
00002e  eb0c0349          ADD      r3,r12,r9,LSL #1
000032  eb0c0249          ADD      r2,r12,r9,LSL #1
000036  eba60109          SUB      r1,r6,r9
00003a  9001              STR      r0,[sp,#4]
00003c  eba50009          SUB      r0,r5,r9
000040  f7fffffe          BL       RMP_Rectangle
;;;2443   
;;;2444           while(Cur_X<=Cur_Y) 
000044  e0ab              B        |L5.414|
                  |L5.70|
;;;2445           {  
;;;2446               if(Cur_X<Quick)
000046  454c              CMP      r4,r9
000048  da3a              BGE      |L5.192|
;;;2447               {
;;;2448                   for(Fill_Y=Cur_X;Fill_Y<=Cur_Y;Fill_Y++)  
00004a  46a0              MOV      r8,r4
00004c  e035              B        |L5.186|
                  |L5.78|
;;;2449                   {
;;;2450                       if(Fill_Y<Quick)
00004e  45c8              CMP      r8,r9
000050  da00              BGE      |L5.84|
;;;2451                           continue;
000052  e030              B        |L5.182|
                  |L5.84|
;;;2452                       
;;;2453                       RMP_POINT(Center_X+Cur_X,Center_Y+Fill_Y,Fill);  
000054  eb060108          ADD      r1,r6,r8
000058  1928              ADDS     r0,r5,r4
00005a  9a10              LDR      r2,[sp,#0x40]
00005c  f7fffffe          BL       RMP_Point
;;;2454                       RMP_POINT(Center_X-Cur_X,Center_Y+Fill_Y,Fill);  
000060  eb060108          ADD      r1,r6,r8
000064  1b28              SUBS     r0,r5,r4
000066  9a10              LDR      r2,[sp,#0x40]
000068  f7fffffe          BL       RMP_Point
;;;2455                       RMP_POINT(Center_X+Cur_X,Center_Y-Fill_Y,Fill); 
00006c  eba60108          SUB      r1,r6,r8
000070  1928              ADDS     r0,r5,r4
000072  9a10              LDR      r2,[sp,#0x40]
000074  f7fffffe          BL       RMP_Point
;;;2456                       RMP_POINT(Center_X-Cur_X,Center_Y-Fill_Y,Fill);  
000078  eba60108          SUB      r1,r6,r8
00007c  1b28              SUBS     r0,r5,r4
00007e  9a10              LDR      r2,[sp,#0x40]
000080  f7fffffe          BL       RMP_Point
;;;2457                       RMP_POINT(Center_X+Fill_Y,Center_Y+Cur_X,Fill); 
000084  1931              ADDS     r1,r6,r4
000086  eb050008          ADD      r0,r5,r8
00008a  9a10              LDR      r2,[sp,#0x40]
00008c  f7fffffe          BL       RMP_Point
;;;2458                       RMP_POINT(Center_X-Fill_Y,Center_Y+Cur_X,Fill);  
000090  1931              ADDS     r1,r6,r4
000092  eba50008          SUB      r0,r5,r8
000096  9a10              LDR      r2,[sp,#0x40]
000098  f7fffffe          BL       RMP_Point
;;;2459                       RMP_POINT(Center_X+Fill_Y,Center_Y-Cur_X,Fill);  
00009c  1b31              SUBS     r1,r6,r4
00009e  eb050008          ADD      r0,r5,r8
0000a2  9a10              LDR      r2,[sp,#0x40]
0000a4  f7fffffe          BL       RMP_Point
;;;2460                       RMP_POINT(Center_X-Fill_Y,Center_Y-Cur_X,Fill);
0000a8  1b31              SUBS     r1,r6,r4
0000aa  eba50008          SUB      r0,r5,r8
0000ae  9a10              LDR      r2,[sp,#0x40]
0000b0  f7fffffe          BL       RMP_Point
0000b4  bf00              NOP                            ;2451
                  |L5.182|
0000b6  f1080801          ADD      r8,r8,#1              ;2448
                  |L5.186|
0000ba  45b8              CMP      r8,r7                 ;2448
0000bc  ddc7              BLE      |L5.78|
0000be  e037              B        |L5.304|
                  |L5.192|
;;;2461                   }
;;;2462               }
;;;2463               /* Here the "Cur_X" is already out of range. We do not check the conditions anymore */
;;;2464               else
;;;2465               {
;;;2466                   for(Fill_Y=Cur_X;Fill_Y<=Cur_Y;Fill_Y++)  
0000c0  46a0              MOV      r8,r4
0000c2  e033              B        |L5.300|
                  |L5.196|
;;;2467                   {                   
;;;2468                       RMP_POINT(Center_X+Cur_X,Center_Y+Fill_Y,Fill);  
0000c4  eb060108          ADD      r1,r6,r8
0000c8  1928              ADDS     r0,r5,r4
0000ca  9a10              LDR      r2,[sp,#0x40]
0000cc  f7fffffe          BL       RMP_Point
;;;2469                       RMP_POINT(Center_X-Cur_X,Center_Y+Fill_Y,Fill);  
0000d0  eb060108          ADD      r1,r6,r8
0000d4  1b28              SUBS     r0,r5,r4
0000d6  9a10              LDR      r2,[sp,#0x40]
0000d8  f7fffffe          BL       RMP_Point
;;;2470                       RMP_POINT(Center_X+Cur_X,Center_Y-Fill_Y,Fill); 
0000dc  eba60108          SUB      r1,r6,r8
0000e0  1928              ADDS     r0,r5,r4
0000e2  9a10              LDR      r2,[sp,#0x40]
0000e4  f7fffffe          BL       RMP_Point
;;;2471                       RMP_POINT(Center_X-Cur_X,Center_Y-Fill_Y,Fill);  
0000e8  eba60108          SUB      r1,r6,r8
0000ec  1b28              SUBS     r0,r5,r4
0000ee  9a10              LDR      r2,[sp,#0x40]
0000f0  f7fffffe          BL       RMP_Point
;;;2472                       RMP_POINT(Center_X+Fill_Y,Center_Y+Cur_X,Fill); 
0000f4  1931              ADDS     r1,r6,r4
0000f6  eb050008          ADD      r0,r5,r8
0000fa  9a10              LDR      r2,[sp,#0x40]
0000fc  f7fffffe          BL       RMP_Point
;;;2473                       RMP_POINT(Center_X-Fill_Y,Center_Y+Cur_X,Fill);  
000100  1931              ADDS     r1,r6,r4
000102  eba50008          SUB      r0,r5,r8
000106  9a10              LDR      r2,[sp,#0x40]
000108  f7fffffe          BL       RMP_Point
;;;2474                       RMP_POINT(Center_X+Fill_Y,Center_Y-Cur_X,Fill);  
00010c  1b31              SUBS     r1,r6,r4
00010e  eb050008          ADD      r0,r5,r8
000112  9a10              LDR      r2,[sp,#0x40]
000114  e000              B        |L5.280|
                  |L5.278|
000116  e046              B        |L5.422|
                  |L5.280|
000118  f7fffffe          BL       RMP_Point
;;;2475                       RMP_POINT(Center_X-Fill_Y,Center_Y-Cur_X,Fill);
00011c  1b31              SUBS     r1,r6,r4
00011e  eba50008          SUB      r0,r5,r8
000122  9a10              LDR      r2,[sp,#0x40]
000124  f7fffffe          BL       RMP_Point
000128  f1080801          ADD      r8,r8,#1              ;2466
                  |L5.300|
00012c  45b8              CMP      r8,r7                 ;2466
00012e  ddc9              BLE      |L5.196|
                  |L5.304|
;;;2476                   }
;;;2477               }
;;;2478               RMP_POINT(Center_X+Cur_X,Center_Y+Cur_Y,Border);  
000130  19f1              ADDS     r1,r6,r7
000132  1928              ADDS     r0,r5,r4
000134  9a06              LDR      r2,[sp,#0x18]
000136  f7fffffe          BL       RMP_Point
;;;2479               RMP_POINT(Center_X-Cur_X,Center_Y+Cur_Y,Border);  
00013a  19f1              ADDS     r1,r6,r7
00013c  1b28              SUBS     r0,r5,r4
00013e  9a06              LDR      r2,[sp,#0x18]
000140  f7fffffe          BL       RMP_Point
;;;2480               RMP_POINT(Center_X+Cur_X,Center_Y-Cur_Y,Border); 
000144  1bf1              SUBS     r1,r6,r7
000146  1928              ADDS     r0,r5,r4
000148  9a06              LDR      r2,[sp,#0x18]
00014a  f7fffffe          BL       RMP_Point
;;;2481               RMP_POINT(Center_X-Cur_X,Center_Y-Cur_Y,Border);  
00014e  1bf1              SUBS     r1,r6,r7
000150  1b28              SUBS     r0,r5,r4
000152  9a06              LDR      r2,[sp,#0x18]
000154  f7fffffe          BL       RMP_Point
;;;2482               RMP_POINT(Center_X+Cur_Y,Center_Y+Cur_X,Border); 
000158  1931              ADDS     r1,r6,r4
00015a  19e8              ADDS     r0,r5,r7
00015c  9a06              LDR      r2,[sp,#0x18]
00015e  f7fffffe          BL       RMP_Point
;;;2483               RMP_POINT(Center_X-Cur_Y,Center_Y+Cur_X,Border);  
000162  1931              ADDS     r1,r6,r4
000164  1be8              SUBS     r0,r5,r7
000166  9a06              LDR      r2,[sp,#0x18]
000168  f7fffffe          BL       RMP_Point
;;;2484               RMP_POINT(Center_X+Cur_Y,Center_Y-Cur_X,Border);  
00016c  1b31              SUBS     r1,r6,r4
00016e  19e8              ADDS     r0,r5,r7
000170  9a06              LDR      r2,[sp,#0x18]
000172  f7fffffe          BL       RMP_Point
;;;2485               RMP_POINT(Center_X-Cur_Y,Center_Y-Cur_X,Border);
000176  1b31              SUBS     r1,r6,r4
000178  1be8              SUBS     r0,r5,r7
00017a  9a06              LDR      r2,[sp,#0x18]
00017c  f7fffffe          BL       RMP_Point
;;;2486   
;;;2487               if(Error<0) 
000180  f1ba0f00          CMP      r10,#0
000184  da04              BGE      |L5.400|
;;;2488                   Error=Error+(Cur_X<<2)+6;
000186  eb0a0084          ADD      r0,r10,r4,LSL #2
00018a  f1000a06          ADD      r10,r0,#6
00018e  e005              B        |L5.412|
                  |L5.400|
;;;2489               else 
;;;2490               {  
;;;2491                   Error=Error+((Cur_X-Cur_Y)<<2)+10;  
000190  1be0              SUBS     r0,r4,r7
000192  eb0a0080          ADD      r0,r10,r0,LSL #2
000196  f1000a0a          ADD      r10,r0,#0xa
;;;2492                   Cur_Y--;  
00019a  1e7f              SUBS     r7,r7,#1
                  |L5.412|
;;;2493               }  
;;;2494               Cur_X++;  
00019c  1c64              ADDS     r4,r4,#1
                  |L5.414|
00019e  42bc              CMP      r4,r7                 ;2444
0001a0  f77faf51          BLE      |L5.70|
0001a4  e037              B        |L5.534|
                  |L5.422|
;;;2495           }
;;;2496       }
;;;2497       else 
;;;2498       {  
;;;2499           /* Border only */ 
;;;2500           while(Cur_X<=Cur_Y) 
0001a6  e034              B        |L5.530|
                  |L5.424|
;;;2501           {
;;;2502               RMP_POINT(Center_X+Cur_X,Center_Y+Cur_Y,Border);  
0001a8  19f1              ADDS     r1,r6,r7
0001aa  1928              ADDS     r0,r5,r4
0001ac  9a06              LDR      r2,[sp,#0x18]
0001ae  f7fffffe          BL       RMP_Point
;;;2503               RMP_POINT(Center_X-Cur_X,Center_Y+Cur_Y,Border);  
0001b2  19f1              ADDS     r1,r6,r7
0001b4  1b28              SUBS     r0,r5,r4
0001b6  9a06              LDR      r2,[sp,#0x18]
0001b8  f7fffffe          BL       RMP_Point
;;;2504               RMP_POINT(Center_X+Cur_X,Center_Y-Cur_Y,Border); 
0001bc  1bf1              SUBS     r1,r6,r7
0001be  1928              ADDS     r0,r5,r4
0001c0  9a06              LDR      r2,[sp,#0x18]
0001c2  f7fffffe          BL       RMP_Point
;;;2505               RMP_POINT(Center_X-Cur_X,Center_Y-Cur_Y,Border);  
0001c6  1bf1              SUBS     r1,r6,r7
0001c8  1b28              SUBS     r0,r5,r4
0001ca  9a06              LDR      r2,[sp,#0x18]
0001cc  f7fffffe          BL       RMP_Point
;;;2506               RMP_POINT(Center_X+Cur_Y,Center_Y+Cur_X,Border); 
0001d0  1931              ADDS     r1,r6,r4
0001d2  19e8              ADDS     r0,r5,r7
0001d4  9a06              LDR      r2,[sp,#0x18]
0001d6  f7fffffe          BL       RMP_Point
;;;2507               RMP_POINT(Center_X-Cur_Y,Center_Y+Cur_X,Border);  
0001da  1931              ADDS     r1,r6,r4
0001dc  1be8              SUBS     r0,r5,r7
0001de  9a06              LDR      r2,[sp,#0x18]
0001e0  f7fffffe          BL       RMP_Point
;;;2508               RMP_POINT(Center_X+Cur_Y,Center_Y-Cur_X,Border);  
0001e4  1b31              SUBS     r1,r6,r4
0001e6  19e8              ADDS     r0,r5,r7
0001e8  9a06              LDR      r2,[sp,#0x18]
0001ea  f7fffffe          BL       RMP_Point
;;;2509               RMP_POINT(Center_X-Cur_Y,Center_Y-Cur_X,Border);
0001ee  1b31              SUBS     r1,r6,r4
0001f0  1be8              SUBS     r0,r5,r7
0001f2  9a06              LDR      r2,[sp,#0x18]
0001f4  f7fffffe          BL       RMP_Point
;;;2510   
;;;2511               if(Error<0)
0001f8  f1ba0f00          CMP      r10,#0
0001fc  da04              BGE      |L5.520|
;;;2512                   Error=Error+(Cur_X<<2)+6;
0001fe  eb0a0084          ADD      r0,r10,r4,LSL #2
000202  f1000a06          ADD      r10,r0,#6
000206  e003              B        |L5.528|
                  |L5.520|
;;;2513               else 
;;;2514               {
;;;2515                   Error=Error+((Cur_X-Cur_Y)<<2);
000208  1be0              SUBS     r0,r4,r7
00020a  eb0a0a80          ADD      r10,r10,r0,LSL #2
;;;2516                   Cur_Y--;
00020e  1e7f              SUBS     r7,r7,#1
                  |L5.528|
;;;2517               }
;;;2518               Cur_X++;  
000210  1c64              ADDS     r4,r4,#1
                  |L5.530|
000212  42bc              CMP      r4,r7                 ;2500
000214  ddc8              BLE      |L5.424|
                  |L5.534|
;;;2519           }  
;;;2520       }
;;;2521   }
000216  b007              ADD      sp,sp,#0x1c
000218  e8bd8ff0          POP      {r4-r11,pc}
;;;2522   /* End Function:RMP_Circle ***************************************************/
                          ENDP


                          AREA ||i.RMP_Clear||, CODE, READONLY, ALIGN=1

                  RMP_Clear PROC
;;;37     ******************************************************************************/
;;;38     void RMP_Clear(volatile void* Addr, ptr_t Size)
000000  b570              PUSH     {r4-r6,lr}
;;;39     {
000002  4604              MOV      r4,r0
;;;40         ptr_t* Word_Inc;
;;;41         u8* Byte_Inc;
;;;42         ptr_t Words;
;;;43         ptr_t Bytes;
;;;44         
;;;45         /* On processors not that fast, copy by word is really important */
;;;46         Word_Inc=(ptr_t*)Addr;
000004  4620              MOV      r0,r4
;;;47         for(Words=Size/sizeof(ptr_t);Words>0;Words--)
000006  088d              LSRS     r5,r1,#2
000008  e003              B        |L6.18|
                  |L6.10|
;;;48         {
;;;49             *Word_Inc=0;
00000a  2600              MOVS     r6,#0
00000c  6006              STR      r6,[r0,#0]
;;;50             Word_Inc++;
00000e  1d00              ADDS     r0,r0,#4
000010  1e6d              SUBS     r5,r5,#1              ;47
                  |L6.18|
000012  2d00              CMP      r5,#0                 ;47
000014  d1f9              BNE      |L6.10|
;;;51         }
;;;52         
;;;53         /* Get the final bytes */
;;;54         Byte_Inc=(u8*)Word_Inc;
000016  4602              MOV      r2,r0
;;;55         for(Bytes=Size%sizeof(ptr_t);Bytes>0;Bytes--)
000018  f0010303          AND      r3,r1,#3
00001c  e003              B        |L6.38|
                  |L6.30|
;;;56         {
;;;57             *Byte_Inc=0;
00001e  2600              MOVS     r6,#0
000020  7016              STRB     r6,[r2,#0]
;;;58             Byte_Inc++;
000022  1c52              ADDS     r2,r2,#1
000024  1e5b              SUBS     r3,r3,#1              ;55
                  |L6.38|
000026  2b00              CMP      r3,#0                 ;55
000028  d1f9              BNE      |L6.30|
;;;59         }
;;;60     }
00002a  bd70              POP      {r4-r6,pc}
;;;61     /* End Function:RMP_Clear ****************************************************/
                          ENDP


                          AREA ||i.RMP_Cmdbtn||, CODE, READONLY, ALIGN=1

                  RMP_Cmdbtn PROC
;;;3043   ******************************************************************************/
;;;3044   void RMP_Cmdbtn(cnt_t Coord_X, cnt_t Coord_Y, cnt_t Length, cnt_t Width, ptr_t Status)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;3045   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8020          LDR      r8,[sp,#0x20]
;;;3046       RMP_Rectangle(Coord_X,Coord_Y,Length,Width,RMP_CTL_GREY,RMP_CTL_GREY);
000010  f64b50d7          MOV      r0,#0xbdd7
000014  9000              STR      r0,[sp,#0]
000016  463b              MOV      r3,r7
000018  4632              MOV      r2,r6
00001a  4629              MOV      r1,r5
00001c  9001              STR      r0,[sp,#4]
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       RMP_Rectangle
;;;3047   
;;;3048       if(Status!=0)
000024  f1b80f00          CMP      r8,#0
000028  d006              BEQ      |L7.56|
;;;3049           RMP_Cmdbtn_Down(Coord_X, Coord_Y, Length, Width);
00002a  463b              MOV      r3,r7
00002c  4632              MOV      r2,r6
00002e  4629              MOV      r1,r5
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       RMP_Cmdbtn_Down
000036  e005              B        |L7.68|
                  |L7.56|
;;;3050       else
;;;3051           RMP_Cmdbtn_Up(Coord_X, Coord_Y, Length, Width);
000038  463b              MOV      r3,r7
00003a  4632              MOV      r2,r6
00003c  4629              MOV      r1,r5
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       RMP_Cmdbtn_Up
                  |L7.68|
;;;3052   }
000044  e8bd81fc          POP      {r2-r8,pc}
;;;3053   /* End Function:RMP_Cmdbtn ***************************************************/
                          ENDP


                          AREA ||i.RMP_Cmdbtn_Down||, CODE, READONLY, ALIGN=1

                  RMP_Cmdbtn_Down PROC
;;;2994   ******************************************************************************/
;;;2995   void RMP_Cmdbtn_Down(cnt_t Coord_X, cnt_t Coord_Y, cnt_t Length, cnt_t Width)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2996   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;2997       RMP_Line(Coord_X,Coord_Y,Coord_X+Length-1,Coord_Y,RMP_CTL_BLACK);
00000a  2000              MOVS     r0,#0
00000c  9000              STR      r0,[sp,#0]
00000e  19a0              ADDS     r0,r4,r6
000010  1e42              SUBS     r2,r0,#1
000012  462b              MOV      r3,r5
000014  4629              MOV      r1,r5
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       RMP_Line
;;;2998       RMP_Line(Coord_X+Length-1,Coord_Y,Coord_X+Length-1,Coord_Y+Width-1,RMP_CTL_WHITE);
00001c  f64f70ff          MOV      r0,#0xffff
000020  19e9              ADDS     r1,r5,r7
000022  1e4b              SUBS     r3,r1,#1
000024  19a1              ADDS     r1,r4,r6
000026  1e4a              SUBS     r2,r1,#1
000028  19a1              ADDS     r1,r4,r6
00002a  9000              STR      r0,[sp,#0]
00002c  1e48              SUBS     r0,r1,#1
00002e  4629              MOV      r1,r5
000030  f7fffffe          BL       RMP_Line
;;;2999       RMP_Line(Coord_X+Length-1,Coord_Y+Width-1,Coord_X,Coord_Y+Width-1,RMP_CTL_WHITE);
000034  f64f70ff          MOV      r0,#0xffff
000038  19ea              ADDS     r2,r5,r7
00003a  1e53              SUBS     r3,r2,#1
00003c  19ea              ADDS     r2,r5,r7
00003e  1e51              SUBS     r1,r2,#1
000040  19a2              ADDS     r2,r4,r6
000042  9000              STR      r0,[sp,#0]
000044  1e50              SUBS     r0,r2,#1
000046  4622              MOV      r2,r4
000048  f7fffffe          BL       RMP_Line
;;;3000       RMP_Line(Coord_X,Coord_Y+Width-1,Coord_X,Coord_Y,RMP_CTL_BLACK);
00004c  2000              MOVS     r0,#0
00004e  9000              STR      r0,[sp,#0]
000050  19e8              ADDS     r0,r5,r7
000052  1e41              SUBS     r1,r0,#1
000054  462b              MOV      r3,r5
000056  4622              MOV      r2,r4
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       RMP_Line
;;;3001       /* Clear the old shadow */
;;;3002       RMP_Line(Coord_X+Length-2,Coord_Y+Width-2,Coord_X+1,Coord_Y+Width-2,RMP_CTL_GREY);    
00005e  f64b50d7          MOV      r0,#0xbdd7
000062  19ea              ADDS     r2,r5,r7
000064  1e93              SUBS     r3,r2,#2
000066  19ea              ADDS     r2,r5,r7
000068  1e91              SUBS     r1,r2,#2
00006a  19a2              ADDS     r2,r4,r6
00006c  9000              STR      r0,[sp,#0]
00006e  1e90              SUBS     r0,r2,#2
000070  1c62              ADDS     r2,r4,#1
000072  f7fffffe          BL       RMP_Line
;;;3003       RMP_Line(Coord_X+Length-2,Coord_Y+1,Coord_X+Length-2,Coord_Y+Width-2,RMP_CTL_GREY);    
000076  f64b50d7          MOV      r0,#0xbdd7
00007a  19e9              ADDS     r1,r5,r7
00007c  1e8b              SUBS     r3,r1,#2
00007e  19a1              ADDS     r1,r4,r6
000080  1e8a              SUBS     r2,r1,#2
000082  19a1              ADDS     r1,r4,r6
000084  9000              STR      r0,[sp,#0]
000086  1e88              SUBS     r0,r1,#2
000088  1c69              ADDS     r1,r5,#1
00008a  f7fffffe          BL       RMP_Line
;;;3004       /* The shadow */                            
;;;3005       RMP_Line(Coord_X+1,Coord_Y+Width-2,Coord_X+1,Coord_Y+1,RMP_CTL_DARK);    
00008e  f64730ef          MOV      r0,#0x7bef
000092  9000              STR      r0,[sp,#0]
000094  19e8              ADDS     r0,r5,r7
000096  1e81              SUBS     r1,r0,#2
000098  1c6b              ADDS     r3,r5,#1
00009a  1c62              ADDS     r2,r4,#1
00009c  1c60              ADDS     r0,r4,#1
00009e  f7fffffe          BL       RMP_Line
;;;3006       RMP_Line(Coord_X+1,Coord_Y+1,Coord_X+Length-2,Coord_Y+1,RMP_CTL_DARK);    
0000a2  f64730ef          MOV      r0,#0x7bef
0000a6  9000              STR      r0,[sp,#0]
0000a8  19a0              ADDS     r0,r4,r6
0000aa  1e82              SUBS     r2,r0,#2
0000ac  1c6b              ADDS     r3,r5,#1
0000ae  1c69              ADDS     r1,r5,#1
0000b0  1c60              ADDS     r0,r4,#1
0000b2  f7fffffe          BL       RMP_Line
;;;3007   }
0000b6  bdf8              POP      {r3-r7,pc}
;;;3008   /* End Function:RMP_Cmdbtn_Down **********************************************/
                          ENDP


                          AREA ||i.RMP_Cmdbtn_Up||, CODE, READONLY, ALIGN=1

                  RMP_Cmdbtn_Up PROC
;;;3018   ******************************************************************************/
;;;3019   void RMP_Cmdbtn_Up(cnt_t Coord_X, cnt_t Coord_Y, cnt_t Length, cnt_t Width)
000000  b5f8              PUSH     {r3-r7,lr}
;;;3020   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;3021       RMP_Line(Coord_X,Coord_Y,Coord_X+Length-1,Coord_Y,RMP_CTL_WHITE);
00000a  f64f70ff          MOV      r0,#0xffff
00000e  9000              STR      r0,[sp,#0]
000010  19a0              ADDS     r0,r4,r6
000012  1e42              SUBS     r2,r0,#1
000014  462b              MOV      r3,r5
000016  4629              MOV      r1,r5
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       RMP_Line
;;;3022       RMP_Line(Coord_X+Length-1,Coord_Y,Coord_X+Length-1,Coord_Y+Width-1,RMP_CTL_BLACK);
00001e  2000              MOVS     r0,#0
000020  19e9              ADDS     r1,r5,r7
000022  1e4b              SUBS     r3,r1,#1
000024  19a1              ADDS     r1,r4,r6
000026  1e4a              SUBS     r2,r1,#1
000028  19a1              ADDS     r1,r4,r6
00002a  9000              STR      r0,[sp,#0]
00002c  1e48              SUBS     r0,r1,#1
00002e  4629              MOV      r1,r5
000030  f7fffffe          BL       RMP_Line
;;;3023       RMP_Line(Coord_X+Length-1,Coord_Y+Width-1,Coord_X,Coord_Y+Width-1,RMP_CTL_BLACK);
000034  2000              MOVS     r0,#0
000036  19ea              ADDS     r2,r5,r7
000038  1e53              SUBS     r3,r2,#1
00003a  19ea              ADDS     r2,r5,r7
00003c  1e51              SUBS     r1,r2,#1
00003e  19a2              ADDS     r2,r4,r6
000040  9000              STR      r0,[sp,#0]
000042  1e50              SUBS     r0,r2,#1
000044  4622              MOV      r2,r4
000046  f7fffffe          BL       RMP_Line
;;;3024       RMP_Line(Coord_X,Coord_Y+Width-1,Coord_X,Coord_Y,RMP_CTL_WHITE);
00004a  f64f70ff          MOV      r0,#0xffff
00004e  9000              STR      r0,[sp,#0]
000050  19e8              ADDS     r0,r5,r7
000052  1e41              SUBS     r1,r0,#1
000054  462b              MOV      r3,r5
000056  4622              MOV      r2,r4
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       RMP_Line
;;;3025       /* Clear the old shadow */
;;;3026       RMP_Line(Coord_X+1,Coord_Y+Width-2,Coord_X+1,Coord_Y+1,RMP_CTL_GREY);    
00005e  f64b50d7          MOV      r0,#0xbdd7
000062  9000              STR      r0,[sp,#0]
000064  19e8              ADDS     r0,r5,r7
000066  1e81              SUBS     r1,r0,#2
000068  1c6b              ADDS     r3,r5,#1
00006a  1c62              ADDS     r2,r4,#1
00006c  1c60              ADDS     r0,r4,#1
00006e  f7fffffe          BL       RMP_Line
;;;3027       RMP_Line(Coord_X+1,Coord_Y+1,Coord_X+Length-2,Coord_Y+1,RMP_CTL_GREY);    
000072  f64b50d7          MOV      r0,#0xbdd7
000076  9000              STR      r0,[sp,#0]
000078  19a0              ADDS     r0,r4,r6
00007a  1e82              SUBS     r2,r0,#2
00007c  1c6b              ADDS     r3,r5,#1
00007e  1c69              ADDS     r1,r5,#1
000080  1c60              ADDS     r0,r4,#1
000082  f7fffffe          BL       RMP_Line
;;;3028       /* The shadow */
;;;3029       RMP_Line(Coord_X+Length-2,Coord_Y+Width-2,Coord_X+1,Coord_Y+Width-2,RMP_CTL_DARK);    
000086  f64730ef          MOV      r0,#0x7bef
00008a  19ea              ADDS     r2,r5,r7
00008c  1e93              SUBS     r3,r2,#2
00008e  19ea              ADDS     r2,r5,r7
000090  1e91              SUBS     r1,r2,#2
000092  19a2              ADDS     r2,r4,r6
000094  9000              STR      r0,[sp,#0]
000096  1e90              SUBS     r0,r2,#2
000098  1c62              ADDS     r2,r4,#1
00009a  f7fffffe          BL       RMP_Line
;;;3030       RMP_Line(Coord_X+Length-2,Coord_Y+1,Coord_X+Length-2,Coord_Y+Width-2,RMP_CTL_DARK);    
00009e  f64730ef          MOV      r0,#0x7bef
0000a2  19e9              ADDS     r1,r5,r7
0000a4  1e8b              SUBS     r3,r1,#2
0000a6  19a1              ADDS     r1,r4,r6
0000a8  1e8a              SUBS     r2,r1,#2
0000aa  19a1              ADDS     r1,r4,r6
0000ac  9000              STR      r0,[sp,#0]
0000ae  1e88              SUBS     r0,r1,#2
0000b0  1c69              ADDS     r1,r5,#1
0000b2  f7fffffe          BL       RMP_Line
;;;3031   }
0000b6  bdf8              POP      {r3-r7,pc}
;;;3032   /* End Function:RMP_Cmdbtn_Up ************************************************/
                          ENDP


                          AREA ||i.RMP_Cursor||, CODE, READONLY, ALIGN=2

                  RMP_Cursor PROC
;;;2734   #ifdef RMP_CTL_BLACK
;;;2735   void RMP_Cursor(cnt_t Coord_X, cnt_t Coord_Y, ptr_t Style)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;2736   {
000004  4681              MOV      r9,r0
000006  468a              MOV      r10,r1
000008  4693              MOV      r11,r2
;;;2737       cnt_t Count;
;;;2738       cnt_t Size_B;
;;;2739       cnt_t Size_W;
;;;2740       const u8* Black;
;;;2741       const u8* White;
;;;2742   
;;;2743       /* Normal Mouse - all matrix encoded in (Y,X) */
;;;2744       static const u8 Arrow_B[]=
;;;2745       {
;;;2746           0x00,0x10,0x11,0x20,0x22,0x30,0x33,0x40,0x44,0x50,0x55,0x60,0x66,0x70,0x77,0x80,
;;;2747           0x88,0x90,0x95,0x96,0x97,0x98,0x99,0xA0,0xA2,0xA3,0xA5,0xB0,0xB1,0xB3,0xB6,0xC0,
;;;2748           0xC1,0xC4,0xC6,0xD0,0xD4,0xD7,0xE5,0xE7,0xF5,0xF6
;;;2749       };
;;;2750       static const u8 Arrow_W[]=
;;;2751       {
;;;2752           0x21,0x31,0x32,0x41,0x42,0x43,0x51,0x52,0x53,0x54,0x61,0x62,0x63,0x64,0x65,0x71,
;;;2753           0x72,0x73,0x74,0x75,0x76,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x91,0x92,0x93,0x94,
;;;2754           0xA1,0xA4,0xB4,0xB5,0xC5,0xD5,0xD6,0xE6
;;;2755       };
;;;2756       /* Busy mark - no white part */
;;;2757       static const u8 Busy_B[]=
;;;2758       {
;;;2759           0x0A,0x0B,0x0C,0x0D,0x0E,0x1A,0x1B,0x1D,0x1E,0x2A,0x2C,0x2E,0x3B,0x3D,0x4C,0x5B,
;;;2760           0x5D,0x6A,0x6E,0x7A,0x7C,0x7E,0x8A,0x8B,0x8C,0x8D,0x8E
;;;2761       };
;;;2762       static const u8 Busy_W[]=
;;;2763       {
;;;2764           0x1C,0x2B,0x2D,0x3C,0x5C,0x6B,0x6C,0x6D,0x7B,0x7D
;;;2765       };
;;;2766       /* Question mark - no white part */
;;;2767       static const u8 Question[]=
;;;2768       {
;;;2769           0x0B,0x0C,0x0D,0x1A,0x1B,0x1C,0x1D,0x1E,0x29,0x2A,0x2B,0x2D,0x2E,0x2F,0x39,0x3A,
;;;2770           0x3E,0x3F,0x4A,0x4D,0x4E,0x4F,0x5C,0x5D,0x5E,0x6C,0x6D,0x8D,0x8E,0x9D,0x9E
;;;2771       };
;;;2772       /* Hand-shaped cursor */
;;;2773       static const u8 Hand_B[]=
;;;2774       {
;;;2775           0x05,0x06,0x14,0x17,0x24,0x27,0x34,0x37,0x39,0x44,0x47,0x48,0x4A,0x4C,0x51,0x52,
;;;2776           0x54,0x57,0x5A,0x5B,0x5D,0x5E,0x60,0x63,0x64,0x67,0x6A,0x6D,0x6F,0x70,0x74,0x77,
;;;2777           0x7A,0x7D,0x7F,0x80,0x8F,0x90,0x9F,0xA0,0xAF,0xB0,0xBF,0xC1,0xCE,0xD1,0xD2,0xD3,
;;;2778           0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xE1,0xEE,0xF2,0xF3,0xF4,
;;;2779           0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD
;;;2780       };
;;;2781       static const u8 Hand_W[]=
;;;2782       {
;;;2783           0x15,0x16,0x25,0x26,0x35,0x36,0x45,0x46,0x49,0x55,0x56,0x58,0x59,0x5C,0x61,0x62,
;;;2784           0x65,0x66,0x68,0x69,0x6B,0x6C,0x6E,0x71,0x72,0x73,0x75,0x76,0x78,0x79,0x7B,0x7C,
;;;2785           0x7E,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x91,
;;;2786           0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0xA1,0xA2,0xA3,
;;;2787           0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xB1,0xB2,0xB3,0xB4,0xB5,
;;;2788           0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,
;;;2789           0xC9,0xCA,0xCB,0xCC,0xCD,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,
;;;2790           0xED
;;;2791       };
;;;2792       /* The cursor for text editing - no white part */
;;;2793       static const u8 Text[]=
;;;2794       {
;;;2795           0x00,0x01,0x02,0x04,0x05,0x06,0x13,0x23,0x33,0x43,0x53,0x63,0x73,0x83,0x93,0xA3,
;;;2796           0xB3,0xC3,0xD3,0xE3,0xF0,0xF1,0xF2,0xF4,0xF5,0xF6
;;;2797       };
;;;2798       /* The stop cursor */
;;;2799       static const u8 Stop_B[]=
;;;2800       {
;;;2801           0x05,0x06,0x07,0x08,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x22,0x23,0x24,0x29,
;;;2802           0x2A,0x2B,0x31,0x32,0x33,0x34,0x3A,0x3B,0x3C,0x41,0x42,0x43,0x44,0x45,0x4B,0x4C,
;;;2803           0x50,0x51,0x54,0x55,0x56,0x5C,0x5D,0x60,0x61,0x65,0x66,0x67,0x6C,0x6D,0x70,0x71,
;;;2804           0x76,0x77,0x78,0x7C,0x7D,0x80,0x81,0x87,0x88,0x89,0x8C,0x8D,0x91,0x92,0x98,0x99,
;;;2805           0x9A,0x9B,0x9C,0xA1,0xA2,0xA3,0xA9,0xAA,0xAB,0xAC,0xB2,0xB3,0xB4,0xB9,0xBA,0xBB,
;;;2806           0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xD5,0xD6,0xD7,0xD8
;;;2807       };
;;;2808       static const u8 Stop_W[]=
;;;2809       {
;;;2810           0x25,0x26,0x27,0x28,0x35,0x36,0x37,0x38,0x39,0x46,0x47,0x48,0x49,0x4A,0x52,0x53,
;;;2811           0x57,0x58,0x59,0x5A,0x5B,0x62,0x63,0x64,0x68,0x69,0x6A,0x6B,0x72,0x73,0x74,0x75,
;;;2812           0x79,0x7A,0x7B,0x82,0x83,0x84,0x85,0x86,0x8A,0x8B,0x93,0x94,0x95,0x96,0x97,0xA4,
;;;2813           0xA5,0xA6,0xA7,0xA8,0xB5,0xB6,0xB7,0xB8
;;;2814       };
;;;2815          /* Cross arrow - no white part  */
;;;2816       static const u8 Adj_ALL[]=
;;;2817       {
;;;2818           0x07,0x16,0x17,0x18,0x25,0x26,0x27,0x28,0x29,0x37,0x47,0x52,0x57,0x5C,0x61,0x62,
;;;2819           0x67,0x6C,0x6D,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7A,0x7B,0x7C,
;;;2820           0x7D,0x7E,0x81,0x82,0x87,0x8C,0x8D,0x92,0x97,0x9C,0xA7,0xB7,0xC5,0xC6,0xC7,0xC8,
;;;2821           0xC9,0xD6,0xD7,0xD8,0xE7
;;;2822       };    
;;;2823       /* Left to right arrow - no white part */
;;;2824       static const u8 Adj_LR[]=
;;;2825       {
;;;2826           0x52,0x5D,0x61,0x62,0x6D,0x6E,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,
;;;2827           0x7A,0x7B,0x7C,0x7D,0x7E,0x7F,0x81,0x82,0x8D,0x8E,0x92,0x9D
;;;2828       };
;;;2829       /* Up to down arrow - no white part */
;;;2830       static const u8 Adj_UD[]=
;;;2831       {
;;;2832           0x07,0x16,0x17,0x18,0x25,0x26,0x27,0x28,0x29,0x37,0x47,0x57,0x67,0x77,0x87,0x97,
;;;2833           0xA7,0xB7,0xC7,0xD5,0xD6,0xD7,0xD8,0xD9,0xE6,0xE7,0xE8,0xF7
;;;2834   
;;;2835       };
;;;2836       /* Bottom-right to top-left arrow - no white part */
;;;2837       static const u8 Adj_BRUL[]=
;;;2838       {
;;;2839           0x00,0x01,0x02,0x03,0x04,0x10,0x11,0x12,0x13,0x20,0x21,0x22,0x30,0x31,0x33,0x40,
;;;2840           0x44,0x55,0x66,0x77,0x88,0x99,0xAA,0xBB,0xBF,0xCC,0xCE,0xCF,0xDD,0xDE,0xDF,0xEC,
;;;2841           0xED,0xEE,0xEF,0xFB,0xFC,0xFD,0xFE,0xFF
;;;2842       };
;;;2843       /* Bottom-left to top-right arrow - no white part */
;;;2844       static const u8 Adj_BLUR[]=
;;;2845       {
;;;2846           0x0B,0x0C,0x0D,0x0E,0x0F,0x1C,0x1D,0x1E,0x1F,0x2D,0x2E,0x2F,0x3C,0x3E,0x3F,0x4B,
;;;2847           0x4F,0x5A,0x69,0x78,0x87,0x96,0xA5,0xB0,0xB4,0xC0,0xC1,0xC3,0xD0,0xD1,0xD2,0xE0,
;;;2848           0xE1,0xE2,0xE3,0xF0,0xF1,0xF2,0xF3,0xF4
;;;2849       };
;;;2850       /* The crosshair cursor - no white part */
;;;2851       static const u8 Cross[]=
;;;2852       {
;;;2853           0x07,0x17,0x27,0x37,0x46,0x47,0x48,0x55,0x57,0x59,0x64,0x6A,0x70,0x71,0x72,0x73,
;;;2854           0x74,0x75,0x77,0x79,0x7A,0x7B,0x7C,0x7D,0x7E,0x84,0x8A,0x95,0x97,0x99,0xA6,0xA7,
;;;2855           0xA8,0xB7,0xC7,0xD7,0xE7
;;;2856       };
;;;2857       
;;;2858       /* Draw them */
;;;2859       switch(Style)
00000a  f1bb0f0c          CMP      r11,#0xc
00000e  d279              BCS      |L10.260|
000010  e8dff00b          TBB      [pc,r11]
000014  060c0d41          DCB      0x06,0x0c,0x0d,0x41
000018  474d5359          DCB      0x47,0x4d,0x53,0x59
00001c  5f656b72          DCB      0x5f,0x65,0x6b,0x72
;;;2860       {
;;;2861           case RMP_CUR_NORM:{Size_B=sizeof(Arrow_B);Size_W=sizeof(Arrow_W);Black=Arrow_B;White=Arrow_W;break;}
000020  272a              MOVS     r7,#0x2a
000022  f04f0828          MOV      r8,#0x28
000026  4d4a              LDR      r5,|L10.336|
000028  4e4a              LDR      r6,|L10.340|
00002a  e06d              B        |L10.264|
;;;2862           case RMP_CUR_BUSY:case RMP_CUR_QUESTION:
00002c  bf00              NOP      
;;;2863           {
;;;2864               for(Count=0;Count<sizeof(Arrow_B);Count++)                                                              
00002e  2400              MOVS     r4,#0
000030  e00d              B        |L10.78|
                  |L10.50|
;;;2865                   RMP_POINT(Coord_X+(Arrow_B[Count]&0x0F),Coord_Y+(Arrow_B[Count]>>4),RMP_CTL_BLACK);
000032  4a47              LDR      r2,|L10.336|
000034  5d12              LDRB     r2,[r2,r4]
000036  eb0a1122          ADD      r1,r10,r2,ASR #4
00003a  4a45              LDR      r2,|L10.336|
00003c  5d12              LDRB     r2,[r2,r4]
00003e  f002020f          AND      r2,r2,#0xf
000042  eb020009          ADD      r0,r2,r9
000046  2200              MOVS     r2,#0
000048  f7fffffe          BL       RMP_Point
00004c  1c64              ADDS     r4,r4,#1              ;2864
                  |L10.78|
00004e  2c2a              CMP      r4,#0x2a              ;2864
000050  d3ef              BCC      |L10.50|
;;;2866               for(Count=0;Count<sizeof(Arrow_W);Count++)                                                              
000052  2400              MOVS     r4,#0
000054  e00e              B        |L10.116|
                  |L10.86|
;;;2867                   RMP_POINT(Coord_X+(Arrow_W[Count]&0x0F),Coord_Y+(Arrow_W[Count]>>4),RMP_CTL_WHITE);
000056  4a3f              LDR      r2,|L10.340|
000058  5d12              LDRB     r2,[r2,r4]
00005a  eb0a1122          ADD      r1,r10,r2,ASR #4
00005e  4a3d              LDR      r2,|L10.340|
000060  5d12              LDRB     r2,[r2,r4]
000062  f002020f          AND      r2,r2,#0xf
000066  eb020009          ADD      r0,r2,r9
00006a  f64f72ff          MOV      r2,#0xffff
00006e  f7fffffe          BL       RMP_Point
000072  1c64              ADDS     r4,r4,#1              ;2866
                  |L10.116|
000074  2c28              CMP      r4,#0x28              ;2866
000076  d3ee              BCC      |L10.86|
;;;2868               
;;;2869               if(Style==RMP_CUR_BUSY)
000078  f1bb0f01          CMP      r11,#1
00007c  d105              BNE      |L10.138|
;;;2870               {
;;;2871                   Size_B=sizeof(Busy_B);
00007e  271b              MOVS     r7,#0x1b
;;;2872                   Size_W=sizeof(Busy_W);
000080  f04f080a          MOV      r8,#0xa
;;;2873                   Black=Busy_B;
000084  4d34              LDR      r5,|L10.344|
;;;2874                   White=Busy_W;
000086  4e35              LDR      r6,|L10.348|
000088  e004              B        |L10.148|
                  |L10.138|
;;;2875               }
;;;2876               else
;;;2877               {
;;;2878                   Size_B=sizeof(Question);
00008a  271f              MOVS     r7,#0x1f
;;;2879                   Size_W=0;
00008c  f04f0800          MOV      r8,#0
;;;2880                   Black=Question;
000090  4d33              LDR      r5,|L10.352|
;;;2881                   White=0;
000092  2600              MOVS     r6,#0
                  |L10.148|
;;;2882               }
;;;2883               break;
000094  e038              B        |L10.264|
;;;2884           }       
;;;2885           case RMP_CUR_HAND:{Size_B=sizeof(Hand_B);Size_W=sizeof(Hand_W);Black=Hand_B;White=Hand_W;break;}
000096  2749              MOVS     r7,#0x49
000098  f04f0871          MOV      r8,#0x71
00009c  4d31              LDR      r5,|L10.356|
00009e  4e32              LDR      r6,|L10.360|
0000a0  e032              B        |L10.264|
;;;2886           case RMP_CUR_TEXT:{Size_B=sizeof(Text);Size_W=0;Black=Text;White=0;break;}
0000a2  271a              MOVS     r7,#0x1a
0000a4  f04f0800          MOV      r8,#0
0000a8  4d30              LDR      r5,|L10.364|
0000aa  2600              MOVS     r6,#0
0000ac  e02c              B        |L10.264|
;;;2887           case RMP_CUR_STOP:{Size_B=sizeof(Stop_B);Size_W=sizeof(Stop_W);Black=Stop_B;White=Stop_W;break;}
0000ae  275c              MOVS     r7,#0x5c
0000b0  f04f0838          MOV      r8,#0x38
0000b4  4d2e              LDR      r5,|L10.368|
0000b6  4e2f              LDR      r6,|L10.372|
0000b8  e026              B        |L10.264|
;;;2888           case RMP_CUR_MOVE:{Size_B=sizeof(Adj_ALL);Size_W=0;Black=Adj_ALL;White=0;break;}
0000ba  2735              MOVS     r7,#0x35
0000bc  f04f0800          MOV      r8,#0
0000c0  4d2d              LDR      r5,|L10.376|
0000c2  2600              MOVS     r6,#0
0000c4  e020              B        |L10.264|
;;;2889           case RMP_CUR_LR:{Size_B=sizeof(Adj_LR);Size_W=0;Black=Adj_LR;White=0;break;}
0000c6  271c              MOVS     r7,#0x1c
0000c8  f04f0800          MOV      r8,#0
0000cc  4d2b              LDR      r5,|L10.380|
0000ce  2600              MOVS     r6,#0
0000d0  e01a              B        |L10.264|
;;;2890           case RMP_CUR_UD:{Size_B=sizeof(Adj_UD);Size_W=0;Black=Adj_UD;White=0;break;}
0000d2  271c              MOVS     r7,#0x1c
0000d4  f04f0800          MOV      r8,#0
0000d8  4d29              LDR      r5,|L10.384|
0000da  2600              MOVS     r6,#0
0000dc  e014              B        |L10.264|
;;;2891           case RMP_CUR_ULBR:{Size_B=sizeof(Adj_BRUL);Size_W=0;Black=Adj_BRUL;White=0;break;}
0000de  2728              MOVS     r7,#0x28
0000e0  f04f0800          MOV      r8,#0
0000e4  4d27              LDR      r5,|L10.388|
0000e6  2600              MOVS     r6,#0
0000e8  e00e              B        |L10.264|
;;;2892           case RMP_CUR_URBL:{Size_B=sizeof(Adj_BLUR);Size_W=0;Black=Adj_BLUR;White=0;break;}
0000ea  2728              MOVS     r7,#0x28
0000ec  f04f0800          MOV      r8,#0
0000f0  4d25              LDR      r5,|L10.392|
0000f2  2600              MOVS     r6,#0
0000f4  e008              B        |L10.264|
0000f6  e005              B        |L10.260|
;;;2893           case RMP_CUR_CROSS:{Size_B=sizeof(Cross);Size_W=0;Black=Cross;White=0;break;}
0000f8  2725              MOVS     r7,#0x25
0000fa  f04f0800          MOV      r8,#0
0000fe  4d23              LDR      r5,|L10.396|
000100  2600              MOVS     r6,#0
000102  e001              B        |L10.264|
                  |L10.260|
;;;2894           default:return;
;;;2895       }
;;;2896       
;;;2897       for(Count=0;Count<Size_B;Count++)                                                              
;;;2898           RMP_POINT(Coord_X+(Black[Count]&0x0F),Coord_Y+(Black[Count]>>4),RMP_CTL_BLACK);
;;;2899       for(Count=0;Count<Size_W;Count++)                                                              
;;;2900           RMP_POINT(Coord_X+(White[Count]&0x0F),Coord_Y+(White[Count]>>4),RMP_CTL_WHITE);
;;;2901   }
000104  e8bd9ff0          POP      {r4-r12,pc}
                  |L10.264|
000108  bf00              NOP                            ;2861
00010a  2400              MOVS     r4,#0                 ;2897
00010c  e00b              B        |L10.294|
                  |L10.270|
00010e  5d2a              LDRB     r2,[r5,r4]            ;2898
000110  eb0a1122          ADD      r1,r10,r2,ASR #4      ;2898
000114  5d2a              LDRB     r2,[r5,r4]            ;2898
000116  f002020f          AND      r2,r2,#0xf            ;2898
00011a  eb020009          ADD      r0,r2,r9              ;2898
00011e  2200              MOVS     r2,#0                 ;2898
000120  f7fffffe          BL       RMP_Point
000124  1c64              ADDS     r4,r4,#1              ;2897
                  |L10.294|
000126  42bc              CMP      r4,r7                 ;2897
000128  dbf1              BLT      |L10.270|
00012a  2400              MOVS     r4,#0                 ;2899
00012c  e00c              B        |L10.328|
                  |L10.302|
00012e  5d32              LDRB     r2,[r6,r4]            ;2900
000130  eb0a1122          ADD      r1,r10,r2,ASR #4      ;2900
000134  5d32              LDRB     r2,[r6,r4]            ;2900
000136  f002020f          AND      r2,r2,#0xf            ;2900
00013a  eb020009          ADD      r0,r2,r9              ;2900
00013e  f64f72ff          MOV      r2,#0xffff            ;2900
000142  f7fffffe          BL       RMP_Point
000146  1c64              ADDS     r4,r4,#1              ;2899
                  |L10.328|
000148  4544              CMP      r4,r8                 ;2899
00014a  dbf0              BLT      |L10.302|
00014c  bf00              NOP      
00014e  e7d9              B        |L10.260|
;;;2902   /* End Function: RMP_Cursor **************************************************/
                          ENDP

                  |L10.336|
                          DCD      Arrow_B
                  |L10.340|
                          DCD      Arrow_W
                  |L10.344|
                          DCD      Busy_B
                  |L10.348|
                          DCD      Busy_W
                  |L10.352|
                          DCD      Question
                  |L10.356|
                          DCD      Hand_B
                  |L10.360|
                          DCD      Hand_W
                  |L10.364|
                          DCD      Text
                  |L10.368|
                          DCD      Stop_B
                  |L10.372|
                          DCD      Stop_W
                  |L10.376|
                          DCD      Adj_ALL
                  |L10.380|
                          DCD      Adj_LR
                  |L10.384|
                          DCD      Adj_UD
                  |L10.388|
                          DCD      Adj_BRUL
                  |L10.392|
                          DCD      Adj_BLUR
                  |L10.396|
                          DCD      Cross

                          AREA ||i.RMP_Dot_Line||, CODE, READONLY, ALIGN=1

                  RMP_Dot_Line PROC
;;;2262   ******************************************************************************/
;;;2263   void RMP_Dot_Line(cnt_t Start_X, cnt_t Start_Y, cnt_t End_X,cnt_t End_Y, ptr_t Dot, ptr_t Space)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;2264   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
;;;2265       cnt_t Trav_X;
;;;2266       cnt_t Trav_Y;
;;;2267       cnt_t Dir_X;
;;;2268       cnt_t Dir_Y;
;;;2269       cnt_t Error;
;;;2270       cnt_t Cur_X;
;;;2271       cnt_t Cur_Y;
;;;2272   
;;;2273       Error=0;
00000c  f04f0a00          MOV      r10,#0
;;;2274       /* Get their absolute value, and then draw the line */
;;;2275       Trav_X=(Start_X>End_X)?(Start_X-End_X):(End_X-Start_X);
000010  4544              CMP      r4,r8
000012  dd02              BLE      |L11.26|
000014  eba40008          SUB      r0,r4,r8
000018  e001              B        |L11.30|
                  |L11.26|
00001a  eba80004          SUB      r0,r8,r4
                  |L11.30|
00001e  9002              STR      r0,[sp,#8]
;;;2276       Trav_Y=(Start_Y>End_Y)?(Start_Y-End_Y):(End_Y-Start_Y);
000020  454d              CMP      r5,r9
000022  dd02              BLE      |L11.42|
000024  eba50009          SUB      r0,r5,r9
000028  e001              B        |L11.46|
                  |L11.42|
00002a  eba90005          SUB      r0,r9,r5
                  |L11.46|
00002e  9001              STR      r0,[sp,#4]
;;;2277   
;;;2278       /* Decide the increment direction */
;;;2279       if(End_X-Start_X>0)
000030  eba80004          SUB      r0,r8,r4
000034  2800              CMP      r0,#0
000036  dd02              BLE      |L11.62|
;;;2280           Dir_X=1;
000038  f04f0b01          MOV      r11,#1
00003c  e001              B        |L11.66|
                  |L11.62|
;;;2281       else
;;;2282           Dir_X=-1;
00003e  f04f3bff          MOV      r11,#0xffffffff
                  |L11.66|
;;;2283   
;;;2284       if(End_Y-Start_Y>0)
000042  eba90005          SUB      r0,r9,r5
000046  2800              CMP      r0,#0
000048  dd02              BLE      |L11.80|
;;;2285           Dir_Y=1;
00004a  2001              MOVS     r0,#1
00004c  9000              STR      r0,[sp,#0]
00004e  e002              B        |L11.86|
                  |L11.80|
;;;2286       else
;;;2287           Dir_Y=-1;
000050  f04f30ff          MOV      r0,#0xffffffff
000054  9000              STR      r0,[sp,#0]
                  |L11.86|
;;;2288   
;;;2289       if(Trav_X>Trav_Y)
000056  e9dd1001          LDRD     r1,r0,[sp,#4]
00005a  4288              CMP      r0,r1
00005c  dd24              BLE      |L11.168|
;;;2290       {
;;;2291           Cur_Y=Start_Y;
00005e  462f              MOV      r7,r5
;;;2292           for(Cur_X=Start_X;Cur_X!=End_X+Dir_X;Cur_X+=Dir_X)
000060  4626              MOV      r6,r4
000062  e01c              B        |L11.158|
                  |L11.100|
;;;2293           {
;;;2294               /* Draw the dot and the white space alternatively */
;;;2295               if((Cur_X&0x01)!=0)
000064  f0060001          AND      r0,r6,#1
000068  b128              CBZ      r0,|L11.118|
;;;2296                   RMP_POINT(Cur_X,Cur_Y,Dot);
00006a  4639              MOV      r1,r7
00006c  4630              MOV      r0,r6
00006e  9a0c              LDR      r2,[sp,#0x30]
000070  f7fffffe          BL       RMP_Point
000074  e007              B        |L11.134|
                  |L11.118|
;;;2297               else
;;;2298               {
;;;2299                   if(Space!=RMP_TRANS)
000076  980d              LDR      r0,[sp,#0x34]
000078  2801              CMP      r0,#1
00007a  d004              BEQ      |L11.134|
;;;2300                       RMP_POINT(Cur_X,Cur_Y,Space);
00007c  4639              MOV      r1,r7
00007e  4630              MOV      r0,r6
000080  9a0d              LDR      r2,[sp,#0x34]
000082  f7fffffe          BL       RMP_Point
                  |L11.134|
;;;2301               }
;;;2302               Error+=Trav_Y;
000086  9801              LDR      r0,[sp,#4]
000088  4482              ADD      r10,r10,r0
;;;2303               if((Error<<1)>=Trav_X)
00008a  9802              LDR      r0,[sp,#8]
00008c  ebb00f4a          CMP      r0,r10,LSL #1
000090  dc04              BGT      |L11.156|
;;;2304               {
;;;2305                   Cur_Y+=Dir_Y;
000092  9800              LDR      r0,[sp,#0]
000094  4407              ADD      r7,r7,r0
;;;2306                   Error-=Trav_X;
000096  9802              LDR      r0,[sp,#8]
000098  ebaa0a00          SUB      r10,r10,r0
                  |L11.156|
00009c  445e              ADD      r6,r6,r11             ;2292
                  |L11.158|
00009e  eb08000b          ADD      r0,r8,r11             ;2292
0000a2  42b0              CMP      r0,r6                 ;2292
0000a4  d1de              BNE      |L11.100|
0000a6  e023              B        |L11.240|
                  |L11.168|
;;;2307               }
;;;2308           }
;;;2309       }
;;;2310       else
;;;2311       {
;;;2312           Cur_X=Start_X;
0000a8  4626              MOV      r6,r4
;;;2313           for(Cur_Y=Start_Y;Cur_Y!=End_Y+Dir_Y;Cur_Y+=Dir_Y)
0000aa  462f              MOV      r7,r5
0000ac  e01c              B        |L11.232|
                  |L11.174|
;;;2314           {
;;;2315               /* Draw the dot and the white space alternatively */
;;;2316               if((Cur_Y&0x01)!=0)
0000ae  f0070001          AND      r0,r7,#1
0000b2  b128              CBZ      r0,|L11.192|
;;;2317                   RMP_POINT(Cur_X,Cur_Y,Dot);
0000b4  4639              MOV      r1,r7
0000b6  4630              MOV      r0,r6
0000b8  9a0c              LDR      r2,[sp,#0x30]
0000ba  f7fffffe          BL       RMP_Point
0000be  e007              B        |L11.208|
                  |L11.192|
;;;2318               else
;;;2319               {
;;;2320                   if(Space!=RMP_TRANS)
0000c0  980d              LDR      r0,[sp,#0x34]
0000c2  2801              CMP      r0,#1
0000c4  d004              BEQ      |L11.208|
;;;2321                       RMP_POINT(Cur_X,Cur_Y,Space);
0000c6  4639              MOV      r1,r7
0000c8  4630              MOV      r0,r6
0000ca  9a0d              LDR      r2,[sp,#0x34]
0000cc  f7fffffe          BL       RMP_Point
                  |L11.208|
;;;2322               }
;;;2323   
;;;2324               Error+=Trav_X;
0000d0  9802              LDR      r0,[sp,#8]
0000d2  4482              ADD      r10,r10,r0
;;;2325               if((Error<<1)>=Trav_Y)
0000d4  9801              LDR      r0,[sp,#4]
0000d6  ebb00f4a          CMP      r0,r10,LSL #1
0000da  dc03              BGT      |L11.228|
;;;2326               {
;;;2327                   Cur_X+=Dir_X;
0000dc  445e              ADD      r6,r6,r11
;;;2328                   Error-=Trav_Y;
0000de  9801              LDR      r0,[sp,#4]
0000e0  ebaa0a00          SUB      r10,r10,r0
                  |L11.228|
0000e4  9800              LDR      r0,[sp,#0]            ;2313
0000e6  4407              ADD      r7,r7,r0              ;2313
                  |L11.232|
0000e8  9800              LDR      r0,[sp,#0]            ;2313
0000ea  4448              ADD      r0,r0,r9              ;2313
0000ec  42b8              CMP      r0,r7                 ;2313
0000ee  d1de              BNE      |L11.174|
                  |L11.240|
;;;2329               }
;;;2330           }
;;;2331       }
;;;2332   }
0000f0  e8bd8ffe          POP      {r1-r11,pc}
;;;2333   /* End Function:RMP_Dot_Line *************************************************/
                          ENDP


                          AREA ||i.RMP_Free||, CODE, READONLY, ALIGN=1

                  RMP_Free PROC
;;;2080   ******************************************************************************/
;;;2081   void RMP_Free(volatile void* Pool, void* Mem_Ptr)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;2082   {
000004  4681              MOV      r9,r0
000006  4688              MOV      r8,r1
;;;2083       volatile struct RMP_Mem* Mem; 
;;;2084       volatile struct RMP_Mem_Head* Mem_Head;
;;;2085       volatile struct RMP_Mem_Head* Left_Head;
;;;2086       volatile struct RMP_Mem_Head* Right_Head;
;;;2087       cnt_t Merge_Left;
;;;2088   
;;;2089       /* See if the address is within the allocatable address range. If not, abort directly. */
;;;2090       Mem=(volatile struct RMP_Mem*)Pool;
000008  464d              MOV      r5,r9
;;;2091       if((((ptr_t)Mem_Ptr)<=((ptr_t)Mem))||(((ptr_t)Mem_Ptr)>=(((ptr_t)Mem)+Mem->Size)))
00000a  45a8              CMP      r8,r5
00000c  d903              BLS      |L12.22|
00000e  6928              LDR      r0,[r5,#0x10]
000010  4428              ADD      r0,r0,r5
000012  4540              CMP      r0,r8
000014  d801              BHI      |L12.26|
                  |L12.22|
;;;2092           return;
;;;2093   
;;;2094       Mem_Head=(struct RMP_Mem_Head*)(((ptr_t)Mem_Ptr)-sizeof(struct RMP_Mem_Head));
;;;2095       /* See if the block can really be freed by this PID. If cannot, return directly */
;;;2096       if(Mem_Head->State==RMP_MEM_FREE)
;;;2097           return;
;;;2098   
;;;2099       /* Now we are sure that it can be freed. Delete it from the allocated list now */
;;;2100       RMP_List_Del(Mem_Head->Head.Prev,Mem_Head->Head.Next);
;;;2101       Mem_Head->State=RMP_MEM_FREE;
;;;2102       
;;;2103       /* Now check if we can merge it with the higher blocks */
;;;2104       Right_Head=(struct RMP_Mem_Head*)(((ptr_t)(Mem_Head->Tail))+sizeof(struct RMP_Mem_Tail));
;;;2105       if(((ptr_t)Right_Head)!=(((ptr_t)Mem)+Mem->Size))
;;;2106       {
;;;2107           /* If this one is unoccupied */
;;;2108           if((Right_Head->State)==RMP_MEM_FREE)
;;;2109           {
;;;2110               /* Delete, merge */
;;;2111               _RMP_Mem_Del(Pool,Right_Head);
;;;2112               _RMP_Mem_Block(Mem_Head,
;;;2113                              ((ptr_t)(Right_Head->Tail))+sizeof(struct RMP_Mem_Tail)-(ptr_t)Mem_Head);
;;;2114           }
;;;2115       }
;;;2116   
;;;2117       /* Now check if we can merge it with the lower blocks */
;;;2118       Merge_Left=0;
;;;2119       if((ptr_t)Mem_Head!=Mem->Start)
;;;2120       {
;;;2121           Left_Head=((struct RMP_Mem_Tail*)(((ptr_t)Mem_Head)-sizeof(struct RMP_Mem_Tail)))->Head;
;;;2122   
;;;2123           /* If this one is unoccupied */
;;;2124           if(Left_Head->State==RMP_MEM_FREE)
;;;2125           {
;;;2126               /* Delete, merge */
;;;2127               _RMP_Mem_Del(Pool, Left_Head);
;;;2128               _RMP_Mem_Block(Left_Head,
;;;2129                              (ptr_t)((ptr_t)(Mem_Head->Tail)+sizeof(struct RMP_Mem_Tail)-(ptr_t)Left_Head));
;;;2130   
;;;2131               /* We have completed the merge here and the original block has destroyed.
;;;2132                * Thus there's no need to insert it into the list again */
;;;2133               Merge_Left=1;
;;;2134           }
;;;2135       }
;;;2136   
;;;2137       /* If we did not merge it with the left-side blocks, insert the original pointer's block 
;;;2138        * into the TLSF table(Merging with the right-side one won't disturb this) */
;;;2139       if(Merge_Left==0)
;;;2140           _RMP_Mem_Ins(Pool, Mem_Head);
;;;2141       else
;;;2142           _RMP_Mem_Ins(Pool, Left_Head);
;;;2143   }
000016  e8bd87f0          POP      {r4-r10,pc}
                  |L12.26|
00001a  f1a80410          SUB      r4,r8,#0x10           ;2094
00001e  68a0              LDR      r0,[r4,#8]            ;2096
000020  b900              CBNZ     r0,|L12.36|
000022  e7f8              B        |L12.22|
                  |L12.36|
000024  6861              LDR      r1,[r4,#4]            ;2100
000026  6820              LDR      r0,[r4,#0]            ;2100
000028  f7fffffe          BL       RMP_List_Del
00002c  2000              MOVS     r0,#0                 ;2101
00002e  60a0              STR      r0,[r4,#8]            ;2101
000030  68e0              LDR      r0,[r4,#0xc]          ;2104
000032  1d07              ADDS     r7,r0,#4              ;2104
000034  6928              LDR      r0,[r5,#0x10]         ;2105
000036  4428              ADD      r0,r0,r5              ;2105
000038  42b8              CMP      r0,r7                 ;2105
00003a  d00b              BEQ      |L12.84|
00003c  68b8              LDR      r0,[r7,#8]            ;2108
00003e  b948              CBNZ     r0,|L12.84|
000040  4639              MOV      r1,r7                 ;2111
000042  4648              MOV      r0,r9                 ;2111
000044  f7fffffe          BL       _RMP_Mem_Del
000048  68f8              LDR      r0,[r7,#0xc]          ;2112
00004a  1d00              ADDS     r0,r0,#4              ;2112
00004c  1b01              SUBS     r1,r0,r4              ;2112
00004e  4620              MOV      r0,r4                 ;2112
000050  f7fffffe          BL       _RMP_Mem_Block
                  |L12.84|
000054  f04f0a00          MOV      r10,#0                ;2118
000058  68e8              LDR      r0,[r5,#0xc]          ;2119
00005a  42a0              CMP      r0,r4                 ;2119
00005c  d00f              BEQ      |L12.126|
00005e  f8546c04          LDR      r6,[r4,#-4]           ;2121
000062  68b0              LDR      r0,[r6,#8]            ;2124
000064  b958              CBNZ     r0,|L12.126|
000066  4631              MOV      r1,r6                 ;2127
000068  4648              MOV      r0,r9                 ;2127
00006a  f7fffffe          BL       _RMP_Mem_Del
00006e  68e0              LDR      r0,[r4,#0xc]          ;2128
000070  1d00              ADDS     r0,r0,#4              ;2128
000072  1b81              SUBS     r1,r0,r6              ;2128
000074  4630              MOV      r0,r6                 ;2128
000076  f7fffffe          BL       _RMP_Mem_Block
00007a  f04f0a01          MOV      r10,#1                ;2133
                  |L12.126|
00007e  f1ba0f00          CMP      r10,#0                ;2139
000082  d104              BNE      |L12.142|
000084  4621              MOV      r1,r4                 ;2140
000086  4648              MOV      r0,r9                 ;2140
000088  f7fffffe          BL       _RMP_Mem_Ins
00008c  e003              B        |L12.150|
                  |L12.142|
00008e  4631              MOV      r1,r6                 ;2142
000090  4648              MOV      r0,r9                 ;2142
000092  f7fffffe          BL       _RMP_Mem_Ins
                  |L12.150|
000096  bf00              NOP      
000098  e7bd              B        |L12.22|
;;;2144   /* End Function:RMP_Free *****************************************************/
                          ENDP


                          AREA ||i.RMP_Init||, CODE, READONLY, ALIGN=1

                  RMP_Init PROC
;;;1592   ******************************************************************************/
;;;1593   void RMP_Init(void)
000000  f7fffffe          BL       RMP_Lock_Sched
;;;1594   {
;;;1595       RMP_Lock_Sched();
;;;1596       
;;;1597       /* Platform will use this hook to do something */
;;;1598       _RMP_Plat_Hook();
000004  f7fffffe          BL       _RMP_Plat_Hook
;;;1599       /* Start the second thread here */
;;;1600       RMP_Init_Hook();
000008  f7fffffe          BL       RMP_Init_Hook
;;;1601       
;;;1602       RMP_Unlock_Sched();
00000c  f7fffffe          BL       RMP_Unlock_Sched
;;;1603       
;;;1604       while(1)
000010  e001              B        |L13.22|
                  |L13.18|
;;;1605       {
;;;1606           RMP_Init_Idle();
000012  f7fffffe          BL       RMP_Init_Idle
                  |L13.22|
000016  e7fc              B        |L13.18|
;;;1607       };
;;;1608   }
;;;1609   /* End Function:RMP_Init *****************************************************/
                          ENDP


                          AREA ||i.RMP_LSB_Get||, CODE, READONLY, ALIGN=1

                  RMP_LSB_Get PROC
;;;1733   ******************************************************************************/
;;;1734   ptr_t RMP_LSB_Get(ptr_t Val)
000000  b570              PUSH     {r4-r6,lr}
;;;1735   {
000002  4604              MOV      r4,r0
;;;1736   #if(RMP_WORD_ORDER==4)
;;;1737       return 15-RMP_MSB_Get(RMP_RBIT_Get(Val));
;;;1738   #elif(RMP_WORD_ORDER==5)
;;;1739       return 31-RMP_MSB_Get(RMP_RBIT_Get(Val));
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       RMP_RBIT_Get
00000a  4605              MOV      r5,r0
00000c  f7fffffe          BL       RMP_MSB_Get
000010  f1c0001f          RSB      r0,r0,#0x1f
;;;1740   #else
;;;1741       return 63-RMP_MSB_Get(RMP_RBIT_Get(Val));
;;;1742   #endif 
;;;1743   }
000014  bd70              POP      {r4-r6,pc}
;;;1744   /* End Function:RMP_LSB_Get **************************************************/
                          ENDP


                          AREA ||i.RMP_Line||, CODE, READONLY, ALIGN=1

                  RMP_Line PROC
;;;2156   #ifdef RMP_POINT
;;;2157   void RMP_Line(cnt_t Start_X, cnt_t Start_Y, cnt_t End_X, cnt_t End_Y, ptr_t Color)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;2158   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;2159       cnt_t Trav_X;
;;;2160       cnt_t Trav_Y;
;;;2161       cnt_t Dir_X;
;;;2162       cnt_t Dir_Y;
;;;2163       cnt_t Error;
;;;2164       cnt_t Cur_X;
;;;2165       cnt_t Cur_Y;
;;;2166       
;;;2167       /* See if this line is horizontal or vertical. If so we speed it up */
;;;2168       if(Start_X==End_X)
00000c  42b4              CMP      r4,r6
00000e  d114              BNE      |L15.58|
;;;2169       {
;;;2170           /* Vertical */
;;;2171           if(Start_Y>End_Y)
000010  42bd              CMP      r5,r7
000012  dd02              BLE      |L15.26|
;;;2172           {
;;;2173               Dir_Y=End_Y;
000014  46bb              MOV      r11,r7
;;;2174               Trav_Y=Start_Y;
000016  9501              STR      r5,[sp,#4]
000018  e001              B        |L15.30|
                  |L15.26|
;;;2175           }
;;;2176           else
;;;2177           {
;;;2178               Dir_Y=Start_Y;
00001a  46ab              MOV      r11,r5
;;;2179               Trav_Y=End_Y;
00001c  9701              STR      r7,[sp,#4]
                  |L15.30|
;;;2180           }
;;;2181           
;;;2182           for(Cur_Y=Dir_Y;Cur_Y<=Trav_Y;Cur_Y++)
00001e  46d9              MOV      r9,r11
000020  e006              B        |L15.48|
                  |L15.34|
;;;2183               RMP_POINT(Start_X,Cur_Y,Color);
000022  4649              MOV      r1,r9
000024  4620              MOV      r0,r4
000026  9a0c              LDR      r2,[sp,#0x30]
000028  f7fffffe          BL       RMP_Point
00002c  f1090901          ADD      r9,r9,#1              ;2182
                  |L15.48|
000030  9801              LDR      r0,[sp,#4]            ;2182
000032  4581              CMP      r9,r0                 ;2182
000034  ddf5              BLE      |L15.34|
                  |L15.54|
;;;2184           return;
;;;2185       }
;;;2186       else if(Start_Y==End_Y)
;;;2187       {
;;;2188           /* Horizontal */
;;;2189           if(Start_X>End_X)
;;;2190           {
;;;2191               Dir_X=End_X;
;;;2192               Trav_X=Start_X;
;;;2193           }
;;;2194           else
;;;2195           {
;;;2196               Dir_X=Start_X;
;;;2197               Trav_X=End_X;
;;;2198           }
;;;2199           
;;;2200           for(Cur_X=Dir_X;Cur_X<=Trav_X;Cur_X++)
;;;2201               RMP_POINT(Cur_X,Start_Y,Color);
;;;2202           return;
;;;2203       }
;;;2204   
;;;2205       Error=0;
;;;2206       /* Get their absolute value, and then draw the line */
;;;2207       Trav_X=(Start_X>End_X)?(Start_X-End_X):(End_X-Start_X);
;;;2208       Trav_Y=(Start_Y>End_Y)?(Start_Y-End_Y):(End_Y-Start_Y);
;;;2209   
;;;2210       /* Decide the increment direction */
;;;2211       if(End_X-Start_X>0)
;;;2212           Dir_X=1;
;;;2213       else
;;;2214           Dir_X=-1;
;;;2215   
;;;2216       if(End_Y-Start_Y>0)
;;;2217           Dir_Y=1;
;;;2218       else
;;;2219           Dir_Y=-1;
;;;2220   
;;;2221       if(Trav_X>Trav_Y)
;;;2222       {
;;;2223           Cur_Y=Start_Y;
;;;2224           for(Cur_X=Start_X;Cur_X!=End_X+Dir_X;Cur_X+=Dir_X)
;;;2225           {
;;;2226               RMP_POINT(Cur_X,Cur_Y,Color);
;;;2227               Error+=Trav_Y;
;;;2228               if((Error<<1)>=Trav_X)
;;;2229               {
;;;2230                   Cur_Y+=Dir_Y;
;;;2231                   Error-=Trav_X;
;;;2232               }
;;;2233           }
;;;2234       }
;;;2235       else
;;;2236       {
;;;2237           Cur_X=Start_X;
;;;2238           for(Cur_Y=Start_Y;Cur_Y!=End_Y+Dir_Y;Cur_Y+=Dir_Y)
;;;2239           {
;;;2240               RMP_POINT(Cur_X,Cur_Y,Color);
;;;2241               Error+=Trav_X;
;;;2242               if((Error<<1)>=Trav_Y)
;;;2243               {
;;;2244                   Cur_X+=Dir_X;
;;;2245                   Error-=Trav_Y;
;;;2246               }
;;;2247           }
;;;2248       }
;;;2249   }
000036  e8bd8ffe          POP      {r1-r11,pc}
                  |L15.58|
00003a  42bd              CMP      r5,r7                 ;2186
00003c  d113              BNE      |L15.102|
00003e  42b4              CMP      r4,r6                 ;2189
000040  dd02              BLE      |L15.72|
000042  46b2              MOV      r10,r6                ;2191
000044  9402              STR      r4,[sp,#8]            ;2192
000046  e001              B        |L15.76|
                  |L15.72|
000048  46a2              MOV      r10,r4                ;2196
00004a  9602              STR      r6,[sp,#8]            ;2197
                  |L15.76|
00004c  46d0              MOV      r8,r10                ;2200
00004e  e006              B        |L15.94|
                  |L15.80|
000050  4629              MOV      r1,r5                 ;2201
000052  4640              MOV      r0,r8                 ;2201
000054  9a0c              LDR      r2,[sp,#0x30]         ;2201
000056  f7fffffe          BL       RMP_Point
00005a  f1080801          ADD      r8,r8,#1              ;2200
                  |L15.94|
00005e  9802              LDR      r0,[sp,#8]            ;2200
000060  4580              CMP      r8,r0                 ;2200
000062  ddf5              BLE      |L15.80|
000064  e7e7              B        |L15.54|
                  |L15.102|
000066  2000              MOVS     r0,#0                 ;2205
000068  9000              STR      r0,[sp,#0]            ;2205
00006a  42b4              CMP      r4,r6                 ;2207
00006c  dd01              BLE      |L15.114|
00006e  1ba0              SUBS     r0,r4,r6              ;2207
000070  e000              B        |L15.116|
                  |L15.114|
000072  1b30              SUBS     r0,r6,r4              ;2207
                  |L15.116|
000074  9002              STR      r0,[sp,#8]            ;2207
000076  42bd              CMP      r5,r7                 ;2208
000078  dd01              BLE      |L15.126|
00007a  1be8              SUBS     r0,r5,r7              ;2208
00007c  e000              B        |L15.128|
                  |L15.126|
00007e  1b78              SUBS     r0,r7,r5              ;2208
                  |L15.128|
000080  9001              STR      r0,[sp,#4]            ;2208
000082  1b30              SUBS     r0,r6,r4              ;2211
000084  2800              CMP      r0,#0                 ;2211
000086  dd02              BLE      |L15.142|
000088  f04f0a01          MOV      r10,#1                ;2212
00008c  e001              B        |L15.146|
                  |L15.142|
00008e  f04f3aff          MOV      r10,#0xffffffff       ;2214
                  |L15.146|
000092  1b78              SUBS     r0,r7,r5              ;2216
000094  2800              CMP      r0,#0                 ;2216
000096  dd02              BLE      |L15.158|
000098  f04f0b01          MOV      r11,#1                ;2217
00009c  e001              B        |L15.162|
                  |L15.158|
00009e  f04f3bff          MOV      r11,#0xffffffff       ;2219
                  |L15.162|
0000a2  e9dd1001          LDRD     r1,r0,[sp,#4]         ;2221
0000a6  4288              CMP      r0,r1                 ;2221
0000a8  dd1b              BLE      |L15.226|
0000aa  46a9              MOV      r9,r5                 ;2223
0000ac  46a0              MOV      r8,r4                 ;2224
0000ae  e013              B        |L15.216|
                  |L15.176|
0000b0  4649              MOV      r1,r9                 ;2226
0000b2  4640              MOV      r0,r8                 ;2226
0000b4  9a0c              LDR      r2,[sp,#0x30]         ;2226
0000b6  f7fffffe          BL       RMP_Point
0000ba  e9dd0100          LDRD     r0,r1,[sp,#0]         ;2227
0000be  4408              ADD      r0,r0,r1              ;2227
0000c0  9000              STR      r0,[sp,#0]            ;2227
0000c2  9900              LDR      r1,[sp,#0]            ;2228
0000c4  9802              LDR      r0,[sp,#8]            ;2228
0000c6  ebb00f41          CMP      r0,r1,LSL #1          ;2228
0000ca  dc04              BGT      |L15.214|
0000cc  44d9              ADD      r9,r9,r11             ;2230
0000ce  9902              LDR      r1,[sp,#8]            ;2231
0000d0  9800              LDR      r0,[sp,#0]            ;2231
0000d2  1a40              SUBS     r0,r0,r1              ;2231
0000d4  9000              STR      r0,[sp,#0]            ;2231
                  |L15.214|
0000d6  44d0              ADD      r8,r8,r10             ;2224
                  |L15.216|
0000d8  eb06000a          ADD      r0,r6,r10             ;2224
0000dc  4540              CMP      r0,r8                 ;2224
0000de  d1e7              BNE      |L15.176|
0000e0  e01a              B        |L15.280|
                  |L15.226|
0000e2  46a0              MOV      r8,r4                 ;2237
0000e4  46a9              MOV      r9,r5                 ;2238
0000e6  e013              B        |L15.272|
                  |L15.232|
0000e8  4649              MOV      r1,r9                 ;2240
0000ea  4640              MOV      r0,r8                 ;2240
0000ec  9a0c              LDR      r2,[sp,#0x30]         ;2240
0000ee  f7fffffe          BL       RMP_Point
0000f2  9902              LDR      r1,[sp,#8]            ;2241
0000f4  9800              LDR      r0,[sp,#0]            ;2241
0000f6  4408              ADD      r0,r0,r1              ;2241
0000f8  9000              STR      r0,[sp,#0]            ;2241
0000fa  e9dd1000          LDRD     r1,r0,[sp,#0]         ;2242
0000fe  ebb00f41          CMP      r0,r1,LSL #1          ;2242
000102  dc04              BGT      |L15.270|
000104  44d0              ADD      r8,r8,r10             ;2244
000106  e9dd0100          LDRD     r0,r1,[sp,#0]         ;2245
00010a  1a40              SUBS     r0,r0,r1              ;2245
00010c  9000              STR      r0,[sp,#0]            ;2245
                  |L15.270|
00010e  44d9              ADD      r9,r9,r11             ;2238
                  |L15.272|
000110  eb07000b          ADD      r0,r7,r11             ;2238
000114  4548              CMP      r0,r9                 ;2238
000116  d1e7              BNE      |L15.232|
                  |L15.280|
000118  bf00              NOP      
00011a  e78c              B        |L15.54|
;;;2250   /* End Function:RMP_Line *****************************************************/
                          ENDP


                          AREA ||i.RMP_Lineedit||, CODE, READONLY, ALIGN=1

                  RMP_Lineedit PROC
;;;3081   ******************************************************************************/
;;;3082   void RMP_Lineedit(cnt_t Coord_X, cnt_t Coord_Y, cnt_t Length, cnt_t Width)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;3083   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;3084       RMP_Rectangle(Coord_X,Coord_Y,Length,Width,RMP_CTL_WHITE,RMP_CTL_WHITE);
00000c  f64f70ff          MOV      r0,#0xffff
000010  9000              STR      r0,[sp,#0]
000012  463b              MOV      r3,r7
000014  4632              MOV      r2,r6
000016  4629              MOV      r1,r5
000018  9001              STR      r0,[sp,#4]
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       RMP_Rectangle
;;;3085       
;;;3086       /* Now draw the border */
;;;3087       RMP_Line(Coord_X,Coord_Y,Coord_X+Length-1,Coord_Y,RMP_CTL_DARK);
000020  f64730ef          MOV      r0,#0x7bef
000024  9000              STR      r0,[sp,#0]
000026  19a0              ADDS     r0,r4,r6
000028  1e42              SUBS     r2,r0,#1
00002a  462b              MOV      r3,r5
00002c  4629              MOV      r1,r5
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       RMP_Line
;;;3088       RMP_Line(Coord_X+Length-1,Coord_Y,Coord_X+Length-1,Coord_Y+Width-1,RMP_CTL_WHITE);
000034  f64f70ff          MOV      r0,#0xffff
000038  19e9              ADDS     r1,r5,r7
00003a  1e4b              SUBS     r3,r1,#1
00003c  19a1              ADDS     r1,r4,r6
00003e  1e4a              SUBS     r2,r1,#1
000040  19a1              ADDS     r1,r4,r6
000042  9000              STR      r0,[sp,#0]
000044  1e48              SUBS     r0,r1,#1
000046  4629              MOV      r1,r5
000048  f7fffffe          BL       RMP_Line
;;;3089       RMP_Line(Coord_X+Length-1,Coord_Y+Width-1,Coord_X,Coord_Y+Width-1,RMP_CTL_WHITE);
00004c  f64f70ff          MOV      r0,#0xffff
000050  19ea              ADDS     r2,r5,r7
000052  1e53              SUBS     r3,r2,#1
000054  19ea              ADDS     r2,r5,r7
000056  1e51              SUBS     r1,r2,#1
000058  19a2              ADDS     r2,r4,r6
00005a  9000              STR      r0,[sp,#0]
00005c  1e50              SUBS     r0,r2,#1
00005e  4622              MOV      r2,r4
000060  f7fffffe          BL       RMP_Line
;;;3090       RMP_Line(Coord_X,Coord_Y+Width-1,Coord_X,Coord_Y,RMP_CTL_DARK);
000064  f64730ef          MOV      r0,#0x7bef
000068  9000              STR      r0,[sp,#0]
00006a  19e8              ADDS     r0,r5,r7
00006c  1e41              SUBS     r1,r0,#1
00006e  462b              MOV      r3,r5
000070  4622              MOV      r2,r4
000072  4620              MOV      r0,r4
000074  f7fffffe          BL       RMP_Line
;;;3091       /* The shadow */
;;;3092       RMP_Line(Coord_X+1,Coord_Y+Width-2,Coord_X+1,Coord_Y+1,RMP_CTL_BLACK);    
000078  2000              MOVS     r0,#0
00007a  9000              STR      r0,[sp,#0]
00007c  19e8              ADDS     r0,r5,r7
00007e  1e81              SUBS     r1,r0,#2
000080  1c6b              ADDS     r3,r5,#1
000082  1c62              ADDS     r2,r4,#1
000084  1c60              ADDS     r0,r4,#1
000086  f7fffffe          BL       RMP_Line
;;;3093       RMP_Line(Coord_X+1,Coord_Y+1,Coord_X+Length-2,Coord_Y+1,RMP_CTL_BLACK);
00008a  2000              MOVS     r0,#0
00008c  9000              STR      r0,[sp,#0]
00008e  19a0              ADDS     r0,r4,r6
000090  1e82              SUBS     r2,r0,#2
000092  1c6b              ADDS     r3,r5,#1
000094  1c69              ADDS     r1,r5,#1
000096  1c60              ADDS     r0,r4,#1
000098  f7fffffe          BL       RMP_Line
;;;3094   }
00009c  e8bd81fc          POP      {r2-r8,pc}
;;;3095   /* End Function:RMP_Lineedit *************************************************/
                          ENDP


                          AREA ||i.RMP_Lineedit_Clr||, CODE, READONLY, ALIGN=1

                  RMP_Lineedit_Clr PROC
;;;3065   ******************************************************************************/
;;;3066   void RMP_Lineedit_Clr(cnt_t Coord_X, cnt_t Coord_Y, cnt_t Length,
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;3067                         cnt_t Width, cnt_t Clr_X, cnt_t Clr_Len)
;;;3068   {
000004  4680              MOV      r8,r0
000006  460c              MOV      r4,r1
000008  4691              MOV      r9,r2
00000a  461d              MOV      r5,r3
00000c  e9dd670a          LDRD     r6,r7,[sp,#0x28]
;;;3069       RMP_Rectangle(Clr_X,Coord_Y+1,Clr_Len,Width-2,RMP_CTL_WHITE,RMP_CTL_WHITE);
000010  f64f70ff          MOV      r0,#0xffff
000014  9000              STR      r0,[sp,#0]
000016  1eab              SUBS     r3,r5,#2
000018  463a              MOV      r2,r7
00001a  1c61              ADDS     r1,r4,#1
00001c  9001              STR      r0,[sp,#4]
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       RMP_Rectangle
;;;3070   }
000024  e8bd87fc          POP      {r2-r10,pc}
;;;3071   /* End Function:RMP_Lineedit_Clr *********************************************/
                          ENDP


                          AREA ||i.RMP_List_Crt||, CODE, READONLY, ALIGN=1

                  RMP_List_Crt PROC
;;;215    ******************************************************************************/
;;;216    void RMP_List_Crt(volatile struct RMP_List* Head)
000000  6000              STR      r0,[r0,#0]
;;;217    {
;;;218        Head->Prev=(struct RMP_List*)Head;
;;;219        Head->Next=(struct RMP_List*)Head;
000002  6040              STR      r0,[r0,#4]
;;;220    }
000004  4770              BX       lr
;;;221    /* End Function:RMP_List_Crt *************************************************/
                          ENDP


                          AREA ||i.RMP_List_Del||, CODE, READONLY, ALIGN=1

                  RMP_List_Del PROC
;;;229    ******************************************************************************/
;;;230    void RMP_List_Del(volatile struct RMP_List* Prev,volatile struct RMP_List* Next)
000000  6008              STR      r0,[r1,#0]
;;;231    {
;;;232        Next->Prev=(struct RMP_List*)Prev;
;;;233        Prev->Next=(struct RMP_List*)Next;
000002  6041              STR      r1,[r0,#4]
;;;234    }
000004  4770              BX       lr
;;;235    /* End Function:RMP_List_Del *************************************************/
                          ENDP


                          AREA ||i.RMP_List_Ins||, CODE, READONLY, ALIGN=1

                  RMP_List_Ins PROC
;;;244    ******************************************************************************/
;;;245    void RMP_List_Ins(volatile struct RMP_List* New,
000000  6010              STR      r0,[r2,#0]
;;;246                      volatile struct RMP_List* Prev,
;;;247                      volatile struct RMP_List* Next)
;;;248    {
;;;249        Next->Prev=(struct RMP_List*)New;
;;;250        New->Next=(struct RMP_List*)Next;
000002  6042              STR      r2,[r0,#4]
;;;251        New->Prev=(struct RMP_List*)Prev;
000004  6001              STR      r1,[r0,#0]
;;;252        Prev->Next=(struct RMP_List*)New;
000006  6048              STR      r0,[r1,#4]
;;;253    }
000008  4770              BX       lr
;;;254    /* End Function:RMP_List_Ins *************************************************/
                          ENDP


                          AREA ||i.RMP_Load_Ctx||, CODE, READONLY, ALIGN=1

                  RMP_Load_Ctx PROC
;;;1560   #if(RMP_USE_HOOKS==RMP_FALSE)
;;;1561   void RMP_Load_Ctx(void)
000000  4770              BX       lr
;;;1562   {
;;;1563       return;
;;;1564   }
;;;1565   #endif
                          ENDP


                          AREA ||i.RMP_Lock_Sched||, CODE, READONLY, ALIGN=2

                  RMP_Lock_Sched PROC
;;;345    ******************************************************************************/
;;;346    void RMP_Lock_Sched(void)
000000  b510              PUSH     {r4,lr}
;;;347    {
;;;348        RMP_MASK_INT();
000002  20ff              MOVS     r0,#0xff
000004  f7fffffe          BL       RMP_Mask_Int
;;;349        RMP_Sched_Locked=1;
000008  2001              MOVS     r0,#1
00000a  4904              LDR      r1,|L22.28|
00000c  6008              STR      r0,[r1,#0]  ; RMP_Sched_Locked
;;;350        RMP_Sched_Lock_Cnt++;
00000e  4804              LDR      r0,|L22.32|
000010  6800              LDR      r0,[r0,#0]  ; RMP_Sched_Lock_Cnt
000012  1c40              ADDS     r0,r0,#1
000014  4902              LDR      r1,|L22.32|
000016  6008              STR      r0,[r1,#0]  ; RMP_Sched_Lock_Cnt
;;;351    }
000018  bd10              POP      {r4,pc}
;;;352    /* End Function:RMP_Lock_Sched ***********************************************/
                          ENDP

00001a  0000              DCW      0x0000
                  |L22.28|
                          DCD      RMP_Sched_Locked
                  |L22.32|
                          DCD      RMP_Sched_Lock_Cnt

                          AREA ||i.RMP_Malloc||, CODE, READONLY, ALIGN=1

                  RMP_Malloc PROC
;;;2018   ******************************************************************************/
;;;2019   void* RMP_Malloc(volatile void* Pool, ptr_t Size)                                                       
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;2020   {    
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
;;;2021       cnt_t FLI_Level;
;;;2022       cnt_t SLI_Level;
;;;2023       volatile struct RMP_Mem* Mem;
;;;2024       ptr_t Old_Size;
;;;2025       volatile struct RMP_Mem_Head* Mem_Head;
;;;2026       ptr_t Rounded_Size;
;;;2027       volatile struct RMP_Mem_Head* New_Mem;
;;;2028       ptr_t New_Size;
;;;2029       
;;;2030       if(Size==0)
000008  f1b80f00          CMP      r8,#0
00000c  d102              BNE      |L23.20|
;;;2031           return (void*)(0);
00000e  2000              MOVS     r0,#0
                  |L23.16|
;;;2032       
;;;2033       /* Round up the size:a multiple of 8 and bigger than 64B. In fact, we will add
;;;2034        * extra 8 bytes at the end if the size is a multiple of 8 for safety. */
;;;2035       Rounded_Size=(((Size-1)>>3)+1)<<3;
;;;2036       /* See if it is smaller than the smallest block */
;;;2037       Rounded_Size=(Rounded_Size>64)?Rounded_Size:64;
;;;2038   
;;;2039       /* See if such block exists, if not, abort */
;;;2040       if(_RMP_Mem_Search(Pool,Rounded_Size,&FLI_Level,&SLI_Level)!=0)
;;;2041           return (void*)(0);
;;;2042       
;;;2043       Mem=(volatile struct RMP_Mem*)Pool;
;;;2044       
;;;2045       /* There is such block. Get it and delete it from the TLSF list. */
;;;2046       Mem_Head=(struct RMP_Mem_Head*)(Mem->Table[RMP_MEM_POS(FLI_Level,SLI_Level)].Next);
;;;2047       _RMP_Mem_Del(Pool, Mem_Head);
;;;2048   
;;;2049       /* Allocate and calculate if the space left could be big enough to be a new 
;;;2050        * block. If so, we will put the block back into the TLSF table */
;;;2051       New_Size=(ptr_t)(Mem_Head->Tail)-((ptr_t)Mem_Head)-sizeof(struct RMP_Mem_Head)-Rounded_Size;
;;;2052       if(New_Size>=sizeof(struct RMP_Mem_Head)+64+sizeof(struct RMP_Mem_Tail))
;;;2053       {
;;;2054           Old_Size=sizeof(struct RMP_Mem_Head)+Rounded_Size+sizeof(struct RMP_Mem_Tail);
;;;2055           New_Mem=(volatile struct RMP_Mem_Head*)(((ptr_t)Mem_Head)+Old_Size);
;;;2056   
;;;2057           _RMP_Mem_Block(Mem_Head, Old_Size);
;;;2058           _RMP_Mem_Block(New_Mem, New_Size);
;;;2059   
;;;2060           /* Put the extra block back */
;;;2061           _RMP_Mem_Ins(Pool, New_Mem);
;;;2062       }
;;;2063   
;;;2064       /* Insert the allocated block into the lists */
;;;2065       RMP_List_Ins(&(Mem_Head->Head),&(Mem->Alloc),Mem->Alloc.Next);
;;;2066       Mem_Head->State=RMP_MEM_USED;
;;;2067   
;;;2068       /* Finally, return the start address */
;;;2069       return (void*)(((ptr_t)Mem_Head)+sizeof(struct RMP_Mem_Head));
;;;2070   }
000010  e8bd9ffc          POP      {r2-r12,pc}
                  |L23.20|
000014  f1a80001          SUB      r0,r8,#1              ;2035
000018  2101              MOVS     r1,#1                 ;2035
00001a  eb0100d0          ADD      r0,r1,r0,LSR #3       ;2035
00001e  00c5              LSLS     r5,r0,#3              ;2035
000020  2d40              CMP      r5,#0x40              ;2037
000022  d901              BLS      |L23.40|
000024  4628              MOV      r0,r5                 ;2037
000026  e000              B        |L23.42|
                  |L23.40|
000028  2040              MOVS     r0,#0x40              ;2037
                  |L23.42|
00002a  4605              MOV      r5,r0                 ;2037
00002c  466b              MOV      r3,sp                 ;2040
00002e  aa01              ADD      r2,sp,#4              ;2040
000030  4629              MOV      r1,r5                 ;2040
000032  4638              MOV      r0,r7                 ;2040
000034  f7fffffe          BL       _RMP_Mem_Search
000038  b108              CBZ      r0,|L23.62|
00003a  2000              MOVS     r0,#0                 ;2041
00003c  e7e8              B        |L23.16|
                  |L23.62|
00003e  463e              MOV      r6,r7                 ;2043
000040  e9dd0100          LDRD     r0,r1,[sp,#0]         ;2046
000044  eb0001c1          ADD      r1,r0,r1,LSL #3       ;2046
000048  f1060028          ADD      r0,r6,#0x28           ;2046
00004c  eb0000c1          ADD      r0,r0,r1,LSL #3       ;2046
000050  6844              LDR      r4,[r0,#4]            ;2046
000052  4621              MOV      r1,r4                 ;2047
000054  4638              MOV      r0,r7                 ;2047
000056  f7fffffe          BL       _RMP_Mem_Del
00005a  68e0              LDR      r0,[r4,#0xc]          ;2051
00005c  1b00              SUBS     r0,r0,r4              ;2051
00005e  3810              SUBS     r0,r0,#0x10           ;2051
000060  eba00b05          SUB      r11,r0,r5             ;2051
000064  f1bb0f54          CMP      r11,#0x54             ;2052
000068  d30f              BCC      |L23.138|
00006a  f1050914          ADD      r9,r5,#0x14           ;2054
00006e  eb040a09          ADD      r10,r4,r9             ;2055
000072  4649              MOV      r1,r9                 ;2057
000074  4620              MOV      r0,r4                 ;2057
000076  f7fffffe          BL       _RMP_Mem_Block
00007a  4659              MOV      r1,r11                ;2058
00007c  4650              MOV      r0,r10                ;2058
00007e  f7fffffe          BL       _RMP_Mem_Block
000082  4651              MOV      r1,r10                ;2061
000084  4638              MOV      r0,r7                 ;2061
000086  f7fffffe          BL       _RMP_Mem_Ins
                  |L23.138|
00008a  6872              LDR      r2,[r6,#4]            ;2065
00008c  4631              MOV      r1,r6                 ;2065
00008e  4620              MOV      r0,r4                 ;2065
000090  f7fffffe          BL       RMP_List_Ins
000094  2001              MOVS     r0,#1                 ;2066
000096  60a0              STR      r0,[r4,#8]            ;2066
000098  f1040010          ADD      r0,r4,#0x10           ;2069
00009c  e7b8              B        |L23.16|
;;;2071   /* End Function:RMP_Malloc ***************************************************/
                          ENDP


                          AREA ||i.RMP_Matrix||, CODE, READONLY, ALIGN=1

                  RMP_Matrix PROC
;;;2534   ******************************************************************************/
;;;2535   void RMP_Matrix(cnt_t Coord_X, cnt_t Coord_Y, const u8* Matrix,
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;2536                   cnt_t Bit_Order, cnt_t Length, cnt_t Width, ptr_t Color)
;;;2537   {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4691              MOV      r9,r2
00000a  e9ddab0e          LDRD     r10,r11,[sp,#0x38]
;;;2538       cnt_t Len_Cnt;
;;;2539       cnt_t Wid_Cnt;
;;;2540       cnt_t Mat_Pos;
;;;2541       
;;;2542       if((Matrix==0)||((Length&0x07)!=0)||(Length==0)||(Width==0))
00000e  f1b90f00          CMP      r9,#0
000012  d008              BEQ      |L24.38|
000014  f00a0007          AND      r0,r10,#7
000018  b928              CBNZ     r0,|L24.38|
00001a  f1ba0f00          CMP      r10,#0
00001e  d002              BEQ      |L24.38|
000020  f1bb0f00          CMP      r11,#0
000024  d101              BNE      |L24.42|
                  |L24.38|
;;;2543           return;
;;;2544       
;;;2545       Mat_Pos=0;
;;;2546       /* Natural order */
;;;2547       if(Bit_Order==RMP_MAT_BIG)
;;;2548       {
;;;2549           for(Wid_Cnt=Coord_Y;Wid_Cnt<Width+Coord_Y;Wid_Cnt++)
;;;2550           {
;;;2551               for(Len_Cnt=Coord_X;Len_Cnt<Length+Coord_X;Len_Cnt++)
;;;2552               {
;;;2553                   if(RMP_MAT_BPOS(Matrix,Mat_Pos)!=0)
;;;2554                       RMP_Point(Len_Cnt,Wid_Cnt,Color);
;;;2555                   Mat_Pos++;
;;;2556               }
;;;2557           }
;;;2558       }
;;;2559       /* Small order */
;;;2560       else
;;;2561       {
;;;2562           for(Wid_Cnt=Coord_Y;Wid_Cnt<Width+Coord_Y;Wid_Cnt++)
;;;2563           {
;;;2564               for(Len_Cnt=Coord_X;Len_Cnt<Length+Coord_X;Len_Cnt++)
;;;2565               {
;;;2566                   if(RMP_MAT_SPOS(Matrix,Mat_Pos)!=0)
;;;2567                       RMP_Point(Len_Cnt,Wid_Cnt,Color);
;;;2568                   Mat_Pos++;
;;;2569               }
;;;2570           }
;;;2571       }
;;;2572   }
000026  e8bd9fff          POP      {r0-r12,pc}
                  |L24.42|
00002a  2500              MOVS     r5,#0                 ;2545
00002c  9803              LDR      r0,[sp,#0xc]          ;2547
00002e  2801              CMP      r0,#1                 ;2547
000030  d120              BNE      |L24.116|
000032  463c              MOV      r4,r7                 ;2549
000034  e019              B        |L24.106|
                  |L24.54|
000036  46b0              MOV      r8,r6                 ;2551
000038  e012              B        |L24.96|
                  |L24.58|
00003a  eb0900e5          ADD      r0,r9,r5,ASR #3       ;2553
00003e  7800              LDRB     r0,[r0,#0]            ;2553
000040  f0050107          AND      r1,r5,#7              ;2553
000044  f1c10207          RSB      r2,r1,#7              ;2553
000048  2101              MOVS     r1,#1                 ;2553
00004a  4091              LSLS     r1,r1,r2              ;2553
00004c  4008              ANDS     r0,r0,r1              ;2553
00004e  b120              CBZ      r0,|L24.90|
000050  4621              MOV      r1,r4                 ;2554
000052  4640              MOV      r0,r8                 ;2554
000054  9a10              LDR      r2,[sp,#0x40]         ;2554
000056  f7fffffe          BL       RMP_Point
                  |L24.90|
00005a  1c6d              ADDS     r5,r5,#1              ;2555
00005c  f1080801          ADD      r8,r8,#1              ;2551
                  |L24.96|
000060  eb0a0006          ADD      r0,r10,r6             ;2551
000064  4540              CMP      r0,r8                 ;2551
000066  dce8              BGT      |L24.58|
000068  1c64              ADDS     r4,r4,#1              ;2549
                  |L24.106|
00006a  eb0b0007          ADD      r0,r11,r7             ;2549
00006e  42a0              CMP      r0,r4                 ;2549
000070  dce1              BGT      |L24.54|
000072  e01d              B        |L24.176|
                  |L24.116|
000074  463c              MOV      r4,r7                 ;2562
000076  e017              B        |L24.168|
                  |L24.120|
000078  46b0              MOV      r8,r6                 ;2564
00007a  e010              B        |L24.158|
                  |L24.124|
00007c  eb0900e5          ADD      r0,r9,r5,ASR #3       ;2566
000080  7800              LDRB     r0,[r0,#0]            ;2566
000082  f0050207          AND      r2,r5,#7              ;2566
000086  2101              MOVS     r1,#1                 ;2566
000088  4091              LSLS     r1,r1,r2              ;2566
00008a  4008              ANDS     r0,r0,r1              ;2566
00008c  b120              CBZ      r0,|L24.152|
00008e  4621              MOV      r1,r4                 ;2567
000090  4640              MOV      r0,r8                 ;2567
000092  9a10              LDR      r2,[sp,#0x40]         ;2567
000094  f7fffffe          BL       RMP_Point
                  |L24.152|
000098  1c6d              ADDS     r5,r5,#1              ;2568
00009a  f1080801          ADD      r8,r8,#1              ;2564
                  |L24.158|
00009e  eb0a0006          ADD      r0,r10,r6             ;2564
0000a2  4540              CMP      r0,r8                 ;2564
0000a4  dcea              BGT      |L24.124|
0000a6  1c64              ADDS     r4,r4,#1              ;2562
                  |L24.168|
0000a8  eb0b0007          ADD      r0,r11,r7             ;2562
0000ac  42a0              CMP      r0,r4                 ;2562
0000ae  dce3              BGT      |L24.120|
                  |L24.176|
0000b0  bf00              NOP      
0000b2  e7b8              B        |L24.38|
;;;2573   /* End Function:RMP_Matrix ***************************************************/
                          ENDP


                          AREA ||i.RMP_Matrix_AA||, CODE, READONLY, ALIGN=1

                  RMP_Matrix_AA PROC
;;;2592   #ifdef RMP_COLOR_75P
;;;2593   void RMP_Matrix_AA(cnt_t Coord_X, cnt_t Coord_Y, const u8* Matrix,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;2594                      cnt_t Bit_Order, cnt_t Length, cnt_t Width, ptr_t Color, ptr_t Back)
;;;2595   {
000004  b085              SUB      sp,sp,#0x14
000006  4681              MOV      r9,r0
000008  4616              MOV      r6,r2
00000a  e9dd7a14          LDRD     r7,r10,[sp,#0x50]
00000e  9d12              LDR      r5,[sp,#0x48]
;;;2596       cnt_t Len_Cnt;
;;;2597       cnt_t Wid_Cnt;
;;;2598       cnt_t Mat_Pos;
;;;2599       cnt_t Anti_Alias;
;;;2600       ptr_t Color_25;
;;;2601       ptr_t Color_50;
;;;2602       ptr_t Color_75;
;;;2603       ptr_t Total;
;;;2604       
;;;2605       if((Matrix==0)||((Length&0x07)!=0)||(Length==0)||(Width==0))
000010  b12e              CBZ      r6,|L25.30|
000012  f0050007          AND      r0,r5,#7
000016  b910              CBNZ     r0,|L25.30|
000018  b10d              CBZ      r5,|L25.30|
00001a  9813              LDR      r0,[sp,#0x4c]
00001c  b910              CBNZ     r0,|L25.36|
                  |L25.30|
;;;2606           return;
;;;2607       
;;;2608       Mat_Pos=0;
;;;2609       Total=Length*Width;
;;;2610       Color_25=RMP_COLOR_25P(Color,Back);
;;;2611       Color_50=RMP_COLOR_50P(Color,Back);
;;;2612       Color_75=RMP_COLOR_75P(Color,Back);
;;;2613       
;;;2614       /* Natural order */
;;;2615       if(Bit_Order==RMP_MAT_BIG)
;;;2616       {
;;;2617           for(Wid_Cnt=Coord_Y;Wid_Cnt<Width+Coord_Y;Wid_Cnt++)
;;;2618           {
;;;2619               for(Len_Cnt=Coord_X;Len_Cnt<Length+Coord_X;Len_Cnt++)
;;;2620               {
;;;2621                   if(RMP_MAT_BPOS(Matrix,Mat_Pos)!=0)
;;;2622                       RMP_Point(Len_Cnt,Wid_Cnt,Color);
;;;2623                   else
;;;2624                   {
;;;2625                       /* Anti-aliasing */
;;;2626                       Anti_Alias=0;
;;;2627                       
;;;2628                       if(Mat_Pos-1>=0)
;;;2629                       {
;;;2630                           if((Len_Cnt!=Coord_X)&&(RMP_MAT_BPOS(Matrix,Mat_Pos-1)!=0))
;;;2631                               Anti_Alias++;
;;;2632                           if((Mat_Pos-Length>=0)&&(RMP_MAT_BPOS(Matrix,Mat_Pos-Length)!=0))
;;;2633                               Anti_Alias++;
;;;2634                       }
;;;2635                       
;;;2636                       if(Mat_Pos+1<Total)
;;;2637                       {
;;;2638                           if((Len_Cnt!=Coord_X+Length-1)&&(RMP_MAT_BPOS(Matrix,Mat_Pos+1)!=0))
;;;2639                               Anti_Alias++;
;;;2640                           if((Mat_Pos+Length<Total)&&(RMP_MAT_BPOS(Matrix,Mat_Pos+Length)!=0))
;;;2641                               Anti_Alias++;
;;;2642                       }
;;;2643                       
;;;2644                       switch(Anti_Alias)
;;;2645                       {
;;;2646                           case 1:RMP_Point(Len_Cnt,Wid_Cnt,Color_25);break;
;;;2647                           case 2:RMP_Point(Len_Cnt,Wid_Cnt,Color_50);break;
;;;2648                           case 3:RMP_Point(Len_Cnt,Wid_Cnt,Color_75);break;
;;;2649                           default:break;
;;;2650                       }
;;;2651                   }
;;;2652                   
;;;2653                   Mat_Pos++;
;;;2654               }
;;;2655           }
;;;2656       }
;;;2657       /* Small order */
;;;2658       else
;;;2659       {
;;;2660           for(Wid_Cnt=Coord_Y;Wid_Cnt<Width+Coord_Y;Wid_Cnt++)
;;;2661           {
;;;2662               for(Len_Cnt=Coord_X;Len_Cnt<Length+Coord_X;Len_Cnt++)
;;;2663               {
;;;2664                   if(RMP_MAT_SPOS(Matrix,Mat_Pos)!=0)
;;;2665                       RMP_Point(Len_Cnt,Wid_Cnt,Color);
;;;2666                   else
;;;2667                   {
;;;2668                       /* Anti-aliasing */
;;;2669                       Anti_Alias=0;
;;;2670                       
;;;2671                       if(Mat_Pos-1>=0)
;;;2672                       {
;;;2673                           if((Len_Cnt!=Coord_X)&&(RMP_MAT_SPOS(Matrix,Mat_Pos-1)!=0))
;;;2674                               Anti_Alias++;
;;;2675                           if((Mat_Pos-Length>=0)&&(RMP_MAT_SPOS(Matrix,Mat_Pos-Length)!=0))
;;;2676                               Anti_Alias++;
;;;2677                       }
;;;2678                       
;;;2679                       if(Mat_Pos+1<Total)
;;;2680                       {
;;;2681                           if((Len_Cnt!=Coord_X+Length-1)&&(RMP_MAT_SPOS(Matrix,Mat_Pos+1)!=0))
;;;2682                               Anti_Alias++;
;;;2683                           if((Mat_Pos+Length<Total)&&(RMP_MAT_SPOS(Matrix,Mat_Pos+Length)!=0))
;;;2684                               Anti_Alias++;
;;;2685                       }
;;;2686                       
;;;2687                       switch(Anti_Alias)
;;;2688                       {
;;;2689                           case 1:RMP_Point(Len_Cnt,Wid_Cnt,Color_25);break;
;;;2690                           case 2:RMP_Point(Len_Cnt,Wid_Cnt,Color_50);break;
;;;2691                           case 3:RMP_Point(Len_Cnt,Wid_Cnt,Color_75);break;
;;;2692                           default:break;
;;;2693                       }
;;;2694                   }
;;;2695                   
;;;2696                   Mat_Pos++;
;;;2697               }
;;;2698           }
;;;2699       }
;;;2700   }
00001e  b009              ADD      sp,sp,#0x24
000020  e8bd8ff0          POP      {r4-r11,pc}
                  |L25.36|
000024  2400              MOVS     r4,#0                 ;2608
000026  9913              LDR      r1,[sp,#0x4c]         ;2609
000028  fb05f001          MUL      r0,r5,r1              ;2609
00002c  9000              STR      r0,[sp,#0]            ;2609
00002e  ea4f20da          LSR      r0,r10,#11            ;2610
000032  eb000040          ADD      r0,r0,r0,LSL #1       ;2610
000036  eb0020d7          ADD      r0,r0,r7,LSR #11      ;2610
00003a  0880              LSRS     r0,r0,#2              ;2610
00003c  02c0              LSLS     r0,r0,#11             ;2610
00003e  f3ca1145          UBFX     r1,r10,#5,#6          ;2610
000042  eb010141          ADD      r1,r1,r1,LSL #1       ;2610
000046  f3c71245          UBFX     r2,r7,#5,#6           ;2610
00004a  4411              ADD      r1,r1,r2              ;2610
00004c  0889              LSRS     r1,r1,#2              ;2610
00004e  ea401041          ORR      r0,r0,r1,LSL #5       ;2610
000052  f007011f          AND      r1,r7,#0x1f           ;2610
000056  f00a021f          AND      r2,r10,#0x1f          ;2610
00005a  eb020242          ADD      r2,r2,r2,LSL #1       ;2610
00005e  4411              ADD      r1,r1,r2              ;2610
000060  ea400091          ORR      r0,r0,r1,LSR #2       ;2610
000064  9003              STR      r0,[sp,#0xc]          ;2610
000066  0af8              LSRS     r0,r7,#11             ;2611
000068  eb0020da          ADD      r0,r0,r10,LSR #11     ;2611
00006c  0840              LSRS     r0,r0,#1              ;2611
00006e  02c0              LSLS     r0,r0,#11             ;2611
000070  f3c71145          UBFX     r1,r7,#5,#6           ;2611
000074  f3ca1245          UBFX     r2,r10,#5,#6          ;2611
000078  4411              ADD      r1,r1,r2              ;2611
00007a  0849              LSRS     r1,r1,#1              ;2611
00007c  ea401041          ORR      r0,r0,r1,LSL #5       ;2611
000080  f007011f          AND      r1,r7,#0x1f           ;2611
000084  f00a021f          AND      r2,r10,#0x1f          ;2611
000088  4411              ADD      r1,r1,r2              ;2611
00008a  ea400051          ORR      r0,r0,r1,LSR #1       ;2611
00008e  9002              STR      r0,[sp,#8]            ;2611
000090  0af8              LSRS     r0,r7,#11             ;2612
000092  eb000040          ADD      r0,r0,r0,LSL #1       ;2612
000096  eb0020da          ADD      r0,r0,r10,LSR #11     ;2612
00009a  0880              LSRS     r0,r0,#2              ;2612
00009c  02c0              LSLS     r0,r0,#11             ;2612
00009e  f3c71145          UBFX     r1,r7,#5,#6           ;2612
0000a2  eb010141          ADD      r1,r1,r1,LSL #1       ;2612
0000a6  f3ca1245          UBFX     r2,r10,#5,#6          ;2612
0000aa  4411              ADD      r1,r1,r2              ;2612
0000ac  0889              LSRS     r1,r1,#2              ;2612
0000ae  ea401041          ORR      r0,r0,r1,LSL #5       ;2612
0000b2  f007011f          AND      r1,r7,#0x1f           ;2612
0000b6  eb010141          ADD      r1,r1,r1,LSL #1       ;2612
0000ba  f00a021f          AND      r2,r10,#0x1f          ;2612
0000be  4411              ADD      r1,r1,r2              ;2612
0000c0  ea400091          ORR      r0,r0,r1,LSR #2       ;2612
0000c4  9001              STR      r0,[sp,#4]            ;2612
0000c6  9808              LDR      r0,[sp,#0x20]         ;2615
0000c8  2801              CMP      r0,#1                 ;2615
0000ca  d170              BNE      |L25.430|
0000cc  9806              LDR      r0,[sp,#0x18]         ;2617
0000ce  9004              STR      r0,[sp,#0x10]         ;2617
0000d0  e08d              B        |L25.494|
                  |L25.210|
0000d2  46cb              MOV      r11,r9                ;2619
0000d4  e083              B        |L25.478|
                  |L25.214|
0000d6  eb0600e4          ADD      r0,r6,r4,ASR #3       ;2621
0000da  7800              LDRB     r0,[r0,#0]            ;2621
0000dc  f0040107          AND      r1,r4,#7              ;2621
0000e0  f1c10207          RSB      r2,r1,#7              ;2621
0000e4  2101              MOVS     r1,#1                 ;2621
0000e6  4091              LSLS     r1,r1,r2              ;2621
0000e8  4008              ANDS     r0,r0,r1              ;2621
0000ea  b128              CBZ      r0,|L25.248|
0000ec  463a              MOV      r2,r7                 ;2622
0000ee  4658              MOV      r0,r11                ;2622
0000f0  9904              LDR      r1,[sp,#0x10]         ;2622
0000f2  f7fffffe          BL       RMP_Point
0000f6  e06f              B        |L25.472|
                  |L25.248|
0000f8  f04f0800          MOV      r8,#0                 ;2626
0000fc  1e60              SUBS     r0,r4,#1              ;2628
0000fe  2800              CMP      r0,#0                 ;2628
000100  d420              BMI      |L25.324|
000102  45cb              CMP      r11,r9                ;2630
000104  d00d              BEQ      |L25.290|
000106  eb0600e0          ADD      r0,r6,r0,ASR #3       ;2630
00010a  7800              LDRB     r0,[r0,#0]            ;2630
00010c  1e61              SUBS     r1,r4,#1              ;2630
00010e  f0010107          AND      r1,r1,#7              ;2630
000112  f1c10207          RSB      r2,r1,#7              ;2630
000116  2101              MOVS     r1,#1                 ;2630
000118  4091              LSLS     r1,r1,r2              ;2630
00011a  4008              ANDS     r0,r0,r1              ;2630
00011c  b108              CBZ      r0,|L25.290|
00011e  f1080801          ADD      r8,r8,#1              ;2631
                  |L25.290|
000122  1b60              SUBS     r0,r4,r5              ;2632
000124  d40e              BMI      |L25.324|
000126  1b60              SUBS     r0,r4,r5              ;2632
000128  eb0600e0          ADD      r0,r6,r0,ASR #3       ;2632
00012c  7800              LDRB     r0,[r0,#0]            ;2632
00012e  1b61              SUBS     r1,r4,r5              ;2632
000130  f0010107          AND      r1,r1,#7              ;2632
000134  f1c10207          RSB      r2,r1,#7              ;2632
000138  2101              MOVS     r1,#1                 ;2632
00013a  4091              LSLS     r1,r1,r2              ;2632
00013c  4008              ANDS     r0,r0,r1              ;2632
00013e  b108              CBZ      r0,|L25.324|
000140  f1080801          ADD      r8,r8,#1              ;2633
                  |L25.324|
000144  1c60              ADDS     r0,r4,#1              ;2636
000146  9900              LDR      r1,[sp,#0]            ;2636
000148  4288              CMP      r0,r1                 ;2636
00014a  d226              BCS      |L25.410|
00014c  eb090005          ADD      r0,r9,r5              ;2638
000150  1e40              SUBS     r0,r0,#1              ;2638
000152  4558              CMP      r0,r11                ;2638
000154  d00e              BEQ      |L25.372|
000156  1c60              ADDS     r0,r4,#1              ;2638
000158  eb0600e0          ADD      r0,r6,r0,ASR #3       ;2638
00015c  7800              LDRB     r0,[r0,#0]            ;2638
00015e  1c61              ADDS     r1,r4,#1              ;2638
000160  f0010107          AND      r1,r1,#7              ;2638
000164  f1c10207          RSB      r2,r1,#7              ;2638
000168  2101              MOVS     r1,#1                 ;2638
00016a  4091              LSLS     r1,r1,r2              ;2638
00016c  4008              ANDS     r0,r0,r1              ;2638
00016e  b108              CBZ      r0,|L25.372|
000170  f1080801          ADD      r8,r8,#1              ;2639
                  |L25.372|
000174  1961              ADDS     r1,r4,r5              ;2640
000176  9800              LDR      r0,[sp,#0]            ;2640
000178  4281              CMP      r1,r0                 ;2640
00017a  d20e              BCS      |L25.410|
00017c  1960              ADDS     r0,r4,r5              ;2640
00017e  eb0600e0          ADD      r0,r6,r0,ASR #3       ;2640
000182  7800              LDRB     r0,[r0,#0]            ;2640
000184  1961              ADDS     r1,r4,r5              ;2640
000186  f0010107          AND      r1,r1,#7              ;2640
00018a  f1c10207          RSB      r2,r1,#7              ;2640
00018e  2101              MOVS     r1,#1                 ;2640
000190  4091              LSLS     r1,r1,r2              ;2640
000192  4008              ANDS     r0,r0,r1              ;2640
000194  b108              CBZ      r0,|L25.410|
000196  f1080801          ADD      r8,r8,#1              ;2641
                  |L25.410|
00019a  f1b80f01          CMP      r8,#1                 ;2644
00019e  d007              BEQ      |L25.432|
0001a0  f1b80f02          CMP      r8,#2                 ;2644
0001a4  d00a              BEQ      |L25.444|
0001a6  f1b80f03          CMP      r8,#3                 ;2644
0001aa  d113              BNE      |L25.468|
0001ac  e00c              B        |L25.456|
                  |L25.430|
0001ae  e026              B        |L25.510|
                  |L25.432|
0001b0  4658              MOV      r0,r11                ;2646
0001b2  e9dd2103          LDRD     r2,r1,[sp,#0xc]       ;2646
0001b6  f7fffffe          BL       RMP_Point
0001ba  e00c              B        |L25.470|
                  |L25.444|
0001bc  4658              MOV      r0,r11                ;2647
0001be  9a02              LDR      r2,[sp,#8]            ;2647
0001c0  9904              LDR      r1,[sp,#0x10]         ;2647
0001c2  f7fffffe          BL       RMP_Point
0001c6  e006              B        |L25.470|
                  |L25.456|
0001c8  4658              MOV      r0,r11                ;2648
0001ca  9a01              LDR      r2,[sp,#4]            ;2648
0001cc  9904              LDR      r1,[sp,#0x10]         ;2648
0001ce  f7fffffe          BL       RMP_Point
0001d2  e000              B        |L25.470|
                  |L25.468|
0001d4  bf00              NOP                            ;2649
                  |L25.470|
0001d6  bf00              NOP                            ;2646
                  |L25.472|
0001d8  1c64              ADDS     r4,r4,#1              ;2653
0001da  f10b0b01          ADD      r11,r11,#1            ;2619
                  |L25.478|
0001de  eb050009          ADD      r0,r5,r9              ;2619
0001e2  4558              CMP      r0,r11                ;2619
0001e4  f73faf77          BGT      |L25.214|
0001e8  9804              LDR      r0,[sp,#0x10]         ;2617
0001ea  1c40              ADDS     r0,r0,#1              ;2617
0001ec  9004              STR      r0,[sp,#0x10]         ;2617
                  |L25.494|
0001ee  9906              LDR      r1,[sp,#0x18]         ;2617
0001f0  9813              LDR      r0,[sp,#0x4c]         ;2617
0001f2  4401              ADD      r1,r1,r0              ;2617
0001f4  9804              LDR      r0,[sp,#0x10]         ;2617
0001f6  4281              CMP      r1,r0                 ;2617
0001f8  f73faf6b          BGT      |L25.210|
0001fc  e08b              B        |L25.790|
                  |L25.510|
0001fe  9806              LDR      r0,[sp,#0x18]         ;2660
000200  9004              STR      r0,[sp,#0x10]         ;2660
000202  e081              B        |L25.776|
                  |L25.516|
000204  46cb              MOV      r11,r9                ;2662
000206  e078              B        |L25.762|
                  |L25.520|
000208  eb0600e4          ADD      r0,r6,r4,ASR #3       ;2664
00020c  7800              LDRB     r0,[r0,#0]            ;2664
00020e  f0040207          AND      r2,r4,#7              ;2664
000212  2101              MOVS     r1,#1                 ;2664
000214  4091              LSLS     r1,r1,r2              ;2664
000216  4008              ANDS     r0,r0,r1              ;2664
000218  b128              CBZ      r0,|L25.550|
00021a  463a              MOV      r2,r7                 ;2665
00021c  4658              MOV      r0,r11                ;2665
00021e  9904              LDR      r1,[sp,#0x10]         ;2665
000220  f7fffffe          BL       RMP_Point
000224  e066              B        |L25.756|
                  |L25.550|
000226  f04f0800          MOV      r8,#0                 ;2669
00022a  1e60              SUBS     r0,r4,#1              ;2671
00022c  2800              CMP      r0,#0                 ;2671
00022e  d41c              BMI      |L25.618|
000230  45cb              CMP      r11,r9                ;2673
000232  d00b              BEQ      |L25.588|
000234  eb0600e0          ADD      r0,r6,r0,ASR #3       ;2673
000238  7800              LDRB     r0,[r0,#0]            ;2673
00023a  1e61              SUBS     r1,r4,#1              ;2673
00023c  f0010207          AND      r2,r1,#7              ;2673
000240  2101              MOVS     r1,#1                 ;2673
000242  4091              LSLS     r1,r1,r2              ;2673
000244  4008              ANDS     r0,r0,r1              ;2673
000246  b108              CBZ      r0,|L25.588|
000248  f1080801          ADD      r8,r8,#1              ;2674
                  |L25.588|
00024c  1b60              SUBS     r0,r4,r5              ;2675
00024e  d40c              BMI      |L25.618|
000250  1b60              SUBS     r0,r4,r5              ;2675
000252  eb0600e0          ADD      r0,r6,r0,ASR #3       ;2675
000256  7800              LDRB     r0,[r0,#0]            ;2675
000258  1b61              SUBS     r1,r4,r5              ;2675
00025a  f0010207          AND      r2,r1,#7              ;2675
00025e  2101              MOVS     r1,#1                 ;2675
000260  4091              LSLS     r1,r1,r2              ;2675
000262  4008              ANDS     r0,r0,r1              ;2675
000264  b108              CBZ      r0,|L25.618|
000266  f1080801          ADD      r8,r8,#1              ;2676
                  |L25.618|
00026a  1c60              ADDS     r0,r4,#1              ;2679
00026c  9900              LDR      r1,[sp,#0]            ;2679
00026e  4288              CMP      r0,r1                 ;2679
000270  d222              BCS      |L25.696|
000272  eb090005          ADD      r0,r9,r5              ;2681
000276  1e40              SUBS     r0,r0,#1              ;2681
000278  4558              CMP      r0,r11                ;2681
00027a  d00c              BEQ      |L25.662|
00027c  1c60              ADDS     r0,r4,#1              ;2681
00027e  eb0600e0          ADD      r0,r6,r0,ASR #3       ;2681
000282  7800              LDRB     r0,[r0,#0]            ;2681
000284  1c61              ADDS     r1,r4,#1              ;2681
000286  f0010207          AND      r2,r1,#7              ;2681
00028a  2101              MOVS     r1,#1                 ;2681
00028c  4091              LSLS     r1,r1,r2              ;2681
00028e  4008              ANDS     r0,r0,r1              ;2681
000290  b108              CBZ      r0,|L25.662|
000292  f1080801          ADD      r8,r8,#1              ;2682
                  |L25.662|
000296  1961              ADDS     r1,r4,r5              ;2683
000298  9800              LDR      r0,[sp,#0]            ;2683
00029a  4281              CMP      r1,r0                 ;2683
00029c  d20c              BCS      |L25.696|
00029e  1960              ADDS     r0,r4,r5              ;2683
0002a0  eb0600e0          ADD      r0,r6,r0,ASR #3       ;2683
0002a4  7800              LDRB     r0,[r0,#0]            ;2683
0002a6  1961              ADDS     r1,r4,r5              ;2683
0002a8  f0010207          AND      r2,r1,#7              ;2683
0002ac  2101              MOVS     r1,#1                 ;2683
0002ae  4091              LSLS     r1,r1,r2              ;2683
0002b0  4008              ANDS     r0,r0,r1              ;2683
0002b2  b108              CBZ      r0,|L25.696|
0002b4  f1080801          ADD      r8,r8,#1              ;2684
                  |L25.696|
0002b8  f1b80f01          CMP      r8,#1                 ;2687
0002bc  d006              BEQ      |L25.716|
0002be  f1b80f02          CMP      r8,#2                 ;2687
0002c2  d009              BEQ      |L25.728|
0002c4  f1b80f03          CMP      r8,#3                 ;2687
0002c8  d112              BNE      |L25.752|
0002ca  e00b              B        |L25.740|
                  |L25.716|
0002cc  4658              MOV      r0,r11                ;2689
0002ce  e9dd2103          LDRD     r2,r1,[sp,#0xc]       ;2689
0002d2  f7fffffe          BL       RMP_Point
0002d6  e00c              B        |L25.754|
                  |L25.728|
0002d8  4658              MOV      r0,r11                ;2690
0002da  9a02              LDR      r2,[sp,#8]            ;2690
0002dc  9904              LDR      r1,[sp,#0x10]         ;2690
0002de  f7fffffe          BL       RMP_Point
0002e2  e006              B        |L25.754|
                  |L25.740|
0002e4  4658              MOV      r0,r11                ;2691
0002e6  9a01              LDR      r2,[sp,#4]            ;2691
0002e8  9904              LDR      r1,[sp,#0x10]         ;2691
0002ea  f7fffffe          BL       RMP_Point
0002ee  e000              B        |L25.754|
                  |L25.752|
0002f0  bf00              NOP                            ;2692
                  |L25.754|
0002f2  bf00              NOP                            ;2689
                  |L25.756|
0002f4  1c64              ADDS     r4,r4,#1              ;2696
0002f6  f10b0b01          ADD      r11,r11,#1            ;2662
                  |L25.762|
0002fa  eb050009          ADD      r0,r5,r9              ;2662
0002fe  4558              CMP      r0,r11                ;2662
000300  dc82              BGT      |L25.520|
000302  9804              LDR      r0,[sp,#0x10]         ;2660
000304  1c40              ADDS     r0,r0,#1              ;2660
000306  9004              STR      r0,[sp,#0x10]         ;2660
                  |L25.776|
000308  9906              LDR      r1,[sp,#0x18]         ;2660
00030a  9813              LDR      r0,[sp,#0x4c]         ;2660
00030c  4401              ADD      r1,r1,r0              ;2660
00030e  9804              LDR      r0,[sp,#0x10]         ;2660
000310  4281              CMP      r1,r0                 ;2660
000312  f73faf77          BGT      |L25.516|
                  |L25.790|
000316  bf00              NOP      
000318  e681              B        |L25.30|
;;;2701   #endif
                          ENDP


                          AREA ||i.RMP_Mem_Init||, CODE, READONLY, ALIGN=1

                  RMP_Mem_Init PROC
;;;1779   ******************************************************************************/
;;;1780   ret_t RMP_Mem_Init(volatile void* Pool, ptr_t Size)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1781   {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;1782       cnt_t FLI_Cnt;
;;;1783       ptr_t Usable_Size;
;;;1784       volatile struct RMP_Mem* Mem;
;;;1785       volatile struct RMP_Mem_Head* Mem_Head;
;;;1786       
;;;1787       /* See if the memory pool is large enough to enable dynamic allocation - at least 4096 words */
;;;1788       if((Pool==0)||(Size<(4096*sizeof(ptr_t)))||((Size>>27)>0))
000008  b126              CBZ      r6,|L26.20|
00000a  f5b74f80          CMP      r7,#0x4000
00000e  d301              BCC      |L26.20|
000010  0ef8              LSRS     r0,r7,#27
000012  b118              CBZ      r0,|L26.28|
                  |L26.20|
;;;1789           return RMP_ERR_MEM;
000014  f06f0006          MVN      r0,#6
                  |L26.24|
;;;1790       
;;;1791       /* See if the address and size is word-aligned */
;;;1792       if((((ptr_t)Pool&(RMP_WORD_MASK>>2))!=0)||((Size&(RMP_WORD_MASK>>2))!=0))
;;;1793           return RMP_ERR_MEM;
;;;1794           
;;;1795       Mem=(volatile struct RMP_Mem*)Pool;
;;;1796       Mem->Size=Size;
;;;1797       /* Initialize the allocated block list */
;;;1798       RMP_List_Crt(&(Mem->Alloc));
;;;1799       /* Calculate the FLI value needed for this - we always align to 64 byte */
;;;1800       Mem->FLI_Num=RMP_MSB_Get(Size-sizeof(struct RMP_Mem))-6+1;
;;;1801       /* Initialize the TLSF allocation table first */
;;;1802       for(FLI_Cnt=0;FLI_Cnt<(cnt_t)(Mem->FLI_Num);FLI_Cnt++)
;;;1803       {
;;;1804           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,0)]));
;;;1805           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,1)]));
;;;1806           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,2)]));
;;;1807           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,3)]));
;;;1808           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,4)]));
;;;1809           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,5)]));
;;;1810           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,6)]));
;;;1811           RMP_List_Crt(&(Mem->Table[RMP_MEM_POS(FLI_Cnt,7)]));
;;;1812       }
;;;1813       for(FLI_Cnt=0;FLI_Cnt<5;FLI_Cnt++)
;;;1814           Mem->Bitmap[FLI_Cnt]=0;
;;;1815       
;;;1816       /* Get the big memory block's size and position */
;;;1817       Usable_Size=sizeof(struct RMP_Mem)+(sizeof(struct RMP_List)<<3)*(Mem->FLI_Num-8);
;;;1818       Mem_Head=(struct RMP_Mem_Head*)(((ptr_t)Pool)+Usable_Size);
;;;1819       Mem->Start=(ptr_t)Mem_Head;
;;;1820       Usable_Size=Size-Usable_Size;
;;;1821       
;;;1822       /* Initialize the big block */
;;;1823       _RMP_Mem_Block(Mem_Head,Usable_Size);
;;;1824       
;;;1825       /* Insert the memory into the corresponding level */
;;;1826       _RMP_Mem_Ins(Pool, Mem_Head);
;;;1827       return 0;
;;;1828   }
000018  e8bd87f0          POP      {r4-r10,pc}
                  |L26.28|
00001c  f0060003          AND      r0,r6,#3              ;1792
000020  b910              CBNZ     r0,|L26.40|
000022  f0070003          AND      r0,r7,#3              ;1792
000026  b110              CBZ      r0,|L26.46|
                  |L26.40|
000028  f06f0006          MVN      r0,#6                 ;1793
00002c  e7f4              B        |L26.24|
                  |L26.46|
00002e  4634              MOV      r4,r6                 ;1795
000030  6127              STR      r7,[r4,#0x10]         ;1796
000032  4620              MOV      r0,r4                 ;1798
000034  f7fffffe          BL       RMP_List_Crt
000038  f5a7700a          SUB      r0,r7,#0x228          ;1800
00003c  f7fffffe          BL       RMP_MSB_Get
000040  1f40              SUBS     r0,r0,#5              ;1800
000042  60a0              STR      r0,[r4,#8]            ;1800
000044  2500              MOVS     r5,#0                 ;1802
000046  e048              B        |L26.218|
                  |L26.72|
000048  2100              MOVS     r1,#0                 ;1804
00004a  eb0102c5          ADD      r2,r1,r5,LSL #3       ;1804
00004e  f1040128          ADD      r1,r4,#0x28           ;1804
000052  eb0100c2          ADD      r0,r1,r2,LSL #3       ;1804
000056  f7fffffe          BL       RMP_List_Crt
00005a  2101              MOVS     r1,#1                 ;1805
00005c  eb0102c5          ADD      r2,r1,r5,LSL #3       ;1805
000060  f1040128          ADD      r1,r4,#0x28           ;1805
000064  eb0100c2          ADD      r0,r1,r2,LSL #3       ;1805
000068  f7fffffe          BL       RMP_List_Crt
00006c  2102              MOVS     r1,#2                 ;1806
00006e  eb0102c5          ADD      r2,r1,r5,LSL #3       ;1806
000072  f1040128          ADD      r1,r4,#0x28           ;1806
000076  eb0100c2          ADD      r0,r1,r2,LSL #3       ;1806
00007a  f7fffffe          BL       RMP_List_Crt
00007e  2103              MOVS     r1,#3                 ;1807
000080  eb0102c5          ADD      r2,r1,r5,LSL #3       ;1807
000084  f1040128          ADD      r1,r4,#0x28           ;1807
000088  eb0100c2          ADD      r0,r1,r2,LSL #3       ;1807
00008c  f7fffffe          BL       RMP_List_Crt
000090  2104              MOVS     r1,#4                 ;1808
000092  eb0102c5          ADD      r2,r1,r5,LSL #3       ;1808
000096  f1040128          ADD      r1,r4,#0x28           ;1808
00009a  eb0100c2          ADD      r0,r1,r2,LSL #3       ;1808
00009e  f7fffffe          BL       RMP_List_Crt
0000a2  2105              MOVS     r1,#5                 ;1809
0000a4  eb0102c5          ADD      r2,r1,r5,LSL #3       ;1809
0000a8  f1040128          ADD      r1,r4,#0x28           ;1809
0000ac  eb0100c2          ADD      r0,r1,r2,LSL #3       ;1809
0000b0  f7fffffe          BL       RMP_List_Crt
0000b4  2106              MOVS     r1,#6                 ;1810
0000b6  eb0102c5          ADD      r2,r1,r5,LSL #3       ;1810
0000ba  f1040128          ADD      r1,r4,#0x28           ;1810
0000be  eb0100c2          ADD      r0,r1,r2,LSL #3       ;1810
0000c2  f7fffffe          BL       RMP_List_Crt
0000c6  2107              MOVS     r1,#7                 ;1811
0000c8  eb0102c5          ADD      r2,r1,r5,LSL #3       ;1811
0000cc  f1040128          ADD      r1,r4,#0x28           ;1811
0000d0  eb0100c2          ADD      r0,r1,r2,LSL #3       ;1811
0000d4  f7fffffe          BL       RMP_List_Crt
0000d8  1c6d              ADDS     r5,r5,#1              ;1802
                  |L26.218|
0000da  68a0              LDR      r0,[r4,#8]            ;1802
0000dc  42a8              CMP      r0,r5                 ;1802
0000de  dcb3              BGT      |L26.72|
0000e0  2500              MOVS     r5,#0                 ;1813
0000e2  e005              B        |L26.240|
                  |L26.228|
0000e4  2100              MOVS     r1,#0                 ;1814
0000e6  f1040014          ADD      r0,r4,#0x14           ;1814
0000ea  f8401025          STR      r1,[r0,r5,LSL #2]     ;1814
0000ee  1c6d              ADDS     r5,r5,#1              ;1813
                  |L26.240|
0000f0  2d05              CMP      r5,#5                 ;1813
0000f2  dbf7              BLT      |L26.228|
0000f4  68a0              LDR      r0,[r4,#8]            ;1817
0000f6  3808              SUBS     r0,r0,#8              ;1817
0000f8  0180              LSLS     r0,r0,#6              ;1817
0000fa  f500790a          ADD      r9,r0,#0x228          ;1817
0000fe  eb060809          ADD      r8,r6,r9              ;1818
000102  f8c4800c          STR      r8,[r4,#0xc]          ;1819
000106  eba70909          SUB      r9,r7,r9              ;1820
00010a  4649              MOV      r1,r9                 ;1823
00010c  4640              MOV      r0,r8                 ;1823
00010e  f7fffffe          BL       _RMP_Mem_Block
000112  4641              MOV      r1,r8                 ;1826
000114  4630              MOV      r0,r6                 ;1826
000116  f7fffffe          BL       _RMP_Mem_Ins
00011a  2000              MOVS     r0,#0                 ;1827
00011c  e77c              B        |L26.24|
;;;1829   /* End Function:RMP_Mem_Init *************************************************/
                          ENDP


                          AREA ||i.RMP_Print_Int||, CODE, READONLY, ALIGN=1

                  RMP_Print_Int PROC
;;;69     ******************************************************************************/
;;;70     cnt_t RMP_Print_Int(cnt_t Int)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;71     {
000004  4607              MOV      r7,r0
;;;72         ptr_t Iter;
;;;73         cnt_t Count;
;;;74         cnt_t Num;
;;;75         ptr_t Div;
;;;76         
;;;77         /* how many digits are there? */
;;;78         if(Int==0)
000006  b92f              CBNZ     r7,|L27.20|
;;;79         {
;;;80             RMP_Putchar('0');
000008  2030              MOVS     r0,#0x30
00000a  f7fffffe          BL       RMP_Putchar
;;;81             return 1;
00000e  2001              MOVS     r0,#1
                  |L27.16|
;;;82         }
;;;83         else if(Int<0)
;;;84         {
;;;85             /* How many digits are there? */
;;;86             Count=0;
;;;87             Div=1;
;;;88             Iter=-Int;
;;;89             while(Iter!=0)
;;;90             {
;;;91                 Iter/=10;
;;;92                 Count++;
;;;93                 Div*=10;
;;;94             }
;;;95             Div/=10;
;;;96             
;;;97             RMP_Putchar('-');
;;;98             Iter=-Int;
;;;99             Num=Count+1;
;;;100            
;;;101            while(Count>0)
;;;102            {
;;;103                Count--;
;;;104                RMP_Putchar(Iter/Div+'0');
;;;105                Iter=Iter%Div;
;;;106                Div/=10;
;;;107            }
;;;108        }
;;;109        else
;;;110        {
;;;111            /* How many digits are there? */
;;;112            Count=0;
;;;113            Div=1;
;;;114            Iter=Int;
;;;115            while(Iter!=0)
;;;116            {
;;;117                Iter/=10;
;;;118                Count++;
;;;119                Div*=10;
;;;120            }
;;;121            Div/=10;
;;;122            
;;;123            Iter=Int;
;;;124            Num=Count;
;;;125            
;;;126            while(Count>0)
;;;127            {
;;;128                Count--;
;;;129                RMP_Putchar(Iter/Div+'0');
;;;130                Iter=Iter%Div;
;;;131                Div/=10;
;;;132            }
;;;133        }
;;;134        
;;;135        return Num;
;;;136    }
000010  e8bd87f0          POP      {r4-r10,pc}
                  |L27.20|
000014  2f00              CMP      r7,#0                 ;83
000016  da29              BGE      |L27.108|
000018  2600              MOVS     r6,#0                 ;86
00001a  2401              MOVS     r4,#1                 ;87
00001c  427d              RSBS     r5,r7,#0              ;88
00001e  e006              B        |L27.46|
                  |L27.32|
000020  200a              MOVS     r0,#0xa               ;91
000022  fbb5f5f0          UDIV     r5,r5,r0              ;91
000026  1c76              ADDS     r6,r6,#1              ;92
000028  eb040084          ADD      r0,r4,r4,LSL #2       ;93
00002c  0044              LSLS     r4,r0,#1              ;93
                  |L27.46|
00002e  2d00              CMP      r5,#0                 ;89
000030  d1f6              BNE      |L27.32|
000032  200a              MOVS     r0,#0xa               ;95
000034  fbb4f4f0          UDIV     r4,r4,r0              ;95
000038  202d              MOVS     r0,#0x2d              ;97
00003a  f7fffffe          BL       RMP_Putchar
00003e  427d              RSBS     r5,r7,#0              ;98
000040  f1060801          ADD      r8,r6,#1              ;99
000044  e00f              B        |L27.102|
                  |L27.70|
000046  1e76              SUBS     r6,r6,#1              ;103
000048  fbb5f0f4          UDIV     r0,r5,r4              ;104
00004c  3030              ADDS     r0,r0,#0x30           ;104
00004e  fa4ff980          SXTB     r9,r0                 ;104
000052  4648              MOV      r0,r9                 ;104
000054  f7fffffe          BL       RMP_Putchar
000058  fbb5f0f4          UDIV     r0,r5,r4              ;105
00005c  fb045510          MLS      r5,r4,r0,r5           ;105
000060  200a              MOVS     r0,#0xa               ;106
000062  fbb4f4f0          UDIV     r4,r4,r0              ;106
                  |L27.102|
000066  2e00              CMP      r6,#0                 ;101
000068  dced              BGT      |L27.70|
00006a  e024              B        |L27.182|
                  |L27.108|
00006c  2600              MOVS     r6,#0                 ;112
00006e  2401              MOVS     r4,#1                 ;113
000070  463d              MOV      r5,r7                 ;114
000072  e006              B        |L27.130|
                  |L27.116|
000074  200a              MOVS     r0,#0xa               ;117
000076  fbb5f5f0          UDIV     r5,r5,r0              ;117
00007a  1c76              ADDS     r6,r6,#1              ;118
00007c  eb040084          ADD      r0,r4,r4,LSL #2       ;119
000080  0044              LSLS     r4,r0,#1              ;119
                  |L27.130|
000082  2d00              CMP      r5,#0                 ;115
000084  d1f6              BNE      |L27.116|
000086  200a              MOVS     r0,#0xa               ;121
000088  fbb4f4f0          UDIV     r4,r4,r0              ;121
00008c  463d              MOV      r5,r7                 ;123
00008e  46b0              MOV      r8,r6                 ;124
000090  e00f              B        |L27.178|
                  |L27.146|
000092  1e76              SUBS     r6,r6,#1              ;128
000094  fbb5f0f4          UDIV     r0,r5,r4              ;129
000098  3030              ADDS     r0,r0,#0x30           ;129
00009a  fa4ff980          SXTB     r9,r0                 ;129
00009e  4648              MOV      r0,r9                 ;129
0000a0  f7fffffe          BL       RMP_Putchar
0000a4  fbb5f0f4          UDIV     r0,r5,r4              ;130
0000a8  fb045510          MLS      r5,r4,r0,r5           ;130
0000ac  200a              MOVS     r0,#0xa               ;131
0000ae  fbb4f4f0          UDIV     r4,r4,r0              ;131
                  |L27.178|
0000b2  2e00              CMP      r6,#0                 ;126
0000b4  dced              BGT      |L27.146|
                  |L27.182|
0000b6  4640              MOV      r0,r8                 ;135
0000b8  e7aa              B        |L27.16|
;;;137    /* End Function:RMP_Print_Int ************************************************/
                          ENDP


                          AREA ||i.RMP_Print_String||, CODE, READONLY, ALIGN=1

                  RMP_Print_String PROC
;;;192    ******************************************************************************/
;;;193    cnt_t RMP_Print_String(s8* String)
000000  b570              PUSH     {r4-r6,lr}
;;;194    {
000002  4605              MOV      r5,r0
;;;195        cnt_t Count;
;;;196        
;;;197        Count=0;
000004  2400              MOVS     r4,#0
;;;198        while(Count<RMP_KERNEL_DEBUG_MAX_STR)
000006  e007              B        |L28.24|
                  |L28.8|
;;;199        {
;;;200            if(String[Count]=='\0')
000008  5d28              LDRB     r0,[r5,r4]
00000a  b900              CBNZ     r0,|L28.14|
;;;201                break;
00000c  e006              B        |L28.28|
                  |L28.14|
;;;202            
;;;203            RMP_Putchar(String[Count++]);
00000e  4621              MOV      r1,r4
000010  1c64              ADDS     r4,r4,#1
000012  5668              LDRSB    r0,[r5,r1]
000014  f7fffffe          BL       RMP_Putchar
                  |L28.24|
000018  2cff              CMP      r4,#0xff              ;198
00001a  dbf5              BLT      |L28.8|
                  |L28.28|
00001c  bf00              NOP                            ;201
;;;204        }
;;;205        
;;;206        return Count;
00001e  4620              MOV      r0,r4
;;;207    }
000020  bd70              POP      {r4-r6,pc}
;;;208    /* End Function:RMP_Print_String *********************************************/
                          ENDP


                          AREA ||i.RMP_Print_Uint||, CODE, READONLY, ALIGN=1

                  RMP_Print_Uint PROC
;;;145    ******************************************************************************/
;;;146    cnt_t RMP_Print_Uint(ptr_t Uint)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;147    {
000004  4606              MOV      r6,r0
;;;148        ptr_t Iter;
;;;149        cnt_t Count;
;;;150        cnt_t Num;
;;;151        
;;;152        /* how many digits are there? */
;;;153        if(Uint==0)
000006  b92e              CBNZ     r6,|L29.20|
;;;154        {
;;;155            RMP_Putchar('0');
000008  2030              MOVS     r0,#0x30
00000a  f7fffffe          BL       RMP_Putchar
;;;156            return 1;
00000e  2001              MOVS     r0,#1
                  |L29.16|
;;;157        }
;;;158        else
;;;159        {
;;;160            /* Filter out all the zeroes */
;;;161            Count=0;
;;;162            Iter=Uint;
;;;163            while((Iter>>((sizeof(ptr_t)*8)-4))==0)
;;;164            {
;;;165                Iter<<=4;
;;;166                Count++;
;;;167            }
;;;168            /* Count is the number of pts to print */
;;;169            Count=sizeof(ptr_t)*2-Count;
;;;170            Num=Count;
;;;171            while(Count>0)
;;;172            {
;;;173                Count--;
;;;174                Iter=(Uint>>(Count*4))&0x0F;
;;;175                if(Iter<10)
;;;176                    RMP_Putchar('0'+Iter);
;;;177                else
;;;178                    RMP_Putchar('A'+Iter-10);
;;;179            }
;;;180        }
;;;181        
;;;182        return Num;
;;;183    }
000010  e8bd81f0          POP      {r4-r8,pc}
                  |L29.20|
000014  2400              MOVS     r4,#0                 ;161
000016  4635              MOV      r5,r6                 ;162
000018  e001              B        |L29.30|
                  |L29.26|
00001a  012d              LSLS     r5,r5,#4              ;165
00001c  1c64              ADDS     r4,r4,#1              ;166
                  |L29.30|
00001e  0f28              LSRS     r0,r5,#28             ;163
000020  2800              CMP      r0,#0                 ;163
000022  d0fa              BEQ      |L29.26|
000024  f1c40408          RSB      r4,r4,#8              ;169
000028  4627              MOV      r7,r4                 ;170
00002a  e012              B        |L29.82|
                  |L29.44|
00002c  1e64              SUBS     r4,r4,#1              ;173
00002e  00a0              LSLS     r0,r4,#2              ;174
000030  fa26f000          LSR      r0,r6,r0              ;174
000034  f000050f          AND      r5,r0,#0xf            ;174
000038  2d0a              CMP      r5,#0xa               ;175
00003a  d205              BCS      |L29.72|
00003c  f1050130          ADD      r1,r5,#0x30           ;176
000040  b248              SXTB     r0,r1                 ;176
000042  f7fffffe          BL       RMP_Putchar
000046  e004              B        |L29.82|
                  |L29.72|
000048  f1050137          ADD      r1,r5,#0x37           ;178
00004c  b248              SXTB     r0,r1                 ;178
00004e  f7fffffe          BL       RMP_Putchar
                  |L29.82|
000052  2c00              CMP      r4,#0                 ;171
000054  dcea              BGT      |L29.44|
000056  4638              MOV      r0,r7                 ;182
000058  e7da              B        |L29.16|
;;;184    /* End Function:RMP_Print_Uint ***********************************************/
                          ENDP


                          AREA ||i.RMP_Progbar||, CODE, READONLY, ALIGN=1

                  RMP_Progbar PROC
;;;3388   ******************************************************************************/
;;;3389   void RMP_Progbar(cnt_t Coord_X, cnt_t Coord_Y, cnt_t Length, cnt_t Width,
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;3390                    cnt_t Style, cnt_t Prog, ptr_t Fore, ptr_t Back)
;;;3391   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  e9ddab10          LDRD     r10,r11,[sp,#0x40]
000010  e9dd890e          LDRD     r8,r9,[sp,#0x38]
;;;3392       /* Draw the progress bar according to the style of the progress bar */
;;;3393       RMP_Progbar_Prog(Coord_X,Coord_Y,Length,Width,Style,Prog,Fore,Back);
000014  463b              MOV      r3,r7
000016  4632              MOV      r2,r6
000018  4629              MOV      r1,r5
00001a  4620              MOV      r0,r4
00001c  e88d0f00          STM      sp,{r8-r11}
000020  f7fffffe          BL       RMP_Progbar_Prog
;;;3394       /* Now draw the border */
;;;3395       RMP_Line(Coord_X,Coord_Y,Coord_X+Length-1,Coord_Y,RMP_CTL_BLACK);
000024  2000              MOVS     r0,#0
000026  9000              STR      r0,[sp,#0]
000028  19a0              ADDS     r0,r4,r6
00002a  1e42              SUBS     r2,r0,#1
00002c  462b              MOV      r3,r5
00002e  4629              MOV      r1,r5
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       RMP_Line
;;;3396       RMP_Line(Coord_X+Length-1,Coord_Y,Coord_X+Length-1,Coord_Y+Width-1,RMP_CTL_BLACK);
000036  2000              MOVS     r0,#0
000038  19e9              ADDS     r1,r5,r7
00003a  1e4b              SUBS     r3,r1,#1
00003c  19a1              ADDS     r1,r4,r6
00003e  1e4a              SUBS     r2,r1,#1
000040  19a1              ADDS     r1,r4,r6
000042  9000              STR      r0,[sp,#0]
000044  1e48              SUBS     r0,r1,#1
000046  4629              MOV      r1,r5
000048  f7fffffe          BL       RMP_Line
;;;3397       RMP_Line(Coord_X+Length-1,Coord_Y+Width-1,Coord_X,Coord_Y+Width-1,RMP_CTL_BLACK);
00004c  2000              MOVS     r0,#0
00004e  19ea              ADDS     r2,r5,r7
000050  1e53              SUBS     r3,r2,#1
000052  19ea              ADDS     r2,r5,r7
000054  1e51              SUBS     r1,r2,#1
000056  19a2              ADDS     r2,r4,r6
000058  9000              STR      r0,[sp,#0]
00005a  1e50              SUBS     r0,r2,#1
00005c  4622              MOV      r2,r4
00005e  f7fffffe          BL       RMP_Line
;;;3398       RMP_Line(Coord_X,Coord_Y+Width-1,Coord_X,Coord_Y,RMP_CTL_BLACK);
000062  2000              MOVS     r0,#0
000064  9000              STR      r0,[sp,#0]
000066  19e8              ADDS     r0,r5,r7
000068  1e41              SUBS     r1,r0,#1
00006a  462b              MOV      r3,r5
00006c  4622              MOV      r2,r4
00006e  4620              MOV      r0,r4
000070  f7fffffe          BL       RMP_Line
;;;3399   }
000074  e8bd9fff          POP      {r0-r12,pc}
;;;3400   #endif
                          ENDP


                          AREA ||i.RMP_Progbar_Prog||, CODE, READONLY, ALIGN=1

                  RMP_Progbar_Prog PROC
;;;3326   ******************************************************************************/
;;;3327   void RMP_Progbar_Prog(cnt_t Coord_X, cnt_t Coord_Y, cnt_t Length, cnt_t Width,
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;3328                         cnt_t Style, cnt_t Prog, ptr_t Fore, ptr_t Back)
;;;3329   {
000004  4682              MOV      r10,r0
000006  468b              MOV      r11,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
00000c  ad0d              ADD      r5,sp,#0x34
00000e  cde0              LDM      r5,{r5-r7}
;;;3330       /* The critical value for drawing the bar */
;;;3331       ptr_t Pivot;
;;;3332       
;;;3333       switch(Style)
000010  980c              LDR      r0,[sp,#0x30]
000012  b130              CBZ      r0,|L31.34|
000014  2801              CMP      r0,#1
000016  d01f              BEQ      |L31.88|
000018  2802              CMP      r0,#2
00001a  d039              BEQ      |L31.144|
00001c  2803              CMP      r0,#3
00001e  d16f              BNE      |L31.256|
000020  e052              B        |L31.200|
                  |L31.34|
;;;3334       {
;;;3335           case RMP_PBAR_L2R:
;;;3336           {
;;;3337               Pivot=Length*Prog/100;
000022  fb08f005          MUL      r0,r8,r5
000026  2164              MOVS     r1,#0x64
000028  fb90f4f1          SDIV     r4,r0,r1
;;;3338               if(Prog!=0)
00002c  b13d              CBZ      r5,|L31.62|
;;;3339                   RMP_Rectangle(Coord_X,Coord_Y,Pivot,Width,Fore,Fore);
00002e  9600              STR      r6,[sp,#0]
000030  464b              MOV      r3,r9
000032  4622              MOV      r2,r4
000034  4659              MOV      r1,r11
000036  4650              MOV      r0,r10
000038  9601              STR      r6,[sp,#4]
00003a  f7fffffe          BL       RMP_Rectangle
                  |L31.62|
;;;3340               if(Prog!=100)
00003e  2d64              CMP      r5,#0x64
000040  d009              BEQ      |L31.86|
;;;3341                   RMP_Rectangle(Coord_X+Pivot,Coord_Y,Length-Pivot,Width,Back,Back);
000042  9700              STR      r7,[sp,#0]
000044  eba80204          SUB      r2,r8,r4
000048  eb0a0004          ADD      r0,r10,r4
00004c  464b              MOV      r3,r9
00004e  4659              MOV      r1,r11
000050  9701              STR      r7,[sp,#4]
000052  f7fffffe          BL       RMP_Rectangle
                  |L31.86|
;;;3342               break;
000056  e054              B        |L31.258|
                  |L31.88|
;;;3343           }
;;;3344           case RMP_PBAR_D2U:
;;;3345           {
;;;3346               Pivot=Width*Prog/100;
000058  fb09f005          MUL      r0,r9,r5
00005c  2164              MOVS     r1,#0x64
00005e  fb90f4f1          SDIV     r4,r0,r1
;;;3347               if(Prog!=0)
000062  b14d              CBZ      r5,|L31.120|
;;;3348                   RMP_Rectangle(Coord_X,Coord_Y+Width-Pivot,Length,Pivot,Fore,Fore);
000064  9600              STR      r6,[sp,#0]
000066  eb0b0009          ADD      r0,r11,r9
00006a  1b01              SUBS     r1,r0,r4
00006c  4623              MOV      r3,r4
00006e  4642              MOV      r2,r8
000070  4650              MOV      r0,r10
000072  9601              STR      r6,[sp,#4]
000074  f7fffffe          BL       RMP_Rectangle
                  |L31.120|
;;;3349               if(Prog!=100)
000078  2d64              CMP      r5,#0x64
00007a  d008              BEQ      |L31.142|
;;;3350                   RMP_Rectangle(Coord_X,Coord_Y,Length,Width-Pivot,Back,Back);
00007c  9700              STR      r7,[sp,#0]
00007e  eba90304          SUB      r3,r9,r4
000082  4642              MOV      r2,r8
000084  4659              MOV      r1,r11
000086  4650              MOV      r0,r10
000088  9701              STR      r7,[sp,#4]
00008a  f7fffffe          BL       RMP_Rectangle
                  |L31.142|
;;;3351               break;
00008e  e038              B        |L31.258|
                  |L31.144|
;;;3352           }
;;;3353           case RMP_PBAR_R2L:
;;;3354           {
;;;3355               Pivot=Length*Prog/100;
000090  fb08f005          MUL      r0,r8,r5
000094  2164              MOVS     r1,#0x64
000096  fb90f4f1          SDIV     r4,r0,r1
;;;3356               if(Prog!=0)
00009a  b14d              CBZ      r5,|L31.176|
;;;3357                   RMP_Rectangle(Coord_X+Length-Pivot,Coord_Y,Pivot,Width,Fore,Fore);
00009c  9600              STR      r6,[sp,#0]
00009e  eb0a0108          ADD      r1,r10,r8
0000a2  1b08              SUBS     r0,r1,r4
0000a4  464b              MOV      r3,r9
0000a6  4622              MOV      r2,r4
0000a8  4659              MOV      r1,r11
0000aa  9601              STR      r6,[sp,#4]
0000ac  f7fffffe          BL       RMP_Rectangle
                  |L31.176|
;;;3358               if(Prog!=100)
0000b0  2d64              CMP      r5,#0x64
0000b2  d008              BEQ      |L31.198|
;;;3359                   RMP_Rectangle(Coord_X,Coord_Y,Length-Pivot,Width,Back,Back);
0000b4  9700              STR      r7,[sp,#0]
0000b6  eba80204          SUB      r2,r8,r4
0000ba  464b              MOV      r3,r9
0000bc  4659              MOV      r1,r11
0000be  4650              MOV      r0,r10
0000c0  9701              STR      r7,[sp,#4]
0000c2  f7fffffe          BL       RMP_Rectangle
                  |L31.198|
;;;3360               break;
0000c6  e01c              B        |L31.258|
                  |L31.200|
;;;3361           }
;;;3362           case RMP_PBAR_U2D:
;;;3363           {
;;;3364               Pivot=Width*Prog/100;
0000c8  fb09f005          MUL      r0,r9,r5
0000cc  2164              MOVS     r1,#0x64
0000ce  fb90f4f1          SDIV     r4,r0,r1
;;;3365               if(Prog!=0)
0000d2  b13d              CBZ      r5,|L31.228|
;;;3366                   RMP_Rectangle(Coord_X,Coord_Y,Length,Pivot,Fore,Fore);
0000d4  9600              STR      r6,[sp,#0]
0000d6  4623              MOV      r3,r4
0000d8  4642              MOV      r2,r8
0000da  4659              MOV      r1,r11
0000dc  4650              MOV      r0,r10
0000de  9601              STR      r6,[sp,#4]
0000e0  f7fffffe          BL       RMP_Rectangle
                  |L31.228|
;;;3367               if(Prog!=100)
0000e4  2d64              CMP      r5,#0x64
0000e6  d009              BEQ      |L31.252|
;;;3368                   RMP_Rectangle(Coord_X,Coord_Y+Pivot,Length,Width-Pivot,Back,Back);
0000e8  9700              STR      r7,[sp,#0]
0000ea  eba90304          SUB      r3,r9,r4
0000ee  eb0b0104          ADD      r1,r11,r4
0000f2  4642              MOV      r2,r8
0000f4  4650              MOV      r0,r10
0000f6  9701              STR      r7,[sp,#4]
0000f8  f7fffffe          BL       RMP_Rectangle
                  |L31.252|
;;;3369               break;
0000fc  e001              B        |L31.258|
0000fe  e7ff              B        |L31.256|
                  |L31.256|
;;;3370           }
;;;3371           default: break;
000100  bf00              NOP      
                  |L31.258|
000102  bf00              NOP                            ;3342
;;;3372       }
;;;3373   }
000104  e8bd9ffc          POP      {r2-r12,pc}
;;;3374   /* End Function:RMP_Progbar_Prog *********************************************/
                          ENDP


                          AREA ||i.RMP_Progbar_Set||, CODE, READONLY, ALIGN=1

                  RMP_Progbar_Set PROC
;;;3247   ******************************************************************************/
;;;3248   void RMP_Progbar_Set(cnt_t Coord_X, cnt_t Coord_Y, cnt_t Length, cnt_t Width,
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;3249                        cnt_t Style, cnt_t Old_Prog, cnt_t New_Prog, ptr_t Fore, ptr_t Back)
;;;3250   {
000004  4680              MOV      r8,r0
000006  4689              MOV      r9,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  e9ddab0f          LDRD     r10,r11,[sp,#0x3c]
;;;3251       /* The critical values for drawing the bar */
;;;3252       ptr_t Old_Pivot;
;;;3253       ptr_t New_Pivot;
;;;3254       
;;;3255       /* If things does not change, return to save time */
;;;3256       if(Old_Prog==New_Prog)
000010  e9dd010d          LDRD     r0,r1,[sp,#0x34]
000014  4288              CMP      r0,r1
000016  d101              BNE      |L32.28|
                  |L32.24|
;;;3257           return;
;;;3258       
;;;3259       switch(Style)
;;;3260       {
;;;3261           case RMP_PBAR_L2R:
;;;3262           {
;;;3263               Old_Pivot=(Length-2)*Old_Prog/100;
;;;3264               New_Pivot=(Length-2)*New_Prog/100;
;;;3265               /* Progress decreased */
;;;3266               if(Old_Pivot>New_Pivot)
;;;3267                   RMP_Rectangle(Coord_X+1+New_Pivot,Coord_Y+1,Old_Pivot-New_Pivot,Width-2,Back,Back);
;;;3268               /* Progress increased */
;;;3269               else
;;;3270                   RMP_Rectangle(Coord_X+1+Old_Pivot,Coord_Y+1,New_Pivot-Old_Pivot,Width-2,Fore,Fore);
;;;3271               break;
;;;3272           }
;;;3273           case RMP_PBAR_D2U:
;;;3274           {
;;;3275               Old_Pivot=(Width-2)*Old_Prog/100;
;;;3276               New_Pivot=(Width-2)*New_Prog/100;
;;;3277               /* Progress decreased */
;;;3278               if(Old_Pivot>New_Pivot)
;;;3279                   RMP_Rectangle(Coord_X+1,Coord_Y-1+Width-Old_Pivot,Length-2,Old_Pivot-New_Pivot,Back,Back);
;;;3280               /* Progress increased */
;;;3281               else
;;;3282                   RMP_Rectangle(Coord_X+1,Coord_Y-1+Width-New_Pivot,Length-2,New_Pivot-Old_Pivot,Fore,Fore);
;;;3283               break;
;;;3284           }
;;;3285           case RMP_PBAR_R2L:
;;;3286           {
;;;3287               Old_Pivot=(Length-2)*Old_Prog/100;
;;;3288               New_Pivot=(Length-2)*New_Prog/100;
;;;3289               /* Progress decreased */
;;;3290               if(Old_Pivot>New_Pivot)
;;;3291                   RMP_Rectangle(Coord_X-1+Length-Old_Pivot,Coord_Y+1,Old_Pivot-New_Pivot,Width-2,Back,Back);
;;;3292               /* Progress increased */
;;;3293               else
;;;3294                   RMP_Rectangle(Coord_X-1+Length-New_Pivot,Coord_Y+1,New_Pivot-Old_Pivot,Width-2,Fore,Fore);
;;;3295               break;
;;;3296           }
;;;3297           case RMP_PBAR_U2D:
;;;3298           {
;;;3299               Old_Pivot=(Width-2)*Old_Prog/100;
;;;3300               New_Pivot=(Width-2)*New_Prog/100;
;;;3301               /* Progress decreased */
;;;3302               if(Old_Pivot>New_Pivot)
;;;3303                   RMP_Rectangle(Coord_X+1,Coord_Y+1+New_Pivot,Length-2,Old_Pivot-New_Pivot,Back,Back);
;;;3304               /* Progress increased */
;;;3305               else
;;;3306                   RMP_Rectangle(Coord_X+1,Coord_Y+1+Old_Pivot,Length-2,New_Pivot-Old_Pivot,Fore,Fore);
;;;3307               break;
;;;3308           }
;;;3309           default: break;
;;;3310       }
;;;3311   }
000018  e8bd9ffc          POP      {r2-r12,pc}
                  |L32.28|
00001c  980c              LDR      r0,[sp,#0x30]         ;3259
00001e  b130              CBZ      r0,|L32.46|
000020  2801              CMP      r0,#1                 ;3259
000022  d02e              BEQ      |L32.130|
000024  2802              CMP      r0,#2                 ;3259
000026  d058              BEQ      |L32.218|
000028  2803              CMP      r0,#3                 ;3259
00002a  d173              BNE      |L32.276|
00002c  e082              B        |L32.308|
                  |L32.46|
00002e  1eb0              SUBS     r0,r6,#2              ;3263
000030  990d              LDR      r1,[sp,#0x34]         ;3263
000032  4348              MULS     r0,r1,r0              ;3263
000034  2164              MOVS     r1,#0x64              ;3263
000036  fb90f4f1          SDIV     r4,r0,r1              ;3263
00003a  1eb0              SUBS     r0,r6,#2              ;3264
00003c  990e              LDR      r1,[sp,#0x38]         ;3264
00003e  4348              MULS     r0,r1,r0              ;3264
000040  2164              MOVS     r1,#0x64              ;3264
000042  fb90f5f1          SDIV     r5,r0,r1              ;3264
000046  42ac              CMP      r4,r5                 ;3266
000048  d90d              BLS      |L32.102|
00004a  f8cdb000          STR      r11,[sp,#0]           ;3267
00004e  1ebb              SUBS     r3,r7,#2              ;3267
000050  1b62              SUBS     r2,r4,r5              ;3267
000052  f1080101          ADD      r1,r8,#1              ;3267
000056  1948              ADDS     r0,r1,r5              ;3267
000058  f1090101          ADD      r1,r9,#1              ;3267
00005c  f8cdb004          STR      r11,[sp,#4]           ;3267
000060  f7fffffe          BL       RMP_Rectangle
000064  e00c              B        |L32.128|
                  |L32.102|
000066  f8cda000          STR      r10,[sp,#0]           ;3270
00006a  1ebb              SUBS     r3,r7,#2              ;3270
00006c  1b2a              SUBS     r2,r5,r4              ;3270
00006e  f1080101          ADD      r1,r8,#1              ;3270
000072  1908              ADDS     r0,r1,r4              ;3270
000074  f1090101          ADD      r1,r9,#1              ;3270
000078  f8cda004          STR      r10,[sp,#4]           ;3270
00007c  f7fffffe          BL       RMP_Rectangle
                  |L32.128|
000080  e083              B        |L32.394|
                  |L32.130|
000082  1eb8              SUBS     r0,r7,#2              ;3275
000084  990d              LDR      r1,[sp,#0x34]         ;3275
000086  4348              MULS     r0,r1,r0              ;3275
000088  2164              MOVS     r1,#0x64              ;3275
00008a  fb90f4f1          SDIV     r4,r0,r1              ;3275
00008e  1eb8              SUBS     r0,r7,#2              ;3276
000090  990e              LDR      r1,[sp,#0x38]         ;3276
000092  4348              MULS     r0,r1,r0              ;3276
000094  2164              MOVS     r1,#0x64              ;3276
000096  fb90f5f1          SDIV     r5,r0,r1              ;3276
00009a  42ac              CMP      r4,r5                 ;3278
00009c  d90e              BLS      |L32.188|
00009e  f8cdb000          STR      r11,[sp,#0]           ;3279
0000a2  1b63              SUBS     r3,r4,r5              ;3279
0000a4  1eb2              SUBS     r2,r6,#2              ;3279
0000a6  f1a90001          SUB      r0,r9,#1              ;3279
0000aa  4438              ADD      r0,r0,r7              ;3279
0000ac  1b01              SUBS     r1,r0,r4              ;3279
0000ae  f1080001          ADD      r0,r8,#1              ;3279
0000b2  f8cdb004          STR      r11,[sp,#4]           ;3279
0000b6  f7fffffe          BL       RMP_Rectangle
0000ba  e00d              B        |L32.216|
                  |L32.188|
0000bc  f8cda000          STR      r10,[sp,#0]           ;3282
0000c0  1b2b              SUBS     r3,r5,r4              ;3282
0000c2  1eb2              SUBS     r2,r6,#2              ;3282
0000c4  f1a90001          SUB      r0,r9,#1              ;3282
0000c8  4438              ADD      r0,r0,r7              ;3282
0000ca  1b41              SUBS     r1,r0,r5              ;3282
0000cc  f1080001          ADD      r0,r8,#1              ;3282
0000d0  f8cda004          STR      r10,[sp,#4]           ;3282
0000d4  f7fffffe          BL       RMP_Rectangle
                  |L32.216|
0000d8  e057              B        |L32.394|
                  |L32.218|
0000da  1eb0              SUBS     r0,r6,#2              ;3287
0000dc  990d              LDR      r1,[sp,#0x34]         ;3287
0000de  4348              MULS     r0,r1,r0              ;3287
0000e0  2164              MOVS     r1,#0x64              ;3287
0000e2  fb90f4f1          SDIV     r4,r0,r1              ;3287
0000e6  1eb0              SUBS     r0,r6,#2              ;3288
0000e8  990e              LDR      r1,[sp,#0x38]         ;3288
0000ea  4348              MULS     r0,r1,r0              ;3288
0000ec  2164              MOVS     r1,#0x64              ;3288
0000ee  fb90f5f1          SDIV     r5,r0,r1              ;3288
0000f2  42ac              CMP      r4,r5                 ;3290
0000f4  d90f              BLS      |L32.278|
0000f6  f8cdb000          STR      r11,[sp,#0]           ;3291
0000fa  1ebb              SUBS     r3,r7,#2              ;3291
0000fc  1b62              SUBS     r2,r4,r5              ;3291
0000fe  f1a80101          SUB      r1,r8,#1              ;3291
000102  4431              ADD      r1,r1,r6              ;3291
000104  1b08              SUBS     r0,r1,r4              ;3291
000106  f1090101          ADD      r1,r9,#1              ;3291
00010a  f8cdb004          STR      r11,[sp,#4]           ;3291
00010e  f7fffffe          BL       RMP_Rectangle
000112  e00e              B        |L32.306|
                  |L32.276|
000114  e038              B        |L32.392|
                  |L32.278|
000116  f8cda000          STR      r10,[sp,#0]           ;3294
00011a  1ebb              SUBS     r3,r7,#2              ;3294
00011c  1b2a              SUBS     r2,r5,r4              ;3294
00011e  f1a80101          SUB      r1,r8,#1              ;3294
000122  4431              ADD      r1,r1,r6              ;3294
000124  1b48              SUBS     r0,r1,r5              ;3294
000126  f1090101          ADD      r1,r9,#1              ;3294
00012a  f8cda004          STR      r10,[sp,#4]           ;3294
00012e  f7fffffe          BL       RMP_Rectangle
                  |L32.306|
000132  e02a              B        |L32.394|
                  |L32.308|
000134  1eb8              SUBS     r0,r7,#2              ;3299
000136  990d              LDR      r1,[sp,#0x34]         ;3299
000138  4348              MULS     r0,r1,r0              ;3299
00013a  2164              MOVS     r1,#0x64              ;3299
00013c  fb90f4f1          SDIV     r4,r0,r1              ;3299
000140  1eb8              SUBS     r0,r7,#2              ;3300
000142  990e              LDR      r1,[sp,#0x38]         ;3300
000144  4348              MULS     r0,r1,r0              ;3300
000146  2164              MOVS     r1,#0x64              ;3300
000148  fb90f5f1          SDIV     r5,r0,r1              ;3300
00014c  42ac              CMP      r4,r5                 ;3302
00014e  d90d              BLS      |L32.364|
000150  f8cdb000          STR      r11,[sp,#0]           ;3303
000154  1b63              SUBS     r3,r4,r5              ;3303
000156  1eb2              SUBS     r2,r6,#2              ;3303
000158  f1090001          ADD      r0,r9,#1              ;3303
00015c  1941              ADDS     r1,r0,r5              ;3303
00015e  f1080001          ADD      r0,r8,#1              ;3303
000162  f8cdb004          STR      r11,[sp,#4]           ;3303
000166  f7fffffe          BL       RMP_Rectangle
00016a  e00c              B        |L32.390|
                  |L32.364|
00016c  f8cda000          STR      r10,[sp,#0]           ;3306
000170  1b2b              SUBS     r3,r5,r4              ;3306
000172  1eb2              SUBS     r2,r6,#2              ;3306
000174  f1090001          ADD      r0,r9,#1              ;3306
000178  1901              ADDS     r1,r0,r4              ;3306
00017a  f1080001          ADD      r0,r8,#1              ;3306
00017e  f8cda004          STR      r10,[sp,#4]           ;3306
000182  f7fffffe          BL       RMP_Rectangle
                  |L32.390|
000186  e000              B        |L32.394|
                  |L32.392|
000188  bf00              NOP                            ;3309
                  |L32.394|
00018a  bf00              NOP                            ;3271
00018c  bf00              NOP      
00018e  e743              B        |L32.24|
;;;3312   /* End Function:RMP_Progbar_Set **********************************************/
                          ENDP


                          AREA ||i.RMP_RBIT_Get||, CODE, READONLY, ALIGN=2

                  RMP_RBIT_Get PROC
;;;1694   
;;;1695   ptr_t RMP_RBIT_Get(ptr_t Val)
000000  b501              PUSH     {r0,lr}
;;;1696   {
000002  b081              SUB      sp,sp,#4
;;;1697       ptr_t Ret;
;;;1698       u8* To;
;;;1699       u8* From;
;;;1700       
;;;1701       To=(u8*)(&Ret);
000004  4669              MOV      r1,sp
;;;1702       From=(u8*)(&Val);
000006  aa01              ADD      r2,sp,#4
;;;1703       
;;;1704   #if(RMP_WORD_ORDER==4)
;;;1705       To[0]=RMP_RBIT_Table[From[1]];
;;;1706       To[1]=RMP_RBIT_Table[From[0]];
;;;1707   #elif(RMP_WORD_ORDER==5)
;;;1708       To[0]=RMP_RBIT_Table[From[3]];
000008  78d0              LDRB     r0,[r2,#3]
00000a  4b07              LDR      r3,|L33.40|
00000c  5c18              LDRB     r0,[r3,r0]
00000e  7008              STRB     r0,[r1,#0]
;;;1709       To[1]=RMP_RBIT_Table[From[2]];
000010  7890              LDRB     r0,[r2,#2]
000012  5c18              LDRB     r0,[r3,r0]
000014  7048              STRB     r0,[r1,#1]
;;;1710       To[2]=RMP_RBIT_Table[From[1]];
000016  7850              LDRB     r0,[r2,#1]
000018  5c18              LDRB     r0,[r3,r0]
00001a  7088              STRB     r0,[r1,#2]
;;;1711       To[3]=RMP_RBIT_Table[From[0]];
00001c  7810              LDRB     r0,[r2,#0]
00001e  5c18              LDRB     r0,[r3,r0]
000020  70c8              STRB     r0,[r1,#3]
;;;1712   #else
;;;1713       To[0]=RMP_RBIT_Table[From[7]];
;;;1714       To[1]=RMP_RBIT_Table[From[6]];
;;;1715       To[2]=RMP_RBIT_Table[From[5]];
;;;1716       To[3]=RMP_RBIT_Table[From[4]];
;;;1717       To[4]=RMP_RBIT_Table[From[3]];
;;;1718       To[5]=RMP_RBIT_Table[From[2]];
;;;1719       To[6]=RMP_RBIT_Table[From[1]];
;;;1720       To[7]=RMP_RBIT_Table[From[0]];
;;;1721   #endif
;;;1722   
;;;1723       return Ret;
000022  9800              LDR      r0,[sp,#0]
;;;1724   }
000024  bd0c              POP      {r2,r3,pc}
;;;1725   /* End Function:RMP_RBIT_Get *************************************************/
                          ENDP

000026  0000              DCW      0x0000
                  |L33.40|
                          DCD      RMP_RBIT_Table

                          AREA ||i.RMP_Radiobtn||, CODE, READONLY, ALIGN=1

                  RMP_Radiobtn PROC
;;;3219   ******************************************************************************/
;;;3220   void RMP_Radiobtn(cnt_t Coord_X, cnt_t Coord_Y, cnt_t Length, ptr_t Status)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;3221   {   
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
;;;3222       /* Fill the area with rect */
;;;3223       RMP_Rectangle(Coord_X,Coord_Y,Length,Length,RMP_CTL_GREY,RMP_CTL_GREY);
00000c  f64b50d7          MOV      r0,#0xbdd7
000010  9000              STR      r0,[sp,#0]
000012  4623              MOV      r3,r4
000014  4622              MOV      r2,r4
000016  4639              MOV      r1,r7
000018  9001              STR      r0,[sp,#4]
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       RMP_Rectangle
;;;3224       
;;;3225       /* Draw the circle first */
;;;3226       RMP_Radiobtn_Circle(Coord_X,Coord_Y,Length);
000020  4622              MOV      r2,r4
000022  4639              MOV      r1,r7
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       RMP_Radiobtn_Circle
;;;3227       
;;;3228       /* See if the radio button is selected */
;;;3229       if(Status==RMP_RBTN_SEL)
00002a  2d01              CMP      r5,#1
00002c  d104              BNE      |L34.56|
;;;3230           RMP_Radiobtn_Set(Coord_X, Coord_Y, Length);
00002e  4622              MOV      r2,r4
000030  4639              MOV      r1,r7
000032  4630              MOV      r0,r6
000034  f7fffffe          BL       RMP_Radiobtn_Set
                  |L34.56|
;;;3231   }
000038  e8bd81fc          POP      {r2-r8,pc}
;;;3232   /* End Function:RMP_Radiobtn *************************************************/
                          ENDP


                          AREA ||i.RMP_Radiobtn_Circle||, CODE, READONLY, ALIGN=1

                  RMP_Radiobtn_Circle PROC
;;;3104   ******************************************************************************/
;;;3105   void RMP_Radiobtn_Circle(cnt_t Coord_X,cnt_t Coord_Y,cnt_t Length)
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;3106   {   
000004  4682              MOV      r10,r0
000006  468b              MOV      r11,r1
;;;3107       cnt_t Radius;
;;;3108       cnt_t Center_X;
;;;3109       cnt_t Center_Y;
;;;3110       cnt_t Cur_X;
;;;3111       cnt_t Cur_Y;
;;;3112       cnt_t Error;
;;;3113       
;;;3114       /* The radius is the length/2 */
;;;3115       Radius=Length>>1;
000008  9802              LDR      r0,[sp,#8]
00000a  ea4f0860          ASR      r8,r0,#1
;;;3116       Center_X=Coord_X+Radius;
00000e  eb0a0608          ADD      r6,r10,r8
;;;3117       Center_Y=Coord_Y+Radius;
000012  eb0b0708          ADD      r7,r11,r8
;;;3118       
;;;3119       /* Now we begin to draw the inner halfcircle */
;;;3120       Cur_X=0;
000016  2400              MOVS     r4,#0
;;;3121       Cur_Y=Radius-1;
000018  f1a80501          SUB      r5,r8,#1
;;;3122       Error=3-((Radius-1)<<1);  
00001c  4628              MOV      r0,r5
00001e  2103              MOVS     r1,#3
000020  eba10940          SUB      r9,r1,r0,LSL #1
;;;3123       
;;;3124       while(Cur_X<=Cur_Y) 
000024  e03c              B        |L35.160|
                  |L35.38|
;;;3125       {  
;;;3126           /* This is the upper-left part */
;;;3127           RMP_POINT(Center_X+Cur_X,Center_Y-Cur_Y,RMP_CTL_DDARK);
000026  1b79              SUBS     r1,r7,r5
000028  1930              ADDS     r0,r6,r4
00002a  f646324d          MOV      r2,#0x6b4d
00002e  f7fffffe          BL       RMP_Point
;;;3128           RMP_POINT(Center_X-Cur_X,Center_Y-Cur_Y,RMP_CTL_DDARK);
000032  1b79              SUBS     r1,r7,r5
000034  1b30              SUBS     r0,r6,r4
000036  f646324d          MOV      r2,#0x6b4d
00003a  f7fffffe          BL       RMP_Point
;;;3129           RMP_POINT(Center_X-Cur_Y,Center_Y-Cur_X,RMP_CTL_DDARK);
00003e  1b39              SUBS     r1,r7,r4
000040  1b70              SUBS     r0,r6,r5
000042  f646324d          MOV      r2,#0x6b4d
000046  f7fffffe          BL       RMP_Point
;;;3130           RMP_POINT(Center_X-Cur_Y,Center_Y+Cur_X,RMP_CTL_DDARK);
00004a  1939              ADDS     r1,r7,r4
00004c  1b70              SUBS     r0,r6,r5
00004e  f646324d          MOV      r2,#0x6b4d
000052  f7fffffe          BL       RMP_Point
;;;3131           
;;;3132           /* This is the lower-right part */
;;;3133           RMP_POINT(Center_X+Cur_X,Center_Y+Cur_Y,RMP_CTL_LGREY);
000056  1979              ADDS     r1,r7,r5
000058  1930              ADDS     r0,r6,r4
00005a  f24e721c          MOV      r2,#0xe71c
00005e  f7fffffe          BL       RMP_Point
;;;3134           RMP_POINT(Center_X-Cur_X,Center_Y+Cur_Y,RMP_CTL_LGREY);  
000062  1979              ADDS     r1,r7,r5
000064  1b30              SUBS     r0,r6,r4
000066  f24e721c          MOV      r2,#0xe71c
00006a  f7fffffe          BL       RMP_Point
;;;3135           RMP_POINT(Center_X+Cur_Y,Center_Y+Cur_X,RMP_CTL_LGREY); 
00006e  1939              ADDS     r1,r7,r4
000070  1970              ADDS     r0,r6,r5
000072  f24e721c          MOV      r2,#0xe71c
000076  f7fffffe          BL       RMP_Point
;;;3136           RMP_POINT(Center_X+Cur_Y,Center_Y-Cur_X,RMP_CTL_LGREY);  
00007a  1b39              SUBS     r1,r7,r4
00007c  1970              ADDS     r0,r6,r5
00007e  f24e721c          MOV      r2,#0xe71c
000082  f7fffffe          BL       RMP_Point
;;;3137           
;;;3138           if(Error<0) 
000086  f1b90f00          CMP      r9,#0
00008a  da04              BGE      |L35.150|
;;;3139           {
;;;3140               Error=Error+(Cur_X<<2)+6;
00008c  eb090084          ADD      r0,r9,r4,LSL #2
000090  f1000906          ADD      r9,r0,#6
000094  e003              B        |L35.158|
                  |L35.150|
;;;3141           }
;;;3142           else 
;;;3143           {
;;;3144               Error=Error+((Cur_X-Cur_Y)<<2);
000096  1b60              SUBS     r0,r4,r5
000098  eb090980          ADD      r9,r9,r0,LSL #2
;;;3145               Cur_Y--;
00009c  1e6d              SUBS     r5,r5,#1
                  |L35.158|
;;;3146           }
;;;3147           Cur_X++;
00009e  1c64              ADDS     r4,r4,#1
                  |L35.160|
0000a0  42ac              CMP      r4,r5                 ;3124
0000a2  ddc0              BLE      |L35.38|
;;;3148       } 
;;;3149       
;;;3150       /* Now we begin to draw the outer halfcircle */
;;;3151       Cur_X=0;
0000a4  2400              MOVS     r4,#0
;;;3152       Cur_Y=Radius;
0000a6  4645              MOV      r5,r8
;;;3153       Error=3-(Radius<<1);  
0000a8  2003              MOVS     r0,#3
0000aa  eba00948          SUB      r9,r0,r8,LSL #1
;;;3154       
;;;3155       while(Cur_X<=Cur_Y) 
0000ae  e03c              B        |L35.298|
                  |L35.176|
;;;3156       {  
;;;3157           /* This is the upper-left part */
;;;3158           RMP_POINT(Center_X+Cur_X,Center_Y-Cur_Y,RMP_CTL_DGREY);
0000b0  1b79              SUBS     r1,r7,r5
0000b2  1930              ADDS     r0,r6,r4
0000b4  f24a5214          MOV      r2,#0xa514
0000b8  f7fffffe          BL       RMP_Point
;;;3159           RMP_POINT(Center_X-Cur_X,Center_Y-Cur_Y,RMP_CTL_DGREY);
0000bc  1b79              SUBS     r1,r7,r5
0000be  1b30              SUBS     r0,r6,r4
0000c0  f24a5214          MOV      r2,#0xa514
0000c4  f7fffffe          BL       RMP_Point
;;;3160           RMP_POINT(Center_X-Cur_Y,Center_Y-Cur_X,RMP_CTL_DGREY);
0000c8  1b39              SUBS     r1,r7,r4
0000ca  1b70              SUBS     r0,r6,r5
0000cc  f24a5214          MOV      r2,#0xa514
0000d0  f7fffffe          BL       RMP_Point
;;;3161           RMP_POINT(Center_X-Cur_Y,Center_Y+Cur_X,RMP_CTL_DGREY);
0000d4  1939              ADDS     r1,r7,r4
0000d6  1b70              SUBS     r0,r6,r5
0000d8  f24a5214          MOV      r2,#0xa514
0000dc  f7fffffe          BL       RMP_Point
;;;3162           
;;;3163           /* This is the lower-right part */
;;;3164           RMP_POINT(Center_X+Cur_X,Center_Y+Cur_Y,RMP_CTL_WHITE);
0000e0  1979              ADDS     r1,r7,r5
0000e2  1930              ADDS     r0,r6,r4
0000e4  f64f72ff          MOV      r2,#0xffff
0000e8  f7fffffe          BL       RMP_Point
;;;3165           RMP_POINT(Center_X-Cur_X,Center_Y+Cur_Y,RMP_CTL_WHITE);  
0000ec  1979              ADDS     r1,r7,r5
0000ee  1b30              SUBS     r0,r6,r4
0000f0  f64f72ff          MOV      r2,#0xffff
0000f4  f7fffffe          BL       RMP_Point
;;;3166           RMP_POINT(Center_X+Cur_Y,Center_Y+Cur_X,RMP_CTL_WHITE); 
0000f8  1939              ADDS     r1,r7,r4
0000fa  1970              ADDS     r0,r6,r5
0000fc  f64f72ff          MOV      r2,#0xffff
000100  f7fffffe          BL       RMP_Point
;;;3167           RMP_POINT(Center_X+Cur_Y,Center_Y-Cur_X,RMP_CTL_WHITE);  
000104  1b39              SUBS     r1,r7,r4
000106  1970              ADDS     r0,r6,r5
000108  f64f72ff          MOV      r2,#0xffff
00010c  f7fffffe          BL       RMP_Point
;;;3168           
;;;3169           if(Error<0) 
000110  f1b90f00          CMP      r9,#0
000114  da04              BGE      |L35.288|
;;;3170           {  
;;;3171               Error=Error+(Cur_X<<2)+6;  
000116  eb090084          ADD      r0,r9,r4,LSL #2
00011a  f1000906          ADD      r9,r0,#6
00011e  e003              B        |L35.296|
                  |L35.288|
;;;3172           } 
;;;3173           else 
;;;3174           {  
;;;3175               Error=Error+((Cur_X-Cur_Y)<<2);  
000120  1b60              SUBS     r0,r4,r5
000122  eb090980          ADD      r9,r9,r0,LSL #2
;;;3176               Cur_Y--;  
000126  1e6d              SUBS     r5,r5,#1
                  |L35.296|
;;;3177           }  
;;;3178           Cur_X++;  
000128  1c64              ADDS     r4,r4,#1
                  |L35.298|
00012a  42ac              CMP      r4,r5                 ;3155
00012c  ddc0              BLE      |L35.176|
;;;3179       } 
;;;3180   }
00012e  e8bd8ffe          POP      {r1-r11,pc}
;;;3181   /* End Function:RMP_Radiobtn_Circle ******************************************/
                          ENDP


                          AREA ||i.RMP_Radiobtn_Clr||, CODE, READONLY, ALIGN=1

                  RMP_Radiobtn_Clr PROC
;;;3204   ******************************************************************************/
;;;3205   void RMP_Radiobtn_Clr(cnt_t Coord_X, cnt_t Coord_Y, cnt_t Length)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;3206   {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
;;;3207       RMP_Circle(Coord_X+Length/2,Coord_Y+Length/2,Length/6,RMP_CTL_GREY,RMP_CTL_GREY);
00000a  2006              MOVS     r0,#6
00000c  fb94f9f0          SDIV     r9,r4,r0
000010  f64b50d7          MOV      r0,#0xbdd7
000014  4625              MOV      r5,r4
000016  eb0472d5          ADD      r2,r4,r5,LSR #31
00001a  eb070162          ADD      r1,r7,r2,ASR #1
00001e  46a0              MOV      r8,r4
000020  eb0472d8          ADD      r2,r4,r8,LSR #31
000024  9000              STR      r0,[sp,#0]
000026  eb060062          ADD      r0,r6,r2,ASR #1
00002a  f64b53d7          MOV      r3,#0xbdd7
00002e  464a              MOV      r2,r9
000030  f7fffffe          BL       RMP_Circle
;;;3208   }
000034  e8bd83f8          POP      {r3-r9,pc}
;;;3209   /* End Function:RMP_Radiobtn_Clr *********************************************/
                          ENDP


                          AREA ||i.RMP_Radiobtn_Set||, CODE, READONLY, ALIGN=1

                  RMP_Radiobtn_Set PROC
;;;3190   ******************************************************************************/
;;;3191   void RMP_Radiobtn_Set(cnt_t Coord_X, cnt_t Coord_Y, cnt_t Length)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;3192   {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
;;;3193       RMP_Circle(Coord_X+Length/2,Coord_Y+Length/2,Length/6,RMP_CTL_BLACK,RMP_CTL_BLACK);
00000a  2006              MOVS     r0,#6
00000c  fb94f9f0          SDIV     r9,r4,r0
000010  2000              MOVS     r0,#0
000012  4625              MOV      r5,r4
000014  eb0472d5          ADD      r2,r4,r5,LSR #31
000018  eb070162          ADD      r1,r7,r2,ASR #1
00001c  46a0              MOV      r8,r4
00001e  eb0472d8          ADD      r2,r4,r8,LSR #31
000022  9000              STR      r0,[sp,#0]
000024  eb060062          ADD      r0,r6,r2,ASR #1
000028  2300              MOVS     r3,#0
00002a  464a              MOV      r2,r9
00002c  f7fffffe          BL       RMP_Circle
;;;3194   }
000030  e8bd83f8          POP      {r3-r9,pc}
;;;3195   /* End Function:RMP_Radiobtn_Set *********************************************/
                          ENDP


                          AREA ||i.RMP_Rectangle||, CODE, READONLY, ALIGN=1

                  RMP_Rectangle PROC
;;;2348   ******************************************************************************/
;;;2349   void RMP_Rectangle(cnt_t Coord_X, cnt_t Coord_Y, cnt_t Length, cnt_t Width, ptr_t Border, ptr_t Fill)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;2350   {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  e9dd8a0a          LDRD     r8,r10,[sp,#0x28]
;;;2351       cnt_t Line_Cnt;
;;;2352       
;;;2353       if(Fill!=RMP_TRANS)
000010  f1ba0f01          CMP      r10,#1
000014  d011              BEQ      |L38.58|
;;;2354       {
;;;2355           for(Line_Cnt=0;Line_Cnt<Width;Line_Cnt++)
000016  f04f0900          MOV      r9,#0
00001a  e00c              B        |L38.54|
                  |L38.28|
;;;2356               RMP_Line(Coord_X,Coord_Y+Line_Cnt,Coord_X+Length-1,Coord_Y+Line_Cnt,Fill);
00001c  eb040309          ADD      r3,r4,r9
000020  19a8              ADDS     r0,r5,r6
000022  1e42              SUBS     r2,r0,#1
000024  eb040109          ADD      r1,r4,r9
000028  4628              MOV      r0,r5
00002a  f8cda000          STR      r10,[sp,#0]
00002e  f7fffffe          BL       RMP_Line
000032  f1090901          ADD      r9,r9,#1              ;2355
                  |L38.54|
000036  45b9              CMP      r9,r7                 ;2355
000038  dbf0              BLT      |L38.28|
                  |L38.58|
;;;2357       }
;;;2358   
;;;2359       if(Border!=RMP_TRANS)
00003a  f1b80f01          CMP      r8,#1
00003e  d027              BEQ      |L38.144|
;;;2360       {
;;;2361           RMP_Line(Coord_X,Coord_Y,Coord_X+Length-1,Coord_Y,Border);
000040  19a8              ADDS     r0,r5,r6
000042  1e42              SUBS     r2,r0,#1
000044  4623              MOV      r3,r4
000046  4621              MOV      r1,r4
000048  4628              MOV      r0,r5
00004a  f8cd8000          STR      r8,[sp,#0]
00004e  f7fffffe          BL       RMP_Line
;;;2362           RMP_Line(Coord_X+Length-1,Coord_Y,Coord_X+Length-1,Coord_Y+Width-1,Border);
000052  19e1              ADDS     r1,r4,r7
000054  1e4b              SUBS     r3,r1,#1
000056  19a9              ADDS     r1,r5,r6
000058  1e4a              SUBS     r2,r1,#1
00005a  19a9              ADDS     r1,r5,r6
00005c  1e48              SUBS     r0,r1,#1
00005e  4621              MOV      r1,r4
000060  f8cd8000          STR      r8,[sp,#0]
000064  f7fffffe          BL       RMP_Line
;;;2363           RMP_Line(Coord_X+Length-1,Coord_Y+Width-1,Coord_X,Coord_Y+Width-1,Border);
000068  19e2              ADDS     r2,r4,r7
00006a  1e53              SUBS     r3,r2,#1
00006c  19e2              ADDS     r2,r4,r7
00006e  1e51              SUBS     r1,r2,#1
000070  19aa              ADDS     r2,r5,r6
000072  1e50              SUBS     r0,r2,#1
000074  462a              MOV      r2,r5
000076  f8cd8000          STR      r8,[sp,#0]
00007a  f7fffffe          BL       RMP_Line
;;;2364           RMP_Line(Coord_X,Coord_Y+Width-1,Coord_X,Coord_Y,Border);
00007e  19e0              ADDS     r0,r4,r7
000080  1e41              SUBS     r1,r0,#1
000082  4623              MOV      r3,r4
000084  462a              MOV      r2,r5
000086  4628              MOV      r0,r5
000088  f8cd8000          STR      r8,[sp,#0]
00008c  f7fffffe          BL       RMP_Line
                  |L38.144|
;;;2365       }
;;;2366   }
000090  e8bd8ff8          POP      {r3-r11,pc}
;;;2367   /* End Function:RMP_Rectangle ************************************************/
                          ENDP


                          AREA ||i.RMP_Round_Rect||, CODE, READONLY, ALIGN=1

                  RMP_Round_Rect PROC
;;;2380   ******************************************************************************/
;;;2381   void RMP_Round_Rect(cnt_t Coord_X, cnt_t Coord_Y, cnt_t Length, cnt_t Width, 
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;2382                       cnt_t Round, ptr_t Fore, ptr_t Back)
;;;2383   {
000004  b085              SUB      sp,sp,#0x14
000006  4607              MOV      r7,r0
000008  4688              MOV      r8,r1
00000a  4693              MOV      r11,r2
00000c  e9dd6513          LDRD     r6,r5,[sp,#0x4c]
000010  9c12              LDR      r4,[sp,#0x48]
;;;2384       cnt_t Cir_X_0;
;;;2385       cnt_t Cir_X_1;
;;;2386       cnt_t Cir_Y_0;
;;;2387       cnt_t Cir_Y_1;
;;;2388       
;;;2389       Cir_X_0=Coord_X+Round+1;
000012  1938              ADDS     r0,r7,r4
000014  f1000901          ADD      r9,r0,#1
;;;2390       Cir_X_1=Coord_X+Length-Round-1;
000018  eb07000b          ADD      r0,r7,r11
00001c  1b00              SUBS     r0,r0,r4
00001e  1e40              SUBS     r0,r0,#1
000020  9004              STR      r0,[sp,#0x10]
;;;2391       Cir_Y_0=Coord_Y+Round+1;
000022  eb080004          ADD      r0,r8,r4
000026  f1000a01          ADD      r10,r0,#1
;;;2392       Cir_Y_1=Coord_Y+Width-Round-1;
00002a  9808              LDR      r0,[sp,#0x20]
00002c  4440              ADD      r0,r0,r8
00002e  1b00              SUBS     r0,r0,r4
000030  1e40              SUBS     r0,r0,#1
000032  9003              STR      r0,[sp,#0xc]
;;;2393       
;;;2394       RMP_Rectangle(Coord_X,Coord_Y,Length,Width,Fore,Fore);
000034  9600              STR      r6,[sp,#0]
000036  9601              STR      r6,[sp,#4]
000038  465a              MOV      r2,r11
00003a  4641              MOV      r1,r8
00003c  4638              MOV      r0,r7
00003e  9b08              LDR      r3,[sp,#0x20]
000040  f7fffffe          BL       RMP_Rectangle
;;;2395       
;;;2396       RMP_Rectangle(Cir_X_0-Round-1,Cir_Y_0-Round-1,Round+1,Round+1,Back,Back);
000044  9500              STR      r5,[sp,#0]
000046  ebaa0204          SUB      r2,r10,r4
00004a  1e51              SUBS     r1,r2,#1
00004c  eba90204          SUB      r2,r9,r4
000050  1e50              SUBS     r0,r2,#1
000052  1c63              ADDS     r3,r4,#1
000054  1c62              ADDS     r2,r4,#1
000056  9501              STR      r5,[sp,#4]
000058  f7fffffe          BL       RMP_Rectangle
;;;2397       RMP_Rectangle(Cir_X_1,Cir_Y_0-Round-1,Round+1,Round+1,Back,Back);
00005c  9500              STR      r5,[sp,#0]
00005e  ebaa0004          SUB      r0,r10,r4
000062  1e41              SUBS     r1,r0,#1
000064  1c63              ADDS     r3,r4,#1
000066  1c62              ADDS     r2,r4,#1
000068  9501              STR      r5,[sp,#4]
00006a  9804              LDR      r0,[sp,#0x10]
00006c  f7fffffe          BL       RMP_Rectangle
;;;2398       RMP_Rectangle(Cir_X_0-Round-1,Cir_Y_1,Round+1,Round+1,Back,Back);
000070  9500              STR      r5,[sp,#0]
000072  eba90104          SUB      r1,r9,r4
000076  1e48              SUBS     r0,r1,#1
000078  1c63              ADDS     r3,r4,#1
00007a  1c62              ADDS     r2,r4,#1
00007c  9501              STR      r5,[sp,#4]
00007e  9903              LDR      r1,[sp,#0xc]
000080  f7fffffe          BL       RMP_Rectangle
;;;2399       RMP_Rectangle(Cir_X_1,Cir_Y_1,Round+1,Round+1,Back,Back);
000084  9500              STR      r5,[sp,#0]
000086  1c63              ADDS     r3,r4,#1
000088  1c62              ADDS     r2,r4,#1
00008a  9501              STR      r5,[sp,#4]
00008c  e9dd1003          LDRD     r1,r0,[sp,#0xc]
000090  f7fffffe          BL       RMP_Rectangle
;;;2400       
;;;2401       RMP_Circle(Cir_X_0,Cir_Y_0,Round,Fore,Fore);
000094  4633              MOV      r3,r6
000096  4622              MOV      r2,r4
000098  4651              MOV      r1,r10
00009a  4648              MOV      r0,r9
00009c  9600              STR      r6,[sp,#0]
00009e  f7fffffe          BL       RMP_Circle
;;;2402       RMP_Circle(Cir_X_1,Cir_Y_0,Round,Fore,Fore);
0000a2  4633              MOV      r3,r6
0000a4  4622              MOV      r2,r4
0000a6  4651              MOV      r1,r10
0000a8  9600              STR      r6,[sp,#0]
0000aa  9804              LDR      r0,[sp,#0x10]
0000ac  f7fffffe          BL       RMP_Circle
;;;2403       RMP_Circle(Cir_X_0,Cir_Y_1,Round,Fore,Fore);
0000b0  4633              MOV      r3,r6
0000b2  4622              MOV      r2,r4
0000b4  9600              STR      r6,[sp,#0]
0000b6  4648              MOV      r0,r9
0000b8  9903              LDR      r1,[sp,#0xc]
0000ba  f7fffffe          BL       RMP_Circle
;;;2404       RMP_Circle(Cir_X_1,Cir_Y_1,Round,Fore,Fore);
0000be  4633              MOV      r3,r6
0000c0  4622              MOV      r2,r4
0000c2  9600              STR      r6,[sp,#0]
0000c4  e9dd1003          LDRD     r1,r0,[sp,#0xc]
0000c8  f7fffffe          BL       RMP_Circle
;;;2405   }
0000cc  b009              ADD      sp,sp,#0x24
0000ce  e8bd8ff0          POP      {r4-r11,pc}
;;;2406   /* End Function:RMP_Round_Rect ***********************************************/
                          ENDP


                          AREA ||i.RMP_Save_Ctx||, CODE, READONLY, ALIGN=1

                  RMP_Save_Ctx PROC
;;;1546   #if(RMP_USE_HOOKS==RMP_FALSE)
;;;1547   void RMP_Save_Ctx(void)
000000  4770              BX       lr
;;;1548   {
;;;1549       return;
;;;1550   }
;;;1551   #endif
                          ENDP


                          AREA ||i.RMP_Sem_Abort||, CODE, READONLY, ALIGN=1

                  RMP_Sem_Abort PROC
;;;1374   ******************************************************************************/
;;;1375   ret_t RMP_Sem_Abort(volatile struct RMP_Thd* Thread)
000000  b510              PUSH     {r4,lr}
;;;1376   {
000002  4604              MOV      r4,r0
;;;1377       /* Check if this thread structure could possibly be in use */
;;;1378       if(Thread==0)
000004  b914              CBNZ     r4,|L41.12|
;;;1379           return RMP_ERR_THD;
000006  f04f30ff          MOV      r0,#0xffffffff
                  |L41.10|
;;;1380   
;;;1381       RMP_Lock_Sched();
;;;1382       
;;;1383       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;1384       {
;;;1385           RMP_Unlock_Sched();
;;;1386           return RMP_ERR_THD;
;;;1387       }
;;;1388       
;;;1389       /* Is it waiting on a semaphore? If no, we abort and return an error code */
;;;1390       if((RMP_THD_STATE(Thread->State)!=RMP_THD_SEMBLK)&&
;;;1391          (RMP_THD_STATE(Thread->State)!=RMP_THD_SEMDLY))
;;;1392       {
;;;1393           RMP_Unlock_Sched();
;;;1394           return RMP_ERR_STATE;
;;;1395       }
;;;1396   
;;;1397       /* Waiting for a semaphore. We abort it and return */
;;;1398       RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1399       if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1400           RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1401       
;;;1402       RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1403   
;;;1404       /* Only when when this thread is not suspended do we change it back */
;;;1405       if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;1406           _RMP_Set_Rdy(Thread);
;;;1407       
;;;1408       Thread->Retval=RMP_ERR_OPER;
;;;1409       
;;;1410       RMP_Unlock_Sched();
;;;1411   
;;;1412       return 0;
;;;1413   }
00000a  bd10              POP      {r4,pc}
                  |L41.12|
00000c  f7fffffe          BL       RMP_Lock_Sched
000010  69a0              LDR      r0,[r4,#0x18]         ;1383
000012  b2c0              UXTB     r0,r0                 ;1383
000014  b920              CBNZ     r0,|L41.32|
000016  f7fffffe          BL       RMP_Unlock_Sched
00001a  f04f30ff          MOV      r0,#0xffffffff        ;1386
00001e  e7f4              B        |L41.10|
                  |L41.32|
000020  69a0              LDR      r0,[r4,#0x18]         ;1390
000022  b2c0              UXTB     r0,r0                 ;1390
000024  2807              CMP      r0,#7                 ;1390
000026  d008              BEQ      |L41.58|
000028  69a0              LDR      r0,[r4,#0x18]         ;1391
00002a  b2c0              UXTB     r0,r0                 ;1391
00002c  2808              CMP      r0,#8                 ;1391
00002e  d004              BEQ      |L41.58|
000030  f7fffffe          BL       RMP_Unlock_Sched
000034  f06f0003          MVN      r0,#3                 ;1394
000038  e7e7              B        |L41.10|
                  |L41.58|
00003a  6861              LDR      r1,[r4,#4]            ;1398
00003c  6820              LDR      r0,[r4,#0]            ;1398
00003e  f7fffffe          BL       RMP_List_Del
000042  69a0              LDR      r0,[r4,#0x18]         ;1399
000044  b2c0              UXTB     r0,r0                 ;1399
000046  2808              CMP      r0,#8                 ;1399
000048  d103              BNE      |L41.82|
00004a  68e1              LDR      r1,[r4,#0xc]          ;1400
00004c  68a0              LDR      r0,[r4,#8]            ;1400
00004e  f7fffffe          BL       RMP_List_Del
                  |L41.82|
000052  69a0              LDR      r0,[r4,#0x18]         ;1402
000054  f02000ff          BIC      r0,r0,#0xff           ;1402
000058  1c40              ADDS     r0,r0,#1              ;1402
00005a  61a0              STR      r0,[r4,#0x18]         ;1402
00005c  69a0              LDR      r0,[r4,#0x18]         ;1405
00005e  f4007080          AND      r0,r0,#0x100          ;1405
000062  b910              CBNZ     r0,|L41.106|
000064  4620              MOV      r0,r4                 ;1406
000066  f7fffffe          BL       _RMP_Set_Rdy
                  |L41.106|
00006a  f06f0004          MVN      r0,#4                 ;1408
00006e  63a0              STR      r0,[r4,#0x38]         ;1408
000070  f7fffffe          BL       RMP_Unlock_Sched
000074  2000              MOVS     r0,#0                 ;1412
000076  e7c8              B        |L41.10|
;;;1414   /* End Function:RMP_Sem_Abort ************************************************/
                          ENDP


                          AREA ||i.RMP_Sem_Crt||, CODE, READONLY, ALIGN=1

                  RMP_Sem_Crt PROC
;;;1232   ******************************************************************************/
;;;1233   ret_t RMP_Sem_Crt(volatile struct RMP_Sem* Semaphore, ptr_t Number)
000000  b570              PUSH     {r4-r6,lr}
;;;1234   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1235       /* Check if this semaphore structure could possibly be in use */
;;;1236       if(Semaphore==0)
000006  b914              CBNZ     r4,|L42.14|
;;;1237           return RMP_ERR_SEM;
000008  f06f0005          MVN      r0,#5
                  |L42.12|
;;;1238       
;;;1239       RMP_Lock_Sched();
;;;1240       
;;;1241       if(Semaphore->State!=RMP_SEM_FREE)
;;;1242       {
;;;1243           RMP_Unlock_Sched();
;;;1244           return RMP_ERR_SEM;
;;;1245       }
;;;1246       
;;;1247       /* Is the number too great to initialize? */
;;;1248       if(Number>=RMP_SEM_MAX_NUM)
;;;1249       {
;;;1250           RMP_Unlock_Sched();
;;;1251           return RMP_ERR_OPER;
;;;1252       }
;;;1253   
;;;1254       /* Initialize contents */
;;;1255       Semaphore->Cur_Num=Number;
;;;1256       Semaphore->State=RMP_SEM_USED;
;;;1257       RMP_List_Crt(&(Semaphore->Wait_List));
;;;1258       
;;;1259       RMP_Unlock_Sched();
;;;1260       
;;;1261       return 0;
;;;1262   }
00000c  bd70              POP      {r4-r6,pc}
                  |L42.14|
00000e  f7fffffe          BL       RMP_Lock_Sched
000012  68a0              LDR      r0,[r4,#8]            ;1241
000014  b120              CBZ      r0,|L42.32|
000016  f7fffffe          BL       RMP_Unlock_Sched
00001a  f06f0005          MVN      r0,#5                 ;1244
00001e  e7f5              B        |L42.12|
                  |L42.32|
000020  f5b57f7a          CMP      r5,#0x3e8             ;1248
000024  d304              BCC      |L42.48|
000026  f7fffffe          BL       RMP_Unlock_Sched
00002a  f06f0004          MVN      r0,#4                 ;1251
00002e  e7ed              B        |L42.12|
                  |L42.48|
000030  60e5              STR      r5,[r4,#0xc]          ;1255
000032  2001              MOVS     r0,#1                 ;1256
000034  60a0              STR      r0,[r4,#8]            ;1256
000036  4620              MOV      r0,r4                 ;1257
000038  f7fffffe          BL       RMP_List_Crt
00003c  f7fffffe          BL       RMP_Unlock_Sched
000040  2000              MOVS     r0,#0                 ;1261
000042  e7e3              B        |L42.12|
;;;1263   /* End Function:RMP_Sem_Crt **************************************************/
                          ENDP


                          AREA ||i.RMP_Sem_Del||, CODE, READONLY, ALIGN=1

                  RMP_Sem_Del PROC
;;;1270   ******************************************************************************/
;;;1271   ret_t RMP_Sem_Del(volatile struct RMP_Sem* Semaphore)
000000  b570              PUSH     {r4-r6,lr}
;;;1272   {
000002  4605              MOV      r5,r0
;;;1273       struct RMP_Thd* Thread;
;;;1274       
;;;1275       /* Check if this semaphore structure could possibly be in use */
;;;1276       if(Semaphore==0)
000004  b915              CBNZ     r5,|L43.12|
;;;1277           return RMP_ERR_SEM;
000006  f06f0005          MVN      r0,#5
                  |L43.10|
;;;1278       
;;;1279       RMP_Lock_Sched();
;;;1280       
;;;1281       if(Semaphore->State!=RMP_SEM_USED)
;;;1282       {
;;;1283           RMP_Unlock_Sched();
;;;1284           return RMP_ERR_SEM;
;;;1285       }
;;;1286   
;;;1287       /* Get rid of all guys waiting on it */
;;;1288       while(&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)
;;;1289       {
;;;1290           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
;;;1291           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1292           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1293               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1294   
;;;1295           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1296   
;;;1297           /* Is it suspended? If yes, we can't directly send it running */
;;;1298           if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;1299              _RMP_Set_Rdy(Thread);
;;;1300           
;;;1301           Thread->Retval=RMP_ERR_OPER;
;;;1302       }
;;;1303       Semaphore->State=RMP_SEM_FREE;
;;;1304       
;;;1305       RMP_Unlock_Sched();
;;;1306   
;;;1307       return 0;
;;;1308   }
00000a  bd70              POP      {r4-r6,pc}
                  |L43.12|
00000c  f7fffffe          BL       RMP_Lock_Sched
000010  68a8              LDR      r0,[r5,#8]            ;1281
000012  2801              CMP      r0,#1                 ;1281
000014  d004              BEQ      |L43.32|
000016  f7fffffe          BL       RMP_Unlock_Sched
00001a  f06f0005          MVN      r0,#5                 ;1284
00001e  e7f4              B        |L43.10|
                  |L43.32|
000020  e01a              B        |L43.88|
                  |L43.34|
000022  686c              LDR      r4,[r5,#4]            ;1290
000024  e9d40100          LDRD     r0,r1,[r4,#0]         ;1291
000028  f7fffffe          BL       RMP_List_Del
00002c  7e20              LDRB     r0,[r4,#0x18]         ;1292
00002e  2808              CMP      r0,#8                 ;1292
000030  d103              BNE      |L43.58|
000032  e9d40102          LDRD     r0,r1,[r4,#8]         ;1293
000036  f7fffffe          BL       RMP_List_Del
                  |L43.58|
00003a  69a0              LDR      r0,[r4,#0x18]         ;1295
00003c  f02000ff          BIC      r0,r0,#0xff           ;1295
000040  1c40              ADDS     r0,r0,#1              ;1295
000042  61a0              STR      r0,[r4,#0x18]         ;1295
000044  8b20              LDRH     r0,[r4,#0x18]         ;1298
000046  f4007080          AND      r0,r0,#0x100          ;1298
00004a  b910              CBNZ     r0,|L43.82|
00004c  4620              MOV      r0,r4                 ;1299
00004e  f7fffffe          BL       _RMP_Set_Rdy
                  |L43.82|
000052  f06f0004          MVN      r0,#4                 ;1301
000056  63a0              STR      r0,[r4,#0x38]         ;1301
                  |L43.88|
000058  6868              LDR      r0,[r5,#4]            ;1288
00005a  42a8              CMP      r0,r5                 ;1288
00005c  d1e1              BNE      |L43.34|
00005e  2000              MOVS     r0,#0                 ;1303
000060  60a8              STR      r0,[r5,#8]            ;1303
000062  f7fffffe          BL       RMP_Unlock_Sched
000066  2000              MOVS     r0,#0                 ;1307
000068  e7cf              B        |L43.10|
;;;1309   /* End Function:RMP_Sem_Del **************************************************/
                          ENDP


                          AREA ||i.RMP_Sem_Pend||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Pend PROC
;;;1317   ******************************************************************************/
;;;1318   ret_t RMP_Sem_Pend(volatile struct RMP_Sem* Semaphore, ptr_t Slices)
000000  b570              PUSH     {r4-r6,lr}
;;;1319   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1320       /* Check if this semaphore structure could possibly be in use */
;;;1321       if(Semaphore==0)
000006  b914              CBNZ     r4,|L44.14|
;;;1322           return RMP_ERR_SEM;
000008  f06f0005          MVN      r0,#5
                  |L44.12|
;;;1323       
;;;1324       RMP_Lock_Sched();
;;;1325       
;;;1326       if(Semaphore->State!=RMP_SEM_USED)
;;;1327       {
;;;1328           RMP_Unlock_Sched();
;;;1329           return RMP_ERR_SEM;
;;;1330       }
;;;1331       
;;;1332       /* Check if we can get one immediately */
;;;1333       if(Semaphore->Cur_Num!=0)
;;;1334       {
;;;1335           Semaphore->Cur_Num--;
;;;1336           RMP_Unlock_Sched();
;;;1337           return Semaphore->Cur_Num;
;;;1338       }
;;;1339       else
;;;1340       {
;;;1341           /* Cannot get one, we need to block */
;;;1342           if(Slices==0)
;;;1343           {
;;;1344               RMP_Unlock_Sched();
;;;1345               return RMP_ERR_OPER;
;;;1346           }
;;;1347   
;;;1348           /* We must be running - place into waitlist now */
;;;1349           _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1350           RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),Semaphore->Wait_List.Prev,&(Semaphore->Wait_List));
;;;1351           
;;;1352           if(Slices<RMP_MAX_SLICES)
;;;1353           {
;;;1354               _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1355               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SEMDLY);
;;;1356           }
;;;1357           else
;;;1358               RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SEMBLK);
;;;1359           
;;;1360           RMP_Cur_Thd->Retval=0;
;;;1361       }
;;;1362       
;;;1363       RMP_Unlock_Sched();
;;;1364   
;;;1365       return RMP_Cur_Thd->Retval;
;;;1366   }
00000c  bd70              POP      {r4-r6,pc}
                  |L44.14|
00000e  f7fffffe          BL       RMP_Lock_Sched
000012  68a0              LDR      r0,[r4,#8]            ;1326
000014  2801              CMP      r0,#1                 ;1326
000016  d004              BEQ      |L44.34|
000018  f7fffffe          BL       RMP_Unlock_Sched
00001c  f06f0005          MVN      r0,#5                 ;1329
000020  e7f4              B        |L44.12|
                  |L44.34|
000022  68e0              LDR      r0,[r4,#0xc]          ;1333
000024  b130              CBZ      r0,|L44.52|
000026  68e0              LDR      r0,[r4,#0xc]          ;1335
000028  1e40              SUBS     r0,r0,#1              ;1335
00002a  60e0              STR      r0,[r4,#0xc]          ;1335
00002c  f7fffffe          BL       RMP_Unlock_Sched
000030  68e0              LDR      r0,[r4,#0xc]          ;1337
000032  e7eb              B        |L44.12|
                  |L44.52|
000034  b925              CBNZ     r5,|L44.64|
000036  f7fffffe          BL       RMP_Unlock_Sched
00003a  f06f0004          MVN      r0,#4                 ;1345
00003e  e7e5              B        |L44.12|
                  |L44.64|
000040  4817              LDR      r0,|L44.160|
000042  6800              LDR      r0,[r0,#0]            ;1349  ; RMP_Cur_Thd
000044  f7fffffe          BL       _RMP_Clr_Rdy
000048  6821              LDR      r1,[r4,#0]            ;1350
00004a  4622              MOV      r2,r4                 ;1350
00004c  4814              LDR      r0,|L44.160|
00004e  6800              LDR      r0,[r0,#0]            ;1350  ; RMP_Cur_Thd
000050  f7fffffe          BL       RMP_List_Ins
000054  4813              LDR      r0,|L44.164|
000056  4285              CMP      r5,r0                 ;1352
000058  d20f              BCS      |L44.122|
00005a  4629              MOV      r1,r5                 ;1354
00005c  4810              LDR      r0,|L44.160|
00005e  6800              LDR      r0,[r0,#0]            ;1354  ; RMP_Cur_Thd
000060  f7fffffe          BL       _RMP_Dly_Ins
000064  480e              LDR      r0,|L44.160|
000066  6800              LDR      r0,[r0,#0]            ;1355  ; RMP_Cur_Thd
000068  6980              LDR      r0,[r0,#0x18]         ;1355
00006a  f02000ff          BIC      r0,r0,#0xff           ;1355
00006e  f0400008          ORR      r0,r0,#8              ;1355
000072  490b              LDR      r1,|L44.160|
000074  6809              LDR      r1,[r1,#0]            ;1355  ; RMP_Cur_Thd
000076  6188              STR      r0,[r1,#0x18]         ;1355
000078  e008              B        |L44.140|
                  |L44.122|
00007a  4809              LDR      r0,|L44.160|
00007c  6800              LDR      r0,[r0,#0]            ;1358  ; RMP_Cur_Thd
00007e  6980              LDR      r0,[r0,#0x18]         ;1358
000080  f02000ff          BIC      r0,r0,#0xff           ;1358
000084  1dc0              ADDS     r0,r0,#7              ;1358
000086  4906              LDR      r1,|L44.160|
000088  6809              LDR      r1,[r1,#0]            ;1358  ; RMP_Cur_Thd
00008a  6188              STR      r0,[r1,#0x18]         ;1358
                  |L44.140|
00008c  2000              MOVS     r0,#0                 ;1360
00008e  4904              LDR      r1,|L44.160|
000090  6809              LDR      r1,[r1,#0]            ;1360  ; RMP_Cur_Thd
000092  6388              STR      r0,[r1,#0x38]         ;1360
000094  f7fffffe          BL       RMP_Unlock_Sched
000098  4801              LDR      r0,|L44.160|
00009a  6800              LDR      r0,[r0,#0]            ;1365  ; RMP_Cur_Thd
00009c  6b80              LDR      r0,[r0,#0x38]         ;1365
00009e  e7b5              B        |L44.12|
;;;1367   /* End Function:RMP_Sem_Pend *************************************************/
                          ENDP

                  |L44.160|
                          DCD      RMP_Cur_Thd
                  |L44.164|
                          DCD      0x000186a0

                          AREA ||i.RMP_Sem_Post||, CODE, READONLY, ALIGN=1

                  RMP_Sem_Post PROC
;;;1424   ******************************************************************************/
;;;1425   ret_t RMP_Sem_Post(volatile struct RMP_Sem* Semaphore, ptr_t Number)
000000  b570              PUSH     {r4-r6,lr}
;;;1426   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;1427       struct RMP_Thd* Thread;
;;;1428       
;;;1429       /* Check if this semaphore structure could possibly be in use */
;;;1430       if((Semaphore==0)||(Number==0))
000006  b104              CBZ      r4,|L45.10|
000008  b916              CBNZ     r6,|L45.16|
                  |L45.10|
;;;1431           return RMP_ERR_SEM;
00000a  f06f0005          MVN      r0,#5
                  |L45.14|
;;;1432       
;;;1433       RMP_Lock_Sched();
;;;1434       
;;;1435       if(Semaphore->State!=RMP_SEM_USED)
;;;1436       {
;;;1437           RMP_Unlock_Sched();
;;;1438           return RMP_ERR_SEM;
;;;1439       }
;;;1440       
;;;1441       /* Would the maximum value be exceeded if this is posted? */
;;;1442       if((Semaphore->Cur_Num+Number)>=RMP_SEM_MAX_NUM)
;;;1443       {
;;;1444           RMP_Unlock_Sched();
;;;1445           return RMP_ERR_OPER;
;;;1446       }
;;;1447       
;;;1448       Semaphore->Cur_Num+=Number;
;;;1449       /* Is there any thread waiting on it? If there are, clean them up*/
;;;1450       while((&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)&&(Semaphore->Cur_Num!=0))
;;;1451       {
;;;1452           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
;;;1453           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1454           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1455               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1456           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1457   
;;;1458           /* Only when when this thread is not suspended do we change it back */
;;;1459           if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;1460               _RMP_Set_Rdy(Thread);
;;;1461   
;;;1462           /* Finally, return success */
;;;1463           Thread->Retval=0;
;;;1464           Semaphore->Cur_Num--;
;;;1465       }
;;;1466   
;;;1467       RMP_Unlock_Sched();
;;;1468   
;;;1469       return 0;
;;;1470   }
00000e  bd70              POP      {r4-r6,pc}
                  |L45.16|
000010  f7fffffe          BL       RMP_Lock_Sched
000014  68a0              LDR      r0,[r4,#8]            ;1435
000016  2801              CMP      r0,#1                 ;1435
000018  d004              BEQ      |L45.36|
00001a  f7fffffe          BL       RMP_Unlock_Sched
00001e  f06f0005          MVN      r0,#5                 ;1438
000022  e7f4              B        |L45.14|
                  |L45.36|
000024  68e0              LDR      r0,[r4,#0xc]          ;1442
000026  4430              ADD      r0,r0,r6              ;1442
000028  f5b07f7a          CMP      r0,#0x3e8             ;1442
00002c  d304              BCC      |L45.56|
00002e  f7fffffe          BL       RMP_Unlock_Sched
000032  f06f0004          MVN      r0,#4                 ;1445
000036  e7ea              B        |L45.14|
                  |L45.56|
000038  68e0              LDR      r0,[r4,#0xc]          ;1448
00003a  4430              ADD      r0,r0,r6              ;1448
00003c  60e0              STR      r0,[r4,#0xc]          ;1448
00003e  e01c              B        |L45.122|
                  |L45.64|
000040  6865              LDR      r5,[r4,#4]            ;1452
000042  e9d50100          LDRD     r0,r1,[r5,#0]         ;1453
000046  f7fffffe          BL       RMP_List_Del
00004a  7e28              LDRB     r0,[r5,#0x18]         ;1454
00004c  2808              CMP      r0,#8                 ;1454
00004e  d103              BNE      |L45.88|
000050  e9d50102          LDRD     r0,r1,[r5,#8]         ;1455
000054  f7fffffe          BL       RMP_List_Del
                  |L45.88|
000058  69a8              LDR      r0,[r5,#0x18]         ;1456
00005a  f02000ff          BIC      r0,r0,#0xff           ;1456
00005e  1c40              ADDS     r0,r0,#1              ;1456
000060  61a8              STR      r0,[r5,#0x18]         ;1456
000062  8b28              LDRH     r0,[r5,#0x18]         ;1459
000064  f4007080          AND      r0,r0,#0x100          ;1459
000068  b910              CBNZ     r0,|L45.112|
00006a  4628              MOV      r0,r5                 ;1460
00006c  f7fffffe          BL       _RMP_Set_Rdy
                  |L45.112|
000070  2000              MOVS     r0,#0                 ;1463
000072  63a8              STR      r0,[r5,#0x38]         ;1463
000074  68e0              LDR      r0,[r4,#0xc]          ;1464
000076  1e40              SUBS     r0,r0,#1              ;1464
000078  60e0              STR      r0,[r4,#0xc]          ;1464
                  |L45.122|
00007a  6860              LDR      r0,[r4,#4]            ;1450
00007c  42a0              CMP      r0,r4                 ;1450
00007e  d002              BEQ      |L45.134|
000080  68e0              LDR      r0,[r4,#0xc]          ;1450
000082  2800              CMP      r0,#0                 ;1450
000084  d1dc              BNE      |L45.64|
                  |L45.134|
000086  f7fffffe          BL       RMP_Unlock_Sched
00008a  2000              MOVS     r0,#0                 ;1469
00008c  e7bf              B        |L45.14|
;;;1471   /* End Function:RMP_Sem_Post *************************************************/
                          ENDP


                          AREA ||i.RMP_Sem_Post_ISR||, CODE, READONLY, ALIGN=2

                  RMP_Sem_Post_ISR PROC
;;;1479   ******************************************************************************/
;;;1480   ret_t RMP_Sem_Post_ISR(volatile struct RMP_Sem* Semaphore, ptr_t Number)
000000  b570              PUSH     {r4-r6,lr}
;;;1481   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;1482       struct RMP_Thd* Thread;
;;;1483       /* Check if this semaphore structure could possibly be in use */
;;;1484       if((Semaphore==0)||(Number==0))
000006  b104              CBZ      r4,|L46.10|
000008  b916              CBNZ     r6,|L46.16|
                  |L46.10|
;;;1485           return RMP_ERR_SEM;
00000a  f06f0005          MVN      r0,#5
                  |L46.14|
;;;1486       
;;;1487       if(Semaphore->State!=RMP_SEM_USED)
;;;1488           return RMP_ERR_SEM;
;;;1489   
;;;1490       if(RMP_Sched_Locked!=0)
;;;1491           return RMP_ERR_OPER;
;;;1492   
;;;1493       /* Would the maximum value be exceeded if this is posted? */
;;;1494       if((Semaphore->Cur_Num+Number)>=RMP_SEM_MAX_NUM)
;;;1495           return RMP_ERR_OPER;
;;;1496       
;;;1497       Semaphore->Cur_Num+=Number;
;;;1498       /* Is there any thread waiting on it? If there are, clean them up*/
;;;1499       while((&(Semaphore->Wait_List)!=Semaphore->Wait_List.Next)&&(Semaphore->Cur_Num!=0))
;;;1500       {
;;;1501           Thread=(struct RMP_Thd*)(Semaphore->Wait_List.Next);
;;;1502           RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;1503           if(RMP_THD_STATE(Thread->State)==RMP_THD_SEMDLY)
;;;1504               RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1505           
;;;1506           RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1507   
;;;1508           /* Only when when this thread is not suspended do we change it back */
;;;1509           if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;1510           {
;;;1511               _RMP_Set_Rdy(Thread);
;;;1512               if(Thread->Prio>RMP_Cur_Thd->Prio)
;;;1513                   _RMP_Yield();
;;;1514           }
;;;1515   
;;;1516           /* Finally, return success */
;;;1517           Thread->Retval=0;
;;;1518           Semaphore->Cur_Num--;
;;;1519       }
;;;1520   
;;;1521       return 0;
;;;1522   }
00000e  bd70              POP      {r4-r6,pc}
                  |L46.16|
000010  68a0              LDR      r0,[r4,#8]            ;1487
000012  2801              CMP      r0,#1                 ;1487
000014  d002              BEQ      |L46.28|
000016  f06f0005          MVN      r0,#5                 ;1488
00001a  e7f8              B        |L46.14|
                  |L46.28|
00001c  481f              LDR      r0,|L46.156|
00001e  6800              LDR      r0,[r0,#0]            ;1490  ; RMP_Sched_Locked
000020  b110              CBZ      r0,|L46.40|
000022  f06f0004          MVN      r0,#4                 ;1491
000026  e7f2              B        |L46.14|
                  |L46.40|
000028  68e0              LDR      r0,[r4,#0xc]          ;1494
00002a  4430              ADD      r0,r0,r6              ;1494
00002c  f5b07f7a          CMP      r0,#0x3e8             ;1494
000030  d302              BCC      |L46.56|
000032  f06f0004          MVN      r0,#4                 ;1495
000036  e7ea              B        |L46.14|
                  |L46.56|
000038  68e0              LDR      r0,[r4,#0xc]          ;1497
00003a  4430              ADD      r0,r0,r6              ;1497
00003c  60e0              STR      r0,[r4,#0xc]          ;1497
00003e  e024              B        |L46.138|
                  |L46.64|
000040  6865              LDR      r5,[r4,#4]            ;1501
000042  e9d50100          LDRD     r0,r1,[r5,#0]         ;1502
000046  f7fffffe          BL       RMP_List_Del
00004a  7e28              LDRB     r0,[r5,#0x18]         ;1503
00004c  2808              CMP      r0,#8                 ;1503
00004e  d103              BNE      |L46.88|
000050  e9d50102          LDRD     r0,r1,[r5,#8]         ;1504
000054  f7fffffe          BL       RMP_List_Del
                  |L46.88|
000058  69a8              LDR      r0,[r5,#0x18]         ;1506
00005a  f02000ff          BIC      r0,r0,#0xff           ;1506
00005e  1c40              ADDS     r0,r0,#1              ;1506
000060  61a8              STR      r0,[r5,#0x18]         ;1506
000062  8b28              LDRH     r0,[r5,#0x18]         ;1509
000064  f4007080          AND      r0,r0,#0x100          ;1509
000068  b950              CBNZ     r0,|L46.128|
00006a  4628              MOV      r0,r5                 ;1511
00006c  f7fffffe          BL       _RMP_Set_Rdy
000070  490b              LDR      r1,|L46.160|
000072  6a68              LDR      r0,[r5,#0x24]         ;1512
000074  6809              LDR      r1,[r1,#0]            ;1512  ; RMP_Cur_Thd
000076  6a49              LDR      r1,[r1,#0x24]         ;1512
000078  4288              CMP      r0,r1                 ;1512
00007a  d901              BLS      |L46.128|
00007c  f7fffffe          BL       _RMP_Yield
                  |L46.128|
000080  2000              MOVS     r0,#0                 ;1517
000082  63a8              STR      r0,[r5,#0x38]         ;1517
000084  68e0              LDR      r0,[r4,#0xc]          ;1518
000086  1e40              SUBS     r0,r0,#1              ;1518
000088  60e0              STR      r0,[r4,#0xc]          ;1518
                  |L46.138|
00008a  6860              LDR      r0,[r4,#4]            ;1499
00008c  42a0              CMP      r0,r4                 ;1499
00008e  d002              BEQ      |L46.150|
000090  68e0              LDR      r0,[r4,#0xc]          ;1499
000092  2800              CMP      r0,#0                 ;1499
000094  d1d4              BNE      |L46.64|
                  |L46.150|
000096  2000              MOVS     r0,#0                 ;1521
000098  e7b9              B        |L46.14|
;;;1523   /* End Function:RMP_Sem_Post_ISR *********************************************/
                          ENDP

00009a  0000              DCW      0x0000
                  |L46.156|
                          DCD      RMP_Sched_Locked
                  |L46.160|
                          DCD      RMP_Cur_Thd

                          AREA ||i.RMP_Start_Hook||, CODE, READONLY, ALIGN=1

                  RMP_Start_Hook PROC
;;;1532   #if(RMP_USE_HOOKS==RMP_FALSE)
;;;1533   void RMP_Start_Hook(void)
000000  4770              BX       lr
;;;1534   {
;;;1535       return;
;;;1536   }
;;;1537   #endif
                          ENDP


                          AREA ||i.RMP_Thd_Cancel||, CODE, READONLY, ALIGN=1

                  RMP_Thd_Cancel PROC
;;;1194   ******************************************************************************/
;;;1195   ret_t RMP_Thd_Cancel(volatile struct RMP_Thd* Thread)
000000  b510              PUSH     {r4,lr}
;;;1196   {
000002  4604              MOV      r4,r0
;;;1197       /* Check if this thread structure could possibly be in use */
;;;1198       if(Thread==0)
000004  b914              CBNZ     r4,|L48.12|
;;;1199           return RMP_ERR_THD;
000006  f04f30ff          MOV      r0,#0xffffffff
                  |L48.10|
;;;1200       
;;;1201       RMP_Lock_Sched();
;;;1202       
;;;1203       /* Is it delayed? */
;;;1204       if(RMP_THD_STATE(Thread->State)!=RMP_THD_DELAYED)
;;;1205       {
;;;1206           RMP_Unlock_Sched();
;;;1207           return RMP_ERR_STATE;
;;;1208       }
;;;1209   
;;;1210       /* Delete it from the delay list */
;;;1211       RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1212       RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1213       
;;;1214       /* Only when when this thread is not suspended do we change it back */
;;;1215       if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;1216           _RMP_Set_Rdy(Thread);
;;;1217       
;;;1218       Thread->Retval=RMP_ERR_OPER;
;;;1219       
;;;1220       RMP_Unlock_Sched();
;;;1221   
;;;1222       return 0;
;;;1223   }
00000a  bd10              POP      {r4,pc}
                  |L48.12|
00000c  f7fffffe          BL       RMP_Lock_Sched
000010  69a0              LDR      r0,[r4,#0x18]         ;1204
000012  b2c0              UXTB     r0,r0                 ;1204
000014  2806              CMP      r0,#6                 ;1204
000016  d004              BEQ      |L48.34|
000018  f7fffffe          BL       RMP_Unlock_Sched
00001c  f06f0003          MVN      r0,#3                 ;1207
000020  e7f3              B        |L48.10|
                  |L48.34|
000022  68e1              LDR      r1,[r4,#0xc]          ;1211
000024  68a0              LDR      r0,[r4,#8]            ;1211
000026  f7fffffe          BL       RMP_List_Del
00002a  69a0              LDR      r0,[r4,#0x18]         ;1212
00002c  f02000ff          BIC      r0,r0,#0xff           ;1212
000030  1c40              ADDS     r0,r0,#1              ;1212
000032  61a0              STR      r0,[r4,#0x18]         ;1212
000034  69a0              LDR      r0,[r4,#0x18]         ;1215
000036  f4007080          AND      r0,r0,#0x100          ;1215
00003a  b910              CBNZ     r0,|L48.66|
00003c  4620              MOV      r0,r4                 ;1216
00003e  f7fffffe          BL       _RMP_Set_Rdy
                  |L48.66|
000042  f06f0004          MVN      r0,#4                 ;1218
000046  63a0              STR      r0,[r4,#0x38]         ;1218
000048  f7fffffe          BL       RMP_Unlock_Sched
00004c  2000              MOVS     r0,#0                 ;1222
00004e  e7dc              B        |L48.10|
;;;1224   /* End Function:RMP_Thd_Cancel ***********************************************/
                          ENDP


                          AREA ||i.RMP_Thd_Crt||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Crt PROC
;;;674    ******************************************************************************/
;;;675    ret_t RMP_Thd_Crt(volatile struct RMP_Thd* Thread, void* Entry, void* Stack, void* Arg, ptr_t Prio, ptr_t Slices)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;676    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
00000a  4698              MOV      r8,r3
00000c  e9dd9508          LDRD     r9,r5,[sp,#0x20]
;;;677        /* Check if the priority and timeslice range is correct */
;;;678        if(Prio>=RMP_MAX_PREEMPT_PRIO)
000010  f1b90f20          CMP      r9,#0x20
000014  d303              BCC      |L49.30|
;;;679            return RMP_ERR_PRIO;
000016  f06f0001          MVN      r0,#1
                  |L49.26|
;;;680        if((Slices==0)||(Slices>=RMP_MAX_SLICES))
;;;681            return RMP_ERR_SLICE;
;;;682        
;;;683        /* Check if this thread structure could possibly be in use */
;;;684        if(Thread==0)
;;;685            return RMP_ERR_THD;
;;;686        
;;;687        RMP_Lock_Sched();
;;;688        
;;;689        if(RMP_THD_STATE(Thread->State)!=RMP_THD_FREE)
;;;690        {
;;;691            RMP_Unlock_Sched();
;;;692            return RMP_ERR_THD;
;;;693        }
;;;694        
;;;695        /* Create the thread and insert it into the list */
;;;696        Thread->Prio=Prio;
;;;697        Thread->Slices=Slices;
;;;698        Thread->Slices_Left=Slices;
;;;699        Thread->Stack=(ptr_t)Stack;
;;;700        
;;;701        /* Initialize its stack and sending list */
;;;702        _RMP_Stack_Init((ptr_t)Entry, (ptr_t)Stack, (ptr_t)Arg);
;;;703        RMP_List_Crt(&(Thread->Snd_List));
;;;704        
;;;705        /* Notify the scheduler that we have created something new, also check locks */
;;;706        Thread->State=RMP_THD_RUNNING;
;;;707        _RMP_Set_Rdy(Thread);
;;;708        
;;;709        RMP_Unlock_Sched();
;;;710    
;;;711        return 0;
;;;712    }
00001a  e8bd87f0          POP      {r4-r10,pc}
                  |L49.30|
00001e  b115              CBZ      r5,|L49.38|
000020  4815              LDR      r0,|L49.120|
000022  4285              CMP      r5,r0                 ;680
000024  d302              BCC      |L49.44|
                  |L49.38|
000026  f06f0002          MVN      r0,#2                 ;681
00002a  e7f6              B        |L49.26|
                  |L49.44|
00002c  b914              CBNZ     r4,|L49.52|
00002e  f04f30ff          MOV      r0,#0xffffffff        ;685
000032  e7f2              B        |L49.26|
                  |L49.52|
000034  f7fffffe          BL       RMP_Lock_Sched
000038  69a0              LDR      r0,[r4,#0x18]         ;689
00003a  b2c0              UXTB     r0,r0                 ;689
00003c  b120              CBZ      r0,|L49.72|
00003e  f7fffffe          BL       RMP_Unlock_Sched
000042  f04f30ff          MOV      r0,#0xffffffff        ;692
000046  e7e8              B        |L49.26|
                  |L49.72|
000048  f8c49024          STR      r9,[r4,#0x24]         ;696
00004c  61e5              STR      r5,[r4,#0x1c]         ;697
00004e  6225              STR      r5,[r4,#0x20]         ;698
000050  6366              STR      r6,[r4,#0x34]         ;699
000052  4642              MOV      r2,r8                 ;702
000054  4631              MOV      r1,r6                 ;702
000056  4638              MOV      r0,r7                 ;702
000058  f7fffffe          BL       _RMP_Stack_Init
00005c  f1040010          ADD      r0,r4,#0x10           ;703
000060  f7fffffe          BL       RMP_List_Crt
000064  2001              MOVS     r0,#1                 ;706
000066  61a0              STR      r0,[r4,#0x18]         ;706
000068  4620              MOV      r0,r4                 ;707
00006a  f7fffffe          BL       _RMP_Set_Rdy
00006e  f7fffffe          BL       RMP_Unlock_Sched
000072  2000              MOVS     r0,#0                 ;711
000074  e7d1              B        |L49.26|
;;;713    /* End Function:RMP_Thd_Crt **************************************************/
                          ENDP

000076  0000              DCW      0x0000
                  |L49.120|
                          DCD      0x000186a0

                          AREA ||i.RMP_Thd_Del||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Del PROC
;;;720    ******************************************************************************/
;;;721    ret_t RMP_Thd_Del(volatile struct RMP_Thd* Thread)
000000  b570              PUSH     {r4-r6,lr}
;;;722    {
000002  4604              MOV      r4,r0
;;;723        struct RMP_Thd* Release;
;;;724        ptr_t Self_Del;
;;;725        
;;;726        /* Check if this thread structure could possibly be in use */
;;;727        if(Thread==0)
000004  b914              CBNZ     r4,|L50.12|
;;;728            return RMP_ERR_THD;
000006  f04f30ff          MOV      r0,#0xffffffff
                  |L50.10|
;;;729        
;;;730        RMP_Lock_Sched();
;;;731        
;;;732        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;733        {
;;;734            RMP_Unlock_Sched();
;;;735            return RMP_ERR_THD;
;;;736        }
;;;737        
;;;738        /* See if anyone waiting to send to this thread. If there is, release all these threads */
;;;739        while(&(Thread->Snd_List)!=Thread->Snd_List.Next)
;;;740        {
;;;741            Release=(struct RMP_Thd*)(Thread->Snd_List.Next);
;;;742            RMP_List_Del(Release->Run_Head.Prev,Release->Run_Head.Next);
;;;743            if(RMP_THD_STATE(Release->State)==RMP_THD_SNDDLY)
;;;744                RMP_List_Del(Release->Dly_Head.Prev,Release->Dly_Head.Next);
;;;745    
;;;746            RMP_THD_STATE_SET(Release->State,RMP_THD_RUNNING);
;;;747    
;;;748            /* Is it suspended? If yes, we can't directly send it running */
;;;749            if((Release->State&RMP_THD_SUSPENDED)==0)
;;;750               _RMP_Set_Rdy(Release);
;;;751            
;;;752            Release->Retval=RMP_ERR_OPER;
;;;753        }
;;;754        
;;;755        /* See what is it state */
;;;756        Self_Del=0;
;;;757        if(RMP_Cur_Thd==Thread)
;;;758            Self_Del=1;
;;;759        
;;;760        switch(RMP_THD_STATE(Thread->State))
;;;761        {
;;;762            case RMP_THD_RUNNING:
;;;763            {
;;;764                if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;765                    _RMP_Clr_Rdy(Thread);
;;;766                break;
;;;767            }
;;;768            
;;;769            case RMP_THD_SNDDLY:
;;;770            case RMP_THD_SEMDLY:
;;;771            {
;;;772                if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;773                    RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
;;;774                RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;775                Thread->Retval=RMP_ERR_OPER;
;;;776                break;
;;;777            }
;;;778                
;;;779            case RMP_THD_RCVDLY:
;;;780            {
;;;781                RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;782                Thread->Retval=RMP_ERR_OPER;
;;;783                break;
;;;784            }
;;;785                
;;;786            case RMP_THD_DELAYED:
;;;787            {
;;;788                RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;789                Thread->Retval=RMP_ERR_OPER;
;;;790                break;
;;;791            }
;;;792            /* Should not get here */
;;;793            default:break;
;;;794        }
;;;795        Thread->State=RMP_THD_FREE;
;;;796        
;;;797        RMP_Unlock_Sched();
;;;798        
;;;799        /* If we are deleting ourself, just stop the execution here */
;;;800        if(Self_Del!=0)
;;;801            while(1);
;;;802    
;;;803        return 0;
;;;804    }
00000a  bd70              POP      {r4-r6,pc}
                  |L50.12|
00000c  f7fffffe          BL       RMP_Lock_Sched
000010  69a0              LDR      r0,[r4,#0x18]         ;732
000012  b2c0              UXTB     r0,r0                 ;732
000014  b920              CBNZ     r0,|L50.32|
000016  f7fffffe          BL       RMP_Unlock_Sched
00001a  f04f30ff          MOV      r0,#0xffffffff        ;735
00001e  e7f4              B        |L50.10|
                  |L50.32|
000020  e01a              B        |L50.88|
                  |L50.34|
000022  6965              LDR      r5,[r4,#0x14]         ;741
000024  e9d50100          LDRD     r0,r1,[r5,#0]         ;742
000028  f7fffffe          BL       RMP_List_Del
00002c  7e28              LDRB     r0,[r5,#0x18]         ;743
00002e  2803              CMP      r0,#3                 ;743
000030  d103              BNE      |L50.58|
000032  e9d50102          LDRD     r0,r1,[r5,#8]         ;744
000036  f7fffffe          BL       RMP_List_Del
                  |L50.58|
00003a  69a8              LDR      r0,[r5,#0x18]         ;746
00003c  f02000ff          BIC      r0,r0,#0xff           ;746
000040  1c40              ADDS     r0,r0,#1              ;746
000042  61a8              STR      r0,[r5,#0x18]         ;746
000044  8b28              LDRH     r0,[r5,#0x18]         ;749
000046  f4007080          AND      r0,r0,#0x100          ;749
00004a  b910              CBNZ     r0,|L50.82|
00004c  4628              MOV      r0,r5                 ;750
00004e  f7fffffe          BL       _RMP_Set_Rdy
                  |L50.82|
000052  f06f0004          MVN      r0,#4                 ;752
000056  63a8              STR      r0,[r5,#0x38]         ;752
                  |L50.88|
000058  6961              LDR      r1,[r4,#0x14]         ;739
00005a  f1040010          ADD      r0,r4,#0x10           ;739
00005e  4281              CMP      r1,r0                 ;739
000060  d1df              BNE      |L50.34|
000062  2600              MOVS     r6,#0                 ;756
000064  4821              LDR      r0,|L50.236|
000066  6800              LDR      r0,[r0,#0]            ;757  ; RMP_Cur_Thd
000068  42a0              CMP      r0,r4                 ;757
00006a  d100              BNE      |L50.110|
00006c  2601              MOVS     r6,#1                 ;758
                  |L50.110|
00006e  69a0              LDR      r0,[r4,#0x18]         ;760
000070  b2c0              UXTB     r0,r0                 ;760
000072  2809              CMP      r0,#9                 ;760
000074  d22f              BCS      |L50.214|
000076  e8dff000          TBB      [pc,r0]               ;760
00007a  2e05              DCB      0x2e,0x05
00007c  2e0d2e1e          DCB      0x2e,0x0d,0x2e,0x1e
000080  262e0e00          DCB      0x26,0x2e,0x0e,0x00
000084  69a0              LDR      r0,[r4,#0x18]         ;764
000086  f4007080          AND      r0,r0,#0x100          ;764
00008a  b910              CBNZ     r0,|L50.146|
00008c  4620              MOV      r0,r4                 ;765
00008e  f7fffffe          BL       _RMP_Clr_Rdy
                  |L50.146|
000092  e021              B        |L50.216|
000094  bf00              NOP                            ;770
000096  69a0              LDR      r0,[r4,#0x18]         ;772
000098  f4007080          AND      r0,r0,#0x100          ;772
00009c  b918              CBNZ     r0,|L50.166|
00009e  6861              LDR      r1,[r4,#4]            ;773
0000a0  6820              LDR      r0,[r4,#0]            ;773
0000a2  f7fffffe          BL       RMP_List_Del
                  |L50.166|
0000a6  68e1              LDR      r1,[r4,#0xc]          ;774
0000a8  68a0              LDR      r0,[r4,#8]            ;774
0000aa  f7fffffe          BL       RMP_List_Del
0000ae  f06f0004          MVN      r0,#4                 ;775
0000b2  63a0              STR      r0,[r4,#0x38]         ;775
0000b4  e010              B        |L50.216|
0000b6  68e1              LDR      r1,[r4,#0xc]          ;781
0000b8  68a0              LDR      r0,[r4,#8]            ;781
0000ba  f7fffffe          BL       RMP_List_Del
0000be  f06f0004          MVN      r0,#4                 ;782
0000c2  63a0              STR      r0,[r4,#0x38]         ;782
0000c4  e008              B        |L50.216|
0000c6  68e1              LDR      r1,[r4,#0xc]          ;788
0000c8  68a0              LDR      r0,[r4,#8]            ;788
0000ca  f7fffffe          BL       RMP_List_Del
0000ce  f06f0004          MVN      r0,#4                 ;789
0000d2  63a0              STR      r0,[r4,#0x38]         ;789
0000d4  e000              B        |L50.216|
                  |L50.214|
0000d6  bf00              NOP                            ;793
                  |L50.216|
0000d8  bf00              NOP                            ;766
0000da  2000              MOVS     r0,#0                 ;795
0000dc  61a0              STR      r0,[r4,#0x18]         ;795
0000de  f7fffffe          BL       RMP_Unlock_Sched
0000e2  b10e              CBZ      r6,|L50.232|
0000e4  bf00              NOP                            ;801
                  |L50.230|
0000e6  e7fe              B        |L50.230|
                  |L50.232|
0000e8  2000              MOVS     r0,#0                 ;803
0000ea  e78e              B        |L50.10|
;;;805    /* End Function:RMP_Thd_Del **************************************************/
                          ENDP

                  |L50.236|
                          DCD      RMP_Cur_Thd

                          AREA ||i.RMP_Thd_Delay||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Delay PROC
;;;1167   ******************************************************************************/
;;;1168   ret_t RMP_Thd_Delay(ptr_t Slices)
000000  b510              PUSH     {r4,lr}
;;;1169   {
000002  4604              MOV      r4,r0
;;;1170       if((Slices==0)||(Slices>=RMP_MAX_SLICES))
000004  b114              CBZ      r4,|L51.12|
000006  4812              LDR      r0,|L51.80|
000008  4284              CMP      r4,r0
00000a  d302              BCC      |L51.18|
                  |L51.12|
;;;1171           return RMP_ERR_SLICE;
00000c  f06f0002          MVN      r0,#2
                  |L51.16|
;;;1172       
;;;1173       RMP_Lock_Sched();
;;;1174   
;;;1175       /* We must be running */
;;;1176       _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1177       RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_DELAYED);
;;;1178       _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1179   
;;;1180       RMP_Cur_Thd->Retval=0;
;;;1181       
;;;1182       RMP_Unlock_Sched();
;;;1183       
;;;1184       /* Need to return if successful or not */
;;;1185       return RMP_Cur_Thd->Retval;
;;;1186   }
000010  bd10              POP      {r4,pc}
                  |L51.18|
000012  f7fffffe          BL       RMP_Lock_Sched
000016  480f              LDR      r0,|L51.84|
000018  6800              LDR      r0,[r0,#0]            ;1176  ; RMP_Cur_Thd
00001a  f7fffffe          BL       _RMP_Clr_Rdy
00001e  480d              LDR      r0,|L51.84|
000020  6800              LDR      r0,[r0,#0]            ;1177  ; RMP_Cur_Thd
000022  6980              LDR      r0,[r0,#0x18]         ;1177
000024  f02000ff          BIC      r0,r0,#0xff           ;1177
000028  1d80              ADDS     r0,r0,#6              ;1177
00002a  490a              LDR      r1,|L51.84|
00002c  6809              LDR      r1,[r1,#0]            ;1177  ; RMP_Cur_Thd
00002e  6188              STR      r0,[r1,#0x18]         ;1177
000030  4621              MOV      r1,r4                 ;1178
000032  4808              LDR      r0,|L51.84|
000034  6800              LDR      r0,[r0,#0]            ;1178  ; RMP_Cur_Thd
000036  f7fffffe          BL       _RMP_Dly_Ins
00003a  2000              MOVS     r0,#0                 ;1180
00003c  4905              LDR      r1,|L51.84|
00003e  6809              LDR      r1,[r1,#0]            ;1180  ; RMP_Cur_Thd
000040  6388              STR      r0,[r1,#0x38]         ;1180
000042  f7fffffe          BL       RMP_Unlock_Sched
000046  4803              LDR      r0,|L51.84|
000048  6800              LDR      r0,[r0,#0]            ;1185  ; RMP_Cur_Thd
00004a  6b80              LDR      r0,[r0,#0x38]         ;1185
00004c  e7e0              B        |L51.16|
;;;1187   /* End Function:RMP_Thd_Delay ************************************************/
                          ENDP

00004e  0000              DCW      0x0000
                  |L51.80|
                          DCD      0x000186a0
                  |L51.84|
                          DCD      RMP_Cur_Thd

                          AREA ||i.RMP_Thd_Rcv||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Rcv PROC
;;;1088   ******************************************************************************/
;;;1089   ret_t RMP_Thd_Rcv(ptr_t* Data, ptr_t Slices)
000000  b570              PUSH     {r4-r6,lr}
;;;1090   {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;1091       struct RMP_Thd* Sender;
;;;1092       
;;;1093       RMP_Lock_Sched();
000006  f7fffffe          BL       RMP_Lock_Sched
;;;1094   
;;;1095       /* Check if there is a value in our mailbox. If yes, we return with that value */
;;;1096       if((RMP_Cur_Thd->State&RMP_THD_MBOXFUL)!=0)
00000a  483e              LDR      r0,|L52.260|
00000c  6800              LDR      r0,[r0,#0]  ; RMP_Cur_Thd
00000e  8b00              LDRH     r0,[r0,#0x18]
000010  f4007000          AND      r0,r0,#0x200
000014  b178              CBZ      r0,|L52.54|
;;;1097       {
;;;1098           /* Get the value from mailbox */
;;;1099           *Data=RMP_Cur_Thd->Mailbox;
000016  483b              LDR      r0,|L52.260|
000018  6800              LDR      r0,[r0,#0]  ; RMP_Cur_Thd
00001a  6ac0              LDR      r0,[r0,#0x2c]
00001c  6028              STR      r0,[r5,#0]
;;;1100           RMP_Cur_Thd->State&=~RMP_THD_MBOXFUL;
00001e  4939              LDR      r1,|L52.260|
000020  6809              LDR      r1,[r1,#0]  ; RMP_Cur_Thd
000022  f1010018          ADD      r0,r1,#0x18
000026  6989              LDR      r1,[r1,#0x18]
000028  f4217100          BIC      r1,r1,#0x200
00002c  6001              STR      r1,[r0,#0]
;;;1101           RMP_Unlock_Sched();
00002e  f7fffffe          BL       RMP_Unlock_Sched
;;;1102           return 0;
000032  2000              MOVS     r0,#0
                  |L52.52|
;;;1103       }
;;;1104       else
;;;1105       {
;;;1106           /* Is there any other guy waiting on us? If there is, unblock it and set it running */
;;;1107           if(&(RMP_Cur_Thd->Snd_List)!=RMP_Cur_Thd->Snd_List.Next)
;;;1108           {
;;;1109               /* Read the data */
;;;1110               Sender=(struct RMP_Thd*)(RMP_Cur_Thd->Snd_List.Next);
;;;1111               RMP_List_Del(Sender->Run_Head.Prev,Sender->Run_Head.Next);
;;;1112               *Data=Sender->Data;
;;;1113               /* Now we unblock it - what state is it in? */
;;;1114               if((RMP_THD_STATE(Sender->State)==RMP_THD_SNDDLY))
;;;1115                   RMP_List_Del(Sender->Dly_Head.Prev,Sender->Dly_Head.Next);
;;;1116               
;;;1117               RMP_THD_STATE_SET(Sender->State,RMP_THD_RUNNING);
;;;1118   
;;;1119               /* Is it suspended? If yes, we can't directly send it running */
;;;1120               if((Sender->State&RMP_THD_SUSPENDED)==0)
;;;1121                   _RMP_Set_Rdy(Sender);
;;;1122               
;;;1123               RMP_Unlock_Sched();
;;;1124           }
;;;1125           /* No sender waiting on us, we need to block */
;;;1126           else
;;;1127           {
;;;1128               /* No such value in our mailbox, we need to block */
;;;1129               if(Slices==0)
;;;1130               {
;;;1131                   RMP_Unlock_Sched();
;;;1132                   return RMP_ERR_OPER;
;;;1133               }
;;;1134   
;;;1135               /* We must be running */
;;;1136               _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;1137   
;;;1138               if(Slices<RMP_MAX_SLICES)
;;;1139               {
;;;1140                   _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;1141                   RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_RCVDLY);
;;;1142               }
;;;1143               else
;;;1144                   RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_RCVBLK);
;;;1145               
;;;1146               RMP_Unlock_Sched();
;;;1147               /* Dummy read - to separate the lock & unlock. If the compiler optimizes these two
;;;1148                * functions(inline them) on some architectures sometimes we never block. */
;;;1149               *Data=RMP_Cur_Thd->Mailbox;
;;;1150               /* We've been unblocked. There must be something in our mbox, or we should have failed */
;;;1151               RMP_Lock_Sched();
;;;1152               *Data=RMP_Cur_Thd->Mailbox;
;;;1153               RMP_Cur_Thd->State&=~RMP_THD_MBOXFUL;
;;;1154               RMP_Unlock_Sched();
;;;1155           }
;;;1156       }
;;;1157       
;;;1158       return RMP_Cur_Thd->Retval;
;;;1159   }
000034  bd70              POP      {r4-r6,pc}
                  |L52.54|
000036  4833              LDR      r0,|L52.260|
000038  6800              LDR      r0,[r0,#0]            ;1107  ; RMP_Cur_Thd
00003a  6941              LDR      r1,[r0,#0x14]         ;1107
00003c  4831              LDR      r0,|L52.260|
00003e  6800              LDR      r0,[r0,#0]            ;1107  ; RMP_Cur_Thd
000040  3010              ADDS     r0,r0,#0x10           ;1107
000042  4281              CMP      r1,r0                 ;1107
000044  d01e              BEQ      |L52.132|
000046  482f              LDR      r0,|L52.260|
000048  6800              LDR      r0,[r0,#0]            ;1110  ; RMP_Cur_Thd
00004a  6944              LDR      r4,[r0,#0x14]         ;1110
00004c  e9d40100          LDRD     r0,r1,[r4,#0]         ;1111
000050  f7fffffe          BL       RMP_List_Del
000054  6b20              LDR      r0,[r4,#0x30]         ;1112
000056  6028              STR      r0,[r5,#0]            ;1112
000058  7e20              LDRB     r0,[r4,#0x18]         ;1114
00005a  2803              CMP      r0,#3                 ;1114
00005c  d103              BNE      |L52.102|
00005e  e9d40102          LDRD     r0,r1,[r4,#8]         ;1115
000062  f7fffffe          BL       RMP_List_Del
                  |L52.102|
000066  69a0              LDR      r0,[r4,#0x18]         ;1117
000068  f02000ff          BIC      r0,r0,#0xff           ;1117
00006c  1c40              ADDS     r0,r0,#1              ;1117
00006e  61a0              STR      r0,[r4,#0x18]         ;1117
000070  8b20              LDRH     r0,[r4,#0x18]         ;1120
000072  f4007080          AND      r0,r0,#0x100          ;1120
000076  b910              CBNZ     r0,|L52.126|
000078  4620              MOV      r0,r4                 ;1121
00007a  f7fffffe          BL       _RMP_Set_Rdy
                  |L52.126|
00007e  f7fffffe          BL       RMP_Unlock_Sched
000082  e03a              B        |L52.250|
                  |L52.132|
000084  b926              CBNZ     r6,|L52.144|
000086  f7fffffe          BL       RMP_Unlock_Sched
00008a  f06f0004          MVN      r0,#4                 ;1132
00008e  e7d1              B        |L52.52|
                  |L52.144|
000090  481c              LDR      r0,|L52.260|
000092  6800              LDR      r0,[r0,#0]            ;1136  ; RMP_Cur_Thd
000094  f7fffffe          BL       _RMP_Clr_Rdy
000098  481b              LDR      r0,|L52.264|
00009a  4286              CMP      r6,r0                 ;1138
00009c  d20e              BCS      |L52.188|
00009e  4631              MOV      r1,r6                 ;1140
0000a0  4818              LDR      r0,|L52.260|
0000a2  6800              LDR      r0,[r0,#0]            ;1140  ; RMP_Cur_Thd
0000a4  f7fffffe          BL       _RMP_Dly_Ins
0000a8  4816              LDR      r0,|L52.260|
0000aa  6800              LDR      r0,[r0,#0]            ;1141  ; RMP_Cur_Thd
0000ac  6980              LDR      r0,[r0,#0x18]         ;1141
0000ae  f02000ff          BIC      r0,r0,#0xff           ;1141
0000b2  1d40              ADDS     r0,r0,#5              ;1141
0000b4  4913              LDR      r1,|L52.260|
0000b6  6809              LDR      r1,[r1,#0]            ;1141  ; RMP_Cur_Thd
0000b8  6188              STR      r0,[r1,#0x18]         ;1141
0000ba  e008              B        |L52.206|
                  |L52.188|
0000bc  4811              LDR      r0,|L52.260|
0000be  6800              LDR      r0,[r0,#0]            ;1144  ; RMP_Cur_Thd
0000c0  6980              LDR      r0,[r0,#0x18]         ;1144
0000c2  f02000ff          BIC      r0,r0,#0xff           ;1144
0000c6  1d00              ADDS     r0,r0,#4              ;1144
0000c8  490e              LDR      r1,|L52.260|
0000ca  6809              LDR      r1,[r1,#0]            ;1144  ; RMP_Cur_Thd
0000cc  6188              STR      r0,[r1,#0x18]         ;1144
                  |L52.206|
0000ce  f7fffffe          BL       RMP_Unlock_Sched
0000d2  480c              LDR      r0,|L52.260|
0000d4  6800              LDR      r0,[r0,#0]            ;1149  ; RMP_Cur_Thd
0000d6  6ac0              LDR      r0,[r0,#0x2c]         ;1149
0000d8  6028              STR      r0,[r5,#0]            ;1149
0000da  f7fffffe          BL       RMP_Lock_Sched
0000de  4809              LDR      r0,|L52.260|
0000e0  6800              LDR      r0,[r0,#0]            ;1152  ; RMP_Cur_Thd
0000e2  6ac0              LDR      r0,[r0,#0x2c]         ;1152
0000e4  6028              STR      r0,[r5,#0]            ;1152
0000e6  4907              LDR      r1,|L52.260|
0000e8  6809              LDR      r1,[r1,#0]            ;1153  ; RMP_Cur_Thd
0000ea  f1010018          ADD      r0,r1,#0x18           ;1153
0000ee  6989              LDR      r1,[r1,#0x18]         ;1153
0000f0  f4217100          BIC      r1,r1,#0x200          ;1153
0000f4  6001              STR      r1,[r0,#0]            ;1153
0000f6  f7fffffe          BL       RMP_Unlock_Sched
                  |L52.250|
0000fa  4802              LDR      r0,|L52.260|
0000fc  6800              LDR      r0,[r0,#0]            ;1158  ; RMP_Cur_Thd
0000fe  6b80              LDR      r0,[r0,#0x38]         ;1158
000100  e798              B        |L52.52|
;;;1160   /* End Function:RMP_Thd_Rcv **************************************************/
                          ENDP

000102  0000              DCW      0x0000
                  |L52.260|
                          DCD      RMP_Cur_Thd
                  |L52.264|
                          DCD      0x000186a0

                          AREA ||i.RMP_Thd_Resume||, CODE, READONLY, ALIGN=1

                  RMP_Thd_Resume PROC
;;;910    ******************************************************************************/
;;;911    ret_t RMP_Thd_Resume(volatile struct RMP_Thd* Thread)
000000  b570              PUSH     {r4-r6,lr}
;;;912    {
000002  4604              MOV      r4,r0
;;;913        ret_t Retval;
;;;914        
;;;915        /* Check if this thread structure could possibly be in use */
;;;916        if(Thread==0)
000004  b914              CBNZ     r4,|L53.12|
;;;917            return RMP_ERR_THD;
000006  f04f30ff          MOV      r0,#0xffffffff
                  |L53.10|
;;;918    
;;;919        RMP_Lock_Sched();
;;;920        
;;;921        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;922        {
;;;923            RMP_Unlock_Sched();
;;;924            return RMP_ERR_THD;
;;;925        }
;;;926        
;;;927        /* Check if the thread is suspended, if not, then throw an error */
;;;928        if((Thread->State&RMP_THD_SUSPENDED)!=0)
;;;929        {
;;;930            /* Suspended */
;;;931            Thread->State&=~RMP_THD_SUSPENDED;
;;;932            if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
;;;933                _RMP_Set_Rdy(Thread);
;;;934            Retval=0;
;;;935        }
;;;936        else
;;;937            Retval=RMP_ERR_STATE;
;;;938        
;;;939        RMP_Unlock_Sched();
;;;940    
;;;941        return Retval;
;;;942    }
00000a  bd70              POP      {r4-r6,pc}
                  |L53.12|
00000c  f7fffffe          BL       RMP_Lock_Sched
000010  69a0              LDR      r0,[r4,#0x18]         ;921
000012  b2c0              UXTB     r0,r0                 ;921
000014  b920              CBNZ     r0,|L53.32|
000016  f7fffffe          BL       RMP_Unlock_Sched
00001a  f04f30ff          MOV      r0,#0xffffffff        ;924
00001e  e7f4              B        |L53.10|
                  |L53.32|
000020  69a0              LDR      r0,[r4,#0x18]         ;928
000022  f4007080          AND      r0,r0,#0x100          ;928
000026  b160              CBZ      r0,|L53.66|
000028  69a0              LDR      r0,[r4,#0x18]         ;931
00002a  f4207080          BIC      r0,r0,#0x100          ;931
00002e  61a0              STR      r0,[r4,#0x18]         ;931
000030  69a0              LDR      r0,[r4,#0x18]         ;932
000032  b2c0              UXTB     r0,r0                 ;932
000034  2801              CMP      r0,#1                 ;932
000036  d102              BNE      |L53.62|
000038  4620              MOV      r0,r4                 ;933
00003a  f7fffffe          BL       _RMP_Set_Rdy
                  |L53.62|
00003e  2500              MOVS     r5,#0                 ;934
000040  e001              B        |L53.70|
                  |L53.66|
000042  f06f0503          MVN      r5,#3                 ;937
                  |L53.70|
000046  f7fffffe          BL       RMP_Unlock_Sched
00004a  4628              MOV      r0,r5                 ;941
00004c  e7dd              B        |L53.10|
;;;943    /* End Function:RMP_Thd_Resume ***********************************************/
                          ENDP


                          AREA ||i.RMP_Thd_Set||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Set PROC
;;;816    ******************************************************************************/
;;;817    ret_t RMP_Thd_Set(volatile struct RMP_Thd* Thread, ptr_t Prio, ptr_t Slices)
000000  b570              PUSH     {r4-r6,lr}
;;;818    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;819        /* Check if the priority and timeslice range is correct */
;;;820        if(Slices==0)
000008  b915              CBNZ     r5,|L54.16|
;;;821            return RMP_ERR_SLICE;
00000a  f06f0002          MVN      r0,#2
                  |L54.14|
;;;822        
;;;823        /* Check if this thread structure could possibly be in use */
;;;824        if(Thread==0)
;;;825            return RMP_ERR_THD;
;;;826        
;;;827        RMP_Lock_Sched();
;;;828        
;;;829        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;830        {
;;;831            RMP_Unlock_Sched();
;;;832            return RMP_ERR_THD;
;;;833        }
;;;834        
;;;835        /* See if the thread is in running state */
;;;836        if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
;;;837        {
;;;838            /* See if we are gonna change one of it or both */
;;;839            if(Prio<RMP_MAX_PREEMPT_PRIO)
;;;840            {
;;;841                if(Thread->Prio!=Prio)
;;;842                {
;;;843                    _RMP_Clr_Rdy(Thread);
;;;844                    Thread->Prio=Prio;
;;;845                    _RMP_Set_Rdy(Thread);
;;;846                }
;;;847            }
;;;848            
;;;849            if(Slices<RMP_MAX_SLICES)
;;;850                Thread->Slices=Slices;
;;;851        }
;;;852        else
;;;853        {
;;;854            if(Prio<RMP_MAX_PREEMPT_PRIO)
;;;855                Thread->Prio=Prio;
;;;856            
;;;857            if(Slices<RMP_MAX_SLICES)
;;;858                Thread->Slices=Slices;
;;;859        }
;;;860        
;;;861        RMP_Unlock_Sched();
;;;862        
;;;863        return 0;
;;;864    }
00000e  bd70              POP      {r4-r6,pc}
                  |L54.16|
000010  b914              CBNZ     r4,|L54.24|
000012  f04f30ff          MOV      r0,#0xffffffff        ;825
000016  e7fa              B        |L54.14|
                  |L54.24|
000018  f7fffffe          BL       RMP_Lock_Sched
00001c  69a0              LDR      r0,[r4,#0x18]         ;829
00001e  b2c0              UXTB     r0,r0                 ;829
000020  b920              CBNZ     r0,|L54.44|
000022  f7fffffe          BL       RMP_Unlock_Sched
000026  f04f30ff          MOV      r0,#0xffffffff        ;832
00002a  e7f0              B        |L54.14|
                  |L54.44|
00002c  69a0              LDR      r0,[r4,#0x18]         ;836
00002e  b2c0              UXTB     r0,r0                 ;836
000030  2801              CMP      r0,#1                 ;836
000032  d110              BNE      |L54.86|
000034  2e20              CMP      r6,#0x20              ;839
000036  d209              BCS      |L54.76|
000038  6a60              LDR      r0,[r4,#0x24]         ;841
00003a  42b0              CMP      r0,r6                 ;841
00003c  d006              BEQ      |L54.76|
00003e  4620              MOV      r0,r4                 ;843
000040  f7fffffe          BL       _RMP_Clr_Rdy
000044  6266              STR      r6,[r4,#0x24]         ;844
000046  4620              MOV      r0,r4                 ;845
000048  f7fffffe          BL       _RMP_Set_Rdy
                  |L54.76|
00004c  4807              LDR      r0,|L54.108|
00004e  4285              CMP      r5,r0                 ;849
000050  d208              BCS      |L54.100|
000052  61e5              STR      r5,[r4,#0x1c]         ;850
000054  e006              B        |L54.100|
                  |L54.86|
000056  2e20              CMP      r6,#0x20              ;854
000058  d200              BCS      |L54.92|
00005a  6266              STR      r6,[r4,#0x24]         ;855
                  |L54.92|
00005c  4803              LDR      r0,|L54.108|
00005e  4285              CMP      r5,r0                 ;857
000060  d200              BCS      |L54.100|
000062  61e5              STR      r5,[r4,#0x1c]         ;858
                  |L54.100|
000064  f7fffffe          BL       RMP_Unlock_Sched
000068  2000              MOVS     r0,#0                 ;863
00006a  e7d0              B        |L54.14|
;;;865    /* End Function:RMP_Thd_Set **************************************************/
                          ENDP

                  |L54.108|
                          DCD      0x000186a0

                          AREA ||i.RMP_Thd_Snd||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Snd PROC
;;;953    ******************************************************************************/
;;;954    ret_t RMP_Thd_Snd(volatile struct RMP_Thd* Thread, ptr_t Data, ptr_t Slices)
000000  b570              PUSH     {r4-r6,lr}
;;;955    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;956        /* Check if this thread structure could possibly be in use */
;;;957        if(Thread==0)
000008  b914              CBNZ     r4,|L55.16|
;;;958            return RMP_ERR_THD;
00000a  f04f30ff          MOV      r0,#0xffffffff
                  |L55.14|
;;;959        
;;;960        RMP_Lock_Sched();
;;;961        
;;;962        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;963        {
;;;964            RMP_Unlock_Sched();
;;;965            return RMP_ERR_THD;
;;;966        }
;;;967        
;;;968        /* Are we sending to ourself? This is not allowed */
;;;969        if(RMP_Cur_Thd==Thread)
;;;970        {
;;;971            RMP_Unlock_Sched();
;;;972            return RMP_ERR_OPER;
;;;973        }
;;;974        
;;;975        RMP_Cur_Thd->Retval=0;
;;;976    
;;;977        /* See if there are already a value in the mailbox, if there is, we block */
;;;978        if((Thread->State&RMP_THD_MBOXFUL)!=0)
;;;979        {
;;;980            /* Mailbox full, we block, and put ourself into the queue */
;;;981            if(Slices==0)
;;;982            {
;;;983                RMP_Unlock_Sched();
;;;984                return RMP_ERR_OPER;
;;;985            }
;;;986    
;;;987            /* We must be running */
;;;988            _RMP_Clr_Rdy(RMP_Cur_Thd);
;;;989            RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),Thread->Snd_List.Prev,&(Thread->Snd_List));
;;;990    
;;;991            if(Slices<RMP_MAX_SLICES)
;;;992            {
;;;993                _RMP_Dly_Ins(RMP_Cur_Thd, Slices);
;;;994                RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SNDDLY);
;;;995            }
;;;996            else
;;;997                RMP_THD_STATE_SET(RMP_Cur_Thd->State,RMP_THD_SNDBLK);
;;;998    
;;;999            RMP_Cur_Thd->Data=Data;
;;;1000       }
;;;1001       else
;;;1002       {
;;;1003           /* Mailbox not full. We need to check if the receiver is waiting for us */
;;;1004           if((RMP_THD_STATE(Thread->State)==RMP_THD_RCVBLK)||
;;;1005              (RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY))
;;;1006           {
;;;1007               /* The receiver is blocked, wake it up and return the value */
;;;1008               if(RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY)
;;;1009                   RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1010               
;;;1011               RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1012   
;;;1013               /* Is it suspended? If yes, we can't directly send it running */
;;;1014               if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;1015                   _RMP_Set_Rdy(Thread);
;;;1016           }
;;;1017           
;;;1018           /* Set the mailbox */
;;;1019           Thread->Mailbox=Data;
;;;1020           Thread->State|=RMP_THD_MBOXFUL;
;;;1021       }
;;;1022       
;;;1023       RMP_Unlock_Sched();
;;;1024   
;;;1025       return RMP_Cur_Thd->Retval;
;;;1026   }
00000e  bd70              POP      {r4-r6,pc}
                  |L55.16|
000010  f7fffffe          BL       RMP_Lock_Sched
000014  69a0              LDR      r0,[r4,#0x18]         ;962
000016  b2c0              UXTB     r0,r0                 ;962
000018  b920              CBNZ     r0,|L55.36|
00001a  f7fffffe          BL       RMP_Unlock_Sched
00001e  f04f30ff          MOV      r0,#0xffffffff        ;965
000022  e7f4              B        |L55.14|
                  |L55.36|
000024  4834              LDR      r0,|L55.248|
000026  6800              LDR      r0,[r0,#0]            ;969  ; RMP_Cur_Thd
000028  42a0              CMP      r0,r4                 ;969
00002a  d104              BNE      |L55.54|
00002c  f7fffffe          BL       RMP_Unlock_Sched
000030  f06f0004          MVN      r0,#4                 ;972
000034  e7eb              B        |L55.14|
                  |L55.54|
000036  2000              MOVS     r0,#0                 ;975
000038  492f              LDR      r1,|L55.248|
00003a  6809              LDR      r1,[r1,#0]            ;975  ; RMP_Cur_Thd
00003c  6388              STR      r0,[r1,#0x38]         ;975
00003e  69a0              LDR      r0,[r4,#0x18]         ;978
000040  f4007000          AND      r0,r0,#0x200          ;978
000044  b378              CBZ      r0,|L55.166|
000046  b925              CBNZ     r5,|L55.82|
000048  f7fffffe          BL       RMP_Unlock_Sched
00004c  f06f0004          MVN      r0,#4                 ;984
000050  e7dd              B        |L55.14|
                  |L55.82|
000052  4829              LDR      r0,|L55.248|
000054  6800              LDR      r0,[r0,#0]            ;988  ; RMP_Cur_Thd
000056  f7fffffe          BL       _RMP_Clr_Rdy
00005a  6921              LDR      r1,[r4,#0x10]         ;989
00005c  f1040210          ADD      r2,r4,#0x10           ;989
000060  4825              LDR      r0,|L55.248|
000062  6800              LDR      r0,[r0,#0]            ;989  ; RMP_Cur_Thd
000064  f7fffffe          BL       RMP_List_Ins
000068  4824              LDR      r0,|L55.252|
00006a  4285              CMP      r5,r0                 ;991
00006c  d20e              BCS      |L55.140|
00006e  4629              MOV      r1,r5                 ;993
000070  4821              LDR      r0,|L55.248|
000072  6800              LDR      r0,[r0,#0]            ;993  ; RMP_Cur_Thd
000074  f7fffffe          BL       _RMP_Dly_Ins
000078  481f              LDR      r0,|L55.248|
00007a  6800              LDR      r0,[r0,#0]            ;994  ; RMP_Cur_Thd
00007c  6980              LDR      r0,[r0,#0x18]         ;994
00007e  f02000ff          BIC      r0,r0,#0xff           ;994
000082  1cc0              ADDS     r0,r0,#3              ;994
000084  491c              LDR      r1,|L55.248|
000086  6809              LDR      r1,[r1,#0]            ;994  ; RMP_Cur_Thd
000088  6188              STR      r0,[r1,#0x18]         ;994
00008a  e008              B        |L55.158|
                  |L55.140|
00008c  481a              LDR      r0,|L55.248|
00008e  6800              LDR      r0,[r0,#0]            ;997  ; RMP_Cur_Thd
000090  6980              LDR      r0,[r0,#0x18]         ;997
000092  f02000ff          BIC      r0,r0,#0xff           ;997
000096  1c80              ADDS     r0,r0,#2              ;997
000098  4917              LDR      r1,|L55.248|
00009a  6809              LDR      r1,[r1,#0]            ;997  ; RMP_Cur_Thd
00009c  6188              STR      r0,[r1,#0x18]         ;997
                  |L55.158|
00009e  4816              LDR      r0,|L55.248|
0000a0  6800              LDR      r0,[r0,#0]            ;999  ; RMP_Cur_Thd
0000a2  6306              STR      r6,[r0,#0x30]         ;999
0000a4  e021              B        |L55.234|
                  |L55.166|
0000a6  e7ff              B        |L55.168|
                  |L55.168|
0000a8  69a0              LDR      r0,[r4,#0x18]         ;1004
0000aa  b2c0              UXTB     r0,r0                 ;1004
0000ac  2804              CMP      r0,#4                 ;1004
0000ae  d003              BEQ      |L55.184|
0000b0  69a0              LDR      r0,[r4,#0x18]         ;1005
0000b2  b2c0              UXTB     r0,r0                 ;1005
0000b4  2805              CMP      r0,#5                 ;1005
0000b6  d113              BNE      |L55.224|
                  |L55.184|
0000b8  69a0              LDR      r0,[r4,#0x18]         ;1008
0000ba  b2c0              UXTB     r0,r0                 ;1008
0000bc  2805              CMP      r0,#5                 ;1008
0000be  d103              BNE      |L55.200|
0000c0  68e1              LDR      r1,[r4,#0xc]          ;1009
0000c2  68a0              LDR      r0,[r4,#8]            ;1009
0000c4  f7fffffe          BL       RMP_List_Del
                  |L55.200|
0000c8  69a0              LDR      r0,[r4,#0x18]         ;1011
0000ca  f02000ff          BIC      r0,r0,#0xff           ;1011
0000ce  1c40              ADDS     r0,r0,#1              ;1011
0000d0  61a0              STR      r0,[r4,#0x18]         ;1011
0000d2  69a0              LDR      r0,[r4,#0x18]         ;1014
0000d4  f4007080          AND      r0,r0,#0x100          ;1014
0000d8  b910              CBNZ     r0,|L55.224|
0000da  4620              MOV      r0,r4                 ;1015
0000dc  f7fffffe          BL       _RMP_Set_Rdy
                  |L55.224|
0000e0  62e6              STR      r6,[r4,#0x2c]         ;1019
0000e2  69a0              LDR      r0,[r4,#0x18]         ;1020
0000e4  f4407000          ORR      r0,r0,#0x200          ;1020
0000e8  61a0              STR      r0,[r4,#0x18]         ;1020
                  |L55.234|
0000ea  f7fffffe          BL       RMP_Unlock_Sched
0000ee  4802              LDR      r0,|L55.248|
0000f0  6800              LDR      r0,[r0,#0]            ;1025  ; RMP_Cur_Thd
0000f2  6b80              LDR      r0,[r0,#0x38]         ;1025
0000f4  e78b              B        |L55.14|
;;;1027   /* End Function:RMP_Thd_Snd **************************************************/
                          ENDP

0000f6  0000              DCW      0x0000
                  |L55.248|
                          DCD      RMP_Cur_Thd
                  |L55.252|
                          DCD      0x000186a0

                          AREA ||i.RMP_Thd_Snd_ISR||, CODE, READONLY, ALIGN=2

                  RMP_Thd_Snd_ISR PROC
;;;1037   ******************************************************************************/
;;;1038   ret_t RMP_Thd_Snd_ISR(volatile struct RMP_Thd* Thread, ptr_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;1039   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1040       /* Check if this thread structure could possibly be in use */
;;;1041       if(Thread==0)
000006  b914              CBNZ     r4,|L56.14|
;;;1042           return RMP_ERR_THD;
000008  f04f30ff          MOV      r0,#0xffffffff
                  |L56.12|
;;;1043       
;;;1044       if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;1045           return RMP_ERR_THD;
;;;1046       
;;;1047       if(RMP_Sched_Locked!=0)
;;;1048           return RMP_ERR_OPER;
;;;1049   
;;;1050       /* See if there are already a value in the mailbox, if there is, we abort */
;;;1051       if((Thread->State&RMP_THD_MBOXFUL)!=0)
;;;1052           return RMP_ERR_OPER;
;;;1053       else
;;;1054       {
;;;1055           /* Mailbox not full. We need to check if the receiver is waiting for us */
;;;1056           if((RMP_THD_STATE(Thread->State)==RMP_THD_RCVBLK)||
;;;1057              (RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY))
;;;1058           {
;;;1059               /* The receiver is blocked, wake it up and return the value */
;;;1060               if(RMP_THD_STATE(Thread->State)==RMP_THD_RCVDLY)
;;;1061                   RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
;;;1062               
;;;1063               RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
;;;1064   
;;;1065               /* Is it suspended? If yes, we can't directly send it running */
;;;1066               if((Thread->State&RMP_THD_SUSPENDED)==0)
;;;1067               {
;;;1068                   _RMP_Set_Rdy(Thread);
;;;1069                   if(Thread->Prio>RMP_Cur_Thd->Prio)
;;;1070                       _RMP_Yield();
;;;1071               }
;;;1072           }
;;;1073           
;;;1074           /* Set the mailbox */
;;;1075           Thread->Mailbox=Data;
;;;1076           Thread->State|=RMP_THD_MBOXFUL;
;;;1077       }
;;;1078   
;;;1079       return 0;
;;;1080   }
00000c  bd70              POP      {r4-r6,pc}
                  |L56.14|
00000e  69a0              LDR      r0,[r4,#0x18]         ;1044
000010  b2c0              UXTB     r0,r0                 ;1044
000012  b910              CBNZ     r0,|L56.26|
000014  f04f30ff          MOV      r0,#0xffffffff        ;1045
000018  e7f8              B        |L56.12|
                  |L56.26|
00001a  481c              LDR      r0,|L56.140|
00001c  6800              LDR      r0,[r0,#0]            ;1047  ; RMP_Sched_Locked
00001e  b110              CBZ      r0,|L56.38|
000020  f06f0004          MVN      r0,#4                 ;1048
000024  e7f2              B        |L56.12|
                  |L56.38|
000026  69a0              LDR      r0,[r4,#0x18]         ;1051
000028  f4007000          AND      r0,r0,#0x200          ;1051
00002c  b110              CBZ      r0,|L56.52|
00002e  f06f0004          MVN      r0,#4                 ;1052
000032  e7eb              B        |L56.12|
                  |L56.52|
000034  69a0              LDR      r0,[r4,#0x18]         ;1056
000036  b2c0              UXTB     r0,r0                 ;1056
000038  2804              CMP      r0,#4                 ;1056
00003a  d003              BEQ      |L56.68|
00003c  69a0              LDR      r0,[r4,#0x18]         ;1057
00003e  b2c0              UXTB     r0,r0                 ;1057
000040  2805              CMP      r0,#5                 ;1057
000042  d11b              BNE      |L56.124|
                  |L56.68|
000044  69a0              LDR      r0,[r4,#0x18]         ;1060
000046  b2c0              UXTB     r0,r0                 ;1060
000048  2805              CMP      r0,#5                 ;1060
00004a  d103              BNE      |L56.84|
00004c  68e1              LDR      r1,[r4,#0xc]          ;1061
00004e  68a0              LDR      r0,[r4,#8]            ;1061
000050  f7fffffe          BL       RMP_List_Del
                  |L56.84|
000054  69a0              LDR      r0,[r4,#0x18]         ;1063
000056  f02000ff          BIC      r0,r0,#0xff           ;1063
00005a  1c40              ADDS     r0,r0,#1              ;1063
00005c  61a0              STR      r0,[r4,#0x18]         ;1063
00005e  69a0              LDR      r0,[r4,#0x18]         ;1066
000060  f4007080          AND      r0,r0,#0x100          ;1066
000064  b950              CBNZ     r0,|L56.124|
000066  4620              MOV      r0,r4                 ;1068
000068  f7fffffe          BL       _RMP_Set_Rdy
00006c  6a60              LDR      r0,[r4,#0x24]         ;1069
00006e  4908              LDR      r1,|L56.144|
000070  6809              LDR      r1,[r1,#0]            ;1069  ; RMP_Cur_Thd
000072  6a49              LDR      r1,[r1,#0x24]         ;1069
000074  4288              CMP      r0,r1                 ;1069
000076  d901              BLS      |L56.124|
000078  f7fffffe          BL       _RMP_Yield
                  |L56.124|
00007c  62e5              STR      r5,[r4,#0x2c]         ;1075
00007e  69a0              LDR      r0,[r4,#0x18]         ;1076
000080  f4407000          ORR      r0,r0,#0x200          ;1076
000084  61a0              STR      r0,[r4,#0x18]         ;1076
000086  2000              MOVS     r0,#0                 ;1079
000088  e7c0              B        |L56.12|
;;;1081   /* End Function:RMP_Thd_Snd_ISR **********************************************/
                          ENDP

00008a  0000              DCW      0x0000
                  |L56.140|
                          DCD      RMP_Sched_Locked
                  |L56.144|
                          DCD      RMP_Cur_Thd

                          AREA ||i.RMP_Thd_Suspend||, CODE, READONLY, ALIGN=1

                  RMP_Thd_Suspend PROC
;;;872    ******************************************************************************/
;;;873    ret_t RMP_Thd_Suspend(volatile struct RMP_Thd* Thread)
000000  b510              PUSH     {r4,lr}
;;;874    {
000002  4604              MOV      r4,r0
;;;875        /* Check if this thread structure could possibly be in use */
;;;876        if(Thread==0)
000004  b914              CBNZ     r4,|L57.12|
;;;877            return RMP_ERR_THD;
000006  f04f30ff          MOV      r0,#0xffffffff
                  |L57.10|
;;;878        
;;;879        RMP_Lock_Sched();
;;;880        
;;;881        if(RMP_THD_STATE(Thread->State)==RMP_THD_FREE)
;;;882        {
;;;883            RMP_Unlock_Sched();
;;;884            return RMP_ERR_THD;
;;;885        }
;;;886        
;;;887        /* Suspend it */
;;;888        if((Thread->State&RMP_THD_SUSPENDED)!=0)
;;;889        {
;;;890            RMP_Unlock_Sched();
;;;891            return RMP_ERR_STATE;
;;;892        }
;;;893        /* Mark this as suspended */
;;;894        Thread->State|=RMP_THD_SUSPENDED;
;;;895        /* Only when it is running do we clear this */
;;;896        if(RMP_THD_STATE(Thread->State)==RMP_THD_RUNNING)
;;;897            _RMP_Clr_Rdy(Thread);
;;;898        
;;;899        RMP_Unlock_Sched();
;;;900    
;;;901        return 0;
;;;902    }
00000a  bd10              POP      {r4,pc}
                  |L57.12|
00000c  f7fffffe          BL       RMP_Lock_Sched
000010  69a0              LDR      r0,[r4,#0x18]         ;881
000012  b2c0              UXTB     r0,r0                 ;881
000014  b920              CBNZ     r0,|L57.32|
000016  f7fffffe          BL       RMP_Unlock_Sched
00001a  f04f30ff          MOV      r0,#0xffffffff        ;884
00001e  e7f4              B        |L57.10|
                  |L57.32|
000020  69a0              LDR      r0,[r4,#0x18]         ;888
000022  f4007080          AND      r0,r0,#0x100          ;888
000026  b120              CBZ      r0,|L57.50|
000028  f7fffffe          BL       RMP_Unlock_Sched
00002c  f06f0003          MVN      r0,#3                 ;891
000030  e7eb              B        |L57.10|
                  |L57.50|
000032  69a0              LDR      r0,[r4,#0x18]         ;894
000034  f4407080          ORR      r0,r0,#0x100          ;894
000038  61a0              STR      r0,[r4,#0x18]         ;894
00003a  69a0              LDR      r0,[r4,#0x18]         ;896
00003c  b2c0              UXTB     r0,r0                 ;896
00003e  2801              CMP      r0,#1                 ;896
000040  d102              BNE      |L57.72|
000042  4620              MOV      r0,r4                 ;897
000044  f7fffffe          BL       _RMP_Clr_Rdy
                  |L57.72|
000048  f7fffffe          BL       RMP_Unlock_Sched
00004c  2000              MOVS     r0,#0                 ;901
00004e  e7dc              B        |L57.10|
;;;903    /* End Function:RMP_Thd_Suspend **********************************************/
                          ENDP


                          AREA ||i.RMP_Tick_Hook||, CODE, READONLY, ALIGN=1

                  RMP_Tick_Hook PROC
;;;1576   #if(RMP_USE_HOOKS==RMP_FALSE)
;;;1577   void RMP_Tick_Hook(ptr_t Ticks)
000000  bf00              NOP      
;;;1578   {
;;;1579       Ticks=Ticks;
;;;1580       return;
;;;1581   }
000002  4770              BX       lr
;;;1582   #endif
                          ENDP


                          AREA ||i.RMP_Unlock_Sched||, CODE, READONLY, ALIGN=2

                  RMP_Unlock_Sched PROC
;;;359    ******************************************************************************/
;;;360    void RMP_Unlock_Sched(void)
000000  b510              PUSH     {r4,lr}
;;;361    {
;;;362        if(RMP_Sched_Lock_Cnt==1)
000002  4811              LDR      r0,|L59.72|
000004  6800              LDR      r0,[r0,#0]  ; RMP_Sched_Lock_Cnt
000006  2801              CMP      r0,#1
000008  d110              BNE      |L59.44|
;;;363        {
;;;364            /* Clear the count before enabling */
;;;365            RMP_Sched_Lock_Cnt=0;
00000a  2000              MOVS     r0,#0
00000c  490e              LDR      r1,|L59.72|
00000e  6008              STR      r0,[r1,#0]  ; RMP_Sched_Lock_Cnt
;;;366            RMP_Sched_Locked=0;
000010  490e              LDR      r1,|L59.76|
000012  6008              STR      r0,[r1,#0]  ; RMP_Sched_Locked
;;;367            /* Now see if the scheduler scheduling action is pended in the lock-unlock 
;;;368             * period. If yes, perform a schedule now */
;;;369            if(RMP_Sched_Pend!=0)
000014  480e              LDR      r0,|L59.80|
000016  6800              LDR      r0,[r0,#0]  ; RMP_Sched_Pend
000018  b120              CBZ      r0,|L59.36|
;;;370            {
;;;371                /* Reset the count and trigger the context switch */
;;;372                RMP_Sched_Pend=0;
00001a  2000              MOVS     r0,#0
00001c  490c              LDR      r1,|L59.80|
00001e  6008              STR      r0,[r1,#0]  ; RMP_Sched_Pend
;;;373                _RMP_Yield();
000020  f7fffffe          BL       _RMP_Yield
                  |L59.36|
;;;374            }
;;;375            RMP_UNMASK_INT();
000024  2000              MOVS     r0,#0
000026  f7fffffe          BL       RMP_Mask_Int
00002a  e00b              B        |L59.68|
                  |L59.44|
;;;376        }
;;;377        else if(RMP_Sched_Lock_Cnt>1)
00002c  4806              LDR      r0,|L59.72|
00002e  6800              LDR      r0,[r0,#0]  ; RMP_Sched_Lock_Cnt
000030  2801              CMP      r0,#1
000032  d905              BLS      |L59.64|
;;;378            RMP_Sched_Lock_Cnt--;
000034  4804              LDR      r0,|L59.72|
000036  6800              LDR      r0,[r0,#0]  ; RMP_Sched_Lock_Cnt
000038  1e40              SUBS     r0,r0,#1
00003a  4903              LDR      r1,|L59.72|
00003c  6008              STR      r0,[r1,#0]  ; RMP_Sched_Lock_Cnt
00003e  e001              B        |L59.68|
                  |L59.64|
;;;379        /* Trying to unlock a scheduler that is not locked */
;;;380        else
;;;381            while(1);
000040  bf00              NOP      
                  |L59.66|
000042  e7fe              B        |L59.66|
                  |L59.68|
;;;382    }
000044  bd10              POP      {r4,pc}
;;;383    /* End Function:RMP_Unlock_Sched *********************************************/
                          ENDP

000046  0000              DCW      0x0000
                  |L59.72|
                          DCD      RMP_Sched_Lock_Cnt
                  |L59.76|
                          DCD      RMP_Sched_Locked
                  |L59.80|
                          DCD      RMP_Sched_Pend

                          AREA ||i.RMP_Yield||, CODE, READONLY, ALIGN=2

                  RMP_Yield PROC
;;;390    ******************************************************************************/
;;;391    void RMP_Yield(void)
000000  b510              PUSH     {r4,lr}
;;;392    {
;;;393        if(RMP_Sched_Locked==0)
000002  4805              LDR      r0,|L60.24|
000004  6800              LDR      r0,[r0,#0]  ; RMP_Sched_Locked
000006  b910              CBNZ     r0,|L60.14|
;;;394        {
;;;395            /* Now see if the scheduler scheduling action is pended in the lock-unlock 
;;;396             * period. If yes, perform a schedule now */
;;;397            _RMP_Yield();
000008  f7fffffe          BL       _RMP_Yield
00000c  e002              B        |L60.20|
                  |L60.14|
;;;398        }
;;;399        else
;;;400            RMP_Sched_Pend=1;
00000e  2001              MOVS     r0,#1
000010  4902              LDR      r1,|L60.28|
000012  6008              STR      r0,[r1,#0]  ; RMP_Sched_Pend
                  |L60.20|
;;;401    }
000014  bd10              POP      {r4,pc}
;;;402    /* End Function:RMP_Yield ****************************************************/
                          ENDP

000016  0000              DCW      0x0000
                  |L60.24|
                          DCD      RMP_Sched_Locked
                  |L60.28|
                          DCD      RMP_Sched_Pend

                          AREA ||i._RMP_Clr_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Clr_Rdy PROC
;;;619    ******************************************************************************/
;;;620    void _RMP_Clr_Rdy(volatile struct RMP_Thd* Thread)
000000  b510              PUSH     {r4,lr}
;;;621    {
000002  4602              MOV      r2,r0
;;;622        /* See if it is the last thread on the priority level */
;;;623        if(Thread->Run_Head.Prev==Thread->Run_Head.Next)
000004  6810              LDR      r0,[r2,#0]
000006  6851              LDR      r1,[r2,#4]
000008  4288              CMP      r0,r1
00000a  d10c              BNE      |L61.38|
;;;624            RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]&=~(((ptr_t)1)<<(Thread->Prio&RMP_WORD_MASK));
00000c  6a51              LDR      r1,[r2,#0x24]
00000e  0949              LSRS     r1,r1,#5
000010  4b0b              LDR      r3,|L61.64|
000012  eb030081          ADD      r0,r3,r1,LSL #2
000016  6801              LDR      r1,[r0,#0]
000018  6a53              LDR      r3,[r2,#0x24]
00001a  f003040f          AND      r4,r3,#0xf
00001e  2301              MOVS     r3,#1
000020  40a3              LSLS     r3,r3,r4
000022  4399              BICS     r1,r1,r3
000024  6001              STR      r1,[r0,#0]
                  |L61.38|
;;;625        
;;;626        /* Insert this into the corresponding runqueue */
;;;627        RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
000026  6851              LDR      r1,[r2,#4]
000028  6810              LDR      r0,[r2,#0]
00002a  f7fffffe          BL       RMP_List_Del
;;;628        
;;;629        /* If it is the current thread, request a context switch */
;;;630        if(Thread==RMP_Cur_Thd)
00002e  4805              LDR      r0,|L61.68|
000030  6800              LDR      r0,[r0,#0]  ; RMP_Cur_Thd
000032  4282              CMP      r2,r0
000034  d102              BNE      |L61.60|
;;;631            RMP_Sched_Pend=1;
000036  2001              MOVS     r0,#1
000038  4903              LDR      r1,|L61.72|
00003a  6008              STR      r0,[r1,#0]  ; RMP_Sched_Pend
                  |L61.60|
;;;632    }
00003c  bd10              POP      {r4,pc}
;;;633    /* End Function:_RMP_Clr_Rdy *************************************************/
                          ENDP

00003e  0000              DCW      0x0000
                  |L61.64|
                          DCD      RMP_Bitmap
                  |L61.68|
                          DCD      RMP_Cur_Thd
                  |L61.72|
                          DCD      RMP_Sched_Pend

                          AREA ||i._RMP_Dly_Ins||, CODE, READONLY, ALIGN=2

                  _RMP_Dly_Ins PROC
;;;642    ******************************************************************************/
;;;643    void _RMP_Dly_Ins(volatile struct RMP_Thd* Thread, ptr_t Slices)
000000  b570              PUSH     {r4-r6,lr}
;;;644    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;645        struct RMP_List* Trav_Ptr;
;;;646        struct RMP_Thd* Trav_Thd;
;;;647        
;;;648        Trav_Ptr=(struct RMP_List*)RMP_Delay.Next;
000006  480d              LDR      r0,|L62.60|
000008  6843              LDR      r3,[r0,#4]  ; RMP_Delay
;;;649        while(Trav_Ptr!=&(RMP_Delay))
00000a  e008              B        |L62.30|
                  |L62.12|
;;;650        {
;;;651            Trav_Thd=RMP_DLY2THD(Trav_Ptr);
00000c  f1a30608          SUB      r6,r3,#8
;;;652            if((Trav_Thd->Timeout-RMP_Tick)>Slices)
000010  490b              LDR      r1,|L62.64|
000012  6ab0              LDR      r0,[r6,#0x28]
000014  6809              LDR      r1,[r1,#0]  ; RMP_Tick
000016  1a40              SUBS     r0,r0,r1
000018  42a8              CMP      r0,r5
00001a  d900              BLS      |L62.30|
;;;653                break;
00001c  e002              B        |L62.36|
                  |L62.30|
00001e  4807              LDR      r0,|L62.60|
000020  4283              CMP      r3,r0                 ;649
000022  d1f3              BNE      |L62.12|
                  |L62.36|
000024  bf00              NOP      
;;;654        }
;;;655    
;;;656        /* Insert this into the list */
;;;657        Thread->Timeout=RMP_Tick+Slices;
000026  4806              LDR      r0,|L62.64|
000028  6800              LDR      r0,[r0,#0]  ; RMP_Tick
00002a  4428              ADD      r0,r0,r5
00002c  62a0              STR      r0,[r4,#0x28]
;;;658        RMP_List_Ins(&Thread->Dly_Head,Trav_Ptr->Prev,Trav_Ptr);
00002e  461a              MOV      r2,r3
000030  f1040008          ADD      r0,r4,#8
000034  6819              LDR      r1,[r3,#0]
000036  f7fffffe          BL       RMP_List_Ins
;;;659    }
00003a  bd70              POP      {r4-r6,pc}
;;;660    /* End Function:_RMP_Dly_Ins *************************************************/
                          ENDP

                  |L62.60|
                          DCD      RMP_Delay
                  |L62.64|
                          DCD      RMP_Tick

                          AREA ||i._RMP_Get_High_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Get_High_Rdy PROC
;;;468    ******************************************************************************/
;;;469    void _RMP_Get_High_Rdy(void)
000000  b510              PUSH     {r4,lr}
;;;470    {
;;;471        cnt_t Count;
;;;472        
;;;473        /* Write the SP value to thread structure */
;;;474        RMP_Cur_Thd->Stack=RMP_Cur_SP;
000002  482d              LDR      r0,|L63.184|
000004  6800              LDR      r0,[r0,#0]  ; RMP_Cur_SP
000006  492d              LDR      r1,|L63.188|
000008  6809              LDR      r1,[r1,#0]  ; RMP_Cur_Thd
00000a  6348              STR      r0,[r1,#0x34]
;;;475        
;;;476        /* Is the scheduler locked on other threads? If yes, we return without doing anything */
;;;477        if(RMP_Sched_Locked!=0)
00000c  482c              LDR      r0,|L63.192|
00000e  6800              LDR      r0,[r0,#0]  ; RMP_Sched_Locked
000010  b100              CBZ      r0,|L63.20|
                  |L63.18|
;;;478            return;
;;;479        
;;;480        if(RMP_Timer_Pend==1)
;;;481        {
;;;482            RMP_Timer_Pend=0;
;;;483            _RMP_Timer_Proc();
;;;484        }
;;;485        
;;;486        RMP_Sched_Pend=0;
;;;487        /* See which one is ready, and pick it */
;;;488        for(Count=RMP_BITMAP_SIZE-1;Count>=0;Count--)
;;;489        {
;;;490            if(RMP_Bitmap[Count]==0)
;;;491                continue;
;;;492            
;;;493            Count=RMP_MSB_Get(RMP_Bitmap[Count])+(Count<<RMP_WORD_ORDER);
;;;494            
;;;495            /* See if the current thread and the next thread are the same. If yes, place the current at the end of the queue */
;;;496            if(RMP_Cur_Thd==(struct RMP_Thd*)(RMP_Run[Count].Next))
;;;497            {
;;;498                RMP_List_Del(RMP_Cur_Thd->Run_Head.Prev, RMP_Cur_Thd->Run_Head.Next);
;;;499                RMP_List_Ins(&(RMP_Cur_Thd->Run_Head),
;;;500                             RMP_Run[RMP_Cur_Thd->Prio].Prev,
;;;501                             &(RMP_Run[RMP_Cur_Thd->Prio]));
;;;502            }
;;;503            
;;;504            /* Replenish timeslices */
;;;505            RMP_Cur_Thd->Slices_Left=RMP_Cur_Thd->Slices;
;;;506            RMP_Cur_Thd=(struct RMP_Thd*)(RMP_Run[Count].Next);
;;;507            break;
;;;508        }
;;;509        
;;;510        /* Load the SP value from thread structure */
;;;511        RMP_Cur_SP=RMP_Cur_Thd->Stack;
;;;512    }
000012  bd10              POP      {r4,pc}
                  |L63.20|
000014  482b              LDR      r0,|L63.196|
000016  6800              LDR      r0,[r0,#0]            ;480  ; RMP_Timer_Pend
000018  2801              CMP      r0,#1                 ;480
00001a  d104              BNE      |L63.38|
00001c  2000              MOVS     r0,#0                 ;482
00001e  4929              LDR      r1,|L63.196|
000020  6008              STR      r0,[r1,#0]            ;482  ; RMP_Timer_Pend
000022  f7fffffe          BL       _RMP_Timer_Proc
                  |L63.38|
000026  2000              MOVS     r0,#0                 ;486
000028  4927              LDR      r1,|L63.200|
00002a  6008              STR      r0,[r1,#0]            ;486  ; RMP_Sched_Pend
00002c  2400              MOVS     r4,#0                 ;488
00002e  e038              B        |L63.162|
                  |L63.48|
000030  4826              LDR      r0,|L63.204|
000032  f8500024          LDR      r0,[r0,r4,LSL #2]     ;490
000036  b900              CBNZ     r0,|L63.58|
000038  e032              B        |L63.160|
                  |L63.58|
00003a  4924              LDR      r1,|L63.204|
00003c  f8510024          LDR      r0,[r1,r4,LSL #2]     ;493
000040  f7fffffe          BL       RMP_MSB_Get
000044  eb001444          ADD      r4,r0,r4,LSL #5       ;493
000048  4821              LDR      r0,|L63.208|
00004a  eb0000c4          ADD      r0,r0,r4,LSL #3       ;496
00004e  6840              LDR      r0,[r0,#4]            ;496
000050  491a              LDR      r1,|L63.188|
000052  6809              LDR      r1,[r1,#0]            ;496  ; RMP_Cur_Thd
000054  4288              CMP      r0,r1                 ;496
000056  d116              BNE      |L63.134|
000058  4a18              LDR      r2,|L63.188|
00005a  6812              LDR      r2,[r2,#0]            ;498  ; RMP_Cur_Thd
00005c  6851              LDR      r1,[r2,#4]            ;498
00005e  4a17              LDR      r2,|L63.188|
000060  6812              LDR      r2,[r2,#0]            ;498  ; RMP_Cur_Thd
000062  6810              LDR      r0,[r2,#0]            ;498
000064  f7fffffe          BL       RMP_List_Del
000068  4814              LDR      r0,|L63.188|
00006a  6800              LDR      r0,[r0,#0]            ;499  ; RMP_Cur_Thd
00006c  6a40              LDR      r0,[r0,#0x24]         ;499
00006e  4b18              LDR      r3,|L63.208|
000070  eb0302c0          ADD      r2,r3,r0,LSL #3       ;499
000074  4811              LDR      r0,|L63.188|
000076  6800              LDR      r0,[r0,#0]            ;499  ; RMP_Cur_Thd
000078  6a40              LDR      r0,[r0,#0x24]         ;499
00007a  f8531030          LDR      r1,[r3,r0,LSL #3]     ;499
00007e  480f              LDR      r0,|L63.188|
000080  6800              LDR      r0,[r0,#0]            ;499  ; RMP_Cur_Thd
000082  f7fffffe          BL       RMP_List_Ins
                  |L63.134|
000086  480d              LDR      r0,|L63.188|
000088  6800              LDR      r0,[r0,#0]            ;505  ; RMP_Cur_Thd
00008a  69c0              LDR      r0,[r0,#0x1c]         ;505
00008c  490b              LDR      r1,|L63.188|
00008e  6809              LDR      r1,[r1,#0]            ;505  ; RMP_Cur_Thd
000090  6208              STR      r0,[r1,#0x20]         ;505
000092  480f              LDR      r0,|L63.208|
000094  eb0000c4          ADD      r0,r0,r4,LSL #3       ;506
000098  6840              LDR      r0,[r0,#4]            ;506
00009a  4908              LDR      r1,|L63.188|
00009c  6008              STR      r0,[r1,#0]            ;506  ; RMP_Cur_Thd
00009e  e002              B        |L63.166|
                  |L63.160|
0000a0  1e64              SUBS     r4,r4,#1              ;488
                  |L63.162|
0000a2  2c00              CMP      r4,#0                 ;488
0000a4  dac4              BGE      |L63.48|
                  |L63.166|
0000a6  bf00              NOP                            ;507
0000a8  4804              LDR      r0,|L63.188|
0000aa  6800              LDR      r0,[r0,#0]            ;511  ; RMP_Cur_Thd
0000ac  6b40              LDR      r0,[r0,#0x34]         ;511
0000ae  4902              LDR      r1,|L63.184|
0000b0  6008              STR      r0,[r1,#0]            ;511  ; RMP_Cur_SP
0000b2  bf00              NOP      
0000b4  e7ad              B        |L63.18|
;;;513    /* End Function:_RMP_Get_High_Rdy ********************************************/
                          ENDP

0000b6  0000              DCW      0x0000
                  |L63.184|
                          DCD      RMP_Cur_SP
                  |L63.188|
                          DCD      RMP_Cur_Thd
                  |L63.192|
                          DCD      RMP_Sched_Locked
                  |L63.196|
                          DCD      RMP_Timer_Pend
                  |L63.200|
                          DCD      RMP_Sched_Pend
                  |L63.204|
                          DCD      RMP_Bitmap
                  |L63.208|
                          DCD      RMP_Run

                          AREA ||i._RMP_Get_Near_Ticks||, CODE, READONLY, ALIGN=2

                  _RMP_Get_Near_Ticks PROC
;;;564    ******************************************************************************/
;;;565    ptr_t _RMP_Get_Near_Ticks(void)
000000  4a0c              LDR      r2,|L64.52|
;;;566    {
;;;567        ptr_t Value;
;;;568        struct RMP_Thd* Thread;
;;;569        
;;;570        /* What is the current thread's timeout value? */
;;;571        Value=RMP_Cur_Thd->Slices_Left;
000002  6812              LDR      r2,[r2,#0]  ; RMP_Cur_Thd
000004  6a10              LDR      r0,[r2,#0x20]
;;;572        
;;;573        /* What is the nearest timer timeout value? */
;;;574        if((&RMP_Delay)!=RMP_Delay.Next)
000006  4a0c              LDR      r2,|L64.56|
000008  6852              LDR      r2,[r2,#4]  ; RMP_Delay
00000a  4b0b              LDR      r3,|L64.56|
00000c  429a              CMP      r2,r3
00000e  d00d              BEQ      |L64.44|
;;;575        {
;;;576            Thread=RMP_DLY2THD(RMP_Delay.Next);
000010  461a              MOV      r2,r3
000012  6852              LDR      r2,[r2,#4]  ; RMP_Delay
000014  f1a20108          SUB      r1,r2,#8
;;;577            /* See if it is nearer - don't worry about the situation that the timer
;;;578             * have overflown, because if that is to happen, it would have been 
;;;579             * already processed by the timeout processing routine just called above. */
;;;580            if((Thread->Timeout-RMP_Tick)<Value)
000018  4b08              LDR      r3,|L64.60|
00001a  6a8a              LDR      r2,[r1,#0x28]
00001c  681b              LDR      r3,[r3,#0]  ; RMP_Tick
00001e  1ad2              SUBS     r2,r2,r3
000020  4282              CMP      r2,r0
000022  d203              BCS      |L64.44|
;;;581                Value=Thread->Timeout-RMP_Tick;
000024  4b05              LDR      r3,|L64.60|
000026  6a8a              LDR      r2,[r1,#0x28]
000028  681b              LDR      r3,[r3,#0]  ; RMP_Tick
00002a  1ad0              SUBS     r0,r2,r3
                  |L64.44|
;;;582        }
;;;583        
;;;584        /* The timer setting is at least 1 tick */
;;;585        if(Value==0)
00002c  b900              CBNZ     r0,|L64.48|
;;;586            Value=1;
00002e  2001              MOVS     r0,#1
                  |L64.48|
;;;587        
;;;588        return Value;
;;;589    }
000030  4770              BX       lr
;;;590    /* End Function:_RMP_Get_Near_Ticks ******************************************/
                          ENDP

000032  0000              DCW      0x0000
                  |L64.52|
                          DCD      RMP_Cur_Thd
                  |L64.56|
                          DCD      RMP_Delay
                  |L64.60|
                          DCD      RMP_Tick

                          AREA ||i._RMP_Mem_Block||, CODE, READONLY, ALIGN=1

                  _RMP_Mem_Block PROC
;;;1839   ******************************************************************************/
;;;1840   void _RMP_Mem_Block(volatile struct RMP_Mem_Head* Addr, ptr_t Size)
000000  460a              MOV      r2,r1
;;;1841   {
;;;1842       volatile struct RMP_Mem_Head* Mem_Head;
;;;1843       
;;;1844       /* Get the big memory block's size and position */
;;;1845       Mem_Head=(struct RMP_Mem_Head*)Addr;
000002  4601              MOV      r1,r0
;;;1846       
;;;1847       /* Initialize the big memory block */
;;;1848       Mem_Head->State=RMP_MEM_FREE;
000004  2300              MOVS     r3,#0
000006  608b              STR      r3,[r1,#8]
;;;1849       Mem_Head->Tail=(struct RMP_Mem_Tail*)(((ptr_t)Mem_Head)+Size-sizeof(struct RMP_Mem_Tail));
000008  188b              ADDS     r3,r1,r2
00000a  1f1b              SUBS     r3,r3,#4
00000c  60cb              STR      r3,[r1,#0xc]
;;;1850       Mem_Head->Tail->Head=Mem_Head;
00000e  68cb              LDR      r3,[r1,#0xc]
000010  6019              STR      r1,[r3,#0]
;;;1851   }
000012  4770              BX       lr
;;;1852   /* End Function:_RMP_Mem_Block ***********************************************/
                          ENDP


                          AREA ||i._RMP_Mem_Del||, CODE, READONLY, ALIGN=1

                  _RMP_Mem_Del PROC
;;;1902   ******************************************************************************/
;;;1903   void _RMP_Mem_Del(volatile void* Pool, volatile struct RMP_Mem_Head* Mem_Head)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1904   {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;1905       cnt_t FLI_Level;
;;;1906       cnt_t SLI_Level;
;;;1907       ptr_t Level;
;;;1908       ptr_t Size;
;;;1909       volatile struct RMP_Mem* Mem;
;;;1910       volatile struct RMP_List* Slot;    
;;;1911       
;;;1912       /* Get the memory pool and block size */
;;;1913       Mem=(volatile struct RMP_Mem*)Pool;
000008  46a8              MOV      r8,r5
;;;1914       Size=(ptr_t)(Mem_Head->Tail)-((ptr_t)Mem_Head)-sizeof(struct RMP_Mem_Head);
00000a  68e0              LDR      r0,[r4,#0xc]
00000c  1b00              SUBS     r0,r0,r4
00000e  f1a00a10          SUB      r10,r0,#0x10
;;;1915       
;;;1916       /* Guarantee the Mem_Size is bigger than 64 or a failure will surely occur here */
;;;1917       FLI_Level=RMP_MSB_Get(Size)-6;
000012  4650              MOV      r0,r10
000014  f7fffffe          BL       RMP_MSB_Get
000018  1f86              SUBS     r6,r0,#6
;;;1918       /* Decide the SLI level directly from the FLI level */
;;;1919       SLI_Level=(Size>>(FLI_Level+3))&0x07;
00001a  1cf0              ADDS     r0,r6,#3
00001c  fa2af000          LSR      r0,r10,r0
000020  f0000907          AND      r9,r0,#7
;;;1920       Level=(FLI_Level<<3)+SLI_Level;
000024  eb0907c6          ADD      r7,r9,r6,LSL #3
;;;1921       /* Get the slot */
;;;1922       Slot=&(Mem->Table[RMP_MEM_POS(FLI_Level,SLI_Level)]);
000028  eb0901c6          ADD      r1,r9,r6,LSL #3
00002c  f1080028          ADD      r0,r8,#0x28
000030  eb000bc1          ADD      r11,r0,r1,LSL #3
;;;1923      
;;;1924       RMP_List_Del(Mem_Head->Head.Prev,Mem_Head->Head.Next);
000034  6861              LDR      r1,[r4,#4]
000036  6820              LDR      r0,[r4,#0]
000038  f7fffffe          BL       RMP_List_Del
;;;1925   
;;;1926       /* See if there are any blocks in the level, equal means no. So
;;;1927        * what we deleted is the last block */
;;;1928       if(Slot==Slot->Next)
00003c  f8db0004          LDR      r0,[r11,#4]
000040  4558              CMP      r0,r11
000042  d10e              BNE      |L66.98|
;;;1929       {
;;;1930           /* Clear the corresponding bit in the TLSF bitmap */
;;;1931           Mem->Bitmap[Level>>RMP_WORD_ORDER]&=~(1<<(Level&RMP_WORD_MASK));
000044  0979              LSRS     r1,r7,#5
000046  f1080014          ADD      r0,r8,#0x14
00004a  f8500021          LDR      r0,[r0,r1,LSL #2]
00004e  f007020f          AND      r2,r7,#0xf
000052  2101              MOVS     r1,#1
000054  4091              LSLS     r1,r1,r2
000056  4388              BICS     r0,r0,r1
000058  097a              LSRS     r2,r7,#5
00005a  f1080114          ADD      r1,r8,#0x14
00005e  f8410022          STR      r0,[r1,r2,LSL #2]
                  |L66.98|
;;;1932       }
;;;1933   }
000062  e8bd9ff0          POP      {r4-r12,pc}
;;;1934   /* End Function:_RMP_Mem_Del *************************************************/
                          ENDP


                          AREA ||i._RMP_Mem_Ins||, CODE, READONLY, ALIGN=1

                  _RMP_Mem_Ins PROC
;;;1861   ******************************************************************************/
;;;1862   void _RMP_Mem_Ins(volatile void* Pool, volatile struct RMP_Mem_Head* Mem_Head)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1863   {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
;;;1864       cnt_t FLI_Level;
;;;1865       cnt_t SLI_Level;
;;;1866       ptr_t Level;
;;;1867       ptr_t Size;
;;;1868       volatile struct RMP_Mem* Mem;
;;;1869       volatile struct RMP_List* Slot;
;;;1870       
;;;1871       /* Get the memory pool and block size */
;;;1872       Mem=(volatile struct RMP_Mem*)Pool;
000008  46b1              MOV      r9,r6
;;;1873       Size=(ptr_t)(Mem_Head->Tail)-((ptr_t)Mem_Head)-sizeof(struct RMP_Mem_Head);
00000a  68e0              LDR      r0,[r4,#0xc]
00000c  1b00              SUBS     r0,r0,r4
00000e  f1a00b10          SUB      r11,r0,#0x10
;;;1874   
;;;1875       /* Guarantee the Mem_Size is bigger than 64 or a failure will surely occur here */
;;;1876       FLI_Level=RMP_MSB_Get(Size)-6;
000012  4658              MOV      r0,r11
000014  f7fffffe          BL       RMP_MSB_Get
000018  1f87              SUBS     r7,r0,#6
;;;1877       /* Decide the SLI level directly from the FLI level */
;;;1878       SLI_Level=(Size>>(FLI_Level+3))&0x07;
00001a  1cf8              ADDS     r0,r7,#3
00001c  fa2bf000          LSR      r0,r11,r0
000020  f0000a07          AND      r10,r0,#7
;;;1879       Level=(FLI_Level<<3)+SLI_Level;
000024  eb0a08c7          ADD      r8,r10,r7,LSL #3
;;;1880       /* Get the slot */
;;;1881       Slot=&(Mem->Table[RMP_MEM_POS(FLI_Level,SLI_Level)]);
000028  eb0a01c7          ADD      r1,r10,r7,LSL #3
00002c  f1090028          ADD      r0,r9,#0x28
000030  eb0005c1          ADD      r5,r0,r1,LSL #3
;;;1882   
;;;1883       /* See if there are any blocks in the level, equal means no. So what we inserted is the first block */
;;;1884       if(Slot==Slot->Next)
000034  6868              LDR      r0,[r5,#4]
000036  42a8              CMP      r0,r5
000038  d110              BNE      |L67.92|
;;;1885       {
;;;1886           /* Set the corresponding bit in the TLSF bitmap */
;;;1887           Mem->Bitmap[Level>>RMP_WORD_ORDER]|=1<<(Level&RMP_WORD_MASK);
00003a  ea4f1158          LSR      r1,r8,#5
00003e  f1090014          ADD      r0,r9,#0x14
000042  f8500021          LDR      r0,[r0,r1,LSL #2]
000046  f008020f          AND      r2,r8,#0xf
00004a  2101              MOVS     r1,#1
00004c  4091              LSLS     r1,r1,r2
00004e  4308              ORRS     r0,r0,r1
000050  ea4f1258          LSR      r2,r8,#5
000054  f1090114          ADD      r1,r9,#0x14
000058  f8410022          STR      r0,[r1,r2,LSL #2]
                  |L67.92|
;;;1888       }
;;;1889   
;;;1890       /* Insert the node now */
;;;1891       RMP_List_Ins(&(Mem_Head->Head), Slot, Slot->Next);
00005c  686a              LDR      r2,[r5,#4]
00005e  4629              MOV      r1,r5
000060  4620              MOV      r0,r4
000062  f7fffffe          BL       RMP_List_Ins
;;;1892   }
000066  e8bd9ff0          POP      {r4-r12,pc}
;;;1893   /* End Function:_RMP_Mem_Ins *************************************************/
                          ENDP


                          AREA ||i._RMP_Mem_Search||, CODE, READONLY, ALIGN=1

                  _RMP_Mem_Search PROC
;;;1944   ******************************************************************************/
;;;1945   ret_t _RMP_Mem_Search(volatile void* Pool, ptr_t Size, cnt_t* FLI_Level, cnt_t* SLI_Level)
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;1946   {
000004  4682              MOV      r10,r0
000006  460f              MOV      r7,r1
000008  4693              MOV      r11,r2
;;;1947       cnt_t FLI_Level_Temp;
;;;1948       cnt_t SLI_Level_Temp;
;;;1949       cnt_t Level;
;;;1950       ptr_t LSB;
;;;1951       volatile struct RMP_Mem* Mem;
;;;1952   
;;;1953       /* Make sure that it is bigger than 64. 64=2^6 */
;;;1954       FLI_Level_Temp=RMP_MSB_Get(Size)-6;
00000a  4638              MOV      r0,r7
00000c  f7fffffe          BL       RMP_MSB_Get
000010  1f85              SUBS     r5,r0,#6
;;;1955       
;;;1956       /* Decide the SLI level directly from the FLI level. We plus the number by one here
;;;1957        * so that we can avoid the list search. However, when the allocated memory is just
;;;1958        * an order of 2, then we do not need to jump to the next level and can fit directly */
;;;1959       if(((cnt_t)Size)==((1<<6)<<FLI_Level_Temp))
000012  2040              MOVS     r0,#0x40
000014  40a8              LSLS     r0,r0,r5
000016  42b8              CMP      r0,r7
000018  d105              BNE      |L68.38|
;;;1960           SLI_Level_Temp=(Size>>(FLI_Level_Temp+3))&0x07;
00001a  1ce8              ADDS     r0,r5,#3
00001c  fa27f000          LSR      r0,r7,r0
000020  f0000907          AND      r9,r0,#7
000024  e00c              B        |L68.64|
                  |L68.38|
;;;1961       else
;;;1962       {
;;;1963           SLI_Level_Temp=((Size>>(FLI_Level_Temp+3))&0x07)+1;
000026  1ce8              ADDS     r0,r5,#3
000028  fa27f000          LSR      r0,r7,r0
00002c  f0000007          AND      r0,r0,#7
000030  f1000901          ADD      r9,r0,#1
;;;1964           
;;;1965           /* If the SLI level is the largest of the SLI level, then jump to the next FLI level */
;;;1966           if(SLI_Level_Temp==8)
000034  f1b90f08          CMP      r9,#8
000038  d102              BNE      |L68.64|
;;;1967           {
;;;1968               FLI_Level_Temp+=1;
00003a  1c6d              ADDS     r5,r5,#1
;;;1969               SLI_Level_Temp=0;
00003c  f04f0900          MOV      r9,#0
                  |L68.64|
;;;1970           }
;;;1971       }
;;;1972       
;;;1973       /* Check if the FLI level is over the boundary */
;;;1974       Mem=(volatile struct RMP_Mem*)Pool;
000040  46d0              MOV      r8,r10
;;;1975       if((ptr_t)FLI_Level_Temp>=Mem->FLI_Num)
000042  f8d80008          LDR      r0,[r8,#8]
000046  42a8              CMP      r0,r5
000048  d804              BHI      |L68.84|
;;;1976           return -1;
00004a  f04f30ff          MOV      r0,#0xffffffff
                  |L68.78|
;;;1977       
;;;1978       /* Try to find one position on this processor word level */
;;;1979       Level=(FLI_Level_Temp<<3)+SLI_Level_Temp;
;;;1980       LSB=RMP_LSB_Get(Mem->Bitmap[Level>>RMP_WORD_ORDER]>>(Level&RMP_WORD_MASK));
;;;1981       /* If there's at least one block that matches the query, return the level */
;;;1982       if(LSB<32)
;;;1983       {
;;;1984           Level=(Level&(~RMP_WORD_MASK))+LSB+(Level&RMP_WORD_MASK);
;;;1985           *FLI_Level=Level>>3;
;;;1986           *SLI_Level=Level&0x07;
;;;1987           return 0;
;;;1988       }
;;;1989       /* No one exactly fits */
;;;1990       else
;;;1991       {
;;;1992           /* From the next word, query one by one */
;;;1993           for(Level=(Level>>RMP_WORD_ORDER)+1;Level<5;Level++)
;;;1994           {
;;;1995               /* if the level has blocks of one FLI level */
;;;1996               if(Mem->Bitmap[Level]!=0)
;;;1997               {
;;;1998                   /* Find the actual level */ 
;;;1999                   LSB=RMP_LSB_Get(Mem->Bitmap[Level]);
;;;2000                   *FLI_Level=((Level<<RMP_WORD_ORDER)+LSB)>>3;
;;;2001                   *SLI_Level=LSB&0x07;
;;;2002                   return 0;
;;;2003               }
;;;2004           }
;;;2005       }
;;;2006   
;;;2007       /* Search failed */
;;;2008       return -1;
;;;2009   }
00004e  b004              ADD      sp,sp,#0x10
000050  e8bd9ff0          POP      {r4-r12,pc}
                  |L68.84|
000054  eb0904c5          ADD      r4,r9,r5,LSL #3       ;1979
000058  1162              ASRS     r2,r4,#5              ;1980
00005a  f1080114          ADD      r1,r8,#0x14           ;1980
00005e  f8511022          LDR      r1,[r1,r2,LSL #2]     ;1980
000062  f004020f          AND      r2,r4,#0xf            ;1980
000066  fa21f002          LSR      r0,r1,r2              ;1980
00006a  f7fffffe          BL       RMP_LSB_Get
00006e  4606              MOV      r6,r0                 ;1980
000070  2e20              CMP      r6,#0x20              ;1982
000072  d20e              BCS      |L68.146|
000074  f024000f          BIC      r0,r4,#0xf            ;1984
000078  4430              ADD      r0,r0,r6              ;1984
00007a  f004010f          AND      r1,r4,#0xf            ;1984
00007e  1844              ADDS     r4,r0,r1              ;1984
000080  10e0              ASRS     r0,r4,#3              ;1985
000082  f8cb0000          STR      r0,[r11,#0]           ;1985
000086  f0040107          AND      r1,r4,#7              ;1986
00008a  9803              LDR      r0,[sp,#0xc]          ;1986
00008c  6001              STR      r1,[r0,#0]            ;1986
00008e  2000              MOVS     r0,#0                 ;1987
000090  e7dd              B        |L68.78|
                  |L68.146|
000092  2001              MOVS     r0,#1                 ;1993
000094  eb001464          ADD      r4,r0,r4,ASR #5       ;1993
000098  e017              B        |L68.202|
                  |L68.154|
00009a  f1080014          ADD      r0,r8,#0x14           ;1996
00009e  f8500024          LDR      r0,[r0,r4,LSL #2]     ;1996
0000a2  b188              CBZ      r0,|L68.200|
0000a4  f1080114          ADD      r1,r8,#0x14           ;1999
0000a8  f8510024          LDR      r0,[r1,r4,LSL #2]     ;1999
0000ac  f7fffffe          BL       RMP_LSB_Get
0000b0  4606              MOV      r6,r0                 ;1999
0000b2  eb061044          ADD      r0,r6,r4,LSL #5       ;2000
0000b6  08c0              LSRS     r0,r0,#3              ;2000
0000b8  f8cb0000          STR      r0,[r11,#0]           ;2000
0000bc  f0060107          AND      r1,r6,#7              ;2001
0000c0  9803              LDR      r0,[sp,#0xc]          ;2001
0000c2  6001              STR      r1,[r0,#0]            ;2001
0000c4  2000              MOVS     r0,#0                 ;2002
0000c6  e7c2              B        |L68.78|
                  |L68.200|
0000c8  1c64              ADDS     r4,r4,#1              ;1993
                  |L68.202|
0000ca  2c05              CMP      r4,#5                 ;1993
0000cc  dbe5              BLT      |L68.154|
0000ce  f04f30ff          MOV      r0,#0xffffffff        ;2008
0000d2  e7bc              B        |L68.78|
;;;2010   /* End Function:_RMP_Mem_Search **********************************************/
                          ENDP


                          AREA ||i._RMP_Set_Rdy||, CODE, READONLY, ALIGN=2

                  _RMP_Set_Rdy PROC
;;;599    ******************************************************************************/
;;;600    void _RMP_Set_Rdy(volatile struct RMP_Thd* Thread)
000000  b510              PUSH     {r4,lr}
;;;601    {
000002  4603              MOV      r3,r0
;;;602        /* Insert this into the corresponding runqueue */
;;;603        RMP_List_Ins(&(Thread->Run_Head),RMP_Run[Thread->Prio].Prev,&(RMP_Run[Thread->Prio]));
000004  6a58              LDR      r0,[r3,#0x24]
000006  4c10              LDR      r4,|L69.72|
000008  eb0402c0          ADD      r2,r4,r0,LSL #3
00000c  6a58              LDR      r0,[r3,#0x24]
00000e  f8541030          LDR      r1,[r4,r0,LSL #3]
000012  4618              MOV      r0,r3
000014  f7fffffe          BL       RMP_List_Ins
;;;604        /* Set this runlevel as active */
;;;605        RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]|=((ptr_t)1)<<(Thread->Prio&RMP_WORD_MASK);
000018  6a59              LDR      r1,[r3,#0x24]
00001a  0949              LSRS     r1,r1,#5
00001c  4a0b              LDR      r2,|L69.76|
00001e  eb020081          ADD      r0,r2,r1,LSL #2
000022  6801              LDR      r1,[r0,#0]
000024  6a5a              LDR      r2,[r3,#0x24]
000026  f002040f          AND      r4,r2,#0xf
00002a  2201              MOVS     r2,#1
00002c  40a2              LSLS     r2,r2,r4
00002e  4311              ORRS     r1,r1,r2
000030  6001              STR      r1,[r0,#0]
;;;606        
;;;607        /* Compare this with the current one to see if we need a context switch */
;;;608        if(Thread->Prio>RMP_Cur_Thd->Prio)
000032  6a58              LDR      r0,[r3,#0x24]
000034  4906              LDR      r1,|L69.80|
000036  6809              LDR      r1,[r1,#0]  ; RMP_Cur_Thd
000038  6a49              LDR      r1,[r1,#0x24]
00003a  4288              CMP      r0,r1
00003c  d902              BLS      |L69.68|
;;;609            RMP_Sched_Pend=1;
00003e  2001              MOVS     r0,#1
000040  4904              LDR      r1,|L69.84|
000042  6008              STR      r0,[r1,#0]  ; RMP_Sched_Pend
                  |L69.68|
;;;610    }
000044  bd10              POP      {r4,pc}
;;;611    /* End Function:_RMP_Set_Rdy *************************************************/
                          ENDP

000046  0000              DCW      0x0000
                  |L69.72|
                          DCD      RMP_Run
                  |L69.76|
                          DCD      RMP_Bitmap
                  |L69.80|
                          DCD      RMP_Cur_Thd
                  |L69.84|
                          DCD      RMP_Sched_Pend

                          AREA ||i._RMP_Tick_Handler||, CODE, READONLY, ALIGN=2

                  _RMP_Tick_Handler PROC
;;;520    ******************************************************************************/
;;;521    void _RMP_Tick_Handler(ptr_t Ticks)
000000  b570              PUSH     {r4-r6,lr}
;;;522    {
000002  4604              MOV      r4,r0
;;;523        struct RMP_Thd* Thread;
;;;524        /* Increase the timestamp as always */
;;;525        RMP_Tick+=Ticks;
000004  481c              LDR      r0,|L70.120|
000006  6800              LDR      r0,[r0,#0]  ; RMP_Tick
000008  4420              ADD      r0,r0,r4
00000a  491b              LDR      r1,|L70.120|
00000c  6008              STR      r0,[r1,#0]  ; RMP_Tick
;;;526    #if(RMP_USE_HOOKS==RMP_TRUE)
;;;527        RMP_Tick_Hook(Ticks);
;;;528    #endif
;;;529        /* See if the current thread expired. If yes, trigger a scheduler event */
;;;530        if(Ticks>=RMP_Cur_Thd->Slices_Left)
00000e  481b              LDR      r0,|L70.124|
000010  6800              LDR      r0,[r0,#0]  ; RMP_Cur_Thd
000012  6a00              LDR      r0,[r0,#0x20]
000014  42a0              CMP      r0,r4
000016  d803              BHI      |L70.32|
;;;531            RMP_Sched_Pend=1;
000018  2001              MOVS     r0,#1
00001a  4919              LDR      r1,|L70.128|
00001c  6008              STR      r0,[r1,#0]  ; RMP_Sched_Pend
00001e  e006              B        |L70.46|
                  |L70.32|
;;;532        else
;;;533            RMP_Cur_Thd->Slices_Left-=Ticks;
000020  4916              LDR      r1,|L70.124|
000022  6809              LDR      r1,[r1,#0]  ; RMP_Cur_Thd
000024  f1010020          ADD      r0,r1,#0x20
000028  6a09              LDR      r1,[r1,#0x20]
00002a  1b09              SUBS     r1,r1,r4
00002c  6001              STR      r1,[r0,#0]
                  |L70.46|
;;;534        
;;;535        /* Is the scheduler locked? If yes, we cannot process timer events here and will have to pend them */
;;;536        if((&RMP_Delay)!=RMP_Delay.Next)
00002e  4815              LDR      r0,|L70.132|
000030  6840              LDR      r0,[r0,#4]  ; RMP_Delay
000032  4914              LDR      r1,|L70.132|
000034  4288              CMP      r0,r1
000036  d013              BEQ      |L70.96|
;;;537        {
;;;538            Thread=RMP_DLY2THD(RMP_Delay.Next);
000038  4608              MOV      r0,r1
00003a  6840              LDR      r0,[r0,#4]  ; RMP_Delay
00003c  f1a00508          SUB      r5,r0,#8
;;;539            /* If the value is less than this, then it means that the time have
;;;540             * already passed and we have to process this */
;;;541            if((RMP_Tick-Thread->Timeout)<=(RMP_ALLBITS>>1))
000040  490d              LDR      r1,|L70.120|
000042  6aa8              LDR      r0,[r5,#0x28]
000044  6809              LDR      r1,[r1,#0]  ; RMP_Tick
000046  1a08              SUBS     r0,r1,r0
000048  f1b04f00          CMP      r0,#0x80000000
00004c  d208              BCS      |L70.96|
;;;542            {
;;;543                /* If scheduler locked, we pend the processing until it is unlocked */
;;;544                if(RMP_Sched_Locked!=0)
00004e  480e              LDR      r0,|L70.136|
000050  6800              LDR      r0,[r0,#0]  ; RMP_Sched_Locked
000052  b118              CBZ      r0,|L70.92|
;;;545                    RMP_Timer_Pend=1;
000054  2001              MOVS     r0,#1
000056  490d              LDR      r1,|L70.140|
000058  6008              STR      r0,[r1,#0]  ; RMP_Timer_Pend
00005a  e001              B        |L70.96|
                  |L70.92|
;;;546                else
;;;547                    _RMP_Timer_Proc();
00005c  f7fffffe          BL       _RMP_Timer_Proc
                  |L70.96|
;;;548            }
;;;549        }
;;;550        
;;;551        if((RMP_Sched_Locked==0)&&(RMP_Sched_Pend!=0))
000060  4809              LDR      r0,|L70.136|
000062  6800              LDR      r0,[r0,#0]  ; RMP_Sched_Locked
000064  b938              CBNZ     r0,|L70.118|
000066  4806              LDR      r0,|L70.128|
000068  6800              LDR      r0,[r0,#0]  ; RMP_Sched_Pend
00006a  b120              CBZ      r0,|L70.118|
;;;552        {
;;;553            RMP_Sched_Pend=0;
00006c  2000              MOVS     r0,#0
00006e  4904              LDR      r1,|L70.128|
000070  6008              STR      r0,[r1,#0]  ; RMP_Sched_Pend
;;;554            _RMP_Yield();
000072  f7fffffe          BL       _RMP_Yield
                  |L70.118|
;;;555        }
;;;556    }
000076  bd70              POP      {r4-r6,pc}
;;;557    /* End Function:_RMP_Tick_Handler ********************************************/
                          ENDP

                  |L70.120|
                          DCD      RMP_Tick
                  |L70.124|
                          DCD      RMP_Cur_Thd
                  |L70.128|
                          DCD      RMP_Sched_Pend
                  |L70.132|
                          DCD      RMP_Delay
                  |L70.136|
                          DCD      RMP_Sched_Locked
                  |L70.140|
                          DCD      RMP_Timer_Pend

                          AREA ||i._RMP_Timer_Proc||, CODE, READONLY, ALIGN=2

                  _RMP_Timer_Proc PROC
;;;409    ******************************************************************************/
;;;410    void _RMP_Timer_Proc(void)
000000  b510              PUSH     {r4,lr}
;;;411    {
;;;412        struct RMP_Thd* Thread;
;;;413        
;;;414        /* Process the timer events, if there are any of them */
;;;415        while((&RMP_Delay)!=RMP_Delay.Next)
000002  e055              B        |L71.176|
                  |L71.4|
;;;416        {
;;;417            Thread=RMP_DLY2THD(RMP_Delay.Next);
000004  482e              LDR      r0,|L71.192|
000006  6840              LDR      r0,[r0,#4]  ; RMP_Delay
000008  f1a00308          SUB      r3,r0,#8
;;;418            /* If the value is more than this, then it means that the time have
;;;419             * already passed and we have to process this */
;;;420            if((RMP_Tick-Thread->Timeout)>(RMP_ALLBITS>>1))
00000c  492d              LDR      r1,|L71.196|
00000e  6a98              LDR      r0,[r3,#0x28]
000010  6809              LDR      r1,[r1,#0]  ; RMP_Tick
000012  1a08              SUBS     r0,r1,r0
000014  f1b04f00          CMP      r0,#0x80000000
000018  d300              BCC      |L71.28|
;;;421                break;
00001a  e04e              B        |L71.186|
                  |L71.28|
;;;422            
;;;423            /* This thread should be processed */
;;;424            RMP_List_Del(Thread->Dly_Head.Prev,Thread->Dly_Head.Next);
00001c  e9d30102          LDRD     r0,r1,[r3,#8]
000020  f7fffffe          BL       RMP_List_Del
;;;425            switch(RMP_THD_STATE(Thread->State))
000024  7e18              LDRB     r0,[r3,#0x18]
000026  2803              CMP      r0,#3
000028  d006              BEQ      |L71.56|
00002a  2805              CMP      r0,#5
00002c  d00d              BEQ      |L71.74|
00002e  2806              CMP      r0,#6
000030  d00f              BEQ      |L71.82|
000032  2808              CMP      r0,#8
000034  d10e              BNE      |L71.84|
000036  e000              B        |L71.58|
                  |L71.56|
;;;426            {
;;;427                case RMP_THD_SNDDLY:
;;;428                case RMP_THD_SEMDLY:
000038  bf00              NOP      
                  |L71.58|
;;;429                {
;;;430                    RMP_List_Del(Thread->Run_Head.Prev,Thread->Run_Head.Next);
00003a  e9d30100          LDRD     r0,r1,[r3,#0]
00003e  f7fffffe          BL       RMP_List_Del
;;;431                    Thread->Retval=RMP_ERR_OPER;
000042  f06f0004          MVN      r0,#4
000046  6398              STR      r0,[r3,#0x38]
;;;432                    break;
000048  e005              B        |L71.86|
                  |L71.74|
;;;433                }
;;;434                
;;;435                case RMP_THD_RCVDLY:
;;;436                {
;;;437                    Thread->Retval=RMP_ERR_OPER;
00004a  f06f0004          MVN      r0,#4
00004e  6398              STR      r0,[r3,#0x38]
;;;438                    break;
000050  e001              B        |L71.86|
                  |L71.82|
;;;439                }
;;;440                
;;;441                case RMP_THD_DELAYED:break;
000052  e000              B        |L71.86|
                  |L71.84|
;;;442                /* Should not get here */
;;;443                default:break;
000054  bf00              NOP      
                  |L71.86|
000056  bf00              NOP                            ;432
;;;444            }
;;;445    
;;;446            RMP_THD_STATE_SET(Thread->State,RMP_THD_RUNNING);
000058  6998              LDR      r0,[r3,#0x18]
00005a  f02000ff          BIC      r0,r0,#0xff
00005e  1c40              ADDS     r0,r0,#1
000060  6198              STR      r0,[r3,#0x18]
;;;447            /* Is it suspended? If yes, we can't directly set it running */
;;;448            if((Thread->State&RMP_THD_SUSPENDED)==0)
000062  8b18              LDRH     r0,[r3,#0x18]
000064  f4007080          AND      r0,r0,#0x100
000068  bb10              CBNZ     r0,|L71.176|
;;;449            {
;;;450                /* Insert this into the corresponding runqueue */
;;;451                RMP_List_Ins(&(Thread->Run_Head),RMP_Run[Thread->Prio].Prev,&(RMP_Run[Thread->Prio]));
00006a  4c17              LDR      r4,|L71.200|
00006c  6a58              LDR      r0,[r3,#0x24]
00006e  eb0402c0          ADD      r2,r4,r0,LSL #3
000072  f8541030          LDR      r1,[r4,r0,LSL #3]
000076  4618              MOV      r0,r3
000078  f7fffffe          BL       RMP_List_Ins
;;;452                /* Set this runlevel as active */
;;;453                RMP_Bitmap[Thread->Prio>>RMP_WORD_ORDER]|=1<<(Thread->Prio&RMP_WORD_MASK);
00007c  6a58              LDR      r0,[r3,#0x24]
00007e  0940              LSRS     r0,r0,#5
000080  4912              LDR      r1,|L71.204|
000082  f8510020          LDR      r0,[r1,r0,LSL #2]
000086  f8931024          LDRB     r1,[r3,#0x24]
00008a  f001020f          AND      r2,r1,#0xf
00008e  2101              MOVS     r1,#1
000090  4091              LSLS     r1,r1,r2
000092  4308              ORRS     r0,r0,r1
000094  6a59              LDR      r1,[r3,#0x24]
000096  0949              LSRS     r1,r1,#5
000098  4a0c              LDR      r2,|L71.204|
00009a  f8420021          STR      r0,[r2,r1,LSL #2]
;;;454                /* See if we need to pend a scheduling event */
;;;455                if(Thread->Prio>RMP_Cur_Thd->Prio)
00009e  490c              LDR      r1,|L71.208|
0000a0  6a58              LDR      r0,[r3,#0x24]
0000a2  6809              LDR      r1,[r1,#0]  ; RMP_Cur_Thd
0000a4  6a49              LDR      r1,[r1,#0x24]
0000a6  4288              CMP      r0,r1
0000a8  d902              BLS      |L71.176|
;;;456                    RMP_Sched_Pend=1;
0000aa  2001              MOVS     r0,#1
0000ac  4909              LDR      r1,|L71.212|
0000ae  6008              STR      r0,[r1,#0]  ; RMP_Sched_Pend
                  |L71.176|
0000b0  4803              LDR      r0,|L71.192|
0000b2  6840              LDR      r0,[r0,#4]            ;415  ; RMP_Delay
0000b4  4902              LDR      r1,|L71.192|
0000b6  4288              CMP      r0,r1                 ;415
0000b8  d1a4              BNE      |L71.4|
                  |L71.186|
0000ba  bf00              NOP                            ;421
;;;457            }
;;;458        }
;;;459    }
0000bc  bd10              POP      {r4,pc}
;;;460    /* Begin Function:_RMP_Timer_Proc ********************************************/
                          ENDP

0000be  0000              DCW      0x0000
                  |L71.192|
                          DCD      RMP_Delay
                  |L71.196|
                          DCD      RMP_Tick
                  |L71.200|
                          DCD      RMP_Run
                  |L71.204|
                          DCD      RMP_Bitmap
                  |L71.208|
                          DCD      RMP_Cur_Thd
                  |L71.212|
                          DCD      RMP_Sched_Pend

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;1617   ******************************************************************************/
;;;1618   int main(void)
000000  b510              PUSH     {r4,lr}
;;;1619   {
;;;1620       ptr_t Count;
;;;1621       /* Initialize the kernel data structures first */
;;;1622       _RMP_Low_Level_Init();
000002  f7fffffe          BL       _RMP_Low_Level_Init
;;;1623       
;;;1624   #if(RMP_USE_HOOKS==RMP_TRUE)
;;;1625       RMP_Start_Hook();
;;;1626   #endif
;;;1627       
;;;1628       RMP_Tick=0;
000006  2000              MOVS     r0,#0
000008  4925              LDR      r1,|L72.160|
00000a  6008              STR      r0,[r1,#0]  ; RMP_Tick
;;;1629       /* Now initialize the kernel data structures */
;;;1630       RMP_Sched_Lock_Cnt=0;
00000c  4925              LDR      r1,|L72.164|
00000e  6008              STR      r0,[r1,#0]  ; RMP_Sched_Lock_Cnt
;;;1631       RMP_Sched_Locked=0;
000010  4925              LDR      r1,|L72.168|
000012  6008              STR      r0,[r1,#0]  ; RMP_Sched_Locked
;;;1632       RMP_Sched_Pend=0;
000014  4925              LDR      r1,|L72.172|
000016  6008              STR      r0,[r1,#0]  ; RMP_Sched_Pend
;;;1633       RMP_Timer_Pend=0;
000018  4925              LDR      r1,|L72.176|
00001a  6008              STR      r0,[r1,#0]  ; RMP_Timer_Pend
;;;1634       
;;;1635       /* Linked lists */
;;;1636       RMP_List_Crt(&RMP_Delay);
00001c  4825              LDR      r0,|L72.180|
00001e  f7fffffe          BL       RMP_List_Crt
;;;1637       for(Count=0;Count<RMP_MAX_PREEMPT_PRIO;Count++)
000022  2400              MOVS     r4,#0
000024  e005              B        |L72.50|
                  |L72.38|
;;;1638           RMP_List_Crt(&RMP_Run[Count]);
000026  4924              LDR      r1,|L72.184|
000028  eb0100c4          ADD      r0,r1,r4,LSL #3
00002c  f7fffffe          BL       RMP_List_Crt
000030  1c64              ADDS     r4,r4,#1              ;1637
                  |L72.50|
000032  2c20              CMP      r4,#0x20              ;1637
000034  d3f7              BCC      |L72.38|
;;;1639       for(Count=0;Count<RMP_BITMAP_SIZE;Count++)
000036  2400              MOVS     r4,#0
000038  e004              B        |L72.68|
                  |L72.58|
;;;1640           RMP_Bitmap[Count]=0;
00003a  2000              MOVS     r0,#0
00003c  491f              LDR      r1,|L72.188|
00003e  f8410024          STR      r0,[r1,r4,LSL #2]
000042  1c64              ADDS     r4,r4,#1              ;1639
                  |L72.68|
000044  2c00              CMP      r4,#0                 ;1639
000046  d0f8              BEQ      |L72.58|
;;;1641           
;;;1642       /* Now boot into the first thread */
;;;1643       RMP_Clear(&RMP_Init_Thd,sizeof(struct RMP_Thd));
000048  213c              MOVS     r1,#0x3c
00004a  481d              LDR      r0,|L72.192|
00004c  f7fffffe          BL       RMP_Clear
;;;1644       RMP_Init_Thd.Prio=0;
000050  2000              MOVS     r0,#0
000052  491b              LDR      r1,|L72.192|
000054  6248              STR      r0,[r1,#0x24]  ; RMP_Init_Thd
;;;1645       RMP_Init_Thd.Slices=10;
000056  200a              MOVS     r0,#0xa
000058  61c8              STR      r0,[r1,#0x1c]  ; RMP_Init_Thd
;;;1646       RMP_Init_Thd.Slices_Left=10;
00005a  6208              STR      r0,[r1,#0x20]  ; RMP_Init_Thd
;;;1647       RMP_Init_Thd.State=RMP_THD_RUNNING;
00005c  2001              MOVS     r0,#1
00005e  6188              STR      r0,[r1,#0x18]  ; RMP_Init_Thd
;;;1648       RMP_Init_Thd.Stack=RMP_INIT_STACK;
000060  4818              LDR      r0,|L72.196|
000062  6348              STR      r0,[r1,#0x34]  ; RMP_Init_Thd
;;;1649       
;;;1650       /* Initialize sending list */
;;;1651       RMP_List_Crt(&(RMP_Init_Thd.Snd_List));
000064  f1010010          ADD      r0,r1,#0x10
000068  f7fffffe          BL       RMP_List_Crt
;;;1652       
;;;1653       /* Insert this into the corresponding runqueue */
;;;1654       RMP_List_Ins(&(RMP_Init_Thd.Run_Head),RMP_Run[0].Prev,&(RMP_Run[0]));
00006c  4812              LDR      r0,|L72.184|
00006e  6801              LDR      r1,[r0,#0]  ; RMP_Run
000070  4602              MOV      r2,r0
000072  4813              LDR      r0,|L72.192|
000074  f7fffffe          BL       RMP_List_Ins
;;;1655       /* Set this runlevel as active - in fact it is always active */
;;;1656       RMP_Bitmap[0]|=1;
000078  4810              LDR      r0,|L72.188|
00007a  6800              LDR      r0,[r0,#0]  ; RMP_Bitmap
00007c  f0400001          ORR      r0,r0,#1
000080  490e              LDR      r1,|L72.188|
000082  6008              STR      r0,[r1,#0]  ; RMP_Bitmap
;;;1657       
;;;1658       /* Set current thread and stack */
;;;1659       RMP_Cur_Thd=(struct RMP_Thd*)(&RMP_Init_Thd);
000084  480e              LDR      r0,|L72.192|
000086  4910              LDR      r1,|L72.200|
000088  6008              STR      r0,[r1,#0]  ; RMP_Cur_Thd
;;;1660       RMP_Cur_SP=RMP_Init_Thd.Stack;
00008a  6b40              LDR      r0,[r0,#0x34]  ; RMP_Init_Thd
00008c  490f              LDR      r1,|L72.204|
00008e  6008              STR      r0,[r1,#0]  ; RMP_Cur_SP
;;;1661       
;;;1662       /* Now jump to the user function and will never return. Initialization of stack is not needed */
;;;1663       _RMP_Start((ptr_t)RMP_Init, (ptr_t)RMP_Init_Thd.Stack);
000090  480b              LDR      r0,|L72.192|
000092  6b41              LDR      r1,[r0,#0x34]  ; RMP_Init_Thd
000094  480e              LDR      r0,|L72.208|
000096  f7fffffe          BL       _RMP_Start
;;;1664       
;;;1665       return 0;
00009a  2000              MOVS     r0,#0
;;;1666   }
00009c  bd10              POP      {r4,pc}
;;;1667   /* End Function:main *********************************************************/
                          ENDP

00009e  0000              DCW      0x0000
                  |L72.160|
                          DCD      RMP_Tick
                  |L72.164|
                          DCD      RMP_Sched_Lock_Cnt
                  |L72.168|
                          DCD      RMP_Sched_Locked
                  |L72.172|
                          DCD      RMP_Sched_Pend
                  |L72.176|
                          DCD      RMP_Timer_Pend
                  |L72.180|
                          DCD      RMP_Delay
                  |L72.184|
                          DCD      RMP_Run
                  |L72.188|
                          DCD      RMP_Bitmap
                  |L72.192|
                          DCD      RMP_Init_Thd
                  |L72.196|
                          DCD      RMP_Init_Stack+0xbc
                  |L72.200|
                          DCD      RMP_Cur_Thd
                  |L72.204|
                          DCD      RMP_Cur_SP
                  |L72.208|
                          DCD      RMP_Init

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  RMP_Run
                          %        256
                  RMP_Init_Stack
                          %        256
                  RMP_Init_Thd
                          %        60

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  RMP_RBIT_Table
000000  008040c0          DCB      0x00,0x80,0x40,0xc0
000004  20a060e0          DCB      0x20,0xa0,0x60,0xe0
000008  109050d0          DCB      0x10,0x90,0x50,0xd0
00000c  30b070f0          DCB      0x30,0xb0,0x70,0xf0
000010  088848c8          DCB      0x08,0x88,0x48,0xc8
000014  28a868e8          DCB      0x28,0xa8,0x68,0xe8
000018  189858d8          DCB      0x18,0x98,0x58,0xd8
00001c  38b878f8          DCB      0x38,0xb8,0x78,0xf8
000020  048444c4          DCB      0x04,0x84,0x44,0xc4
000024  24a464e4          DCB      0x24,0xa4,0x64,0xe4
000028  149454d4          DCB      0x14,0x94,0x54,0xd4
00002c  34b474f4          DCB      0x34,0xb4,0x74,0xf4
000030  0c8c4ccc          DCB      0x0c,0x8c,0x4c,0xcc
000034  2cac6cec          DCB      0x2c,0xac,0x6c,0xec
000038  1c9c5cdc          DCB      0x1c,0x9c,0x5c,0xdc
00003c  3cbc7cfc          DCB      0x3c,0xbc,0x7c,0xfc
000040  028242c2          DCB      0x02,0x82,0x42,0xc2
000044  22a262e2          DCB      0x22,0xa2,0x62,0xe2
000048  129252d2          DCB      0x12,0x92,0x52,0xd2
00004c  32b272f2          DCB      0x32,0xb2,0x72,0xf2
000050  0a8a4aca          DCB      0x0a,0x8a,0x4a,0xca
000054  2aaa6aea          DCB      0x2a,0xaa,0x6a,0xea
000058  1a9a5ada          DCB      0x1a,0x9a,0x5a,0xda
00005c  3aba7afa          DCB      0x3a,0xba,0x7a,0xfa
000060  068646c6          DCB      0x06,0x86,0x46,0xc6
000064  26a666e6          DCB      0x26,0xa6,0x66,0xe6
000068  169656d6          DCB      0x16,0x96,0x56,0xd6
00006c  36b676f6          DCB      0x36,0xb6,0x76,0xf6
000070  0e8e4ece          DCB      0x0e,0x8e,0x4e,0xce
000074  2eae6eee          DCB      0x2e,0xae,0x6e,0xee
000078  1e9e5ede          DCB      0x1e,0x9e,0x5e,0xde
00007c  3ebe7efe          DCB      0x3e,0xbe,0x7e,0xfe
000080  018141c1          DCB      0x01,0x81,0x41,0xc1
000084  21a161e1          DCB      0x21,0xa1,0x61,0xe1
000088  119151d1          DCB      0x11,0x91,0x51,0xd1
00008c  31b171f1          DCB      0x31,0xb1,0x71,0xf1
000090  098949c9          DCB      0x09,0x89,0x49,0xc9
000094  29a969e9          DCB      0x29,0xa9,0x69,0xe9
000098  199959d9          DCB      0x19,0x99,0x59,0xd9
00009c  39b979f9          DCB      0x39,0xb9,0x79,0xf9
0000a0  058545c5          DCB      0x05,0x85,0x45,0xc5
0000a4  25a565e5          DCB      0x25,0xa5,0x65,0xe5
0000a8  159555d5          DCB      0x15,0x95,0x55,0xd5
0000ac  35b575f5          DCB      0x35,0xb5,0x75,0xf5
0000b0  0d8d4dcd          DCB      0x0d,0x8d,0x4d,0xcd
0000b4  2dad6ded          DCB      0x2d,0xad,0x6d,0xed
0000b8  1d9d5ddd          DCB      0x1d,0x9d,0x5d,0xdd
0000bc  3dbd7dfd          DCB      0x3d,0xbd,0x7d,0xfd
0000c0  038343c3          DCB      0x03,0x83,0x43,0xc3
0000c4  23a363e3          DCB      0x23,0xa3,0x63,0xe3
0000c8  139353d3          DCB      0x13,0x93,0x53,0xd3
0000cc  33b373f3          DCB      0x33,0xb3,0x73,0xf3
0000d0  0b8b4bcb          DCB      0x0b,0x8b,0x4b,0xcb
0000d4  2bab6beb          DCB      0x2b,0xab,0x6b,0xeb
0000d8  1b9b5bdb          DCB      0x1b,0x9b,0x5b,0xdb
0000dc  3bbb7bfb          DCB      0x3b,0xbb,0x7b,0xfb
0000e0  078747c7          DCB      0x07,0x87,0x47,0xc7
0000e4  27a767e7          DCB      0x27,0xa7,0x67,0xe7
0000e8  179757d7          DCB      0x17,0x97,0x57,0xd7
0000ec  37b777f7          DCB      0x37,0xb7,0x77,0xf7
0000f0  0f8f4fcf          DCB      0x0f,0x8f,0x4f,0xcf
0000f4  2faf6fef          DCB      0x2f,0xaf,0x6f,0xef
0000f8  1f9f5fdf          DCB      0x1f,0x9f,0x5f,0xdf
0000fc  3fbf7fff          DCB      0x3f,0xbf,0x7f,0xff
                  CRC16_High
000100  00c18140          DCB      0x00,0xc1,0x81,0x40
000104  01c08041          DCB      0x01,0xc0,0x80,0x41
000108  01c08041          DCB      0x01,0xc0,0x80,0x41
00010c  00c18140          DCB      0x00,0xc1,0x81,0x40
000110  01c08041          DCB      0x01,0xc0,0x80,0x41
000114  00c18140          DCB      0x00,0xc1,0x81,0x40
000118  00c18140          DCB      0x00,0xc1,0x81,0x40
00011c  01c08041          DCB      0x01,0xc0,0x80,0x41
000120  01c08041          DCB      0x01,0xc0,0x80,0x41
000124  00c18140          DCB      0x00,0xc1,0x81,0x40
000128  00c18140          DCB      0x00,0xc1,0x81,0x40
00012c  01c08041          DCB      0x01,0xc0,0x80,0x41
000130  00c18140          DCB      0x00,0xc1,0x81,0x40
000134  01c08041          DCB      0x01,0xc0,0x80,0x41
000138  01c08041          DCB      0x01,0xc0,0x80,0x41
00013c  00c18140          DCB      0x00,0xc1,0x81,0x40
000140  01c08041          DCB      0x01,0xc0,0x80,0x41
000144  00c18140          DCB      0x00,0xc1,0x81,0x40
000148  00c18140          DCB      0x00,0xc1,0x81,0x40
00014c  01c08041          DCB      0x01,0xc0,0x80,0x41
000150  00c18140          DCB      0x00,0xc1,0x81,0x40
000154  01c08041          DCB      0x01,0xc0,0x80,0x41
000158  01c08041          DCB      0x01,0xc0,0x80,0x41
00015c  00c18140          DCB      0x00,0xc1,0x81,0x40
000160  00c18140          DCB      0x00,0xc1,0x81,0x40
000164  01c08041          DCB      0x01,0xc0,0x80,0x41
000168  01c08041          DCB      0x01,0xc0,0x80,0x41
00016c  00c18140          DCB      0x00,0xc1,0x81,0x40
000170  01c08041          DCB      0x01,0xc0,0x80,0x41
000174  00c18140          DCB      0x00,0xc1,0x81,0x40
000178  00c18140          DCB      0x00,0xc1,0x81,0x40
00017c  01c08041          DCB      0x01,0xc0,0x80,0x41
000180  01c08041          DCB      0x01,0xc0,0x80,0x41
000184  00c18140          DCB      0x00,0xc1,0x81,0x40
000188  00c18140          DCB      0x00,0xc1,0x81,0x40
00018c  01c08041          DCB      0x01,0xc0,0x80,0x41
000190  00c18140          DCB      0x00,0xc1,0x81,0x40
000194  01c08041          DCB      0x01,0xc0,0x80,0x41
000198  01c08041          DCB      0x01,0xc0,0x80,0x41
00019c  00c18140          DCB      0x00,0xc1,0x81,0x40
0001a0  00c18140          DCB      0x00,0xc1,0x81,0x40
0001a4  01c08041          DCB      0x01,0xc0,0x80,0x41
0001a8  01c08041          DCB      0x01,0xc0,0x80,0x41
0001ac  00c18140          DCB      0x00,0xc1,0x81,0x40
0001b0  01c08041          DCB      0x01,0xc0,0x80,0x41
0001b4  00c18140          DCB      0x00,0xc1,0x81,0x40
0001b8  00c18140          DCB      0x00,0xc1,0x81,0x40
0001bc  01c08041          DCB      0x01,0xc0,0x80,0x41
0001c0  00c18140          DCB      0x00,0xc1,0x81,0x40
0001c4  01c08041          DCB      0x01,0xc0,0x80,0x41
0001c8  01c08041          DCB      0x01,0xc0,0x80,0x41
0001cc  00c18140          DCB      0x00,0xc1,0x81,0x40
0001d0  01c08041          DCB      0x01,0xc0,0x80,0x41
0001d4  00c18140          DCB      0x00,0xc1,0x81,0x40
0001d8  00c18140          DCB      0x00,0xc1,0x81,0x40
0001dc  01c08041          DCB      0x01,0xc0,0x80,0x41
0001e0  01c08041          DCB      0x01,0xc0,0x80,0x41
0001e4  00c18140          DCB      0x00,0xc1,0x81,0x40
0001e8  00c18140          DCB      0x00,0xc1,0x81,0x40
0001ec  01c08041          DCB      0x01,0xc0,0x80,0x41
0001f0  00c18140          DCB      0x00,0xc1,0x81,0x40
0001f4  01c08041          DCB      0x01,0xc0,0x80,0x41
0001f8  01c08041          DCB      0x01,0xc0,0x80,0x41
0001fc  00c18140          DCB      0x00,0xc1,0x81,0x40
                  Arrow_B
000200  00101120          DCB      0x00,0x10,0x11,0x20
000204  22303340          DCB      0x22,0x30,0x33,0x40
000208  44505560          DCB      0x44,0x50,0x55,0x60
00020c  66707780          DCB      0x66,0x70,0x77,0x80
000210  88909596          DCB      0x88,0x90,0x95,0x96
000214  979899a0          DCB      0x97,0x98,0x99,0xa0
000218  a2a3a5b0          DCB      0xa2,0xa3,0xa5,0xb0
00021c  b1b3b6c0          DCB      0xb1,0xb3,0xb6,0xc0
000220  c1c4c6d0          DCB      0xc1,0xc4,0xc6,0xd0
000224  d4d7e5e7          DCB      0xd4,0xd7,0xe5,0xe7
000228  f5f6              DCB      0xf5,0xf6
                  Arrow_W
00022a  2131              DCB      0x21,0x31
00022c  32414243          DCB      0x32,0x41,0x42,0x43
000230  51525354          DCB      0x51,0x52,0x53,0x54
000234  61626364          DCB      0x61,0x62,0x63,0x64
000238  65717273          DCB      0x65,0x71,0x72,0x73
00023c  74757681          DCB      0x74,0x75,0x76,0x81
000240  82838485          DCB      0x82,0x83,0x84,0x85
000244  86879192          DCB      0x86,0x87,0x91,0x92
000248  9394a1a4          DCB      0x93,0x94,0xa1,0xa4
00024c  b4b5c5d5          DCB      0xb4,0xb5,0xc5,0xd5
000250  d6e6              DCB      0xd6,0xe6
                  Busy_B
000252  0a0b              DCB      0x0a,0x0b
000254  0c0d0e1a          DCB      0x0c,0x0d,0x0e,0x1a
000258  1b1d1e2a          DCB      0x1b,0x1d,0x1e,0x2a
00025c  2c2e3b3d          DCB      0x2c,0x2e,0x3b,0x3d
000260  4c5b5d6a          DCB      0x4c,0x5b,0x5d,0x6a
000264  6e7a7c7e          DCB      0x6e,0x7a,0x7c,0x7e
000268  8a8b8c8d          DCB      0x8a,0x8b,0x8c,0x8d
00026c  8e                DCB      0x8e
                  Busy_W
00026d  1c2b2d            DCB      0x1c,0x2b,0x2d
000270  3c5c6b6c          DCB      0x3c,0x5c,0x6b,0x6c
000274  6d7b7d            DCB      0x6d,0x7b,0x7d
                  Question
000277  0b                DCB      0x0b
000278  0c0d1a1b          DCB      0x0c,0x0d,0x1a,0x1b
00027c  1c1d1e29          DCB      0x1c,0x1d,0x1e,0x29
000280  2a2b2d2e          DCB      0x2a,0x2b,0x2d,0x2e
000284  2f393a3e          DCB      0x2f,0x39,0x3a,0x3e
000288  3f4a4d4e          DCB      0x3f,0x4a,0x4d,0x4e
00028c  4f5c5d5e          DCB      0x4f,0x5c,0x5d,0x5e
000290  6c6d8d8e          DCB      0x6c,0x6d,0x8d,0x8e
000294  9d9e              DCB      0x9d,0x9e
                  Hand_B
000296  0506              DCB      0x05,0x06
000298  14172427          DCB      0x14,0x17,0x24,0x27
00029c  34373944          DCB      0x34,0x37,0x39,0x44
0002a0  47484a4c          DCB      0x47,0x48,0x4a,0x4c
0002a4  51525457          DCB      0x51,0x52,0x54,0x57
0002a8  5a5b5d5e          DCB      0x5a,0x5b,0x5d,0x5e
0002ac  60636467          DCB      0x60,0x63,0x64,0x67
0002b0  6a6d6f70          DCB      0x6a,0x6d,0x6f,0x70
0002b4  74777a7d          DCB      0x74,0x77,0x7a,0x7d
0002b8  7f808f90          DCB      0x7f,0x80,0x8f,0x90
0002bc  9fa0afb0          DCB      0x9f,0xa0,0xaf,0xb0
0002c0  bfc1ced1          DCB      0xbf,0xc1,0xce,0xd1
0002c4  d2d3d4d5          DCB      0xd2,0xd3,0xd4,0xd5
0002c8  d6d7d8d9          DCB      0xd6,0xd7,0xd8,0xd9
0002cc  dadbdcdd          DCB      0xda,0xdb,0xdc,0xdd
0002d0  dee1eef2          DCB      0xde,0xe1,0xee,0xf2
0002d4  f3f4f5f6          DCB      0xf3,0xf4,0xf5,0xf6
0002d8  f7f8f9fa          DCB      0xf7,0xf8,0xf9,0xfa
0002dc  fbfcfd            DCB      0xfb,0xfc,0xfd
                  Hand_W
0002df  15                DCB      0x15
0002e0  16252635          DCB      0x16,0x25,0x26,0x35
0002e4  36454649          DCB      0x36,0x45,0x46,0x49
0002e8  55565859          DCB      0x55,0x56,0x58,0x59
0002ec  5c616265          DCB      0x5c,0x61,0x62,0x65
0002f0  6668696b          DCB      0x66,0x68,0x69,0x6b
0002f4  6c6e7172          DCB      0x6c,0x6e,0x71,0x72
0002f8  73757678          DCB      0x73,0x75,0x76,0x78
0002fc  797b7c7e          DCB      0x79,0x7b,0x7c,0x7e
000300  81828384          DCB      0x81,0x82,0x83,0x84
000304  85868788          DCB      0x85,0x86,0x87,0x88
000308  898a8b8c          DCB      0x89,0x8a,0x8b,0x8c
00030c  8d8e9192          DCB      0x8d,0x8e,0x91,0x92
000310  93949596          DCB      0x93,0x94,0x95,0x96
000314  9798999a          DCB      0x97,0x98,0x99,0x9a
000318  9b9c9d9e          DCB      0x9b,0x9c,0x9d,0x9e
00031c  a1a2a3a4          DCB      0xa1,0xa2,0xa3,0xa4
000320  a5a6a7a8          DCB      0xa5,0xa6,0xa7,0xa8
000324  a9aaabac          DCB      0xa9,0xaa,0xab,0xac
000328  adaeb1b2          DCB      0xad,0xae,0xb1,0xb2
00032c  b3b4b5b6          DCB      0xb3,0xb4,0xb5,0xb6
000330  b7b8b9ba          DCB      0xb7,0xb8,0xb9,0xba
000334  bbbcbdbe          DCB      0xbb,0xbc,0xbd,0xbe
000338  c2c3c4c5          DCB      0xc2,0xc3,0xc4,0xc5
00033c  c6c7c8c9          DCB      0xc6,0xc7,0xc8,0xc9
000340  cacbcccd          DCB      0xca,0xcb,0xcc,0xcd
000344  e2e3e4e5          DCB      0xe2,0xe3,0xe4,0xe5
000348  e6e7e8e9          DCB      0xe6,0xe7,0xe8,0xe9
00034c  eaebeced          DCB      0xea,0xeb,0xec,0xed
                  Text
000350  00010204          DCB      0x00,0x01,0x02,0x04
000354  05061323          DCB      0x05,0x06,0x13,0x23
000358  33435363          DCB      0x33,0x43,0x53,0x63
00035c  738393a3          DCB      0x73,0x83,0x93,0xa3
000360  b3c3d3e3          DCB      0xb3,0xc3,0xd3,0xe3
000364  f0f1f2f4          DCB      0xf0,0xf1,0xf2,0xf4
000368  f5f6              DCB      0xf5,0xf6
                  Stop_B
00036a  0506              DCB      0x05,0x06
00036c  07081314          DCB      0x07,0x08,0x13,0x14
000370  15161718          DCB      0x15,0x16,0x17,0x18
000374  191a2223          DCB      0x19,0x1a,0x22,0x23
000378  24292a2b          DCB      0x24,0x29,0x2a,0x2b
00037c  31323334          DCB      0x31,0x32,0x33,0x34
000380  3a3b3c41          DCB      0x3a,0x3b,0x3c,0x41
000384  42434445          DCB      0x42,0x43,0x44,0x45
000388  4b4c5051          DCB      0x4b,0x4c,0x50,0x51
00038c  5455565c          DCB      0x54,0x55,0x56,0x5c
000390  5d606165          DCB      0x5d,0x60,0x61,0x65
000394  66676c6d          DCB      0x66,0x67,0x6c,0x6d
000398  70717677          DCB      0x70,0x71,0x76,0x77
00039c  787c7d80          DCB      0x78,0x7c,0x7d,0x80
0003a0  81878889          DCB      0x81,0x87,0x88,0x89
0003a4  8c8d9192          DCB      0x8c,0x8d,0x91,0x92
0003a8  98999a9b          DCB      0x98,0x99,0x9a,0x9b
0003ac  9ca1a2a3          DCB      0x9c,0xa1,0xa2,0xa3
0003b0  a9aaabac          DCB      0xa9,0xaa,0xab,0xac
0003b4  b2b3b4b9          DCB      0xb2,0xb3,0xb4,0xb9
0003b8  babbc3c4          DCB      0xba,0xbb,0xc3,0xc4
0003bc  c5c6c7c8          DCB      0xc5,0xc6,0xc7,0xc8
0003c0  c9cad5d6          DCB      0xc9,0xca,0xd5,0xd6
0003c4  d7d8              DCB      0xd7,0xd8
                  Stop_W
0003c6  2526              DCB      0x25,0x26
0003c8  27283536          DCB      0x27,0x28,0x35,0x36
0003cc  37383946          DCB      0x37,0x38,0x39,0x46
0003d0  4748494a          DCB      0x47,0x48,0x49,0x4a
0003d4  52535758          DCB      0x52,0x53,0x57,0x58
0003d8  595a5b62          DCB      0x59,0x5a,0x5b,0x62
0003dc  63646869          DCB      0x63,0x64,0x68,0x69
0003e0  6a6b7273          DCB      0x6a,0x6b,0x72,0x73
0003e4  7475797a          DCB      0x74,0x75,0x79,0x7a
0003e8  7b828384          DCB      0x7b,0x82,0x83,0x84
0003ec  85868a8b          DCB      0x85,0x86,0x8a,0x8b
0003f0  93949596          DCB      0x93,0x94,0x95,0x96
0003f4  97a4a5a6          DCB      0x97,0xa4,0xa5,0xa6
0003f8  a7a8b5b6          DCB      0xa7,0xa8,0xb5,0xb6
0003fc  b7b8              DCB      0xb7,0xb8
                  Adj_ALL
0003fe  0716              DCB      0x07,0x16
000400  17182526          DCB      0x17,0x18,0x25,0x26
000404  27282937          DCB      0x27,0x28,0x29,0x37
000408  4752575c          DCB      0x47,0x52,0x57,0x5c
00040c  6162676c          DCB      0x61,0x62,0x67,0x6c
000410  6d707172          DCB      0x6d,0x70,0x71,0x72
000414  73747576          DCB      0x73,0x74,0x75,0x76
000418  7778797a          DCB      0x77,0x78,0x79,0x7a
00041c  7b7c7d7e          DCB      0x7b,0x7c,0x7d,0x7e
000420  8182878c          DCB      0x81,0x82,0x87,0x8c
000424  8d92979c          DCB      0x8d,0x92,0x97,0x9c
000428  a7b7c5c6          DCB      0xa7,0xb7,0xc5,0xc6
00042c  c7c8c9d6          DCB      0xc7,0xc8,0xc9,0xd6
000430  d7d8e7            DCB      0xd7,0xd8,0xe7
                  Adj_LR
000433  52                DCB      0x52
000434  5d61626d          DCB      0x5d,0x61,0x62,0x6d
000438  6e707172          DCB      0x6e,0x70,0x71,0x72
00043c  73747576          DCB      0x73,0x74,0x75,0x76
000440  7778797a          DCB      0x77,0x78,0x79,0x7a
000444  7b7c7d7e          DCB      0x7b,0x7c,0x7d,0x7e
000448  7f81828d          DCB      0x7f,0x81,0x82,0x8d
00044c  8e929d            DCB      0x8e,0x92,0x9d
                  Adj_UD
00044f  07                DCB      0x07
000450  16171825          DCB      0x16,0x17,0x18,0x25
000454  26272829          DCB      0x26,0x27,0x28,0x29
000458  37475767          DCB      0x37,0x47,0x57,0x67
00045c  778797a7          DCB      0x77,0x87,0x97,0xa7
000460  b7c7d5d6          DCB      0xb7,0xc7,0xd5,0xd6
000464  d7d8d9e6          DCB      0xd7,0xd8,0xd9,0xe6
000468  e7e8f7            DCB      0xe7,0xe8,0xf7
                  Adj_BRUL
00046b  00                DCB      0x00
00046c  01020304          DCB      0x01,0x02,0x03,0x04
000470  10111213          DCB      0x10,0x11,0x12,0x13
000474  20212230          DCB      0x20,0x21,0x22,0x30
000478  31334044          DCB      0x31,0x33,0x40,0x44
00047c  55667788          DCB      0x55,0x66,0x77,0x88
000480  99aabbbf          DCB      0x99,0xaa,0xbb,0xbf
000484  cccecfdd          DCB      0xcc,0xce,0xcf,0xdd
000488  dedfeced          DCB      0xde,0xdf,0xec,0xed
00048c  eeeffbfc          DCB      0xee,0xef,0xfb,0xfc
000490  fdfeff            DCB      0xfd,0xfe,0xff
                  Adj_BLUR
000493  0b                DCB      0x0b
000494  0c0d0e0f          DCB      0x0c,0x0d,0x0e,0x0f
000498  1c1d1e1f          DCB      0x1c,0x1d,0x1e,0x1f
00049c  2d2e2f3c          DCB      0x2d,0x2e,0x2f,0x3c
0004a0  3e3f4b4f          DCB      0x3e,0x3f,0x4b,0x4f
0004a4  5a697887          DCB      0x5a,0x69,0x78,0x87
0004a8  96a5b0b4          DCB      0x96,0xa5,0xb0,0xb4
0004ac  c0c1c3d0          DCB      0xc0,0xc1,0xc3,0xd0
0004b0  d1d2e0e1          DCB      0xd1,0xd2,0xe0,0xe1
0004b4  e2e3f0f1          DCB      0xe2,0xe3,0xf0,0xf1
0004b8  f2f3f4            DCB      0xf2,0xf3,0xf4
                  Cross
0004bb  07                DCB      0x07
0004bc  17273746          DCB      0x17,0x27,0x37,0x46
0004c0  47485557          DCB      0x47,0x48,0x55,0x57
0004c4  59646a70          DCB      0x59,0x64,0x6a,0x70
0004c8  71727374          DCB      0x71,0x72,0x73,0x74
0004cc  7577797a          DCB      0x75,0x77,0x79,0x7a
0004d0  7b7c7d7e          DCB      0x7b,0x7c,0x7d,0x7e
0004d4  848a9597          DCB      0x84,0x8a,0x95,0x97
0004d8  99a6a7a8          DCB      0x99,0xa6,0xa7,0xa8
0004dc  b7c7d7e7          DCB      0xb7,0xc7,0xd7,0xe7
0004e0  00c0c101          DCB      0x00,0xc0,0xc1,0x01
0004e4  c30302c2          DCB      0xc3,0x03,0x02,0xc2
0004e8  c60607c7          DCB      0xc6,0x06,0x07,0xc7
0004ec  05c5c404          DCB      0x05,0xc5,0xc4,0x04
0004f0  cc0c0dcd          DCB      0xcc,0x0c,0x0d,0xcd
0004f4  0fcfce0e          DCB      0x0f,0xcf,0xce,0x0e
0004f8  0acacb0b          DCB      0x0a,0xca,0xcb,0x0b
0004fc  c90908c8          DCB      0xc9,0x09,0x08,0xc8
000500  d81819d9          DCB      0xd8,0x18,0x19,0xd9
000504  1bdbda1a          DCB      0x1b,0xdb,0xda,0x1a
000508  1ededf1f          DCB      0x1e,0xde,0xdf,0x1f
00050c  dd1d1cdc          DCB      0xdd,0x1d,0x1c,0xdc
000510  14d4d515          DCB      0x14,0xd4,0xd5,0x15
000514  d71716d6          DCB      0xd7,0x17,0x16,0xd6
000518  d21213d3          DCB      0xd2,0x12,0x13,0xd3
00051c  11d1d010          DCB      0x11,0xd1,0xd0,0x10
000520  f03031f1          DCB      0xf0,0x30,0x31,0xf1
000524  33f3f232          DCB      0x33,0xf3,0xf2,0x32
000528  36f6f737          DCB      0x36,0xf6,0xf7,0x37
00052c  f53534f4          DCB      0xf5,0x35,0x34,0xf4
000530  3cfcfd3d          DCB      0x3c,0xfc,0xfd,0x3d
000534  ff3f3efe          DCB      0xff,0x3f,0x3e,0xfe
000538  fa3a3bfb          DCB      0xfa,0x3a,0x3b,0xfb
00053c  39f9f838          DCB      0x39,0xf9,0xf8,0x38
000540  28e8e929          DCB      0x28,0xe8,0xe9,0x29
000544  eb2b2aea          DCB      0xeb,0x2b,0x2a,0xea
000548  ee2e2fef          DCB      0xee,0x2e,0x2f,0xef
00054c  2dedec2c          DCB      0x2d,0xed,0xec,0x2c
000550  e42425e5          DCB      0xe4,0x24,0x25,0xe5
000554  27e7e626          DCB      0x27,0xe7,0xe6,0x26
000558  22e2e323          DCB      0x22,0xe2,0xe3,0x23
00055c  e12120e0          DCB      0xe1,0x21,0x20,0xe0
000560  a06061a1          DCB      0xa0,0x60,0x61,0xa1
000564  63a3a262          DCB      0x63,0xa3,0xa2,0x62
000568  66a6a767          DCB      0x66,0xa6,0xa7,0x67
00056c  a56564a4          DCB      0xa5,0x65,0x64,0xa4
000570  6cacad6d          DCB      0x6c,0xac,0xad,0x6d
000574  af6f6eae          DCB      0xaf,0x6f,0x6e,0xae
000578  aa6a6bab          DCB      0xaa,0x6a,0x6b,0xab
00057c  69a9a868          DCB      0x69,0xa9,0xa8,0x68
000580  78b8b979          DCB      0x78,0xb8,0xb9,0x79
000584  bb7b7aba          DCB      0xbb,0x7b,0x7a,0xba
000588  be7e7fbf          DCB      0xbe,0x7e,0x7f,0xbf
00058c  7dbdbc7c          DCB      0x7d,0xbd,0xbc,0x7c
000590  b47475b5          DCB      0xb4,0x74,0x75,0xb5
000594  77b7b676          DCB      0x77,0xb7,0xb6,0x76
000598  72b2b373          DCB      0x72,0xb2,0xb3,0x73
00059c  b17170b0          DCB      0xb1,0x71,0x70,0xb0
0005a0  50909151          DCB      0x50,0x90,0x91,0x51
0005a4  93535292          DCB      0x93,0x53,0x52,0x92
0005a8  96565797          DCB      0x96,0x56,0x57,0x97
0005ac  55959454          DCB      0x55,0x95,0x94,0x54
0005b0  9c5c5d9d          DCB      0x9c,0x5c,0x5d,0x9d
0005b4  5f9f9e5e          DCB      0x5f,0x9f,0x9e,0x5e
0005b8  5a9a9b5b          DCB      0x5a,0x9a,0x9b,0x5b
0005bc  99595898          DCB      0x99,0x59,0x58,0x98
0005c0  88484989          DCB      0x88,0x48,0x49,0x89
0005c4  4b8b8a4a          DCB      0x4b,0x8b,0x8a,0x4a
0005c8  4e8e8f4f          DCB      0x4e,0x8e,0x8f,0x4f
0005cc  8d4d4c8c          DCB      0x8d,0x4d,0x4c,0x8c
0005d0  44848545          DCB      0x44,0x84,0x85,0x45
0005d4  87474686          DCB      0x87,0x47,0x46,0x86
0005d8  82424383          DCB      0x82,0x42,0x43,0x83
0005dc  41818040          DCB      0x41,0x81,0x80,0x40

                          AREA ||.data||, DATA, ALIGN=2

                  RMP_Bitmap
                          DCD      0x00000000
                  RMP_Delay
                          %        8
                  RMP_Tick
                          DCD      0x00000000
                  RMP_Sched_Lock_Cnt
                          DCD      0x00000000
                  RMP_Sched_Locked
                          DCD      0x00000000
                  RMP_Sched_Pend
                          DCD      0x00000000
                  RMP_Timer_Pend
                          DCD      0x00000000
                  RMP_Cur_Thd
                          DCD      0x00000000
                  RMP_Cur_SP
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\MProkaron\\Kernel\\kernel.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_kernel_c_346ad0e8____REV16|
#line 464 "D:\\Program_Files_x86\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.1.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___8_kernel_c_346ad0e8____REV16| PROC
#line 465

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_kernel_c_346ad0e8____REVSH|
#line 479
|__asm___8_kernel_c_346ad0e8____REVSH| PROC
#line 480

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___8_kernel_c_346ad0e8____RRX|
#line 666
|__asm___8_kernel_c_346ad0e8____RRX| PROC
#line 667

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
