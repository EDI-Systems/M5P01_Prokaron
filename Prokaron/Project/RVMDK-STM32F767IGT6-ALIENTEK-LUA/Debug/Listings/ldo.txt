; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\ldo.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\ldo.d --cpu=Cortex-M7 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Inc -I.\Source -I.\Drivers -I..\..\..\M6P1(L)_Lua\lua -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6-ALIENTEK-LUA\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER -Dlua_writestring=RMP_lua_writestring -Dlua_writeline=RMP_lua_writeline --enum_is_int --signed_chars --omf_browse=.\debug\output\ldo.crf ..\..\..\M6P1(L)_Lua\lua\ldo.c]
                          THUMB

                          AREA ||i.checkmode||, CODE, READONLY, ALIGN=2

                  checkmode PROC
;;;765    
;;;766    static void checkmode (lua_State *L, const char *mode, const char *x) {
000000  b570              PUSH     {r4-r6,lr}
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;767      if (mode && strchr(mode, x[0]) == NULL) {
000008  b17c              CBZ      r4,|L1.42|
00000a  f9951000          LDRSB    r1,[r5,#0]
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       strchr
000014  b948              CBNZ     r0,|L1.42|
;;;768        luaO_pushfstring(L,
000016  4623              MOV      r3,r4
000018  462a              MOV      r2,r5
00001a  a104              ADR      r1,|L1.44|
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       luaO_pushfstring
;;;769           "attempt to load a %s chunk (mode is '%s')", x, mode);
;;;770        luaD_throw(L, LUA_ERRSYNTAX);
000022  2103              MOVS     r1,#3
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       luaD_throw
                  |L1.42|
;;;771      }
;;;772    }
00002a  bd70              POP      {r4-r6,pc}
;;;773    
                          ENDP

                  |L1.44|
00002c  61747465          DCB      "attempt to load a %s chunk (mode is '%s')",0
000030  6d707420
000034  746f206c
000038  6f616420
00003c  61202573
000040  20636875
000044  6e6b2028
000048  6d6f6465
00004c  20697320
000050  27257327
000054  2900    
000056  00                DCB      0
000057  00                DCB      0

                          AREA ||i.correctstack||, CODE, READONLY, ALIGN=1

                  correctstack PROC
;;;158    */
;;;159    static void correctstack (lua_State *L, StkId oldstack, StkId newstack) {
000000  b570              PUSH     {r4-r6,lr}
000002  4603              MOV      r3,r0
;;;160      CallInfo *ci;
;;;161      UpVal *up;
;;;162      if (oldstack == newstack)
000004  4291              CMP      r1,r2
000006  d100              BNE      |L2.10|
                  |L2.8|
;;;163        return;  /* stack address did not change */
;;;164      L->top = (L->top - oldstack) + newstack;
;;;165      for (up = L->openupval; up != NULL; up = up->u.open.next)
;;;166        up->v = s2v((uplevel(up) - oldstack) + newstack);
;;;167      for (ci = L->ci; ci != NULL; ci = ci->previous) {
;;;168        ci->top = (ci->top - oldstack) + newstack;
;;;169        ci->func = (ci->func - oldstack) + newstack;
;;;170        if (isLua(ci))
;;;171          ci->u.l.trap = 1;  /* signal to update 'trap' in 'luaV_execute' */
;;;172      }
;;;173    }
000008  bd70              POP      {r4-r6,pc}
                  |L2.10|
00000a  68dd              LDR      r5,[r3,#0xc]          ;164
00000c  1a6d              SUBS     r5,r5,r1              ;164
00000e  112d              ASRS     r5,r5,#4              ;164
000010  eb021505          ADD      r5,r2,r5,LSL #4       ;164
000014  60dd              STR      r5,[r3,#0xc]          ;164
000016  6a5c              LDR      r4,[r3,#0x24]         ;165
000018  e006              B        |L2.40|
                  |L2.26|
00001a  68a5              LDR      r5,[r4,#8]            ;166
00001c  1a6d              SUBS     r5,r5,r1              ;166
00001e  112d              ASRS     r5,r5,#4              ;166
000020  eb021505          ADD      r5,r2,r5,LSL #4       ;166
000024  60a5              STR      r5,[r4,#8]            ;166
000026  6924              LDR      r4,[r4,#0x10]         ;165
                  |L2.40|
000028  2c00              CMP      r4,#0                 ;165
00002a  d1f6              BNE      |L2.26|
00002c  6958              LDR      r0,[r3,#0x14]         ;167
00002e  e013              B        |L2.88|
                  |L2.48|
000030  6845              LDR      r5,[r0,#4]            ;168
000032  1a6d              SUBS     r5,r5,r1              ;168
000034  112d              ASRS     r5,r5,#4              ;168
000036  eb021505          ADD      r5,r2,r5,LSL #4       ;168
00003a  6045              STR      r5,[r0,#4]            ;168
00003c  6805              LDR      r5,[r0,#0]            ;169
00003e  1a6d              SUBS     r5,r5,r1              ;169
000040  112d              ASRS     r5,r5,#4              ;169
000042  eb021505          ADD      r5,r2,r5,LSL #4       ;169
000046  6005              STR      r5,[r0,#0]            ;169
000048  f8905022          LDRB     r5,[r0,#0x22]         ;170
00004c  f0050502          AND      r5,r5,#2              ;170
000050  b90d              CBNZ     r5,|L2.86|
000052  2601              MOVS     r6,#1                 ;171
000054  6146              STR      r6,[r0,#0x14]         ;171
                  |L2.86|
000056  6880              LDR      r0,[r0,#8]            ;167
                  |L2.88|
000058  2800              CMP      r0,#0                 ;167
00005a  d1e9              BNE      |L2.48|
00005c  bf00              NOP      
00005e  e7d3              B        |L2.8|
;;;174    
                          ENDP


                          AREA ||i.f_parser||, CODE, READONLY, ALIGN=2

                  f_parser PROC
;;;774    
;;;775    static void f_parser (lua_State *L, void *ud) {
000000  e92d41fc          PUSH     {r2-r8,lr}
000004  4680              MOV      r8,r0
000006  460d              MOV      r5,r1
;;;776      LClosure *cl;
;;;777      struct SParser *p = cast(struct SParser *, ud);
000008  462c              MOV      r4,r5
;;;778      int c = zgetc(p->z);  /* read first character */
00000a  6820              LDR      r0,[r4,#0]
00000c  6801              LDR      r1,[r0,#0]
00000e  1e48              SUBS     r0,r1,#1
000010  6822              LDR      r2,[r4,#0]
000012  6010              STR      r0,[r2,#0]
000014  b131              CBZ      r1,|L3.36|
000016  6820              LDR      r0,[r4,#0]
000018  6841              LDR      r1,[r0,#4]
00001a  1c48              ADDS     r0,r1,#1
00001c  6822              LDR      r2,[r4,#0]
00001e  6050              STR      r0,[r2,#4]
000020  7808              LDRB     r0,[r1,#0]
000022  e002              B        |L3.42|
                  |L3.36|
000024  6820              LDR      r0,[r4,#0]
000026  f7fffffe          BL       luaZ_fill
                  |L3.42|
00002a  4607              MOV      r7,r0
;;;779      if (c == LUA_SIGNATURE[0]) {
00002c  a013              ADR      r0,|L3.124|
00002e  f9900000          LDRSB    r0,[r0,#0]
000032  42b8              CMP      r0,r7
000034  d10b              BNE      |L3.78|
;;;780        checkmode(L, p->mode, "binary");
000036  a213              ADR      r2,|L3.132|
000038  4640              MOV      r0,r8
00003a  6b61              LDR      r1,[r4,#0x34]
00003c  f7fffffe          BL       checkmode
;;;781        cl = luaU_undump(L, p->z, p->name);
000040  4640              MOV      r0,r8
000042  6ba2              LDR      r2,[r4,#0x38]
000044  6821              LDR      r1,[r4,#0]
000046  f7fffffe          BL       luaU_undump
00004a  4606              MOV      r6,r0
00004c  e00f              B        |L3.110|
                  |L3.78|
;;;782      }
;;;783      else {
;;;784        checkmode(L, p->mode, "text");
00004e  a20f              ADR      r2,|L3.140|
000050  4640              MOV      r0,r8
000052  6b61              LDR      r1,[r4,#0x34]
000054  f7fffffe          BL       checkmode
;;;785        cl = luaY_parser(L, p->z, &p->buff, &p->dyd, p->name, c);
000058  6ba0              LDR      r0,[r4,#0x38]
00005a  e9cd0700          STRD     r0,r7,[sp,#0]
00005e  f1040310          ADD      r3,r4,#0x10
000062  1d22              ADDS     r2,r4,#4
000064  4640              MOV      r0,r8
000066  6821              LDR      r1,[r4,#0]
000068  f7fffffe          BL       luaY_parser
00006c  4606              MOV      r6,r0
                  |L3.110|
;;;786      }
;;;787      lua_assert(cl->nupvalues == cl->p->sizeupvalues);
;;;788      luaF_initupvals(L, cl);
00006e  4631              MOV      r1,r6
000070  4640              MOV      r0,r8
000072  f7fffffe          BL       luaF_initupvals
;;;789    }
000076  e8bd81fc          POP      {r2-r8,pc}
;;;790    
                          ENDP

00007a  0000              DCW      0x0000
                  |L3.124|
00007c  1b4c7561          DCB      27,"Lua",0
000080  00      
000081  00                DCB      0
000082  00                DCB      0
000083  00                DCB      0
                  |L3.132|
000084  62696e61          DCB      "binary",0
000088  727900  
00008b  00                DCB      0
                  |L3.140|
00008c  74657874          DCB      "text",0
000090  00      
000091  00                DCB      0
000092  00                DCB      0
000093  00                DCB      0

                          AREA ||i.findpcall||, CODE, READONLY, ALIGN=1

                  findpcall PROC
;;;573    */
;;;574    static CallInfo *findpcall (lua_State *L) {
000000  4602              MOV      r2,r0
;;;575      CallInfo *ci;
;;;576      for (ci = L->ci; ci != NULL; ci = ci->previous) {  /* search for a pcall */
000002  6951              LDR      r1,[r2,#0x14]
000004  e007              B        |L4.22|
                  |L4.6|
;;;577        if (ci->callstatus & CIST_YPCALL)
000006  f8910022          LDRB     r0,[r1,#0x22]
00000a  f0000008          AND      r0,r0,#8
00000e  b108              CBZ      r0,|L4.20|
;;;578          return ci;
000010  4608              MOV      r0,r1
                  |L4.18|
;;;579      }
;;;580      return NULL;  /* no pending pcall */
;;;581    }
000012  4770              BX       lr
                  |L4.20|
000014  6889              LDR      r1,[r1,#8]            ;576
                  |L4.22|
000016  2900              CMP      r1,#0                 ;576
000018  d1f5              BNE      |L4.6|
00001a  2000              MOVS     r0,#0                 ;580
00001c  e7f9              B        |L4.18|
;;;582    
                          ENDP


                          AREA ||i.finishCcall||, CODE, READONLY, ALIGN=1

                  finishCcall PROC
;;;524    */
;;;525    static void finishCcall (lua_State *L, int status) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;526      CallInfo *ci = L->ci;
000008  6965              LDR      r5,[r4,#0x14]
;;;527      int n;
;;;528      /* must have a continuation and must be able to call it */
;;;529      lua_assert(ci->u.c.k != NULL && L->nny == 0);
;;;530      /* error status can only happen in a protected call */
;;;531      lua_assert((ci->callstatus & CIST_YPCALL) || status == LUA_YIELD);
;;;532      if (ci->callstatus & CIST_YPCALL) {  /* was inside a pcall? */
00000a  f8950022          LDRB     r0,[r5,#0x22]
00000e  f0000008          AND      r0,r0,#8
000012  b128              CBZ      r0,|L5.32|
;;;533        ci->callstatus &= ~CIST_YPCALL;  /* continuation is also inside it */
000014  8c68              LDRH     r0,[r5,#0x22]
000016  f0200008          BIC      r0,r0,#8
00001a  8468              STRH     r0,[r5,#0x22]
;;;534        L->errfunc = ci->u.c.old_errfunc;  /* with the same error function */
00001c  6968              LDR      r0,[r5,#0x14]
00001e  65e0              STR      r0,[r4,#0x5c]
                  |L5.32|
;;;535      }
;;;536      /* finish 'lua_callk'/'lua_pcall'; CIST_YPCALL and 'errfunc' already
;;;537         handled */
;;;538      adjustresults(L, ci->nresults);
000020  f9b50020          LDRSH    r0,[r5,#0x20]
000024  1c40              ADDS     r0,r0,#1
000026  b938              CBNZ     r0,|L5.56|
000028  6960              LDR      r0,[r4,#0x14]
00002a  6840              LDR      r0,[r0,#4]
00002c  68e1              LDR      r1,[r4,#0xc]
00002e  4288              CMP      r0,r1
000030  d202              BCS      |L5.56|
000032  6961              LDR      r1,[r4,#0x14]
000034  68e0              LDR      r0,[r4,#0xc]
000036  6048              STR      r0,[r1,#4]
                  |L5.56|
;;;539      lua_unlock(L);
;;;540      n = (*ci->u.c.k)(L, status, ci->u.c.ctx);  /* call continuation function */
000038  4639              MOV      r1,r7
00003a  4620              MOV      r0,r4
00003c  692b              LDR      r3,[r5,#0x10]
00003e  69aa              LDR      r2,[r5,#0x18]
000040  4798              BLX      r3
000042  4606              MOV      r6,r0
;;;541      lua_lock(L);
;;;542      api_checknelems(L, n);
;;;543      luaD_poscall(L, ci, L->top - n, n);  /* finish 'luaD_call' */
000044  68e0              LDR      r0,[r4,#0xc]
000046  eba01206          SUB      r2,r0,r6,LSL #4
00004a  4633              MOV      r3,r6
00004c  4629              MOV      r1,r5
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       luaD_poscall
;;;544    }
000054  e8bd81f0          POP      {r4-r8,pc}
;;;545    
                          ENDP


                          AREA ||i.luaD_call||, CODE, READONLY, ALIGN=1

                  luaD_call PROC
;;;452    */
;;;453    void luaD_call (lua_State *L, StkId func, int nresults) {
000000  e92d4ffe          PUSH     {r1-r11,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4690              MOV      r8,r2
;;;454      lua_CFunction f;
;;;455      TValue *funcv = s2v(func);
00000a  462f              MOV      r7,r5
;;;456      switch (ttypetag(funcv)) {
00000c  7a38              LDRB     r0,[r7,#8]
00000e  f000003f          AND      r0,r0,#0x3f
000012  2816              CMP      r0,#0x16
000014  d05a              BEQ      |L6.204|
000016  2826              CMP      r0,#0x26
000018  d005              BEQ      |L6.38|
00001a  2836              CMP      r0,#0x36
00001c  d17e              BNE      |L6.284|
;;;457        case LUA_TCCL:  /* C closure */
;;;458          f = clCvalue(funcv)->f;
00001e  6838              LDR      r0,[r7,#0]
000020  f8d0900c          LDR      r9,[r0,#0xc]
;;;459          goto Cfunc;
000024  e002              B        |L6.44|
                  |L6.38|
;;;460        case LUA_TLCF:  /* light C function */
;;;461          f = fvalue(funcv);
000026  f8d79000          LDR      r9,[r7,#0]
;;;462         Cfunc: {
00002a  bf00              NOP      
                  |L6.44|
;;;463          int n;  /* number of returns */
;;;464          CallInfo *ci;
;;;465          checkstackp(L, LUA_MINSTACK, func);  /* ensure minimum stack size */
00002c  68e1              LDR      r1,[r4,#0xc]
00002e  69e0              LDR      r0,[r4,#0x1c]
000030  1a40              SUBS     r0,r0,r1
000032  2114              MOVS     r1,#0x14
000034  ebb11f20          CMP      r1,r0,ASR #4
000038  db13              BLT      |L6.98|
00003a  6a20              LDR      r0,[r4,#0x20]
00003c  eba50b00          SUB      r11,r5,r0
000040  6920              LDR      r0,[r4,#0x10]
000042  68c0              LDR      r0,[r0,#0xc]
000044  2800              CMP      r0,#0
000046  dd03              BLE      |L6.80|
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       luaC_step
00004e  bf00              NOP      
                  |L6.80|
000050  2201              MOVS     r2,#1
000052  2114              MOVS     r1,#0x14
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       luaD_growstack
00005a  6a20              LDR      r0,[r4,#0x20]
00005c  eb00050b          ADD      r5,r0,r11
000060  e000              B        |L6.100|
                  |L6.98|
000062  bf00              NOP      
                  |L6.100|
;;;466          ci = next_ci(L);
000064  6960              LDR      r0,[r4,#0x14]
000066  68c0              LDR      r0,[r0,#0xc]
000068  b110              CBZ      r0,|L6.112|
00006a  6960              LDR      r0,[r4,#0x14]
00006c  68c0              LDR      r0,[r0,#0xc]
00006e  e002              B        |L6.118|
                  |L6.112|
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       luaE_extendCI
                  |L6.118|
000076  4606              MOV      r6,r0
000078  6160              STR      r0,[r4,#0x14]
;;;467          ci->nresults = nresults;
00007a  fa0ff088          SXTH     r0,r8
00007e  8430              STRH     r0,[r6,#0x20]
;;;468          ci->callstatus = CIST_C;
000080  2002              MOVS     r0,#2
000082  8470              STRH     r0,[r6,#0x22]
;;;469          ci->top = L->top + LUA_MINSTACK;
000084  68e0              LDR      r0,[r4,#0xc]
000086  f50070a0          ADD      r0,r0,#0x140
00008a  6070              STR      r0,[r6,#4]
;;;470          ci->func = func;
00008c  6035              STR      r5,[r6,#0]
;;;471          lua_assert(ci->top <= L->stack_last);
;;;472          if (L->hookmask & LUA_MASKCALL) {
00008e  f8940070          LDRB     r0,[r4,#0x70]
000092  f0000001          AND      r0,r0,#1
000096  b168              CBZ      r0,|L6.180|
;;;473            int narg = cast_int(L->top - func) - 1;
000098  68e0              LDR      r0,[r4,#0xc]
00009a  1b40              SUBS     r0,r0,r5
00009c  2101              MOVS     r1,#1
00009e  ebc11b20          RSB      r11,r1,r0,ASR #4
;;;474            luaD_hook(L, LUA_HOOKCALL, -1, 1, narg);
0000a2  2301              MOVS     r3,#1
0000a4  1e8a              SUBS     r2,r1,#2
0000a6  2100              MOVS     r1,#0
0000a8  4620              MOV      r0,r4
0000aa  f8cdb000          STR      r11,[sp,#0]
0000ae  f7fffffe          BL       luaD_hook
;;;475          }
0000b2  bf00              NOP      
                  |L6.180|
;;;476          lua_unlock(L);
;;;477          n = (*f)(L);  /* do the actual call */
0000b4  4620              MOV      r0,r4
0000b6  47c8              BLX      r9
0000b8  4682              MOV      r10,r0
;;;478          lua_lock(L);
;;;479          api_checknelems(L, n);
;;;480          luaD_poscall(L, ci, L->top - n, n);
0000ba  68e0              LDR      r0,[r4,#0xc]
0000bc  eba0120a          SUB      r2,r0,r10,LSL #4
0000c0  4653              MOV      r3,r10
0000c2  4631              MOV      r1,r6
0000c4  4620              MOV      r0,r4
0000c6  f7fffffe          BL       luaD_poscall
;;;481          break;
0000ca  e05f              B        |L6.396|
                  |L6.204|
;;;482        }
;;;483        case LUA_TLCL: {  /* Lua function */
;;;484          CallInfo *ci;
;;;485          Proto *p = clLvalue(funcv)->p;
0000cc  6838              LDR      r0,[r7,#0]
0000ce  f8d0a00c          LDR      r10,[r0,#0xc]
;;;486          int narg = cast_int(L->top - func) - 1;  /* number of real arguments */
0000d2  68e0              LDR      r0,[r4,#0xc]
0000d4  1b40              SUBS     r0,r0,r5
0000d6  2101              MOVS     r1,#1
0000d8  ebc11020          RSB      r0,r1,r0,ASR #4
0000dc  9002              STR      r0,[sp,#8]
;;;487          int nfixparams = p->numparams;
0000de  f89a0006          LDRB     r0,[r10,#6]
0000e2  9001              STR      r0,[sp,#4]
;;;488          int fsize = p->maxstacksize;  /* frame size */
0000e4  f89ab008          LDRB     r11,[r10,#8]
;;;489          checkstackp(L, fsize, func);
0000e8  68e1              LDR      r1,[r4,#0xc]
0000ea  69e0              LDR      r0,[r4,#0x1c]
0000ec  1a40              SUBS     r0,r0,r1
0000ee  ebbb1f20          CMP      r11,r0,ASR #4
0000f2  db14              BLT      |L6.286|
0000f4  6a20              LDR      r0,[r4,#0x20]
0000f6  1a28              SUBS     r0,r5,r0
0000f8  9000              STR      r0,[sp,#0]
0000fa  6920              LDR      r0,[r4,#0x10]
0000fc  68c0              LDR      r0,[r0,#0xc]
0000fe  2800              CMP      r0,#0
000100  dd03              BLE      |L6.266|
000102  4620              MOV      r0,r4
000104  f7fffffe          BL       luaC_step
000108  bf00              NOP      
                  |L6.266|
00010a  2201              MOVS     r2,#1
00010c  4659              MOV      r1,r11
00010e  4620              MOV      r0,r4
000110  f7fffffe          BL       luaD_growstack
000114  6a21              LDR      r1,[r4,#0x20]
000116  9800              LDR      r0,[sp,#0]
000118  180d              ADDS     r5,r1,r0
00011a  e001              B        |L6.288|
                  |L6.284|
00011c  e02c              B        |L6.376|
                  |L6.286|
00011e  bf00              NOP      
                  |L6.288|
;;;490          ci = next_ci(L);
000120  6960              LDR      r0,[r4,#0x14]
000122  68c0              LDR      r0,[r0,#0xc]
000124  b110              CBZ      r0,|L6.300|
000126  6960              LDR      r0,[r4,#0x14]
000128  68c0              LDR      r0,[r0,#0xc]
00012a  e002              B        |L6.306|
                  |L6.300|
00012c  4620              MOV      r0,r4
00012e  f7fffffe          BL       luaE_extendCI
                  |L6.306|
000132  4606              MOV      r6,r0
000134  6160              STR      r0,[r4,#0x14]
;;;491          ci->nresults = nresults;
000136  fa0ff088          SXTH     r0,r8
00013a  8430              STRH     r0,[r6,#0x20]
;;;492          ci->u.l.savedpc = p->code;  /* starting point */
00013c  f8da0038          LDR      r0,[r10,#0x38]
000140  6130              STR      r0,[r6,#0x10]
;;;493          ci->callstatus = 0;
000142  2000              MOVS     r0,#0
000144  8470              STRH     r0,[r6,#0x22]
;;;494          ci->top = func + 1 + fsize;
000146  f1050010          ADD      r0,r5,#0x10
00014a  eb00100b          ADD      r0,r0,r11,LSL #4
00014e  6070              STR      r0,[r6,#4]
;;;495          ci->func = func;
000150  6035              STR      r5,[r6,#0]
;;;496          for (; narg < nfixparams; narg++)
000152  e008              B        |L6.358|
                  |L6.340|
;;;497            setnilvalue(s2v(L->top++));  /* complete missing arguments */
000154  2100              MOVS     r1,#0
000156  68e2              LDR      r2,[r4,#0xc]
000158  f1020010          ADD      r0,r2,#0x10
00015c  60e0              STR      r0,[r4,#0xc]
00015e  7211              STRB     r1,[r2,#8]
000160  9802              LDR      r0,[sp,#8]            ;496
000162  1c40              ADDS     r0,r0,#1              ;496
000164  9002              STR      r0,[sp,#8]            ;496
                  |L6.358|
000166  e9dd1001          LDRD     r1,r0,[sp,#4]         ;496
00016a  4288              CMP      r0,r1                 ;496
00016c  dbf2              BLT      |L6.340|
;;;498          lua_assert(ci->top <= L->stack_last);
;;;499          luaV_execute(L, ci);  /* run the function */
00016e  4631              MOV      r1,r6
000170  4620              MOV      r0,r4
000172  f7fffffe          BL       luaV_execute
;;;500          break;
000176  e009              B        |L6.396|
                  |L6.376|
;;;501        }
;;;502        default: {  /* not a function */
;;;503          luaD_tryfuncTM(L, func);  /* try to get '__call' metamethod */
000178  4629              MOV      r1,r5
00017a  4620              MOV      r0,r4
00017c  f7fffffe          BL       luaD_tryfuncTM
;;;504          luaD_call(L, func, nresults);  /* now it must be a function */
000180  4642              MOV      r2,r8
000182  4629              MOV      r1,r5
000184  4620              MOV      r0,r4
000186  f7fffffe          BL       luaD_call
;;;505          break;
00018a  bf00              NOP      
                  |L6.396|
00018c  bf00              NOP                            ;481
;;;506        }
;;;507      }
;;;508    }
00018e  e8bd8ffe          POP      {r1-r11,pc}
;;;509    
                          ENDP


                          AREA ||i.luaD_callnoyield||, CODE, READONLY, ALIGN=1

                  luaD_callnoyield PROC
;;;513    */
;;;514    void luaD_callnoyield (lua_State *L, StkId func, int nResults) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;515      L->nny++;
000008  f8b4006c          LDRH     r0,[r4,#0x6c]
00000c  1c40              ADDS     r0,r0,#1
00000e  f8a4006c          STRH     r0,[r4,#0x6c]
;;;516      luaD_call(L, func, nResults);
000012  4632              MOV      r2,r6
000014  4629              MOV      r1,r5
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       luaD_call
;;;517      L->nny--;
00001c  f8b4006c          LDRH     r0,[r4,#0x6c]
000020  1e40              SUBS     r0,r0,#1
000022  f8a4006c          STRH     r0,[r4,#0x6c]
;;;518    }
000026  bd70              POP      {r4-r6,pc}
;;;519    
                          ENDP


                          AREA ||i.luaD_growstack||, CODE, READONLY, ALIGN=2

                  luaD_growstack PROC
;;;203    */
;;;204    int luaD_growstack (lua_State *L, int n, int raiseerror) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
;;;205      int size = L->stacksize;
00000a  f8d48060          LDR      r8,[r4,#0x60]
;;;206      int newsize = 2 * size;  /* tentative new size */
00000e  ea4f0548          LSL      r5,r8,#1
;;;207      if (size > LUAI_MAXSTACK) {  /* need more space after extra size? */
000012  4819              LDR      r0,|L8.120|
000014  4580              CMP      r8,r0
000016  dd08              BLE      |L8.42|
;;;208        if (raiseerror)
000018  b126              CBZ      r6,|L8.36|
;;;209          luaD_throw(L, LUA_ERRERR);  /* error inside message handler */
00001a  2106              MOVS     r1,#6
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       luaD_throw
000022  e022              B        |L8.106|
                  |L8.36|
;;;210        else return 0;
000024  2000              MOVS     r0,#0
                  |L8.38|
;;;211      }
;;;212      else {
;;;213        int needed = cast_int(L->top - L->stack) + n + EXTRA_STACK;
;;;214        if (newsize > LUAI_MAXSTACK)  /* cannot cross the limit */
;;;215          newsize = LUAI_MAXSTACK;
;;;216        if (newsize < needed)  /* but must respect what was asked for */
;;;217          newsize = needed;
;;;218        if (newsize > LUAI_MAXSTACK) {  /* stack overflow? */
;;;219          /* add extra size to be able to handle the error message */
;;;220          luaD_reallocstack(L, ERRORSTACKSIZE, raiseerror);
;;;221          if (raiseerror)
;;;222            luaG_runerror(L, "stack overflow");
;;;223          else return 0;
;;;224        }
;;;225      }  /* else no errors */
;;;226      return luaD_reallocstack(L, newsize, raiseerror);
;;;227    }
000026  e8bd87f0          POP      {r4-r10,pc}
                  |L8.42|
00002a  6a21              LDR      r1,[r4,#0x20]         ;213
00002c  68e0              LDR      r0,[r4,#0xc]          ;213
00002e  1a40              SUBS     r0,r0,r1              ;213
000030  eb071020          ADD      r0,r7,r0,ASR #4       ;213
000034  f1000905          ADD      r9,r0,#5              ;213
000038  480f              LDR      r0,|L8.120|
00003a  4285              CMP      r5,r0                 ;214
00003c  dd00              BLE      |L8.64|
00003e  4605              MOV      r5,r0                 ;215
                  |L8.64|
000040  454d              CMP      r5,r9                 ;216
000042  da00              BGE      |L8.70|
000044  464d              MOV      r5,r9                 ;217
                  |L8.70|
000046  480c              LDR      r0,|L8.120|
000048  4285              CMP      r5,r0                 ;218
00004a  dd0d              BLE      |L8.104|
00004c  4632              MOV      r2,r6                 ;220
00004e  490a              LDR      r1,|L8.120|
000050  31c8              ADDS     r1,r1,#0xc8           ;220
000052  4620              MOV      r0,r4                 ;220
000054  f7fffffe          BL       luaD_reallocstack
000058  b126              CBZ      r6,|L8.100|
00005a  a108              ADR      r1,|L8.124|
00005c  4620              MOV      r0,r4                 ;222
00005e  f7fffffe          BL       luaG_runerror
000062  e001              B        |L8.104|
                  |L8.100|
000064  2000              MOVS     r0,#0                 ;223
000066  e7de              B        |L8.38|
                  |L8.104|
000068  bf00              NOP                            ;225
                  |L8.106|
00006a  4632              MOV      r2,r6                 ;226
00006c  4629              MOV      r1,r5                 ;226
00006e  4620              MOV      r0,r4                 ;226
000070  f7fffffe          BL       luaD_reallocstack
000074  e7d7              B        |L8.38|
;;;228    
                          ENDP

000076  0000              DCW      0x0000
                  |L8.120|
                          DCD      0x000f4240
                  |L8.124|
00007c  73746163          DCB      "stack overflow",0
000080  6b206f76
000084  6572666c
000088  6f7700  
00008b  00                DCB      0

                          AREA ||i.luaD_hook||, CODE, READONLY, ALIGN=1

                  luaD_hook PROC
;;;269    */
;;;270    void luaD_hook (lua_State *L, int event, int line,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;271                                  int fTransfer, int nTransfer) {
000004  b09d              SUB      sp,sp,#0x74
000006  4604              MOV      r4,r0
000008  460f              MOV      r7,r1
00000a  4690              MOV      r8,r2
00000c  4699              MOV      r9,r3
00000e  f8dda098          LDR      r10,[sp,#0x98]
;;;272      lua_Hook hook = L->hook;
000012  f8d4b058          LDR      r11,[r4,#0x58]
;;;273      if (hook && L->allowhook) {  /* make sure there is a hook */
000016  f1bb0f00          CMP      r11,#0
00001a  d049              BEQ      |L9.176|
00001c  f8940074          LDRB     r0,[r4,#0x74]
000020  2800              CMP      r0,#0
000022  d045              BEQ      |L9.176|
;;;274        int mask = CIST_HOOKED;
000024  2604              MOVS     r6,#4
;;;275        CallInfo *ci = L->ci;
000026  6965              LDR      r5,[r4,#0x14]
;;;276        ptrdiff_t top = savestack(L, L->top);
000028  6a21              LDR      r1,[r4,#0x20]
00002a  68e0              LDR      r0,[r4,#0xc]
00002c  1a40              SUBS     r0,r0,r1
00002e  901c              STR      r0,[sp,#0x70]
;;;277        ptrdiff_t ci_top = savestack(L, ci->top);
000030  6868              LDR      r0,[r5,#4]
000032  6a21              LDR      r1,[r4,#0x20]
000034  1a40              SUBS     r0,r0,r1
000036  901b              STR      r0,[sp,#0x6c]
;;;278        lua_Debug ar;
;;;279        ar.event = event;
000038  9701              STR      r7,[sp,#4]
;;;280        ar.currentline = line;
00003a  f8cd8018          STR      r8,[sp,#0x18]
;;;281        ar.i_ci = ci;
00003e  951a              STR      r5,[sp,#0x68]
;;;282        if (nTransfer != 0) {
000040  f1ba0f00          CMP      r10,#0
000044  d005              BEQ      |L9.82|
;;;283          mask |= CIST_TRAN;  /* 'ci' has transfer information */
000046  f4467680          ORR      r6,r6,#0x100
;;;284          ci->u2.transferinfo.fTransfer = fTransfer;
00004a  f8a5901c          STRH     r9,[r5,#0x1c]
;;;285          ci->u2.transferinfo.nTransfer = nTransfer;
00004e  f8a5a01e          STRH     r10,[r5,#0x1e]
                  |L9.82|
;;;286        }
;;;287        luaD_checkstack(L, LUA_MINSTACK);  /* ensure minimum stack size */
000052  68e1              LDR      r1,[r4,#0xc]
000054  69e0              LDR      r0,[r4,#0x1c]
000056  1a40              SUBS     r0,r0,r1
000058  2114              MOVS     r1,#0x14
00005a  ebb11f20          CMP      r1,r0,ASR #4
00005e  db04              BLT      |L9.106|
000060  2201              MOVS     r2,#1
000062  4620              MOV      r0,r4
000064  f7fffffe          BL       luaD_growstack
000068  e000              B        |L9.108|
                  |L9.106|
00006a  bf00              NOP      
                  |L9.108|
;;;288        if (L->top + LUA_MINSTACK > ci->top)
00006c  68e0              LDR      r0,[r4,#0xc]
00006e  f50070a0          ADD      r0,r0,#0x140
000072  6869              LDR      r1,[r5,#4]
000074  4288              CMP      r0,r1
000076  d903              BLS      |L9.128|
;;;289          ci->top = L->top + LUA_MINSTACK;
000078  68e0              LDR      r0,[r4,#0xc]
00007a  f50070a0          ADD      r0,r0,#0x140
00007e  6068              STR      r0,[r5,#4]
                  |L9.128|
;;;290        L->allowhook = 0;  /* cannot call hooks inside a hook */
000080  2000              MOVS     r0,#0
000082  f8840074          STRB     r0,[r4,#0x74]
;;;291        ci->callstatus |= mask;
000086  8c68              LDRH     r0,[r5,#0x22]
000088  4330              ORRS     r0,r0,r6
00008a  8468              STRH     r0,[r5,#0x22]
;;;292        lua_unlock(L);
;;;293        (*hook)(L, &ar);
00008c  a901              ADD      r1,sp,#4
00008e  4620              MOV      r0,r4
000090  47d8              BLX      r11
;;;294        lua_lock(L);
;;;295        lua_assert(!L->allowhook);
;;;296        L->allowhook = 1;
000092  2001              MOVS     r0,#1
000094  f8840074          STRB     r0,[r4,#0x74]
;;;297        ci->top = restorestack(L, ci_top);
000098  6a21              LDR      r1,[r4,#0x20]
00009a  981b              LDR      r0,[sp,#0x6c]
00009c  4408              ADD      r0,r0,r1
00009e  6068              STR      r0,[r5,#4]
;;;298        L->top = restorestack(L, top);
0000a0  6a21              LDR      r1,[r4,#0x20]
0000a2  981c              LDR      r0,[sp,#0x70]
0000a4  4408              ADD      r0,r0,r1
0000a6  60e0              STR      r0,[r4,#0xc]
;;;299        ci->callstatus &= ~mask;
0000a8  8c68              LDRH     r0,[r5,#0x22]
0000aa  43b0              BICS     r0,r0,r6
0000ac  8468              STRH     r0,[r5,#0x22]
;;;300      }
0000ae  bf00              NOP      
                  |L9.176|
;;;301    }
0000b0  b01d              ADD      sp,sp,#0x74
0000b2  e8bd8ff0          POP      {r4-r11,pc}
;;;302    
                          ENDP


                          AREA ||i.luaD_hookcall||, CODE, READONLY, ALIGN=1

                  luaD_hookcall PROC
;;;308    */
;;;309    void luaD_hookcall (lua_State *L, CallInfo *ci) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;310      int hook = (ci->callstatus & CIST_TAIL) ? LUA_HOOKTAILCALL : LUA_HOOKCALL;
000006  f8940022          LDRB     r0,[r4,#0x22]
00000a  f0000010          AND      r0,r0,#0x10
00000e  b108              CBZ      r0,|L10.20|
000010  2004              MOVS     r0,#4
000012  e000              B        |L10.22|
                  |L10.20|
000014  2000              MOVS     r0,#0
                  |L10.22|
000016  4607              MOV      r7,r0
;;;311      Proto *p;
;;;312      if (!(L->hookmask & LUA_MASKCALL))  /* some other hook? */
000018  f8950070          LDRB     r0,[r5,#0x70]
00001c  f0000001          AND      r0,r0,#1
000020  b900              CBNZ     r0,|L10.36|
                  |L10.34|
;;;313        return;  /* don't call hook */
;;;314      p = clLvalue(s2v(ci->func))->p;
;;;315      L->top = ci->top;  /* prepare top */
;;;316      ci->u.l.savedpc++;  /* hooks assume 'pc' is already incremented */
;;;317      luaD_hook(L, hook, -1, 1, p->numparams);
;;;318      ci->u.l.savedpc--;  /* correct 'pc' */
;;;319    }
000022  bdf8              POP      {r3-r7,pc}
                  |L10.36|
000024  6820              LDR      r0,[r4,#0]            ;314
000026  6800              LDR      r0,[r0,#0]            ;314
000028  68c6              LDR      r6,[r0,#0xc]          ;314
00002a  6860              LDR      r0,[r4,#4]            ;315
00002c  60e8              STR      r0,[r5,#0xc]          ;315
00002e  6920              LDR      r0,[r4,#0x10]         ;316
000030  1d00              ADDS     r0,r0,#4              ;316
000032  6120              STR      r0,[r4,#0x10]         ;316
000034  79b0              LDRB     r0,[r6,#6]            ;317
000036  2301              MOVS     r3,#1                 ;317
000038  1e9a              SUBS     r2,r3,#2              ;317
00003a  4639              MOV      r1,r7                 ;317
00003c  9000              STR      r0,[sp,#0]            ;317
00003e  4628              MOV      r0,r5                 ;317
000040  f7fffffe          BL       luaD_hook
000044  6920              LDR      r0,[r4,#0x10]         ;318
000046  1f00              SUBS     r0,r0,#4              ;318
000048  6120              STR      r0,[r4,#0x10]         ;318
00004a  bf00              NOP      
00004c  e7e9              B        |L10.34|
;;;320    
                          ENDP


                          AREA ||i.luaD_inctop||, CODE, READONLY, ALIGN=1

                  luaD_inctop PROC
;;;256    
;;;257    void luaD_inctop (lua_State *L) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;258      luaD_checkstack(L, 1);
000004  68e1              LDR      r1,[r4,#0xc]
000006  69e0              LDR      r0,[r4,#0x1c]
000008  1a40              SUBS     r0,r0,r1
00000a  2101              MOVS     r1,#1
00000c  ebb11f20          CMP      r1,r0,ASR #4
000010  db05              BLT      |L11.30|
000012  2201              MOVS     r2,#1
000014  4611              MOV      r1,r2
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       luaD_growstack
00001c  e000              B        |L11.32|
                  |L11.30|
00001e  bf00              NOP      
                  |L11.32|
;;;259      L->top++;
000020  68e0              LDR      r0,[r4,#0xc]
000022  3010              ADDS     r0,r0,#0x10
000024  60e0              STR      r0,[r4,#0xc]
;;;260    }
000026  bd10              POP      {r4,pc}
;;;261    
                          ENDP


                          AREA ||i.luaD_pcall||, CODE, READONLY, ALIGN=1

                  luaD_pcall PROC
;;;729    
;;;730    int luaD_pcall (lua_State *L, Pfunc func, void *u,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;731                    ptrdiff_t old_top, ptrdiff_t ef) {
000004  b083              SUB      sp,sp,#0xc
000006  4604              MOV      r4,r0
000008  4688              MOV      r8,r1
00000a  461e              MOV      r6,r3
00000c  f8dd9040          LDR      r9,[sp,#0x40]
;;;732      int status;
;;;733      CallInfo *old_ci = L->ci;
000010  f8d4a014          LDR      r10,[r4,#0x14]
;;;734      lu_byte old_allowhooks = L->allowhook;
000014  f894b074          LDRB     r11,[r4,#0x74]
;;;735      unsigned short old_nny = L->nny;
000018  f8b4006c          LDRH     r0,[r4,#0x6c]
00001c  9002              STR      r0,[sp,#8]
;;;736      ptrdiff_t old_errfunc = L->errfunc;
00001e  6de0              LDR      r0,[r4,#0x5c]
000020  9001              STR      r0,[sp,#4]
;;;737      L->errfunc = ef;
000022  f8c4905c          STR      r9,[r4,#0x5c]
;;;738      status = luaD_rawrunprotected(L, func, u);
000026  4641              MOV      r1,r8
000028  4620              MOV      r0,r4
00002a  9a05              LDR      r2,[sp,#0x14]
00002c  f7fffffe          BL       luaD_rawrunprotected
000030  4605              MOV      r5,r0
;;;739      if (status != LUA_OK) {  /* an error occurred? */
000032  b1ad              CBZ      r5,|L12.96|
;;;740        StkId oldtop = restorestack(L, old_top);
000034  6a20              LDR      r0,[r4,#0x20]
000036  1987              ADDS     r7,r0,r6
;;;741        luaF_close(L, oldtop);  /* close possible pending closures */
000038  4639              MOV      r1,r7
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       luaF_close
;;;742        seterrorobj(L, status, oldtop);
000040  463a              MOV      r2,r7
000042  4629              MOV      r1,r5
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       seterrorobj
;;;743        L->ci = old_ci;
00004a  f8c4a014          STR      r10,[r4,#0x14]
;;;744        L->allowhook = old_allowhooks;
00004e  f884b074          STRB     r11,[r4,#0x74]
;;;745        L->nny = old_nny;
000052  9802              LDR      r0,[sp,#8]
000054  f8a4006c          STRH     r0,[r4,#0x6c]
;;;746        luaD_shrinkstack(L);
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       luaD_shrinkstack
;;;747      }
00005e  bf00              NOP      
                  |L12.96|
;;;748      L->errfunc = old_errfunc;
000060  9801              LDR      r0,[sp,#4]
000062  65e0              STR      r0,[r4,#0x5c]
;;;749      return status;
000064  4628              MOV      r0,r5
;;;750    }
000066  b007              ADD      sp,sp,#0x1c
000068  e8bd8ff0          POP      {r4-r11,pc}
;;;751    
                          ENDP


                          AREA ||i.luaD_poscall||, CODE, READONLY, ALIGN=1

                  luaD_poscall PROC
;;;406    */
;;;407    void luaD_poscall (lua_State *L, CallInfo *ci, StkId firstResult, int nres) {
000000  e92d43f8          PUSH     {r3-r9,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;408      if (L->hookmask) {
00000c  6f20              LDR      r0,[r4,#0x70]
00000e  b160              CBZ      r0,|L13.42|
;;;409        ptrdiff_t fr = savestack(L, firstResult);  /* hook may change stack */
000010  6a20              LDR      r0,[r4,#0x20]
000012  eba60800          SUB      r8,r6,r0
;;;410        rethook(L, ci, firstResult, nres);
000016  463b              MOV      r3,r7
000018  4632              MOV      r2,r6
00001a  4629              MOV      r1,r5
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       rethook
;;;411        firstResult = restorestack(L, fr);
000022  6a20              LDR      r0,[r4,#0x20]
000024  eb000608          ADD      r6,r0,r8
;;;412      }
000028  bf00              NOP      
                  |L13.42|
;;;413      L->ci = ci->previous;  /* back to caller */
00002a  68a8              LDR      r0,[r5,#8]
00002c  6160              STR      r0,[r4,#0x14]
;;;414      /* move results to proper place */
;;;415      moveresults(L, firstResult, ci->func, nres, ci->nresults);
00002e  f9b50020          LDRSH    r0,[r5,#0x20]
000032  9000              STR      r0,[sp,#0]
000034  463b              MOV      r3,r7
000036  4631              MOV      r1,r6
000038  4620              MOV      r0,r4
00003a  682a              LDR      r2,[r5,#0]
00003c  f7fffffe          BL       moveresults
;;;416    }
000040  e8bd83f8          POP      {r3-r9,pc}
;;;417    
                          ENDP


                          AREA ||i.luaD_pretailcall||, CODE, READONLY, ALIGN=1

                  luaD_pretailcall PROC
;;;427    */
;;;428    void luaD_pretailcall (lua_State *L, CallInfo *ci, StkId func, int narg1) {
000000  e92d5ff0          PUSH     {r4-r12,lr}
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
;;;429      Proto *p = clLvalue(s2v(func))->p;
00000c  6828              LDR      r0,[r5,#0]
00000e  f8d0900c          LDR      r9,[r0,#0xc]
;;;430      int fsize = p->maxstacksize;  /* frame size */
000012  f899a008          LDRB     r10,[r9,#8]
;;;431      int nfixparams = p->numparams;
000016  f899b006          LDRB     r11,[r9,#6]
;;;432      int i;
;;;433      for (i = 0; i < narg1; i++)  /* move down function and arguments */
00001a  f04f0800          MOV      r8,#0
00001e  e00c              B        |L14.58|
                  |L14.32|
;;;434        setobjs2s(L, ci->func + i, func + i);
000020  6822              LDR      r2,[r4,#0]
000022  eb021008          ADD      r0,r2,r8,LSL #4
000026  eb051108          ADD      r1,r5,r8,LSL #4
00002a  e9d12300          LDRD     r2,r3,[r1,#0]
00002e  e9c02300          STRD     r2,r3,[r0,#0]
000032  7a0a              LDRB     r2,[r1,#8]
000034  7202              STRB     r2,[r0,#8]
000036  f1080801          ADD      r8,r8,#1              ;433
                  |L14.58|
00003a  45b0              CMP      r8,r6                 ;433
00003c  dbf0              BLT      |L14.32|
;;;435      checkstackGC(L, fsize);
00003e  68f9              LDR      r1,[r7,#0xc]
000040  69f8              LDR      r0,[r7,#0x1c]
000042  1a40              SUBS     r0,r0,r1
000044  ebba1f20          CMP      r10,r0,ASR #4
000048  db0d              BLT      |L14.102|
00004a  2201              MOVS     r2,#1
00004c  4651              MOV      r1,r10
00004e  4638              MOV      r0,r7
000050  f7fffffe          BL       luaD_growstack
000054  6938              LDR      r0,[r7,#0x10]
000056  68c0              LDR      r0,[r0,#0xc]
000058  2800              CMP      r0,#0
00005a  dd03              BLE      |L14.100|
00005c  4638              MOV      r0,r7
00005e  f7fffffe          BL       luaC_step
000062  bf00              NOP      
                  |L14.100|
000064  e000              B        |L14.104|
                  |L14.102|
000066  bf00              NOP      
                  |L14.104|
;;;436      func = ci->func;  /* moved-down function */
000068  6825              LDR      r5,[r4,#0]
;;;437      for (; narg1 <= nfixparams; narg1++)
00006a  e004              B        |L14.118|
                  |L14.108|
;;;438        setnilvalue(s2v(func + narg1));  /* complete missing arguments */
00006c  2000              MOVS     r0,#0
00006e  eb051106          ADD      r1,r5,r6,LSL #4
000072  7208              STRB     r0,[r1,#8]
000074  1c76              ADDS     r6,r6,#1              ;437
                  |L14.118|
000076  455e              CMP      r6,r11                ;437
000078  ddf8              BLE      |L14.108|
;;;439      ci->top = func + 1 + fsize;  /* top for new function */
00007a  f1050010          ADD      r0,r5,#0x10
00007e  eb00100a          ADD      r0,r0,r10,LSL #4
000082  6060              STR      r0,[r4,#4]
;;;440      lua_assert(ci->top <= L->stack_last);
;;;441      ci->u.l.savedpc = p->code;  /* starting point */
000084  f8d90038          LDR      r0,[r9,#0x38]
000088  6120              STR      r0,[r4,#0x10]
;;;442      ci->callstatus |= CIST_TAIL;
00008a  8c60              LDRH     r0,[r4,#0x22]
00008c  f0400010          ORR      r0,r0,#0x10
000090  8460              STRH     r0,[r4,#0x22]
;;;443      L->top = func + narg1;  /* set top */
000092  eb051006          ADD      r0,r5,r6,LSL #4
000096  60f8              STR      r0,[r7,#0xc]
;;;444    }
000098  e8bd9ff0          POP      {r4-r12,pc}
;;;445    
                          ENDP


                          AREA ||i.luaD_protectedparser||, CODE, READONLY, ALIGN=2

                  luaD_protectedparser PROC
;;;791    
;;;792    int luaD_protectedparser (lua_State *L, ZIO *z, const char *name,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;793                                            const char *mode) {
000004  b090              SUB      sp,sp,#0x40
000006  4604              MOV      r4,r0
000008  460d              MOV      r5,r1
00000a  4616              MOV      r6,r2
00000c  461f              MOV      r7,r3
;;;794      struct SParser p;
;;;795      int status;
;;;796      L->nny++;  /* cannot yield during parsing */
00000e  f8b4006c          LDRH     r0,[r4,#0x6c]
000012  1c40              ADDS     r0,r0,#1
000014  f8a4006c          STRH     r0,[r4,#0x6c]
;;;797      p.z = z; p.name = name; p.mode = mode;
000018  9501              STR      r5,[sp,#4]
00001a  960f              STR      r6,[sp,#0x3c]
00001c  970e              STR      r7,[sp,#0x38]
;;;798      p.dyd.actvar.arr = NULL; p.dyd.actvar.size = 0;
00001e  2000              MOVS     r0,#0
000020  9005              STR      r0,[sp,#0x14]
000022  2100              MOVS     r1,#0
000024  9107              STR      r1,[sp,#0x1c]
;;;799      p.dyd.gt.arr = NULL; p.dyd.gt.size = 0;
000026  9108              STR      r1,[sp,#0x20]
000028  910a              STR      r1,[sp,#0x28]
;;;800      p.dyd.label.arr = NULL; p.dyd.label.size = 0;
00002a  910b              STR      r1,[sp,#0x2c]
00002c  910d              STR      r1,[sp,#0x34]
;;;801      luaZ_initbuffer(L, &p.buff);
00002e  9002              STR      r0,[sp,#8]
000030  9104              STR      r1,[sp,#0x10]
;;;802      status = luaD_pcall(L, f_parser, &p, savestack(L, L->top), L->errfunc);
000032  6de0              LDR      r0,[r4,#0x5c]
000034  9000              STR      r0,[sp,#0]
000036  6a21              LDR      r1,[r4,#0x20]
000038  68e0              LDR      r0,[r4,#0xc]
00003a  1a43              SUBS     r3,r0,r1
00003c  aa01              ADD      r2,sp,#4
00003e  4914              LDR      r1,|L15.144|
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       luaD_pcall
000046  4680              MOV      r8,r0
;;;803      luaZ_freebuffer(L, &p.buff);
000048  2300              MOVS     r3,#0
00004a  4620              MOV      r0,r4
00004c  9a04              LDR      r2,[sp,#0x10]
00004e  9902              LDR      r1,[sp,#8]
000050  f7fffffe          BL       luaM_saferealloc_
000054  9002              STR      r0,[sp,#8]
000056  2100              MOVS     r1,#0
000058  9104              STR      r1,[sp,#0x10]
;;;804      luaM_freearray(L, p.dyd.actvar.arr, p.dyd.actvar.size);
00005a  9807              LDR      r0,[sp,#0x1c]
00005c  0042              LSLS     r2,r0,#1
00005e  4620              MOV      r0,r4
000060  9905              LDR      r1,[sp,#0x14]
000062  f7fffffe          BL       luaM_free_
;;;805      luaM_freearray(L, p.dyd.gt.arr, p.dyd.gt.size);
000066  980a              LDR      r0,[sp,#0x28]
000068  0102              LSLS     r2,r0,#4
00006a  4620              MOV      r0,r4
00006c  9908              LDR      r1,[sp,#0x20]
00006e  f7fffffe          BL       luaM_free_
;;;806      luaM_freearray(L, p.dyd.label.arr, p.dyd.label.size);
000072  980d              LDR      r0,[sp,#0x34]
000074  0102              LSLS     r2,r0,#4
000076  4620              MOV      r0,r4
000078  990b              LDR      r1,[sp,#0x2c]
00007a  f7fffffe          BL       luaM_free_
;;;807      L->nny--;
00007e  f8b4006c          LDRH     r0,[r4,#0x6c]
000082  1e40              SUBS     r0,r0,#1
000084  f8a4006c          STRH     r0,[r4,#0x6c]
;;;808      return status;
000088  4640              MOV      r0,r8
;;;809    }
00008a  b010              ADD      sp,sp,#0x40
00008c  e8bd81f0          POP      {r4-r8,pc}
;;;810    
                          ENDP

                  |L15.144|
                          DCD      f_parser

                          AREA ||i.luaD_rawrunprotected||, CODE, READONLY, ALIGN=1

                  luaD_rawrunprotected PROC
;;;136    
;;;137    int luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud) {
000000  b5f0              PUSH     {r4-r7,lr}
000002  b0ad              SUB      sp,sp,#0xb4
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;138      unsigned short oldnCcalls = L->nCcalls - L->nci;
00000a  f8b4006e          LDRH     r0,[r4,#0x6e]
00000e  88e1              LDRH     r1,[r4,#6]
000010  1a40              SUBS     r0,r0,r1
000012  b287              UXTH     r7,r0
;;;139      struct lua_longjmp lj;
;;;140      lj.status = LUA_OK;
000014  2000              MOVS     r0,#0
000016  902a              STR      r0,[sp,#0xa8]
;;;141      lj.previous = L->errorJmp;  /* chain new error handler */
000018  6b20              LDR      r0,[r4,#0x30]
00001a  9000              STR      r0,[sp,#0]
;;;142      L->errorJmp = &lj;
00001c  f8c4d030          STR      sp,[r4,#0x30]
;;;143      LUAI_TRY(L, &lj,
000020  a802              ADD      r0,sp,#8
000022  f7fffffe          BL       setjmp
000026  b910              CBNZ     r0,|L16.46|
000028  4631              MOV      r1,r6
00002a  4620              MOV      r0,r4
00002c  47a8              BLX      r5
                  |L16.46|
;;;144        (*f)(L, ud);
;;;145      );
;;;146      L->errorJmp = lj.previous;  /* restore old error handler */
00002e  9800              LDR      r0,[sp,#0]
000030  6320              STR      r0,[r4,#0x30]
;;;147      L->nCcalls = oldnCcalls + L->nci;
000032  88e0              LDRH     r0,[r4,#6]
000034  4438              ADD      r0,r0,r7
000036  f8a4006e          STRH     r0,[r4,#0x6e]
;;;148      return lj.status;
00003a  982a              LDR      r0,[sp,#0xa8]
;;;149    }
00003c  b02d              ADD      sp,sp,#0xb4
00003e  bdf0              POP      {r4-r7,pc}
;;;150    
                          ENDP


                          AREA ||i.luaD_reallocstack||, CODE, READONLY, ALIGN=1

                  luaD_reallocstack PROC
;;;179    
;;;180    int luaD_reallocstack (lua_State *L, int newsize, int raiseerror) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4690              MOV      r8,r2
;;;181      int lim = L->stacksize;
00000a  6e26              LDR      r6,[r4,#0x60]
;;;182      StkId newstack = luaM_reallocvector(L, L->stack, lim, newsize, StackValue);
00000c  012b              LSLS     r3,r5,#4
00000e  0132              LSLS     r2,r6,#4
000010  4620              MOV      r0,r4
000012  6a21              LDR      r1,[r4,#0x20]
000014  f7fffffe          BL       luaM_realloc_
000018  4607              MOV      r7,r0
;;;183      lua_assert(newsize <= LUAI_MAXSTACK || newsize == ERRORSTACKSIZE);
;;;184      lua_assert(L->stack_last - L->stack == L->stacksize - EXTRA_STACK);
;;;185      if (newstack == NULL) {  /* reallocation failed? */
00001a  b957              CBNZ     r7,|L17.50|
;;;186        if (raiseerror)
00001c  f1b80f00          CMP      r8,#0
000020  d004              BEQ      |L17.44|
;;;187          luaM_error(L);
000022  2104              MOVS     r1,#4
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       luaD_throw
00002a  e002              B        |L17.50|
                  |L17.44|
;;;188        else return 0;  /* do not raise an error */
00002c  2000              MOVS     r0,#0
                  |L17.46|
;;;189      }
;;;190      for (; lim < newsize; lim++)
;;;191        setnilvalue(s2v(newstack + lim)); /* erase new segment */
;;;192      correctstack(L, L->stack, newstack);
;;;193      L->stack = newstack;
;;;194      L->stacksize = newsize;
;;;195      L->stack_last = L->stack + newsize - EXTRA_STACK;
;;;196      return 1;
;;;197    }
00002e  e8bd81f0          POP      {r4-r8,pc}
                  |L17.50|
000032  e004              B        |L17.62|
                  |L17.52|
000034  2000              MOVS     r0,#0                 ;191
000036  eb071106          ADD      r1,r7,r6,LSL #4       ;191
00003a  7208              STRB     r0,[r1,#8]            ;191
00003c  1c76              ADDS     r6,r6,#1              ;190
                  |L17.62|
00003e  42ae              CMP      r6,r5                 ;190
000040  dbf8              BLT      |L17.52|
000042  463a              MOV      r2,r7                 ;192
000044  4620              MOV      r0,r4                 ;192
000046  6a21              LDR      r1,[r4,#0x20]         ;192
000048  f7fffffe          BL       correctstack
00004c  6227              STR      r7,[r4,#0x20]         ;193
00004e  6625              STR      r5,[r4,#0x60]         ;194
000050  6a20              LDR      r0,[r4,#0x20]         ;195
000052  eb001005          ADD      r0,r0,r5,LSL #4       ;195
000056  3850              SUBS     r0,r0,#0x50           ;195
000058  61e0              STR      r0,[r4,#0x1c]         ;195
00005a  2001              MOVS     r0,#1                 ;196
00005c  e7e7              B        |L17.46|
;;;198    
                          ENDP


                          AREA ||i.luaD_shrinkstack||, CODE, READONLY, ALIGN=2

                  luaD_shrinkstack PROC
;;;240    
;;;241    void luaD_shrinkstack (lua_State *L) {
000000  b570              PUSH     {r4-r6,lr}
000002  4606              MOV      r6,r0
;;;242      int inuse = stackinuse(L);
000004  4630              MOV      r0,r6
000006  f7fffffe          BL       stackinuse
00000a  4604              MOV      r4,r0
;;;243      int goodsize = inuse + (inuse / 8) + 2*EXTRA_STACK;
00000c  4620              MOV      r0,r4
00000e  17e1              ASRS     r1,r4,#31
000010  eb047151          ADD      r1,r4,r1,LSR #29
000014  eb0401e1          ADD      r1,r4,r1,ASR #3
000018  f101050a          ADD      r5,r1,#0xa
;;;244      if (goodsize > LUAI_MAXSTACK)
00001c  480a              LDR      r0,|L18.72|
00001e  4285              CMP      r5,r0
000020  dd00              BLE      |L18.36|
;;;245        goodsize = LUAI_MAXSTACK;  /* respect stack limit */
000022  4605              MOV      r5,r0
                  |L18.36|
;;;246      /* if thread is currently not handling a stack overflow and its
;;;247         good size is smaller than current size, shrink its stack */
;;;248      if (inuse <= (LUAI_MAXSTACK - EXTRA_STACK) &&
000024  4808              LDR      r0,|L18.72|
000026  1f40              SUBS     r0,r0,#5
000028  4284              CMP      r4,r0
00002a  dc08              BGT      |L18.62|
;;;249          goodsize < L->stacksize)
00002c  6e30              LDR      r0,[r6,#0x60]
00002e  42a8              CMP      r0,r5
000030  dd05              BLE      |L18.62|
;;;250        luaD_reallocstack(L, goodsize, 0);  /* ok if that fails */
000032  2200              MOVS     r2,#0
000034  4629              MOV      r1,r5
000036  4630              MOV      r0,r6
000038  f7fffffe          BL       luaD_reallocstack
00003c  e000              B        |L18.64|
                  |L18.62|
;;;251      else  /* don't change stack */
;;;252        condmovestack(L,{},{});  /* (change only for debugging) */
00003e  bf00              NOP      
                  |L18.64|
;;;253      luaE_shrinkCI(L);  /* shrink CI list */
000040  4630              MOV      r0,r6
000042  f7fffffe          BL       luaE_shrinkCI
;;;254    }
000046  bd70              POP      {r4-r6,pc}
;;;255    
                          ENDP

                  |L18.72|
                          DCD      0x000f4240

                          AREA ||i.luaD_throw||, CODE, READONLY, ALIGN=1

                  luaD_throw PROC
;;;110    
;;;111    l_noret luaD_throw (lua_State *L, int errcode) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;112      if (L->errorJmp) {  /* thread has an error handler? */
000006  6b20              LDR      r0,[r4,#0x30]
000008  b140              CBZ      r0,|L19.28|
;;;113        L->errorJmp->status = errcode;  /* set status */
00000a  6b20              LDR      r0,[r4,#0x30]
00000c  f8c060a8          STR      r6,[r0,#0xa8]
;;;114        LUAI_THROW(L, L->errorJmp);  /* jump to it */
000010  6b21              LDR      r1,[r4,#0x30]
000012  f1010008          ADD      r0,r1,#8
000016  2101              MOVS     r1,#1
000018  f7fffffe          BL       longjmp
                  |L19.28|
;;;115      }
;;;116      else {  /* thread has no error handler */
;;;117        global_State *g = G(L);
00001c  6925              LDR      r5,[r4,#0x10]
;;;118        L->status = cast_byte(errcode);  /* mark it as dead */
00001e  7226              STRB     r6,[r4,#8]
;;;119        if (g->mainthread->errorJmp) {  /* main thread has a handler? */
000020  f8d5008c          LDR      r0,[r5,#0x8c]
000024  6b00              LDR      r0,[r0,#0x30]
000026  b1b0              CBZ      r0,|L19.86|
;;;120          setobjs2s(L, g->mainthread->top++, L->top - 1);  /* copy error obj. */
000028  f8552f8c          LDR      r2,[r5,#0x8c]!
00002c  68d0              LDR      r0,[r2,#0xc]
00002e  682a              LDR      r2,[r5,#0]
000030  68d2              LDR      r2,[r2,#0xc]
000032  3210              ADDS     r2,r2,#0x10
000034  682b              LDR      r3,[r5,#0]
000036  60da              STR      r2,[r3,#0xc]
000038  68e2              LDR      r2,[r4,#0xc]
00003a  f1a20110          SUB      r1,r2,#0x10
00003e  e9d12300          LDRD     r2,r3,[r1,#0]
000042  e9c02300          STRD     r2,r3,[r0,#0]
000046  7a0a              LDRB     r2,[r1,#8]
000048  7202              STRB     r2,[r0,#8]
;;;121          luaD_throw(g->mainthread, errcode);  /* re-throw in main thread */
00004a  f855098c          LDR      r0,[r5],#-0x8c
00004e  4631              MOV      r1,r6
000050  f7fffffe          BL       luaD_throw
000054  e015              B        |L19.130|
                  |L19.86|
;;;122        }
;;;123        else {  /* no handler at all; abort */
;;;124          if (g->panic) {  /* panic function? */
000056  f8d50088          LDR      r0,[r5,#0x88]
00005a  b180              CBZ      r0,|L19.126|
;;;125            seterrorobj(L, errcode, L->top);  /* assume EXTRA_STACK */
00005c  4631              MOV      r1,r6
00005e  4620              MOV      r0,r4
000060  68e2              LDR      r2,[r4,#0xc]
000062  f7fffffe          BL       seterrorobj
;;;126            if (L->ci->top < L->top)
000066  6960              LDR      r0,[r4,#0x14]
000068  6840              LDR      r0,[r0,#4]
00006a  68e1              LDR      r1,[r4,#0xc]
00006c  4288              CMP      r0,r1
00006e  d202              BCS      |L19.118|
;;;127              L->ci->top = L->top;  /* pushing msg. can break this invariant */
000070  6961              LDR      r1,[r4,#0x14]
000072  68e0              LDR      r0,[r4,#0xc]
000074  6048              STR      r0,[r1,#4]
                  |L19.118|
;;;128            lua_unlock(L);
;;;129            g->panic(L);  /* call panic function (last chance to jump out) */
000076  4620              MOV      r0,r4
000078  f8d51088          LDR      r1,[r5,#0x88]
00007c  4788              BLX      r1
                  |L19.126|
;;;130          }
;;;131          abort();
00007e  f7fffffe          BL       abort
                  |L19.130|
;;;132        }
;;;133      }
000082  bf00              NOP      
;;;134    }
000084  bd70              POP      {r4-r6,pc}
;;;135    
                          ENDP


                          AREA ||i.luaD_tryfuncTM||, CODE, READONLY, ALIGN=2

                  luaD_tryfuncTM PROC
;;;347    */
;;;348    void luaD_tryfuncTM (lua_State *L, StkId func) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
;;;349      const TValue *tm = luaT_gettmbyobj(L, s2v(func), TM_CALL);
000008  2219              MOVS     r2,#0x19
00000a  4629              MOV      r1,r5
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       luaT_gettmbyobj
000012  4607              MOV      r7,r0
;;;350      StkId p;
;;;351      if (!ttisfunction(tm))
000014  7a38              LDRB     r0,[r7,#8]
000016  f000000f          AND      r0,r0,#0xf
00001a  2806              CMP      r0,#6
00001c  d004              BEQ      |L20.40|
;;;352        luaG_typeerror(L, s2v(func), "call");
00001e  a210              ADR      r2,|L20.96|
000020  4629              MOV      r1,r5
000022  4630              MOV      r0,r6
000024  f7fffffe          BL       luaG_typeerror
                  |L20.40|
;;;353      for (p = L->top; p > func; p--)
000028  68f4              LDR      r4,[r6,#0xc]
00002a  e009              B        |L20.64|
                  |L20.44|
;;;354        setobjs2s(L, p, p-1);
00002c  4620              MOV      r0,r4
00002e  f1a40110          SUB      r1,r4,#0x10
000032  e9d12300          LDRD     r2,r3,[r1,#0]
000036  e9c02300          STRD     r2,r3,[r0,#0]
00003a  7a0a              LDRB     r2,[r1,#8]
00003c  7202              STRB     r2,[r0,#8]
00003e  3c10              SUBS     r4,r4,#0x10           ;353
                  |L20.64|
000040  42ac              CMP      r4,r5                 ;353
000042  d8f3              BHI      |L20.44|
;;;355      L->top++;  /* assume EXTRA_STACK */
000044  68f0              LDR      r0,[r6,#0xc]
000046  3010              ADDS     r0,r0,#0x10
000048  60f0              STR      r0,[r6,#0xc]
;;;356      setobj2s(L, func, tm);  /* metamethod is the new function to be called */
00004a  4628              MOV      r0,r5
00004c  4639              MOV      r1,r7
00004e  e9d12300          LDRD     r2,r3,[r1,#0]
000052  e9c02300          STRD     r2,r3,[r0,#0]
000056  7a0a              LDRB     r2,[r1,#8]
000058  7202              STRB     r2,[r0,#8]
;;;357    }
00005a  e8bd81f0          POP      {r4-r8,pc}
;;;358    
                          ENDP

00005e  0000              DCW      0x0000
                  |L20.96|
000060  63616c6c          DCB      "call",0
000064  00      
000065  00                DCB      0
000066  00                DCB      0
000067  00                DCB      0

                          AREA ||i.lua_isyieldable||, CODE, READONLY, ALIGN=1

                  lua_isyieldable PROC
;;;694    
;;;695    LUA_API int lua_isyieldable (lua_State *L) {
000000  4601              MOV      r1,r0
;;;696      return (L->nny == 0);
000002  f8b1006c          LDRH     r0,[r1,#0x6c]
000006  b908              CBNZ     r0,|L21.12|
000008  2001              MOVS     r0,#1
                  |L21.10|
;;;697    }
00000a  4770              BX       lr
                  |L21.12|
00000c  2000              MOVS     r0,#0                 ;696
00000e  e7fc              B        |L21.10|
;;;698    
                          ENDP


                          AREA ||i.lua_resume||, CODE, READONLY, ALIGN=2

                  lua_resume PROC
;;;653    
;;;654    LUA_API int lua_resume (lua_State *L, lua_State *from, int nargs,
000000  b5ff              PUSH     {r0-r7,lr}
;;;655                                          int *nresults) {
000002  b081              SUB      sp,sp,#4
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  461e              MOV      r6,r3
;;;656      int status;
;;;657      unsigned short oldnny = L->nny;  /* save "number of non-yieldable" calls */
00000a  f8b4706c          LDRH     r7,[r4,#0x6c]
;;;658      lua_lock(L);
;;;659      if (L->status == LUA_OK) {  /* may be starting a coroutine */
00000e  7a20              LDRB     r0,[r4,#8]
000010  b958              CBNZ     r0,|L22.42|
;;;660        if (L->ci != &L->base_ci)  /* not in base level? */
000012  f1040034          ADD      r0,r4,#0x34
000016  6961              LDR      r1,[r4,#0x14]
000018  4281              CMP      r1,r0
00001a  d00f              BEQ      |L22.60|
;;;661          return resume_error(L, "cannot resume non-suspended coroutine", nargs);
00001c  a133              ADR      r1,|L22.236|
00001e  4620              MOV      r0,r4
000020  9a03              LDR      r2,[sp,#0xc]
000022  f7fffffe          BL       resume_error
                  |L22.38|
;;;662      }
;;;663      else if (L->status != LUA_YIELD)
;;;664        return resume_error(L, "cannot resume dead coroutine", nargs);
;;;665      L->nCcalls = (from) ? from->nCcalls + 1 : 1;
;;;666      if (L->nCcalls >= LUAI_MAXCCALLS)
;;;667        return resume_error(L, "C stack overflow", nargs);
;;;668      luai_userstateresume(L, nargs);
;;;669      L->nny = 0;  /* allow yields */
;;;670      api_checknelems(L, (L->status == LUA_OK) ? nargs + 1 : nargs);
;;;671      status = luaD_rawrunprotected(L, resume, &nargs);
;;;672      if (status == -1)  /* error calling 'lua_resume'? */
;;;673        status = LUA_ERRRUN;
;;;674      else {  /* continue running after recoverable errors */
;;;675        while (errorstatus(status) && recover(L, status)) {
;;;676          /* unroll continuation */
;;;677          status = luaD_rawrunprotected(L, unroll, &status);
;;;678        }
;;;679        if (errorstatus(status)) {  /* unrecoverable error? */
;;;680          L->status = cast_byte(status);  /* mark thread as 'dead' */
;;;681          seterrorobj(L, status, L->top);  /* push error message */
;;;682          L->ci->top = L->top;
;;;683        }
;;;684        else lua_assert(status == L->status);  /* normal end or yield */
;;;685      }
;;;686      *nresults = (status == LUA_YIELD) ? L->ci->u2.nyield
;;;687                                        : cast_int(L->top - (L->ci->func + 1));
;;;688      L->nny = oldnny;  /* restore 'nny' */
;;;689      L->nCcalls--;
;;;690      lua_unlock(L);
;;;691      return status;
;;;692    }
000026  b005              ADD      sp,sp,#0x14
000028  bdf0              POP      {r4-r7,pc}
                  |L22.42|
00002a  7a20              LDRB     r0,[r4,#8]            ;663
00002c  2801              CMP      r0,#1                 ;663
00002e  d005              BEQ      |L22.60|
000030  a138              ADR      r1,|L22.276|
000032  4620              MOV      r0,r4                 ;664
000034  9a03              LDR      r2,[sp,#0xc]          ;664
000036  f7fffffe          BL       resume_error
00003a  e7f4              B        |L22.38|
                  |L22.60|
00003c  b11d              CBZ      r5,|L22.70|
00003e  f8b5006e          LDRH     r0,[r5,#0x6e]         ;665
000042  1c40              ADDS     r0,r0,#1              ;665
000044  e000              B        |L22.72|
                  |L22.70|
000046  2001              MOVS     r0,#1                 ;665
                  |L22.72|
000048  f8a4006e          STRH     r0,[r4,#0x6e]         ;665
00004c  f8b4006e          LDRH     r0,[r4,#0x6e]         ;666
000050  f6400198          MOV      r1,#0x898             ;666
000054  4288              CMP      r0,r1                 ;666
000056  db05              BLT      |L22.100|
000058  a136              ADR      r1,|L22.308|
00005a  4620              MOV      r0,r4                 ;667
00005c  9a03              LDR      r2,[sp,#0xc]          ;667
00005e  f7fffffe          BL       resume_error
000062  e7e0              B        |L22.38|
                  |L22.100|
000064  2000              MOVS     r0,#0                 ;669
000066  f8a4006c          STRH     r0,[r4,#0x6c]         ;669
00006a  aa03              ADD      r2,sp,#0xc            ;671
00006c  4936              LDR      r1,|L22.328|
00006e  4620              MOV      r0,r4                 ;671
000070  f7fffffe          BL       luaD_rawrunprotected
000074  9000              STR      r0,[sp,#0]            ;671
000076  9800              LDR      r0,[sp,#0]            ;672
000078  1c40              ADDS     r0,r0,#1              ;672
00007a  b910              CBNZ     r0,|L22.130|
00007c  2002              MOVS     r0,#2                 ;673
00007e  9000              STR      r0,[sp,#0]            ;673
000080  e01e              B        |L22.192|
                  |L22.130|
000082  e005              B        |L22.144|
                  |L22.132|
000084  466a              MOV      r2,sp                 ;677
000086  4931              LDR      r1,|L22.332|
000088  4620              MOV      r0,r4                 ;677
00008a  f7fffffe          BL       luaD_rawrunprotected
00008e  9000              STR      r0,[sp,#0]            ;677
                  |L22.144|
000090  9800              LDR      r0,[sp,#0]            ;675
000092  2801              CMP      r0,#1                 ;675
000094  dd05              BLE      |L22.162|
000096  4620              MOV      r0,r4                 ;675
000098  9900              LDR      r1,[sp,#0]            ;675
00009a  f7fffffe          BL       recover
00009e  2800              CMP      r0,#0                 ;675
0000a0  d1f0              BNE      |L22.132|
                  |L22.162|
0000a2  9800              LDR      r0,[sp,#0]            ;679
0000a4  2801              CMP      r0,#1                 ;679
0000a6  dd0a              BLE      |L22.190|
0000a8  9800              LDR      r0,[sp,#0]            ;680
0000aa  7220              STRB     r0,[r4,#8]            ;680
0000ac  68e2              LDR      r2,[r4,#0xc]          ;681
0000ae  4620              MOV      r0,r4                 ;681
0000b0  9900              LDR      r1,[sp,#0]            ;681
0000b2  f7fffffe          BL       seterrorobj
0000b6  6961              LDR      r1,[r4,#0x14]         ;682
0000b8  68e0              LDR      r0,[r4,#0xc]          ;682
0000ba  6048              STR      r0,[r1,#4]            ;682
0000bc  e000              B        |L22.192|
                  |L22.190|
0000be  bf00              NOP                            ;684
                  |L22.192|
0000c0  9800              LDR      r0,[sp,#0]            ;686
0000c2  2801              CMP      r0,#1                 ;686
0000c4  d102              BNE      |L22.204|
0000c6  6960              LDR      r0,[r4,#0x14]         ;686
0000c8  69c0              LDR      r0,[r0,#0x1c]         ;686
0000ca  e005              B        |L22.216|
                  |L22.204|
0000cc  68e1              LDR      r1,[r4,#0xc]          ;687
0000ce  6960              LDR      r0,[r4,#0x14]         ;687
0000d0  6800              LDR      r0,[r0,#0]            ;687
0000d2  3010              ADDS     r0,r0,#0x10           ;687
0000d4  1a08              SUBS     r0,r1,r0              ;687
0000d6  1100              ASRS     r0,r0,#4              ;687
                  |L22.216|
0000d8  6030              STR      r0,[r6,#0]            ;687
0000da  f8247f6c          STRH     r7,[r4,#0x6c]!        ;688
0000de  8860              LDRH     r0,[r4,#2]            ;689
0000e0  1e40              SUBS     r0,r0,#1              ;689
0000e2  8060              STRH     r0,[r4,#2]            ;689
0000e4  3c6c              SUBS     r4,r4,#0x6c           ;689
0000e6  9800              LDR      r0,[sp,#0]            ;691
0000e8  e79d              B        |L22.38|
;;;693    
                          ENDP

0000ea  0000              DCW      0x0000
                  |L22.236|
0000ec  63616e6e          DCB      "cannot resume non-suspended coroutine",0
0000f0  6f742072
0000f4  6573756d
0000f8  65206e6f
0000fc  6e2d7375
000100  7370656e
000104  64656420
000108  636f726f
00010c  7574696e
000110  6500    
000112  00                DCB      0
000113  00                DCB      0
                  |L22.276|
000114  63616e6e          DCB      "cannot resume dead coroutine",0
000118  6f742072
00011c  6573756d
000120  65206465
000124  61642063
000128  6f726f75
00012c  74696e65
000130  00      
000131  00                DCB      0
000132  00                DCB      0
000133  00                DCB      0
                  |L22.308|
000134  43207374          DCB      "C stack overflow",0
000138  61636b20
00013c  6f766572
000140  666c6f77
000144  00      
000145  00                DCB      0
000146  00                DCB      0
000147  00                DCB      0
                  |L22.328|
                          DCD      resume
                  |L22.332|
                          DCD      unroll

                          AREA ||i.lua_yieldk||, CODE, READONLY, ALIGN=2

                  lua_yieldk PROC
;;;699    
;;;700    LUA_API int lua_yieldk (lua_State *L, int nresults, lua_KContext ctx,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;701                            lua_KFunction k) {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;702      CallInfo *ci = L->ci;
00000c  6965              LDR      r5,[r4,#0x14]
;;;703      luai_userstateyield(L, nresults);
;;;704      lua_lock(L);
;;;705      api_checknelems(L, nresults);
;;;706      if (L->nny > 0) {
00000e  f8b4006c          LDRH     r0,[r4,#0x6c]
000012  2800              CMP      r0,#0
000014  dd0d              BLE      |L23.50|
;;;707        if (L != G(L)->mainthread)
000016  6920              LDR      r0,[r4,#0x10]
000018  f8d0008c          LDR      r0,[r0,#0x8c]
00001c  42a0              CMP      r0,r4
00001e  d004              BEQ      |L23.42|
;;;708          luaG_runerror(L, "attempt to yield across a C-call boundary");
000020  a110              ADR      r1,|L23.100|
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       luaG_runerror
000028  e003              B        |L23.50|
                  |L23.42|
;;;709        else
;;;710          luaG_runerror(L, "attempt to yield from outside a coroutine");
00002a  a119              ADR      r1,|L23.144|
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       luaG_runerror
                  |L23.50|
;;;711      }
;;;712      L->status = LUA_YIELD;
000032  2001              MOVS     r0,#1
000034  7220              STRB     r0,[r4,#8]
;;;713      if (isLua(ci)) {  /* inside a hook? */
000036  f8950022          LDRB     r0,[r5,#0x22]
00003a  f0000002          AND      r0,r0,#2
00003e  b910              CBNZ     r0,|L23.70|
;;;714        lua_assert(!isLuacode(ci));
;;;715        api_check(L, k == NULL, "hooks cannot continue after yielding");
;;;716        ci->u2.nyield = 0;  /* no results */
000040  2000              MOVS     r0,#0
000042  61e8              STR      r0,[r5,#0x1c]
000044  e00a              B        |L23.92|
                  |L23.70|
;;;717      }
;;;718      else {
;;;719        if ((ci->u.c.k = k) != NULL)  /* is there a continuation? */
000046  f8c58010          STR      r8,[r5,#0x10]
00004a  f1b80f00          CMP      r8,#0
00004e  d000              BEQ      |L23.82|
;;;720          ci->u.c.ctx = ctx;  /* save context */
000050  61af              STR      r7,[r5,#0x18]
                  |L23.82|
;;;721        ci->u2.nyield = nresults;  /* save number of results */
000052  61ee              STR      r6,[r5,#0x1c]
;;;722        luaD_throw(L, LUA_YIELD);
000054  2101              MOVS     r1,#1
000056  4620              MOV      r0,r4
000058  f7fffffe          BL       luaD_throw
                  |L23.92|
;;;723      }
;;;724      lua_assert(ci->callstatus & CIST_HOOKED);  /* must be inside a hook */
;;;725      lua_unlock(L);
;;;726      return 0;  /* return to 'luaD_hook' */
00005c  2000              MOVS     r0,#0
;;;727    }
00005e  e8bd81f0          POP      {r4-r8,pc}
;;;728    
                          ENDP

000062  0000              DCW      0x0000
                  |L23.100|
000064  61747465          DCB      "attempt to yield across a C-call boundary",0
000068  6d707420
00006c  746f2079
000070  69656c64
000074  20616372
000078  6f737320
00007c  6120432d
000080  63616c6c
000084  20626f75
000088  6e646172
00008c  7900    
00008e  00                DCB      0
00008f  00                DCB      0
                  |L23.144|
000090  61747465          DCB      "attempt to yield from outside a coroutine",0
000094  6d707420
000098  746f2079
00009c  69656c64
0000a0  2066726f
0000a4  6d206f75
0000a8  74736964
0000ac  65206120
0000b0  636f726f
0000b4  7574696e
0000b8  6500    
0000ba  00                DCB      0
0000bb  00                DCB      0

                          AREA ||i.moveresults||, CODE, READONLY, ALIGN=1

                  moveresults PROC
;;;365    */
;;;366    static void moveresults (lua_State *L, StkId firstResult, StkId res,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;367                                           int nres, int wanted) {
000004  4605              MOV      r5,r0
000006  9c06              LDR      r4,[sp,#0x18]
;;;368      switch (wanted) {  /* handle typical cases separately */
000008  f1b43fff          CMP      r4,#0xffffffff
00000c  d012              BEQ      |L24.52|
00000e  b114              CBZ      r4,|L24.22|
000010  2c01              CMP      r4,#1
000012  d122              BNE      |L24.90|
000014  e000              B        |L24.24|
                  |L24.22|
;;;369        case 0: break;  /* nothing to move */
000016  e04e              B        |L24.182|
                  |L24.24|
;;;370        case 1: {  /* one result needed */
;;;371          if (nres == 0)   /* no results? */
000018  b913              CBNZ     r3,|L24.32|
;;;372            setnilvalue(s2v(res));  /* adjust with nil */
00001a  2000              MOVS     r0,#0
00001c  7210              STRB     r0,[r2,#8]
00001e  e008              B        |L24.50|
                  |L24.32|
;;;373          else
;;;374            setobjs2s(L, res, firstResult);  /* move it to proper place */
000020  4616              MOV      r6,r2
000022  4608              MOV      r0,r1
000024  e9d07c00          LDRD     r7,r12,[r0,#0]
000028  e9c67c00          STRD     r7,r12,[r6,#0]
00002c  7a07              LDRB     r7,[r0,#8]
00002e  7237              STRB     r7,[r6,#8]
000030  bf00              NOP      
                  |L24.50|
;;;375          break;
000032  e040              B        |L24.182|
                  |L24.52|
;;;376        }
;;;377        case LUA_MULTRET: {
;;;378          int i;
;;;379          for (i = 0; i < nres; i++)  /* move all results to correct place */
000034  2000              MOVS     r0,#0
000036  e00c              B        |L24.82|
                  |L24.56|
;;;380            setobjs2s(L, res + i, firstResult + i);
000038  eb021600          ADD      r6,r2,r0,LSL #4
00003c  eb011700          ADD      r7,r1,r0,LSL #4
000040  e9d78c00          LDRD     r8,r12,[r7,#0]
000044  e9c68c00          STRD     r8,r12,[r6,#0]
000048  f897c008          LDRB     r12,[r7,#8]
00004c  f886c008          STRB     r12,[r6,#8]
000050  1c40              ADDS     r0,r0,#1              ;379
                  |L24.82|
000052  4298              CMP      r0,r3                 ;379
000054  dbf0              BLT      |L24.56|
;;;381          wanted = nres;  /* it wanted what it had */
000056  461c              MOV      r4,r3
;;;382          break;
000058  e02d              B        |L24.182|
                  |L24.90|
;;;383        }
;;;384        default: {
;;;385          int i;
;;;386          if (wanted <= nres) {  /* enough results? */
00005a  429c              CMP      r4,r3
00005c  dc11              BGT      |L24.130|
;;;387            for (i = 0; i < wanted; i++)  /* move wanted results to correct place */
00005e  2000              MOVS     r0,#0
000060  e00c              B        |L24.124|
                  |L24.98|
;;;388              setobjs2s(L, res + i, firstResult + i);
000062  eb021600          ADD      r6,r2,r0,LSL #4
000066  eb011700          ADD      r7,r1,r0,LSL #4
00006a  e9d78c00          LDRD     r8,r12,[r7,#0]
00006e  e9c68c00          STRD     r8,r12,[r6,#0]
000072  f897c008          LDRB     r12,[r7,#8]
000076  f886c008          STRB     r12,[r6,#8]
00007a  1c40              ADDS     r0,r0,#1              ;387
                  |L24.124|
00007c  42a0              CMP      r0,r4                 ;387
00007e  dbf0              BLT      |L24.98|
000080  e018              B        |L24.180|
                  |L24.130|
;;;389          }
;;;390          else {  /* not enough results; use all of them plus nils */
;;;391            for (i = 0; i < nres; i++)  /* move all results to correct place */
000082  2000              MOVS     r0,#0
000084  e00c              B        |L24.160|
                  |L24.134|
;;;392              setobjs2s(L, res + i, firstResult + i);
000086  eb021600          ADD      r6,r2,r0,LSL #4
00008a  eb011700          ADD      r7,r1,r0,LSL #4
00008e  e9d78c00          LDRD     r8,r12,[r7,#0]
000092  e9c68c00          STRD     r8,r12,[r6,#0]
000096  f897c008          LDRB     r12,[r7,#8]
00009a  f886c008          STRB     r12,[r6,#8]
00009e  1c40              ADDS     r0,r0,#1              ;391
                  |L24.160|
0000a0  4298              CMP      r0,r3                 ;391
0000a2  dbf0              BLT      |L24.134|
;;;393            for (; i < wanted; i++)  /* complete wanted number of results */
0000a4  e004              B        |L24.176|
                  |L24.166|
;;;394              setnilvalue(s2v(res + i));
0000a6  2600              MOVS     r6,#0
0000a8  eb021700          ADD      r7,r2,r0,LSL #4
0000ac  723e              STRB     r6,[r7,#8]
0000ae  1c40              ADDS     r0,r0,#1              ;393
                  |L24.176|
0000b0  42a0              CMP      r0,r4                 ;393
0000b2  dbf8              BLT      |L24.166|
                  |L24.180|
;;;395          }
;;;396          break;
0000b4  bf00              NOP      
                  |L24.182|
0000b6  bf00              NOP                            ;369
;;;397        }
;;;398      }
;;;399      L->top = res + wanted;  /* top points after the last result */
0000b8  eb021004          ADD      r0,r2,r4,LSL #4
0000bc  60e8              STR      r0,[r5,#0xc]
;;;400    }
0000be  e8bd81f0          POP      {r4-r8,pc}
;;;401    
                          ENDP


                          AREA ||i.recover||, CODE, READONLY, ALIGN=1

                  recover PROC
;;;588    */
;;;589    static int recover (lua_State *L, int status) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;590      StkId oldtop;
;;;591      CallInfo *ci = findpcall(L);
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       findpcall
00000e  4605              MOV      r5,r0
;;;592      if (ci == NULL) return 0;  /* no recovery point */
000010  b915              CBNZ     r5,|L25.24|
000012  2000              MOVS     r0,#0
                  |L25.20|
;;;593      /* "finish" luaD_pcall */
;;;594      oldtop = restorestack(L, ci->u2.funcidx);
;;;595      luaF_close(L, oldtop);
;;;596      seterrorobj(L, status, oldtop);
;;;597      L->ci = ci;
;;;598      L->allowhook = getoah(ci->callstatus);  /* restore original 'allowhook' */
;;;599      L->nny = 0;  /* should be zero to be yieldable */
;;;600      luaD_shrinkstack(L);
;;;601      L->errfunc = ci->u.c.old_errfunc;
;;;602      return 1;  /* continue running the coroutine */
;;;603    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L25.24|
000018  6a20              LDR      r0,[r4,#0x20]         ;594
00001a  69e9              LDR      r1,[r5,#0x1c]         ;594
00001c  1846              ADDS     r6,r0,r1              ;594
00001e  4631              MOV      r1,r6                 ;595
000020  4620              MOV      r0,r4                 ;595
000022  f7fffffe          BL       luaF_close
000026  4632              MOV      r2,r6                 ;596
000028  4639              MOV      r1,r7                 ;596
00002a  4620              MOV      r0,r4                 ;596
00002c  f7fffffe          BL       seterrorobj
000030  6165              STR      r5,[r4,#0x14]         ;597
000032  f8950022          LDRB     r0,[r5,#0x22]         ;598
000036  f0000001          AND      r0,r0,#1              ;598
00003a  f8840074          STRB     r0,[r4,#0x74]         ;598
00003e  2000              MOVS     r0,#0                 ;599
000040  f8a4006c          STRH     r0,[r4,#0x6c]         ;599
000044  4620              MOV      r0,r4                 ;600
000046  f7fffffe          BL       luaD_shrinkstack
00004a  6968              LDR      r0,[r5,#0x14]         ;601
00004c  65e0              STR      r0,[r4,#0x5c]         ;601
00004e  2001              MOVS     r0,#1                 ;602
000050  e7e0              B        |L25.20|
;;;604    
                          ENDP


                          AREA ||i.resume||, CODE, READONLY, ALIGN=1

                  resume PROC
;;;626    */
;;;627    static void resume (lua_State *L, void *ud) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;628      int n = *(cast(int*, ud));  /* number of arguments */
000008  683e              LDR      r6,[r7,#0]
;;;629      StkId firstArg = L->top - n;  /* first argument */
00000a  68e0              LDR      r0,[r4,#0xc]
00000c  eba01806          SUB      r8,r0,r6,LSL #4
;;;630      CallInfo *ci = L->ci;
000010  6965              LDR      r5,[r4,#0x14]
;;;631      if (L->status == LUA_OK) {  /* starting a coroutine? */
000012  7a20              LDRB     r0,[r4,#8]
000014  b938              CBNZ     r0,|L26.38|
;;;632        luaD_call(L, firstArg - 1, LUA_MULTRET);
000016  f1a80110          SUB      r1,r8,#0x10
00001a  f04f32ff          MOV      r2,#0xffffffff
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       luaD_call
000024  e020              B        |L26.104|
                  |L26.38|
;;;633      }
;;;634      else {  /* resuming from previous yield */
;;;635        lua_assert(L->status == LUA_YIELD);
;;;636        L->status = LUA_OK;  /* mark that it is running (again) */
000026  2000              MOVS     r0,#0
000028  7220              STRB     r0,[r4,#8]
;;;637        if (isLua(ci))  /* yielded inside a hook? */
00002a  f8950022          LDRB     r0,[r5,#0x22]
00002e  f0000002          AND      r0,r0,#2
000032  b920              CBNZ     r0,|L26.62|
;;;638          luaV_execute(L, ci);  /* just continue running Lua code */
000034  4629              MOV      r1,r5
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       luaV_execute
00003c  e010              B        |L26.96|
                  |L26.62|
;;;639        else {  /* 'common' yield */
;;;640          if (ci->u.c.k != NULL) {  /* does it have a continuation function? */
00003e  6928              LDR      r0,[r5,#0x10]
000040  b140              CBZ      r0,|L26.84|
;;;641            lua_unlock(L);
;;;642            n = (*ci->u.c.k)(L, LUA_YIELD, ci->u.c.ctx); /* call continuation */
000042  2101              MOVS     r1,#1
000044  4620              MOV      r0,r4
000046  692b              LDR      r3,[r5,#0x10]
000048  69aa              LDR      r2,[r5,#0x18]
00004a  4798              BLX      r3
00004c  4606              MOV      r6,r0
;;;643            lua_lock(L);
;;;644            api_checknelems(L, n);
;;;645            firstArg = L->top - n;  /* yield results come from continuation */
00004e  68e0              LDR      r0,[r4,#0xc]
000050  eba01806          SUB      r8,r0,r6,LSL #4
                  |L26.84|
;;;646          }
;;;647          luaD_poscall(L, ci, firstArg, n);  /* finish 'luaD_call' */
000054  4633              MOV      r3,r6
000056  4642              MOV      r2,r8
000058  4629              MOV      r1,r5
00005a  4620              MOV      r0,r4
00005c  f7fffffe          BL       luaD_poscall
                  |L26.96|
;;;648        }
;;;649        unroll(L, NULL);  /* run continuation */
000060  2100              MOVS     r1,#0
000062  4620              MOV      r0,r4
000064  f7fffffe          BL       unroll
                  |L26.104|
;;;650      }
;;;651    }
000068  e8bd81f0          POP      {r4-r8,pc}
;;;652    
                          ENDP


                          AREA ||i.resume_error||, CODE, READONLY, ALIGN=1

                  resume_error PROC
;;;610    */
;;;611    static int resume_error (lua_State *L, const char *msg, int narg) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4615              MOV      r5,r2
;;;612      L->top -= narg;  /* remove args from the stack */
00000a  68e0              LDR      r0,[r4,#0xc]
00000c  eba01005          SUB      r0,r0,r5,LSL #4
000010  60e0              STR      r0,[r4,#0xc]
;;;613      setsvalue2s(L, L->top, luaS_new(L, msg));  /* push error message */
000012  68e6              LDR      r6,[r4,#0xc]
000014  4641              MOV      r1,r8
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       luaS_new
00001c  4607              MOV      r7,r0
00001e  6037              STR      r7,[r6,#0]
000020  7938              LDRB     r0,[r7,#4]
000022  f0400040          ORR      r0,r0,#0x40
000026  7230              STRB     r0,[r6,#8]
;;;614      api_incr_top(L);
000028  68e0              LDR      r0,[r4,#0xc]
00002a  3010              ADDS     r0,r0,#0x10
00002c  60e0              STR      r0,[r4,#0xc]
;;;615      lua_unlock(L);
;;;616      return LUA_ERRRUN;
00002e  2002              MOVS     r0,#2
;;;617    }
000030  e8bd81f0          POP      {r4-r8,pc}
;;;618    
                          ENDP


                          AREA ||i.rethook||, CODE, READONLY, ALIGN=1

                  rethook PROC
;;;321    
;;;322    static void rethook (lua_State *L, CallInfo *ci, StkId firstres, int nres) {
000000  e92d43f8          PUSH     {r3-r9,lr}
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;323      int delta = 0;
00000c  f04f0800          MOV      r8,#0
;;;324      if (isLuacode(ci)) {
000010  f8940022          LDRB     r0,[r4,#0x22]
000014  f0000006          AND      r0,r0,#6
000018  b980              CBNZ     r0,|L28.60|
;;;325        Proto *p = clLvalue(s2v(ci->func))->p;
00001a  6821              LDR      r1,[r4,#0]
00001c  6809              LDR      r1,[r1,#0]
00001e  68c8              LDR      r0,[r1,#0xc]
;;;326        if (p->is_vararg)
000020  79c1              LDRB     r1,[r0,#7]
000022  b121              CBZ      r1,|L28.46|
;;;327          delta = ci->u.l.nextraargs + p->numparams + 1;
000024  7982              LDRB     r2,[r0,#6]
000026  69a1              LDR      r1,[r4,#0x18]
000028  4411              ADD      r1,r1,r2
00002a  f1010801          ADD      r8,r1,#1
                  |L28.46|
;;;328        if (L->top < ci->top)
00002e  68e9              LDR      r1,[r5,#0xc]
000030  6862              LDR      r2,[r4,#4]
000032  4291              CMP      r1,r2
000034  d201              BCS      |L28.58|
;;;329          L->top = ci->top;  /* correct top */
000036  6861              LDR      r1,[r4,#4]
000038  60e9              STR      r1,[r5,#0xc]
                  |L28.58|
;;;330      }
00003a  bf00              NOP      
                  |L28.60|
;;;331      if (L->hookmask & LUA_MASKRET) {  /* is return hook on? */
00003c  f8950070          LDRB     r0,[r5,#0x70]
000040  f0000002          AND      r0,r0,#2
000044  b1a0              CBZ      r0,|L28.112|
;;;332        int fTransfer;
;;;333        ci->func += delta;  /* if vararg, back to virtual 'func' */
000046  6820              LDR      r0,[r4,#0]
000048  eb001008          ADD      r0,r0,r8,LSL #4
00004c  6020              STR      r0,[r4,#0]
;;;334        fTransfer = cast(unsigned short, firstres - ci->func);
00004e  6820              LDR      r0,[r4,#0]
000050  1a30              SUBS     r0,r6,r0
000052  f3c0190f          UBFX     r9,r0,#4,#16
;;;335        luaD_hook(L, LUA_HOOKRET, -1, fTransfer, nres);  /* call it */
000056  464b              MOV      r3,r9
000058  f04f32ff          MOV      r2,#0xffffffff
00005c  2101              MOVS     r1,#1
00005e  4628              MOV      r0,r5
000060  9700              STR      r7,[sp,#0]
000062  f7fffffe          BL       luaD_hook
;;;336        ci->func -= delta;
000066  6820              LDR      r0,[r4,#0]
000068  eba01008          SUB      r0,r0,r8,LSL #4
00006c  6020              STR      r0,[r4,#0]
;;;337      }
00006e  bf00              NOP      
                  |L28.112|
;;;338      if (isLua(ci->previous))
000070  68a0              LDR      r0,[r4,#8]
000072  f8900022          LDRB     r0,[r0,#0x22]
000076  f0000002          AND      r0,r0,#2
00007a  b910              CBNZ     r0,|L28.130|
;;;339        L->oldpc = ci->previous->u.l.savedpc;  /* update 'oldpc' */
00007c  68a0              LDR      r0,[r4,#8]
00007e  6900              LDR      r0,[r0,#0x10]
000080  61a8              STR      r0,[r5,#0x18]
                  |L28.130|
;;;340    }
000082  e8bd83f8          POP      {r3-r9,pc}
;;;341    
                          ENDP


                          AREA ||i.seterrorobj||, CODE, READONLY, ALIGN=2

                  seterrorobj PROC
;;;90     
;;;91     static void seterrorobj (lua_State *L, int errcode, StkId oldtop) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
;;;92       switch (errcode) {
00000a  2f04              CMP      r7,#4
00000c  d002              BEQ      |L29.20|
00000e  2f06              CMP      r7,#6
000010  d11d              BNE      |L29.78|
000012  e00d              B        |L29.48|
                  |L29.20|
;;;93         case LUA_ERRMEM: {  /* memory error? */
;;;94           TString *memerrmsg = luaS_newliteral(L, MEMERRMSG);
000014  2211              MOVS     r2,#0x11
000016  a116              ADR      r1,|L29.112|
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       luaS_newlstr
00001e  4606              MOV      r6,r0
;;;95           setsvalue2s(L, oldtop, memerrmsg); /* reuse preregistered msg. */
000020  4620              MOV      r0,r4
000022  4631              MOV      r1,r6
000024  6001              STR      r1,[r0,#0]
000026  790a              LDRB     r2,[r1,#4]
000028  f0420240          ORR      r2,r2,#0x40
00002c  7202              STRB     r2,[r0,#8]
;;;96           break;
00002e  e019              B        |L29.100|
                  |L29.48|
;;;97         }
;;;98         case LUA_ERRERR: {
;;;99           setsvalue2s(L, oldtop, luaS_newliteral(L, "error in error handling"));
000030  4626              MOV      r6,r4
000032  2217              MOVS     r2,#0x17
000034  a113              ADR      r1,|L29.132|
000036  4628              MOV      r0,r5
000038  f7fffffe          BL       luaS_newlstr
00003c  4680              MOV      r8,r0
00003e  f8c68000          STR      r8,[r6,#0]
000042  f8980004          LDRB     r0,[r8,#4]
000046  f0400040          ORR      r0,r0,#0x40
00004a  7230              STRB     r0,[r6,#8]
;;;100          break;
00004c  e00a              B        |L29.100|
                  |L29.78|
;;;101        }
;;;102        default: {
;;;103          setobjs2s(L, oldtop, L->top - 1);  /* error message on current top */
00004e  4620              MOV      r0,r4
000050  68ea              LDR      r2,[r5,#0xc]
000052  f1a20110          SUB      r1,r2,#0x10
000056  e9d12300          LDRD     r2,r3,[r1,#0]
00005a  e9c02300          STRD     r2,r3,[r0,#0]
00005e  7a0a              LDRB     r2,[r1,#8]
000060  7202              STRB     r2,[r0,#8]
;;;104          break;
000062  bf00              NOP      
                  |L29.100|
000064  bf00              NOP                            ;96
;;;105        }
;;;106      }
;;;107      L->top = oldtop + 1;
000066  f1040010          ADD      r0,r4,#0x10
00006a  60e8              STR      r0,[r5,#0xc]
;;;108    }
00006c  e8bd81f0          POP      {r4-r8,pc}
;;;109    
                          ENDP

                  |L29.112|
000070  6e6f7420          DCB      "not enough memory",0
000074  656e6f75
000078  6768206d
00007c  656d6f72
000080  7900    
000082  00                DCB      0
000083  00                DCB      0
                  |L29.132|
000084  6572726f          DCB      "error in error handling",0
000088  7220696e
00008c  20657272
000090  6f722068
000094  616e646c
000098  696e6700

                          AREA ||i.stackinuse||, CODE, READONLY, ALIGN=1

                  stackinuse PROC
;;;229    
;;;230    static int stackinuse (lua_State *L) {
000000  4601              MOV      r1,r0
;;;231      CallInfo *ci;
;;;232      StkId lim = L->top;
000002  68cb              LDR      r3,[r1,#0xc]
;;;233      for (ci = L->ci; ci != NULL; ci = ci->previous) {
000004  694a              LDR      r2,[r1,#0x14]
000006  e004              B        |L30.18|
                  |L30.8|
;;;234        if (lim < ci->top) lim = ci->top;
000008  6850              LDR      r0,[r2,#4]
00000a  4298              CMP      r0,r3
00000c  d900              BLS      |L30.16|
00000e  6853              LDR      r3,[r2,#4]
                  |L30.16|
000010  6892              LDR      r2,[r2,#8]            ;233
                  |L30.18|
000012  2a00              CMP      r2,#0                 ;233
000014  d1f8              BNE      |L30.8|
;;;235      }
;;;236      lua_assert(lim <= L->stack_last);
;;;237      return cast_int(lim - L->stack) + 1;  /* part of stack in use */
000016  6a08              LDR      r0,[r1,#0x20]
000018  1a18              SUBS     r0,r3,r0
00001a  1100              ASRS     r0,r0,#4
00001c  1c40              ADDS     r0,r0,#1
;;;238    }
00001e  4770              BX       lr
;;;239    
                          ENDP


                          AREA ||i.unroll||, CODE, READONLY, ALIGN=1

                  unroll PROC
;;;554    */
;;;555    static void unroll (lua_State *L, void *ud) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;556      CallInfo *ci;
;;;557      if (ud != NULL)  /* error status? */
000006  b11d              CBZ      r5,|L31.16|
;;;558        finishCcall(L, *(int *)ud);  /* finish 'lua_pcallk' callee */
000008  4620              MOV      r0,r4
00000a  6829              LDR      r1,[r5,#0]
00000c  f7fffffe          BL       finishCcall
                  |L31.16|
;;;559      while ((ci = L->ci) != &L->base_ci) {  /* something in the stack */
000010  e010              B        |L31.52|
                  |L31.18|
;;;560        if (!isLua(ci))  /* C function? */
000012  f8960022          LDRB     r0,[r6,#0x22]
000016  f0000002          AND      r0,r0,#2
00001a  b120              CBZ      r0,|L31.38|
;;;561          finishCcall(L, LUA_YIELD);  /* complete its execution */
00001c  2101              MOVS     r1,#1
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       finishCcall
000024  e006              B        |L31.52|
                  |L31.38|
;;;562        else {  /* Lua function */
;;;563          luaV_finishOp(L);  /* finish interrupted instruction */
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       luaV_finishOp
;;;564          luaV_execute(L, ci);  /* execute down to higher C 'boundary' */
00002c  4631              MOV      r1,r6
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       luaV_execute
                  |L31.52|
000034  f1040034          ADD      r0,r4,#0x34           ;559
000038  6966              LDR      r6,[r4,#0x14]         ;559
00003a  4286              CMP      r6,r0                 ;559
00003c  d1e9              BNE      |L31.18|
;;;565        }
;;;566      }
;;;567    }
00003e  bd70              POP      {r4-r6,pc}
;;;568    
                          ENDP

