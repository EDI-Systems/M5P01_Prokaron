; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\lgc.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\lgc.d --cpu=Cortex-M7 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Inc -I.\Source -I.\Drivers -I..\..\..\M6P1(L)_Lua\lua -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6-ALIENTEK-LUA\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER -Dlua_writestring=RMP_lua_writestring -Dlua_writeline=RMP_lua_writeline --enum_is_int --signed_chars --omf_browse=.\debug\output\lgc.crf ..\..\..\M6P1(L)_Lua\lua\lgc.c]
                          THUMB

                          AREA ||i.GCTM||, CODE, READONLY, ALIGN=2

                  GCTM PROC
;;;867    
;;;868    static void GCTM (lua_State *L, int propagateerrors) {
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b087              SUB      sp,sp,#0x1c
000006  4604              MOV      r4,r0
000008  4688              MOV      r8,r1
;;;869      global_State *g = G(L);
00000a  6926              LDR      r6,[r4,#0x10]
;;;870      const TValue *tm;
;;;871      TValue v;
;;;872      lua_assert(!g->gcemergency);
;;;873      setgcovalue(L, &v, udata2finalize(g));
00000c  af02              ADD      r7,sp,#8
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       udata2finalize
000014  4681              MOV      r9,r0
000016  f8c79000          STR      r9,[r7,#0]
00001a  f8990004          LDRB     r0,[r9,#4]
00001e  f0400040          ORR      r0,r0,#0x40
000022  7238              STRB     r0,[r7,#8]
;;;874      tm = luaT_gettmbyobj(L, &v, TM_GC);
000024  2204              MOVS     r2,#4
000026  a902              ADD      r1,sp,#8
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       luaT_gettmbyobj
00002e  4605              MOV      r5,r0
;;;875      if (tm != NULL && ttisfunction(tm)) {  /* is there a finalizer? */
000030  2d00              CMP      r5,#0
000032  d05e              BEQ      |L1.242|
000034  7a28              LDRB     r0,[r5,#8]
000036  f000000f          AND      r0,r0,#0xf
00003a  2806              CMP      r0,#6
00003c  d159              BNE      |L1.242|
;;;876        int status;
;;;877        lu_byte oldah = L->allowhook;
00003e  f894a074          LDRB     r10,[r4,#0x74]
;;;878        int running  = g->gcrunning;
000042  f8969039          LDRB     r9,[r6,#0x39]
;;;879        L->allowhook = 0;  /* stop debug hooks during GC metamethod */
000046  2000              MOVS     r0,#0
000048  f8840074          STRB     r0,[r4,#0x74]
;;;880        g->gcrunning = 0;  /* avoid GC steps */
00004c  f8860039          STRB     r0,[r6,#0x39]
;;;881        setobj2s(L, L->top, tm);  /* push finalizer... */
000050  68e0              LDR      r0,[r4,#0xc]
000052  4629              MOV      r1,r5
000054  e9d12300          LDRD     r2,r3,[r1,#0]
000058  e9c02300          STRD     r2,r3,[r0,#0]
00005c  7a0a              LDRB     r2,[r1,#8]
00005e  7202              STRB     r2,[r0,#8]
;;;882        setobj2s(L, L->top + 1, &v);  /* ... and its argument */
000060  68e2              LDR      r2,[r4,#0xc]
000062  f1020010          ADD      r0,r2,#0x10
000066  a902              ADD      r1,sp,#8
000068  e9d12300          LDRD     r2,r3,[r1,#0]
00006c  e9c02300          STRD     r2,r3,[r0,#0]
000070  7a0a              LDRB     r2,[r1,#8]
000072  7202              STRB     r2,[r0,#8]
;;;883        L->top += 2;  /* and (next line) call the finalizer */
000074  68e0              LDR      r0,[r4,#0xc]
000076  3020              ADDS     r0,r0,#0x20
000078  60e0              STR      r0,[r4,#0xc]
;;;884        L->ci->callstatus |= CIST_FIN;  /* will run a finalizer */
00007a  6960              LDR      r0,[r4,#0x14]
00007c  8c40              LDRH     r0,[r0,#0x22]
00007e  f0400080          ORR      r0,r0,#0x80
000082  6961              LDR      r1,[r4,#0x14]
000084  8448              STRH     r0,[r1,#0x22]
;;;885        status = luaD_pcall(L, dothecall, NULL, savestack(L, L->top - 2), 0);
000086  2000              MOVS     r0,#0
000088  9000              STR      r0,[sp,#0]
00008a  68e0              LDR      r0,[r4,#0xc]
00008c  3820              SUBS     r0,r0,#0x20
00008e  6a21              LDR      r1,[r4,#0x20]
000090  1a43              SUBS     r3,r0,r1
000092  2200              MOVS     r2,#0
000094  4918              LDR      r1,|L1.248|
000096  4620              MOV      r0,r4
000098  f7fffffe          BL       luaD_pcall
00009c  4607              MOV      r7,r0
;;;886        L->ci->callstatus &= ~CIST_FIN;  /* not running a finalizer anymore */
00009e  6960              LDR      r0,[r4,#0x14]
0000a0  8c40              LDRH     r0,[r0,#0x22]
0000a2  f0200080          BIC      r0,r0,#0x80
0000a6  6961              LDR      r1,[r4,#0x14]
0000a8  8448              STRH     r0,[r1,#0x22]
;;;887        L->allowhook = oldah;  /* restore hooks */
0000aa  f884a074          STRB     r10,[r4,#0x74]
;;;888        g->gcrunning = running;  /* restore state */
0000ae  f8869039          STRB     r9,[r6,#0x39]
;;;889        if (status != LUA_OK && propagateerrors) {  /* error while running __gc? */
0000b2  b1ef              CBZ      r7,|L1.240|
0000b4  f1b80f00          CMP      r8,#0
0000b8  d01a              BEQ      |L1.240|
;;;890          if (status == LUA_ERRRUN) {  /* is there an error object? */
0000ba  2f02              CMP      r7,#2
0000bc  d114              BNE      |L1.232|
;;;891            const char *msg = (ttisstring(s2v(L->top - 1)))
0000be  68e0              LDR      r0,[r4,#0xc]
0000c0  f8100c08          LDRB     r0,[r0,#-8]
0000c4  f000000f          AND      r0,r0,#0xf
0000c8  2804              CMP      r0,#4
0000ca  d104              BNE      |L1.214|
;;;892                                ? svalue(s2v(L->top - 1))
0000cc  68e0              LDR      r0,[r4,#0xc]
0000ce  f8500c10          LDR      r0,[r0,#-0x10]
0000d2  3010              ADDS     r0,r0,#0x10
0000d4  e000              B        |L1.216|
                  |L1.214|
;;;893                                : "no message";
0000d6  a009              ADR      r0,|L1.252|
                  |L1.216|
0000d8  4683              MOV      r11,r0
;;;894            luaO_pushfstring(L, "error in __gc metamethod (%s)", msg);
0000da  465a              MOV      r2,r11
0000dc  a10a              ADR      r1,|L1.264|
0000de  4620              MOV      r0,r4
0000e0  f7fffffe          BL       luaO_pushfstring
;;;895            status = LUA_ERRGCMM;  /* error in __gc metamethod */
0000e4  2705              MOVS     r7,#5
;;;896          }
0000e6  bf00              NOP      
                  |L1.232|
;;;897          luaD_throw(L, status);  /* re-throw error */
0000e8  4639              MOV      r1,r7
0000ea  4620              MOV      r0,r4
0000ec  f7fffffe          BL       luaD_throw
                  |L1.240|
;;;898        }
;;;899      }
0000f0  bf00              NOP      
                  |L1.242|
;;;900    }
0000f2  b007              ADD      sp,sp,#0x1c
0000f4  e8bd8ff0          POP      {r4-r11,pc}
;;;901    
                          ENDP

                  |L1.248|
                          DCD      dothecall
                  |L1.252|
0000fc  6e6f206d          DCB      "no message",0
000100  65737361
000104  676500  
000107  00                DCB      0
                  |L1.264|
000108  6572726f          DCB      "error in __gc metamethod (%s)",0
00010c  7220696e
000110  205f5f67
000114  63206d65
000118  74616d65
00011c  74686f64
000120  20282573
000124  2900    
000126  00                DCB      0
000127  00                DCB      0

                          AREA ||i.atomic||, CODE, READONLY, ALIGN=1

                  atomic PROC
;;;1368   
;;;1369   static lu_mem atomic (lua_State *L) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4606              MOV      r6,r0
;;;1370     global_State *g = G(L);
000006  6934              LDR      r4,[r6,#0x10]
;;;1371     lu_mem work = 0;
000008  2500              MOVS     r5,#0
;;;1372     GCObject *origweak, *origall;
;;;1373     GCObject *grayagain = g->grayagain;  /* save original list */
00000a  f8d49050          LDR      r9,[r4,#0x50]
;;;1374     g->grayagain = NULL;
00000e  2000              MOVS     r0,#0
000010  6520              STR      r0,[r4,#0x50]
;;;1375     lua_assert(g->ephemeron == NULL && g->weak == NULL);
;;;1376     lua_assert(!iswhite(g->mainthread));
;;;1377     g->gcstate = GCSatomic;
000012  2002              MOVS     r0,#2
000014  f8840035          STRB     r0,[r4,#0x35]
;;;1378     markobject(g, L);  /* mark running thread */
000018  7970              LDRB     r0,[r6,#5]
00001a  f0000018          AND      r0,r0,#0x18
00001e  b118              CBZ      r0,|L2.40|
000020  4631              MOV      r1,r6
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       reallymarkobject
                  |L2.40|
;;;1379     /* registry and global metatables may be changed by API */
;;;1380     markvalue(g, &g->l_registry);
000028  2028              MOVS     r0,#0x28
00002a  5d00              LDRB     r0,[r0,r4]
00002c  f0000040          AND      r0,r0,#0x40
000030  b140              CBZ      r0,|L2.68|
000032  6a20              LDR      r0,[r4,#0x20]
000034  7940              LDRB     r0,[r0,#5]
000036  f0000018          AND      r0,r0,#0x18
00003a  b118              CBZ      r0,|L2.68|
00003c  4620              MOV      r0,r4
00003e  6a21              LDR      r1,[r4,#0x20]
000040  f7fffffe          BL       reallymarkobject
                  |L2.68|
;;;1381     markmt(g);  /* mark global metatables */
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       markmt
;;;1382     /* remark occasional upvalues of (maybe) dead threads */
;;;1383     work += remarkupvals(g);
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       remarkupvals
000050  4405              ADD      r5,r5,r0
;;;1384     work += propagateall(g);  /* propagate changes */
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       propagateall
000058  4405              ADD      r5,r5,r0
;;;1385     g->gray = grayagain;
00005a  f8c4904c          STR      r9,[r4,#0x4c]
;;;1386     work += propagateall(g);  /* traverse 'grayagain' list */
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       propagateall
000064  4405              ADD      r5,r5,r0
;;;1387     convergeephemerons(g);
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       convergeephemerons
;;;1388     /* at this point, all strongly accessible objects are marked. */
;;;1389     /* Clear values from weak tables, before checking finalizers */
;;;1390     clearbyvalues(g, g->weak, NULL);
00006c  2200              MOVS     r2,#0
00006e  4620              MOV      r0,r4
000070  6d61              LDR      r1,[r4,#0x54]
000072  f7fffffe          BL       clearbyvalues
;;;1391     clearbyvalues(g, g->allweak, NULL);
000076  2200              MOVS     r2,#0
000078  4620              MOV      r0,r4
00007a  6de1              LDR      r1,[r4,#0x5c]
00007c  f7fffffe          BL       clearbyvalues
;;;1392     origweak = g->weak; origall = g->allweak;
000080  6d67              LDR      r7,[r4,#0x54]
000082  f8d4805c          LDR      r8,[r4,#0x5c]
;;;1393     separatetobefnz(g, 0);  /* separate objects to be finalized */
000086  2100              MOVS     r1,#0
000088  4620              MOV      r0,r4
00008a  f7fffffe          BL       separatetobefnz
;;;1394     work += markbeingfnz(g);  /* mark objects that will be finalized */
00008e  4620              MOV      r0,r4
000090  f7fffffe          BL       markbeingfnz
000094  4405              ADD      r5,r5,r0
;;;1395     work += propagateall(g);  /* remark, to propagate 'resurrection' */
000096  4620              MOV      r0,r4
000098  f7fffffe          BL       propagateall
00009c  4405              ADD      r5,r5,r0
;;;1396     convergeephemerons(g);
00009e  4620              MOV      r0,r4
0000a0  f7fffffe          BL       convergeephemerons
;;;1397     /* at this point, all resurrected objects are marked. */
;;;1398     /* remove dead objects from weak tables */
;;;1399     clearbykeys(g, g->ephemeron);  /* clear keys from all ephemeron tables */
0000a4  4620              MOV      r0,r4
0000a6  6da1              LDR      r1,[r4,#0x58]
0000a8  f7fffffe          BL       clearbykeys
;;;1400     clearbykeys(g, g->allweak);  /* clear keys from all 'allweak' tables */
0000ac  4620              MOV      r0,r4
0000ae  6de1              LDR      r1,[r4,#0x5c]
0000b0  f7fffffe          BL       clearbykeys
;;;1401     /* clear values from resurrected weak tables */
;;;1402     clearbyvalues(g, g->weak, origweak);
0000b4  463a              MOV      r2,r7
0000b6  4620              MOV      r0,r4
0000b8  6d61              LDR      r1,[r4,#0x54]
0000ba  f7fffffe          BL       clearbyvalues
;;;1403     clearbyvalues(g, g->allweak, origall);
0000be  4642              MOV      r2,r8
0000c0  4620              MOV      r0,r4
0000c2  6de1              LDR      r1,[r4,#0x5c]
0000c4  f7fffffe          BL       clearbyvalues
;;;1404     luaS_clearcache(g);
0000c8  4620              MOV      r0,r4
0000ca  f7fffffe          BL       luaS_clearcache
;;;1405     clearprotolist(g);
0000ce  4620              MOV      r0,r4
0000d0  f7fffffe          BL       clearprotolist
;;;1406     g->currentwhite = cast_byte(otherwhite(g));  /* flip current white */
0000d4  f8940034          LDRB     r0,[r4,#0x34]
0000d8  f0800018          EOR      r0,r0,#0x18
0000dc  f8840034          STRB     r0,[r4,#0x34]
;;;1407     lua_assert(g->gray == NULL);
;;;1408     return work;  /* estimate of slots marked by 'atomic' */
0000e0  4628              MOV      r0,r5
;;;1409   }
0000e2  e8bd87f0          POP      {r4-r10,pc}
;;;1410   
                          ENDP


                          AREA ||i.callallpendingfinalizers||, CODE, READONLY, ALIGN=1

                  callallpendingfinalizers PROC
;;;917    */
;;;918    static void callallpendingfinalizers (lua_State *L, int propagateerrors) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;919      global_State *g = G(L);
000006  6926              LDR      r6,[r4,#0x10]
;;;920      while (g->tobefnz)
000008  e003              B        |L3.18|
                  |L3.10|
;;;921        GCTM(L, propagateerrors);
00000a  4629              MOV      r1,r5
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       GCTM
                  |L3.18|
000012  6e70              LDR      r0,[r6,#0x64]         ;920
000014  2800              CMP      r0,#0                 ;920
000016  d1f8              BNE      |L3.10|
;;;922    }
000018  bd70              POP      {r4-r6,pc}
;;;923    
                          ENDP


                          AREA ||i.checkSizes||, CODE, READONLY, ALIGN=1

                  checkSizes PROC
;;;834    */
;;;835    static void checkSizes (lua_State *L, global_State *g) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;836      if (!g->gcemergency) {
000008  f894003a          LDRB     r0,[r4,#0x3a]
00000c  b9a8              CBNZ     r0,|L4.58|
;;;837        l_mem olddebt = g->GCdebt;
00000e  68e6              LDR      r6,[r4,#0xc]
;;;838        if (g->strt.nuse < g->strt.size / 4)  /* string table too big? */
000010  e9d41006          LDRD     r1,r0,[r4,#0x18]
000014  17c2              ASRS     r2,r0,#31
000016  eb007292          ADD      r2,r0,r2,LSR #30
00001a  ebb10fa2          CMP      r1,r2,ASR #2
00001e  da06              BGE      |L4.46|
;;;839          luaS_resize(L, g->strt.size / 2);
000020  69e7              LDR      r7,[r4,#0x1c]
000022  eb0770d7          ADD      r0,r7,r7,LSR #31
000026  1041              ASRS     r1,r0,#1
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       luaS_resize
                  |L4.46|
;;;840        g->GCestimate += g->GCdebt - olddebt;  /* correct estimate */
00002e  e9d41003          LDRD     r1,r0,[r4,#0xc]
000032  1b89              SUBS     r1,r1,r6
000034  4408              ADD      r0,r0,r1
000036  6120              STR      r0,[r4,#0x10]
;;;841      }
000038  bf00              NOP      
                  |L4.58|
;;;842    }
00003a  e8bd81f0          POP      {r4-r8,pc}
;;;843    
                          ENDP


                          AREA ||i.checkprotocache||, CODE, READONLY, ALIGN=1

                  checkprotocache PROC
;;;527    */
;;;528    static void checkprotocache (global_State *g, Proto *p) {
000000  6b4a              LDR      r2,[r1,#0x34]
;;;529      if (p->cache) {
000002  b1ea              CBZ      r2,|L5.64|
;;;530        if (iswhite(p->cache))
000004  6b4a              LDR      r2,[r1,#0x34]
000006  7952              LDRB     r2,[r2,#5]
000008  f0020218          AND      r2,r2,#0x18
00000c  b112              CBZ      r2,|L5.20|
;;;531          p->cache = NULL;  /* allow cache to be collected */
00000e  2200              MOVS     r2,#0
000010  634a              STR      r2,[r1,#0x34]
000012  e015              B        |L5.64|
                  |L5.20|
;;;532        else if (g->gckind == KGC_GEN && !isold(p->cache) && getage(p) >= G_OLD1) {
000014  f8902036          LDRB     r2,[r0,#0x36]
000018  2a01              CMP      r2,#1
00001a  d111              BNE      |L5.64|
00001c  6b4a              LDR      r2,[r1,#0x34]
00001e  7952              LDRB     r2,[r2,#5]
000020  f0020207          AND      r2,r2,#7
000024  2a01              CMP      r2,#1
000026  dc0b              BGT      |L5.64|
000028  794a              LDRB     r2,[r1,#5]
00002a  f0020207          AND      r2,r2,#7
00002e  2a03              CMP      r2,#3
000030  db06              BLT      |L5.64|
;;;533          linkgclist(p, g->protogray);  /* link it in 'protogray' */
000032  6e02              LDR      r2,[r0,#0x60]
000034  654a              STR      r2,[r1,#0x54]
000036  6601              STR      r1,[r0,#0x60]
;;;534          black2gray(p);  /* make prototype gray */
000038  794a              LDRB     r2,[r1,#5]
00003a  f00202df          AND      r2,r2,#0xdf
00003e  714a              STRB     r2,[r1,#5]
                  |L5.64|
;;;535        }
;;;536      }
;;;537      p->cachemiss = 0;  /* restart counting */
000040  2200              MOVS     r2,#0
000042  724a              STRB     r2,[r1,#9]
;;;538    }
000044  4770              BX       lr
;;;539    
                          ENDP


                          AREA ||i.clearbykeys||, CODE, READONLY, ALIGN=1

                  clearbykeys PROC
;;;697    */
;;;698    static void clearbykeys (global_State *g, GCObject *l) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
;;;699      for (; l; l = gco2t(l)->gclist) {
000008  e023              B        |L6.82|
                  |L6.10|
;;;700        Table *h = gco2t(l);
00000a  4626              MOV      r6,r4
;;;701        Node *limit = gnodelast(h);
00000c  79f2              LDRB     r2,[r6,#7]
00000e  2001              MOVS     r0,#1
000010  4090              LSLS     r0,r0,r2
000012  eb000040          ADD      r0,r0,r0,LSL #1
000016  6931              LDR      r1,[r6,#0x10]
000018  eb0108c0          ADD      r8,r1,r0,LSL #3
;;;702        Node *n;
;;;703        for (n = gnode(h, 0); n < limit; n++) {
00001c  6935              LDR      r5,[r6,#0x10]
00001e  e015              B        |L6.76|
                  |L6.32|
;;;704          if (iscleared(g, gckeyN(n)))  /* unmarked key? */
000020  7a68              LDRB     r0,[r5,#9]
000022  f0000040          AND      r0,r0,#0x40
000026  b108              CBZ      r0,|L6.44|
000028  6928              LDR      r0,[r5,#0x10]
00002a  e000              B        |L6.46|
                  |L6.44|
00002c  2000              MOVS     r0,#0
                  |L6.46|
00002e  4601              MOV      r1,r0
000030  4638              MOV      r0,r7
000032  f7fffffe          BL       iscleared
000036  b108              CBZ      r0,|L6.60|
;;;705            setempty(gval(n));  /* remove entry */
000038  2010              MOVS     r0,#0x10
00003a  7228              STRB     r0,[r5,#8]
                  |L6.60|
;;;706          if (isempty(gval(n)))  /* is entry empty? */
00003c  7a28              LDRB     r0,[r5,#8]
00003e  f000000f          AND      r0,r0,#0xf
000042  b910              CBNZ     r0,|L6.74|
;;;707            clearkey(n);  /* clear its key */
000044  4628              MOV      r0,r5
000046  f7fffffe          BL       clearkey
                  |L6.74|
00004a  3518              ADDS     r5,r5,#0x18           ;703
                  |L6.76|
00004c  4545              CMP      r5,r8                 ;703
00004e  d3e7              BCC      |L6.32|
000050  69e4              LDR      r4,[r4,#0x1c]         ;699
                  |L6.82|
000052  2c00              CMP      r4,#0                 ;699
000054  d1d9              BNE      |L6.10|
;;;708        }
;;;709      }
;;;710    }
000056  e8bd81f0          POP      {r4-r8,pc}
;;;711    
                          ENDP


                          AREA ||i.clearbyvalues||, CODE, READONLY, ALIGN=1

                  clearbyvalues PROC
;;;716    */
;;;717    static void clearbyvalues (global_State *g, GCObject *l, GCObject *f) {
000000  e92d5ff0          PUSH     {r4-r12,lr}
000004  4682              MOV      r10,r0
000006  460d              MOV      r5,r1
000008  4691              MOV      r9,r2
;;;718      for (; l != f; l = gco2t(l)->gclist) {
00000a  e03d              B        |L7.136|
                  |L7.12|
;;;719        Table *h = gco2t(l);
00000c  462e              MOV      r6,r5
;;;720        Node *n, *limit = gnodelast(h);
00000e  79f2              LDRB     r2,[r6,#7]
000010  2001              MOVS     r0,#1
000012  4090              LSLS     r0,r0,r2
000014  eb000040          ADD      r0,r0,r0,LSL #1
000018  6931              LDR      r1,[r6,#0x10]
00001a  eb010bc0          ADD      r11,r1,r0,LSL #3
;;;721        unsigned int i;
;;;722        for (i = 0; i < h->sizearray; i++) {
00001e  2700              MOVS     r7,#0
000020  e014              B        |L7.76|
                  |L7.34|
;;;723          TValue *o = &h->array[i];
000022  68f0              LDR      r0,[r6,#0xc]
000024  eb001807          ADD      r8,r0,r7,LSL #4
;;;724          if (iscleared(g, gcvalueN(o)))  /* value was collected? */
000028  f8980008          LDRB     r0,[r8,#8]
00002c  f0000040          AND      r0,r0,#0x40
000030  b110              CBZ      r0,|L7.56|
000032  f8d80000          LDR      r0,[r8,#0]
000036  e000              B        |L7.58|
                  |L7.56|
000038  2000              MOVS     r0,#0
                  |L7.58|
00003a  4601              MOV      r1,r0
00003c  4650              MOV      r0,r10
00003e  f7fffffe          BL       iscleared
000042  b110              CBZ      r0,|L7.74|
;;;725            setempty(o);  /* remove entry */
000044  2010              MOVS     r0,#0x10
000046  f8880008          STRB     r0,[r8,#8]
                  |L7.74|
00004a  1c7f              ADDS     r7,r7,#1              ;722
                  |L7.76|
00004c  68b0              LDR      r0,[r6,#8]            ;722
00004e  42b8              CMP      r0,r7                 ;722
000050  d8e7              BHI      |L7.34|
;;;726        }
;;;727        for (n = gnode(h, 0); n < limit; n++) {
000052  6934              LDR      r4,[r6,#0x10]
000054  e015              B        |L7.130|
                  |L7.86|
;;;728          if (iscleared(g, gcvalueN(gval(n))))  /* unmarked value? */
000056  7a20              LDRB     r0,[r4,#8]
000058  f0000040          AND      r0,r0,#0x40
00005c  b108              CBZ      r0,|L7.98|
00005e  6820              LDR      r0,[r4,#0]
000060  e000              B        |L7.100|
                  |L7.98|
000062  2000              MOVS     r0,#0
                  |L7.100|
000064  4601              MOV      r1,r0
000066  4650              MOV      r0,r10
000068  f7fffffe          BL       iscleared
00006c  b108              CBZ      r0,|L7.114|
;;;729            setempty(gval(n));  /* remove entry */
00006e  2010              MOVS     r0,#0x10
000070  7220              STRB     r0,[r4,#8]
                  |L7.114|
;;;730          if (isempty(gval(n)))  /* is entry empty? */
000072  7a20              LDRB     r0,[r4,#8]
000074  f000000f          AND      r0,r0,#0xf
000078  b910              CBNZ     r0,|L7.128|
;;;731            clearkey(n);  /* clear its key */
00007a  4620              MOV      r0,r4
00007c  f7fffffe          BL       clearkey
                  |L7.128|
000080  3418              ADDS     r4,r4,#0x18           ;727
                  |L7.130|
000082  455c              CMP      r4,r11                ;727
000084  d3e7              BCC      |L7.86|
000086  69ed              LDR      r5,[r5,#0x1c]         ;718
                  |L7.136|
000088  454d              CMP      r5,r9                 ;718
00008a  d1bf              BNE      |L7.12|
;;;732        }
;;;733      }
;;;734    }
00008c  e8bd9ff0          POP      {r4-r12,pc}
;;;735    
                          ENDP


                          AREA ||i.clearkey||, CODE, READONLY, ALIGN=1

                  clearkey PROC
;;;156    */
;;;157    static void clearkey (Node *n) {
000000  7a41              LDRB     r1,[r0,#9]
;;;158      lua_assert(isempty(gval(n)));
;;;159      if (keyiswhite(n))
000002  f0010140          AND      r1,r1,#0x40
000006  b141              CBZ      r1,|L8.26|
000008  6901              LDR      r1,[r0,#0x10]
00000a  7949              LDRB     r1,[r1,#5]
00000c  f0010118          AND      r1,r1,#0x18
000010  b119              CBZ      r1,|L8.26|
;;;160        setdeadkey(n);  /* unused and unmarked key; remove it */
000012  2105              MOVS     r1,#5
000014  7241              STRB     r1,[r0,#9]
000016  2100              MOVS     r1,#0
000018  6101              STR      r1,[r0,#0x10]
                  |L8.26|
;;;161    }
00001a  4770              BX       lr
;;;162    
                          ENDP


                          AREA ||i.clearprotolist||, CODE, READONLY, ALIGN=1

                  clearprotolist PROC
;;;680    
;;;681    static void clearprotolist (global_State *g) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4606              MOV      r6,r0
;;;682      GCObject *p = g->protogray;
000006  6e34              LDR      r4,[r6,#0x60]
;;;683      g->protogray = NULL;
000008  2000              MOVS     r0,#0
00000a  6630              STR      r0,[r6,#0x60]
;;;684      while (p != NULL) {
00000c  e00b              B        |L9.38|
                  |L9.14|
;;;685        Proto *pp = gco2p(p);
00000e  4625              MOV      r5,r4
;;;686        GCObject *next = pp->gclist;
000010  6d6f              LDR      r7,[r5,#0x54]
;;;687        lua_assert(isgray(pp) && (pp->cache != NULL || pp->cachemiss >= MAXMISS));
;;;688        gray2black(pp);
000012  7968              LDRB     r0,[r5,#5]
000014  f0400020          ORR      r0,r0,#0x20
000018  7168              STRB     r0,[r5,#5]
;;;689        checkprotocache(g, pp);
00001a  4629              MOV      r1,r5
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       checkprotocache
;;;690        p = next;
000022  463c              MOV      r4,r7
;;;691      }
000024  bf00              NOP      
                  |L9.38|
000026  2c00              CMP      r4,#0                 ;684
000028  d1f1              BNE      |L9.14|
;;;692    }
00002a  e8bd81f0          POP      {r4-r8,pc}
;;;693    
                          ENDP


                          AREA ||i.convergeephemerons||, CODE, READONLY, ALIGN=1

                  convergeephemerons PROC
;;;654    
;;;655    static void convergeephemerons (global_State *g) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
;;;656      int changed;
;;;657      do {
000006  bf00              NOP      
                  |L10.8|
;;;658        GCObject *w;
;;;659        GCObject *next = g->ephemeron;  /* get ephemeron list */
000008  6da7              LDR      r7,[r4,#0x58]
;;;660        g->ephemeron = NULL;  /* tables may return to this list when traversed */
00000a  2000              MOVS     r0,#0
00000c  65a0              STR      r0,[r4,#0x58]
;;;661        changed = 0;
00000e  2600              MOVS     r6,#0
;;;662        while ((w = next) != NULL) {
000010  e009              B        |L10.38|
                  |L10.18|
;;;663          next = gco2t(w)->gclist;
000012  69ef              LDR      r7,[r5,#0x1c]
;;;664          if (traverseephemeron(g, gco2t(w))) {  /* traverse marked some value? */
000014  4629              MOV      r1,r5
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       traverseephemeron
00001c  b118              CBZ      r0,|L10.38|
;;;665            propagateall(g);  /* propagate changes */
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       propagateall
;;;666            changed = 1;  /* will have to revisit all ephemeron tables */
000024  2601              MOVS     r6,#1
                  |L10.38|
000026  1e3d              SUBS     r5,r7,#0              ;662
000028  d1f3              BNE      |L10.18|
;;;667          }
;;;668        }
;;;669      } while (changed);
00002a  2e00              CMP      r6,#0
00002c  d1ec              BNE      |L10.8|
;;;670    }
00002e  e8bd81f0          POP      {r4-r8,pc}
;;;671    
                          ENDP


                          AREA ||i.correctgraylist||, CODE, READONLY, ALIGN=1

                  correctgraylist PROC
;;;1084   */
;;;1085   static GCObject **correctgraylist (GCObject **p) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;1086     GCObject *curr;
;;;1087     while ((curr = *p) != NULL) {
000004  e03c              B        |L11.128|
                  |L11.6|
;;;1088       switch (curr->tt) {
000006  7920              LDRB     r0,[r4,#4]
000008  2805              CMP      r0,#5
00000a  d004              BEQ      |L11.22|
00000c  2807              CMP      r0,#7
00000e  d003              BEQ      |L11.24|
000010  2808              CMP      r0,#8
000012  d133              BNE      |L11.124|
000014  e027              B        |L11.102|
                  |L11.22|
;;;1089         case LUA_TTABLE: case LUA_TUSERDATA: {
000016  bf00              NOP      
                  |L11.24|
;;;1090           GCObject **next = getgclist(curr);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       getgclist
00001e  4606              MOV      r6,r0
;;;1091           if (getage(curr) == G_TOUCHED1) {  /* touched in this cycle? */
000020  7960              LDRB     r0,[r4,#5]
000022  f0000007          AND      r0,r0,#7
000026  2805              CMP      r0,#5
000028  d109              BNE      |L11.62|
;;;1092             lua_assert(isgray(curr));
;;;1093             gray2black(curr);  /* make it black, for next barrier */
00002a  7960              LDRB     r0,[r4,#5]
00002c  f0400020          ORR      r0,r0,#0x20
000030  7160              STRB     r0,[r4,#5]
;;;1094             changeage(curr, G_TOUCHED1, G_TOUCHED2);
000032  7960              LDRB     r0,[r4,#5]
000034  f0800003          EOR      r0,r0,#3
000038  7160              STRB     r0,[r4,#5]
;;;1095             p = next;  /* go to next element */
00003a  4635              MOV      r5,r6
00003c  e012              B        |L11.100|
                  |L11.62|
;;;1096           }
;;;1097           else {
;;;1098             if (!iswhite(curr)) {
00003e  7960              LDRB     r0,[r4,#5]
000040  f0000018          AND      r0,r0,#0x18
000044  b960              CBNZ     r0,|L11.96|
;;;1099               lua_assert(isold(curr));
;;;1100               if (getage(curr) == G_TOUCHED2)
000046  7960              LDRB     r0,[r4,#5]
000048  f0000007          AND      r0,r0,#7
00004c  2806              CMP      r0,#6
00004e  d103              BNE      |L11.88|
;;;1101                 changeage(curr, G_TOUCHED2, G_OLD);
000050  7960              LDRB     r0,[r4,#5]
000052  f0800002          EOR      r0,r0,#2
000056  7160              STRB     r0,[r4,#5]
                  |L11.88|
;;;1102               gray2black(curr);  /* make it black */
000058  7960              LDRB     r0,[r4,#5]
00005a  f0400020          ORR      r0,r0,#0x20
00005e  7160              STRB     r0,[r4,#5]
                  |L11.96|
;;;1103             }
;;;1104             *p = *next;  /* remove 'curr' from gray list */
000060  6830              LDR      r0,[r6,#0]
000062  6028              STR      r0,[r5,#0]
                  |L11.100|
;;;1105           }
;;;1106           break;
000064  e00b              B        |L11.126|
                  |L11.102|
;;;1107         }
;;;1108         case LUA_TTHREAD: {
;;;1109           lua_State *th = gco2th(curr);
000066  4620              MOV      r0,r4
;;;1110           lua_assert(!isblack(th));
;;;1111           if (iswhite(th))  /* new object? */
000068  7941              LDRB     r1,[r0,#5]
00006a  f0010118          AND      r1,r1,#0x18
00006e  b111              CBZ      r1,|L11.118|
;;;1112             *p = th->gclist;  /* remove from gray list */
000070  6a81              LDR      r1,[r0,#0x28]
000072  6029              STR      r1,[r5,#0]
000074  e001              B        |L11.122|
                  |L11.118|
;;;1113           else  /* old threads remain gray */
;;;1114             p = &th->gclist;  /* go to next element */
000076  f1000528          ADD      r5,r0,#0x28
                  |L11.122|
;;;1115           break;
00007a  e000              B        |L11.126|
                  |L11.124|
00007c  bf00              NOP                            ;1088
                  |L11.126|
00007e  bf00              NOP                            ;1106
                  |L11.128|
000080  682c              LDR      r4,[r5,#0]            ;1087
000082  2c00              CMP      r4,#0                 ;1087
000084  d1bf              BNE      |L11.6|
;;;1116         }
;;;1117         default: lua_assert(0);  /* nothing more could be gray here */
;;;1118       }
;;;1119     }
;;;1120     return p;
000086  4628              MOV      r0,r5
;;;1121   }
000088  bd70              POP      {r4-r6,pc}
;;;1122   
                          ENDP


                          AREA ||i.correctgraylists||, CODE, READONLY, ALIGN=1

                  correctgraylists PROC
;;;1126   */
;;;1127   static void correctgraylists (global_State *g) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;1128     GCObject **list = correctgraylist(&g->grayagain);
000004  f1040050          ADD      r0,r4,#0x50
000008  f7fffffe          BL       correctgraylist
00000c  4605              MOV      r5,r0
;;;1129     *list = g->weak; g->weak = NULL;
00000e  6d60              LDR      r0,[r4,#0x54]
000010  6028              STR      r0,[r5,#0]
000012  2000              MOVS     r0,#0
000014  6560              STR      r0,[r4,#0x54]
;;;1130     list = correctgraylist(list);
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       correctgraylist
00001c  4605              MOV      r5,r0
;;;1131     *list = g->allweak; g->allweak = NULL;
00001e  6de0              LDR      r0,[r4,#0x5c]
000020  6028              STR      r0,[r5,#0]
000022  2000              MOVS     r0,#0
000024  65e0              STR      r0,[r4,#0x5c]
;;;1132     list = correctgraylist(list);
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       correctgraylist
00002c  4605              MOV      r5,r0
;;;1133     *list = g->ephemeron; g->ephemeron = NULL;
00002e  6da0              LDR      r0,[r4,#0x58]
000030  6028              STR      r0,[r5,#0]
000032  2000              MOVS     r0,#0
000034  65a0              STR      r0,[r4,#0x58]
;;;1134     correctgraylist(list);
000036  4628              MOV      r0,r5
000038  f7fffffe          BL       correctgraylist
;;;1135   }
00003c  bd70              POP      {r4-r6,pc}
;;;1136   
                          ENDP


                          AREA ||i.deletelist||, CODE, READONLY, ALIGN=1

                  deletelist PROC
;;;1342   */
;;;1343   static void deletelist (lua_State *L, GCObject *p, GCObject *limit) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;1344     while (p != limit) {
00000a  e006              B        |L13.26|
                  |L13.12|
;;;1345       GCObject *next = p->next;
00000c  6827              LDR      r7,[r4,#0]
;;;1346       freeobj(L, p);
00000e  4621              MOV      r1,r4
000010  4630              MOV      r0,r6
000012  f7fffffe          BL       freeobj
;;;1347       p = next;
000016  463c              MOV      r4,r7
;;;1348     }
000018  bf00              NOP      
                  |L13.26|
00001a  42ac              CMP      r4,r5                 ;1344
00001c  d1f6              BNE      |L13.12|
;;;1349   }
00001e  e8bd81f0          POP      {r4-r8,pc}
;;;1350   
                          ENDP


                          AREA ||i.dothecall||, CODE, READONLY, ALIGN=1

                  dothecall PROC
;;;861    
;;;862    static void dothecall (lua_State *L, void *ud) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;863      UNUSED(ud);
;;;864      luaD_callnoyield(L, L->top - 2, 0);
000006  68e0              LDR      r0,[r4,#0xc]
000008  f1a00120          SUB      r1,r0,#0x20
00000c  2200              MOVS     r2,#0
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       luaD_callnoyield
;;;865    }
000014  bd70              POP      {r4-r6,pc}
;;;866    
                          ENDP


                          AREA ||i.entergen||, CODE, READONLY, ALIGN=1

                  entergen PROC
;;;1209   */
;;;1210   static void entergen (lua_State *L, global_State *g) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1211     luaC_runtilstate(L, bitmask(GCSpause));  /* prepare to start a new cycle */
000006  f44f7180          MOV      r1,#0x100
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       luaC_runtilstate
;;;1212     luaC_runtilstate(L, bitmask(GCSpropagate));  /* start new cycle */
000010  2101              MOVS     r1,#1
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       luaC_runtilstate
;;;1213     atomic(L);
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       atomic
;;;1214     /* sweep all elements making them old */
;;;1215     sweep2old(L, &g->allgc);
00001e  f1040140          ADD      r1,r4,#0x40
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       sweep2old
;;;1216     /* everything alive now is old */
;;;1217     g->reallyold = g->old = g->survival = g->allgc;
000028  6c20              LDR      r0,[r4,#0x40]
00002a  66e0              STR      r0,[r4,#0x6c]
00002c  6720              STR      r0,[r4,#0x70]
00002e  6760              STR      r0,[r4,#0x74]
;;;1218   
;;;1219     /* repeat for 'finobj' lists */
;;;1220     sweep2old(L, &g->finobj);
000030  f1040148          ADD      r1,r4,#0x48
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       sweep2old
;;;1221     g->finobjrold = g->finobjold = g->finobjsur = g->finobj;
00003a  6ca0              LDR      r0,[r4,#0x48]
00003c  67a0              STR      r0,[r4,#0x78]
00003e  67e0              STR      r0,[r4,#0x7c]
000040  f8c40080          STR      r0,[r4,#0x80]
;;;1222   
;;;1223     sweep2old(L, &g->tobefnz);
000044  f1040164          ADD      r1,r4,#0x64
000048  4628              MOV      r0,r5
00004a  f7fffffe          BL       sweep2old
;;;1224   
;;;1225     g->gckind = KGC_GEN;
00004e  2001              MOVS     r0,#1
000050  f8840036          STRB     r0,[r4,#0x36]
;;;1226     g->GCestimate = gettotalbytes(g);  /* base for memory control */
000054  e9d40102          LDRD     r0,r1,[r4,#8]
000058  4408              ADD      r0,r0,r1
00005a  6120              STR      r0,[r4,#0x10]
;;;1227     finishgencycle(L, g);
00005c  4621              MOV      r1,r4
00005e  4628              MOV      r0,r5
000060  f7fffffe          BL       finishgencycle
;;;1228   }
000064  bd70              POP      {r4-r6,pc}
;;;1229   
                          ENDP


                          AREA ||i.enterinc||, CODE, READONLY, ALIGN=1

                  enterinc PROC
;;;1235   */
;;;1236   static void enterinc (global_State *g) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;1237     whitelist(g, g->allgc);
000004  4620              MOV      r0,r4
000006  6c21              LDR      r1,[r4,#0x40]
000008  f7fffffe          BL       whitelist
;;;1238     g->reallyold = g->old = g->survival = NULL;
00000c  2000              MOVS     r0,#0
00000e  66e0              STR      r0,[r4,#0x6c]
000010  6720              STR      r0,[r4,#0x70]
000012  6760              STR      r0,[r4,#0x74]
;;;1239     whitelist(g, g->finobj);
000014  4620              MOV      r0,r4
000016  6ca1              LDR      r1,[r4,#0x48]
000018  f7fffffe          BL       whitelist
;;;1240     whitelist(g, g->tobefnz);
00001c  4620              MOV      r0,r4
00001e  6e61              LDR      r1,[r4,#0x64]
000020  f7fffffe          BL       whitelist
;;;1241     g->finobjrold = g->finobjold = g->finobjsur = NULL;
000024  2000              MOVS     r0,#0
000026  67a0              STR      r0,[r4,#0x78]
000028  67e0              STR      r0,[r4,#0x7c]
00002a  f8c40080          STR      r0,[r4,#0x80]
;;;1242     g->gcstate = GCSpause;
00002e  2008              MOVS     r0,#8
000030  f8840035          STRB     r0,[r4,#0x35]
;;;1243     g->gckind = KGC_INC;
000034  2000              MOVS     r0,#0
000036  f8840036          STRB     r0,[r4,#0x36]
;;;1244   }
00003a  bd10              POP      {r4,pc}
;;;1245   
                          ENDP


                          AREA ||i.entersweep||, CODE, READONLY, ALIGN=1

                  entersweep PROC
;;;1330   */
;;;1331   static void entersweep (lua_State *L) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;1332     global_State *g = G(L);
000004  692c              LDR      r4,[r5,#0x10]
;;;1333     g->gcstate = GCSswpallgc;
000006  2003              MOVS     r0,#3
000008  f8840035          STRB     r0,[r4,#0x35]
;;;1334     lua_assert(g->sweepgc == NULL);
;;;1335     g->sweepgc = sweeptolive(L, &g->allgc);
00000c  f1040140          ADD      r1,r4,#0x40
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       sweeptolive
000016  6460              STR      r0,[r4,#0x44]
;;;1336   }
000018  bd70              POP      {r4-r6,pc}
;;;1337   
                          ENDP


                          AREA ||i.findlast||, CODE, READONLY, ALIGN=1

                  findlast PROC
;;;927    */
;;;928    static GCObject **findlast (GCObject **p) {
000000  e000              B        |L18.4|
                  |L18.2|
;;;929      while (*p != NULL)
;;;930        p = &(*p)->next;
000002  6800              LDR      r0,[r0,#0]
                  |L18.4|
000004  6801              LDR      r1,[r0,#0]            ;929
000006  2900              CMP      r1,#0                 ;929
000008  d1fb              BNE      |L18.2|
;;;931      return p;
;;;932    }
00000a  4770              BX       lr
;;;933    
                          ENDP


                          AREA ||i.finishgencycle||, CODE, READONLY, ALIGN=1

                  finishgencycle PROC
;;;1159   */
;;;1160   static void finishgencycle (lua_State *L, global_State *g) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1161     correctgraylists(g);
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       correctgraylists
;;;1162     checkSizes(L, g);
00000c  4621              MOV      r1,r4
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       checkSizes
;;;1163     g->gcstate = GCSpropagate;  /* skip restart */
000014  2000              MOVS     r0,#0
000016  f8840035          STRB     r0,[r4,#0x35]
;;;1164     if (!g->gcemergency)
00001a  f894003a          LDRB     r0,[r4,#0x3a]
00001e  b918              CBNZ     r0,|L19.40|
;;;1165       callallpendingfinalizers(L, 1);
000020  2101              MOVS     r1,#1
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       callallpendingfinalizers
                  |L19.40|
;;;1166   }
000028  bd70              POP      {r4-r6,pc}
;;;1167   
                          ENDP


                          AREA ||i.freeobj||, CODE, READONLY, ALIGN=1

                  freeobj PROC
;;;743    
;;;744    static void freeobj (lua_State *L, GCObject *o) {
000000  b570              PUSH     {r4-r6,lr}
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;745      switch (o->tt) {
000006  7920              LDRB     r0,[r4,#4]
000008  280a              CMP      r0,#0xa
00000a  d012              BEQ      |L20.50|
00000c  dc08              BGT      |L20.32|
00000e  2805              CMP      r0,#5
000010  d02b              BEQ      |L20.106|
000012  2807              CMP      r0,#7
000014  d033              BEQ      |L20.126|
000016  2808              CMP      r0,#8
000018  d02c              BEQ      |L20.116|
00001a  2809              CMP      r0,#9
00001c  d152              BNE      |L20.196|
00001e  e00d              B        |L20.60|
                  |L20.32|
000020  2814              CMP      r0,#0x14
000022  d03b              BEQ      |L20.156|
000024  2816              CMP      r0,#0x16
000026  d00e              BEQ      |L20.70|
000028  2824              CMP      r0,#0x24
00002a  d043              BEQ      |L20.180|
00002c  2836              CMP      r0,#0x36
00002e  d149              BNE      |L20.196|
000030  e012              B        |L20.88|
                  |L20.50|
;;;746        case LUA_TPROTO:
;;;747          luaF_freeproto(L, gco2p(o));
000032  4621              MOV      r1,r4
000034  4630              MOV      r0,r6
000036  f7fffffe          BL       luaF_freeproto
;;;748          break;
00003a  e044              B        |L20.198|
                  |L20.60|
;;;749        case LUA_TUPVAL:
;;;750          freeupval(L, gco2upv(o));
00003c  4621              MOV      r1,r4
00003e  4630              MOV      r0,r6
000040  f7fffffe          BL       freeupval
;;;751          break;
000044  e03f              B        |L20.198|
                  |L20.70|
;;;752        case LUA_TLCL:
;;;753          luaM_freemem(L, o, sizeLclosure(gco2lcl(o)->nupvalues));
000046  79a0              LDRB     r0,[r4,#6]
000048  0080              LSLS     r0,r0,#2
00004a  f1000210          ADD      r2,r0,#0x10
00004e  4621              MOV      r1,r4
000050  4630              MOV      r0,r6
000052  f7fffffe          BL       luaM_free_
;;;754          break;
000056  e036              B        |L20.198|
                  |L20.88|
;;;755        case LUA_TCCL:
;;;756          luaM_freemem(L, o, sizeCclosure(gco2ccl(o)->nupvalues));
000058  79a0              LDRB     r0,[r4,#6]
00005a  0100              LSLS     r0,r0,#4
00005c  f1000210          ADD      r2,r0,#0x10
000060  4621              MOV      r1,r4
000062  4630              MOV      r0,r6
000064  f7fffffe          BL       luaM_free_
;;;757          break;
000068  e02d              B        |L20.198|
                  |L20.106|
;;;758        case LUA_TTABLE:
;;;759          luaH_free(L, gco2t(o));
00006a  4621              MOV      r1,r4
00006c  4630              MOV      r0,r6
00006e  f7fffffe          BL       luaH_free
;;;760          break;
000072  e028              B        |L20.198|
                  |L20.116|
;;;761        case LUA_TTHREAD:
;;;762          luaE_freethread(L, gco2th(o));
000074  4621              MOV      r1,r4
000076  4630              MOV      r0,r6
000078  f7fffffe          BL       luaE_freethread
;;;763          break;
00007c  e023              B        |L20.198|
                  |L20.126|
;;;764        case LUA_TUSERDATA: {
;;;765          Udata *u = gco2u(o);
00007e  4625              MOV      r5,r4
;;;766          luaM_freemem(L, o, sizeudata(u->nuvalue, u->len));
000080  88e8              LDRH     r0,[r5,#6]
000082  b908              CBNZ     r0,|L20.136|
000084  2010              MOVS     r0,#0x10
000086  e002              B        |L20.142|
                  |L20.136|
000088  88e8              LDRH     r0,[r5,#6]
00008a  0100              LSLS     r0,r0,#4
00008c  3018              ADDS     r0,r0,#0x18
                  |L20.142|
00008e  68a9              LDR      r1,[r5,#8]
000090  1842              ADDS     r2,r0,r1
000092  4621              MOV      r1,r4
000094  4630              MOV      r0,r6
000096  f7fffffe          BL       luaM_free_
;;;767          break;
00009a  e014              B        |L20.198|
                  |L20.156|
;;;768        }
;;;769        case LUA_TSHRSTR:
;;;770          luaS_remove(L, gco2ts(o));  /* remove it from hash table */
00009c  4621              MOV      r1,r4
00009e  4630              MOV      r0,r6
0000a0  f7fffffe          BL       luaS_remove
;;;771          luaM_freemem(L, o, sizelstring(gco2ts(o)->shrlen));
0000a4  79e0              LDRB     r0,[r4,#7]
0000a6  f1000211          ADD      r2,r0,#0x11
0000aa  4621              MOV      r1,r4
0000ac  4630              MOV      r0,r6
0000ae  f7fffffe          BL       luaM_free_
;;;772          break;
0000b2  e008              B        |L20.198|
                  |L20.180|
;;;773        case LUA_TLNGSTR:
;;;774          luaM_freemem(L, o, sizelstring(gco2ts(o)->u.lnglen));
0000b4  68e0              LDR      r0,[r4,#0xc]
0000b6  f1000211          ADD      r2,r0,#0x11
0000ba  4621              MOV      r1,r4
0000bc  4630              MOV      r0,r6
0000be  f7fffffe          BL       luaM_free_
;;;775          break;
0000c2  e000              B        |L20.198|
                  |L20.196|
0000c4  bf00              NOP                            ;745
                  |L20.198|
0000c6  bf00              NOP                            ;748
;;;776        default: lua_assert(0);
;;;777      }
;;;778    }
0000c8  bd70              POP      {r4-r6,pc}
;;;779    
                          ENDP


                          AREA ||i.freeupval||, CODE, READONLY, ALIGN=1

                  freeupval PROC
;;;736    
;;;737    static void freeupval (lua_State *L, UpVal *uv) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;738      if (upisopen(uv))
000006  f1040010          ADD      r0,r4,#0x10
00000a  68a1              LDR      r1,[r4,#8]
00000c  4281              CMP      r1,r0
00000e  d002              BEQ      |L21.22|
;;;739        luaF_unlinkupval(uv);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       luaF_unlinkupval
                  |L21.22|
;;;740      luaM_free(L, uv);
000016  2220              MOVS     r2,#0x20
000018  4621              MOV      r1,r4
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       luaM_free_
;;;741    }
000020  bd70              POP      {r4-r6,pc}
;;;742    
                          ENDP


                          AREA ||i.fullgen||, CODE, READONLY, ALIGN=1

                  fullgen PROC
;;;1263   */
;;;1264   static void fullgen (lua_State *L, global_State *g) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1265     enterinc(g);
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       enterinc
;;;1266     entergen(L, g);
00000c  4621              MOV      r1,r4
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       entergen
;;;1267   }
000014  bd70              POP      {r4-r6,pc}
;;;1268   
                          ENDP


                          AREA ||i.fullinc||, CODE, READONLY, ALIGN=1

                  fullinc PROC
;;;1537   */
;;;1538   static void fullinc (lua_State *L, global_State *g) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1539     if (keepinvariant(g))  /* black objects? */
000006  f8940035          LDRB     r0,[r4,#0x35]
00000a  2802              CMP      r0,#2
00000c  dc02              BGT      |L23.20|
;;;1540       entersweep(L); /* sweep everything to turn them back to white */
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       entersweep
                  |L23.20|
;;;1541     /* finish any pending sweep phase to start a new cycle */
;;;1542     luaC_runtilstate(L, bitmask(GCSpause));
000014  f44f7180          MOV      r1,#0x100
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       luaC_runtilstate
;;;1543     luaC_runtilstate(L, bitmask(GCScallfin));  /* run up to finalizers */
00001e  2180              MOVS     r1,#0x80
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       luaC_runtilstate
;;;1544     /* estimate must be correct after a full GC cycle */
;;;1545     lua_assert(g->GCestimate == gettotalbytes(g));
;;;1546     luaC_runtilstate(L, bitmask(GCSpause));  /* finish collection */
000026  f44f7180          MOV      r1,#0x100
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       luaC_runtilstate
;;;1547     setpause(g);
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       setpause
;;;1548   }
000036  bd70              POP      {r4-r6,pc}
;;;1549   
                          ENDP


                          AREA ||i.genstep||, CODE, READONLY, ALIGN=1

                  genstep PROC
;;;1277   */
;;;1278   static void genstep (lua_State *L, global_State *g) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
;;;1279     lu_mem majorbase = g->GCestimate;
000008  6925              LDR      r5,[r4,#0x10]
;;;1280     int majormul = getgcparam(g->genmajormul);
00000a  f8940038          LDRB     r0,[r4,#0x38]
00000e  0087              LSLS     r7,r0,#2
;;;1281     if (g->GCdebt > 0 &&
000010  68e0              LDR      r0,[r4,#0xc]
000012  2800              CMP      r0,#0
000014  dd0f              BLE      |L24.54|
;;;1282         gettotalbytes(g) > (majorbase / 100) * (100 + majormul)) {
000016  2064              MOVS     r0,#0x64
000018  fbb5f0f0          UDIV     r0,r5,r0
00001c  f1070164          ADD      r1,r7,#0x64
000020  4348              MULS     r0,r1,r0
000022  e9d41202          LDRD     r1,r2,[r4,#8]
000026  4411              ADD      r1,r1,r2
000028  4288              CMP      r0,r1
00002a  d204              BCS      |L24.54|
;;;1283       fullgen(L, g);
00002c  4621              MOV      r1,r4
00002e  4630              MOV      r0,r6
000030  f7fffffe          BL       fullgen
000034  e015              B        |L24.98|
                  |L24.54|
;;;1284     }
;;;1285     else {
;;;1286       lu_mem mem;
;;;1287       youngcollection(L, g);
000036  4621              MOV      r1,r4
000038  4630              MOV      r0,r6
00003a  f7fffffe          BL       youngcollection
;;;1288       mem = gettotalbytes(g);
00003e  e9d40102          LDRD     r0,r1,[r4,#8]
000042  eb000801          ADD      r8,r0,r1
;;;1289       luaE_setdebt(g, -(cast(l_mem, (mem / 100)) * g->genminormul));
000046  2064              MOVS     r0,#0x64
000048  fbb8f0f0          UDIV     r0,r8,r0
00004c  f8941037          LDRB     r1,[r4,#0x37]
000050  4348              MULS     r0,r1,r0
000052  f1c00900          RSB      r9,r0,#0
000056  4649              MOV      r1,r9
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       luaE_setdebt
;;;1290       g->GCestimate = majorbase;  /* preserve base value */
00005e  6125              STR      r5,[r4,#0x10]
;;;1291     }
000060  bf00              NOP      
                  |L24.98|
;;;1292   }
000062  e8bd87f0          POP      {r4-r10,pc}
;;;1293   
                          ENDP


                          AREA ||i.getgclist||, CODE, READONLY, ALIGN=1

                  getgclist PROC
;;;117    
;;;118    static GCObject **getgclist (GCObject *o) {
000000  4601              MOV      r1,r0
;;;119      switch (o->tt) {
000002  7908              LDRB     r0,[r1,#4]
000004  280a              CMP      r0,#0xa
000006  d018              BEQ      |L25.58|
000008  dc06              BGT      |L25.24|
00000a  2805              CMP      r0,#5
00000c  d009              BEQ      |L25.34|
00000e  2807              CMP      r0,#7
000010  d016              BEQ      |L25.64|
000012  2808              CMP      r0,#8
000014  d118              BNE      |L25.72|
000016  e00d              B        |L25.52|
                  |L25.24|
000018  2816              CMP      r0,#0x16
00001a  d005              BEQ      |L25.40|
00001c  2836              CMP      r0,#0x36
00001e  d113              BNE      |L25.72|
000020  e005              B        |L25.46|
                  |L25.34|
;;;120        case LUA_TTABLE: return &gco2t(o)->gclist;
000022  f101001c          ADD      r0,r1,#0x1c
                  |L25.38|
;;;121        case LUA_TLCL: return &gco2lcl(o)->gclist;
;;;122        case LUA_TCCL: return &gco2ccl(o)->gclist;
;;;123        case LUA_TTHREAD: return &gco2th(o)->gclist;
;;;124        case LUA_TPROTO: return &gco2p(o)->gclist;
;;;125        case LUA_TUSERDATA: {
;;;126          Udata *u = gco2u(o);
;;;127          lua_assert(u->nuvalue > 0);
;;;128          return &u->gclist;
;;;129        }
;;;130        default: lua_assert(0); return 0;
;;;131      }
;;;132    }
000026  4770              BX       lr
                  |L25.40|
000028  f1010008          ADD      r0,r1,#8              ;121
00002c  e7fb              B        |L25.38|
                  |L25.46|
00002e  f1010008          ADD      r0,r1,#8              ;122
000032  e7f8              B        |L25.38|
                  |L25.52|
000034  f1010028          ADD      r0,r1,#0x28           ;123
000038  e7f5              B        |L25.38|
                  |L25.58|
00003a  f1010054          ADD      r0,r1,#0x54           ;124
00003e  e7f2              B        |L25.38|
                  |L25.64|
000040  460a              MOV      r2,r1                 ;126
000042  f1020010          ADD      r0,r2,#0x10           ;128
000046  e7ee              B        |L25.38|
                  |L25.72|
000048  2000              MOVS     r0,#0                 ;130
00004a  e7ec              B        |L25.38|
;;;133    
                          ENDP


                          AREA ||i.incstep||, CODE, READONLY, ALIGN=1

                  incstep PROC
;;;1498   */
;;;1499   static void incstep (lua_State *L, global_State *g) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
;;;1500     int stepmul = (getgcparam(g->gcstepmul) | 1);  /* avoid division by 0 */
000008  f894003c          LDRB     r0,[r4,#0x3c]
00000c  2101              MOVS     r1,#1
00000e  eb010680          ADD      r6,r1,r0,LSL #2
;;;1501     l_mem debt = (g->GCdebt / WORK2MEM) * stepmul;
000012  68e0              LDR      r0,[r4,#0xc]
000014  0900              LSRS     r0,r0,#4
000016  fb00f506          MUL      r5,r0,r6
;;;1502     l_mem stepsize = (g->gcstepsize <= log2maxs(l_mem))
00001a  f894003d          LDRB     r0,[r4,#0x3d]
00001e  281e              CMP      r0,#0x1e
000020  d806              BHI      |L26.48|
;;;1503                    ? ((cast(l_mem, 1) << g->gcstepsize) / WORK2MEM) * stepmul
000022  f894103d          LDRB     r1,[r4,#0x3d]
000026  2001              MOVS     r0,#1
000028  4088              LSLS     r0,r0,r1
00002a  0900              LSRS     r0,r0,#4
00002c  4370              MULS     r0,r6,r0
00002e  e001              B        |L26.52|
                  |L26.48|
;;;1504                    : MAX_LMEM;  /* overflow; keep maximum value */
000030  f06f4000          MVN      r0,#0x80000000
                  |L26.52|
000034  4680              MOV      r8,r0
;;;1505     do {  /* repeat until pause or enough "credit" (negative debt) */
000036  bf00              NOP      
                  |L26.56|
;;;1506       lu_mem work = singlestep(L);  /* perform one single step */
000038  4638              MOV      r0,r7
00003a  f7fffffe          BL       singlestep
00003e  4681              MOV      r9,r0
;;;1507       debt -= work;
000040  eba50509          SUB      r5,r5,r9
;;;1508     } while (debt > -stepsize && g->gcstate != GCSpause);
000044  f1c80000          RSB      r0,r8,#0
000048  4285              CMP      r5,r0
00004a  dd03              BLE      |L26.84|
00004c  f8940035          LDRB     r0,[r4,#0x35]
000050  2808              CMP      r0,#8
000052  d1f1              BNE      |L26.56|
                  |L26.84|
;;;1509     if (g->gcstate == GCSpause)
000054  f8940035          LDRB     r0,[r4,#0x35]
000058  2808              CMP      r0,#8
00005a  d103              BNE      |L26.100|
;;;1510       setpause(g);  /* pause until next cycle */
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       setpause
000062  e006              B        |L26.114|
                  |L26.100|
;;;1511     else {
;;;1512       debt = (debt / stepmul) * WORK2MEM;  /* convert 'work units' to bytes */
000064  fb95f0f6          SDIV     r0,r5,r6
000068  0105              LSLS     r5,r0,#4
;;;1513       luaE_setdebt(g, debt);
00006a  4629              MOV      r1,r5
00006c  4620              MOV      r0,r4
00006e  f7fffffe          BL       luaE_setdebt
                  |L26.114|
;;;1514     }
;;;1515   }
000072  e8bd87f0          POP      {r4-r10,pc}
;;;1516   
                          ENDP


                          AREA ||i.iscleared||, CODE, READONLY, ALIGN=1

                  iscleared PROC
;;;170    */
;;;171    static int iscleared (global_State *g, const GCObject *o) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;172      if (o == NULL) return 0;  /* non-collectable value */
000006  b90c              CBNZ     r4,|L27.12|
000008  2000              MOVS     r0,#0
                  |L27.10|
;;;173      else if (novariant(o->tt) == LUA_TSTRING) {
;;;174        markobject(g, o);  /* strings are 'values', so are never weak */
;;;175        return 0;
;;;176      }
;;;177      else return iswhite(o);
;;;178    }
00000a  bd70              POP      {r4-r6,pc}
                  |L27.12|
00000c  7920              LDRB     r0,[r4,#4]            ;173
00000e  f000000f          AND      r0,r0,#0xf            ;173
000012  2804              CMP      r0,#4                 ;173
000014  d109              BNE      |L27.42|
000016  7960              LDRB     r0,[r4,#5]            ;174
000018  f0000018          AND      r0,r0,#0x18           ;174
00001c  b118              CBZ      r0,|L27.38|
00001e  4621              MOV      r1,r4                 ;174
000020  4628              MOV      r0,r5                 ;174
000022  f7fffffe          BL       reallymarkobject
                  |L27.38|
000026  2000              MOVS     r0,#0                 ;175
000028  e7ef              B        |L27.10|
                  |L27.42|
00002a  7960              LDRB     r0,[r4,#5]            ;177
00002c  f0000018          AND      r0,r0,#0x18           ;177
000030  e7eb              B        |L27.10|
;;;179    
                          ENDP


                          AREA ||i.luaC_barrier_||, CODE, READONLY, ALIGN=1

                  luaC_barrier_ PROC
;;;186    */
;;;187    void luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;188      global_State *g = G(L);
00000a  693e              LDR      r6,[r7,#0x10]
;;;189      lua_assert(isblack(o) && iswhite(v) && !isdead(g, v) && !isdead(g, o));
;;;190      if (keepinvariant(g)) {  /* must keep invariant? */
00000c  f8960035          LDRB     r0,[r6,#0x35]
000010  2802              CMP      r0,#2
000012  dc0e              BGT      |L28.50|
;;;191        reallymarkobject(g, v);  /* restore invariant */
000014  4629              MOV      r1,r5
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       reallymarkobject
;;;192        if (isold(o)) {
00001c  7960              LDRB     r0,[r4,#5]
00001e  f0000007          AND      r0,r0,#7
000022  2801              CMP      r0,#1
000024  dd0e              BLE      |L28.68|
;;;193          lua_assert(!isold(v));  /* white object could not be old */
;;;194          setage(v, G_OLD0);  /* restore generational invariant */
000026  7968              LDRB     r0,[r5,#5]
000028  f0200007          BIC      r0,r0,#7
00002c  1c80              ADDS     r0,r0,#2
00002e  7168              STRB     r0,[r5,#5]
000030  e008              B        |L28.68|
                  |L28.50|
;;;195        }
;;;196      }
;;;197      else {  /* sweep phase */
;;;198        lua_assert(issweepphase(g));
;;;199        makewhite(g, o);  /* mark main obj. as white to avoid other barriers */
000032  7960              LDRB     r0,[r4,#5]
000034  f020003f          BIC      r0,r0,#0x3f
000038  f8961034          LDRB     r1,[r6,#0x34]
00003c  f0010118          AND      r1,r1,#0x18
000040  4308              ORRS     r0,r0,r1
000042  7160              STRB     r0,[r4,#5]
                  |L28.68|
;;;200      }
;;;201    }
000044  e8bd81f0          POP      {r4-r8,pc}
;;;202    
                          ENDP


                          AREA ||i.luaC_barrierback_||, CODE, READONLY, ALIGN=1

                  luaC_barrierback_ PROC
;;;207    */
;;;208    void luaC_barrierback_ (lua_State *L, GCObject *o) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;209      global_State *g = G(L);
000006  692e              LDR      r6,[r5,#0x10]
;;;210      lua_assert(isblack(o) && !isdead(g, o));
;;;211      lua_assert(g->gckind != KGC_GEN || (isold(o) && getage(o) != G_TOUCHED1));
;;;212      if (getage(o) != G_TOUCHED2)  /* not already in gray list? */
000008  7960              LDRB     r0,[r4,#5]
00000a  f0000007          AND      r0,r0,#7
00000e  2806              CMP      r0,#6
000010  d005              BEQ      |L29.30|
;;;213        linkobjgclist(o, g->grayagain);  /* link it in 'grayagain' */
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       getgclist
000018  6d31              LDR      r1,[r6,#0x50]
00001a  6001              STR      r1,[r0,#0]
00001c  6534              STR      r4,[r6,#0x50]
                  |L29.30|
;;;214      black2gray(o);  /* make table gray (again) */
00001e  7960              LDRB     r0,[r4,#5]
000020  f00000df          AND      r0,r0,#0xdf
000024  7160              STRB     r0,[r4,#5]
;;;215      setage(o, G_TOUCHED1);  /* touched in current cycle */
000026  7960              LDRB     r0,[r4,#5]
000028  f0200007          BIC      r0,r0,#7
00002c  1d40              ADDS     r0,r0,#5
00002e  7160              STRB     r0,[r4,#5]
;;;216    }
000030  bd70              POP      {r4-r6,pc}
;;;217    
                          ENDP


                          AREA ||i.luaC_changemode||, CODE, READONLY, ALIGN=1

                  luaC_changemode PROC
;;;1249   */
;;;1250   void luaC_changemode (lua_State *L, int newmode) {
000000  b570              PUSH     {r4-r6,lr}
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;1251     global_State *g = G(L);
000006  6935              LDR      r5,[r6,#0x10]
;;;1252     if (newmode != g->gckind) {
000008  f8950036          LDRB     r0,[r5,#0x36]
00000c  42a0              CMP      r0,r4
00000e  d009              BEQ      |L30.36|
;;;1253       if (newmode == KGC_GEN)  /* entering generational mode? */
000010  2c01              CMP      r4,#1
000012  d104              BNE      |L30.30|
;;;1254         entergen(L, g);
000014  4629              MOV      r1,r5
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       entergen
00001c  e002              B        |L30.36|
                  |L30.30|
;;;1255       else
;;;1256         enterinc(g);  /* entering incremental mode */
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       enterinc
                  |L30.36|
;;;1257     }
;;;1258   }
000024  bd70              POP      {r4-r6,pc}
;;;1259   
                          ENDP


                          AREA ||i.luaC_checkfinalizer||, CODE, READONLY, ALIGN=1

                  luaC_checkfinalizer PROC
;;;965    */
;;;966    void luaC_checkfinalizer (lua_State *L, GCObject *o, Table *mt) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4680              MOV      r8,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
;;;967      global_State *g = G(L);
00000a  f8d85010          LDR      r5,[r8,#0x10]
;;;968      if (tofinalize(o) ||                 /* obj. is already marked... */
00000e  7960              LDRB     r0,[r4,#5]
000010  f0000040          AND      r0,r0,#0x40
000014  b978              CBNZ     r0,|L31.54|
;;;969          gfasttm(g, mt, TM_GC) == NULL)   /* or has no finalizer? */
000016  b90e              CBNZ     r6,|L31.28|
000018  2000              MOVS     r0,#0
00001a  e00b              B        |L31.52|
                  |L31.28|
00001c  79b0              LDRB     r0,[r6,#6]
00001e  f0000010          AND      r0,r0,#0x10
000022  b108              CBZ      r0,|L31.40|
000024  2000              MOVS     r0,#0
000026  e005              B        |L31.52|
                  |L31.40|
000028  20a8              MOVS     r0,#0xa8
00002a  5942              LDR      r2,[r0,r5]
00002c  2104              MOVS     r1,#4
00002e  4630              MOV      r0,r6
000030  f7fffffe          BL       luaT_gettm
                  |L31.52|
000034  b908              CBNZ     r0,|L31.58|
                  |L31.54|
;;;970        return;  /* nothing to be done */
;;;971      else {  /* move 'o' to 'finobj' list */
;;;972        GCObject **p;
;;;973        if (issweepphase(g)) {
;;;974          makewhite(g, o);  /* "sweep" object 'o' */
;;;975          if (g->sweepgc == &o->next)  /* should not remove 'sweepgc' object */
;;;976            g->sweepgc = sweeptolive(L, g->sweepgc);  /* change 'sweepgc' */
;;;977        }
;;;978        else {  /* correct pointers into 'allgc' list, if needed */
;;;979          if (o == g->survival)
;;;980            g->survival = o->next;
;;;981          if (o == g->old)
;;;982            g->old = o->next;
;;;983          if (o == g->reallyold)
;;;984            g->reallyold = o->next;
;;;985        }
;;;986        /* search for pointer pointing to 'o' */
;;;987        for (p = &g->allgc; *p != o; p = &(*p)->next) { /* empty */ }
;;;988        *p = o->next;  /* remove 'o' from 'allgc' list */
;;;989        o->next = g->finobj;  /* link it in 'finobj' list */
;;;990        g->finobj = o;
;;;991        l_setbit(o->marked, FINALIZEDBIT);  /* mark it as such */
;;;992      }
;;;993    }
000036  e8bd81f0          POP      {r4-r8,pc}
                  |L31.58|
00003a  f8950035          LDRB     r0,[r5,#0x35]         ;973
00003e  2803              CMP      r0,#3                 ;973
000040  db15              BLT      |L31.110|
000042  f8950035          LDRB     r0,[r5,#0x35]         ;973
000046  2806              CMP      r0,#6                 ;973
000048  dc11              BGT      |L31.110|
00004a  7960              LDRB     r0,[r4,#5]            ;974
00004c  f020003f          BIC      r0,r0,#0x3f           ;974
000050  f8951034          LDRB     r1,[r5,#0x34]         ;974
000054  f0010118          AND      r1,r1,#0x18           ;974
000058  4308              ORRS     r0,r0,r1              ;974
00005a  7160              STRB     r0,[r4,#5]            ;974
00005c  6c68              LDR      r0,[r5,#0x44]         ;975
00005e  42a0              CMP      r0,r4                 ;975
000060  d114              BNE      |L31.140|
000062  4640              MOV      r0,r8                 ;976
000064  6c69              LDR      r1,[r5,#0x44]         ;976
000066  f7fffffe          BL       sweeptolive
00006a  6468              STR      r0,[r5,#0x44]         ;976
00006c  e00e              B        |L31.140|
                  |L31.110|
00006e  6ee8              LDR      r0,[r5,#0x6c]         ;979
000070  42a0              CMP      r0,r4                 ;979
000072  d101              BNE      |L31.120|
000074  6820              LDR      r0,[r4,#0]            ;980
000076  66e8              STR      r0,[r5,#0x6c]         ;980
                  |L31.120|
000078  6f28              LDR      r0,[r5,#0x70]         ;981
00007a  42a0              CMP      r0,r4                 ;981
00007c  d101              BNE      |L31.130|
00007e  6820              LDR      r0,[r4,#0]            ;982
000080  6728              STR      r0,[r5,#0x70]         ;982
                  |L31.130|
000082  6f68              LDR      r0,[r5,#0x74]         ;983
000084  42a0              CMP      r0,r4                 ;983
000086  d101              BNE      |L31.140|
000088  6820              LDR      r0,[r4,#0]            ;984
00008a  6768              STR      r0,[r5,#0x74]         ;984
                  |L31.140|
00008c  f1050740          ADD      r7,r5,#0x40           ;987
000090  e000              B        |L31.148|
                  |L31.146|
000092  683f              LDR      r7,[r7,#0]            ;987
                  |L31.148|
000094  6838              LDR      r0,[r7,#0]            ;987
000096  42a0              CMP      r0,r4                 ;987
000098  d1fb              BNE      |L31.146|
00009a  6820              LDR      r0,[r4,#0]            ;988
00009c  6038              STR      r0,[r7,#0]            ;988
00009e  6ca8              LDR      r0,[r5,#0x48]         ;989
0000a0  6020              STR      r0,[r4,#0]            ;989
0000a2  64ac              STR      r4,[r5,#0x48]         ;990
0000a4  7960              LDRB     r0,[r4,#5]            ;991
0000a6  f0400040          ORR      r0,r0,#0x40           ;991
0000aa  7160              STRB     r0,[r4,#5]            ;991
0000ac  bf00              NOP                            ;992
0000ae  bf00              NOP      
0000b0  e7c1              B        |L31.54|
;;;994    
                          ENDP


                          AREA ||i.luaC_fix||, CODE, READONLY, ALIGN=1

                  luaC_fix PROC
;;;238    
;;;239    void luaC_fix (lua_State *L, GCObject *o) {
000000  4602              MOV      r2,r0
;;;240      global_State *g = G(L);
000002  6910              LDR      r0,[r2,#0x10]
;;;241      lua_assert(g->allgc == o);  /* object must be 1st in 'allgc' list! */
;;;242      white2gray(o);  /* they will be gray forever */
000004  794b              LDRB     r3,[r1,#5]
000006  f00303e7          AND      r3,r3,#0xe7
00000a  714b              STRB     r3,[r1,#5]
;;;243      setage(o, G_OLD);  /* and old forever */
00000c  794b              LDRB     r3,[r1,#5]
00000e  f0230307          BIC      r3,r3,#7
000012  1d1b              ADDS     r3,r3,#4
000014  714b              STRB     r3,[r1,#5]
;;;244      g->allgc = o->next;  /* remove object from 'allgc' list */
000016  680b              LDR      r3,[r1,#0]
000018  6403              STR      r3,[r0,#0x40]
;;;245      o->next = g->fixedgc;  /* link it to 'fixedgc' list */
00001a  6e83              LDR      r3,[r0,#0x68]
00001c  600b              STR      r3,[r1,#0]
;;;246      g->fixedgc = o;
00001e  6681              STR      r1,[r0,#0x68]
;;;247    }
000020  4770              BX       lr
;;;248    
                          ENDP


                          AREA ||i.luaC_freeallobjects||, CODE, READONLY, ALIGN=1

                  luaC_freeallobjects PROC
;;;1355   */
;;;1356   void luaC_freeallobjects (lua_State *L) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;1357     global_State *g = G(L);
000004  692c              LDR      r4,[r5,#0x10]
;;;1358     luaC_changemode(L, KGC_INC);
000006  2100              MOVS     r1,#0
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       luaC_changemode
;;;1359     separatetobefnz(g, 1);  /* separate all objects with finalizers */
00000e  2101              MOVS     r1,#1
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       separatetobefnz
;;;1360     lua_assert(g->finobj == NULL);
;;;1361     callallpendingfinalizers(L, 0);
000016  2100              MOVS     r1,#0
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       callallpendingfinalizers
;;;1362     deletelist(L, g->allgc, obj2gco(g->mainthread));
00001e  4628              MOV      r0,r5
000020  f8d4208c          LDR      r2,[r4,#0x8c]
000024  6c21              LDR      r1,[r4,#0x40]
000026  f7fffffe          BL       deletelist
;;;1363     deletelist(L, g->finobj, NULL);
00002a  2200              MOVS     r2,#0
00002c  4628              MOV      r0,r5
00002e  6ca1              LDR      r1,[r4,#0x48]
000030  f7fffffe          BL       deletelist
;;;1364     deletelist(L, g->fixedgc, NULL);  /* collect fixed objects */
000034  2200              MOVS     r2,#0
000036  4628              MOV      r0,r5
000038  6ea1              LDR      r1,[r4,#0x68]
00003a  f7fffffe          BL       deletelist
;;;1365     lua_assert(g->strt.nuse == 0);
;;;1366   }
00003e  bd70              POP      {r4-r6,pc}
;;;1367   
                          ENDP


                          AREA ||i.luaC_fullgc||, CODE, READONLY, ALIGN=1

                  luaC_fullgc PROC
;;;1555   */
;;;1556   void luaC_fullgc (lua_State *L, int isemergency) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;1557     global_State *g = G(L);
000006  692c              LDR      r4,[r5,#0x10]
;;;1558     lua_assert(!g->gcemergency);
;;;1559     g->gcemergency = isemergency;  /* set flag */
000008  f884603a          STRB     r6,[r4,#0x3a]
;;;1560     if (g->gckind == KGC_INC)
00000c  f8940036          LDRB     r0,[r4,#0x36]
000010  b920              CBNZ     r0,|L34.28|
;;;1561       fullinc(L, g);
000012  4621              MOV      r1,r4
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       fullinc
00001a  e003              B        |L34.36|
                  |L34.28|
;;;1562     else
;;;1563       fullgen(L, g);
00001c  4621              MOV      r1,r4
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       fullgen
                  |L34.36|
;;;1564     g->gcemergency = 0;
000024  2000              MOVS     r0,#0
000026  f884003a          STRB     r0,[r4,#0x3a]
;;;1565   }
00002a  bd70              POP      {r4-r6,pc}
;;;1566   
                          ENDP


                          AREA ||i.luaC_newobj||, CODE, READONLY, ALIGN=1

                  luaC_newobj PROC
;;;253    */
;;;254    GCObject *luaC_newobj (lua_State *L, int tt, size_t sz) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4690              MOV      r8,r2
;;;255      global_State *g = G(L);
00000a  693e              LDR      r6,[r7,#0x10]
;;;256      GCObject *o = cast(GCObject *, luaM_newobject(L, novariant(tt), sz));
00000c  f005020f          AND      r2,r5,#0xf
000010  4641              MOV      r1,r8
000012  4638              MOV      r0,r7
000014  f7fffffe          BL       luaM_malloc_
000018  4604              MOV      r4,r0
;;;257      o->marked = luaC_white(g);
00001a  f8960034          LDRB     r0,[r6,#0x34]
00001e  f0000018          AND      r0,r0,#0x18
000022  7160              STRB     r0,[r4,#5]
;;;258      o->tt = tt;
000024  7125              STRB     r5,[r4,#4]
;;;259      o->next = g->allgc;
000026  6c30              LDR      r0,[r6,#0x40]
000028  6020              STR      r0,[r4,#0]
;;;260      g->allgc = o;
00002a  6434              STR      r4,[r6,#0x40]
;;;261      return o;
00002c  4620              MOV      r0,r4
;;;262    }
00002e  e8bd81f0          POP      {r4-r8,pc}
;;;263    
                          ENDP


                          AREA ||i.luaC_protobarrier_||, CODE, READONLY, ALIGN=1

                  luaC_protobarrier_ PROC
;;;227    */
;;;228    LUAI_FUNC void luaC_protobarrier_ (lua_State *L, Proto *p) {
000000  4602              MOV      r2,r0
;;;229      global_State *g = G(L);
000002  6910              LDR      r0,[r2,#0x10]
;;;230      lua_assert(g->gckind != KGC_GEN || isold(p));
;;;231      if (getage(p) == G_OLD1)  /* still need to be visited? */
000004  794b              LDRB     r3,[r1,#5]
000006  f0030307          AND      r3,r3,#7
00000a  2b03              CMP      r3,#3
00000c  d103              BNE      |L36.22|
;;;232        linkgclist(p, g->grayagain);  /* link it in 'grayagain' */
00000e  6d03              LDR      r3,[r0,#0x50]
000010  654b              STR      r3,[r1,#0x54]
000012  6501              STR      r1,[r0,#0x50]
000014  e002              B        |L36.28|
                  |L36.22|
;;;233      else
;;;234        linkgclist(p, g->protogray);  /* link it in 'protogray' */
000016  6e03              LDR      r3,[r0,#0x60]
000018  654b              STR      r3,[r1,#0x54]
00001a  6601              STR      r1,[r0,#0x60]
                  |L36.28|
;;;235      black2gray(p);  /* make prototype gray (to avoid other barriers) */
00001c  794b              LDRB     r3,[r1,#5]
00001e  f00303df          AND      r3,r3,#0xdf
000022  714b              STRB     r3,[r1,#5]
;;;236    }
000024  4770              BX       lr
;;;237    
                          ENDP


                          AREA ||i.luaC_runtilstate||, CODE, READONLY, ALIGN=1

                  luaC_runtilstate PROC
;;;1484   */
;;;1485   void luaC_runtilstate (lua_State *L, int statesmask) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1486     global_State *g = G(L);
000006  6926              LDR      r6,[r4,#0x10]
;;;1487     while (!testbit(statesmask, g->gcstate))
000008  e002              B        |L37.16|
                  |L37.10|
;;;1488       singlestep(L);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       singlestep
                  |L37.16|
000010  f8961035          LDRB     r1,[r6,#0x35]         ;1487
000014  2001              MOVS     r0,#1                 ;1487
000016  4088              LSLS     r0,r0,r1              ;1487
000018  4028              ANDS     r0,r0,r5              ;1487
00001a  2800              CMP      r0,#0                 ;1487
00001c  d0f5              BEQ      |L37.10|
;;;1489   }
00001e  bd70              POP      {r4-r6,pc}
;;;1490   
                          ENDP


                          AREA ||i.luaC_step||, CODE, READONLY, ALIGN=1

                  luaC_step PROC
;;;1519   */
;;;1520   void luaC_step (lua_State *L) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;1521     global_State *g = G(L);
000004  692c              LDR      r4,[r5,#0x10]
;;;1522     if (g->gcrunning) {  /* running? */
000006  f8940039          LDRB     r0,[r4,#0x39]
00000a  b158              CBZ      r0,|L38.36|
;;;1523       if (g->gckind == KGC_INC)
00000c  f8940036          LDRB     r0,[r4,#0x36]
000010  b920              CBNZ     r0,|L38.28|
;;;1524         incstep(L, g);
000012  4621              MOV      r1,r4
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       incstep
00001a  e003              B        |L38.36|
                  |L38.28|
;;;1525       else
;;;1526         genstep(L, g);
00001c  4621              MOV      r1,r4
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       genstep
                  |L38.36|
;;;1527     }
;;;1528   }
000024  bd70              POP      {r4-r6,pc}
;;;1529   
                          ENDP


                          AREA ||i.markbeingfnz||, CODE, READONLY, ALIGN=1

                  markbeingfnz PROC
;;;328    */
;;;329    static lu_mem markbeingfnz (global_State *g) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;330      GCObject *o;
;;;331      lu_mem count = 0;
000004  2600              MOVS     r6,#0
;;;332      for (o = g->tobefnz; o != NULL; o = o->next) {
000006  6e6c              LDR      r4,[r5,#0x64]
000008  e009              B        |L39.30|
                  |L39.10|
;;;333        count++;
00000a  1c76              ADDS     r6,r6,#1
;;;334        markobject(g, o);
00000c  7960              LDRB     r0,[r4,#5]
00000e  f0000018          AND      r0,r0,#0x18
000012  b118              CBZ      r0,|L39.28|
000014  4621              MOV      r1,r4
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       reallymarkobject
                  |L39.28|
00001c  6824              LDR      r4,[r4,#0]            ;332
                  |L39.30|
00001e  2c00              CMP      r4,#0                 ;332
000020  d1f3              BNE      |L39.10|
;;;335      }
;;;336      return count;
000022  4630              MOV      r0,r6
;;;337    }
000024  bd70              POP      {r4-r6,pc}
;;;338    
                          ENDP


                          AREA ||i.markmt||, CODE, READONLY, ALIGN=1

                  markmt PROC
;;;318    */
;;;319    static void markmt (global_State *g) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;320      int i;
;;;321      for (i=0; i < LUA_NUMTAGS; i++)
000004  2400              MOVS     r4,#0
000006  e014              B        |L40.50|
                  |L40.8|
;;;322        markobjectN(g, g->mt[i]);
000008  f5057080          ADD      r0,r5,#0x100
00000c  f8500024          LDR      r0,[r0,r4,LSL #2]
000010  b170              CBZ      r0,|L40.48|
000012  f5057080          ADD      r0,r5,#0x100
000016  f8500024          LDR      r0,[r0,r4,LSL #2]
00001a  7940              LDRB     r0,[r0,#5]
00001c  f0000018          AND      r0,r0,#0x18
000020  b130              CBZ      r0,|L40.48|
000022  f5057080          ADD      r0,r5,#0x100
000026  f8501024          LDR      r1,[r0,r4,LSL #2]
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       reallymarkobject
                  |L40.48|
000030  1c64              ADDS     r4,r4,#1              ;321
                  |L40.50|
000032  2c09              CMP      r4,#9                 ;321
000034  dbe8              BLT      |L40.8|
;;;323    }
000036  bd70              POP      {r4-r6,pc}
;;;324    
                          ENDP


                          AREA ||i.markold||, CODE, READONLY, ALIGN=1

                  markold PROC
;;;1142   */
;;;1143   static void markold (global_State *g, GCObject *from, GCObject *to) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;1144     GCObject *p;
;;;1145     for (p = from; p != to; p = p->next) {
00000a  462c              MOV      r4,r5
00000c  e011              B        |L41.50|
                  |L41.14|
;;;1146       if (getage(p) == G_OLD1) {
00000e  7960              LDRB     r0,[r4,#5]
000010  f0000007          AND      r0,r0,#7
000014  2803              CMP      r0,#3
000016  d10b              BNE      |L41.48|
;;;1147         lua_assert(!iswhite(p));
;;;1148         if (isblack(p)) {
000018  7960              LDRB     r0,[r4,#5]
00001a  f0000020          AND      r0,r0,#0x20
00001e  b138              CBZ      r0,|L41.48|
;;;1149           black2gray(p);  /* should be '2white', but gray works too */
000020  7960              LDRB     r0,[r4,#5]
000022  f00000df          AND      r0,r0,#0xdf
000026  7160              STRB     r0,[r4,#5]
;;;1150           reallymarkobject(g, p);
000028  4621              MOV      r1,r4
00002a  4638              MOV      r0,r7
00002c  f7fffffe          BL       reallymarkobject
                  |L41.48|
000030  6824              LDR      r4,[r4,#0]            ;1145
                  |L41.50|
000032  42b4              CMP      r4,r6                 ;1145
000034  d1eb              BNE      |L41.14|
;;;1151         }
;;;1152       }
;;;1153     }
;;;1154   }
000036  e8bd81f0          POP      {r4-r8,pc}
;;;1155   
                          ENDP


                          AREA ||i.propagateall||, CODE, READONLY, ALIGN=1

                  propagateall PROC
;;;646    
;;;647    static lu_mem propagateall (global_State *g) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;648      lu_mem tot = 0;
000004  2500              MOVS     r5,#0
;;;649      while (g->gray)
000006  e003              B        |L42.16|
                  |L42.8|
;;;650        tot += propagatemark(g);
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       propagatemark
00000e  4405              ADD      r5,r5,r0
                  |L42.16|
000010  6ce0              LDR      r0,[r4,#0x4c]         ;649
000012  2800              CMP      r0,#0                 ;649
000014  d1f8              BNE      |L42.8|
;;;651      return tot;
000016  4628              MOV      r0,r5
;;;652    }
000018  bd70              POP      {r4-r6,pc}
;;;653    
                          ENDP


                          AREA ||i.propagatemark||, CODE, READONLY, ALIGN=1

                  propagatemark PROC
;;;625    */
;;;626    static lu_mem propagatemark (global_State *g) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;627      GCObject *o = g->gray;
000004  6cec              LDR      r4,[r5,#0x4c]
;;;628      gray2black(o);
000006  7960              LDRB     r0,[r4,#5]
000008  f0400020          ORR      r0,r0,#0x20
00000c  7160              STRB     r0,[r4,#5]
;;;629      g->gray = *getgclist(o);  /* remove from 'gray' list */
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       getgclist
000014  6800              LDR      r0,[r0,#0]
000016  64e8              STR      r0,[r5,#0x4c]
;;;630      switch (o->tt) {
000018  7920              LDRB     r0,[r4,#4]
00001a  280a              CMP      r0,#0xa
00001c  d020              BEQ      |L43.96|
00001e  dc06              BGT      |L43.46|
000020  2805              CMP      r0,#5
000022  d009              BEQ      |L43.56|
000024  2807              CMP      r0,#7
000026  d00c              BEQ      |L43.66|
000028  2808              CMP      r0,#8
00002a  d12b              BNE      |L43.132|
00002c  e01d              B        |L43.106|
                  |L43.46|
00002e  2816              CMP      r0,#0x16
000030  d00c              BEQ      |L43.76|
000032  2836              CMP      r0,#0x36
000034  d126              BNE      |L43.132|
000036  e00e              B        |L43.86|
                  |L43.56|
;;;631        case LUA_TTABLE: return traversetable(g, gco2t(o));
000038  4621              MOV      r1,r4
00003a  4628              MOV      r0,r5
00003c  f7fffffe          BL       traversetable
                  |L43.64|
;;;632        case LUA_TUSERDATA: return traverseudata(g, gco2u(o));
;;;633        case LUA_TLCL: return traverseLclosure(g, gco2lcl(o));
;;;634        case LUA_TCCL: return traverseCclosure(g, gco2ccl(o));
;;;635        case LUA_TPROTO: return traverseproto(g, gco2p(o));
;;;636        case LUA_TTHREAD: {
;;;637          lua_State *th = gco2th(o);
;;;638          linkgclist(th, g->grayagain);  /* insert into 'grayagain' list */
;;;639          black2gray(o);
;;;640          return traversethread(g, th);
;;;641        }
;;;642        default: lua_assert(0); return 0;
;;;643      }
;;;644    }
000040  bd70              POP      {r4-r6,pc}
                  |L43.66|
000042  4621              MOV      r1,r4                 ;632
000044  4628              MOV      r0,r5                 ;632
000046  f7fffffe          BL       traverseudata
00004a  e7f9              B        |L43.64|
                  |L43.76|
00004c  4621              MOV      r1,r4                 ;633
00004e  4628              MOV      r0,r5                 ;633
000050  f7fffffe          BL       traverseLclosure
000054  e7f4              B        |L43.64|
                  |L43.86|
000056  4621              MOV      r1,r4                 ;634
000058  4628              MOV      r0,r5                 ;634
00005a  f7fffffe          BL       traverseCclosure
00005e  e7ef              B        |L43.64|
                  |L43.96|
000060  4621              MOV      r1,r4                 ;635
000062  4628              MOV      r0,r5                 ;635
000064  f7fffffe          BL       traverseproto
000068  e7ea              B        |L43.64|
                  |L43.106|
00006a  4626              MOV      r6,r4                 ;637
00006c  6d28              LDR      r0,[r5,#0x50]         ;638
00006e  62b0              STR      r0,[r6,#0x28]         ;638
000070  652e              STR      r6,[r5,#0x50]         ;638
000072  7960              LDRB     r0,[r4,#5]            ;639
000074  f00000df          AND      r0,r0,#0xdf           ;639
000078  7160              STRB     r0,[r4,#5]            ;639
00007a  4631              MOV      r1,r6                 ;640
00007c  4628              MOV      r0,r5                 ;640
00007e  f7fffffe          BL       traversethread
000082  e7dd              B        |L43.64|
                  |L43.132|
000084  2000              MOVS     r0,#0                 ;642
000086  e7db              B        |L43.64|
;;;645    
                          ENDP


                          AREA ||i.reallymarkobject||, CODE, READONLY, ALIGN=1

                  reallymarkobject PROC
;;;281    */
;;;282    static void reallymarkobject (global_State *g, GCObject *o) {
000000  b570              PUSH     {r4-r6,lr}
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;283      white2gray(o);
000006  7960              LDRB     r0,[r4,#5]
000008  f00000e7          AND      r0,r0,#0xe7
00000c  7160              STRB     r0,[r4,#5]
;;;284      switch (o->tt) {
00000e  7920              LDRB     r0,[r4,#4]
000010  280a              CMP      r0,#0xa
000012  d04b              BEQ      |L44.172|
000014  dc08              BGT      |L44.40|
000016  2805              CMP      r0,#5
000018  d046              BEQ      |L44.168|
00001a  2807              CMP      r0,#7
00001c  d02e              BEQ      |L44.124|
00001e  2808              CMP      r0,#8
000020  d043              BEQ      |L44.170|
000022  2809              CMP      r0,#9
000024  d149              BNE      |L44.186|
000026  e00e              B        |L44.70|
                  |L44.40|
000028  2814              CMP      r0,#0x14
00002a  d006              BEQ      |L44.58|
00002c  2816              CMP      r0,#0x16
00002e  d039              BEQ      |L44.164|
000030  2824              CMP      r0,#0x24
000032  d003              BEQ      |L44.60|
000034  2836              CMP      r0,#0x36
000036  d140              BNE      |L44.186|
000038  e035              B        |L44.166|
                  |L44.58|
;;;285        case LUA_TSHRSTR:
;;;286        case LUA_TLNGSTR: {
00003a  bf00              NOP      
                  |L44.60|
;;;287          gray2black(o);
00003c  7960              LDRB     r0,[r4,#5]
00003e  f0400020          ORR      r0,r0,#0x20
000042  7160              STRB     r0,[r4,#5]
;;;288          break;
000044  e03a              B        |L44.188|
                  |L44.70|
;;;289        }
;;;290        case LUA_TUPVAL: {
;;;291          UpVal *uv = gco2upv(o);
000046  4625              MOV      r5,r4
;;;292          if (!upisopen(uv))  /* open upvalues are kept gray */
000048  f1050010          ADD      r0,r5,#0x10
00004c  68a9              LDR      r1,[r5,#8]
00004e  4281              CMP      r1,r0
000050  d103              BNE      |L44.90|
;;;293            gray2black(o);
000052  7960              LDRB     r0,[r4,#5]
000054  f0400020          ORR      r0,r0,#0x20
000058  7160              STRB     r0,[r4,#5]
                  |L44.90|
;;;294          markvalue(g, uv->v);  /* mark its content */
00005a  68a8              LDR      r0,[r5,#8]
00005c  7a00              LDRB     r0,[r0,#8]
00005e  f0000040          AND      r0,r0,#0x40
000062  b150              CBZ      r0,|L44.122|
000064  68a8              LDR      r0,[r5,#8]
000066  6800              LDR      r0,[r0,#0]
000068  7940              LDRB     r0,[r0,#5]
00006a  f0000018          AND      r0,r0,#0x18
00006e  b120              CBZ      r0,|L44.122|
000070  68a8              LDR      r0,[r5,#8]
000072  6801              LDR      r1,[r0,#0]
000074  4630              MOV      r0,r6
000076  f7fffffe          BL       reallymarkobject
                  |L44.122|
;;;295          break;
00007a  e01f              B        |L44.188|
                  |L44.124|
;;;296        }
;;;297        case LUA_TUSERDATA: {
;;;298          Udata *u = gco2u(o);
00007c  4625              MOV      r5,r4
;;;299          if (u->nuvalue == 0) {  /* no user values? */
00007e  88e8              LDRH     r0,[r5,#6]
000080  b978              CBNZ     r0,|L44.162|
;;;300            markobjectN(g, u->metatable);  /* mark its metatable */
000082  68e8              LDR      r0,[r5,#0xc]
000084  b140              CBZ      r0,|L44.152|
000086  68e8              LDR      r0,[r5,#0xc]
000088  7940              LDRB     r0,[r0,#5]
00008a  f0000018          AND      r0,r0,#0x18
00008e  b118              CBZ      r0,|L44.152|
000090  4630              MOV      r0,r6
000092  68e9              LDR      r1,[r5,#0xc]
000094  f7fffffe          BL       reallymarkobject
                  |L44.152|
;;;301            gray2black(o);  /* nothing else to mark */
000098  7960              LDRB     r0,[r4,#5]
00009a  f0400020          ORR      r0,r0,#0x20
00009e  7160              STRB     r0,[r4,#5]
;;;302            break;
0000a0  e00c              B        |L44.188|
                  |L44.162|
;;;303          }
;;;304          /* else *//* FALLTHROUGH */
;;;305        }
;;;306        case LUA_TLCL: case LUA_TCCL: case LUA_TTABLE:
0000a2  bf00              NOP      
                  |L44.164|
0000a4  bf00              NOP      
                  |L44.166|
0000a6  bf00              NOP      
                  |L44.168|
;;;307        case LUA_TTHREAD: case LUA_TPROTO: {
0000a8  bf00              NOP      
                  |L44.170|
0000aa  bf00              NOP      
                  |L44.172|
;;;308          linkobjgclist(o, g->gray);
0000ac  4620              MOV      r0,r4
0000ae  f7fffffe          BL       getgclist
0000b2  6cf1              LDR      r1,[r6,#0x4c]
0000b4  6001              STR      r1,[r0,#0]
0000b6  64f4              STR      r4,[r6,#0x4c]
;;;309          break;
0000b8  e000              B        |L44.188|
                  |L44.186|
;;;310        }
;;;311        default: lua_assert(0); break;
0000ba  bf00              NOP      
                  |L44.188|
0000bc  bf00              NOP                            ;288
;;;312      }
;;;313    }
0000be  bd70              POP      {r4-r6,pc}
;;;314    
                          ENDP


                          AREA ||i.remarkupvals||, CODE, READONLY, ALIGN=1

                  remarkupvals PROC
;;;345    */
;;;346    static int remarkupvals (global_State *g) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4607              MOV      r7,r0
;;;347      lua_State *thread;
;;;348      lua_State **p = &g->twups;
000006  f1070884          ADD      r8,r7,#0x84
;;;349      int work = 0;
00000a  2600              MOVS     r6,#0
;;;350      while ((thread = *p) != NULL) {
00000c  e028              B        |L45.96|
                  |L45.14|
;;;351        work++;
00000e  1c76              ADDS     r6,r6,#1
;;;352        lua_assert(!isblack(thread));  /* threads are never black */
;;;353        if (isgray(thread) && thread->openupval != NULL)
000010  7960              LDRB     r0,[r4,#5]
000012  f0000038          AND      r0,r0,#0x38
000016  b920              CBNZ     r0,|L45.34|
000018  6a60              LDR      r0,[r4,#0x24]
00001a  b110              CBZ      r0,|L45.34|
;;;354          p = &thread->twups;  /* keep marked thread with upvalues in the list */
00001c  f104082c          ADD      r8,r4,#0x2c
000020  e01e              B        |L45.96|
                  |L45.34|
;;;355        else {  /* thread is not marked or without upvalues */
;;;356          UpVal *uv;
;;;357          *p = thread->twups;  /* remove thread from the list */
000022  6ae0              LDR      r0,[r4,#0x2c]
000024  f8c80000          STR      r0,[r8,#0]
;;;358          thread->twups = thread;  /* mark that it is out of list */
000028  62e4              STR      r4,[r4,#0x2c]
;;;359          for (uv = thread->openupval; uv != NULL; uv = uv->u.open.next) {
00002a  6a65              LDR      r5,[r4,#0x24]
00002c  e015              B        |L45.90|
                  |L45.46|
;;;360            work++;
00002e  1c76              ADDS     r6,r6,#1
;;;361            if (!iswhite(uv))  /* upvalue already visited? */
000030  7968              LDRB     r0,[r5,#5]
000032  f0000018          AND      r0,r0,#0x18
000036  b978              CBNZ     r0,|L45.88|
;;;362              markvalue(g, uv->v);  /* mark its value */
000038  68a8              LDR      r0,[r5,#8]
00003a  7a00              LDRB     r0,[r0,#8]
00003c  f0000040          AND      r0,r0,#0x40
000040  b150              CBZ      r0,|L45.88|
000042  68a8              LDR      r0,[r5,#8]
000044  6800              LDR      r0,[r0,#0]
000046  7940              LDRB     r0,[r0,#5]
000048  f0000018          AND      r0,r0,#0x18
00004c  b120              CBZ      r0,|L45.88|
00004e  68a8              LDR      r0,[r5,#8]
000050  6801              LDR      r1,[r0,#0]
000052  4638              MOV      r0,r7
000054  f7fffffe          BL       reallymarkobject
                  |L45.88|
000058  692d              LDR      r5,[r5,#0x10]         ;359
                  |L45.90|
00005a  2d00              CMP      r5,#0                 ;359
00005c  d1e7              BNE      |L45.46|
;;;363          }
;;;364        }
00005e  bf00              NOP      
                  |L45.96|
000060  f8d84000          LDR      r4,[r8,#0]            ;350
000064  2c00              CMP      r4,#0                 ;350
000066  d1d2              BNE      |L45.14|
;;;365      }
;;;366      return work;
000068  4630              MOV      r0,r6
;;;367    }
00006a  e8bd81f0          POP      {r4-r8,pc}
;;;368    
                          ENDP


                          AREA ||i.restartcollection||, CODE, READONLY, ALIGN=1

                  restartcollection PROC
;;;372    */
;;;373    static void restartcollection (global_State *g) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;374      g->gray = g->grayagain = NULL;
000004  2000              MOVS     r0,#0
000006  6520              STR      r0,[r4,#0x50]
000008  64e0              STR      r0,[r4,#0x4c]
;;;375      g->weak = g->allweak = g->ephemeron = g->protogray = NULL;
00000a  6620              STR      r0,[r4,#0x60]
00000c  65a0              STR      r0,[r4,#0x58]
00000e  65e0              STR      r0,[r4,#0x5c]
000010  6560              STR      r0,[r4,#0x54]
;;;376      markobject(g, g->mainthread);
000012  f8d4008c          LDR      r0,[r4,#0x8c]
000016  7940              LDRB     r0,[r0,#5]
000018  f0000018          AND      r0,r0,#0x18
00001c  b120              CBZ      r0,|L46.40|
00001e  4620              MOV      r0,r4
000020  f8d4108c          LDR      r1,[r4,#0x8c]
000024  f7fffffe          BL       reallymarkobject
                  |L46.40|
;;;377      markvalue(g, &g->l_registry);
000028  2028              MOVS     r0,#0x28
00002a  5d00              LDRB     r0,[r0,r4]
00002c  f0000040          AND      r0,r0,#0x40
000030  b140              CBZ      r0,|L46.68|
000032  6a20              LDR      r0,[r4,#0x20]
000034  7940              LDRB     r0,[r0,#5]
000036  f0000018          AND      r0,r0,#0x18
00003a  b118              CBZ      r0,|L46.68|
00003c  4620              MOV      r0,r4
00003e  6a21              LDR      r1,[r4,#0x20]
000040  f7fffffe          BL       reallymarkobject
                  |L46.68|
;;;378      markmt(g);
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       markmt
;;;379      markbeingfnz(g);  /* mark any finalizing object left from previous cycle */
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       markbeingfnz
;;;380    }
000050  bd10              POP      {r4,pc}
;;;381    
                          ENDP


                          AREA ||i.runafewfinalizers||, CODE, READONLY, ALIGN=1

                  runafewfinalizers PROC
;;;905    */
;;;906    static int runafewfinalizers (lua_State *L, int n) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;907      global_State *g = G(L);
000008  692f              LDR      r7,[r5,#0x10]
;;;908      int i;
;;;909      for (i = 0; i < n && g->tobefnz; i++)
00000a  2400              MOVS     r4,#0
00000c  e004              B        |L47.24|
                  |L47.14|
;;;910        GCTM(L, 1);  /* call one finalizer */
00000e  2101              MOVS     r1,#1
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       GCTM
000016  1c64              ADDS     r4,r4,#1              ;909
                  |L47.24|
000018  42b4              CMP      r4,r6                 ;909
00001a  da02              BGE      |L47.34|
00001c  6e78              LDR      r0,[r7,#0x64]         ;909
00001e  2800              CMP      r0,#0                 ;909
000020  d1f5              BNE      |L47.14|
                  |L47.34|
;;;911      return i;
000022  4620              MOV      r0,r4
;;;912    }
000024  e8bd81f0          POP      {r4-r8,pc}
;;;913    
                          ENDP


                          AREA ||i.separatetobefnz||, CODE, READONLY, ALIGN=1

                  separatetobefnz PROC
;;;941    */
;;;942    static void separatetobefnz (global_State *g, int all) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;943      GCObject *curr;
;;;944      GCObject **p = &g->finobj;
000008  f1050748          ADD      r7,r5,#0x48
;;;945      GCObject **lastnext = findlast(&g->tobefnz);
00000c  f1050064          ADD      r0,r5,#0x64
000010  f7fffffe          BL       findlast
000014  4680              MOV      r8,r0
;;;946      while ((curr = *p) != g->finobjold) {  /* traverse all finalizable objects */
000016  e013              B        |L48.64|
                  |L48.24|
;;;947        lua_assert(tofinalize(curr));
;;;948        if (!(iswhite(curr) || all))  /* not being collected? */
000018  7960              LDRB     r0,[r4,#5]
00001a  f0000018          AND      r0,r0,#0x18
00001e  b910              CBNZ     r0,|L48.38|
000020  b90e              CBNZ     r6,|L48.38|
;;;949          p = &curr->next;  /* don't bother with it */
000022  4627              MOV      r7,r4
000024  e00c              B        |L48.64|
                  |L48.38|
;;;950        else {
;;;951          if (curr == g->finobjsur)  /* removing 'finobjsur'? */
000026  6fa8              LDR      r0,[r5,#0x78]
000028  42a0              CMP      r0,r4
00002a  d101              BNE      |L48.48|
;;;952            g->finobjsur = curr->next;  /* correct it */
00002c  6820              LDR      r0,[r4,#0]
00002e  67a8              STR      r0,[r5,#0x78]
                  |L48.48|
;;;953          *p = curr->next;  /* remove 'curr' from 'finobj' list */
000030  6820              LDR      r0,[r4,#0]
000032  6038              STR      r0,[r7,#0]
;;;954          curr->next = *lastnext;  /* link at the end of 'tobefnz' list */
000034  f8d80000          LDR      r0,[r8,#0]
000038  6020              STR      r0,[r4,#0]
;;;955          *lastnext = curr;
00003a  f8c84000          STR      r4,[r8,#0]
;;;956          lastnext = &curr->next;
00003e  46a0              MOV      r8,r4
                  |L48.64|
000040  683c              LDR      r4,[r7,#0]            ;946
000042  6fe8              LDR      r0,[r5,#0x7c]         ;946
000044  4284              CMP      r4,r0                 ;946
000046  d1e7              BNE      |L48.24|
;;;957        }
;;;958      }
;;;959    }
000048  e8bd81f0          POP      {r4-r8,pc}
;;;960    
                          ENDP


                          AREA ||i.setpause||, CODE, READONLY, ALIGN=1

                  setpause PROC
;;;1309   */
;;;1310   static void setpause (global_State *g) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
;;;1311     l_mem threshold, debt;
;;;1312     int pause = getgcparam(g->gcpause);
000006  f894003b          LDRB     r0,[r4,#0x3b]
00000a  0086              LSLS     r6,r0,#2
;;;1313     l_mem estimate = g->GCestimate / PAUSEADJ;  /* adjust 'estimate' */
00000c  2164              MOVS     r1,#0x64
00000e  6920              LDR      r0,[r4,#0x10]
000010  fbb0f7f1          UDIV     r7,r0,r1
;;;1314     lua_assert(estimate > 0);
;;;1315     threshold = (pause < MAX_LMEM / estimate)  /* overflow? */
000014  f06f4000          MVN      r0,#0x80000000
000018  fb90f0f7          SDIV     r0,r0,r7
00001c  42b0              CMP      r0,r6
00001e  dd02              BLE      |L49.38|
;;;1316               ? estimate * pause  /* no overflow */
000020  fb07f006          MUL      r0,r7,r6
000024  e001              B        |L49.42|
                  |L49.38|
;;;1317               : MAX_LMEM;  /* overflow; truncate to maximum */
000026  f06f4000          MVN      r0,#0x80000000
                  |L49.42|
00002a  4680              MOV      r8,r0
;;;1318     debt = gettotalbytes(g) - threshold;
00002c  e9d40102          LDRD     r0,r1,[r4,#8]
000030  4408              ADD      r0,r0,r1
000032  eba00508          SUB      r5,r0,r8
;;;1319     if (debt > 0) debt = 0;
000036  2d00              CMP      r5,#0
000038  dd00              BLE      |L49.60|
00003a  2500              MOVS     r5,#0
                  |L49.60|
;;;1320     luaE_setdebt(g, debt);
00003c  4629              MOV      r1,r5
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       luaE_setdebt
;;;1321   }
000044  e8bd81f0          POP      {r4-r8,pc}
;;;1322   
                          ENDP


                          AREA ||i.singlestep||, CODE, READONLY, ALIGN=1

                  singlestep PROC
;;;1428   
;;;1429   static lu_mem singlestep (lua_State *L) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;1430     global_State *g = G(L);
000004  692c              LDR      r4,[r5,#0x10]
;;;1431     switch (g->gcstate) {
000006  f8940035          LDRB     r0,[r4,#0x35]
00000a  2809              CMP      r0,#9
00000c  d25d              BCS      |L50.202|
00000e  e8dff000          TBB      [pc,r0]
000012  0d18              DCB      0x0d,0x18
000014  5c293139          DCB      0x5c,0x29,0x31,0x39
000018  40490500          DCB      0x40,0x49,0x05,0x00
;;;1432       case GCSpause: {
;;;1433         restartcollection(g);
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       restartcollection
;;;1434         g->gcstate = GCSpropagate;
000022  2000              MOVS     r0,#0
000024  f8840035          STRB     r0,[r4,#0x35]
;;;1435         return 1;
000028  2001              MOVS     r0,#1
                  |L50.42|
;;;1436       }
;;;1437       case GCSpropagate: {
;;;1438         if (g->gray == NULL) {  /* no more gray objects? */
;;;1439           g->gcstate = GCSenteratomic;  /* finish propagate phase */
;;;1440           return 0;
;;;1441         }
;;;1442         else
;;;1443           return propagatemark(g);  /* traverse one gray object */
;;;1444       }
;;;1445       case GCSenteratomic: {
;;;1446         lu_mem work = propagateall(g);  /* make sure gray list is empty */
;;;1447         work += atomic(L);  /* work is what was traversed by 'atomic' */
;;;1448         entersweep(L);
;;;1449         g->GCestimate = gettotalbytes(g);  /* first estimate */;
;;;1450         return work;
;;;1451       }
;;;1452       case GCSswpallgc: {  /* sweep "regular" objects */
;;;1453         return sweepstep(L, g, GCSswpfinobj, &g->finobj);
;;;1454       }
;;;1455       case GCSswpfinobj: {  /* sweep objects with finalizers */
;;;1456         return sweepstep(L, g, GCSswptobefnz, &g->tobefnz);
;;;1457       }
;;;1458       case GCSswptobefnz: {  /* sweep objects to be finalized */
;;;1459         return sweepstep(L, g, GCSswpend, NULL);
;;;1460       }
;;;1461       case GCSswpend: {  /* finish sweeps */
;;;1462         checkSizes(L, g);
;;;1463         g->gcstate = GCScallfin;
;;;1464         return 0;
;;;1465       }
;;;1466       case GCScallfin: {  /* call remaining finalizers */
;;;1467         if (g->tobefnz && !g->gcemergency) {
;;;1468           int n = runafewfinalizers(L, GCFINMAX);
;;;1469           return n * GCFINALIZECOST;
;;;1470         }
;;;1471         else {  /* emergency mode or no more finalizers */
;;;1472           g->gcstate = GCSpause;  /* finish collection */
;;;1473           return 0;
;;;1474         }
;;;1475       }
;;;1476       default: lua_assert(0); return 0;
;;;1477     }
;;;1478   }
00002a  bd70              POP      {r4-r6,pc}
00002c  6ce0              LDR      r0,[r4,#0x4c]         ;1438
00002e  b920              CBNZ     r0,|L50.58|
000030  2001              MOVS     r0,#1                 ;1439
000032  f8840035          STRB     r0,[r4,#0x35]         ;1439
000036  2000              MOVS     r0,#0                 ;1440
000038  e7f7              B        |L50.42|
                  |L50.58|
00003a  4620              MOV      r0,r4                 ;1443
00003c  f7fffffe          BL       propagatemark
000040  e7f3              B        |L50.42|
000042  4620              MOV      r0,r4                 ;1446
000044  f7fffffe          BL       propagateall
000048  4606              MOV      r6,r0                 ;1446
00004a  4628              MOV      r0,r5                 ;1447
00004c  f7fffffe          BL       atomic
000050  4406              ADD      r6,r6,r0              ;1447
000052  4628              MOV      r0,r5                 ;1448
000054  f7fffffe          BL       entersweep
000058  e9d40102          LDRD     r0,r1,[r4,#8]         ;1449
00005c  4408              ADD      r0,r0,r1              ;1449
00005e  6120              STR      r0,[r4,#0x10]         ;1449
000060  4630              MOV      r0,r6                 ;1450
000062  e7e2              B        |L50.42|
000064  f1040348          ADD      r3,r4,#0x48           ;1453
000068  2204              MOVS     r2,#4                 ;1453
00006a  4621              MOV      r1,r4                 ;1453
00006c  4628              MOV      r0,r5                 ;1453
00006e  f7fffffe          BL       sweepstep
000072  e7da              B        |L50.42|
000074  f1040364          ADD      r3,r4,#0x64           ;1456
000078  2205              MOVS     r2,#5                 ;1456
00007a  4621              MOV      r1,r4                 ;1456
00007c  4628              MOV      r0,r5                 ;1456
00007e  f7fffffe          BL       sweepstep
000082  e7d2              B        |L50.42|
000084  2300              MOVS     r3,#0                 ;1459
000086  2206              MOVS     r2,#6                 ;1459
000088  4621              MOV      r1,r4                 ;1459
00008a  4628              MOV      r0,r5                 ;1459
00008c  f7fffffe          BL       sweepstep
000090  e7cb              B        |L50.42|
000092  4621              MOV      r1,r4                 ;1462
000094  4628              MOV      r0,r5                 ;1462
000096  f7fffffe          BL       checkSizes
00009a  2007              MOVS     r0,#7                 ;1463
00009c  f8840035          STRB     r0,[r4,#0x35]         ;1463
0000a0  2000              MOVS     r0,#0                 ;1464
0000a2  e7c2              B        |L50.42|
0000a4  6e60              LDR      r0,[r4,#0x64]         ;1467
0000a6  b158              CBZ      r0,|L50.192|
0000a8  f894003a          LDRB     r0,[r4,#0x3a]         ;1467
0000ac  b940              CBNZ     r0,|L50.192|
0000ae  210a              MOVS     r1,#0xa               ;1468
0000b0  4628              MOV      r0,r5                 ;1468
0000b2  f7fffffe          BL       runafewfinalizers
0000b6  4606              MOV      r6,r0                 ;1468
0000b8  2132              MOVS     r1,#0x32              ;1469
0000ba  fb06f001          MUL      r0,r6,r1              ;1469
0000be  e7b4              B        |L50.42|
                  |L50.192|
0000c0  2008              MOVS     r0,#8                 ;1472
0000c2  f8840035          STRB     r0,[r4,#0x35]         ;1472
0000c6  2000              MOVS     r0,#0                 ;1473
0000c8  e7af              B        |L50.42|
                  |L50.202|
0000ca  2000              MOVS     r0,#0                 ;1476
0000cc  e7ad              B        |L50.42|
;;;1479   
                          ENDP


                          AREA ||i.sweep2old||, CODE, READONLY, ALIGN=1

                  sweep2old PROC
;;;1012   */
;;;1013   static void sweep2old (lua_State *L, GCObject **p) {
000000  b570              PUSH     {r4-r6,lr}
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;1014     GCObject *curr;
;;;1015     while ((curr = *p) != NULL) {
000006  e010              B        |L51.42|
                  |L51.8|
;;;1016       if (iswhite(curr)) {  /* is 'curr' dead? */
000008  7960              LDRB     r0,[r4,#5]
00000a  f0000018          AND      r0,r0,#0x18
00000e  b130              CBZ      r0,|L51.30|
;;;1017         lua_assert(isdead(G(L), curr));
;;;1018         *p = curr->next;  /* remove 'curr' from list */
000010  6820              LDR      r0,[r4,#0]
000012  6028              STR      r0,[r5,#0]
;;;1019         freeobj(L, curr);  /* erase 'curr' */
000014  4621              MOV      r1,r4
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       freeobj
00001c  e005              B        |L51.42|
                  |L51.30|
;;;1020       }
;;;1021       else {  /* all surviving objects become old */
;;;1022         setage(curr, G_OLD);
00001e  7960              LDRB     r0,[r4,#5]
000020  f0200007          BIC      r0,r0,#7
000024  1d00              ADDS     r0,r0,#4
000026  7160              STRB     r0,[r4,#5]
;;;1023         p = &curr->next;  /* go to next element */
000028  4625              MOV      r5,r4
                  |L51.42|
00002a  682c              LDR      r4,[r5,#0]            ;1015
00002c  2c00              CMP      r4,#0                 ;1015
00002e  d1eb              BNE      |L51.8|
;;;1024       }
;;;1025     }
;;;1026   }
000030  bd70              POP      {r4-r6,pc}
;;;1027   
                          ENDP


                          AREA ||i.sweepgen||, CODE, READONLY, ALIGN=2

                  sweepgen PROC
;;;1035   */
;;;1036   static GCObject **sweepgen (lua_State *L, global_State *g, GCObject **p,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1037                               GCObject *limit) {
000004  4680              MOV      r8,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
00000a  461f              MOV      r7,r3
;;;1038     static lu_byte nextage[] = {
;;;1039       G_SURVIVAL,  /* from G_NEW */
;;;1040       G_OLD1,      /* from G_SURVIVAL */
;;;1041       G_OLD1,      /* from G_OLD0 */
;;;1042       G_OLD,       /* from G_OLD1 */
;;;1043       G_OLD,       /* from G_OLD (do not change) */
;;;1044       G_TOUCHED1,  /* from G_TOUCHED1 (do not change) */
;;;1045       G_TOUCHED2   /* from G_TOUCHED2 (do not change) */
;;;1046     };
;;;1047     int white = luaC_white(g);
00000c  f8960034          LDRB     r0,[r6,#0x34]
000010  f0000918          AND      r9,r0,#0x18
;;;1048     GCObject *curr;
;;;1049     while ((curr = *p) != limit) {
000014  e01f              B        |L52.86|
                  |L52.22|
;;;1050       if (iswhite(curr)) {  /* is 'curr' dead? */
000016  7960              LDRB     r0,[r4,#5]
000018  f0000018          AND      r0,r0,#0x18
00001c  b130              CBZ      r0,|L52.44|
;;;1051         lua_assert(!isold(curr) && isdead(g, curr));
;;;1052         *p = curr->next;  /* remove 'curr' from list */
00001e  6820              LDR      r0,[r4,#0]
000020  6028              STR      r0,[r5,#0]
;;;1053         freeobj(L, curr);  /* erase 'curr' */
000022  4621              MOV      r1,r4
000024  4640              MOV      r0,r8
000026  f7fffffe          BL       freeobj
00002a  e014              B        |L52.86|
                  |L52.44|
;;;1054       }
;;;1055       else {  /* correct mark and age */
;;;1056         if (getage(curr) == G_NEW)
00002c  7960              LDRB     r0,[r4,#5]
00002e  f0000007          AND      r0,r0,#7
000032  b928              CBNZ     r0,|L52.64|
;;;1057           curr->marked = cast_byte((curr->marked & maskgencolors) | white);
000034  7960              LDRB     r0,[r4,#5]
000036  f0200038          BIC      r0,r0,#0x38
00003a  ea400009          ORR      r0,r0,r9
00003e  7160              STRB     r0,[r4,#5]
                  |L52.64|
;;;1058         setage(curr, nextage[getage(curr)]);
000040  7960              LDRB     r0,[r4,#5]
000042  f0200007          BIC      r0,r0,#7
000046  7961              LDRB     r1,[r4,#5]
000048  f0010107          AND      r1,r1,#7
00004c  4a05              LDR      r2,|L52.100|
00004e  5c51              LDRB     r1,[r2,r1]
000050  4308              ORRS     r0,r0,r1
000052  7160              STRB     r0,[r4,#5]
;;;1059         p = &curr->next;  /* go to next element */
000054  4625              MOV      r5,r4
                  |L52.86|
000056  682c              LDR      r4,[r5,#0]            ;1049
000058  42bc              CMP      r4,r7                 ;1049
00005a  d1dc              BNE      |L52.22|
;;;1060       }
;;;1061     }
;;;1062     return p;
00005c  4628              MOV      r0,r5
;;;1063   }
00005e  e8bd87f0          POP      {r4-r10,pc}
;;;1064   
                          ENDP

000062  0000              DCW      0x0000
                  |L52.100|
                          DCD      nextage

                          AREA ||i.sweeplist||, CODE, READONLY, ALIGN=1

                  sweeplist PROC
;;;787    */
;;;788    static GCObject **sweeplist (lua_State *L, GCObject **p, int countin,
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;789                                 int *countout) {
000004  4680              MOV      r8,r0
000006  460c              MOV      r4,r1
000008  4691              MOV      r9,r2
00000a  461e              MOV      r6,r3
;;;790      global_State *g = G(L);
00000c  f8d8a010          LDR      r10,[r8,#0x10]
;;;791      int ow = otherwhite(g);
000010  f89a0034          LDRB     r0,[r10,#0x34]
000014  f0800018          EOR      r0,r0,#0x18
000018  9001              STR      r0,[sp,#4]
;;;792      int i;
;;;793      int white = luaC_white(g);  /* current white */
00001a  f89a0034          LDRB     r0,[r10,#0x34]
00001e  f0000018          AND      r0,r0,#0x18
000022  9000              STR      r0,[sp,#0]
;;;794      for (i = 0; *p != NULL && i < countin; i++) {
000024  2700              MOVS     r7,#0
000026  e014              B        |L53.82|
                  |L53.40|
;;;795        GCObject *curr = *p;
000028  6825              LDR      r5,[r4,#0]
;;;796        int marked = curr->marked;
00002a  f895b005          LDRB     r11,[r5,#5]
;;;797        if (isdeadm(ow, marked)) {  /* is 'curr' dead? */
00002e  9801              LDR      r0,[sp,#4]
000030  ea0b0000          AND      r0,r11,r0
000034  b130              CBZ      r0,|L53.68|
;;;798          *p = curr->next;  /* remove 'curr' from list */
000036  6828              LDR      r0,[r5,#0]
000038  6020              STR      r0,[r4,#0]
;;;799          freeobj(L, curr);  /* erase 'curr' */
00003a  4629              MOV      r1,r5
00003c  4640              MOV      r0,r8
00003e  f7fffffe          BL       freeobj
000042  e005              B        |L53.80|
                  |L53.68|
;;;800        }
;;;801        else {  /* change mark to 'white' */
;;;802          curr->marked = cast_byte((marked & maskcolors) | white);
000044  f02b003f          BIC      r0,r11,#0x3f
000048  9900              LDR      r1,[sp,#0]
00004a  4308              ORRS     r0,r0,r1
00004c  7168              STRB     r0,[r5,#5]
;;;803          p = &curr->next;  /* go to next element */
00004e  462c              MOV      r4,r5
                  |L53.80|
000050  1c7f              ADDS     r7,r7,#1              ;794
                  |L53.82|
000052  6820              LDR      r0,[r4,#0]            ;794
000054  b108              CBZ      r0,|L53.90|
000056  454f              CMP      r7,r9                 ;794
000058  dbe6              BLT      |L53.40|
                  |L53.90|
;;;804        }
;;;805      }
;;;806      if (countout)
00005a  b106              CBZ      r6,|L53.94|
;;;807        *countout = i;  /* number of elements traversed */
00005c  6037              STR      r7,[r6,#0]
                  |L53.94|
;;;808      return (*p == NULL) ? NULL : p;
00005e  6820              LDR      r0,[r4,#0]
000060  b910              CBNZ     r0,|L53.104|
000062  2000              MOVS     r0,#0
                  |L53.100|
;;;809    }
000064  e8bd9ffc          POP      {r2-r12,pc}
                  |L53.104|
000068  4620              MOV      r0,r4                 ;808
00006a  e7fb              B        |L53.100|
;;;810    
                          ENDP


                          AREA ||i.sweepstep||, CODE, READONLY, ALIGN=1

                  sweepstep PROC
;;;1411   
;;;1412   static int sweepstep (lua_State *L, global_State *g,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1413                         int nextstate, GCObject **nextlist) {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
;;;1414     if (g->sweepgc) {
00000c  6c60              LDR      r0,[r4,#0x44]
00000e  b188              CBZ      r0,|L54.52|
;;;1415       l_mem olddebt = g->GCdebt;
000010  f8d4800c          LDR      r8,[r4,#0xc]
;;;1416       int count;
;;;1417       g->sweepgc = sweeplist(L, g->sweepgc, GCSWEEPMAX, &count);
000014  466b              MOV      r3,sp
000016  2264              MOVS     r2,#0x64
000018  4638              MOV      r0,r7
00001a  6c61              LDR      r1,[r4,#0x44]
00001c  f7fffffe          BL       sweeplist
000020  6460              STR      r0,[r4,#0x44]
;;;1418       g->GCestimate += g->GCdebt - olddebt;  /* update estimate */
000022  e9d41003          LDRD     r1,r0,[r4,#0xc]
000026  eba10108          SUB      r1,r1,r8
00002a  4408              ADD      r0,r0,r1
00002c  6120              STR      r0,[r4,#0x10]
;;;1419       return count;
00002e  9800              LDR      r0,[sp,#0]
                  |L54.48|
;;;1420     }
;;;1421     else {  /* enter next state */
;;;1422       g->gcstate = nextstate;
;;;1423       g->sweepgc = nextlist;
;;;1424       return 0;  /* no work done */
;;;1425     }
;;;1426   }
000030  e8bd83f8          POP      {r3-r9,pc}
                  |L54.52|
000034  f8845035          STRB     r5,[r4,#0x35]         ;1422
000038  6466              STR      r6,[r4,#0x44]         ;1423
00003a  2000              MOVS     r0,#0                 ;1424
00003c  e7f8              B        |L54.48|
;;;1427   
                          ENDP


                          AREA ||i.sweeptolive||, CODE, READONLY, ALIGN=1

                  sweeptolive PROC
;;;814    */
;;;815    static GCObject **sweeptolive (lua_State *L, GCObject **p) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;816      GCObject **old = p;
000006  4626              MOV      r6,r4
;;;817      do {
000008  bf00              NOP      
                  |L55.10|
;;;818        p = sweeplist(L, p, 1, NULL);
00000a  2300              MOVS     r3,#0
00000c  2201              MOVS     r2,#1
00000e  4621              MOV      r1,r4
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       sweeplist
000016  4604              MOV      r4,r0
;;;819      } while (p == old);
000018  42b4              CMP      r4,r6
00001a  d0f6              BEQ      |L55.10|
;;;820      return p;
00001c  4620              MOV      r0,r4
;;;821    }
00001e  bd70              POP      {r4-r6,pc}
;;;822    
                          ENDP


                          AREA ||i.traverseCclosure||, CODE, READONLY, ALIGN=1

                  traverseCclosure PROC
;;;561    
;;;562    static int traverseCclosure (global_State *g, CClosure *cl) {
000000  b570              PUSH     {r4-r6,lr}
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;563      int i;
;;;564      for (i = 0; i < cl->nupvalues; i++)  /* mark its upvalues */
000006  2500              MOVS     r5,#0
000008  e019              B        |L56.62|
                  |L56.10|
;;;565        markvalue(g, &cl->upvalue[i]);
00000a  f1040010          ADD      r0,r4,#0x10
00000e  eb001005          ADD      r0,r0,r5,LSL #4
000012  7a00              LDRB     r0,[r0,#8]
000014  f0000040          AND      r0,r0,#0x40
000018  b180              CBZ      r0,|L56.60|
00001a  f1040010          ADD      r0,r4,#0x10
00001e  eb001005          ADD      r0,r0,r5,LSL #4
000022  6800              LDR      r0,[r0,#0]
000024  7940              LDRB     r0,[r0,#5]
000026  f0000018          AND      r0,r0,#0x18
00002a  b138              CBZ      r0,|L56.60|
00002c  f1040010          ADD      r0,r4,#0x10
000030  eb001005          ADD      r0,r0,r5,LSL #4
000034  6801              LDR      r1,[r0,#0]
000036  4630              MOV      r0,r6
000038  f7fffffe          BL       reallymarkobject
                  |L56.60|
00003c  1c6d              ADDS     r5,r5,#1              ;564
                  |L56.62|
00003e  79a0              LDRB     r0,[r4,#6]            ;564
000040  42a8              CMP      r0,r5                 ;564
000042  dce2              BGT      |L56.10|
;;;566      return 1 + cl->nupvalues;
000044  79a0              LDRB     r0,[r4,#6]
000046  1c40              ADDS     r0,r0,#1
;;;567    }
000048  bd70              POP      {r4-r6,pc}
;;;568    
                          ENDP


                          AREA ||i.traverseLclosure||, CODE, READONLY, ALIGN=1

                  traverseLclosure PROC
;;;572    */
;;;573    static int traverseLclosure (global_State *g, LClosure *cl) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
;;;574      int i;
;;;575      markobjectN(g, cl->p);  /* mark its prototype */
000008  68e0              LDR      r0,[r4,#0xc]
00000a  b140              CBZ      r0,|L57.30|
00000c  68e0              LDR      r0,[r4,#0xc]
00000e  7940              LDRB     r0,[r0,#5]
000010  f0000018          AND      r0,r0,#0x18
000014  b118              CBZ      r0,|L57.30|
000016  4638              MOV      r0,r7
000018  68e1              LDR      r1,[r4,#0xc]
00001a  f7fffffe          BL       reallymarkobject
                  |L57.30|
;;;576      for (i = 0; i < cl->nupvalues; i++) {  /* visit its upvalues */
00001e  2500              MOVS     r5,#0
000020  e00d              B        |L57.62|
                  |L57.34|
;;;577        UpVal *uv = cl->upvals[i];
000022  f1040010          ADD      r0,r4,#0x10
000026  f8506025          LDR      r6,[r0,r5,LSL #2]
;;;578        markobjectN(g, uv);  /* mark upvalue */
00002a  b13e              CBZ      r6,|L57.60|
00002c  7970              LDRB     r0,[r6,#5]
00002e  f0000018          AND      r0,r0,#0x18
000032  b118              CBZ      r0,|L57.60|
000034  4631              MOV      r1,r6
000036  4638              MOV      r0,r7
000038  f7fffffe          BL       reallymarkobject
                  |L57.60|
00003c  1c6d              ADDS     r5,r5,#1              ;576
                  |L57.62|
00003e  79a0              LDRB     r0,[r4,#6]            ;576
000040  42a8              CMP      r0,r5                 ;576
000042  dcee              BGT      |L57.34|
;;;579      }
;;;580      return 1 + cl->nupvalues;
000044  79a0              LDRB     r0,[r4,#6]
000046  1c40              ADDS     r0,r0,#1
;;;581    }
000048  e8bd81f0          POP      {r4-r8,pc}
;;;582    
                          ENDP


                          AREA ||i.traverseephemeron||, CODE, READONLY, ALIGN=1

                  traverseephemeron PROC
;;;429    */
;;;430    static int traverseephemeron (global_State *g, Table *h) {
000000  e92d5ff0          PUSH     {r4-r12,lr}
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
;;;431      int marked = 0;  /* true if an object is marked in this traversal */
000008  f04f0800          MOV      r8,#0
;;;432      int hasclears = 0;  /* true if table has white keys */
00000c  46c1              MOV      r9,r8
;;;433      int hasww = 0;  /* true if table has entry "white-key -> white-value" */
00000e  46c2              MOV      r10,r8
;;;434      Node *n, *limit = gnodelast(h);
000010  79e2              LDRB     r2,[r4,#7]
000012  2001              MOVS     r0,#1
000014  4090              LSLS     r0,r0,r2
000016  eb000040          ADD      r0,r0,r0,LSL #1
00001a  6921              LDR      r1,[r4,#0x10]
00001c  eb010bc0          ADD      r11,r1,r0,LSL #3
;;;435      unsigned int i;
;;;436      /* traverse array part */
;;;437      for (i = 0; i < h->sizearray; i++) {
000020  2700              MOVS     r7,#0
000022  e018              B        |L58.86|
                  |L58.36|
;;;438        if (valiswhite(&h->array[i])) {
000024  68e0              LDR      r0,[r4,#0xc]
000026  eb001007          ADD      r0,r0,r7,LSL #4
00002a  7a00              LDRB     r0,[r0,#8]
00002c  f0000040          AND      r0,r0,#0x40
000030  b180              CBZ      r0,|L58.84|
000032  68e0              LDR      r0,[r4,#0xc]
000034  eb001007          ADD      r0,r0,r7,LSL #4
000038  6800              LDR      r0,[r0,#0]
00003a  7940              LDRB     r0,[r0,#5]
00003c  f0000018          AND      r0,r0,#0x18
000040  b140              CBZ      r0,|L58.84|
;;;439          marked = 1;
000042  f04f0801          MOV      r8,#1
;;;440          reallymarkobject(g, gcvalue(&h->array[i]));
000046  68e0              LDR      r0,[r4,#0xc]
000048  eb001007          ADD      r0,r0,r7,LSL #4
00004c  6801              LDR      r1,[r0,#0]
00004e  4630              MOV      r0,r6
000050  f7fffffe          BL       reallymarkobject
                  |L58.84|
000054  1c7f              ADDS     r7,r7,#1              ;437
                  |L58.86|
000056  68a0              LDR      r0,[r4,#8]            ;437
000058  42b8              CMP      r0,r7                 ;437
00005a  d8e3              BHI      |L58.36|
;;;441        }
;;;442      }
;;;443      /* traverse hash part */
;;;444      for (n = gnode(h, 0); n < limit; n++) {
00005c  6925              LDR      r5,[r4,#0x10]
00005e  e030              B        |L58.194|
                  |L58.96|
;;;445        if (isempty(gval(n)))  /* entry is empty? */
000060  7a28              LDRB     r0,[r5,#8]
000062  f000000f          AND      r0,r0,#0xf
000066  b918              CBNZ     r0,|L58.112|
;;;446          clearkey(n);  /* clear its key */
000068  4628              MOV      r0,r5
00006a  f7fffffe          BL       clearkey
00006e  e027              B        |L58.192|
                  |L58.112|
;;;447        else if (iscleared(g, gckeyN(n))) {  /* key is not marked (yet)? */
000070  7a68              LDRB     r0,[r5,#9]
000072  f0000040          AND      r0,r0,#0x40
000076  b108              CBZ      r0,|L58.124|
000078  6928              LDR      r0,[r5,#0x10]
00007a  e000              B        |L58.126|
                  |L58.124|
00007c  2000              MOVS     r0,#0
                  |L58.126|
00007e  4601              MOV      r1,r0
000080  4630              MOV      r0,r6
000082  f7fffffe          BL       iscleared
000086  b160              CBZ      r0,|L58.162|
;;;448          hasclears = 1;  /* table must be cleared */
000088  f04f0901          MOV      r9,#1
;;;449          if (valiswhite(gval(n)))  /* value not marked yet? */
00008c  7a28              LDRB     r0,[r5,#8]
00008e  f0000040          AND      r0,r0,#0x40
000092  b1a8              CBZ      r0,|L58.192|
000094  6828              LDR      r0,[r5,#0]
000096  7940              LDRB     r0,[r0,#5]
000098  f0000018          AND      r0,r0,#0x18
00009c  b180              CBZ      r0,|L58.192|
;;;450            hasww = 1;  /* white-white entry */
00009e  46ca              MOV      r10,r9
0000a0  e00e              B        |L58.192|
                  |L58.162|
;;;451        }
;;;452        else if (valiswhite(gval(n))) {  /* value not marked yet? */
0000a2  7a28              LDRB     r0,[r5,#8]
0000a4  f0000040          AND      r0,r0,#0x40
0000a8  b150              CBZ      r0,|L58.192|
0000aa  6828              LDR      r0,[r5,#0]
0000ac  7940              LDRB     r0,[r0,#5]
0000ae  f0000018          AND      r0,r0,#0x18
0000b2  b128              CBZ      r0,|L58.192|
;;;453          marked = 1;
0000b4  f04f0801          MOV      r8,#1
;;;454          reallymarkobject(g, gcvalue(gval(n)));  /* mark it now */
0000b8  4630              MOV      r0,r6
0000ba  6829              LDR      r1,[r5,#0]
0000bc  f7fffffe          BL       reallymarkobject
                  |L58.192|
0000c0  3518              ADDS     r5,r5,#0x18           ;444
                  |L58.194|
0000c2  455d              CMP      r5,r11                ;444
0000c4  d3cc              BCC      |L58.96|
;;;455        }
;;;456      }
;;;457      /* link table into proper list */
;;;458      if (g->gcstate == GCSpropagate)
0000c6  f8960035          LDRB     r0,[r6,#0x35]
0000ca  b918              CBNZ     r0,|L58.212|
;;;459        linkgclist(h, g->grayagain);  /* must retraverse it in atomic phase */
0000cc  6d30              LDR      r0,[r6,#0x50]
0000ce  61e0              STR      r0,[r4,#0x1c]
0000d0  6534              STR      r4,[r6,#0x50]
0000d2  e019              B        |L58.264|
                  |L58.212|
;;;460      else if (hasww)  /* table has white->white entries? */
0000d4  f1ba0f00          CMP      r10,#0
0000d8  d003              BEQ      |L58.226|
;;;461        linkgclist(h, g->ephemeron);  /* have to propagate again */
0000da  6db0              LDR      r0,[r6,#0x58]
0000dc  61e0              STR      r0,[r4,#0x1c]
0000de  65b4              STR      r4,[r6,#0x58]
0000e0  e012              B        |L58.264|
                  |L58.226|
;;;462      else if (hasclears)  /* table has white keys? */
0000e2  f1b90f00          CMP      r9,#0
0000e6  d003              BEQ      |L58.240|
;;;463        linkgclist(h, g->allweak);  /* may have to clean white keys */
0000e8  6df0              LDR      r0,[r6,#0x5c]
0000ea  61e0              STR      r0,[r4,#0x1c]
0000ec  65f4              STR      r4,[r6,#0x5c]
0000ee  e00b              B        |L58.264|
                  |L58.240|
;;;464      else if (g->gckind == KGC_GEN)
0000f0  f8960036          LDRB     r0,[r6,#0x36]
0000f4  2801              CMP      r0,#1
0000f6  d103              BNE      |L58.256|
;;;465        linkgclist(h, g->grayagain);  /* keep it in some list */
0000f8  6d30              LDR      r0,[r6,#0x50]
0000fa  61e0              STR      r0,[r4,#0x1c]
0000fc  6534              STR      r4,[r6,#0x50]
0000fe  e003              B        |L58.264|
                  |L58.256|
;;;466      else
;;;467        gray2black(h);
000100  7960              LDRB     r0,[r4,#5]
000102  f0400020          ORR      r0,r0,#0x20
000106  7160              STRB     r0,[r4,#5]
                  |L58.264|
;;;468      return marked;
000108  4640              MOV      r0,r8
;;;469    }
00010a  e8bd9ff0          POP      {r4-r12,pc}
;;;470    
                          ENDP


                          AREA ||i.traverseproto||, CODE, READONLY, ALIGN=1

                  traverseproto PROC
;;;545    */
;;;546    static int traverseproto (global_State *g, Proto *f) {
000000  b570              PUSH     {r4-r6,lr}
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;547      int i;
;;;548      checkprotocache(g, f);
000006  4621              MOV      r1,r4
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       checkprotocache
;;;549      markobjectN(g, f->source);
00000e  6d20              LDR      r0,[r4,#0x50]
000010  b140              CBZ      r0,|L59.36|
000012  6d20              LDR      r0,[r4,#0x50]
000014  7940              LDRB     r0,[r0,#5]
000016  f0000018          AND      r0,r0,#0x18
00001a  b118              CBZ      r0,|L59.36|
00001c  4630              MOV      r0,r6
00001e  6d21              LDR      r1,[r4,#0x50]
000020  f7fffffe          BL       reallymarkobject
                  |L59.36|
;;;550      for (i = 0; i < f->sizek; i++)  /* mark literals */
000024  2500              MOVS     r5,#0
000026  e016              B        |L59.86|
                  |L59.40|
;;;551        markvalue(g, &f->k[i]);
000028  6b20              LDR      r0,[r4,#0x30]
00002a  eb001005          ADD      r0,r0,r5,LSL #4
00002e  7a00              LDRB     r0,[r0,#8]
000030  f0000040          AND      r0,r0,#0x40
000034  b170              CBZ      r0,|L59.84|
000036  6b20              LDR      r0,[r4,#0x30]
000038  eb001005          ADD      r0,r0,r5,LSL #4
00003c  6800              LDR      r0,[r0,#0]
00003e  7940              LDRB     r0,[r0,#5]
000040  f0000018          AND      r0,r0,#0x18
000044  b130              CBZ      r0,|L59.84|
000046  6b20              LDR      r0,[r4,#0x30]
000048  eb001005          ADD      r0,r0,r5,LSL #4
00004c  6801              LDR      r1,[r0,#0]
00004e  4630              MOV      r0,r6
000050  f7fffffe          BL       reallymarkobject
                  |L59.84|
000054  1c6d              ADDS     r5,r5,#1              ;550
                  |L59.86|
000056  6920              LDR      r0,[r4,#0x10]         ;550
000058  42a8              CMP      r0,r5                 ;550
00005a  dce5              BGT      |L59.40|
;;;552      for (i = 0; i < f->sizeupvalues; i++)  /* mark upvalue names */
00005c  2500              MOVS     r5,#0
00005e  e011              B        |L59.132|
                  |L59.96|
;;;553        markobjectN(g, f->upvalues[i].name);
000060  6c20              LDR      r0,[r4,#0x40]
000062  f8500035          LDR      r0,[r0,r5,LSL #3]
000066  b160              CBZ      r0,|L59.130|
000068  6c20              LDR      r0,[r4,#0x40]
00006a  f8500035          LDR      r0,[r0,r5,LSL #3]
00006e  7940              LDRB     r0,[r0,#5]
000070  f0000018          AND      r0,r0,#0x18
000074  b128              CBZ      r0,|L59.130|
000076  6c20              LDR      r0,[r4,#0x40]
000078  f8501035          LDR      r1,[r0,r5,LSL #3]
00007c  4630              MOV      r0,r6
00007e  f7fffffe          BL       reallymarkobject
                  |L59.130|
000082  1c6d              ADDS     r5,r5,#1              ;552
                  |L59.132|
000084  68e0              LDR      r0,[r4,#0xc]          ;552
000086  42a8              CMP      r0,r5                 ;552
000088  dcea              BGT      |L59.96|
;;;554      for (i = 0; i < f->sizep; i++)  /* mark nested protos */
00008a  2500              MOVS     r5,#0
00008c  e011              B        |L59.178|
                  |L59.142|
;;;555        markobjectN(g, f->p[i]);
00008e  6be0              LDR      r0,[r4,#0x3c]
000090  f8500025          LDR      r0,[r0,r5,LSL #2]
000094  b160              CBZ      r0,|L59.176|
000096  6be0              LDR      r0,[r4,#0x3c]
000098  f8500025          LDR      r0,[r0,r5,LSL #2]
00009c  7940              LDRB     r0,[r0,#5]
00009e  f0000018          AND      r0,r0,#0x18
0000a2  b128              CBZ      r0,|L59.176|
0000a4  6be0              LDR      r0,[r4,#0x3c]
0000a6  f8501025          LDR      r1,[r0,r5,LSL #2]
0000aa  4630              MOV      r0,r6
0000ac  f7fffffe          BL       reallymarkobject
                  |L59.176|
0000b0  1c6d              ADDS     r5,r5,#1              ;554
                  |L59.178|
0000b2  69e0              LDR      r0,[r4,#0x1c]         ;554
0000b4  42a8              CMP      r0,r5                 ;554
0000b6  dcea              BGT      |L59.142|
;;;556      for (i = 0; i < f->sizelocvars; i++)  /* mark local-variable names */
0000b8  2500              MOVS     r5,#0
0000ba  e017              B        |L59.236|
                  |L59.188|
;;;557        markobjectN(g, f->locvars[i].varname);
0000bc  eb050145          ADD      r1,r5,r5,LSL #1
0000c0  6ce0              LDR      r0,[r4,#0x4c]
0000c2  f8500021          LDR      r0,[r0,r1,LSL #2]
0000c6  b180              CBZ      r0,|L59.234|
0000c8  eb050145          ADD      r1,r5,r5,LSL #1
0000cc  6ce0              LDR      r0,[r4,#0x4c]
0000ce  f8500021          LDR      r0,[r0,r1,LSL #2]
0000d2  7940              LDRB     r0,[r0,#5]
0000d4  f0000018          AND      r0,r0,#0x18
0000d8  b138              CBZ      r0,|L59.234|
0000da  eb050245          ADD      r2,r5,r5,LSL #1
0000de  6ce0              LDR      r0,[r4,#0x4c]
0000e0  f8501022          LDR      r1,[r0,r2,LSL #2]
0000e4  4630              MOV      r0,r6
0000e6  f7fffffe          BL       reallymarkobject
                  |L59.234|
0000ea  1c6d              ADDS     r5,r5,#1              ;556
                  |L59.236|
0000ec  6a20              LDR      r0,[r4,#0x20]         ;556
0000ee  42a8              CMP      r0,r5                 ;556
0000f0  dce4              BGT      |L59.188|
;;;558      return 1 + f->sizek + f->sizeupvalues + f->sizep + f->sizelocvars;
0000f2  6920              LDR      r0,[r4,#0x10]
0000f4  1c40              ADDS     r0,r0,#1
0000f6  68e1              LDR      r1,[r4,#0xc]
0000f8  4408              ADD      r0,r0,r1
0000fa  69e1              LDR      r1,[r4,#0x1c]
0000fc  4408              ADD      r0,r0,r1
0000fe  6a21              LDR      r1,[r4,#0x20]
000100  4408              ADD      r0,r0,r1
;;;559    }
000102  bd70              POP      {r4-r6,pc}
;;;560    
                          ENDP


                          AREA ||i.traversestrongtable||, CODE, READONLY, ALIGN=1

                  traversestrongtable PROC
;;;471    
;;;472    static void traversestrongtable (global_State *g, Table *h) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
;;;473      Node *n, *limit = gnodelast(h);
000008  79e2              LDRB     r2,[r4,#7]
00000a  2001              MOVS     r0,#1
00000c  4090              LSLS     r0,r0,r2
00000e  eb000040          ADD      r0,r0,r0,LSL #1
000012  6921              LDR      r1,[r4,#0x10]
000014  eb0108c0          ADD      r8,r1,r0,LSL #3
;;;474      unsigned int i;
;;;475      for (i = 0; i < h->sizearray; i++)  /* traverse array part */
000018  2600              MOVS     r6,#0
00001a  e016              B        |L60.74|
                  |L60.28|
;;;476        markvalue(g, &h->array[i]);
00001c  68e0              LDR      r0,[r4,#0xc]
00001e  eb001006          ADD      r0,r0,r6,LSL #4
000022  7a00              LDRB     r0,[r0,#8]
000024  f0000040          AND      r0,r0,#0x40
000028  b170              CBZ      r0,|L60.72|
00002a  68e0              LDR      r0,[r4,#0xc]
00002c  eb001006          ADD      r0,r0,r6,LSL #4
000030  6800              LDR      r0,[r0,#0]
000032  7940              LDRB     r0,[r0,#5]
000034  f0000018          AND      r0,r0,#0x18
000038  b130              CBZ      r0,|L60.72|
00003a  68e0              LDR      r0,[r4,#0xc]
00003c  eb001006          ADD      r0,r0,r6,LSL #4
000040  6801              LDR      r1,[r0,#0]
000042  4638              MOV      r0,r7
000044  f7fffffe          BL       reallymarkobject
                  |L60.72|
000048  1c76              ADDS     r6,r6,#1              ;475
                  |L60.74|
00004a  68a0              LDR      r0,[r4,#8]            ;475
00004c  42b0              CMP      r0,r6                 ;475
00004e  d8e5              BHI      |L60.28|
;;;477      for (n = gnode(h, 0); n < limit; n++) {  /* traverse hash part */
000050  6925              LDR      r5,[r4,#0x10]
000052  e022              B        |L60.154|
                  |L60.84|
;;;478        if (isempty(gval(n)))  /* entry is empty? */
000054  7a28              LDRB     r0,[r5,#8]
000056  f000000f          AND      r0,r0,#0xf
00005a  b918              CBNZ     r0,|L60.100|
;;;479          clearkey(n);  /* clear its key */
00005c  4628              MOV      r0,r5
00005e  f7fffffe          BL       clearkey
000062  e019              B        |L60.152|
                  |L60.100|
;;;480        else {
;;;481          lua_assert(!keyisnil(n));
;;;482          markkey(g, n);
000064  7a68              LDRB     r0,[r5,#9]
000066  f0000040          AND      r0,r0,#0x40
00006a  b140              CBZ      r0,|L60.126|
00006c  6928              LDR      r0,[r5,#0x10]
00006e  7940              LDRB     r0,[r0,#5]
000070  f0000018          AND      r0,r0,#0x18
000074  b118              CBZ      r0,|L60.126|
000076  4638              MOV      r0,r7
000078  6929              LDR      r1,[r5,#0x10]
00007a  f7fffffe          BL       reallymarkobject
                  |L60.126|
;;;483          markvalue(g, gval(n));
00007e  7a28              LDRB     r0,[r5,#8]
000080  f0000040          AND      r0,r0,#0x40
000084  b140              CBZ      r0,|L60.152|
000086  6828              LDR      r0,[r5,#0]
000088  7940              LDRB     r0,[r0,#5]
00008a  f0000018          AND      r0,r0,#0x18
00008e  b118              CBZ      r0,|L60.152|
000090  4638              MOV      r0,r7
000092  6829              LDR      r1,[r5,#0]
000094  f7fffffe          BL       reallymarkobject
                  |L60.152|
000098  3518              ADDS     r5,r5,#0x18           ;477
                  |L60.154|
00009a  4545              CMP      r5,r8                 ;477
00009c  d3da              BCC      |L60.84|
;;;484        }
;;;485      }
;;;486      if (g->gckind == KGC_GEN) {
00009e  f8970036          LDRB     r0,[r7,#0x36]
0000a2  2801              CMP      r0,#1
0000a4  d106              BNE      |L60.180|
;;;487        linkgclist(h, g->grayagain);  /* keep it in some gray list */
0000a6  6d38              LDR      r0,[r7,#0x50]
0000a8  61e0              STR      r0,[r4,#0x1c]
0000aa  653c              STR      r4,[r7,#0x50]
;;;488        black2gray(h);
0000ac  7960              LDRB     r0,[r4,#5]
0000ae  f00000df          AND      r0,r0,#0xdf
0000b2  7160              STRB     r0,[r4,#5]
                  |L60.180|
;;;489      }
;;;490    }
0000b4  e8bd81f0          POP      {r4-r8,pc}
;;;491    
                          ENDP


                          AREA ||i.traversetable||, CODE, READONLY, ALIGN=1

                  traversetable PROC
;;;492    
;;;493    static lu_mem traversetable (global_State *g, Table *h) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;494      const char *weakkey, *weakvalue;
;;;495      const TValue *mode = gfasttm(g, h->metatable, TM_MODE);
000008  69a0              LDR      r0,[r4,#0x18]
00000a  b908              CBNZ     r0,|L61.16|
00000c  2000              MOVS     r0,#0
00000e  e00c              B        |L61.42|
                  |L61.16|
000010  69a0              LDR      r0,[r4,#0x18]
000012  7980              LDRB     r0,[r0,#6]
000014  f0000020          AND      r0,r0,#0x20
000018  b108              CBZ      r0,|L61.30|
00001a  2000              MOVS     r0,#0
00001c  e005              B        |L61.42|
                  |L61.30|
00001e  21ac              MOVS     r1,#0xac
000020  594a              LDR      r2,[r1,r5]
000022  2105              MOVS     r1,#5
000024  69a0              LDR      r0,[r4,#0x18]
000026  f7fffffe          BL       luaT_gettm
                  |L61.42|
00002a  4607              MOV      r7,r0
;;;496      markobjectN(g, h->metatable);
00002c  69a0              LDR      r0,[r4,#0x18]
00002e  b140              CBZ      r0,|L61.66|
000030  69a0              LDR      r0,[r4,#0x18]
000032  7940              LDRB     r0,[r0,#5]
000034  f0000018          AND      r0,r0,#0x18
000038  b118              CBZ      r0,|L61.66|
00003a  4628              MOV      r0,r5
00003c  69a1              LDR      r1,[r4,#0x18]
00003e  f7fffffe          BL       reallymarkobject
                  |L61.66|
;;;497      if (mode && ttisstring(mode) &&  /* is there a weak mode? */
000042  b387              CBZ      r7,|L61.166|
000044  7a38              LDRB     r0,[r7,#8]
000046  f000000f          AND      r0,r0,#0xf
00004a  2804              CMP      r0,#4
00004c  d12c              BNE      |L61.168|
;;;498          ((weakkey = strchr(svalue(mode), 'k')),
00004e  6839              LDR      r1,[r7,#0]
000050  f1010010          ADD      r0,r1,#0x10
000054  216b              MOVS     r1,#0x6b
000056  f7fffffe          BL       strchr
00005a  4680              MOV      r8,r0
;;;499           (weakvalue = strchr(svalue(mode), 'v')),
00005c  6839              LDR      r1,[r7,#0]
00005e  f1010010          ADD      r0,r1,#0x10
000062  2176              MOVS     r1,#0x76
000064  f7fffffe          BL       strchr
000068  4606              MOV      r6,r0
;;;500           (weakkey || weakvalue))) {  /* is really weak? */
00006a  f1b80f00          CMP      r8,#0
00006e  d100              BNE      |L61.114|
000070  b10e              CBZ      r6,|L61.118|
                  |L61.114|
000072  2001              MOVS     r0,#1
000074  e000              B        |L61.120|
                  |L61.118|
000076  2000              MOVS     r0,#0
                  |L61.120|
000078  b1a8              CBZ      r0,|L61.166|
;;;501        black2gray(h);  /* keep table gray */
00007a  7960              LDRB     r0,[r4,#5]
00007c  f00000df          AND      r0,r0,#0xdf
000080  7160              STRB     r0,[r4,#5]
;;;502        if (!weakkey)  /* strong keys? */
000082  f1b80f00          CMP      r8,#0
000086  d104              BNE      |L61.146|
;;;503          traverseweakvalue(g, h);
000088  4621              MOV      r1,r4
00008a  4628              MOV      r0,r5
00008c  f7fffffe          BL       traverseweakvalue
000090  e00e              B        |L61.176|
                  |L61.146|
;;;504        else if (!weakvalue)  /* strong values? */
000092  b926              CBNZ     r6,|L61.158|
;;;505          traverseephemeron(g, h);
000094  4621              MOV      r1,r4
000096  4628              MOV      r0,r5
000098  f7fffffe          BL       traverseephemeron
00009c  e008              B        |L61.176|
                  |L61.158|
;;;506        else  /* all weak */
;;;507          linkgclist(h, g->allweak);  /* nothing to traverse now */
00009e  6de8              LDR      r0,[r5,#0x5c]
0000a0  61e0              STR      r0,[r4,#0x1c]
0000a2  65ec              STR      r4,[r5,#0x5c]
0000a4  e004              B        |L61.176|
                  |L61.166|
0000a6  e7ff              B        |L61.168|
                  |L61.168|
;;;508      }
;;;509      else  /* not weak */
;;;510        traversestrongtable(g, h);
0000a8  4621              MOV      r1,r4
0000aa  4628              MOV      r0,r5
0000ac  f7fffffe          BL       traversestrongtable
                  |L61.176|
;;;511      return 1 + h->sizearray + 2 * allocsizenode(h);
0000b0  68a1              LDR      r1,[r4,#8]
0000b2  1c49              ADDS     r1,r1,#1
0000b4  6960              LDR      r0,[r4,#0x14]
0000b6  b908              CBNZ     r0,|L61.188|
0000b8  2000              MOVS     r0,#0
0000ba  e002              B        |L61.194|
                  |L61.188|
0000bc  79e2              LDRB     r2,[r4,#7]
0000be  2001              MOVS     r0,#1
0000c0  4090              LSLS     r0,r0,r2
                  |L61.194|
0000c2  2202              MOVS     r2,#2
0000c4  fb021000          MLA      r0,r2,r0,r1
;;;512    }
0000c8  e8bd81f0          POP      {r4-r8,pc}
;;;513    
                          ENDP


                          AREA ||i.traversethread||, CODE, READONLY, ALIGN=1

                  traversethread PROC
;;;588    */
;;;589    static int traversethread (global_State *g, lua_State *th) {
000000  b570              PUSH     {r4-r6,lr}
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;590      StkId o = th->stack;
000006  6a25              LDR      r5,[r4,#0x20]
;;;591      if (o == NULL)
000008  b90d              CBNZ     r5,|L62.14|
;;;592        return 1;  /* stack not completely built yet */
00000a  2001              MOVS     r0,#1
                  |L62.12|
;;;593      lua_assert(g->gcstate == GCSatomic ||
;;;594                 th->openupval == NULL || isintwups(th));
;;;595      for (; o < th->top; o++)  /* mark live elements in the stack */
;;;596        markvalue(g, s2v(o));
;;;597      if (g->gcstate == GCSatomic) {  /* final traversal? */
;;;598        StkId lim = th->stack + th->stacksize;  /* real end of stack */
;;;599        for (; o < lim; o++)  /* clear not-marked stack slice */
;;;600          setnilvalue(s2v(o));
;;;601        /* 'remarkupvals' may have removed thread from 'twups' list */
;;;602        if (!isintwups(th) && th->openupval != NULL) {
;;;603          th->twups = g->twups;  /* link it back to the list */
;;;604          g->twups = th;
;;;605        }
;;;606      }
;;;607      else if (!g->gcemergency)
;;;608        luaD_shrinkstack(th); /* do not change stack in emergency cycle */
;;;609      return 1 + th->stacksize;
;;;610    }
00000c  bd70              POP      {r4-r6,pc}
                  |L62.14|
00000e  e00d              B        |L62.44|
                  |L62.16|
000010  7a28              LDRB     r0,[r5,#8]            ;596
000012  f0000040          AND      r0,r0,#0x40           ;596
000016  b140              CBZ      r0,|L62.42|
000018  6828              LDR      r0,[r5,#0]            ;596
00001a  7940              LDRB     r0,[r0,#5]            ;596
00001c  f0000018          AND      r0,r0,#0x18           ;596
000020  b118              CBZ      r0,|L62.42|
000022  4630              MOV      r0,r6                 ;596
000024  6829              LDR      r1,[r5,#0]            ;596
000026  f7fffffe          BL       reallymarkobject
                  |L62.42|
00002a  3510              ADDS     r5,r5,#0x10           ;595
                  |L62.44|
00002c  68e0              LDR      r0,[r4,#0xc]          ;595
00002e  42a8              CMP      r0,r5                 ;595
000030  d8ee              BHI      |L62.16|
000032  f8960035          LDRB     r0,[r6,#0x35]         ;597
000036  2802              CMP      r0,#2                 ;597
000038  d114              BNE      |L62.100|
00003a  6e22              LDR      r2,[r4,#0x60]         ;598
00003c  6a21              LDR      r1,[r4,#0x20]         ;598
00003e  eb011002          ADD      r0,r1,r2,LSL #4       ;598
000042  e002              B        |L62.74|
                  |L62.68|
000044  2100              MOVS     r1,#0                 ;600
000046  7229              STRB     r1,[r5,#8]            ;600
000048  3510              ADDS     r5,r5,#0x10           ;599
                  |L62.74|
00004a  4285              CMP      r5,r0                 ;599
00004c  d3fa              BCC      |L62.68|
00004e  6ae1              LDR      r1,[r4,#0x2c]         ;602
000050  42a1              CMP      r1,r4                 ;602
000052  d106              BNE      |L62.98|
000054  6a61              LDR      r1,[r4,#0x24]         ;602
000056  b121              CBZ      r1,|L62.98|
000058  f8d61084          LDR      r1,[r6,#0x84]         ;603
00005c  62e1              STR      r1,[r4,#0x2c]         ;603
00005e  f8c64084          STR      r4,[r6,#0x84]         ;604
                  |L62.98|
000062  e005              B        |L62.112|
                  |L62.100|
000064  f896003a          LDRB     r0,[r6,#0x3a]         ;607
000068  b910              CBNZ     r0,|L62.112|
00006a  4620              MOV      r0,r4                 ;608
00006c  f7fffffe          BL       luaD_shrinkstack
                  |L62.112|
000070  6e20              LDR      r0,[r4,#0x60]         ;609
000072  1c40              ADDS     r0,r0,#1              ;609
000074  e7ca              B        |L62.12|
;;;611    
                          ENDP


                          AREA ||i.traverseudata||, CODE, READONLY, ALIGN=1

                  traverseudata PROC
;;;612    
;;;613    static int traverseudata (global_State *g, Udata *u) {
000000  b570              PUSH     {r4-r6,lr}
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;614      int i;
;;;615      markobjectN(g, u->metatable);  /* mark its metatable */
000006  68e0              LDR      r0,[r4,#0xc]
000008  b140              CBZ      r0,|L63.28|
00000a  68e0              LDR      r0,[r4,#0xc]
00000c  7940              LDRB     r0,[r0,#5]
00000e  f0000018          AND      r0,r0,#0x18
000012  b118              CBZ      r0,|L63.28|
000014  4630              MOV      r0,r6
000016  68e1              LDR      r1,[r4,#0xc]
000018  f7fffffe          BL       reallymarkobject
                  |L63.28|
;;;616      for (i = 0; i < u->nuvalue; i++)
00001c  2500              MOVS     r5,#0
00001e  e019              B        |L63.84|
                  |L63.32|
;;;617        markvalue(g, &u->uv[i].uv);
000020  f1040018          ADD      r0,r4,#0x18
000024  eb001005          ADD      r0,r0,r5,LSL #4
000028  7a00              LDRB     r0,[r0,#8]
00002a  f0000040          AND      r0,r0,#0x40
00002e  b180              CBZ      r0,|L63.82|
000030  f1040018          ADD      r0,r4,#0x18
000034  eb001005          ADD      r0,r0,r5,LSL #4
000038  6800              LDR      r0,[r0,#0]
00003a  7940              LDRB     r0,[r0,#5]
00003c  f0000018          AND      r0,r0,#0x18
000040  b138              CBZ      r0,|L63.82|
000042  f1040018          ADD      r0,r4,#0x18
000046  eb001005          ADD      r0,r0,r5,LSL #4
00004a  6801              LDR      r1,[r0,#0]
00004c  4630              MOV      r0,r6
00004e  f7fffffe          BL       reallymarkobject
                  |L63.82|
000052  1c6d              ADDS     r5,r5,#1              ;616
                  |L63.84|
000054  88e0              LDRH     r0,[r4,#6]            ;616
000056  42a8              CMP      r0,r5                 ;616
000058  dce2              BGT      |L63.32|
;;;618      return 1 + u->nuvalue;
00005a  88e0              LDRH     r0,[r4,#6]
00005c  1c40              ADDS     r0,r0,#1
;;;619    }
00005e  bd70              POP      {r4-r6,pc}
;;;620    
                          ENDP


                          AREA ||i.traverseweakvalue||, CODE, READONLY, ALIGN=1

                  traverseweakvalue PROC
;;;396    */
;;;397    static void traverseweakvalue (global_State *g, Table *h) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
;;;398      Node *n, *limit = gnodelast(h);
000008  79ea              LDRB     r2,[r5,#7]
00000a  2001              MOVS     r0,#1
00000c  4090              LSLS     r0,r0,r2
00000e  eb000040          ADD      r0,r0,r0,LSL #1
000012  6929              LDR      r1,[r5,#0x10]
000014  eb0108c0          ADD      r8,r1,r0,LSL #3
;;;399      /* if there is array part, assume it may have white values (it is not
;;;400         worth traversing it now just to check) */
;;;401      int hasclears = (h->sizearray > 0);
000018  68a8              LDR      r0,[r5,#8]
00001a  b108              CBZ      r0,|L64.32|
00001c  2001              MOVS     r0,#1
00001e  e000              B        |L64.34|
                  |L64.32|
000020  2000              MOVS     r0,#0
                  |L64.34|
000022  4607              MOV      r7,r0
;;;402      for (n = gnode(h, 0); n < limit; n++) {  /* traverse hash part */
000024  692c              LDR      r4,[r5,#0x10]
000026  e023              B        |L64.112|
                  |L64.40|
;;;403        if (isempty(gval(n)))  /* entry is empty? */
000028  7a20              LDRB     r0,[r4,#8]
00002a  f000000f          AND      r0,r0,#0xf
00002e  b918              CBNZ     r0,|L64.56|
;;;404          clearkey(n);  /* clear its key */
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       clearkey
000036  e01a              B        |L64.110|
                  |L64.56|
;;;405        else {
;;;406          lua_assert(!keyisnil(n));
;;;407          markkey(g, n);
000038  7a60              LDRB     r0,[r4,#9]
00003a  f0000040          AND      r0,r0,#0x40
00003e  b140              CBZ      r0,|L64.82|
000040  6920              LDR      r0,[r4,#0x10]
000042  7940              LDRB     r0,[r0,#5]
000044  f0000018          AND      r0,r0,#0x18
000048  b118              CBZ      r0,|L64.82|
00004a  4630              MOV      r0,r6
00004c  6921              LDR      r1,[r4,#0x10]
00004e  f7fffffe          BL       reallymarkobject
                  |L64.82|
;;;408          if (!hasclears && iscleared(g, gcvalueN(gval(n))))  /* a white value? */
000052  b967              CBNZ     r7,|L64.110|
000054  7a20              LDRB     r0,[r4,#8]
000056  f0000040          AND      r0,r0,#0x40
00005a  b108              CBZ      r0,|L64.96|
00005c  6820              LDR      r0,[r4,#0]
00005e  e000              B        |L64.98|
                  |L64.96|
000060  2000              MOVS     r0,#0
                  |L64.98|
000062  4601              MOV      r1,r0
000064  4630              MOV      r0,r6
000066  f7fffffe          BL       iscleared
00006a  b100              CBZ      r0,|L64.110|
;;;409            hasclears = 1;  /* table will have to be cleared */
00006c  2701              MOVS     r7,#1
                  |L64.110|
00006e  3418              ADDS     r4,r4,#0x18           ;402
                  |L64.112|
000070  4544              CMP      r4,r8                 ;402
000072  d3d9              BCC      |L64.40|
;;;410        }
;;;411      }
;;;412      if (g->gcstate == GCSatomic && hasclears)
000074  f8960035          LDRB     r0,[r6,#0x35]
000078  2802              CMP      r0,#2
00007a  d104              BNE      |L64.134|
00007c  b11f              CBZ      r7,|L64.134|
;;;413        linkgclist(h, g->weak);  /* has to be cleared later */
00007e  6d70              LDR      r0,[r6,#0x54]
000080  61e8              STR      r0,[r5,#0x1c]
000082  6575              STR      r5,[r6,#0x54]
000084  e002              B        |L64.140|
                  |L64.134|
;;;414      else
;;;415        linkgclist(h, g->grayagain);  /* must retraverse it in atomic phase */
000086  6d30              LDR      r0,[r6,#0x50]
000088  61e8              STR      r0,[r5,#0x1c]
00008a  6535              STR      r5,[r6,#0x50]
                  |L64.140|
;;;416    }
00008c  e8bd81f0          POP      {r4-r8,pc}
;;;417    
                          ENDP


                          AREA ||i.udata2finalize||, CODE, READONLY, ALIGN=1

                  udata2finalize PROC
;;;848    */
;;;849    static GCObject *udata2finalize (global_State *g) {
000000  4601              MOV      r1,r0
;;;850      GCObject *o = g->tobefnz;  /* get first element */
000002  6e48              LDR      r0,[r1,#0x64]
;;;851      lua_assert(tofinalize(o));
;;;852      g->tobefnz = o->next;  /* remove it from 'tobefnz' list */
000004  6802              LDR      r2,[r0,#0]
000006  664a              STR      r2,[r1,#0x64]
;;;853      o->next = g->allgc;  /* return it to 'allgc' list */
000008  6c0a              LDR      r2,[r1,#0x40]
00000a  6002              STR      r2,[r0,#0]
;;;854      g->allgc = o;
00000c  6408              STR      r0,[r1,#0x40]
;;;855      resetbit(o->marked, FINALIZEDBIT);  /* object is "normal" again */
00000e  7942              LDRB     r2,[r0,#5]
000010  f00202bf          AND      r2,r2,#0xbf
000014  7142              STRB     r2,[r0,#5]
;;;856      if (issweepphase(g))
000016  f8912035          LDRB     r2,[r1,#0x35]
00001a  2a03              CMP      r2,#3
00001c  db0c              BLT      |L65.56|
00001e  f8912035          LDRB     r2,[r1,#0x35]
000022  2a06              CMP      r2,#6
000024  dc08              BGT      |L65.56|
;;;857        makewhite(g, o);  /* "sweep" object */
000026  7942              LDRB     r2,[r0,#5]
000028  f022023f          BIC      r2,r2,#0x3f
00002c  f8913034          LDRB     r3,[r1,#0x34]
000030  f0030318          AND      r3,r3,#0x18
000034  431a              ORRS     r2,r2,r3
000036  7142              STRB     r2,[r0,#5]
                  |L65.56|
;;;858      return o;
;;;859    }
000038  4770              BX       lr
;;;860    
                          ENDP


                          AREA ||i.whitelist||, CODE, READONLY, ALIGN=1

                  whitelist PROC
;;;1069   */
;;;1070   static void whitelist (global_State *g, GCObject *p) {
000000  f8903034          LDRB     r3,[r0,#0x34]
;;;1071     int white = luaC_white(g);
000004  f0030218          AND      r2,r3,#0x18
;;;1072     for (; p != NULL; p = p->next)
000008  e005              B        |L66.22|
                  |L66.10|
;;;1073       p->marked = cast_byte((p->marked & maskcolors) | white);
00000a  794b              LDRB     r3,[r1,#5]
00000c  f023033f          BIC      r3,r3,#0x3f
000010  4313              ORRS     r3,r3,r2
000012  714b              STRB     r3,[r1,#5]
000014  6809              LDR      r1,[r1,#0]            ;1072
                  |L66.22|
000016  2900              CMP      r1,#0                 ;1072
000018  d1f7              BNE      |L66.10|
;;;1074   }
00001a  4770              BX       lr
;;;1075   
                          ENDP


                          AREA ||i.youngcollection||, CODE, READONLY, ALIGN=1

                  youngcollection PROC
;;;1175   */
;;;1176   static void youngcollection (lua_State *L, global_State *g) {
000000  b570              PUSH     {r4-r6,lr}
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;1177     GCObject **psurvival;  /* to point to first non-dead survival object */
;;;1178     lua_assert(g->gcstate == GCSpropagate);
;;;1179     markold(g, g->survival, g->reallyold);
000006  4620              MOV      r0,r4
000008  6f62              LDR      r2,[r4,#0x74]
00000a  6ee1              LDR      r1,[r4,#0x6c]
00000c  f7fffffe          BL       markold
;;;1180     markold(g, g->finobj, g->finobjrold);
000010  4620              MOV      r0,r4
000012  f8d42080          LDR      r2,[r4,#0x80]
000016  6ca1              LDR      r1,[r4,#0x48]
000018  f7fffffe          BL       markold
;;;1181     atomic(L);
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       atomic
;;;1182   
;;;1183     /* sweep nursery and get a pointer to its last live element */
;;;1184     psurvival = sweepgen(L, g, &g->allgc, g->survival);
000022  f1040240          ADD      r2,r4,#0x40
000026  4621              MOV      r1,r4
000028  4630              MOV      r0,r6
00002a  6ee3              LDR      r3,[r4,#0x6c]
00002c  f7fffffe          BL       sweepgen
000030  4605              MOV      r5,r0
;;;1185     /* sweep 'survival' and 'old' */
;;;1186     sweepgen(L, g, psurvival, g->reallyold);
000032  462a              MOV      r2,r5
000034  4621              MOV      r1,r4
000036  4630              MOV      r0,r6
000038  6f63              LDR      r3,[r4,#0x74]
00003a  f7fffffe          BL       sweepgen
;;;1187     g->reallyold = g->old;
00003e  6f20              LDR      r0,[r4,#0x70]
000040  6760              STR      r0,[r4,#0x74]
;;;1188     g->old = *psurvival;  /* 'survival' survivals are old now */
000042  6828              LDR      r0,[r5,#0]
000044  6720              STR      r0,[r4,#0x70]
;;;1189     g->survival = g->allgc;  /* all news are survivals */
000046  6c20              LDR      r0,[r4,#0x40]
000048  66e0              STR      r0,[r4,#0x6c]
;;;1190   
;;;1191     /* repeat for 'finobj' lists */
;;;1192     psurvival = sweepgen(L, g, &g->finobj, g->finobjsur);
00004a  f1040248          ADD      r2,r4,#0x48
00004e  4621              MOV      r1,r4
000050  4630              MOV      r0,r6
000052  6fa3              LDR      r3,[r4,#0x78]
000054  f7fffffe          BL       sweepgen
000058  4605              MOV      r5,r0
;;;1193     /* sweep 'survival' and 'old' */
;;;1194     sweepgen(L, g, psurvival, g->finobjrold);
00005a  462a              MOV      r2,r5
00005c  4621              MOV      r1,r4
00005e  4630              MOV      r0,r6
000060  f8d43080          LDR      r3,[r4,#0x80]
000064  f7fffffe          BL       sweepgen
;;;1195     g->finobjrold = g->finobjold;
000068  6fe0              LDR      r0,[r4,#0x7c]
00006a  f8c40080          STR      r0,[r4,#0x80]
;;;1196     g->finobjold = *psurvival;  /* 'survival' survivals are old now */
00006e  6828              LDR      r0,[r5,#0]
000070  67e0              STR      r0,[r4,#0x7c]
;;;1197     g->finobjsur = g->finobj;  /* all news are survivals */
000072  6ca0              LDR      r0,[r4,#0x48]
000074  67a0              STR      r0,[r4,#0x78]
;;;1198   
;;;1199     sweepgen(L, g, &g->tobefnz, NULL);
000076  2300              MOVS     r3,#0
000078  f1040264          ADD      r2,r4,#0x64
00007c  4621              MOV      r1,r4
00007e  4630              MOV      r0,r6
000080  f7fffffe          BL       sweepgen
;;;1200   
;;;1201     finishgencycle(L, g);
000084  4621              MOV      r1,r4
000086  4630              MOV      r0,r6
000088  f7fffffe          BL       finishgencycle
;;;1202   }
00008c  bd70              POP      {r4-r6,pc}
;;;1203   
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  nextage
000000  01030304          DCB      0x01,0x03,0x03,0x04
000004  040506            DCB      0x04,0x05,0x06
