; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\ltable.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\ltable.d --cpu=Cortex-M7 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Inc -I.\Source -I.\Drivers -I..\..\..\M6P1(L)_Lua\lua -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6-ALIENTEK-LUA\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER -Dlua_writestring=RMP_lua_writestring -Dlua_writeline=RMP_lua_writeline --enum_is_int --signed_chars --omf_browse=.\debug\output\ltable.crf ..\..\..\M6P1(L)_Lua\lua\ltable.c]
                          THUMB

                          AREA ||i.arrayindex||, CODE, READONLY, ALIGN=1

                  arrayindex PROC
;;;216    */
;;;217    static unsigned int arrayindex (lua_Integer k) {
000000  4602              MOV      r2,r0
000002  460b              MOV      r3,r1
;;;218      if (0 < k && l_castS2U(k) <= MAXASIZE)
000004  2100              MOVS     r1,#0
000006  4608              MOV      r0,r1
000008  1a89              SUBS     r1,r1,r2
00000a  4198              SBCS     r0,r0,r3
00000c  da07              BGE      |L1.30|
00000e  f06f4170          MVN      r1,#0xf0000000
000012  2000              MOVS     r0,#0
000014  1a89              SUBS     r1,r1,r2
000016  4198              SBCS     r0,r0,r3
000018  d301              BCC      |L1.30|
;;;219        return cast_uint(k);  /* 'key' is an appropriate array index */
00001a  4610              MOV      r0,r2
                  |L1.28|
;;;220      else
;;;221        return 0;
;;;222    }
00001c  4770              BX       lr
                  |L1.30|
00001e  2000              MOVS     r0,#0                 ;221
000020  e7fc              B        |L1.28|
;;;223    
                          ENDP


                          AREA ||i.computesizes||, CODE, READONLY, ALIGN=1

                  computesizes PROC
;;;287    */
;;;288    static unsigned int computesizes (unsigned int nums[], unsigned int *pna) {
000000  b5f0              PUSH     {r4-r7,lr}
000002  4604              MOV      r4,r0
000004  460a              MOV      r2,r1
;;;289      int i;
;;;290      unsigned int twotoi;  /* 2^i (candidate for optimal size) */
;;;291      unsigned int a = 0;  /* number of elements smaller than 2^i */
000006  2300              MOVS     r3,#0
;;;292      unsigned int na = 0;  /* number of elements to go to array part */
000008  2600              MOVS     r6,#0
;;;293      unsigned int optimal = 0;  /* optimal size for array part */
00000a  2000              MOVS     r0,#0
;;;294      /* loop while keys can fill more than half of total size */
;;;295      for (i = 0, twotoi = 1;
00000c  2500              MOVS     r5,#0
00000e  2101              MOVS     r1,#1
000010  e009              B        |L2.38|
                  |L2.18|
;;;296           twotoi > 0 && *pna > twotoi / 2;
;;;297           i++, twotoi *= 2) {
;;;298        a += nums[i];
000012  f8547025          LDR      r7,[r4,r5,LSL #2]
000016  443b              ADD      r3,r3,r7
;;;299        if (a > twotoi/2) {  /* more than half elements present? */
000018  ebb30f51          CMP      r3,r1,LSR #1
00001c  d901              BLS      |L2.34|
;;;300          optimal = twotoi;  /* optimal size (till now) */
00001e  4608              MOV      r0,r1
;;;301          na = a;  /* all elements up to 'optimal' will go to array part */
000020  461e              MOV      r6,r3
                  |L2.34|
000022  1c6d              ADDS     r5,r5,#1              ;297
000024  0049              LSLS     r1,r1,#1              ;297
                  |L2.38|
000026  b119              CBZ      r1,|L2.48|
000028  6817              LDR      r7,[r2,#0]            ;296
00002a  ebb70f51          CMP      r7,r1,LSR #1          ;296
00002e  d8f0              BHI      |L2.18|
                  |L2.48|
;;;302        }
;;;303      }
;;;304      lua_assert((optimal == 0 || optimal / 2 < na) && na <= optimal);
;;;305      *pna = na;
000030  6016              STR      r6,[r2,#0]
;;;306      return optimal;
;;;307    }
000032  bdf0              POP      {r4-r7,pc}
;;;308    
                          ENDP


                          AREA ||i.countint||, CODE, READONLY, ALIGN=1

                  countint PROC
;;;309    
;;;310    static int countint (lua_Integer key, unsigned int *nums) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4614              MOV      r4,r2
;;;311      unsigned int k = arrayindex(key);
00000a  4638              MOV      r0,r7
00000c  4641              MOV      r1,r8
00000e  f7fffffe          BL       arrayindex
000012  4605              MOV      r5,r0
;;;312      if (k != 0) {  /* is 'key' an appropriate array index? */
000014  b155              CBZ      r5,|L3.44|
;;;313        nums[luaO_ceillog2(k)]++;  /* count as such */
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       luaO_ceillog2
00001c  eb040680          ADD      r6,r4,r0,LSL #2
000020  6830              LDR      r0,[r6,#0]
000022  1c40              ADDS     r0,r0,#1
000024  6030              STR      r0,[r6,#0]
;;;314        return 1;
000026  2001              MOVS     r0,#1
                  |L3.40|
;;;315      }
;;;316      else
;;;317        return 0;
;;;318    }
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L3.44|
00002c  2000              MOVS     r0,#0                 ;317
00002e  e7fb              B        |L3.40|
;;;319    
                          ENDP


                          AREA ||i.equalkey||, CODE, READONLY, ALIGN=1

                  equalkey PROC
;;;169    */
;;;170    static int equalkey (const TValue *k1, const Node *n2) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
;;;171      if (rawtt(k1) != keytt(n2))  /* not the same variants? */
000008  7a20              LDRB     r0,[r4,#8]
00000a  f8991009          LDRB     r1,[r9,#9]
00000e  4288              CMP      r0,r1
000010  d002              BEQ      |L4.24|
;;;172       return 0;  /* cannot be same key */
000012  2000              MOVS     r0,#0
                  |L4.20|
;;;173      switch (ttypetag(k1)) {
;;;174        case LUA_TNIL:
;;;175          return 1;
;;;176        case LUA_TNUMINT:
;;;177          return (ivalue(k1) == keyival(n2));
;;;178        case LUA_TNUMFLT:
;;;179          return luai_numeq(fltvalue(k1), fltvalueraw(keyval(n2)));
;;;180        case LUA_TBOOLEAN:
;;;181          return bvalue(k1) == bvalueraw(keyval(n2));
;;;182        case LUA_TLIGHTUSERDATA:
;;;183          return pvalue(k1) == pvalueraw(keyval(n2));
;;;184        case LUA_TLCF:
;;;185          return fvalue(k1) == fvalueraw(keyval(n2));
;;;186        case LUA_TLNGSTR:
;;;187          return luaS_eqlngstr(tsvalue(k1), keystrval(n2));
;;;188        default:
;;;189          return gcvalue(k1) == gcvalueraw(keyval(n2));
;;;190      }
;;;191    }
000014  e8bd87f0          POP      {r4-r10,pc}
                  |L4.24|
000018  7a20              LDRB     r0,[r4,#8]            ;173
00001a  f000003f          AND      r0,r0,#0x3f           ;173
00001e  2813              CMP      r0,#0x13              ;173
000020  d01b              BEQ      |L4.90|
000022  dc05              BGT      |L4.48|
000024  b158              CBZ      r0,|L4.62|
000026  2801              CMP      r0,#1                 ;173
000028  d024              BEQ      |L4.116|
00002a  2802              CMP      r0,#2                 ;173
00002c  d143              BNE      |L4.182|
00002e  e02a              B        |L4.134|
                  |L4.48|
000030  2823              CMP      r0,#0x23              ;173
000032  d006              BEQ      |L4.66|
000034  2824              CMP      r0,#0x24              ;173
000036  d038              BEQ      |L4.170|
000038  2826              CMP      r0,#0x26              ;173
00003a  d13c              BNE      |L4.182|
00003c  e02c              B        |L4.152|
                  |L4.62|
00003e  2001              MOVS     r0,#1                 ;175
000040  e7e8              B        |L4.20|
                  |L4.66|
000042  e9d41000          LDRD     r1,r0,[r4,#0]         ;177
000046  e9d92304          LDRD     r2,r3,[r9,#0x10]      ;177
00004a  4051              EORS     r1,r1,r2              ;177
00004c  4058              EORS     r0,r0,r3              ;177
00004e  4301              ORRS     r1,r1,r0              ;177
000050  d101              BNE      |L4.86|
000052  2001              MOVS     r0,#1                 ;177
000054  e7de              B        |L4.20|
                  |L4.86|
000056  2000              MOVS     r0,#0                 ;177
000058  e7dc              B        |L4.20|
                  |L4.90|
00005a  e9d95304          LDRD     r5,r3,[r9,#0x10]      ;179
00005e  462a              MOV      r2,r5                 ;179
000060  e9d47100          LDRD     r7,r1,[r4,#0]         ;179
000064  4638              MOV      r0,r7                 ;179
000066  f7fffffe          BL       __aeabi_cdcmpeq
00006a  d101              BNE      |L4.112|
00006c  2001              MOVS     r0,#1                 ;179
00006e  e7d1              B        |L4.20|
                  |L4.112|
000070  2000              MOVS     r0,#0                 ;179
000072  e7cf              B        |L4.20|
                  |L4.116|
000074  6820              LDR      r0,[r4,#0]            ;181
000076  f8d91010          LDR      r1,[r9,#0x10]         ;181
00007a  4288              CMP      r0,r1                 ;181
00007c  d101              BNE      |L4.130|
00007e  2001              MOVS     r0,#1                 ;181
000080  e7c8              B        |L4.20|
                  |L4.130|
000082  2000              MOVS     r0,#0                 ;181
000084  e7c6              B        |L4.20|
                  |L4.134|
000086  6820              LDR      r0,[r4,#0]            ;183
000088  f8d91010          LDR      r1,[r9,#0x10]         ;183
00008c  4288              CMP      r0,r1                 ;183
00008e  d101              BNE      |L4.148|
000090  2001              MOVS     r0,#1                 ;183
000092  e7bf              B        |L4.20|
                  |L4.148|
000094  2000              MOVS     r0,#0                 ;183
000096  e7bd              B        |L4.20|
                  |L4.152|
000098  6820              LDR      r0,[r4,#0]            ;185
00009a  f8d91010          LDR      r1,[r9,#0x10]         ;185
00009e  4288              CMP      r0,r1                 ;185
0000a0  d101              BNE      |L4.166|
0000a2  2001              MOVS     r0,#1                 ;185
0000a4  e7b6              B        |L4.20|
                  |L4.166|
0000a6  2000              MOVS     r0,#0                 ;185
0000a8  e7b4              B        |L4.20|
                  |L4.170|
0000aa  f8d91010          LDR      r1,[r9,#0x10]         ;187
0000ae  6820              LDR      r0,[r4,#0]            ;187
0000b0  f7fffffe          BL       luaS_eqlngstr
0000b4  e7ae              B        |L4.20|
                  |L4.182|
0000b6  6820              LDR      r0,[r4,#0]            ;189
0000b8  f8d91010          LDR      r1,[r9,#0x10]         ;189
0000bc  4288              CMP      r0,r1                 ;189
0000be  d101              BNE      |L4.196|
0000c0  2001              MOVS     r0,#1                 ;189
0000c2  e7a7              B        |L4.20|
                  |L4.196|
0000c4  2000              MOVS     r0,#0                 ;189
0000c6  e7a5              B        |L4.20|
;;;192    
                          ENDP


                          AREA ||i.exchangehashpart||, CODE, READONLY, ALIGN=1

                  exchangehashpart PROC
;;;422    */
;;;423    static void exchangehashpart (Table *t1, Table *t2) {
000000  b530              PUSH     {r4,r5,lr}
;;;424      lu_byte lsizenode = t1->lsizenode;
000002  79c4              LDRB     r4,[r0,#7]
;;;425      Node *node = t1->node;
000004  6902              LDR      r2,[r0,#0x10]
;;;426      Node *lastfree = t1->lastfree;
000006  6943              LDR      r3,[r0,#0x14]
;;;427      t1->lsizenode = t2->lsizenode;
000008  79cd              LDRB     r5,[r1,#7]
00000a  71c5              STRB     r5,[r0,#7]
;;;428      t1->node = t2->node;
00000c  690d              LDR      r5,[r1,#0x10]
00000e  6105              STR      r5,[r0,#0x10]
;;;429      t1->lastfree = t2->lastfree;
000010  694d              LDR      r5,[r1,#0x14]
000012  6145              STR      r5,[r0,#0x14]
;;;430      t2->lsizenode = lsizenode;
000014  71cc              STRB     r4,[r1,#7]
;;;431      t2->node = node;
000016  610a              STR      r2,[r1,#0x10]
;;;432      t2->lastfree = lastfree;
000018  614b              STR      r3,[r1,#0x14]
;;;433    }
00001a  bd30              POP      {r4,r5,pc}
;;;434    
                          ENDP


                          AREA ||i.findindex||, CODE, READONLY, ALIGN=2

                  findindex PROC
;;;229    */
;;;230    static unsigned int findindex (lua_State *L, Table *t, TValue *key) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4680              MOV      r8,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;231      unsigned int i;
;;;232      if (ttisnil(key)) return 0;  /* first iteration */
00000a  7a28              LDRB     r0,[r5,#8]
00000c  b910              CBNZ     r0,|L6.20|
00000e  2000              MOVS     r0,#0
                  |L6.16|
;;;233      i = ttisinteger(key) ? arrayindex(ivalue(key)) : 0;
;;;234      if (i != 0 && i <= t->sizearray)  /* is 'key' inside array part? */
;;;235        return i;  /* yes; that's the index */
;;;236      else {
;;;237        const TValue *n = getgeneric(t, key);
;;;238        if (n == luaH_emptyobject)
;;;239          luaG_runerror(L, "invalid key to 'next'");  /* key not found */
;;;240        i = cast_int(nodefromval(n) - gnode(t, 0));  /* key index in hash table */
;;;241        /* hash elements are numbered after array ones */
;;;242        return (i + 1) + t->sizearray;
;;;243      }
;;;244    }
000010  e8bd81f0          POP      {r4-r8,pc}
                  |L6.20|
000014  7a28              LDRB     r0,[r5,#8]            ;233
000016  2823              CMP      r0,#0x23              ;233
000018  d105              BNE      |L6.38|
00001a  e9d52100          LDRD     r2,r1,[r5,#0]         ;233
00001e  4610              MOV      r0,r2                 ;233
000020  f7fffffe          BL       arrayindex
000024  e000              B        |L6.40|
                  |L6.38|
000026  2000              MOVS     r0,#0                 ;233
                  |L6.40|
000028  4606              MOV      r6,r0                 ;233
00002a  b126              CBZ      r6,|L6.54|
00002c  68a0              LDR      r0,[r4,#8]            ;234
00002e  42b0              CMP      r0,r6                 ;234
000030  d301              BCC      |L6.54|
000032  4630              MOV      r0,r6                 ;235
000034  e7ec              B        |L6.16|
                  |L6.54|
000036  4629              MOV      r1,r5                 ;237
000038  4620              MOV      r0,r4                 ;237
00003a  f7fffffe          BL       getgeneric
00003e  4607              MOV      r7,r0                 ;237
000040  4807              LDR      r0,|L6.96|
000042  4287              CMP      r7,r0                 ;238
000044  d103              BNE      |L6.78|
000046  a107              ADR      r1,|L6.100|
000048  4640              MOV      r0,r8                 ;239
00004a  f7fffffe          BL       luaG_runerror
                  |L6.78|
00004e  6920              LDR      r0,[r4,#0x10]         ;240
000050  1a38              SUBS     r0,r7,r0              ;240
000052  2118              MOVS     r1,#0x18              ;240
000054  fb90f6f1          SDIV     r6,r0,r1              ;240
000058  1c70              ADDS     r0,r6,#1              ;242
00005a  68a1              LDR      r1,[r4,#8]            ;242
00005c  4408              ADD      r0,r0,r1              ;242
00005e  e7d7              B        |L6.16|
;;;245    
                          ENDP

                  |L6.96|
                          DCD      luaH_emptyobject_
                  |L6.100|
000064  696e7661          DCB      "invalid key to 'next'",0
000068  6c696420
00006c  6b657920
000070  746f2027
000074  6e657874
000078  2700    
00007a  00                DCB      0
00007b  00                DCB      0

                          AREA ||i.freehash||, CODE, READONLY, ALIGN=1

                  freehash PROC
;;;267    
;;;268    static void freehash (lua_State *L, Table *t) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;269      if (!isdummy(t))
000006  6960              LDR      r0,[r4,#0x14]
000008  b148              CBZ      r0,|L7.30|
;;;270        luaM_freearray(L, t->node, cast_sizet(sizenode(t)));
00000a  79e3              LDRB     r3,[r4,#7]
00000c  2001              MOVS     r0,#1
00000e  4098              LSLS     r0,r0,r3
000010  eb000040          ADD      r0,r0,r0,LSL #1
000014  00c2              LSLS     r2,r0,#3
000016  4628              MOV      r0,r5
000018  6921              LDR      r1,[r4,#0x10]
00001a  f7fffffe          BL       luaM_free_
                  |L7.30|
;;;271    }
00001e  bd70              POP      {r4-r6,pc}
;;;272    
                          ENDP


                          AREA ||i.getfreepos||, CODE, READONLY, ALIGN=1

                  getfreepos PROC
;;;539    
;;;540    static Node *getfreepos (Table *t) {
000000  4601              MOV      r1,r0
;;;541      if (!isdummy(t)) {
000002  6948              LDR      r0,[r1,#0x14]
000004  b160              CBZ      r0,|L8.32|
;;;542        while (t->lastfree > t->node) {
000006  e007              B        |L8.24|
                  |L8.8|
;;;543          t->lastfree--;
000008  6948              LDR      r0,[r1,#0x14]
00000a  3818              SUBS     r0,r0,#0x18
00000c  6148              STR      r0,[r1,#0x14]
;;;544          if (keyisnil(t->lastfree))
00000e  6948              LDR      r0,[r1,#0x14]
000010  7a40              LDRB     r0,[r0,#9]
000012  b908              CBNZ     r0,|L8.24|
;;;545            return t->lastfree;
000014  6948              LDR      r0,[r1,#0x14]
                  |L8.22|
;;;546        }
;;;547      }
;;;548      return NULL;  /* could not find a free place */
;;;549    }
000016  4770              BX       lr
                  |L8.24|
000018  e9d12004          LDRD     r2,r0,[r1,#0x10]      ;542
00001c  4290              CMP      r0,r2                 ;542
00001e  d8f3              BHI      |L8.8|
                  |L8.32|
000020  2000              MOVS     r0,#0                 ;548
000022  e7f8              B        |L8.22|
;;;550    
                          ENDP


                          AREA ||i.getgeneric||, CODE, READONLY, ALIGN=2

                  getgeneric PROC
;;;197    */
;;;198    static const TValue *getgeneric (Table *t, const TValue *key) {
000000  b570              PUSH     {r4-r6,lr}
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;199      Node *n = mainpositionTV(t, key);
000006  4629              MOV      r1,r5
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       mainpositionTV
00000e  4604              MOV      r4,r0
;;;200      for (;;) {  /* check whether 'key' is somewhere in the chain */
000010  bf00              NOP      
                  |L9.18|
;;;201        if (equalkey(key, n))
000012  4621              MOV      r1,r4
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       equalkey
00001a  b108              CBZ      r0,|L9.32|
;;;202          return gval(n);  /* that's it */
00001c  4620              MOV      r0,r4
                  |L9.30|
;;;203        else {
;;;204          int nx = gnext(n);
;;;205          if (nx == 0)
;;;206            return luaH_emptyobject;  /* not found */
;;;207          n += nx;
;;;208        }
;;;209      }
;;;210    }
00001e  bd70              POP      {r4-r6,pc}
                  |L9.32|
000020  68e1              LDR      r1,[r4,#0xc]          ;204
000022  b909              CBNZ     r1,|L9.40|
000024  4803              LDR      r0,|L9.52|
000026  e7fa              B        |L9.30|
                  |L9.40|
000028  eb010041          ADD      r0,r1,r1,LSL #1       ;207
00002c  eb0404c0          ADD      r4,r4,r0,LSL #3       ;207
000030  e7ef              B        |L9.18|
;;;211    
                          ENDP

000032  0000              DCW      0x0000
                  |L9.52|
                          DCD      luaH_emptyobject_

                          AREA ||i.hash_search||, CODE, READONLY, ALIGN=1

                  hash_search PROC
;;;724    */
;;;725    static lua_Unsigned hash_search (Table *t, lua_Unsigned j) {
000000  e92d5fff          PUSH     {r0-r12,lr}
000004  4614              MOV      r4,r2
000006  461d              MOV      r5,r3
;;;726      lua_Unsigned i;
;;;727      if (j == 0) j++;  /* the caller ensures 'j + 1' is present */
000008  2100              MOVS     r1,#0
00000a  ea840001          EOR      r0,r4,r1
00000e  4069              EORS     r1,r1,r5
000010  4308              ORRS     r0,r0,r1
000012  d102              BNE      |L10.26|
000014  1c64              ADDS     r4,r4,#1
000016  f1450500          ADC      r5,r5,#0
                  |L10.26|
;;;728      do {
00001a  bf00              NOP      
                  |L10.28|
;;;729        i = j;  /* 'i' is a present index */
00001c  4626              MOV      r6,r4
00001e  462f              MOV      r7,r5
;;;730        if (j <= l_castS2U(LUA_MAXINTEGER) / 2)
000020  f06f4040          MVN      r0,#0xc0000000
000024  f1d431ff          RSBS     r1,r4,#0xffffffff
000028  41a8              SBCS     r0,r0,r5
00002a  d30a              BCC      |L10.66|
;;;731          j *= 2;
00002c  2202              MOVS     r2,#2
00002e  2000              MOVS     r0,#0
000030  4623              MOV      r3,r4
000032  fba3c802          UMULL    r12,r8,r3,r2
000036  fb058102          MLA      r1,r5,r2,r8
00003a  fb041500          MLA      r5,r4,r0,r1
00003e  4664              MOV      r4,r12
000040  e011              B        |L10.102|
                  |L10.66|
;;;732        else {
;;;733          j = LUA_MAXINTEGER;
000042  f04f34ff          MOV      r4,#0xffffffff
000046  0865              LSRS     r5,r4,#1
;;;734          if (isempty(luaH_getint(t, j)))  /* t[j] not present? */
000048  4622              MOV      r2,r4
00004a  462b              MOV      r3,r5
00004c  9800              LDR      r0,[sp,#0]
00004e  f7fffffe          BL       luaH_getint
000052  7a00              LDRB     r0,[r0,#8]
000054  f000000f          AND      r0,r0,#0xf
000058  b900              CBNZ     r0,|L10.92|
;;;735            break;  /* 'j' now is an absent index */
00005a  e00e              B        |L10.122|
                  |L10.92|
;;;736          else  /* weird case */
;;;737            return j;  /* well, max integer is a boundary... */
00005c  4620              MOV      r0,r4
00005e  4629              MOV      r1,r5
                  |L10.96|
;;;738        }
;;;739      } while (!isempty(luaH_getint(t, j)));  /* repeat until an absent t[j] */
;;;740      /* i < j  &&  t[i] present  &&  t[j] absent */
;;;741      while (j - i > 1u) {  /* do a binary search between them */
;;;742        lua_Unsigned m = (i + j) / 2;
;;;743        if (isempty(luaH_getint(t, m))) j = m;
;;;744        else i = m;
;;;745      }
;;;746      return i;
;;;747    }
000060  b004              ADD      sp,sp,#0x10
000062  e8bd9ff0          POP      {r4-r12,pc}
                  |L10.102|
000066  4622              MOV      r2,r4                 ;739
000068  462b              MOV      r3,r5                 ;739
00006a  9800              LDR      r0,[sp,#0]            ;739
00006c  f7fffffe          BL       luaH_getint
000070  7a00              LDRB     r0,[r0,#8]            ;739
000072  f000000f          AND      r0,r0,#0xf            ;739
000076  2800              CMP      r0,#0                 ;739
000078  d1d0              BNE      |L10.28|
                  |L10.122|
00007a  bf00              NOP                            ;735
00007c  e019              B        |L10.178|
                  |L10.126|
00007e  eb160a04          ADDS     r10,r6,r4             ;742
000082  eb470105          ADC      r1,r7,r5              ;742
000086  2202              MOVS     r2,#2                 ;742
000088  2300              MOVS     r3,#0                 ;742
00008a  4650              MOV      r0,r10                ;742
00008c  f7fffffe          BL       __aeabi_uldivmod
000090  4680              MOV      r8,r0                 ;742
000092  4689              MOV      r9,r1                 ;742
000094  4642              MOV      r2,r8                 ;743
000096  464b              MOV      r3,r9                 ;743
000098  9800              LDR      r0,[sp,#0]            ;743
00009a  f7fffffe          BL       luaH_getint
00009e  7a00              LDRB     r0,[r0,#8]            ;743
0000a0  f000000f          AND      r0,r0,#0xf            ;743
0000a4  b910              CBNZ     r0,|L10.172|
0000a6  4644              MOV      r4,r8                 ;743
0000a8  464d              MOV      r5,r9                 ;743
0000aa  e001              B        |L10.176|
                  |L10.172|
0000ac  4646              MOV      r6,r8                 ;744
0000ae  464f              MOV      r7,r9                 ;744
                  |L10.176|
0000b0  bf00              NOP                            ;745
                  |L10.178|
0000b2  1ba2              SUBS     r2,r4,r6              ;741
0000b4  eb650007          SBC      r0,r5,r7              ;741
0000b8  2100              MOVS     r1,#0                 ;741
0000ba  f1d20201          RSBS     r2,r2,#1              ;741
0000be  4181              SBCS     r1,r1,r0              ;741
0000c0  d3dd              BCC      |L10.126|
0000c2  4630              MOV      r0,r6                 ;746
0000c4  4639              MOV      r1,r7                 ;746
0000c6  e7cb              B        |L10.96|
;;;748    
                          ENDP


                          AREA ||i.l_hashfloat||, CODE, READONLY, ALIGN=2

                  l_hashfloat PROC
;;;112    #if !defined(l_hashfloat)
;;;113    static int l_hashfloat (lua_Number n) {
000000  e92d43f8          PUSH     {r3-r9,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;114      int i;
;;;115      lua_Integer ni;
;;;116      n = l_mathop(frexp)(n, &i) * -cast_num(INT_MIN);
000008  466a              MOV      r2,sp
00000a  4620              MOV      r0,r4
00000c  4629              MOV      r1,r5
00000e  f7fffffe          BL       frexp
000012  4680              MOV      r8,r0
000014  2200              MOVS     r2,#0
000016  4b13              LDR      r3,|L11.100|
000018  f7fffffe          BL       __aeabi_dmul
00001c  4604              MOV      r4,r0
00001e  460d              MOV      r5,r1
;;;117      if (!lua_numbertointeger(n, &ni)) {  /* is 'n' inf/-inf/NaN? */
000020  2200              MOVS     r2,#0
000022  4b11              LDR      r3,|L11.104|
000024  4620              MOV      r0,r4
000026  4629              MOV      r1,r5
000028  f7fffffe          BL       __aeabi_cdrcmple
00002c  d80d              BHI      |L11.74|
00002e  2200              MOVS     r2,#0
000030  4b0e              LDR      r3,|L11.108|
000032  4620              MOV      r0,r4
000034  4629              MOV      r1,r5
000036  f7fffffe          BL       __aeabi_cdcmple
00003a  d206              BCS      |L11.74|
00003c  4620              MOV      r0,r4
00003e  4629              MOV      r1,r5
000040  f7fffffe          BL       __aeabi_d2lz
000044  4606              MOV      r6,r0
000046  2001              MOVS     r0,#1
000048  b910              CBNZ     r0,|L11.80|
                  |L11.74|
;;;118        lua_assert(luai_numisnan(n) || l_mathop(fabs)(n) == cast_num(HUGE_VAL));
;;;119        return 0;
00004a  2000              MOVS     r0,#0
                  |L11.76|
;;;120      }
;;;121      else {  /* normal case */
;;;122        unsigned int u = cast_uint(i) + cast_uint(ni);
;;;123        return cast_int(u <= cast_uint(INT_MAX) ? u : ~u);
;;;124      }
;;;125    }
00004c  e8bd83f8          POP      {r3-r9,pc}
                  |L11.80|
000050  9800              LDR      r0,[sp,#0]            ;122
000052  1981              ADDS     r1,r0,r6              ;122
000054  f1b14f00          CMP      r1,#0x80000000        ;123
000058  d201              BCS      |L11.94|
00005a  4608              MOV      r0,r1                 ;123
00005c  e7f6              B        |L11.76|
                  |L11.94|
00005e  43c8              MVNS     r0,r1                 ;123
000060  e7f4              B        |L11.76|
;;;126    #endif
                          ENDP

000062  0000              DCW      0x0000
                  |L11.100|
                          DCD      0x41e00000
                  |L11.104|
                          DCD      0xc3e00000
                  |L11.108|
                          DCD      0x43e00000

                          AREA ||i.luaH_free||, CODE, READONLY, ALIGN=1

                  luaH_free PROC
;;;532    
;;;533    void luaH_free (lua_State *L, Table *t) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;534      freehash(L, t);
000006  4621              MOV      r1,r4
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       freehash
;;;535      luaM_freearray(L, t->array, t->sizearray);
00000e  68a0              LDR      r0,[r4,#8]
000010  0102              LSLS     r2,r0,#4
000012  4628              MOV      r0,r5
000014  68e1              LDR      r1,[r4,#0xc]
000016  f7fffffe          BL       luaM_free_
;;;536      luaM_free(L, t);
00001a  2220              MOVS     r2,#0x20
00001c  4621              MOV      r1,r4
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       luaM_free_
;;;537    }
000024  bd70              POP      {r4-r6,pc}
;;;538    
                          ENDP


                          AREA ||i.luaH_get||, CODE, READONLY, ALIGN=2

                  luaH_get PROC
;;;668    */
;;;669    const TValue *luaH_get (Table *t, const TValue *key) {
000000  e92d41fc          PUSH     {r2-r8,lr}
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;670      switch (ttypetag(key)) {
000008  7a20              LDRB     r0,[r4,#8]
00000a  f000003f          AND      r0,r0,#0x3f
00000e  b198              CBZ      r0,|L13.56|
000010  2813              CMP      r0,#0x13
000012  d013              BEQ      |L13.60|
000014  2814              CMP      r0,#0x14
000016  d002              BEQ      |L13.30|
000018  2823              CMP      r0,#0x23
00001a  d11e              BNE      |L13.90|
00001c  e005              B        |L13.42|
                  |L13.30|
;;;671        case LUA_TSHRSTR: return luaH_getshortstr(t, tsvalue(key));
00001e  4628              MOV      r0,r5
000020  6821              LDR      r1,[r4,#0]
000022  f7fffffe          BL       luaH_getshortstr
                  |L13.38|
;;;672        case LUA_TNUMINT: return luaH_getint(t, ivalue(key));
;;;673        case LUA_TNIL: return luaH_emptyobject;
;;;674        case LUA_TNUMFLT: {
;;;675          lua_Integer k;
;;;676          if (luaV_flttointeger(fltvalue(key), &k, 0)) /* index is an integral? */
;;;677            return luaH_getint(t, k);  /* use specialized version */
;;;678          /* else... */
;;;679        }  /* FALLTHROUGH */
;;;680        default:
;;;681          return getgeneric(t, key);
;;;682      }
;;;683    }
000026  e8bd81fc          POP      {r2-r8,pc}
                  |L13.42|
00002a  e9d46300          LDRD     r6,r3,[r4,#0]         ;672
00002e  4632              MOV      r2,r6                 ;672
000030  4628              MOV      r0,r5                 ;672
000032  f7fffffe          BL       luaH_getint
000036  e7f6              B        |L13.38|
                  |L13.56|
000038  480a              LDR      r0,|L13.100|
00003a  e7f4              B        |L13.38|
                  |L13.60|
00003c  2300              MOVS     r3,#0                 ;676
00003e  466a              MOV      r2,sp                 ;676
000040  e9d46100          LDRD     r6,r1,[r4,#0]         ;676
000044  4630              MOV      r0,r6                 ;676
000046  f7fffffe          BL       luaV_flttointeger
00004a  b128              CBZ      r0,|L13.88|
00004c  4628              MOV      r0,r5                 ;677
00004e  e9dd2300          LDRD     r2,r3,[sp,#0]         ;677
000052  f7fffffe          BL       luaH_getint
000056  e7e6              B        |L13.38|
                  |L13.88|
000058  bf00              NOP                            ;680
                  |L13.90|
00005a  4621              MOV      r1,r4                 ;681
00005c  4628              MOV      r0,r5                 ;681
00005e  f7fffffe          BL       getgeneric
000062  e7e0              B        |L13.38|
;;;684    
                          ENDP

                  |L13.100|
                          DCD      luaH_emptyobject_

                          AREA ||i.luaH_getint||, CODE, READONLY, ALIGN=2

                  luaH_getint PROC
;;;615    */
;;;616    const TValue *luaH_getint (Table *t, lua_Integer key) {
000000  b570              PUSH     {r4-r6,lr}
000002  4601              MOV      r1,r0
;;;617      /* (1 <= key && key <= t->sizearray) */
;;;618      if (l_castS2U(key) - 1u < t->sizearray)
000004  1e56              SUBS     r6,r2,#1
000006  f1630400          SBC      r4,r3,#0
00000a  6888              LDR      r0,[r1,#8]
00000c  1a30              SUBS     r0,r6,r0
00000e  f1740400          SBCS     r4,r4,#0
000012  d204              BCS      |L14.30|
;;;619        return &t->array[key - 1];
000014  68cc              LDR      r4,[r1,#0xc]
000016  1e50              SUBS     r0,r2,#1
000018  eb041000          ADD      r0,r4,r0,LSL #4
                  |L14.28|
;;;620      else {
;;;621        Node *n = hashint(t, key);
;;;622        for (;;) {  /* check whether 'key' is somewhere in the chain */
;;;623          if (keyisinteger(n) && keyival(n) == key)
;;;624            return gval(n);  /* that's it */
;;;625          else {
;;;626            int nx = gnext(n);
;;;627            if (nx == 0) break;
;;;628            n += nx;
;;;629          }
;;;630        }
;;;631        return luaH_emptyobject;
;;;632      }
;;;633    }
00001c  bd70              POP      {r4-r6,pc}
                  |L14.30|
00001e  79ce              LDRB     r6,[r1,#7]            ;621
000020  2001              MOVS     r0,#1                 ;621
000022  40b0              LSLS     r0,r0,r6              ;621
000024  1e40              SUBS     r0,r0,#1              ;621
000026  4010              ANDS     r0,r0,r2              ;621
000028  eb000040          ADD      r0,r0,r0,LSL #1       ;621
00002c  690d              LDR      r5,[r1,#0x10]         ;621
00002e  eb0504c0          ADD      r4,r5,r0,LSL #3       ;621
000032  bf00              NOP                            ;622
                  |L14.52|
000034  7a60              LDRB     r0,[r4,#9]            ;623
000036  2823              CMP      r0,#0x23              ;623
000038  d107              BNE      |L14.74|
00003a  e9d40504          LDRD     r0,r5,[r4,#0x10]      ;623
00003e  4050              EORS     r0,r0,r2              ;623
000040  405d              EORS     r5,r5,r3              ;623
000042  4328              ORRS     r0,r0,r5              ;623
000044  d101              BNE      |L14.74|
000046  4620              MOV      r0,r4                 ;624
000048  e7e8              B        |L14.28|
                  |L14.74|
00004a  68e0              LDR      r0,[r4,#0xc]          ;626
00004c  b900              CBNZ     r0,|L14.80|
00004e  e004              B        |L14.90|
                  |L14.80|
000050  eb000540          ADD      r5,r0,r0,LSL #1       ;628
000054  eb0404c5          ADD      r4,r4,r5,LSL #3       ;628
000058  e7ec              B        |L14.52|
                  |L14.90|
00005a  bf00              NOP                            ;627
00005c  4800              LDR      r0,|L14.96|
00005e  e7dd              B        |L14.28|
;;;634    
                          ENDP

                  |L14.96|
                          DCD      luaH_emptyobject_

                          AREA ||i.luaH_getn||, CODE, READONLY, ALIGN=1

                  luaH_getn PROC
;;;759    */
;;;760    lua_Unsigned luaH_getn (Table *t) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;761      unsigned int j = t->sizearray;
000004  68ac              LDR      r4,[r5,#8]
;;;762      if (j > 0 && isempty(&t->array[j - 1])) {
000006  b1e4              CBZ      r4,|L15.66|
000008  1e60              SUBS     r0,r4,#1
00000a  68e9              LDR      r1,[r5,#0xc]
00000c  eb011000          ADD      r0,r1,r0,LSL #4
000010  7a00              LDRB     r0,[r0,#8]
000012  f000000f          AND      r0,r0,#0xf
000016  b9a0              CBNZ     r0,|L15.66|
;;;763        unsigned int i = 0;
000018  2000              MOVS     r0,#0
;;;764        while (j - i > 1u) {  /* binary search */
00001a  e00d              B        |L15.56|
                  |L15.28|
;;;765          unsigned int m = (i + j) / 2;
00001c  1902              ADDS     r2,r0,r4
00001e  0851              LSRS     r1,r2,#1
;;;766          if (isempty(&t->array[m - 1])) j = m;
000020  1e4a              SUBS     r2,r1,#1
000022  68eb              LDR      r3,[r5,#0xc]
000024  eb031202          ADD      r2,r3,r2,LSL #4
000028  7a12              LDRB     r2,[r2,#8]
00002a  f002020f          AND      r2,r2,#0xf
00002e  b90a              CBNZ     r2,|L15.52|
000030  460c              MOV      r4,r1
000032  e000              B        |L15.54|
                  |L15.52|
;;;767          else i = m;
000034  4608              MOV      r0,r1
                  |L15.54|
;;;768        }
000036  bf00              NOP      
                  |L15.56|
000038  1a21              SUBS     r1,r4,r0              ;764
00003a  2901              CMP      r1,#1                 ;764
00003c  d8ee              BHI      |L15.28|
;;;769        return i;
00003e  2100              MOVS     r1,#0
                  |L15.64|
;;;770      }
;;;771      else {  /* 'j' is zero or present in table */
;;;772        if (isdummy(t) || isempty(luaH_getint(t, l_castU2S(j + 1))))
;;;773          return j;  /* 'j + 1' is absent... */
;;;774        else  /* 'j + 1' is also present */
;;;775          return hash_search(t, j);
;;;776      }
;;;777    }
000040  bd70              POP      {r4-r6,pc}
                  |L15.66|
000042  6968              LDR      r0,[r5,#0x14]         ;772
000044  b140              CBZ      r0,|L15.88|
000046  1c62              ADDS     r2,r4,#1              ;772
000048  2300              MOVS     r3,#0                 ;772
00004a  4628              MOV      r0,r5                 ;772
00004c  f7fffffe          BL       luaH_getint
000050  7a00              LDRB     r0,[r0,#8]            ;772
000052  f000000f          AND      r0,r0,#0xf            ;772
000056  b910              CBNZ     r0,|L15.94|
                  |L15.88|
000058  2100              MOVS     r1,#0                 ;773
00005a  4620              MOV      r0,r4                 ;773
00005c  e7f0              B        |L15.64|
                  |L15.94|
00005e  4622              MOV      r2,r4                 ;775
000060  2300              MOVS     r3,#0                 ;775
000062  4628              MOV      r0,r5                 ;775
000064  f7fffffe          BL       hash_search
000068  e7ea              B        |L15.64|
;;;778    
                          ENDP


                          AREA ||i.luaH_getshortstr||, CODE, READONLY, ALIGN=2

                  luaH_getshortstr PROC
;;;638    */
;;;639    const TValue *luaH_getshortstr (Table *t, TString *key) {
000000  b530              PUSH     {r4,r5,lr}
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;640      Node *n = hashstr(t, key);
000006  79d5              LDRB     r5,[r2,#7]
000008  2001              MOVS     r0,#1
00000a  40a8              LSLS     r0,r0,r5
00000c  1e40              SUBS     r0,r0,#1
00000e  689c              LDR      r4,[r3,#8]
000010  4004              ANDS     r4,r4,r0
000012  eb040044          ADD      r0,r4,r4,LSL #1
000016  6914              LDR      r4,[r2,#0x10]
000018  eb0401c0          ADD      r1,r4,r0,LSL #3
;;;641      lua_assert(key->tt == LUA_TSHRSTR);
;;;642      for (;;) {  /* check whether 'key' is somewhere in the chain */
00001c  bf00              NOP      
                  |L16.30|
;;;643        if (keyisshrstr(n) && eqshrstr(keystrval(n), key))
00001e  7a48              LDRB     r0,[r1,#9]
000020  2854              CMP      r0,#0x54
000022  d104              BNE      |L16.46|
000024  6908              LDR      r0,[r1,#0x10]
000026  4298              CMP      r0,r3
000028  d101              BNE      |L16.46|
;;;644          return gval(n);  /* that's it */
00002a  4608              MOV      r0,r1
                  |L16.44|
;;;645        else {
;;;646          int nx = gnext(n);
;;;647          if (nx == 0)
;;;648            return luaH_emptyobject;  /* not found */
;;;649          n += nx;
;;;650        }
;;;651      }
;;;652    }
00002c  bd30              POP      {r4,r5,pc}
                  |L16.46|
00002e  68cc              LDR      r4,[r1,#0xc]          ;646
000030  b90c              CBNZ     r4,|L16.54|
000032  4803              LDR      r0,|L16.64|
000034  e7fa              B        |L16.44|
                  |L16.54|
000036  eb040044          ADD      r0,r4,r4,LSL #1       ;649
00003a  eb0101c0          ADD      r1,r1,r0,LSL #3       ;649
00003e  e7ee              B        |L16.30|
;;;653    
                          ENDP

                  |L16.64|
                          DCD      luaH_emptyobject_

                          AREA ||i.luaH_getstr||, CODE, READONLY, ALIGN=1

                  luaH_getstr PROC
;;;654    
;;;655    const TValue *luaH_getstr (Table *t, TString *key) {
000000  b57f              PUSH     {r0-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;656      if (key->tt == LUA_TSHRSTR)
000006  7920              LDRB     r0,[r4,#4]
000008  2814              CMP      r0,#0x14
00000a  d105              BNE      |L17.24|
;;;657        return luaH_getshortstr(t, key);
00000c  4621              MOV      r1,r4
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       luaH_getshortstr
                  |L17.20|
;;;658      else {  /* for long strings, use generic case */
;;;659        TValue ko;
;;;660        setsvalue(cast(lua_State *, NULL), &ko, key);
;;;661        return getgeneric(t, &ko);
;;;662      }
;;;663    }
000014  b004              ADD      sp,sp,#0x10
000016  bd70              POP      {r4-r6,pc}
                  |L17.24|
000018  4668              MOV      r0,sp                 ;660
00001a  4621              MOV      r1,r4                 ;660
00001c  6001              STR      r1,[r0,#0]            ;660
00001e  790a              LDRB     r2,[r1,#4]            ;660
000020  f0420240          ORR      r2,r2,#0x40           ;660
000024  7202              STRB     r2,[r0,#8]            ;660
000026  4669              MOV      r1,sp                 ;661
000028  4628              MOV      r0,r5                 ;661
00002a  f7fffffe          BL       getgeneric
00002e  e7f1              B        |L17.20|
;;;664    
                          ENDP


                          AREA ||i.luaH_new||, CODE, READONLY, ALIGN=1

                  luaH_new PROC
;;;520    
;;;521    Table *luaH_new (lua_State *L) {
000000  b570              PUSH     {r4-r6,lr}
000002  4606              MOV      r6,r0
;;;522      GCObject *o = luaC_newobj(L, LUA_TTABLE, sizeof(Table));
000004  2220              MOVS     r2,#0x20
000006  2105              MOVS     r1,#5
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       luaC_newobj
00000e  4605              MOV      r5,r0
;;;523      Table *t = gco2t(o);
000010  462c              MOV      r4,r5
;;;524      t->metatable = NULL;
000012  2000              MOVS     r0,#0
000014  61a0              STR      r0,[r4,#0x18]
;;;525      t->flags = cast_byte(~0);
000016  20ff              MOVS     r0,#0xff
000018  71a0              STRB     r0,[r4,#6]
;;;526      t->array = NULL;
00001a  2000              MOVS     r0,#0
00001c  60e0              STR      r0,[r4,#0xc]
;;;527      t->sizearray = 0;
00001e  60a0              STR      r0,[r4,#8]
;;;528      setnodevector(L, t, 0);
000020  2200              MOVS     r2,#0
000022  4621              MOV      r1,r4
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       setnodevector
;;;529      return t;
00002a  4620              MOV      r0,r4
;;;530    }
00002c  bd70              POP      {r4-r6,pc}
;;;531    
                          ENDP


                          AREA ||i.luaH_newkey||, CODE, READONLY, ALIGN=2

                  luaH_newkey PROC
;;;559    */
;;;560    TValue *luaH_newkey (lua_State *L, Table *t, const TValue *key) {
000000  e92d43f0          PUSH     {r4-r9,lr}
000004  b087              SUB      sp,sp,#0x1c
000006  4681              MOV      r9,r0
000008  4688              MOV      r8,r1
00000a  4615              MOV      r5,r2
;;;561      Node *mp;
;;;562      TValue aux;
;;;563      if (ttisnil(key)) luaG_runerror(L, "table index is nil");
00000c  7a28              LDRB     r0,[r5,#8]
00000e  b920              CBNZ     r0,|L19.26|
000010  a152              ADR      r1,|L19.348|
000012  4648              MOV      r0,r9
000014  f7fffffe          BL       luaG_runerror
000018  e020              B        |L19.92|
                  |L19.26|
;;;564      else if (ttisfloat(key)) {
00001a  7a28              LDRB     r0,[r5,#8]
00001c  2813              CMP      r0,#0x13
00001e  d11d              BNE      |L19.92|
;;;565        lua_Number f = fltvalue(key);
000020  e9d56700          LDRD     r6,r7,[r5,#0]
;;;566        lua_Integer k;
;;;567        if (luaV_flttointeger(f, &k, 0)) {  /* does key fit in an integer? */
000024  2300              MOVS     r3,#0
000026  466a              MOV      r2,sp
000028  4630              MOV      r0,r6
00002a  4639              MOV      r1,r7
00002c  f7fffffe          BL       luaV_flttointeger
000030  b140              CBZ      r0,|L19.68|
;;;568          setivalue(&aux, k);
000032  a802              ADD      r0,sp,#8
000034  e9dd1200          LDRD     r1,r2,[sp,#0]
000038  e9c01200          STRD     r1,r2,[r0,#0]
00003c  2123              MOVS     r1,#0x23
00003e  7201              STRB     r1,[r0,#8]
;;;569          key = &aux;  /* insert it as an integer */
000040  ad02              ADD      r5,sp,#8
000042  e00a              B        |L19.90|
                  |L19.68|
;;;570        }
;;;571        else if (luai_numisnan(f))
000044  4632              MOV      r2,r6
000046  463b              MOV      r3,r7
000048  4630              MOV      r0,r6
00004a  4639              MOV      r1,r7
00004c  f7fffffe          BL       __aeabi_cdcmpeq
000050  d003              BEQ      |L19.90|
;;;572          luaG_runerror(L, "table index is NaN");
000052  a147              ADR      r1,|L19.368|
000054  4648              MOV      r0,r9
000056  f7fffffe          BL       luaG_runerror
                  |L19.90|
;;;573      }
00005a  bf00              NOP      
                  |L19.92|
;;;574      mp = mainpositionTV(t, key);
00005c  4629              MOV      r1,r5
00005e  4640              MOV      r0,r8
000060  f7fffffe          BL       mainpositionTV
000064  4604              MOV      r4,r0
;;;575      if (!isempty(gval(mp)) || isdummy(t)) {  /* main position is taken? */
000066  7a20              LDRB     r0,[r4,#8]
000068  f000000f          AND      r0,r0,#0xf
00006c  b918              CBNZ     r0,|L19.118|
00006e  f8d80014          LDR      r0,[r8,#0x14]
000072  2800              CMP      r0,#0
000074  d154              BNE      |L19.288|
                  |L19.118|
;;;576        Node *othern;
;;;577        Node *f = getfreepos(t);  /* get a free place */
000076  4640              MOV      r0,r8
000078  f7fffffe          BL       getfreepos
00007c  4606              MOV      r6,r0
;;;578        if (f == NULL) {  /* cannot find a free place? */
00007e  b966              CBNZ     r6,|L19.154|
;;;579          rehash(L, t, key);  /* grow table */
000080  462a              MOV      r2,r5
000082  4641              MOV      r1,r8
000084  4648              MOV      r0,r9
000086  f7fffffe          BL       rehash
;;;580          /* whatever called 'newkey' takes care of TM cache */
;;;581          return luaH_set(L, t, key);  /* insert key into grown table */
00008a  462a              MOV      r2,r5
00008c  4641              MOV      r1,r8
00008e  4648              MOV      r0,r9
000090  f7fffffe          BL       luaH_set
                  |L19.148|
;;;582        }
;;;583        lua_assert(!isdummy(t));
;;;584        othern = mainposition(t, keytt(mp), &keyval(mp));
;;;585        if (othern != mp) {  /* is colliding node out of its main position? */
;;;586          /* yes; move colliding node into free position */
;;;587          while (othern + gnext(othern) != mp)  /* find previous */
;;;588            othern += gnext(othern);
;;;589          gnext(othern) = cast_int(f - othern);  /* rechain to point to 'f' */
;;;590          *f = *mp;  /* copy colliding node into free pos. (mp->next also goes) */
;;;591          if (gnext(mp) != 0) {
;;;592            gnext(f) += cast_int(mp - f);  /* correct 'next' */
;;;593            gnext(mp) = 0;  /* now 'mp' is free */
;;;594          }
;;;595          setempty(gval(mp));
;;;596        }
;;;597        else {  /* colliding node is in its own main position */
;;;598          /* new node will go into free position */
;;;599          if (gnext(mp) != 0)
;;;600            gnext(f) = cast_int((mp + gnext(mp)) - f);  /* chain new position */
;;;601          else lua_assert(gnext(f) == 0);
;;;602          gnext(mp) = cast_int(f - mp);
;;;603          mp = f;
;;;604        }
;;;605      }
;;;606      setnodekey(L, mp, key);
;;;607      luaC_barrierback(L, obj2gco(t), key);
;;;608      lua_assert(isempty(gval(mp)));
;;;609      return gval(mp);
;;;610    }
000094  b007              ADD      sp,sp,#0x1c
000096  e8bd83f0          POP      {r4-r9,pc}
                  |L19.154|
00009a  7a61              LDRB     r1,[r4,#9]            ;584
00009c  f1040210          ADD      r2,r4,#0x10           ;584
0000a0  4640              MOV      r0,r8                 ;584
0000a2  f7fffffe          BL       mainposition
0000a6  4607              MOV      r7,r0                 ;584
0000a8  42a7              CMP      r7,r4                 ;585
0000aa  d024              BEQ      |L19.246|
0000ac  e004              B        |L19.184|
                  |L19.174|
0000ae  68f8              LDR      r0,[r7,#0xc]          ;588
0000b0  eb000040          ADD      r0,r0,r0,LSL #1       ;588
0000b4  eb0707c0          ADD      r7,r7,r0,LSL #3       ;588
                  |L19.184|
0000b8  68f8              LDR      r0,[r7,#0xc]          ;587
0000ba  eb000040          ADD      r0,r0,r0,LSL #1       ;587
0000be  eb0700c0          ADD      r0,r7,r0,LSL #3       ;587
0000c2  42a0              CMP      r0,r4                 ;587
0000c4  d1f3              BNE      |L19.174|
0000c6  1bf0              SUBS     r0,r6,r7              ;589
0000c8  2118              MOVS     r1,#0x18              ;589
0000ca  fb90f0f1          SDIV     r0,r0,r1              ;589
0000ce  60f8              STR      r0,[r7,#0xc]          ;589
0000d0  2218              MOVS     r2,#0x18              ;590
0000d2  4621              MOV      r1,r4                 ;590
0000d4  4630              MOV      r0,r6                 ;590
0000d6  f7fffffe          BL       __aeabi_memcpy4
0000da  68e0              LDR      r0,[r4,#0xc]          ;591
0000dc  b140              CBZ      r0,|L19.240|
0000de  1ba0              SUBS     r0,r4,r6              ;592
0000e0  2118              MOVS     r1,#0x18              ;592
0000e2  fb90f0f1          SDIV     r0,r0,r1              ;592
0000e6  68f1              LDR      r1,[r6,#0xc]          ;592
0000e8  4408              ADD      r0,r0,r1              ;592
0000ea  60f0              STR      r0,[r6,#0xc]          ;592
0000ec  2000              MOVS     r0,#0                 ;593
0000ee  60e0              STR      r0,[r4,#0xc]          ;593
                  |L19.240|
0000f0  2010              MOVS     r0,#0x10              ;595
0000f2  7220              STRB     r0,[r4,#8]            ;595
0000f4  e013              B        |L19.286|
                  |L19.246|
0000f6  68e0              LDR      r0,[r4,#0xc]          ;599
0000f8  b150              CBZ      r0,|L19.272|
0000fa  68e0              LDR      r0,[r4,#0xc]          ;600
0000fc  eb000040          ADD      r0,r0,r0,LSL #1       ;600
000100  eb0400c0          ADD      r0,r4,r0,LSL #3       ;600
000104  1b80              SUBS     r0,r0,r6              ;600
000106  2118              MOVS     r1,#0x18              ;600
000108  fb90f0f1          SDIV     r0,r0,r1              ;600
00010c  60f0              STR      r0,[r6,#0xc]          ;600
00010e  e000              B        |L19.274|
                  |L19.272|
000110  bf00              NOP                            ;601
                  |L19.274|
000112  1b30              SUBS     r0,r6,r4              ;602
000114  2118              MOVS     r1,#0x18              ;602
000116  fb90f0f1          SDIV     r0,r0,r1              ;602
00011a  60e0              STR      r0,[r4,#0xc]          ;602
00011c  4634              MOV      r4,r6                 ;603
                  |L19.286|
00011e  bf00              NOP                            ;605
                  |L19.288|
000120  4620              MOV      r0,r4                 ;606
000122  4629              MOV      r1,r5                 ;606
000124  e9d12300          LDRD     r2,r3,[r1,#0]         ;606
000128  e9c02304          STRD     r2,r3,[r0,#0x10]      ;606
00012c  7a0a              LDRB     r2,[r1,#8]            ;606
00012e  7242              STRB     r2,[r0,#9]            ;606
000130  7a28              LDRB     r0,[r5,#8]            ;607
000132  f0000040          AND      r0,r0,#0x40           ;607
000136  b170              CBZ      r0,|L19.342|
000138  f8980005          LDRB     r0,[r8,#5]            ;607
00013c  f0000020          AND      r0,r0,#0x20           ;607
000140  b148              CBZ      r0,|L19.342|
000142  6828              LDR      r0,[r5,#0]            ;607
000144  7940              LDRB     r0,[r0,#5]            ;607
000146  f0000018          AND      r0,r0,#0x18           ;607
00014a  b120              CBZ      r0,|L19.342|
00014c  4641              MOV      r1,r8                 ;607
00014e  4648              MOV      r0,r9                 ;607
000150  f7fffffe          BL       luaC_barrierback_
000154  e000              B        |L19.344|
                  |L19.342|
000156  bf00              NOP                            ;607
                  |L19.344|
000158  4620              MOV      r0,r4                 ;609
00015a  e79b              B        |L19.148|
;;;611    
                          ENDP

                  |L19.348|
00015c  7461626c          DCB      "table index is nil",0
000160  6520696e
000164  64657820
000168  6973206e
00016c  696c00  
00016f  00                DCB      0
                  |L19.368|
000170  7461626c          DCB      "table index is NaN",0
000174  6520696e
000178  64657820
00017c  6973204e
000180  614e00  
000183  00                DCB      0

                          AREA ||i.luaH_next||, CODE, READONLY, ALIGN=1

                  luaH_next PROC
;;;246    
;;;247    int luaH_next (lua_State *L, Table *t, StkId key) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;248      unsigned int i = findindex(L, t, s2v(key));  /* find original element */
00000a  462a              MOV      r2,r5
00000c  4631              MOV      r1,r6
00000e  4638              MOV      r0,r7
000010  f7fffffe          BL       findindex
000014  4604              MOV      r4,r0
;;;249      for (; i < t->sizearray; i++) {  /* try first array part */
000016  e01b              B        |L20.80|
                  |L20.24|
;;;250        if (!isempty(&t->array[i])) {  /* a non-empty entry? */
000018  68f0              LDR      r0,[r6,#0xc]
00001a  eb001004          ADD      r0,r0,r4,LSL #4
00001e  7a00              LDRB     r0,[r0,#8]
000020  f000000f          AND      r0,r0,#0xf
000024  b198              CBZ      r0,|L20.78|
;;;251          setivalue(s2v(key), i + 1);
000026  4628              MOV      r0,r5
000028  1c61              ADDS     r1,r4,#1
00002a  2200              MOVS     r2,#0
00002c  e9c01200          STRD     r1,r2,[r0,#0]
000030  2123              MOVS     r1,#0x23
000032  7201              STRB     r1,[r0,#8]
;;;252          setobj2s(L, key + 1, &t->array[i]);
000034  3010              ADDS     r0,r0,#0x10
000036  68f2              LDR      r2,[r6,#0xc]
000038  eb021104          ADD      r1,r2,r4,LSL #4
00003c  e9d12300          LDRD     r2,r3,[r1,#0]
000040  e9c02300          STRD     r2,r3,[r0,#0]
000044  7a0a              LDRB     r2,[r1,#8]
000046  7202              STRB     r2,[r0,#8]
;;;253          return 1;
000048  2001              MOVS     r0,#1
                  |L20.74|
;;;254        }
;;;255      }
;;;256      for (i -= t->sizearray; cast_int(i) < sizenode(t); i++) {  /* hash part */
;;;257        if (!isempty(gval(gnode(t, i)))) {  /* a non-empty entry? */
;;;258          Node *n = gnode(t, i);
;;;259          getnodekey(L, s2v(key), n);
;;;260          setobj2s(L, key + 1, gval(n));
;;;261          return 1;
;;;262        }
;;;263      }
;;;264      return 0;  /* no more elements */
;;;265    }
00004a  e8bd81f0          POP      {r4-r8,pc}
                  |L20.78|
00004e  1c64              ADDS     r4,r4,#1              ;249
                  |L20.80|
000050  68b0              LDR      r0,[r6,#8]            ;249
000052  42a0              CMP      r0,r4                 ;249
000054  d8e0              BHI      |L20.24|
000056  68b0              LDR      r0,[r6,#8]            ;256
000058  1a24              SUBS     r4,r4,r0              ;256
00005a  e020              B        |L20.158|
                  |L20.92|
00005c  eb040144          ADD      r1,r4,r4,LSL #1       ;257
000060  6930              LDR      r0,[r6,#0x10]         ;257
000062  eb0000c1          ADD      r0,r0,r1,LSL #3       ;257
000066  7a00              LDRB     r0,[r0,#8]            ;257
000068  f000000f          AND      r0,r0,#0xf            ;257
00006c  b1b0              CBZ      r0,|L20.156|
00006e  eb040244          ADD      r2,r4,r4,LSL #1       ;258
000072  6930              LDR      r0,[r6,#0x10]         ;258
000074  eb0001c2          ADD      r1,r0,r2,LSL #3       ;258
000078  4628              MOV      r0,r5                 ;259
00007a  460a              MOV      r2,r1                 ;259
00007c  e9d23c04          LDRD     r3,r12,[r2,#0x10]     ;259
000080  e9c03c00          STRD     r3,r12,[r0,#0]        ;259
000084  7a53              LDRB     r3,[r2,#9]            ;259
000086  7203              STRB     r3,[r0,#8]            ;259
000088  3010              ADDS     r0,r0,#0x10           ;260
00008a  bf00              NOP                            ;260
00008c  e9d23c00          LDRD     r3,r12,[r2,#0]        ;260
000090  e9c03c00          STRD     r3,r12,[r0,#0]        ;260
000094  7a13              LDRB     r3,[r2,#8]            ;260
000096  7203              STRB     r3,[r0,#8]            ;260
000098  2001              MOVS     r0,#1                 ;261
00009a  e7d6              B        |L20.74|
                  |L20.156|
00009c  1c64              ADDS     r4,r4,#1              ;256
                  |L20.158|
00009e  79f1              LDRB     r1,[r6,#7]            ;256
0000a0  2001              MOVS     r0,#1                 ;256
0000a2  4088              LSLS     r0,r0,r1              ;256
0000a4  42a0              CMP      r0,r4                 ;256
0000a6  dcd9              BGT      |L20.92|
0000a8  2000              MOVS     r0,#0                 ;264
0000aa  e7ce              B        |L20.74|
;;;266    
                          ENDP


                          AREA ||i.luaH_resize||, CODE, READONLY, ALIGN=1

                  luaH_resize PROC
;;;448    */
;;;449    void luaH_resize (lua_State *L, Table *t, unsigned int newasize,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;450                                              unsigned int nhsize) {
000004  b08a              SUB      sp,sp,#0x28
000006  4682              MOV      r10,r0
000008  460c              MOV      r4,r1
00000a  4616              MOV      r6,r2
00000c  4699              MOV      r9,r3
;;;451      unsigned int i;
;;;452      Table newt;  /* to keep the new hash part */
;;;453      unsigned int oldasize = t->sizearray;
00000e  68a7              LDR      r7,[r4,#8]
;;;454      TValue *newarray;
;;;455      /* create new hash part with appropriate size into 'newt' */
;;;456      setnodevector(L, &newt, nhsize);
000010  464a              MOV      r2,r9
000012  a902              ADD      r1,sp,#8
000014  4650              MOV      r0,r10
000016  f7fffffe          BL       setnodevector
;;;457      if (newasize < oldasize) {  /* will array shrink? */
00001a  42be              CMP      r6,r7
00001c  d21f              BCS      |L21.94|
;;;458        t->sizearray = newasize;  /* pretend array has new size... */
00001e  60a6              STR      r6,[r4,#8]
;;;459        exchangehashpart(t, &newt);  /* and new hash */
000020  a902              ADD      r1,sp,#8
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       exchangehashpart
;;;460        /* re-insert into the new hash the elements from vanishing slice */
;;;461        for (i = newasize; i < oldasize; i++) {
000028  4635              MOV      r5,r6
00002a  e011              B        |L21.80|
                  |L21.44|
;;;462          if (!isempty(&t->array[i]))
00002c  68e0              LDR      r0,[r4,#0xc]
00002e  eb001005          ADD      r0,r0,r5,LSL #4
000032  7a00              LDRB     r0,[r0,#8]
000034  f000000f          AND      r0,r0,#0xf
000038  b148              CBZ      r0,|L21.78|
;;;463            luaH_setint(L, t, i + 1, &t->array[i]);
00003a  68e0              LDR      r0,[r4,#0xc]
00003c  eb001005          ADD      r0,r0,r5,LSL #4
000040  1c6a              ADDS     r2,r5,#1
000042  2300              MOVS     r3,#0
000044  4621              MOV      r1,r4
000046  9000              STR      r0,[sp,#0]
000048  4650              MOV      r0,r10
00004a  f7fffffe          BL       luaH_setint
                  |L21.78|
00004e  1c6d              ADDS     r5,r5,#1              ;461
                  |L21.80|
000050  42bd              CMP      r5,r7                 ;461
000052  d3eb              BCC      |L21.44|
;;;464        }
;;;465        t->sizearray = oldasize;  /* restore current size... */
000054  60a7              STR      r7,[r4,#8]
;;;466        exchangehashpart(t, &newt);  /* and hash (in case of errors) */
000056  a902              ADD      r1,sp,#8
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       exchangehashpart
                  |L21.94|
;;;467      }
;;;468      /* allocate new array */
;;;469      newarray = luaM_reallocvector(L, t->array, oldasize, newasize, TValue);
00005e  0133              LSLS     r3,r6,#4
000060  013a              LSLS     r2,r7,#4
000062  4650              MOV      r0,r10
000064  68e1              LDR      r1,[r4,#0xc]
000066  f7fffffe          BL       luaM_realloc_
00006a  4680              MOV      r8,r0
;;;470      if (newarray == NULL && newasize > 0) {  /* allocation failed? */
00006c  f1b80f00          CMP      r8,#0
000070  d108              BNE      |L21.132|
000072  b13e              CBZ      r6,|L21.132|
;;;471        freehash(L, &newt);  /* release new hash part */
000074  a902              ADD      r1,sp,#8
000076  4650              MOV      r0,r10
000078  f7fffffe          BL       freehash
;;;472        luaM_error(L);  /* raise error (with array unchanged) */
00007c  2104              MOVS     r1,#4
00007e  4650              MOV      r0,r10
000080  f7fffffe          BL       luaD_throw
                  |L21.132|
;;;473      }
;;;474      /* allocation ok; initialize new part of the array */
;;;475      exchangehashpart(t, &newt);  /* 't' has the new hash ('newt' has the old) */
000084  a902              ADD      r1,sp,#8
000086  4620              MOV      r0,r4
000088  f7fffffe          BL       exchangehashpart
;;;476      t->array = newarray;  /* set new array part */
00008c  f8c4800c          STR      r8,[r4,#0xc]
;;;477      t->sizearray = newasize;
000090  60a6              STR      r6,[r4,#8]
;;;478      for (i = oldasize; i < newasize; i++)  /* clear new slice of the array */
000092  463d              MOV      r5,r7
000094  e005              B        |L21.162|
                  |L21.150|
;;;479         setempty(&t->array[i]);
000096  2010              MOVS     r0,#0x10
000098  68e1              LDR      r1,[r4,#0xc]
00009a  eb011105          ADD      r1,r1,r5,LSL #4
00009e  7208              STRB     r0,[r1,#8]
0000a0  1c6d              ADDS     r5,r5,#1              ;478
                  |L21.162|
0000a2  42b5              CMP      r5,r6                 ;478
0000a4  d3f7              BCC      |L21.150|
;;;480      /* re-insert elements from old hash part into new parts */
;;;481      reinsert(L, &newt, t);  /* 'newt' now has the old hash */
0000a6  4622              MOV      r2,r4
0000a8  a902              ADD      r1,sp,#8
0000aa  4650              MOV      r0,r10
0000ac  f7fffffe          BL       reinsert
;;;482      freehash(L, &newt);  /* free old hash part */
0000b0  a902              ADD      r1,sp,#8
0000b2  4650              MOV      r0,r10
0000b4  f7fffffe          BL       freehash
;;;483    }
0000b8  b00a              ADD      sp,sp,#0x28
0000ba  e8bd87f0          POP      {r4-r10,pc}
;;;484    
                          ENDP


                          AREA ||i.luaH_resizearray||, CODE, READONLY, ALIGN=1

                  luaH_resizearray PROC
;;;485    
;;;486    void luaH_resizearray (lua_State *L, Table *t, unsigned int nasize) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
;;;487      int nsize = allocsizenode(t);
00000a  6960              LDR      r0,[r4,#0x14]
00000c  b908              CBNZ     r0,|L22.18|
00000e  2000              MOVS     r0,#0
000010  e002              B        |L22.24|
                  |L22.18|
000012  79e1              LDRB     r1,[r4,#7]
000014  2001              MOVS     r0,#1
000016  4088              LSLS     r0,r0,r1
                  |L22.24|
000018  4607              MOV      r7,r0
;;;488      luaH_resize(L, t, nasize, nsize);
00001a  463b              MOV      r3,r7
00001c  4632              MOV      r2,r6
00001e  4621              MOV      r1,r4
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       luaH_resize
;;;489    }
000026  e8bd81f0          POP      {r4-r8,pc}
;;;490    
                          ENDP


                          AREA ||i.luaH_set||, CODE, READONLY, ALIGN=2

                  luaH_set PROC
;;;689    */
;;;690    TValue *luaH_set (lua_State *L, Table *t, const TValue *key) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;691      const TValue *p = luaH_get(t, key);
00000a  4629              MOV      r1,r5
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       luaH_get
000012  4606              MOV      r6,r0
;;;692      if (p != luaH_emptyobject)
000014  4805              LDR      r0,|L23.44|
000016  4286              CMP      r6,r0
000018  d002              BEQ      |L23.32|
;;;693        return cast(TValue *, p);
00001a  4630              MOV      r0,r6
                  |L23.28|
;;;694      else return luaH_newkey(L, t, key);
;;;695    }
00001c  e8bd81f0          POP      {r4-r8,pc}
                  |L23.32|
000020  462a              MOV      r2,r5                 ;694
000022  4621              MOV      r1,r4                 ;694
000024  4638              MOV      r0,r7                 ;694
000026  f7fffffe          BL       luaH_newkey
00002a  e7f7              B        |L23.28|
;;;696    
                          ENDP

                  |L23.44|
                          DCD      luaH_emptyobject_

                          AREA ||i.luaH_setint||, CODE, READONLY, ALIGN=2

                  luaH_setint PROC
;;;697    
;;;698    void luaH_setint (lua_State *L, Table *t, lua_Integer key, TValue *value) {
000000  e92d47ff          PUSH     {r0-r10,lr}
000004  4682              MOV      r10,r0
000006  4688              MOV      r8,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
00000c  9f0c              LDR      r7,[sp,#0x30]
;;;699      const TValue *p = luaH_getint(t, key);
00000e  462a              MOV      r2,r5
000010  4633              MOV      r3,r6
000012  4640              MOV      r0,r8
000014  f7fffffe          BL       luaH_getint
000018  4681              MOV      r9,r0
;;;700      TValue *cell;
;;;701      if (p != luaH_emptyobject)
00001a  480d              LDR      r0,|L24.80|
00001c  4581              CMP      r9,r0
00001e  d001              BEQ      |L24.36|
;;;702        cell = cast(TValue *, p);
000020  464c              MOV      r4,r9
000022  e00b              B        |L24.60|
                  |L24.36|
;;;703      else {
;;;704        TValue k;
;;;705        setivalue(&k, key);
000024  4668              MOV      r0,sp
000026  e9c05600          STRD     r5,r6,[r0,#0]
00002a  2123              MOVS     r1,#0x23
00002c  7201              STRB     r1,[r0,#8]
;;;706        cell = luaH_newkey(L, t, &k);
00002e  466a              MOV      r2,sp
000030  4641              MOV      r1,r8
000032  4650              MOV      r0,r10
000034  f7fffffe          BL       luaH_newkey
000038  4604              MOV      r4,r0
;;;707      }
00003a  bf00              NOP      
                  |L24.60|
;;;708      setobj2t(L, cell, value);
00003c  4620              MOV      r0,r4
00003e  4639              MOV      r1,r7
000040  e9d12300          LDRD     r2,r3,[r1,#0]
000044  e9c02300          STRD     r2,r3,[r0,#0]
000048  7a0a              LDRB     r2,[r1,#8]
00004a  7202              STRB     r2,[r0,#8]
;;;709    }
00004c  e8bd87ff          POP      {r0-r10,pc}
;;;710    
                          ENDP

                  |L24.80|
                          DCD      luaH_emptyobject_

                          AREA ||i.mainposition||, CODE, READONLY, ALIGN=1

                  mainposition PROC
;;;134    */
;;;135    static Node *mainposition (const Table *t, int ktt, const Value *kvl) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;136      switch (withvariant(ktt)) {
000008  f006003f          AND      r0,r6,#0x3f
00000c  2814              CMP      r0,#0x14
00000e  d030              BEQ      |L25.114|
000010  dc06              BGT      |L25.32|
000012  2801              CMP      r0,#1
000014  d048              BEQ      |L25.168|
000016  2802              CMP      r0,#2
000018  d052              BEQ      |L25.192|
00001a  2813              CMP      r0,#0x13
00001c  d173              BNE      |L25.262|
00001e  e012              B        |L25.70|
                  |L25.32|
000020  2823              CMP      r0,#0x23
000022  d004              BEQ      |L25.46|
000024  2824              CMP      r0,#0x24
000026  d031              BEQ      |L25.140|
000028  2826              CMP      r0,#0x26
00002a  d16c              BNE      |L25.262|
00002c  e059              B        |L25.226|
                  |L25.46|
;;;137        case LUA_TNUMINT:
;;;138          return hashint(t, ivalueraw(*kvl));
00002e  79e2              LDRB     r2,[r4,#7]
000030  2001              MOVS     r0,#1
000032  4090              LSLS     r0,r0,r2
000034  1e40              SUBS     r0,r0,#1
000036  6829              LDR      r1,[r5,#0]
000038  4001              ANDS     r1,r1,r0
00003a  eb010041          ADD      r0,r1,r1,LSL #1
00003e  6921              LDR      r1,[r4,#0x10]
000040  eb0100c0          ADD      r0,r1,r0,LSL #3
                  |L25.68|
;;;139        case LUA_TNUMFLT:
;;;140          return hashmod(t, l_hashfloat(fltvalueraw(*kvl)));
;;;141        case LUA_TSHRSTR:
;;;142          return hashstr(t, tsvalueraw(*kvl));
;;;143        case LUA_TLNGSTR:
;;;144          return hashpow2(t, luaS_hashlongstr(tsvalueraw(*kvl)));
;;;145        case LUA_TBOOLEAN:
;;;146          return hashboolean(t, bvalueraw(*kvl));
;;;147        case LUA_TLIGHTUSERDATA:
;;;148          return hashpointer(t, pvalueraw(*kvl));
;;;149        case LUA_TLCF:
;;;150          return hashpointer(t, fvalueraw(*kvl));
;;;151        default:
;;;152          return hashpointer(t, gcvalueraw(*kvl));
;;;153      }
;;;154    }
000044  bd70              POP      {r4-r6,pc}
                  |L25.70|
000046  e9d52100          LDRD     r2,r1,[r5,#0]         ;140
00004a  4610              MOV      r0,r2                 ;140
00004c  f7fffffe          BL       l_hashfloat
000050  4601              MOV      r1,r0                 ;140
000052  79e2              LDRB     r2,[r4,#7]            ;140
000054  2001              MOVS     r0,#1                 ;140
000056  4090              LSLS     r0,r0,r2              ;140
000058  1e40              SUBS     r0,r0,#1              ;140
00005a  f0400001          ORR      r0,r0,#1              ;140
00005e  fb91f2f0          SDIV     r2,r1,r0              ;140
000062  fb001012          MLS      r0,r0,r2,r1           ;140
000066  eb000040          ADD      r0,r0,r0,LSL #1       ;140
00006a  6921              LDR      r1,[r4,#0x10]         ;140
00006c  eb0100c0          ADD      r0,r1,r0,LSL #3       ;140
000070  e7e8              B        |L25.68|
                  |L25.114|
000072  6828              LDR      r0,[r5,#0]            ;142
000074  79e2              LDRB     r2,[r4,#7]            ;142
000076  6881              LDR      r1,[r0,#8]            ;142
000078  2001              MOVS     r0,#1                 ;142
00007a  4090              LSLS     r0,r0,r2              ;142
00007c  1e40              SUBS     r0,r0,#1              ;142
00007e  4001              ANDS     r1,r1,r0              ;142
000080  eb010041          ADD      r0,r1,r1,LSL #1       ;142
000084  6921              LDR      r1,[r4,#0x10]         ;142
000086  eb0100c0          ADD      r0,r1,r0,LSL #3       ;142
00008a  e7db              B        |L25.68|
                  |L25.140|
00008c  6828              LDR      r0,[r5,#0]            ;144
00008e  f7fffffe          BL       luaS_hashlongstr
000092  79e2              LDRB     r2,[r4,#7]            ;144
000094  2101              MOVS     r1,#1                 ;144
000096  4091              LSLS     r1,r1,r2              ;144
000098  1e49              SUBS     r1,r1,#1              ;144
00009a  4008              ANDS     r0,r0,r1              ;144
00009c  eb000040          ADD      r0,r0,r0,LSL #1       ;144
0000a0  6921              LDR      r1,[r4,#0x10]         ;144
0000a2  eb0100c0          ADD      r0,r1,r0,LSL #3       ;144
0000a6  e7cd              B        |L25.68|
                  |L25.168|
0000a8  79e2              LDRB     r2,[r4,#7]            ;146
0000aa  2001              MOVS     r0,#1                 ;146
0000ac  4090              LSLS     r0,r0,r2              ;146
0000ae  1e40              SUBS     r0,r0,#1              ;146
0000b0  6829              LDR      r1,[r5,#0]            ;146
0000b2  4001              ANDS     r1,r1,r0              ;146
0000b4  eb010041          ADD      r0,r1,r1,LSL #1       ;146
0000b8  6921              LDR      r1,[r4,#0x10]         ;146
0000ba  eb0100c0          ADD      r0,r1,r0,LSL #3       ;146
0000be  e7c1              B        |L25.68|
                  |L25.192|
0000c0  79e2              LDRB     r2,[r4,#7]            ;148
0000c2  2001              MOVS     r0,#1                 ;148
0000c4  4090              LSLS     r0,r0,r2              ;148
0000c6  1e40              SUBS     r0,r0,#1              ;148
0000c8  f0400001          ORR      r0,r0,#1              ;148
0000cc  6829              LDR      r1,[r5,#0]            ;148
0000ce  fbb1f2f0          UDIV     r2,r1,r0              ;148
0000d2  fb001012          MLS      r0,r0,r2,r1           ;148
0000d6  eb000040          ADD      r0,r0,r0,LSL #1       ;148
0000da  6921              LDR      r1,[r4,#0x10]         ;148
0000dc  eb0100c0          ADD      r0,r1,r0,LSL #3       ;148
0000e0  e7b0              B        |L25.68|
                  |L25.226|
0000e2  79e2              LDRB     r2,[r4,#7]            ;150
0000e4  2001              MOVS     r0,#1                 ;150
0000e6  4090              LSLS     r0,r0,r2              ;150
0000e8  1e40              SUBS     r0,r0,#1              ;150
0000ea  f0400001          ORR      r0,r0,#1              ;150
0000ee  6829              LDR      r1,[r5,#0]            ;150
0000f0  fbb1f2f0          UDIV     r2,r1,r0              ;150
0000f4  fb001012          MLS      r0,r0,r2,r1           ;150
0000f8  eb000040          ADD      r0,r0,r0,LSL #1       ;150
0000fc  6921              LDR      r1,[r4,#0x10]         ;150
0000fe  eb0100c0          ADD      r0,r1,r0,LSL #3       ;150
000102  e79f              B        |L25.68|
000104  e7ff              B        |L25.262|
                  |L25.262|
000106  79e2              LDRB     r2,[r4,#7]            ;152
000108  2001              MOVS     r0,#1                 ;152
00010a  4090              LSLS     r0,r0,r2              ;152
00010c  1e40              SUBS     r0,r0,#1              ;152
00010e  f0400001          ORR      r0,r0,#1              ;152
000112  6829              LDR      r1,[r5,#0]            ;152
000114  fbb1f2f0          UDIV     r2,r1,r0              ;152
000118  fb001012          MLS      r0,r0,r2,r1           ;152
00011c  eb000040          ADD      r0,r0,r0,LSL #1       ;152
000120  6921              LDR      r1,[r4,#0x10]         ;152
000122  eb0100c0          ADD      r0,r1,r0,LSL #3       ;152
000126  e78d              B        |L25.68|
;;;155    
                          ENDP


                          AREA ||i.mainpositionTV||, CODE, READONLY, ALIGN=1

                  mainpositionTV PROC
;;;156    
;;;157    static Node *mainpositionTV (const Table *t, const TValue *key) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;158      return mainposition(t, rawtt(key), valraw(key));
000006  7a21              LDRB     r1,[r4,#8]
000008  4622              MOV      r2,r4
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       mainposition
;;;159    }
000010  bd70              POP      {r4-r6,pc}
;;;160    
                          ENDP


                          AREA ||i.numusearray||, CODE, READONLY, ALIGN=1

                  numusearray PROC
;;;325    */
;;;326    static unsigned int numusearray (const Table *t, unsigned int *nums) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4602              MOV      r2,r0
000006  460c              MOV      r4,r1
;;;327      int lg;
;;;328      unsigned int ttlg;  /* 2^lg */
;;;329      unsigned int ause = 0;  /* summation of 'nums' */
000008  2700              MOVS     r7,#0
;;;330      unsigned int i = 1;  /* count to traverse all array keys */
00000a  2301              MOVS     r3,#1
;;;331      /* traverse each slice */
;;;332      for (lg = 0, ttlg = 1; lg <= MAXABITS; lg++, ttlg *= 2) {
00000c  2100              MOVS     r1,#0
00000e  2501              MOVS     r5,#1
000010  e023              B        |L27.90|
                  |L27.18|
;;;333        unsigned int lc = 0;  /* counter */
000012  2000              MOVS     r0,#0
;;;334        unsigned int lim = ttlg;
000014  462e              MOV      r6,r5
;;;335        if (lim > t->sizearray) {
000016  f8d2c008          LDR      r12,[r2,#8]
00001a  45b4              CMP      r12,r6
00001c  d203              BCS      |L27.38|
;;;336          lim = t->sizearray;  /* adjust upper limit */
00001e  6896              LDR      r6,[r2,#8]
;;;337          if (i > lim)
000020  42b3              CMP      r3,r6
000022  d900              BLS      |L27.38|
;;;338            break;  /* no more elements to count */
000024  e01b              B        |L27.94|
                  |L27.38|
;;;339        }
;;;340        /* count elements in range (2^(lg - 1), 2^lg] */
;;;341        for (; i <= lim; i++) {
000026  e00e              B        |L27.70|
                  |L27.40|
;;;342          if (!isempty(&t->array[i-1]))
000028  f1a30c01          SUB      r12,r3,#1
00002c  f8d2800c          LDR      r8,[r2,#0xc]
000030  eb081c0c          ADD      r12,r8,r12,LSL #4
000034  f89cc008          LDRB     r12,[r12,#8]
000038  f00c0c0f          AND      r12,r12,#0xf
00003c  f1bc0f00          CMP      r12,#0
000040  d000              BEQ      |L27.68|
;;;343            lc++;
000042  1c40              ADDS     r0,r0,#1
                  |L27.68|
000044  1c5b              ADDS     r3,r3,#1              ;341
                  |L27.70|
000046  42b3              CMP      r3,r6                 ;341
000048  d9ee              BLS      |L27.40|
;;;344        }
;;;345        nums[lg] += lc;
00004a  f854c021          LDR      r12,[r4,r1,LSL #2]
00004e  4484              ADD      r12,r12,r0
000050  f844c021          STR      r12,[r4,r1,LSL #2]
;;;346        ause += lc;
000054  4407              ADD      r7,r7,r0
000056  1c49              ADDS     r1,r1,#1              ;332
000058  006d              LSLS     r5,r5,#1              ;332
                  |L27.90|
00005a  291f              CMP      r1,#0x1f              ;332
00005c  ddd9              BLE      |L27.18|
                  |L27.94|
00005e  bf00              NOP                            ;338
;;;347      }
;;;348      return ause;
000060  4638              MOV      r0,r7
;;;349    }
000062  e8bd81f0          POP      {r4-r8,pc}
;;;350    
                          ENDP


                          AREA ||i.numusehash||, CODE, READONLY, ALIGN=1

                  numusehash PROC
;;;351    
;;;352    static int numusehash (const Table *t, unsigned int *nums, unsigned int *pna) {
000000  e92d5ff0          PUSH     {r4-r12,lr}
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;353      int totaluse = 0;  /* total number of elements */
00000a  f04f0800          MOV      r8,#0
;;;354      int ause = 0;  /* elements added to 'nums' (can go to array part) */
00000e  46c1              MOV      r9,r8
;;;355      int i = sizenode(t);
000010  79e1              LDRB     r1,[r4,#7]
000012  2001              MOVS     r0,#1
000014  fa00fa01          LSL      r10,r0,r1
;;;356      while (i--) {
000018  e015              B        |L28.70|
                  |L28.26|
;;;357        Node *n = &t->node[i];
00001a  eb0a014a          ADD      r1,r10,r10,LSL #1
00001e  6920              LDR      r0,[r4,#0x10]
000020  eb0006c1          ADD      r6,r0,r1,LSL #3
;;;358        if (!isempty(gval(n))) {
000024  7a30              LDRB     r0,[r6,#8]
000026  f000000f          AND      r0,r0,#0xf
00002a  b158              CBZ      r0,|L28.68|
;;;359          if (keyisinteger(n))
00002c  7a70              LDRB     r0,[r6,#9]
00002e  2823              CMP      r0,#0x23
000030  d106              BNE      |L28.64|
;;;360            ause += countint(keyival(n), nums);
000032  463a              MOV      r2,r7
000034  e9d6b104          LDRD     r11,r1,[r6,#0x10]
000038  4658              MOV      r0,r11
00003a  f7fffffe          BL       countint
00003e  4481              ADD      r9,r9,r0
                  |L28.64|
;;;361          totaluse++;
000040  f1080801          ADD      r8,r8,#1
                  |L28.68|
;;;362        }
;;;363      }
000044  bf00              NOP      
                  |L28.70|
000046  f1ba0000          SUBS     r0,r10,#0             ;356
00004a  f1aa0a01          SUB      r10,r10,#1            ;356
00004e  d1e4              BNE      |L28.26|
;;;364      *pna += ause;
000050  6828              LDR      r0,[r5,#0]
000052  4448              ADD      r0,r0,r9
000054  6028              STR      r0,[r5,#0]
;;;365      return totaluse;
000056  4640              MOV      r0,r8
;;;366    }
000058  e8bd9ff0          POP      {r4-r12,pc}
;;;367    
                          ENDP


                          AREA ||i.rehash||, CODE, READONLY, ALIGN=1

                  rehash PROC
;;;493    */
;;;494    static void rehash (lua_State *L, Table *t, const TValue *ek) {
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b0a1              SUB      sp,sp,#0x84
000006  4682              MOV      r10,r0
000008  460f              MOV      r7,r1
00000a  4614              MOV      r4,r2
;;;495      unsigned int asize;  /* optimal size for array part */
;;;496      unsigned int na;  /* number of keys in the array part */
;;;497      unsigned int nums[MAXABITS + 1];
;;;498      int i;
;;;499      int totaluse;
;;;500      for (i = 0; i <= MAXABITS; i++) nums[i] = 0;  /* reset counts */
00000c  2500              MOVS     r5,#0
00000e  e003              B        |L29.24|
                  |L29.16|
000010  2000              MOVS     r0,#0
000012  f84d0025          STR      r0,[sp,r5,LSL #2]
000016  1c6d              ADDS     r5,r5,#1
                  |L29.24|
000018  2d1f              CMP      r5,#0x1f
00001a  ddf9              BLE      |L29.16|
;;;501      na = numusearray(t, nums);  /* count keys in array part */
00001c  4669              MOV      r1,sp
00001e  4638              MOV      r0,r7
000020  f7fffffe          BL       numusearray
000024  9020              STR      r0,[sp,#0x80]
;;;502      totaluse = na;  /* all those keys are integer keys */
000026  9e20              LDR      r6,[sp,#0x80]
;;;503      totaluse += numusehash(t, nums, &na);  /* count keys in hash part */
000028  aa20              ADD      r2,sp,#0x80
00002a  4669              MOV      r1,sp
00002c  4638              MOV      r0,r7
00002e  f7fffffe          BL       numusehash
000032  4406              ADD      r6,r6,r0
;;;504      /* count extra key */
;;;505      if (ttisinteger(ek))
000034  7a20              LDRB     r0,[r4,#8]
000036  2823              CMP      r0,#0x23
000038  d108              BNE      |L29.76|
;;;506        na += countint(ivalue(ek), nums);
00003a  466a              MOV      r2,sp
00003c  e9d48100          LDRD     r8,r1,[r4,#0]
000040  4640              MOV      r0,r8
000042  f7fffffe          BL       countint
000046  9920              LDR      r1,[sp,#0x80]
000048  4408              ADD      r0,r0,r1
00004a  9020              STR      r0,[sp,#0x80]
                  |L29.76|
;;;507      totaluse++;
00004c  1c76              ADDS     r6,r6,#1
;;;508      /* compute new size for array part */
;;;509      asize = computesizes(nums, &na);
00004e  a920              ADD      r1,sp,#0x80
000050  4668              MOV      r0,sp
000052  f7fffffe          BL       computesizes
000056  4683              MOV      r11,r0
;;;510      /* resize the table to new computed sizes */
;;;511      luaH_resize(L, t, asize, totaluse - na);
000058  9820              LDR      r0,[sp,#0x80]
00005a  1a33              SUBS     r3,r6,r0
00005c  465a              MOV      r2,r11
00005e  4639              MOV      r1,r7
000060  4650              MOV      r0,r10
000062  f7fffffe          BL       luaH_resize
;;;512    }
000066  b021              ADD      sp,sp,#0x84
000068  e8bd8ff0          POP      {r4-r11,pc}
;;;513    
                          ENDP


                          AREA ||i.reinsert||, CODE, READONLY, ALIGN=1

                  reinsert PROC
;;;403    */
;;;404    static void reinsert (lua_State *L, Table *ot, Table *t) {
000000  e92d5fff          PUSH     {r0-r12,lr}
000004  4682              MOV      r10,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
;;;405      int j;
;;;406      int size = sizenode(ot);
00000a  79e9              LDRB     r1,[r5,#7]
00000c  2001              MOVS     r0,#1
00000e  fa00fb01          LSL      r11,r0,r1
;;;407      for (j = 0; j < size; j++) {
000012  2600              MOVS     r6,#0
000014  e021              B        |L30.90|
                  |L30.22|
;;;408        Node *old = gnode(ot, j);
000016  eb060146          ADD      r1,r6,r6,LSL #1
00001a  6928              LDR      r0,[r5,#0x10]
00001c  eb0004c1          ADD      r4,r0,r1,LSL #3
;;;409        if (!isempty(gval(old))) {
000020  7a20              LDRB     r0,[r4,#8]
000022  f000000f          AND      r0,r0,#0xf
000026  b1b8              CBZ      r0,|L30.88|
;;;410          /* doesn't need barrier/invalidate cache, as entry was
;;;411             already present in the table */
;;;412          TValue k;
;;;413          getnodekey(L, &k, old);
000028  4668              MOV      r0,sp
00002a  4621              MOV      r1,r4
00002c  e9d12304          LDRD     r2,r3,[r1,#0x10]
000030  e9c02300          STRD     r2,r3,[r0,#0]
000034  7a4a              LDRB     r2,[r1,#9]
000036  7202              STRB     r2,[r0,#8]
;;;414          setobjt2t(L, luaH_set(L, t, &k), gval(old));
000038  466a              MOV      r2,sp
00003a  4639              MOV      r1,r7
00003c  4650              MOV      r0,r10
00003e  f7fffffe          BL       luaH_set
000042  4680              MOV      r8,r0
000044  46a1              MOV      r9,r4
000046  e9d90100          LDRD     r0,r1,[r9,#0]
00004a  e9c80100          STRD     r0,r1,[r8,#0]
00004e  f8990008          LDRB     r0,[r9,#8]
000052  f8880008          STRB     r0,[r8,#8]
;;;415        }
000056  bf00              NOP      
                  |L30.88|
000058  1c76              ADDS     r6,r6,#1              ;407
                  |L30.90|
00005a  455e              CMP      r6,r11                ;407
00005c  dbdb              BLT      |L30.22|
;;;416      }
;;;417    }
00005e  e8bd9fff          POP      {r0-r12,pc}
;;;418    
                          ENDP


                          AREA ||i.setnodevector||, CODE, READONLY, ALIGN=2

                  setnodevector PROC
;;;375    */
;;;376    static void setnodevector (lua_State *L, Table *t, unsigned int size) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4680              MOV      r8,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;377      if (size == 0) {  /* no elements to hash part? */
00000a  b92d              CBNZ     r5,|L31.24|
;;;378        t->node = cast(Node *, dummynode);  /* use common 'dummynode' */
00000c  481c              LDR      r0,|L31.128|
00000e  6120              STR      r0,[r4,#0x10]
;;;379        t->lsizenode = 0;
000010  2000              MOVS     r0,#0
000012  71e0              STRB     r0,[r4,#7]
;;;380        t->lastfree = NULL;  /* signal that it is using dummy node */
000014  6160              STR      r0,[r4,#0x14]
000016  e030              B        |L31.122|
                  |L31.24|
;;;381      }
;;;382      else {
;;;383        int i;
;;;384        int lsize = luaO_ceillog2(size);
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       luaO_ceillog2
00001e  4607              MOV      r7,r0
;;;385        if (lsize > MAXHBITS || (1u << lsize) > MAXHSIZE)
000020  2f1e              CMP      r7,#0x1e
000022  dc04              BGT      |L31.46|
000024  2001              MOVS     r0,#1
000026  40b8              LSLS     r0,r0,r7
000028  4916              LDR      r1,|L31.132|
00002a  4288              CMP      r0,r1
00002c  d903              BLS      |L31.54|
                  |L31.46|
;;;386          luaG_runerror(L, "table overflow");
00002e  a116              ADR      r1,|L31.136|
000030  4640              MOV      r0,r8
000032  f7fffffe          BL       luaG_runerror
                  |L31.54|
;;;387        size = twoto(lsize);
000036  2001              MOVS     r0,#1
000038  fa00f507          LSL      r5,r0,r7
;;;388        t->node = luaM_newvector(L, size, Node);
00003c  eb050045          ADD      r0,r5,r5,LSL #1
000040  00c1              LSLS     r1,r0,#3
000042  2200              MOVS     r2,#0
000044  4640              MOV      r0,r8
000046  f7fffffe          BL       luaM_malloc_
00004a  6120              STR      r0,[r4,#0x10]
;;;389        for (i = 0; i < (int)size; i++) {
00004c  2600              MOVS     r6,#0
00004e  e00a              B        |L31.102|
                  |L31.80|
;;;390          Node *n = gnode(t, i);
000050  eb060246          ADD      r2,r6,r6,LSL #1
000054  6921              LDR      r1,[r4,#0x10]
000056  eb0100c2          ADD      r0,r1,r2,LSL #3
;;;391          gnext(n) = 0;
00005a  2100              MOVS     r1,#0
00005c  60c1              STR      r1,[r0,#0xc]
;;;392          setnilkey(n);
00005e  7241              STRB     r1,[r0,#9]
;;;393          setempty(gval(n));
000060  2110              MOVS     r1,#0x10
000062  7201              STRB     r1,[r0,#8]
000064  1c76              ADDS     r6,r6,#1              ;389
                  |L31.102|
000066  42ae              CMP      r6,r5                 ;389
000068  dbf2              BLT      |L31.80|
;;;394        }
;;;395        t->lsizenode = cast_byte(lsize);
00006a  71e7              STRB     r7,[r4,#7]
;;;396        t->lastfree = gnode(t, size);  /* all positions are free */
00006c  eb050145          ADD      r1,r5,r5,LSL #1
000070  6920              LDR      r0,[r4,#0x10]
000072  eb0000c1          ADD      r0,r0,r1,LSL #3
000076  6160              STR      r0,[r4,#0x14]
;;;397      }
000078  bf00              NOP      
                  |L31.122|
;;;398    }
00007a  e8bd81f0          POP      {r4-r8,pc}
;;;399    
                          ENDP

00007e  0000              DCW      0x0000
                  |L31.128|
                          DCD      dummynode_
                  |L31.132|
                          DCD      0x0aaaaaaa
                  |L31.136|
000088  7461626c          DCB      "table overflow",0
00008c  65206f76
000090  6572666c
000094  6f7700  
000097  00                DCB      0

                          AREA ||.constdata||, DATA, READONLY, ALIGN=3

                  dummynode_
                          DCD      0x00000000
                          DCD      0x00000000
000008  10000000          DCB      0x10,0x00,0x00,0x00
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                  luaH_emptyobject_
                          DCD      0x00000000
                          DCD      0x00000000
000020  10000000          DCB      0x10,0x00,0x00,0x00
                          DCD      0x00000000
