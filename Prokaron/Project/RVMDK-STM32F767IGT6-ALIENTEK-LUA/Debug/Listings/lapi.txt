; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\lapi.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\lapi.d --cpu=Cortex-M7 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Inc -I.\Source -I.\Drivers -I..\..\..\M6P1(L)_Lua\lua -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6-ALIENTEK-LUA\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER -Dlua_writestring=RMP_lua_writestring -Dlua_writeline=RMP_lua_writeline --enum_is_int --signed_chars --omf_browse=.\debug\output\lapi.crf ..\..\..\M6P1(L)_Lua\lua\lapi.c]
                          THUMB

                          AREA ||i.aux_upvalue||, CODE, READONLY, ALIGN=2

                  aux_upvalue PROC
;;;1292   
;;;1293   static const char *aux_upvalue (TValue *fi, int n, TValue **val,
000000  b5f0              PUSH     {r4-r7,lr}
;;;1294                                   GCObject **owner) {
000002  4604              MOV      r4,r0
;;;1295     switch (ttypetag(fi)) {
000004  7a20              LDRB     r0,[r4,#8]
000006  f000003f          AND      r0,r0,#0x3f
00000a  2816              CMP      r0,#0x16
00000c  d013              BEQ      |L1.54|
00000e  2836              CMP      r0,#0x36
000010  d131              BNE      |L1.118|
;;;1296       case LUA_TCCL: {  /* C closure */
;;;1297         CClosure *f = clCvalue(fi);
000012  6825              LDR      r5,[r4,#0]
;;;1298         if (!(1 <= n && n <= f->nupvalues)) return NULL;
000014  2901              CMP      r1,#1
000016  db02              BLT      |L1.30|
000018  79a8              LDRB     r0,[r5,#6]
00001a  4288              CMP      r0,r1
00001c  da01              BGE      |L1.34|
                  |L1.30|
00001e  2000              MOVS     r0,#0
                  |L1.32|
;;;1299         *val = &f->upvalue[n-1];
;;;1300         if (owner) *owner = obj2gco(f);
;;;1301         return "";
;;;1302       }
;;;1303       case LUA_TLCL: {  /* Lua closure */
;;;1304         LClosure *f = clLvalue(fi);
;;;1305         TString *name;
;;;1306         Proto *p = f->p;
;;;1307         if (!(1 <= n && n <= p->sizeupvalues)) return NULL;
;;;1308         *val = f->upvals[n-1]->v;
;;;1309         if (owner) *owner = obj2gco(f->upvals[n - 1]);
;;;1310         name = p->upvalues[n-1].name;
;;;1311         return (name == NULL) ? "(*no name)" : getstr(name);
;;;1312       }
;;;1313       default: return NULL;  /* not a closure */
;;;1314     }
;;;1315   }
000020  bdf0              POP      {r4-r7,pc}
                  |L1.34|
000022  1e48              SUBS     r0,r1,#1              ;1299
000024  f1050610          ADD      r6,r5,#0x10           ;1299
000028  eb061000          ADD      r0,r6,r0,LSL #4       ;1299
00002c  6010              STR      r0,[r2,#0]            ;1299
00002e  b103              CBZ      r3,|L1.50|
000030  601d              STR      r5,[r3,#0]            ;1300
                  |L1.50|
000032  a012              ADR      r0,|L1.124|
000034  e7f4              B        |L1.32|
                  |L1.54|
000036  6825              LDR      r5,[r4,#0]            ;1304
000038  68ef              LDR      r7,[r5,#0xc]          ;1306
00003a  2901              CMP      r1,#1                 ;1307
00003c  db02              BLT      |L1.68|
00003e  68f8              LDR      r0,[r7,#0xc]          ;1307
000040  4288              CMP      r0,r1                 ;1307
000042  da01              BGE      |L1.72|
                  |L1.68|
000044  2000              MOVS     r0,#0                 ;1307
000046  e7eb              B        |L1.32|
                  |L1.72|
000048  1e48              SUBS     r0,r1,#1              ;1308
00004a  f1050c10          ADD      r12,r5,#0x10          ;1308
00004e  f85c0020          LDR      r0,[r12,r0,LSL #2]    ;1308
000052  6880              LDR      r0,[r0,#8]            ;1308
000054  6010              STR      r0,[r2,#0]            ;1308
000056  b11b              CBZ      r3,|L1.96|
000058  1e48              SUBS     r0,r1,#1              ;1309
00005a  f85c0020          LDR      r0,[r12,r0,LSL #2]    ;1309
00005e  6018              STR      r0,[r3,#0]            ;1309
                  |L1.96|
000060  1e48              SUBS     r0,r1,#1              ;1310
000062  f8d7c040          LDR      r12,[r7,#0x40]        ;1310
000066  f85c6030          LDR      r6,[r12,r0,LSL #3]    ;1310
00006a  b90e              CBNZ     r6,|L1.112|
00006c  a004              ADR      r0,|L1.128|
00006e  e7d7              B        |L1.32|
                  |L1.112|
000070  f1060010          ADD      r0,r6,#0x10           ;1311
000074  e7d4              B        |L1.32|
                  |L1.118|
000076  2000              MOVS     r0,#0                 ;1313
000078  e7d2              B        |L1.32|
;;;1316   
                          ENDP

00007a  0000              DCW      0x0000
                  |L1.124|
00007c  00                DCB      0
00007d  00                DCB      0
00007e  00                DCB      0
00007f  00                DCB      0
                  |L1.128|
000080  282a6e6f          DCB      "(*no name)",0
000084  206e616d
000088  652900  
00008b  00                DCB      0

                          AREA ||i.auxgetstr||, CODE, READONLY, ALIGN=1

                  auxgetstr PROC
;;;595    
;;;596    static int auxgetstr (lua_State *L, const TValue *t, const char *k) {
000000  e92d43f8          PUSH     {r3-r9,lr}
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
;;;597      const TValue *slot;
;;;598      TString *str = luaS_new(L, k);
00000a  4641              MOV      r1,r8
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       luaS_new
000012  4606              MOV      r6,r0
;;;599      if (luaV_fastget(L, t, str, slot, luaH_getstr)) {
000014  7a38              LDRB     r0,[r7,#8]
000016  2845              CMP      r0,#0x45
000018  d002              BEQ      |L2.32|
00001a  2500              MOVS     r5,#0
00001c  2000              MOVS     r0,#0
00001e  e00b              B        |L2.56|
                  |L2.32|
000020  4631              MOV      r1,r6
000022  6838              LDR      r0,[r7,#0]
000024  f7fffffe          BL       luaH_getstr
000028  4605              MOV      r5,r0
00002a  7a28              LDRB     r0,[r5,#8]
00002c  f000000f          AND      r0,r0,#0xf
000030  b108              CBZ      r0,|L2.54|
000032  2001              MOVS     r0,#1
000034  e000              B        |L2.56|
                  |L2.54|
000036  2000              MOVS     r0,#0
                  |L2.56|
000038  b158              CBZ      r0,|L2.82|
;;;600        setobj2s(L, L->top, slot);
00003a  68e0              LDR      r0,[r4,#0xc]
00003c  4629              MOV      r1,r5
00003e  e9d12300          LDRD     r2,r3,[r1,#0]
000042  e9c02300          STRD     r2,r3,[r0,#0]
000046  7a0a              LDRB     r2,[r1,#8]
000048  7202              STRB     r2,[r0,#8]
;;;601        api_incr_top(L);
00004a  68e0              LDR      r0,[r4,#0xc]
00004c  3010              ADDS     r0,r0,#0x10
00004e  60e0              STR      r0,[r4,#0xc]
000050  e012              B        |L2.120|
                  |L2.82|
;;;602      }
;;;603      else {
;;;604        setsvalue2s(L, L->top, str);
000052  68e0              LDR      r0,[r4,#0xc]
000054  4631              MOV      r1,r6
000056  6001              STR      r1,[r0,#0]
000058  790a              LDRB     r2,[r1,#4]
00005a  f0420240          ORR      r2,r2,#0x40
00005e  7202              STRB     r2,[r0,#8]
;;;605        api_incr_top(L);
000060  68e0              LDR      r0,[r4,#0xc]
000062  3010              ADDS     r0,r0,#0x10
000064  60e0              STR      r0,[r4,#0xc]
;;;606        luaV_finishget(L, t, s2v(L->top - 1), L->top - 1, slot);
000066  9500              STR      r5,[sp,#0]
000068  68e0              LDR      r0,[r4,#0xc]
00006a  f1a00310          SUB      r3,r0,#0x10
00006e  461a              MOV      r2,r3
000070  4639              MOV      r1,r7
000072  4620              MOV      r0,r4
000074  f7fffffe          BL       luaV_finishget
                  |L2.120|
;;;607      }
;;;608      lua_unlock(L);
;;;609      return ttype(s2v(L->top - 1));
000078  68e0              LDR      r0,[r4,#0xc]
00007a  f8100c08          LDRB     r0,[r0,#-8]
00007e  f000000f          AND      r0,r0,#0xf
;;;610    }
000082  e8bd83f8          POP      {r3-r9,pc}
;;;611    
                          ENDP


                          AREA ||i.auxkeydef||, CODE, READONLY, ALIGN=1

                  auxkeydef PROC
;;;707    
;;;708    static int auxkeydef (lua_State *L, int idx, int remove) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;709      int res;
;;;710      lua_lock(L);
;;;711      api_checknelems(L, 1);
;;;712      res = luaT_keydef(L, index2value(L, idx), s2v(L->top - 1), remove);
00000a  4631              MOV      r1,r6
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       index2value
000012  4680              MOV      r8,r0
000014  68e0              LDR      r0,[r4,#0xc]
000016  f1a00210          SUB      r2,r0,#0x10
00001a  462b              MOV      r3,r5
00001c  4641              MOV      r1,r8
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       luaT_keydef
000024  4607              MOV      r7,r0
;;;713      L->top--;  /* remove key */
000026  68e0              LDR      r0,[r4,#0xc]
000028  3810              SUBS     r0,r0,#0x10
00002a  60e0              STR      r0,[r4,#0xc]
;;;714      lua_unlock(L);
;;;715      return res;
00002c  4638              MOV      r0,r7
;;;716    }
00002e  e8bd81f0          POP      {r4-r8,pc}
;;;717    
                          ENDP


                          AREA ||i.auxsetstr||, CODE, READONLY, ALIGN=1

                  auxsetstr PROC
;;;795    */
;;;796    static void auxsetstr (lua_State *L, const TValue *t, const char *k) {
000000  e92d43f8          PUSH     {r3-r9,lr}
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4690              MOV      r8,r2
;;;797      const TValue *slot;
;;;798      TString *str = luaS_new(L, k);
00000a  4641              MOV      r1,r8
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       luaS_new
000012  4607              MOV      r7,r0
;;;799      api_checknelems(L, 1);
;;;800      if (luaV_fastget(L, t, str, slot, luaH_getstr)) {
000014  7a30              LDRB     r0,[r6,#8]
000016  2845              CMP      r0,#0x45
000018  d002              BEQ      |L4.32|
00001a  2500              MOVS     r5,#0
00001c  2000              MOVS     r0,#0
00001e  e00b              B        |L4.56|
                  |L4.32|
000020  4639              MOV      r1,r7
000022  6830              LDR      r0,[r6,#0]
000024  f7fffffe          BL       luaH_getstr
000028  4605              MOV      r5,r0
00002a  7a28              LDRB     r0,[r5,#8]
00002c  f000000f          AND      r0,r0,#0xf
000030  b108              CBZ      r0,|L4.54|
000032  2001              MOVS     r0,#1
000034  e000              B        |L4.56|
                  |L4.54|
000036  2000              MOVS     r0,#0
                  |L4.56|
000038  b328              CBZ      r0,|L4.134|
;;;801        luaV_finishfastset(L, t, slot, s2v(L->top - 1));
00003a  4628              MOV      r0,r5
00003c  68e2              LDR      r2,[r4,#0xc]
00003e  f1a20110          SUB      r1,r2,#0x10
000042  e9d12300          LDRD     r2,r3,[r1,#0]
000046  e9c02300          STRD     r2,r3,[r0,#0]
00004a  7a0a              LDRB     r2,[r1,#8]
00004c  7202              STRB     r2,[r0,#8]
00004e  68e0              LDR      r0,[r4,#0xc]
000050  f8100c08          LDRB     r0,[r0,#-8]
000054  f0000040          AND      r0,r0,#0x40
000058  b180              CBZ      r0,|L4.124|
00005a  6830              LDR      r0,[r6,#0]
00005c  7940              LDRB     r0,[r0,#5]
00005e  f0000020          AND      r0,r0,#0x20
000062  b158              CBZ      r0,|L4.124|
000064  68e0              LDR      r0,[r4,#0xc]
000066  f8500c10          LDR      r0,[r0,#-0x10]
00006a  7940              LDRB     r0,[r0,#5]
00006c  f0000018          AND      r0,r0,#0x18
000070  b120              CBZ      r0,|L4.124|
000072  4620              MOV      r0,r4
000074  6831              LDR      r1,[r6,#0]
000076  f7fffffe          BL       luaC_barrierback_
00007a  e000              B        |L4.126|
                  |L4.124|
00007c  bf00              NOP      
                  |L4.126|
;;;802        L->top--;  /* pop value */
00007e  68e0              LDR      r0,[r4,#0xc]
000080  3810              SUBS     r0,r0,#0x10
000082  60e0              STR      r0,[r4,#0xc]
000084  e016              B        |L4.180|
                  |L4.134|
;;;803      }
;;;804      else {
;;;805        setsvalue2s(L, L->top, str);  /* push 'str' (to make it a TValue) */
000086  68e0              LDR      r0,[r4,#0xc]
000088  4639              MOV      r1,r7
00008a  6001              STR      r1,[r0,#0]
00008c  790a              LDRB     r2,[r1,#4]
00008e  f0420240          ORR      r2,r2,#0x40
000092  7202              STRB     r2,[r0,#8]
;;;806        api_incr_top(L);
000094  68e0              LDR      r0,[r4,#0xc]
000096  3010              ADDS     r0,r0,#0x10
000098  60e0              STR      r0,[r4,#0xc]
;;;807        luaV_finishset(L, t, s2v(L->top - 1), s2v(L->top - 2), slot);
00009a  9500              STR      r5,[sp,#0]
00009c  68e0              LDR      r0,[r4,#0xc]
00009e  f1a00320          SUB      r3,r0,#0x20
0000a2  f1a00210          SUB      r2,r0,#0x10
0000a6  4631              MOV      r1,r6
0000a8  4620              MOV      r0,r4
0000aa  f7fffffe          BL       luaV_finishset
;;;808        L->top -= 2;  /* pop value and key */
0000ae  68e0              LDR      r0,[r4,#0xc]
0000b0  3820              SUBS     r0,r0,#0x20
0000b2  60e0              STR      r0,[r4,#0xc]
                  |L4.180|
;;;809      }
;;;810      lua_unlock(L);  /* lock done by caller */
;;;811    }
0000b4  e8bd83f8          POP      {r3-r9,pc}
;;;812    
                          ENDP


                          AREA ||i.f_call||, CODE, READONLY, ALIGN=1

                  f_call PROC
;;;1005   
;;;1006   static void f_call (lua_State *L, void *ud) {
000000  b570              PUSH     {r4-r6,lr}
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;1007     struct CallS *c = cast(struct CallS *, ud);
000006  4625              MOV      r5,r4
;;;1008     luaD_callnoyield(L, c->func, c->nresults);
000008  4630              MOV      r0,r6
00000a  e9d51200          LDRD     r1,r2,[r5,#0]
00000e  f7fffffe          BL       luaD_callnoyield
;;;1009   }
000012  bd70              POP      {r4-r6,pc}
;;;1010   
                          ENDP


                          AREA ||i.finishrawget||, CODE, READONLY, ALIGN=1

                  finishrawget PROC
;;;659    
;;;660    static int finishrawget (lua_State *L, const TValue *val) {
000000  b530              PUSH     {r4,r5,lr}
000002  4602              MOV      r2,r0
;;;661      if (isempty(val))  /* avoid copying empty items to the stack */
000004  7a08              LDRB     r0,[r1,#8]
000006  f000000f          AND      r0,r0,#0xf
00000a  b918              CBNZ     r0,|L6.20|
;;;662        setnilvalue(s2v(L->top));
00000c  2000              MOVS     r0,#0
00000e  68d3              LDR      r3,[r2,#0xc]
000010  7218              STRB     r0,[r3,#8]
000012  e008              B        |L6.38|
                  |L6.20|
;;;663      else
;;;664        setobj2s(L, L->top, val);
000014  68d0              LDR      r0,[r2,#0xc]
000016  460b              MOV      r3,r1
000018  e9d34500          LDRD     r4,r5,[r3,#0]
00001c  e9c04500          STRD     r4,r5,[r0,#0]
000020  7a1c              LDRB     r4,[r3,#8]
000022  7204              STRB     r4,[r0,#8]
000024  bf00              NOP      
                  |L6.38|
;;;665      api_incr_top(L);
000026  68d0              LDR      r0,[r2,#0xc]
000028  3010              ADDS     r0,r0,#0x10
00002a  60d0              STR      r0,[r2,#0xc]
;;;666      lua_unlock(L);
;;;667      return ttype(s2v(L->top - 1));
00002c  68d0              LDR      r0,[r2,#0xc]
00002e  f8100c08          LDRB     r0,[r0,#-8]
000032  f000000f          AND      r0,r0,#0xf
;;;668    }
000036  bd30              POP      {r4,r5,pc}
;;;669    
                          ENDP


                          AREA ||i.gettable||, CODE, READONLY, ALIGN=1

                  gettable PROC
;;;670    
;;;671    static Table *gettable (lua_State *L, int idx) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;672      TValue *t = index2value(L, idx);
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       index2value
00000e  4606              MOV      r6,r0
;;;673      api_check(L, ttistable(t), "table expected");
;;;674      return hvalue(t);
000010  6830              LDR      r0,[r6,#0]
;;;675    }
000012  bd70              POP      {r4-r6,pc}
;;;676    
                          ENDP


                          AREA ||i.getupvalref||, CODE, READONLY, ALIGN=1

                  getupvalref PROC
;;;1350   
;;;1351   static UpVal **getupvalref (lua_State *L, int fidx, int n, LClosure **pf) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4615              MOV      r5,r2
00000a  461c              MOV      r4,r3
;;;1352     LClosure *f;
;;;1353     TValue *fi = index2value(L, fidx);
00000c  4641              MOV      r1,r8
00000e  4638              MOV      r0,r7
000010  f7fffffe          BL       index2value
000014  4681              MOV      r9,r0
;;;1354     api_check(L, ttisLclosure(fi), "Lua function expected");
;;;1355     f = clLvalue(fi);
000016  f8d96000          LDR      r6,[r9,#0]
;;;1356     api_check(L, (1 <= n && n <= f->p->sizeupvalues), "invalid upvalue index");
;;;1357     if (pf) *pf = f;
00001a  b104              CBZ      r4,|L8.30|
00001c  6026              STR      r6,[r4,#0]
                  |L8.30|
;;;1358     return &f->upvals[n - 1];  /* get its upvalue pointer */
00001e  1e68              SUBS     r0,r5,#1
000020  f1060110          ADD      r1,r6,#0x10
000024  eb010080          ADD      r0,r1,r0,LSL #2
;;;1359   }
000028  e8bd87f0          POP      {r4-r10,pc}
;;;1360   
                          ENDP


                          AREA ||i.index2stack||, CODE, READONLY, ALIGN=1

                  index2stack PROC
;;;87     
;;;88     static StkId index2stack (lua_State *L, int idx) {
000000  b510              PUSH     {r4,lr}
000002  4602              MOV      r2,r0
;;;89       CallInfo *ci = L->ci;
000004  6953              LDR      r3,[r2,#0x14]
;;;90       if (idx > 0) {
000006  2900              CMP      r1,#0
000008  dd03              BLE      |L9.18|
;;;91         StkId o = ci->func + idx;
00000a  681c              LDR      r4,[r3,#0]
00000c  eb041001          ADD      r0,r4,r1,LSL #4
                  |L9.16|
;;;92         api_check(L, o < L->top, "unacceptable index");
;;;93         return o;
;;;94       }
;;;95       else {    /* non-positive index */
;;;96         api_check(L, idx != 0 && -idx <= L->top - (ci->func + 1), "invalid index");
;;;97         api_check(L, !ispseudo(idx), "invalid index");
;;;98         return L->top + idx;
;;;99       }
;;;100    }
000010  bd10              POP      {r4,pc}
                  |L9.18|
000012  68d0              LDR      r0,[r2,#0xc]          ;98
000014  eb001001          ADD      r0,r0,r1,LSL #4       ;98
000018  e7fa              B        |L9.16|
;;;101    
                          ENDP


                          AREA ||i.index2value||, CODE, READONLY, ALIGN=2

                  index2value PROC
;;;60     
;;;61     static TValue *index2value (lua_State *L, int idx) {
000000  b530              PUSH     {r4,r5,lr}
000002  4602              MOV      r2,r0
;;;62       CallInfo *ci = L->ci;
000004  6953              LDR      r3,[r2,#0x14]
;;;63       if (idx > 0) {
000006  2900              CMP      r1,#0
000008  dd09              BLE      |L10.30|
;;;64         StkId o = ci->func + idx;
00000a  6818              LDR      r0,[r3,#0]
00000c  eb001401          ADD      r4,r0,r1,LSL #4
;;;65         api_check(L, idx <= L->ci->top - (ci->func + 1), "unacceptable index");
;;;66         if (o >= L->top) return NONVALIDVALUE;
000010  68d0              LDR      r0,[r2,#0xc]
000012  42a0              CMP      r0,r4
000014  d801              BHI      |L10.26|
000016  4813              LDR      r0,|L10.100|
                  |L10.24|
;;;67         else return s2v(o);
;;;68       }
;;;69       else if (!ispseudo(idx)) {  /* negative index */
;;;70         api_check(L, idx != 0 && -idx <= L->top - (ci->func + 1), "invalid index");
;;;71         return s2v(L->top + idx);
;;;72       }
;;;73       else if (idx == LUA_REGISTRYINDEX)
;;;74         return &G(L)->l_registry;
;;;75       else {  /* upvalues */
;;;76         idx = LUA_REGISTRYINDEX - idx;
;;;77         api_check(L, idx <= MAXUPVAL + 1, "upvalue index too large");
;;;78         if (ttislcf(s2v(ci->func)))  /* light C function? */
;;;79           return NONVALIDVALUE;  /* it has no upvalues */
;;;80         else {
;;;81           CClosure *func = clCvalue(s2v(ci->func));
;;;82           return (idx <= func->nupvalues) ? &func->upvalue[idx-1] : NONVALIDVALUE;
;;;83         }
;;;84       }
;;;85     }
000018  bd30              POP      {r4,r5,pc}
                  |L10.26|
00001a  4620              MOV      r0,r4                 ;67
00001c  e7fc              B        |L10.24|
                  |L10.30|
00001e  4812              LDR      r0,|L10.104|
000020  4281              CMP      r1,r0                 ;69
000022  dd03              BLE      |L10.44|
000024  68d0              LDR      r0,[r2,#0xc]          ;71
000026  eb001001          ADD      r0,r0,r1,LSL #4       ;71
00002a  e7f5              B        |L10.24|
                  |L10.44|
00002c  480e              LDR      r0,|L10.104|
00002e  4281              CMP      r1,r0                 ;73
000030  d102              BNE      |L10.56|
000032  6910              LDR      r0,[r2,#0x10]         ;74
000034  3020              ADDS     r0,r0,#0x20           ;74
000036  e7ef              B        |L10.24|
                  |L10.56|
000038  480b              LDR      r0,|L10.104|
00003a  1a41              SUBS     r1,r0,r1              ;76
00003c  6818              LDR      r0,[r3,#0]            ;78
00003e  7a00              LDRB     r0,[r0,#8]            ;78
000040  2826              CMP      r0,#0x26              ;78
000042  d101              BNE      |L10.72|
000044  4807              LDR      r0,|L10.100|
000046  e7e7              B        |L10.24|
                  |L10.72|
000048  6818              LDR      r0,[r3,#0]            ;81
00004a  6804              LDR      r4,[r0,#0]            ;81
00004c  79a0              LDRB     r0,[r4,#6]            ;82
00004e  4288              CMP      r0,r1                 ;82
000050  db05              BLT      |L10.94|
000052  1e48              SUBS     r0,r1,#1              ;82
000054  f1040510          ADD      r5,r4,#0x10           ;82
000058  eb051000          ADD      r0,r5,r0,LSL #4       ;82
00005c  e7dc              B        |L10.24|
                  |L10.94|
00005e  4801              LDR      r0,|L10.100|
000060  e7da              B        |L10.24|
;;;86     
                          ENDP

000062  0000              DCW      0x0000
                  |L10.100|
                          DCD      luaO_nilobject_
                  |L10.104|
                          DCD      0xfff0b9d8

                          AREA ||i.lua_absindex||, CODE, READONLY, ALIGN=2

                  lua_absindex PROC
;;;165    */
;;;166    LUA_API int lua_absindex (lua_State *L, int idx) {
000000  4602              MOV      r2,r0
;;;167      return (idx > 0 || ispseudo(idx))
000002  2900              CMP      r1,#0
000004  dc02              BGT      |L11.12|
000006  4806              LDR      r0,|L11.32|
000008  4281              CMP      r1,r0
00000a  dc01              BGT      |L11.16|
                  |L11.12|
;;;168             ? idx
00000c  4608              MOV      r0,r1
                  |L11.14|
;;;169             : cast_int(L->top - L->ci->func) + idx;
;;;170    }
00000e  4770              BX       lr
                  |L11.16|
000010  6953              LDR      r3,[r2,#0x14]         ;169
000012  68d0              LDR      r0,[r2,#0xc]          ;169
000014  681b              LDR      r3,[r3,#0]            ;169
000016  1ac0              SUBS     r0,r0,r3              ;169
000018  eb011020          ADD      r0,r1,r0,ASR #4       ;169
00001c  e7f7              B        |L11.14|
;;;171    
                          ENDP

00001e  0000              DCW      0x0000
                  |L11.32|
                          DCD      0xfff0b9d8

                          AREA ||i.lua_arith||, CODE, READONLY, ALIGN=1

                  lua_arith PROC
;;;308    
;;;309    LUA_API void lua_arith (lua_State *L, int op) {
000000  b538              PUSH     {r3-r5,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;310      lua_lock(L);
;;;311      if (op != LUA_OPUNM && op != LUA_OPBNOT)
000006  2d0c              CMP      r5,#0xc
000008  d002              BEQ      |L12.16|
00000a  2d0d              CMP      r5,#0xd
00000c  d000              BEQ      |L12.16|
;;;312        api_checknelems(L, 2);  /* all other operations expect two operands */
00000e  e00d              B        |L12.44|
                  |L12.16|
;;;313      else {  /* for unary operations, add fake 2nd operand */
;;;314        api_checknelems(L, 1);
;;;315        setobjs2s(L, L->top, L->top - 1);
000010  68e0              LDR      r0,[r4,#0xc]
000012  68e2              LDR      r2,[r4,#0xc]
000014  f1a20110          SUB      r1,r2,#0x10
000018  e9d12300          LDRD     r2,r3,[r1,#0]
00001c  e9c02300          STRD     r2,r3,[r0,#0]
000020  7a0a              LDRB     r2,[r1,#8]
000022  7202              STRB     r2,[r0,#8]
;;;316        api_incr_top(L);
000024  68e0              LDR      r0,[r4,#0xc]
000026  3010              ADDS     r0,r0,#0x10
000028  60e0              STR      r0,[r4,#0xc]
00002a  bf00              NOP      
                  |L12.44|
;;;317      }
;;;318      /* first operand at top - 2, second at top - 1; result go to top - 2 */
;;;319      luaO_arith(L, op, s2v(L->top - 2), s2v(L->top - 1), L->top - 2);
00002c  68e0              LDR      r0,[r4,#0xc]
00002e  3820              SUBS     r0,r0,#0x20
000030  9000              STR      r0,[sp,#0]
000032  68e0              LDR      r0,[r4,#0xc]
000034  f1a00310          SUB      r3,r0,#0x10
000038  f1a00220          SUB      r2,r0,#0x20
00003c  4629              MOV      r1,r5
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       luaO_arith
;;;320      L->top--;  /* remove second operand */
000044  68e0              LDR      r0,[r4,#0xc]
000046  3810              SUBS     r0,r0,#0x10
000048  60e0              STR      r0,[r4,#0xc]
;;;321      lua_unlock(L);
;;;322    }
00004a  bd38              POP      {r3-r5,pc}
;;;323    
                          ENDP


                          AREA ||i.lua_atpanic||, CODE, READONLY, ALIGN=1

                  lua_atpanic PROC
;;;139    
;;;140    LUA_API lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf) {
000000  4602              MOV      r2,r0
;;;141      lua_CFunction old;
;;;142      lua_lock(L);
;;;143      old = G(L)->panic;
000002  6913              LDR      r3,[r2,#0x10]
000004  f8d30088          LDR      r0,[r3,#0x88]
;;;144      G(L)->panic = panicf;
000008  6913              LDR      r3,[r2,#0x10]
00000a  f8c31088          STR      r1,[r3,#0x88]
;;;145      lua_unlock(L);
;;;146      return old;
;;;147    }
00000e  4770              BX       lr
;;;148    
                          ENDP


                          AREA ||i.lua_callk||, CODE, READONLY, ALIGN=1

                  lua_callk PROC
;;;973    
;;;974    LUA_API void lua_callk (lua_State *L, int nargs, int nresults,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;975                            lua_KContext ctx, lua_KFunction k) {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  461e              MOV      r6,r3
00000c  f8dd8020          LDR      r8,[sp,#0x20]
;;;976      StkId func;
;;;977      lua_lock(L);
;;;978      api_check(L, k == NULL || !isLua(L->ci),
;;;979        "cannot use continuations inside hooks");
;;;980      api_checknelems(L, nargs+1);
;;;981      api_check(L, L->status == LUA_OK, "cannot do calls on non-normal thread");
;;;982      checkresults(L, nargs, nresults);
;;;983      func = L->top - (nargs+1);
000010  1c68              ADDS     r0,r5,#1
000012  68e1              LDR      r1,[r4,#0xc]
000014  eba11900          SUB      r9,r1,r0,LSL #4
;;;984      if (k != NULL && L->nny == 0) {  /* need to prepare continuation? */
000018  f1b80f00          CMP      r8,#0
00001c  d00d              BEQ      |L14.58|
00001e  f8b4006c          LDRH     r0,[r4,#0x6c]
000022  b950              CBNZ     r0,|L14.58|
;;;985        L->ci->u.c.k = k;  /* save continuation */
000024  6960              LDR      r0,[r4,#0x14]
000026  f8c08010          STR      r8,[r0,#0x10]
;;;986        L->ci->u.c.ctx = ctx;  /* save context */
00002a  6960              LDR      r0,[r4,#0x14]
00002c  6186              STR      r6,[r0,#0x18]
;;;987        luaD_call(L, func, nresults);  /* do the call */
00002e  463a              MOV      r2,r7
000030  4649              MOV      r1,r9
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       luaD_call
000038  e004              B        |L14.68|
                  |L14.58|
;;;988      }
;;;989      else  /* no continuation or no yieldable */
;;;990        luaD_callnoyield(L, func, nresults);  /* just do the call */
00003a  463a              MOV      r2,r7
00003c  4649              MOV      r1,r9
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       luaD_callnoyield
                  |L14.68|
;;;991      adjustresults(L, nresults);
000044  1c78              ADDS     r0,r7,#1
000046  b938              CBNZ     r0,|L14.88|
000048  6960              LDR      r0,[r4,#0x14]
00004a  6840              LDR      r0,[r0,#4]
00004c  68e1              LDR      r1,[r4,#0xc]
00004e  4288              CMP      r0,r1
000050  d202              BCS      |L14.88|
000052  6961              LDR      r1,[r4,#0x14]
000054  68e0              LDR      r0,[r4,#0xc]
000056  6048              STR      r0,[r1,#4]
                  |L14.88|
;;;992      lua_unlock(L);
;;;993    }
000058  e8bd87f0          POP      {r4-r10,pc}
;;;994    
                          ENDP


                          AREA ||i.lua_checkstack||, CODE, READONLY, ALIGN=2

                  lua_checkstack PROC
;;;102    
;;;103    LUA_API int lua_checkstack (lua_State *L, int n) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;104      int res;
;;;105      CallInfo *ci = L->ci;
000008  6967              LDR      r7,[r4,#0x14]
;;;106      lua_lock(L);
;;;107      api_check(L, n >= 0, "negative 'n'");
;;;108      if (L->stack_last - L->top > n)  /* stack large enough? */
00000a  68e1              LDR      r1,[r4,#0xc]
00000c  69e0              LDR      r0,[r4,#0x1c]
00000e  1a40              SUBS     r0,r0,r1
000010  ebb51f20          CMP      r5,r0,ASR #4
000014  da01              BGE      |L15.26|
;;;109        res = 1;  /* yes; check is OK */
000016  2601              MOVS     r6,#1
000018  e012              B        |L15.64|
                  |L15.26|
;;;110      else {  /* no; need to grow stack */
;;;111        int inuse = cast_int(L->top - L->stack) + EXTRA_STACK;
00001a  6a21              LDR      r1,[r4,#0x20]
00001c  68e0              LDR      r0,[r4,#0xc]
00001e  1a40              SUBS     r0,r0,r1
000020  2105              MOVS     r1,#5
000022  eb011820          ADD      r8,r1,r0,ASR #4
;;;112        if (inuse > LUAI_MAXSTACK - n)  /* can grow without overflow? */
000026  480d              LDR      r0,|L15.92|
000028  1b40              SUBS     r0,r0,r5
00002a  4540              CMP      r0,r8
00002c  da01              BGE      |L15.50|
;;;113          res = 0;  /* no */
00002e  2600              MOVS     r6,#0
000030  e005              B        |L15.62|
                  |L15.50|
;;;114        else  /* try to grow stack */
;;;115          res = luaD_growstack(L, n, 0);
000032  2200              MOVS     r2,#0
000034  4629              MOV      r1,r5
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       luaD_growstack
00003c  4606              MOV      r6,r0
                  |L15.62|
;;;116      }
00003e  bf00              NOP      
                  |L15.64|
;;;117      if (res && ci->top < L->top + n)
000040  b14e              CBZ      r6,|L15.86|
000042  68e0              LDR      r0,[r4,#0xc]
000044  eb001005          ADD      r0,r0,r5,LSL #4
000048  6879              LDR      r1,[r7,#4]
00004a  4288              CMP      r0,r1
00004c  d903              BLS      |L15.86|
;;;118        ci->top = L->top + n;  /* adjust frame top */
00004e  68e0              LDR      r0,[r4,#0xc]
000050  eb001005          ADD      r0,r0,r5,LSL #4
000054  6078              STR      r0,[r7,#4]
                  |L15.86|
;;;119      lua_unlock(L);
;;;120      return res;
000056  4630              MOV      r0,r6
;;;121    }
000058  e8bd81f0          POP      {r4-r8,pc}
;;;122    
                          ENDP

                  |L15.92|
                          DCD      0x000f4240

                          AREA ||i.lua_compare||, CODE, READONLY, ALIGN=2

                  lua_compare PROC
;;;324    
;;;325    LUA_API int lua_compare (lua_State *L, int index1, int index2, int op) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4680              MOV      r8,r0
000006  4689              MOV      r9,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
;;;326      const TValue *o1;
;;;327      const TValue *o2;
;;;328      int i = 0;
00000c  f04f0a00          MOV      r10,#0
;;;329      lua_lock(L);  /* may call tag method */
;;;330      o1 = index2value(L, index1);
000010  4649              MOV      r1,r9
000012  4640              MOV      r0,r8
000014  f7fffffe          BL       index2value
000018  4606              MOV      r6,r0
;;;331      o2 = index2value(L, index2);
00001a  4621              MOV      r1,r4
00001c  4640              MOV      r0,r8
00001e  f7fffffe          BL       index2value
000022  4607              MOV      r7,r0
;;;332      if (isvalid(o1) && isvalid(o2)) {
000024  4812              LDR      r0,|L16.112|
000026  4286              CMP      r6,r0
000028  d01e              BEQ      |L16.104|
00002a  4287              CMP      r7,r0
00002c  d01c              BEQ      |L16.104|
;;;333        switch (op) {
00002e  b125              CBZ      r5,|L16.58|
000030  2d01              CMP      r5,#1
000032  d009              BEQ      |L16.72|
000034  2d02              CMP      r5,#2
000036  d115              BNE      |L16.100|
000038  e00d              B        |L16.86|
                  |L16.58|
;;;334          case LUA_OPEQ: i = luaV_equalobj(L, o1, o2); break;
00003a  463a              MOV      r2,r7
00003c  4631              MOV      r1,r6
00003e  4640              MOV      r0,r8
000040  f7fffffe          BL       luaV_equalobj
000044  4682              MOV      r10,r0
000046  e00e              B        |L16.102|
                  |L16.72|
;;;335          case LUA_OPLT: i = luaV_lessthan(L, o1, o2); break;
000048  463a              MOV      r2,r7
00004a  4631              MOV      r1,r6
00004c  4640              MOV      r0,r8
00004e  f7fffffe          BL       luaV_lessthan
000052  4682              MOV      r10,r0
000054  e007              B        |L16.102|
                  |L16.86|
;;;336          case LUA_OPLE: i = luaV_lessequal(L, o1, o2); break;
000056  463a              MOV      r2,r7
000058  4631              MOV      r1,r6
00005a  4640              MOV      r0,r8
00005c  f7fffffe          BL       luaV_lessequal
000060  4682              MOV      r10,r0
000062  e000              B        |L16.102|
                  |L16.100|
000064  bf00              NOP                            ;333
                  |L16.102|
000066  bf00              NOP                            ;334
                  |L16.104|
;;;337          default: api_check(L, 0, "invalid option");
;;;338        }
;;;339      }
;;;340      lua_unlock(L);
;;;341      return i;
000068  4650              MOV      r0,r10
;;;342    }
00006a  e8bd87f0          POP      {r4-r10,pc}
;;;343    
                          ENDP

00006e  0000              DCW      0x0000
                  |L16.112|
                          DCD      luaO_nilobject_

                          AREA ||i.lua_concat||, CODE, READONLY, ALIGN=2

                  lua_concat PROC
;;;1234   
;;;1235   LUA_API void lua_concat (lua_State *L, int n) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;1236     lua_lock(L);
;;;1237     api_checknelems(L, n);
;;;1238     if (n >= 2) {
000008  2d02              CMP      r5,#2
00000a  db04              BLT      |L17.22|
;;;1239       luaV_concat(L, n);
00000c  4629              MOV      r1,r5
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       luaV_concat
000014  e010              B        |L17.56|
                  |L17.22|
;;;1240     }
;;;1241     else if (n == 0) {  /* push empty string */
000016  b97d              CBNZ     r5,|L17.56|
;;;1242       setsvalue2s(L, L->top, luaS_newlstr(L, "", 0));
000018  68e6              LDR      r6,[r4,#0xc]
00001a  2200              MOVS     r2,#0
00001c  a10b              ADR      r1,|L17.76|
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       luaS_newlstr
000024  4607              MOV      r7,r0
000026  6037              STR      r7,[r6,#0]
000028  7938              LDRB     r0,[r7,#4]
00002a  f0400040          ORR      r0,r0,#0x40
00002e  7230              STRB     r0,[r6,#8]
;;;1243       api_incr_top(L);
000030  68e0              LDR      r0,[r4,#0xc]
000032  3010              ADDS     r0,r0,#0x10
000034  60e0              STR      r0,[r4,#0xc]
000036  bf00              NOP      
                  |L17.56|
;;;1244     }
;;;1245     /* else n == 1; nothing to do */
;;;1246     luaC_checkGC(L);
000038  6920              LDR      r0,[r4,#0x10]
00003a  68c0              LDR      r0,[r0,#0xc]
00003c  2800              CMP      r0,#0
00003e  dd03              BLE      |L17.72|
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       luaC_step
000046  bf00              NOP      
                  |L17.72|
;;;1247     lua_unlock(L);
;;;1248   }
000048  e8bd81f0          POP      {r4-r8,pc}
;;;1249   
                          ENDP

                  |L17.76|
00004c  00                DCB      0
00004d  00                DCB      0
00004e  00                DCB      0
00004f  00                DCB      0

                          AREA ||i.lua_copy||, CODE, READONLY, ALIGN=2

                  lua_copy PROC
;;;228    
;;;229    LUA_API void lua_copy (lua_State *L, int fromidx, int toidx) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
;;;230      TValue *fr, *to;
;;;231      lua_lock(L);
;;;232      fr = index2value(L, fromidx);
00000a  4641              MOV      r1,r8
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       index2value
000012  4604              MOV      r4,r0
;;;233      to = index2value(L, toidx);
000014  4631              MOV      r1,r6
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       index2value
00001c  4607              MOV      r7,r0
;;;234      api_checkvalidindex(L, to);
;;;235      setobj(L, to, fr);
00001e  4638              MOV      r0,r7
000020  4621              MOV      r1,r4
000022  e9d12300          LDRD     r2,r3,[r1,#0]
000026  e9c02300          STRD     r2,r3,[r0,#0]
00002a  7a0a              LDRB     r2,[r1,#8]
00002c  7202              STRB     r2,[r0,#8]
;;;236      if (isupvalue(toidx))  /* function upvalue? */
00002e  480f              LDR      r0,|L18.108|
000030  4286              CMP      r6,r0
000032  da18              BGE      |L18.102|
;;;237        luaC_barrier(L, clCvalue(s2v(L->ci->func)), fr);
000034  7a20              LDRB     r0,[r4,#8]
000036  f0000040          AND      r0,r0,#0x40
00003a  b198              CBZ      r0,|L18.100|
00003c  6968              LDR      r0,[r5,#0x14]
00003e  6800              LDR      r0,[r0,#0]
000040  6800              LDR      r0,[r0,#0]
000042  7940              LDRB     r0,[r0,#5]
000044  f0000020          AND      r0,r0,#0x20
000048  b160              CBZ      r0,|L18.100|
00004a  6820              LDR      r0,[r4,#0]
00004c  7940              LDRB     r0,[r0,#5]
00004e  f0000018          AND      r0,r0,#0x18
000052  b138              CBZ      r0,|L18.100|
000054  6822              LDR      r2,[r4,#0]
000056  6968              LDR      r0,[r5,#0x14]
000058  6800              LDR      r0,[r0,#0]
00005a  6801              LDR      r1,[r0,#0]
00005c  4628              MOV      r0,r5
00005e  f7fffffe          BL       luaC_barrier_
000062  e000              B        |L18.102|
                  |L18.100|
000064  bf00              NOP      
                  |L18.102|
;;;238      /* LUA_REGISTRYINDEX does not need gc barrier
;;;239         (collector revisits it before finishing collection) */
;;;240      lua_unlock(L);
;;;241    }
000066  e8bd81f0          POP      {r4-r8,pc}
;;;242    
                          ENDP

00006a  0000              DCW      0x0000
                  |L18.108|
                          DCD      0xfff0b9d8

                          AREA ||i.lua_createtable||, CODE, READONLY, ALIGN=1

                  lua_createtable PROC
;;;728    
;;;729    LUA_API void lua_createtable (lua_State *L, int narray, int nrec) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;730      Table *t;
;;;731      lua_lock(L);
;;;732      t = luaH_new(L);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       luaH_new
000010  4607              MOV      r7,r0
;;;733      sethvalue2s(L, L->top, t);
000012  68e0              LDR      r0,[r4,#0xc]
000014  4639              MOV      r1,r7
000016  6001              STR      r1,[r0,#0]
000018  2245              MOVS     r2,#0x45
00001a  7202              STRB     r2,[r0,#8]
;;;734      api_incr_top(L);
00001c  68e0              LDR      r0,[r4,#0xc]
00001e  3010              ADDS     r0,r0,#0x10
000020  60e0              STR      r0,[r4,#0xc]
;;;735      if (narray > 0 || nrec > 0)
000022  2d00              CMP      r5,#0
000024  dc01              BGT      |L19.42|
000026  2e00              CMP      r6,#0
000028  dd05              BLE      |L19.54|
                  |L19.42|
;;;736        luaH_resize(L, t, narray, nrec);
00002a  4633              MOV      r3,r6
00002c  462a              MOV      r2,r5
00002e  4639              MOV      r1,r7
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       luaH_resize
                  |L19.54|
;;;737      luaC_checkGC(L);
000036  6920              LDR      r0,[r4,#0x10]
000038  68c0              LDR      r0,[r0,#0xc]
00003a  2800              CMP      r0,#0
00003c  dd03              BLE      |L19.70|
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       luaC_step
000044  bf00              NOP      
                  |L19.70|
;;;738      lua_unlock(L);
;;;739    }
000046  e8bd81f0          POP      {r4-r8,pc}
;;;740    
                          ENDP


                          AREA ||i.lua_dump||, CODE, READONLY, ALIGN=1

                  lua_dump PROC
;;;1080   
;;;1081   LUA_API int lua_dump (lua_State *L, lua_Writer writer, void *data, int strip) {
000000  e92d43f8          PUSH     {r3-r9,lr}
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;1082     int status;
;;;1083     TValue *o;
;;;1084     lua_lock(L);
;;;1085     api_checknelems(L, 1);
;;;1086     o = s2v(L->top - 1);
00000c  68e8              LDR      r0,[r5,#0xc]
00000e  f1a00910          SUB      r9,r0,#0x10
;;;1087     if (isLfunction(o))
000012  f8990008          LDRB     r0,[r9,#8]
000016  2856              CMP      r0,#0x56
000018  d10b              BNE      |L20.50|
;;;1088       status = luaU_dump(L, getproto(o), writer, data, strip);
00001a  f8cd8000          STR      r8,[sp,#0]
00001e  f8d90000          LDR      r0,[r9,#0]
000022  463b              MOV      r3,r7
000024  4632              MOV      r2,r6
000026  68c1              LDR      r1,[r0,#0xc]
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       luaU_dump
00002e  4604              MOV      r4,r0
000030  e000              B        |L20.52|
                  |L20.50|
;;;1089     else
;;;1090       status = 1;
000032  2401              MOVS     r4,#1
                  |L20.52|
;;;1091     lua_unlock(L);
;;;1092     return status;
000034  4620              MOV      r0,r4
;;;1093   }
000036  e8bd83f8          POP      {r3-r9,pc}
;;;1094   
                          ENDP


                          AREA ||i.lua_error||, CODE, READONLY, ALIGN=1

                  lua_error PROC
;;;1208   
;;;1209   LUA_API int lua_error (lua_State *L) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;1210     lua_lock(L);
;;;1211     api_checknelems(L, 1);
;;;1212     luaG_errormsg(L);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       luaG_errormsg
;;;1213     /* code unreachable; will unlock when control actually leaves the kernel */
;;;1214     return 0;  /* to avoid warnings */
00000a  2000              MOVS     r0,#0
;;;1215   }
00000c  bd10              POP      {r4,pc}
;;;1216   
                          ENDP


                          AREA ||i.lua_gc||, CODE, READONLY, ALIGN=1

                  lua_gc PROC
;;;1103   */
;;;1104   LUA_API int lua_gc (lua_State *L, int what, ...) {
000000  b40f              PUSH     {r0-r3}
000002  e92d4ff8          PUSH     {r3-r11,lr}
000006  4607              MOV      r7,r0
;;;1105     va_list argp;
;;;1106     int res = 0;
000008  f04f0800          MOV      r8,#0
;;;1107     global_State *g = G(L);
00000c  693c              LDR      r4,[r7,#0x10]
;;;1108     lua_lock(L);
;;;1109     va_start(argp, what);
00000e  a80c              ADD      r0,sp,#0x30
000010  9000              STR      r0,[sp,#0]
;;;1110     switch (what) {
000012  980b              LDR      r0,[sp,#0x2c]
000014  280c              CMP      r0,#0xc
000016  d271              BCS      |L22.252|
000018  e8dff000          TBB      [pc,r0]
00001c  060a1217          DCB      0x06,0x0a,0x12,0x17
000020  1d235060          DCB      0x1d,0x23,0x50,0x60
000024  c3717494          DCB      0xc3,0x71,0x74,0x94
;;;1111       case LUA_GCSTOP: {
;;;1112         g->gcrunning = 0;
000028  2000              MOVS     r0,#0
00002a  f8840039          STRB     r0,[r4,#0x39]
;;;1113         break;
00002e  e0bb              B        |L22.424|
;;;1114       }
;;;1115       case LUA_GCRESTART: {
;;;1116         luaE_setdebt(g, 0);
000030  2100              MOVS     r1,#0
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       luaE_setdebt
;;;1117         g->gcrunning = 1;
000038  2001              MOVS     r0,#1
00003a  f8840039          STRB     r0,[r4,#0x39]
;;;1118         break;
00003e  e0b3              B        |L22.424|
;;;1119       }
;;;1120       case LUA_GCCOLLECT: {
;;;1121         luaC_fullgc(L, 0);
000040  2100              MOVS     r1,#0
000042  4638              MOV      r0,r7
000044  f7fffffe          BL       luaC_fullgc
;;;1122         break;
000048  e0ae              B        |L22.424|
;;;1123       }
;;;1124       case LUA_GCCOUNT: {
;;;1125         /* GC values are expressed in Kbytes: #bytes/2^10 */
;;;1126         res = cast_int(gettotalbytes(g) >> 10);
00004a  e9d40102          LDRD     r0,r1,[r4,#8]
00004e  4408              ADD      r0,r0,r1
000050  ea4f2890          LSR      r8,r0,#10
;;;1127         break;
000054  e0a8              B        |L22.424|
;;;1128       }
;;;1129       case LUA_GCCOUNTB: {
;;;1130         res = cast_int(gettotalbytes(g) & 0x3ff);
000056  8920              LDRH     r0,[r4,#8]
000058  89a1              LDRH     r1,[r4,#0xc]
00005a  4408              ADD      r0,r0,r1
00005c  f3c00809          UBFX     r8,r0,#0,#10
;;;1131         break;
000060  e0a2              B        |L22.424|
;;;1132       }
;;;1133       case LUA_GCSTEP: {
;;;1134         int data = va_arg(argp, int);
000062  9800              LDR      r0,[sp,#0]
000064  c820              LDM      r0!,{r5}
000066  9000              STR      r0,[sp,#0]
;;;1135         l_mem debt = 1;  /* =1 to signal that it did an actual step */
000068  2601              MOVS     r6,#1
;;;1136         lu_byte oldrunning = g->gcrunning;
00006a  f8949039          LDRB     r9,[r4,#0x39]
;;;1137         g->gcrunning = 1;  /* allow GC to run */
00006e  2001              MOVS     r0,#1
000070  f8840039          STRB     r0,[r4,#0x39]
;;;1138         if (data == 0) {
000074  b93d              CBNZ     r5,|L22.134|
;;;1139           luaE_setdebt(g, 0);  /* do a basic step */
000076  2100              MOVS     r1,#0
000078  4620              MOV      r0,r4
00007a  f7fffffe          BL       luaE_setdebt
;;;1140           luaC_step(L);
00007e  4638              MOV      r0,r7
000080  f7fffffe          BL       luaC_step
000084  e00f              B        |L22.166|
                  |L22.134|
;;;1141         }
;;;1142         else {  /* add 'data' to total debt */
;;;1143           debt = cast(l_mem, data) * 1024 + g->GCdebt;
000086  68e0              LDR      r0,[r4,#0xc]
000088  eb002685          ADD      r6,r0,r5,LSL #10
;;;1144           luaE_setdebt(g, debt);
00008c  4631              MOV      r1,r6
00008e  4620              MOV      r0,r4
000090  f7fffffe          BL       luaE_setdebt
;;;1145           luaC_checkGC(L);
000094  6938              LDR      r0,[r7,#0x10]
000096  68c0              LDR      r0,[r0,#0xc]
000098  2800              CMP      r0,#0
00009a  dd03              BLE      |L22.164|
00009c  4638              MOV      r0,r7
00009e  f7fffffe          BL       luaC_step
0000a2  bf00              NOP      
                  |L22.164|
0000a4  bf00              NOP      
                  |L22.166|
;;;1146         }
;;;1147         g->gcrunning = oldrunning;  /* restore previous state */
0000a6  f8849039          STRB     r9,[r4,#0x39]
;;;1148         if (debt > 0 && g->gcstate == GCSpause)  /* end of cycle? */
0000aa  2e00              CMP      r6,#0
0000ac  dd05              BLE      |L22.186|
0000ae  f8940035          LDRB     r0,[r4,#0x35]
0000b2  2808              CMP      r0,#8
0000b4  d101              BNE      |L22.186|
;;;1149           res = 1;  /* signal it */
0000b6  f04f0801          MOV      r8,#1
                  |L22.186|
;;;1150         break;
0000ba  e075              B        |L22.424|
;;;1151       }
;;;1152       case LUA_GCSETPAUSE: {
;;;1153         int data = va_arg(argp, int);
0000bc  9900              LDR      r1,[sp,#0]
0000be  c901              LDM      r1!,{r0}
0000c0  9100              STR      r1,[sp,#0]
;;;1154         res = getgcparam(g->gcpause);
0000c2  f894103b          LDRB     r1,[r4,#0x3b]
0000c6  ea4f0881          LSL      r8,r1,#2
;;;1155         setgcparam(g->gcpause, data);
0000ca  4601              MOV      r1,r0
0000cc  17c2              ASRS     r2,r0,#31
0000ce  eb007292          ADD      r2,r0,r2,LSR #30
0000d2  f3c20287          UBFX     r2,r2,#2,#8
0000d6  f884203b          STRB     r2,[r4,#0x3b]
;;;1156         break;
0000da  e065              B        |L22.424|
;;;1157       }
;;;1158       case LUA_GCSETSTEPMUL: {
;;;1159         int data = va_arg(argp, int);
0000dc  9900              LDR      r1,[sp,#0]
0000de  c901              LDM      r1!,{r0}
0000e0  9100              STR      r1,[sp,#0]
;;;1160         res = getgcparam(g->gcstepmul);
0000e2  f894103c          LDRB     r1,[r4,#0x3c]
0000e6  ea4f0881          LSL      r8,r1,#2
;;;1161         setgcparam(g->gcstepmul, data);
0000ea  4601              MOV      r1,r0
0000ec  17c2              ASRS     r2,r0,#31
0000ee  eb007292          ADD      r2,r0,r2,LSR #30
0000f2  f3c20287          UBFX     r2,r2,#2,#8
0000f6  f884203c          STRB     r2,[r4,#0x3c]
;;;1162         break;
0000fa  e055              B        |L22.424|
                  |L22.252|
0000fc  e051              B        |L22.418|
;;;1163       }
;;;1164       case LUA_GCISRUNNING: {
;;;1165         res = g->gcrunning;
0000fe  f8948039          LDRB     r8,[r4,#0x39]
;;;1166         break;
000102  e051              B        |L22.424|
;;;1167       }
;;;1168       case LUA_GCGEN: {
;;;1169         int oldmode = g->gckind;
000104  f8949036          LDRB     r9,[r4,#0x36]
;;;1170         int minormul = va_arg(argp, int);
000108  9800              LDR      r0,[sp,#0]
00010a  c840              LDM      r0!,{r6}
00010c  9000              STR      r0,[sp,#0]
;;;1171         int majormul = va_arg(argp, int);
00010e  9800              LDR      r0,[sp,#0]
000110  c820              LDM      r0!,{r5}
000112  9000              STR      r0,[sp,#0]
;;;1172         if (minormul != 0)
000114  b10e              CBZ      r6,|L22.282|
;;;1173           g->genminormul = minormul;
000116  f8846037          STRB     r6,[r4,#0x37]
                  |L22.282|
;;;1174         if (majormul != 0)
00011a  b13d              CBZ      r5,|L22.300|
;;;1175           setgcparam(g->genmajormul, majormul);
00011c  4628              MOV      r0,r5
00011e  17e9              ASRS     r1,r5,#31
000120  eb057191          ADD      r1,r5,r1,LSR #30
000124  f3c10187          UBFX     r1,r1,#2,#8
000128  f8841038          STRB     r1,[r4,#0x38]
                  |L22.300|
;;;1176         luaC_changemode(L, KGC_GEN);
00012c  2101              MOVS     r1,#1
00012e  4638              MOV      r0,r7
000130  f7fffffe          BL       luaC_changemode
;;;1177         res = (oldmode == KGC_GEN) ? LUA_GCGEN : LUA_GCINC;
000134  f1b90f01          CMP      r9,#1
000138  d101              BNE      |L22.318|
00013a  200a              MOVS     r0,#0xa
00013c  e000              B        |L22.320|
                  |L22.318|
00013e  200b              MOVS     r0,#0xb
                  |L22.320|
000140  4680              MOV      r8,r0
;;;1178         break;
000142  e031              B        |L22.424|
;;;1179       }
;;;1180       case LUA_GCINC: {
;;;1181         int oldmode = g->gckind;
000144  f894a036          LDRB     r10,[r4,#0x36]
;;;1182         int pause = va_arg(argp, int);
000148  9800              LDR      r0,[sp,#0]
00014a  c820              LDM      r0!,{r5}
00014c  9000              STR      r0,[sp,#0]
;;;1183         int stepmul = va_arg(argp, int);
00014e  9800              LDR      r0,[sp,#0]
000150  c840              LDM      r0!,{r6}
000152  9000              STR      r0,[sp,#0]
;;;1184         int stepsize = va_arg(argp, int);
000154  9800              LDR      r0,[sp,#0]
000156  f8509b04          LDR      r9,[r0],#4
00015a  9000              STR      r0,[sp,#0]
;;;1185         if (pause != 0)
00015c  b13d              CBZ      r5,|L22.366|
;;;1186           setgcparam(g->gcpause, pause);
00015e  4628              MOV      r0,r5
000160  17e9              ASRS     r1,r5,#31
000162  eb057191          ADD      r1,r5,r1,LSR #30
000166  f3c10187          UBFX     r1,r1,#2,#8
00016a  f884103b          STRB     r1,[r4,#0x3b]
                  |L22.366|
;;;1187         if (stepmul != 0)
00016e  b13e              CBZ      r6,|L22.384|
;;;1188           setgcparam(g->gcstepmul, stepmul);
000170  4630              MOV      r0,r6
000172  17f1              ASRS     r1,r6,#31
000174  eb067191          ADD      r1,r6,r1,LSR #30
000178  f3c10187          UBFX     r1,r1,#2,#8
00017c  f884103c          STRB     r1,[r4,#0x3c]
                  |L22.384|
;;;1189         if (stepsize != 0)
000180  f1b90f00          CMP      r9,#0
000184  d001              BEQ      |L22.394|
;;;1190           g->gcstepsize = stepsize;
000186  f884903d          STRB     r9,[r4,#0x3d]
                  |L22.394|
;;;1191         luaC_changemode(L, KGC_INC);
00018a  2100              MOVS     r1,#0
00018c  4638              MOV      r0,r7
00018e  f7fffffe          BL       luaC_changemode
;;;1192         res = (oldmode == KGC_GEN) ? LUA_GCGEN : LUA_GCINC;
000192  f1ba0f01          CMP      r10,#1
000196  d101              BNE      |L22.412|
000198  200a              MOVS     r0,#0xa
00019a  e000              B        |L22.414|
                  |L22.412|
00019c  200b              MOVS     r0,#0xb
                  |L22.414|
00019e  4680              MOV      r8,r0
;;;1193         break;
0001a0  e002              B        |L22.424|
                  |L22.418|
;;;1194       }
;;;1195       default: res = -1;  /* invalid option */
0001a2  f04f38ff          MOV      r8,#0xffffffff
0001a6  bf00              NOP                            ;1110
                  |L22.424|
0001a8  bf00              NOP                            ;1113
;;;1196     }
;;;1197     va_end(argp);
0001aa  2000              MOVS     r0,#0
0001ac  9000              STR      r0,[sp,#0]
;;;1198     lua_unlock(L);
;;;1199     return res;
0001ae  4640              MOV      r0,r8
;;;1200   }
0001b0  e8bd0ff8          POP      {r3-r11}
0001b4  f85dfb14          LDR      pc,[sp],#0x14
;;;1201   
                          ENDP


                          AREA ||i.lua_getallocf||, CODE, READONLY, ALIGN=1

                  lua_getallocf PROC
;;;1260   
;;;1261   LUA_API lua_Alloc lua_getallocf (lua_State *L, void **ud) {
000000  4602              MOV      r2,r0
;;;1262     lua_Alloc f;
;;;1263     lua_lock(L);
;;;1264     if (ud) *ud = G(L)->ud;
000002  b111              CBZ      r1,|L23.10|
000004  6913              LDR      r3,[r2,#0x10]
000006  685b              LDR      r3,[r3,#4]
000008  600b              STR      r3,[r1,#0]
                  |L23.10|
;;;1265     f = G(L)->frealloc;
00000a  6913              LDR      r3,[r2,#0x10]
00000c  6818              LDR      r0,[r3,#0]
;;;1266     lua_unlock(L);
;;;1267     return f;
;;;1268   }
00000e  4770              BX       lr
;;;1269   
                          ENDP


                          AREA ||i.lua_getfield||, CODE, READONLY, ALIGN=1

                  lua_getfield PROC
;;;634    
;;;635    LUA_API int lua_getfield (lua_State *L, int idx, const char *k) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;636      lua_lock(L);
;;;637      return auxgetstr(L, index2value(L, idx), k);
00000a  4629              MOV      r1,r5
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       index2value
000012  4607              MOV      r7,r0
000014  4632              MOV      r2,r6
000016  4639              MOV      r1,r7
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       auxgetstr
;;;638    }
00001e  e8bd81f0          POP      {r4-r8,pc}
;;;639    
                          ENDP


                          AREA ||i.lua_getglobal||, CODE, READONLY, ALIGN=1

                  lua_getglobal PROC
;;;612    
;;;613    LUA_API int lua_getglobal (lua_State *L, const char *name) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;614      Table *reg = hvalue(&G(L)->l_registry);
000008  6920              LDR      r0,[r4,#0x10]
00000a  6a06              LDR      r6,[r0,#0x20]
;;;615      lua_lock(L);
;;;616      return auxgetstr(L, luaH_getint(reg, LUA_RIDX_GLOBALS), name);
00000c  2202              MOVS     r2,#2
00000e  2300              MOVS     r3,#0
000010  4630              MOV      r0,r6
000012  f7fffffe          BL       luaH_getint
000016  4607              MOV      r7,r0
000018  462a              MOV      r2,r5
00001a  4639              MOV      r1,r7
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       auxgetstr
;;;617    }
000022  e8bd81f0          POP      {r4-r8,pc}
;;;618    
                          ENDP


                          AREA ||i.lua_geti||, CODE, READONLY, ALIGN=1

                  lua_geti PROC
;;;640    
;;;641    LUA_API int lua_geti (lua_State *L, int idx, lua_Integer n) {
000000  e92d43f0          PUSH     {r4-r9,lr}
000004  b087              SUB      sp,sp,#0x1c
000006  4606              MOV      r6,r0
000008  4689              MOV      r9,r1
00000a  4614              MOV      r4,r2
00000c  461d              MOV      r5,r3
;;;642      TValue *t;
;;;643      const TValue *slot;
;;;644      lua_lock(L);
;;;645      t = index2value(L, idx);
00000e  4649              MOV      r1,r9
000010  4630              MOV      r0,r6
000012  f7fffffe          BL       index2value
000016  4680              MOV      r8,r0
;;;646      if (luaV_fastgeti(L, t, n, slot)) {
000018  f8980008          LDRB     r0,[r8,#8]
00001c  2845              CMP      r0,#0x45
00001e  d002              BEQ      |L26.38|
000020  2700              MOVS     r7,#0
000022  2000              MOVS     r0,#0
000024  e01e              B        |L26.100|
                  |L26.38|
000026  1e63              SUBS     r3,r4,#1
000028  f1650100          SBC      r1,r5,#0
00002c  f8d80000          LDR      r0,[r8,#0]
000030  6880              LDR      r0,[r0,#8]
000032  1a18              SUBS     r0,r3,r0
000034  f1710100          SBCS     r1,r1,#0
000038  d206              BCS      |L26.72|
00003a  f8d80000          LDR      r0,[r8,#0]
00003e  68c1              LDR      r1,[r0,#0xc]
000040  1e60              SUBS     r0,r4,#1
000042  eb011000          ADD      r0,r1,r0,LSL #4
000046  e005              B        |L26.84|
                  |L26.72|
000048  4622              MOV      r2,r4
00004a  462b              MOV      r3,r5
00004c  f8d80000          LDR      r0,[r8,#0]
000050  f7fffffe          BL       luaH_getint
                  |L26.84|
000054  4607              MOV      r7,r0
000056  7a38              LDRB     r0,[r7,#8]
000058  f000000f          AND      r0,r0,#0xf
00005c  b108              CBZ      r0,|L26.98|
00005e  2001              MOVS     r0,#1
000060  e000              B        |L26.100|
                  |L26.98|
000062  2000              MOVS     r0,#0
                  |L26.100|
000064  b140              CBZ      r0,|L26.120|
;;;647        setobj2s(L, L->top, slot);
000066  68f0              LDR      r0,[r6,#0xc]
000068  4639              MOV      r1,r7
00006a  e9d12300          LDRD     r2,r3,[r1,#0]
00006e  e9c02300          STRD     r2,r3,[r0,#0]
000072  7a0a              LDRB     r2,[r1,#8]
000074  7202              STRB     r2,[r0,#8]
000076  e00c              B        |L26.146|
                  |L26.120|
;;;648      }
;;;649      else {
;;;650        TValue aux;
;;;651        setivalue(&aux, n);
000078  a802              ADD      r0,sp,#8
00007a  e9c04500          STRD     r4,r5,[r0,#0]
00007e  2123              MOVS     r1,#0x23
000080  7201              STRB     r1,[r0,#8]
;;;652        luaV_finishget(L, t, &aux, L->top, slot);
000082  9700              STR      r7,[sp,#0]
000084  aa02              ADD      r2,sp,#8
000086  4641              MOV      r1,r8
000088  4630              MOV      r0,r6
00008a  68f3              LDR      r3,[r6,#0xc]
00008c  f7fffffe          BL       luaV_finishget
;;;653      }
000090  bf00              NOP      
                  |L26.146|
;;;654      api_incr_top(L);
000092  68f0              LDR      r0,[r6,#0xc]
000094  3010              ADDS     r0,r0,#0x10
000096  60f0              STR      r0,[r6,#0xc]
;;;655      lua_unlock(L);
;;;656      return ttype(s2v(L->top - 1));
000098  68f0              LDR      r0,[r6,#0xc]
00009a  f8100c08          LDRB     r0,[r0,#-8]
00009e  f000000f          AND      r0,r0,#0xf
;;;657    }
0000a2  b007              ADD      sp,sp,#0x1c
0000a4  e8bd83f0          POP      {r4-r9,pc}
;;;658    
                          ENDP


                          AREA ||i.lua_getiuservalue||, CODE, READONLY, ALIGN=1

                  lua_getiuservalue PROC
;;;768    
;;;769    LUA_API int lua_getiuservalue (lua_State *L, int idx, int n) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4615              MOV      r5,r2
;;;770      TValue *o;
;;;771      int t;
;;;772      lua_lock(L);
;;;773      o = index2value(L, idx);
00000a  4641              MOV      r1,r8
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       index2value
000012  4607              MOV      r7,r0
;;;774      api_check(L, ttisfulluserdata(o), "full userdata expected");
;;;775      if (n <= 0 || n > uvalue(o)->nuvalue) {
000014  2d00              CMP      r5,#0
000016  dd03              BLE      |L27.32|
000018  6838              LDR      r0,[r7,#0]
00001a  88c0              LDRH     r0,[r0,#6]
00001c  42a8              CMP      r0,r5
00001e  da04              BGE      |L27.42|
                  |L27.32|
;;;776        setnilvalue(s2v(L->top));
000020  2000              MOVS     r0,#0
000022  68e1              LDR      r1,[r4,#0xc]
000024  7208              STRB     r0,[r1,#8]
;;;777        t = LUA_TNONE;
000026  1e46              SUBS     r6,r0,#1
000028  e00f              B        |L27.74|
                  |L27.42|
;;;778      }
;;;779      else {
;;;780        setobj2s(L, L->top, &uvalue(o)->uv[n - 1].uv);
00002a  68e0              LDR      r0,[r4,#0xc]
00002c  683a              LDR      r2,[r7,#0]
00002e  3218              ADDS     r2,r2,#0x18
000030  1e6b              SUBS     r3,r5,#1
000032  eb021103          ADD      r1,r2,r3,LSL #4
000036  e9d12300          LDRD     r2,r3,[r1,#0]
00003a  e9c02300          STRD     r2,r3,[r0,#0]
00003e  7a0a              LDRB     r2,[r1,#8]
000040  7202              STRB     r2,[r0,#8]
;;;781        t = ttype(s2v(L->top));
000042  68e0              LDR      r0,[r4,#0xc]
000044  7a00              LDRB     r0,[r0,#8]
000046  f000060f          AND      r6,r0,#0xf
                  |L27.74|
;;;782      }
;;;783      api_incr_top(L);
00004a  68e0              LDR      r0,[r4,#0xc]
00004c  3010              ADDS     r0,r0,#0x10
00004e  60e0              STR      r0,[r4,#0xc]
;;;784      lua_unlock(L);
;;;785      return t;
000050  4630              MOV      r0,r6
;;;786    }
000052  e8bd81f0          POP      {r4-r8,pc}
;;;787    
                          ENDP


                          AREA ||i.lua_getmetatable||, CODE, READONLY, ALIGN=1

                  lua_getmetatable PROC
;;;741    
;;;742    LUA_API int lua_getmetatable (lua_State *L, int objindex) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
;;;743      const TValue *obj;
;;;744      Table *mt;
;;;745      int res = 0;
000008  f04f0800          MOV      r8,#0
;;;746      lua_lock(L);
;;;747      obj = index2value(L, objindex);
00000c  4639              MOV      r1,r7
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       index2value
000014  4606              MOV      r6,r0
;;;748      switch (ttype(obj)) {
000016  7a30              LDRB     r0,[r6,#8]
000018  f000000f          AND      r0,r0,#0xf
00001c  2805              CMP      r0,#5
00001e  d002              BEQ      |L28.38|
000020  2807              CMP      r0,#7
000022  d106              BNE      |L28.50|
000024  e002              B        |L28.44|
                  |L28.38|
;;;749        case LUA_TTABLE:
;;;750          mt = hvalue(obj)->metatable;
000026  6830              LDR      r0,[r6,#0]
000028  6984              LDR      r4,[r0,#0x18]
;;;751          break;
00002a  e00b              B        |L28.68|
                  |L28.44|
;;;752        case LUA_TUSERDATA:
;;;753          mt = uvalue(obj)->metatable;
00002c  6830              LDR      r0,[r6,#0]
00002e  68c4              LDR      r4,[r0,#0xc]
;;;754          break;
000030  e008              B        |L28.68|
                  |L28.50|
;;;755        default:
;;;756          mt = G(L)->mt[ttype(obj)];
000032  6928              LDR      r0,[r5,#0x10]
000034  f5007080          ADD      r0,r0,#0x100
000038  7a31              LDRB     r1,[r6,#8]
00003a  f001010f          AND      r1,r1,#0xf
00003e  f8504021          LDR      r4,[r0,r1,LSL #2]
;;;757          break;
000042  bf00              NOP      
                  |L28.68|
000044  bf00              NOP                            ;751
;;;758      }
;;;759      if (mt != NULL) {
000046  b14c              CBZ      r4,|L28.92|
;;;760        sethvalue2s(L, L->top, mt);
000048  68e8              LDR      r0,[r5,#0xc]
00004a  4621              MOV      r1,r4
00004c  6001              STR      r1,[r0,#0]
00004e  2245              MOVS     r2,#0x45
000050  7202              STRB     r2,[r0,#8]
;;;761        api_incr_top(L);
000052  68e8              LDR      r0,[r5,#0xc]
000054  3010              ADDS     r0,r0,#0x10
000056  60e8              STR      r0,[r5,#0xc]
;;;762        res = 1;
000058  f04f0801          MOV      r8,#1
                  |L28.92|
;;;763      }
;;;764      lua_unlock(L);
;;;765      return res;
00005c  4640              MOV      r0,r8
;;;766    }
00005e  e8bd81f0          POP      {r4-r8,pc}
;;;767    
                          ENDP


                          AREA ||i.lua_gettable||, CODE, READONLY, ALIGN=1

                  lua_gettable PROC
;;;619    
;;;620    LUA_API int lua_gettable (lua_State *L, int idx) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4605              MOV      r5,r0
000004  460f              MOV      r7,r1
;;;621      const TValue *slot;
;;;622      TValue *t;
;;;623      lua_lock(L);
;;;624      t = index2value(L, idx);
000006  4639              MOV      r1,r7
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       index2value
00000e  4606              MOV      r6,r0
;;;625      if (luaV_fastget(L, t, s2v(L->top - 1), slot, luaH_get)) {
000010  7a30              LDRB     r0,[r6,#8]
000012  2845              CMP      r0,#0x45
000014  d002              BEQ      |L29.28|
000016  2400              MOVS     r4,#0
000018  2000              MOVS     r0,#0
00001a  e00d              B        |L29.56|
                  |L29.28|
00001c  68ea              LDR      r2,[r5,#0xc]
00001e  f1a20110          SUB      r1,r2,#0x10
000022  6830              LDR      r0,[r6,#0]
000024  f7fffffe          BL       luaH_get
000028  4604              MOV      r4,r0
00002a  7a20              LDRB     r0,[r4,#8]
00002c  f000000f          AND      r0,r0,#0xf
000030  b108              CBZ      r0,|L29.54|
000032  2001              MOVS     r0,#1
000034  e000              B        |L29.56|
                  |L29.54|
000036  2000              MOVS     r0,#0
                  |L29.56|
000038  b150              CBZ      r0,|L29.80|
;;;626        setobj2s(L, L->top - 1, slot);
00003a  68ea              LDR      r2,[r5,#0xc]
00003c  f1a20010          SUB      r0,r2,#0x10
000040  4621              MOV      r1,r4
000042  e9d12300          LDRD     r2,r3,[r1,#0]
000046  e9c02300          STRD     r2,r3,[r0,#0]
00004a  7a0a              LDRB     r2,[r1,#8]
00004c  7202              STRB     r2,[r0,#8]
00004e  e008              B        |L29.98|
                  |L29.80|
;;;627      }
;;;628      else
;;;629        luaV_finishget(L, t, s2v(L->top - 1), L->top - 1, slot);
000050  9400              STR      r4,[sp,#0]
000052  68e8              LDR      r0,[r5,#0xc]
000054  f1a00310          SUB      r3,r0,#0x10
000058  461a              MOV      r2,r3
00005a  4631              MOV      r1,r6
00005c  4628              MOV      r0,r5
00005e  f7fffffe          BL       luaV_finishget
                  |L29.98|
;;;630      lua_unlock(L);
;;;631      return ttype(s2v(L->top - 1));
000062  68e8              LDR      r0,[r5,#0xc]
000064  f8100c08          LDRB     r0,[r0,#-8]
000068  f000000f          AND      r0,r0,#0xf
;;;632    }
00006c  bdf8              POP      {r3-r7,pc}
;;;633    
                          ENDP


                          AREA ||i.lua_gettop||, CODE, READONLY, ALIGN=1

                  lua_gettop PROC
;;;172    
;;;173    LUA_API int lua_gettop (lua_State *L) {
000000  4601              MOV      r1,r0
;;;174      return cast_int(L->top - (L->ci->func + 1));
000002  68ca              LDR      r2,[r1,#0xc]
000004  6948              LDR      r0,[r1,#0x14]
000006  6800              LDR      r0,[r0,#0]
000008  3010              ADDS     r0,r0,#0x10
00000a  1a10              SUBS     r0,r2,r0
00000c  1100              ASRS     r0,r0,#4
;;;175    }
00000e  4770              BX       lr
;;;176    
                          ENDP


                          AREA ||i.lua_getupvalue||, CODE, READONLY, ALIGN=1

                  lua_getupvalue PROC
;;;1317   
;;;1318   LUA_API const char *lua_getupvalue (lua_State *L, int funcindex, int n) {
000000  e92d43f8          PUSH     {r3-r9,lr}
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;1319     const char *name;
;;;1320     TValue *val = NULL;  /* to avoid warnings */
00000a  2000              MOVS     r0,#0
00000c  9000              STR      r0,[sp,#0]
;;;1321     lua_lock(L);
;;;1322     name = aux_upvalue(index2value(L, funcindex), n, &val, NULL);
00000e  4639              MOV      r1,r7
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       index2value
000016  4680              MOV      r8,r0
000018  2300              MOVS     r3,#0
00001a  466a              MOV      r2,sp
00001c  4629              MOV      r1,r5
00001e  f7fffffe          BL       aux_upvalue
000022  4606              MOV      r6,r0
;;;1323     if (name) {
000024  b15e              CBZ      r6,|L31.62|
;;;1324       setobj2s(L, L->top, val);
000026  68e0              LDR      r0,[r4,#0xc]
000028  9900              LDR      r1,[sp,#0]
00002a  e9d12300          LDRD     r2,r3,[r1,#0]
00002e  e9c02300          STRD     r2,r3,[r0,#0]
000032  7a0a              LDRB     r2,[r1,#8]
000034  7202              STRB     r2,[r0,#8]
;;;1325       api_incr_top(L);
000036  68e0              LDR      r0,[r4,#0xc]
000038  3010              ADDS     r0,r0,#0x10
00003a  60e0              STR      r0,[r4,#0xc]
00003c  bf00              NOP      
                  |L31.62|
;;;1326     }
;;;1327     lua_unlock(L);
;;;1328     return name;
00003e  4630              MOV      r0,r6
;;;1329   }
000040  e8bd83f8          POP      {r3-r9,pc}
;;;1330   
                          ENDP


                          AREA ||i.lua_iscfunction||, CODE, READONLY, ALIGN=1

                  lua_iscfunction PROC
;;;270    
;;;271    LUA_API int lua_iscfunction (lua_State *L, int idx) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;272      const TValue *o = index2value(L, idx);
000006  4631              MOV      r1,r6
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       index2value
00000e  4604              MOV      r4,r0
;;;273      return (ttislcf(o) || (ttisCclosure(o)));
000010  7a20              LDRB     r0,[r4,#8]
000012  2826              CMP      r0,#0x26
000014  d002              BEQ      |L32.28|
000016  7a20              LDRB     r0,[r4,#8]
000018  2876              CMP      r0,#0x76
00001a  d101              BNE      |L32.32|
                  |L32.28|
00001c  2001              MOVS     r0,#1
                  |L32.30|
;;;274    }
00001e  bd70              POP      {r4-r6,pc}
                  |L32.32|
000020  2000              MOVS     r0,#0                 ;273
000022  e7fc              B        |L32.30|
;;;275    
                          ENDP


                          AREA ||i.lua_isinteger||, CODE, READONLY, ALIGN=1

                  lua_isinteger PROC
;;;276    
;;;277    LUA_API int lua_isinteger (lua_State *L, int idx) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;278      const TValue *o = index2value(L, idx);
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       index2value
00000e  4606              MOV      r6,r0
;;;279      return ttisinteger(o);
000010  7a30              LDRB     r0,[r6,#8]
000012  2823              CMP      r0,#0x23
000014  d101              BNE      |L33.26|
000016  2001              MOVS     r0,#1
                  |L33.24|
;;;280    }
000018  bd70              POP      {r4-r6,pc}
                  |L33.26|
00001a  2000              MOVS     r0,#0                 ;279
00001c  e7fc              B        |L33.24|
;;;281    
                          ENDP


                          AREA ||i.lua_isnumber||, CODE, READONLY, ALIGN=1

                  lua_isnumber PROC
;;;282    
;;;283    LUA_API int lua_isnumber (lua_State *L, int idx) {
000000  b57c              PUSH     {r2-r6,lr}
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;284      lua_Number n;
;;;285      const TValue *o = index2value(L, idx);
000006  4631              MOV      r1,r6
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       index2value
00000e  4604              MOV      r4,r0
;;;286      return tonumber(o, &n);
000010  7a20              LDRB     r0,[r4,#8]
000012  2813              CMP      r0,#0x13
000014  d105              BNE      |L34.34|
000016  e9d40100          LDRD     r0,r1,[r4,#0]
00001a  e9cd0100          STRD     r0,r1,[sp,#0]
00001e  2001              MOVS     r0,#1
                  |L34.32|
;;;287    }
000020  bd7c              POP      {r2-r6,pc}
                  |L34.34|
000022  4669              MOV      r1,sp                 ;286
000024  4620              MOV      r0,r4                 ;286
000026  f7fffffe          BL       luaV_tonumber_
00002a  e7f9              B        |L34.32|
;;;288    
                          ENDP


                          AREA ||i.lua_isstring||, CODE, READONLY, ALIGN=1

                  lua_isstring PROC
;;;289    
;;;290    LUA_API int lua_isstring (lua_State *L, int idx) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;291      const TValue *o = index2value(L, idx);
000006  4631              MOV      r1,r6
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       index2value
00000e  4604              MOV      r4,r0
;;;292      return (ttisstring(o) || cvt2str(o));
000010  7a20              LDRB     r0,[r4,#8]
000012  f000000f          AND      r0,r0,#0xf
000016  2804              CMP      r0,#4
000018  d004              BEQ      |L35.36|
00001a  7a20              LDRB     r0,[r4,#8]
00001c  f000000f          AND      r0,r0,#0xf
000020  2803              CMP      r0,#3
000022  d101              BNE      |L35.40|
                  |L35.36|
000024  2001              MOVS     r0,#1
                  |L35.38|
;;;293    }
000026  bd70              POP      {r4-r6,pc}
                  |L35.40|
000028  2000              MOVS     r0,#0                 ;292
00002a  e7fc              B        |L35.38|
;;;294    
                          ENDP


                          AREA ||i.lua_isuserdata||, CODE, READONLY, ALIGN=1

                  lua_isuserdata PROC
;;;295    
;;;296    LUA_API int lua_isuserdata (lua_State *L, int idx) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;297      const TValue *o = index2value(L, idx);
000006  4631              MOV      r1,r6
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       index2value
00000e  4604              MOV      r4,r0
;;;298      return (ttisfulluserdata(o) || ttislightuserdata(o));
000010  7a20              LDRB     r0,[r4,#8]
000012  f000000f          AND      r0,r0,#0xf
000016  2807              CMP      r0,#7
000018  d002              BEQ      |L36.32|
00001a  7a20              LDRB     r0,[r4,#8]
00001c  2802              CMP      r0,#2
00001e  d101              BNE      |L36.36|
                  |L36.32|
000020  2001              MOVS     r0,#1
                  |L36.34|
;;;299    }
000022  bd70              POP      {r4-r6,pc}
                  |L36.36|
000024  2000              MOVS     r0,#0                 ;298
000026  e7fc              B        |L36.34|
;;;300    
                          ENDP


                          AREA ||i.lua_keyin||, CODE, READONLY, ALIGN=1

                  lua_keyin PROC
;;;723    
;;;724    LUA_API int lua_keyin (lua_State *L, int idx) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;725      return auxkeydef(L, idx, 0);
000006  2200              MOVS     r2,#0
000008  4629              MOV      r1,r5
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       auxkeydef
;;;726    }
000010  bd70              POP      {r4-r6,pc}
;;;727    
                          ENDP


                          AREA ||i.lua_len||, CODE, READONLY, ALIGN=1

                  lua_len PROC
;;;1250   
;;;1251   LUA_API void lua_len (lua_State *L, int idx) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1252     TValue *t;
;;;1253     lua_lock(L);
;;;1254     t = index2value(L, idx);
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       index2value
00000e  4606              MOV      r6,r0
;;;1255     luaV_objlen(L, L->top, t);
000010  4632              MOV      r2,r6
000012  4620              MOV      r0,r4
000014  68e1              LDR      r1,[r4,#0xc]
000016  f7fffffe          BL       luaV_objlen
;;;1256     api_incr_top(L);
00001a  68e0              LDR      r0,[r4,#0xc]
00001c  3010              ADDS     r0,r0,#0x10
00001e  60e0              STR      r0,[r4,#0xc]
;;;1257     lua_unlock(L);
;;;1258   }
000020  bd70              POP      {r4-r6,pc}
;;;1259   
                          ENDP


                          AREA ||i.lua_load||, CODE, READONLY, ALIGN=2

                  lua_load PROC
;;;1056   
;;;1057   LUA_API int lua_load (lua_State *L, lua_Reader reader, void *data,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1058                         const char *chunkname, const char *mode) {
000004  b085              SUB      sp,sp,#0x14
000006  4606              MOV      r6,r0
000008  4689              MOV      r9,r1
00000a  4692              MOV      r10,r2
00000c  461f              MOV      r7,r3
;;;1059     ZIO z;
;;;1060     int status;
;;;1061     lua_lock(L);
;;;1062     if (!chunkname) chunkname = "?";
00000e  b907              CBNZ     r7,|L39.18|
000010  a721              ADR      r7,|L39.152|
                  |L39.18|
;;;1063     luaZ_init(L, &z, reader, data);
000012  4653              MOV      r3,r10
000014  464a              MOV      r2,r9
000016  4669              MOV      r1,sp
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       luaZ_init
;;;1064     status = luaD_protectedparser(L, &z, chunkname, mode);
00001e  463a              MOV      r2,r7
000020  4669              MOV      r1,sp
000022  4630              MOV      r0,r6
000024  9b0e              LDR      r3,[sp,#0x38]
000026  f7fffffe          BL       luaD_protectedparser
00002a  4680              MOV      r8,r0
;;;1065     if (status == LUA_OK) {  /* no errors? */
00002c  f1b80f00          CMP      r8,#0
000030  d12e              BNE      |L39.144|
;;;1066       LClosure *f = clLvalue(s2v(L->top - 1));  /* get newly created function */
000032  68f0              LDR      r0,[r6,#0xc]
000034  f8505c10          LDR      r5,[r0,#-0x10]
;;;1067       if (f->nupvalues >= 1) {  /* does it have an upvalue? */
000038  79a8              LDRB     r0,[r5,#6]
00003a  2801              CMP      r0,#1
00003c  db27              BLT      |L39.142|
;;;1068         /* get global table from registry */
;;;1069         Table *reg = hvalue(&G(L)->l_registry);
00003e  6930              LDR      r0,[r6,#0x10]
000040  f8d0b020          LDR      r11,[r0,#0x20]
;;;1070         const TValue *gt = luaH_getint(reg, LUA_RIDX_GLOBALS);
000044  2202              MOVS     r2,#2
000046  2300              MOVS     r3,#0
000048  4658              MOV      r0,r11
00004a  f7fffffe          BL       luaH_getint
00004e  4604              MOV      r4,r0
;;;1071         /* set global table as 1st upvalue of 'f' (may be LUA_ENV) */
;;;1072         setobj(L, f->upvals[0]->v, gt);
000050  692a              LDR      r2,[r5,#0x10]
000052  6890              LDR      r0,[r2,#8]
000054  4621              MOV      r1,r4
000056  e9d12300          LDRD     r2,r3,[r1,#0]
00005a  e9c02300          STRD     r2,r3,[r0,#0]
00005e  7a0a              LDRB     r2,[r1,#8]
000060  7202              STRB     r2,[r0,#8]
;;;1073         luaC_barrier(L, f->upvals[0], gt);
000062  7a20              LDRB     r0,[r4,#8]
000064  f0000040          AND      r0,r0,#0x40
000068  b178              CBZ      r0,|L39.138|
00006a  6928              LDR      r0,[r5,#0x10]
00006c  7940              LDRB     r0,[r0,#5]
00006e  f0000020          AND      r0,r0,#0x20
000072  b150              CBZ      r0,|L39.138|
000074  6820              LDR      r0,[r4,#0]
000076  7940              LDRB     r0,[r0,#5]
000078  f0000018          AND      r0,r0,#0x18
00007c  b128              CBZ      r0,|L39.138|
00007e  6822              LDR      r2,[r4,#0]
000080  4630              MOV      r0,r6
000082  6929              LDR      r1,[r5,#0x10]
000084  f7fffffe          BL       luaC_barrier_
000088  e000              B        |L39.140|
                  |L39.138|
00008a  bf00              NOP      
                  |L39.140|
;;;1074       }
00008c  bf00              NOP      
                  |L39.142|
;;;1075     }
00008e  bf00              NOP      
                  |L39.144|
;;;1076     lua_unlock(L);
;;;1077     return status;
000090  4640              MOV      r0,r8
;;;1078   }
000092  b005              ADD      sp,sp,#0x14
000094  e8bd8ff0          POP      {r4-r11,pc}
;;;1079   
                          ENDP

                  |L39.152|
000098  3f00              DCB      "?",0
00009a  00                DCB      0
00009b  00                DCB      0

                          AREA ||i.lua_newuserdatauv||, CODE, READONLY, ALIGN=1

                  lua_newuserdatauv PROC
;;;1278   
;;;1279   LUA_API void *lua_newuserdatauv (lua_State *L, size_t size, int nuvalue) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;1280     Udata *u;
;;;1281     lua_lock(L);
;;;1282     api_check(L, 0 <= nuvalue && nuvalue < USHRT_MAX, "invalid value");
;;;1283     u = luaS_newudata(L, size, nuvalue);
00000a  463a              MOV      r2,r7
00000c  4631              MOV      r1,r6
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       luaS_newudata
000014  4605              MOV      r5,r0
;;;1284     setuvalue(L, s2v(L->top), u);
000016  68e0              LDR      r0,[r4,#0xc]
000018  4629              MOV      r1,r5
00001a  6001              STR      r1,[r0,#0]
00001c  2247              MOVS     r2,#0x47
00001e  7202              STRB     r2,[r0,#8]
;;;1285     api_incr_top(L);
000020  68e0              LDR      r0,[r4,#0xc]
000022  3010              ADDS     r0,r0,#0x10
000024  60e0              STR      r0,[r4,#0xc]
;;;1286     luaC_checkGC(L);
000026  6920              LDR      r0,[r4,#0x10]
000028  68c0              LDR      r0,[r0,#0xc]
00002a  2800              CMP      r0,#0
00002c  dd03              BLE      |L40.54|
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       luaC_step
000034  bf00              NOP      
                  |L40.54|
;;;1287     lua_unlock(L);
;;;1288     return getudatamem(u);
000036  88e8              LDRH     r0,[r5,#6]
000038  b908              CBNZ     r0,|L40.62|
00003a  2010              MOVS     r0,#0x10
00003c  e002              B        |L40.68|
                  |L40.62|
00003e  88e8              LDRH     r0,[r5,#6]
000040  0100              LSLS     r0,r0,#4
000042  3018              ADDS     r0,r0,#0x18
                  |L40.68|
000044  4428              ADD      r0,r0,r5
;;;1289   }
000046  e8bd81f0          POP      {r4-r8,pc}
;;;1290   
                          ENDP


                          AREA ||i.lua_next||, CODE, READONLY, ALIGN=1

                  lua_next PROC
;;;1217   
;;;1218   LUA_API int lua_next (lua_State *L, int idx) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;1219     Table *t;
;;;1220     int more;
;;;1221     lua_lock(L);
;;;1222     api_checknelems(L, 1);
;;;1223     t = gettable(L, idx);
000008  4631              MOV      r1,r6
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       gettable
000010  4607              MOV      r7,r0
;;;1224     more = luaH_next(L, t, L->top - 1);
000012  68e0              LDR      r0,[r4,#0xc]
000014  f1a00210          SUB      r2,r0,#0x10
000018  4639              MOV      r1,r7
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       luaH_next
000020  4605              MOV      r5,r0
;;;1225     if (more) {
000022  b11d              CBZ      r5,|L41.44|
;;;1226       api_incr_top(L);
000024  68e0              LDR      r0,[r4,#0xc]
000026  3010              ADDS     r0,r0,#0x10
000028  60e0              STR      r0,[r4,#0xc]
00002a  e002              B        |L41.50|
                  |L41.44|
;;;1227     }
;;;1228     else  /* no more elements */
;;;1229       L->top -= 1;  /* remove key */
00002c  68e0              LDR      r0,[r4,#0xc]
00002e  3810              SUBS     r0,r0,#0x10
000030  60e0              STR      r0,[r4,#0xc]
                  |L41.50|
;;;1230     lua_unlock(L);
;;;1231     return more;
000032  4628              MOV      r0,r5
;;;1232   }
000034  e8bd81f0          POP      {r4-r8,pc}
;;;1233   
                          ENDP


                          AREA ||i.lua_pcallk||, CODE, READONLY, ALIGN=2

                  lua_pcallk PROC
;;;1012   
;;;1013   LUA_API int lua_pcallk (lua_State *L, int nargs, int nresults, int errfunc,
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;1014                           lua_KContext ctx, lua_KFunction k) {
000004  4604              MOV      r4,r0
000006  468a              MOV      r10,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  f8ddb034          LDR      r11,[sp,#0x34]
;;;1015     struct CallS c;
;;;1016     int status;
;;;1017     ptrdiff_t func;
;;;1018     lua_lock(L);
;;;1019     api_check(L, k == NULL || !isLua(L->ci),
;;;1020       "cannot use continuations inside hooks");
;;;1021     api_checknelems(L, nargs+1);
;;;1022     api_check(L, L->status == LUA_OK, "cannot do calls on non-normal thread");
;;;1023     checkresults(L, nargs, nresults);
;;;1024     if (errfunc == 0)
000010  f1b80f00          CMP      r8,#0
000014  d101              BNE      |L42.26|
;;;1025       func = 0;
000016  2600              MOVS     r6,#0
000018  e007              B        |L42.42|
                  |L42.26|
;;;1026     else {
;;;1027       StkId o = index2stack(L, errfunc);
00001a  4641              MOV      r1,r8
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       index2stack
000022  4605              MOV      r5,r0
;;;1028       api_check(L, ttisfunction(s2v(o)), "error handler must be a function");
;;;1029       func = savestack(L, o);
000024  6a20              LDR      r0,[r4,#0x20]
000026  1a2e              SUBS     r6,r5,r0
;;;1030     }
000028  bf00              NOP      
                  |L42.42|
;;;1031     c.func = L->top - (nargs+1);  /* function to be called */
00002a  f10a0001          ADD      r0,r10,#1
00002e  68e1              LDR      r1,[r4,#0xc]
000030  eba11000          SUB      r0,r1,r0,LSL #4
000034  9001              STR      r0,[sp,#4]
;;;1032     if (k == NULL || L->nny > 0) {  /* no continuation or no yieldable? */
000036  f1bb0f00          CMP      r11,#0
00003a  d003              BEQ      |L42.68|
00003c  f8b4006c          LDRH     r0,[r4,#0x6c]
000040  2800              CMP      r0,#0
000042  dd0b              BLE      |L42.92|
                  |L42.68|
;;;1033       c.nresults = nresults;  /* do a 'conventional' protected call */
000044  9702              STR      r7,[sp,#8]
;;;1034       status = luaD_pcall(L, f_call, &c, savestack(L, c.func), func);
000046  9600              STR      r6,[sp,#0]
000048  9801              LDR      r0,[sp,#4]
00004a  6a21              LDR      r1,[r4,#0x20]
00004c  1a43              SUBS     r3,r0,r1
00004e  aa01              ADD      r2,sp,#4
000050  491b              LDR      r1,|L42.192|
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       luaD_pcall
000058  4681              MOV      r9,r0
00005a  e024              B        |L42.166|
                  |L42.92|
;;;1035     }
;;;1036     else {  /* prepare continuation (call is already protected by 'resume') */
;;;1037       CallInfo *ci = L->ci;
00005c  6965              LDR      r5,[r4,#0x14]
;;;1038       ci->u.c.k = k;  /* save continuation */
00005e  f8c5b010          STR      r11,[r5,#0x10]
;;;1039       ci->u.c.ctx = ctx;  /* save context */
000062  980c              LDR      r0,[sp,#0x30]
000064  61a8              STR      r0,[r5,#0x18]
;;;1040       /* save information for error recovery */
;;;1041       ci->u2.funcidx = cast_int(savestack(L, c.func));
000066  9801              LDR      r0,[sp,#4]
000068  6a21              LDR      r1,[r4,#0x20]
00006a  1a40              SUBS     r0,r0,r1
00006c  61e8              STR      r0,[r5,#0x1c]
;;;1042       ci->u.c.old_errfunc = L->errfunc;
00006e  6de1              LDR      r1,[r4,#0x5c]
000070  6169              STR      r1,[r5,#0x14]
;;;1043       L->errfunc = func;
000072  65e6              STR      r6,[r4,#0x5c]
;;;1044       setoah(ci->callstatus, L->allowhook);  /* save value of 'allowhook' */
000074  8c68              LDRH     r0,[r5,#0x22]
000076  f0200001          BIC      r0,r0,#1
00007a  f8941074          LDRB     r1,[r4,#0x74]
00007e  4308              ORRS     r0,r0,r1
000080  8468              STRH     r0,[r5,#0x22]
;;;1045       ci->callstatus |= CIST_YPCALL;  /* function can do error recovery */
000082  8c68              LDRH     r0,[r5,#0x22]
000084  f0400008          ORR      r0,r0,#8
000088  8468              STRH     r0,[r5,#0x22]
;;;1046       luaD_call(L, c.func, nresults);  /* do the call */
00008a  463a              MOV      r2,r7
00008c  4620              MOV      r0,r4
00008e  9901              LDR      r1,[sp,#4]
000090  f7fffffe          BL       luaD_call
;;;1047       ci->callstatus &= ~CIST_YPCALL;
000094  8c68              LDRH     r0,[r5,#0x22]
000096  f0200008          BIC      r0,r0,#8
00009a  8468              STRH     r0,[r5,#0x22]
;;;1048       L->errfunc = ci->u.c.old_errfunc;
00009c  6968              LDR      r0,[r5,#0x14]
00009e  65e0              STR      r0,[r4,#0x5c]
;;;1049       status = LUA_OK;  /* if it is here, there were no errors */
0000a0  f04f0900          MOV      r9,#0
;;;1050     }
0000a4  bf00              NOP      
                  |L42.166|
;;;1051     adjustresults(L, nresults);
0000a6  1c78              ADDS     r0,r7,#1
0000a8  b938              CBNZ     r0,|L42.186|
0000aa  6960              LDR      r0,[r4,#0x14]
0000ac  6840              LDR      r0,[r0,#4]
0000ae  68e1              LDR      r1,[r4,#0xc]
0000b0  4288              CMP      r0,r1
0000b2  d202              BCS      |L42.186|
0000b4  6961              LDR      r1,[r4,#0x14]
0000b6  68e0              LDR      r0,[r4,#0xc]
0000b8  6048              STR      r0,[r1,#4]
                  |L42.186|
;;;1052     lua_unlock(L);
;;;1053     return status;
0000ba  4648              MOV      r0,r9
;;;1054   }
0000bc  e8bd8ffe          POP      {r1-r11,pc}
;;;1055   
                          ENDP

                  |L42.192|
                          DCD      f_call

                          AREA ||i.lua_pushboolean||, CODE, READONLY, ALIGN=1

                  lua_pushboolean PROC
;;;564    
;;;565    LUA_API void lua_pushboolean (lua_State *L, int b) {
000000  68c2              LDR      r2,[r0,#0xc]
;;;566      lua_lock(L);
;;;567      setbvalue(s2v(L->top), (b != 0));  /* ensure that true is 1 */
000002  b109              CBZ      r1,|L43.8|
000004  2301              MOVS     r3,#1
000006  e000              B        |L43.10|
                  |L43.8|
000008  2300              MOVS     r3,#0
                  |L43.10|
00000a  6013              STR      r3,[r2,#0]
00000c  2301              MOVS     r3,#1
00000e  7213              STRB     r3,[r2,#8]
;;;568      api_incr_top(L);
000010  68c2              LDR      r2,[r0,#0xc]
000012  3210              ADDS     r2,r2,#0x10
000014  60c2              STR      r2,[r0,#0xc]
;;;569      lua_unlock(L);
;;;570    }
000016  4770              BX       lr
;;;571    
                          ENDP


                          AREA ||i.lua_pushcclosure||, CODE, READONLY, ALIGN=1

                  lua_pushcclosure PROC
;;;539    
;;;540    LUA_API void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;541      lua_lock(L);
;;;542      if (n == 0) {
00000a  b93d              CBNZ     r5,|L44.28|
;;;543        setfvalue(s2v(L->top), fn);
00000c  68e0              LDR      r0,[r4,#0xc]
00000e  6007              STR      r7,[r0,#0]
000010  2126              MOVS     r1,#0x26
000012  7201              STRB     r1,[r0,#8]
;;;544        api_incr_top(L);
000014  68e0              LDR      r0,[r4,#0xc]
000016  3010              ADDS     r0,r0,#0x10
000018  60e0              STR      r0,[r4,#0xc]
00001a  e02d              B        |L44.120|
                  |L44.28|
;;;545      }
;;;546      else {
;;;547        CClosure *cl;
;;;548        api_checknelems(L, n);
;;;549        api_check(L, n <= MAXUPVAL, "upvalue index too large");
;;;550        cl = luaF_newCclosure(L, n);
00001c  4629              MOV      r1,r5
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       luaF_newCclosure
000024  4606              MOV      r6,r0
;;;551        cl->f = fn;
000026  60f7              STR      r7,[r6,#0xc]
;;;552        L->top -= n;
000028  68e0              LDR      r0,[r4,#0xc]
00002a  eba01005          SUB      r0,r0,r5,LSL #4
00002e  60e0              STR      r0,[r4,#0xc]
;;;553        while (n--) {
000030  e00d              B        |L44.78|
                  |L44.50|
;;;554          setobj2n(L, &cl->upvalue[n], s2v(L->top + n));
000032  f1060210          ADD      r2,r6,#0x10
000036  eb021005          ADD      r0,r2,r5,LSL #4
00003a  68e2              LDR      r2,[r4,#0xc]
00003c  eb021105          ADD      r1,r2,r5,LSL #4
000040  e9d12300          LDRD     r2,r3,[r1,#0]
000044  e9c02300          STRD     r2,r3,[r0,#0]
000048  7a0a              LDRB     r2,[r1,#8]
00004a  7202              STRB     r2,[r0,#8]
00004c  bf00              NOP      
                  |L44.78|
00004e  1e28              SUBS     r0,r5,#0              ;553
000050  f1a50501          SUB      r5,r5,#1              ;553
000054  d1ed              BNE      |L44.50|
;;;555          /* does not need barrier because closure is white */
;;;556        }
;;;557        setclCvalue(L, s2v(L->top), cl);
000056  68e0              LDR      r0,[r4,#0xc]
000058  4631              MOV      r1,r6
00005a  6001              STR      r1,[r0,#0]
00005c  2276              MOVS     r2,#0x76
00005e  7202              STRB     r2,[r0,#8]
;;;558        api_incr_top(L);
000060  68e0              LDR      r0,[r4,#0xc]
000062  3010              ADDS     r0,r0,#0x10
000064  60e0              STR      r0,[r4,#0xc]
;;;559        luaC_checkGC(L);
000066  6920              LDR      r0,[r4,#0x10]
000068  68c0              LDR      r0,[r0,#0xc]
00006a  2800              CMP      r0,#0
00006c  dd03              BLE      |L44.118|
00006e  4620              MOV      r0,r4
000070  f7fffffe          BL       luaC_step
000074  bf00              NOP      
                  |L44.118|
;;;560      }
000076  bf00              NOP      
                  |L44.120|
;;;561      lua_unlock(L);
;;;562    }
000078  e8bd81f0          POP      {r4-r8,pc}
;;;563    
                          ENDP


                          AREA ||i.lua_pushfstring||, CODE, READONLY, ALIGN=1

                  lua_pushfstring PROC
;;;526    
;;;527    LUA_API const char *lua_pushfstring (lua_State *L, const char *fmt, ...) {
000000  b40f              PUSH     {r0-r3}
000002  b538              PUSH     {r3-r5,lr}
000004  4604              MOV      r4,r0
;;;528      const char *ret;
;;;529      va_list argp;
;;;530      lua_lock(L);
;;;531      va_start(argp, fmt);
000006  a806              ADD      r0,sp,#0x18
000008  9000              STR      r0,[sp,#0]
;;;532      ret = luaO_pushvfstring(L, fmt, argp);
00000a  4620              MOV      r0,r4
00000c  9a00              LDR      r2,[sp,#0]
00000e  9905              LDR      r1,[sp,#0x14]
000010  f7fffffe          BL       luaO_pushvfstring
000014  4605              MOV      r5,r0
;;;533      va_end(argp);
000016  2000              MOVS     r0,#0
000018  9000              STR      r0,[sp,#0]
;;;534      luaC_checkGC(L);
00001a  6920              LDR      r0,[r4,#0x10]
00001c  68c0              LDR      r0,[r0,#0xc]
00001e  2800              CMP      r0,#0
000020  dd03              BLE      |L45.42|
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       luaC_step
000028  bf00              NOP      
                  |L45.42|
;;;535      lua_unlock(L);
;;;536      return ret;
00002a  4628              MOV      r0,r5
;;;537    }
00002c  bc38              POP      {r3-r5}
00002e  f85dfb14          LDR      pc,[sp],#0x14
;;;538    
                          ENDP


                          AREA ||i.lua_pushinteger||, CODE, READONLY, ALIGN=1

                  lua_pushinteger PROC
;;;473    
;;;474    LUA_API void lua_pushinteger (lua_State *L, lua_Integer n) {
000000  b510              PUSH     {r4,lr}
;;;475      lua_lock(L);
;;;476      setivalue(s2v(L->top), n);
000002  68c1              LDR      r1,[r0,#0xc]
000004  e9c12300          STRD     r2,r3,[r1,#0]
000008  2423              MOVS     r4,#0x23
00000a  720c              STRB     r4,[r1,#8]
;;;477      api_incr_top(L);
00000c  68c1              LDR      r1,[r0,#0xc]
00000e  3110              ADDS     r1,r1,#0x10
000010  60c1              STR      r1,[r0,#0xc]
;;;478      lua_unlock(L);
;;;479    }
000012  bd10              POP      {r4,pc}
;;;480    
                          ENDP


                          AREA ||i.lua_pushlightuserdata||, CODE, READONLY, ALIGN=1

                  lua_pushlightuserdata PROC
;;;572    
;;;573    LUA_API void lua_pushlightuserdata (lua_State *L, void *p) {
000000  68c2              LDR      r2,[r0,#0xc]
;;;574      lua_lock(L);
;;;575      setpvalue(s2v(L->top), p);
000002  6011              STR      r1,[r2,#0]
000004  2302              MOVS     r3,#2
000006  7213              STRB     r3,[r2,#8]
;;;576      api_incr_top(L);
000008  68c2              LDR      r2,[r0,#0xc]
00000a  3210              ADDS     r2,r2,#0x10
00000c  60c2              STR      r2,[r0,#0xc]
;;;577      lua_unlock(L);
;;;578    }
00000e  4770              BX       lr
;;;579    
                          ENDP


                          AREA ||i.lua_pushlstring||, CODE, READONLY, ALIGN=2

                  lua_pushlstring PROC
;;;486    */
;;;487    LUA_API const char *lua_pushlstring (lua_State *L, const char *s, size_t len) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
;;;488      TString *ts;
;;;489      lua_lock(L);
;;;490      ts = (len == 0) ? luaS_new(L, "") : luaS_newlstr(L, s, len);
00000a  b926              CBNZ     r6,|L48.22|
00000c  a110              ADR      r1,|L48.80|
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       luaS_new
000014  e004              B        |L48.32|
                  |L48.22|
000016  4632              MOV      r2,r6
000018  4639              MOV      r1,r7
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       luaS_newlstr
                  |L48.32|
000020  4605              MOV      r5,r0
;;;491      setsvalue2s(L, L->top, ts);
000022  68e0              LDR      r0,[r4,#0xc]
000024  4629              MOV      r1,r5
000026  6001              STR      r1,[r0,#0]
000028  790a              LDRB     r2,[r1,#4]
00002a  f0420240          ORR      r2,r2,#0x40
00002e  7202              STRB     r2,[r0,#8]
;;;492      api_incr_top(L);
000030  68e0              LDR      r0,[r4,#0xc]
000032  3010              ADDS     r0,r0,#0x10
000034  60e0              STR      r0,[r4,#0xc]
;;;493      luaC_checkGC(L);
000036  6920              LDR      r0,[r4,#0x10]
000038  68c0              LDR      r0,[r0,#0xc]
00003a  2800              CMP      r0,#0
00003c  dd03              BLE      |L48.70|
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       luaC_step
000044  bf00              NOP      
                  |L48.70|
;;;494      lua_unlock(L);
;;;495      return getstr(ts);
000046  f1050010          ADD      r0,r5,#0x10
;;;496    }
00004a  e8bd81f0          POP      {r4-r8,pc}
;;;497    
                          ENDP

00004e  0000              DCW      0x0000
                  |L48.80|
000050  00                DCB      0
000051  00                DCB      0
000052  00                DCB      0
000053  00                DCB      0

                          AREA ||i.lua_pushnil||, CODE, READONLY, ALIGN=1

                  lua_pushnil PROC
;;;457    
;;;458    LUA_API void lua_pushnil (lua_State *L) {
000000  2100              MOVS     r1,#0
;;;459      lua_lock(L);
;;;460      setnilvalue(s2v(L->top));
000002  68c2              LDR      r2,[r0,#0xc]
000004  7211              STRB     r1,[r2,#8]
;;;461      api_incr_top(L);
000006  68c1              LDR      r1,[r0,#0xc]
000008  3110              ADDS     r1,r1,#0x10
00000a  60c1              STR      r1,[r0,#0xc]
;;;462      lua_unlock(L);
;;;463    }
00000c  4770              BX       lr
;;;464    
                          ENDP


                          AREA ||i.lua_pushnumber||, CODE, READONLY, ALIGN=1

                  lua_pushnumber PROC
;;;465    
;;;466    LUA_API void lua_pushnumber (lua_State *L, lua_Number n) {
000000  b510              PUSH     {r4,lr}
;;;467      lua_lock(L);
;;;468      setfltvalue(s2v(L->top), n);
000002  68c1              LDR      r1,[r0,#0xc]
000004  e9c12300          STRD     r2,r3,[r1,#0]
000008  2413              MOVS     r4,#0x13
00000a  720c              STRB     r4,[r1,#8]
;;;469      api_incr_top(L);
00000c  68c1              LDR      r1,[r0,#0xc]
00000e  3110              ADDS     r1,r1,#0x10
000010  60c1              STR      r1,[r0,#0xc]
;;;470      lua_unlock(L);
;;;471    }
000012  bd10              POP      {r4,pc}
;;;472    
                          ENDP


                          AREA ||i.lua_pushstring||, CODE, READONLY, ALIGN=1

                  lua_pushstring PROC
;;;498    
;;;499    LUA_API const char *lua_pushstring (lua_State *L, const char *s) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;500      lua_lock(L);
;;;501      if (s == NULL)
000006  b91e              CBNZ     r6,|L51.16|
;;;502        setnilvalue(s2v(L->top));
000008  2000              MOVS     r0,#0
00000a  68e1              LDR      r1,[r4,#0xc]
00000c  7208              STRB     r0,[r1,#8]
00000e  e00e              B        |L51.46|
                  |L51.16|
;;;503      else {
;;;504        TString *ts;
;;;505        ts = luaS_new(L, s);
000010  4631              MOV      r1,r6
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       luaS_new
000018  4605              MOV      r5,r0
;;;506        setsvalue2s(L, L->top, ts);
00001a  68e0              LDR      r0,[r4,#0xc]
00001c  4629              MOV      r1,r5
00001e  6001              STR      r1,[r0,#0]
000020  790a              LDRB     r2,[r1,#4]
000022  f0420240          ORR      r2,r2,#0x40
000026  7202              STRB     r2,[r0,#8]
;;;507        s = getstr(ts);  /* internal copy's address */
000028  f1050610          ADD      r6,r5,#0x10
;;;508      }
00002c  bf00              NOP      
                  |L51.46|
;;;509      api_incr_top(L);
00002e  68e0              LDR      r0,[r4,#0xc]
000030  3010              ADDS     r0,r0,#0x10
000032  60e0              STR      r0,[r4,#0xc]
;;;510      luaC_checkGC(L);
000034  6920              LDR      r0,[r4,#0x10]
000036  68c0              LDR      r0,[r0,#0xc]
000038  2800              CMP      r0,#0
00003a  dd03              BLE      |L51.68|
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       luaC_step
000042  bf00              NOP      
                  |L51.68|
;;;511      lua_unlock(L);
;;;512      return s;
000044  4630              MOV      r0,r6
;;;513    }
000046  bd70              POP      {r4-r6,pc}
;;;514    
                          ENDP


                          AREA ||i.lua_pushthread||, CODE, READONLY, ALIGN=1

                  lua_pushthread PROC
;;;580    
;;;581    LUA_API int lua_pushthread (lua_State *L) {
000000  4601              MOV      r1,r0
;;;582      lua_lock(L);
;;;583      setthvalue(L, s2v(L->top), L);
000002  68c8              LDR      r0,[r1,#0xc]
000004  460a              MOV      r2,r1
000006  6002              STR      r2,[r0,#0]
000008  2348              MOVS     r3,#0x48
00000a  7203              STRB     r3,[r0,#8]
;;;584      api_incr_top(L);
00000c  68c8              LDR      r0,[r1,#0xc]
00000e  3010              ADDS     r0,r0,#0x10
000010  60c8              STR      r0,[r1,#0xc]
;;;585      lua_unlock(L);
;;;586      return (G(L)->mainthread == L);
000012  6908              LDR      r0,[r1,#0x10]
000014  f8d0008c          LDR      r0,[r0,#0x8c]
000018  4288              CMP      r0,r1
00001a  d101              BNE      |L52.32|
00001c  2001              MOVS     r0,#1
                  |L52.30|
;;;587    }
00001e  4770              BX       lr
                  |L52.32|
000020  2000              MOVS     r0,#0                 ;586
000022  e7fc              B        |L52.30|
;;;588    
                          ENDP


                          AREA ||i.lua_pushvalue||, CODE, READONLY, ALIGN=1

                  lua_pushvalue PROC
;;;243    
;;;244    LUA_API void lua_pushvalue (lua_State *L, int idx) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;245      lua_lock(L);
;;;246      setobj2s(L, L->top, index2value(L, idx));
000008  68e5              LDR      r5,[r4,#0xc]
00000a  4639              MOV      r1,r7
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       index2value
000012  4606              MOV      r6,r0
000014  e9d60100          LDRD     r0,r1,[r6,#0]
000018  e9c50100          STRD     r0,r1,[r5,#0]
00001c  7a30              LDRB     r0,[r6,#8]
00001e  7228              STRB     r0,[r5,#8]
;;;247      api_incr_top(L);
000020  68e0              LDR      r0,[r4,#0xc]
000022  3010              ADDS     r0,r0,#0x10
000024  60e0              STR      r0,[r4,#0xc]
;;;248      lua_unlock(L);
;;;249    }
000026  e8bd81f0          POP      {r4-r8,pc}
;;;250    
                          ENDP


                          AREA ||i.lua_pushvfstring||, CODE, READONLY, ALIGN=1

                  lua_pushvfstring PROC
;;;515    
;;;516    LUA_API const char *lua_pushvfstring (lua_State *L, const char *fmt,
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;517                                          va_list argp) {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;518      const char *ret;
;;;519      lua_lock(L);
;;;520      ret = luaO_pushvfstring(L, fmt, argp);
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  9a02              LDR      r2,[sp,#8]
00000c  f7fffffe          BL       luaO_pushvfstring
000010  4606              MOV      r6,r0
;;;521      luaC_checkGC(L);
000012  6920              LDR      r0,[r4,#0x10]
000014  68c0              LDR      r0,[r0,#0xc]
000016  2800              CMP      r0,#0
000018  dd03              BLE      |L54.34|
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       luaC_step
000020  bf00              NOP      
                  |L54.34|
;;;522      lua_unlock(L);
;;;523      return ret;
000022  4630              MOV      r0,r6
;;;524    }
000024  bdfe              POP      {r1-r7,pc}
;;;525    
                          ENDP


                          AREA ||i.lua_rawequal||, CODE, READONLY, ALIGN=2

                  lua_rawequal PROC
;;;301    
;;;302    LUA_API int lua_rawequal (lua_State *L, int index1, int index2) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4614              MOV      r4,r2
;;;303      const TValue *o1 = index2value(L, index1);
00000a  4641              MOV      r1,r8
00000c  4638              MOV      r0,r7
00000e  f7fffffe          BL       index2value
000012  4605              MOV      r5,r0
;;;304      const TValue *o2 = index2value(L, index2);
000014  4621              MOV      r1,r4
000016  4638              MOV      r0,r7
000018  f7fffffe          BL       index2value
00001c  4606              MOV      r6,r0
;;;305      return (isvalid(o1) && isvalid(o2)) ? luaV_rawequalobj(o1, o2) : 0;
00001e  4807              LDR      r0,|L55.60|
000020  4285              CMP      r5,r0
000022  d008              BEQ      |L55.54|
000024  4286              CMP      r6,r0
000026  d006              BEQ      |L55.54|
000028  4632              MOV      r2,r6
00002a  4629              MOV      r1,r5
00002c  2000              MOVS     r0,#0
00002e  f7fffffe          BL       luaV_equalobj
                  |L55.50|
;;;306    }
000032  e8bd81f0          POP      {r4-r8,pc}
                  |L55.54|
000036  2000              MOVS     r0,#0                 ;305
000038  e7fb              B        |L55.50|
;;;307    
                          ENDP

00003a  0000              DCW      0x0000
                  |L55.60|
                          DCD      luaO_nilobject_

                          AREA ||i.lua_rawget||, CODE, READONLY, ALIGN=1

                  lua_rawget PROC
;;;677    
;;;678    LUA_API int lua_rawget (lua_State *L, int idx) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;679      Table *t;
;;;680      const TValue *val;
;;;681      lua_lock(L);
;;;682      api_checknelems(L, 1);
;;;683      t = gettable(L, idx);
000008  4629              MOV      r1,r5
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       gettable
000010  4606              MOV      r6,r0
;;;684      val = luaH_get(t, s2v(L->top - 1));
000012  68e0              LDR      r0,[r4,#0xc]
000014  f1a00110          SUB      r1,r0,#0x10
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       luaH_get
00001e  4607              MOV      r7,r0
;;;685      L->top--;  /* remove key */
000020  68e0              LDR      r0,[r4,#0xc]
000022  3810              SUBS     r0,r0,#0x10
000024  60e0              STR      r0,[r4,#0xc]
;;;686      return finishrawget(L, val);
000026  4639              MOV      r1,r7
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       finishrawget
;;;687    }
00002e  e8bd81f0          POP      {r4-r8,pc}
;;;688    
                          ENDP


                          AREA ||i.lua_rawgeti||, CODE, READONLY, ALIGN=1

                  lua_rawgeti PROC
;;;689    
;;;690    LUA_API int lua_rawgeti (lua_State *L, int idx, lua_Integer n) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
;;;691      Table *t;
;;;692      lua_lock(L);
;;;693      t = gettable(L, idx);
00000c  4639              MOV      r1,r7
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       gettable
000014  4680              MOV      r8,r0
;;;694      return finishrawget(L, luaH_getint(t, n));
000016  4622              MOV      r2,r4
000018  462b              MOV      r3,r5
00001a  4640              MOV      r0,r8
00001c  f7fffffe          BL       luaH_getint
000020  4681              MOV      r9,r0
000022  4649              MOV      r1,r9
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       finishrawget
;;;695    }
00002a  e8bd87f0          POP      {r4-r10,pc}
;;;696    
                          ENDP


                          AREA ||i.lua_rawgetp||, CODE, READONLY, ALIGN=1

                  lua_rawgetp PROC
;;;697    
;;;698    LUA_API int lua_rawgetp (lua_State *L, int idx, const void *p) {
000000  e92d41ff          PUSH     {r0-r8,lr}
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;699      Table *t;
;;;700      TValue k;
;;;701      lua_lock(L);
;;;702      t = gettable(L, idx);
00000a  4631              MOV      r1,r6
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       gettable
000012  4607              MOV      r7,r0
;;;703      setpvalue(&k, cast_voidp(p));
000014  4668              MOV      r0,sp
000016  6004              STR      r4,[r0,#0]
000018  2102              MOVS     r1,#2
00001a  7201              STRB     r1,[r0,#8]
;;;704      return finishrawget(L, luaH_get(t, &k));
00001c  4669              MOV      r1,sp
00001e  4638              MOV      r0,r7
000020  f7fffffe          BL       luaH_get
000024  4680              MOV      r8,r0
000026  4641              MOV      r1,r8
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       finishrawget
;;;705    }
00002e  b004              ADD      sp,sp,#0x10
000030  e8bd81f0          POP      {r4-r8,pc}
;;;706    
                          ENDP


                          AREA ||i.lua_rawlen||, CODE, READONLY, ALIGN=1

                  lua_rawlen PROC
;;;399    
;;;400    LUA_API lua_Unsigned lua_rawlen (lua_State *L, int idx) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;401      const TValue *o = index2value(L, idx);
000006  4631              MOV      r1,r6
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       index2value
00000e  4604              MOV      r4,r0
;;;402      switch (ttypetag(o)) {
000010  7a20              LDRB     r0,[r4,#8]
000012  f000003f          AND      r0,r0,#0x3f
000016  2805              CMP      r0,#5
000018  d012              BEQ      |L59.64|
00001a  2807              CMP      r0,#7
00001c  d00c              BEQ      |L59.56|
00001e  2814              CMP      r0,#0x14
000020  d002              BEQ      |L59.40|
000022  2824              CMP      r0,#0x24
000024  d110              BNE      |L59.72|
000026  e003              B        |L59.48|
                  |L59.40|
;;;403        case LUA_TSHRSTR: return tsvalue(o)->shrlen;
000028  6820              LDR      r0,[r4,#0]
00002a  79c0              LDRB     r0,[r0,#7]
00002c  2100              MOVS     r1,#0
                  |L59.46|
;;;404        case LUA_TLNGSTR: return tsvalue(o)->u.lnglen;
;;;405        case LUA_TUSERDATA: return uvalue(o)->len;
;;;406        case LUA_TTABLE: return luaH_getn(hvalue(o));
;;;407        default: return 0;
;;;408      }
;;;409    }
00002e  bd70              POP      {r4-r6,pc}
                  |L59.48|
000030  6820              LDR      r0,[r4,#0]            ;404
000032  68c0              LDR      r0,[r0,#0xc]          ;404
000034  2100              MOVS     r1,#0                 ;404
000036  e7fa              B        |L59.46|
                  |L59.56|
000038  6820              LDR      r0,[r4,#0]            ;405
00003a  6880              LDR      r0,[r0,#8]            ;405
00003c  2100              MOVS     r1,#0                 ;405
00003e  e7f6              B        |L59.46|
                  |L59.64|
000040  6820              LDR      r0,[r4,#0]            ;406
000042  f7fffffe          BL       luaH_getn
000046  e7f2              B        |L59.46|
                  |L59.72|
000048  2000              MOVS     r0,#0                 ;407
00004a  4601              MOV      r1,r0                 ;407
00004c  e7ef              B        |L59.46|
;;;410    
                          ENDP


                          AREA ||i.lua_rawset||, CODE, READONLY, ALIGN=1

                  lua_rawset PROC
;;;861    
;;;862    LUA_API void lua_rawset (lua_State *L, int idx) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;863      Table *t;
;;;864      TValue *slot;
;;;865      lua_lock(L);
;;;866      api_checknelems(L, 2);
;;;867      t = gettable(L, idx);
000008  4639              MOV      r1,r7
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       gettable
000010  4605              MOV      r5,r0
;;;868      slot = luaH_set(L, t, s2v(L->top - 2));
000012  68e0              LDR      r0,[r4,#0xc]
000014  f1a00220          SUB      r2,r0,#0x20
000018  4629              MOV      r1,r5
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       luaH_set
000020  4606              MOV      r6,r0
;;;869      setobj2t(L, slot, s2v(L->top - 1));
000022  4631              MOV      r1,r6
000024  68e2              LDR      r2,[r4,#0xc]
000026  f1a20010          SUB      r0,r2,#0x10
00002a  e9d02300          LDRD     r2,r3,[r0,#0]
00002e  e9c12300          STRD     r2,r3,[r1,#0]
000032  7a02              LDRB     r2,[r0,#8]
000034  720a              STRB     r2,[r1,#8]
;;;870      invalidateTMcache(t);
000036  2000              MOVS     r0,#0
000038  71a8              STRB     r0,[r5,#6]
;;;871      luaC_barrierback(L, obj2gco(t), s2v(L->top - 1));
00003a  68e0              LDR      r0,[r4,#0xc]
00003c  f8100c08          LDRB     r0,[r0,#-8]
000040  f0000040          AND      r0,r0,#0x40
000044  b178              CBZ      r0,|L60.102|
000046  7968              LDRB     r0,[r5,#5]
000048  f0000020          AND      r0,r0,#0x20
00004c  b158              CBZ      r0,|L60.102|
00004e  68e0              LDR      r0,[r4,#0xc]
000050  f8500c10          LDR      r0,[r0,#-0x10]
000054  7940              LDRB     r0,[r0,#5]
000056  f0000018          AND      r0,r0,#0x18
00005a  b120              CBZ      r0,|L60.102|
00005c  4629              MOV      r1,r5
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       luaC_barrierback_
000064  e000              B        |L60.104|
                  |L60.102|
000066  bf00              NOP      
                  |L60.104|
;;;872      L->top -= 2;
000068  68e0              LDR      r0,[r4,#0xc]
00006a  3820              SUBS     r0,r0,#0x20
00006c  60e0              STR      r0,[r4,#0xc]
;;;873      lua_unlock(L);
;;;874    }
00006e  e8bd81f0          POP      {r4-r8,pc}
;;;875    
                          ENDP


                          AREA ||i.lua_rawseti||, CODE, READONLY, ALIGN=1

                  lua_rawseti PROC
;;;876    
;;;877    LUA_API void lua_rawseti (lua_State *L, int idx, lua_Integer n) {
000000  e92d43f8          PUSH     {r3-r9,lr}
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;878      Table *t;
;;;879      lua_lock(L);
;;;880      api_checknelems(L, 1);
;;;881      t = gettable(L, idx);
00000c  4641              MOV      r1,r8
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       gettable
000014  4605              MOV      r5,r0
;;;882      luaH_setint(L, t, n, s2v(L->top - 1));
000016  68e0              LDR      r0,[r4,#0xc]
000018  3810              SUBS     r0,r0,#0x10
00001a  4632              MOV      r2,r6
00001c  463b              MOV      r3,r7
00001e  4629              MOV      r1,r5
000020  9000              STR      r0,[sp,#0]
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       luaH_setint
;;;883      luaC_barrierback(L, obj2gco(t), s2v(L->top - 1));
000028  68e0              LDR      r0,[r4,#0xc]
00002a  f8100c08          LDRB     r0,[r0,#-8]
00002e  f0000040          AND      r0,r0,#0x40
000032  b178              CBZ      r0,|L61.84|
000034  7968              LDRB     r0,[r5,#5]
000036  f0000020          AND      r0,r0,#0x20
00003a  b158              CBZ      r0,|L61.84|
00003c  68e0              LDR      r0,[r4,#0xc]
00003e  f8500c10          LDR      r0,[r0,#-0x10]
000042  7940              LDRB     r0,[r0,#5]
000044  f0000018          AND      r0,r0,#0x18
000048  b120              CBZ      r0,|L61.84|
00004a  4629              MOV      r1,r5
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       luaC_barrierback_
000052  e000              B        |L61.86|
                  |L61.84|
000054  bf00              NOP      
                  |L61.86|
;;;884      L->top--;
000056  68e0              LDR      r0,[r4,#0xc]
000058  3810              SUBS     r0,r0,#0x10
00005a  60e0              STR      r0,[r4,#0xc]
;;;885      lua_unlock(L);
;;;886    }
00005c  e8bd83f8          POP      {r3-r9,pc}
;;;887    
                          ENDP


                          AREA ||i.lua_rawsetp||, CODE, READONLY, ALIGN=1

                  lua_rawsetp PROC
;;;888    
;;;889    LUA_API void lua_rawsetp (lua_State *L, int idx, const void *p) {
000000  e92d41ff          PUSH     {r0-r8,lr}
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
;;;890      Table *t;
;;;891      TValue k, *slot;
;;;892      lua_lock(L);
;;;893      api_checknelems(L, 1);
;;;894      t = gettable(L, idx);
00000a  4641              MOV      r1,r8
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       gettable
000012  4607              MOV      r7,r0
;;;895      setpvalue(&k, cast_voidp(p));
000014  4668              MOV      r0,sp
000016  6006              STR      r6,[r0,#0]
000018  2102              MOVS     r1,#2
00001a  7201              STRB     r1,[r0,#8]
;;;896      slot = luaH_set(L, t, &k);
00001c  466a              MOV      r2,sp
00001e  4639              MOV      r1,r7
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       luaH_set
000026  4605              MOV      r5,r0
;;;897      setobj2t(L, slot, s2v(L->top - 1));
000028  4629              MOV      r1,r5
00002a  68e2              LDR      r2,[r4,#0xc]
00002c  f1a20010          SUB      r0,r2,#0x10
000030  e9d02300          LDRD     r2,r3,[r0,#0]
000034  e9c12300          STRD     r2,r3,[r1,#0]
000038  7a02              LDRB     r2,[r0,#8]
00003a  720a              STRB     r2,[r1,#8]
;;;898      luaC_barrierback(L, obj2gco(t), s2v(L->top - 1));
00003c  68e0              LDR      r0,[r4,#0xc]
00003e  f8100c08          LDRB     r0,[r0,#-8]
000042  f0000040          AND      r0,r0,#0x40
000046  b178              CBZ      r0,|L62.104|
000048  7978              LDRB     r0,[r7,#5]
00004a  f0000020          AND      r0,r0,#0x20
00004e  b158              CBZ      r0,|L62.104|
000050  68e0              LDR      r0,[r4,#0xc]
000052  f8500c10          LDR      r0,[r0,#-0x10]
000056  7940              LDRB     r0,[r0,#5]
000058  f0000018          AND      r0,r0,#0x18
00005c  b120              CBZ      r0,|L62.104|
00005e  4639              MOV      r1,r7
000060  4620              MOV      r0,r4
000062  f7fffffe          BL       luaC_barrierback_
000066  e000              B        |L62.106|
                  |L62.104|
000068  bf00              NOP      
                  |L62.106|
;;;899      L->top--;
00006a  68e0              LDR      r0,[r4,#0xc]
00006c  3810              SUBS     r0,r0,#0x10
00006e  60e0              STR      r0,[r4,#0xc]
;;;900      lua_unlock(L);
;;;901    }
000070  e8bd81ff          POP      {r0-r8,pc}
;;;902    
                          ENDP


                          AREA ||i.lua_removekey||, CODE, READONLY, ALIGN=1

                  lua_removekey PROC
;;;718    
;;;719    LUA_API void lua_removekey (lua_State *L, int idx) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;720      auxkeydef(L, idx, 1);
000006  2201              MOVS     r2,#1
000008  4629              MOV      r1,r5
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       auxkeydef
;;;721    }
000010  bd70              POP      {r4-r6,pc}
;;;722    
                          ENDP


                          AREA ||i.lua_rotate||, CODE, READONLY, ALIGN=1

                  lua_rotate PROC
;;;214    */
;;;215    LUA_API void lua_rotate (lua_State *L, int idx, int n) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4605              MOV      r5,r0
000006  4689              MOV      r9,r1
000008  4614              MOV      r4,r2
;;;216      StkId p, t, m;
;;;217      lua_lock(L);
;;;218      t = L->top - 1;  /* end of stack segment being rotated */
00000a  68e8              LDR      r0,[r5,#0xc]
00000c  f1a00710          SUB      r7,r0,#0x10
;;;219      p = index2stack(L, idx);  /* start of segment */
000010  4649              MOV      r1,r9
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       index2stack
000018  4606              MOV      r6,r0
;;;220      api_check(L, (n >= 0 ? n : -n) <= (t - p + 1), "invalid 'n'");
;;;221      m = (n >= 0 ? t - n : p - n - 1);  /* end of prefix */
00001a  2c00              CMP      r4,#0
00001c  db02              BLT      |L64.36|
00001e  eba71004          SUB      r0,r7,r4,LSL #4
000022  e002              B        |L64.42|
                  |L64.36|
000024  eba61004          SUB      r0,r6,r4,LSL #4
000028  3810              SUBS     r0,r0,#0x10
                  |L64.42|
00002a  4680              MOV      r8,r0
;;;222      reverse(L, p, m);  /* reverse the prefix with length 'n' */
00002c  4642              MOV      r2,r8
00002e  4631              MOV      r1,r6
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       reverse
;;;223      reverse(L, m + 1, t);  /* reverse the suffix */
000036  463a              MOV      r2,r7
000038  f1080110          ADD      r1,r8,#0x10
00003c  4628              MOV      r0,r5
00003e  f7fffffe          BL       reverse
;;;224      reverse(L, p, t);  /* reverse the entire segment */
000042  463a              MOV      r2,r7
000044  4631              MOV      r1,r6
000046  4628              MOV      r0,r5
000048  f7fffffe          BL       reverse
;;;225      lua_unlock(L);
;;;226    }
00004c  e8bd87f0          POP      {r4-r10,pc}
;;;227    
                          ENDP


                          AREA ||i.lua_setallocf||, CODE, READONLY, ALIGN=1

                  lua_setallocf PROC
;;;1270   
;;;1271   LUA_API void lua_setallocf (lua_State *L, lua_Alloc f, void *ud) {
000000  6903              LDR      r3,[r0,#0x10]
;;;1272     lua_lock(L);
;;;1273     G(L)->ud = ud;
000002  605a              STR      r2,[r3,#4]
;;;1274     G(L)->frealloc = f;
000004  6903              LDR      r3,[r0,#0x10]
000006  6019              STR      r1,[r3,#0]
;;;1275     lua_unlock(L);
;;;1276   }
000008  4770              BX       lr
;;;1277   
                          ENDP


                          AREA ||i.lua_setfield||, CODE, READONLY, ALIGN=1

                  lua_setfield PROC
;;;836    
;;;837    LUA_API void lua_setfield (lua_State *L, int idx, const char *k) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;838      lua_lock(L);  /* unlock done in 'auxsetstr' */
;;;839      auxsetstr(L, index2value(L, idx), k);
00000a  4629              MOV      r1,r5
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       index2value
000012  4607              MOV      r7,r0
000014  4632              MOV      r2,r6
000016  4639              MOV      r1,r7
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       auxsetstr
;;;840    }
00001e  e8bd81f0          POP      {r4-r8,pc}
;;;841    
                          ENDP


                          AREA ||i.lua_setglobal||, CODE, READONLY, ALIGN=1

                  lua_setglobal PROC
;;;813    
;;;814    LUA_API void lua_setglobal (lua_State *L, const char *name) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;815      Table *reg = hvalue(&G(L)->l_registry);
000008  6920              LDR      r0,[r4,#0x10]
00000a  6a06              LDR      r6,[r0,#0x20]
;;;816      lua_lock(L);  /* unlock done in 'auxsetstr' */
;;;817      auxsetstr(L, luaH_getint(reg, LUA_RIDX_GLOBALS), name);
00000c  2202              MOVS     r2,#2
00000e  2300              MOVS     r3,#0
000010  4630              MOV      r0,r6
000012  f7fffffe          BL       luaH_getint
000016  4607              MOV      r7,r0
000018  462a              MOV      r2,r5
00001a  4639              MOV      r1,r7
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       auxsetstr
;;;818    }
000022  e8bd81f0          POP      {r4-r8,pc}
;;;819    
                          ENDP


                          AREA ||i.lua_seti||, CODE, READONLY, ALIGN=1

                  lua_seti PROC
;;;842    
;;;843    LUA_API void lua_seti (lua_State *L, int idx, lua_Integer n) {
000000  e92d43f0          PUSH     {r4-r9,lr}
000004  b087              SUB      sp,sp,#0x1c
000006  4606              MOV      r6,r0
000008  4689              MOV      r9,r1
00000a  4614              MOV      r4,r2
00000c  461d              MOV      r5,r3
;;;844      TValue *t;
;;;845      const TValue *slot;
;;;846      lua_lock(L);
;;;847      api_checknelems(L, 1);
;;;848      t = index2value(L, idx);
00000e  4649              MOV      r1,r9
000010  4630              MOV      r0,r6
000012  f7fffffe          BL       index2value
000016  4607              MOV      r7,r0
;;;849      if (luaV_fastgeti(L, t, n, slot)) {
000018  7a38              LDRB     r0,[r7,#8]
00001a  2845              CMP      r0,#0x45
00001c  d003              BEQ      |L68.38|
00001e  f04f0800          MOV      r8,#0
000022  2000              MOVS     r0,#0
000024  e01c              B        |L68.96|
                  |L68.38|
000026  1e63              SUBS     r3,r4,#1
000028  f1650100          SBC      r1,r5,#0
00002c  6838              LDR      r0,[r7,#0]
00002e  6880              LDR      r0,[r0,#8]
000030  1a18              SUBS     r0,r3,r0
000032  f1710100          SBCS     r1,r1,#0
000036  d205              BCS      |L68.68|
000038  6838              LDR      r0,[r7,#0]
00003a  68c1              LDR      r1,[r0,#0xc]
00003c  1e60              SUBS     r0,r4,#1
00003e  eb011000          ADD      r0,r1,r0,LSL #4
000042  e004              B        |L68.78|
                  |L68.68|
000044  4622              MOV      r2,r4
000046  462b              MOV      r3,r5
000048  6838              LDR      r0,[r7,#0]
00004a  f7fffffe          BL       luaH_getint
                  |L68.78|
00004e  4680              MOV      r8,r0
000050  f8980008          LDRB     r0,[r8,#8]
000054  f000000f          AND      r0,r0,#0xf
000058  b108              CBZ      r0,|L68.94|
00005a  2001              MOVS     r0,#1
00005c  e000              B        |L68.96|
                  |L68.94|
00005e  2000              MOVS     r0,#0
                  |L68.96|
000060  b308              CBZ      r0,|L68.166|
;;;850        luaV_finishfastset(L, t, slot, s2v(L->top - 1));
000062  4640              MOV      r0,r8
000064  68f2              LDR      r2,[r6,#0xc]
000066  f1a20110          SUB      r1,r2,#0x10
00006a  e9d12300          LDRD     r2,r3,[r1,#0]
00006e  e9c02300          STRD     r2,r3,[r0,#0]
000072  7a0a              LDRB     r2,[r1,#8]
000074  7202              STRB     r2,[r0,#8]
000076  68f0              LDR      r0,[r6,#0xc]
000078  f8100c08          LDRB     r0,[r0,#-8]
00007c  f0000040          AND      r0,r0,#0x40
000080  b180              CBZ      r0,|L68.164|
000082  6838              LDR      r0,[r7,#0]
000084  7940              LDRB     r0,[r0,#5]
000086  f0000020          AND      r0,r0,#0x20
00008a  b158              CBZ      r0,|L68.164|
00008c  68f0              LDR      r0,[r6,#0xc]
00008e  f8500c10          LDR      r0,[r0,#-0x10]
000092  7940              LDRB     r0,[r0,#5]
000094  f0000018          AND      r0,r0,#0x18
000098  b120              CBZ      r0,|L68.164|
00009a  4630              MOV      r0,r6
00009c  6839              LDR      r1,[r7,#0]
00009e  f7fffffe          BL       luaC_barrierback_
0000a2  e010              B        |L68.198|
                  |L68.164|
0000a4  e00f              B        |L68.198|
                  |L68.166|
;;;851      }
;;;852      else {
;;;853        TValue aux;
;;;854        setivalue(&aux, n);
0000a6  a802              ADD      r0,sp,#8
0000a8  e9c04500          STRD     r4,r5,[r0,#0]
0000ac  2123              MOVS     r1,#0x23
0000ae  7201              STRB     r1,[r0,#8]
;;;855        luaV_finishset(L, t, &aux, s2v(L->top - 1), slot);
0000b0  f8cd8000          STR      r8,[sp,#0]
0000b4  68f0              LDR      r0,[r6,#0xc]
0000b6  f1a00310          SUB      r3,r0,#0x10
0000ba  aa02              ADD      r2,sp,#8
0000bc  4639              MOV      r1,r7
0000be  4630              MOV      r0,r6
0000c0  f7fffffe          BL       luaV_finishset
;;;856      }
0000c4  bf00              NOP      
                  |L68.198|
;;;857      L->top--;  /* pop value */
0000c6  68f0              LDR      r0,[r6,#0xc]
0000c8  3810              SUBS     r0,r0,#0x10
0000ca  60f0              STR      r0,[r6,#0xc]
;;;858      lua_unlock(L);
;;;859    }
0000cc  b007              ADD      sp,sp,#0x1c
0000ce  e8bd83f0          POP      {r4-r9,pc}
;;;860    
                          ENDP


                          AREA ||i.lua_setiuservalue||, CODE, READONLY, ALIGN=1

                  lua_setiuservalue PROC
;;;943    
;;;944    LUA_API int lua_setiuservalue (lua_State *L, int idx, int n) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4615              MOV      r5,r2
;;;945      TValue *o;
;;;946      int res;
;;;947      lua_lock(L);
;;;948      api_checknelems(L, 1);
;;;949      o = index2value(L, idx);
00000a  4641              MOV      r1,r8
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       index2value
000012  4606              MOV      r6,r0
;;;950      api_check(L, ttisfulluserdata(o), "full userdata expected");
;;;951      if (!(0 < n && n <= uvalue(o)->nuvalue))
000014  2d00              CMP      r5,#0
000016  dd03              BLE      |L69.32|
000018  6830              LDR      r0,[r6,#0]
00001a  88c0              LDRH     r0,[r0,#6]
00001c  42a8              CMP      r0,r5
00001e  da01              BGE      |L69.36|
                  |L69.32|
;;;952        res = 0;
000020  2700              MOVS     r7,#0
000022  e026              B        |L69.114|
                  |L69.36|
;;;953      else {
;;;954        setobj(L, &uvalue(o)->uv[n - 1].uv, s2v(L->top - 1));
000024  6832              LDR      r2,[r6,#0]
000026  3218              ADDS     r2,r2,#0x18
000028  1e6b              SUBS     r3,r5,#1
00002a  eb021003          ADD      r0,r2,r3,LSL #4
00002e  68e2              LDR      r2,[r4,#0xc]
000030  f1a20110          SUB      r1,r2,#0x10
000034  e9d12300          LDRD     r2,r3,[r1,#0]
000038  e9c02300          STRD     r2,r3,[r0,#0]
00003c  7a0a              LDRB     r2,[r1,#8]
00003e  7202              STRB     r2,[r0,#8]
;;;955        luaC_barrierback(L, gcvalue(o), s2v(L->top - 1));
000040  68e0              LDR      r0,[r4,#0xc]
000042  f8100c08          LDRB     r0,[r0,#-8]
000046  f0000040          AND      r0,r0,#0x40
00004a  b180              CBZ      r0,|L69.110|
00004c  6830              LDR      r0,[r6,#0]
00004e  7940              LDRB     r0,[r0,#5]
000050  f0000020          AND      r0,r0,#0x20
000054  b158              CBZ      r0,|L69.110|
000056  68e0              LDR      r0,[r4,#0xc]
000058  f8500c10          LDR      r0,[r0,#-0x10]
00005c  7940              LDRB     r0,[r0,#5]
00005e  f0000018          AND      r0,r0,#0x18
000062  b120              CBZ      r0,|L69.110|
000064  4620              MOV      r0,r4
000066  6831              LDR      r1,[r6,#0]
000068  f7fffffe          BL       luaC_barrierback_
00006c  e000              B        |L69.112|
                  |L69.110|
00006e  bf00              NOP      
                  |L69.112|
;;;956        res = 1;
000070  2701              MOVS     r7,#1
                  |L69.114|
;;;957      }
;;;958      L->top--;
000072  68e0              LDR      r0,[r4,#0xc]
000074  3810              SUBS     r0,r0,#0x10
000076  60e0              STR      r0,[r4,#0xc]
;;;959      lua_unlock(L);
;;;960      return res;
000078  4638              MOV      r0,r7
;;;961    }
00007a  e8bd81f0          POP      {r4-r8,pc}
;;;962    
                          ENDP


                          AREA ||i.lua_setmetatable||, CODE, READONLY, ALIGN=1

                  lua_setmetatable PROC
;;;903    
;;;904    LUA_API int lua_setmetatable (lua_State *L, int objindex) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;905      TValue *obj;
;;;906      Table *mt;
;;;907      lua_lock(L);
;;;908      api_checknelems(L, 1);
;;;909      obj = index2value(L, objindex);
000008  4639              MOV      r1,r7
00000a  4630              MOV      r0,r6
00000c  f7fffffe          BL       index2value
000010  4604              MOV      r4,r0
;;;910      if (ttisnil(s2v(L->top - 1)))
000012  68f0              LDR      r0,[r6,#0xc]
000014  f8100c08          LDRB     r0,[r0,#-8]
000018  b908              CBNZ     r0,|L70.30|
;;;911        mt = NULL;
00001a  2500              MOVS     r5,#0
00001c  e002              B        |L70.36|
                  |L70.30|
;;;912      else {
;;;913        api_check(L, ttistable(s2v(L->top - 1)), "table expected");
;;;914        mt = hvalue(s2v(L->top - 1));
00001e  68f0              LDR      r0,[r6,#0xc]
000020  f8505c10          LDR      r5,[r0,#-0x10]
                  |L70.36|
;;;915      }
;;;916      switch (ttype(obj)) {
000024  7a20              LDRB     r0,[r4,#8]
000026  f000000f          AND      r0,r0,#0xf
00002a  2805              CMP      r0,#5
00002c  d002              BEQ      |L70.52|
00002e  2807              CMP      r0,#7
000030  d132              BNE      |L70.152|
000032  e018              B        |L70.102|
                  |L70.52|
;;;917        case LUA_TTABLE: {
;;;918          hvalue(obj)->metatable = mt;
000034  6820              LDR      r0,[r4,#0]
000036  6185              STR      r5,[r0,#0x18]
;;;919          if (mt) {
000038  b1a5              CBZ      r5,|L70.100|
;;;920            luaC_objbarrier(L, gcvalue(obj), mt);
00003a  6820              LDR      r0,[r4,#0]
00003c  7940              LDRB     r0,[r0,#5]
00003e  f0000020          AND      r0,r0,#0x20
000042  b148              CBZ      r0,|L70.88|
000044  7968              LDRB     r0,[r5,#5]
000046  f0000018          AND      r0,r0,#0x18
00004a  b128              CBZ      r0,|L70.88|
00004c  462a              MOV      r2,r5
00004e  4630              MOV      r0,r6
000050  6821              LDR      r1,[r4,#0]
000052  f7fffffe          BL       luaC_barrier_
000056  e000              B        |L70.90|
                  |L70.88|
000058  bf00              NOP      
                  |L70.90|
;;;921            luaC_checkfinalizer(L, gcvalue(obj), mt);
00005a  462a              MOV      r2,r5
00005c  4630              MOV      r0,r6
00005e  6821              LDR      r1,[r4,#0]
000060  f7fffffe          BL       luaC_checkfinalizer
                  |L70.100|
;;;922          }
;;;923          break;
000064  e021              B        |L70.170|
                  |L70.102|
;;;924        }
;;;925        case LUA_TUSERDATA: {
;;;926          uvalue(obj)->metatable = mt;
000066  6820              LDR      r0,[r4,#0]
000068  60c5              STR      r5,[r0,#0xc]
;;;927          if (mt) {
00006a  b1a5              CBZ      r5,|L70.150|
;;;928            luaC_objbarrier(L, uvalue(obj), mt);
00006c  6820              LDR      r0,[r4,#0]
00006e  7940              LDRB     r0,[r0,#5]
000070  f0000020          AND      r0,r0,#0x20
000074  b148              CBZ      r0,|L70.138|
000076  7968              LDRB     r0,[r5,#5]
000078  f0000018          AND      r0,r0,#0x18
00007c  b128              CBZ      r0,|L70.138|
00007e  462a              MOV      r2,r5
000080  4630              MOV      r0,r6
000082  6821              LDR      r1,[r4,#0]
000084  f7fffffe          BL       luaC_barrier_
000088  e000              B        |L70.140|
                  |L70.138|
00008a  bf00              NOP      
                  |L70.140|
;;;929            luaC_checkfinalizer(L, gcvalue(obj), mt);
00008c  462a              MOV      r2,r5
00008e  4630              MOV      r0,r6
000090  6821              LDR      r1,[r4,#0]
000092  f7fffffe          BL       luaC_checkfinalizer
                  |L70.150|
;;;930          }
;;;931          break;
000096  e008              B        |L70.170|
                  |L70.152|
;;;932        }
;;;933        default: {
;;;934          G(L)->mt[ttype(obj)] = mt;
000098  6930              LDR      r0,[r6,#0x10]
00009a  f5007080          ADD      r0,r0,#0x100
00009e  7a21              LDRB     r1,[r4,#8]
0000a0  f001010f          AND      r1,r1,#0xf
0000a4  f8405021          STR      r5,[r0,r1,LSL #2]
;;;935          break;
0000a8  bf00              NOP      
                  |L70.170|
0000aa  bf00              NOP                            ;923
;;;936        }
;;;937      }
;;;938      L->top--;
0000ac  68f0              LDR      r0,[r6,#0xc]
0000ae  3810              SUBS     r0,r0,#0x10
0000b0  60f0              STR      r0,[r6,#0xc]
;;;939      lua_unlock(L);
;;;940      return 1;
0000b2  2001              MOVS     r0,#1
;;;941    }
0000b4  e8bd81f0          POP      {r4-r8,pc}
;;;942    
                          ENDP


                          AREA ||i.lua_settable||, CODE, READONLY, ALIGN=1

                  lua_settable PROC
;;;820    
;;;821    LUA_API void lua_settable (lua_State *L, int idx) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4604              MOV      r4,r0
000004  460f              MOV      r7,r1
;;;822      TValue *t;
;;;823      const TValue *slot;
;;;824      lua_lock(L);
;;;825      api_checknelems(L, 2);
;;;826      t = index2value(L, idx);
000006  4639              MOV      r1,r7
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       index2value
00000e  4606              MOV      r6,r0
;;;827      if (luaV_fastget(L, t, s2v(L->top - 2), slot, luaH_get)) {
000010  7a30              LDRB     r0,[r6,#8]
000012  2845              CMP      r0,#0x45
000014  d002              BEQ      |L71.28|
000016  2500              MOVS     r5,#0
000018  2000              MOVS     r0,#0
00001a  e00d              B        |L71.56|
                  |L71.28|
00001c  68e2              LDR      r2,[r4,#0xc]
00001e  f1a20120          SUB      r1,r2,#0x20
000022  6830              LDR      r0,[r6,#0]
000024  f7fffffe          BL       luaH_get
000028  4605              MOV      r5,r0
00002a  7a28              LDRB     r0,[r5,#8]
00002c  f000000f          AND      r0,r0,#0xf
000030  b108              CBZ      r0,|L71.54|
000032  2001              MOVS     r0,#1
000034  e000              B        |L71.56|
                  |L71.54|
000036  2000              MOVS     r0,#0
                  |L71.56|
000038  b308              CBZ      r0,|L71.126|
;;;828        luaV_finishfastset(L, t, slot, s2v(L->top - 1));
00003a  4628              MOV      r0,r5
00003c  68e2              LDR      r2,[r4,#0xc]
00003e  f1a20110          SUB      r1,r2,#0x10
000042  e9d12300          LDRD     r2,r3,[r1,#0]
000046  e9c02300          STRD     r2,r3,[r0,#0]
00004a  7a0a              LDRB     r2,[r1,#8]
00004c  7202              STRB     r2,[r0,#8]
00004e  68e0              LDR      r0,[r4,#0xc]
000050  f8100c08          LDRB     r0,[r0,#-8]
000054  f0000040          AND      r0,r0,#0x40
000058  b180              CBZ      r0,|L71.124|
00005a  6830              LDR      r0,[r6,#0]
00005c  7940              LDRB     r0,[r0,#5]
00005e  f0000020          AND      r0,r0,#0x20
000062  b158              CBZ      r0,|L71.124|
000064  68e0              LDR      r0,[r4,#0xc]
000066  f8500c10          LDR      r0,[r0,#-0x10]
00006a  7940              LDRB     r0,[r0,#5]
00006c  f0000018          AND      r0,r0,#0x18
000070  b120              CBZ      r0,|L71.124|
000072  4620              MOV      r0,r4
000074  6831              LDR      r1,[r6,#0]
000076  f7fffffe          BL       luaC_barrierback_
00007a  e00a              B        |L71.146|
                  |L71.124|
00007c  e009              B        |L71.146|
                  |L71.126|
;;;829      }
;;;830      else
;;;831        luaV_finishset(L, t, s2v(L->top - 2), s2v(L->top - 1), slot);
00007e  9500              STR      r5,[sp,#0]
000080  68e0              LDR      r0,[r4,#0xc]
000082  f1a00310          SUB      r3,r0,#0x10
000086  f1a00220          SUB      r2,r0,#0x20
00008a  4631              MOV      r1,r6
00008c  4620              MOV      r0,r4
00008e  f7fffffe          BL       luaV_finishset
                  |L71.146|
;;;832      L->top -= 2;  /* pop index and value */
000092  68e0              LDR      r0,[r4,#0xc]
000094  3820              SUBS     r0,r0,#0x20
000096  60e0              STR      r0,[r4,#0xc]
;;;833      lua_unlock(L);
;;;834    }
000098  bdf8              POP      {r3-r7,pc}
;;;835    
                          ENDP


                          AREA ||i.lua_settop||, CODE, READONLY, ALIGN=1

                  lua_settop PROC
;;;177    
;;;178    LUA_API void lua_settop (lua_State *L, int idx) {
000000  b530              PUSH     {r4,r5,lr}
;;;179      StkId func = L->ci->func;
000002  6943              LDR      r3,[r0,#0x14]
000004  681a              LDR      r2,[r3,#0]
;;;180      lua_lock(L);
;;;181      if (idx >= 0) {
000006  2900              CMP      r1,#0
000008  db13              BLT      |L72.50|
;;;182        api_check(L, idx <= L->stack_last - (func + 1), "new top too large");
;;;183        while (L->top < (func + 1) + idx)
00000a  e005              B        |L72.24|
                  |L72.12|
;;;184          setnilvalue(s2v(L->top++));
00000c  2400              MOVS     r4,#0
00000e  68c5              LDR      r5,[r0,#0xc]
000010  f1050310          ADD      r3,r5,#0x10
000014  60c3              STR      r3,[r0,#0xc]
000016  722c              STRB     r4,[r5,#8]
                  |L72.24|
000018  f1020310          ADD      r3,r2,#0x10           ;183
00001c  eb031301          ADD      r3,r3,r1,LSL #4       ;183
000020  68c4              LDR      r4,[r0,#0xc]          ;183
000022  429c              CMP      r4,r3                 ;183
000024  d3f2              BCC      |L72.12|
;;;185        L->top = (func + 1) + idx;
000026  f1020310          ADD      r3,r2,#0x10
00002a  eb031301          ADD      r3,r3,r1,LSL #4
00002e  60c3              STR      r3,[r0,#0xc]
000030  e004              B        |L72.60|
                  |L72.50|
;;;186      }
;;;187      else {
;;;188        api_check(L, -(idx+1) <= (L->top - (func + 1)), "invalid new top");
;;;189        L->top += idx+1;  /* 'subtract' index (index is negative) */
000032  1c4b              ADDS     r3,r1,#1
000034  68c4              LDR      r4,[r0,#0xc]
000036  eb041303          ADD      r3,r4,r3,LSL #4
00003a  60c3              STR      r3,[r0,#0xc]
                  |L72.60|
;;;190      }
;;;191      lua_unlock(L);
;;;192    }
00003c  bd30              POP      {r4,r5,pc}
;;;193    
                          ENDP


                          AREA ||i.lua_setupvalue||, CODE, READONLY, ALIGN=1

                  lua_setupvalue PROC
;;;1331   
;;;1332   LUA_API const char *lua_setupvalue (lua_State *L, int funcindex, int n) {
000000  e92d41fc          PUSH     {r2-r8,lr}
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;1333     const char *name;
;;;1334     TValue *val = NULL;  /* to avoid warnings */
00000a  2000              MOVS     r0,#0
00000c  9001              STR      r0,[sp,#4]
;;;1335     GCObject *owner = NULL;  /* to avoid warnings */
00000e  9000              STR      r0,[sp,#0]
;;;1336     TValue *fi;
;;;1337     lua_lock(L);
;;;1338     fi = index2value(L, funcindex);
000010  4639              MOV      r1,r7
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       index2value
000018  4680              MOV      r8,r0
;;;1339     api_checknelems(L, 1);
;;;1340     name = aux_upvalue(fi, n, &val, &owner);
00001a  466b              MOV      r3,sp
00001c  aa01              ADD      r2,sp,#4
00001e  4629              MOV      r1,r5
000020  4640              MOV      r0,r8
000022  f7fffffe          BL       aux_upvalue
000026  4606              MOV      r6,r0
;;;1341     if (name) {
000028  b306              CBZ      r6,|L73.108|
;;;1342       L->top--;
00002a  68e0              LDR      r0,[r4,#0xc]
00002c  3810              SUBS     r0,r0,#0x10
00002e  60e0              STR      r0,[r4,#0xc]
;;;1343       setobj(L, val, s2v(L->top));
000030  9801              LDR      r0,[sp,#4]
000032  68e1              LDR      r1,[r4,#0xc]
000034  e9d12300          LDRD     r2,r3,[r1,#0]
000038  e9c02300          STRD     r2,r3,[r0,#0]
00003c  7a0a              LDRB     r2,[r1,#8]
00003e  7202              STRB     r2,[r0,#8]
;;;1344       luaC_barrier(L, owner, val);
000040  9801              LDR      r0,[sp,#4]
000042  7a00              LDRB     r0,[r0,#8]
000044  f0000040          AND      r0,r0,#0x40
000048  b188              CBZ      r0,|L73.110|
00004a  9800              LDR      r0,[sp,#0]
00004c  7940              LDRB     r0,[r0,#5]
00004e  f0000020          AND      r0,r0,#0x20
000052  b160              CBZ      r0,|L73.110|
000054  9801              LDR      r0,[sp,#4]
000056  6800              LDR      r0,[r0,#0]
000058  7940              LDRB     r0,[r0,#5]
00005a  f0000018          AND      r0,r0,#0x18
00005e  b130              CBZ      r0,|L73.110|
000060  9801              LDR      r0,[sp,#4]
000062  6802              LDR      r2,[r0,#0]
000064  4620              MOV      r0,r4
000066  9900              LDR      r1,[sp,#0]
000068  f7fffffe          BL       luaC_barrier_
                  |L73.108|
00006c  e000              B        |L73.112|
                  |L73.110|
00006e  bf00              NOP      
                  |L73.112|
;;;1345     }
;;;1346     lua_unlock(L);
;;;1347     return name;
000070  4630              MOV      r0,r6
;;;1348   }
000072  e8bd81fc          POP      {r2-r8,pc}
;;;1349   
                          ENDP


                          AREA ||i.lua_status||, CODE, READONLY, ALIGN=1

                  lua_status PROC
;;;1095   
;;;1096   LUA_API int lua_status (lua_State *L) {
000000  4601              MOV      r1,r0
;;;1097     return L->status;
000002  7a08              LDRB     r0,[r1,#8]
;;;1098   }
000004  4770              BX       lr
;;;1099   
                          ENDP


                          AREA ||i.lua_stringtonumber||, CODE, READONLY, ALIGN=1

                  lua_stringtonumber PROC
;;;344    
;;;345    LUA_API size_t lua_stringtonumber (lua_State *L, const char *s) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;346      size_t sz = luaO_str2num(s, s2v(L->top));
000006  4628              MOV      r0,r5
000008  68e1              LDR      r1,[r4,#0xc]
00000a  f7fffffe          BL       luaO_str2num
00000e  4606              MOV      r6,r0
;;;347      if (sz != 0)
000010  b11e              CBZ      r6,|L75.26|
;;;348        api_incr_top(L);
000012  68e0              LDR      r0,[r4,#0xc]
000014  3010              ADDS     r0,r0,#0x10
000016  60e0              STR      r0,[r4,#0xc]
000018  bf00              NOP      
                  |L75.26|
;;;349      return sz;
00001a  4630              MOV      r0,r6
;;;350    }
00001c  bd70              POP      {r4-r6,pc}
;;;351    
                          ENDP


                          AREA ||i.lua_toboolean||, CODE, READONLY, ALIGN=1

                  lua_toboolean PROC
;;;374    
;;;375    LUA_API int lua_toboolean (lua_State *L, int idx) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;376      const TValue *o = index2value(L, idx);
000006  4631              MOV      r1,r6
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       index2value
00000e  4604              MOV      r4,r0
;;;377      return !l_isfalse(o);
000010  7a20              LDRB     r0,[r4,#8]
000012  b130              CBZ      r0,|L76.34|
000014  7a20              LDRB     r0,[r4,#8]
000016  2801              CMP      r0,#1
000018  d101              BNE      |L76.30|
00001a  6820              LDR      r0,[r4,#0]
00001c  b108              CBZ      r0,|L76.34|
                  |L76.30|
00001e  2001              MOVS     r0,#1
                  |L76.32|
;;;378    }
000020  bd70              POP      {r4-r6,pc}
                  |L76.34|
000022  2000              MOVS     r0,#0                 ;377
000024  e7fc              B        |L76.32|
;;;379    
                          ENDP


                          AREA ||i.lua_tocfunction||, CODE, READONLY, ALIGN=1

                  lua_tocfunction PROC
;;;411    
;;;412    LUA_API lua_CFunction lua_tocfunction (lua_State *L, int idx) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;413      const TValue *o = index2value(L, idx);
000006  4631              MOV      r1,r6
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       index2value
00000e  4604              MOV      r4,r0
;;;414      if (ttislcf(o)) return fvalue(o);
000010  7a20              LDRB     r0,[r4,#8]
000012  2826              CMP      r0,#0x26
000014  d101              BNE      |L77.26|
000016  6820              LDR      r0,[r4,#0]
                  |L77.24|
;;;415      else if (ttisCclosure(o))
;;;416        return clCvalue(o)->f;
;;;417      else return NULL;  /* not a C function */
;;;418    }
000018  bd70              POP      {r4-r6,pc}
                  |L77.26|
00001a  7a20              LDRB     r0,[r4,#8]            ;415
00001c  2876              CMP      r0,#0x76              ;415
00001e  d102              BNE      |L77.38|
000020  6820              LDR      r0,[r4,#0]            ;416
000022  68c0              LDR      r0,[r0,#0xc]          ;416
000024  e7f8              B        |L77.24|
                  |L77.38|
000026  2000              MOVS     r0,#0                 ;417
000028  e7f6              B        |L77.24|
;;;419    
                          ENDP


                          AREA ||i.lua_tointegerx||, CODE, READONLY, ALIGN=1

                  lua_tointegerx PROC
;;;363    
;;;364    LUA_API lua_Integer lua_tointegerx (lua_State *L, int idx, int *pisnum) {
000000  e92d41fc          PUSH     {r2-r8,lr}
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4614              MOV      r4,r2
;;;365      lua_Integer res;
;;;366      const TValue *o = index2value(L, idx);
00000a  4641              MOV      r1,r8
00000c  4638              MOV      r0,r7
00000e  f7fffffe          BL       index2value
000012  4605              MOV      r5,r0
;;;367      int isnum = tointeger(o, &res);
000014  7a28              LDRB     r0,[r5,#8]
000016  2823              CMP      r0,#0x23
000018  d105              BNE      |L78.38|
00001a  e9d50100          LDRD     r0,r1,[r5,#0]
00001e  e9cd0100          STRD     r0,r1,[sp,#0]
000022  2001              MOVS     r0,#1
000024  e004              B        |L78.48|
                  |L78.38|
000026  2200              MOVS     r2,#0
000028  4669              MOV      r1,sp
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       luaV_tointeger
                  |L78.48|
000030  4606              MOV      r6,r0
;;;368      if (!isnum)
000032  b916              CBNZ     r6,|L78.58|
;;;369        res = 0;  /* call to 'tointeger' may change 'n' even if it fails */
000034  2000              MOVS     r0,#0
000036  9000              STR      r0,[sp,#0]
000038  9001              STR      r0,[sp,#4]
                  |L78.58|
;;;370      if (pisnum) *pisnum = isnum;
00003a  b104              CBZ      r4,|L78.62|
00003c  6026              STR      r6,[r4,#0]
                  |L78.62|
;;;371      return res;
00003e  e9dd0100          LDRD     r0,r1,[sp,#0]
;;;372    }
000042  e8bd81fc          POP      {r2-r8,pc}
;;;373    
                          ENDP


                          AREA ||i.lua_tolstring||, CODE, READONLY, ALIGN=1

                  lua_tolstring PROC
;;;380    
;;;381    LUA_API const char *lua_tolstring (lua_State *L, int idx, size_t *len) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;382      TValue *o = index2value(L, idx);
00000a  4639              MOV      r1,r7
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       index2value
000012  4604              MOV      r4,r0
;;;383      if (!ttisstring(o)) {
000014  7a20              LDRB     r0,[r4,#8]
000016  f000000f          AND      r0,r0,#0xf
00001a  2804              CMP      r0,#4
00001c  d01c              BEQ      |L79.88|
;;;384        if (!cvt2str(o)) {  /* not convertible? */
00001e  7a20              LDRB     r0,[r4,#8]
000020  f000000f          AND      r0,r0,#0xf
000024  2803              CMP      r0,#3
000026  d005              BEQ      |L79.52|
;;;385          if (len != NULL) *len = 0;
000028  b10d              CBZ      r5,|L79.46|
00002a  2000              MOVS     r0,#0
00002c  6028              STR      r0,[r5,#0]
                  |L79.46|
;;;386          return NULL;
00002e  2000              MOVS     r0,#0
                  |L79.48|
;;;387        }
;;;388        lua_lock(L);  /* 'luaO_tostring' may create a new string */
;;;389        luaO_tostring(L, o);
;;;390        luaC_checkGC(L);
;;;391        o = index2value(L, idx);  /* previous call may reallocate the stack */
;;;392        lua_unlock(L);
;;;393      }
;;;394      if (len != NULL)
;;;395        *len = vslen(o);
;;;396      return svalue(o);
;;;397    }
000030  e8bd81f0          POP      {r4-r8,pc}
                  |L79.52|
000034  4621              MOV      r1,r4                 ;389
000036  4630              MOV      r0,r6                 ;389
000038  f7fffffe          BL       luaO_tostring
00003c  6930              LDR      r0,[r6,#0x10]         ;390
00003e  68c0              LDR      r0,[r0,#0xc]          ;390
000040  2800              CMP      r0,#0                 ;390
000042  dd03              BLE      |L79.76|
000044  4630              MOV      r0,r6                 ;390
000046  f7fffffe          BL       luaC_step
00004a  bf00              NOP                            ;390
                  |L79.76|
00004c  4639              MOV      r1,r7                 ;391
00004e  4630              MOV      r0,r6                 ;391
000050  f7fffffe          BL       index2value
000054  4604              MOV      r4,r0                 ;391
000056  bf00              NOP                            ;392
                  |L79.88|
000058  b14d              CBZ      r5,|L79.110|
00005a  6820              LDR      r0,[r4,#0]            ;395
00005c  7900              LDRB     r0,[r0,#4]            ;395
00005e  2814              CMP      r0,#0x14              ;395
000060  d102              BNE      |L79.104|
000062  6820              LDR      r0,[r4,#0]            ;395
000064  79c0              LDRB     r0,[r0,#7]            ;395
000066  e001              B        |L79.108|
                  |L79.104|
000068  6820              LDR      r0,[r4,#0]            ;395
00006a  68c0              LDR      r0,[r0,#0xc]          ;395
                  |L79.108|
00006c  6028              STR      r0,[r5,#0]            ;395
                  |L79.110|
00006e  6820              LDR      r0,[r4,#0]            ;396
000070  3010              ADDS     r0,r0,#0x10           ;396
000072  e7dd              B        |L79.48|
;;;398    
                          ENDP


                          AREA ||i.lua_tonumberx||, CODE, READONLY, ALIGN=1

                  lua_tonumberx PROC
;;;352    
;;;353    LUA_API lua_Number lua_tonumberx (lua_State *L, int idx, int *pisnum) {
000000  e92d41fc          PUSH     {r2-r8,lr}
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4614              MOV      r4,r2
;;;354      lua_Number n;
;;;355      const TValue *o = index2value(L, idx);
00000a  4641              MOV      r1,r8
00000c  4638              MOV      r0,r7
00000e  f7fffffe          BL       index2value
000012  4605              MOV      r5,r0
;;;356      int isnum = tonumber(o, &n);
000014  7a28              LDRB     r0,[r5,#8]
000016  2813              CMP      r0,#0x13
000018  d105              BNE      |L80.38|
00001a  e9d50100          LDRD     r0,r1,[r5,#0]
00001e  e9cd0100          STRD     r0,r1,[sp,#0]
000022  2001              MOVS     r0,#1
000024  e003              B        |L80.46|
                  |L80.38|
000026  4669              MOV      r1,sp
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       luaV_tonumber_
                  |L80.46|
00002e  4606              MOV      r6,r0
;;;357      if (!isnum)
000030  b916              CBNZ     r6,|L80.56|
;;;358        n = 0;  /* call to 'tonumber' may change 'n' even if it fails */
000032  2000              MOVS     r0,#0
000034  9000              STR      r0,[sp,#0]
000036  9001              STR      r0,[sp,#4]
                  |L80.56|
;;;359      if (pisnum) *pisnum = isnum;
000038  b104              CBZ      r4,|L80.60|
00003a  6026              STR      r6,[r4,#0]
                  |L80.60|
;;;360      return n;
00003c  e9dd0100          LDRD     r0,r1,[sp,#0]
;;;361    }
000040  e8bd81fc          POP      {r2-r8,pc}
;;;362    
                          ENDP


                          AREA ||i.lua_topointer||, CODE, READONLY, ALIGN=1

                  lua_topointer PROC
;;;436    
;;;437    LUA_API const void *lua_topointer (lua_State *L, int idx) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;438      const TValue *o = index2value(L, idx);
000006  4631              MOV      r1,r6
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       index2value
00000e  4604              MOV      r4,r0
;;;439      switch (ttypetag(o)) {
000010  7a20              LDRB     r0,[r4,#8]
000012  f000003f          AND      r0,r0,#0x3f
000016  2808              CMP      r0,#8
000018  d016              BEQ      |L81.72|
00001a  dc06              BGT      |L81.42|
00001c  2802              CMP      r0,#2
00001e  d020              BEQ      |L81.98|
000020  2805              CMP      r0,#5
000022  d009              BEQ      |L81.56|
000024  2807              CMP      r0,#7
000026  d11e              BNE      |L81.102|
000028  e010              B        |L81.76|
                  |L81.42|
00002a  2816              CMP      r0,#0x16
00002c  d006              BEQ      |L81.60|
00002e  2826              CMP      r0,#0x26
000030  d008              BEQ      |L81.68|
000032  2836              CMP      r0,#0x36
000034  d117              BNE      |L81.102|
000036  e003              B        |L81.64|
                  |L81.56|
;;;440        case LUA_TTABLE: return hvalue(o);
000038  6820              LDR      r0,[r4,#0]
                  |L81.58|
;;;441        case LUA_TLCL: return clLvalue(o);
;;;442        case LUA_TCCL: return clCvalue(o);
;;;443        case LUA_TLCF: return cast_voidp(cast_sizet(fvalue(o)));
;;;444        case LUA_TTHREAD: return thvalue(o);
;;;445        case LUA_TUSERDATA: return getudatamem(uvalue(o));
;;;446        case LUA_TLIGHTUSERDATA: return pvalue(o);
;;;447        default: return NULL;
;;;448      }
;;;449    }
00003a  bd70              POP      {r4-r6,pc}
                  |L81.60|
00003c  6820              LDR      r0,[r4,#0]            ;441
00003e  e7fc              B        |L81.58|
                  |L81.64|
000040  6820              LDR      r0,[r4,#0]            ;442
000042  e7fa              B        |L81.58|
                  |L81.68|
000044  6820              LDR      r0,[r4,#0]            ;443
000046  e7f8              B        |L81.58|
                  |L81.72|
000048  6820              LDR      r0,[r4,#0]            ;444
00004a  e7f6              B        |L81.58|
                  |L81.76|
00004c  6821              LDR      r1,[r4,#0]            ;445
00004e  88c8              LDRH     r0,[r1,#6]            ;445
000050  b908              CBNZ     r0,|L81.86|
000052  2010              MOVS     r0,#0x10              ;445
000054  e003              B        |L81.94|
                  |L81.86|
000056  6820              LDR      r0,[r4,#0]            ;445
000058  88c0              LDRH     r0,[r0,#6]            ;445
00005a  0100              LSLS     r0,r0,#4              ;445
00005c  3018              ADDS     r0,r0,#0x18           ;445
                  |L81.94|
00005e  4408              ADD      r0,r0,r1              ;445
000060  e7eb              B        |L81.58|
                  |L81.98|
000062  6820              LDR      r0,[r4,#0]            ;446
000064  e7e9              B        |L81.58|
                  |L81.102|
000066  2000              MOVS     r0,#0                 ;447
000068  e7e7              B        |L81.58|
;;;450    
                          ENDP


                          AREA ||i.lua_tothread||, CODE, READONLY, ALIGN=1

                  lua_tothread PROC
;;;430    
;;;431    LUA_API lua_State *lua_tothread (lua_State *L, int idx) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;432      const TValue *o = index2value(L, idx);
000006  4631              MOV      r1,r6
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       index2value
00000e  4604              MOV      r4,r0
;;;433      return (!ttisthread(o)) ? NULL : thvalue(o);
000010  7a20              LDRB     r0,[r4,#8]
000012  2848              CMP      r0,#0x48
000014  d001              BEQ      |L82.26|
000016  2000              MOVS     r0,#0
                  |L82.24|
;;;434    }
000018  bd70              POP      {r4-r6,pc}
                  |L82.26|
00001a  6820              LDR      r0,[r4,#0]            ;433
00001c  e7fc              B        |L82.24|
;;;435    
                          ENDP


                          AREA ||i.lua_touserdata||, CODE, READONLY, ALIGN=1

                  lua_touserdata PROC
;;;420    
;;;421    LUA_API void *lua_touserdata (lua_State *L, int idx) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;422      const TValue *o = index2value(L, idx);
000006  4631              MOV      r1,r6
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       index2value
00000e  4604              MOV      r4,r0
;;;423      switch (ttype(o)) {
000010  7a20              LDRB     r0,[r4,#8]
000012  f000000f          AND      r0,r0,#0xf
000016  2802              CMP      r0,#2
000018  d00c              BEQ      |L83.52|
00001a  2807              CMP      r0,#7
00001c  d10c              BNE      |L83.56|
;;;424        case LUA_TUSERDATA: return getudatamem(uvalue(o));
00001e  6821              LDR      r1,[r4,#0]
000020  88c8              LDRH     r0,[r1,#6]
000022  b908              CBNZ     r0,|L83.40|
000024  2010              MOVS     r0,#0x10
000026  e003              B        |L83.48|
                  |L83.40|
000028  6820              LDR      r0,[r4,#0]
00002a  88c0              LDRH     r0,[r0,#6]
00002c  0100              LSLS     r0,r0,#4
00002e  3018              ADDS     r0,r0,#0x18
                  |L83.48|
000030  4408              ADD      r0,r0,r1
                  |L83.50|
;;;425        case LUA_TLIGHTUSERDATA: return pvalue(o);
;;;426        default: return NULL;
;;;427      }
;;;428    }
000032  bd70              POP      {r4-r6,pc}
                  |L83.52|
000034  6820              LDR      r0,[r4,#0]            ;425
000036  e7fc              B        |L83.50|
                  |L83.56|
000038  2000              MOVS     r0,#0                 ;426
00003a  e7fa              B        |L83.50|
;;;429    
                          ENDP


                          AREA ||i.lua_type||, CODE, READONLY, ALIGN=2

                  lua_type PROC
;;;257    
;;;258    LUA_API int lua_type (lua_State *L, int idx) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;259      const TValue *o = index2value(L, idx);
000006  4631              MOV      r1,r6
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       index2value
00000e  4604              MOV      r4,r0
;;;260      return (isvalid(o) ? ttype(o) : LUA_TNONE);
000010  4804              LDR      r0,|L84.36|
000012  4284              CMP      r4,r0
000014  d003              BEQ      |L84.30|
000016  7a20              LDRB     r0,[r4,#8]
000018  f000000f          AND      r0,r0,#0xf
                  |L84.28|
;;;261    }
00001c  bd70              POP      {r4-r6,pc}
                  |L84.30|
00001e  f04f30ff          MOV      r0,#0xffffffff        ;260
000022  e7fb              B        |L84.28|
;;;262    
                          ENDP

                  |L84.36|
                          DCD      luaO_nilobject_

                          AREA ||i.lua_typename||, CODE, READONLY, ALIGN=2

                  lua_typename PROC
;;;263    
;;;264    LUA_API const char *lua_typename (lua_State *L, int t) {
000000  4602              MOV      r2,r0
;;;265      UNUSED(L);
;;;266      api_check(L, LUA_TNONE <= t && t < LUA_NUMTAGS, "invalid tag");
;;;267      return ttypename(t);
000002  4b02              LDR      r3,|L85.12|
000004  1c48              ADDS     r0,r1,#1
000006  f8530020          LDR      r0,[r3,r0,LSL #2]
;;;268    }
00000a  4770              BX       lr
;;;269    
                          ENDP

                  |L85.12|
                          DCD      luaT_typenames_

                          AREA ||i.lua_upvalueid||, CODE, READONLY, ALIGN=1

                  lua_upvalueid PROC
;;;1361   
;;;1362   LUA_API void *lua_upvalueid (lua_State *L, int fidx, int n) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
;;;1363     TValue *fi = index2value(L, fidx);
00000a  4639              MOV      r1,r7
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       index2value
000012  4605              MOV      r5,r0
;;;1364     switch (ttypetag(fi)) {
000014  7a28              LDRB     r0,[r5,#8]
000016  f000003f          AND      r0,r0,#0x3f
00001a  2816              CMP      r0,#0x16
00001c  d002              BEQ      |L86.36|
00001e  2836              CMP      r0,#0x36
000020  d110              BNE      |L86.68|
000022  e008              B        |L86.54|
                  |L86.36|
;;;1365       case LUA_TLCL: {  /* lua closure */
;;;1366         return *getupvalref(L, fidx, n, NULL);
000024  2300              MOVS     r3,#0
000026  4622              MOV      r2,r4
000028  4639              MOV      r1,r7
00002a  4630              MOV      r0,r6
00002c  f7fffffe          BL       getupvalref
000030  6800              LDR      r0,[r0,#0]
                  |L86.50|
;;;1367       }
;;;1368       case LUA_TCCL: {  /* C closure */
;;;1369         CClosure *f = clCvalue(fi);
;;;1370         api_check(L, 1 <= n && n <= f->nupvalues, "invalid upvalue index");
;;;1371         return &f->upvalue[n - 1];
;;;1372       }
;;;1373       default: {
;;;1374         api_check(L, 0, "closure expected");
;;;1375         return NULL;
;;;1376       }
;;;1377     }
;;;1378   }
000032  e8bd81f0          POP      {r4-r8,pc}
                  |L86.54|
000036  6829              LDR      r1,[r5,#0]            ;1369
000038  1e60              SUBS     r0,r4,#1              ;1371
00003a  f1010210          ADD      r2,r1,#0x10           ;1371
00003e  eb021000          ADD      r0,r2,r0,LSL #4       ;1371
000042  e7f6              B        |L86.50|
                  |L86.68|
000044  2000              MOVS     r0,#0                 ;1375
000046  e7f4              B        |L86.50|
;;;1379   
                          ENDP


                          AREA ||i.lua_upvaluejoin||, CODE, READONLY, ALIGN=1

                  lua_upvaluejoin PROC
;;;1380   
;;;1381   LUA_API void lua_upvaluejoin (lua_State *L, int fidx1, int n1,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1382                                               int fidx2, int n2) {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  461d              MOV      r5,r3
00000c  f8dd9028          LDR      r9,[sp,#0x28]
;;;1383     LClosure *f1;
;;;1384     UpVal **up1 = getupvalref(L, fidx1, n1, &f1);
000010  466b              MOV      r3,sp
000012  4642              MOV      r2,r8
000014  4639              MOV      r1,r7
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       getupvalref
00001c  4604              MOV      r4,r0
;;;1385     UpVal **up2 = getupvalref(L, fidx2, n2, NULL);
00001e  2300              MOVS     r3,#0
000020  464a              MOV      r2,r9
000022  4629              MOV      r1,r5
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       getupvalref
00002a  4682              MOV      r10,r0
;;;1386     *up1 = *up2;
00002c  f8da0000          LDR      r0,[r10,#0]
000030  6020              STR      r0,[r4,#0]
;;;1387     luaC_objbarrier(L, f1, *up1);
000032  9800              LDR      r0,[sp,#0]
000034  7940              LDRB     r0,[r0,#5]
000036  f0000020          AND      r0,r0,#0x20
00003a  b150              CBZ      r0,|L87.82|
00003c  6820              LDR      r0,[r4,#0]
00003e  7940              LDRB     r0,[r0,#5]
000040  f0000018          AND      r0,r0,#0x18
000044  b128              CBZ      r0,|L87.82|
000046  6822              LDR      r2,[r4,#0]
000048  4630              MOV      r0,r6
00004a  9900              LDR      r1,[sp,#0]
00004c  f7fffffe          BL       luaC_barrier_
000050  e000              B        |L87.84|
                  |L87.82|
000052  bf00              NOP      
                  |L87.84|
;;;1388   }
000054  e8bd8ff8          POP      {r3-r11,pc}
;;;1389   
                          ENDP


                          AREA ||i.lua_version||, CODE, READONLY, ALIGN=2

                  lua_version PROC
;;;149    
;;;150    LUA_API const lua_Number *lua_version (lua_State *L) {
000000  4601              MOV      r1,r0
;;;151      static const lua_Number version = LUA_VERSION_NUM;
;;;152      if (L == NULL) return &version;
000002  b909              CBNZ     r1,|L88.8|
000004  4802              LDR      r0,|L88.16|
                  |L88.6|
;;;153      else return G(L)->version;
;;;154    }
000006  4770              BX       lr
                  |L88.8|
000008  6908              LDR      r0,[r1,#0x10]         ;153
00000a  f8d00090          LDR      r0,[r0,#0x90]         ;153
00000e  e7fa              B        |L88.6|
;;;155    
                          ENDP

                  |L88.16|
                          DCD      version

                          AREA ||i.lua_xmove||, CODE, READONLY, ALIGN=1

                  lua_xmove PROC
;;;123    
;;;124    LUA_API void lua_xmove (lua_State *from, lua_State *to, int n) {
000000  b5f0              PUSH     {r4-r7,lr}
000002  4613              MOV      r3,r2
;;;125      int i;
;;;126      if (from == to) return;
000004  4288              CMP      r0,r1
000006  d100              BNE      |L89.10|
                  |L89.8|
;;;127      lua_lock(to);
;;;128      api_checknelems(from, n);
;;;129      api_check(from, G(from) == G(to), "moving among independent states");
;;;130      api_check(from, to->ci->top - to->top >= n, "stack overflow");
;;;131      from->top -= n;
;;;132      for (i = 0; i < n; i++) {
;;;133        setobjs2s(to, to->top, from->top + i);
;;;134        to->top++;  /* stack already checked by previous 'api_check' */
;;;135      }
;;;136      lua_unlock(to);
;;;137    }
000008  bdf0              POP      {r4-r7,pc}
                  |L89.10|
00000a  68c4              LDR      r4,[r0,#0xc]          ;131
00000c  eba41403          SUB      r4,r4,r3,LSL #4       ;131
000010  60c4              STR      r4,[r0,#0xc]          ;131
000012  2200              MOVS     r2,#0                 ;132
000014  e00d              B        |L89.50|
                  |L89.22|
000016  68cc              LDR      r4,[r1,#0xc]          ;133
000018  68c6              LDR      r6,[r0,#0xc]          ;133
00001a  eb061502          ADD      r5,r6,r2,LSL #4       ;133
00001e  e9d56700          LDRD     r6,r7,[r5,#0]         ;133
000022  e9c46700          STRD     r6,r7,[r4,#0]         ;133
000026  7a2e              LDRB     r6,[r5,#8]            ;133
000028  7226              STRB     r6,[r4,#8]            ;133
00002a  68cc              LDR      r4,[r1,#0xc]          ;134
00002c  3410              ADDS     r4,r4,#0x10           ;134
00002e  60cc              STR      r4,[r1,#0xc]          ;134
000030  1c52              ADDS     r2,r2,#1              ;132
                  |L89.50|
000032  429a              CMP      r2,r3                 ;132
000034  dbef              BLT      |L89.22|
000036  bf00              NOP      
000038  e7e6              B        |L89.8|
;;;138    
                          ENDP


                          AREA ||i.reverse||, CODE, READONLY, ALIGN=1

                  reverse PROC
;;;200    */
;;;201    static void reverse (lua_State *L, StkId from, StkId to) {
000000  b57f              PUSH     {r0-r6,lr}
000002  4604              MOV      r4,r0
;;;202      for (; from < to; from++, to--) {
000004  e019              B        |L90.58|
                  |L90.6|
;;;203        TValue temp;
;;;204        setobj(L, &temp, s2v(from));
000006  4668              MOV      r0,sp
000008  460b              MOV      r3,r1
00000a  e9d35600          LDRD     r5,r6,[r3,#0]
00000e  e9c05600          STRD     r5,r6,[r0,#0]
000012  7a1d              LDRB     r5,[r3,#8]
000014  7205              STRB     r5,[r0,#8]
;;;205        setobjs2s(L, from, to);
000016  4608              MOV      r0,r1
000018  4613              MOV      r3,r2
00001a  e9d35600          LDRD     r5,r6,[r3,#0]
00001e  e9c05600          STRD     r5,r6,[r0,#0]
000022  7a1d              LDRB     r5,[r3,#8]
000024  7205              STRB     r5,[r0,#8]
;;;206        setobj2s(L, to, &temp);
000026  4610              MOV      r0,r2
000028  466b              MOV      r3,sp
00002a  e9d35600          LDRD     r5,r6,[r3,#0]
00002e  e9c05600          STRD     r5,r6,[r0,#0]
000032  7a1d              LDRB     r5,[r3,#8]
000034  7205              STRB     r5,[r0,#8]
000036  3110              ADDS     r1,r1,#0x10           ;202
000038  3a10              SUBS     r2,r2,#0x10           ;202
                  |L90.58|
00003a  4291              CMP      r1,r2                 ;202
00003c  d3e3              BCC      |L90.6|
;;;207      }
;;;208    }
00003e  bd7f              POP      {r0-r6,pc}
;;;209    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=3

                  lua_ident
000000  244c7561          DCB      0x24,0x4c,0x75,0x61
000004  56657273          DCB      0x56,0x65,0x72,0x73
000008  696f6e3a          DCB      0x69,0x6f,0x6e,0x3a
00000c  204c7561          DCB      0x20,0x4c,0x75,0x61
000010  20352e34          DCB      0x20,0x35,0x2e,0x34
000014  2e302020          DCB      0x2e,0x30,0x20,0x20
000018  436f7079          DCB      0x43,0x6f,0x70,0x79
00001c  72696768          DCB      0x72,0x69,0x67,0x68
000020  74202843          DCB      0x74,0x20,0x28,0x43
000024  29203139          DCB      0x29,0x20,0x31,0x39
000028  39342d32          DCB      0x39,0x34,0x2d,0x32
00002c  30313820          DCB      0x30,0x31,0x38,0x20
000030  4c75612e          DCB      0x4c,0x75,0x61,0x2e
000034  6f72672c          DCB      0x6f,0x72,0x67,0x2c
000038  20505543          DCB      0x20,0x50,0x55,0x43
00003c  2d52696f          DCB      0x2d,0x52,0x69,0x6f
000040  2024244c          DCB      0x20,0x24,0x24,0x4c
000044  75614175          DCB      0x75,0x61,0x41,0x75
000048  74686f72          DCB      0x74,0x68,0x6f,0x72
00004c  733a2052          DCB      0x73,0x3a,0x20,0x52
000050  2e204965          DCB      0x2e,0x20,0x49,0x65
000054  72757361          DCB      0x72,0x75,0x73,0x61
000058  6c696d73          DCB      0x6c,0x69,0x6d,0x73
00005c  6368792c          DCB      0x63,0x68,0x79,0x2c
000060  204c2e20          DCB      0x20,0x4c,0x2e,0x20
000064  482e2064          DCB      0x48,0x2e,0x20,0x64
000068  65204669          DCB      0x65,0x20,0x46,0x69
00006c  67756569          DCB      0x67,0x75,0x65,0x69
000070  7265646f          DCB      0x72,0x65,0x64,0x6f
000074  2c20572e          DCB      0x2c,0x20,0x57,0x2e
000078  2043656c          DCB      0x20,0x43,0x65,0x6c
00007c  65732024          DCB      0x65,0x73,0x20,0x24
000080  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
                  version
000088  00000000          DCFD     0x407f800000000000 ; 504
00008c  407f8000
