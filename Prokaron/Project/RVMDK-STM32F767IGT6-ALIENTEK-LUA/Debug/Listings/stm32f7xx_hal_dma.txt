; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\stm32f7xx_hal_dma.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\stm32f7xx_hal_dma.d --cpu=Cortex-M7 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Inc -I.\Source -I.\Drivers -I..\..\..\M6P1(L)_Lua\lua -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6-ALIENTEK-LUA\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER -Dlua_writestring=RMP_lua_writestring -Dlua_writeline=RMP_lua_writeline --enum_is_int --signed_chars --omf_browse=.\debug\output\stm32f7xx_hal_dma.crf ..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Src\stm32f7xx_hal_dma.c]
                          THUMB

                          AREA ||i.DMA_CalcBaseAndBitshift||, CODE, READONLY, ALIGN=2

                  DMA_CalcBaseAndBitshift PROC
;;;1201     */
;;;1202   static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
000000  4601              MOV      r1,r0
;;;1203   {
;;;1204     uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
000002  7808              LDRB     r0,[r1,#0]
000004  3810              SUBS     r0,r0,#0x10
000006  2318              MOVS     r3,#0x18
000008  fbb0f2f3          UDIV     r2,r0,r3
;;;1205     
;;;1206     /* lookup table for necessary bitshift of flags within status registers */
;;;1207     static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
;;;1208     hdma->StreamIndex = flagBitshiftOffset[stream_number];
00000c  4808              LDR      r0,|L1.48|
00000e  5c80              LDRB     r0,[r0,r2]
000010  6608              STR      r0,[r1,#0x60]
;;;1209     
;;;1210     if (stream_number > 3U)
000012  2a03              CMP      r2,#3
000014  d905              BLS      |L1.34|
;;;1211     {
;;;1212       /* return pointer to HISR and HIFCR */
;;;1213       hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
000016  6808              LDR      r0,[r1,#0]
000018  f36f0009          BFC      r0,#0,#10
00001c  1d00              ADDS     r0,r0,#4
00001e  65c8              STR      r0,[r1,#0x5c]
000020  e003              B        |L1.42|
                  |L1.34|
;;;1214     }
;;;1215     else
;;;1216     {
;;;1217       /* return pointer to LISR and LIFCR */
;;;1218       hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU));
000022  6808              LDR      r0,[r1,#0]
000024  f36f0009          BFC      r0,#0,#10
000028  65c8              STR      r0,[r1,#0x5c]
                  |L1.42|
;;;1219     }
;;;1220     
;;;1221     return hdma->StreamBaseAddress;
00002a  6dc8              LDR      r0,[r1,#0x5c]
;;;1222   }
00002c  4770              BX       lr
;;;1223   
                          ENDP

00002e  0000              DCW      0x0000
                  |L1.48|
                          DCD      flagBitshiftOffset

                          AREA ||i.DMA_CheckFifoParam||, CODE, READONLY, ALIGN=1

                  DMA_CheckFifoParam PROC
;;;1229     */
;;;1230   static HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma)
000000  4601              MOV      r1,r0
;;;1231   {
;;;1232     HAL_StatusTypeDef status = HAL_OK;
000002  2000              MOVS     r0,#0
;;;1233     uint32_t tmp = hdma->Init.FIFOThreshold;
000004  6a8a              LDR      r2,[r1,#0x28]
;;;1234     
;;;1235     /* Memory Data size equal to Byte */
;;;1236     if(hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
000006  698b              LDR      r3,[r1,#0x18]
000008  b9cb              CBNZ     r3,|L2.62|
;;;1237     {
;;;1238       switch (tmp)
00000a  b132              CBZ      r2,|L2.26|
00000c  2a01              CMP      r2,#1
00000e  d00d              BEQ      |L2.44|
000010  2a02              CMP      r2,#2
000012  d003              BEQ      |L2.28|
000014  2a03              CMP      r2,#3
000016  d110              BNE      |L2.58|
000018  e00e              B        |L2.56|
                  |L2.26|
;;;1239       {
;;;1240       case DMA_FIFO_THRESHOLD_1QUARTERFULL:
;;;1241       case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
00001a  bf00              NOP      
                  |L2.28|
;;;1242         if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
00001c  6acb              LDR      r3,[r1,#0x2c]
00001e  f0037380          AND      r3,r3,#0x1000000
000022  f1b37f80          CMP      r3,#0x1000000
000026  d100              BNE      |L2.42|
;;;1243         {
;;;1244           status = HAL_ERROR;
000028  2001              MOVS     r0,#1
                  |L2.42|
;;;1245         }
;;;1246         break;
00002a  e007              B        |L2.60|
                  |L2.44|
;;;1247       case DMA_FIFO_THRESHOLD_HALFFULL:
;;;1248         if (hdma->Init.MemBurst == DMA_MBURST_INC16)
00002c  6acb              LDR      r3,[r1,#0x2c]
00002e  f1b37fc0          CMP      r3,#0x1800000
000032  d100              BNE      |L2.54|
;;;1249         {
;;;1250           status = HAL_ERROR;
000034  2001              MOVS     r0,#1
                  |L2.54|
;;;1251         }
;;;1252         break;
000036  e001              B        |L2.60|
                  |L2.56|
;;;1253       case DMA_FIFO_THRESHOLD_FULL:
;;;1254         break;
000038  e000              B        |L2.60|
                  |L2.58|
;;;1255       default:
;;;1256         break;
00003a  bf00              NOP      
                  |L2.60|
00003c  e034              B        |L2.168|
                  |L2.62|
;;;1257       }
;;;1258     }
;;;1259     
;;;1260     /* Memory Data size equal to Half-Word */
;;;1261     else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
00003e  698b              LDR      r3,[r1,#0x18]
000040  f5b35f00          CMP      r3,#0x2000
000044  d11a              BNE      |L2.124|
;;;1262     {
;;;1263       switch (tmp)
000046  b132              CBZ      r2,|L2.86|
000048  2a01              CMP      r2,#1
00004a  d007              BEQ      |L2.92|
00004c  2a02              CMP      r2,#2
00004e  d003              BEQ      |L2.88|
000050  2a03              CMP      r2,#3
000052  d111              BNE      |L2.120|
000054  e00a              B        |L2.108|
                  |L2.86|
;;;1264       {
;;;1265       case DMA_FIFO_THRESHOLD_1QUARTERFULL:
;;;1266       case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
000056  bf00              NOP      
                  |L2.88|
;;;1267         status = HAL_ERROR;
000058  2001              MOVS     r0,#1
;;;1268         break;
00005a  e00e              B        |L2.122|
                  |L2.92|
;;;1269       case DMA_FIFO_THRESHOLD_HALFFULL:
;;;1270         if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
00005c  6acb              LDR      r3,[r1,#0x2c]
00005e  f0037380          AND      r3,r3,#0x1000000
000062  f1b37f80          CMP      r3,#0x1000000
000066  d100              BNE      |L2.106|
;;;1271         {
;;;1272           status = HAL_ERROR;
000068  2001              MOVS     r0,#1
                  |L2.106|
;;;1273         }
;;;1274         break;
00006a  e006              B        |L2.122|
                  |L2.108|
;;;1275       case DMA_FIFO_THRESHOLD_FULL:
;;;1276         if (hdma->Init.MemBurst == DMA_MBURST_INC16)
00006c  6acb              LDR      r3,[r1,#0x2c]
00006e  f1b37fc0          CMP      r3,#0x1800000
000072  d100              BNE      |L2.118|
;;;1277         {
;;;1278           status = HAL_ERROR;
000074  2001              MOVS     r0,#1
                  |L2.118|
;;;1279         }
;;;1280         break;   
000076  e000              B        |L2.122|
                  |L2.120|
;;;1281       default:
;;;1282         break;
000078  bf00              NOP      
                  |L2.122|
00007a  e015              B        |L2.168|
                  |L2.124|
;;;1283       }
;;;1284     }
;;;1285     
;;;1286     /* Memory Data size equal to Word */
;;;1287     else
;;;1288     {
;;;1289       switch (tmp)
00007c  b132              CBZ      r2,|L2.140|
00007e  2a01              CMP      r2,#1
000080  d005              BEQ      |L2.142|
000082  2a02              CMP      r2,#2
000084  d004              BEQ      |L2.144|
000086  2a03              CMP      r2,#3
000088  d10c              BNE      |L2.164|
00008a  e003              B        |L2.148|
                  |L2.140|
;;;1290       {
;;;1291       case DMA_FIFO_THRESHOLD_1QUARTERFULL:
;;;1292       case DMA_FIFO_THRESHOLD_HALFFULL:
00008c  bf00              NOP      
                  |L2.142|
;;;1293       case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
00008e  bf00              NOP      
                  |L2.144|
;;;1294         status = HAL_ERROR;
000090  2001              MOVS     r0,#1
;;;1295         break;
000092  e008              B        |L2.166|
                  |L2.148|
;;;1296       case DMA_FIFO_THRESHOLD_FULL:
;;;1297         if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
000094  6acb              LDR      r3,[r1,#0x2c]
000096  f0037380          AND      r3,r3,#0x1000000
00009a  f1b37f80          CMP      r3,#0x1000000
00009e  d100              BNE      |L2.162|
;;;1298         {
;;;1299           status = HAL_ERROR;
0000a0  2001              MOVS     r0,#1
                  |L2.162|
;;;1300         }
;;;1301         break;
0000a2  e000              B        |L2.166|
                  |L2.164|
;;;1302       default:
;;;1303         break;
0000a4  bf00              NOP      
                  |L2.166|
0000a6  bf00              NOP                            ;1295
                  |L2.168|
;;;1304       }
;;;1305     } 
;;;1306     
;;;1307     return status; 
;;;1308   }
0000a8  4770              BX       lr
;;;1309   
                          ENDP


                          AREA ||i.DMA_SetConfig||, CODE, READONLY, ALIGN=1

                  DMA_SetConfig PROC
;;;1167     */
;;;1168   static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
000000  b530              PUSH     {r4,r5,lr}
;;;1169   {
;;;1170     /* Clear DBM bit */
;;;1171     hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
000002  6804              LDR      r4,[r0,#0]
000004  6824              LDR      r4,[r4,#0]
000006  f4242480          BIC      r4,r4,#0x40000
00000a  6805              LDR      r5,[r0,#0]
00000c  602c              STR      r4,[r5,#0]
;;;1172   
;;;1173     /* Configure DMA Stream data length */
;;;1174     hdma->Instance->NDTR = DataLength;
00000e  6804              LDR      r4,[r0,#0]
000010  6063              STR      r3,[r4,#4]
;;;1175   
;;;1176     /* Memory to Peripheral */
;;;1177     if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
000012  6884              LDR      r4,[r0,#8]
000014  2c40              CMP      r4,#0x40
000016  d104              BNE      |L3.34|
;;;1178     {
;;;1179       /* Configure DMA Stream destination address */
;;;1180       hdma->Instance->PAR = DstAddress;
000018  6804              LDR      r4,[r0,#0]
00001a  60a2              STR      r2,[r4,#8]
;;;1181   
;;;1182       /* Configure DMA Stream source address */
;;;1183       hdma->Instance->M0AR = SrcAddress;
00001c  6804              LDR      r4,[r0,#0]
00001e  60e1              STR      r1,[r4,#0xc]
000020  e003              B        |L3.42|
                  |L3.34|
;;;1184     }
;;;1185     /* Peripheral to Memory */
;;;1186     else
;;;1187     {
;;;1188       /* Configure DMA Stream source address */
;;;1189       hdma->Instance->PAR = SrcAddress;
000022  6804              LDR      r4,[r0,#0]
000024  60a1              STR      r1,[r4,#8]
;;;1190   
;;;1191       /* Configure DMA Stream destination address */
;;;1192       hdma->Instance->M0AR = DstAddress;
000026  6804              LDR      r4,[r0,#0]
000028  60e2              STR      r2,[r4,#0xc]
                  |L3.42|
;;;1193     }
;;;1194   }
00002a  bd30              POP      {r4,r5,pc}
;;;1195   
                          ENDP


                          AREA ||i.HAL_DMA_Abort||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Abort PROC
;;;531      */
;;;532    HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;533    {
000002  4604              MOV      r4,r0
;;;534      /* calculate DMA base and stream number */
;;;535      DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
000004  6de5              LDR      r5,[r4,#0x5c]
;;;536      
;;;537      uint32_t tickstart = HAL_GetTick();
000006  f7fffffe          BL       HAL_GetTick
00000a  4606              MOV      r6,r0
;;;538      
;;;539      if(hdma->State != HAL_DMA_STATE_BUSY)
00000c  6ba0              LDR      r0,[r4,#0x38]
00000e  2802              CMP      r0,#2
000010  d007              BEQ      |L4.34|
;;;540      {
;;;541        hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
000012  2080              MOVS     r0,#0x80
000014  65a0              STR      r0,[r4,#0x58]
;;;542        
;;;543        /* Process Unlocked */
;;;544        __HAL_UNLOCK(hdma);
000016  bf00              NOP      
000018  2000              MOVS     r0,#0
00001a  6360              STR      r0,[r4,#0x34]
00001c  bf00              NOP      
;;;545        
;;;546        return HAL_ERROR;
00001e  2001              MOVS     r0,#1
                  |L4.32|
;;;547      }
;;;548      else
;;;549      {
;;;550        /* Disable all the transfer interrupts */
;;;551        hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
;;;552        hdma->Instance->FCR &= ~(DMA_IT_FE);
;;;553        
;;;554        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
;;;555        {
;;;556          hdma->Instance->CR  &= ~(DMA_IT_HT);
;;;557        }
;;;558        
;;;559        /* Disable the stream */
;;;560        __HAL_DMA_DISABLE(hdma);
;;;561        
;;;562        /* Check if the DMA Stream is effectively disabled */
;;;563        while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
;;;564        {
;;;565          /* Check for the Timeout */
;;;566          if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
;;;567          {
;;;568            /* Update error code */
;;;569            hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
;;;570            
;;;571            /* Process Unlocked */
;;;572            __HAL_UNLOCK(hdma);
;;;573            
;;;574            /* Change the DMA state */
;;;575            hdma->State = HAL_DMA_STATE_TIMEOUT;
;;;576            
;;;577            return HAL_TIMEOUT;
;;;578          }
;;;579        }
;;;580        
;;;581        /* Clear all interrupt flags at correct offset within the register */
;;;582        regs->IFCR = 0x3FU << hdma->StreamIndex;
;;;583        
;;;584        /* Process Unlocked */
;;;585        __HAL_UNLOCK(hdma);
;;;586        
;;;587        /* Change the DMA state*/
;;;588        hdma->State = HAL_DMA_STATE_READY;
;;;589      }
;;;590      return HAL_OK;
;;;591    }
000020  bd70              POP      {r4-r6,pc}
                  |L4.34|
000022  6820              LDR      r0,[r4,#0]            ;551
000024  6800              LDR      r0,[r0,#0]            ;551
000026  f0200016          BIC      r0,r0,#0x16           ;551
00002a  6821              LDR      r1,[r4,#0]            ;551
00002c  6008              STR      r0,[r1,#0]            ;551
00002e  6820              LDR      r0,[r4,#0]            ;552
000030  6940              LDR      r0,[r0,#0x14]         ;552
000032  f0200080          BIC      r0,r0,#0x80           ;552
000036  6821              LDR      r1,[r4,#0]            ;552
000038  6148              STR      r0,[r1,#0x14]         ;552
00003a  6c60              LDR      r0,[r4,#0x44]         ;554
00003c  b908              CBNZ     r0,|L4.66|
00003e  6ce0              LDR      r0,[r4,#0x4c]         ;554
000040  b128              CBZ      r0,|L4.78|
                  |L4.66|
000042  6820              LDR      r0,[r4,#0]            ;556
000044  6800              LDR      r0,[r0,#0]            ;556
000046  f0200008          BIC      r0,r0,#8              ;556
00004a  6821              LDR      r1,[r4,#0]            ;556
00004c  6008              STR      r0,[r1,#0]            ;556
                  |L4.78|
00004e  6820              LDR      r0,[r4,#0]            ;560
000050  6800              LDR      r0,[r0,#0]            ;560
000052  f0200001          BIC      r0,r0,#1              ;560
000056  6821              LDR      r1,[r4,#0]            ;560
000058  6008              STR      r0,[r1,#0]            ;560
00005a  e00d              B        |L4.120|
                  |L4.92|
00005c  f7fffffe          BL       HAL_GetTick
000060  1b80              SUBS     r0,r0,r6              ;566
000062  2805              CMP      r0,#5                 ;566
000064  d908              BLS      |L4.120|
000066  2020              MOVS     r0,#0x20              ;569
000068  65a0              STR      r0,[r4,#0x58]         ;569
00006a  bf00              NOP                            ;572
00006c  2000              MOVS     r0,#0                 ;572
00006e  6360              STR      r0,[r4,#0x34]         ;572
000070  bf00              NOP                            ;572
000072  2003              MOVS     r0,#3                 ;575
000074  63a0              STR      r0,[r4,#0x38]         ;575
000076  e7d3              B        |L4.32|
                  |L4.120|
000078  6820              LDR      r0,[r4,#0]            ;563
00007a  6800              LDR      r0,[r0,#0]            ;563
00007c  f0000001          AND      r0,r0,#1              ;563
000080  2800              CMP      r0,#0                 ;563
000082  d1eb              BNE      |L4.92|
000084  f8941060          LDRB     r1,[r4,#0x60]         ;582
000088  203f              MOVS     r0,#0x3f              ;582
00008a  4088              LSLS     r0,r0,r1              ;582
00008c  60a8              STR      r0,[r5,#8]            ;582
00008e  bf00              NOP                            ;585
000090  2000              MOVS     r0,#0                 ;585
000092  6360              STR      r0,[r4,#0x34]         ;585
000094  bf00              NOP                            ;585
000096  2001              MOVS     r0,#1                 ;588
000098  63a0              STR      r0,[r4,#0x38]         ;588
00009a  2000              MOVS     r0,#0                 ;590
00009c  e7c0              B        |L4.32|
;;;592    
                          ENDP


                          AREA ||i.HAL_DMA_Abort_IT||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Abort_IT PROC
;;;598      */
;;;599    HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
000000  4601              MOV      r1,r0
;;;600    {
;;;601      if(hdma->State != HAL_DMA_STATE_BUSY)
000002  6b88              LDR      r0,[r1,#0x38]
000004  2802              CMP      r0,#2
000006  d003              BEQ      |L5.16|
;;;602      {
;;;603        hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
000008  2080              MOVS     r0,#0x80
00000a  6588              STR      r0,[r1,#0x58]
;;;604        return HAL_ERROR;
00000c  2001              MOVS     r0,#1
                  |L5.14|
;;;605      }
;;;606      else
;;;607      {
;;;608        /* Set Abort State  */
;;;609        hdma->State = HAL_DMA_STATE_ABORT;
;;;610        
;;;611        /* Disable the stream */
;;;612        __HAL_DMA_DISABLE(hdma);
;;;613      }
;;;614    
;;;615      return HAL_OK;
;;;616    }
00000e  4770              BX       lr
                  |L5.16|
000010  2005              MOVS     r0,#5                 ;609
000012  6388              STR      r0,[r1,#0x38]         ;609
000014  6808              LDR      r0,[r1,#0]            ;612
000016  6800              LDR      r0,[r0,#0]            ;612
000018  f0200001          BIC      r0,r0,#1              ;612
00001c  680a              LDR      r2,[r1,#0]            ;612
00001e  6010              STR      r0,[r2,#0]            ;612
000020  2000              MOVS     r0,#0                 ;615
000022  e7f4              B        |L5.14|
;;;617    
                          ENDP


                          AREA ||i.HAL_DMA_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_DMA_DeInit PROC
;;;326      */
;;;327    HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;328    {
000002  4604              MOV      r4,r0
;;;329      DMA_Base_Registers *regs;
;;;330    
;;;331      /* Check the DMA peripheral state */
;;;332      if(hdma == NULL)
000004  b90c              CBNZ     r4,|L6.10|
;;;333      {
;;;334        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L6.8|
;;;335      }
;;;336      
;;;337      /* Check the DMA peripheral state */
;;;338      if(hdma->State == HAL_DMA_STATE_BUSY)
;;;339      {
;;;340        /* Return error status */
;;;341        return HAL_BUSY;
;;;342      }
;;;343    
;;;344      /* Check the parameters */
;;;345      assert_param(IS_DMA_STREAM_ALL_INSTANCE(hdma->Instance));
;;;346    
;;;347      /* Disable the selected DMA Streamx */
;;;348      __HAL_DMA_DISABLE(hdma);
;;;349    
;;;350      /* Reset DMA Streamx control register */
;;;351      hdma->Instance->CR   = 0U;
;;;352    
;;;353      /* Reset DMA Streamx number of data to transfer register */
;;;354      hdma->Instance->NDTR = 0U;
;;;355    
;;;356      /* Reset DMA Streamx peripheral address register */
;;;357      hdma->Instance->PAR  = 0U;
;;;358    
;;;359      /* Reset DMA Streamx memory 0 address register */
;;;360      hdma->Instance->M0AR = 0U;
;;;361      
;;;362      /* Reset DMA Streamx memory 1 address register */
;;;363      hdma->Instance->M1AR = 0U;
;;;364      
;;;365      /* Reset DMA Streamx FIFO control register */
;;;366      hdma->Instance->FCR  = (uint32_t)0x00000021U;
;;;367      
;;;368      /* Get DMA steam Base Address */  
;;;369      regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
;;;370      
;;;371      /* Clear all interrupt flags at correct offset within the register */
;;;372      regs->IFCR = 0x3FU << hdma->StreamIndex;
;;;373      
;;;374      /* Clean all callbacks */
;;;375      hdma->XferCpltCallback = NULL;
;;;376      hdma->XferHalfCpltCallback = NULL;
;;;377      hdma->XferM1CpltCallback = NULL;
;;;378      hdma->XferM1HalfCpltCallback = NULL;
;;;379      hdma->XferErrorCallback = NULL;
;;;380      hdma->XferAbortCallback = NULL;  
;;;381    
;;;382      /* Reset the error code */
;;;383      hdma->ErrorCode = HAL_DMA_ERROR_NONE;
;;;384    
;;;385      /* Reset the DMA state */
;;;386      hdma->State = HAL_DMA_STATE_RESET;
;;;387    
;;;388      /* Release Lock */
;;;389      __HAL_UNLOCK(hdma);
;;;390    
;;;391      return HAL_OK;
;;;392    }
000008  bd70              POP      {r4-r6,pc}
                  |L6.10|
00000a  6ba0              LDR      r0,[r4,#0x38]         ;338
00000c  2802              CMP      r0,#2                 ;338
00000e  d100              BNE      |L6.18|
000010  e7fa              B        |L6.8|
                  |L6.18|
000012  6820              LDR      r0,[r4,#0]            ;348
000014  6800              LDR      r0,[r0,#0]            ;348
000016  f0200001          BIC      r0,r0,#1              ;348
00001a  6821              LDR      r1,[r4,#0]            ;348
00001c  6008              STR      r0,[r1,#0]            ;348
00001e  2000              MOVS     r0,#0                 ;351
000020  6821              LDR      r1,[r4,#0]            ;351
000022  6008              STR      r0,[r1,#0]            ;351
000024  6821              LDR      r1,[r4,#0]            ;354
000026  6048              STR      r0,[r1,#4]            ;354
000028  6821              LDR      r1,[r4,#0]            ;357
00002a  6088              STR      r0,[r1,#8]            ;357
00002c  6821              LDR      r1,[r4,#0]            ;360
00002e  60c8              STR      r0,[r1,#0xc]          ;360
000030  6821              LDR      r1,[r4,#0]            ;363
000032  6108              STR      r0,[r1,#0x10]         ;363
000034  2021              MOVS     r0,#0x21              ;366
000036  6821              LDR      r1,[r4,#0]            ;366
000038  6148              STR      r0,[r1,#0x14]         ;366
00003a  4620              MOV      r0,r4                 ;369
00003c  f7fffffe          BL       DMA_CalcBaseAndBitshift
000040  4605              MOV      r5,r0                 ;369
000042  f8941060          LDRB     r1,[r4,#0x60]         ;372
000046  203f              MOVS     r0,#0x3f              ;372
000048  4088              LSLS     r0,r0,r1              ;372
00004a  60a8              STR      r0,[r5,#8]            ;372
00004c  2000              MOVS     r0,#0                 ;375
00004e  6420              STR      r0,[r4,#0x40]         ;375
000050  6460              STR      r0,[r4,#0x44]         ;376
000052  64a0              STR      r0,[r4,#0x48]         ;377
000054  64e0              STR      r0,[r4,#0x4c]         ;378
000056  6520              STR      r0,[r4,#0x50]         ;379
000058  6560              STR      r0,[r4,#0x54]         ;380
00005a  65a0              STR      r0,[r4,#0x58]         ;383
00005c  63a0              STR      r0,[r4,#0x38]         ;386
00005e  bf00              NOP                            ;389
000060  6360              STR      r0,[r4,#0x34]         ;389
000062  bf00              NOP                            ;389
000064  bf00              NOP                            ;391
000066  e7cf              B        |L6.8|
;;;393    
                          ENDP


                          AREA ||i.HAL_DMA_GetError||, CODE, READONLY, ALIGN=1

                  HAL_DMA_GetError PROC
;;;1141     */
;;;1142   uint32_t HAL_DMA_GetError(DMA_HandleTypeDef *hdma)
000000  4601              MOV      r1,r0
;;;1143   {
;;;1144     return hdma->ErrorCode;
000002  6d88              LDR      r0,[r1,#0x58]
;;;1145   }
000004  4770              BX       lr
;;;1146   
                          ENDP


                          AREA ||i.HAL_DMA_GetState||, CODE, READONLY, ALIGN=1

                  HAL_DMA_GetState PROC
;;;1130     */
;;;1131   HAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef *hdma)
000000  4601              MOV      r1,r0
;;;1132   {
;;;1133     return hdma->State;
000002  6b88              LDR      r0,[r1,#0x38]
;;;1134   }
000004  4770              BX       lr
;;;1135   
                          ENDP


                          AREA ||i.HAL_DMA_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_DMA_IRQHandler PROC
;;;764      */
;;;765    void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
000000  b5f8              PUSH     {r3-r7,lr}
;;;766    {
000002  4604              MOV      r4,r0
;;;767      uint32_t tmpisr;
;;;768      __IO uint32_t count = 0;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;769      uint32_t timeout = SystemCoreClock / 9600;
000008  4888              LDR      r0,|L9.556|
00000a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000c  f44f5116          MOV      r1,#0x2580
000010  fbb0f7f1          UDIV     r7,r0,r1
;;;770    
;;;771      /* calculate DMA base and stream number */
;;;772      DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
000014  6de5              LDR      r5,[r4,#0x5c]
;;;773    
;;;774      tmpisr = regs->ISR;
000016  682e              LDR      r6,[r5,#0]
;;;775    
;;;776      /* Transfer Error Interrupt management ***************************************/
;;;777      if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
000018  f8941060          LDRB     r1,[r4,#0x60]
00001c  2008              MOVS     r0,#8
00001e  4088              LSLS     r0,r0,r1
000020  4030              ANDS     r0,r0,r6
000022  b198              CBZ      r0,|L9.76|
;;;778      {
;;;779        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
000024  6820              LDR      r0,[r4,#0]
000026  6800              LDR      r0,[r0,#0]
000028  f0000004          AND      r0,r0,#4
00002c  b170              CBZ      r0,|L9.76|
;;;780        {
;;;781          /* Disable the transfer error interrupt */
;;;782          hdma->Instance->CR  &= ~(DMA_IT_TE);
00002e  6820              LDR      r0,[r4,#0]
000030  6800              LDR      r0,[r0,#0]
000032  f0200004          BIC      r0,r0,#4
000036  6821              LDR      r1,[r4,#0]
000038  6008              STR      r0,[r1,#0]
;;;783          
;;;784          /* Clear the transfer error flag */
;;;785          regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
00003a  f8941060          LDRB     r1,[r4,#0x60]
00003e  2008              MOVS     r0,#8
000040  4088              LSLS     r0,r0,r1
000042  60a8              STR      r0,[r5,#8]
;;;786          
;;;787          /* Update error code */
;;;788          hdma->ErrorCode |= HAL_DMA_ERROR_TE;
000044  6da0              LDR      r0,[r4,#0x58]
000046  f0400001          ORR      r0,r0,#1
00004a  65a0              STR      r0,[r4,#0x58]
                  |L9.76|
;;;789        }
;;;790      }
;;;791      /* FIFO Error Interrupt management ******************************************/
;;;792      if ((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
00004c  f8941060          LDRB     r1,[r4,#0x60]
000050  2001              MOVS     r0,#1
000052  4088              LSLS     r0,r0,r1
000054  4030              ANDS     r0,r0,r6
000056  b168              CBZ      r0,|L9.116|
;;;793      {
;;;794        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
000058  6820              LDR      r0,[r4,#0]
00005a  6940              LDR      r0,[r0,#0x14]
00005c  f0000080          AND      r0,r0,#0x80
000060  b140              CBZ      r0,|L9.116|
;;;795        {
;;;796          /* Clear the FIFO error flag */
;;;797          regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
000062  f8941060          LDRB     r1,[r4,#0x60]
000066  2001              MOVS     r0,#1
000068  4088              LSLS     r0,r0,r1
00006a  60a8              STR      r0,[r5,#8]
;;;798    
;;;799          /* Update error code */
;;;800          hdma->ErrorCode |= HAL_DMA_ERROR_FE;
00006c  6da0              LDR      r0,[r4,#0x58]
00006e  f0400002          ORR      r0,r0,#2
000072  65a0              STR      r0,[r4,#0x58]
                  |L9.116|
;;;801        }
;;;802      }
;;;803      /* Direct Mode Error Interrupt management ***********************************/
;;;804      if ((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
000074  f8941060          LDRB     r1,[r4,#0x60]
000078  2004              MOVS     r0,#4
00007a  4088              LSLS     r0,r0,r1
00007c  4030              ANDS     r0,r0,r6
00007e  b168              CBZ      r0,|L9.156|
;;;805      {
;;;806        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
000080  6820              LDR      r0,[r4,#0]
000082  6800              LDR      r0,[r0,#0]
000084  f0000002          AND      r0,r0,#2
000088  b140              CBZ      r0,|L9.156|
;;;807        {
;;;808          /* Clear the direct mode error flag */
;;;809          regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
00008a  f8941060          LDRB     r1,[r4,#0x60]
00008e  2004              MOVS     r0,#4
000090  4088              LSLS     r0,r0,r1
000092  60a8              STR      r0,[r5,#8]
;;;810    
;;;811          /* Update error code */
;;;812          hdma->ErrorCode |= HAL_DMA_ERROR_DME;
000094  6da0              LDR      r0,[r4,#0x58]
000096  f0400004          ORR      r0,r0,#4
00009a  65a0              STR      r0,[r4,#0x58]
                  |L9.156|
;;;813        }
;;;814      }
;;;815      /* Half Transfer Complete Interrupt management ******************************/
;;;816      if ((tmpisr & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)
00009c  f8941060          LDRB     r1,[r4,#0x60]
0000a0  2010              MOVS     r0,#0x10
0000a2  4088              LSLS     r0,r0,r1
0000a4  4030              ANDS     r0,r0,r6
0000a6  b378              CBZ      r0,|L9.264|
;;;817      {
;;;818        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
0000a8  6820              LDR      r0,[r4,#0]
0000aa  6800              LDR      r0,[r0,#0]
0000ac  f0000008          AND      r0,r0,#8
0000b0  b350              CBZ      r0,|L9.264|
;;;819        {
;;;820          /* Clear the half transfer complete flag */
;;;821          regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
0000b2  f8941060          LDRB     r1,[r4,#0x60]
0000b6  2010              MOVS     r0,#0x10
0000b8  4088              LSLS     r0,r0,r1
0000ba  60a8              STR      r0,[r5,#8]
;;;822          
;;;823          /* Multi_Buffering mode enabled */
;;;824          if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
0000bc  6820              LDR      r0,[r4,#0]
0000be  6800              LDR      r0,[r0,#0]
0000c0  f4002080          AND      r0,r0,#0x40000
0000c4  b180              CBZ      r0,|L9.232|
;;;825          {
;;;826            /* Current memory buffer used is Memory 0 */
;;;827            if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
0000c6  6820              LDR      r0,[r4,#0]
0000c8  6800              LDR      r0,[r0,#0]
0000ca  f4002000          AND      r0,r0,#0x80000
0000ce  b928              CBNZ     r0,|L9.220|
;;;828            {
;;;829              if(hdma->XferHalfCpltCallback != NULL)
0000d0  6c60              LDR      r0,[r4,#0x44]
0000d2  b1c8              CBZ      r0,|L9.264|
;;;830              {
;;;831                /* Half transfer callback */
;;;832                hdma->XferHalfCpltCallback(hdma);
0000d4  4620              MOV      r0,r4
0000d6  6c61              LDR      r1,[r4,#0x44]
0000d8  4788              BLX      r1
0000da  e015              B        |L9.264|
                  |L9.220|
;;;833              }
;;;834            }
;;;835            /* Current memory buffer used is Memory 1 */
;;;836            else
;;;837            {
;;;838              if(hdma->XferM1HalfCpltCallback != NULL)
0000dc  6ce0              LDR      r0,[r4,#0x4c]
0000de  b198              CBZ      r0,|L9.264|
;;;839              {
;;;840                /* Half transfer callback */
;;;841                hdma->XferM1HalfCpltCallback(hdma);
0000e0  4620              MOV      r0,r4
0000e2  6ce1              LDR      r1,[r4,#0x4c]
0000e4  4788              BLX      r1
0000e6  e00f              B        |L9.264|
                  |L9.232|
;;;842              }
;;;843            }
;;;844          }
;;;845          else
;;;846          {
;;;847            /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
;;;848            if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
0000e8  6820              LDR      r0,[r4,#0]
0000ea  6800              LDR      r0,[r0,#0]
0000ec  f4007080          AND      r0,r0,#0x100
0000f0  b928              CBNZ     r0,|L9.254|
;;;849            {
;;;850              /* Disable the half transfer interrupt */
;;;851              hdma->Instance->CR  &= ~(DMA_IT_HT);
0000f2  6820              LDR      r0,[r4,#0]
0000f4  6800              LDR      r0,[r0,#0]
0000f6  f0200008          BIC      r0,r0,#8
0000fa  6821              LDR      r1,[r4,#0]
0000fc  6008              STR      r0,[r1,#0]
                  |L9.254|
;;;852            }
;;;853            
;;;854            if(hdma->XferHalfCpltCallback != NULL)
0000fe  6c60              LDR      r0,[r4,#0x44]
000100  b110              CBZ      r0,|L9.264|
;;;855            {
;;;856              /* Half transfer callback */
;;;857              hdma->XferHalfCpltCallback(hdma);
000102  4620              MOV      r0,r4
000104  6c61              LDR      r1,[r4,#0x44]
000106  4788              BLX      r1
                  |L9.264|
;;;858            }
;;;859          }
;;;860        }
;;;861      }
;;;862      /* Transfer Complete Interrupt management ***********************************/
;;;863      if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
000108  f8941060          LDRB     r1,[r4,#0x60]
00010c  2020              MOVS     r0,#0x20
00010e  4088              LSLS     r0,r0,r1
000110  4030              ANDS     r0,r0,r6
000112  2800              CMP      r0,#0
000114  d060              BEQ      |L9.472|
;;;864      {
;;;865        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
000116  6820              LDR      r0,[r4,#0]
000118  6800              LDR      r0,[r0,#0]
00011a  f0000010          AND      r0,r0,#0x10
00011e  2800              CMP      r0,#0
000120  d05a              BEQ      |L9.472|
;;;866        {
;;;867          /* Clear the transfer complete flag */
;;;868          regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
000122  f8941060          LDRB     r1,[r4,#0x60]
000126  2020              MOVS     r0,#0x20
000128  4088              LSLS     r0,r0,r1
00012a  60a8              STR      r0,[r5,#8]
;;;869          
;;;870          if(HAL_DMA_STATE_ABORT == hdma->State)
00012c  6ba0              LDR      r0,[r4,#0x38]
00012e  2805              CMP      r0,#5
000130  d126              BNE      |L9.384|
;;;871          {
;;;872            /* Disable all the transfer interrupts */
;;;873            hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
000132  6820              LDR      r0,[r4,#0]
000134  6800              LDR      r0,[r0,#0]
000136  f0200016          BIC      r0,r0,#0x16
00013a  6821              LDR      r1,[r4,#0]
00013c  6008              STR      r0,[r1,#0]
;;;874            hdma->Instance->FCR &= ~(DMA_IT_FE);
00013e  6820              LDR      r0,[r4,#0]
000140  6940              LDR      r0,[r0,#0x14]
000142  f0200080          BIC      r0,r0,#0x80
000146  6821              LDR      r1,[r4,#0]
000148  6148              STR      r0,[r1,#0x14]
;;;875            
;;;876            if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
00014a  6c60              LDR      r0,[r4,#0x44]
00014c  b908              CBNZ     r0,|L9.338|
00014e  6ce0              LDR      r0,[r4,#0x4c]
000150  b128              CBZ      r0,|L9.350|
                  |L9.338|
;;;877            {
;;;878              hdma->Instance->CR  &= ~(DMA_IT_HT);
000152  6820              LDR      r0,[r4,#0]
000154  6800              LDR      r0,[r0,#0]
000156  f0200008          BIC      r0,r0,#8
00015a  6821              LDR      r1,[r4,#0]
00015c  6008              STR      r0,[r1,#0]
                  |L9.350|
;;;879            }
;;;880    
;;;881            /* Clear all interrupt flags at correct offset within the register */
;;;882            regs->IFCR = 0x3FU << hdma->StreamIndex;
00015e  f8941060          LDRB     r1,[r4,#0x60]
000162  203f              MOVS     r0,#0x3f
000164  4088              LSLS     r0,r0,r1
000166  60a8              STR      r0,[r5,#8]
;;;883    
;;;884            /* Process Unlocked */
;;;885            __HAL_UNLOCK(hdma);
000168  bf00              NOP      
00016a  2000              MOVS     r0,#0
00016c  6360              STR      r0,[r4,#0x34]
00016e  bf00              NOP      
;;;886    
;;;887            /* Change the DMA state */
;;;888            hdma->State = HAL_DMA_STATE_READY;
000170  2001              MOVS     r0,#1
000172  63a0              STR      r0,[r4,#0x38]
;;;889    
;;;890            if(hdma->XferAbortCallback != NULL)
000174  6d60              LDR      r0,[r4,#0x54]
000176  b110              CBZ      r0,|L9.382|
;;;891            {
;;;892              hdma->XferAbortCallback(hdma);
000178  4620              MOV      r0,r4
00017a  6d61              LDR      r1,[r4,#0x54]
00017c  4788              BLX      r1
                  |L9.382|
;;;893            }
;;;894            return;
;;;895          }
;;;896    
;;;897          if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
;;;898          {
;;;899            /* Current memory buffer used is Memory 0 */
;;;900            if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
;;;901            {
;;;902              if(hdma->XferM1CpltCallback != NULL)
;;;903              {
;;;904                /* Transfer complete Callback for memory1 */
;;;905                hdma->XferM1CpltCallback(hdma);
;;;906              }
;;;907            }
;;;908            /* Current memory buffer used is Memory 1 */
;;;909            else
;;;910            {
;;;911              if(hdma->XferCpltCallback != NULL)
;;;912              {
;;;913                /* Transfer complete Callback for memory0 */
;;;914                hdma->XferCpltCallback(hdma);
;;;915              }
;;;916            }
;;;917          }
;;;918          /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */
;;;919          else
;;;920          {
;;;921            if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
;;;922            {
;;;923              /* Disable the transfer complete interrupt */
;;;924              hdma->Instance->CR  &= ~(DMA_IT_TC);
;;;925    
;;;926              /* Process Unlocked */
;;;927              __HAL_UNLOCK(hdma);
;;;928    
;;;929              /* Change the DMA state */
;;;930              hdma->State = HAL_DMA_STATE_READY;
;;;931            }
;;;932    
;;;933            if(hdma->XferCpltCallback != NULL)
;;;934            {
;;;935              /* Transfer complete callback */
;;;936              hdma->XferCpltCallback(hdma);
;;;937            }
;;;938          }
;;;939        }
;;;940      }
;;;941      
;;;942      /* manage error case */
;;;943      if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
;;;944      {
;;;945        if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
;;;946        {
;;;947          hdma->State = HAL_DMA_STATE_ABORT;
;;;948    
;;;949          /* Disable the stream */
;;;950          __HAL_DMA_DISABLE(hdma);
;;;951    
;;;952          do
;;;953          {
;;;954            if (++count > timeout)
;;;955            {
;;;956              break;
;;;957            }
;;;958          }
;;;959          while((hdma->Instance->CR & DMA_SxCR_EN) != RESET);
;;;960    
;;;961          /* Process Unlocked */
;;;962          __HAL_UNLOCK(hdma);
;;;963    
;;;964          /* Change the DMA state */
;;;965          hdma->State = HAL_DMA_STATE_READY;
;;;966        }
;;;967    
;;;968        if(hdma->XferErrorCallback != NULL)
;;;969        {
;;;970          /* Transfer error callback */
;;;971          hdma->XferErrorCallback(hdma);
;;;972        }
;;;973      }
;;;974    }
00017e  bdf8              POP      {r3-r7,pc}
                  |L9.384|
000180  6820              LDR      r0,[r4,#0]            ;897
000182  6800              LDR      r0,[r0,#0]            ;897
000184  f4002080          AND      r0,r0,#0x40000        ;897
000188  b180              CBZ      r0,|L9.428|
00018a  6820              LDR      r0,[r4,#0]            ;900
00018c  6800              LDR      r0,[r0,#0]            ;900
00018e  f4002000          AND      r0,r0,#0x80000        ;900
000192  b928              CBNZ     r0,|L9.416|
000194  6ca0              LDR      r0,[r4,#0x48]         ;902
000196  b110              CBZ      r0,|L9.414|
000198  4620              MOV      r0,r4                 ;905
00019a  6ca1              LDR      r1,[r4,#0x48]         ;905
00019c  4788              BLX      r1                    ;905
                  |L9.414|
00019e  e01b              B        |L9.472|
                  |L9.416|
0001a0  6c20              LDR      r0,[r4,#0x40]         ;911
0001a2  b1c8              CBZ      r0,|L9.472|
0001a4  4620              MOV      r0,r4                 ;914
0001a6  6c21              LDR      r1,[r4,#0x40]         ;914
0001a8  4788              BLX      r1                    ;914
0001aa  e015              B        |L9.472|
                  |L9.428|
0001ac  6820              LDR      r0,[r4,#0]            ;921
0001ae  6800              LDR      r0,[r0,#0]            ;921
0001b0  f4007080          AND      r0,r0,#0x100          ;921
0001b4  b958              CBNZ     r0,|L9.462|
0001b6  6820              LDR      r0,[r4,#0]            ;924
0001b8  6800              LDR      r0,[r0,#0]            ;924
0001ba  f0200010          BIC      r0,r0,#0x10           ;924
0001be  6821              LDR      r1,[r4,#0]            ;924
0001c0  6008              STR      r0,[r1,#0]            ;924
0001c2  bf00              NOP                            ;927
0001c4  2000              MOVS     r0,#0                 ;927
0001c6  6360              STR      r0,[r4,#0x34]         ;927
0001c8  bf00              NOP                            ;927
0001ca  2001              MOVS     r0,#1                 ;930
0001cc  63a0              STR      r0,[r4,#0x38]         ;930
                  |L9.462|
0001ce  6c20              LDR      r0,[r4,#0x40]         ;933
0001d0  b110              CBZ      r0,|L9.472|
0001d2  4620              MOV      r0,r4                 ;936
0001d4  6c21              LDR      r1,[r4,#0x40]         ;936
0001d6  4788              BLX      r1                    ;936
                  |L9.472|
0001d8  6da0              LDR      r0,[r4,#0x58]         ;943
0001da  b320              CBZ      r0,|L9.550|
0001dc  6da0              LDR      r0,[r4,#0x58]         ;945
0001de  f0000001          AND      r0,r0,#1              ;945
0001e2  b1d8              CBZ      r0,|L9.540|
0001e4  2005              MOVS     r0,#5                 ;947
0001e6  63a0              STR      r0,[r4,#0x38]         ;947
0001e8  6820              LDR      r0,[r4,#0]            ;950
0001ea  6800              LDR      r0,[r0,#0]            ;950
0001ec  f0200001          BIC      r0,r0,#1              ;950
0001f0  6821              LDR      r1,[r4,#0]            ;950
0001f2  6008              STR      r0,[r1,#0]            ;950
0001f4  bf00              NOP                            ;952
                  |L9.502|
0001f6  9800              LDR      r0,[sp,#0]            ;954
0001f8  1c40              ADDS     r0,r0,#1              ;954
0001fa  9000              STR      r0,[sp,#0]            ;954
0001fc  42b8              CMP      r0,r7                 ;954
0001fe  d900              BLS      |L9.514|
000200  e005              B        |L9.526|
                  |L9.514|
000202  6820              LDR      r0,[r4,#0]            ;959
000204  6800              LDR      r0,[r0,#0]            ;959
000206  f0000001          AND      r0,r0,#1              ;959
00020a  2800              CMP      r0,#0                 ;959
00020c  d1f3              BNE      |L9.502|
                  |L9.526|
00020e  bf00              NOP                            ;956
000210  bf00              NOP                            ;962
000212  2000              MOVS     r0,#0                 ;962
000214  6360              STR      r0,[r4,#0x34]         ;962
000216  bf00              NOP                            ;962
000218  2001              MOVS     r0,#1                 ;965
00021a  63a0              STR      r0,[r4,#0x38]         ;965
                  |L9.540|
00021c  6d20              LDR      r0,[r4,#0x50]         ;968
00021e  b110              CBZ      r0,|L9.550|
000220  4620              MOV      r0,r4                 ;971
000222  6d21              LDR      r1,[r4,#0x50]         ;971
000224  4788              BLX      r1                    ;971
                  |L9.550|
000226  bf00              NOP      
000228  e7a9              B        |L9.382|
;;;975    
                          ENDP

00022a  0000              DCW      0x0000
                  |L9.556|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_DMA_Init||, CODE, READONLY, ALIGN=2

                  HAL_DMA_Init PROC
;;;187      */
;;;188    HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;189    {
000004  4604              MOV      r4,r0
;;;190      uint32_t tmp = 0U;
000006  2500              MOVS     r5,#0
;;;191      uint32_t tickstart = HAL_GetTick();
000008  f7fffffe          BL       HAL_GetTick
00000c  4607              MOV      r7,r0
;;;192      DMA_Base_Registers *regs;
;;;193    
;;;194      /* Check the DMA peripheral state */
;;;195      if(hdma == NULL)
00000e  b914              CBNZ     r4,|L10.22|
;;;196      {
;;;197        return HAL_ERROR;
000010  2001              MOVS     r0,#1
                  |L10.18|
;;;198      }
;;;199    
;;;200      /* Check the parameters */
;;;201      assert_param(IS_DMA_STREAM_ALL_INSTANCE(hdma->Instance));
;;;202      assert_param(IS_DMA_CHANNEL(hdma->Init.Channel));
;;;203      assert_param(IS_DMA_DIRECTION(hdma->Init.Direction));
;;;204      assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));
;;;205      assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));
;;;206      assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
;;;207      assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
;;;208      assert_param(IS_DMA_MODE(hdma->Init.Mode));
;;;209      assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
;;;210      assert_param(IS_DMA_FIFO_MODE_STATE(hdma->Init.FIFOMode));
;;;211      /* Check the memory burst, peripheral burst and FIFO threshold parameters only
;;;212         when FIFO mode is enabled */
;;;213      if(hdma->Init.FIFOMode != DMA_FIFOMODE_DISABLE)
;;;214      {
;;;215        assert_param(IS_DMA_FIFO_THRESHOLD(hdma->Init.FIFOThreshold));
;;;216        assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
;;;217        assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
;;;218      }
;;;219      
;;;220      /* Allocate lock resource */
;;;221      __HAL_UNLOCK(hdma);
;;;222    
;;;223      /* Change DMA peripheral state */
;;;224      hdma->State = HAL_DMA_STATE_BUSY;
;;;225      
;;;226      /* Disable the peripheral */
;;;227      __HAL_DMA_DISABLE(hdma);
;;;228      
;;;229      /* Check if the DMA Stream is effectively disabled */
;;;230      while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
;;;231      {
;;;232        /* Check for the Timeout */
;;;233        if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
;;;234        {
;;;235          /* Update error code */
;;;236          hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
;;;237          
;;;238          /* Change the DMA state */
;;;239          hdma->State = HAL_DMA_STATE_TIMEOUT;
;;;240          
;;;241          return HAL_TIMEOUT;
;;;242        }
;;;243      }
;;;244      
;;;245      /* Get the CR register value */
;;;246      tmp = hdma->Instance->CR;
;;;247    
;;;248      /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */
;;;249      tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
;;;250                          DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
;;;251                          DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
;;;252                          DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));
;;;253    
;;;254      /* Prepare the DMA Stream configuration */
;;;255      tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
;;;256              hdma->Init.PeriphInc           | hdma->Init.MemInc           |
;;;257              hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
;;;258              hdma->Init.Mode                | hdma->Init.Priority;
;;;259    
;;;260      /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
;;;261      if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
;;;262      {
;;;263        /* Get memory burst and peripheral burst */
;;;264        tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
;;;265      }
;;;266      
;;;267      /* Write to DMA Stream CR register */
;;;268      hdma->Instance->CR = tmp;  
;;;269    
;;;270      /* Get the FCR register value */
;;;271      tmp = hdma->Instance->FCR;
;;;272    
;;;273      /* Clear Direct mode and FIFO threshold bits */
;;;274      tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
;;;275    
;;;276      /* Prepare the DMA Stream FIFO configuration */
;;;277      tmp |= hdma->Init.FIFOMode;
;;;278    
;;;279      /* The FIFO threshold is not used when the FIFO mode is disabled */
;;;280      if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
;;;281      {
;;;282        /* Get the FIFO threshold */
;;;283        tmp |= hdma->Init.FIFOThreshold;
;;;284        
;;;285        /* Check compatibility between FIFO threshold level and size of the memory burst */
;;;286        /* for INCR4, INCR8, INCR16 bursts */
;;;287        if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
;;;288        {
;;;289          if (DMA_CheckFifoParam(hdma) != HAL_OK)
;;;290          {
;;;291            /* Update error code */
;;;292            hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
;;;293            
;;;294            /* Change the DMA state */
;;;295            hdma->State = HAL_DMA_STATE_READY;
;;;296            
;;;297            return HAL_ERROR; 
;;;298          }
;;;299        }
;;;300      }
;;;301      
;;;302      /* Write to DMA Stream FCR */
;;;303      hdma->Instance->FCR = tmp;
;;;304    
;;;305      /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
;;;306         DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
;;;307      regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
;;;308      
;;;309      /* Clear all interrupt flags */
;;;310      regs->IFCR = 0x3FU << hdma->StreamIndex;
;;;311    
;;;312      /* Initialize the error code */
;;;313      hdma->ErrorCode = HAL_DMA_ERROR_NONE;
;;;314                                                                                         
;;;315      /* Initialize the DMA state */
;;;316      hdma->State = HAL_DMA_STATE_READY;
;;;317    
;;;318      return HAL_OK;
;;;319    }
000012  e8bd81f0          POP      {r4-r8,pc}
                  |L10.22|
000016  6a60              LDR      r0,[r4,#0x24]         ;213
000018  b100              CBZ      r0,|L10.28|
00001a  bf00              NOP                            ;217
                  |L10.28|
00001c  bf00              NOP                            ;221
00001e  2000              MOVS     r0,#0                 ;221
000020  6360              STR      r0,[r4,#0x34]         ;221
000022  bf00              NOP                            ;221
000024  2002              MOVS     r0,#2                 ;224
000026  63a0              STR      r0,[r4,#0x38]         ;224
000028  6820              LDR      r0,[r4,#0]            ;227
00002a  6800              LDR      r0,[r0,#0]            ;227
00002c  f0200001          BIC      r0,r0,#1              ;227
000030  6821              LDR      r1,[r4,#0]            ;227
000032  6008              STR      r0,[r1,#0]            ;227
000034  e009              B        |L10.74|
                  |L10.54|
000036  f7fffffe          BL       HAL_GetTick
00003a  1bc0              SUBS     r0,r0,r7              ;233
00003c  2805              CMP      r0,#5                 ;233
00003e  d904              BLS      |L10.74|
000040  2020              MOVS     r0,#0x20              ;236
000042  65a0              STR      r0,[r4,#0x58]         ;236
000044  2003              MOVS     r0,#3                 ;239
000046  63a0              STR      r0,[r4,#0x38]         ;239
000048  e7e3              B        |L10.18|
                  |L10.74|
00004a  6820              LDR      r0,[r4,#0]            ;230
00004c  6800              LDR      r0,[r0,#0]            ;230
00004e  f0000001          AND      r0,r0,#1              ;230
000052  2800              CMP      r0,#0                 ;230
000054  d1ef              BNE      |L10.54|
000056  6820              LDR      r0,[r4,#0]            ;246
000058  6805              LDR      r5,[r0,#0]            ;246
00005a  4821              LDR      r0,|L10.224|
00005c  4005              ANDS     r5,r5,r0              ;249
00005e  e9d40101          LDRD     r0,r1,[r4,#4]         ;255
000062  4308              ORRS     r0,r0,r1              ;255
000064  68e1              LDR      r1,[r4,#0xc]          ;255
000066  4308              ORRS     r0,r0,r1              ;255
000068  6921              LDR      r1,[r4,#0x10]         ;255
00006a  4308              ORRS     r0,r0,r1              ;255
00006c  6961              LDR      r1,[r4,#0x14]         ;255
00006e  4308              ORRS     r0,r0,r1              ;255
000070  69a1              LDR      r1,[r4,#0x18]         ;255
000072  4308              ORRS     r0,r0,r1              ;255
000074  69e1              LDR      r1,[r4,#0x1c]         ;255
000076  4308              ORRS     r0,r0,r1              ;255
000078  6a21              LDR      r1,[r4,#0x20]         ;255
00007a  4308              ORRS     r0,r0,r1              ;255
00007c  4305              ORRS     r5,r5,r0              ;255
00007e  6a60              LDR      r0,[r4,#0x24]         ;261
000080  2804              CMP      r0,#4                 ;261
000082  d103              BNE      |L10.140|
000084  e9d4010b          LDRD     r0,r1,[r4,#0x2c]      ;264
000088  4308              ORRS     r0,r0,r1              ;264
00008a  4305              ORRS     r5,r5,r0              ;264
                  |L10.140|
00008c  6820              LDR      r0,[r4,#0]            ;268
00008e  6005              STR      r5,[r0,#0]            ;268
000090  6820              LDR      r0,[r4,#0]            ;271
000092  6945              LDR      r5,[r0,#0x14]         ;271
000094  f0250507          BIC      r5,r5,#7              ;274
000098  6a60              LDR      r0,[r4,#0x24]         ;277
00009a  4305              ORRS     r5,r5,r0              ;277
00009c  6a60              LDR      r0,[r4,#0x24]         ;280
00009e  2804              CMP      r0,#4                 ;280
0000a0  d10c              BNE      |L10.188|
0000a2  6aa0              LDR      r0,[r4,#0x28]         ;283
0000a4  4305              ORRS     r5,r5,r0              ;283
0000a6  6ae0              LDR      r0,[r4,#0x2c]         ;287
0000a8  b140              CBZ      r0,|L10.188|
0000aa  4620              MOV      r0,r4                 ;289
0000ac  f7fffffe          BL       DMA_CheckFifoParam
0000b0  b120              CBZ      r0,|L10.188|
0000b2  2040              MOVS     r0,#0x40              ;292
0000b4  65a0              STR      r0,[r4,#0x58]         ;292
0000b6  2001              MOVS     r0,#1                 ;295
0000b8  63a0              STR      r0,[r4,#0x38]         ;295
0000ba  e7aa              B        |L10.18|
                  |L10.188|
0000bc  6820              LDR      r0,[r4,#0]            ;303
0000be  6145              STR      r5,[r0,#0x14]         ;303
0000c0  4620              MOV      r0,r4                 ;307
0000c2  f7fffffe          BL       DMA_CalcBaseAndBitshift
0000c6  4606              MOV      r6,r0                 ;307
0000c8  f8941060          LDRB     r1,[r4,#0x60]         ;310
0000cc  203f              MOVS     r0,#0x3f              ;310
0000ce  4088              LSLS     r0,r0,r1              ;310
0000d0  60b0              STR      r0,[r6,#8]            ;310
0000d2  2000              MOVS     r0,#0                 ;313
0000d4  65a0              STR      r0,[r4,#0x58]         ;313
0000d6  2001              MOVS     r0,#1                 ;316
0000d8  63a0              STR      r0,[r4,#0x38]         ;316
0000da  2000              MOVS     r0,#0                 ;318
0000dc  e799              B        |L10.18|
;;;320    
                          ENDP

0000de  0000              DCW      0x0000
                  |L10.224|
                          DCD      0xe010803f

                          AREA ||i.HAL_DMA_PollForTransfer||, CODE, READONLY, ALIGN=1

                  HAL_DMA_PollForTransfer PROC
;;;628      */
;;;629    HAL_StatusTypeDef HAL_DMA_PollForTransfer(DMA_HandleTypeDef *hdma, HAL_DMA_LevelCompleteTypeDef CompleteLevel, uint32_t Timeout)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;630    {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4617              MOV      r7,r2
;;;631      HAL_StatusTypeDef status = HAL_OK; 
00000a  f04f0a00          MOV      r10,#0
;;;632      uint32_t mask_cpltlevel;
;;;633      uint32_t tickstart = HAL_GetTick(); 
00000e  f7fffffe          BL       HAL_GetTick
000012  4683              MOV      r11,r0
;;;634      uint32_t tmpisr;
;;;635      
;;;636      /* calculate DMA base and stream number */
;;;637      DMA_Base_Registers *regs;
;;;638    
;;;639      if(HAL_DMA_STATE_BUSY != hdma->State)
000014  6ba0              LDR      r0,[r4,#0x38]
000016  2802              CMP      r0,#2
000018  d008              BEQ      |L11.44|
;;;640      {
;;;641        /* No transfer ongoing */
;;;642        hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
00001a  2080              MOVS     r0,#0x80
00001c  65a0              STR      r0,[r4,#0x58]
;;;643        __HAL_UNLOCK(hdma);
00001e  bf00              NOP      
000020  2000              MOVS     r0,#0
000022  6360              STR      r0,[r4,#0x34]
000024  bf00              NOP      
;;;644        return HAL_ERROR;
000026  2001              MOVS     r0,#1
                  |L11.40|
;;;645      }
;;;646    
;;;647      /* Polling mode not supported in circular mode and double buffering mode */
;;;648      if ((hdma->Instance->CR & DMA_SxCR_CIRC) != RESET)
;;;649      {
;;;650        hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
;;;651        return HAL_ERROR;
;;;652      }
;;;653      
;;;654      /* Get the level transfer complete flag */
;;;655      if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
;;;656      {
;;;657        /* Transfer Complete flag */
;;;658        mask_cpltlevel = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
;;;659      }
;;;660      else
;;;661      {
;;;662        /* Half Transfer Complete flag */
;;;663        mask_cpltlevel = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
;;;664      }
;;;665      
;;;666      regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
;;;667      tmpisr = regs->ISR;
;;;668      
;;;669      while(((tmpisr & mask_cpltlevel) == RESET) && ((hdma->ErrorCode & HAL_DMA_ERROR_TE) == RESET))
;;;670      {
;;;671        /* Check for the Timeout (Not applicable in circular mode)*/
;;;672        if(Timeout != HAL_MAX_DELAY)
;;;673        {
;;;674          if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
;;;675          {
;;;676            /* Update error code */
;;;677            hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
;;;678    
;;;679            /* Process Unlocked */
;;;680            __HAL_UNLOCK(hdma);
;;;681            
;;;682            /* Change the DMA state */
;;;683            hdma->State = HAL_DMA_STATE_READY;
;;;684            
;;;685            return HAL_TIMEOUT;
;;;686          }
;;;687        }
;;;688    
;;;689        /* Get the ISR register value */
;;;690        tmpisr = regs->ISR;
;;;691    
;;;692        if((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
;;;693        {
;;;694          /* Update error code */
;;;695          hdma->ErrorCode |= HAL_DMA_ERROR_TE;
;;;696          
;;;697          /* Clear the transfer error flag */
;;;698          regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
;;;699        }
;;;700        
;;;701        if((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
;;;702        {
;;;703          /* Update error code */
;;;704          hdma->ErrorCode |= HAL_DMA_ERROR_FE;
;;;705          
;;;706          /* Clear the FIFO error flag */
;;;707          regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
;;;708        }
;;;709        
;;;710        if((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
;;;711        {
;;;712          /* Update error code */
;;;713          hdma->ErrorCode |= HAL_DMA_ERROR_DME;
;;;714          
;;;715          /* Clear the Direct Mode error flag */
;;;716          regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
;;;717        }
;;;718      }
;;;719      
;;;720      if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
;;;721      {
;;;722        if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
;;;723        {
;;;724          HAL_DMA_Abort(hdma);
;;;725        
;;;726          /* Clear the half transfer and transfer complete flags */
;;;727          regs->IFCR = (DMA_FLAG_HTIF0_4 | DMA_FLAG_TCIF0_4) << hdma->StreamIndex;
;;;728        
;;;729          /* Process Unlocked */
;;;730          __HAL_UNLOCK(hdma);
;;;731    
;;;732          /* Change the DMA state */
;;;733          hdma->State= HAL_DMA_STATE_READY;
;;;734    
;;;735          return HAL_ERROR;
;;;736       }
;;;737      }
;;;738      
;;;739      /* Get the level transfer complete flag */
;;;740      if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
;;;741      {
;;;742        /* Clear the half transfer and transfer complete flags */
;;;743        regs->IFCR = (DMA_FLAG_HTIF0_4 | DMA_FLAG_TCIF0_4) << hdma->StreamIndex;
;;;744        
;;;745        /* Process Unlocked */
;;;746        __HAL_UNLOCK(hdma);
;;;747    
;;;748        hdma->State = HAL_DMA_STATE_READY;
;;;749      }
;;;750      else
;;;751      {
;;;752        /* Clear the half transfer flag */
;;;753        regs->IFCR = (DMA_FLAG_HTIF0_4) << hdma->StreamIndex;
;;;754      }
;;;755      
;;;756      return status;
;;;757    }
000028  e8bd9ff0          POP      {r4-r12,pc}
                  |L11.44|
00002c  6820              LDR      r0,[r4,#0]            ;648
00002e  6800              LDR      r0,[r0,#0]            ;648
000030  f4007080          AND      r0,r0,#0x100          ;648
000034  b120              CBZ      r0,|L11.64|
000036  f44f7080          MOV      r0,#0x100             ;650
00003a  65a0              STR      r0,[r4,#0x58]         ;650
00003c  2001              MOVS     r0,#1                 ;651
00003e  e7f3              B        |L11.40|
                  |L11.64|
000040  f1b80f00          CMP      r8,#0                 ;655
000044  d105              BNE      |L11.82|
000046  f8941060          LDRB     r1,[r4,#0x60]         ;658
00004a  2020              MOVS     r0,#0x20              ;658
00004c  fa00f901          LSL      r9,r0,r1              ;658
000050  e004              B        |L11.92|
                  |L11.82|
000052  f8941060          LDRB     r1,[r4,#0x60]         ;663
000056  2010              MOVS     r0,#0x10              ;663
000058  fa00f901          LSL      r9,r0,r1              ;663
                  |L11.92|
00005c  6de5              LDR      r5,[r4,#0x5c]         ;666
00005e  682e              LDR      r6,[r5,#0]            ;667
000060  e040              B        |L11.228|
                  |L11.98|
000062  1c78              ADDS     r0,r7,#1              ;672
000064  b180              CBZ      r0,|L11.136|
000066  b12f              CBZ      r7,|L11.116|
000068  f7fffffe          BL       HAL_GetTick
00006c  eba0000b          SUB      r0,r0,r11             ;674
000070  42b8              CMP      r0,r7                 ;674
000072  d909              BLS      |L11.136|
                  |L11.116|
000074  2020              MOVS     r0,#0x20              ;677
000076  65a0              STR      r0,[r4,#0x58]         ;677
000078  bf00              NOP                            ;680
00007a  2000              MOVS     r0,#0                 ;680
00007c  6360              STR      r0,[r4,#0x34]         ;680
00007e  bf00              NOP                            ;680
000080  2001              MOVS     r0,#1                 ;683
000082  63a0              STR      r0,[r4,#0x38]         ;683
000084  2003              MOVS     r0,#3                 ;685
000086  e7cf              B        |L11.40|
                  |L11.136|
000088  682e              LDR      r6,[r5,#0]            ;690
00008a  f8941060          LDRB     r1,[r4,#0x60]         ;692
00008e  2008              MOVS     r0,#8                 ;692
000090  4088              LSLS     r0,r0,r1              ;692
000092  4030              ANDS     r0,r0,r6              ;692
000094  b140              CBZ      r0,|L11.168|
000096  6da0              LDR      r0,[r4,#0x58]         ;695
000098  f0400001          ORR      r0,r0,#1              ;695
00009c  65a0              STR      r0,[r4,#0x58]         ;695
00009e  f8941060          LDRB     r1,[r4,#0x60]         ;698
0000a2  2008              MOVS     r0,#8                 ;698
0000a4  4088              LSLS     r0,r0,r1              ;698
0000a6  60a8              STR      r0,[r5,#8]            ;698
                  |L11.168|
0000a8  f8941060          LDRB     r1,[r4,#0x60]         ;701
0000ac  2001              MOVS     r0,#1                 ;701
0000ae  4088              LSLS     r0,r0,r1              ;701
0000b0  4030              ANDS     r0,r0,r6              ;701
0000b2  b140              CBZ      r0,|L11.198|
0000b4  6da0              LDR      r0,[r4,#0x58]         ;704
0000b6  f0400002          ORR      r0,r0,#2              ;704
0000ba  65a0              STR      r0,[r4,#0x58]         ;704
0000bc  f8941060          LDRB     r1,[r4,#0x60]         ;707
0000c0  2001              MOVS     r0,#1                 ;707
0000c2  4088              LSLS     r0,r0,r1              ;707
0000c4  60a8              STR      r0,[r5,#8]            ;707
                  |L11.198|
0000c6  f8941060          LDRB     r1,[r4,#0x60]         ;710
0000ca  2004              MOVS     r0,#4                 ;710
0000cc  4088              LSLS     r0,r0,r1              ;710
0000ce  4030              ANDS     r0,r0,r6              ;710
0000d0  b140              CBZ      r0,|L11.228|
0000d2  6da0              LDR      r0,[r4,#0x58]         ;713
0000d4  f0400004          ORR      r0,r0,#4              ;713
0000d8  65a0              STR      r0,[r4,#0x58]         ;713
0000da  f8941060          LDRB     r1,[r4,#0x60]         ;716
0000de  2004              MOVS     r0,#4                 ;716
0000e0  4088              LSLS     r0,r0,r1              ;716
0000e2  60a8              STR      r0,[r5,#8]            ;716
                  |L11.228|
0000e4  ea060009          AND      r0,r6,r9              ;669
0000e8  b920              CBNZ     r0,|L11.244|
0000ea  6da0              LDR      r0,[r4,#0x58]         ;669
0000ec  f0000001          AND      r0,r0,#1              ;669
0000f0  2800              CMP      r0,#0                 ;669
0000f2  d0b6              BEQ      |L11.98|
                  |L11.244|
0000f4  6da0              LDR      r0,[r4,#0x58]         ;720
0000f6  b190              CBZ      r0,|L11.286|
0000f8  6da0              LDR      r0,[r4,#0x58]         ;722
0000fa  f0000001          AND      r0,r0,#1              ;722
0000fe  b170              CBZ      r0,|L11.286|
000100  4620              MOV      r0,r4                 ;724
000102  f7fffffe          BL       HAL_DMA_Abort
000106  f8941060          LDRB     r1,[r4,#0x60]         ;727
00010a  2030              MOVS     r0,#0x30              ;727
00010c  4088              LSLS     r0,r0,r1              ;727
00010e  60a8              STR      r0,[r5,#8]            ;727
000110  bf00              NOP                            ;730
000112  2000              MOVS     r0,#0                 ;730
000114  6360              STR      r0,[r4,#0x34]         ;730
000116  bf00              NOP                            ;730
000118  2001              MOVS     r0,#1                 ;733
00011a  63a0              STR      r0,[r4,#0x38]         ;733
00011c  e784              B        |L11.40|
                  |L11.286|
00011e  f1b80f00          CMP      r8,#0                 ;740
000122  d10b              BNE      |L11.316|
000124  f8941060          LDRB     r1,[r4,#0x60]         ;743
000128  2030              MOVS     r0,#0x30              ;743
00012a  4088              LSLS     r0,r0,r1              ;743
00012c  60a8              STR      r0,[r5,#8]            ;743
00012e  bf00              NOP                            ;746
000130  2000              MOVS     r0,#0                 ;746
000132  6360              STR      r0,[r4,#0x34]         ;746
000134  bf00              NOP                            ;746
000136  2001              MOVS     r0,#1                 ;748
000138  63a0              STR      r0,[r4,#0x38]         ;748
00013a  e004              B        |L11.326|
                  |L11.316|
00013c  f8941060          LDRB     r1,[r4,#0x60]         ;753
000140  2010              MOVS     r0,#0x10              ;753
000142  4088              LSLS     r0,r0,r1              ;753
000144  60a8              STR      r0,[r5,#8]            ;753
                  |L11.326|
000146  4650              MOV      r0,r10                ;756
000148  e76e              B        |L11.40|
;;;758    
                          ENDP


                          AREA ||i.HAL_DMA_RegisterCallback||, CODE, READONLY, ALIGN=1

                  HAL_DMA_RegisterCallback PROC
;;;985      */                      
;;;986    HAL_StatusTypeDef HAL_DMA_RegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID, void (* pCallback)(DMA_HandleTypeDef *_hdma))
000000  b510              PUSH     {r4,lr}
;;;987    {
000002  4603              MOV      r3,r0
;;;988    
;;;989      HAL_StatusTypeDef status = HAL_OK;
000004  2400              MOVS     r4,#0
;;;990    
;;;991      /* Process locked */
;;;992      __HAL_LOCK(hdma);
000006  bf00              NOP      
000008  6b58              LDR      r0,[r3,#0x34]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L12.18|
00000e  2002              MOVS     r0,#2
                  |L12.16|
;;;993    
;;;994      if(HAL_DMA_STATE_READY == hdma->State)
;;;995      {
;;;996        switch (CallbackID)
;;;997        {
;;;998        case  HAL_DMA_XFER_CPLT_CB_ID:
;;;999          hdma->XferCpltCallback = pCallback;
;;;1000         break;
;;;1001   
;;;1002       case  HAL_DMA_XFER_HALFCPLT_CB_ID:
;;;1003         hdma->XferHalfCpltCallback = pCallback;
;;;1004         break;
;;;1005   
;;;1006       case  HAL_DMA_XFER_M1CPLT_CB_ID:
;;;1007         hdma->XferM1CpltCallback = pCallback;
;;;1008         break;
;;;1009   
;;;1010       case  HAL_DMA_XFER_M1HALFCPLT_CB_ID:
;;;1011         hdma->XferM1HalfCpltCallback = pCallback;
;;;1012         break;
;;;1013   
;;;1014       case  HAL_DMA_XFER_ERROR_CB_ID:
;;;1015         hdma->XferErrorCallback = pCallback;
;;;1016         break;
;;;1017   
;;;1018       case  HAL_DMA_XFER_ABORT_CB_ID:
;;;1019         hdma->XferAbortCallback = pCallback;
;;;1020         break;
;;;1021   
;;;1022       default:
;;;1023         break;
;;;1024       }
;;;1025     }
;;;1026     else
;;;1027     {
;;;1028       /* Return error status */
;;;1029       status =  HAL_ERROR;
;;;1030     }
;;;1031   
;;;1032     /* Release Lock */
;;;1033     __HAL_UNLOCK(hdma);
;;;1034     
;;;1035     return status;
;;;1036   }
000010  bd10              POP      {r4,pc}
                  |L12.18|
000012  2001              MOVS     r0,#1                 ;992
000014  6358              STR      r0,[r3,#0x34]         ;992
000016  bf00              NOP                            ;992
000018  6b98              LDR      r0,[r3,#0x38]         ;994
00001a  2801              CMP      r0,#1                 ;994
00001c  d114              BNE      |L12.72|
00001e  2906              CMP      r1,#6                 ;996
000020  d210              BCS      |L12.68|
000022  e8dff001          TBB      [pc,r1]               ;996
000026  0305              DCB      0x03,0x05
000028  07090b0d          DCB      0x07,0x09,0x0b,0x0d
00002c  641a              STR      r2,[r3,#0x40]         ;999
00002e  e00a              B        |L12.70|
000030  645a              STR      r2,[r3,#0x44]         ;1003
000032  e008              B        |L12.70|
000034  649a              STR      r2,[r3,#0x48]         ;1007
000036  e006              B        |L12.70|
000038  64da              STR      r2,[r3,#0x4c]         ;1011
00003a  e004              B        |L12.70|
00003c  651a              STR      r2,[r3,#0x50]         ;1015
00003e  e002              B        |L12.70|
000040  655a              STR      r2,[r3,#0x54]         ;1019
000042  e000              B        |L12.70|
                  |L12.68|
000044  bf00              NOP                            ;1023
                  |L12.70|
000046  e000              B        |L12.74|
                  |L12.72|
000048  2401              MOVS     r4,#1                 ;1029
                  |L12.74|
00004a  bf00              NOP                            ;1033
00004c  2000              MOVS     r0,#0                 ;1033
00004e  6358              STR      r0,[r3,#0x34]         ;1033
000050  bf00              NOP                            ;1033
000052  4620              MOV      r0,r4                 ;1035
000054  e7dc              B        |L12.16|
;;;1037   
                          ENDP


                          AREA ||i.HAL_DMA_Start||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Start PROC
;;;424      */
;;;425    HAL_StatusTypeDef HAL_DMA_Start(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;426    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;427      HAL_StatusTypeDef status = HAL_OK;
00000c  f04f0800          MOV      r8,#0
;;;428      
;;;429      /* Check the parameters */
;;;430      assert_param(IS_DMA_BUFFER_SIZE(DataLength));
;;;431    
;;;432      /* Process locked */
;;;433      __HAL_LOCK(hdma);
000010  bf00              NOP      
000012  6b60              LDR      r0,[r4,#0x34]
000014  2801              CMP      r0,#1
000016  d102              BNE      |L13.30|
000018  2002              MOVS     r0,#2
                  |L13.26|
;;;434    
;;;435      if(HAL_DMA_STATE_READY == hdma->State)
;;;436      {
;;;437        /* Change DMA peripheral state */
;;;438        hdma->State = HAL_DMA_STATE_BUSY;
;;;439        
;;;440        /* Initialize the error code */
;;;441        hdma->ErrorCode = HAL_DMA_ERROR_NONE;
;;;442        
;;;443        /* Configure the source, destination address and the data length */
;;;444        DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
;;;445    
;;;446        /* Enable the Peripheral */
;;;447        __HAL_DMA_ENABLE(hdma);
;;;448      }
;;;449      else
;;;450      {
;;;451        /* Process unlocked */
;;;452        __HAL_UNLOCK(hdma);
;;;453        
;;;454        /* Return error status */
;;;455        status = HAL_BUSY;
;;;456      } 
;;;457      return status; 
;;;458    }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L13.30|
00001e  2001              MOVS     r0,#1                 ;433
000020  6360              STR      r0,[r4,#0x34]         ;433
000022  bf00              NOP                            ;433
000024  6ba0              LDR      r0,[r4,#0x38]         ;435
000026  2801              CMP      r0,#1                 ;435
000028  d110              BNE      |L13.76|
00002a  2002              MOVS     r0,#2                 ;438
00002c  63a0              STR      r0,[r4,#0x38]         ;438
00002e  2000              MOVS     r0,#0                 ;441
000030  65a0              STR      r0,[r4,#0x58]         ;441
000032  463b              MOV      r3,r7                 ;444
000034  4632              MOV      r2,r6                 ;444
000036  4629              MOV      r1,r5                 ;444
000038  4620              MOV      r0,r4                 ;444
00003a  f7fffffe          BL       DMA_SetConfig
00003e  6820              LDR      r0,[r4,#0]            ;447
000040  6800              LDR      r0,[r0,#0]            ;447
000042  f0400001          ORR      r0,r0,#1              ;447
000046  6821              LDR      r1,[r4,#0]            ;447
000048  6008              STR      r0,[r1,#0]            ;447
00004a  e005              B        |L13.88|
                  |L13.76|
00004c  bf00              NOP                            ;452
00004e  2000              MOVS     r0,#0                 ;452
000050  6360              STR      r0,[r4,#0x34]         ;452
000052  bf00              NOP                            ;452
000054  f04f0802          MOV      r8,#2                 ;455
                  |L13.88|
000058  4640              MOV      r0,r8                 ;457
00005a  e7de              B        |L13.26|
;;;459    
                          ENDP


                          AREA ||i.HAL_DMA_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Start_IT PROC
;;;468      */
;;;469    HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;470    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;471      HAL_StatusTypeDef status = HAL_OK;
00000c  f04f0800          MOV      r8,#0
;;;472    
;;;473      /* calculate DMA base and stream number */
;;;474      DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
000010  f8d4905c          LDR      r9,[r4,#0x5c]
;;;475      
;;;476      /* Check the parameters */
;;;477      assert_param(IS_DMA_BUFFER_SIZE(DataLength));
;;;478     
;;;479      /* Process locked */
;;;480      __HAL_LOCK(hdma);
000014  bf00              NOP      
000016  6b60              LDR      r0,[r4,#0x34]
000018  2801              CMP      r0,#1
00001a  d102              BNE      |L14.34|
00001c  2002              MOVS     r0,#2
                  |L14.30|
;;;481      
;;;482      if(HAL_DMA_STATE_READY == hdma->State)
;;;483      {
;;;484        /* Change DMA peripheral state */
;;;485        hdma->State = HAL_DMA_STATE_BUSY;
;;;486        
;;;487        /* Initialize the error code */
;;;488        hdma->ErrorCode = HAL_DMA_ERROR_NONE;
;;;489        
;;;490        /* Configure the source, destination address and the data length */
;;;491        DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
;;;492        
;;;493        /* Clear all interrupt flags at correct offset within the register */
;;;494        regs->IFCR = 0x3FU << hdma->StreamIndex;
;;;495        
;;;496        /* Enable Common interrupts*/
;;;497        hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
;;;498        hdma->Instance->FCR |= DMA_IT_FE;
;;;499        
;;;500        if(hdma->XferHalfCpltCallback != NULL)
;;;501        {
;;;502          hdma->Instance->CR  |= DMA_IT_HT;
;;;503        }
;;;504        
;;;505        /* Enable the Peripheral */
;;;506        __HAL_DMA_ENABLE(hdma);
;;;507      }
;;;508      else
;;;509      {
;;;510        /* Process unlocked */
;;;511        __HAL_UNLOCK(hdma);	  
;;;512        
;;;513        /* Return error status */
;;;514        status = HAL_BUSY;
;;;515      }
;;;516      
;;;517      return status;
;;;518    }
00001e  e8bd87f0          POP      {r4-r10,pc}
                  |L14.34|
000022  2001              MOVS     r0,#1                 ;480
000024  6360              STR      r0,[r4,#0x34]         ;480
000026  bf00              NOP                            ;480
000028  6ba0              LDR      r0,[r4,#0x38]         ;482
00002a  2801              CMP      r0,#1                 ;482
00002c  d12a              BNE      |L14.132|
00002e  2002              MOVS     r0,#2                 ;485
000030  63a0              STR      r0,[r4,#0x38]         ;485
000032  2000              MOVS     r0,#0                 ;488
000034  65a0              STR      r0,[r4,#0x58]         ;488
000036  463b              MOV      r3,r7                 ;491
000038  4632              MOV      r2,r6                 ;491
00003a  4629              MOV      r1,r5                 ;491
00003c  4620              MOV      r0,r4                 ;491
00003e  f7fffffe          BL       DMA_SetConfig
000042  f8941060          LDRB     r1,[r4,#0x60]         ;494
000046  203f              MOVS     r0,#0x3f              ;494
000048  4088              LSLS     r0,r0,r1              ;494
00004a  f8c90008          STR      r0,[r9,#8]            ;494
00004e  6820              LDR      r0,[r4,#0]            ;497
000050  6800              LDR      r0,[r0,#0]            ;497
000052  f0400016          ORR      r0,r0,#0x16           ;497
000056  6821              LDR      r1,[r4,#0]            ;497
000058  6008              STR      r0,[r1,#0]            ;497
00005a  6820              LDR      r0,[r4,#0]            ;498
00005c  6940              LDR      r0,[r0,#0x14]         ;498
00005e  f0400080          ORR      r0,r0,#0x80           ;498
000062  6821              LDR      r1,[r4,#0]            ;498
000064  6148              STR      r0,[r1,#0x14]         ;498
000066  6c60              LDR      r0,[r4,#0x44]         ;500
000068  b128              CBZ      r0,|L14.118|
00006a  6820              LDR      r0,[r4,#0]            ;502
00006c  6800              LDR      r0,[r0,#0]            ;502
00006e  f0400008          ORR      r0,r0,#8              ;502
000072  6821              LDR      r1,[r4,#0]            ;502
000074  6008              STR      r0,[r1,#0]            ;502
                  |L14.118|
000076  6820              LDR      r0,[r4,#0]            ;506
000078  6800              LDR      r0,[r0,#0]            ;506
00007a  f0400001          ORR      r0,r0,#1              ;506
00007e  6821              LDR      r1,[r4,#0]            ;506
000080  6008              STR      r0,[r1,#0]            ;506
000082  e005              B        |L14.144|
                  |L14.132|
000084  bf00              NOP                            ;511
000086  2000              MOVS     r0,#0                 ;511
000088  6360              STR      r0,[r4,#0x34]         ;511
00008a  bf00              NOP                            ;511
00008c  f04f0802          MOV      r8,#2                 ;514
                  |L14.144|
000090  4640              MOV      r0,r8                 ;517
000092  e7c4              B        |L14.30|
;;;519    
                          ENDP


                          AREA ||i.HAL_DMA_UnRegisterCallback||, CODE, READONLY, ALIGN=1

                  HAL_DMA_UnRegisterCallback PROC
;;;1045     */              
;;;1046   HAL_StatusTypeDef HAL_DMA_UnRegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID)
000000  4602              MOV      r2,r0
;;;1047   {
;;;1048     HAL_StatusTypeDef status = HAL_OK;
000002  2300              MOVS     r3,#0
;;;1049     
;;;1050     /* Process locked */
;;;1051     __HAL_LOCK(hdma);
000004  bf00              NOP      
000006  6b50              LDR      r0,[r2,#0x34]
000008  2801              CMP      r0,#1
00000a  d101              BNE      |L15.16|
00000c  2002              MOVS     r0,#2
                  |L15.14|
;;;1052     
;;;1053     if(HAL_DMA_STATE_READY == hdma->State)
;;;1054     {
;;;1055       switch (CallbackID)
;;;1056       {
;;;1057       case  HAL_DMA_XFER_CPLT_CB_ID:
;;;1058         hdma->XferCpltCallback = NULL;
;;;1059         break;
;;;1060         
;;;1061       case  HAL_DMA_XFER_HALFCPLT_CB_ID:
;;;1062         hdma->XferHalfCpltCallback = NULL;
;;;1063         break;
;;;1064         
;;;1065       case  HAL_DMA_XFER_M1CPLT_CB_ID:
;;;1066         hdma->XferM1CpltCallback = NULL;
;;;1067         break;
;;;1068         
;;;1069       case  HAL_DMA_XFER_M1HALFCPLT_CB_ID:
;;;1070         hdma->XferM1HalfCpltCallback = NULL;
;;;1071         break;
;;;1072         
;;;1073       case  HAL_DMA_XFER_ERROR_CB_ID:
;;;1074         hdma->XferErrorCallback = NULL;
;;;1075         break;
;;;1076         
;;;1077       case  HAL_DMA_XFER_ABORT_CB_ID:
;;;1078         hdma->XferAbortCallback = NULL;
;;;1079         break; 
;;;1080         
;;;1081       case   HAL_DMA_XFER_ALL_CB_ID:
;;;1082         hdma->XferCpltCallback = NULL;
;;;1083         hdma->XferHalfCpltCallback = NULL;
;;;1084         hdma->XferM1CpltCallback = NULL;
;;;1085         hdma->XferM1HalfCpltCallback = NULL;
;;;1086         hdma->XferErrorCallback = NULL;
;;;1087         hdma->XferAbortCallback = NULL;
;;;1088         break; 
;;;1089         
;;;1090       default:
;;;1091         status = HAL_ERROR;
;;;1092         break;
;;;1093       }
;;;1094     }
;;;1095     else
;;;1096     {
;;;1097       status = HAL_ERROR;
;;;1098     }
;;;1099     
;;;1100     /* Release Lock */
;;;1101     __HAL_UNLOCK(hdma);
;;;1102     
;;;1103     return status;
;;;1104   }
00000e  4770              BX       lr
                  |L15.16|
000010  2001              MOVS     r0,#1                 ;1051
000012  6350              STR      r0,[r2,#0x34]         ;1051
000014  bf00              NOP                            ;1051
000016  6b90              LDR      r0,[r2,#0x38]         ;1053
000018  2801              CMP      r0,#1                 ;1053
00001a  d124              BNE      |L15.102|
00001c  2907              CMP      r1,#7                 ;1055
00001e  d21f              BCS      |L15.96|
000020  e8dff001          TBB      [pc,r1]               ;1055
000024  04070a0d          DCB      0x04,0x07,0x0a,0x0d
000028  10131600          DCB      0x10,0x13,0x16,0x00
00002c  2000              MOVS     r0,#0                 ;1058
00002e  6410              STR      r0,[r2,#0x40]         ;1058
000030  e018              B        |L15.100|
000032  2000              MOVS     r0,#0                 ;1062
000034  6450              STR      r0,[r2,#0x44]         ;1062
000036  e015              B        |L15.100|
000038  2000              MOVS     r0,#0                 ;1066
00003a  6490              STR      r0,[r2,#0x48]         ;1066
00003c  e012              B        |L15.100|
00003e  2000              MOVS     r0,#0                 ;1070
000040  64d0              STR      r0,[r2,#0x4c]         ;1070
000042  e00f              B        |L15.100|
000044  2000              MOVS     r0,#0                 ;1074
000046  6510              STR      r0,[r2,#0x50]         ;1074
000048  e00c              B        |L15.100|
00004a  2000              MOVS     r0,#0                 ;1078
00004c  6550              STR      r0,[r2,#0x54]         ;1078
00004e  e009              B        |L15.100|
000050  2000              MOVS     r0,#0                 ;1082
000052  6410              STR      r0,[r2,#0x40]         ;1082
000054  6450              STR      r0,[r2,#0x44]         ;1083
000056  6490              STR      r0,[r2,#0x48]         ;1084
000058  64d0              STR      r0,[r2,#0x4c]         ;1085
00005a  6510              STR      r0,[r2,#0x50]         ;1086
00005c  6550              STR      r0,[r2,#0x54]         ;1087
00005e  e001              B        |L15.100|
                  |L15.96|
000060  2301              MOVS     r3,#1                 ;1091
000062  bf00              NOP                            ;1092
                  |L15.100|
000064  e000              B        |L15.104|
                  |L15.102|
000066  2301              MOVS     r3,#1                 ;1097
                  |L15.104|
000068  bf00              NOP                            ;1101
00006a  2000              MOVS     r0,#0                 ;1101
00006c  6350              STR      r0,[r2,#0x34]         ;1101
00006e  bf00              NOP                            ;1101
000070  4618              MOV      r0,r3                 ;1103
000072  e7cc              B        |L15.14|
;;;1105   
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  flagBitshiftOffset
000000  00061016          DCB      0x00,0x06,0x10,0x16
000004  00061016          DCB      0x00,0x06,0x10,0x16

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\M0P0_Library\\STM32Cube_FW_F7_V1.11.0\\Drivers\\STM32F7xx_HAL_Driver\\Src\\stm32f7xx_hal_dma.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f7xx_hal_dma_c_c25f65ec____REV16|
#line 464 "D:\\Program_Files_x86\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.1.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___19_stm32f7xx_hal_dma_c_c25f65ec____REV16| PROC
#line 465

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f7xx_hal_dma_c_c25f65ec____REVSH|
#line 479
|__asm___19_stm32f7xx_hal_dma_c_c25f65ec____REVSH| PROC
#line 480

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f7xx_hal_dma_c_c25f65ec____RRX|
#line 666
|__asm___19_stm32f7xx_hal_dma_c_c25f65ec____RRX| PROC
#line 667

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
