; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\ldebug.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\ldebug.d --cpu=Cortex-M7 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Inc -I.\Source -I.\Drivers -I..\..\..\M6P1(L)_Lua\lua -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6-ALIENTEK-LUA\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER -Dlua_writestring=RMP_lua_writestring -Dlua_writeline=RMP_lua_writeline --enum_is_int --signed_chars --omf_browse=.\debug\output\ldebug.crf ..\..\..\M6P1(L)_Lua\lua\ldebug.c]
                          THUMB

                          AREA ||i.auxgetinfo||, CODE, READONLY, ALIGN=2

                  auxgetinfo PROC
;;;321    
;;;322    static int auxgetinfo (lua_State *L, const char *what, lua_Debug *ar,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;323                           Closure *f, CallInfo *ci) {
000004  4680              MOV      r8,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
00000a  461e              MOV      r6,r3
00000c  9d08              LDR      r5,[sp,#0x20]
;;;324      int status = 1;
00000e  f04f0901          MOV      r9,#1
;;;325      for (; *what; what++) {
000012  e06e              B        |L1.242|
                  |L1.20|
;;;326        switch (*what) {
000014  f9970000          LDRSB    r0,[r7,#0]
000018  286e              CMP      r0,#0x6e
00001a  d048              BEQ      |L1.174|
00001c  dc08              BGT      |L1.48|
00001e  284c              CMP      r0,#0x4c
000020  d060              BEQ      |L1.228|
000022  2853              CMP      r0,#0x53
000024  d00b              BEQ      |L1.62|
000026  2866              CMP      r0,#0x66
000028  d05d              BEQ      |L1.230|
00002a  286c              CMP      r0,#0x6c
00002c  d15c              BNE      |L1.232|
00002e  e00b              B        |L1.72|
                  |L1.48|
000030  2872              CMP      r0,#0x72
000032  d049              BEQ      |L1.200|
000034  2874              CMP      r0,#0x74
000036  d030              BEQ      |L1.154|
000038  2875              CMP      r0,#0x75
00003a  d155              BNE      |L1.232|
00003c  e012              B        |L1.100|
                  |L1.62|
;;;327          case 'S': {
;;;328            funcinfo(ar, f);
00003e  4631              MOV      r1,r6
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       funcinfo
;;;329            break;
000046  e052              B        |L1.238|
                  |L1.72|
;;;330          }
;;;331          case 'l': {
;;;332            ar->currentline = (ci && isLua(ci)) ? currentline(ci) : -1;
000048  b145              CBZ      r5,|L1.92|
00004a  f8950022          LDRB     r0,[r5,#0x22]
00004e  f0000002          AND      r0,r0,#2
000052  b918              CBNZ     r0,|L1.92|
000054  4628              MOV      r0,r5
000056  f7fffffe          BL       currentline
00005a  e001              B        |L1.96|
                  |L1.92|
00005c  f04f30ff          MOV      r0,#0xffffffff
                  |L1.96|
000060  6160              STR      r0,[r4,#0x14]
;;;333            break;
000062  e044              B        |L1.238|
                  |L1.100|
;;;334          }
;;;335          case 'u': {
;;;336            ar->nups = (f == NULL) ? 0 : f->c.nupvalues;
000064  b90e              CBNZ     r6,|L1.106|
000066  2000              MOVS     r0,#0
000068  e000              B        |L1.108|
                  |L1.106|
00006a  79b0              LDRB     r0,[r6,#6]
                  |L1.108|
00006c  f8840020          STRB     r0,[r4,#0x20]
;;;337            if (noLuaClosure(f)) {
000070  b116              CBZ      r6,|L1.120|
000072  7930              LDRB     r0,[r6,#4]
000074  2836              CMP      r0,#0x36
000076  d106              BNE      |L1.134|
                  |L1.120|
;;;338              ar->isvararg = 1;
000078  2001              MOVS     r0,#1
00007a  f8840022          STRB     r0,[r4,#0x22]
;;;339              ar->nparams = 0;
00007e  2000              MOVS     r0,#0
000080  f8840021          STRB     r0,[r4,#0x21]
000084  e008              B        |L1.152|
                  |L1.134|
;;;340            }
;;;341            else {
;;;342              ar->isvararg = f->l.p->is_vararg;
000086  68f0              LDR      r0,[r6,#0xc]
000088  79c0              LDRB     r0,[r0,#7]
00008a  b240              SXTB     r0,r0
00008c  f8840022          STRB     r0,[r4,#0x22]
;;;343              ar->nparams = f->l.p->numparams;
000090  68f0              LDR      r0,[r6,#0xc]
000092  7980              LDRB     r0,[r0,#6]
000094  f8840021          STRB     r0,[r4,#0x21]
                  |L1.152|
;;;344            }
;;;345            break;
000098  e029              B        |L1.238|
                  |L1.154|
;;;346          }
;;;347          case 't': {
;;;348            ar->istailcall = (ci) ? ci->callstatus & CIST_TAIL : 0;
00009a  b125              CBZ      r5,|L1.166|
00009c  f8950022          LDRB     r0,[r5,#0x22]
0000a0  f0000010          AND      r0,r0,#0x10
0000a4  e000              B        |L1.168|
                  |L1.166|
0000a6  2000              MOVS     r0,#0
                  |L1.168|
0000a8  f8840023          STRB     r0,[r4,#0x23]
;;;349            break;
0000ac  e01f              B        |L1.238|
                  |L1.174|
;;;350          }
;;;351          case 'n': {
;;;352            ar->namewhat = getfuncname(L, ci, &ar->name);
0000ae  1d22              ADDS     r2,r4,#4
0000b0  4629              MOV      r1,r5
0000b2  4640              MOV      r0,r8
0000b4  f7fffffe          BL       getfuncname
0000b8  60a0              STR      r0,[r4,#8]
;;;353            if (ar->namewhat == NULL) {
0000ba  68a0              LDR      r0,[r4,#8]
0000bc  b918              CBNZ     r0,|L1.198|
;;;354              ar->namewhat = "";  /* not found */
0000be  a010              ADR      r0,|L1.256|
0000c0  60a0              STR      r0,[r4,#8]
;;;355              ar->name = NULL;
0000c2  2000              MOVS     r0,#0
0000c4  6060              STR      r0,[r4,#4]
                  |L1.198|
;;;356            }
;;;357            break;
0000c6  e012              B        |L1.238|
                  |L1.200|
;;;358          }
;;;359          case 'r': {
;;;360            if (ci == NULL || !(ci->callstatus & CIST_TRAN))
0000c8  b11d              CBZ      r5,|L1.210|
0000ca  8c68              LDRH     r0,[r5,#0x22]
0000cc  f4007080          AND      r0,r0,#0x100
0000d0  b918              CBNZ     r0,|L1.218|
                  |L1.210|
;;;361              ar->fTransfer = ar->nTransfer = 0;
0000d2  2000              MOVS     r0,#0
0000d4  84e0              STRH     r0,[r4,#0x26]
0000d6  84a0              STRH     r0,[r4,#0x24]
0000d8  e003              B        |L1.226|
                  |L1.218|
;;;362            else {
;;;363              ar->fTransfer = ci->u2.transferinfo.fTransfer;
0000da  8ba8              LDRH     r0,[r5,#0x1c]
0000dc  84a0              STRH     r0,[r4,#0x24]
;;;364              ar->nTransfer = ci->u2.transferinfo.nTransfer;
0000de  8be8              LDRH     r0,[r5,#0x1e]
0000e0  84e0              STRH     r0,[r4,#0x26]
                  |L1.226|
;;;365            }
;;;366          }
;;;367          case 'L':
0000e2  bf00              NOP      
                  |L1.228|
;;;368          case 'f':  /* handled by lua_getinfo */
0000e4  bf00              NOP      
                  |L1.230|
;;;369            break;
0000e6  e002              B        |L1.238|
                  |L1.232|
;;;370          default: status = 0;  /* invalid option */
0000e8  f04f0900          MOV      r9,#0
0000ec  bf00              NOP                            ;326
                  |L1.238|
0000ee  bf00              NOP                            ;329
0000f0  1c7f              ADDS     r7,r7,#1              ;325
                  |L1.242|
0000f2  7838              LDRB     r0,[r7,#0]            ;325
0000f4  2800              CMP      r0,#0                 ;325
0000f6  d18d              BNE      |L1.20|
;;;371        }
;;;372      }
;;;373      return status;
0000f8  4648              MOV      r0,r9
;;;374    }
0000fa  e8bd87f0          POP      {r4-r10,pc}
;;;375    
                          ENDP

0000fe  0000              DCW      0x0000
                  |L1.256|
000100  00                DCB      0
000101  00                DCB      0
000102  00                DCB      0
000103  00                DCB      0

                          AREA ||i.changedline||, CODE, READONLY, ALIGN=1

                  changedline PROC
;;;776    */
;;;777    static int changedline (Proto *p, int oldpc, int newpc) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;778      while (oldpc++ < newpc) {
00000a  e012              B        |L2.50|
                  |L2.12|
;;;779        if (p->lineinfo[oldpc] != 0)
00000c  6c70              LDR      r0,[r6,#0x44]
00000e  5d00              LDRB     r0,[r0,r4]
000010  b178              CBZ      r0,|L2.50|
;;;780          return (luaG_getfuncline(p, oldpc - 1) != luaG_getfuncline(p, newpc));
000012  1e61              SUBS     r1,r4,#1
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       luaG_getfuncline
00001a  4607              MOV      r7,r0
00001c  4629              MOV      r1,r5
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       luaG_getfuncline
000024  4287              CMP      r7,r0
000026  d002              BEQ      |L2.46|
000028  2001              MOVS     r0,#1
                  |L2.42|
;;;781      }
;;;782      return 0;  /* no line changes in the way */
;;;783    }
00002a  e8bd81f0          POP      {r4-r8,pc}
                  |L2.46|
00002e  2000              MOVS     r0,#0                 ;780
000030  e7fb              B        |L2.42|
                  |L2.50|
000032  4620              MOV      r0,r4                 ;778
000034  1c64              ADDS     r4,r4,#1              ;778
000036  42a8              CMP      r0,r5                 ;778
000038  dbe8              BLT      |L2.12|
00003a  2000              MOVS     r0,#0                 ;782
00003c  e7f5              B        |L2.42|
;;;784    
                          ENDP


                          AREA ||i.collectvalidlines||, CODE, READONLY, ALIGN=1

                  collectvalidlines PROC
;;;285    
;;;286    static void collectvalidlines (lua_State *L, Closure *f) {
000000  e92d43f0          PUSH     {r4-r9,lr}
000004  b087              SUB      sp,sp,#0x1c
000006  4604              MOV      r4,r0
000008  460d              MOV      r5,r1
;;;287      if (noLuaClosure(f)) {
00000a  b115              CBZ      r5,|L3.18|
00000c  7928              LDRB     r0,[r5,#4]
00000e  2836              CMP      r0,#0x36
000010  d106              BNE      |L3.32|
                  |L3.18|
;;;288        setnilvalue(s2v(L->top));
000012  2000              MOVS     r0,#0
000014  68e1              LDR      r1,[r4,#0xc]
000016  7208              STRB     r0,[r1,#8]
;;;289        api_incr_top(L);
000018  68e0              LDR      r0,[r4,#0xc]
00001a  3010              ADDS     r0,r0,#0x10
00001c  60e0              STR      r0,[r4,#0xc]
00001e  e028              B        |L3.114|
                  |L3.32|
;;;290      }
;;;291      else {
;;;292        int i;
;;;293        TValue v;
;;;294        Proto *p = f->l.p;
000020  68ef              LDR      r7,[r5,#0xc]
;;;295        int currentline = p->linedefined;
000022  f8d78028          LDR      r8,[r7,#0x28]
;;;296        Table *t = luaH_new(L);  /* new table to store active lines */
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       luaH_new
00002c  4681              MOV      r9,r0
;;;297        sethvalue2s(L, L->top, t);  /* push it on stack */
00002e  68e0              LDR      r0,[r4,#0xc]
000030  4649              MOV      r1,r9
000032  6001              STR      r1,[r0,#0]
000034  2245              MOVS     r2,#0x45
000036  7202              STRB     r2,[r0,#8]
;;;298        api_incr_top(L);
000038  68e0              LDR      r0,[r4,#0xc]
00003a  3010              ADDS     r0,r0,#0x10
00003c  60e0              STR      r0,[r4,#0xc]
;;;299        setbvalue(&v, 1);  /* boolean 'true' to be the value of all indices */
00003e  a802              ADD      r0,sp,#8
000040  2101              MOVS     r1,#1
000042  6001              STR      r1,[r0,#0]
000044  7201              STRB     r1,[r0,#8]
;;;300        for (i = 0; i < p->sizelineinfo; i++) {  /* for all lines with code */
000046  2600              MOVS     r6,#0
000048  e00f              B        |L3.106|
                  |L3.74|
;;;301          currentline = nextline(p, currentline, i);
00004a  4632              MOV      r2,r6
00004c  4641              MOV      r1,r8
00004e  4638              MOV      r0,r7
000050  f7fffffe          BL       nextline
000054  4680              MOV      r8,r0
;;;302          luaH_setint(L, t, currentline, &v);  /* table[line] = true */
000056  a802              ADD      r0,sp,#8
000058  4642              MOV      r2,r8
00005a  ea4f73e8          ASR      r3,r8,#31
00005e  4649              MOV      r1,r9
000060  9000              STR      r0,[sp,#0]
000062  4620              MOV      r0,r4
000064  f7fffffe          BL       luaH_setint
000068  1c76              ADDS     r6,r6,#1              ;300
                  |L3.106|
00006a  69b8              LDR      r0,[r7,#0x18]         ;300
00006c  42b0              CMP      r0,r6                 ;300
00006e  dcec              BGT      |L3.74|
;;;303        }
;;;304      }
000070  bf00              NOP      
                  |L3.114|
;;;305    }
000072  b007              ADD      sp,sp,#0x1c
000074  e8bd83f0          POP      {r4-r9,pc}
;;;306    
                          ENDP


                          AREA ||i.currentline||, CODE, READONLY, ALIGN=1

                  currentline PROC
;;;103    
;;;104    static int currentline (CallInfo *ci) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;105      return luaG_getfuncline(ci_func(ci)->p, currentpc(ci));
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       currentpc
00000a  4605              MOV      r5,r0
00000c  6821              LDR      r1,[r4,#0]
00000e  6809              LDR      r1,[r1,#0]
000010  68c8              LDR      r0,[r1,#0xc]
000012  4629              MOV      r1,r5
000014  f7fffffe          BL       luaG_getfuncline
;;;106    }
000018  bd70              POP      {r4-r6,pc}
;;;107    
                          ENDP


                          AREA ||i.currentpc||, CODE, READONLY, ALIGN=1

                  currentpc PROC
;;;44     
;;;45     static int currentpc (CallInfo *ci) {
000000  4601              MOV      r1,r0
;;;46       lua_assert(isLua(ci));
;;;47       return pcRel(ci->u.l.savedpc, ci_func(ci)->p);
000002  680a              LDR      r2,[r1,#0]
000004  6908              LDR      r0,[r1,#0x10]
000006  6812              LDR      r2,[r2,#0]
000008  68d2              LDR      r2,[r2,#0xc]
00000a  6b92              LDR      r2,[r2,#0x38]
00000c  1a80              SUBS     r0,r0,r2
00000e  2201              MOVS     r2,#1
000010  ebc200a0          RSB      r0,r2,r0,ASR #2
;;;48     }
000014  4770              BX       lr
;;;49     
                          ENDP


                          AREA ||i.filterpc||, CODE, READONLY, ALIGN=1

                  filterpc PROC
;;;448    
;;;449    static int filterpc (int pc, int jmptarget) {
000000  4602              MOV      r2,r0
;;;450      if (pc < jmptarget)  /* is code conditional (inside a jump)? */
000002  428a              CMP      r2,r1
000004  da02              BGE      |L6.12|
;;;451        return -1;  /* cannot know who sets that register */
000006  f04f30ff          MOV      r0,#0xffffffff
                  |L6.10|
;;;452      else return pc;  /* current position sets that register */
;;;453    }
00000a  4770              BX       lr
                  |L6.12|
00000c  4610              MOV      r0,r2                 ;452
00000e  e7fc              B        |L6.10|
;;;454    
                          ENDP


                          AREA ||i.findlocal||, CODE, READONLY, ALIGN=2

                  findlocal PROC
;;;201    
;;;202    static const char *findlocal (lua_State *L, CallInfo *ci, int n,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;203                                  StkId *pos) {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  461f              MOV      r7,r3
;;;204      StkId base = ci->func + 1;
00000c  6820              LDR      r0,[r4,#0]
00000e  f1000810          ADD      r8,r0,#0x10
;;;205      const char *name = NULL;
000012  f04f0900          MOV      r9,#0
;;;206      if (isLua(ci)) {
000016  f8940022          LDRB     r0,[r4,#0x22]
00001a  f0000002          AND      r0,r0,#2
00001e  b9a0              CBNZ     r0,|L7.74|
;;;207        if (n < 0)  /* access to vararg values? */
000020  2d00              CMP      r5,#0
000022  da06              BGE      |L7.50|
;;;208          return findvararg(ci, -n, pos);
000024  463a              MOV      r2,r7
000026  4269              RSBS     r1,r5,#0
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       findvararg
                  |L7.46|
;;;209        else
;;;210          name = luaF_getlocalname(ci_func(ci)->p, n, currentpc(ci));
;;;211      }
;;;212      if (name == NULL) {  /* no 'standard' name? */
;;;213        StkId limit = (ci == L->ci) ? L->top : ci->next->func;
;;;214        if (limit - base >= n && n > 0)  /* is 'n' inside 'ci' stack? */
;;;215          name = "(*temporary)";  /* generic name for any valid slot */
;;;216        else
;;;217          return NULL;  /* no name */
;;;218      }
;;;219      *pos = base + (n - 1);
;;;220      return name;
;;;221    }
00002e  e8bd87f0          POP      {r4-r10,pc}
                  |L7.50|
000032  4620              MOV      r0,r4                 ;210
000034  f7fffffe          BL       currentpc
000038  4682              MOV      r10,r0                ;210
00003a  6821              LDR      r1,[r4,#0]            ;210
00003c  6809              LDR      r1,[r1,#0]            ;210
00003e  4652              MOV      r2,r10                ;210
000040  68c8              LDR      r0,[r1,#0xc]          ;210
000042  4629              MOV      r1,r5                 ;210
000044  f7fffffe          BL       luaF_getlocalname
000048  4681              MOV      r9,r0                 ;210
                  |L7.74|
00004a  f1b90f00          CMP      r9,#0                 ;212
00004e  d114              BNE      |L7.122|
000050  6970              LDR      r0,[r6,#0x14]         ;213
000052  42a0              CMP      r0,r4                 ;213
000054  d101              BNE      |L7.90|
000056  68f0              LDR      r0,[r6,#0xc]          ;213
000058  e001              B        |L7.94|
                  |L7.90|
00005a  68e0              LDR      r0,[r4,#0xc]          ;213
00005c  6800              LDR      r0,[r0,#0]            ;213
                  |L7.94|
00005e  4601              MOV      r1,r0                 ;213
000060  eba10008          SUB      r0,r1,r8              ;214
000064  ebb51f20          CMP      r5,r0,ASR #4          ;214
000068  dc04              BGT      |L7.116|
00006a  2d00              CMP      r5,#0                 ;214
00006c  dd02              BLE      |L7.116|
00006e  f20f0918          ADR      r9,|L7.136|
000072  e001              B        |L7.120|
                  |L7.116|
000074  2000              MOVS     r0,#0                 ;217
000076  e7da              B        |L7.46|
                  |L7.120|
000078  bf00              NOP                            ;218
                  |L7.122|
00007a  1e68              SUBS     r0,r5,#1              ;219
00007c  eb081000          ADD      r0,r8,r0,LSL #4       ;219
000080  6038              STR      r0,[r7,#0]            ;219
000082  4648              MOV      r0,r9                 ;220
000084  e7d3              B        |L7.46|
;;;222    
                          ENDP

000086  0000              DCW      0x0000
                  |L7.136|
000088  282a7465          DCB      "(*temporary)",0
00008c  6d706f72
000090  61727929
000094  00      
000095  00                DCB      0
000096  00                DCB      0
000097  00                DCB      0

                          AREA ||i.findsetreg||, CODE, READONLY, ALIGN=2

                  findsetreg PROC
;;;458    */
;;;459    static int findsetreg (Proto *p, int lastpc, int reg) {
000000  e92d5ffc          PUSH     {r2-r12,lr}
000004  4681              MOV      r9,r0
000006  4688              MOV      r8,r1
000008  4614              MOV      r4,r2
;;;460      int pc;
;;;461      int setreg = -1;  /* keep last instruction that changed 'reg' */
00000a  f04f30ff          MOV      r0,#0xffffffff
00000e  9001              STR      r0,[sp,#4]
;;;462      int jmptarget = 0;  /* any code before this address is conditional */
000010  2000              MOVS     r0,#0
000012  9000              STR      r0,[sp,#0]
;;;463      for (pc = 0; pc < lastpc; pc++) {
000014  2500              MOVS     r5,#0
000016  e05d              B        |L8.212|
                  |L8.24|
;;;464        Instruction i = p->code[pc];
000018  f8d90038          LDR      r0,[r9,#0x38]
00001c  f8507025          LDR      r7,[r0,r5,LSL #2]
;;;465        OpCode op = GET_OPCODE(i);
000020  f0070a7f          AND      r10,r7,#0x7f
;;;466        int a = GETARG_A(i);
000024  f3c716c7          UBFX     r6,r7,#7,#8
;;;467        int change;  /* true if current instruction changed 'reg' */
;;;468        switch (op) {
000028  f1ba0f3f          CMP      r10,#0x3f
00002c  d022              BEQ      |L8.116|
00002e  dc06              BGT      |L8.62|
000030  f1ba0f06          CMP      r10,#6
000034  d00a              BEQ      |L8.76|
000036  f1ba0f31          CMP      r10,#0x31
00003a  d134              BNE      |L8.166|
00003c  e022              B        |L8.132|
                  |L8.62|
00003e  f1ba0f40          CMP      r10,#0x40
000042  d018              BEQ      |L8.118|
000044  f1ba0f48          CMP      r10,#0x48
000048  d12d              BNE      |L8.166|
00004a  e00b              B        |L8.100|
                  |L8.76|
;;;469          case OP_LOADNIL: {  /* set registers from 'a' to 'a+b' */
;;;470            int b = GETARG_B(i);
00004c  f3c74007          UBFX     r0,r7,#16,#8
;;;471            change = (a <= reg && reg <= a + b);
000050  42a6              CMP      r6,r4
000052  dc04              BGT      |L8.94|
000054  1831              ADDS     r1,r6,r0
000056  42a1              CMP      r1,r4
000058  db01              BLT      |L8.94|
00005a  2101              MOVS     r1,#1
00005c  e000              B        |L8.96|
                  |L8.94|
00005e  2100              MOVS     r1,#0
                  |L8.96|
000060  468b              MOV      r11,r1
;;;472            break;
000062  e02d              B        |L8.192|
                  |L8.100|
;;;473          }
;;;474          case OP_TFORCALL: {  /* affect all regs above its base */
;;;475            change = (reg >= a + 2);
000064  1cb0              ADDS     r0,r6,#2
000066  4284              CMP      r4,r0
000068  db01              BLT      |L8.110|
00006a  2001              MOVS     r0,#1
00006c  e000              B        |L8.112|
                  |L8.110|
00006e  2000              MOVS     r0,#0
                  |L8.112|
000070  4683              MOV      r11,r0
;;;476            break;
000072  e025              B        |L8.192|
                  |L8.116|
;;;477          }
;;;478          case OP_CALL:
;;;479          case OP_TAILCALL: {  /* affect all registers above base */
000074  bf00              NOP      
                  |L8.118|
;;;480            change = (reg >= a);
000076  42b4              CMP      r4,r6
000078  db01              BLT      |L8.126|
00007a  2001              MOVS     r0,#1
00007c  e000              B        |L8.128|
                  |L8.126|
00007e  2000              MOVS     r0,#0
                  |L8.128|
000080  4683              MOV      r11,r0
;;;481            break;
000082  e01d              B        |L8.192|
                  |L8.132|
;;;482          }
;;;483          case OP_JMP: {  /* doesn't change registers, but changes 'jmptarget' */
;;;484            int b = GETARG_sJ(i);
000084  f06f427f          MVN      r2,#0xff000000
000088  ea022217          AND      r2,r2,r7,LSR #8
00008c  4b14              LDR      r3,|L8.224|
00008e  1ad1              SUBS     r1,r2,r3
;;;485            int dest = pc + 1 + b;
000090  1c6a              ADDS     r2,r5,#1
000092  1850              ADDS     r0,r2,r1
;;;486            /* jump does not skip 'lastpc' and is larger than current one? */
;;;487            if (dest <= lastpc && dest > jmptarget)
000094  4540              CMP      r0,r8
000096  dc03              BGT      |L8.160|
000098  9a00              LDR      r2,[sp,#0]
00009a  4290              CMP      r0,r2
00009c  dd00              BLE      |L8.160|
;;;488              jmptarget = dest;  /* update 'jmptarget' */
00009e  9000              STR      r0,[sp,#0]
                  |L8.160|
;;;489            change = 0;
0000a0  f04f0b00          MOV      r11,#0
;;;490            break;
0000a4  e00c              B        |L8.192|
                  |L8.166|
;;;491          }
;;;492          default:  /* any instruction that sets A */
;;;493            change = (testAMode(op) && reg == a);
0000a6  480f              LDR      r0,|L8.228|
0000a8  f810000a          LDRB     r0,[r0,r10]
0000ac  f0000008          AND      r0,r0,#8
0000b0  b118              CBZ      r0,|L8.186|
0000b2  42b4              CMP      r4,r6
0000b4  d101              BNE      |L8.186|
0000b6  2001              MOVS     r0,#1
0000b8  e000              B        |L8.188|
                  |L8.186|
0000ba  2000              MOVS     r0,#0
                  |L8.188|
0000bc  4683              MOV      r11,r0
;;;494            break;
0000be  bf00              NOP      
                  |L8.192|
0000c0  bf00              NOP                            ;472
;;;495        }
;;;496        if (change)
0000c2  f1bb0f00          CMP      r11,#0
0000c6  d004              BEQ      |L8.210|
;;;497          setreg = filterpc(pc, jmptarget);
0000c8  4628              MOV      r0,r5
0000ca  9900              LDR      r1,[sp,#0]
0000cc  f7fffffe          BL       filterpc
0000d0  9001              STR      r0,[sp,#4]
                  |L8.210|
0000d2  1c6d              ADDS     r5,r5,#1              ;463
                  |L8.212|
0000d4  4545              CMP      r5,r8                 ;463
0000d6  db9f              BLT      |L8.24|
;;;498      }
;;;499      return setreg;
0000d8  9801              LDR      r0,[sp,#4]
;;;500    }
0000da  e8bd9ffc          POP      {r2-r12,pc}
;;;501    
                          ENDP

0000de  0000              DCW      0x0000
                  |L8.224|
                          DCD      0x007fffff
                  |L8.228|
                          DCD      luaP_opmodes

                          AREA ||i.findvararg||, CODE, READONLY, ALIGN=2

                  findvararg PROC
;;;189    
;;;190    static const char *findvararg (CallInfo *ci, int n, StkId *pos) {
000000  b530              PUSH     {r4,r5,lr}
000002  4603              MOV      r3,r0
;;;191      if (clLvalue(s2v(ci->func))->p->is_vararg) {
000004  6818              LDR      r0,[r3,#0]
000006  6800              LDR      r0,[r0,#0]
000008  68c0              LDR      r0,[r0,#0xc]
00000a  79c0              LDRB     r0,[r0,#7]
00000c  b160              CBZ      r0,|L9.40|
;;;192        int nextra = ci->u.l.nextraargs;
00000e  699c              LDR      r4,[r3,#0x18]
;;;193        if (n <= nextra) {
000010  42a1              CMP      r1,r4
000012  dc08              BGT      |L9.38|
;;;194          *pos = ci->func - nextra + (n - 1);
000014  6818              LDR      r0,[r3,#0]
000016  eba01504          SUB      r5,r0,r4,LSL #4
00001a  1e48              SUBS     r0,r1,#1
00001c  eb051000          ADD      r0,r5,r0,LSL #4
000020  6010              STR      r0,[r2,#0]
;;;195          return "(*vararg)";  /* generic name for any vararg */
000022  a002              ADR      r0,|L9.44|
                  |L9.36|
;;;196        }
;;;197      }
;;;198      return NULL;  /* no such vararg */
;;;199    }
000024  bd30              POP      {r4,r5,pc}
                  |L9.38|
000026  bf00              NOP                            ;197
                  |L9.40|
000028  2000              MOVS     r0,#0                 ;198
00002a  e7fb              B        |L9.36|
;;;200    
                          ENDP

                  |L9.44|
00002c  282a7661          DCB      "(*vararg)",0
000030  72617267
000034  2900    
000036  00                DCB      0
000037  00                DCB      0

                          AREA ||i.funcinfo||, CODE, READONLY, ALIGN=2

                  funcinfo PROC
;;;259    
;;;260    static void funcinfo (lua_Debug *ar, Closure *cl) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;261      if (noLuaClosure(cl)) {
000006  b115              CBZ      r5,|L10.14|
000008  7928              LDRB     r0,[r5,#4]
00000a  2836              CMP      r0,#0x36
00000c  d108              BNE      |L10.32|
                  |L10.14|
;;;262        ar->source = "=[C]";
00000e  a011              ADR      r0,|L10.84|
000010  6120              STR      r0,[r4,#0x10]
;;;263        ar->linedefined = -1;
000012  f04f30ff          MOV      r0,#0xffffffff
000016  61a0              STR      r0,[r4,#0x18]
;;;264        ar->lastlinedefined = -1;
000018  61e0              STR      r0,[r4,#0x1c]
;;;265        ar->what = "C";
00001a  a010              ADR      r0,|L10.92|
00001c  60e0              STR      r0,[r4,#0xc]
00001e  e012              B        |L10.70|
                  |L10.32|
;;;266      }
;;;267      else {
;;;268        Proto *p = cl->l.p;
000020  68e8              LDR      r0,[r5,#0xc]
;;;269        ar->source = p->source ? getstr(p->source) : "=?";
000022  6d01              LDR      r1,[r0,#0x50]
000024  b111              CBZ      r1,|L10.44|
000026  6d01              LDR      r1,[r0,#0x50]
000028  3110              ADDS     r1,r1,#0x10
00002a  e000              B        |L10.46|
                  |L10.44|
00002c  a10c              ADR      r1,|L10.96|
                  |L10.46|
00002e  6121              STR      r1,[r4,#0x10]
;;;270        ar->linedefined = p->linedefined;
000030  6a81              LDR      r1,[r0,#0x28]
000032  61a1              STR      r1,[r4,#0x18]
;;;271        ar->lastlinedefined = p->lastlinedefined;
000034  6ac1              LDR      r1,[r0,#0x2c]
000036  61e1              STR      r1,[r4,#0x1c]
;;;272        ar->what = (ar->linedefined == 0) ? "main" : "Lua";
000038  69a1              LDR      r1,[r4,#0x18]
00003a  b909              CBNZ     r1,|L10.64|
00003c  a109              ADR      r1,|L10.100|
00003e  e000              B        |L10.66|
                  |L10.64|
000040  a10a              ADR      r1,|L10.108|
                  |L10.66|
000042  60e1              STR      r1,[r4,#0xc]
;;;273      }
000044  bf00              NOP      
                  |L10.70|
;;;274      luaO_chunkid(ar->short_src, ar->source, LUA_IDSIZE);
000046  223c              MOVS     r2,#0x3c
000048  f1040028          ADD      r0,r4,#0x28
00004c  6921              LDR      r1,[r4,#0x10]
00004e  f7fffffe          BL       luaO_chunkid
;;;275    }
000052  bd70              POP      {r4-r6,pc}
;;;276    
                          ENDP

                  |L10.84|
000054  3d5b435d          DCB      "=[C]",0
000058  00      
000059  00                DCB      0
00005a  00                DCB      0
00005b  00                DCB      0
                  |L10.92|
00005c  4300              DCB      "C",0
00005e  00                DCB      0
00005f  00                DCB      0
                  |L10.96|
000060  3d3f00            DCB      "=?",0
000063  00                DCB      0
                  |L10.100|
000064  6d61696e          DCB      "main",0
000068  00      
000069  00                DCB      0
00006a  00                DCB      0
00006b  00                DCB      0
                  |L10.108|
00006c  4c756100          DCB      "Lua",0

                          AREA ||i.funcnamefromcode||, CODE, READONLY, ALIGN=2

                  funcnamefromcode PROC
;;;584    */
;;;585    static const char *funcnamefromcode (lua_State *L, CallInfo *ci,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;586                                         const char **name) {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4614              MOV      r4,r2
;;;587      TMS tm = (TMS)0;  /* (initial value avoids warnings) */
00000a  f04f0a00          MOV      r10,#0
;;;588      Proto *p = ci_func(ci)->p;  /* calling function */
00000e  6828              LDR      r0,[r5,#0]
000010  6800              LDR      r0,[r0,#0]
000012  f8d0800c          LDR      r8,[r0,#0xc]
;;;589      int pc = currentpc(ci);  /* calling instruction index */
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       currentpc
00001c  4681              MOV      r9,r0
;;;590      Instruction i = p->code[pc];  /* calling instruction */
00001e  f8d80038          LDR      r0,[r8,#0x38]
000022  f8506029          LDR      r6,[r0,r9,LSL #2]
;;;591      if (ci->callstatus & CIST_HOOKED) {  /* was it called inside a hook? */
000026  f8950022          LDRB     r0,[r5,#0x22]
00002a  f0000004          AND      r0,r0,#4
00002e  b120              CBZ      r0,|L11.58|
;;;592        *name = "?";
000030  a047              ADR      r0,|L11.336|
000032  6020              STR      r0,[r4,#0]
;;;593        return "hook";
000034  a047              ADR      r0,|L11.340|
                  |L11.54|
;;;594      }
;;;595      switch (GET_OPCODE(i)) {
;;;596        case OP_CALL:
;;;597        case OP_TAILCALL:
;;;598          return getobjname(p, pc, GETARG_A(i), name);  /* get function name */
;;;599        case OP_TFORCALL: {  /* for iterator */
;;;600          *name = "for iterator";
;;;601           return "for iterator";
;;;602        }
;;;603        /* other instructions can do calls through metamethods */
;;;604        case OP_SELF: case OP_GETTABUP: case OP_GETTABLE:
;;;605        case OP_GETI: case OP_GETFIELD:
;;;606          tm = TM_INDEX;
;;;607          break;
;;;608        case OP_SETTABUP: case OP_SETTABLE: case OP_SETI: case OP_SETFIELD:
;;;609          tm = TM_NEWINDEX;
;;;610          break;
;;;611        case OP_ADDI: case OP_SUBI: case OP_MULI: case OP_MODI:
;;;612        case OP_POWI: case OP_DIVI: case OP_IDIVI:
;;;613        case OP_BANDK: case OP_BORK: case OP_BXORK: {
;;;614          int offset = GET_OPCODE(i) - OP_ADDI;  /* ORDER OP */
;;;615          tm = cast(TMS, offset + TM_ADD);  /* ORDER TM */
;;;616          break;
;;;617        }
;;;618        case OP_ADD: case OP_SUB: case OP_MUL: case OP_MOD:
;;;619        case OP_POW: case OP_DIV: case OP_IDIV: case OP_BAND:
;;;620        case OP_BOR: case OP_BXOR: case OP_SHL: case OP_SHR: {
;;;621          int offset = GET_OPCODE(i) - OP_ADD;  /* ORDER OP */
;;;622          tm = cast(TMS, offset + TM_ADD);  /* ORDER TM */
;;;623          break;
;;;624        }
;;;625        case OP_UNM: tm = TM_UNM; break;
;;;626        case OP_BNOT: tm = TM_BNOT; break;
;;;627        case OP_LEN: tm = TM_LEN; break;
;;;628        case OP_CONCAT: tm = TM_CONCAT; break;
;;;629        case OP_EQ: tm = TM_EQ; break;
;;;630        case OP_LT: case OP_LE: case OP_LTI: case OP_LEI:
;;;631          *name = "order";  /* '<=' can call '__lt', etc. */
;;;632          return "metamethod";
;;;633        case OP_SHRI: case OP_SHLI:
;;;634          *name = "shift";
;;;635          return "metamethod";
;;;636        default:
;;;637          return NULL;  /* cannot find a reasonable name */
;;;638      }
;;;639      *name = getstr(G(L)->tmname[tm]) + 2;
;;;640      return "metamethod";
;;;641    }
000036  e8bd87f0          POP      {r4-r10,pc}
                  |L11.58|
00003a  f006007f          AND      r0,r6,#0x7f           ;595
00003e  3809              SUBS     r0,r0,#9              ;595
000040  2840              CMP      r0,#0x40              ;595
000042  d279              BCS      |L11.312|
000044  e8dff000          TBB      [pc,r0]               ;595
000048  2e2f3031          DCB      0x2e,0x2f,0x30,0x31
00004c  34353637          DCB      0x34,0x35,0x36,0x37
000050  782d3a3b          DCB      0x78,0x2d,0x3a,0x3b
000054  3c3d3e3f          DCB      0x3c,0x3d,0x3e,0x3f
000058  40414243          DCB      0x40,0x41,0x42,0x43
00005c  73744a4b          DCB      0x73,0x74,0x4a,0x4b
000060  4c4d4e4f          DCB      0x4c,0x4d,0x4e,0x4f
000064  50515253          DCB      0x50,0x51,0x52,0x53
000068  54555c5f          DCB      0x54,0x55,0x5c,0x5f
00006c  78626578          DCB      0x78,0x62,0x65,0x78
000070  78686b6c          DCB      0x78,0x68,0x6b,0x6c
000074  78786d6e          DCB      0x78,0x78,0x6d,0x6e
000078  78787878          DCB      0x78,0x78,0x78,0x78
00007c  78782021          DCB      0x78,0x78,0x20,0x21
000080  78787878          DCB      0x78,0x78,0x78,0x78
000084  78787829          DCB      0x78,0x78,0x78,0x29
000088  bf00              NOP                            ;597
00008a  4623              MOV      r3,r4                 ;598
00008c  f3c612c7          UBFX     r2,r6,#7,#8           ;598
000090  4649              MOV      r1,r9                 ;598
000092  4640              MOV      r0,r8                 ;598
000094  f7fffffe          BL       getobjname
000098  e7cd              B        |L11.54|
00009a  a030              ADR      r0,|L11.348|
00009c  6020              STR      r0,[r4,#0]            ;600
00009e  a02f              ADR      r0,|L11.348|
0000a0  e7c9              B        |L11.54|
0000a2  bf00              NOP                            ;604
0000a4  bf00              NOP                            ;604
0000a6  bf00              NOP                            ;605
0000a8  bf00              NOP                            ;605
0000aa  f04f0a00          MOV      r10,#0                ;606
0000ae  e045              B        |L11.316|
0000b0  bf00              NOP                            ;608
0000b2  bf00              NOP                            ;608
0000b4  bf00              NOP                            ;608
0000b6  f04f0a01          MOV      r10,#1                ;609
0000ba  e03f              B        |L11.316|
0000bc  bf00              NOP                            ;611
0000be  bf00              NOP                            ;611
0000c0  bf00              NOP                            ;611
0000c2  bf00              NOP                            ;612
0000c4  bf00              NOP                            ;612
0000c6  bf00              NOP                            ;612
0000c8  bf00              NOP                            ;613
0000ca  bf00              NOP                            ;613
0000cc  bf00              NOP                            ;613
0000ce  f006017f          AND      r1,r6,#0x7f           ;614
0000d2  f1a10013          SUB      r0,r1,#0x13           ;614
0000d6  f1000a08          ADD      r10,r0,#8             ;615
0000da  e02f              B        |L11.316|
0000dc  bf00              NOP                            ;618
0000de  bf00              NOP                            ;618
0000e0  bf00              NOP                            ;618
0000e2  bf00              NOP                            ;619
0000e4  bf00              NOP                            ;619
0000e6  bf00              NOP                            ;619
0000e8  bf00              NOP                            ;619
0000ea  bf00              NOP                            ;620
0000ec  bf00              NOP                            ;620
0000ee  bf00              NOP                            ;620
0000f0  bf00              NOP                            ;620
0000f2  f006017f          AND      r1,r6,#0x7f           ;621
0000f6  f1a1001f          SUB      r0,r1,#0x1f           ;621
0000fa  f1000a08          ADD      r10,r0,#8             ;622
0000fe  e01d              B        |L11.316|
000100  f04f0a14          MOV      r10,#0x14             ;625
000104  e01a              B        |L11.316|
000106  f04f0a15          MOV      r10,#0x15             ;626
00010a  e017              B        |L11.316|
00010c  f04f0a06          MOV      r10,#6                ;627
000110  e014              B        |L11.316|
000112  f04f0a18          MOV      r10,#0x18             ;628
000116  e011              B        |L11.316|
000118  f04f0a07          MOV      r10,#7                ;629
00011c  e00e              B        |L11.316|
00011e  bf00              NOP                            ;630
000120  bf00              NOP                            ;630
000122  bf00              NOP                            ;630
000124  a011              ADR      r0,|L11.364|
000126  6020              STR      r0,[r4,#0]            ;631
000128  a012              ADR      r0,|L11.372|
00012a  e784              B        |L11.54|
00012c  e004              B        |L11.312|
00012e  bf00              NOP                            ;633
000130  a013              ADR      r0,|L11.384|
000132  6020              STR      r0,[r4,#0]            ;634
000134  a00f              ADR      r0,|L11.372|
000136  e77e              B        |L11.54|
                  |L11.312|
000138  2000              MOVS     r0,#0                 ;637
00013a  e77c              B        |L11.54|
                  |L11.316|
00013c  bf00              NOP                            ;607
00013e  6938              LDR      r0,[r7,#0x10]         ;639
000140  3098              ADDS     r0,r0,#0x98           ;639
000142  f850002a          LDR      r0,[r0,r10,LSL #2]    ;639
000146  3012              ADDS     r0,r0,#0x12           ;639
000148  6020              STR      r0,[r4,#0]            ;639
00014a  a00a              ADR      r0,|L11.372|
00014c  e773              B        |L11.54|
;;;642    
                          ENDP

00014e  0000              DCW      0x0000
                  |L11.336|
000150  3f00              DCB      "?",0
000152  00                DCB      0
000153  00                DCB      0
                  |L11.340|
000154  686f6f6b          DCB      "hook",0
000158  00      
000159  00                DCB      0
00015a  00                DCB      0
00015b  00                DCB      0
                  |L11.348|
00015c  666f7220          DCB      "for iterator",0
000160  69746572
000164  61746f72
000168  00      
000169  00                DCB      0
00016a  00                DCB      0
00016b  00                DCB      0
                  |L11.364|
00016c  6f726465          DCB      "order",0
000170  7200    
000172  00                DCB      0
000173  00                DCB      0
                  |L11.372|
000174  6d657461          DCB      "metamethod",0
000178  6d657468
00017c  6f6400  
00017f  00                DCB      0
                  |L11.384|
000180  73686966          DCB      "shift",0
000184  7400    
000186  00                DCB      0
000187  00                DCB      0

                          AREA ||i.getbaseline||, CODE, READONLY, ALIGN=1

                  getbaseline PROC
;;;57     */
;;;58     static int getbaseline (Proto *f, int pc, int *basepc) {
000000  b570              PUSH     {r4-r6,lr}
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;59       if (f->sizeabslineinfo == 0 || pc < f->abslineinfo[0].pc) {
000006  6a58              LDR      r0,[r3,#0x24]
000008  b118              CBZ      r0,|L12.18|
00000a  6c98              LDR      r0,[r3,#0x48]
00000c  6800              LDR      r0,[r0,#0]
00000e  42a0              CMP      r0,r4
000010  dd04              BLE      |L12.28|
                  |L12.18|
;;;60         *basepc = -1;  /* start from the beginning */
000012  f04f30ff          MOV      r0,#0xffffffff
000016  6010              STR      r0,[r2,#0]
;;;61         return f->linedefined;
000018  6a98              LDR      r0,[r3,#0x28]
                  |L12.26|
;;;62       }
;;;63       else {
;;;64         unsigned int i;
;;;65         if (pc >= f->abslineinfo[f->sizeabslineinfo - 1].pc)
;;;66           i = f->sizeabslineinfo - 1;  /* instruction is after last saved one */
;;;67         else {  /* binary search */
;;;68           unsigned int j = f->sizeabslineinfo - 1;  /* pc < anchorlines[j] */
;;;69           i = 0;  /* abslineinfo[i] <= pc */
;;;70           while (i < j - 1) {
;;;71             unsigned int m = (j + i) / 2;
;;;72             if (pc >= f->abslineinfo[m].pc)
;;;73               i = m;
;;;74             else
;;;75               j = m;
;;;76           }
;;;77         }
;;;78         *basepc = f->abslineinfo[i].pc;
;;;79         return f->abslineinfo[i].line;
;;;80       }
;;;81     }
00001a  bd70              POP      {r4-r6,pc}
                  |L12.28|
00001c  6a58              LDR      r0,[r3,#0x24]         ;65
00001e  1e40              SUBS     r0,r0,#1              ;65
000020  6c9d              LDR      r5,[r3,#0x48]         ;65
000022  f8550030          LDR      r0,[r5,r0,LSL #3]     ;65
000026  42a0              CMP      r0,r4                 ;65
000028  dc02              BGT      |L12.48|
00002a  6a58              LDR      r0,[r3,#0x24]         ;66
00002c  1e41              SUBS     r1,r0,#1              ;66
00002e  e012              B        |L12.86|
                  |L12.48|
000030  6a58              LDR      r0,[r3,#0x24]         ;68
000032  1e45              SUBS     r5,r0,#1              ;68
000034  2100              MOVS     r1,#0                 ;69
000036  e00a              B        |L12.78|
                  |L12.56|
000038  186e              ADDS     r6,r5,r1              ;71
00003a  0870              LSRS     r0,r6,#1              ;71
00003c  6c9e              LDR      r6,[r3,#0x48]         ;72
00003e  f8566030          LDR      r6,[r6,r0,LSL #3]     ;72
000042  42a6              CMP      r6,r4                 ;72
000044  dc01              BGT      |L12.74|
000046  4601              MOV      r1,r0                 ;73
000048  e000              B        |L12.76|
                  |L12.74|
00004a  4605              MOV      r5,r0                 ;75
                  |L12.76|
00004c  bf00              NOP                            ;76
                  |L12.78|
00004e  1e68              SUBS     r0,r5,#1              ;70
000050  4288              CMP      r0,r1                 ;70
000052  d8f1              BHI      |L12.56|
000054  bf00              NOP                            ;77
                  |L12.86|
000056  6c98              LDR      r0,[r3,#0x48]         ;78
000058  f8500031          LDR      r0,[r0,r1,LSL #3]     ;78
00005c  6010              STR      r0,[r2,#0]            ;78
00005e  6c98              LDR      r0,[r3,#0x48]         ;79
000060  eb0000c1          ADD      r0,r0,r1,LSL #3       ;79
000064  6840              LDR      r0,[r0,#4]            ;79
000066  e7d8              B        |L12.26|
;;;82     
                          ENDP


                          AREA ||i.getfuncname||, CODE, READONLY, ALIGN=2

                  getfuncname PROC
;;;307    
;;;308    static const char *getfuncname (lua_State *L, CallInfo *ci, const char **name) {
000000  b570              PUSH     {r4-r6,lr}
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;309      if (ci == NULL)  /* no 'ci'? */
000008  b90c              CBNZ     r4,|L13.14|
;;;310        return NULL;  /* no info */
00000a  2000              MOVS     r0,#0
                  |L13.12|
;;;311      else if (ci->callstatus & CIST_FIN) {  /* is this a finalizer? */
;;;312        *name = "__gc";
;;;313        return "metamethod";  /* report it as such */
;;;314      }
;;;315      /* calling function is a known Lua function? */
;;;316      else if (!(ci->callstatus & CIST_TAIL) && isLua(ci->previous))
;;;317        return funcnamefromcode(L, ci->previous, name);
;;;318      else return NULL;  /* no way to find a name */
;;;319    }
00000c  bd70              POP      {r4-r6,pc}
                  |L13.14|
00000e  f8940022          LDRB     r0,[r4,#0x22]         ;311
000012  f0000080          AND      r0,r0,#0x80           ;311
000016  b118              CBZ      r0,|L13.32|
000018  a00b              ADR      r0,|L13.72|
00001a  6028              STR      r0,[r5,#0]            ;312
00001c  a00c              ADR      r0,|L13.80|
00001e  e7f5              B        |L13.12|
                  |L13.32|
000020  f8940022          LDRB     r0,[r4,#0x22]         ;316
000024  f0000010          AND      r0,r0,#0x10           ;316
000028  b958              CBNZ     r0,|L13.66|
00002a  68a0              LDR      r0,[r4,#8]            ;316
00002c  f8900022          LDRB     r0,[r0,#0x22]         ;316
000030  f0000002          AND      r0,r0,#2              ;316
000034  b928              CBNZ     r0,|L13.66|
000036  462a              MOV      r2,r5                 ;317
000038  4630              MOV      r0,r6                 ;317
00003a  68a1              LDR      r1,[r4,#8]            ;317
00003c  f7fffffe          BL       funcnamefromcode
000040  e7e4              B        |L13.12|
                  |L13.66|
000042  2000              MOVS     r0,#0                 ;318
000044  e7e2              B        |L13.12|
;;;320    
                          ENDP

000046  0000              DCW      0x0000
                  |L13.72|
000048  5f5f6763          DCB      "__gc",0
00004c  00      
00004d  00                DCB      0
00004e  00                DCB      0
00004f  00                DCB      0
                  |L13.80|
000050  6d657461          DCB      "metamethod",0
000054  6d657468
000058  6f6400  
00005b  00                DCB      0

                          AREA ||i.getobjname||, CODE, READONLY, ALIGN=2

                  getobjname PROC
;;;517    
;;;518     const char *getobjname (Proto *p, int lastpc, int reg, const char **name) {
000000  e92d5ff0          PUSH     {r4-r12,lr}
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4691              MOV      r9,r2
00000a  461d              MOV      r5,r3
;;;519      int pc;
;;;520      *name = luaF_getlocalname(p, reg + 1, lastpc);
00000c  4642              MOV      r2,r8
00000e  f1090101          ADD      r1,r9,#1
000012  4638              MOV      r0,r7
000014  f7fffffe          BL       luaF_getlocalname
000018  6028              STR      r0,[r5,#0]
;;;521      if (*name)  /* is a local? */
00001a  6828              LDR      r0,[r5,#0]
00001c  b110              CBZ      r0,|L14.36|
;;;522        return "local";
00001e  a052              ADR      r0,|L14.360|
                  |L14.32|
;;;523      /* else try symbolic execution */
;;;524      pc = findsetreg(p, lastpc, reg);
;;;525      if (pc != -1) {  /* could find instruction? */
;;;526        Instruction i = p->code[pc];
;;;527        OpCode op = GET_OPCODE(i);
;;;528        switch (op) {
;;;529          case OP_MOVE: {
;;;530            int b = GETARG_B(i);  /* move from 'b' to 'a' */
;;;531            if (b < GETARG_A(i))
;;;532              return getobjname(p, pc, b, name);  /* get name for 'b' */
;;;533            break;
;;;534          }
;;;535          case OP_GETTABUP: {
;;;536            int k = GETARG_C(i);  /* key index */
;;;537            kname(p, k, name);
;;;538            return gxf(p, pc, i, 1);
;;;539          }
;;;540          case OP_GETTABLE: {
;;;541            int k = GETARG_C(i);  /* key index */
;;;542            rname(p, pc, k, name);
;;;543            return gxf(p, pc, i, 0);
;;;544          }
;;;545          case OP_GETI: {
;;;546            *name = "integer index";
;;;547            return "field";
;;;548          }
;;;549          case OP_GETFIELD: {
;;;550            int k = GETARG_C(i);  /* key index */
;;;551            kname(p, k, name);
;;;552            return gxf(p, pc, i, 0);
;;;553          }
;;;554          case OP_GETUPVAL: {
;;;555            *name = upvalname(p, GETARG_B(i));
;;;556            return "upvalue";
;;;557          }
;;;558          case OP_LOADK:
;;;559          case OP_LOADKX: {
;;;560            int b = (op == OP_LOADK) ? GETARG_Bx(i)
;;;561                                     : GETARG_Ax(p->code[pc + 1]);
;;;562            if (ttisstring(&p->k[b])) {
;;;563              *name = svalue(&p->k[b]);
;;;564              return "constant";
;;;565            }
;;;566            break;
;;;567          }
;;;568          case OP_SELF: {
;;;569            rkname(p, pc, i, name);
;;;570            return "method";
;;;571          }
;;;572          default: break;  /* go through to return NULL */
;;;573        }
;;;574      }
;;;575      return NULL;  /* could not find reasonable name */
;;;576    }
000020  e8bd9ff0          POP      {r4-r12,pc}
                  |L14.36|
000024  464a              MOV      r2,r9                 ;524
000026  4641              MOV      r1,r8                 ;524
000028  4638              MOV      r0,r7                 ;524
00002a  f7fffffe          BL       findsetreg
00002e  4606              MOV      r6,r0                 ;524
000030  1c70              ADDS     r0,r6,#1              ;525
000032  2800              CMP      r0,#0                 ;525
000034  d06f              BEQ      |L14.278|
000036  6bb8              LDR      r0,[r7,#0x38]         ;526
000038  f8504026          LDR      r4,[r0,r6,LSL #2]     ;526
00003c  f0040a7f          AND      r10,r4,#0x7f          ;527
000040  f1ba0f09          CMP      r10,#9                ;528
000044  d028              BEQ      |L14.152|
000046  dc0c              BGT      |L14.98|
000048  f1ba0f00          CMP      r10,#0                ;528
00004c  d016              BEQ      |L14.124|
00004e  f1ba0f03          CMP      r10,#3                ;528
000052  d058              BEQ      |L14.262|
000054  f1ba0f04          CMP      r10,#4                ;528
000058  d056              BEQ      |L14.264|
00005a  f1ba0f07          CMP      r10,#7                ;528
00005e  d17e              BNE      |L14.350|
000060  e049              B        |L14.246|
                  |L14.98|
000062  f1ba0f0a          CMP      r10,#0xa              ;528
000066  d025              BEQ      |L14.180|
000068  f1ba0f0b          CMP      r10,#0xb              ;528
00006c  d031              BEQ      |L14.210|
00006e  f1ba0f0c          CMP      r10,#0xc              ;528
000072  d032              BEQ      |L14.218|
000074  f1ba0f12          CMP      r10,#0x12             ;528
000078  d171              BNE      |L14.350|
00007a  e068              B        |L14.334|
                  |L14.124|
00007c  f3c44b07          UBFX     r11,r4,#16,#8         ;530
000080  f3c410c7          UBFX     r0,r4,#7,#8           ;531
000084  4583              CMP      r11,r0                ;531
000086  da06              BGE      |L14.150|
000088  462b              MOV      r3,r5                 ;532
00008a  465a              MOV      r2,r11                ;532
00008c  4631              MOV      r1,r6                 ;532
00008e  4638              MOV      r0,r7                 ;532
000090  f7fffffe          BL       getobjname
000094  e7c4              B        |L14.32|
                  |L14.150|
000096  e063              B        |L14.352|
                  |L14.152|
000098  ea4f6b14          LSR      r11,r4,#24            ;536
00009c  462a              MOV      r2,r5                 ;537
00009e  4659              MOV      r1,r11                ;537
0000a0  4638              MOV      r0,r7                 ;537
0000a2  f7fffffe          BL       kname
0000a6  2301              MOVS     r3,#1                 ;538
0000a8  4622              MOV      r2,r4                 ;538
0000aa  4631              MOV      r1,r6                 ;538
0000ac  4638              MOV      r0,r7                 ;538
0000ae  f7fffffe          BL       gxf
0000b2  e7b5              B        |L14.32|
                  |L14.180|
0000b4  ea4f6b14          LSR      r11,r4,#24            ;541
0000b8  462b              MOV      r3,r5                 ;542
0000ba  465a              MOV      r2,r11                ;542
0000bc  4631              MOV      r1,r6                 ;542
0000be  4638              MOV      r0,r7                 ;542
0000c0  f7fffffe          BL       rname
0000c4  2300              MOVS     r3,#0                 ;543
0000c6  4622              MOV      r2,r4                 ;543
0000c8  4631              MOV      r1,r6                 ;543
0000ca  4638              MOV      r0,r7                 ;543
0000cc  f7fffffe          BL       gxf
0000d0  e7a6              B        |L14.32|
                  |L14.210|
0000d2  a027              ADR      r0,|L14.368|
0000d4  6028              STR      r0,[r5,#0]            ;546
0000d6  a02a              ADR      r0,|L14.384|
0000d8  e7a2              B        |L14.32|
                  |L14.218|
0000da  ea4f6b14          LSR      r11,r4,#24            ;550
0000de  462a              MOV      r2,r5                 ;551
0000e0  4659              MOV      r1,r11                ;551
0000e2  4638              MOV      r0,r7                 ;551
0000e4  f7fffffe          BL       kname
0000e8  2300              MOVS     r3,#0                 ;552
0000ea  4622              MOV      r2,r4                 ;552
0000ec  4631              MOV      r1,r6                 ;552
0000ee  4638              MOV      r0,r7                 ;552
0000f0  f7fffffe          BL       gxf
0000f4  e794              B        |L14.32|
                  |L14.246|
0000f6  f3c44107          UBFX     r1,r4,#16,#8          ;555
0000fa  4638              MOV      r0,r7                 ;555
0000fc  f7fffffe          BL       upvalname
000100  6028              STR      r0,[r5,#0]            ;555
000102  a021              ADR      r0,|L14.392|
000104  e78c              B        |L14.32|
                  |L14.262|
000106  bf00              NOP                            ;559
                  |L14.264|
000108  f1ba0f03          CMP      r10,#3                ;560
00010c  d104              BNE      |L14.280|
00010e  4820              LDR      r0,|L14.400|
000110  ea0030d4          AND      r0,r0,r4,LSR #15      ;560
000114  e008              B        |L14.296|
                  |L14.278|
000116  e025              B        |L14.356|
                  |L14.280|
000118  1c70              ADDS     r0,r6,#1              ;561
00011a  6bba              LDR      r2,[r7,#0x38]         ;561
00011c  f8520020          LDR      r0,[r2,r0,LSL #2]     ;561
000120  f06f427e          MVN      r2,#0xfe000000        ;561
000124  ea0210d0          AND      r0,r2,r0,LSR #7       ;561
                  |L14.296|
000128  4601              MOV      r1,r0                 ;561
00012a  6b38              LDR      r0,[r7,#0x30]         ;562
00012c  eb001001          ADD      r0,r0,r1,LSL #4       ;562
000130  7a00              LDRB     r0,[r0,#8]            ;562
000132  f000000f          AND      r0,r0,#0xf            ;562
000136  2804              CMP      r0,#4                 ;562
000138  d108              BNE      |L14.332|
00013a  6b38              LDR      r0,[r7,#0x30]         ;563
00013c  eb001001          ADD      r0,r0,r1,LSL #4       ;563
000140  6800              LDR      r0,[r0,#0]            ;563
000142  3010              ADDS     r0,r0,#0x10           ;563
000144  6028              STR      r0,[r5,#0]            ;563
000146  a013              ADR      r0,|L14.404|
000148  e76a              B        |L14.32|
00014a  e008              B        |L14.350|
                  |L14.332|
00014c  e008              B        |L14.352|
                  |L14.334|
00014e  462b              MOV      r3,r5                 ;569
000150  4622              MOV      r2,r4                 ;569
000152  4631              MOV      r1,r6                 ;569
000154  4638              MOV      r0,r7                 ;569
000156  f7fffffe          BL       rkname
00015a  a011              ADR      r0,|L14.416|
00015c  e760              B        |L14.32|
                  |L14.350|
00015e  bf00              NOP                            ;572
                  |L14.352|
000160  bf00              NOP                            ;533
000162  bf00              NOP                            ;574
                  |L14.356|
000164  2000              MOVS     r0,#0                 ;575
000166  e75b              B        |L14.32|
;;;577    
                          ENDP

                  |L14.360|
000168  6c6f6361          DCB      "local",0
00016c  6c00    
00016e  00                DCB      0
00016f  00                DCB      0
                  |L14.368|
000170  696e7465          DCB      "integer index",0
000174  67657220
000178  696e6465
00017c  7800    
00017e  00                DCB      0
00017f  00                DCB      0
                  |L14.384|
000180  6669656c          DCB      "field",0
000184  6400    
000186  00                DCB      0
000187  00                DCB      0
                  |L14.392|
000188  75707661          DCB      "upvalue",0
00018c  6c756500
                  |L14.400|
                          DCD      0x0001ffff
                  |L14.404|
000194  636f6e73          DCB      "constant",0
000198  74616e74
00019c  00      
00019d  00                DCB      0
00019e  00                DCB      0
00019f  00                DCB      0
                  |L14.416|
0001a0  6d657468          DCB      "method",0
0001a4  6f6400  
0001a7  00                DCB      0

                          AREA ||i.getupvalname||, CODE, READONLY, ALIGN=2

                  getupvalname PROC
;;;663    */
;;;664    static const char *getupvalname (CallInfo *ci, const TValue *o,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;665                                     const char **name) {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
;;;666      LClosure *c = ci_func(ci);
00000a  6830              LDR      r0,[r6,#0]
00000c  6805              LDR      r5,[r0,#0]
;;;667      int i;
;;;668      for (i = 0; i < c->nupvalues; i++) {
00000e  2400              MOVS     r4,#0
000010  e010              B        |L15.52|
                  |L15.18|
;;;669        if (c->upvals[i]->v == o) {
000012  f1050010          ADD      r0,r5,#0x10
000016  f8500024          LDR      r0,[r0,r4,LSL #2]
00001a  6880              LDR      r0,[r0,#8]
00001c  42b8              CMP      r0,r7
00001e  d108              BNE      |L15.50|
;;;670          *name = upvalname(c->p, i);
000020  4621              MOV      r1,r4
000022  68e8              LDR      r0,[r5,#0xc]
000024  f7fffffe          BL       upvalname
000028  f8c80000          STR      r0,[r8,#0]
;;;671          return "upvalue";
00002c  a004              ADR      r0,|L15.64|
                  |L15.46|
;;;672        }
;;;673      }
;;;674      return NULL;
;;;675    }
00002e  e8bd81f0          POP      {r4-r8,pc}
                  |L15.50|
000032  1c64              ADDS     r4,r4,#1              ;668
                  |L15.52|
000034  79a8              LDRB     r0,[r5,#6]            ;668
000036  42a0              CMP      r0,r4                 ;668
000038  dceb              BGT      |L15.18|
00003a  2000              MOVS     r0,#0                 ;674
00003c  e7f7              B        |L15.46|
;;;676    
                          ENDP

00003e  0000              DCW      0x0000
                  |L15.64|
000040  75707661          DCB      "upvalue",0
000044  6c756500

                          AREA ||i.gxf||, CODE, READONLY, ALIGN=2

                  gxf PROC
;;;506    */
;;;507    static const char *gxf (Proto *p, int pc, Instruction i, int isup) {
000000  e92d43f8          PUSH     {r3-r9,lr}
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
;;;508      int t = GETARG_B(i);  /* table index */
00000c  f3c44607          UBFX     r6,r4,#16,#8
;;;509      const char *name;  /* name of indexed variable */
;;;510      if (isup)  /* is an upvalue? */
000010  b12d              CBZ      r5,|L16.30|
;;;511        name = upvalname(p, t);
000012  4631              MOV      r1,r6
000014  4638              MOV      r0,r7
000016  f7fffffe          BL       upvalname
00001a  9000              STR      r0,[sp,#0]
00001c  e005              B        |L16.42|
                  |L16.30|
;;;512      else
;;;513        getobjname(p, pc, t, &name);
00001e  466b              MOV      r3,sp
000020  4632              MOV      r2,r6
000022  4641              MOV      r1,r8
000024  4638              MOV      r0,r7
000026  f7fffffe          BL       getobjname
                  |L16.42|
;;;514      return (name && strcmp(name, LUA_ENV) == 0) ? "global" : "field";
00002a  9800              LDR      r0,[sp,#0]
00002c  b138              CBZ      r0,|L16.62|
00002e  a105              ADR      r1,|L16.68|
000030  9800              LDR      r0,[sp,#0]
000032  f7fffffe          BL       strcmp
000036  b910              CBNZ     r0,|L16.62|
000038  a004              ADR      r0,|L16.76|
                  |L16.58|
;;;515    }
00003a  e8bd83f8          POP      {r3-r9,pc}
                  |L16.62|
00003e  a005              ADR      r0,|L16.84|
000040  e7fb              B        |L16.58|
;;;516    
                          ENDP

000042  0000              DCW      0x0000
                  |L16.68|
000044  5f454e56          DCB      "_ENV",0
000048  00      
000049  00                DCB      0
00004a  00                DCB      0
00004b  00                DCB      0
                  |L16.76|
00004c  676c6f62          DCB      "global",0
000050  616c00  
000053  00                DCB      0
                  |L16.84|
000054  6669656c          DCB      "field",0
000058  6400    
00005a  00                DCB      0
00005b  00                DCB      0

                          AREA ||i.isinstack||, CODE, READONLY, ALIGN=1

                  isinstack PROC
;;;651    */
;;;652    static int isinstack (CallInfo *ci, const TValue *o) {
000000  b510              PUSH     {r4,lr}
000002  4602              MOV      r2,r0
;;;653      StkId base = ci->func + 1;
000004  6810              LDR      r0,[r2,#0]
000006  f1000310          ADD      r3,r0,#0x10
;;;654      ptrdiff_t i = cast(StkId, o) - base;
00000a  1ac8              SUBS     r0,r1,r3
00000c  1104              ASRS     r4,r0,#4
;;;655      return (0 <= i && i < (ci->top - base) && s2v(base + i) == o);
00000e  2c00              CMP      r4,#0
000010  db0a              BLT      |L17.40|
000012  6850              LDR      r0,[r2,#4]
000014  1ac0              SUBS     r0,r0,r3
000016  ebb41f20          CMP      r4,r0,ASR #4
00001a  da05              BGE      |L17.40|
00001c  eb031004          ADD      r0,r3,r4,LSL #4
000020  4288              CMP      r0,r1
000022  d101              BNE      |L17.40|
000024  2001              MOVS     r0,#1
                  |L17.38|
;;;656    }
000026  bd10              POP      {r4,pc}
                  |L17.40|
000028  2000              MOVS     r0,#0                 ;655
00002a  e7fc              B        |L17.38|
;;;657    
                          ENDP


                          AREA ||i.kname||, CODE, READONLY, ALIGN=2

                  kname PROC
;;;420    */
;;;421    static void kname (Proto *p, int c, const char **name) {
000000  b510              PUSH     {r4,lr}
;;;422      TValue *kvalue = &p->k[c];
000002  6b04              LDR      r4,[r0,#0x30]
000004  eb041301          ADD      r3,r4,r1,LSL #4
;;;423      *name = (ttisstring(kvalue)) ? svalue(kvalue) : "?";
000008  7a1c              LDRB     r4,[r3,#8]
00000a  f004040f          AND      r4,r4,#0xf
00000e  2c04              CMP      r4,#4
000010  d102              BNE      |L18.24|
000012  681c              LDR      r4,[r3,#0]
000014  3410              ADDS     r4,r4,#0x10
000016  e000              B        |L18.26|
                  |L18.24|
000018  a401              ADR      r4,|L18.32|
                  |L18.26|
00001a  6014              STR      r4,[r2,#0]
;;;424    }
00001c  bd10              POP      {r4,pc}
;;;425    
                          ENDP

00001e  0000              DCW      0x0000
                  |L18.32|
000020  3f00              DCB      "?",0
000022  00                DCB      0
000023  00                DCB      0

                          AREA ||i.luaG_addinfo||, CODE, READONLY, ALIGN=2

                  luaG_addinfo PROC
;;;733    /* add src:line information to 'msg' */
;;;734    const char *luaG_addinfo (lua_State *L, const char *msg, TString *src,
000000  b5f0              PUSH     {r4-r7,lr}
;;;735                                            int line) {
000002  b091              SUB      sp,sp,#0x44
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4614              MOV      r4,r2
00000a  461f              MOV      r7,r3
;;;736      char buff[LUA_IDSIZE];
;;;737      if (src)
00000c  b134              CBZ      r4,|L19.28|
;;;738        luaO_chunkid(buff, getstr(src), LUA_IDSIZE);
00000e  223c              MOVS     r2,#0x3c
000010  f1040110          ADD      r1,r4,#0x10
000014  a802              ADD      r0,sp,#8
000016  f7fffffe          BL       luaO_chunkid
00001a  e005              B        |L19.40|
                  |L19.28|
;;;739      else {  /* no source available; use "?" instead */
;;;740        buff[0] = '?'; buff[1] = '\0';
00001c  203f              MOVS     r0,#0x3f
00001e  f88d0008          STRB     r0,[sp,#8]
000022  2000              MOVS     r0,#0
000024  f88d0009          STRB     r0,[sp,#9]
                  |L19.40|
;;;741      }
;;;742      return luaO_pushfstring(L, "%s:%d: %s", buff, line, msg);
000028  463b              MOV      r3,r7
00002a  aa02              ADD      r2,sp,#8
00002c  a103              ADR      r1,|L19.60|
00002e  4630              MOV      r0,r6
000030  9500              STR      r5,[sp,#0]
000032  f7fffffe          BL       luaO_pushfstring
;;;743    }
000036  b011              ADD      sp,sp,#0x44
000038  bdf0              POP      {r4-r7,pc}
;;;744    
                          ENDP

00003a  0000              DCW      0x0000
                  |L19.60|
00003c  25733a25          DCB      "%s:%d: %s",0
000040  643a2025
000044  7300    
000046  00                DCB      0
000047  00                DCB      0

                          AREA ||i.luaG_concaterror||, CODE, READONLY, ALIGN=2

                  luaG_concaterror PROC
;;;697    
;;;698    l_noret luaG_concaterror (lua_State *L, const TValue *p1, const TValue *p2) {
000000  b570              PUSH     {r4-r6,lr}
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;699      if (ttisstring(p1) || cvt2str(p1)) p1 = p2;
000008  7a20              LDRB     r0,[r4,#8]
00000a  f000000f          AND      r0,r0,#0xf
00000e  2804              CMP      r0,#4
000010  d004              BEQ      |L20.28|
000012  7a20              LDRB     r0,[r4,#8]
000014  f000000f          AND      r0,r0,#0xf
000018  2803              CMP      r0,#3
00001a  d100              BNE      |L20.30|
                  |L20.28|
00001c  462c              MOV      r4,r5
                  |L20.30|
;;;700      luaG_typeerror(L, p1, "concatenate");
00001e  a203              ADR      r2,|L20.44|
000020  4621              MOV      r1,r4
000022  4630              MOV      r0,r6
000024  f7fffffe          BL       luaG_typeerror
;;;701    }
000028  bd70              POP      {r4-r6,pc}
;;;702    
                          ENDP

00002a  0000              DCW      0x0000
                  |L20.44|
00002c  636f6e63          DCB      "concatenate",0
000030  6174656e
000034  61746500

                          AREA ||i.luaG_errormsg||, CODE, READONLY, ALIGN=1

                  luaG_errormsg PROC
;;;745    
;;;746    l_noret luaG_errormsg (lua_State *L) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;747      if (L->errfunc != 0) {  /* is there an error handling function? */
000004  6de0              LDR      r0,[r4,#0x5c]
000006  b308              CBZ      r0,|L21.76|
;;;748        StkId errfunc = restorestack(L, L->errfunc);
000008  6de1              LDR      r1,[r4,#0x5c]
00000a  6a20              LDR      r0,[r4,#0x20]
00000c  1845              ADDS     r5,r0,r1
;;;749        lua_assert(ttisfunction(s2v(errfunc)));
;;;750        setobjs2s(L, L->top, L->top - 1);  /* move argument */
00000e  68e0              LDR      r0,[r4,#0xc]
000010  68e2              LDR      r2,[r4,#0xc]
000012  f1a20110          SUB      r1,r2,#0x10
000016  e9d12300          LDRD     r2,r3,[r1,#0]
00001a  e9c02300          STRD     r2,r3,[r0,#0]
00001e  7a0a              LDRB     r2,[r1,#8]
000020  7202              STRB     r2,[r0,#8]
;;;751        setobjs2s(L, L->top - 1, errfunc);  /* push function */
000022  68e2              LDR      r2,[r4,#0xc]
000024  f1a20010          SUB      r0,r2,#0x10
000028  4629              MOV      r1,r5
00002a  e9d12300          LDRD     r2,r3,[r1,#0]
00002e  e9c02300          STRD     r2,r3,[r0,#0]
000032  7a0a              LDRB     r2,[r1,#8]
000034  7202              STRB     r2,[r0,#8]
;;;752        L->top++;  /* assume EXTRA_STACK */
000036  68e0              LDR      r0,[r4,#0xc]
000038  3010              ADDS     r0,r0,#0x10
00003a  60e0              STR      r0,[r4,#0xc]
;;;753        luaD_callnoyield(L, L->top - 2, 1);  /* call it */
00003c  68e0              LDR      r0,[r4,#0xc]
00003e  f1a00120          SUB      r1,r0,#0x20
000042  2201              MOVS     r2,#1
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       luaD_callnoyield
;;;754      }
00004a  bf00              NOP      
                  |L21.76|
;;;755      luaD_throw(L, LUA_ERRRUN);
00004c  2102              MOVS     r1,#2
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       luaD_throw
;;;756    }
000054  bd70              POP      {r4-r6,pc}
;;;757    
                          ENDP


                          AREA ||i.luaG_getfuncline||, CODE, READONLY, ALIGN=1

                  luaG_getfuncline PROC
;;;88     */
;;;89     int luaG_getfuncline (Proto *f, int pc) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;90       if (f->lineinfo == NULL)  /* no debug information? */
000006  6c60              LDR      r0,[r4,#0x44]
000008  b910              CBNZ     r0,|L22.16|
;;;91         return -1;
00000a  f04f30ff          MOV      r0,#0xffffffff
                  |L22.14|
;;;92       else {
;;;93         int basepc;
;;;94         int baseline = getbaseline(f, pc, &basepc);
;;;95         while (basepc++ < pc) {  /* walk until given instruction */
;;;96           lua_assert(f->lineinfo[basepc] != ABSLINEINFO);
;;;97           baseline += f->lineinfo[basepc];  /* correct line */
;;;98         }
;;;99         return baseline;
;;;100      }
;;;101    }
00000e  bdf8              POP      {r3-r7,pc}
                  |L22.16|
000010  466a              MOV      r2,sp                 ;94
000012  4629              MOV      r1,r5                 ;94
000014  4620              MOV      r0,r4                 ;94
000016  f7fffffe          BL       getbaseline
00001a  4606              MOV      r6,r0                 ;94
00001c  e003              B        |L22.38|
                  |L22.30|
00001e  6c60              LDR      r0,[r4,#0x44]         ;97
000020  9900              LDR      r1,[sp,#0]            ;97
000022  5640              LDRSB    r0,[r0,r1]            ;97
000024  4406              ADD      r6,r6,r0              ;97
                  |L22.38|
000026  9900              LDR      r1,[sp,#0]            ;95
000028  1c48              ADDS     r0,r1,#1              ;95
00002a  9000              STR      r0,[sp,#0]            ;95
00002c  42a9              CMP      r1,r5                 ;95
00002e  dbf6              BLT      |L22.30|
000030  4630              MOV      r0,r6                 ;99
000032  e7ec              B        |L22.14|
;;;102    
                          ENDP


                          AREA ||i.luaG_opinterror||, CODE, READONLY, ALIGN=1

                  luaG_opinterror PROC
;;;703    
;;;704    l_noret luaG_opinterror (lua_State *L, const TValue *p1,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;705                             const TValue *p2, const char *msg) {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
;;;706      if (!ttisnumber(p1))  /* first operand is wrong? */
00000c  7a20              LDRB     r0,[r4,#8]
00000e  f000000f          AND      r0,r0,#0xf
000012  2803              CMP      r0,#3
000014  d000              BEQ      |L23.24|
;;;707        p2 = p1;  /* now second is wrong */
000016  4625              MOV      r5,r4
                  |L23.24|
;;;708      luaG_typeerror(L, p2, msg);
000018  4632              MOV      r2,r6
00001a  4629              MOV      r1,r5
00001c  4638              MOV      r0,r7
00001e  f7fffffe          BL       luaG_typeerror
;;;709    }
000022  e8bd81f0          POP      {r4-r8,pc}
;;;710    
                          ENDP


                          AREA ||i.luaG_ordererror||, CODE, READONLY, ALIGN=2

                  luaG_ordererror PROC
;;;722    
;;;723    l_noret luaG_ordererror (lua_State *L, const TValue *p1, const TValue *p2) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;724      const char *t1 = luaT_objtypename(L, p1);
00000a  4631              MOV      r1,r6
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       luaT_objtypename
000012  4607              MOV      r7,r0
;;;725      const char *t2 = luaT_objtypename(L, p2);
000014  4621              MOV      r1,r4
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       luaT_objtypename
00001c  4680              MOV      r8,r0
;;;726      if (strcmp(t1, t2) == 0)
00001e  4641              MOV      r1,r8
000020  4638              MOV      r0,r7
000022  f7fffffe          BL       strcmp
000026  b928              CBNZ     r0,|L24.52|
;;;727        luaG_runerror(L, "attempt to compare two %s values", t1);
000028  463a              MOV      r2,r7
00002a  a106              ADR      r1,|L24.68|
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       luaG_runerror
000032  e005              B        |L24.64|
                  |L24.52|
;;;728      else
;;;729        luaG_runerror(L, "attempt to compare %s with %s", t1, t2);
000034  4643              MOV      r3,r8
000036  463a              MOV      r2,r7
000038  a10b              ADR      r1,|L24.104|
00003a  4628              MOV      r0,r5
00003c  f7fffffe          BL       luaG_runerror
                  |L24.64|
;;;730    }
000040  e8bd81f0          POP      {r4-r8,pc}
;;;731    
                          ENDP

                  |L24.68|
000044  61747465          DCB      "attempt to compare two %s values",0
000048  6d707420
00004c  746f2063
000050  6f6d7061
000054  72652074
000058  776f2025
00005c  73207661
000060  6c756573
000064  00      
000065  00                DCB      0
000066  00                DCB      0
000067  00                DCB      0
                  |L24.104|
000068  61747465          DCB      "attempt to compare %s with %s",0
00006c  6d707420
000070  746f2063
000074  6f6d7061
000078  72652025
00007c  73207769
000080  74682025
000084  7300    
000086  00                DCB      0
000087  00                DCB      0

                          AREA ||i.luaG_runerror||, CODE, READONLY, ALIGN=1

                  luaG_runerror PROC
;;;758    
;;;759    l_noret luaG_runerror (lua_State *L, const char *fmt, ...) {
000000  b40f              PUSH     {r0-r3}
000002  b5f8              PUSH     {r3-r7,lr}
000004  4604              MOV      r4,r0
;;;760      CallInfo *ci = L->ci;
000006  6965              LDR      r5,[r4,#0x14]
;;;761      const char *msg;
;;;762      va_list argp;
;;;763      luaC_checkGC(L);  /* error message uses memory */
000008  6920              LDR      r0,[r4,#0x10]
00000a  68c0              LDR      r0,[r0,#0xc]
00000c  2800              CMP      r0,#0
00000e  dd03              BLE      |L25.24|
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       luaC_step
000016  bf00              NOP      
                  |L25.24|
;;;764      va_start(argp, fmt);
000018  a808              ADD      r0,sp,#0x20
00001a  9000              STR      r0,[sp,#0]
;;;765      msg = luaO_pushvfstring(L, fmt, argp);  /* format message */
00001c  4620              MOV      r0,r4
00001e  9a00              LDR      r2,[sp,#0]
000020  9907              LDR      r1,[sp,#0x1c]
000022  f7fffffe          BL       luaO_pushvfstring
000026  4606              MOV      r6,r0
;;;766      va_end(argp);
000028  2000              MOVS     r0,#0
00002a  9000              STR      r0,[sp,#0]
;;;767      if (isLua(ci))  /* if Lua function, add source:line information */
00002c  f8950022          LDRB     r0,[r5,#0x22]
000030  f0000002          AND      r0,r0,#2
000034  b960              CBNZ     r0,|L25.80|
;;;768        luaG_addinfo(L, msg, ci_func(ci)->p->source, currentline(ci));
000036  4628              MOV      r0,r5
000038  f7fffffe          BL       currentline
00003c  4607              MOV      r7,r0
00003e  6828              LDR      r0,[r5,#0]
000040  6800              LDR      r0,[r0,#0]
000042  68c0              LDR      r0,[r0,#0xc]
000044  463b              MOV      r3,r7
000046  4631              MOV      r1,r6
000048  6d02              LDR      r2,[r0,#0x50]
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       luaG_addinfo
                  |L25.80|
;;;769      luaG_errormsg(L);
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       luaG_errormsg
;;;770    }
000056  bcf8              POP      {r3-r7}
000058  f85dfb14          LDR      pc,[sp],#0x14
;;;771    
                          ENDP


                          AREA ||i.luaG_tointerror||, CODE, READONLY, ALIGN=2

                  luaG_tointerror PROC
;;;714    */
;;;715    l_noret luaG_tointerror (lua_State *L, const TValue *p1, const TValue *p2) {
000000  e92d41fc          PUSH     {r2-r8,lr}
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;716      lua_Integer temp;
;;;717      if (!tointegerns(p1, &temp))
00000a  7a20              LDRB     r0,[r4,#8]
00000c  2823              CMP      r0,#0x23
00000e  d105              BNE      |L26.28|
000010  e9d40100          LDRD     r0,r1,[r4,#0]
000014  e9cd0100          STRD     r0,r1,[sp,#0]
000018  2001              MOVS     r0,#1
00001a  e004              B        |L26.38|
                  |L26.28|
00001c  2200              MOVS     r2,#0
00001e  4669              MOV      r1,sp
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       luaV_tointegerns
                  |L26.38|
000026  b900              CBNZ     r0,|L26.42|
;;;718        p2 = p1;
000028  4625              MOV      r5,r4
                  |L26.42|
;;;719      luaG_runerror(L, "number%s has no integer representation", varinfo(L, p2));
00002a  4629              MOV      r1,r5
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       varinfo
000032  4607              MOV      r7,r0
000034  463a              MOV      r2,r7
000036  a103              ADR      r1,|L26.68|
000038  4630              MOV      r0,r6
00003a  f7fffffe          BL       luaG_runerror
;;;720    }
00003e  e8bd81fc          POP      {r2-r8,pc}
;;;721    
                          ENDP

000042  0000              DCW      0x0000
                  |L26.68|
000044  6e756d62          DCB      "number%s has no integer representation",0
000048  65722573
00004c  20686173
000050  206e6f20
000054  696e7465
000058  67657220
00005c  72657072
000060  6573656e
000064  74617469
000068  6f6e00  
00006b  00                DCB      0

                          AREA ||i.luaG_traceexec||, CODE, READONLY, ALIGN=2

                  luaG_traceexec PROC
;;;785    
;;;786    void luaG_traceexec (lua_State *L) {
000000  e92d4ff8          PUSH     {r3-r11,lr}
000004  4604              MOV      r4,r0
;;;787      CallInfo *ci = L->ci;
000006  6965              LDR      r5,[r4,#0x14]
;;;788      lu_byte mask = L->hookmask;
000008  f8946070          LDRB     r6,[r4,#0x70]
;;;789      int counthook = (--L->hookcount == 0 && (mask & LUA_MASKCOUNT));
00000c  6ea0              LDR      r0,[r4,#0x68]
00000e  1e40              SUBS     r0,r0,#1
000010  66a0              STR      r0,[r4,#0x68]
000012  b920              CBNZ     r0,|L27.30|
000014  f0060008          AND      r0,r6,#8
000018  b108              CBZ      r0,|L27.30|
00001a  2001              MOVS     r0,#1
00001c  e000              B        |L27.32|
                  |L27.30|
00001e  2000              MOVS     r0,#0
                  |L27.32|
000020  4607              MOV      r7,r0
;;;790      if (counthook)
000022  b117              CBZ      r7,|L27.42|
;;;791        resethookcount(L);  /* reset count */
000024  6e60              LDR      r0,[r4,#0x64]
000026  66a0              STR      r0,[r4,#0x68]
000028  e004              B        |L27.52|
                  |L27.42|
;;;792      else if (!(mask & LUA_MASKLINE))
00002a  f0060004          AND      r0,r6,#4
00002e  b908              CBNZ     r0,|L27.52|
                  |L27.48|
;;;793        return;  /* no line hook and count != 0; nothing to be done */
;;;794      if (ci->callstatus & CIST_HOOKYIELD) {  /* called hook last time? */
;;;795        ci->callstatus &= ~CIST_HOOKYIELD;  /* erase mark */
;;;796        return;  /* do not call hook again (VM yielded, so it did not move) */
;;;797      }
;;;798      if (!isIT(*(ci->u.l.savedpc - 1)))
;;;799        L->top = ci->top;  /* prepare top */
;;;800      if (counthook)
;;;801        luaD_hook(L, LUA_HOOKCOUNT, -1, 0, 0);  /* call count hook */
;;;802      if (mask & LUA_MASKLINE) {
;;;803        Proto *p = ci_func(ci)->p;
;;;804        const Instruction *npc = ci->u.l.savedpc;
;;;805        int npci = pcRel(npc, p);
;;;806        if (npci == 0 ||  /* call linehook when enter a new function, */
;;;807            npc <= L->oldpc ||  /* when jump back (loop), or when */
;;;808            changedline(p, pcRel(L->oldpc, p), npci)) {  /* enter new line */
;;;809          int newline = luaG_getfuncline(p, npci);  /* new line */
;;;810          luaD_hook(L, LUA_HOOKLINE, newline, 0, 0);  /* call line hook */
;;;811        }
;;;812        L->oldpc = npc;
;;;813      }
;;;814      if (L->status == LUA_YIELD) {  /* did hook yield? */
;;;815        if (counthook)
;;;816          L->hookcount = 1;  /* undo decrement to zero */
;;;817        ci->u.l.savedpc--;  /* undo increment (resume will increment it again) */
;;;818        ci->callstatus |= CIST_HOOKYIELD;  /* mark that it yielded */
;;;819        luaD_throw(L, LUA_YIELD);
;;;820      }
;;;821    }
000030  e8bd8ff8          POP      {r3-r11,pc}
                  |L27.52|
000034  f8950022          LDRB     r0,[r5,#0x22]         ;794
000038  f0000020          AND      r0,r0,#0x20           ;794
00003c  b120              CBZ      r0,|L27.72|
00003e  8c68              LDRH     r0,[r5,#0x22]         ;795
000040  f0200020          BIC      r0,r0,#0x20           ;795
000044  8468              STRH     r0,[r5,#0x22]         ;795
000046  e7f3              B        |L27.48|
                  |L27.72|
000048  6928              LDR      r0,[r5,#0x10]         ;798
00004a  f8100c04          LDRB     r0,[r0,#-4]           ;798
00004e  f000007f          AND      r0,r0,#0x7f           ;798
000052  492d              LDR      r1,|L27.264|
000054  5c08              LDRB     r0,[r1,r0]            ;798
000056  f0000020          AND      r0,r0,#0x20           ;798
00005a  b128              CBZ      r0,|L27.104|
00005c  6928              LDR      r0,[r5,#0x10]         ;798
00005e  f8500c04          LDR      r0,[r0,#-4]           ;798
000062  f3c04007          UBFX     r0,r0,#16,#8          ;798
000066  b108              CBZ      r0,|L27.108|
                  |L27.104|
000068  6868              LDR      r0,[r5,#4]            ;799
00006a  60e0              STR      r0,[r4,#0xc]          ;799
                  |L27.108|
00006c  b13f              CBZ      r7,|L27.126|
00006e  2000              MOVS     r0,#0                 ;801
000070  4603              MOV      r3,r0                 ;801
000072  1e42              SUBS     r2,r0,#1              ;801
000074  2103              MOVS     r1,#3                 ;801
000076  9000              STR      r0,[sp,#0]            ;801
000078  4620              MOV      r0,r4                 ;801
00007a  f7fffffe          BL       luaD_hook
                  |L27.126|
00007e  f0060004          AND      r0,r6,#4              ;802
000082  b378              CBZ      r0,|L27.228|
000084  6828              LDR      r0,[r5,#0]            ;803
000086  6800              LDR      r0,[r0,#0]            ;803
000088  f8d0800c          LDR      r8,[r0,#0xc]          ;803
00008c  f8d59010          LDR      r9,[r5,#0x10]         ;804
000090  f8d80038          LDR      r0,[r8,#0x38]         ;805
000094  eba90000          SUB      r0,r9,r0              ;805
000098  2101              MOVS     r1,#1                 ;805
00009a  ebc10aa0          RSB      r10,r1,r0,ASR #2      ;805
00009e  f1ba0f00          CMP      r10,#0                ;806
0000a2  d00e              BEQ      |L27.194|
0000a4  69a0              LDR      r0,[r4,#0x18]         ;807
0000a6  4548              CMP      r0,r9                 ;807
0000a8  d20b              BCS      |L27.194|
0000aa  69a0              LDR      r0,[r4,#0x18]         ;808
0000ac  f8d82038          LDR      r2,[r8,#0x38]         ;808
0000b0  1a80              SUBS     r0,r0,r2              ;808
0000b2  2201              MOVS     r2,#1                 ;808
0000b4  ebc201a0          RSB      r1,r2,r0,ASR #2       ;808
0000b8  4652              MOV      r2,r10                ;808
0000ba  4640              MOV      r0,r8                 ;808
0000bc  f7fffffe          BL       changedline
0000c0  b168              CBZ      r0,|L27.222|
                  |L27.194|
0000c2  4651              MOV      r1,r10                ;809
0000c4  4640              MOV      r0,r8                 ;809
0000c6  f7fffffe          BL       luaG_getfuncline
0000ca  4683              MOV      r11,r0                ;809
0000cc  2000              MOVS     r0,#0                 ;810
0000ce  4603              MOV      r3,r0                 ;810
0000d0  465a              MOV      r2,r11                ;810
0000d2  2102              MOVS     r1,#2                 ;810
0000d4  9000              STR      r0,[sp,#0]            ;810
0000d6  4620              MOV      r0,r4                 ;810
0000d8  f7fffffe          BL       luaD_hook
0000dc  bf00              NOP                            ;811
                  |L27.222|
0000de  f8c49018          STR      r9,[r4,#0x18]         ;812
0000e2  bf00              NOP                            ;813
                  |L27.228|
0000e4  7a20              LDRB     r0,[r4,#8]            ;814
0000e6  2801              CMP      r0,#1                 ;814
0000e8  d10c              BNE      |L27.260|
0000ea  b107              CBZ      r7,|L27.238|
0000ec  66a0              STR      r0,[r4,#0x68]         ;816
                  |L27.238|
0000ee  6928              LDR      r0,[r5,#0x10]         ;817
0000f0  1f00              SUBS     r0,r0,#4              ;817
0000f2  6128              STR      r0,[r5,#0x10]         ;817
0000f4  8c68              LDRH     r0,[r5,#0x22]         ;818
0000f6  f0400020          ORR      r0,r0,#0x20           ;818
0000fa  8468              STRH     r0,[r5,#0x22]         ;818
0000fc  2101              MOVS     r1,#1                 ;819
0000fe  4620              MOV      r0,r4                 ;819
000100  f7fffffe          BL       luaD_throw
                  |L27.260|
000104  bf00              NOP      
000106  e793              B        |L27.48|
;;;822    
                          ENDP

                  |L27.264|
                          DCD      luaP_opmodes

                          AREA ||i.luaG_typeerror||, CODE, READONLY, ALIGN=2

                  luaG_typeerror PROC
;;;691    
;;;692    l_noret luaG_typeerror (lua_State *L, const TValue *o, const char *op) {
000000  e92d43f8          PUSH     {r3-r9,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;693      const char *t = luaT_objtypename(L, o);
00000a  4629              MOV      r1,r5
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       luaT_objtypename
000012  4680              MOV      r8,r0
;;;694      luaG_runerror(L, "attempt to %s a %s value%s", op, t, varinfo(L, o));
000014  4629              MOV      r1,r5
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       varinfo
00001c  4607              MOV      r7,r0
00001e  4643              MOV      r3,r8
000020  4632              MOV      r2,r6
000022  a103              ADR      r1,|L28.48|
000024  9000              STR      r0,[sp,#0]
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       luaG_runerror
;;;695    }
00002c  e8bd83f8          POP      {r3-r9,pc}
;;;696    
                          ENDP

                  |L28.48|
000030  61747465          DCB      "attempt to %s a %s value%s",0
000034  6d707420
000038  746f2025
00003c  73206120
000040  25732076
000044  616c7565
000048  257300  
00004b  00                DCB      0

                          AREA ||i.lua_gethook||, CODE, READONLY, ALIGN=1

                  lua_gethook PROC
;;;150    
;;;151    LUA_API lua_Hook lua_gethook (lua_State *L) {
000000  4601              MOV      r1,r0
;;;152      return L->hook;
000002  6d88              LDR      r0,[r1,#0x58]
;;;153    }
000004  4770              BX       lr
;;;154    
                          ENDP


                          AREA ||i.lua_gethookcount||, CODE, READONLY, ALIGN=1

                  lua_gethookcount PROC
;;;160    
;;;161    LUA_API int lua_gethookcount (lua_State *L) {
000000  4601              MOV      r1,r0
;;;162      return L->basehookcount;
000002  6e48              LDR      r0,[r1,#0x64]
;;;163    }
000004  4770              BX       lr
;;;164    
                          ENDP


                          AREA ||i.lua_gethookmask||, CODE, READONLY, ALIGN=1

                  lua_gethookmask PROC
;;;155    
;;;156    LUA_API int lua_gethookmask (lua_State *L) {
000000  4601              MOV      r1,r0
;;;157      return L->hookmask;
000002  6f08              LDR      r0,[r1,#0x70]
;;;158    }
000004  4770              BX       lr
;;;159    
                          ENDP


                          AREA ||i.lua_getinfo||, CODE, READONLY, ALIGN=1

                  lua_getinfo PROC
;;;376    
;;;377    LUA_API int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar) {
000000  e92d4ff8          PUSH     {r3-r11,lr}
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4690              MOV      r8,r2
;;;378      int status;
;;;379      Closure *cl;
;;;380      CallInfo *ci;
;;;381      TValue *func;
;;;382      lua_lock(L);
;;;383      if (*what == '>') {
00000a  7830              LDRB     r0,[r6,#0]
00000c  283e              CMP      r0,#0x3e
00000e  d108              BNE      |L32.34|
;;;384        ci = NULL;
000010  2700              MOVS     r7,#0
;;;385        func = s2v(L->top - 1);
000012  68e0              LDR      r0,[r4,#0xc]
000014  f1a00510          SUB      r5,r0,#0x10
;;;386        api_check(L, ttisfunction(func), "function expected");
;;;387        what++;  /* skip the '>' */
000018  1c76              ADDS     r6,r6,#1
;;;388        L->top--;  /* pop function */
00001a  68e0              LDR      r0,[r4,#0xc]
00001c  3810              SUBS     r0,r0,#0x10
00001e  60e0              STR      r0,[r4,#0xc]
000020  e003              B        |L32.42|
                  |L32.34|
;;;389      }
;;;390      else {
;;;391        ci = ar->i_ci;
000022  f8d87064          LDR      r7,[r8,#0x64]
;;;392        func = s2v(ci->func);
000026  683d              LDR      r5,[r7,#0]
;;;393        lua_assert(ttisfunction(func));
000028  bf00              NOP      
                  |L32.42|
;;;394      }
;;;395      cl = ttisclosure(func) ? clvalue(func) : NULL;
00002a  7a28              LDRB     r0,[r5,#8]
00002c  f000001f          AND      r0,r0,#0x1f
000030  2816              CMP      r0,#0x16
000032  d101              BNE      |L32.56|
000034  6828              LDR      r0,[r5,#0]
000036  e000              B        |L32.58|
                  |L32.56|
000038  2000              MOVS     r0,#0
                  |L32.58|
00003a  4682              MOV      r10,r0
;;;396      status = auxgetinfo(L, what, ar, cl, ci);
00003c  4653              MOV      r3,r10
00003e  4642              MOV      r2,r8
000040  4631              MOV      r1,r6
000042  4620              MOV      r0,r4
000044  9700              STR      r7,[sp,#0]
000046  f7fffffe          BL       auxgetinfo
00004a  4681              MOV      r9,r0
;;;397      if (strchr(what, 'f')) {
00004c  2166              MOVS     r1,#0x66
00004e  4630              MOV      r0,r6
000050  f7fffffe          BL       strchr
000054  b158              CBZ      r0,|L32.110|
;;;398        setobj2s(L, L->top, func);
000056  68e0              LDR      r0,[r4,#0xc]
000058  4629              MOV      r1,r5
00005a  e9d12300          LDRD     r2,r3,[r1,#0]
00005e  e9c02300          STRD     r2,r3,[r0,#0]
000062  7a0a              LDRB     r2,[r1,#8]
000064  7202              STRB     r2,[r0,#8]
;;;399        api_incr_top(L);
000066  68e0              LDR      r0,[r4,#0xc]
000068  3010              ADDS     r0,r0,#0x10
00006a  60e0              STR      r0,[r4,#0xc]
00006c  bf00              NOP      
                  |L32.110|
;;;400      }
;;;401      if (strchr(what, 'L'))
00006e  214c              MOVS     r1,#0x4c
000070  4630              MOV      r0,r6
000072  f7fffffe          BL       strchr
000076  b118              CBZ      r0,|L32.128|
;;;402        collectvalidlines(L, cl);
000078  4651              MOV      r1,r10
00007a  4620              MOV      r0,r4
00007c  f7fffffe          BL       collectvalidlines
                  |L32.128|
;;;403      lua_unlock(L);
;;;404      return status;
000080  4648              MOV      r0,r9
;;;405    }
000082  e8bd8ff8          POP      {r3-r11,pc}
;;;406    
                          ENDP


                          AREA ||i.lua_getlocal||, CODE, READONLY, ALIGN=1

                  lua_getlocal PROC
;;;223    
;;;224    LUA_API const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;225      const char *name;
;;;226      lua_lock(L);
;;;227      if (ar == NULL) {  /* information about non-active function? */
000008  b986              CBNZ     r6,|L33.44|
;;;228        if (!isLfunction(s2v(L->top - 1)))  /* not a Lua function? */
00000a  68e0              LDR      r0,[r4,#0xc]
00000c  f8100c08          LDRB     r0,[r0,#-8]
000010  2856              CMP      r0,#0x56
000012  d001              BEQ      |L33.24|
;;;229          name = NULL;
000014  2500              MOVS     r5,#0
000016  e020              B        |L33.90|
                  |L33.24|
;;;230        else  /* consider live variables at function start (parameters) */
;;;231          name = luaF_getlocalname(clLvalue(s2v(L->top - 1))->p, n, 0);
000018  68e1              LDR      r1,[r4,#0xc]
00001a  f8511c10          LDR      r1,[r1,#-0x10]
00001e  2200              MOVS     r2,#0
000020  68c8              LDR      r0,[r1,#0xc]
000022  4639              MOV      r1,r7
000024  f7fffffe          BL       luaF_getlocalname
000028  4605              MOV      r5,r0
00002a  e016              B        |L33.90|
                  |L33.44|
;;;232      }
;;;233      else {  /* active function; get information through 'ar' */
;;;234        StkId pos = NULL;  /* to avoid warnings */
00002c  2000              MOVS     r0,#0
00002e  9000              STR      r0,[sp,#0]
;;;235        name = findlocal(L, ar->i_ci, n, &pos);
000030  466b              MOV      r3,sp
000032  463a              MOV      r2,r7
000034  4620              MOV      r0,r4
000036  6e71              LDR      r1,[r6,#0x64]
000038  f7fffffe          BL       findlocal
00003c  4605              MOV      r5,r0
;;;236        if (name) {
00003e  b15d              CBZ      r5,|L33.88|
;;;237          setobjs2s(L, L->top, pos);
000040  68e0              LDR      r0,[r4,#0xc]
000042  9900              LDR      r1,[sp,#0]
000044  e9d12300          LDRD     r2,r3,[r1,#0]
000048  e9c02300          STRD     r2,r3,[r0,#0]
00004c  7a0a              LDRB     r2,[r1,#8]
00004e  7202              STRB     r2,[r0,#8]
;;;238          api_incr_top(L);
000050  68e0              LDR      r0,[r4,#0xc]
000052  3010              ADDS     r0,r0,#0x10
000054  60e0              STR      r0,[r4,#0xc]
000056  bf00              NOP      
                  |L33.88|
;;;239        }
;;;240      }
000058  bf00              NOP      
                  |L33.90|
;;;241      lua_unlock(L);
;;;242      return name;
00005a  4628              MOV      r0,r5
;;;243    }
00005c  bdf8              POP      {r3-r7,pc}
;;;244    
                          ENDP


                          AREA ||i.lua_getstack||, CODE, READONLY, ALIGN=1

                  lua_getstack PROC
;;;165    
;;;166    LUA_API int lua_getstack (lua_State *L, int level, lua_Debug *ar) {
000000  b530              PUSH     {r4,r5,lr}
000002  4603              MOV      r3,r0
000004  4615              MOV      r5,r2
;;;167      int status;
;;;168      CallInfo *ci;
;;;169      if (level < 0) return 0;  /* invalid (negative) level */
000006  2900              CMP      r1,#0
000008  da01              BGE      |L34.14|
00000a  2000              MOVS     r0,#0
                  |L34.12|
;;;170      lua_lock(L);
;;;171      for (ci = L->ci; level > 0 && ci != &L->base_ci; ci = ci->previous)
;;;172        level--;
;;;173      if (level == 0 && ci != &L->base_ci) {  /* level found? */
;;;174        status = 1;
;;;175        ar->i_ci = ci;
;;;176      }
;;;177      else status = 0;  /* no such level */
;;;178      lua_unlock(L);
;;;179      return status;
;;;180    }
00000c  bd30              POP      {r4,r5,pc}
                  |L34.14|
00000e  695a              LDR      r2,[r3,#0x14]         ;171
000010  e001              B        |L34.22|
                  |L34.18|
000012  1e49              SUBS     r1,r1,#1              ;172
000014  6892              LDR      r2,[r2,#8]            ;171
                  |L34.22|
000016  2900              CMP      r1,#0                 ;171
000018  dd03              BLE      |L34.34|
00001a  f1030034          ADD      r0,r3,#0x34           ;171
00001e  4282              CMP      r2,r0                 ;171
000020  d1f7              BNE      |L34.18|
                  |L34.34|
000022  b931              CBNZ     r1,|L34.50|
000024  f1030034          ADD      r0,r3,#0x34           ;173
000028  4282              CMP      r2,r0                 ;173
00002a  d002              BEQ      |L34.50|
00002c  2401              MOVS     r4,#1                 ;174
00002e  666a              STR      r2,[r5,#0x64]         ;175
000030  e000              B        |L34.52|
                  |L34.50|
000032  2400              MOVS     r4,#0                 ;177
                  |L34.52|
000034  4620              MOV      r0,r4                 ;179
000036  e7e9              B        |L34.12|
;;;181    
                          ENDP


                          AREA ||i.lua_sethook||, CODE, READONLY, ALIGN=1

                  lua_sethook PROC
;;;134    */
;;;135    LUA_API void lua_sethook (lua_State *L, lua_Hook func, int mask, int count) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
00000a  461f              MOV      r7,r3
;;;136      if (func == NULL || mask == 0) {  /* turn off hooks? */
00000c  b106              CBZ      r6,|L35.16|
00000e  b90d              CBNZ     r5,|L35.20|
                  |L35.16|
;;;137        mask = 0;
000010  2500              MOVS     r5,#0
;;;138        func = NULL;
000012  2600              MOVS     r6,#0
                  |L35.20|
;;;139      }
;;;140      if (isLua(L->ci))
000014  6960              LDR      r0,[r4,#0x14]
000016  f8900022          LDRB     r0,[r0,#0x22]
00001a  f0000002          AND      r0,r0,#2
00001e  b910              CBNZ     r0,|L35.38|
;;;141        L->oldpc = L->ci->u.l.savedpc;
000020  6960              LDR      r0,[r4,#0x14]
000022  6900              LDR      r0,[r0,#0x10]
000024  61a0              STR      r0,[r4,#0x18]
                  |L35.38|
;;;142      L->hook = func;
000026  65a6              STR      r6,[r4,#0x58]
;;;143      L->basehookcount = count;
000028  6667              STR      r7,[r4,#0x64]
;;;144      resethookcount(L);
00002a  6e60              LDR      r0,[r4,#0x64]
00002c  66a0              STR      r0,[r4,#0x68]
;;;145      L->hookmask = cast_byte(mask);
00002e  b2e8              UXTB     r0,r5
000030  6720              STR      r0,[r4,#0x70]
;;;146      if (mask)
000032  b115              CBZ      r5,|L35.58|
;;;147        settraps(L->ci);  /* to trace inside 'luaV_execute' */
000034  6960              LDR      r0,[r4,#0x14]
000036  f7fffffe          BL       settraps
                  |L35.58|
;;;148    }
00003a  e8bd81f0          POP      {r4-r8,pc}
;;;149    
                          ENDP


                          AREA ||i.lua_setlocal||, CODE, READONLY, ALIGN=1

                  lua_setlocal PROC
;;;245    
;;;246    LUA_API const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4617              MOV      r7,r2
;;;247      StkId pos = NULL;  /* to avoid warnings */
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;248      const char *name;
;;;249      lua_lock(L);
;;;250      name = findlocal(L, ar->i_ci, n, &pos);
00000c  466b              MOV      r3,sp
00000e  463a              MOV      r2,r7
000010  4620              MOV      r0,r4
000012  6e69              LDR      r1,[r5,#0x64]
000014  f7fffffe          BL       findlocal
000018  4606              MOV      r6,r0
;;;251      if (name) {
00001a  b166              CBZ      r6,|L36.54|
;;;252        setobjs2s(L, pos, L->top - 1);
00001c  9800              LDR      r0,[sp,#0]
00001e  68e2              LDR      r2,[r4,#0xc]
000020  f1a20110          SUB      r1,r2,#0x10
000024  e9d12300          LDRD     r2,r3,[r1,#0]
000028  e9c02300          STRD     r2,r3,[r0,#0]
00002c  7a0a              LDRB     r2,[r1,#8]
00002e  7202              STRB     r2,[r0,#8]
;;;253        L->top--;  /* pop value */
000030  68e0              LDR      r0,[r4,#0xc]
000032  3810              SUBS     r0,r0,#0x10
000034  60e0              STR      r0,[r4,#0xc]
                  |L36.54|
;;;254      }
;;;255      lua_unlock(L);
;;;256      return name;
000036  4630              MOV      r0,r6
;;;257    }
000038  bdf8              POP      {r3-r7,pc}
;;;258    
                          ENDP


                          AREA ||i.nextline||, CODE, READONLY, ALIGN=1

                  nextline PROC
;;;277    
;;;278    static int nextline (Proto *p, int currentline, int pc) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;279      if (p->lineinfo[pc] != ABSLINEINFO)
000008  6c68              LDR      r0,[r5,#0x44]
00000a  5700              LDRSB    r0,[r0,r4]
00000c  3080              ADDS     r0,r0,#0x80
00000e  b118              CBZ      r0,|L37.24|
;;;280        return currentline + p->lineinfo[pc];
000010  6c68              LDR      r0,[r5,#0x44]
000012  5700              LDRSB    r0,[r0,r4]
000014  4430              ADD      r0,r0,r6
                  |L37.22|
;;;281      else
;;;282        return luaG_getfuncline(p, pc);
;;;283    }
000016  bd70              POP      {r4-r6,pc}
                  |L37.24|
000018  4621              MOV      r1,r4                 ;282
00001a  4628              MOV      r0,r5                 ;282
00001c  f7fffffe          BL       luaG_getfuncline
000020  e7f9              B        |L37.22|
;;;284    
                          ENDP


                          AREA ||i.rkname||, CODE, READONLY, ALIGN=1

                  rkname PROC
;;;439    */
;;;440    static void rkname (Proto *p, int pc, Instruction i, const char **name) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
;;;441      int c = GETARG_C(i);  /* key index */
00000c  0e26              LSRS     r6,r4,#24
;;;442      if (GETARG_k(i))  /* is 'c' a constant? */
00000e  f3c430c0          UBFX     r0,r4,#15,#1
000012  b128              CBZ      r0,|L38.32|
;;;443        kname(p, c, name);
000014  462a              MOV      r2,r5
000016  4631              MOV      r1,r6
000018  4638              MOV      r0,r7
00001a  f7fffffe          BL       kname
00001e  e005              B        |L38.44|
                  |L38.32|
;;;444      else  /* 'c' is a register */
;;;445        rname(p, pc, c, name);
000020  462b              MOV      r3,r5
000022  4632              MOV      r2,r6
000024  4641              MOV      r1,r8
000026  4638              MOV      r0,r7
000028  f7fffffe          BL       rname
                  |L38.44|
;;;446    }
00002c  e8bd81f0          POP      {r4-r8,pc}
;;;447    
                          ENDP


                          AREA ||i.rname||, CODE, READONLY, ALIGN=2

                  rname PROC
;;;429    */
;;;430    static void rname (Proto *p, int pc, int c, const char **name) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  461c              MOV      r4,r3
;;;431      const char *what = getobjname(p, pc, c, name); /* search for 'c' */
00000c  4623              MOV      r3,r4
00000e  4642              MOV      r2,r8
000010  4639              MOV      r1,r7
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       getobjname
000018  4605              MOV      r5,r0
;;;432      if (!(what && *what == 'c'))  /* did not find a constant name? */
00001a  b115              CBZ      r5,|L39.34|
00001c  7828              LDRB     r0,[r5,#0]
00001e  2863              CMP      r0,#0x63
000020  d001              BEQ      |L39.38|
                  |L39.34|
;;;433        *name = "?";
000022  a002              ADR      r0,|L39.44|
000024  6020              STR      r0,[r4,#0]
                  |L39.38|
;;;434    }
000026  e8bd81f0          POP      {r4-r8,pc}
;;;435    
                          ENDP

00002a  0000              DCW      0x0000
                  |L39.44|
00002c  3f00              DCB      "?",0
00002e  00                DCB      0
00002f  00                DCB      0

                          AREA ||i.settraps||, CODE, READONLY, ALIGN=1

                  settraps PROC
;;;117    */
;;;118    static void settraps (CallInfo *ci) {
000000  e007              B        |L40.18|
                  |L40.2|
;;;119      for (; ci != NULL; ci = ci->previous)
;;;120        if (isLua(ci))
000002  f8901022          LDRB     r1,[r0,#0x22]
000006  f0010102          AND      r1,r1,#2
00000a  b909              CBNZ     r1,|L40.16|
;;;121          ci->u.l.trap = 1;
00000c  2201              MOVS     r2,#1
00000e  6142              STR      r2,[r0,#0x14]
                  |L40.16|
000010  6880              LDR      r0,[r0,#8]            ;119
                  |L40.18|
000012  2800              CMP      r0,#0                 ;119
000014  d1f5              BNE      |L40.2|
;;;122    }
000016  4770              BX       lr
;;;123    
                          ENDP


                          AREA ||i.upvalname||, CODE, READONLY, ALIGN=2

                  upvalname PROC
;;;182    
;;;183    static const char *upvalname (Proto *p, int uv) {
000000  4602              MOV      r2,r0
;;;184      TString *s = check_exp(uv < p->sizeupvalues, p->upvalues[uv].name);
000002  6c10              LDR      r0,[r2,#0x40]
000004  f8503031          LDR      r3,[r0,r1,LSL #3]
;;;185      if (s == NULL) return "?";
000008  b90b              CBNZ     r3,|L41.14|
00000a  a002              ADR      r0,|L41.20|
                  |L41.12|
;;;186      else return getstr(s);
;;;187    }
00000c  4770              BX       lr
                  |L41.14|
00000e  f1030010          ADD      r0,r3,#0x10           ;186
000012  e7fb              B        |L41.12|
;;;188    
                          ENDP

                  |L41.20|
000014  3f00              DCB      "?",0
000016  00                DCB      0
000017  00                DCB      0

                          AREA ||i.varinfo||, CODE, READONLY, ALIGN=2

                  varinfo PROC
;;;677    
;;;678    static const char *varinfo (lua_State *L, const TValue *o) {
000000  e92d43f8          PUSH     {r3-r9,lr}
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;679      const char *name = NULL;  /* to avoid warnings */
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;680      CallInfo *ci = L->ci;
00000c  6974              LDR      r4,[r6,#0x14]
;;;681      const char *kind = NULL;
00000e  2500              MOVS     r5,#0
;;;682      if (isLua(ci)) {
000010  f8940022          LDRB     r0,[r4,#0x22]
000014  f0000002          AND      r0,r0,#2
000018  b9d8              CBNZ     r0,|L42.82|
;;;683        kind = getupvalname(ci, o, &name);  /* check whether 'o' is an upvalue */
00001a  466a              MOV      r2,sp
00001c  4639              MOV      r1,r7
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       getupvalname
000024  4605              MOV      r5,r0
;;;684        if (!kind && isinstack(ci, o))  /* no? try a register */
000026  b9a5              CBNZ     r5,|L42.82|
000028  4639              MOV      r1,r7
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       isinstack
000030  b178              CBZ      r0,|L42.82|
;;;685          kind = getobjname(ci_func(ci)->p, currentpc(ci),
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       currentpc
000038  4680              MOV      r8,r0
00003a  6821              LDR      r1,[r4,#0]
00003c  3110              ADDS     r1,r1,#0x10
00003e  1a79              SUBS     r1,r7,r1
000040  110a              ASRS     r2,r1,#4
000042  6821              LDR      r1,[r4,#0]
000044  6809              LDR      r1,[r1,#0]
000046  466b              MOV      r3,sp
000048  68c8              LDR      r0,[r1,#0xc]
00004a  4641              MOV      r1,r8
00004c  f7fffffe          BL       getobjname
000050  4605              MOV      r5,r0
                  |L42.82|
;;;686                            cast_int(cast(StkId, o) - (ci->func + 1)), &name);
;;;687      }
;;;688      return (kind) ? luaO_pushfstring(L, " (%s '%s')", kind, name) : "";
000052  b13d              CBZ      r5,|L42.100|
000054  462a              MOV      r2,r5
000056  a104              ADR      r1,|L42.104|
000058  4630              MOV      r0,r6
00005a  9b00              LDR      r3,[sp,#0]
00005c  f7fffffe          BL       luaO_pushfstring
                  |L42.96|
;;;689    }
000060  e8bd83f8          POP      {r3-r9,pc}
                  |L42.100|
000064  a003              ADR      r0,|L42.116|
000066  e7fb              B        |L42.96|
;;;690    
                          ENDP

                  |L42.104|
000068  20282573          DCB      " (%s '%s')",0
00006c  20272573
000070  272900  
000073  00                DCB      0
                  |L42.116|
000074  00                DCB      0
000075  00                DCB      0
000076  00                DCB      0
000077  00                DCB      0
