; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\debug\output\lparser.o --asm_dir=.\Debug\Listings\ --list_dir=.\Debug\Listings\ --depend=.\debug\output\lparser.d --cpu=Cortex-M7 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\MProkaron\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -I..\..\..\M0P0_Library\STM32Cube_FW_F7_V1.11.0\Drivers\STM32F7xx_HAL_Driver\Inc -I.\Source -I.\Drivers -I..\..\..\M6P1(L)_Lua\lua -IF:\Code_Library\MCU\Mutatus\M5P1_MuProkaron\Project\RVMDK-STM32F767IGT6-ALIENTEK-LUA\RTE -ID:\Program_Files_x86\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -ID:\Program_Files_x86\Keil_v5\ARM\PACK\Keil\STM32F7xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F7xx\Include -D__MICROLIB -D__UVISION_VERSION=520 -D_RTE_ -DSTM32F767xx -DSTM32F767xx -DUSE_HAL_DRIVER -Dlua_writestring=RMP_lua_writestring -Dlua_writeline=RMP_lua_writeline --enum_is_int --signed_chars --omf_browse=.\debug\output\lparser.crf ..\..\..\M6P1(L)_Lua\lua\lparser.c]
                          THUMB

                          AREA ||i.addprototype||, CODE, READONLY, ALIGN=2

                  addprototype PROC
;;;503    */
;;;504    static Proto *addprototype (LexState *ls) {
000000  e92d43fe          PUSH     {r1-r9,lr}
000004  4607              MOV      r7,r0
;;;505      Proto *clp;
;;;506      lua_State *L = ls->L;
000006  f8d79034          LDR      r9,[r7,#0x34]
;;;507      FuncState *fs = ls->fs;
00000a  6b3d              LDR      r5,[r7,#0x30]
;;;508      Proto *f = fs->f;  /* prototype of current function */
00000c  682c              LDR      r4,[r5,#0]
;;;509      if (fs->np >= f->sizep) {
00000e  6a28              LDR      r0,[r5,#0x20]
000010  69e1              LDR      r1,[r4,#0x1c]
000012  4288              CMP      r0,r1
000014  db1b              BLT      |L1.78|
;;;510        int oldsize = f->sizep;
000016  f8d4801c          LDR      r8,[r4,#0x1c]
;;;511        luaM_growvector(L, f->p, fs->np, f->sizep, Proto *, MAXARG_Bx, "functions");
00001a  a01b              ADR      r0,|L1.136|
00001c  491d              LDR      r1,|L1.148|
00001e  2204              MOVS     r2,#4
000020  e9cd2100          STRD     r2,r1,[sp,#0]
000024  9002              STR      r0,[sp,#8]
000026  6a2a              LDR      r2,[r5,#0x20]
000028  f104031c          ADD      r3,r4,#0x1c
00002c  4648              MOV      r0,r9
00002e  6be1              LDR      r1,[r4,#0x3c]
000030  f7fffffe          BL       luaM_growaux_
000034  63e0              STR      r0,[r4,#0x3c]
;;;512        while (oldsize < f->sizep)
000036  e006              B        |L1.70|
                  |L1.56|
;;;513          f->p[oldsize++] = NULL;
000038  2200              MOVS     r2,#0
00003a  4640              MOV      r0,r8
00003c  f1080801          ADD      r8,r8,#1
000040  6be3              LDR      r3,[r4,#0x3c]
000042  f8432020          STR      r2,[r3,r0,LSL #2]
                  |L1.70|
000046  69e0              LDR      r0,[r4,#0x1c]         ;512
000048  4540              CMP      r0,r8                 ;512
00004a  dcf5              BGT      |L1.56|
;;;514      }
00004c  bf00              NOP      
                  |L1.78|
;;;515      f->p[fs->np++] = clp = luaF_newproto(L);
00004e  4648              MOV      r0,r9
000050  f7fffffe          BL       luaF_newproto
000054  4606              MOV      r6,r0
000056  6a2a              LDR      r2,[r5,#0x20]
000058  1c51              ADDS     r1,r2,#1
00005a  6229              STR      r1,[r5,#0x20]
00005c  6be1              LDR      r1,[r4,#0x3c]
00005e  f8410022          STR      r0,[r1,r2,LSL #2]
;;;516      luaC_objbarrier(L, f, clp);
000062  7960              LDRB     r0,[r4,#5]
000064  f0000020          AND      r0,r0,#0x20
000068  b148              CBZ      r0,|L1.126|
00006a  7970              LDRB     r0,[r6,#5]
00006c  f0000018          AND      r0,r0,#0x18
000070  b128              CBZ      r0,|L1.126|
000072  4632              MOV      r2,r6
000074  4621              MOV      r1,r4
000076  4648              MOV      r0,r9
000078  f7fffffe          BL       luaC_barrier_
00007c  e000              B        |L1.128|
                  |L1.126|
00007e  bf00              NOP      
                  |L1.128|
;;;517      return clp;
000080  4630              MOV      r0,r6
;;;518    }
000082  e8bd83fe          POP      {r1-r9,pc}
;;;519    
                          ENDP

000086  0000              DCW      0x0000
                  |L1.136|
000088  66756e63          DCB      "functions",0
00008c  74696f6e
000090  7300    
000092  00                DCB      0
000093  00                DCB      0
                  |L1.148|
                          DCD      0x0001ffff

                          AREA ||i.adjust_assign||, CODE, READONLY, ALIGN=1

                  adjust_assign PROC
;;;303    
;;;304    static void adjust_assign (LexState *ls, int nvars, int nexps, expdesc *e) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  461d              MOV      r5,r3
;;;305      FuncState *fs = ls->fs;
00000c  f8d69030          LDR      r9,[r6,#0x30]
;;;306      int extra = nvars - nexps;
000010  eba70408          SUB      r4,r7,r8
;;;307      if (hasmultret(e->k)) {
000014  6828              LDR      r0,[r5,#0]
000016  2810              CMP      r0,#0x10
000018  d002              BEQ      |L2.32|
00001a  6828              LDR      r0,[r5,#0]
00001c  2811              CMP      r0,#0x11
00001e  d10f              BNE      |L2.64|
                  |L2.32|
;;;308        extra++;  /* includes call itself */
000020  1c64              ADDS     r4,r4,#1
;;;309        if (extra < 0) extra = 0;
000022  2c00              CMP      r4,#0
000024  da00              BGE      |L2.40|
000026  2400              MOVS     r4,#0
                  |L2.40|
;;;310        luaK_setreturns(fs, e, extra);  /* last exp. provides the difference */
000028  4622              MOV      r2,r4
00002a  4629              MOV      r1,r5
00002c  4648              MOV      r0,r9
00002e  f7fffffe          BL       luaK_setreturns
;;;311        if (extra > 1) luaK_reserveregs(fs, extra-1);
000032  2c01              CMP      r4,#1
000034  dd18              BLE      |L2.104|
000036  1e61              SUBS     r1,r4,#1
000038  4648              MOV      r0,r9
00003a  f7fffffe          BL       luaK_reserveregs
00003e  e013              B        |L2.104|
                  |L2.64|
;;;312      }
;;;313      else {
;;;314        if (e->k != VVOID) luaK_exp2nextreg(fs, e);  /* close last expression */
000040  6828              LDR      r0,[r5,#0]
000042  b118              CBZ      r0,|L2.76|
000044  4629              MOV      r1,r5
000046  4648              MOV      r0,r9
000048  f7fffffe          BL       luaK_exp2nextreg
                  |L2.76|
;;;315        if (extra > 0) {
00004c  2c00              CMP      r4,#0
00004e  dd0b              BLE      |L2.104|
;;;316          int reg = fs->freereg;
000050  f899a030          LDRB     r10,[r9,#0x30]
;;;317          luaK_reserveregs(fs, extra);
000054  4621              MOV      r1,r4
000056  4648              MOV      r0,r9
000058  f7fffffe          BL       luaK_reserveregs
;;;318          luaK_nil(fs, reg, extra);
00005c  4622              MOV      r2,r4
00005e  4651              MOV      r1,r10
000060  4648              MOV      r0,r9
000062  f7fffffe          BL       luaK_nil
;;;319        }
000066  bf00              NOP      
                  |L2.104|
;;;320      }
;;;321      if (nexps > nvars)
000068  45b8              CMP      r8,r7
00006a  dd08              BLE      |L2.126|
;;;322        ls->fs->freereg -= nexps - nvars;  /* remove extra values */
00006c  6b30              LDR      r0,[r6,#0x30]
00006e  f8900030          LDRB     r0,[r0,#0x30]
000072  eba80107          SUB      r1,r8,r7
000076  1a40              SUBS     r0,r0,r1
000078  6b31              LDR      r1,[r6,#0x30]
00007a  f8810030          STRB     r0,[r1,#0x30]
                  |L2.126|
;;;323    }
00007e  e8bd87f0          POP      {r4-r10,pc}
;;;324    
                          ENDP


                          AREA ||i.adjustlocalvars||, CODE, READONLY, ALIGN=1

                  adjustlocalvars PROC
;;;196    
;;;197    static void adjustlocalvars (LexState *ls, int nvars) {
000000  b570              PUSH     {r4-r6,lr}
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;198      FuncState *fs = ls->fs;
000006  6b35              LDR      r5,[r6,#0x30]
;;;199      fs->nactvar = cast_byte(fs->nactvar + nvars);
000008  f895002e          LDRB     r0,[r5,#0x2e]
00000c  4420              ADD      r0,r0,r4
00000e  f885002e          STRB     r0,[r5,#0x2e]
;;;200      for (; nvars; nvars--) {
000012  e008              B        |L3.38|
                  |L3.20|
;;;201        getlocvar(fs, fs->nactvar - nvars)->startpc = fs->pc;
000014  f895002e          LDRB     r0,[r5,#0x2e]
000018  1b01              SUBS     r1,r0,r4
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       getlocvar
000020  6929              LDR      r1,[r5,#0x10]
000022  6041              STR      r1,[r0,#4]
000024  1e64              SUBS     r4,r4,#1              ;200
                  |L3.38|
000026  2c00              CMP      r4,#0                 ;200
000028  d1f4              BNE      |L3.20|
;;;202      }
;;;203    }
00002a  bd70              POP      {r4-r6,pc}
;;;204    
                          ENDP


                          AREA ||i.assignment||, CODE, READONLY, ALIGN=2

                  assignment PROC
;;;1169   
;;;1170   static void assignment (LexState *ls, struct LHS_assign *lh, int nvars) {
000000  b5f0              PUSH     {r4-r7,lr}
000002  b08f              SUB      sp,sp,#0x3c
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;1171     expdesc e;
;;;1172     check_condition(ls, vkisvar(lh->v.k), "syntax error");
00000a  68a8              LDR      r0,[r5,#8]
00000c  2808              CMP      r0,#8
00000e  d302              BCC      |L4.22|
000010  68a8              LDR      r0,[r5,#8]
000012  280d              CMP      r0,#0xd
000014  d903              BLS      |L4.30|
                  |L4.22|
000016  a133              ADR      r1,|L4.228|
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       luaX_syntaxerror
                  |L4.30|
;;;1173     if (testnext(ls, ',')) {  /* assignment -> ',' suffixedexp assignment */
00001e  212c              MOVS     r1,#0x2c
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       testnext
000026  b1f8              CBZ      r0,|L4.104|
;;;1174       struct LHS_assign nv;
;;;1175       nv.prev = lh;
000028  9500              STR      r5,[sp,#0]
;;;1176       suffixedexp(ls, &nv.v);
00002a  a902              ADD      r1,sp,#8
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       suffixedexp
;;;1177       if (!vkisindexed(nv.v.k))
000032  9802              LDR      r0,[sp,#8]
000034  280a              CMP      r0,#0xa
000036  d302              BCC      |L4.62|
000038  9802              LDR      r0,[sp,#8]
00003a  280d              CMP      r0,#0xd
00003c  d904              BLS      |L4.72|
                  |L4.62|
;;;1178         check_conflict(ls, lh, &nv.v);
00003e  aa02              ADD      r2,sp,#8
000040  4629              MOV      r1,r5
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       check_conflict
                  |L4.72|
;;;1179       luaE_incCcalls(ls->L);  /* control recursion depth */
000048  6b60              LDR      r0,[r4,#0x34]
00004a  f7fffffe          BL       luaE_incCcalls
;;;1180       assignment(ls, &nv, nvars+1);
00004e  1c72              ADDS     r2,r6,#1
000050  4669              MOV      r1,sp
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       assignment
;;;1181       ls->L->nCcalls--;
000058  6b60              LDR      r0,[r4,#0x34]
00005a  f8b0006e          LDRH     r0,[r0,#0x6e]
00005e  1e40              SUBS     r0,r0,#1
000060  6b61              LDR      r1,[r4,#0x34]
000062  f8a1006e          STRH     r0,[r1,#0x6e]
;;;1182     }
000066  e02c              B        |L4.194|
                  |L4.104|
;;;1183     else {  /* assignment -> '=' explist */
;;;1184       int nexps;
;;;1185       checknext(ls, '=');
000068  213d              MOVS     r1,#0x3d
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       checknext
;;;1186       if (nvars == 1 && testnext(ls, TK_UNDEF)) {
000070  2e01              CMP      r6,#1
000072  d10c              BNE      |L4.142|
000074  f2401115          MOV      r1,#0x115
000078  4620              MOV      r0,r4
00007a  f7fffffe          BL       testnext
00007e  b130              CBZ      r0,|L4.142|
;;;1187         luaK_codeundef(ls->fs, &lh->v);
000080  f1050108          ADD      r1,r5,#8
000084  6b20              LDR      r0,[r4,#0x30]
000086  f7fffffe          BL       luaK_codeundef
                  |L4.138|
;;;1188         return;
;;;1189       }
;;;1190       nexps = explist(ls, &e);
;;;1191       if (nexps != nvars)
;;;1192         adjust_assign(ls, nvars, nexps, &e);
;;;1193       else {
;;;1194         luaK_setoneret(ls->fs, &e);  /* close last expression */
;;;1195         luaK_storevar(ls->fs, &lh->v, &e);
;;;1196         return;  /* avoid default */
;;;1197       }
;;;1198     }
;;;1199     init_exp(&e, VNONRELOC, ls->fs->freereg-1);  /* default assignment */
;;;1200     luaK_storevar(ls->fs, &lh->v, &e);
;;;1201   }
00008a  b00f              ADD      sp,sp,#0x3c
00008c  bdf0              POP      {r4-r7,pc}
                  |L4.142|
00008e  a908              ADD      r1,sp,#0x20           ;1190
000090  4620              MOV      r0,r4                 ;1190
000092  f7fffffe          BL       explist
000096  4607              MOV      r7,r0                 ;1190
000098  42b7              CMP      r7,r6                 ;1191
00009a  d006              BEQ      |L4.170|
00009c  ab08              ADD      r3,sp,#0x20           ;1192
00009e  463a              MOV      r2,r7                 ;1192
0000a0  4631              MOV      r1,r6                 ;1192
0000a2  4620              MOV      r0,r4                 ;1192
0000a4  f7fffffe          BL       adjust_assign
0000a8  e00a              B        |L4.192|
                  |L4.170|
0000aa  a908              ADD      r1,sp,#0x20           ;1194
0000ac  6b20              LDR      r0,[r4,#0x30]         ;1194
0000ae  f7fffffe          BL       luaK_setoneret
0000b2  aa08              ADD      r2,sp,#0x20           ;1195
0000b4  f1050108          ADD      r1,r5,#8              ;1195
0000b8  6b20              LDR      r0,[r4,#0x30]         ;1195
0000ba  f7fffffe          BL       luaK_storevar
0000be  e7e4              B        |L4.138|
                  |L4.192|
0000c0  bf00              NOP                            ;1198
                  |L4.194|
0000c2  6b20              LDR      r0,[r4,#0x30]         ;1199
0000c4  f8900030          LDRB     r0,[r0,#0x30]         ;1199
0000c8  1e42              SUBS     r2,r0,#1              ;1199
0000ca  2107              MOVS     r1,#7                 ;1199
0000cc  a808              ADD      r0,sp,#0x20           ;1199
0000ce  f7fffffe          BL       init_exp
0000d2  aa08              ADD      r2,sp,#0x20           ;1200
0000d4  f1050108          ADD      r1,r5,#8              ;1200
0000d8  6b20              LDR      r0,[r4,#0x30]         ;1200
0000da  f7fffffe          BL       luaK_storevar
0000de  bf00              NOP      
0000e0  e7d3              B        |L4.138|
;;;1202   
                          ENDP

0000e2  0000              DCW      0x0000
                  |L4.228|
0000e4  73796e74          DCB      "syntax error",0
0000e8  61782065
0000ec  72726f72
0000f0  00      
0000f1  00                DCB      0
0000f2  00                DCB      0
0000f3  00                DCB      0

                          AREA ||i.block||, CODE, READONLY, ALIGN=1

                  block PROC
;;;1107   
;;;1108   static void block (LexState *ls) {
000000  b530              PUSH     {r4,r5,lr}
000002  b085              SUB      sp,sp,#0x14
000004  4604              MOV      r4,r0
;;;1109     /* block -> statlist */
;;;1110     FuncState *fs = ls->fs;
000006  6b25              LDR      r5,[r4,#0x30]
;;;1111     BlockCnt bl;
;;;1112     enterblock(fs, &bl, 0);
000008  2200              MOVS     r2,#0
00000a  4669              MOV      r1,sp
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       enterblock
;;;1113     statlist(ls);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       statlist
;;;1114     leaveblock(fs);
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       leaveblock
;;;1115   }
00001e  b005              ADD      sp,sp,#0x14
000020  bd30              POP      {r4,r5,pc}
;;;1116   
                          ENDP


                          AREA ||i.block_follow||, CODE, READONLY, ALIGN=1

                  block_follow PROC
;;;589    */
;;;590    static int block_follow (LexState *ls, int withuntil) {
000000  4602              MOV      r2,r0
;;;591      switch (ls->t.token) {
000002  6910              LDR      r0,[r2,#0x10]
000004  f5b07f83          CMP      r0,#0x106
000008  d010              BEQ      |L6.44|
00000a  dc06              BGT      |L6.26|
00000c  f5b07f82          CMP      r0,#0x104
000010  d00a              BEQ      |L6.40|
000012  f2a01005          SUB      r0,r0,#0x105
000016  b970              CBNZ     r0,|L6.54|
000018  e007              B        |L6.42|
                  |L6.26|
00001a  f5b07f8b          CMP      r0,#0x116
00001e  d008              BEQ      |L6.50|
000020  f5b07f91          CMP      r0,#0x122
000024  d107              BNE      |L6.54|
000026  e002              B        |L6.46|
                  |L6.40|
;;;592        case TK_ELSE: case TK_ELSEIF:
000028  bf00              NOP      
                  |L6.42|
;;;593        case TK_END: case TK_EOS:
00002a  bf00              NOP      
                  |L6.44|
00002c  bf00              NOP      
                  |L6.46|
;;;594          return 1;
00002e  2001              MOVS     r0,#1
                  |L6.48|
;;;595        case TK_UNTIL: return withuntil;
;;;596        default: return 0;
;;;597      }
;;;598    }
000030  4770              BX       lr
                  |L6.50|
000032  4608              MOV      r0,r1                 ;595
000034  e7fc              B        |L6.48|
                  |L6.54|
000036  2000              MOVS     r0,#0                 ;596
000038  e7fa              B        |L6.48|
;;;599    
                          ENDP


                          AREA ||i.body||, CODE, READONLY, ALIGN=2

                  body PROC
;;;791    
;;;792    static void body (LexState *ls, expdesc *e, int ismethod, int line) {
000000  b5f0              PUSH     {r4-r7,lr}
000002  b093              SUB      sp,sp,#0x4c
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
;;;793      /* body ->  '(' parlist ')' block END */
;;;794      FuncState new_fs;
;;;795      BlockCnt bl;
;;;796      new_fs.f = addprototype(ls);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       addprototype
000012  9006              STR      r0,[sp,#0x18]
;;;797      new_fs.f->linedefined = line;
000014  9806              LDR      r0,[sp,#0x18]
000016  6286              STR      r6,[r0,#0x28]
;;;798      open_func(ls, &new_fs, &bl);
000018  aa01              ADD      r2,sp,#4
00001a  a906              ADD      r1,sp,#0x18
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       open_func
;;;799      checknext(ls, '(');
000022  2128              MOVS     r1,#0x28
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       checknext
;;;800      if (ismethod) {
00002a  b145              CBZ      r5,|L7.62|
;;;801        new_localvarliteral(ls, "self");  /* create 'self' parameter */
00002c  2204              MOVS     r2,#4
00002e  a112              ADR      r1,|L7.120|
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       new_localvarliteral_
;;;802        adjustlocalvars(ls, 1);
000036  2101              MOVS     r1,#1
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       adjustlocalvars
                  |L7.62|
;;;803      }
;;;804      parlist(ls);
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       parlist
;;;805      checknext(ls, ')');
000044  2129              MOVS     r1,#0x29
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       checknext
;;;806      statlist(ls);
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       statlist
;;;807      new_fs.f->lastlinedefined = ls->linenumber;
000052  6860              LDR      r0,[r4,#4]
000054  9906              LDR      r1,[sp,#0x18]
000056  62c8              STR      r0,[r1,#0x2c]
;;;808      check_match(ls, TK_END, TK_FUNCTION, line);
000058  4633              MOV      r3,r6
00005a  f2401209          MOV      r2,#0x109
00005e  1ed1              SUBS     r1,r2,#3
000060  4620              MOV      r0,r4
000062  f7fffffe          BL       check_match
;;;809      codeclosure(ls, e);
000066  4639              MOV      r1,r7
000068  4620              MOV      r0,r4
00006a  f7fffffe          BL       codeclosure
;;;810      close_func(ls);
00006e  4620              MOV      r0,r4
000070  f7fffffe          BL       close_func
;;;811    }
000074  b013              ADD      sp,sp,#0x4c
000076  bdf0              POP      {r4-r7,pc}
;;;812    
                          ENDP

                  |L7.120|
000078  73656c66          DCB      "self",0
00007c  00      
00007d  00                DCB      0
00007e  00                DCB      0
00007f  00                DCB      0

                          AREA ||i.breakstat||, CODE, READONLY, ALIGN=2

                  breakstat PROC
;;;1222   
;;;1223   static void breakstat (LexState *ls, int pc) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;1224     FuncState *fs = ls->fs;
000008  6b35              LDR      r5,[r6,#0x30]
;;;1225     BlockCnt *bl = fs->bl;
00000a  68ec              LDR      r4,[r5,#0xc]
;;;1226     luaX_next(ls);  /* skip break */
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       luaX_next
;;;1227     while (bl && !bl->isloop) { bl = bl->previous; }
000012  e000              B        |L8.22|
                  |L8.20|
000014  6824              LDR      r4,[r4,#0]
                  |L8.22|
000016  b114              CBZ      r4,|L8.30|
000018  7ce0              LDRB     r0,[r4,#0x13]
00001a  2800              CMP      r0,#0
00001c  d0fa              BEQ      |L8.20|
                  |L8.30|
;;;1228     if (!bl)
00001e  b91c              CBNZ     r4,|L8.40|
;;;1229       luaX_syntaxerror(ls, "no loop to break");
000020  a106              ADR      r1,|L8.60|
000022  4630              MOV      r0,r6
000024  f7fffffe          BL       luaX_syntaxerror
                  |L8.40|
;;;1230     luaK_concat(fs, &fs->bl->brks, pc);
000028  68e8              LDR      r0,[r5,#0xc]
00002a  f100010c          ADD      r1,r0,#0xc
00002e  463a              MOV      r2,r7
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       luaK_concat
;;;1231   }
000036  e8bd81f0          POP      {r4-r8,pc}
;;;1232   
                          ENDP

00003a  0000              DCW      0x0000
                  |L8.60|
00003c  6e6f206c          DCB      "no loop to break",0
000040  6f6f7020
000044  746f2062
000048  7265616b
00004c  00      
00004d  00                DCB      0
00004e  00                DCB      0
00004f  00                DCB      0

                          AREA ||i.check||, CODE, READONLY, ALIGN=1

                  check PROC
;;;100    
;;;101    static void check (LexState *ls, int c) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;102      if (ls->t.token != c)
000006  6920              LDR      r0,[r4,#0x10]
000008  42a8              CMP      r0,r5
00000a  d003              BEQ      |L9.20|
;;;103        error_expected(ls, c);
00000c  4629              MOV      r1,r5
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       error_expected
                  |L9.20|
;;;104    }
000014  bd70              POP      {r4-r6,pc}
;;;105    
                          ENDP


                          AREA ||i.check_conflict||, CODE, READONLY, ALIGN=1

                  check_conflict PROC
;;;1133   */
;;;1134   static void check_conflict (LexState *ls, struct LHS_assign *lh, expdesc *v) {
000000  e92d47fc          PUSH     {r2-r10,lr}
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;1135     FuncState *fs = ls->fs;
00000a  f8d78030          LDR      r8,[r7,#0x30]
;;;1136     int extra = fs->freereg;  /* eventual position to save local variable */
00000e  f8986030          LDRB     r6,[r8,#0x30]
;;;1137     int conflict = 0;
000012  f04f0900          MOV      r9,#0
;;;1138     for (; lh; lh = lh->prev) {  /* check all previous assignments */
000016  e02f              B        |L10.120|
                  |L10.24|
;;;1139       if (vkisindexed(lh->v.k)) {  /* assignment to table field? */
000018  68a0              LDR      r0,[r4,#8]
00001a  280a              CMP      r0,#0xa
00001c  d32b              BCC      |L10.118|
00001e  68a0              LDR      r0,[r4,#8]
000020  280d              CMP      r0,#0xd
000022  d828              BHI      |L10.118|
;;;1140         if (lh->v.k == VINDEXUP) {  /* is table an upvalue? */
000024  68a0              LDR      r0,[r4,#8]
000026  280b              CMP      r0,#0xb
000028  d10c              BNE      |L10.68|
;;;1141           if (v->k == VUPVAL && lh->v.u.ind.t == v->u.info) {
00002a  6828              LDR      r0,[r5,#0]
00002c  2809              CMP      r0,#9
00002e  d122              BNE      |L10.118|
000030  7ca0              LDRB     r0,[r4,#0x12]
000032  68a9              LDR      r1,[r5,#8]
000034  4288              CMP      r0,r1
000036  d11e              BNE      |L10.118|
;;;1142             conflict = 1;  /* table is the upvalue being assigned now */
000038  f04f0901          MOV      r9,#1
;;;1143             lh->v.k = VINDEXSTR;
00003c  200d              MOVS     r0,#0xd
00003e  60a0              STR      r0,[r4,#8]
;;;1144             lh->v.u.ind.t = extra;  /* assignment will use safe copy */
000040  74a6              STRB     r6,[r4,#0x12]
000042  e018              B        |L10.118|
                  |L10.68|
;;;1145           }
;;;1146         }
;;;1147         else {  /* table is a register */
;;;1148           if (v->k == VLOCAL && lh->v.u.ind.t == v->u.info) {
000044  6828              LDR      r0,[r5,#0]
000046  2808              CMP      r0,#8
000048  d106              BNE      |L10.88|
00004a  7ca0              LDRB     r0,[r4,#0x12]
00004c  68a9              LDR      r1,[r5,#8]
00004e  4288              CMP      r0,r1
000050  d102              BNE      |L10.88|
;;;1149             conflict = 1;  /* table is the local being assigned now */
000052  f04f0901          MOV      r9,#1
;;;1150             lh->v.u.ind.t = extra;  /* assignment will use safe copy */
000056  74a6              STRB     r6,[r4,#0x12]
                  |L10.88|
;;;1151           }
;;;1152           /* is index the local being assigned? */
;;;1153           if (lh->v.k == VINDEXED && v->k == VLOCAL &&
000058  68a0              LDR      r0,[r4,#8]
00005a  280a              CMP      r0,#0xa
00005c  d10b              BNE      |L10.118|
00005e  6828              LDR      r0,[r5,#0]
000060  2808              CMP      r0,#8
000062  d108              BNE      |L10.118|
;;;1154               lh->v.u.ind.idx == v->u.info) {
000064  f9b40010          LDRSH    r0,[r4,#0x10]
000068  68a9              LDR      r1,[r5,#8]
00006a  4288              CMP      r0,r1
00006c  d103              BNE      |L10.118|
;;;1155             conflict = 1;
00006e  f04f0901          MOV      r9,#1
;;;1156             lh->v.u.ind.idx = extra;  /* previous assignment will use safe copy */
000072  b231              SXTH     r1,r6
000074  8221              STRH     r1,[r4,#0x10]
                  |L10.118|
000076  6824              LDR      r4,[r4,#0]            ;1138
                  |L10.120|
000078  2c00              CMP      r4,#0                 ;1138
00007a  d1cd              BNE      |L10.24|
;;;1157           }
;;;1158         }
;;;1159       }
;;;1160     }
;;;1161     if (conflict) {
00007c  f1b90f00          CMP      r9,#0
000080  d014              BEQ      |L10.172|
;;;1162       /* copy upvalue/local value to a temporary (in position 'extra') */
;;;1163       OpCode op = (v->k == VLOCAL) ? OP_MOVE : OP_GETUPVAL;
000082  6828              LDR      r0,[r5,#0]
000084  2808              CMP      r0,#8
000086  d101              BNE      |L10.140|
000088  2000              MOVS     r0,#0
00008a  e000              B        |L10.142|
                  |L10.140|
00008c  2007              MOVS     r0,#7
                  |L10.142|
00008e  4682              MOV      r10,r0
;;;1164       luaK_codeABC(fs, op, extra, v->u.info, 0);
000090  2000              MOVS     r0,#0
000092  9000              STR      r0,[sp,#0]
000094  9001              STR      r0,[sp,#4]
000096  4632              MOV      r2,r6
000098  4651              MOV      r1,r10
00009a  4640              MOV      r0,r8
00009c  68ab              LDR      r3,[r5,#8]
00009e  f7fffffe          BL       luaK_codeABCk
;;;1165       luaK_reserveregs(fs, 1);
0000a2  2101              MOVS     r1,#1
0000a4  4640              MOV      r0,r8
0000a6  f7fffffe          BL       luaK_reserveregs
;;;1166     }
0000aa  bf00              NOP      
                  |L10.172|
;;;1167   }
0000ac  e8bd87fc          POP      {r2-r10,pc}
;;;1168   
                          ENDP


                          AREA ||i.check_match||, CODE, READONLY, ALIGN=2

                  check_match PROC
;;;116    
;;;117    static void check_match (LexState *ls, int what, int who, int where) {
000000  e92d4ff8          PUSH     {r3-r11,lr}
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
00000a  461d              MOV      r5,r3
;;;118      if (!testnext(ls, what)) {
00000c  4639              MOV      r1,r7
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       testnext
000014  b9e8              CBNZ     r0,|L11.82|
;;;119        if (where == ls->linenumber)
000016  6860              LDR      r0,[r4,#4]
000018  42a8              CMP      r0,r5
00001a  d104              BNE      |L11.38|
;;;120          error_expected(ls, what);
00001c  4639              MOV      r1,r7
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       error_expected
000024  e015              B        |L11.82|
                  |L11.38|
;;;121        else {
;;;122          luaX_syntaxerror(ls, luaO_pushfstring(ls->L,
000026  4631              MOV      r1,r6
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       luaX_token2str
00002e  4681              MOV      r9,r0
000030  4639              MOV      r1,r7
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       luaX_token2str
000038  4682              MOV      r10,r0
00003a  9500              STR      r5,[sp,#0]
00003c  464b              MOV      r3,r9
00003e  4652              MOV      r2,r10
000040  a105              ADR      r1,|L11.88|
000042  6b60              LDR      r0,[r4,#0x34]
000044  f7fffffe          BL       luaO_pushfstring
000048  4680              MOV      r8,r0
00004a  4641              MOV      r1,r8
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       luaX_syntaxerror
                  |L11.82|
;;;123                 "%s expected (to close %s at line %d)",
;;;124                  luaX_token2str(ls, what), luaX_token2str(ls, who), where));
;;;125        }
;;;126      }
;;;127    }
000052  e8bd8ff8          POP      {r3-r11,pc}
;;;128    
                          ENDP

000056  0000              DCW      0x0000
                  |L11.88|
000058  25732065          DCB      "%s expected (to close %s at line %d)",0
00005c  78706563
000060  74656420
000064  28746f20
000068  636c6f73
00006c  65202573
000070  20617420
000074  6c696e65
000078  20256429
00007c  00      
00007d  00                DCB      0
00007e  00                DCB      0
00007f  00                DCB      0

                          AREA ||i.checklimit||, CODE, READONLY, ALIGN=1

                  checklimit PROC
;;;86     
;;;87     static void checklimit (FuncState *fs, int v, int l, const char *what) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4614              MOV      r4,r2
00000a  461e              MOV      r6,r3
;;;88       if (v > l) errorlimit(fs, l, what);
00000c  42a5              CMP      r5,r4
00000e  dd04              BLE      |L12.26|
000010  4632              MOV      r2,r6
000012  4621              MOV      r1,r4
000014  4638              MOV      r0,r7
000016  f7fffffe          BL       errorlimit
                  |L12.26|
;;;89     }
00001a  e8bd81f0          POP      {r4-r8,pc}
;;;90     
                          ENDP


                          AREA ||i.checkname||, CODE, READONLY, ALIGN=1

                  checkname PROC
;;;150    
;;;151    static void checkname (LexState *ls, expdesc *e) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;152      codestring(ls, e, str_checkname(ls));
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       str_checkname
00000c  4606              MOV      r6,r0
00000e  4632              MOV      r2,r6
000010  4629              MOV      r1,r5
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       codestring
;;;153    }
000018  bd70              POP      {r4-r6,pc}
;;;154    
                          ENDP


                          AREA ||i.checknext||, CODE, READONLY, ALIGN=1

                  checknext PROC
;;;106    
;;;107    static void checknext (LexState *ls, int c) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;108      check(ls, c);
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       check
;;;109      luaX_next(ls);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       luaX_next
;;;110    }
000014  bd70              POP      {r4-r6,pc}
;;;111    
                          ENDP


                          AREA ||i.checkrepeated||, CODE, READONLY, ALIGN=2

                  checkrepeated PROC
;;;1234   /* check for repeated labels on the same block */
;;;1235   static void checkrepeated (FuncState *fs, Labellist *ll, TString *label) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
;;;1236     int i;
;;;1237     for (i = fs->bl->firstlabel; i < ll->n; i++) {
00000a  68e0              LDR      r0,[r4,#0xc]
00000c  6846              LDR      r6,[r0,#4]
00000e  e017              B        |L15.64|
                  |L15.16|
;;;1238       if (eqstr(label, ll->arr[i].name)) {
000010  6828              LDR      r0,[r5,#0]
000012  eb001006          ADD      r0,r0,r6,LSL #4
000016  6800              LDR      r0,[r0,#0]
000018  42b8              CMP      r0,r7
00001a  d110              BNE      |L15.62|
;;;1239         const char *msg = luaO_pushfstring(fs->ls->L,
00001c  6829              LDR      r1,[r5,#0]
00001e  eb011106          ADD      r1,r1,r6,LSL #4
000022  688b              LDR      r3,[r1,#8]
000024  68a1              LDR      r1,[r4,#8]
000026  f1070210          ADD      r2,r7,#0x10
00002a  6b48              LDR      r0,[r1,#0x34]
00002c  a107              ADR      r1,|L15.76|
00002e  f7fffffe          BL       luaO_pushfstring
000032  4680              MOV      r8,r0
;;;1240                             "label '%s' already defined on line %d",
;;;1241                             getstr(label), ll->arr[i].line);
;;;1242         luaK_semerror(fs->ls, msg);
000034  4641              MOV      r1,r8
000036  68a0              LDR      r0,[r4,#8]
000038  f7fffffe          BL       luaK_semerror
;;;1243       }
00003c  bf00              NOP      
                  |L15.62|
00003e  1c76              ADDS     r6,r6,#1              ;1237
                  |L15.64|
000040  6868              LDR      r0,[r5,#4]            ;1237
000042  42b0              CMP      r0,r6                 ;1237
000044  dce4              BGT      |L15.16|
;;;1244     }
;;;1245   }
000046  e8bd81f0          POP      {r4-r8,pc}
;;;1246   
                          ENDP

00004a  0000              DCW      0x0000
                  |L15.76|
00004c  6c616265          DCB      "label '%s' already defined on line %d",0
000050  6c202725
000054  73272061
000058  6c726561
00005c  64792064
000060  6566696e
000064  6564206f
000068  6e206c69
00006c  6e652025
000070  6400    
000072  00                DCB      0
000073  00                DCB      0

                          AREA ||i.close_func||, CODE, READONLY, ALIGN=1

                  close_func PROC
;;;557    
;;;558    static void close_func (LexState *ls) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4606              MOV      r6,r0
;;;559      lua_State *L = ls->L;
000004  6b77              LDR      r7,[r6,#0x34]
;;;560      FuncState *fs = ls->fs;
000006  6b35              LDR      r5,[r6,#0x30]
;;;561      Proto *f = fs->f;
000008  682c              LDR      r4,[r5,#0]
;;;562      luaK_ret(fs, 0, 0);  /* final return */
00000a  2200              MOVS     r2,#0
00000c  4611              MOV      r1,r2
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       luaK_ret
;;;563      leaveblock(fs);
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       leaveblock
;;;564      lua_assert(fs->bl == NULL);
;;;565      luaK_finish(fs);
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       luaK_finish
;;;566      luaM_shrinkvector(L, f->code, f->sizecode, fs->pc, Instruction);
000020  2004              MOVS     r0,#4
000022  9000              STR      r0,[sp,#0]
000024  692b              LDR      r3,[r5,#0x10]
000026  f1040214          ADD      r2,r4,#0x14
00002a  4638              MOV      r0,r7
00002c  6ba1              LDR      r1,[r4,#0x38]
00002e  f7fffffe          BL       luaM_shrinkvector_
000032  63a0              STR      r0,[r4,#0x38]
;;;567      luaM_shrinkvector(L, f->lineinfo, f->sizelineinfo, fs->pc, ls_byte);
000034  2001              MOVS     r0,#1
000036  9000              STR      r0,[sp,#0]
000038  692b              LDR      r3,[r5,#0x10]
00003a  f1040218          ADD      r2,r4,#0x18
00003e  4638              MOV      r0,r7
000040  6c61              LDR      r1,[r4,#0x44]
000042  f7fffffe          BL       luaM_shrinkvector_
000046  6460              STR      r0,[r4,#0x44]
;;;568      luaM_shrinkvector(L, f->abslineinfo, f->sizeabslineinfo,
000048  2008              MOVS     r0,#8
00004a  9000              STR      r0,[sp,#0]
00004c  6a6b              LDR      r3,[r5,#0x24]
00004e  f1040224          ADD      r2,r4,#0x24
000052  4638              MOV      r0,r7
000054  6ca1              LDR      r1,[r4,#0x48]
000056  f7fffffe          BL       luaM_shrinkvector_
00005a  64a0              STR      r0,[r4,#0x48]
;;;569                           fs->nabslineinfo, AbsLineInfo);
;;;570      luaM_shrinkvector(L, f->k, f->sizek, fs->nk, TValue);
00005c  2010              MOVS     r0,#0x10
00005e  9000              STR      r0,[sp,#0]
000060  69eb              LDR      r3,[r5,#0x1c]
000062  f1040210          ADD      r2,r4,#0x10
000066  4638              MOV      r0,r7
000068  6b21              LDR      r1,[r4,#0x30]
00006a  f7fffffe          BL       luaM_shrinkvector_
00006e  6320              STR      r0,[r4,#0x30]
;;;571      luaM_shrinkvector(L, f->p, f->sizep, fs->np, Proto *);
000070  2004              MOVS     r0,#4
000072  9000              STR      r0,[sp,#0]
000074  6a2b              LDR      r3,[r5,#0x20]
000076  f104021c          ADD      r2,r4,#0x1c
00007a  4638              MOV      r0,r7
00007c  6be1              LDR      r1,[r4,#0x3c]
00007e  f7fffffe          BL       luaM_shrinkvector_
000082  63e0              STR      r0,[r4,#0x3c]
;;;572      luaM_shrinkvector(L, f->locvars, f->sizelocvars, fs->nlocvars, LocVar);
000084  200c              MOVS     r0,#0xc
000086  9000              STR      r0,[sp,#0]
000088  f9b5302c          LDRSH    r3,[r5,#0x2c]
00008c  f1040220          ADD      r2,r4,#0x20
000090  4638              MOV      r0,r7
000092  6ce1              LDR      r1,[r4,#0x4c]
000094  f7fffffe          BL       luaM_shrinkvector_
000098  64e0              STR      r0,[r4,#0x4c]
;;;573      luaM_shrinkvector(L, f->upvalues, f->sizeupvalues, fs->nups, Upvaldesc);
00009a  2008              MOVS     r0,#8
00009c  9000              STR      r0,[sp,#0]
00009e  f895302f          LDRB     r3,[r5,#0x2f]
0000a2  f104020c          ADD      r2,r4,#0xc
0000a6  4638              MOV      r0,r7
0000a8  6c21              LDR      r1,[r4,#0x40]
0000aa  f7fffffe          BL       luaM_shrinkvector_
0000ae  6420              STR      r0,[r4,#0x40]
;;;574      ls->fs = fs->prev;
0000b0  6868              LDR      r0,[r5,#4]
0000b2  6330              STR      r0,[r6,#0x30]
;;;575      luaC_checkGC(L);
0000b4  6938              LDR      r0,[r7,#0x10]
0000b6  68c0              LDR      r0,[r0,#0xc]
0000b8  2800              CMP      r0,#0
0000ba  dd03              BLE      |L16.196|
0000bc  4638              MOV      r0,r7
0000be  f7fffffe          BL       luaC_step
0000c2  bf00              NOP      
                  |L16.196|
;;;576    }
0000c4  bdf8              POP      {r3-r7,pc}
;;;577    
                          ENDP


                          AREA ||i.closegoto||, CODE, READONLY, ALIGN=2

                  closegoto PROC
;;;331    
;;;332    static void closegoto (LexState *ls, int g, Labeldesc *label) {
000000  e92d5ffc          PUSH     {r2-r12,lr}
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4691              MOV      r9,r2
;;;333      int i;
;;;334      FuncState *fs = ls->fs;
00000a  6b38              LDR      r0,[r7,#0x30]
00000c  9001              STR      r0,[sp,#4]
;;;335      Labellist *gl = &ls->dyd->gt;
00000e  6c78              LDR      r0,[r7,#0x44]
000010  f100040c          ADD      r4,r0,#0xc
;;;336      Labeldesc *gt = &gl->arr[g];
000014  6820              LDR      r0,[r4,#0]
000016  eb001608          ADD      r6,r0,r8,LSL #4
;;;337      lua_assert(eqstr(gt->name, label->name));
;;;338      if (gt->nactvar < label->nactvar) {
00001a  7b30              LDRB     r0,[r6,#0xc]
00001c  f899100c          LDRB     r1,[r9,#0xc]
000020  4288              CMP      r0,r1
000022  da16              BGE      |L17.82|
;;;339        TString *vname = getlocvar(fs, gt->nactvar)->varname;
000024  7b31              LDRB     r1,[r6,#0xc]
000026  9801              LDR      r0,[sp,#4]
000028  f7fffffe          BL       getlocvar
00002c  f8d0a000          LDR      r10,[r0,#0]
;;;340        const char *msg = luaO_pushfstring(ls->L,
000030  f10a0010          ADD      r0,r10,#0x10
000034  9000              STR      r0,[sp,#0]
000036  6831              LDR      r1,[r6,#0]
000038  f1010210          ADD      r2,r1,#0x10
00003c  68b3              LDR      r3,[r6,#8]
00003e  a114              ADR      r1,|L17.144|
000040  6b78              LDR      r0,[r7,#0x34]
000042  f7fffffe          BL       luaO_pushfstring
000046  4683              MOV      r11,r0
;;;341          "<goto %s> at line %d jumps into the scope of local '%s'",
;;;342          getstr(gt->name), gt->line, getstr(vname));
;;;343        luaK_semerror(ls, msg);
000048  4659              MOV      r1,r11
00004a  4638              MOV      r0,r7
00004c  f7fffffe          BL       luaK_semerror
;;;344      }
000050  bf00              NOP      
                  |L17.82|
;;;345      luaK_patchgoto(fs, gt->pc, label->pc, 1);
000052  f8d92004          LDR      r2,[r9,#4]
000056  2301              MOVS     r3,#1
000058  6871              LDR      r1,[r6,#4]
00005a  9801              LDR      r0,[sp,#4]
00005c  f7fffffe          BL       luaK_patchgoto
;;;346      /* remove goto from pending list */
;;;347      for (i = g; i < gl->n - 1; i++)
000060  4645              MOV      r5,r8
000062  e00b              B        |L17.124|
                  |L17.100|
;;;348        gl->arr[i] = gl->arr[i + 1];
000064  6820              LDR      r0,[r4,#0]
000066  eb001105          ADD      r1,r0,r5,LSL #4
00006a  4602              MOV      r2,r0
00006c  1c68              ADDS     r0,r5,#1
00006e  eb021c00          ADD      r12,r2,r0,LSL #4
000072  e89c100d          LDM      r12,{r0,r2,r3,r12}
000076  e8a1100d          STM      r1!,{r0,r2,r3,r12}
00007a  1c6d              ADDS     r5,r5,#1              ;347
                  |L17.124|
00007c  6860              LDR      r0,[r4,#4]            ;347
00007e  1e40              SUBS     r0,r0,#1              ;347
000080  42a8              CMP      r0,r5                 ;347
000082  dcef              BGT      |L17.100|
;;;349      gl->n--;
000084  6860              LDR      r0,[r4,#4]
000086  1e40              SUBS     r0,r0,#1
000088  6060              STR      r0,[r4,#4]
;;;350    }
00008a  e8bd9ffc          POP      {r2-r12,pc}
;;;351    
                          ENDP

00008e  0000              DCW      0x0000
                  |L17.144|
000090  3c676f74          DCB      "<goto %s> at line %d jumps into the scope of local '%s'"
000094  6f202573
000098  3e206174
00009c  206c696e
0000a0  65202564
0000a4  206a756d
0000a8  70732069
0000ac  6e746f20
0000b0  74686520
0000b4  73636f70
0000b8  65206f66
0000bc  206c6f63
0000c0  616c2027
0000c4  257327  
0000c7  00                DCB      0

                          AREA ||i.closelistfield||, CODE, READONLY, ALIGN=1

                  closelistfield PROC
;;;669    
;;;670    static void closelistfield (FuncState *fs, struct ConsControl *cc) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;671      if (cc->v.k == VVOID) return;  /* there is no list item */
000006  6820              LDR      r0,[r4,#0]
000008  b900              CBNZ     r0,|L18.12|
                  |L18.10|
;;;672      luaK_exp2nextreg(fs, &cc->v);
;;;673      cc->v.k = VVOID;
;;;674      if (cc->tostore == LFIELDS_PER_FLUSH) {
;;;675        luaK_setlist(fs, cc->t->u.info, cc->na, cc->tostore);  /* flush */
;;;676        cc->tostore = 0;  /* no more items pending */
;;;677      }
;;;678    }
00000a  bd70              POP      {r4-r6,pc}
                  |L18.12|
00000c  4621              MOV      r1,r4                 ;672
00000e  4628              MOV      r0,r5                 ;672
000010  f7fffffe          BL       luaK_exp2nextreg
000014  2000              MOVS     r0,#0                 ;673
000016  6020              STR      r0,[r4,#0]            ;673
000018  6a60              LDR      r0,[r4,#0x24]         ;674
00001a  2832              CMP      r0,#0x32              ;674
00001c  d108              BNE      |L18.48|
00001e  e9d42308          LDRD     r2,r3,[r4,#0x20]      ;675
000022  69a0              LDR      r0,[r4,#0x18]         ;675
000024  6881              LDR      r1,[r0,#8]            ;675
000026  4628              MOV      r0,r5                 ;675
000028  f7fffffe          BL       luaK_setlist
00002c  2000              MOVS     r0,#0                 ;676
00002e  6260              STR      r0,[r4,#0x24]         ;676
                  |L18.48|
000030  bf00              NOP      
000032  e7ea              B        |L18.10|
;;;679    
                          ENDP


                          AREA ||i.codeclosure||, CODE, READONLY, ALIGN=1

                  codeclosure PROC
;;;526    */
;;;527    static void codeclosure (LexState *ls, expdesc *v) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;528      FuncState *fs = ls->fs->prev;
000008  6b20              LDR      r0,[r4,#0x30]
00000a  6846              LDR      r6,[r0,#4]
;;;529      init_exp(v, VRELOC, luaK_codeABx(fs, OP_CLOSURE, 0, fs->np - 1));
00000c  6a30              LDR      r0,[r6,#0x20]
00000e  1e43              SUBS     r3,r0,#1
000010  2200              MOVS     r2,#0
000012  214b              MOVS     r1,#0x4b
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       luaK_codeABx
00001a  4607              MOV      r7,r0
00001c  463a              MOV      r2,r7
00001e  210f              MOVS     r1,#0xf
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       init_exp
;;;530      luaK_exp2nextreg(fs, v);  /* fix it at the last register */
000026  4629              MOV      r1,r5
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       luaK_exp2nextreg
;;;531    }
00002e  e8bd81f0          POP      {r4-r8,pc}
;;;532    
                          ENDP


                          AREA ||i.codestring||, CODE, READONLY, ALIGN=1

                  codestring PROC
;;;145    
;;;146    static void codestring (LexState *ls, expdesc *e, TString *s) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;147      init_exp(e, VK, luaK_stringK(ls->fs, s));
00000a  4631              MOV      r1,r6
00000c  6b20              LDR      r0,[r4,#0x30]
00000e  f7fffffe          BL       luaK_stringK
000012  4607              MOV      r7,r0
000014  463a              MOV      r2,r7
000016  2104              MOVS     r1,#4
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       init_exp
;;;148    }
00001e  e8bd81f0          POP      {r4-r8,pc}
;;;149    
                          ENDP


                          AREA ||i.cond||, CODE, READONLY, ALIGN=1

                  cond PROC
;;;1203   
;;;1204   static int cond (LexState *ls) {
000000  b510              PUSH     {r4,lr}
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;1205     /* cond -> exp */
;;;1206     expdesc v;
;;;1207     expr(ls, &v);  /* read condition */
000006  4669              MOV      r1,sp
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       expr
;;;1208     if (v.k == VNIL) v.k = VFALSE;  /* 'falses' are all equal here */
00000e  9800              LDR      r0,[sp,#0]
000010  2801              CMP      r0,#1
000012  d101              BNE      |L21.24|
000014  2003              MOVS     r0,#3
000016  9000              STR      r0,[sp,#0]
                  |L21.24|
;;;1209     luaK_goiftrue(ls->fs, &v);
000018  4669              MOV      r1,sp
00001a  6b20              LDR      r0,[r4,#0x30]
00001c  f7fffffe          BL       luaK_goiftrue
;;;1210     return v.f;
000020  9805              LDR      r0,[sp,#0x14]
;;;1211   }
000022  b006              ADD      sp,sp,#0x18
000024  bd10              POP      {r4,pc}
;;;1212   
                          ENDP


                          AREA ||i.constructor||, CODE, READONLY, ALIGN=1

                  constructor PROC
;;;726    
;;;727    static void constructor (LexState *ls, expdesc *t) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  b08c              SUB      sp,sp,#0x30
000006  4604              MOV      r4,r0
000008  460f              MOV      r7,r1
;;;728      /* constructor -> '{' [ field { sep field } [sep] ] '}'
;;;729         sep -> ',' | ';' */
;;;730      FuncState *fs = ls->fs;
00000a  6b25              LDR      r5,[r4,#0x30]
;;;731      int line = ls->linenumber;
00000c  f8d48004          LDR      r8,[r4,#4]
;;;732      int pc = luaK_codeABC(fs, OP_NEWTABLE, 0, 0, 0);
000010  2000              MOVS     r0,#0
000012  9000              STR      r0,[sp,#0]
000014  4603              MOV      r3,r0
000016  4602              MOV      r2,r0
000018  2111              MOVS     r1,#0x11
00001a  9001              STR      r0,[sp,#4]
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       luaK_codeABCk
000022  4606              MOV      r6,r0
;;;733      struct ConsControl cc;
;;;734      cc.na = cc.nh = cc.tostore = 0;
000024  2000              MOVS     r0,#0
000026  900b              STR      r0,[sp,#0x2c]
000028  9009              STR      r0,[sp,#0x24]
00002a  900a              STR      r0,[sp,#0x28]
;;;735      cc.t = t;
00002c  9708              STR      r7,[sp,#0x20]
;;;736      init_exp(t, VRELOC, pc);
00002e  4632              MOV      r2,r6
000030  210f              MOVS     r1,#0xf
000032  4638              MOV      r0,r7
000034  f7fffffe          BL       init_exp
;;;737      init_exp(&cc.v, VVOID, 0);  /* no value (yet) */
000038  2200              MOVS     r2,#0
00003a  4611              MOV      r1,r2
00003c  a802              ADD      r0,sp,#8
00003e  f7fffffe          BL       init_exp
;;;738      luaK_exp2nextreg(ls->fs, t);  /* fix it at stack top */
000042  4639              MOV      r1,r7
000044  6b20              LDR      r0,[r4,#0x30]
000046  f7fffffe          BL       luaK_exp2nextreg
;;;739      checknext(ls, '{');
00004a  217b              MOVS     r1,#0x7b
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       checknext
;;;740      do {
000052  bf00              NOP      
                  |L22.84|
;;;741        lua_assert(cc.v.k == VVOID || cc.tostore > 0);
;;;742        if (ls->t.token == '}') break;
000054  6920              LDR      r0,[r4,#0x10]
000056  287d              CMP      r0,#0x7d
000058  d100              BNE      |L22.92|
00005a  e013              B        |L22.132|
                  |L22.92|
;;;743        closelistfield(fs, &cc);
00005c  a902              ADD      r1,sp,#8
00005e  4628              MOV      r0,r5
000060  f7fffffe          BL       closelistfield
;;;744        field(ls, &cc);
000064  a902              ADD      r1,sp,#8
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       field
;;;745      } while (testnext(ls, ',') || testnext(ls, ';'));
00006c  212c              MOVS     r1,#0x2c
00006e  4620              MOV      r0,r4
000070  f7fffffe          BL       testnext
000074  2800              CMP      r0,#0
000076  d1ed              BNE      |L22.84|
000078  213b              MOVS     r1,#0x3b
00007a  4620              MOV      r0,r4
00007c  f7fffffe          BL       testnext
000080  2800              CMP      r0,#0
000082  d1e7              BNE      |L22.84|
                  |L22.132|
000084  bf00              NOP                            ;742
;;;746      check_match(ls, '}', '{', line);
000086  4643              MOV      r3,r8
000088  227b              MOVS     r2,#0x7b
00008a  217d              MOVS     r1,#0x7d
00008c  4620              MOV      r0,r4
00008e  f7fffffe          BL       check_match
;;;747      lastlistfield(fs, &cc);
000092  a902              ADD      r1,sp,#8
000094  4628              MOV      r0,r5
000096  f7fffffe          BL       lastlistfield
;;;748      SETARG_B(fs->f->code[pc], luaO_int2fb(cc.na)); /* set initial array size */
00009a  980a              LDR      r0,[sp,#0x28]
00009c  f7fffffe          BL       luaO_int2fb
0000a0  6829              LDR      r1,[r5,#0]
0000a2  6b89              LDR      r1,[r1,#0x38]
0000a4  f8511026          LDR      r1,[r1,r6,LSL #2]
0000a8  f3604117          BFI      r1,r0,#16,#8
0000ac  6828              LDR      r0,[r5,#0]
0000ae  6b80              LDR      r0,[r0,#0x38]
0000b0  f8401026          STR      r1,[r0,r6,LSL #2]
;;;749      SETARG_C(fs->f->code[pc], luaO_int2fb(cc.nh));  /* set initial table size */
0000b4  9809              LDR      r0,[sp,#0x24]
0000b6  f7fffffe          BL       luaO_int2fb
0000ba  6829              LDR      r1,[r5,#0]
0000bc  6b89              LDR      r1,[r1,#0x38]
0000be  f8511026          LDR      r1,[r1,r6,LSL #2]
0000c2  f360611f          BFI      r1,r0,#24,#8
0000c6  6828              LDR      r0,[r5,#0]
0000c8  6b80              LDR      r0,[r0,#0x38]
0000ca  f8401026          STR      r1,[r0,r6,LSL #2]
;;;750    }
0000ce  b00c              ADD      sp,sp,#0x30
0000d0  e8bd81f0          POP      {r4-r8,pc}
;;;751    
                          ENDP


                          AREA ||i.enterblock||, CODE, READONLY, ALIGN=1

                  enterblock PROC
;;;438    
;;;439    static void enterblock (FuncState *fs, BlockCnt *bl, lu_byte isloop) {
000000  74ca              STRB     r2,[r1,#0x13]
;;;440      bl->isloop = isloop;
;;;441      bl->nactvar = fs->nactvar;
000002  f890302e          LDRB     r3,[r0,#0x2e]
000006  744b              STRB     r3,[r1,#0x11]
;;;442      bl->firstlabel = fs->ls->dyd->label.n;
000008  6883              LDR      r3,[r0,#8]
00000a  6c5b              LDR      r3,[r3,#0x44]
00000c  69db              LDR      r3,[r3,#0x1c]
00000e  604b              STR      r3,[r1,#4]
;;;443      bl->firstgoto = fs->ls->dyd->gt.n;
000010  6883              LDR      r3,[r0,#8]
000012  6c5b              LDR      r3,[r3,#0x44]
000014  691b              LDR      r3,[r3,#0x10]
000016  608b              STR      r3,[r1,#8]
;;;444      bl->brks = NO_JUMP;
000018  f04f33ff          MOV      r3,#0xffffffff
00001c  60cb              STR      r3,[r1,#0xc]
;;;445      bl->brkcls = 0;
00001e  2300              MOVS     r3,#0
000020  740b              STRB     r3,[r1,#0x10]
;;;446      bl->upval = 0;
000022  748b              STRB     r3,[r1,#0x12]
;;;447      bl->previous = fs->bl;
000024  68c3              LDR      r3,[r0,#0xc]
000026  600b              STR      r3,[r1,#0]
;;;448      fs->bl = bl;
000028  60c1              STR      r1,[r0,#0xc]
;;;449      lua_assert(fs->freereg == fs->nactvar);
;;;450    }
00002a  4770              BX       lr
;;;451    
                          ENDP


                          AREA ||i.error_expected||, CODE, READONLY, ALIGN=2

                  error_expected PROC
;;;67     
;;;68     static l_noret error_expected (LexState *ls, int token) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;69       luaX_syntaxerror(ls,
000008  4629              MOV      r1,r5
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       luaX_token2str
000010  4607              MOV      r7,r0
000012  463a              MOV      r2,r7
000014  a105              ADR      r1,|L24.44|
000016  6b60              LDR      r0,[r4,#0x34]
000018  f7fffffe          BL       luaO_pushfstring
00001c  4606              MOV      r6,r0
00001e  4631              MOV      r1,r6
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       luaX_syntaxerror
;;;70           luaO_pushfstring(ls->L, "%s expected", luaX_token2str(ls, token)));
;;;71     }
000026  e8bd81f0          POP      {r4-r8,pc}
;;;72     
                          ENDP

00002a  0000              DCW      0x0000
                  |L24.44|
00002c  25732065          DCB      "%s expected",0
000030  78706563
000034  74656400

                          AREA ||i.errorlimit||, CODE, READONLY, ALIGN=2

                  errorlimit PROC
;;;73     
;;;74     static l_noret errorlimit (FuncState *fs, int limit, const char *what) {
000000  e92d4ff8          PUSH     {r3-r11,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4690              MOV      r8,r2
;;;75       lua_State *L = fs->ls->L;
00000a  68a0              LDR      r0,[r4,#8]
00000c  f8d09034          LDR      r9,[r0,#0x34]
;;;76       const char *msg;
;;;77       int line = fs->f->linedefined;
000010  6820              LDR      r0,[r4,#0]
000012  6a87              LDR      r7,[r0,#0x28]
;;;78       const char *where = (line == 0)
000014  b90f              CBNZ     r7,|L25.26|
;;;79                           ? "main function"
000016  a00b              ADR      r0,|L25.68|
000018  e004              B        |L25.36|
                  |L25.26|
;;;80                           : luaO_pushfstring(L, "function at line %d", line);
00001a  463a              MOV      r2,r7
00001c  a10d              ADR      r1,|L25.84|
00001e  4648              MOV      r0,r9
000020  f7fffffe          BL       luaO_pushfstring
                  |L25.36|
000024  4682              MOV      r10,r0
;;;81       msg = luaO_pushfstring(L, "too many %s (limit is %d) in %s",
000026  462b              MOV      r3,r5
000028  4642              MOV      r2,r8
00002a  a10f              ADR      r1,|L25.104|
00002c  4648              MOV      r0,r9
00002e  f8cda000          STR      r10,[sp,#0]
000032  f7fffffe          BL       luaO_pushfstring
000036  4606              MOV      r6,r0
;;;82                                  what, limit, where);
;;;83       luaX_syntaxerror(fs->ls, msg);
000038  4631              MOV      r1,r6
00003a  68a0              LDR      r0,[r4,#8]
00003c  f7fffffe          BL       luaX_syntaxerror
;;;84     }
000040  e8bd8ff8          POP      {r3-r11,pc}
;;;85     
                          ENDP

                  |L25.68|
000044  6d61696e          DCB      "main function",0
000048  2066756e
00004c  6374696f
000050  6e00    
000052  00                DCB      0
000053  00                DCB      0
                  |L25.84|
000054  66756e63          DCB      "function at line %d",0
000058  74696f6e
00005c  20617420
000060  6c696e65
000064  20256400
                  |L25.104|
000068  746f6f20          DCB      "too many %s (limit is %d) in %s",0
00006c  6d616e79
000070  20257320
000074  286c696d
000078  69742069
00007c  73202564
000080  2920696e
000084  20257300

                          AREA ||i.exp1||, CODE, READONLY, ALIGN=1

                  exp1 PROC
;;;1325   */
;;;1326   static int exp1 (LexState *ls, int i) {
000000  b570              PUSH     {r4-r6,lr}
000002  b086              SUB      sp,sp,#0x18
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;1327     expdesc e;
;;;1328     int res;
;;;1329     expr(ls, &e);
000008  4669              MOV      r1,sp
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       expr
;;;1330     res = luaK_isKint(&e) && (i == 0 || i == e.u.ival);
000010  4668              MOV      r0,sp
000012  f7fffffe          BL       luaK_isKint
000016  b148              CBZ      r0,|L26.44|
000018  b134              CBZ      r4,|L26.40|
00001a  e9dd1202          LDRD     r1,r2,[sp,#8]
00001e  4061              EORS     r1,r1,r4
000020  ea8270e4          EOR      r0,r2,r4,ASR #31
000024  4301              ORRS     r1,r1,r0
000026  d101              BNE      |L26.44|
                  |L26.40|
000028  2001              MOVS     r0,#1
00002a  e000              B        |L26.46|
                  |L26.44|
00002c  2000              MOVS     r0,#0
                  |L26.46|
00002e  4606              MOV      r6,r0
;;;1331     luaK_exp2nextreg(ls->fs, &e);
000030  4669              MOV      r1,sp
000032  6b28              LDR      r0,[r5,#0x30]
000034  f7fffffe          BL       luaK_exp2nextreg
;;;1332     lua_assert(e.k == VNONRELOC);
;;;1333     return res;
000038  4630              MOV      r0,r6
;;;1334   }
00003a  b006              ADD      sp,sp,#0x18
00003c  bd70              POP      {r4-r6,pc}
;;;1335   
                          ENDP


                          AREA ||i.explist||, CODE, READONLY, ALIGN=1

                  explist PROC
;;;813    
;;;814    static int explist (LexState *ls, expdesc *v) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;815      /* explist -> expr { ',' expr } */
;;;816      int n = 1;  /* at least one expression */
000006  2501              MOVS     r5,#1
;;;817      expr(ls, v);
000008  4631              MOV      r1,r6
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       expr
;;;818      while (testnext(ls, ',')) {
000010  e008              B        |L27.36|
                  |L27.18|
;;;819        luaK_exp2nextreg(ls->fs, v);
000012  4631              MOV      r1,r6
000014  6b20              LDR      r0,[r4,#0x30]
000016  f7fffffe          BL       luaK_exp2nextreg
;;;820        expr(ls, v);
00001a  4631              MOV      r1,r6
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       expr
;;;821        n++;
000022  1c6d              ADDS     r5,r5,#1
                  |L27.36|
000024  212c              MOVS     r1,#0x2c              ;818
000026  4620              MOV      r0,r4                 ;818
000028  f7fffffe          BL       testnext
00002c  2800              CMP      r0,#0                 ;818
00002e  d1f0              BNE      |L27.18|
;;;822      }
;;;823      return n;
000030  4628              MOV      r0,r5
;;;824    }
000032  bd70              POP      {r4-r6,pc}
;;;825    
                          ENDP


                          AREA ||i.expr||, CODE, READONLY, ALIGN=1

                  expr PROC
;;;1092   
;;;1093   static void expr (LexState *ls, expdesc *v) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1094     subexpr(ls, v, 0);
000006  2200              MOVS     r2,#0
000008  4629              MOV      r1,r5
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       subexpr
;;;1095   }
000010  bd70              POP      {r4-r6,pc}
;;;1096   
                          ENDP


                          AREA ||i.exprstat||, CODE, READONLY, ALIGN=2

                  exprstat PROC
;;;1566   
;;;1567   static void exprstat (LexState *ls) {
000000  b570              PUSH     {r4-r6,lr}
000002  b088              SUB      sp,sp,#0x20
000004  4604              MOV      r4,r0
;;;1568     /* stat -> func | assignment */
;;;1569     FuncState *fs = ls->fs;
000006  6b26              LDR      r6,[r4,#0x30]
;;;1570     struct LHS_assign v;
;;;1571     suffixedexp(ls, &v.v);
000008  a902              ADD      r1,sp,#8
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       suffixedexp
;;;1572     if (ls->t.token == '=' || ls->t.token == ',') { /* stat -> assignment ? */
000010  6920              LDR      r0,[r4,#0x10]
000012  283d              CMP      r0,#0x3d
000014  d002              BEQ      |L29.28|
000016  6920              LDR      r0,[r4,#0x10]
000018  282c              CMP      r0,#0x2c
00001a  d107              BNE      |L29.44|
                  |L29.28|
;;;1573       v.prev = NULL;
00001c  2000              MOVS     r0,#0
00001e  9000              STR      r0,[sp,#0]
;;;1574       assignment(ls, &v, 1);
000020  2201              MOVS     r2,#1
000022  4669              MOV      r1,sp
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       assignment
00002a  e012              B        |L29.82|
                  |L29.44|
;;;1575     }
;;;1576     else {  /* stat -> func */
;;;1577       Instruction *inst = &getinstruction(fs, &v.v);
00002c  6830              LDR      r0,[r6,#0]
00002e  6b81              LDR      r1,[r0,#0x38]
000030  9804              LDR      r0,[sp,#0x10]
000032  eb010580          ADD      r5,r1,r0,LSL #2
;;;1578       check_condition(ls, v.v.k == VCALL, "syntax error");
000036  9802              LDR      r0,[sp,#8]
000038  2810              CMP      r0,#0x10
00003a  d003              BEQ      |L29.68|
00003c  a106              ADR      r1,|L29.88|
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       luaX_syntaxerror
                  |L29.68|
;;;1579       SETARG_C(*inst, 1);  /* call statement uses no results */
000044  6828              LDR      r0,[r5,#0]
000046  f020407f          BIC      r0,r0,#0xff000000
00004a  f0407080          ORR      r0,r0,#0x1000000
00004e  6028              STR      r0,[r5,#0]
;;;1580     }
000050  bf00              NOP      
                  |L29.82|
;;;1581   }
000052  b008              ADD      sp,sp,#0x20
000054  bd70              POP      {r4-r6,pc}
;;;1582   
                          ENDP

000056  0000              DCW      0x0000
                  |L29.88|
000058  73796e74          DCB      "syntax error",0
00005c  61782065
000060  72726f72
000064  00      
000065  00                DCB      0
000066  00                DCB      0
000067  00                DCB      0

                          AREA ||i.field||, CODE, READONLY, ALIGN=1

                  field PROC
;;;704    
;;;705    static void field (LexState *ls, struct ConsControl *cc) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;706      /* field -> listfield | recfield */
;;;707      switch(ls->t.token) {
000006  6920              LDR      r0,[r4,#0x10]
000008  285b              CMP      r0,#0x5b
00000a  d011              BEQ      |L30.48|
00000c  f2a01025          SUB      r0,r0,#0x125
000010  b998              CBNZ     r0,|L30.58|
;;;708        case TK_NAME: {  /* may be 'listfield' or 'recfield' */
;;;709          if (luaX_lookahead(ls) != '=')  /* expression? */
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       luaX_lookahead
000018  283d              CMP      r0,#0x3d
00001a  d004              BEQ      |L30.38|
;;;710            listfield(ls, cc);
00001c  4629              MOV      r1,r5
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       listfield
000024  e003              B        |L30.46|
                  |L30.38|
;;;711          else
;;;712            recfield(ls, cc);
000026  4629              MOV      r1,r5
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       recfield
                  |L30.46|
;;;713          break;
00002e  e009              B        |L30.68|
                  |L30.48|
;;;714        }
;;;715        case '[': {
;;;716          recfield(ls, cc);
000030  4629              MOV      r1,r5
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       recfield
;;;717          break;
000038  e004              B        |L30.68|
                  |L30.58|
;;;718        }
;;;719        default: {
;;;720          listfield(ls, cc);
00003a  4629              MOV      r1,r5
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       listfield
;;;721          break;
000042  bf00              NOP      
                  |L30.68|
000044  bf00              NOP                            ;713
;;;722        }
;;;723      }
;;;724    }
000046  bd70              POP      {r4-r6,pc}
;;;725    
                          ENDP


                          AREA ||i.fieldsel||, CODE, READONLY, ALIGN=1

                  fieldsel PROC
;;;612    
;;;613    static void fieldsel (LexState *ls, expdesc *v) {
000000  b570              PUSH     {r4-r6,lr}
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;614      /* fieldsel -> ['.' | ':'] NAME */
;;;615      FuncState *fs = ls->fs;
000008  6b26              LDR      r6,[r4,#0x30]
;;;616      expdesc key;
;;;617      luaK_exp2anyregup(fs, v);
00000a  4629              MOV      r1,r5
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       luaK_exp2anyregup
;;;618      luaX_next(ls);  /* skip the dot or colon */
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       luaX_next
;;;619      checkname(ls, &key);
000018  4669              MOV      r1,sp
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       checkname
;;;620      luaK_indexed(fs, v, &key);
000020  466a              MOV      r2,sp
000022  4629              MOV      r1,r5
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       luaK_indexed
;;;621    }
00002a  b006              ADD      sp,sp,#0x18
00002c  bd70              POP      {r4-r6,pc}
;;;622    
                          ENDP


                          AREA ||i.fixbreaks||, CODE, READONLY, ALIGN=1

                  fixbreaks PROC
;;;455    */
;;;456    static void fixbreaks (FuncState *fs, BlockCnt *bl) {
000000  b57c              PUSH     {r2-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;457      int target = fs->pc;
000006  692e              LDR      r6,[r5,#0x10]
;;;458      if (bl->brkcls)  /* does the block need to close upvalues? */
000008  7c20              LDRB     r0,[r4,#0x10]
00000a  b140              CBZ      r0,|L32.30|
;;;459        luaK_codeABC(fs, OP_CLOSE, bl->nactvar, 0, 0);
00000c  2000              MOVS     r0,#0
00000e  9000              STR      r0,[sp,#0]
000010  9001              STR      r0,[sp,#4]
000012  7c62              LDRB     r2,[r4,#0x11]
000014  4603              MOV      r3,r0
000016  2130              MOVS     r1,#0x30
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       luaK_codeABCk
                  |L32.30|
;;;460      luaK_patchgoto(fs, bl->brks, target, bl->brkcls);
00001e  7c23              LDRB     r3,[r4,#0x10]
000020  4632              MOV      r2,r6
000022  4628              MOV      r0,r5
000024  68e1              LDR      r1,[r4,#0xc]
000026  f7fffffe          BL       luaK_patchgoto
;;;461      bl->brks = NO_JUMP;  /* no more breaks to fix */
00002a  f04f30ff          MOV      r0,#0xffffffff
00002e  60e0              STR      r0,[r4,#0xc]
;;;462      bl->brkcls = 0;  /* no more need to close upvalues */
000030  2000              MOVS     r0,#0
000032  7420              STRB     r0,[r4,#0x10]
;;;463      lua_assert(!bl->upval);  /* loop body cannot have local variables */
;;;464    }
000034  bd7c              POP      {r2-r6,pc}
;;;465    
                          ENDP


                          AREA ||i.fixforjump||, CODE, READONLY, ALIGN=2

                  fixforjump PROC
;;;1341   */
;;;1342   static void fixforjump (FuncState *fs, int pc, int dest, int back) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;1343     Instruction *jmp = &fs->f->code[pc];
00000c  6820              LDR      r0,[r4,#0]
00000e  6b80              LDR      r0,[r0,#0x38]
000010  eb000985          ADD      r9,r0,r5,LSL #2
;;;1344     int offset = dest - (pc + 1);
000014  1c68              ADDS     r0,r5,#1
000016  1a3e              SUBS     r6,r7,r0
;;;1345     if (back)
000018  f1b80f00          CMP      r8,#0
00001c  d000              BEQ      |L33.32|
;;;1346       offset = -offset;
00001e  4276              RSBS     r6,r6,#0
                  |L33.32|
;;;1347     if (offset > MAXARG_Bx)
000020  f5b63f00          CMP      r6,#0x20000
000024  db03              BLT      |L33.46|
;;;1348       luaX_syntaxerror(fs->ls, "control structure too long");
000026  a106              ADR      r1,|L33.64|
000028  68a0              LDR      r0,[r4,#8]
00002a  f7fffffe          BL       luaX_syntaxerror
                  |L33.46|
;;;1349     SETARG_Bx(*jmp, offset);
00002e  f8d90000          LDR      r0,[r9,#0]
000032  f36630df          BFI      r0,r6,#15,#17
000036  f8c90000          STR      r0,[r9,#0]
;;;1350   }
00003a  e8bd87f0          POP      {r4-r10,pc}
;;;1351   
                          ENDP

00003e  0000              DCW      0x0000
                  |L33.64|
000040  636f6e74          DCB      "control structure too long",0
000044  726f6c20
000048  73747275
00004c  63747572
000050  6520746f
000054  6f206c6f
000058  6e6700  
00005b  00                DCB      0

                          AREA ||i.forbody||, CODE, READONLY, ALIGN=1

                  forbody PROC
;;;1357   */
;;;1358   static void forbody (LexState *ls, int base, int line, int nvars, int kind) {
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b087              SUB      sp,sp,#0x1c
000006  4680              MOV      r8,r0
000008  460d              MOV      r5,r1
00000a  4691              MOV      r9,r2
00000c  461e              MOV      r6,r3
00000e  9c10              LDR      r4,[sp,#0x40]
;;;1359     /* forbody -> DO block */
;;;1360     BlockCnt bl;
;;;1361     FuncState *fs = ls->fs;
000010  f8d8b030          LDR      r11,[r8,#0x30]
;;;1362     int prep, endfor;
;;;1363     adjustlocalvars(ls, 3);  /* control variables */
000014  2103              MOVS     r1,#3
000016  4640              MOV      r0,r8
000018  f7fffffe          BL       adjustlocalvars
;;;1364     checknext(ls, TK_DO);
00001c  f2401103          MOV      r1,#0x103
000020  4640              MOV      r0,r8
000022  f7fffffe          BL       checknext
;;;1365     prep = (kind == 0) ? luaK_codeABx(fs, OP_FORPREP, base, 0)
000026  b934              CBNZ     r4,|L34.54|
000028  2300              MOVS     r3,#0
00002a  462a              MOV      r2,r5
00002c  2147              MOVS     r1,#0x47
00002e  4658              MOV      r0,r11
000030  f7fffffe          BL       luaK_codeABx
000034  e00b              B        |L34.78|
                  |L34.54|
;;;1366          : (kind == 1) ? luaK_codeABx(fs, OP_FORPREP1, base, 0)
000036  2c01              CMP      r4,#1
000038  d106              BNE      |L34.72|
00003a  2300              MOVS     r3,#0
00003c  462a              MOV      r2,r5
00003e  2145              MOVS     r1,#0x45
000040  4658              MOV      r0,r11
000042  f7fffffe          BL       luaK_codeABx
000046  e002              B        |L34.78|
                  |L34.72|
;;;1367          : luaK_jump(fs);
000048  4658              MOV      r0,r11
00004a  f7fffffe          BL       luaK_jump
                  |L34.78|
00004e  4682              MOV      r10,r0
;;;1368     enterblock(fs, &bl, 0);  /* scope for declared variables */
000050  2200              MOVS     r2,#0
000052  a902              ADD      r1,sp,#8
000054  4658              MOV      r0,r11
000056  f7fffffe          BL       enterblock
;;;1369     adjustlocalvars(ls, nvars);
00005a  4631              MOV      r1,r6
00005c  4640              MOV      r0,r8
00005e  f7fffffe          BL       adjustlocalvars
;;;1370     luaK_reserveregs(fs, nvars);
000062  4631              MOV      r1,r6
000064  4658              MOV      r0,r11
000066  f7fffffe          BL       luaK_reserveregs
;;;1371     block(ls);
00006a  4640              MOV      r0,r8
00006c  f7fffffe          BL       block
;;;1372     leaveblock(fs);  /* end of scope for declared variables */
000070  4658              MOV      r0,r11
000072  f7fffffe          BL       leaveblock
;;;1373     if (kind == 2) {  /* generic for? */
000076  2c02              CMP      r4,#2
000078  d118              BNE      |L34.172|
;;;1374       luaK_patchtohere(fs, prep);
00007a  4651              MOV      r1,r10
00007c  4658              MOV      r0,r11
00007e  f7fffffe          BL       luaK_patchtohere
;;;1375       luaK_codeABC(fs, OP_TFORCALL, base, 0, nvars);
000082  2000              MOVS     r0,#0
000084  4603              MOV      r3,r0
000086  462a              MOV      r2,r5
000088  2148              MOVS     r1,#0x48
00008a  e9cd6000          STRD     r6,r0,[sp,#0]
00008e  4658              MOV      r0,r11
000090  f7fffffe          BL       luaK_codeABCk
;;;1376       luaK_fixline(fs, line);
000094  4649              MOV      r1,r9
000096  4658              MOV      r0,r11
000098  f7fffffe          BL       luaK_fixline
;;;1377       endfor = luaK_codeABx(fs, OP_TFORLOOP, base + 2, 0);
00009c  2300              MOVS     r3,#0
00009e  1caa              ADDS     r2,r5,#2
0000a0  2149              MOVS     r1,#0x49
0000a2  4658              MOV      r0,r11
0000a4  f7fffffe          BL       luaK_codeABx
0000a8  4607              MOV      r7,r0
0000aa  e018              B        |L34.222|
                  |L34.172|
;;;1378     }
;;;1379     else {
;;;1380       fixforjump(fs, prep, luaK_getlabel(fs), 0);
0000ac  4658              MOV      r0,r11
0000ae  f7fffffe          BL       luaK_getlabel
0000b2  2300              MOVS     r3,#0
0000b4  4602              MOV      r2,r0
0000b6  4651              MOV      r1,r10
0000b8  9001              STR      r0,[sp,#4]
0000ba  4658              MOV      r0,r11
0000bc  f7fffffe          BL       fixforjump
;;;1381       endfor = (kind == 0) ? luaK_codeABx(fs, OP_FORLOOP, base, 0)
0000c0  b934              CBNZ     r4,|L34.208|
0000c2  2300              MOVS     r3,#0
0000c4  462a              MOV      r2,r5
0000c6  2146              MOVS     r1,#0x46
0000c8  4658              MOV      r0,r11
0000ca  f7fffffe          BL       luaK_codeABx
0000ce  e005              B        |L34.220|
                  |L34.208|
;;;1382                            : luaK_codeABx(fs, OP_FORLOOP1, base, 0);
0000d0  2300              MOVS     r3,#0
0000d2  462a              MOV      r2,r5
0000d4  2144              MOVS     r1,#0x44
0000d6  4658              MOV      r0,r11
0000d8  f7fffffe          BL       luaK_codeABx
                  |L34.220|
0000dc  4607              MOV      r7,r0
                  |L34.222|
;;;1383     }
;;;1384     fixforjump(fs, endfor, prep + 1, 1);
0000de  2301              MOVS     r3,#1
0000e0  f10a0201          ADD      r2,r10,#1
0000e4  4639              MOV      r1,r7
0000e6  4658              MOV      r0,r11
0000e8  f7fffffe          BL       fixforjump
;;;1385     luaK_fixline(fs, line);
0000ec  4649              MOV      r1,r9
0000ee  4658              MOV      r0,r11
0000f0  f7fffffe          BL       luaK_fixline
;;;1386   }
0000f4  b007              ADD      sp,sp,#0x1c
0000f6  e8bd8ff0          POP      {r4-r11,pc}
;;;1387   
                          ENDP


                          AREA ||i.forlist||, CODE, READONLY, ALIGN=2

                  forlist PROC
;;;1414   
;;;1415   static void forlist (LexState *ls, TString *indexname) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  b088              SUB      sp,sp,#0x20
000006  4604              MOV      r4,r0
000008  4688              MOV      r8,r1
;;;1416     /* forlist -> NAME {,NAME} IN explist forbody */
;;;1417     FuncState *fs = ls->fs;
00000a  6b25              LDR      r5,[r4,#0x30]
;;;1418     expdesc e;
;;;1419     int nvars = 4;  /* gen, state, control, plus at least one declared var */
00000c  2604              MOVS     r6,#4
;;;1420     int line;
;;;1421     int base = fs->freereg;
00000e  f8959030          LDRB     r9,[r5,#0x30]
;;;1422     /* create control variables */
;;;1423     new_localvarliteral(ls, "(for generator)");
000012  220f              MOVS     r2,#0xf
000014  a120              ADR      r1,|L35.152|
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       new_localvarliteral_
;;;1424     new_localvarliteral(ls, "(for state)");
00001c  220b              MOVS     r2,#0xb
00001e  a122              ADR      r1,|L35.168|
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       new_localvarliteral_
;;;1425     new_localvarliteral(ls, "(for control)");
000026  220d              MOVS     r2,#0xd
000028  a122              ADR      r1,|L35.180|
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       new_localvarliteral_
;;;1426     /* create declared variables */
;;;1427     new_localvar(ls, indexname);
000030  4641              MOV      r1,r8
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       new_localvar
;;;1428     while (testnext(ls, ',')) {
000038  e008              B        |L35.76|
                  |L35.58|
;;;1429       new_localvar(ls, str_checkname(ls));
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       str_checkname
000040  4682              MOV      r10,r0
000042  4651              MOV      r1,r10
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       new_localvar
;;;1430       nvars++;
00004a  1c76              ADDS     r6,r6,#1
                  |L35.76|
00004c  212c              MOVS     r1,#0x2c              ;1428
00004e  4620              MOV      r0,r4                 ;1428
000050  f7fffffe          BL       testnext
000054  2800              CMP      r0,#0                 ;1428
000056  d1f0              BNE      |L35.58|
;;;1431     }
;;;1432     checknext(ls, TK_IN);
000058  f44f7186          MOV      r1,#0x10c
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       checknext
;;;1433     line = ls->linenumber;
000062  6867              LDR      r7,[r4,#4]
;;;1434     adjust_assign(ls, 3, explist(ls, &e), &e);
000064  a902              ADD      r1,sp,#8
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       explist
00006c  4682              MOV      r10,r0
00006e  ab02              ADD      r3,sp,#8
000070  4652              MOV      r2,r10
000072  2103              MOVS     r1,#3
000074  4620              MOV      r0,r4
000076  f7fffffe          BL       adjust_assign
;;;1435     luaK_checkstack(fs, 3);  /* extra space to call generator */
00007a  2103              MOVS     r1,#3
00007c  4628              MOV      r0,r5
00007e  f7fffffe          BL       luaK_checkstack
;;;1436     forbody(ls, base, line, nvars - 3, 2);
000082  2002              MOVS     r0,#2
000084  1ef3              SUBS     r3,r6,#3
000086  463a              MOV      r2,r7
000088  4649              MOV      r1,r9
00008a  9000              STR      r0,[sp,#0]
00008c  4620              MOV      r0,r4
00008e  f7fffffe          BL       forbody
;;;1437   }
000092  b008              ADD      sp,sp,#0x20
000094  e8bd87f0          POP      {r4-r10,pc}
;;;1438   
                          ENDP

                  |L35.152|
000098  28666f72          DCB      "(for generator)",0
00009c  2067656e
0000a0  65726174
0000a4  6f722900
                  |L35.168|
0000a8  28666f72          DCB      "(for state)",0
0000ac  20737461
0000b0  74652900
                  |L35.180|
0000b4  28666f72          DCB      "(for control)",0
0000b8  20636f6e
0000bc  74726f6c
0000c0  2900    
0000c2  00                DCB      0
0000c3  00                DCB      0

                          AREA ||i.fornum||, CODE, READONLY, ALIGN=2

                  fornum PROC
;;;1388   
;;;1389   static void fornum (LexState *ls, TString *varname, int line) {
000000  e92d43f8          PUSH     {r3-r9,lr}
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;1390     /* fornum -> NAME = exp,exp[,exp] forbody */
;;;1391     FuncState *fs = ls->fs;
00000a  6b2c              LDR      r4,[r5,#0x30]
;;;1392     int base = fs->freereg;
00000c  f8948030          LDRB     r8,[r4,#0x30]
;;;1393     int basicfor = 1;  /* true if it is a "basic" 'for' (integer + 1) */
000010  f04f0901          MOV      r9,#1
;;;1394     new_localvarliteral(ls, "(for index)");
000014  220b              MOVS     r2,#0xb
000016  a123              ADR      r1,|L36.164|
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       new_localvarliteral_
;;;1395     new_localvarliteral(ls, "(for limit)");
00001e  220b              MOVS     r2,#0xb
000020  a123              ADR      r1,|L36.176|
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       new_localvarliteral_
;;;1396     new_localvarliteral(ls, "(for step)");
000028  220a              MOVS     r2,#0xa
00002a  a124              ADR      r1,|L36.188|
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       new_localvarliteral_
;;;1397     new_localvar(ls, varname);
000032  4631              MOV      r1,r6
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       new_localvar
;;;1398     checknext(ls, '=');
00003a  213d              MOVS     r1,#0x3d
00003c  4628              MOV      r0,r5
00003e  f7fffffe          BL       checknext
;;;1399     if (!exp1(ls, 0))  /* initial value not an integer? */
000042  2100              MOVS     r1,#0
000044  4628              MOV      r0,r5
000046  f7fffffe          BL       exp1
00004a  b908              CBNZ     r0,|L36.80|
;;;1400       basicfor = 0;  /* not a basic 'for' */
00004c  f04f0900          MOV      r9,#0
                  |L36.80|
;;;1401     checknext(ls, ',');
000050  212c              MOVS     r1,#0x2c
000052  4628              MOV      r0,r5
000054  f7fffffe          BL       checknext
;;;1402     exp1(ls, 0);  /* limit */
000058  2100              MOVS     r1,#0
00005a  4628              MOV      r0,r5
00005c  f7fffffe          BL       exp1
;;;1403     if (testnext(ls, ',')) {
000060  212c              MOVS     r1,#0x2c
000062  4628              MOV      r0,r5
000064  f7fffffe          BL       testnext
000068  b138              CBZ      r0,|L36.122|
;;;1404       if (!exp1(ls, 1))  /* optional step not 1? */
00006a  2101              MOVS     r1,#1
00006c  4628              MOV      r0,r5
00006e  f7fffffe          BL       exp1
000072  b968              CBNZ     r0,|L36.144|
;;;1405         basicfor = 0;  /* not a basic 'for' */
000074  f04f0900          MOV      r9,#0
000078  e00a              B        |L36.144|
                  |L36.122|
;;;1406     }
;;;1407     else {  /* default step = 1 */
;;;1408       luaK_int(fs, fs->freereg, 1);
00007a  f8941030          LDRB     r1,[r4,#0x30]
00007e  2201              MOVS     r2,#1
000080  2300              MOVS     r3,#0
000082  4620              MOV      r0,r4
000084  f7fffffe          BL       luaK_int
;;;1409       luaK_reserveregs(fs, 1);
000088  2101              MOVS     r1,#1
00008a  4620              MOV      r0,r4
00008c  f7fffffe          BL       luaK_reserveregs
                  |L36.144|
;;;1410     }
;;;1411     forbody(ls, base, line, 1, basicfor);
000090  2301              MOVS     r3,#1
000092  463a              MOV      r2,r7
000094  4641              MOV      r1,r8
000096  4628              MOV      r0,r5
000098  f8cd9000          STR      r9,[sp,#0]
00009c  f7fffffe          BL       forbody
;;;1412   }
0000a0  e8bd83f8          POP      {r3-r9,pc}
;;;1413   
                          ENDP

                  |L36.164|
0000a4  28666f72          DCB      "(for index)",0
0000a8  20696e64
0000ac  65782900
                  |L36.176|
0000b0  28666f72          DCB      "(for limit)",0
0000b4  206c696d
0000b8  69742900
                  |L36.188|
0000bc  28666f72          DCB      "(for step)",0
0000c0  20737465
0000c4  702900  
0000c7  00                DCB      0

                          AREA ||i.forstat||, CODE, READONLY, ALIGN=2

                  forstat PROC
;;;1439   
;;;1440   static void forstat (LexState *ls, int line) {
000000  b5f0              PUSH     {r4-r7,lr}
000002  b085              SUB      sp,sp,#0x14
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;1441     /* forstat -> FOR (fornum | forlist) END */
;;;1442     FuncState *fs = ls->fs;
000008  6b26              LDR      r6,[r4,#0x30]
;;;1443     TString *varname;
;;;1444     BlockCnt bl;
;;;1445     enterblock(fs, &bl, 1);  /* scope for loop and control variables */
00000a  2201              MOVS     r2,#1
00000c  4669              MOV      r1,sp
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       enterblock
;;;1446     luaX_next(ls);  /* skip 'for' */
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       luaX_next
;;;1447     varname = str_checkname(ls);  /* first variable name */
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       str_checkname
000020  4607              MOV      r7,r0
;;;1448     switch (ls->t.token) {
000022  6920              LDR      r0,[r4,#0x10]
000024  282c              CMP      r0,#0x2c
000026  d00b              BEQ      |L37.64|
000028  283d              CMP      r0,#0x3d
00002a  d003              BEQ      |L37.52|
00002c  f5b07f86          CMP      r0,#0x10c
000030  d10c              BNE      |L37.76|
000032  e006              B        |L37.66|
                  |L37.52|
;;;1449       case '=': fornum(ls, varname, line); break;
000034  462a              MOV      r2,r5
000036  4639              MOV      r1,r7
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       fornum
00003e  e00a              B        |L37.86|
                  |L37.64|
;;;1450       case ',': case TK_IN: forlist(ls, varname); break;
000040  bf00              NOP      
                  |L37.66|
000042  4639              MOV      r1,r7
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       forlist
00004a  e004              B        |L37.86|
                  |L37.76|
;;;1451       default: luaX_syntaxerror(ls, "'=' or 'in' expected");
00004c  a108              ADR      r1,|L37.112|
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       luaX_syntaxerror
000054  bf00              NOP                            ;1448
                  |L37.86|
000056  bf00              NOP                            ;1449
;;;1452     }
;;;1453     check_match(ls, TK_END, TK_FOR, line);
000058  462b              MOV      r3,r5
00005a  f44f7284          MOV      r2,#0x108
00005e  1e91              SUBS     r1,r2,#2
000060  4620              MOV      r0,r4
000062  f7fffffe          BL       check_match
;;;1454     leaveblock(fs);  /* loop scope ('break' jumps to this point) */
000066  4630              MOV      r0,r6
000068  f7fffffe          BL       leaveblock
;;;1455   }
00006c  b005              ADD      sp,sp,#0x14
00006e  bdf0              POP      {r4-r7,pc}
;;;1456   
                          ENDP

                  |L37.112|
000070  273d2720          DCB      "'=' or 'in' expected",0
000074  6f722027
000078  696e2720
00007c  65787065
000080  63746564
000084  00      
000085  00                DCB      0
000086  00                DCB      0
000087  00                DCB      0

                          AREA ||i.funcargs||, CODE, READONLY, ALIGN=2

                  funcargs PROC
;;;826    
;;;827    static void funcargs (LexState *ls, expdesc *f, int line) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  b088              SUB      sp,sp,#0x20
000006  4604              MOV      r4,r0
000008  460e              MOV      r6,r1
00000a  4617              MOV      r7,r2
;;;828      FuncState *fs = ls->fs;
00000c  f8d48030          LDR      r8,[r4,#0x30]
;;;829      expdesc args;
;;;830      int base, nparams;
;;;831      switch (ls->t.token) {
000010  6920              LDR      r0,[r4,#0x10]
000012  2828              CMP      r0,#0x28
000014  d005              BEQ      |L38.34|
000016  287b              CMP      r0,#0x7b
000018  d01d              BEQ      |L38.86|
00001a  f5b07f93          CMP      r0,#0x126
00001e  d128              BNE      |L38.114|
000020  e01e              B        |L38.96|
                  |L38.34|
;;;832        case '(': {  /* funcargs -> '(' [ explist ] ')' */
;;;833          luaX_next(ls);
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       luaX_next
;;;834          if (ls->t.token == ')')  /* arg list is empty? */
000028  6920              LDR      r0,[r4,#0x10]
00002a  2829              CMP      r0,#0x29
00002c  d102              BNE      |L38.52|
;;;835            args.k = VVOID;
00002e  2000              MOVS     r0,#0
000030  9002              STR      r0,[sp,#8]
000032  e009              B        |L38.72|
                  |L38.52|
;;;836          else {
;;;837            explist(ls, &args);
000034  a902              ADD      r1,sp,#8
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       explist
;;;838            luaK_setmultret(fs, &args);
00003c  f04f32ff          MOV      r2,#0xffffffff
000040  a902              ADD      r1,sp,#8
000042  4640              MOV      r0,r8
000044  f7fffffe          BL       luaK_setreturns
                  |L38.72|
;;;839          }
;;;840          check_match(ls, ')', '(', line);
000048  463b              MOV      r3,r7
00004a  2228              MOVS     r2,#0x28
00004c  2129              MOVS     r1,#0x29
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       check_match
;;;841          break;
000054  e012              B        |L38.124|
                  |L38.86|
;;;842        }
;;;843        case '{': {  /* funcargs -> constructor */
;;;844          constructor(ls, &args);
000056  a902              ADD      r1,sp,#8
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       constructor
;;;845          break;
00005e  e00d              B        |L38.124|
                  |L38.96|
;;;846        }
;;;847        case TK_STRING: {  /* funcargs -> STRING */
;;;848          codestring(ls, &args, ls->t.seminfo.ts);
000060  a902              ADD      r1,sp,#8
000062  4620              MOV      r0,r4
000064  69a2              LDR      r2,[r4,#0x18]
000066  f7fffffe          BL       codestring
;;;849          luaX_next(ls);  /* must use 'seminfo' before 'next' */
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       luaX_next
;;;850          break;
000070  e004              B        |L38.124|
                  |L38.114|
;;;851        }
;;;852        default: {
;;;853          luaX_syntaxerror(ls, "function arguments expected");
000072  a11b              ADR      r1,|L38.224|
000074  4620              MOV      r0,r4
000076  f7fffffe          BL       luaX_syntaxerror
00007a  bf00              NOP                            ;831
                  |L38.124|
00007c  bf00              NOP                            ;841
;;;854        }
;;;855      }
;;;856      lua_assert(f->k == VNONRELOC);
;;;857      base = f->u.info;  /* base register for call */
00007e  68b5              LDR      r5,[r6,#8]
;;;858      if (hasmultret(args.k))
000080  9802              LDR      r0,[sp,#8]
000082  2810              CMP      r0,#0x10
000084  d002              BEQ      |L38.140|
000086  9802              LDR      r0,[sp,#8]
000088  2811              CMP      r0,#0x11
00008a  d102              BNE      |L38.146|
                  |L38.140|
;;;859        nparams = LUA_MULTRET;  /* open call */
00008c  f04f39ff          MOV      r9,#0xffffffff
000090  e00a              B        |L38.168|
                  |L38.146|
;;;860      else {
;;;861        if (args.k != VVOID)
000092  9802              LDR      r0,[sp,#8]
000094  b118              CBZ      r0,|L38.158|
;;;862          luaK_exp2nextreg(fs, &args);  /* close last argument */
000096  a902              ADD      r1,sp,#8
000098  4640              MOV      r0,r8
00009a  f7fffffe          BL       luaK_exp2nextreg
                  |L38.158|
;;;863        nparams = fs->freereg - (base+1);
00009e  f8981030          LDRB     r1,[r8,#0x30]
0000a2  1c68              ADDS     r0,r5,#1
0000a4  eba10900          SUB      r9,r1,r0
                  |L38.168|
;;;864      }
;;;865      init_exp(f, VCALL, luaK_codeABC(fs, OP_CALL, base, nparams+1, 2));
0000a8  2000              MOVS     r0,#0
0000aa  2102              MOVS     r1,#2
0000ac  f1090301          ADD      r3,r9,#1
0000b0  462a              MOV      r2,r5
0000b2  e9cd1000          STRD     r1,r0,[sp,#0]
0000b6  213f              MOVS     r1,#0x3f
0000b8  4640              MOV      r0,r8
0000ba  f7fffffe          BL       luaK_codeABCk
0000be  4682              MOV      r10,r0
0000c0  4652              MOV      r2,r10
0000c2  2110              MOVS     r1,#0x10
0000c4  4630              MOV      r0,r6
0000c6  f7fffffe          BL       init_exp
;;;866      luaK_fixline(fs, line);
0000ca  4639              MOV      r1,r7
0000cc  4640              MOV      r0,r8
0000ce  f7fffffe          BL       luaK_fixline
;;;867      fs->freereg = base+1;  /* call remove function and arguments and leaves
0000d2  1c68              ADDS     r0,r5,#1
0000d4  f8880030          STRB     r0,[r8,#0x30]
;;;868                                (unless changed) one result */
;;;869    }
0000d8  b008              ADD      sp,sp,#0x20
0000da  e8bd87f0          POP      {r4-r10,pc}
;;;870    
                          ENDP

0000de  0000              DCW      0x0000
                  |L38.224|
0000e0  66756e63          DCB      "function arguments expected",0
0000e4  74696f6e
0000e8  20617267
0000ec  756d656e
0000f0  74732065
0000f4  78706563
0000f8  74656400

                          AREA ||i.funcname||, CODE, READONLY, ALIGN=1

                  funcname PROC
;;;1540   
;;;1541   static int funcname (LexState *ls, expdesc *v) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1542     /* funcname -> NAME {fieldsel} [':' NAME] */
;;;1543     int ismethod = 0;
000006  2600              MOVS     r6,#0
;;;1544     singlevar(ls, v);
000008  4629              MOV      r1,r5
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       singlevar
;;;1545     while (ls->t.token == '.')
000010  e003              B        |L39.26|
                  |L39.18|
;;;1546       fieldsel(ls, v);
000012  4629              MOV      r1,r5
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       fieldsel
                  |L39.26|
00001a  6920              LDR      r0,[r4,#0x10]         ;1545
00001c  282e              CMP      r0,#0x2e              ;1545
00001e  d0f8              BEQ      |L39.18|
;;;1547     if (ls->t.token == ':') {
000020  6920              LDR      r0,[r4,#0x10]
000022  283a              CMP      r0,#0x3a
000024  d104              BNE      |L39.48|
;;;1548       ismethod = 1;
000026  2601              MOVS     r6,#1
;;;1549       fieldsel(ls, v);
000028  4629              MOV      r1,r5
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       fieldsel
                  |L39.48|
;;;1550     }
;;;1551     return ismethod;
000030  4630              MOV      r0,r6
;;;1552   }
000032  bd70              POP      {r4-r6,pc}
;;;1553   
                          ENDP


                          AREA ||i.funcstat||, CODE, READONLY, ALIGN=1

                  funcstat PROC
;;;1554   
;;;1555   static void funcstat (LexState *ls, int line) {
000000  b570              PUSH     {r4-r6,lr}
000002  b08c              SUB      sp,sp,#0x30
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;1556     /* funcstat -> FUNCTION funcname body */
;;;1557     int ismethod;
;;;1558     expdesc v, b;
;;;1559     luaX_next(ls);  /* skip FUNCTION */
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       luaX_next
;;;1560     ismethod = funcname(ls, &v);
00000e  a906              ADD      r1,sp,#0x18
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       funcname
000016  4606              MOV      r6,r0
;;;1561     body(ls, &b, ismethod, line);
000018  462b              MOV      r3,r5
00001a  4632              MOV      r2,r6
00001c  4669              MOV      r1,sp
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       body
;;;1562     luaK_storevar(ls->fs, &v, &b);
000024  466a              MOV      r2,sp
000026  a906              ADD      r1,sp,#0x18
000028  6b20              LDR      r0,[r4,#0x30]
00002a  f7fffffe          BL       luaK_storevar
;;;1563     luaK_fixline(ls->fs, line);  /* definition "happens" in the first line */
00002e  4629              MOV      r1,r5
000030  6b20              LDR      r0,[r4,#0x30]
000032  f7fffffe          BL       luaK_fixline
;;;1564   }
000036  b00c              ADD      sp,sp,#0x30
000038  bd70              POP      {r4-r6,pc}
;;;1565   
                          ENDP


                          AREA ||i.getbinopr||, CODE, READONLY, ALIGN=1

                  getbinopr PROC
;;;1011   
;;;1012   static BinOpr getbinopr (int op) {
000000  4601              MOV      r1,r0
;;;1013     switch (op) {
000002  297e              CMP      r1,#0x7e
000004  d047              BEQ      |L41.150|
000006  dc16              BGT      |L41.54|
000008  292f              CMP      r1,#0x2f
00000a  d03c              BEQ      |L41.134|
00000c  dc0a              BGT      |L41.36|
00000e  f1a10025          SUB      r0,r1,#0x25
000012  2809              CMP      r0,#9
000014  d258              BCS      |L41.200|
000016  e8dff000          TBB      [pc,r0]
00001a  323a              DCB      0x32,0x3a
00001c  57575730          DCB      0x57,0x57,0x57,0x30
000020  2c572e00          DCB      0x2c,0x57,0x2e,0x00
                  |L41.36|
000024  293c              CMP      r1,#0x3c
000026  d043              BEQ      |L41.176|
000028  293e              CMP      r1,#0x3e
00002a  d045              BEQ      |L41.184|
00002c  295e              CMP      r1,#0x5e
00002e  d028              BEQ      |L41.130|
000030  297c              CMP      r1,#0x7c
000032  d149              BNE      |L41.200|
000034  e02d              B        |L41.146|
                  |L41.54|
000036  f5b17f8e          CMP      r1,#0x11c
00003a  d03f              BEQ      |L41.188|
00003c  dc0f              BGT      |L41.94|
00003e  f5b17f8c          CMP      r1,#0x118
000042  d022              BEQ      |L41.138|
000044  dc05              BGT      |L41.82|
000046  f2a11001          SUB      r0,r1,#0x101
00004a  b370              CBZ      r0,|L41.170|
00004c  280f              CMP      r0,#0xf
00004e  d13b              BNE      |L41.200|
000050  e038              B        |L41.196|
                  |L41.82|
000052  f2a11019          SUB      r0,r1,#0x119
000056  b320              CBZ      r0,|L41.162|
000058  2802              CMP      r0,#2
00005a  d135              BNE      |L41.200|
00005c  e026              B        |L41.172|
                  |L41.94|
00005e  f2a1101d          SUB      r0,r1,#0x11d
000062  b338              CBZ      r0,|L41.180|
000064  2801              CMP      r0,#1
000066  d01e              BEQ      |L41.166|
000068  2802              CMP      r0,#2
00006a  d016              BEQ      |L41.154|
00006c  2803              CMP      r0,#3
00006e  d12b              BNE      |L41.200|
000070  e015              B        |L41.158|
;;;1014       case '+': return OPR_ADD;
000072  2000              MOVS     r0,#0
                  |L41.116|
;;;1015       case '-': return OPR_SUB;
;;;1016       case '*': return OPR_MUL;
;;;1017       case '%': return OPR_MOD;
;;;1018       case '^': return OPR_POW;
;;;1019       case '/': return OPR_DIV;
;;;1020       case TK_IDIV: return OPR_IDIV;
;;;1021       case '&': return OPR_BAND;
;;;1022       case '|': return OPR_BOR;
;;;1023       case '~': return OPR_BXOR;
;;;1024       case TK_SHL: return OPR_SHL;
;;;1025       case TK_SHR: return OPR_SHR;
;;;1026       case TK_CONCAT: return OPR_CONCAT;
;;;1027       case TK_NE: return OPR_NE;
;;;1028       case TK_EQ: return OPR_EQ;
;;;1029       case '<': return OPR_LT;
;;;1030       case TK_LE: return OPR_LE;
;;;1031       case '>': return OPR_GT;
;;;1032       case TK_GE: return OPR_GE;
;;;1033       case TK_AND: return OPR_AND;
;;;1034       case TK_OR: return OPR_OR;
;;;1035       default: return OPR_NOBINOPR;
;;;1036     }
;;;1037   }
000074  4770              BX       lr
000076  2001              MOVS     r0,#1                 ;1015
000078  e7fc              B        |L41.116|
00007a  2002              MOVS     r0,#2                 ;1016
00007c  e7fa              B        |L41.116|
00007e  2003              MOVS     r0,#3                 ;1017
000080  e7f8              B        |L41.116|
                  |L41.130|
000082  2004              MOVS     r0,#4                 ;1018
000084  e7f6              B        |L41.116|
                  |L41.134|
000086  2005              MOVS     r0,#5                 ;1019
000088  e7f4              B        |L41.116|
                  |L41.138|
00008a  2006              MOVS     r0,#6                 ;1020
00008c  e7f2              B        |L41.116|
00008e  2007              MOVS     r0,#7                 ;1021
000090  e7f0              B        |L41.116|
                  |L41.146|
000092  2008              MOVS     r0,#8                 ;1022
000094  e7ee              B        |L41.116|
                  |L41.150|
000096  2009              MOVS     r0,#9                 ;1023
000098  e7ec              B        |L41.116|
                  |L41.154|
00009a  200a              MOVS     r0,#0xa               ;1024
00009c  e7ea              B        |L41.116|
                  |L41.158|
00009e  200b              MOVS     r0,#0xb               ;1025
0000a0  e7e8              B        |L41.116|
                  |L41.162|
0000a2  200c              MOVS     r0,#0xc               ;1026
0000a4  e7e6              B        |L41.116|
                  |L41.166|
0000a6  2010              MOVS     r0,#0x10              ;1027
0000a8  e7e4              B        |L41.116|
                  |L41.170|
0000aa  e009              B        |L41.192|
                  |L41.172|
0000ac  200d              MOVS     r0,#0xd               ;1028
0000ae  e7e1              B        |L41.116|
                  |L41.176|
0000b0  200e              MOVS     r0,#0xe               ;1029
0000b2  e7df              B        |L41.116|
                  |L41.180|
0000b4  200f              MOVS     r0,#0xf               ;1030
0000b6  e7dd              B        |L41.116|
                  |L41.184|
0000b8  2011              MOVS     r0,#0x11              ;1031
0000ba  e7db              B        |L41.116|
                  |L41.188|
0000bc  2012              MOVS     r0,#0x12              ;1032
0000be  e7d9              B        |L41.116|
                  |L41.192|
0000c0  2013              MOVS     r0,#0x13              ;1033
0000c2  e7d7              B        |L41.116|
                  |L41.196|
0000c4  2014              MOVS     r0,#0x14              ;1034
0000c6  e7d5              B        |L41.116|
                  |L41.200|
0000c8  2015              MOVS     r0,#0x15              ;1035
0000ca  e7d3              B        |L41.116|
;;;1038   
                          ENDP


                          AREA ||i.getlocvar||, CODE, READONLY, ALIGN=1

                  getlocvar PROC
;;;189    
;;;190    static LocVar *getlocvar (FuncState *fs, int i) {
000000  b510              PUSH     {r4,lr}
000002  4602              MOV      r2,r0
;;;191      int idx = fs->ls->dyd->actvar.arr[fs->firstlocal + i].idx;
000004  6890              LDR      r0,[r2,#8]
000006  6c40              LDR      r0,[r0,#0x44]
000008  6800              LDR      r0,[r0,#0]
00000a  6a94              LDR      r4,[r2,#0x28]
00000c  440c              ADD      r4,r4,r1
00000e  f9303014          LDRSH    r3,[r0,r4,LSL #1]
;;;192      lua_assert(idx < fs->nlocvars);
;;;193      return &fs->f->locvars[idx];
000012  6810              LDR      r0,[r2,#0]
000014  6cc0              LDR      r0,[r0,#0x4c]
000016  eb030443          ADD      r4,r3,r3,LSL #1
00001a  eb000084          ADD      r0,r0,r4,LSL #2
;;;194    }
00001e  bd10              POP      {r4,pc}
;;;195    
                          ENDP


                          AREA ||i.getunopr||, CODE, READONLY, ALIGN=1

                  getunopr PROC
;;;1000   
;;;1001   static UnOpr getunopr (int op) {
000000  4601              MOV      r1,r0
;;;1002     switch (op) {
000002  2923              CMP      r1,#0x23
000004  d00c              BEQ      |L43.32|
000006  292d              CMP      r1,#0x2d
000008  d006              BEQ      |L43.24|
00000a  297e              CMP      r1,#0x7e
00000c  d006              BEQ      |L43.28|
00000e  f2a1100f          SUB      r0,r1,#0x10f
000012  b938              CBNZ     r0,|L43.36|
;;;1003       case TK_NOT: return OPR_NOT;
000014  2002              MOVS     r0,#2
                  |L43.22|
;;;1004       case '-': return OPR_MINUS;
;;;1005       case '~': return OPR_BNOT;
;;;1006       case '#': return OPR_LEN;
;;;1007       default: return OPR_NOUNOPR;
;;;1008     }
;;;1009   }
000016  4770              BX       lr
                  |L43.24|
000018  2000              MOVS     r0,#0                 ;1004
00001a  e7fc              B        |L43.22|
                  |L43.28|
00001c  2001              MOVS     r0,#1                 ;1005
00001e  e7fa              B        |L43.22|
                  |L43.32|
000020  2003              MOVS     r0,#3                 ;1006
000022  e7f8              B        |L43.22|
                  |L43.36|
000024  2004              MOVS     r0,#4                 ;1007
000026  e7f6              B        |L43.22|
;;;1010   
                          ENDP


                          AREA ||i.gotostat||, CODE, READONLY, ALIGN=1

                  gotostat PROC
;;;1213   
;;;1214   static void gotostat (LexState *ls, int pc) {
000000  e92d43f8          PUSH     {r3-r9,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;1215     int line = ls->linenumber;
000008  6866              LDR      r6,[r4,#4]
;;;1216     int g;
;;;1217     luaX_next(ls);  /* skip 'goto' */
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       luaX_next
;;;1218     g = newlabelentry(ls, &ls->dyd->gt, str_checkname(ls), line, pc);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       str_checkname
000016  4680              MOV      r8,r0
000018  9500              STR      r5,[sp,#0]
00001a  6c60              LDR      r0,[r4,#0x44]
00001c  f100010c          ADD      r1,r0,#0xc
000020  4633              MOV      r3,r6
000022  4642              MOV      r2,r8
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       newlabelentry
00002a  4607              MOV      r7,r0
;;;1219     solvelabel(ls, g);  /* close it if label already defined */
00002c  4639              MOV      r1,r7
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       solvelabel
;;;1220   }
000034  e8bd83f8          POP      {r3-r9,pc}
;;;1221   
                          ENDP


                          AREA ||i.ifstat||, CODE, READONLY, ALIGN=1

                  ifstat PROC
;;;1495   
;;;1496   static void ifstat (LexState *ls, int line) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1497     /* ifstat -> IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END */
;;;1498     FuncState *fs = ls->fs;
000006  6b26              LDR      r6,[r4,#0x30]
;;;1499     int escapelist = NO_JUMP;  /* exit list for finished parts */
000008  f04f30ff          MOV      r0,#0xffffffff
00000c  9000              STR      r0,[sp,#0]
;;;1500     test_then_block(ls, &escapelist);  /* IF cond THEN block */
00000e  4669              MOV      r1,sp
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       test_then_block
;;;1501     while (ls->t.token == TK_ELSEIF)
000016  e003              B        |L45.32|
                  |L45.24|
;;;1502       test_then_block(ls, &escapelist);  /* ELSEIF cond THEN block */
000018  4669              MOV      r1,sp
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       test_then_block
                  |L45.32|
000020  f2401105          MOV      r1,#0x105             ;1501
000024  6920              LDR      r0,[r4,#0x10]         ;1501
000026  4288              CMP      r0,r1                 ;1501
000028  d0f6              BEQ      |L45.24|
;;;1503     if (testnext(ls, TK_ELSE))
00002a  1e49              SUBS     r1,r1,#1
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       testnext
000032  b110              CBZ      r0,|L45.58|
;;;1504       block(ls);  /* 'else' part */
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       block
                  |L45.58|
;;;1505     check_match(ls, TK_END, TK_IF, line);
00003a  462b              MOV      r3,r5
00003c  f240120b          MOV      r2,#0x10b
000040  1f51              SUBS     r1,r2,#5
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       check_match
;;;1506     luaK_patchtohere(fs, escapelist);  /* patch escape list to 'if' end */
000048  4630              MOV      r0,r6
00004a  9900              LDR      r1,[sp,#0]
00004c  f7fffffe          BL       luaK_patchtohere
;;;1507   }
000050  bdf8              POP      {r3-r7,pc}
;;;1508   
                          ENDP


                          AREA ||i.init_exp||, CODE, READONLY, ALIGN=1

                  init_exp PROC
;;;138    
;;;139    static void init_exp (expdesc *e, expkind k, int i) {
000000  f04f33ff          MOV      r3,#0xffffffff
;;;140      e->f = e->t = NO_JUMP;
000004  6103              STR      r3,[r0,#0x10]
000006  6143              STR      r3,[r0,#0x14]
;;;141      e->k = k;
000008  6001              STR      r1,[r0,#0]
;;;142      e->u.info = i;
00000a  6082              STR      r2,[r0,#8]
;;;143    }
00000c  4770              BX       lr
;;;144    
                          ENDP


                          AREA ||i.labelstat||, CODE, READONLY, ALIGN=1

                  labelstat PROC
;;;1254   
;;;1255   static void labelstat (LexState *ls, TString *label, int line) {
000000  e92d47fc          PUSH     {r2-r10,lr}
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
;;;1256     /* label -> '::' NAME '::' */
;;;1257     FuncState *fs = ls->fs;
00000a  6b25              LDR      r5,[r4,#0x30]
;;;1258     Labellist *ll = &ls->dyd->label;
00000c  6c60              LDR      r0,[r4,#0x44]
00000e  f1000618          ADD      r6,r0,#0x18
;;;1259     int l;  /* index of new label being created */
;;;1260     checkrepeated(fs, ll, label);  /* check for repeated labels */
000012  463a              MOV      r2,r7
000014  4631              MOV      r1,r6
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       checkrepeated
;;;1261     checknext(ls, TK_DBCOLON);  /* skip double colon */
00001c  f2401121          MOV      r1,#0x121
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       checknext
;;;1262     /* create new entry for this label */
;;;1263     l = newlabelentry(ls, ll, label, line, luaK_getlabel(fs));
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       luaK_getlabel
00002c  4682              MOV      r10,r0
00002e  4643              MOV      r3,r8
000030  463a              MOV      r2,r7
000032  4631              MOV      r1,r6
000034  9000              STR      r0,[sp,#0]
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       newlabelentry
00003c  4681              MOV      r9,r0
;;;1264     luaK_codeABC(fs, OP_CLOSE, fs->nactvar, 0, 0);
00003e  2000              MOVS     r0,#0
000040  9000              STR      r0,[sp,#0]
000042  9001              STR      r0,[sp,#4]
000044  f895202e          LDRB     r2,[r5,#0x2e]
000048  4603              MOV      r3,r0
00004a  2130              MOVS     r1,#0x30
00004c  4628              MOV      r0,r5
00004e  f7fffffe          BL       luaK_codeABCk
;;;1265     skipnoopstat(ls);  /* skip other no-op statements */
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       skipnoopstat
;;;1266     if (block_follow(ls, 0)) {  /* label is last no-op statement in the block? */
000058  2100              MOVS     r1,#0
00005a  4620              MOV      r0,r4
00005c  f7fffffe          BL       block_follow
000060  b128              CBZ      r0,|L47.110|
;;;1267       /* assume that locals are already out of scope */
;;;1268       ll->arr[l].nactvar = fs->bl->nactvar;
000062  68e8              LDR      r0,[r5,#0xc]
000064  7c40              LDRB     r0,[r0,#0x11]
000066  6831              LDR      r1,[r6,#0]
000068  eb011109          ADD      r1,r1,r9,LSL #4
00006c  7308              STRB     r0,[r1,#0xc]
                  |L47.110|
;;;1269     }
;;;1270     solvegotos(ls, &ll->arr[l]);
00006e  6830              LDR      r0,[r6,#0]
000070  eb001109          ADD      r1,r0,r9,LSL #4
000074  4620              MOV      r0,r4
000076  f7fffffe          BL       solvegotos
;;;1271   }
00007a  e8bd87fc          POP      {r2-r10,pc}
;;;1272   
                          ENDP


                          AREA ||i.lastlistfield||, CODE, READONLY, ALIGN=1

                  lastlistfield PROC
;;;680    
;;;681    static void lastlistfield (FuncState *fs, struct ConsControl *cc) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;682      if (cc->tostore == 0) return;
000006  6a60              LDR      r0,[r4,#0x24]
000008  b900              CBNZ     r0,|L48.12|
                  |L48.10|
;;;683      if (hasmultret(cc->v.k)) {
;;;684        luaK_setmultret(fs, &cc->v);
;;;685        luaK_setlist(fs, cc->t->u.info, cc->na, LUA_MULTRET);
;;;686        cc->na--;  /* do not count last expression (unknown number of elements) */
;;;687      }
;;;688      else {
;;;689        if (cc->v.k != VVOID)
;;;690          luaK_exp2nextreg(fs, &cc->v);
;;;691        luaK_setlist(fs, cc->t->u.info, cc->na, cc->tostore);
;;;692      }
;;;693    }
00000a  bd70              POP      {r4-r6,pc}
                  |L48.12|
00000c  6820              LDR      r0,[r4,#0]            ;683
00000e  2810              CMP      r0,#0x10              ;683
000010  d002              BEQ      |L48.24|
000012  6820              LDR      r0,[r4,#0]            ;683
000014  2811              CMP      r0,#0x11              ;683
000016  d111              BNE      |L48.60|
                  |L48.24|
000018  f04f32ff          MOV      r2,#0xffffffff        ;684
00001c  4621              MOV      r1,r4                 ;684
00001e  4628              MOV      r0,r5                 ;684
000020  f7fffffe          BL       luaK_setreturns
000024  6a22              LDR      r2,[r4,#0x20]         ;685
000026  69a0              LDR      r0,[r4,#0x18]         ;685
000028  f04f33ff          MOV      r3,#0xffffffff        ;685
00002c  6881              LDR      r1,[r0,#8]            ;685
00002e  4628              MOV      r0,r5                 ;685
000030  f7fffffe          BL       luaK_setlist
000034  6a20              LDR      r0,[r4,#0x20]         ;686
000036  1e40              SUBS     r0,r0,#1              ;686
000038  6220              STR      r0,[r4,#0x20]         ;686
00003a  e00c              B        |L48.86|
                  |L48.60|
00003c  6820              LDR      r0,[r4,#0]            ;689
00003e  b118              CBZ      r0,|L48.72|
000040  4621              MOV      r1,r4                 ;690
000042  4628              MOV      r0,r5                 ;690
000044  f7fffffe          BL       luaK_exp2nextreg
                  |L48.72|
000048  e9d42308          LDRD     r2,r3,[r4,#0x20]      ;691
00004c  69a0              LDR      r0,[r4,#0x18]         ;691
00004e  6881              LDR      r1,[r0,#8]            ;691
000050  4628              MOV      r0,r5                 ;691
000052  f7fffffe          BL       luaK_setlist
                  |L48.86|
000056  bf00              NOP      
000058  e7d7              B        |L48.10|
;;;694    
                          ENDP


                          AREA ||i.leaveblock||, CODE, READONLY, ALIGN=1

                  leaveblock PROC
;;;476    
;;;477    static void leaveblock (FuncState *fs) {
000000  b57c              PUSH     {r2-r6,lr}
000002  4605              MOV      r5,r0
;;;478      BlockCnt *bl = fs->bl;
000004  68ec              LDR      r4,[r5,#0xc]
;;;479      LexState *ls = fs->ls;
000006  68ae              LDR      r6,[r5,#8]
;;;480      if (bl->upval && bl->brks != NO_JUMP)  /* breaks in upvalue scopes? */
000008  7ca0              LDRB     r0,[r4,#0x12]
00000a  b120              CBZ      r0,|L49.22|
00000c  68e0              LDR      r0,[r4,#0xc]
00000e  1c40              ADDS     r0,r0,#1
000010  b108              CBZ      r0,|L49.22|
;;;481        bl->brkcls = 1;  /* these breaks must close the upvalues */
000012  2001              MOVS     r0,#1
000014  7420              STRB     r0,[r4,#0x10]
                  |L49.22|
;;;482      if (bl->isloop)
000016  7ce0              LDRB     r0,[r4,#0x13]
000018  b118              CBZ      r0,|L49.34|
;;;483        fixbreaks(fs, bl);  /* fix pending breaks */
00001a  4621              MOV      r1,r4
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       fixbreaks
                  |L49.34|
;;;484      if (bl->previous && bl->upval)
000022  6820              LDR      r0,[r4,#0]
000024  b150              CBZ      r0,|L49.60|
000026  7ca0              LDRB     r0,[r4,#0x12]
000028  b140              CBZ      r0,|L49.60|
;;;485        luaK_codeABC(fs, OP_CLOSE, bl->nactvar, 0, 0);
00002a  2000              MOVS     r0,#0
00002c  9000              STR      r0,[sp,#0]
00002e  9001              STR      r0,[sp,#4]
000030  7c62              LDRB     r2,[r4,#0x11]
000032  4603              MOV      r3,r0
000034  2130              MOVS     r1,#0x30
000036  4628              MOV      r0,r5
000038  f7fffffe          BL       luaK_codeABCk
                  |L49.60|
;;;486      fs->bl = bl->previous;
00003c  6820              LDR      r0,[r4,#0]
00003e  60e8              STR      r0,[r5,#0xc]
;;;487      removevars(fs, bl->nactvar);
000040  7c61              LDRB     r1,[r4,#0x11]
000042  4628              MOV      r0,r5
000044  f7fffffe          BL       removevars
;;;488      lua_assert(bl->nactvar == fs->nactvar);
;;;489      fs->freereg = fs->nactvar;  /* free registers */
000048  f895002e          LDRB     r0,[r5,#0x2e]
00004c  f8850030          STRB     r0,[r5,#0x30]
;;;490      ls->dyd->label.n = bl->firstlabel;  /* remove local labels */
000050  6861              LDR      r1,[r4,#4]
000052  6c70              LDR      r0,[r6,#0x44]
000054  61c1              STR      r1,[r0,#0x1c]
;;;491      if (bl->previous)  /* inner block? */
000056  6820              LDR      r0,[r4,#0]
000058  b120              CBZ      r0,|L49.100|
;;;492        movegotosout(fs, bl);  /* update pending gotos to outer block */
00005a  4621              MOV      r1,r4
00005c  4628              MOV      r0,r5
00005e  f7fffffe          BL       movegotosout
000062  e00c              B        |L49.126|
                  |L49.100|
;;;493      else {
;;;494        lua_assert(bl->brks == NO_JUMP);  /* no pending breaks */
;;;495        if (bl->firstgoto < ls->dyd->gt.n)  /* pending gotos in outer block? */
000064  68a1              LDR      r1,[r4,#8]
000066  6c70              LDR      r0,[r6,#0x44]
000068  6900              LDR      r0,[r0,#0x10]
00006a  4281              CMP      r1,r0
00006c  da07              BGE      |L49.126|
;;;496          undefgoto(ls, &ls->dyd->gt.arr[bl->firstgoto]);  /* error */
00006e  6c70              LDR      r0,[r6,#0x44]
000070  68c0              LDR      r0,[r0,#0xc]
000072  68a2              LDR      r2,[r4,#8]
000074  eb001102          ADD      r1,r0,r2,LSL #4
000078  4630              MOV      r0,r6
00007a  f7fffffe          BL       undefgoto
                  |L49.126|
;;;497      }
;;;498    }
00007e  bd7c              POP      {r2-r6,pc}
;;;499    
                          ENDP


                          AREA ||i.listfield||, CODE, READONLY, ALIGN=2

                  listfield PROC
;;;695    
;;;696    static void listfield (LexState *ls, struct ConsControl *cc) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;697      /* listfield -> exp */
;;;698      expr(ls, &cc->v);
000006  4621              MOV      r1,r4
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       expr
;;;699      checklimit(ls->fs, cc->na, MAX_INT, "items in a constructor");
00000e  6a21              LDR      r1,[r4,#0x20]
000010  a306              ADR      r3,|L50.44|
000012  f06f4200          MVN      r2,#0x80000000
000016  6b28              LDR      r0,[r5,#0x30]
000018  f7fffffe          BL       checklimit
;;;700      cc->na++;
00001c  6a20              LDR      r0,[r4,#0x20]
00001e  1c40              ADDS     r0,r0,#1
000020  6220              STR      r0,[r4,#0x20]
;;;701      cc->tostore++;
000022  6a60              LDR      r0,[r4,#0x24]
000024  1c40              ADDS     r0,r0,#1
000026  6260              STR      r0,[r4,#0x24]
;;;702    }
000028  bd70              POP      {r4-r6,pc}
;;;703    
                          ENDP

00002a  0000              DCW      0x0000
                  |L50.44|
00002c  6974656d          DCB      "items in a constructor",0
000030  7320696e
000034  20612063
000038  6f6e7374
00003c  72756374
000040  6f7200  
000043  00                DCB      0

                          AREA ||i.localfunc||, CODE, READONLY, ALIGN=1

                  localfunc PROC
;;;1509   
;;;1510   static void localfunc (LexState *ls) {
000000  b570              PUSH     {r4-r6,lr}
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;1511     expdesc b;
;;;1512     FuncState *fs = ls->fs;
000006  6b25              LDR      r5,[r4,#0x30]
;;;1513     new_localvar(ls, str_checkname(ls));  /* new local variable */
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       str_checkname
00000e  4606              MOV      r6,r0
000010  4631              MOV      r1,r6
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       new_localvar
;;;1514     adjustlocalvars(ls, 1);  /* enter its scope */
000018  2101              MOVS     r1,#1
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       adjustlocalvars
;;;1515     body(ls, &b, 0, ls->linenumber);  /* function created in next register */
000020  2200              MOVS     r2,#0
000022  4669              MOV      r1,sp
000024  4620              MOV      r0,r4
000026  6863              LDR      r3,[r4,#4]
000028  f7fffffe          BL       body
;;;1516     /* debug information will only see the variable after this point! */
;;;1517     getlocvar(fs, b.u.info)->startpc = fs->pc;
00002c  4628              MOV      r0,r5
00002e  9902              LDR      r1,[sp,#8]
000030  f7fffffe          BL       getlocvar
000034  6929              LDR      r1,[r5,#0x10]
000036  6041              STR      r1,[r0,#4]
;;;1518   }
000038  b006              ADD      sp,sp,#0x18
00003a  bd70              POP      {r4-r6,pc}
;;;1519   
                          ENDP


                          AREA ||i.localstat||, CODE, READONLY, ALIGN=1

                  localstat PROC
;;;1520   
;;;1521   static void localstat (LexState *ls) {
000000  b5f0              PUSH     {r4-r7,lr}
000002  b087              SUB      sp,sp,#0x1c
000004  4606              MOV      r6,r0
;;;1522     /* stat -> LOCAL NAME {',' NAME} ['=' explist] */
;;;1523     int nvars = 0;
000006  2500              MOVS     r5,#0
;;;1524     int nexps;
;;;1525     expdesc e;
;;;1526     do {
000008  bf00              NOP      
                  |L52.10|
;;;1527       new_localvar(ls, str_checkname(ls));
00000a  4630              MOV      r0,r6
00000c  f7fffffe          BL       str_checkname
000010  4607              MOV      r7,r0
000012  4639              MOV      r1,r7
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       new_localvar
;;;1528       nvars++;
00001a  1c6d              ADDS     r5,r5,#1
;;;1529     } while (testnext(ls, ','));
00001c  212c              MOVS     r1,#0x2c
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       testnext
000024  2800              CMP      r0,#0
000026  d1f0              BNE      |L52.10|
;;;1530     if (testnext(ls, '='))
000028  213d              MOVS     r1,#0x3d
00002a  4630              MOV      r0,r6
00002c  f7fffffe          BL       testnext
000030  b128              CBZ      r0,|L52.62|
;;;1531       nexps = explist(ls, &e);
000032  4669              MOV      r1,sp
000034  4630              MOV      r0,r6
000036  f7fffffe          BL       explist
00003a  4604              MOV      r4,r0
00003c  e002              B        |L52.68|
                  |L52.62|
;;;1532     else {
;;;1533       e.k = VVOID;
00003e  2000              MOVS     r0,#0
000040  9000              STR      r0,[sp,#0]
;;;1534       nexps = 0;
000042  2400              MOVS     r4,#0
                  |L52.68|
;;;1535     }
;;;1536     adjust_assign(ls, nvars, nexps, &e);
000044  466b              MOV      r3,sp
000046  4622              MOV      r2,r4
000048  4629              MOV      r1,r5
00004a  4630              MOV      r0,r6
00004c  f7fffffe          BL       adjust_assign
;;;1537     adjustlocalvars(ls, nvars);
000050  4629              MOV      r1,r5
000052  4630              MOV      r0,r6
000054  f7fffffe          BL       adjustlocalvars
;;;1538   }
000058  b007              ADD      sp,sp,#0x1c
00005a  bdf0              POP      {r4-r7,pc}
;;;1539   
                          ENDP


                          AREA ||i.luaY_parser||, CODE, READONLY, ALIGN=1

                  luaY_parser PROC
;;;1713   
;;;1714   LClosure *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1715                          Dyndata *dyd, const char *name, int firstchar) {
000004  b0a2              SUB      sp,sp,#0x88
000006  4604              MOV      r4,r0
000008  460f              MOV      r7,r1
00000a  4690              MOV      r8,r2
00000c  461d              MOV      r5,r3
00000e  e9dd9a2a          LDRD     r9,r10,[sp,#0xa8]
;;;1716     LexState lexstate;
;;;1717     FuncState funcstate;
;;;1718     LClosure *cl = luaF_newLclosure(L, 1);  /* create main closure */
000012  2101              MOVS     r1,#1
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       luaF_newLclosure
00001a  4606              MOV      r6,r0
;;;1719     setclLvalue2s(L, L->top, cl);  /* anchor it (to avoid being collected) */
00001c  68e0              LDR      r0,[r4,#0xc]
00001e  4631              MOV      r1,r6
000020  6001              STR      r1,[r0,#0]
000022  2256              MOVS     r2,#0x56
000024  7202              STRB     r2,[r0,#8]
;;;1720     luaD_inctop(L);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       luaD_inctop
;;;1721     lexstate.h = luaH_new(L);  /* create table for scanner */
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       luaH_new
000032  901e              STR      r0,[sp,#0x78]
;;;1722     sethvalue2s(L, L->top, lexstate.h);  /* anchor it */
000034  68e0              LDR      r0,[r4,#0xc]
000036  991e              LDR      r1,[sp,#0x78]
000038  6001              STR      r1,[r0,#0]
00003a  2245              MOVS     r2,#0x45
00003c  7202              STRB     r2,[r0,#8]
;;;1723     luaD_inctop(L);
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       luaD_inctop
;;;1724     funcstate.f = cl->p = luaF_newproto(L);
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       luaF_newproto
00004a  60f0              STR      r0,[r6,#0xc]
00004c  9001              STR      r0,[sp,#4]
;;;1725     funcstate.f->source = luaS_new(L, name);  /* create and anchor TString */
00004e  4649              MOV      r1,r9
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       luaS_new
000056  9901              LDR      r1,[sp,#4]
000058  6508              STR      r0,[r1,#0x50]
;;;1726     lua_assert(iswhite(funcstate.f));  /* do not need barrier here */
;;;1727     lexstate.buff = buff;
00005a  f8cd8074          STR      r8,[sp,#0x74]
;;;1728     lexstate.dyd = dyd;
00005e  951f              STR      r5,[sp,#0x7c]
;;;1729     dyd->actvar.n = dyd->gt.n = dyd->label.n = 0;
000060  2100              MOVS     r1,#0
000062  61e9              STR      r1,[r5,#0x1c]
000064  6129              STR      r1,[r5,#0x10]
000066  6069              STR      r1,[r5,#4]
;;;1730     luaX_setinput(L, &lexstate, z, funcstate.f->source, firstchar);
000068  f8cda000          STR      r10,[sp,#0]
00006c  9801              LDR      r0,[sp,#4]
00006e  463a              MOV      r2,r7
000070  a90e              ADD      r1,sp,#0x38
000072  6d03              LDR      r3,[r0,#0x50]
000074  4620              MOV      r0,r4
000076  f7fffffe          BL       luaX_setinput
;;;1731     mainfunc(&lexstate, &funcstate);
00007a  a901              ADD      r1,sp,#4
00007c  a80e              ADD      r0,sp,#0x38
00007e  f7fffffe          BL       mainfunc
;;;1732     lua_assert(!funcstate.prev && funcstate.nups == 1 && !lexstate.fs);
;;;1733     /* all scopes should be correctly finished */
;;;1734     lua_assert(dyd->actvar.n == 0 && dyd->gt.n == 0 && dyd->label.n == 0);
;;;1735     L->top--;  /* remove scanner's table */
000082  68e0              LDR      r0,[r4,#0xc]
000084  3810              SUBS     r0,r0,#0x10
000086  60e0              STR      r0,[r4,#0xc]
;;;1736     return cl;  /* closure is on the stack, too */
000088  4630              MOV      r0,r6
;;;1737   }
00008a  b022              ADD      sp,sp,#0x88
00008c  e8bd87f0          POP      {r4-r10,pc}
;;;1738   
                          ENDP


                          AREA ||i.mainfunc||, CODE, READONLY, ALIGN=1

                  mainfunc PROC
;;;1699   */
;;;1700   static void mainfunc (LexState *ls, FuncState *fs) {
000000  b530              PUSH     {r4,r5,lr}
000002  b08b              SUB      sp,sp,#0x2c
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;1701     BlockCnt bl;
;;;1702     expdesc v;
;;;1703     open_func(ls, fs, &bl);
000008  aa06              ADD      r2,sp,#0x18
00000a  4629              MOV      r1,r5
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       open_func
;;;1704     setvararg(fs, 0);  /* main function is always declared vararg */
000012  2100              MOVS     r1,#0
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       setvararg
;;;1705     init_exp(&v, VLOCAL, 0);  /* create and... */
00001a  2200              MOVS     r2,#0
00001c  2108              MOVS     r1,#8
00001e  4668              MOV      r0,sp
000020  f7fffffe          BL       init_exp
;;;1706     newupvalue(fs, ls->envn, &v);  /* ...set environment upvalue */
000024  466a              MOV      r2,sp
000026  4628              MOV      r0,r5
000028  6ce1              LDR      r1,[r4,#0x4c]
00002a  f7fffffe          BL       newupvalue
;;;1707     luaX_next(ls);  /* read first token */
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       luaX_next
;;;1708     statlist(ls);  /* parse main body */
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       statlist
;;;1709     check(ls, TK_EOS);
00003a  f44f7191          MOV      r1,#0x122
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       check
;;;1710     close_func(ls);
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       close_func
;;;1711   }
00004a  b00b              ADD      sp,sp,#0x2c
00004c  bd30              POP      {r4,r5,pc}
;;;1712   
                          ENDP


                          AREA ||i.markupval||, CODE, READONLY, ALIGN=1

                  markupval PROC
;;;252    */
;;;253    static void markupval (FuncState *fs, int level) {
000000  4602              MOV      r2,r0
;;;254      BlockCnt *bl = fs->bl;
000002  68d0              LDR      r0,[r2,#0xc]
;;;255      while (bl->nactvar > level)
000004  e000              B        |L55.8|
                  |L55.6|
;;;256        bl = bl->previous;
000006  6800              LDR      r0,[r0,#0]
                  |L55.8|
000008  7c43              LDRB     r3,[r0,#0x11]         ;255
00000a  428b              CMP      r3,r1                 ;255
00000c  dcfb              BGT      |L55.6|
;;;257      bl->upval = 1;
00000e  2301              MOVS     r3,#1
000010  7483              STRB     r3,[r0,#0x12]
;;;258    }
000012  4770              BX       lr
;;;259    
                          ENDP


                          AREA ||i.movegotosout||, CODE, READONLY, ALIGN=1

                  movegotosout PROC
;;;412    */
;;;413    static void movegotosout (FuncState *fs, BlockCnt *bl) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
;;;414      int i = bl->firstgoto;
000008  68a5              LDR      r5,[r4,#8]
;;;415      Labellist *gl = &fs->ls->dyd->gt;
00000a  68b0              LDR      r0,[r6,#8]
00000c  6c40              LDR      r0,[r0,#0x44]
00000e  f100080c          ADD      r8,r0,#0xc
;;;416      /* correct pending gotos to current block and try to close it
;;;417         with visible labels */
;;;418      while (i < gl->n) {  /* for each pending goto */
000012  e016              B        |L56.66|
                  |L56.20|
;;;419        Labeldesc *gt = &gl->arr[i];
000014  f8d80000          LDR      r0,[r8,#0]
000018  eb001705          ADD      r7,r0,r5,LSL #4
;;;420        if (gt->nactvar > bl->nactvar) {  /* leaving a variable scope? */
00001c  7b38              LDRB     r0,[r7,#0xc]
00001e  7c61              LDRB     r1,[r4,#0x11]
000020  4288              CMP      r0,r1
000022  dd07              BLE      |L56.52|
;;;421          if (bl->upval)  /* variable may be an upvalue? */
000024  7ca0              LDRB     r0,[r4,#0x12]
000026  b118              CBZ      r0,|L56.48|
;;;422            luaK_patchclose(fs, gt->pc);  /* jump will need a close */
000028  4630              MOV      r0,r6
00002a  6879              LDR      r1,[r7,#4]
00002c  f7fffffe          BL       luaK_patchclose
                  |L56.48|
;;;423          gt->nactvar = bl->nactvar;  /* update goto level */
000030  7c60              LDRB     r0,[r4,#0x11]
000032  7338              STRB     r0,[r7,#0xc]
                  |L56.52|
;;;424        }
;;;425        if (!solvelabel(fs->ls, i))
000034  4629              MOV      r1,r5
000036  68b0              LDR      r0,[r6,#8]
000038  f7fffffe          BL       solvelabel
00003c  b900              CBNZ     r0,|L56.64|
;;;426          i++;  /* move to next one */
00003e  1c6d              ADDS     r5,r5,#1
                  |L56.64|
;;;427        /* else, 'solvelabel' removed current goto from the list
;;;428           and 'i' now points to next one */
;;;429      }
000040  bf00              NOP      
                  |L56.66|
000042  f8d80004          LDR      r0,[r8,#4]            ;418
000046  42a8              CMP      r0,r5                 ;418
000048  dce4              BGT      |L56.20|
;;;430      /* handles break list */
;;;431      if (bl->upval)  /* exiting the scope of an upvalue? */
00004a  7ca0              LDRB     r0,[r4,#0x12]
00004c  b118              CBZ      r0,|L56.86|
;;;432        luaK_patchclose(fs, bl->brks);  /* breaks will need OP_CLOSE */
00004e  4630              MOV      r0,r6
000050  68e1              LDR      r1,[r4,#0xc]
000052  f7fffffe          BL       luaK_patchclose
                  |L56.86|
;;;433      /* move breaks to outer block */
;;;434      luaK_concat(fs, &bl->previous->brks, bl->brks);
000056  6820              LDR      r0,[r4,#0]
000058  f100010c          ADD      r1,r0,#0xc
00005c  4630              MOV      r0,r6
00005e  68e2              LDR      r2,[r4,#0xc]
000060  f7fffffe          BL       luaK_concat
;;;435      bl->previous->brkcls |= bl->brkcls;
000064  6820              LDR      r0,[r4,#0]
000066  7c00              LDRB     r0,[r0,#0x10]
000068  7c21              LDRB     r1,[r4,#0x10]
00006a  4308              ORRS     r0,r0,r1
00006c  6821              LDR      r1,[r4,#0]
00006e  7408              STRB     r0,[r1,#0x10]
;;;436    }
000070  e8bd81f0          POP      {r4-r8,pc}
;;;437    
                          ENDP


                          AREA ||i.new_localvar||, CODE, READONLY, ALIGN=2

                  new_localvar PROC
;;;169    
;;;170    static void new_localvar (LexState *ls, TString *name) {
000000  e92d43fe          PUSH     {r1-r9,lr}
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
;;;171      FuncState *fs = ls->fs;
000008  6b2e              LDR      r6,[r5,#0x30]
;;;172      Dyndata *dyd = ls->dyd;
00000a  6c6c              LDR      r4,[r5,#0x44]
;;;173      int reg = registerlocalvar(ls, name);
00000c  4639              MOV      r1,r7
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       registerlocalvar
000014  4680              MOV      r8,r0
;;;174      checklimit(fs, dyd->actvar.n + 1 - fs->firstlocal,
000016  6860              LDR      r0,[r4,#4]
000018  1c40              ADDS     r0,r0,#1
00001a  6ab2              LDR      r2,[r6,#0x28]
00001c  1a81              SUBS     r1,r0,r2
00001e  a30f              ADR      r3,|L57.92|
000020  22c8              MOVS     r2,#0xc8
000022  4630              MOV      r0,r6
000024  f7fffffe          BL       checklimit
;;;175                      MAXVARS, "local variables");
;;;176      luaM_growvector(ls->L, dyd->actvar.arr, dyd->actvar.n + 1,
000028  a00c              ADR      r0,|L57.92|
00002a  f06f4100          MVN      r1,#0x80000000
00002e  2202              MOVS     r2,#2
000030  e9cd2100          STRD     r2,r1,[sp,#0]
000034  9002              STR      r0,[sp,#8]
000036  6863              LDR      r3,[r4,#4]
000038  1c5a              ADDS     r2,r3,#1
00003a  6821              LDR      r1,[r4,#0]
00003c  f1040308          ADD      r3,r4,#8
000040  6b68              LDR      r0,[r5,#0x34]
000042  f7fffffe          BL       luaM_growaux_
000046  6020              STR      r0,[r4,#0]
;;;177                      dyd->actvar.size, Vardesc, MAX_INT, "local variables");
;;;178      dyd->actvar.arr[dyd->actvar.n++].idx = cast(short, reg);
000048  fa0ff188          SXTH     r1,r8
00004c  6862              LDR      r2,[r4,#4]
00004e  1c50              ADDS     r0,r2,#1
000050  6060              STR      r0,[r4,#4]
000052  6820              LDR      r0,[r4,#0]
000054  f8201012          STRH     r1,[r0,r2,LSL #1]
;;;179    }
000058  e8bd83fe          POP      {r1-r9,pc}
;;;180    
                          ENDP

                  |L57.92|
00005c  6c6f6361          DCB      "local variables",0
000060  6c207661
000064  72696162
000068  6c657300

                          AREA ||i.new_localvarliteral_||, CODE, READONLY, ALIGN=1

                  new_localvarliteral_ PROC
;;;181    
;;;182    static void new_localvarliteral_ (LexState *ls, const char *name, size_t sz) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;183      new_localvar(ls, luaX_newstring(ls, name, sz));
00000a  4632              MOV      r2,r6
00000c  4629              MOV      r1,r5
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       luaX_newstring
000014  4607              MOV      r7,r0
000016  4639              MOV      r1,r7
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       new_localvar
;;;184    }
00001e  e8bd81f0          POP      {r4-r8,pc}
;;;185    
                          ENDP


                          AREA ||i.newlabelentry||, CODE, READONLY, ALIGN=2

                  newlabelentry PROC
;;;375    
;;;376    static int newlabelentry (LexState *ls, Labellist *l, TString *name,
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;377                              int line, int pc) {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  f8dd9028          LDR      r9,[sp,#0x28]
;;;378      int n = l->n;
000010  6865              LDR      r5,[r4,#4]
;;;379      luaM_growvector(ls->L, l->arr, n, l->size,
000012  a014              ADR      r0,|L59.100|
000014  f64771ff          MOV      r1,#0x7fff
000018  2210              MOVS     r2,#0x10
00001a  e9cd2100          STRD     r2,r1,[sp,#0]
00001e  9002              STR      r0,[sp,#8]
000020  6821              LDR      r1,[r4,#0]
000022  f1040308          ADD      r3,r4,#8
000026  462a              MOV      r2,r5
000028  6b70              LDR      r0,[r6,#0x34]
00002a  f7fffffe          BL       luaM_growaux_
00002e  6020              STR      r0,[r4,#0]
;;;380                      Labeldesc, SHRT_MAX, "labels/gotos");
;;;381      l->arr[n].name = name;
000030  6820              LDR      r0,[r4,#0]
000032  eb001005          ADD      r0,r0,r5,LSL #4
000036  6007              STR      r7,[r0,#0]
;;;382      l->arr[n].line = line;
000038  6820              LDR      r0,[r4,#0]
00003a  eb001005          ADD      r0,r0,r5,LSL #4
00003e  f8c08008          STR      r8,[r0,#8]
;;;383      l->arr[n].nactvar = ls->fs->nactvar;
000042  6b30              LDR      r0,[r6,#0x30]
000044  f890002e          LDRB     r0,[r0,#0x2e]
000048  6821              LDR      r1,[r4,#0]
00004a  eb011105          ADD      r1,r1,r5,LSL #4
00004e  7308              STRB     r0,[r1,#0xc]
;;;384      l->arr[n].pc = pc;
000050  6820              LDR      r0,[r4,#0]
000052  eb001005          ADD      r0,r0,r5,LSL #4
000056  f8c09004          STR      r9,[r0,#4]
;;;385      l->n = n + 1;
00005a  1c68              ADDS     r0,r5,#1
00005c  6060              STR      r0,[r4,#4]
;;;386      return n;
00005e  4628              MOV      r0,r5
;;;387    }
000060  e8bd83fe          POP      {r1-r9,pc}
;;;388    
                          ENDP

                  |L59.100|
000064  6c616265          DCB      "labels/gotos",0
000068  6c732f67
00006c  6f746f73
000070  00      
000071  00                DCB      0
000072  00                DCB      0
000073  00                DCB      0

                          AREA ||i.newupvalue||, CODE, READONLY, ALIGN=2

                  newupvalue PROC
;;;222    
;;;223    static int newupvalue (FuncState *fs, TString *name, expdesc *v) {
000000  e92d43fe          PUSH     {r1-r9,lr}
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;224      Proto *f = fs->f;
00000a  6825              LDR      r5,[r4,#0]
;;;225      int oldsize = f->sizeupvalues;
00000c  f8d5800c          LDR      r8,[r5,#0xc]
;;;226      checklimit(fs, fs->nups + 1, MAXUPVAL, "upvalues");
000010  f894002f          LDRB     r0,[r4,#0x2f]
000014  1c41              ADDS     r1,r0,#1
000016  a327              ADR      r3,|L60.180|
000018  22ff              MOVS     r2,#0xff
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       checklimit
;;;227      luaM_growvector(fs->ls->L, f->upvalues, fs->nups, f->sizeupvalues,
000020  a024              ADR      r0,|L60.180|
000022  21ff              MOVS     r1,#0xff
000024  2208              MOVS     r2,#8
000026  e9cd2100          STRD     r2,r1,[sp,#0]
00002a  9002              STR      r0,[sp,#8]
00002c  f894202f          LDRB     r2,[r4,#0x2f]
000030  6c29              LDR      r1,[r5,#0x40]
000032  68a3              LDR      r3,[r4,#8]
000034  6b58              LDR      r0,[r3,#0x34]
000036  f105030c          ADD      r3,r5,#0xc
00003a  f7fffffe          BL       luaM_growaux_
00003e  6428              STR      r0,[r5,#0x40]
;;;228                      Upvaldesc, MAXUPVAL, "upvalues");
;;;229      while (oldsize < f->sizeupvalues)
000040  e006              B        |L60.80|
                  |L60.66|
;;;230        f->upvalues[oldsize++].name = NULL;
000042  2200              MOVS     r2,#0
000044  4640              MOV      r0,r8
000046  f1080801          ADD      r8,r8,#1
00004a  6c2b              LDR      r3,[r5,#0x40]
00004c  f8432030          STR      r2,[r3,r0,LSL #3]
                  |L60.80|
000050  68e8              LDR      r0,[r5,#0xc]          ;229
000052  4540              CMP      r0,r8                 ;229
000054  dcf5              BGT      |L60.66|
;;;231      f->upvalues[fs->nups].instack = (v->k == VLOCAL);
000056  6838              LDR      r0,[r7,#0]
000058  2808              CMP      r0,#8
00005a  d101              BNE      |L60.96|
00005c  2001              MOVS     r0,#1
00005e  e000              B        |L60.98|
                  |L60.96|
000060  2000              MOVS     r0,#0
                  |L60.98|
000062  6c29              LDR      r1,[r5,#0x40]
000064  f8142f2f          LDRB     r2,[r4,#0x2f]!
000068  eb0101c2          ADD      r1,r1,r2,LSL #3
00006c  7108              STRB     r0,[r1,#4]
;;;232      f->upvalues[fs->nups].idx = cast_byte(v->u.info);
00006e  7a38              LDRB     r0,[r7,#8]
000070  7822              LDRB     r2,[r4,#0]
000072  6c29              LDR      r1,[r5,#0x40]
000074  eb0101c2          ADD      r1,r1,r2,LSL #3
000078  7148              STRB     r0,[r1,#5]
;;;233      f->upvalues[fs->nups].name = name;
00007a  6c28              LDR      r0,[r5,#0x40]
00007c  f814192f          LDRB     r1,[r4],#-0x2f
000080  f8406031          STR      r6,[r0,r1,LSL #3]
;;;234      luaC_objbarrier(fs->ls->L, f, name);
000084  7968              LDRB     r0,[r5,#5]
000086  f0000020          AND      r0,r0,#0x20
00008a  b150              CBZ      r0,|L60.162|
00008c  7970              LDRB     r0,[r6,#5]
00008e  f0000018          AND      r0,r0,#0x18
000092  b130              CBZ      r0,|L60.162|
000094  68a1              LDR      r1,[r4,#8]
000096  4632              MOV      r2,r6
000098  6b48              LDR      r0,[r1,#0x34]
00009a  4629              MOV      r1,r5
00009c  f7fffffe          BL       luaC_barrier_
0000a0  e000              B        |L60.164|
                  |L60.162|
0000a2  bf00              NOP      
                  |L60.164|
;;;235      return fs->nups++;
0000a4  f8140f2f          LDRB     r0,[r4,#0x2f]!
0000a8  7821              LDRB     r1,[r4,#0]
0000aa  1c49              ADDS     r1,r1,#1
0000ac  f804192f          STRB     r1,[r4],#-0x2f
;;;236    }
0000b0  e8bd83fe          POP      {r1-r9,pc}
;;;237    
                          ENDP

                  |L60.180|
0000b4  75707661          DCB      "upvalues",0
0000b8  6c756573
0000bc  00      
0000bd  00                DCB      0
0000be  00                DCB      0
0000bf  00                DCB      0

                          AREA ||i.open_func||, CODE, READONLY, ALIGN=1

                  open_func PROC
;;;533    
;;;534    static void open_func (LexState *ls, FuncState *fs, BlockCnt *bl) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
;;;535      Proto *f = fs->f;
00000a  6826              LDR      r6,[r4,#0]
;;;536      fs->prev = ls->fs;  /* linked list of funcstates */
00000c  6b28              LDR      r0,[r5,#0x30]
00000e  6060              STR      r0,[r4,#4]
;;;537      fs->ls = ls;
000010  60a5              STR      r5,[r4,#8]
;;;538      ls->fs = fs;
000012  632c              STR      r4,[r5,#0x30]
;;;539      fs->pc = 0;
000014  2000              MOVS     r0,#0
000016  6120              STR      r0,[r4,#0x10]
;;;540      fs->previousline = f->linedefined;
000018  6ab0              LDR      r0,[r6,#0x28]
00001a  61a0              STR      r0,[r4,#0x18]
;;;541      fs->iwthabs = 0;
00001c  2000              MOVS     r0,#0
00001e  f8840031          STRB     r0,[r4,#0x31]
;;;542      fs->lasttarget = 0;
000022  6160              STR      r0,[r4,#0x14]
;;;543      fs->freereg = 0;
000024  f8840030          STRB     r0,[r4,#0x30]
;;;544      fs->nk = 0;
000028  61e0              STR      r0,[r4,#0x1c]
;;;545      fs->nabslineinfo = 0;
00002a  6260              STR      r0,[r4,#0x24]
;;;546      fs->np = 0;
00002c  6220              STR      r0,[r4,#0x20]
;;;547      fs->nups = 0;
00002e  f884002f          STRB     r0,[r4,#0x2f]
;;;548      fs->nlocvars = 0;
000032  85a0              STRH     r0,[r4,#0x2c]
;;;549      fs->nactvar = 0;
000034  f884002e          STRB     r0,[r4,#0x2e]
;;;550      fs->firstlocal = ls->dyd->actvar.n;
000038  6c68              LDR      r0,[r5,#0x44]
00003a  6840              LDR      r0,[r0,#4]
00003c  62a0              STR      r0,[r4,#0x28]
;;;551      fs->bl = NULL;
00003e  2000              MOVS     r0,#0
000040  60e0              STR      r0,[r4,#0xc]
;;;552      f->source = ls->source;
000042  6ca8              LDR      r0,[r5,#0x48]
000044  6530              STR      r0,[r6,#0x50]
;;;553      f->maxstacksize = 2;  /* registers 0/1 are always valid */
000046  2002              MOVS     r0,#2
000048  7230              STRB     r0,[r6,#8]
;;;554      enterblock(fs, bl, 0);
00004a  2200              MOVS     r2,#0
00004c  4639              MOV      r1,r7
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       enterblock
;;;555    }
000054  e8bd81f0          POP      {r4-r8,pc}
;;;556    
                          ENDP


                          AREA ||i.parlist||, CODE, READONLY, ALIGN=2

                  parlist PROC
;;;760    
;;;761    static void parlist (LexState *ls) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4604              MOV      r4,r0
;;;762      /* parlist -> [ param { ',' param } ] */
;;;763      FuncState *fs = ls->fs;
000006  6b25              LDR      r5,[r4,#0x30]
;;;764      Proto *f = fs->f;
000008  682e              LDR      r6,[r5,#0]
;;;765      int nparams = 0;
00000a  2700              MOVS     r7,#0
;;;766      int isvararg = 0;
00000c  46b8              MOV      r8,r7
;;;767      if (ls->t.token != ')') {  /* is 'parlist' not empty? */
00000e  6920              LDR      r0,[r4,#0x10]
000010  2829              CMP      r0,#0x29
000012  d026              BEQ      |L62.98|
;;;768        do {
000014  bf00              NOP      
                  |L62.22|
;;;769          switch (ls->t.token) {
000016  6920              LDR      r0,[r4,#0x10]
000018  f5b07f8d          CMP      r0,#0x11a
00001c  d00c              BEQ      |L62.56|
00001e  f2a01025          SUB      r0,r0,#0x125
000022  b978              CBNZ     r0,|L62.68|
;;;770            case TK_NAME: {  /* param -> NAME */
;;;771              new_localvar(ls, str_checkname(ls));
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       str_checkname
00002a  4681              MOV      r9,r0
00002c  4649              MOV      r1,r9
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       new_localvar
;;;772              nparams++;
000034  1c7f              ADDS     r7,r7,#1
;;;773              break;
000036  e00a              B        |L62.78|
                  |L62.56|
;;;774            }
;;;775            case TK_DOTS: {  /* param -> '...' */
;;;776              luaX_next(ls);
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       luaX_next
;;;777              isvararg = 1;
00003e  f04f0801          MOV      r8,#1
;;;778              break;
000042  e004              B        |L62.78|
                  |L62.68|
;;;779            }
;;;780            default: luaX_syntaxerror(ls, "<name> or '...' expected");
000044  a111              ADR      r1,|L62.140|
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       luaX_syntaxerror
00004c  bf00              NOP                            ;769
                  |L62.78|
00004e  bf00              NOP                            ;773
;;;781          }
;;;782        } while (!isvararg && testnext(ls, ','));
000050  f1b80f00          CMP      r8,#0
000054  d105              BNE      |L62.98|
000056  212c              MOVS     r1,#0x2c
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       testnext
00005e  2800              CMP      r0,#0
000060  d1d9              BNE      |L62.22|
                  |L62.98|
;;;783      }
;;;784      adjustlocalvars(ls, nparams);
000062  4639              MOV      r1,r7
000064  4620              MOV      r0,r4
000066  f7fffffe          BL       adjustlocalvars
;;;785      f->numparams = cast_byte(fs->nactvar);
00006a  f895002e          LDRB     r0,[r5,#0x2e]
00006e  71b0              STRB     r0,[r6,#6]
;;;786      if (isvararg)
000070  f1b80f00          CMP      r8,#0
000074  d003              BEQ      |L62.126|
;;;787        setvararg(fs, f->numparams);  /* declared vararg */
000076  79b1              LDRB     r1,[r6,#6]
000078  4628              MOV      r0,r5
00007a  f7fffffe          BL       setvararg
                  |L62.126|
;;;788      luaK_reserveregs(fs, fs->nactvar);  /* reserve registers for parameters */
00007e  f895102e          LDRB     r1,[r5,#0x2e]
000082  4628              MOV      r0,r5
000084  f7fffffe          BL       luaK_reserveregs
;;;789    }
000088  e8bd87f0          POP      {r4-r10,pc}
;;;790    
                          ENDP

                  |L62.140|
00008c  3c6e616d          DCB      "<name> or '...' expected",0
000090  653e206f
000094  7220272e
000098  2e2e2720
00009c  65787065
0000a0  63746564
0000a4  00      
0000a5  00                DCB      0
0000a6  00                DCB      0
0000a7  00                DCB      0

                          AREA ||i.primaryexp||, CODE, READONLY, ALIGN=2

                  primaryexp PROC
;;;880    
;;;881    static void primaryexp (LexState *ls, expdesc *v) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;882      /* primaryexp -> NAME | '(' expr ')' */
;;;883      switch (ls->t.token) {
000006  6920              LDR      r0,[r4,#0x10]
000008  2828              CMP      r0,#0x28
00000a  d005              BEQ      |L63.24|
00000c  f2a01015          SUB      r0,r0,#0x115
000010  b1d0              CBZ      r0,|L63.72|
000012  2810              CMP      r0,#0x10
000014  d121              BNE      |L63.90|
000016  e012              B        |L63.62|
                  |L63.24|
;;;884        case '(': {
;;;885          int line = ls->linenumber;
000018  6866              LDR      r6,[r4,#4]
;;;886          luaX_next(ls);
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       luaX_next
;;;887          expr(ls, v);
000020  4629              MOV      r1,r5
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       expr
;;;888          check_match(ls, ')', '(', line);
000028  4633              MOV      r3,r6
00002a  2228              MOVS     r2,#0x28
00002c  2129              MOVS     r1,#0x29
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       check_match
;;;889          luaK_dischargevars(ls->fs, v);
000034  4629              MOV      r1,r5
000036  6b20              LDR      r0,[r4,#0x30]
000038  f7fffffe          BL       luaK_dischargevars
                  |L63.60|
;;;890          return;
;;;891        }
;;;892        case TK_NAME: {
;;;893          singlevar(ls, v);
;;;894          return;
;;;895        }
;;;896        case TK_UNDEF: {
;;;897          luaX_next(ls);
;;;898          init_exp(v, VUNDEF, 0);
;;;899          return;
;;;900        }
;;;901        default: {
;;;902          luaX_syntaxerror(ls, "unexpected symbol");
;;;903        }
;;;904      }
;;;905    }
00003c  bd70              POP      {r4-r6,pc}
                  |L63.62|
00003e  4629              MOV      r1,r5                 ;893
000040  4620              MOV      r0,r4                 ;893
000042  f7fffffe          BL       singlevar
000046  e7f9              B        |L63.60|
                  |L63.72|
000048  4620              MOV      r0,r4                 ;897
00004a  f7fffffe          BL       luaX_next
00004e  2200              MOVS     r2,#0                 ;898
000050  2112              MOVS     r1,#0x12              ;898
000052  4628              MOV      r0,r5                 ;898
000054  f7fffffe          BL       init_exp
000058  e7f0              B        |L63.60|
                  |L63.90|
00005a  a104              ADR      r1,|L63.108|
00005c  4620              MOV      r0,r4                 ;902
00005e  f7fffffe          BL       luaX_syntaxerror
000062  bf00              NOP                            ;883
000064  bf00              NOP                            ;883
000066  bf00              NOP      
000068  e7e8              B        |L63.60|
;;;906    
                          ENDP

00006a  0000              DCW      0x0000
                  |L63.108|
00006c  756e6578          DCB      "unexpected symbol",0
000070  70656374
000074  65642073
000078  796d626f
00007c  6c00    
00007e  00                DCB      0
00007f  00                DCB      0

                          AREA ||i.recfield||, CODE, READONLY, ALIGN=2

                  recfield PROC
;;;648    
;;;649    static void recfield (LexState *ls, struct ConsControl *cc) {
000000  b5f0              PUSH     {r4-r7,lr}
000002  b093              SUB      sp,sp,#0x4c
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;650      /* recfield -> (NAME | '['exp']') = exp */
;;;651      FuncState *fs = ls->fs;
000008  6b2e              LDR      r6,[r5,#0x30]
;;;652      int reg = ls->fs->freereg;
00000a  6b28              LDR      r0,[r5,#0x30]
00000c  f8907030          LDRB     r7,[r0,#0x30]
;;;653      expdesc tab, key, val;
;;;654      if (ls->t.token == TK_NAME) {
000010  f2401125          MOV      r1,#0x125
000014  6928              LDR      r0,[r5,#0x10]
000016  4288              CMP      r0,r1
000018  d10b              BNE      |L64.50|
;;;655        checklimit(fs, cc->nh, MAX_INT, "items in a constructor");
00001a  a317              ADR      r3,|L64.120|
00001c  f06f4200          MVN      r2,#0x80000000
000020  4630              MOV      r0,r6
000022  69e1              LDR      r1,[r4,#0x1c]
000024  f7fffffe          BL       checklimit
;;;656        checkname(ls, &key);
000028  a906              ADD      r1,sp,#0x18
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       checkname
000030  e003              B        |L64.58|
                  |L64.50|
;;;657      }
;;;658      else  /* ls->t.token == '[' */
;;;659        yindex(ls, &key);
000032  a906              ADD      r1,sp,#0x18
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       yindex
                  |L64.58|
;;;660      cc->nh++;
00003a  69e0              LDR      r0,[r4,#0x1c]
00003c  1c40              ADDS     r0,r0,#1
00003e  61e0              STR      r0,[r4,#0x1c]
;;;661      checknext(ls, '=');
000040  213d              MOVS     r1,#0x3d
000042  4628              MOV      r0,r5
000044  f7fffffe          BL       checknext
;;;662      tab = *cc->t;
000048  2218              MOVS     r2,#0x18
00004a  a80c              ADD      r0,sp,#0x30
00004c  69a1              LDR      r1,[r4,#0x18]
00004e  f7fffffe          BL       __aeabi_memcpy4
;;;663      luaK_indexed(fs, &tab, &key);
000052  aa06              ADD      r2,sp,#0x18
000054  a90c              ADD      r1,sp,#0x30
000056  4630              MOV      r0,r6
000058  f7fffffe          BL       luaK_indexed
;;;664      expr(ls, &val);
00005c  4669              MOV      r1,sp
00005e  4628              MOV      r0,r5
000060  f7fffffe          BL       expr
;;;665      luaK_storevar(fs, &tab, &val);
000064  466a              MOV      r2,sp
000066  a90c              ADD      r1,sp,#0x30
000068  4630              MOV      r0,r6
00006a  f7fffffe          BL       luaK_storevar
;;;666      fs->freereg = reg;  /* free registers */
00006e  f8867030          STRB     r7,[r6,#0x30]
;;;667    }
000072  b013              ADD      sp,sp,#0x4c
000074  bdf0              POP      {r4-r7,pc}
;;;668    
                          ENDP

000076  0000              DCW      0x0000
                  |L64.120|
000078  6974656d          DCB      "items in a constructor",0
00007c  7320696e
000080  20612063
000084  6f6e7374
000088  72756374
00008c  6f7200  
00008f  00                DCB      0

                          AREA ||i.registerlocalvar||, CODE, READONLY, ALIGN=2

                  registerlocalvar PROC
;;;155    
;;;156    static int registerlocalvar (LexState *ls, TString *varname) {
000000  e92d43fe          PUSH     {r1-r9,lr}
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;157      FuncState *fs = ls->fs;
000008  6b35              LDR      r5,[r6,#0x30]
;;;158      Proto *f = fs->f;
00000a  682c              LDR      r4,[r5,#0]
;;;159      int oldsize = f->sizelocvars;
00000c  f8d48020          LDR      r8,[r4,#0x20]
;;;160      luaM_growvector(ls->L, f->locvars, fs->nlocvars, f->sizelocvars,
000010  a01d              ADR      r0,|L65.136|
000012  f64771ff          MOV      r1,#0x7fff
000016  220c              MOVS     r2,#0xc
000018  e9cd2100          STRD     r2,r1,[sp,#0]
00001c  9002              STR      r0,[sp,#8]
00001e  f9b5202c          LDRSH    r2,[r5,#0x2c]
000022  6ce1              LDR      r1,[r4,#0x4c]
000024  f1040320          ADD      r3,r4,#0x20
000028  6b70              LDR      r0,[r6,#0x34]
00002a  f7fffffe          BL       luaM_growaux_
00002e  64e0              STR      r0,[r4,#0x4c]
;;;161                      LocVar, SHRT_MAX, "local variables");
;;;162      while (oldsize < f->sizelocvars)
000030  e008              B        |L65.68|
                  |L65.50|
;;;163        f->locvars[oldsize++].varname = NULL;
000032  2200              MOVS     r2,#0
000034  4640              MOV      r0,r8
000036  f1080801          ADD      r8,r8,#1
00003a  eb000040          ADD      r0,r0,r0,LSL #1
00003e  6ce3              LDR      r3,[r4,#0x4c]
000040  f8432020          STR      r2,[r3,r0,LSL #2]
                  |L65.68|
000044  6a20              LDR      r0,[r4,#0x20]         ;162
000046  4540              CMP      r0,r8                 ;162
000048  dcf3              BGT      |L65.50|
;;;164      f->locvars[fs->nlocvars].varname = varname;
00004a  f9b5102c          LDRSH    r1,[r5,#0x2c]
00004e  eb010141          ADD      r1,r1,r1,LSL #1
000052  6ce0              LDR      r0,[r4,#0x4c]
000054  f8407021          STR      r7,[r0,r1,LSL #2]
;;;165      luaC_objbarrier(ls->L, f, varname);
000058  7960              LDRB     r0,[r4,#5]
00005a  f0000020          AND      r0,r0,#0x20
00005e  b148              CBZ      r0,|L65.116|
000060  7978              LDRB     r0,[r7,#5]
000062  f0000018          AND      r0,r0,#0x18
000066  b128              CBZ      r0,|L65.116|
000068  463a              MOV      r2,r7
00006a  4621              MOV      r1,r4
00006c  6b70              LDR      r0,[r6,#0x34]
00006e  f7fffffe          BL       luaC_barrier_
000072  e000              B        |L65.118|
                  |L65.116|
000074  bf00              NOP      
                  |L65.118|
;;;166      return fs->nlocvars++;
000076  f9b5002c          LDRSH    r0,[r5,#0x2c]
00007a  b281              UXTH     r1,r0
00007c  1c49              ADDS     r1,r1,#1
00007e  b209              SXTH     r1,r1
000080  85a9              STRH     r1,[r5,#0x2c]
;;;167    }
000082  e8bd83fe          POP      {r1-r9,pc}
;;;168    
                          ENDP

000086  0000              DCW      0x0000
                  |L65.136|
000088  6c6f6361          DCB      "local variables",0
00008c  6c207661
000090  72696162
000094  6c657300

                          AREA ||i.removevars||, CODE, READONLY, ALIGN=1

                  removevars PROC
;;;205    
;;;206    static void removevars (FuncState *fs, int tolevel) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;207      fs->ls->dyd->actvar.n -= (fs->nactvar - tolevel);
000006  68a0              LDR      r0,[r4,#8]
000008  6c40              LDR      r0,[r0,#0x44]
00000a  6840              LDR      r0,[r0,#4]
00000c  f894102e          LDRB     r1,[r4,#0x2e]
000010  1b49              SUBS     r1,r1,r5
000012  1a40              SUBS     r0,r0,r1
000014  68a1              LDR      r1,[r4,#8]
000016  6c49              LDR      r1,[r1,#0x44]
000018  6048              STR      r0,[r1,#4]
;;;208      while (fs->nactvar > tolevel)
00001a  e00b              B        |L66.52|
                  |L66.28|
;;;209        getlocvar(fs, --fs->nactvar)->endpc = fs->pc;
00001c  f894002e          LDRB     r0,[r4,#0x2e]
000020  1e40              SUBS     r0,r0,#1
000022  b2c0              UXTB     r0,r0
000024  f884002e          STRB     r0,[r4,#0x2e]
000028  4601              MOV      r1,r0
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       getlocvar
000030  6921              LDR      r1,[r4,#0x10]
000032  6081              STR      r1,[r0,#8]
                  |L66.52|
000034  f894002e          LDRB     r0,[r4,#0x2e]         ;208
000038  42a8              CMP      r0,r5                 ;208
00003a  dcef              BGT      |L66.28|
;;;210    }
00003c  bd70              POP      {r4-r6,pc}
;;;211    
                          ENDP


                          AREA ||i.repeatstat||, CODE, READONLY, ALIGN=1

                  repeatstat PROC
;;;1292   
;;;1293   static void repeatstat (LexState *ls, int line) {
000000  e92d43f0          PUSH     {r4-r9,lr}
000004  b08d              SUB      sp,sp,#0x34
000006  4604              MOV      r4,r0
000008  460d              MOV      r5,r1
;;;1294     /* repeatstat -> REPEAT block UNTIL cond */
;;;1295     int condexit;
;;;1296     FuncState *fs = ls->fs;
00000a  6b27              LDR      r7,[r4,#0x30]
;;;1297     int repeat_init = luaK_getlabel(fs);
00000c  4638              MOV      r0,r7
00000e  f7fffffe          BL       luaK_getlabel
000012  4680              MOV      r8,r0
;;;1298     BlockCnt bl1, bl2;
;;;1299     enterblock(fs, &bl1, 1);  /* loop block */
000014  2201              MOVS     r2,#1
000016  a908              ADD      r1,sp,#0x20
000018  4638              MOV      r0,r7
00001a  f7fffffe          BL       enterblock
;;;1300     enterblock(fs, &bl2, 0);  /* scope block */
00001e  2200              MOVS     r2,#0
000020  a903              ADD      r1,sp,#0xc
000022  4638              MOV      r0,r7
000024  f7fffffe          BL       enterblock
;;;1301     luaX_next(ls);  /* skip REPEAT */
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       luaX_next
;;;1302     statlist(ls);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       statlist
;;;1303     check_match(ls, TK_UNTIL, TK_REPEAT, line);
000034  462b              MOV      r3,r5
000036  f2401211          MOV      r2,#0x111
00003a  1d51              ADDS     r1,r2,#5
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       check_match
;;;1304     condexit = cond(ls);  /* read condition (inside scope block) */
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       cond
000048  4606              MOV      r6,r0
;;;1305     if (bl2.upval)  /* upvalues? */
00004a  f89d001e          LDRB     r0,[sp,#0x1e]
00004e  b118              CBZ      r0,|L67.88|
;;;1306       luaK_patchclose(fs, condexit);
000050  4631              MOV      r1,r6
000052  4638              MOV      r0,r7
000054  f7fffffe          BL       luaK_patchclose
                  |L67.88|
;;;1307     leaveblock(fs);  /* finish scope */
000058  4638              MOV      r0,r7
00005a  f7fffffe          BL       leaveblock
;;;1308     if (bl2.upval) {  /* upvalues? */
00005e  f89d001e          LDRB     r0,[sp,#0x1e]
000062  b1d0              CBZ      r0,|L67.154|
;;;1309       int exit = luaK_jump(fs);  /* normal exit must jump over fix */
000064  4638              MOV      r0,r7
000066  f7fffffe          BL       luaK_jump
00006a  4681              MOV      r9,r0
;;;1310       luaK_patchtohere(fs, condexit);  /* repetition must close upvalues */
00006c  4631              MOV      r1,r6
00006e  4638              MOV      r0,r7
000070  f7fffffe          BL       luaK_patchtohere
;;;1311       luaK_codeABC(fs, OP_CLOSE, bl2.nactvar, 0, 0);
000074  2000              MOVS     r0,#0
000076  9000              STR      r0,[sp,#0]
000078  9001              STR      r0,[sp,#4]
00007a  f89d201d          LDRB     r2,[sp,#0x1d]
00007e  4603              MOV      r3,r0
000080  2130              MOVS     r1,#0x30
000082  4638              MOV      r0,r7
000084  f7fffffe          BL       luaK_codeABCk
;;;1312       condexit = luaK_jump(fs);  /* repeat after closing upvalues */
000088  4638              MOV      r0,r7
00008a  f7fffffe          BL       luaK_jump
00008e  4606              MOV      r6,r0
;;;1313       luaK_patchtohere(fs, exit);  /* normal exit comes to here */
000090  4649              MOV      r1,r9
000092  4638              MOV      r0,r7
000094  f7fffffe          BL       luaK_patchtohere
;;;1314     }
000098  bf00              NOP      
                  |L67.154|
;;;1315     luaK_patchlist(fs, condexit, repeat_init);  /* close the loop */
00009a  4642              MOV      r2,r8
00009c  4631              MOV      r1,r6
00009e  4638              MOV      r0,r7
0000a0  f7fffffe          BL       luaK_patchlist
;;;1316     leaveblock(fs);  /* finish loop */
0000a4  4638              MOV      r0,r7
0000a6  f7fffffe          BL       leaveblock
;;;1317   }
0000aa  b00d              ADD      sp,sp,#0x34
0000ac  e8bd83f0          POP      {r4-r9,pc}
;;;1318   
                          ENDP


                          AREA ||i.retstat||, CODE, READONLY, ALIGN=1

                  retstat PROC
;;;1583   
;;;1584   static void retstat (LexState *ls) {
000000  b5f0              PUSH     {r4-r7,lr}
000002  b087              SUB      sp,sp,#0x1c
000004  4607              MOV      r7,r0
;;;1585     /* stat -> RETURN [explist] [';'] */
;;;1586     FuncState *fs = ls->fs;
000006  6b3e              LDR      r6,[r7,#0x30]
;;;1587     expdesc e;
;;;1588     int first, nret;  /* registers with returned values */
;;;1589     if (block_follow(ls, 1) || ls->t.token == ';')
000008  2101              MOVS     r1,#1
00000a  4638              MOV      r0,r7
00000c  f7fffffe          BL       block_follow
000010  b910              CBNZ     r0,|L68.24|
000012  6938              LDR      r0,[r7,#0x10]
000014  283b              CMP      r0,#0x3b
000016  d102              BNE      |L68.30|
                  |L68.24|
;;;1590       first = nret = 0;  /* return no values */
000018  2400              MOVS     r4,#0
00001a  4625              MOV      r5,r4
00001c  e038              B        |L68.144|
                  |L68.30|
;;;1591     else {
;;;1592       nret = explist(ls, &e);  /* optional return values */
00001e  4669              MOV      r1,sp
000020  4638              MOV      r0,r7
000022  f7fffffe          BL       explist
000026  4605              MOV      r5,r0
;;;1593       if (hasmultret(e.k)) {
000028  9800              LDR      r0,[sp,#0]
00002a  2810              CMP      r0,#0x10
00002c  d002              BEQ      |L68.52|
00002e  9800              LDR      r0,[sp,#0]
000030  2811              CMP      r0,#0x11
000032  d11e              BNE      |L68.114|
                  |L68.52|
;;;1594         luaK_setmultret(fs, &e);
000034  f04f32ff          MOV      r2,#0xffffffff
000038  4669              MOV      r1,sp
00003a  4630              MOV      r0,r6
00003c  f7fffffe          BL       luaK_setreturns
;;;1595         if (e.k == VCALL && nret == 1) {  /* tail call? */
000040  9800              LDR      r0,[sp,#0]
000042  2810              CMP      r0,#0x10
000044  d110              BNE      |L68.104|
000046  2d01              CMP      r5,#1
000048  d10e              BNE      |L68.104|
;;;1596           SET_OPCODE(getinstruction(fs,&e), OP_TAILCALL);
00004a  6830              LDR      r0,[r6,#0]
00004c  6b80              LDR      r0,[r0,#0x38]
00004e  9902              LDR      r1,[sp,#8]
000050  f8500021          LDR      r0,[r0,r1,LSL #2]
000054  f020007f          BIC      r0,r0,#0x7f
000058  f0400040          ORR      r0,r0,#0x40
00005c  6831              LDR      r1,[r6,#0]
00005e  6b89              LDR      r1,[r1,#0x38]
000060  9a02              LDR      r2,[sp,#8]
000062  f8410022          STR      r0,[r1,r2,LSL #2]
;;;1597           lua_assert(GETARG_A(getinstruction(fs,&e)) == fs->nactvar);
000066  bf00              NOP      
                  |L68.104|
;;;1598         }
;;;1599         first = fs->nactvar;
000068  f896402e          LDRB     r4,[r6,#0x2e]
;;;1600         nret = LUA_MULTRET;  /* return all values */
00006c  f04f35ff          MOV      r5,#0xffffffff
000070  e00e              B        |L68.144|
                  |L68.114|
;;;1601       }
;;;1602       else {
;;;1603         if (nret == 1)  /* only one single value? */
000072  2d01              CMP      r5,#1
000074  d105              BNE      |L68.130|
;;;1604           first = luaK_exp2anyreg(fs, &e);
000076  4669              MOV      r1,sp
000078  4630              MOV      r0,r6
00007a  f7fffffe          BL       luaK_exp2anyreg
00007e  4604              MOV      r4,r0
000080  e006              B        |L68.144|
                  |L68.130|
;;;1605         else {
;;;1606           luaK_exp2nextreg(fs, &e);  /* values must go to the stack */
000082  4669              MOV      r1,sp
000084  4630              MOV      r0,r6
000086  f7fffffe          BL       luaK_exp2nextreg
;;;1607           first = fs->nactvar;  /* return all active values */
00008a  f896402e          LDRB     r4,[r6,#0x2e]
;;;1608           lua_assert(nret == fs->freereg - first);
00008e  bf00              NOP      
                  |L68.144|
;;;1609         }
;;;1610       }
;;;1611     }
;;;1612     luaK_ret(fs, first, nret);
000090  462a              MOV      r2,r5
000092  4621              MOV      r1,r4
000094  4630              MOV      r0,r6
000096  f7fffffe          BL       luaK_ret
;;;1613     testnext(ls, ';');  /* skip optional semicolon */
00009a  213b              MOVS     r1,#0x3b
00009c  4638              MOV      r0,r7
00009e  f7fffffe          BL       testnext
;;;1614   }
0000a2  b007              ADD      sp,sp,#0x1c
0000a4  bdf0              POP      {r4-r7,pc}
;;;1615   
                          ENDP


                          AREA ||i.searchupvalue||, CODE, READONLY, ALIGN=1

                  searchupvalue PROC
;;;212    
;;;213    static int searchupvalue (FuncState *fs, TString *name) {
000000  b510              PUSH     {r4,lr}
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;214      int i;
;;;215      Upvaldesc *up = fs->f->upvalues;
000006  6810              LDR      r0,[r2,#0]
000008  6c04              LDR      r4,[r0,#0x40]
;;;216      for (i = 0; i < fs->nups; i++) {
00000a  2100              MOVS     r1,#0
00000c  e006              B        |L69.28|
                  |L69.14|
;;;217        if (eqstr(up[i].name, name)) return i;
00000e  f8540031          LDR      r0,[r4,r1,LSL #3]
000012  4298              CMP      r0,r3
000014  d101              BNE      |L69.26|
000016  4608              MOV      r0,r1
                  |L69.24|
;;;218      }
;;;219      return -1;  /* not found */
;;;220    }
000018  bd10              POP      {r4,pc}
                  |L69.26|
00001a  1c49              ADDS     r1,r1,#1              ;216
                  |L69.28|
00001c  f892002f          LDRB     r0,[r2,#0x2f]         ;216
000020  4288              CMP      r0,r1                 ;216
000022  dcf4              BGT      |L69.14|
000024  f04f30ff          MOV      r0,#0xffffffff        ;219
000028  e7f6              B        |L69.24|
;;;221    
                          ENDP


                          AREA ||i.searchvar||, CODE, READONLY, ALIGN=1

                  searchvar PROC
;;;238    
;;;239    static int searchvar (FuncState *fs, TString *n) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;240      int i;
;;;241      for (i = cast_int(fs->nactvar) - 1; i >= 0; i--) {
000006  f895002e          LDRB     r0,[r5,#0x2e]
00000a  1e44              SUBS     r4,r0,#1
00000c  e009              B        |L70.34|
                  |L70.14|
;;;242        if (eqstr(n, getlocvar(fs, i)->varname))
00000e  4621              MOV      r1,r4
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       getlocvar
000016  6800              LDR      r0,[r0,#0]
000018  42b0              CMP      r0,r6
00001a  d101              BNE      |L70.32|
;;;243          return i;
00001c  4620              MOV      r0,r4
                  |L70.30|
;;;244      }
;;;245      return -1;  /* not found */
;;;246    }
00001e  bd70              POP      {r4-r6,pc}
                  |L70.32|
000020  1e64              SUBS     r4,r4,#1              ;241
                  |L70.34|
000022  2c00              CMP      r4,#0                 ;241
000024  daf3              BGE      |L70.14|
000026  f04f30ff          MOV      r0,#0xffffffff        ;245
00002a  e7f8              B        |L70.30|
;;;247    
                          ENDP


                          AREA ||i.setvararg||, CODE, READONLY, ALIGN=1

                  setvararg PROC
;;;754    
;;;755    static void setvararg (FuncState *fs, int nparams) {
000000  b57c              PUSH     {r2-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;756      fs->f->is_vararg = 1;
000006  2001              MOVS     r0,#1
000008  6829              LDR      r1,[r5,#0]
00000a  71c8              STRB     r0,[r1,#7]
;;;757      luaK_codeABC(fs, OP_PREPVARARG, nparams, 0, 0);
00000c  2000              MOVS     r0,#0
00000e  9000              STR      r0,[sp,#0]
000010  4603              MOV      r3,r0
000012  4622              MOV      r2,r4
000014  214d              MOVS     r1,#0x4d
000016  9001              STR      r0,[sp,#4]
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       luaK_codeABCk
;;;758    }
00001e  bd7c              POP      {r2-r6,pc}
;;;759    
                          ENDP


                          AREA ||i.simpleexp||, CODE, READONLY, ALIGN=2

                  simpleexp PROC
;;;945    
;;;946    static void simpleexp (LexState *ls, expdesc *v) {
000000  e92d41fc          PUSH     {r2-r8,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;947      /* simpleexp -> FLT | INT | STRING | NIL | TRUE | FALSE | ... |
;;;948                      constructor | FUNCTION body | suffixedexp */
;;;949      switch (ls->t.token) {
000008  6920              LDR      r0,[r4,#0x10]
00000a  f5b07f8a          CMP      r0,#0x114
00000e  d036              BEQ      |L72.126|
000010  dc09              BGT      |L72.38|
000012  287b              CMP      r0,#0x7b
000014  d058              BEQ      |L72.200|
000016  f2a01007          SUB      r0,r0,#0x107
00001a  b378              CBZ      r0,|L72.124|
00001c  2802              CMP      r0,#2
00001e  d059              BEQ      |L72.212|
000020  2807              CMP      r0,#7
000022  d161              BNE      |L72.232|
000024  e024              B        |L72.112|
                  |L72.38|
000026  f5b07f8d          CMP      r0,#0x11a
00002a  d034              BEQ      |L72.150|
00002c  f2a01023          SUB      r0,r0,#0x123
000030  b120              CBZ      r0,|L72.60|
000032  2801              CMP      r0,#1
000034  d00c              BEQ      |L72.80|
000036  2803              CMP      r0,#3
000038  d156              BNE      |L72.232|
00003a  e013              B        |L72.100|
                  |L72.60|
;;;950        case TK_FLT: {
;;;951          init_exp(v, VKFLT, 0);
00003c  2200              MOVS     r2,#0
00003e  2105              MOVS     r1,#5
000040  4628              MOV      r0,r5
000042  f7fffffe          BL       init_exp
;;;952          v->u.nval = ls->t.seminfo.r;
000046  e9d40106          LDRD     r0,r1,[r4,#0x18]
00004a  e9c50102          STRD     r0,r1,[r5,#8]
;;;953          break;
00004e  e050              B        |L72.242|
                  |L72.80|
;;;954        }
;;;955        case TK_INT: {
;;;956          init_exp(v, VKINT, 0);
000050  2200              MOVS     r2,#0
000052  2106              MOVS     r1,#6
000054  4628              MOV      r0,r5
000056  f7fffffe          BL       init_exp
;;;957          v->u.ival = ls->t.seminfo.i;
00005a  e9d40106          LDRD     r0,r1,[r4,#0x18]
00005e  e9c50102          STRD     r0,r1,[r5,#8]
;;;958          break;
000062  e046              B        |L72.242|
                  |L72.100|
;;;959        }
;;;960        case TK_STRING: {
;;;961          codestring(ls, v, ls->t.seminfo.ts);
000064  4629              MOV      r1,r5
000066  4620              MOV      r0,r4
000068  69a2              LDR      r2,[r4,#0x18]
00006a  f7fffffe          BL       codestring
;;;962          break;
00006e  e040              B        |L72.242|
                  |L72.112|
;;;963        }
;;;964        case TK_NIL: {
;;;965          init_exp(v, VNIL, 0);
000070  2200              MOVS     r2,#0
000072  2101              MOVS     r1,#1
000074  4628              MOV      r0,r5
000076  f7fffffe          BL       init_exp
;;;966          break;
00007a  e03a              B        |L72.242|
                  |L72.124|
00007c  e005              B        |L72.138|
                  |L72.126|
;;;967        }
;;;968        case TK_TRUE: {
;;;969          init_exp(v, VTRUE, 0);
00007e  2200              MOVS     r2,#0
000080  2102              MOVS     r1,#2
000082  4628              MOV      r0,r5
000084  f7fffffe          BL       init_exp
;;;970          break;
000088  e033              B        |L72.242|
                  |L72.138|
;;;971        }
;;;972        case TK_FALSE: {
;;;973          init_exp(v, VFALSE, 0);
00008a  2200              MOVS     r2,#0
00008c  2103              MOVS     r1,#3
00008e  4628              MOV      r0,r5
000090  f7fffffe          BL       init_exp
;;;974          break;
000094  e02d              B        |L72.242|
                  |L72.150|
;;;975        }
;;;976        case TK_DOTS: {  /* vararg */
;;;977          FuncState *fs = ls->fs;
000096  6b26              LDR      r6,[r4,#0x30]
;;;978          check_condition(ls, fs->f->is_vararg,
000098  6830              LDR      r0,[r6,#0]
00009a  79c0              LDRB     r0,[r0,#7]
00009c  b918              CBNZ     r0,|L72.166|
00009e  a118              ADR      r1,|L72.256|
0000a0  4620              MOV      r0,r4
0000a2  f7fffffe          BL       luaX_syntaxerror
                  |L72.166|
;;;979                          "cannot use '...' outside a vararg function");
;;;980          init_exp(v, VVARARG, luaK_codeABC(fs, OP_VARARG, 0, 0, 1));
0000a6  2000              MOVS     r0,#0
0000a8  2101              MOVS     r1,#1
0000aa  4603              MOV      r3,r0
0000ac  4602              MOV      r2,r0
0000ae  e9cd1000          STRD     r1,r0,[sp,#0]
0000b2  214c              MOVS     r1,#0x4c
0000b4  4630              MOV      r0,r6
0000b6  f7fffffe          BL       luaK_codeABCk
0000ba  4607              MOV      r7,r0
0000bc  463a              MOV      r2,r7
0000be  2111              MOVS     r1,#0x11
0000c0  4628              MOV      r0,r5
0000c2  f7fffffe          BL       init_exp
;;;981          break;
0000c6  e014              B        |L72.242|
                  |L72.200|
;;;982        }
;;;983        case '{': {  /* constructor */
;;;984          constructor(ls, v);
0000c8  4629              MOV      r1,r5
0000ca  4620              MOV      r0,r4
0000cc  f7fffffe          BL       constructor
                  |L72.208|
;;;985          return;
;;;986        }
;;;987        case TK_FUNCTION: {
;;;988          luaX_next(ls);
;;;989          body(ls, v, 0, ls->linenumber);
;;;990          return;
;;;991        }
;;;992        default: {
;;;993          suffixedexp(ls, v);
;;;994          return;
;;;995        }
;;;996      }
;;;997      luaX_next(ls);
;;;998    }
0000d0  e8bd81fc          POP      {r2-r8,pc}
                  |L72.212|
0000d4  4620              MOV      r0,r4                 ;988
0000d6  f7fffffe          BL       luaX_next
0000da  2200              MOVS     r2,#0                 ;989
0000dc  4629              MOV      r1,r5                 ;989
0000de  4620              MOV      r0,r4                 ;989
0000e0  6863              LDR      r3,[r4,#4]            ;989
0000e2  f7fffffe          BL       body
0000e6  e7f3              B        |L72.208|
                  |L72.232|
0000e8  4629              MOV      r1,r5                 ;993
0000ea  4620              MOV      r0,r4                 ;993
0000ec  f7fffffe          BL       suffixedexp
0000f0  e7ee              B        |L72.208|
                  |L72.242|
0000f2  bf00              NOP                            ;953
0000f4  4620              MOV      r0,r4                 ;997
0000f6  f7fffffe          BL       luaX_next
0000fa  bf00              NOP      
0000fc  e7e8              B        |L72.208|
;;;999    
                          ENDP

0000fe  0000              DCW      0x0000
                  |L72.256|
000100  63616e6e          DCB      "cannot use '...' outside a vararg function",0
000104  6f742075
000108  73652027
00010c  2e2e2e27
000110  206f7574
000114  73696465
000118  20612076
00011c  61726172
000120  67206675
000124  6e637469
000128  6f6e00  
00012b  00                DCB      0

                          AREA ||i.singlevar||, CODE, READONLY, ALIGN=1

                  singlevar PROC
;;;289    
;;;290    static void singlevar (LexState *ls, expdesc *var) {
000000  b5f0              PUSH     {r4-r7,lr}
000002  b087              SUB      sp,sp,#0x1c
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;291      TString *varname = str_checkname(ls);
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       str_checkname
00000e  4607              MOV      r7,r0
;;;292      FuncState *fs = ls->fs;
000010  6b26              LDR      r6,[r4,#0x30]
;;;293      singlevaraux(fs, varname, var, 1);
000012  2301              MOVS     r3,#1
000014  462a              MOV      r2,r5
000016  4639              MOV      r1,r7
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       singlevaraux
;;;294      if (var->k == VVOID) {  /* global name? */
00001e  6828              LDR      r0,[r5,#0]
000020  b980              CBNZ     r0,|L73.68|
;;;295        expdesc key;
;;;296        singlevaraux(fs, ls->envn, var, 1);  /* get environment variable */
000022  2301              MOVS     r3,#1
000024  462a              MOV      r2,r5
000026  4630              MOV      r0,r6
000028  6ce1              LDR      r1,[r4,#0x4c]
00002a  f7fffffe          BL       singlevaraux
;;;297        lua_assert(var->k != VVOID);  /* this one must exist */
;;;298        codestring(ls, &key, varname);  /* key is variable name */
00002e  463a              MOV      r2,r7
000030  4669              MOV      r1,sp
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       codestring
;;;299        luaK_indexed(fs, var, &key);  /* env[varname] */
000038  466a              MOV      r2,sp
00003a  4629              MOV      r1,r5
00003c  4630              MOV      r0,r6
00003e  f7fffffe          BL       luaK_indexed
;;;300      }
000042  bf00              NOP      
                  |L73.68|
;;;301    }
000044  b007              ADD      sp,sp,#0x1c
000046  bdf0              POP      {r4-r7,pc}
;;;302    
                          ENDP


                          AREA ||i.singlevaraux||, CODE, READONLY, ALIGN=1

                  singlevaraux PROC
;;;264    */
;;;265    static void singlevaraux (FuncState *fs, TString *n, expdesc *var, int base) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4615              MOV      r5,r2
00000a  461f              MOV      r7,r3
;;;266      if (fs == NULL)  /* no more levels? */
00000c  b92c              CBNZ     r4,|L74.26|
;;;267        init_exp(var, VVOID, 0);  /* default is global */
00000e  2200              MOVS     r2,#0
000010  4611              MOV      r1,r2
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       init_exp
000018  e030              B        |L74.124|
                  |L74.26|
;;;268      else {
;;;269        int v = searchvar(fs, n);  /* look up locals at current level */
00001a  4649              MOV      r1,r9
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       searchvar
000022  4606              MOV      r6,r0
;;;270        if (v >= 0) {  /* found? */
000024  2e00              CMP      r6,#0
000026  db0a              BLT      |L74.62|
;;;271          init_exp(var, VLOCAL, v);  /* variable is local */
000028  4632              MOV      r2,r6
00002a  2108              MOVS     r1,#8
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       init_exp
;;;272          if (!base)
000032  bb17              CBNZ     r7,|L74.122|
;;;273            markupval(fs, v);  /* local will be used as an upval */
000034  4631              MOV      r1,r6
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       markupval
00003c  e01d              B        |L74.122|
                  |L74.62|
;;;274        }
;;;275        else {  /* not found as local at current level; try upvalues */
;;;276          int idx = searchupvalue(fs, n);  /* try existing upvalues */
00003e  4649              MOV      r1,r9
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       searchupvalue
000046  4680              MOV      r8,r0
;;;277          if (idx < 0) {  /* not found? */
000048  f1b80f00          CMP      r8,#0
00004c  da0f              BGE      |L74.110|
;;;278            singlevaraux(fs->prev, n, var, 0);  /* try upper levels */
00004e  2300              MOVS     r3,#0
000050  462a              MOV      r2,r5
000052  4649              MOV      r1,r9
000054  6860              LDR      r0,[r4,#4]
000056  f7fffffe          BL       singlevaraux
;;;279            if (var->k == VVOID)  /* not found? */
00005a  6828              LDR      r0,[r5,#0]
00005c  b908              CBNZ     r0,|L74.98|
                  |L74.94|
;;;280              return;  /* it is a global */
;;;281            /* else was LOCAL or UPVAL */
;;;282            idx  = newupvalue(fs, n, var);  /* will be a new upvalue */
;;;283          }
;;;284          init_exp(var, VUPVAL, idx);  /* new or old upvalue */
;;;285        }
;;;286      }
;;;287    }
00005e  e8bd87f0          POP      {r4-r10,pc}
                  |L74.98|
000062  462a              MOV      r2,r5                 ;282
000064  4649              MOV      r1,r9                 ;282
000066  4620              MOV      r0,r4                 ;282
000068  f7fffffe          BL       newupvalue
00006c  4680              MOV      r8,r0                 ;282
                  |L74.110|
00006e  4642              MOV      r2,r8                 ;284
000070  2109              MOVS     r1,#9                 ;284
000072  4628              MOV      r0,r5                 ;284
000074  f7fffffe          BL       init_exp
000078  bf00              NOP                            ;285
                  |L74.122|
00007a  bf00              NOP                            ;286
                  |L74.124|
00007c  bf00              NOP      
00007e  e7ee              B        |L74.94|
;;;288    
                          ENDP


                          AREA ||i.skipnoopstat||, CODE, READONLY, ALIGN=1

                  skipnoopstat PROC
;;;1248   /* skip no-op statements */
;;;1249   static void skipnoopstat (LexState *ls) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;1250     while (ls->t.token == ';' || ls->t.token == TK_DBCOLON)
000004  e002              B        |L75.12|
                  |L75.6|
;;;1251       statement(ls);
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       statement
                  |L75.12|
00000c  6920              LDR      r0,[r4,#0x10]         ;1250
00000e  283b              CMP      r0,#0x3b              ;1250
000010  d0f9              BEQ      |L75.6|
000012  f2401121          MOV      r1,#0x121             ;1250
000016  6920              LDR      r0,[r4,#0x10]         ;1250
000018  4288              CMP      r0,r1                 ;1250
00001a  d0f4              BEQ      |L75.6|
;;;1252   }
00001c  bd10              POP      {r4,pc}
;;;1253   
                          ENDP


                          AREA ||i.solvegotos||, CODE, READONLY, ALIGN=1

                  solvegotos PROC
;;;393    */
;;;394    static void solvegotos (LexState *ls, Labeldesc *lb) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;395      Labellist *gl = &ls->dyd->gt;
000008  6c68              LDR      r0,[r5,#0x44]
00000a  f100070c          ADD      r7,r0,#0xc
;;;396      int i = ls->fs->bl->firstgoto;
00000e  6b28              LDR      r0,[r5,#0x30]
000010  68c0              LDR      r0,[r0,#0xc]
000012  6884              LDR      r4,[r0,#8]
;;;397      while (i < gl->n) {
000014  e00d              B        |L76.50|
                  |L76.22|
;;;398        if (eqstr(gl->arr[i].name, lb->name))
000016  6838              LDR      r0,[r7,#0]
000018  eb001004          ADD      r0,r0,r4,LSL #4
00001c  6800              LDR      r0,[r0,#0]
00001e  6831              LDR      r1,[r6,#0]
000020  4288              CMP      r0,r1
000022  d105              BNE      |L76.48|
;;;399          closegoto(ls, i, lb);  /* will remove 'i' from the list */
000024  4632              MOV      r2,r6
000026  4621              MOV      r1,r4
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       closegoto
00002e  e000              B        |L76.50|
                  |L76.48|
;;;400        else
;;;401          i++;
000030  1c64              ADDS     r4,r4,#1
                  |L76.50|
000032  6878              LDR      r0,[r7,#4]            ;397
000034  42a0              CMP      r0,r4                 ;397
000036  dcee              BGT      |L76.22|
;;;402      }
;;;403    }
000038  e8bd81f0          POP      {r4-r8,pc}
;;;404    
                          ENDP


                          AREA ||i.solvelabel||, CODE, READONLY, ALIGN=1

                  solvelabel PROC
;;;355    */
;;;356    static int solvelabel (LexState *ls, int g) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4604              MOV      r4,r0
000006  468a              MOV      r10,r1
;;;357      int i;
;;;358      BlockCnt *bl = ls->fs->bl;
000008  6b20              LDR      r0,[r4,#0x30]
00000a  68c7              LDR      r7,[r0,#0xc]
;;;359      Dyndata *dyd = ls->dyd;
00000c  6c65              LDR      r5,[r4,#0x44]
;;;360      Labeldesc *gt = &dyd->gt.arr[g];
00000e  68e8              LDR      r0,[r5,#0xc]
000010  eb00180a          ADD      r8,r0,r10,LSL #4
;;;361      /* check labels in current block for a match */
;;;362      for (i = bl->firstlabel; i < dyd->label.n; i++) {
000014  687e              LDR      r6,[r7,#4]
000016  e022              B        |L77.94|
                  |L77.24|
;;;363        Labeldesc *lb = &dyd->label.arr[i];
000018  69a8              LDR      r0,[r5,#0x18]
00001a  eb001906          ADD      r9,r0,r6,LSL #4
;;;364        if (eqstr(lb->name, gt->name)) {  /* correct label? */
00001e  f8d90000          LDR      r0,[r9,#0]
000022  f8d81000          LDR      r1,[r8,#0]
000026  4288              CMP      r0,r1
000028  d118              BNE      |L77.92|
;;;365          if (gt->nactvar > lb->nactvar &&
00002a  f898000c          LDRB     r0,[r8,#0xc]
00002e  f899100c          LDRB     r1,[r9,#0xc]
000032  4288              CMP      r0,r1
000034  dd0a              BLE      |L77.76|
;;;366              (bl->upval || dyd->label.n > bl->firstlabel))
000036  7cb8              LDRB     r0,[r7,#0x12]
000038  b918              CBNZ     r0,|L77.66|
00003a  69e8              LDR      r0,[r5,#0x1c]
00003c  6879              LDR      r1,[r7,#4]
00003e  4288              CMP      r0,r1
000040  dd04              BLE      |L77.76|
                  |L77.66|
;;;367            luaK_patchclose(ls->fs, gt->pc);
000042  f8d81004          LDR      r1,[r8,#4]
000046  6b20              LDR      r0,[r4,#0x30]
000048  f7fffffe          BL       luaK_patchclose
                  |L77.76|
;;;368          closegoto(ls, g, lb);  /* close it */
00004c  464a              MOV      r2,r9
00004e  4651              MOV      r1,r10
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       closegoto
;;;369          return 1;
000056  2001              MOVS     r0,#1
                  |L77.88|
;;;370        }
;;;371      }
;;;372      return 0;  /* label not found; cannot close goto */
;;;373    }
000058  e8bd87f0          POP      {r4-r10,pc}
                  |L77.92|
00005c  1c76              ADDS     r6,r6,#1              ;362
                  |L77.94|
00005e  69e8              LDR      r0,[r5,#0x1c]         ;362
000060  42b0              CMP      r0,r6                 ;362
000062  dcd9              BGT      |L77.24|
000064  2000              MOVS     r0,#0                 ;372
000066  e7f7              B        |L77.88|
;;;374    
                          ENDP


                          AREA ||i.statement||, CODE, READONLY, ALIGN=1

                  statement PROC
;;;1616   
;;;1617   static void statement (LexState *ls) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;1618     int line = ls->linenumber;  /* may be needed for error messages */
000004  6865              LDR      r5,[r4,#4]
;;;1619     enterlevel(ls);
000006  6b60              LDR      r0,[r4,#0x34]
000008  f7fffffe          BL       luaE_incCcalls
;;;1620     switch (ls->t.token) {
00000c  f240120b          MOV      r2,#0x10b
000010  6920              LDR      r0,[r4,#0x10]
000012  1a81              SUBS     r1,r0,r2
000014  4290              CMP      r0,r2
000016  d025              BEQ      |L78.100|
000018  dc13              BGT      |L78.66|
00001a  f5b07f84          CMP      r0,#0x108
00001e  d039              BEQ      |L78.148|
000020  dc09              BGT      |L78.54|
000022  283b              CMP      r0,#0x3b
000024  d01a              BEQ      |L78.92|
000026  f5b07f81          CMP      r0,#0x102
00002a  d071              BEQ      |L78.272|
00002c  f2a01003          SUB      r0,r0,#0x103
000030  2800              CMP      r0,#0
000032  d17f              BNE      |L78.308|
000034  e020              B        |L78.120|
                  |L78.54|
000036  f2a01009          SUB      r0,r0,#0x109
00003a  b380              CBZ      r0,|L78.158|
00003c  2801              CMP      r0,#1
00003e  d179              BNE      |L78.308|
000040  e06f              B        |L78.290|
                  |L78.66|
000042  2907              CMP      r1,#7
000044  d05b              BEQ      |L78.254|
000046  dc04              BGT      |L78.82|
000048  2902              CMP      r1,#2
00004a  d033              BEQ      |L78.180|
00004c  2906              CMP      r1,#6
00004e  d171              BNE      |L78.308|
000050  e026              B        |L78.160|
                  |L78.82|
000052  290c              CMP      r1,#0xc
000054  d00b              BEQ      |L78.110|
000056  2916              CMP      r1,#0x16
000058  d16c              BNE      |L78.308|
00005a  e043              B        |L78.228|
                  |L78.92|
;;;1621       case ';': {  /* stat -> ';' (empty statement) */
;;;1622         luaX_next(ls);  /* skip ';' */
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       luaX_next
;;;1623         break;
000062  e06b              B        |L78.316|
                  |L78.100|
;;;1624       }
;;;1625       case TK_IF: {  /* stat -> ifstat */
;;;1626         ifstat(ls, line);
000064  4629              MOV      r1,r5
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       ifstat
;;;1627         break;
00006c  e066              B        |L78.316|
                  |L78.110|
;;;1628       }
;;;1629       case TK_WHILE: {  /* stat -> whilestat */
;;;1630         whilestat(ls, line);
00006e  4629              MOV      r1,r5
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       whilestat
;;;1631         break;
000076  e061              B        |L78.316|
                  |L78.120|
;;;1632       }
;;;1633       case TK_DO: {  /* stat -> DO block END */
;;;1634         luaX_next(ls);  /* skip DO */
000078  4620              MOV      r0,r4
00007a  f7fffffe          BL       luaX_next
;;;1635         block(ls);
00007e  4620              MOV      r0,r4
000080  f7fffffe          BL       block
;;;1636         check_match(ls, TK_END, TK_DO, line);
000084  462b              MOV      r3,r5
000086  f2401203          MOV      r2,#0x103
00008a  1cd1              ADDS     r1,r2,#3
00008c  4620              MOV      r0,r4
00008e  f7fffffe          BL       check_match
;;;1637         break;
000092  e053              B        |L78.316|
                  |L78.148|
;;;1638       }
;;;1639       case TK_FOR: {  /* stat -> forstat */
;;;1640         forstat(ls, line);
000094  4629              MOV      r1,r5
000096  4620              MOV      r0,r4
000098  f7fffffe          BL       forstat
;;;1641         break;
00009c  e04e              B        |L78.316|
                  |L78.158|
00009e  e004              B        |L78.170|
                  |L78.160|
;;;1642       }
;;;1643       case TK_REPEAT: {  /* stat -> repeatstat */
;;;1644         repeatstat(ls, line);
0000a0  4629              MOV      r1,r5
0000a2  4620              MOV      r0,r4
0000a4  f7fffffe          BL       repeatstat
;;;1645         break;
0000a8  e048              B        |L78.316|
                  |L78.170|
;;;1646       }
;;;1647       case TK_FUNCTION: {  /* stat -> funcstat */
;;;1648         funcstat(ls, line);
0000aa  4629              MOV      r1,r5
0000ac  4620              MOV      r0,r4
0000ae  f7fffffe          BL       funcstat
;;;1649         break;
0000b2  e043              B        |L78.316|
                  |L78.180|
;;;1650       }
;;;1651       case TK_LOCAL: {  /* stat -> localstat */
;;;1652         luaX_next(ls);  /* skip LOCAL */
0000b4  4620              MOV      r0,r4
0000b6  f7fffffe          BL       luaX_next
;;;1653         if (testnext(ls, TK_FUNCTION))  /* local function? */
0000ba  f2401109          MOV      r1,#0x109
0000be  4620              MOV      r0,r4
0000c0  f7fffffe          BL       testnext
0000c4  b118              CBZ      r0,|L78.206|
;;;1654           localfunc(ls);
0000c6  4620              MOV      r0,r4
0000c8  f7fffffe          BL       localfunc
0000cc  e009              B        |L78.226|
                  |L78.206|
;;;1655         else if (testnext(ls, TK_UNDEF))
0000ce  f2401115          MOV      r1,#0x115
0000d2  4620              MOV      r0,r4
0000d4  f7fffffe          BL       testnext
0000d8  b100              CBZ      r0,|L78.220|
;;;1656           (void)0;  /* ignore */
0000da  e002              B        |L78.226|
                  |L78.220|
;;;1657         /* old versions may need to declare 'local undef'
;;;1658            when using 'undef' with no environment; so this
;;;1659            version accepts (and ignores) these declarations */
;;;1660         else
;;;1661           localstat(ls);
0000dc  4620              MOV      r0,r4
0000de  f7fffffe          BL       localstat
                  |L78.226|
;;;1662         break;
0000e2  e02b              B        |L78.316|
                  |L78.228|
;;;1663       }
;;;1664       case TK_DBCOLON: {  /* stat -> label */
;;;1665         luaX_next(ls);  /* skip double colon */
0000e4  4620              MOV      r0,r4
0000e6  f7fffffe          BL       luaX_next
;;;1666         labelstat(ls, str_checkname(ls), line);
0000ea  4620              MOV      r0,r4
0000ec  f7fffffe          BL       str_checkname
0000f0  4606              MOV      r6,r0
0000f2  462a              MOV      r2,r5
0000f4  4631              MOV      r1,r6
0000f6  4620              MOV      r0,r4
0000f8  f7fffffe          BL       labelstat
;;;1667         break;
0000fc  e01e              B        |L78.316|
                  |L78.254|
;;;1668       }
;;;1669       case TK_RETURN: {  /* stat -> retstat */
;;;1670         luaX_next(ls);  /* skip RETURN */
0000fe  4620              MOV      r0,r4
000100  f7fffffe          BL       luaX_next
;;;1671         retstat(ls);
000104  4620              MOV      r0,r4
000106  f7fffffe          BL       retstat
;;;1672         break;
00010a  e017              B        |L78.316|
00010c  e000              B        |L78.272|
00010e  e011              B        |L78.308|
                  |L78.272|
;;;1673       }
;;;1674       case TK_BREAK: {  /* stat -> breakstat */
;;;1675         breakstat(ls, luaK_jump(ls->fs));
000110  6b20              LDR      r0,[r4,#0x30]
000112  f7fffffe          BL       luaK_jump
000116  4606              MOV      r6,r0
000118  4631              MOV      r1,r6
00011a  4620              MOV      r0,r4
00011c  f7fffffe          BL       breakstat
;;;1676         break;
000120  e00c              B        |L78.316|
                  |L78.290|
;;;1677       }
;;;1678       case TK_GOTO: {  /* stat -> 'goto' NAME */
;;;1679         gotostat(ls, luaK_jump(ls->fs));
000122  6b20              LDR      r0,[r4,#0x30]
000124  f7fffffe          BL       luaK_jump
000128  4606              MOV      r6,r0
00012a  4631              MOV      r1,r6
00012c  4620              MOV      r0,r4
00012e  f7fffffe          BL       gotostat
;;;1680         break;
000132  e003              B        |L78.316|
                  |L78.308|
;;;1681       }
;;;1682       default: {  /* stat -> func | assignment */
;;;1683         exprstat(ls);
000134  4620              MOV      r0,r4
000136  f7fffffe          BL       exprstat
;;;1684         break;
00013a  bf00              NOP      
                  |L78.316|
00013c  bf00              NOP                            ;1623
;;;1685       }
;;;1686     }
;;;1687     lua_assert(ls->fs->f->maxstacksize >= ls->fs->freereg &&
;;;1688                ls->fs->freereg >= ls->fs->nactvar);
;;;1689     ls->fs->freereg = ls->fs->nactvar;  /* free registers */
00013e  6b20              LDR      r0,[r4,#0x30]
000140  f890002e          LDRB     r0,[r0,#0x2e]
000144  6b21              LDR      r1,[r4,#0x30]
000146  f8810030          STRB     r0,[r1,#0x30]
;;;1690     leavelevel(ls);
00014a  6b60              LDR      r0,[r4,#0x34]
00014c  f8b0006e          LDRH     r0,[r0,#0x6e]
000150  1e40              SUBS     r0,r0,#1
000152  6b61              LDR      r1,[r4,#0x34]
000154  f8a1006e          STRH     r0,[r1,#0x6e]
;;;1691   }
000158  bd70              POP      {r4-r6,pc}
;;;1692   
                          ENDP


                          AREA ||i.statlist||, CODE, READONLY, ALIGN=1

                  statlist PROC
;;;600    
;;;601    static void statlist (LexState *ls) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;602      /* statlist -> { stat [';'] } */
;;;603      while (!block_follow(ls, 1)) {
000004  e00a              B        |L79.28|
                  |L79.6|
;;;604        if (ls->t.token == TK_RETURN) {
000006  6920              LDR      r0,[r4,#0x10]
000008  f5b07f89          CMP      r0,#0x112
00000c  d103              BNE      |L79.22|
;;;605          statement(ls);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       statement
                  |L79.20|
;;;606          return;  /* 'return' must be last statement */
;;;607        }
;;;608        statement(ls);
;;;609      }
;;;610    }
000014  bd10              POP      {r4,pc}
                  |L79.22|
000016  4620              MOV      r0,r4                 ;608
000018  f7fffffe          BL       statement
                  |L79.28|
00001c  2101              MOVS     r1,#1                 ;603
00001e  4620              MOV      r0,r4                 ;603
000020  f7fffffe          BL       block_follow
000024  2800              CMP      r0,#0                 ;603
000026  d0ee              BEQ      |L79.6|
000028  bf00              NOP      
00002a  e7f3              B        |L79.20|
;;;611    
                          ENDP


                          AREA ||i.str_checkname||, CODE, READONLY, ALIGN=1

                  str_checkname PROC
;;;129    
;;;130    static TString *str_checkname (LexState *ls) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;131      TString *ts;
;;;132      check(ls, TK_NAME);
000004  f2401125          MOV      r1,#0x125
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       check
;;;133      ts = ls->t.seminfo.ts;
00000e  69a5              LDR      r5,[r4,#0x18]
;;;134      luaX_next(ls);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       luaX_next
;;;135      return ts;
000016  4628              MOV      r0,r5
;;;136    }
000018  bd70              POP      {r4-r6,pc}
;;;137    
                          ENDP


                          AREA ||i.subexpr||, CODE, READONLY, ALIGN=2

                  subexpr PROC
;;;1062   */
;;;1063   static BinOpr subexpr (LexState *ls, expdesc *v, int limit) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  b088              SUB      sp,sp,#0x20
000006  4604              MOV      r4,r0
000008  460e              MOV      r6,r1
00000a  4617              MOV      r7,r2
;;;1064     BinOpr op;
;;;1065     UnOpr uop;
;;;1066     enterlevel(ls);
00000c  6b60              LDR      r0,[r4,#0x34]
00000e  f7fffffe          BL       luaE_incCcalls
;;;1067     uop = getunopr(ls->t.token);
000012  6920              LDR      r0,[r4,#0x10]
000014  f7fffffe          BL       getunopr
000018  4680              MOV      r8,r0
;;;1068     if (uop != OPR_NOUNOPR) {
00001a  f1b80f04          CMP      r8,#4
00001e  d010              BEQ      |L81.66|
;;;1069       int line = ls->linenumber;
000020  f8d49004          LDR      r9,[r4,#4]
;;;1070       luaX_next(ls);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       luaX_next
;;;1071       subexpr(ls, v, UNARY_PRIORITY);
00002a  220c              MOVS     r2,#0xc
00002c  4631              MOV      r1,r6
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       subexpr
;;;1072       luaK_prefix(ls->fs, uop, v, line);
000034  464b              MOV      r3,r9
000036  4632              MOV      r2,r6
000038  4641              MOV      r1,r8
00003a  6b20              LDR      r0,[r4,#0x30]
00003c  f7fffffe          BL       luaK_prefix
;;;1073     }
000040  e003              B        |L81.74|
                  |L81.66|
;;;1074     else simpleexp(ls, v);
000042  4631              MOV      r1,r6
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       simpleexp
                  |L81.74|
;;;1075     /* expand while operators have priorities higher than 'limit' */
;;;1076     op = getbinopr(ls->t.token);
00004a  6920              LDR      r0,[r4,#0x10]
00004c  f7fffffe          BL       getbinopr
000050  4605              MOV      r5,r0
;;;1077     while (op != OPR_NOBINOPR && priority[op].left > limit) {
000052  e01c              B        |L81.142|
                  |L81.84|
;;;1078       expdesc v2;
;;;1079       BinOpr nextop;
;;;1080       int line = ls->linenumber;
000054  f8d4a004          LDR      r10,[r4,#4]
;;;1081       luaX_next(ls);
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       luaX_next
;;;1082       luaK_infix(ls->fs, op, v);
00005e  4632              MOV      r2,r6
000060  4629              MOV      r1,r5
000062  6b20              LDR      r0,[r4,#0x30]
000064  f7fffffe          BL       luaK_infix
;;;1083       /* read sub-expression with higher priority */
;;;1084       nextop = subexpr(ls, &v2, priority[op].right);
000068  4812              LDR      r0,|L81.180|
00006a  eb000045          ADD      r0,r0,r5,LSL #1
00006e  7842              LDRB     r2,[r0,#1]
000070  a902              ADD      r1,sp,#8
000072  4620              MOV      r0,r4
000074  f7fffffe          BL       subexpr
000078  4681              MOV      r9,r0
;;;1085       luaK_posfix(ls->fs, op, v, &v2, line);
00007a  f8cda000          STR      r10,[sp,#0]
00007e  ab02              ADD      r3,sp,#8
000080  4632              MOV      r2,r6
000082  4629              MOV      r1,r5
000084  6b20              LDR      r0,[r4,#0x30]
000086  f7fffffe          BL       luaK_posfix
;;;1086       op = nextop;
00008a  464d              MOV      r5,r9
;;;1087     }
00008c  bf00              NOP      
                  |L81.142|
00008e  2d15              CMP      r5,#0x15              ;1077
000090  d004              BEQ      |L81.156|
000092  4808              LDR      r0,|L81.180|
000094  f8100015          LDRB     r0,[r0,r5,LSL #1]     ;1077
000098  42b8              CMP      r0,r7                 ;1077
00009a  dcdb              BGT      |L81.84|
                  |L81.156|
;;;1088     leavelevel(ls);
00009c  6b60              LDR      r0,[r4,#0x34]
00009e  f8b0006e          LDRH     r0,[r0,#0x6e]
0000a2  1e40              SUBS     r0,r0,#1
0000a4  6b61              LDR      r1,[r4,#0x34]
0000a6  f8a1006e          STRH     r0,[r1,#0x6e]
;;;1089     return op;  /* return first untreated operator */
0000aa  4628              MOV      r0,r5
;;;1090   }
0000ac  b008              ADD      sp,sp,#0x20
0000ae  e8bd87f0          POP      {r4-r10,pc}
;;;1091   
                          ENDP

0000b2  0000              DCW      0x0000
                  |L81.180|
                          DCD      priority

                          AREA ||i.suffixedexp||, CODE, READONLY, ALIGN=1

                  suffixedexp PROC
;;;907    
;;;908    static void suffixedexp (LexState *ls, expdesc *v) {
000000  b5f0              PUSH     {r4-r7,lr}
000002  b087              SUB      sp,sp,#0x1c
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;909      /* suffixedexp ->
;;;910           primaryexp { '.' NAME | '[' exp ']' | ':' NAME funcargs | funcargs } */
;;;911      FuncState *fs = ls->fs;
000008  6b26              LDR      r6,[r4,#0x30]
;;;912      int line = ls->linenumber;
00000a  6867              LDR      r7,[r4,#4]
;;;913      primaryexp(ls, v);
00000c  4629              MOV      r1,r5
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       primaryexp
;;;914      for (;;) {
000014  bf00              NOP      
                  |L82.22|
;;;915        switch (ls->t.token) {
000016  6920              LDR      r0,[r4,#0x10]
000018  285b              CMP      r0,#0x5b
00001a  d012              BEQ      |L82.66|
00001c  dc06              BGT      |L82.44|
00001e  2828              CMP      r0,#0x28
000020  d02f              BEQ      |L82.130|
000022  282e              CMP      r0,#0x2e
000024  d008              BEQ      |L82.56|
000026  283a              CMP      r0,#0x3a
000028  d137              BNE      |L82.154|
00002a  e018              B        |L82.94|
                  |L82.44|
00002c  287b              CMP      r0,#0x7b
00002e  d02a              BEQ      |L82.134|
000030  f5b07f93          CMP      r0,#0x126
000034  d131              BNE      |L82.154|
000036  e025              B        |L82.132|
                  |L82.56|
;;;916          case '.': {  /* fieldsel */
;;;917            fieldsel(ls, v);
000038  4629              MOV      r1,r5
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       fieldsel
;;;918            break;
000040  e02d              B        |L82.158|
                  |L82.66|
;;;919          }
;;;920          case '[': {  /* '[' exp ']' */
;;;921            expdesc key;
;;;922            luaK_exp2anyregup(fs, v);
000042  4629              MOV      r1,r5
000044  4630              MOV      r0,r6
000046  f7fffffe          BL       luaK_exp2anyregup
;;;923            yindex(ls, &key);
00004a  4669              MOV      r1,sp
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       yindex
;;;924            luaK_indexed(fs, v, &key);
000052  466a              MOV      r2,sp
000054  4629              MOV      r1,r5
000056  4630              MOV      r0,r6
000058  f7fffffe          BL       luaK_indexed
;;;925            break;
00005c  e01f              B        |L82.158|
                  |L82.94|
;;;926          }
;;;927          case ':': {  /* ':' NAME funcargs */
;;;928            expdesc key;
;;;929            luaX_next(ls);
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       luaX_next
;;;930            checkname(ls, &key);
000064  4669              MOV      r1,sp
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       checkname
;;;931            luaK_self(fs, v, &key);
00006c  466a              MOV      r2,sp
00006e  4629              MOV      r1,r5
000070  4630              MOV      r0,r6
000072  f7fffffe          BL       luaK_self
;;;932            funcargs(ls, v, line);
000076  463a              MOV      r2,r7
000078  4629              MOV      r1,r5
00007a  4620              MOV      r0,r4
00007c  f7fffffe          BL       funcargs
;;;933            break;
000080  e00d              B        |L82.158|
                  |L82.130|
;;;934          }
;;;935          case '(': case TK_STRING: case '{': {  /* funcargs */
000082  bf00              NOP      
                  |L82.132|
000084  bf00              NOP      
                  |L82.134|
;;;936            luaK_exp2nextreg(fs, v);
000086  4629              MOV      r1,r5
000088  4630              MOV      r0,r6
00008a  f7fffffe          BL       luaK_exp2nextreg
;;;937            funcargs(ls, v, line);
00008e  463a              MOV      r2,r7
000090  4629              MOV      r1,r5
000092  4620              MOV      r0,r4
000094  f7fffffe          BL       funcargs
;;;938            break;
000098  e001              B        |L82.158|
                  |L82.154|
;;;939          }
;;;940          default: return;
;;;941        }
;;;942      }
;;;943    }
00009a  b007              ADD      sp,sp,#0x1c
00009c  bdf0              POP      {r4-r7,pc}
                  |L82.158|
00009e  e7ba              B        |L82.22|
;;;944    
                          ENDP


                          AREA ||i.test_then_block||, CODE, READONLY, ALIGN=1

                  test_then_block PROC
;;;1457   
;;;1458   static void test_then_block (LexState *ls, int *escapelist) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  b08c              SUB      sp,sp,#0x30
000006  4604              MOV      r4,r0
000008  460e              MOV      r6,r1
;;;1459     /* test_then_block -> [IF | ELSEIF] cond THEN block */
;;;1460     BlockCnt bl;
;;;1461     FuncState *fs = ls->fs;
00000a  6b27              LDR      r7,[r4,#0x30]
;;;1462     expdesc v;
;;;1463     int jf;  /* instruction to skip 'then' code (if condition is false) */
;;;1464     luaX_next(ls);  /* skip IF or ELSEIF */
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       luaX_next
;;;1465     expr(ls, &v);  /* read condition */
000012  4669              MOV      r1,sp
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       expr
;;;1466     checknext(ls, TK_THEN);
00001a  f2401113          MOV      r1,#0x113
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       checknext
;;;1467     if (ls->t.token == TK_GOTO || ls->t.token == TK_BREAK) {
000024  6920              LDR      r0,[r4,#0x10]
000026  f5b07f85          CMP      r0,#0x10a
00002a  d003              BEQ      |L83.52|
00002c  6920              LDR      r0,[r4,#0x10]
00002e  f5b07f81          CMP      r0,#0x102
000032  d12c              BNE      |L83.142|
                  |L83.52|
;;;1468       luaK_goiffalse(ls->fs, &v);  /* will jump to label if condition is true */
000034  4669              MOV      r1,sp
000036  6b20              LDR      r0,[r4,#0x30]
000038  f7fffffe          BL       luaK_goiffalse
;;;1469       enterblock(fs, &bl, 0);  /* must enter block before 'goto' */
00003c  2200              MOVS     r2,#0
00003e  a906              ADD      r1,sp,#0x18
000040  4638              MOV      r0,r7
000042  f7fffffe          BL       enterblock
;;;1470       if (ls->t.token == TK_GOTO)
000046  6920              LDR      r0,[r4,#0x10]
000048  f5b07f85          CMP      r0,#0x10a
00004c  d104              BNE      |L83.88|
;;;1471         gotostat(ls, v.t);  /* handle goto */
00004e  4620              MOV      r0,r4
000050  9904              LDR      r1,[sp,#0x10]
000052  f7fffffe          BL       gotostat
000056  e003              B        |L83.96|
                  |L83.88|
;;;1472       else
;;;1473         breakstat(ls, v.t);  /* handle break */
000058  4620              MOV      r0,r4
00005a  9904              LDR      r1,[sp,#0x10]
00005c  f7fffffe          BL       breakstat
                  |L83.96|
;;;1474       while (testnext(ls, ';')) {}  /* skip semicolons */
000060  bf00              NOP      
                  |L83.98|
000062  213b              MOVS     r1,#0x3b
000064  4620              MOV      r0,r4
000066  f7fffffe          BL       testnext
00006a  2800              CMP      r0,#0
00006c  d1f9              BNE      |L83.98|
;;;1475       if (block_follow(ls, 0)) {  /* 'goto'/'break' is the entire block? */
00006e  2100              MOVS     r1,#0
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       block_follow
000076  b128              CBZ      r0,|L83.132|
;;;1476         leaveblock(fs);
000078  4638              MOV      r0,r7
00007a  f7fffffe          BL       leaveblock
                  |L83.126|
;;;1477         return;  /* and that is it */
;;;1478       }
;;;1479       else  /* must skip over 'then' part if condition is false */
;;;1480         jf = luaK_jump(fs);
;;;1481     }
;;;1482     else {  /* regular case (not goto/break) */
;;;1483       luaK_goiftrue(ls->fs, &v);  /* skip over block if condition is false */
;;;1484       enterblock(fs, &bl, 0);
;;;1485       jf = v.f;
;;;1486     }
;;;1487     statlist(ls);  /* 'then' part */
;;;1488     leaveblock(fs);
;;;1489     if (ls->t.token == TK_ELSE ||
;;;1490         ls->t.token == TK_ELSEIF)  /* followed by 'else'/'elseif'? */
;;;1491       luaK_concat(fs, escapelist, luaK_jump(fs));  /* must jump over it */
;;;1492     luaK_patchtohere(fs, jf);
;;;1493   }
00007e  b00c              ADD      sp,sp,#0x30
000080  e8bd81f0          POP      {r4-r8,pc}
                  |L83.132|
000084  4638              MOV      r0,r7                 ;1480
000086  f7fffffe          BL       luaK_jump
00008a  4605              MOV      r5,r0                 ;1480
00008c  e009              B        |L83.162|
                  |L83.142|
00008e  4669              MOV      r1,sp                 ;1483
000090  6b20              LDR      r0,[r4,#0x30]         ;1483
000092  f7fffffe          BL       luaK_goiftrue
000096  2200              MOVS     r2,#0                 ;1484
000098  a906              ADD      r1,sp,#0x18           ;1484
00009a  4638              MOV      r0,r7                 ;1484
00009c  f7fffffe          BL       enterblock
0000a0  9d05              LDR      r5,[sp,#0x14]         ;1485
                  |L83.162|
0000a2  4620              MOV      r0,r4                 ;1487
0000a4  f7fffffe          BL       statlist
0000a8  4638              MOV      r0,r7                 ;1488
0000aa  f7fffffe          BL       leaveblock
0000ae  6920              LDR      r0,[r4,#0x10]         ;1489
0000b0  f5b07f82          CMP      r0,#0x104             ;1489
0000b4  d004              BEQ      |L83.192|
0000b6  f2401105          MOV      r1,#0x105             ;1490
0000ba  6920              LDR      r0,[r4,#0x10]         ;1490
0000bc  4288              CMP      r0,r1                 ;1490
0000be  d108              BNE      |L83.210|
                  |L83.192|
0000c0  4638              MOV      r0,r7                 ;1491
0000c2  f7fffffe          BL       luaK_jump
0000c6  4680              MOV      r8,r0                 ;1491
0000c8  4642              MOV      r2,r8                 ;1491
0000ca  4631              MOV      r1,r6                 ;1491
0000cc  4638              MOV      r0,r7                 ;1491
0000ce  f7fffffe          BL       luaK_concat
                  |L83.210|
0000d2  4629              MOV      r1,r5                 ;1492
0000d4  4638              MOV      r0,r7                 ;1492
0000d6  f7fffffe          BL       luaK_patchtohere
0000da  bf00              NOP      
0000dc  e7cf              B        |L83.126|
;;;1494   
                          ENDP


                          AREA ||i.testnext||, CODE, READONLY, ALIGN=1

                  testnext PROC
;;;91     
;;;92     static int testnext (LexState *ls, int c) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;93       if (ls->t.token == c) {
000006  6920              LDR      r0,[r4,#0x10]
000008  42a8              CMP      r0,r5
00000a  d104              BNE      |L84.22|
;;;94         luaX_next(ls);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       luaX_next
;;;95         return 1;
000012  2001              MOVS     r0,#1
                  |L84.20|
;;;96       }
;;;97       else return 0;
;;;98     }
000014  bd70              POP      {r4-r6,pc}
                  |L84.22|
000016  2000              MOVS     r0,#0                 ;97
000018  e7fc              B        |L84.20|
;;;99     
                          ENDP


                          AREA ||i.undefgoto||, CODE, READONLY, ALIGN=2

                  undefgoto PROC
;;;469    */
;;;470    static l_noret undefgoto (LexState *ls, Labeldesc *gt) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;471      const char *msg = "no visible label '%s' for <goto> at line %d";
000006  a607              ADR      r6,|L85.36|
;;;472      msg = luaO_pushfstring(ls->L, msg, getstr(gt->name), gt->line);
000008  6821              LDR      r1,[r4,#0]
00000a  f1010210          ADD      r2,r1,#0x10
00000e  68a3              LDR      r3,[r4,#8]
000010  4631              MOV      r1,r6
000012  6b68              LDR      r0,[r5,#0x34]
000014  f7fffffe          BL       luaO_pushfstring
000018  4606              MOV      r6,r0
;;;473      luaK_semerror(ls, msg);
00001a  4631              MOV      r1,r6
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       luaK_semerror
;;;474    }
000022  bd70              POP      {r4-r6,pc}
;;;475    
                          ENDP

                  |L85.36|
000024  6e6f2076          DCB      "no visible label '%s' for <goto> at line %d",0
000028  69736962
00002c  6c65206c
000030  6162656c
000034  20272573
000038  2720666f
00003c  72203c67
000040  6f746f3e
000044  20617420
000048  6c696e65
00004c  20256400

                          AREA ||i.whilestat||, CODE, READONLY, ALIGN=1

                  whilestat PROC
;;;1273   
;;;1274   static void whilestat (LexState *ls, int line) {
000000  e92d43f0          PUSH     {r4-r9,lr}
000004  b085              SUB      sp,sp,#0x14
000006  4604              MOV      r4,r0
000008  460d              MOV      r5,r1
;;;1275     /* whilestat -> WHILE cond DO block END */
;;;1276     FuncState *fs = ls->fs;
00000a  6b26              LDR      r6,[r4,#0x30]
;;;1277     int whileinit;
;;;1278     int condexit;
;;;1279     BlockCnt bl;
;;;1280     luaX_next(ls);  /* skip WHILE */
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       luaX_next
;;;1281     whileinit = luaK_getlabel(fs);
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       luaK_getlabel
000018  4607              MOV      r7,r0
;;;1282     condexit = cond(ls);
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       cond
000020  4680              MOV      r8,r0
;;;1283     enterblock(fs, &bl, 1);
000022  2201              MOVS     r2,#1
000024  4669              MOV      r1,sp
000026  4630              MOV      r0,r6
000028  f7fffffe          BL       enterblock
;;;1284     checknext(ls, TK_DO);
00002c  f2401103          MOV      r1,#0x103
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       checknext
;;;1285     block(ls);
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       block
;;;1286     luaK_jumpto(fs, whileinit);
00003c  4630              MOV      r0,r6
00003e  f7fffffe          BL       luaK_jump
000042  4681              MOV      r9,r0
000044  463a              MOV      r2,r7
000046  4649              MOV      r1,r9
000048  4630              MOV      r0,r6
00004a  f7fffffe          BL       luaK_patchlist
;;;1287     check_match(ls, TK_END, TK_WHILE, line);
00004e  462b              MOV      r3,r5
000050  f2401217          MOV      r2,#0x117
000054  f44f7183          MOV      r1,#0x106
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       check_match
;;;1288     leaveblock(fs);
00005e  4630              MOV      r0,r6
000060  f7fffffe          BL       leaveblock
;;;1289     luaK_patchtohere(fs, condexit);  /* false conditions finish the loop */
000064  4641              MOV      r1,r8
000066  4630              MOV      r0,r6
000068  f7fffffe          BL       luaK_patchtohere
;;;1290   }
00006c  b005              ADD      sp,sp,#0x14
00006e  e8bd83f0          POP      {r4-r9,pc}
;;;1291   
                          ENDP


                          AREA ||i.yindex||, CODE, READONLY, ALIGN=1

                  yindex PROC
;;;623    
;;;624    static void yindex (LexState *ls, expdesc *v) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;625      /* index -> '[' expr ']' */
;;;626      luaX_next(ls);  /* skip the '[' */
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       luaX_next
;;;627      expr(ls, v);
00000c  4629              MOV      r1,r5
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       expr
;;;628      luaK_exp2val(ls->fs, v);
000014  4629              MOV      r1,r5
000016  6b20              LDR      r0,[r4,#0x30]
000018  f7fffffe          BL       luaK_exp2val
;;;629      checknext(ls, ']');
00001c  215d              MOVS     r1,#0x5d
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       checknext
;;;630    }
000024  bd70              POP      {r4-r6,pc}
;;;631    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  priority
000000  0a0a0a0a          DCB      0x0a,0x0a,0x0a,0x0a
000004  0b0b0b0b          DCB      0x0b,0x0b,0x0b,0x0b
000008  0e0d0b0b          DCB      0x0e,0x0d,0x0b,0x0b
00000c  0b0b0606          DCB      0x0b,0x0b,0x06,0x06
000010  04040505          DCB      0x04,0x04,0x05,0x05
000014  07070707          DCB      0x07,0x07,0x07,0x07
000018  09080303          DCB      0x09,0x08,0x03,0x03
00001c  03030303          DCB      0x03,0x03,0x03,0x03
000020  03030303          DCB      0x03,0x03,0x03,0x03
000024  03030202          DCB      0x03,0x03,0x02,0x02
000028  0101              DCB      0x01,0x01
